<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ParScanThreadState.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,10 +22,11 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1Analytics.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,11 +48,11 @@</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/pair.hpp&quot;
  
<span class="udiff-line-modified-removed">- G1Policy::G1Policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer) :</span>
<span class="udiff-line-modified-added">+ G1Policy::G1Policy(STWGCTimer* gc_timer) :</span>
    _predictor(G1ConfidencePercent / 100.0),
    _analytics(new G1Analytics(&amp;_predictor)),
    _remset_tracker(),
    _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
    _ihop_control(create_ihop_control(&amp;_predictor)),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59,23 +60,26 @@</span>
    _full_collection_start_sec(0.0),
    _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
    _young_list_target_length(0),
    _young_list_fixed_length(0),
    _young_list_max_length(0),
<span class="udiff-line-modified-removed">-   _short_lived_surv_rate_group(new SurvRateGroup()),</span>
<span class="udiff-line-modified-removed">-   _survivor_surv_rate_group(new SurvRateGroup()),</span>
<span class="udiff-line-modified-added">+   _eden_surv_rate_group(new G1SurvRateGroup()),</span>
<span class="udiff-line-modified-added">+   _survivor_surv_rate_group(new G1SurvRateGroup()),</span>
    _reserve_factor((double) G1ReservePercent / 100.0),
    _reserve_regions(0),
<span class="udiff-line-modified-removed">-   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer(policy)),</span>
<span class="udiff-line-modified-added">+   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),</span>
    _free_regions_at_end_of_collection(0),
<span class="udiff-line-modified-removed">-   _max_rs_lengths(0),</span>
<span class="udiff-line-modified-removed">-   _rs_lengths_prediction(0),</span>
<span class="udiff-line-modified-removed">-   _pending_cards(0),</span>
<span class="udiff-line-modified-added">+   _rs_length(0),</span>
<span class="udiff-line-modified-added">+   _rs_length_prediction(0),</span>
<span class="udiff-line-modified-added">+   _pending_cards_at_gc_start(0),</span>
<span class="udiff-line-added">+   _pending_cards_at_prev_gc_end(0),</span>
<span class="udiff-line-added">+   _total_mutator_refined_cards(0),</span>
<span class="udiff-line-added">+   _total_concurrent_refined_cards(0),</span>
<span class="udiff-line-added">+   _total_concurrent_refinement_time(),</span>
    _bytes_allocated_in_old_since_last_gc(0),
    _initial_mark_to_mixed(),
    _collection_set(NULL),
<span class="udiff-line-removed">-   _bytes_copied_during_gc(0),</span>
    _g1h(NULL),
    _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
    _mark_remark_start_sec(0),
    _mark_cleanup_start_sec(0),
    _tenuring_threshold(MaxTenuringThreshold),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,15 +91,15 @@</span>
  G1Policy::~G1Policy() {
    delete _ihop_control;
    delete _young_gen_sizer;
  }
  
<span class="udiff-line-modified-removed">- G1Policy* G1Policy::create_policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer_stw) {</span>
<span class="udiff-line-modified-removed">-   if (policy-&gt;is_heterogeneous_heap()) {</span>
<span class="udiff-line-modified-removed">-     return new G1HeterogeneousHeapPolicy(policy, gc_timer_stw);</span>
<span class="udiff-line-modified-added">+ G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {</span>
<span class="udiff-line-modified-added">+   if (G1Arguments::is_heterogeneous_heap()) {</span>
<span class="udiff-line-modified-added">+     return new G1HeterogeneousHeapPolicy(gc_timer_stw);</span>
    } else {
<span class="udiff-line-modified-removed">-     return new G1Policy(policy, gc_timer_stw);</span>
<span class="udiff-line-modified-added">+     return new G1Policy(gc_timer_stw);</span>
    }
  }
  
  G1CollectorState* G1Policy::collector_state() const { return _g1h-&gt;collector_state(); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,11 +107,11 @@</span>
    _g1h = g1h;
    _collection_set = collection_set;
  
    assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
  
<span class="udiff-line-modified-removed">-   if (!adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-added">+   if (!use_adaptive_young_list_length()) {</span>
      _young_list_fixed_length = _young_gen_sizer-&gt;min_desired_young_length();
    }
    _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,23 +125,20 @@</span>
  void G1Policy::note_gc_start() {
    phase_times()-&gt;note_gc_start();
  }
  
  class G1YoungLengthPredictor {
<span class="udiff-line-removed">-   const bool _during_cm;</span>
    const double _base_time_ms;
    const double _base_free_regions;
    const double _target_pause_time_ms;
    const G1Policy* const _policy;
  
   public:
<span class="udiff-line-modified-removed">-   G1YoungLengthPredictor(bool during_cm,</span>
<span class="udiff-line-removed">-                          double base_time_ms,</span>
<span class="udiff-line-modified-added">+   G1YoungLengthPredictor(double base_time_ms,</span>
                           double base_free_regions,
                           double target_pause_time_ms,
                           const G1Policy* policy) :
<span class="udiff-line-removed">-     _during_cm(during_cm),</span>
      _base_time_ms(base_time_ms),
      _base_free_regions(base_free_regions),
      _target_pause_time_ms(target_pause_time_ms),
      _policy(policy) {}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -145,15 +146,12 @@</span>
      if (young_length &gt;= _base_free_regions) {
        // end condition 1: not enough space for the young regions
        return false;
      }
  
<span class="udiff-line-modified-removed">-     const double accum_surv_rate = _policy-&gt;accum_yg_surv_rate_pred((int) young_length - 1);</span>
<span class="udiff-line-modified-removed">-     const size_t bytes_to_copy =</span>
<span class="udiff-line-removed">-                  (size_t) (accum_surv_rate * (double) HeapRegion::GrainBytes);</span>
<span class="udiff-line-removed">-     const double copy_time_ms =</span>
<span class="udiff-line-removed">-       _policy-&gt;analytics()-&gt;predict_object_copy_time_ms(bytes_to_copy, _during_cm);</span>
<span class="udiff-line-modified-added">+     size_t bytes_to_copy = 0;</span>
<span class="udiff-line-modified-added">+     const double copy_time_ms = _policy-&gt;predict_eden_copy_time_ms(young_length, &amp;bytes_to_copy);</span>
      const double young_other_time_ms = _policy-&gt;analytics()-&gt;predict_young_other_time_ms(young_length);
      const double pause_time_ms = _base_time_ms + copy_time_ms + young_other_time_ms;
      if (pause_time_ms &gt; _target_pause_time_ms) {
        // end condition 2: prediction is over the target pause time
        return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,11 +191,11 @@</span>
    _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
  }
  
  uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {
    uint desired_min_length = 0;
<span class="udiff-line-modified-removed">-   if (adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-added">+   if (use_adaptive_young_list_length()) {</span>
      if (_analytics-&gt;num_alloc_rate_ms() &gt; 3) {
        double now_sec = os::elapsedTime();
        double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;
        double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();
        desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -216,27 +214,27 @@</span>
    // effectively don&#39;t set this bound.
    return _young_gen_sizer-&gt;max_desired_young_length();
  }
  
  uint G1Policy::update_young_list_max_and_target_length() {
<span class="udiff-line-modified-removed">-   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_lengths());</span>
<span class="udiff-line-modified-added">+   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_length());</span>
  }
  
<span class="udiff-line-modified-removed">- uint G1Policy::update_young_list_max_and_target_length(size_t rs_lengths) {</span>
<span class="udiff-line-modified-removed">-   uint unbounded_target_length = update_young_list_target_length(rs_lengths);</span>
<span class="udiff-line-modified-added">+ uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {</span>
<span class="udiff-line-modified-added">+   uint unbounded_target_length = update_young_list_target_length(rs_length);</span>
    update_max_gc_locker_expansion();
    return unbounded_target_length;
  }
  
<span class="udiff-line-modified-removed">- uint G1Policy::update_young_list_target_length(size_t rs_lengths) {</span>
<span class="udiff-line-modified-removed">-   YoungTargetLengths young_lengths = young_list_target_lengths(rs_lengths);</span>
<span class="udiff-line-modified-added">+ uint G1Policy::update_young_list_target_length(size_t rs_length) {</span>
<span class="udiff-line-modified-added">+   YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);</span>
    _young_list_target_length = young_lengths.first;
  
    return young_lengths.second;
  }
  
<span class="udiff-line-modified-removed">- G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_lengths) const {</span>
<span class="udiff-line-modified-added">+ G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {</span>
    YoungTargetLengths result;
  
    // Calculate the absolute and desired min bounds first.
  
    // This is how many young regions we already have (currently: the survivors).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,14 +248,14 @@</span>
    // Calculate the absolute and desired max bounds.
  
    uint desired_max_length = calculate_young_list_desired_max_length();
  
    uint young_list_target_length = 0;
<span class="udiff-line-modified-removed">-   if (adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-added">+   if (use_adaptive_young_list_length()) {</span>
      if (collector_state()-&gt;in_young_only_phase()) {
        young_list_target_length =
<span class="udiff-line-modified-removed">-                         calculate_young_list_target_length(rs_lengths,</span>
<span class="udiff-line-modified-added">+                         calculate_young_list_target_length(rs_length,</span>
                                                             base_min_length,
                                                             desired_min_length,
                                                             desired_max_length);
      } else {
        // Don&#39;t calculate anything and let the code below bound it to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -297,16 +295,15 @@</span>
  
    result.first = young_list_target_length;
    return result;
  }
  
<span class="udiff-line-modified-removed">- uint</span>
<span class="udiff-line-modified-removed">- G1Policy::calculate_young_list_target_length(size_t rs_lengths,</span>
<span class="udiff-line-modified-removed">-                                                     uint base_min_length,</span>
<span class="udiff-line-modified-removed">-                                                     uint desired_min_length,</span>
<span class="udiff-line-modified-removed">-                                                     uint desired_max_length) const {</span>
<span class="udiff-line-removed">-   assert(adaptive_young_list_length(), &quot;pre-condition&quot;);</span>
<span class="udiff-line-modified-added">+ uint G1Policy::calculate_young_list_target_length(size_t rs_length,</span>
<span class="udiff-line-modified-added">+                                                   uint base_min_length,</span>
<span class="udiff-line-modified-added">+                                                   uint desired_min_length,</span>
<span class="udiff-line-modified-added">+                                                   uint desired_max_length) const {</span>
<span class="udiff-line-modified-added">+   assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);</span>
    assert(collector_state()-&gt;in_young_only_phase(), &quot;only call this for young GCs&quot;);
  
    // In case some edge-condition makes the desired max length too small...
    if (desired_max_length &lt;= desired_min_length) {
      return desired_min_length;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -321,26 +318,20 @@</span>
    uint min_young_length = desired_min_length - base_min_length;
    assert(desired_max_length &gt; base_min_length, &quot;invariant&quot;);
    uint max_young_length = desired_max_length - base_min_length;
  
    const double target_pause_time_ms = _mmu_tracker-&gt;max_gc_time() * 1000.0;
<span class="udiff-line-removed">-   const double survivor_regions_evac_time = predict_survivor_regions_evac_time();</span>
    const size_t pending_cards = _analytics-&gt;predict_pending_cards();
<span class="udiff-line-modified-removed">-   const size_t adj_rs_lengths = rs_lengths + _analytics-&gt;predict_rs_length_diff();</span>
<span class="udiff-line-removed">-   const size_t scanned_cards = _analytics-&gt;predict_card_num(adj_rs_lengths, true /* for_young_gc */);</span>
<span class="udiff-line-removed">-   const double base_time_ms =</span>
<span class="udiff-line-removed">-     predict_base_elapsed_time_ms(pending_cards, scanned_cards) +</span>
<span class="udiff-line-removed">-     survivor_regions_evac_time;</span>
<span class="udiff-line-modified-added">+   const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);</span>
    const uint available_free_regions = _free_regions_at_end_of_collection;
    const uint base_free_regions =
      available_free_regions &gt; _reserve_regions ? available_free_regions - _reserve_regions : 0;
  
    // Here, we will make sure that the shortest young length that
    // makes sense fits within the target pause time.
  
<span class="udiff-line-modified-removed">-   G1YoungLengthPredictor p(collector_state()-&gt;mark_or_rebuild_in_progress(),</span>
<span class="udiff-line-removed">-                            base_time_ms,</span>
<span class="udiff-line-modified-added">+   G1YoungLengthPredictor p(base_time_ms,</span>
                             base_free_regions,
                             target_pause_time_ms,
                             this);
    if (p.will_fit(min_young_length)) {
      // The shortest young length will fit into the target pause time;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,47 +393,47 @@</span>
  }
  
  double G1Policy::predict_survivor_regions_evac_time() const {
    double survivor_regions_evac_time = 0.0;
    const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
<span class="udiff-line-removed">- </span>
    for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivor_regions-&gt;begin();
         it != survivor_regions-&gt;end();
         ++it) {
<span class="udiff-line-modified-removed">-     survivor_regions_evac_time += predict_region_elapsed_time_ms(*it, collector_state()-&gt;in_young_only_phase());</span>
<span class="udiff-line-modified-added">+     survivor_regions_evac_time += predict_region_total_time_ms(*it, collector_state()-&gt;in_young_only_phase());</span>
    }
    return survivor_regions_evac_time;
  }
  
<span class="udiff-line-modified-removed">- void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_lengths) {</span>
<span class="udiff-line-modified-removed">-   guarantee( adaptive_young_list_length(), &quot;should not call this otherwise&quot; );</span>
<span class="udiff-line-modified-added">+ void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_length) {</span>
<span class="udiff-line-modified-added">+   guarantee(use_adaptive_young_list_length(), &quot;should not call this otherwise&quot; );</span>
  
<span class="udiff-line-modified-removed">-   if (rs_lengths &gt; _rs_lengths_prediction) {</span>
<span class="udiff-line-modified-added">+   if (rs_length &gt; _rs_length_prediction) {</span>
      // add 10% to avoid having to recalculate often
<span class="udiff-line-modified-removed">-     size_t rs_lengths_prediction = rs_lengths * 1100 / 1000;</span>
<span class="udiff-line-modified-removed">-     update_rs_lengths_prediction(rs_lengths_prediction);</span>
<span class="udiff-line-modified-added">+     size_t rs_length_prediction = rs_length * 1100 / 1000;</span>
<span class="udiff-line-modified-added">+     update_rs_length_prediction(rs_length_prediction);</span>
  
<span class="udiff-line-modified-removed">-     update_young_list_max_and_target_length(rs_lengths_prediction);</span>
<span class="udiff-line-modified-added">+     update_young_list_max_and_target_length(rs_length_prediction);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void G1Policy::update_rs_lengths_prediction() {</span>
<span class="udiff-line-modified-removed">-   update_rs_lengths_prediction(_analytics-&gt;predict_rs_lengths());</span>
<span class="udiff-line-modified-added">+ void G1Policy::update_rs_length_prediction() {</span>
<span class="udiff-line-modified-added">+   update_rs_length_prediction(_analytics-&gt;predict_rs_length());</span>
  }
  
<span class="udiff-line-modified-removed">- void G1Policy::update_rs_lengths_prediction(size_t prediction) {</span>
<span class="udiff-line-modified-removed">-   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-removed">-     _rs_lengths_prediction = prediction;</span>
<span class="udiff-line-modified-added">+ void G1Policy::update_rs_length_prediction(size_t prediction) {</span>
<span class="udiff-line-modified-added">+   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-added">+     _rs_length_prediction = prediction;</span>
    }
  }
  
  void G1Policy::record_full_collection_start() {
    _full_collection_start_sec = os::elapsedTime();
    // Release the future to-space so that it is available for compaction into.
    collector_state()-&gt;set_in_young_only_phase(false);
    collector_state()-&gt;set_in_full_gc(true);
    _collection_set-&gt;clear_candidates();
<span class="udiff-line-added">+   record_concurrent_refinement_data(true /* is_full_collection */);</span>
  }
  
  void G1Policy::record_full_collection_end() {
    // Consider this like a collection pause for the purposes of allocation
    // since last pause.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -461,46 +452,97 @@</span>
    collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
    collector_state()-&gt;set_in_initial_mark_gc(false);
    collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
    collector_state()-&gt;set_clearing_next_bitmap(false);
  
<span class="udiff-line-modified-removed">-   _short_lived_surv_rate_group-&gt;start_adding_regions();</span>
<span class="udiff-line-modified-added">+   _eden_surv_rate_group-&gt;start_adding_regions();</span>
    // also call this on any additional surv rate groups
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
<span class="udiff-line-removed">-   // Reset survivors SurvRateGroup.</span>
    _survivor_surv_rate_group-&gt;reset();
    update_young_list_max_and_target_length();
<span class="udiff-line-modified-removed">-   update_rs_lengths_prediction();</span>
<span class="udiff-line-modified-added">+   update_rs_length_prediction();</span>
<span class="udiff-line-added">+   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
  
    _bytes_allocated_in_old_since_last_gc = 0;
  
    record_pause(FullGC, _full_collection_start_sec, end_sec);
  }
  
<span class="udiff-line-added">+ void G1Policy::record_concurrent_refinement_data(bool is_full_collection) {</span>
<span class="udiff-line-added">+   _pending_cards_at_gc_start = _g1h-&gt;pending_card_num();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Record info about concurrent refinement thread processing.</span>
<span class="udiff-line-added">+   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();</span>
<span class="udiff-line-added">+   G1ConcurrentRefine::RefinementStats cr_stats = cr-&gt;total_refinement_stats();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Tickspan cr_time = cr_stats._time - _total_concurrent_refinement_time;</span>
<span class="udiff-line-added">+   _total_concurrent_refinement_time = cr_stats._time;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t cr_cards = cr_stats._cards - _total_concurrent_refined_cards;</span>
<span class="udiff-line-added">+   _total_concurrent_refined_cards = cr_stats._cards;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Don&#39;t update rate if full collection.  We could be in an implicit full</span>
<span class="udiff-line-added">+   // collection after a non-full collection failure, in which case there</span>
<span class="udiff-line-added">+   // wasn&#39;t any mutator/cr-thread activity since last recording.  And if</span>
<span class="udiff-line-added">+   // we&#39;re in an explicit full collection, the time since the last GC can</span>
<span class="udiff-line-added">+   // be arbitrarily short, so not a very good sample.  Similarly, don&#39;t</span>
<span class="udiff-line-added">+   // update the rate if the current sample is empty or time is zero.</span>
<span class="udiff-line-added">+   if (!is_full_collection &amp;&amp; (cr_cards &gt; 0) &amp;&amp; (cr_time &gt; Tickspan())) {</span>
<span class="udiff-line-added">+     double rate = cr_cards / (cr_time.seconds() * MILLIUNITS);</span>
<span class="udiff-line-added">+     _analytics-&gt;report_concurrent_refine_rate_ms(rate);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Record info about mutator thread processing.</span>
<span class="udiff-line-added">+   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-added">+   size_t mut_total_cards = dcqs.total_mutator_refined_cards();</span>
<span class="udiff-line-added">+   size_t mut_cards = mut_total_cards - _total_mutator_refined_cards;</span>
<span class="udiff-line-added">+   _total_mutator_refined_cards = mut_total_cards;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Record mutator&#39;s card logging rate.</span>
<span class="udiff-line-added">+   // Don&#39;t update if full collection; see above.</span>
<span class="udiff-line-added">+   if (!is_full_collection) {</span>
<span class="udiff-line-added">+     size_t total_cards = _pending_cards_at_gc_start + cr_cards + mut_cards;</span>
<span class="udiff-line-added">+     assert(_pending_cards_at_prev_gc_end &lt;= total_cards,</span>
<span class="udiff-line-added">+            &quot;untracked cards: last pending: &quot; SIZE_FORMAT</span>
<span class="udiff-line-added">+            &quot;, pending: &quot; SIZE_FORMAT &quot;, conc refine: &quot; SIZE_FORMAT</span>
<span class="udiff-line-added">+            &quot;, mut refine:&quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+            _pending_cards_at_prev_gc_end, _pending_cards_at_gc_start,</span>
<span class="udiff-line-added">+            cr_cards, mut_cards);</span>
<span class="udiff-line-added">+     size_t logged_cards = total_cards - _pending_cards_at_prev_gc_end;</span>
<span class="udiff-line-added">+     double logging_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="udiff-line-added">+     double logging_end_time = Ticks::now().seconds() * MILLIUNITS;</span>
<span class="udiff-line-added">+     double logging_time = logging_end_time - logging_start_time;</span>
<span class="udiff-line-added">+     // Unlike above for conc-refine rate, here we should not require a</span>
<span class="udiff-line-added">+     // non-empty sample, since an application could go some time with only</span>
<span class="udiff-line-added">+     // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="udiff-line-added">+     // sample periods, as they may just pollute the predictions.</span>
<span class="udiff-line-added">+     if (logging_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="udiff-line-added">+       _analytics-&gt;report_logged_cards_rate_ms(logged_cards / logging_time);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void G1Policy::record_collection_pause_start(double start_time_sec) {
    // We only need to do this here as the policy will only be applied
    // to the GC we&#39;re about to start. so, no point is calculating this
    // every time we calculate / recalculate the target young length.
    update_survivors_policy();
  
    assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
           &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
           max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   assert(_g1h-&gt;used() == _g1h-&gt;recalculate_used(),</span>
<span class="udiff-line-removed">-          &quot;sanity, used: &quot; SIZE_FORMAT &quot; recalculate_used: &quot; SIZE_FORMAT,</span>
<span class="udiff-line-removed">-          _g1h-&gt;used(), _g1h-&gt;recalculate_used());</span>
<span class="udiff-line-modified-added">+   assert_used_and_recalculate_used_equal(_g1h);</span>
  
    phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
<span class="udiff-line-modified-removed">-   _pending_cards = _g1h-&gt;pending_card_num();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   record_concurrent_refinement_data(false /* is_full_collection */);</span>
  
    _collection_set-&gt;reset_bytes_used_before();
<span class="udiff-line-removed">-   _bytes_copied_during_gc = 0;</span>
  
    // do that for any other surv rate groups
<span class="udiff-line-modified-removed">-   _short_lived_surv_rate_group-&gt;stop_adding_regions();</span>
<span class="udiff-line-modified-added">+   _eden_surv_rate_group-&gt;stop_adding_regions();</span>
    _survivors_age_table.clear();
  
    assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -543,11 +585,11 @@</span>
  double G1Policy::other_time_ms(double pause_time_ms) const {
    return pause_time_ms - phase_times()-&gt;cur_collection_par_time_ms();
  }
  
  double G1Policy::constant_other_time_ms(double pause_time_ms) const {
<span class="udiff-line-modified-removed">-   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms();</span>
<span class="udiff-line-modified-added">+   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms() - phase_times()-&gt;total_rebuild_freelist_time_ms();</span>
  }
  
  bool G1Policy::about_to_start_mixed_phase() const {
    return _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle() || collector_state()-&gt;in_young_gc_before_mixed();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,18 +614,30 @@</span>
    }
  
    return result;
  }
  
<span class="udiff-line-added">+ double G1Policy::logged_cards_processing_time() const {</span>
<span class="udiff-line-added">+   double all_cards_processing_time = average_time_ms(G1GCPhaseTimes::ScanHR) + average_time_ms(G1GCPhaseTimes::OptScanHR);</span>
<span class="udiff-line-added">+   size_t logged_dirty_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="udiff-line-added">+   size_t scan_heap_roots_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +</span>
<span class="udiff-line-added">+                                  phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="udiff-line-added">+   // This may happen if there are duplicate cards in different log buffers.</span>
<span class="udiff-line-added">+   if (logged_dirty_cards &gt; scan_heap_roots_cards) {</span>
<span class="udiff-line-added">+     return all_cards_processing_time + average_time_ms(G1GCPhaseTimes::MergeLB);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return (all_cards_processing_time * logged_dirty_cards / scan_heap_roots_cards) + average_time_ms(G1GCPhaseTimes::MergeLB);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Anything below that is considered to be zero
  #define MIN_TIMER_GRANULARITY 0.0000001
  
<span class="udiff-line-modified-removed">- void G1Policy::record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc) {</span>
<span class="udiff-line-modified-added">+ void G1Policy::record_collection_pause_end(double pause_time_ms) {</span>
<span class="udiff-line-added">+   G1GCPhaseTimes* p = phase_times();</span>
<span class="udiff-line-added">+ </span>
    double end_time_sec = os::elapsedTime();
  
<span class="udiff-line-removed">-   size_t cur_used_bytes = _g1h-&gt;used();</span>
<span class="udiff-line-removed">-   assert(cur_used_bytes == _g1h-&gt;recalculate_used(), &quot;It should!&quot;);</span>
    bool this_pause_included_initial_mark = false;
    bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();
  
    bool update_stats = !_g1h-&gt;evacuation_failed();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -642,61 +696,67 @@</span>
        clear_collection_set_candidates();
        maybe_start_marking();
      }
    }
  
<span class="udiff-line-modified-removed">-   _short_lived_surv_rate_group-&gt;start_adding_regions();</span>
<span class="udiff-line-removed">-   // Do that for any other surv rate groups</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   double scan_hcc_time_ms = G1HotCardCache::default_use_cache() ? average_time_ms(G1GCPhaseTimes::ScanHCC) : 0.0;</span>
<span class="udiff-line-modified-added">+   _eden_surv_rate_group-&gt;start_adding_regions();</span>
  
<span class="udiff-line-added">+   double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);</span>
    if (update_stats) {
<span class="udiff-line-modified-removed">-     double cost_per_card_ms = 0.0;</span>
<span class="udiff-line-modified-removed">-     if (_pending_cards &gt; 0) {</span>
<span class="udiff-line-modified-removed">-       cost_per_card_ms = (average_time_ms(G1GCPhaseTimes::UpdateRS)) / (double) _pending_cards;</span>
<span class="udiff-line-modified-removed">-       _analytics-&gt;report_cost_per_card_ms(cost_per_card_ms);</span>
<span class="udiff-line-modified-added">+     size_t const total_log_buffer_cards = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +</span>
<span class="udiff-line-modified-added">+                                           p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="udiff-line-modified-added">+     // Update prediction for card merge; MergeRSDirtyCards includes the cards from the Eager Reclaim phase.</span>
<span class="udiff-line-modified-added">+     size_t const total_cards_merged = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +</span>
<span class="udiff-line-added">+                                       p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +</span>
<span class="udiff-line-added">+                                       total_log_buffer_cards;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // The threshold for the number of cards in a given sampling which we consider</span>
<span class="udiff-line-added">+     // large enough so that the impact from setup and other costs is negligible.</span>
<span class="udiff-line-added">+     size_t const CardsNumSamplingThreshold = 10;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (total_cards_merged &gt; CardsNumSamplingThreshold) {</span>
<span class="udiff-line-added">+       double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +</span>
<span class="udiff-line-added">+                                     average_time_ms(G1GCPhaseTimes::MergeRS) +</span>
<span class="udiff-line-added">+                                     average_time_ms(G1GCPhaseTimes::MergeHCC) +</span>
<span class="udiff-line-added">+                                     average_time_ms(G1GCPhaseTimes::MergeLB) +</span>
<span class="udiff-line-added">+                                     average_time_ms(G1GCPhaseTimes::OptMergeRS);</span>
<span class="udiff-line-added">+       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged, this_pause_was_young_only);</span>
      }
<span class="udiff-line-removed">-     _analytics-&gt;report_cost_scan_hcc(scan_hcc_time_ms);</span>
  
<span class="udiff-line-modified-removed">-     double cost_per_entry_ms = 0.0;</span>
<span class="udiff-line-modified-removed">-     if (cards_scanned &gt; 10) {</span>
<span class="udiff-line-modified-removed">-       cost_per_entry_ms = average_time_ms(G1GCPhaseTimes::ScanRS) / (double) cards_scanned;</span>
<span class="udiff-line-modified-removed">-       _analytics-&gt;report_cost_per_entry_ms(cost_per_entry_ms, this_pause_was_young_only);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     // Update prediction for card scan</span>
<span class="udiff-line-modified-added">+     size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +</span>
<span class="udiff-line-modified-added">+                                        p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (total_cards_scanned &gt; CardsNumSamplingThreshold) {</span>
<span class="udiff-line-added">+       double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +</span>
<span class="udiff-line-added">+                                         average_time_ms(G1GCPhaseTimes::OptScanHR);</span>
  
<span class="udiff-line-modified-removed">-     if (_max_rs_lengths &gt; 0) {</span>
<span class="udiff-line-removed">-       double cards_per_entry_ratio =</span>
<span class="udiff-line-removed">-         (double) cards_scanned / (double) _max_rs_lengths;</span>
<span class="udiff-line-removed">-       _analytics-&gt;report_cards_per_entry_ratio(cards_per_entry_ratio, this_pause_was_young_only);</span>
<span class="udiff-line-modified-added">+       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned, this_pause_was_young_only);</span>
      }
  
<span class="udiff-line-modified-removed">-     // This is defensive. For a while _max_rs_lengths could get</span>
<span class="udiff-line-modified-removed">-     // smaller than _recorded_rs_lengths which was causing</span>
<span class="udiff-line-modified-removed">-     // rs_length_diff to get very large and mess up the RSet length</span>
<span class="udiff-line-modified-removed">-     // predictions. The reason was unsafe concurrent updates to the</span>
<span class="udiff-line-modified-removed">-     // _inc_cset_recorded_rs_lengths field which the code below guards</span>
<span class="udiff-line-modified-removed">-     // against (see CR 7118202). This bug has now been fixed (see CR</span>
<span class="udiff-line-modified-removed">-     // 7119027). However, I&#39;m still worried that</span>
<span class="udiff-line-modified-removed">-     // _inc_cset_recorded_rs_lengths might still end up somewhat</span>
<span class="udiff-line-modified-removed">-     // inaccurate. The concurrent refinement thread calculates an</span>
<span class="udiff-line-modified-removed">-     // RSet&#39;s length concurrently with other CR threads updating it</span>
<span class="udiff-line-removed">-     // which might cause it to calculate the length incorrectly (if,</span>
<span class="udiff-line-removed">-     // say, it&#39;s in mid-coarsening). So I&#39;ll leave in the defensive</span>
<span class="udiff-line-removed">-     // conditional below just in case.</span>
<span class="udiff-line-removed">-     size_t rs_length_diff = 0;</span>
<span class="udiff-line-removed">-     size_t recorded_rs_lengths = _collection_set-&gt;recorded_rs_lengths();</span>
<span class="udiff-line-removed">-     if (_max_rs_lengths &gt; recorded_rs_lengths) {</span>
<span class="udiff-line-removed">-       rs_length_diff = _max_rs_lengths - recorded_rs_lengths;</span>
<span class="udiff-line-modified-added">+     // Update prediction for the ratio between cards from the remembered</span>
<span class="udiff-line-modified-added">+     // sets and actually scanned cards from the remembered sets.</span>
<span class="udiff-line-modified-added">+     // Cards from the remembered sets are all cards not duplicated by cards from</span>
<span class="udiff-line-modified-added">+     // the logs.</span>
<span class="udiff-line-modified-added">+     // Due to duplicates in the log buffers, the number of actually scanned cards</span>
<span class="udiff-line-modified-added">+     // can be smaller than the cards in the log buffers.</span>
<span class="udiff-line-modified-added">+     const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;</span>
<span class="udiff-line-modified-added">+     double merge_to_scan_ratio = 0.0;</span>
<span class="udiff-line-modified-added">+     if (total_cards_scanned &gt; 0) {</span>
<span class="udiff-line-modified-added">+       merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;</span>
      }
<span class="udiff-line-modified-removed">-     _analytics-&gt;report_rs_length_diff((double) rs_length_diff);</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio, this_pause_was_young_only);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();</span>
<span class="udiff-line-added">+     const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;</span>
<span class="udiff-line-added">+     _analytics-&gt;report_rs_length_diff(rs_length_diff);</span>
  
<span class="udiff-line-modified-removed">-     size_t freed_bytes = heap_used_bytes_before_gc - cur_used_bytes;</span>
<span class="udiff-line-modified-removed">-     size_t copied_bytes = _collection_set-&gt;bytes_used_before() - freed_bytes;</span>
<span class="udiff-line-removed">-     double cost_per_byte_ms = 0.0;</span>
<span class="udiff-line-modified-added">+     // Update prediction for copy cost per byte</span>
<span class="udiff-line-modified-added">+     size_t copied_bytes = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergePSS, G1GCPhaseTimes::MergePSSCopiedBytes);</span>
  
      if (copied_bytes &gt; 0) {
<span class="udiff-line-modified-removed">-       cost_per_byte_ms = average_time_ms(G1GCPhaseTimes::ObjCopy) / (double) copied_bytes;</span>
<span class="udiff-line-modified-added">+       double cost_per_byte_ms = (average_time_ms(G1GCPhaseTimes::ObjCopy) + average_time_ms(G1GCPhaseTimes::OptObjCopy)) / copied_bytes;</span>
        _analytics-&gt;report_cost_per_byte_ms(cost_per_byte_ms, collector_state()-&gt;mark_or_rebuild_in_progress());
      }
  
      if (_collection_set-&gt;young_region_length() &gt; 0) {
        _analytics-&gt;report_young_other_cost_per_region_ms(young_other_time_ms() /
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -713,12 +773,12 @@</span>
      // Do not update RS lengths and the number of pending cards with information from mixed gc:
      // these are is wildly different to during young only gc and mess up young gen sizing right
      // after the mixed gc phase.
      // During mixed gc we do not use them for young gen sizing.
      if (this_pause_was_young_only) {
<span class="udiff-line-modified-removed">-       _analytics-&gt;report_pending_cards((double) _pending_cards);</span>
<span class="udiff-line-modified-removed">-       _analytics-&gt;report_rs_lengths((double) _max_rs_lengths);</span>
<span class="udiff-line-modified-added">+       _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);</span>
<span class="udiff-line-modified-added">+       _analytics-&gt;report_rs_length((double) _rs_length);</span>
      }
    }
  
    assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),
           &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -726,11 +786,11 @@</span>
      collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
    }
  
    _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
  
<span class="udiff-line-modified-removed">-   update_rs_lengths_prediction();</span>
<span class="udiff-line-modified-added">+   update_rs_length_prediction();</span>
  
    // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
    // that in this case we are not running in a &quot;normal&quot; operating mode.
    if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
      // IHOP control wants to know the expected young gen length if it were not
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,24 +815,31 @@</span>
      // the mark start being too late.
      _initial_mark_to_mixed.reset();
    }
  
    // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
<span class="udiff-line-modified-removed">-   double update_rs_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;</span>
<span class="udiff-line-modified-added">+   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;</span>
  
<span class="udiff-line-modified-removed">-   if (update_rs_time_goal_ms &lt; scan_hcc_time_ms) {</span>
<span class="udiff-line-modified-added">+   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {</span>
      log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
<span class="udiff-line-modified-removed">-                                 &quot;Update RS time goal: %1.2fms Scan HCC time: %1.2fms&quot;,</span>
<span class="udiff-line-modified-removed">-                                 update_rs_time_goal_ms, scan_hcc_time_ms);</span>
<span class="udiff-line-modified-added">+                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,</span>
<span class="udiff-line-modified-added">+                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);</span>
  
<span class="udiff-line-modified-removed">-     update_rs_time_goal_ms = 0;</span>
<span class="udiff-line-modified-added">+     scan_logged_cards_time_goal_ms = 0;</span>
    } else {
<span class="udiff-line-modified-removed">-     update_rs_time_goal_ms -= scan_hcc_time_ms;</span>
<span class="udiff-line-modified-added">+     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;</span>
    }
<span class="udiff-line-modified-removed">-   _g1h-&gt;concurrent_refine()-&gt;adjust(average_time_ms(G1GCPhaseTimes::UpdateRS),</span>
<span class="udiff-line-modified-removed">-                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::UpdateRS),</span>
<span class="udiff-line-modified-removed">-                                     update_rs_time_goal_ms);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
<span class="udiff-line-modified-added">+   double const logged_cards_time = logged_cards_processing_time();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,</span>
<span class="udiff-line-added">+                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,</span>
<span class="udiff-line-added">+                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),</span>
<span class="udiff-line-added">+                                     scan_logged_cards_time_goal_ms);</span>
  }
  
  G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
    if (G1UseAdaptiveIHOP) {
      return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -829,62 +896,59 @@</span>
  
  void G1Policy::print_phases() {
    phase_times()-&gt;print();
  }
  
<span class="udiff-line-removed">- double G1Policy::predict_yg_surv_rate(int age, SurvRateGroup* surv_rate_group) const {</span>
<span class="udiff-line-removed">-   TruncatedSeq* seq = surv_rate_group-&gt;get_seq(age);</span>
<span class="udiff-line-removed">-   guarantee(seq-&gt;num() &gt; 0, &quot;There should be some young gen survivor samples available. Tried to access with age %d&quot;, age);</span>
<span class="udiff-line-removed">-   double pred = _predictor.get_new_prediction(seq);</span>
<span class="udiff-line-removed">-   if (pred &gt; 1.0) {</span>
<span class="udiff-line-removed">-     pred = 1.0;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return pred;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- double G1Policy::accum_yg_surv_rate_pred(int age) const {</span>
<span class="udiff-line-removed">-   return _short_lived_surv_rate_group-&gt;accum_surv_rate_pred(age);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,
<span class="udiff-line-modified-removed">-                                               size_t scanned_cards) const {</span>
<span class="udiff-line-modified-added">+                                               size_t rs_length) const {</span>
<span class="udiff-line-added">+   size_t effective_scanned_cards = _analytics-&gt;predict_scan_card_num(rs_length, collector_state()-&gt;in_young_only_phase());</span>
    return
<span class="udiff-line-modified-removed">-     _analytics-&gt;predict_rs_update_time_ms(pending_cards) +</span>
<span class="udiff-line-modified-removed">-     _analytics-&gt;predict_rs_scan_time_ms(scanned_cards, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="udiff-line-modified-removed">-     _analytics-&gt;predict_constant_other_time_ms();</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;predict_card_merge_time_ms(pending_cards + rs_length, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;predict_card_scan_time_ms(effective_scanned_cards, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;predict_constant_other_time_ms() +</span>
<span class="udiff-line-added">+     predict_survivor_regions_evac_time();</span>
  }
  
  double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
<span class="udiff-line-modified-removed">-   size_t rs_length = _analytics-&gt;predict_rs_lengths() + _analytics-&gt;predict_rs_length_diff();</span>
<span class="udiff-line-modified-removed">-   size_t card_num = _analytics-&gt;predict_card_num(rs_length, collector_state()-&gt;in_young_only_phase());</span>
<span class="udiff-line-removed">-   return predict_base_elapsed_time_ms(pending_cards, card_num);</span>
<span class="udiff-line-modified-added">+   size_t rs_length = _analytics-&gt;predict_rs_length();</span>
<span class="udiff-line-modified-added">+   return predict_base_elapsed_time_ms(pending_cards, rs_length);</span>
  }
  
  size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {
    size_t bytes_to_copy;
    if (!hr-&gt;is_young()) {
      bytes_to_copy = hr-&gt;max_live_bytes();
    } else {
<span class="udiff-line-modified-removed">-     assert(hr-&gt;age_in_surv_rate_group() != -1, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     int age = hr-&gt;age_in_surv_rate_group();</span>
<span class="udiff-line-removed">-     double yg_surv_rate = predict_yg_surv_rate(age, hr-&gt;surv_rate_group());</span>
<span class="udiff-line-removed">-     bytes_to_copy = (size_t) (hr-&gt;used() * yg_surv_rate);</span>
<span class="udiff-line-modified-added">+     bytes_to_copy = (size_t) (hr-&gt;used() * hr-&gt;surv_rate_prediction(_predictor));</span>
    }
    return bytes_to_copy;
  }
  
<span class="udiff-line-modified-removed">- double G1Policy::predict_region_elapsed_time_ms(HeapRegion* hr,</span>
<span class="udiff-line-modified-removed">-                                                 bool for_young_gc) const {</span>
<span class="udiff-line-modified-added">+ double G1Policy::predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy) const {</span>
<span class="udiff-line-modified-added">+   if (count == 0) {</span>
<span class="udiff-line-added">+     return 0.0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   size_t const expected_bytes = _eden_surv_rate_group-&gt;accum_surv_rate_pred(count) * HeapRegion::GrainBytes;</span>
<span class="udiff-line-added">+   if (bytes_to_copy != NULL) {</span>
<span class="udiff-line-added">+     *bytes_to_copy = expected_bytes;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return _analytics-&gt;predict_object_copy_time_ms(expected_bytes, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ double G1Policy::predict_region_copy_time_ms(HeapRegion* hr) const {</span>
<span class="udiff-line-added">+   size_t const bytes_to_copy = predict_bytes_to_copy(hr);</span>
<span class="udiff-line-added">+   return _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,</span>
<span class="udiff-line-added">+                                                  bool for_young_gc) const {</span>
    size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="udiff-line-modified-removed">-   // Predicting the number of cards is based on which type of GC</span>
<span class="udiff-line-removed">-   // we&#39;re predicting for.</span>
<span class="udiff-line-removed">-   size_t card_num = _analytics-&gt;predict_card_num(rs_length, for_young_gc);</span>
<span class="udiff-line-removed">-   size_t bytes_to_copy = predict_bytes_to_copy(hr);</span>
<span class="udiff-line-modified-added">+   size_t scan_card_num = _analytics-&gt;predict_scan_card_num(rs_length, for_young_gc);</span>
  
    double region_elapsed_time_ms =
<span class="udiff-line-modified-removed">-     _analytics-&gt;predict_rs_scan_time_ms(card_num, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="udiff-line-modified-removed">-     _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;predict_card_merge_time_ms(rs_length, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="udiff-line-modified-added">+     _analytics-&gt;predict_card_scan_time_ms(scan_card_num, collector_state()-&gt;in_young_only_phase());</span>
  
    // The prediction of the &quot;other&quot; time for this region is based
    // upon the region type and NOT the GC type.
    if (hr-&gt;is_young()) {
      region_elapsed_time_ms += _analytics-&gt;predict_young_other_time_ms(1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -892,10 +956,14 @@</span>
      region_elapsed_time_ms += _analytics-&gt;predict_non_young_other_time_ms(1);
    }
    return region_elapsed_time_ms;
  }
  
<span class="udiff-line-added">+ double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const {</span>
<span class="udiff-line-added">+   return predict_region_non_copy_time_ms(hr, for_young_gc) + predict_region_copy_time_ms(hr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool G1Policy::should_allocate_mutator_region() const {
    uint young_list_length = _g1h-&gt;young_regions_count();
    uint young_list_target_length = _young_list_target_length;
    return young_list_length &lt; young_list_target_length;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -904,12 +972,12 @@</span>
    uint young_list_length = _g1h-&gt;young_regions_count();
    uint young_list_max_length = _young_list_max_length;
    return young_list_length &lt; young_list_max_length;
  }
  
<span class="udiff-line-modified-removed">- bool G1Policy::adaptive_young_list_length() const {</span>
<span class="udiff-line-modified-removed">-   return _young_gen_sizer-&gt;adaptive_young_list_length();</span>
<span class="udiff-line-modified-added">+ bool G1Policy::use_adaptive_young_list_length() const {</span>
<span class="udiff-line-modified-added">+   return _young_gen_sizer-&gt;use_adaptive_young_list_length();</span>
  }
  
  size_t G1Policy::desired_survivor_size(uint max_regions) const {
    size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;
    return (size_t)((((double)survivor_capacity) * TargetSurvivorRatio) / 100);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1186,20 +1254,143 @@</span>
      result += 1;
    }
    return (uint) result;
  }
  
<span class="udiff-line-modified-removed">- void G1Policy::finalize_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {</span>
<span class="udiff-line-modified-removed">-   double time_remaining_ms = _collection_set-&gt;finalize_young_part(target_pause_time_ms, survivor);</span>
<span class="udiff-line-modified-removed">-   _collection_set-&gt;finalize_old_part(time_remaining_ms);</span>
<span class="udiff-line-modified-added">+ void G1Policy::calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="udiff-line-modified-added">+                                                     double time_remaining_ms,</span>
<span class="udiff-line-modified-added">+                                                     uint&amp; num_initial_regions,</span>
<span class="udiff-line-added">+                                                     uint&amp; num_optional_regions) {</span>
<span class="udiff-line-added">+   assert(candidates != NULL, &quot;Must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   num_initial_regions = 0;</span>
<span class="udiff-line-added">+   num_optional_regions = 0;</span>
<span class="udiff-line-added">+   uint num_expensive_regions = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double predicted_old_time_ms = 0.0;</span>
<span class="udiff-line-added">+   double predicted_initial_time_ms = 0.0;</span>
<span class="udiff-line-added">+   double predicted_optional_time_ms = 0.0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const uint min_old_cset_length = calc_min_old_cset_length();</span>
<span class="udiff-line-added">+   const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());</span>
<span class="udiff-line-added">+   const uint max_optional_regions = max_old_cset_length - min_old_cset_length;</span>
<span class="udiff-line-added">+   bool check_time_remaining = use_adaptive_young_list_length();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint candidate_idx = candidates-&gt;cur_idx();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(gc, ergo, cset)(&quot;Start adding old regions to collection set. Min %u regions, max %u regions, &quot;</span>
<span class="udiff-line-added">+                             &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,</span>
<span class="udiff-line-added">+                             min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapRegion* hr = candidates-&gt;at(candidate_idx);</span>
<span class="udiff-line-added">+   while (hr != NULL) {</span>
<span class="udiff-line-added">+     if (num_initial_regions + num_optional_regions &gt;= max_old_cset_length) {</span>
<span class="udiff-line-added">+       // Added maximum number of old regions to the CSet.</span>
<span class="udiff-line-added">+       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Maximum number of regions). &quot;</span>
<span class="udiff-line-added">+                                 &quot;Initial %u regions, optional %u regions&quot;,</span>
<span class="udiff-line-added">+                                 num_initial_regions, num_optional_regions);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Stop adding regions if the remaining reclaimable space is</span>
<span class="udiff-line-added">+     // not above G1HeapWastePercent.</span>
<span class="udiff-line-added">+     size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();</span>
<span class="udiff-line-added">+     double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);</span>
<span class="udiff-line-added">+     double threshold = (double) G1HeapWastePercent;</span>
<span class="udiff-line-added">+     if (reclaimable_percent &lt;= threshold) {</span>
<span class="udiff-line-added">+       // We&#39;ve added enough old regions that the amount of uncollected</span>
<span class="udiff-line-added">+       // reclaimable space is at or below the waste threshold. Stop</span>
<span class="udiff-line-added">+       // adding old regions to the CSet.</span>
<span class="udiff-line-added">+       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Reclaimable percentage below threshold). &quot;</span>
<span class="udiff-line-added">+                                 &quot;Reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,</span>
<span class="udiff-line-added">+                                 byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),</span>
<span class="udiff-line-added">+                                 reclaimable_percent, G1HeapWastePercent);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     double predicted_time_ms = predict_region_total_time_ms(hr, false);</span>
<span class="udiff-line-added">+     time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);</span>
<span class="udiff-line-added">+     // Add regions to old set until we reach the minimum amount</span>
<span class="udiff-line-added">+     if (num_initial_regions &lt; min_old_cset_length) {</span>
<span class="udiff-line-added">+       predicted_old_time_ms += predicted_time_ms;</span>
<span class="udiff-line-added">+       num_initial_regions++;</span>
<span class="udiff-line-added">+       // Record the number of regions added with no time remaining</span>
<span class="udiff-line-added">+       if (time_remaining_ms == 0.0) {</span>
<span class="udiff-line-added">+         num_expensive_regions++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } else if (!check_time_remaining) {</span>
<span class="udiff-line-added">+       // In the non-auto-tuning case, we&#39;ll finish adding regions</span>
<span class="udiff-line-added">+       // to the CSet if we reach the minimum.</span>
<span class="udiff-line-added">+       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Region amount reached min).&quot;);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Keep adding regions to old set until we reach the optional threshold</span>
<span class="udiff-line-added">+       if (time_remaining_ms &gt; optional_threshold_ms) {</span>
<span class="udiff-line-added">+         predicted_old_time_ms += predicted_time_ms;</span>
<span class="udiff-line-added">+         num_initial_regions++;</span>
<span class="udiff-line-added">+       } else if (time_remaining_ms &gt; 0) {</span>
<span class="udiff-line-added">+         // Keep adding optional regions until time is up.</span>
<span class="udiff-line-added">+         assert(num_optional_regions &lt; max_optional_regions, &quot;Should not be possible.&quot;);</span>
<span class="udiff-line-added">+         predicted_optional_time_ms += predicted_time_ms;</span>
<span class="udiff-line-added">+         num_optional_regions++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Predicted time too high).&quot;);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     hr = candidates-&gt;at(++candidate_idx);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (hr == NULL) {</span>
<span class="udiff-line-added">+     log_debug(gc, ergo, cset)(&quot;Old candidate collection set empty.&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (num_expensive_regions &gt; 0) {</span>
<span class="udiff-line-added">+     log_debug(gc, ergo, cset)(&quot;Added %u initial old regions to collection set although the predicted time was too high.&quot;,</span>
<span class="udiff-line-added">+                               num_expensive_regions);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(gc, ergo, cset)(&quot;Finish choosing collection set old regions. Initial: %u, optional: %u, &quot;</span>
<span class="udiff-line-added">+                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,</span>
<span class="udiff-line-added">+                             num_initial_regions, num_optional_regions,</span>
<span class="udiff-line-added">+                             predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1Policy::calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="udiff-line-added">+                                                          uint const max_optional_regions,</span>
<span class="udiff-line-added">+                                                          double time_remaining_ms,</span>
<span class="udiff-line-added">+                                                          uint&amp; num_optional_regions) {</span>
<span class="udiff-line-added">+   assert(_g1h-&gt;collector_state()-&gt;in_mixed_phase(), &quot;Should only be called in mixed phase&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   num_optional_regions = 0;</span>
<span class="udiff-line-added">+   double prediction_ms = 0;</span>
<span class="udiff-line-added">+   uint candidate_idx = candidates-&gt;cur_idx();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapRegion* r = candidates-&gt;at(candidate_idx);</span>
<span class="udiff-line-added">+   while (num_optional_regions &lt; max_optional_regions) {</span>
<span class="udiff-line-added">+     assert(r != NULL, &quot;Region must exist&quot;);</span>
<span class="udiff-line-added">+     prediction_ms += predict_region_total_time_ms(r, false);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (prediction_ms &gt; time_remaining_ms) {</span>
<span class="udiff-line-added">+       log_debug(gc, ergo, cset)(&quot;Prediction %.3fms for region %u does not fit remaining time: %.3fms.&quot;,</span>
<span class="udiff-line-added">+                                 prediction_ms, r-&gt;hrm_index(), time_remaining_ms);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // This region will be included in the next optional evacuation.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     time_remaining_ms -= prediction_ms;</span>
<span class="udiff-line-added">+     num_optional_regions++;</span>
<span class="udiff-line-added">+     r = candidates-&gt;at(++candidate_idx);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(gc, ergo, cset)(&quot;Prepared %u regions out of %u for optional evacuation. Predicted time: %.3fms&quot;,</span>
<span class="udiff-line-added">+                             num_optional_regions, max_optional_regions, prediction_ms);</span>
  }
  
  void G1Policy::transfer_survivors_to_cset(const G1SurvivorRegions* survivors) {
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Add survivor regions to SurvRateGroup.</span>
    note_start_adding_survivor_regions();
<span class="udiff-line-removed">-   finished_recalculating_age_indexes(true /* is_survivors */);</span>
  
    HeapRegion* last = NULL;
    for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivors-&gt;regions()-&gt;begin();
         it != survivors-&gt;regions()-&gt;end();
         ++it) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1217,8 +1408,6 @@</span>
  
    // Don&#39;t clear the survivor list handles until the start of
    // the next evacuation pause - we need it in order to re-tag
    // the survivor regions from this evacuation pause as &#39;young&#39;
    // at the start of the next.
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   finished_recalculating_age_indexes(false /* is_survivors */);</span>
  }
</pre>
<center><a href="g1ParScanThreadState.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
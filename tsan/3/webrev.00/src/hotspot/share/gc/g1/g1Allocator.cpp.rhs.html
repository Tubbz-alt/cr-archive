<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 28 #include &quot;gc/g1/g1EvacStats.inline.hpp&quot;
 29 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
 30 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 31 #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 35 #include &quot;gc/g1/heapRegionType.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 G1Allocator::G1Allocator(G1CollectedHeap* heap) :
 39   _g1h(heap),
<a name="3" id="anc3"></a><span class="line-added"> 40   _numa(heap-&gt;numa()),</span>
 41   _survivor_is_full(false),
 42   _old_is_full(false),
<a name="4" id="anc4"></a><span class="line-modified"> 43   _num_alloc_regions(_numa-&gt;num_active_nodes()),</span>
<span class="line-modified"> 44   _mutator_alloc_regions(NULL),</span>
<span class="line-modified"> 45   _survivor_gc_alloc_regions(NULL),</span>
<span class="line-added"> 46   _old_gc_alloc_region(heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Old)),</span>
 47   _retained_old_gc_alloc_region(NULL) {
<a name="5" id="anc5"></a><span class="line-added"> 48 </span>
<span class="line-added"> 49   _mutator_alloc_regions = NEW_C_HEAP_ARRAY(MutatorAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added"> 50   _survivor_gc_alloc_regions = NEW_C_HEAP_ARRAY(SurvivorGCAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added"> 51   G1EvacStats* stat = heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Young);</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 54     ::new(_mutator_alloc_regions + i) MutatorAllocRegion(i);</span>
<span class="line-added"> 55     ::new(_survivor_gc_alloc_regions + i) SurvivorGCAllocRegion(stat, i);</span>
<span class="line-added"> 56   }</span>
 57 }
 58 
<a name="6" id="anc6"></a><span class="line-modified"> 59 G1Allocator::~G1Allocator() {</span>
<span class="line-modified"> 60   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-modified"> 61     _mutator_alloc_regions[i].~MutatorAllocRegion();</span>
<span class="line-added"> 62     _survivor_gc_alloc_regions[i].~SurvivorGCAllocRegion();</span>
<span class="line-added"> 63   }</span>
<span class="line-added"> 64   FREE_C_HEAP_ARRAY(MutatorAllocRegion, _mutator_alloc_regions);</span>
<span class="line-added"> 65   FREE_C_HEAP_ARRAY(SurvivorGCAllocRegion, _survivor_gc_alloc_regions);</span>
 66 }
 67 
<a name="7" id="anc7"></a><span class="line-modified"> 68 #ifdef ASSERT</span>
<span class="line-modified"> 69 bool G1Allocator::has_mutator_alloc_region() {</span>
<span class="line-modified"> 70   uint node_index = current_node_index();</span>
<span class="line-added"> 71   return mutator_alloc_region(node_index)-&gt;get() != NULL;</span>
<span class="line-added"> 72 }</span>
<span class="line-added"> 73 #endif</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75 void G1Allocator::init_mutator_alloc_regions() {</span>
<span class="line-added"> 76   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 77     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added"> 78     mutator_alloc_region(i)-&gt;init();</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 void G1Allocator::release_mutator_alloc_regions() {</span>
<span class="line-added"> 83   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 84     mutator_alloc_region(i)-&gt;release();</span>
<span class="line-added"> 85     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;post-condition&quot;);</span>
<span class="line-added"> 86   }</span>
 87 }
 88 
 89 bool G1Allocator::is_retained_old_region(HeapRegion* hr) {
 90   return _retained_old_gc_alloc_region == hr;
 91 }
 92 
 93 void G1Allocator::reuse_retained_old_region(G1EvacuationInfo&amp; evacuation_info,
 94                                             OldGCAllocRegion* old,
 95                                             HeapRegion** retained_old) {
 96   HeapRegion* retained_region = *retained_old;
 97   *retained_old = NULL;
 98   assert(retained_region == NULL || !retained_region-&gt;is_archive(),
 99          &quot;Archive region should not be alloc region (index %u)&quot;, retained_region-&gt;hrm_index());
100 
101   // We will discard the current GC alloc region if:
102   // a) it&#39;s in the collection set (it can happen!),
103   // b) it&#39;s already full (no point in using it),
104   // c) it&#39;s empty (this means that it was emptied during
105   // a cleanup and it should be on the free list now), or
106   // d) it&#39;s humongous (this means that it was emptied
107   // during a cleanup and was added to the free list, but
108   // has been subsequently used to allocate a humongous
109   // object that may be less than the region size).
110   if (retained_region != NULL &amp;&amp;
111       !retained_region-&gt;in_collection_set() &amp;&amp;
112       !(retained_region-&gt;top() == retained_region-&gt;end()) &amp;&amp;
113       !retained_region-&gt;is_empty() &amp;&amp;
114       !retained_region-&gt;is_humongous()) {
115     // The retained region was added to the old region set when it was
116     // retired. We have to remove it now, since we don&#39;t allow regions
117     // we allocate to in the region sets. We&#39;ll re-add it later, when
118     // it&#39;s retired again.
119     _g1h-&gt;old_set_remove(retained_region);
120     old-&gt;set(retained_region);
121     _g1h-&gt;hr_printer()-&gt;reuse(retained_region);
122     evacuation_info.set_alloc_regions_used_before(retained_region-&gt;used());
123   }
124 }
125 
126 void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
127   assert_at_safepoint_on_vm_thread();
128 
129   _survivor_is_full = false;
130   _old_is_full = false;
131 
<a name="8" id="anc8"></a><span class="line-modified">132   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">133     survivor_gc_alloc_region(i)-&gt;init();</span>
<span class="line-added">134   }</span>
<span class="line-added">135 </span>
136   _old_gc_alloc_region.init();
137   reuse_retained_old_region(evacuation_info,
138                             &amp;_old_gc_alloc_region,
139                             &amp;_retained_old_gc_alloc_region);
140 }
141 
142 void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
<a name="9" id="anc9"></a><span class="line-modified">143   uint survivor_region_count = 0;</span>
<span class="line-added">144   for (uint node_index = 0; node_index &lt; _num_alloc_regions; node_index++) {</span>
<span class="line-added">145     survivor_region_count += survivor_gc_alloc_region(node_index)-&gt;count();</span>
<span class="line-added">146     survivor_gc_alloc_region(node_index)-&gt;release();</span>
<span class="line-added">147   }</span>
<span class="line-added">148   evacuation_info.set_allocation_regions(survivor_region_count +</span>
149                                          old_gc_alloc_region()-&gt;count());
<a name="10" id="anc10"></a><span class="line-modified">150 </span>
151   // If we have an old GC alloc region to release, we&#39;ll save it in
152   // _retained_old_gc_alloc_region. If we don&#39;t
153   // _retained_old_gc_alloc_region will become NULL. This is what we
154   // want either way so no reason to check explicitly for either
155   // condition.
156   _retained_old_gc_alloc_region = old_gc_alloc_region()-&gt;release();
157 }
158 
159 void G1Allocator::abandon_gc_alloc_regions() {
<a name="11" id="anc11"></a><span class="line-modified">160   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">161     assert(survivor_gc_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">162   }</span>
163   assert(old_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);
164   _retained_old_gc_alloc_region = NULL;
165 }
166 
167 bool G1Allocator::survivor_is_full() const {
168   return _survivor_is_full;
169 }
170 
171 bool G1Allocator::old_is_full() const {
172   return _old_is_full;
173 }
174 
175 void G1Allocator::set_survivor_full() {
176   _survivor_is_full = true;
177 }
178 
179 void G1Allocator::set_old_full() {
180   _old_is_full = true;
181 }
182 
183 size_t G1Allocator::unsafe_max_tlab_alloc() {
184   // Return the remaining space in the cur alloc region, but not less than
185   // the min TLAB size.
186 
187   // Also, this value can be at most the humongous object threshold,
188   // since we can&#39;t allow tlabs to grow big enough to accommodate
189   // humongous objects.
190 
<a name="12" id="anc12"></a><span class="line-modified">191   uint node_index = current_node_index();</span>
<span class="line-added">192   HeapRegion* hr = mutator_alloc_region(node_index)-&gt;get();</span>
193   size_t max_tlab = _g1h-&gt;max_tlab_size() * wordSize;
194   if (hr == NULL) {
195     return max_tlab;
196   } else {
<a name="13" id="anc13"></a><span class="line-modified">197     return clamp(hr-&gt;free(), MinTLABSize, max_tlab);</span>
198   }
199 }
200 
201 size_t G1Allocator::used_in_alloc_regions() {
202   assert(Heap_lock-&gt;owner() != NULL, &quot;Should be owned on this thread&#39;s behalf.&quot;);
<a name="14" id="anc14"></a><span class="line-modified">203   size_t used = 0;</span>
<span class="line-added">204   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">205     used += mutator_alloc_region(i)-&gt;used_in_alloc_regions();</span>
<span class="line-added">206   }</span>
<span class="line-added">207   return used;</span>
208 }
209 
210 
<a name="15" id="anc15"></a><span class="line-modified">211 HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
<span class="line-modified">212                                               size_t word_size,</span>
<span class="line-added">213                                               uint node_index) {</span>
214   size_t temp = 0;
<a name="16" id="anc16"></a><span class="line-modified">215   HeapWord* result = par_allocate_during_gc(dest, word_size, word_size, &amp;temp, node_index);</span>
216   assert(result == NULL || temp == word_size,
217          &quot;Requested &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
218          word_size, temp, p2i(result));
219   return result;
220 }
221 
<a name="17" id="anc17"></a><span class="line-modified">222 HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
223                                               size_t min_word_size,
224                                               size_t desired_word_size,
<a name="18" id="anc18"></a><span class="line-modified">225                                               size_t* actual_word_size,</span>
<span class="line-modified">226                                               uint node_index) {</span>
<span class="line-modified">227   switch (dest.type()) {</span>
<span class="line-modified">228     case G1HeapRegionAttr::Young:</span>
<span class="line-modified">229       return survivor_attempt_allocation(min_word_size, desired_word_size, actual_word_size, node_index);</span>
<span class="line-added">230     case G1HeapRegionAttr::Old:</span>
231       return old_attempt_allocation(min_word_size, desired_word_size, actual_word_size);
232     default:
233       ShouldNotReachHere();
234       return NULL; // Keep some compilers happy
235   }
236 }
237 
238 HeapWord* G1Allocator::survivor_attempt_allocation(size_t min_word_size,
239                                                    size_t desired_word_size,
<a name="19" id="anc19"></a><span class="line-modified">240                                                    size_t* actual_word_size,</span>
<span class="line-added">241                                                    uint node_index) {</span>
242   assert(!_g1h-&gt;is_humongous(desired_word_size),
243          &quot;we should not be seeing humongous-size allocations in this path&quot;);
244 
<a name="20" id="anc20"></a><span class="line-modified">245   HeapWord* result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation(min_word_size,</span>
<span class="line-modified">246                                                                               desired_word_size,</span>
<span class="line-modified">247                                                                               actual_word_size);</span>
248   if (result == NULL &amp;&amp; !survivor_is_full()) {
<a name="21" id="anc21"></a><span class="line-modified">249     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">250     result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation_locked(min_word_size,</span>
<span class="line-modified">251                                                                              desired_word_size,</span>
<span class="line-modified">252                                                                              actual_word_size);</span>
253     if (result == NULL) {
254       set_survivor_full();
255     }
256   }
257   if (result != NULL) {
258     _g1h-&gt;dirty_young_block(result, *actual_word_size);
259   }
260   return result;
261 }
262 
263 HeapWord* G1Allocator::old_attempt_allocation(size_t min_word_size,
264                                               size_t desired_word_size,
265                                               size_t* actual_word_size) {
266   assert(!_g1h-&gt;is_humongous(desired_word_size),
267          &quot;we should not be seeing humongous-size allocations in this path&quot;);
268 
269   HeapWord* result = old_gc_alloc_region()-&gt;attempt_allocation(min_word_size,
270                                                                desired_word_size,
271                                                                actual_word_size);
272   if (result == NULL &amp;&amp; !old_is_full()) {
<a name="22" id="anc22"></a><span class="line-modified">273     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
274     result = old_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,
275                                                               desired_word_size,
276                                                               actual_word_size);
277     if (result == NULL) {
278       set_old_full();
279     }
280   }
281   return result;
282 }
283 
284 uint G1PLABAllocator::calc_survivor_alignment_bytes() {
285   assert(SurvivorAlignmentInBytes &gt;= ObjectAlignmentInBytes, &quot;sanity&quot;);
286   if (SurvivorAlignmentInBytes == ObjectAlignmentInBytes) {
287     // No need to align objects in the survivors differently, return 0
288     // which means &quot;survivor alignment is not used&quot;.
289     return 0;
290   } else {
291     assert(SurvivorAlignmentInBytes &gt; 0, &quot;sanity&quot;);
292     return SurvivorAlignmentInBytes;
293   }
294 }
295 
296 G1PLABAllocator::G1PLABAllocator(G1Allocator* allocator) :
297   _g1h(G1CollectedHeap::heap()),
298   _allocator(allocator),
<a name="23" id="anc23"></a>

299   _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {
<a name="24" id="anc24"></a><span class="line-modified">300   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
301     _direct_allocated[state] = 0;
<a name="25" id="anc25"></a><span class="line-modified">302     uint length = alloc_buffers_length(state);</span>
<span class="line-added">303     _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);</span>
<span class="line-added">304     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">305       _alloc_buffers[state][node_index] = new PLAB(_g1h-&gt;desired_plab_sz(state));</span>
<span class="line-added">306     }</span>
<span class="line-added">307   }</span>
<span class="line-added">308 }</span>
<span class="line-added">309 </span>
<span class="line-added">310 G1PLABAllocator::~G1PLABAllocator() {</span>
<span class="line-added">311   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-added">312     uint length = alloc_buffers_length(state);</span>
<span class="line-added">313     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">314       delete _alloc_buffers[state][node_index];</span>
<span class="line-added">315     }</span>
<span class="line-added">316     FREE_C_HEAP_ARRAY(PLAB*, _alloc_buffers[state]);</span>
317   }
<a name="26" id="anc26"></a>

318 }
319 
320 bool G1PLABAllocator::may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const {
321   return (allocation_word_sz * 100 &lt; buffer_size * ParallelGCBufferWastePct);
322 }
323 
<a name="27" id="anc27"></a><span class="line-modified">324 HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(G1HeapRegionAttr dest,</span>
325                                                        size_t word_sz,
<a name="28" id="anc28"></a><span class="line-modified">326                                                        bool* plab_refill_failed,</span>
<span class="line-added">327                                                        uint node_index) {</span>
328   size_t plab_word_size = _g1h-&gt;desired_plab_sz(dest);
329   size_t required_in_plab = PLAB::size_required_for_allocation(word_sz);
330 
331   // Only get a new PLAB if the allocation fits and it would not waste more than
332   // ParallelGCBufferWastePct in the existing buffer.
333   if ((required_in_plab &lt;= plab_word_size) &amp;&amp;
334     may_throw_away_buffer(required_in_plab, plab_word_size)) {
335 
<a name="29" id="anc29"></a><span class="line-modified">336     PLAB* alloc_buf = alloc_buffer(dest, node_index);</span>
337     alloc_buf-&gt;retire();
338 
339     size_t actual_plab_size = 0;
340     HeapWord* buf = _allocator-&gt;par_allocate_during_gc(dest,
341                                                        required_in_plab,
342                                                        plab_word_size,
<a name="30" id="anc30"></a><span class="line-modified">343                                                        &amp;actual_plab_size,</span>
<span class="line-added">344                                                        node_index);</span>
345 
346     assert(buf == NULL || ((actual_plab_size &gt;= required_in_plab) &amp;&amp; (actual_plab_size &lt;= plab_word_size)),
347            &quot;Requested at minimum &quot; SIZE_FORMAT &quot;, desired &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
348            required_in_plab, plab_word_size, actual_plab_size, p2i(buf));
349 
350     if (buf != NULL) {
351       alloc_buf-&gt;set_buf(buf, actual_plab_size);
352 
353       HeapWord* const obj = alloc_buf-&gt;allocate(word_sz);
354       assert(obj != NULL, &quot;PLAB should have been big enough, tried to allocate &quot;
355                           SIZE_FORMAT &quot; requiring &quot; SIZE_FORMAT &quot; PLAB size &quot; SIZE_FORMAT,
356                           word_sz, required_in_plab, plab_word_size);
357       return obj;
358     }
359     // Otherwise.
360     *plab_refill_failed = true;
361   }
362   // Try direct allocation.
<a name="31" id="anc31"></a><span class="line-modified">363   HeapWord* result = _allocator-&gt;par_allocate_during_gc(dest, word_sz, node_index);</span>
364   if (result != NULL) {
<a name="32" id="anc32"></a><span class="line-modified">365     _direct_allocated[dest.type()] += word_sz;</span>
366   }
367   return result;
368 }
369 
<a name="33" id="anc33"></a><span class="line-modified">370 void G1PLABAllocator::undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index) {</span>
<span class="line-modified">371   alloc_buffer(dest, node_index)-&gt;undo_allocation(obj, word_sz);</span>
372 }
373 
374 void G1PLABAllocator::flush_and_retire_stats() {
<a name="34" id="anc34"></a><span class="line-modified">375   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">376     G1EvacStats* stats = _g1h-&gt;alloc_buffer_stats(state);</span>
<span class="line-modified">377     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">378       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">379       if (buf != NULL) {</span>
<span class="line-modified">380         buf-&gt;flush_and_retire_stats(stats);</span>
<span class="line-modified">381       }</span>
382     }
<a name="35" id="anc35"></a><span class="line-added">383     stats-&gt;add_direct_allocated(_direct_allocated[state]);</span>
<span class="line-added">384     _direct_allocated[state] = 0;</span>
385   }
386 }
387 
388 size_t G1PLABAllocator::waste() const {
389   size_t result = 0;
<a name="36" id="anc36"></a><span class="line-modified">390   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">391     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">392       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">393       if (buf != NULL) {</span>
<span class="line-added">394         result += buf-&gt;waste();</span>
<span class="line-added">395       }</span>
396     }
397   }
398   return result;
399 }
400 
401 size_t G1PLABAllocator::undo_waste() const {
402   size_t result = 0;
<a name="37" id="anc37"></a><span class="line-modified">403   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">404     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">405       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">406       if (buf != NULL) {</span>
<span class="line-added">407         result += buf-&gt;undo_waste();</span>
<span class="line-added">408       }</span>
409     }
410   }
411   return result;
412 }
413 
414 bool G1ArchiveAllocator::_archive_check_enabled = false;
<a name="38" id="anc38"></a><span class="line-modified">415 G1ArchiveRegionMap G1ArchiveAllocator::_archive_region_map;</span>

416 
417 G1ArchiveAllocator* G1ArchiveAllocator::create_allocator(G1CollectedHeap* g1h, bool open) {
418   // Create the archive allocator, and also enable archive object checking
419   // in mark-sweep, since we will be creating archive regions.
420   G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);
421   enable_archive_object_check();
422   return result;
423 }
424 
425 bool G1ArchiveAllocator::alloc_new_region() {
426   // Allocate the highest free region in the reserved heap,
427   // and add it to our list of allocated regions. It is marked
428   // archive and added to the old set.
429   HeapRegion* hr = _g1h-&gt;alloc_highest_free_region();
430   if (hr == NULL) {
431     return false;
432   }
433   assert(hr-&gt;is_empty(), &quot;expected empty region (index %u)&quot;, hr-&gt;hrm_index());
434   if (_open) {
435     hr-&gt;set_open_archive();
436   } else {
437     hr-&gt;set_closed_archive();
438   }
439   _g1h-&gt;policy()-&gt;remset_tracker()-&gt;update_at_allocate(hr);
440   _g1h-&gt;archive_set_add(hr);
441   _g1h-&gt;hr_printer()-&gt;alloc(hr);
442   _allocated_regions.append(hr);
443   _allocation_region = hr;
444 
445   // Set up _bottom and _max to begin allocating in the lowest
446   // min_region_size&#39;d chunk of the allocated G1 region.
447   _bottom = hr-&gt;bottom();
448   _max = _bottom + HeapRegion::min_region_size_in_words();
449 
450   // Tell mark-sweep that objects in this region are not to be marked.
451   set_range_archive(MemRegion(_bottom, HeapRegion::GrainWords), _open);
452 
453   // Since we&#39;ve modified the old set, call update_sizes.
454   _g1h-&gt;g1mm()-&gt;update_sizes();
455   return true;
456 }
457 
458 HeapWord* G1ArchiveAllocator::archive_mem_allocate(size_t word_size) {
459   assert(word_size != 0, &quot;size must not be zero&quot;);
460   if (_allocation_region == NULL) {
461     if (!alloc_new_region()) {
462       return NULL;
463     }
464   }
465   HeapWord* old_top = _allocation_region-&gt;top();
466   assert(_bottom &gt;= _allocation_region-&gt;bottom(),
467          &quot;inconsistent allocation state: &quot; PTR_FORMAT &quot; &lt; &quot; PTR_FORMAT,
468          p2i(_bottom), p2i(_allocation_region-&gt;bottom()));
469   assert(_max &lt;= _allocation_region-&gt;end(),
470          &quot;inconsistent allocation state: &quot; PTR_FORMAT &quot; &gt; &quot; PTR_FORMAT,
471          p2i(_max), p2i(_allocation_region-&gt;end()));
472   assert(_bottom &lt;= old_top &amp;&amp; old_top &lt;= _max,
473          &quot;inconsistent allocation state: expected &quot;
474          PTR_FORMAT &quot; &lt;= &quot; PTR_FORMAT &quot; &lt;= &quot; PTR_FORMAT,
475          p2i(_bottom), p2i(old_top), p2i(_max));
476 
477   // Allocate the next word_size words in the current allocation chunk.
478   // If allocation would cross the _max boundary, insert a filler and begin
479   // at the base of the next min_region_size&#39;d chunk. Also advance to the next
480   // chunk if we don&#39;t yet cross the boundary, but the remainder would be too
481   // small to fill.
482   HeapWord* new_top = old_top + word_size;
483   size_t remainder = pointer_delta(_max, new_top);
484   if ((new_top &gt; _max) ||
485       ((new_top &lt; _max) &amp;&amp; (remainder &lt; CollectedHeap::min_fill_size()))) {
486     if (old_top != _max) {
487       size_t fill_size = pointer_delta(_max, old_top);
488       CollectedHeap::fill_with_object(old_top, fill_size);
489       _summary_bytes_used += fill_size * HeapWordSize;
490     }
491     _allocation_region-&gt;set_top(_max);
492     old_top = _bottom = _max;
493 
494     // Check if we&#39;ve just used up the last min_region_size&#39;d chunk
495     // in the current region, and if so, allocate a new one.
496     if (_bottom != _allocation_region-&gt;end()) {
497       _max = _bottom + HeapRegion::min_region_size_in_words();
498     } else {
499       if (!alloc_new_region()) {
500         return NULL;
501       }
502       old_top = _allocation_region-&gt;bottom();
503     }
504   }
505   _allocation_region-&gt;set_top(old_top + word_size);
506   _summary_bytes_used += word_size * HeapWordSize;
507 
508   return old_top;
509 }
510 
511 void G1ArchiveAllocator::complete_archive(GrowableArray&lt;MemRegion&gt;* ranges,
512                                           size_t end_alignment_in_bytes) {
513   assert((end_alignment_in_bytes &gt;&gt; LogHeapWordSize) &lt; HeapRegion::min_region_size_in_words(),
514          &quot;alignment &quot; SIZE_FORMAT &quot; too large&quot;, end_alignment_in_bytes);
515   assert(is_aligned(end_alignment_in_bytes, HeapWordSize),
516          &quot;alignment &quot; SIZE_FORMAT &quot; is not HeapWord (%u) aligned&quot;, end_alignment_in_bytes, HeapWordSize);
517 
518   // If we&#39;ve allocated nothing, simply return.
519   if (_allocation_region == NULL) {
520     return;
521   }
522 
523   // If an end alignment was requested, insert filler objects.
524   if (end_alignment_in_bytes != 0) {
525     HeapWord* currtop = _allocation_region-&gt;top();
526     HeapWord* newtop = align_up(currtop, end_alignment_in_bytes);
527     size_t fill_size = pointer_delta(newtop, currtop);
528     if (fill_size != 0) {
529       if (fill_size &lt; CollectedHeap::min_fill_size()) {
530         // If the required fill is smaller than we can represent,
531         // bump up to the next aligned address. We know we won&#39;t exceed the current
532         // region boundary because the max supported alignment is smaller than the min
533         // region size, and because the allocation code never leaves space smaller than
534         // the min_fill_size at the top of the current allocation region.
535         newtop = align_up(currtop + CollectedHeap::min_fill_size(),
536                           end_alignment_in_bytes);
537         fill_size = pointer_delta(newtop, currtop);
538       }
539       HeapWord* fill = archive_mem_allocate(fill_size);
540       CollectedHeap::fill_with_objects(fill, fill_size);
541     }
542   }
543 
544   // Loop through the allocated regions, and create MemRegions summarizing
545   // the allocated address range, combining contiguous ranges. Add the
546   // MemRegions to the GrowableArray provided by the caller.
547   int index = _allocated_regions.length() - 1;
548   assert(_allocated_regions.at(index) == _allocation_region,
549          &quot;expected region %u at end of array, found %u&quot;,
550          _allocation_region-&gt;hrm_index(), _allocated_regions.at(index)-&gt;hrm_index());
551   HeapWord* base_address = _allocation_region-&gt;bottom();
552   HeapWord* top = base_address;
553 
554   while (index &gt;= 0) {
555     HeapRegion* next = _allocated_regions.at(index);
556     HeapWord* new_base = next-&gt;bottom();
557     HeapWord* new_top = next-&gt;top();
558     if (new_base != top) {
559       ranges-&gt;append(MemRegion(base_address, pointer_delta(top, base_address)));
560       base_address = new_base;
561     }
562     top = new_top;
563     index = index - 1;
564   }
565 
566   assert(top != base_address, &quot;zero-sized range, address &quot; PTR_FORMAT, p2i(base_address));
567   ranges-&gt;append(MemRegion(base_address, pointer_delta(top, base_address)));
568   _allocated_regions.clear();
569   _allocation_region = NULL;
570 };
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
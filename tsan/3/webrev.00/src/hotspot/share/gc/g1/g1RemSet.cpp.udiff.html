<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1RemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RegionToSpaceMapper.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1RemSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,276 +24,462 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BarrierSet.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CardTable.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  #include &quot;gc/g1/g1FromCardCache.hpp&quot;
  #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  #include &quot;gc/g1/g1RootClosures.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1SharedDirtyCardQueue.hpp&quot;</span>
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/heapRegionRemSet.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/g1/sparsePRT.hpp&quot;</span>
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/ptrQueue.hpp&quot;</span>
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/stack.inline.hpp&quot;
  #include &quot;utilities/ticks.hpp&quot;
  
<span class="udiff-line-modified-removed">- // Collects information about the overall remembered set scan progress during an evacuation.</span>
<span class="udiff-line-modified-added">+ // Collects information about the overall heap root scan progress during an evacuation.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Scanning the remembered sets works by first merging all sources of cards to be</span>
<span class="udiff-line-added">+ // scanned (log buffers, hcc, remembered sets) into a single data structure to remove</span>
<span class="udiff-line-added">+ // duplicates and simplify work distribution.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // During the following card scanning we not only scan this combined set of cards, but</span>
<span class="udiff-line-added">+ // also remember that these were completely scanned. The following evacuation passes</span>
<span class="udiff-line-added">+ // do not scan these cards again, and so need to be preserved across increments.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // The representation for all the cards to scan is the card table: cards can have</span>
<span class="udiff-line-added">+ // one of three states during GC:</span>
<span class="udiff-line-added">+ // - clean: these cards will not be scanned in this pass</span>
<span class="udiff-line-added">+ // - dirty: these cards will be scanned in this pass</span>
<span class="udiff-line-added">+ // - scanned: these cards have already been scanned in a previous pass</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // After all evacuation is done, we reset the card table to clean.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Work distribution occurs on &quot;chunk&quot; basis, i.e. contiguous ranges of cards. As an</span>
<span class="udiff-line-added">+ // additional optimization, during card merging we remember which regions and which</span>
<span class="udiff-line-added">+ // chunks actually contain cards to be scanned. Threads iterate only across these</span>
<span class="udiff-line-added">+ // regions, and only compete for chunks containing any cards.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Within these chunks, a worker scans the card table on &quot;blocks&quot; of cards, i.e.</span>
<span class="udiff-line-added">+ // contiguous ranges of dirty cards to be scanned. These blocks are converted to actual</span>
<span class="udiff-line-added">+ // memory ranges and then passed on to actual scanning.</span>
  class G1RemSetScanState : public CHeapObj&lt;mtGC&gt; {
<span class="udiff-line-added">+   class G1DirtyRegions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t _max_regions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Has this region that is part of the regions in the collection set been processed yet.</span>
<span class="udiff-line-added">+   typedef bool G1RemsetIterState;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1RemsetIterState volatile* _collection_set_iter_state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Card table iteration claim for each heap region, from 0 (completely unscanned)</span>
<span class="udiff-line-added">+   // to (&gt;=) HeapRegion::CardsPerRegion (completely scanned).</span>
<span class="udiff-line-added">+   uint volatile* _card_table_scan_state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Return &quot;optimal&quot; number of chunks per region we want to use for claiming areas</span>
<span class="udiff-line-added">+   // within a region to claim. Dependent on the region size as proxy for the heap</span>
<span class="udiff-line-added">+   // size, we limit the total number of chunks to limit memory usage and maintenance</span>
<span class="udiff-line-added">+   // effort of that table vs. granularity of distributing scanning work.</span>
<span class="udiff-line-added">+   // Testing showed that 8 for 1M/2M region, 16 for 4M/8M regions, 32 for 16/32M regions</span>
<span class="udiff-line-added">+   // seems to be such a good trade-off.</span>
<span class="udiff-line-added">+   static uint get_chunks_per_region(uint log_region_size) {</span>
<span class="udiff-line-added">+     // Limit the expected input values to current known possible values of the</span>
<span class="udiff-line-added">+     // (log) region size. Adjust as necessary after testing if changing the permissible</span>
<span class="udiff-line-added">+     // values for region size.</span>
<span class="udiff-line-added">+     assert(log_region_size &gt;= 20 &amp;&amp; log_region_size &lt;= 25,</span>
<span class="udiff-line-added">+            &quot;expected value in [20,25], but got %u&quot;, log_region_size);</span>
<span class="udiff-line-added">+     return 1u &lt;&lt; (log_region_size / 2 - 7);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint _scan_chunks_per_region;         // Number of chunks per region.</span>
<span class="udiff-line-added">+   uint8_t _log_scan_chunks_per_region;  // Log of number of chunks per region.</span>
<span class="udiff-line-added">+   bool* _region_scan_chunks;</span>
<span class="udiff-line-added">+   size_t _num_total_scan_chunks;        // Total number of elements in _region_scan_chunks.</span>
<span class="udiff-line-added">+   uint8_t _scan_chunks_shift;           // For conversion between card index and chunk index.</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   uint scan_chunk_size() const { return (uint)1 &lt;&lt; _scan_chunks_shift; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Returns whether the chunk corresponding to the given region/card in region contain a</span>
<span class="udiff-line-added">+   // dirty card, i.e. actually needs scanning.</span>
<span class="udiff-line-added">+   bool chunk_needs_scan(uint const region_idx, uint const card_in_region) const {</span>
<span class="udiff-line-added">+     size_t const idx = ((size_t)region_idx &lt;&lt; _log_scan_chunks_per_region) + (card_in_region &gt;&gt; _scan_chunks_shift);</span>
<span class="udiff-line-added">+     assert(idx &lt; _num_total_scan_chunks, &quot;Index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="udiff-line-added">+            idx, _num_total_scan_chunks);</span>
<span class="udiff-line-added">+     return _region_scan_chunks[idx];</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  private:
<span class="udiff-line-added">+   // The complete set of regions which card table needs to be cleared at the end of GC because</span>
<span class="udiff-line-added">+   // we scribbled all over them.</span>
<span class="udiff-line-added">+   G1DirtyRegions* _all_dirty_regions;</span>
<span class="udiff-line-added">+   // The set of regions which card table needs to be scanned for new dirty cards</span>
<span class="udiff-line-added">+   // in the current evacuation pass.</span>
<span class="udiff-line-added">+   G1DirtyRegions* _next_dirty_regions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Set of (unique) regions that can be added to concurrently.</span>
<span class="udiff-line-added">+   class G1DirtyRegions : public CHeapObj&lt;mtGC&gt; {</span>
<span class="udiff-line-added">+     uint* _buffer;</span>
<span class="udiff-line-added">+     uint _cur_idx;</span>
<span class="udiff-line-added">+     size_t _max_regions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool* _contains;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+     G1DirtyRegions(size_t max_regions) :</span>
<span class="udiff-line-added">+       _buffer(NEW_C_HEAP_ARRAY(uint, max_regions, mtGC)),</span>
<span class="udiff-line-added">+       _cur_idx(0),</span>
<span class="udiff-line-added">+       _max_regions(max_regions),</span>
<span class="udiff-line-added">+       _contains(NEW_C_HEAP_ARRAY(bool, max_regions, mtGC)) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       reset();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static size_t chunk_size() { return M; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ~G1DirtyRegions() {</span>
<span class="udiff-line-added">+       FREE_C_HEAP_ARRAY(uint, _buffer);</span>
<span class="udiff-line-added">+       FREE_C_HEAP_ARRAY(bool, _contains);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void reset() {</span>
<span class="udiff-line-added">+       _cur_idx = 0;</span>
<span class="udiff-line-added">+       ::memset(_contains, false, _max_regions * sizeof(bool));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint size() const { return _cur_idx; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint at(uint idx) const {</span>
<span class="udiff-line-added">+       assert(idx &lt; _cur_idx, &quot;Index %u beyond valid regions&quot;, idx);</span>
<span class="udiff-line-added">+       return _buffer[idx];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void add_dirty_region(uint region) {</span>
<span class="udiff-line-added">+       if (_contains[region]) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       bool marked_as_dirty = Atomic::cmpxchg(&amp;_contains[region], false, true) == false;</span>
<span class="udiff-line-added">+       if (marked_as_dirty) {</span>
<span class="udiff-line-added">+         uint allocated = Atomic::fetch_and_add(&amp;_cur_idx, 1u);</span>
<span class="udiff-line-added">+         _buffer[allocated] = region;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Creates the union of this and the other G1DirtyRegions.</span>
<span class="udiff-line-added">+     void merge(const G1DirtyRegions* other) {</span>
<span class="udiff-line-added">+       for (uint i = 0; i &lt; other-&gt;size(); i++) {</span>
<span class="udiff-line-added">+         uint region = other-&gt;at(i);</span>
<span class="udiff-line-added">+         if (!_contains[region]) {</span>
<span class="udiff-line-added">+           _buffer[_cur_idx++] = region;</span>
<span class="udiff-line-added">+           _contains[region] = true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // For each region, contains the maximum top() value to be used during this garbage</span>
<span class="udiff-line-added">+   // collection. Subsumes common checks like filtering out everything but old and</span>
<span class="udiff-line-added">+   // humongous regions outside the collection set.</span>
<span class="udiff-line-added">+   // This is valid because we are not interested in scanning stray remembered set</span>
<span class="udiff-line-added">+   // entries from free or archive regions.</span>
<span class="udiff-line-added">+   HeapWord** _scan_top;</span>
<span class="udiff-line-added">+ </span>
    class G1ClearCardTableTask : public AbstractGangTask {
      G1CollectedHeap* _g1h;
<span class="udiff-line-modified-removed">-     uint* _dirty_region_list;</span>
<span class="udiff-line-modified-removed">-     size_t _num_dirty_regions;</span>
<span class="udiff-line-modified-removed">-     size_t _chunk_length;</span>
<span class="udiff-line-modified-added">+     G1DirtyRegions* _regions;</span>
<span class="udiff-line-modified-added">+     uint _chunk_length;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     uint volatile _cur_dirty_regions;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     G1RemSetScanState* _scan_state;</span>
  
<span class="udiff-line-removed">-     size_t volatile _cur_dirty_regions;</span>
    public:
      G1ClearCardTableTask(G1CollectedHeap* g1h,
<span class="udiff-line-modified-removed">-                          uint* dirty_region_list,</span>
<span class="udiff-line-modified-removed">-                          size_t num_dirty_regions,</span>
<span class="udiff-line-modified-removed">-                          size_t chunk_length) :</span>
<span class="udiff-line-modified-added">+                          G1DirtyRegions* regions,</span>
<span class="udiff-line-modified-added">+                          uint chunk_length,</span>
<span class="udiff-line-modified-added">+                          G1RemSetScanState* scan_state) :</span>
        AbstractGangTask(&quot;G1 Clear Card Table Task&quot;),
        _g1h(g1h),
<span class="udiff-line-modified-removed">-       _dirty_region_list(dirty_region_list),</span>
<span class="udiff-line-removed">-       _num_dirty_regions(num_dirty_regions),</span>
<span class="udiff-line-modified-added">+       _regions(regions),</span>
        _chunk_length(chunk_length),
<span class="udiff-line-modified-removed">-       _cur_dirty_regions(0) {</span>
<span class="udiff-line-modified-added">+       _cur_dirty_regions(0),</span>
<span class="udiff-line-added">+       _scan_state(scan_state) {</span>
  
        assert(chunk_length &gt; 0, &quot;must be&quot;);
      }
  
<span class="udiff-line-modified-removed">-     static size_t chunk_size() { return M; }</span>
<span class="udiff-line-modified-added">+     static uint chunk_size() { return M; }</span>
  
      void work(uint worker_id) {
<span class="udiff-line-modified-removed">-       while (_cur_dirty_regions &lt; _num_dirty_regions) {</span>
<span class="udiff-line-modified-removed">-         size_t next = Atomic::add(_chunk_length, &amp;_cur_dirty_regions) - _chunk_length;</span>
<span class="udiff-line-modified-removed">-         size_t max = MIN2(next + _chunk_length, _num_dirty_regions);</span>
<span class="udiff-line-modified-added">+       while (_cur_dirty_regions &lt; _regions-&gt;size()) {</span>
<span class="udiff-line-modified-added">+         uint next = Atomic::fetch_and_add(&amp;_cur_dirty_regions, _chunk_length);</span>
<span class="udiff-line-modified-added">+         uint max = MIN2(next + _chunk_length, _regions-&gt;size());</span>
  
<span class="udiff-line-modified-removed">-         for (size_t i = next; i &lt; max; i++) {</span>
<span class="udiff-line-modified-removed">-           HeapRegion* r = _g1h-&gt;region_at(_dirty_region_list[i]);</span>
<span class="udiff-line-modified-added">+         for (uint i = next; i &lt; max; i++) {</span>
<span class="udiff-line-modified-added">+           HeapRegion* r = _g1h-&gt;region_at(_regions-&gt;at(i));</span>
            if (!r-&gt;is_survivor()) {
              r-&gt;clear_cardtable();
            }
          }
        }
      }
    };
  
<span class="udiff-line-modified-removed">-   size_t _max_regions;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Scan progress for the remembered set of a single region. Transitions from</span>
<span class="udiff-line-removed">-   // Unclaimed -&gt; Claimed -&gt; Complete.</span>
<span class="udiff-line-removed">-   // At each of the transitions the thread that does the transition needs to perform</span>
<span class="udiff-line-removed">-   // some special action once. This is the reason for the extra &quot;Claimed&quot; state.</span>
<span class="udiff-line-removed">-   typedef jint G1RemsetIterState;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static const G1RemsetIterState Unclaimed = 0; // The remembered set has not been scanned yet.</span>
<span class="udiff-line-removed">-   static const G1RemsetIterState Claimed = 1;   // The remembered set is currently being scanned.</span>
<span class="udiff-line-removed">-   static const G1RemsetIterState Complete = 2;  // The remembered set has been completely scanned.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   G1RemsetIterState volatile* _iter_states;</span>
<span class="udiff-line-removed">-   // The current location where the next thread should continue scanning in a region&#39;s</span>
<span class="udiff-line-removed">-   // remembered set.</span>
<span class="udiff-line-removed">-   size_t volatile* _iter_claims;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Temporary buffer holding the regions we used to store remembered set scan duplicate</span>
<span class="udiff-line-removed">-   // information. These are also called &quot;dirty&quot;. Valid entries are from [0.._cur_dirty_region)</span>
<span class="udiff-line-removed">-   uint* _dirty_region_buffer;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Flag for every region whether it is in the _dirty_region_buffer already</span>
<span class="udiff-line-removed">-   // to avoid duplicates.</span>
<span class="udiff-line-removed">-   bool volatile* _in_dirty_region_buffer;</span>
<span class="udiff-line-removed">-   size_t _cur_dirty_region;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Creates a snapshot of the current _top values at the start of collection to</span>
<span class="udiff-line-removed">-   // filter out card marks that we do not want to scan.</span>
<span class="udiff-line-removed">-   class G1ResetScanTopClosure : public HeapRegionClosure {</span>
<span class="udiff-line-removed">-   private:</span>
<span class="udiff-line-removed">-     HeapWord** _scan_top;</span>
<span class="udiff-line-removed">-   public:</span>
<span class="udiff-line-removed">-     G1ResetScanTopClosure(HeapWord** scan_top) : _scan_top(scan_top) { }</span>
<span class="udiff-line-modified-added">+   // Clear the card table of &quot;dirty&quot; regions.</span>
<span class="udiff-line-modified-added">+   void clear_card_table(WorkGang* workers) {</span>
<span class="udiff-line-modified-added">+     uint num_regions = _all_dirty_regions-&gt;size();</span>
  
<span class="udiff-line-modified-removed">-     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-modified-removed">-       uint hrm_index = r-&gt;hrm_index();</span>
<span class="udiff-line-removed">-       if (!r-&gt;in_collection_set() &amp;&amp; r-&gt;is_old_or_humongous_or_archive() &amp;&amp; !r-&gt;is_empty()) {</span>
<span class="udiff-line-removed">-         _scan_top[hrm_index] = r-&gt;top();</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         _scan_top[hrm_index] = NULL;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-modified-added">+     if (num_regions == 0) {</span>
<span class="udiff-line-modified-added">+       return;</span>
      }
<span class="udiff-line-removed">-   };</span>
  
<span class="udiff-line-modified-removed">-   // For each region, contains the maximum top() value to be used during this garbage</span>
<span class="udiff-line-modified-removed">-   // collection. Subsumes common checks like filtering out everything but old and</span>
<span class="udiff-line-modified-removed">-   // humongous regions outside the collection set.</span>
<span class="udiff-line-modified-removed">-   // This is valid because we are not interested in scanning stray remembered set</span>
<span class="udiff-line-modified-removed">-   // entries from free or archive regions.</span>
<span class="udiff-line-modified-removed">-   HeapWord** _scan_top;</span>
<span class="udiff-line-modified-added">+     uint const num_chunks = (uint)(align_up((size_t)num_regions &lt;&lt; HeapRegion::LogCardsPerRegion, G1ClearCardTableTask::chunk_size()) / G1ClearCardTableTask::chunk_size());</span>
<span class="udiff-line-modified-added">+     uint const num_workers = MIN2(num_chunks, workers-&gt;active_workers());</span>
<span class="udiff-line-modified-added">+     uint const chunk_length = G1ClearCardTableTask::chunk_size() / (uint)HeapRegion::CardsPerRegion;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Iterate over the dirty cards region list.</span>
<span class="udiff-line-modified-added">+     G1ClearCardTableTask cl(G1CollectedHeap::heap(), _all_dirty_regions, chunk_length, this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     log_debug(gc, ergo)(&quot;Running %s using %u workers for %u &quot;</span>
<span class="udiff-line-added">+                         &quot;units of work for %u regions.&quot;,</span>
<span class="udiff-line-added">+                         cl.name(), num_workers, num_chunks, num_regions);</span>
<span class="udiff-line-added">+     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef PRODUCT</span>
<span class="udiff-line-added">+     G1CollectedHeap::heap()-&gt;verifier()-&gt;verify_card_table_cleanup();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  public:
    G1RemSetScanState() :
      _max_regions(0),
<span class="udiff-line-modified-removed">-     _iter_states(NULL),</span>
<span class="udiff-line-modified-removed">-     _iter_claims(NULL),</span>
<span class="udiff-line-modified-removed">-     _dirty_region_buffer(NULL),</span>
<span class="udiff-line-modified-removed">-     _in_dirty_region_buffer(NULL),</span>
<span class="udiff-line-modified-removed">-     _cur_dirty_region(0),</span>
<span class="udiff-line-modified-added">+     _collection_set_iter_state(NULL),</span>
<span class="udiff-line-modified-added">+     _card_table_scan_state(NULL),</span>
<span class="udiff-line-modified-added">+     _scan_chunks_per_region(get_chunks_per_region(HeapRegion::LogOfHRGrainBytes)),</span>
<span class="udiff-line-modified-added">+     _log_scan_chunks_per_region(log2_uint(_scan_chunks_per_region)),</span>
<span class="udiff-line-modified-added">+     _region_scan_chunks(NULL),</span>
<span class="udiff-line-added">+     _num_total_scan_chunks(0),</span>
<span class="udiff-line-added">+     _scan_chunks_shift(0),</span>
<span class="udiff-line-added">+     _all_dirty_regions(NULL),</span>
<span class="udiff-line-added">+     _next_dirty_regions(NULL),</span>
      _scan_top(NULL) {
    }
  
    ~G1RemSetScanState() {
<span class="udiff-line-modified-removed">-     if (_iter_states != NULL) {</span>
<span class="udiff-line-modified-removed">-       FREE_C_HEAP_ARRAY(G1RemsetIterState, _iter_states);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     if (_iter_claims != NULL) {</span>
<span class="udiff-line-removed">-       FREE_C_HEAP_ARRAY(size_t, _iter_claims);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (_dirty_region_buffer != NULL) {</span>
<span class="udiff-line-removed">-       FREE_C_HEAP_ARRAY(uint, _dirty_region_buffer);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (_in_dirty_region_buffer != NULL) {</span>
<span class="udiff-line-removed">-       FREE_C_HEAP_ARRAY(bool, _in_dirty_region_buffer);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (_scan_top != NULL) {</span>
<span class="udiff-line-removed">-       FREE_C_HEAP_ARRAY(HeapWord*, _scan_top);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     FREE_C_HEAP_ARRAY(G1RemsetIterState, _collection_set_iter_state);</span>
<span class="udiff-line-modified-added">+     FREE_C_HEAP_ARRAY(uint, _card_table_scan_state);</span>
<span class="udiff-line-modified-added">+     FREE_C_HEAP_ARRAY(bool, _region_scan_chunks);</span>
<span class="udiff-line-modified-added">+     FREE_C_HEAP_ARRAY(HeapWord*, _scan_top);</span>
    }
  
<span class="udiff-line-modified-removed">-   void initialize(uint max_regions) {</span>
<span class="udiff-line-modified-removed">-     assert(_iter_states == NULL, &quot;Must not be initialized twice&quot;);</span>
<span class="udiff-line-removed">-     assert(_iter_claims == NULL, &quot;Must not be initialized twice&quot;);</span>
<span class="udiff-line-modified-added">+   void initialize(size_t max_regions) {</span>
<span class="udiff-line-modified-added">+     assert(_collection_set_iter_state == NULL, &quot;Must not be initialized twice&quot;);</span>
      _max_regions = max_regions;
<span class="udiff-line-modified-removed">-     _iter_states = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);</span>
<span class="udiff-line-modified-removed">-     _iter_claims = NEW_C_HEAP_ARRAY(size_t, max_regions, mtGC);</span>
<span class="udiff-line-modified-removed">-     _dirty_region_buffer = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);</span>
<span class="udiff-line-modified-removed">-     _in_dirty_region_buffer = NEW_C_HEAP_ARRAY(bool, max_regions, mtGC);</span>
<span class="udiff-line-modified-added">+     _collection_set_iter_state = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);</span>
<span class="udiff-line-modified-added">+     _card_table_scan_state = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);</span>
<span class="udiff-line-modified-added">+     _num_total_scan_chunks = max_regions * _scan_chunks_per_region;</span>
<span class="udiff-line-modified-added">+     _region_scan_chunks = NEW_C_HEAP_ARRAY(bool, _num_total_scan_chunks, mtGC);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _scan_chunks_shift = (uint8_t)log2_intptr(HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>
      _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_regions, mtGC);
    }
  
<span class="udiff-line-modified-removed">-   void reset() {</span>
<span class="udiff-line-modified-removed">-     for (uint i = 0; i &lt; _max_regions; i++) {</span>
<span class="udiff-line-modified-removed">-       _iter_states[i] = Unclaimed;</span>
<span class="udiff-line-modified-removed">-       _scan_top[i] = NULL;</span>
<span class="udiff-line-modified-added">+   void prepare() {</span>
<span class="udiff-line-modified-added">+     // Reset the claim and clear scan top for all regions, including</span>
<span class="udiff-line-modified-added">+     // regions currently not available or free. Since regions might</span>
<span class="udiff-line-modified-added">+     // become used during the collection these values must be valid</span>
<span class="udiff-line-added">+     // for those regions as well.</span>
<span class="udiff-line-added">+     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="udiff-line-added">+       reset_region_claim((uint)i);</span>
<span class="udiff-line-added">+       clear_scan_top((uint)i);</span>
      }
  
<span class="udiff-line-modified-removed">-     G1ResetScanTopClosure cl(_scan_top);</span>
<span class="udiff-line-modified-removed">-     G1CollectedHeap::heap()-&gt;heap_region_iterate(&amp;cl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     memset((void*)_iter_claims, 0, _max_regions * sizeof(size_t));</span>
<span class="udiff-line-removed">-     memset((void*)_in_dirty_region_buffer, false, _max_regions * sizeof(bool));</span>
<span class="udiff-line-removed">-     _cur_dirty_region = 0;</span>
<span class="udiff-line-modified-added">+     _all_dirty_regions = new G1DirtyRegions(_max_regions);</span>
<span class="udiff-line-modified-added">+     _next_dirty_regions = new G1DirtyRegions(_max_regions);</span>
    }
  
<span class="udiff-line-modified-removed">-   // Attempt to claim the remembered set of the region for iteration. Returns true</span>
<span class="udiff-line-modified-removed">-   // if this call caused the transition from Unclaimed to Claimed.</span>
<span class="udiff-line-modified-removed">-   inline bool claim_iter(uint region) {</span>
<span class="udiff-line-modified-removed">-     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-modified-removed">-     if (_iter_states[region] != Unclaimed) {</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-modified-added">+   void prepare_for_merge_heap_roots() {</span>
<span class="udiff-line-modified-added">+     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     _next_dirty_regions-&gt;reset();</span>
<span class="udiff-line-modified-added">+     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="udiff-line-modified-added">+       _card_table_scan_state[i] = 0;</span>
      }
<span class="udiff-line-modified-removed">-     G1RemsetIterState res = Atomic::cmpxchg(Claimed, &amp;_iter_states[region], Unclaimed);</span>
<span class="udiff-line-modified-removed">-     return (res == Unclaimed);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     ::memset(_region_scan_chunks, false, _num_total_scan_chunks * sizeof(*_region_scan_chunks));</span>
    }
  
<span class="udiff-line-modified-removed">-   // Try to atomically sets the iteration state to &quot;complete&quot;. Returns true for the</span>
<span class="udiff-line-modified-removed">-   // thread that caused the transition.</span>
<span class="udiff-line-modified-removed">-   inline bool set_iter_complete(uint region) {</span>
<span class="udiff-line-modified-removed">-     if (iter_is_complete(region)) {</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-modified-added">+   // Returns whether the given region contains cards we need to scan. The remembered</span>
<span class="udiff-line-modified-added">+   // set and other sources may contain cards that</span>
<span class="udiff-line-modified-added">+   // - are in uncommitted regions</span>
<span class="udiff-line-modified-added">+   // - are located in the collection set</span>
<span class="udiff-line-modified-added">+   // - are located in free regions</span>
<span class="udiff-line-added">+   // as we do not clean up remembered sets before merging heap roots.</span>
<span class="udiff-line-added">+   bool contains_cards_to_process(uint const region_idx) const {</span>
<span class="udiff-line-added">+     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at_or_null(region_idx);</span>
<span class="udiff-line-added">+     return (hr != NULL &amp;&amp; !hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t num_visited_cards() const {</span>
<span class="udiff-line-added">+     size_t result = 0;</span>
<span class="udiff-line-added">+     for (uint i = 0; i &lt; _num_total_scan_chunks; i++) {</span>
<span class="udiff-line-added">+       if (_region_scan_chunks[i]) {</span>
<span class="udiff-line-added">+         result++;</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-modified-removed">-     G1RemsetIterState res = Atomic::cmpxchg(Complete, &amp;_iter_states[region], Claimed);</span>
<span class="udiff-line-removed">-     return (res == Claimed);</span>
<span class="udiff-line-modified-added">+     return result * (HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>
    }
  
<span class="udiff-line-modified-removed">-   // Returns true if the region&#39;s iteration is complete.</span>
<span class="udiff-line-modified-removed">-   inline bool iter_is_complete(uint region) const {</span>
<span class="udiff-line-removed">-     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-removed">-     return _iter_states[region] == Complete;</span>
<span class="udiff-line-modified-added">+   size_t num_cards_in_dirty_regions() const {</span>
<span class="udiff-line-modified-added">+     return _next_dirty_regions-&gt;size() * HeapRegion::CardsPerRegion;</span>
    }
  
<span class="udiff-line-modified-removed">-   // The current position within the remembered set of the given region.</span>
<span class="udiff-line-modified-removed">-   inline size_t iter_claimed(uint region) const {</span>
<span class="udiff-line-modified-removed">-     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-modified-removed">-     return _iter_claims[region];</span>
<span class="udiff-line-modified-added">+   void set_chunk_region_dirty(size_t const region_card_idx) {</span>
<span class="udiff-line-modified-added">+     size_t chunk_idx = region_card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="udiff-line-modified-added">+     for (uint i = 0; i &lt; _scan_chunks_per_region; i++) {</span>
<span class="udiff-line-modified-added">+       _region_scan_chunks[chunk_idx++] = true;</span>
<span class="udiff-line-added">+     }</span>
    }
  
<span class="udiff-line-modified-removed">-   // Claim the next block of cards within the remembered set of the region with</span>
<span class="udiff-line-modified-removed">-   // step size.</span>
<span class="udiff-line-modified-removed">-   inline size_t iter_claimed_next(uint region, size_t step) {</span>
<span class="udiff-line-modified-removed">-     return Atomic::add(step, &amp;_iter_claims[region]) - step;</span>
<span class="udiff-line-modified-added">+   void set_chunk_dirty(size_t const card_idx) {</span>
<span class="udiff-line-modified-added">+     assert((card_idx &gt;&gt; _scan_chunks_shift) &lt; _num_total_scan_chunks,</span>
<span class="udiff-line-modified-added">+            &quot;Trying to access index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="udiff-line-modified-added">+            card_idx &gt;&gt; _scan_chunks_shift, _num_total_scan_chunks);</span>
<span class="udiff-line-added">+     size_t const chunk_idx = card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="udiff-line-added">+     if (!_region_scan_chunks[chunk_idx]) {</span>
<span class="udiff-line-added">+       _region_scan_chunks[chunk_idx] = true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void cleanup(WorkGang* workers) {</span>
<span class="udiff-line-added">+     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     clear_card_table(workers);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     delete _all_dirty_regions;</span>
<span class="udiff-line-added">+     _all_dirty_regions = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     delete _next_dirty_regions;</span>
<span class="udiff-line-added">+     _next_dirty_regions = NULL;</span>
    }
  
<span class="udiff-line-modified-removed">-   void add_dirty_region(uint region) {</span>
<span class="udiff-line-modified-removed">-     if (_in_dirty_region_buffer[region]) {</span>
<span class="udiff-line-modified-added">+   void iterate_dirty_regions_from(HeapRegionClosure* cl, uint worker_id) {</span>
<span class="udiff-line-modified-added">+     uint num_regions = _next_dirty_regions-&gt;size();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (num_regions == 0) {</span>
        return;
      }
  
<span class="udiff-line-modified-removed">-     if (!Atomic::cmpxchg(true, &amp;_in_dirty_region_buffer[region], false)) {</span>
<span class="udiff-line-modified-removed">-       size_t allocated = Atomic::add(1u, &amp;_cur_dirty_region) - 1;</span>
<span class="udiff-line-modified-removed">-       _dirty_region_buffer[allocated] = region;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     WorkGang* workers = g1h-&gt;workers();</span>
<span class="udiff-line-modified-added">+     uint const max_workers = workers-&gt;active_workers();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint const start_pos = num_regions * worker_id / max_workers;</span>
<span class="udiff-line-added">+     uint cur = start_pos;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     do {</span>
<span class="udiff-line-added">+       bool result = cl-&gt;do_heap_region(g1h-&gt;region_at(_next_dirty_regions-&gt;at(cur)));</span>
<span class="udiff-line-added">+       guarantee(!result, &quot;Not allowed to ask for early termination.&quot;);</span>
<span class="udiff-line-added">+       cur++;</span>
<span class="udiff-line-added">+       if (cur == _next_dirty_regions-&gt;size()) {</span>
<span class="udiff-line-added">+         cur = 0;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     } while (cur != start_pos);</span>
    }
  
<span class="udiff-line-modified-removed">-   HeapWord* scan_top(uint region_idx) const {</span>
<span class="udiff-line-modified-removed">-     return _scan_top[region_idx];</span>
<span class="udiff-line-modified-added">+   void reset_region_claim(uint region_idx) {</span>
<span class="udiff-line-modified-added">+     _collection_set_iter_state[region_idx] = false;</span>
    }
  
<span class="udiff-line-modified-removed">-   // Clear the card table of &quot;dirty&quot; regions.</span>
<span class="udiff-line-modified-removed">-   void clear_card_table(WorkGang* workers) {</span>
<span class="udiff-line-modified-removed">-     if (_cur_dirty_region == 0) {</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-added">+   // Attempt to claim the given region in the collection set for iteration. Returns true</span>
<span class="udiff-line-modified-added">+   // if this call caused the transition from Unclaimed to Claimed.</span>
<span class="udiff-line-modified-added">+   inline bool claim_collection_set_region(uint region) {</span>
<span class="udiff-line-modified-added">+     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-added">+     if (_collection_set_iter_state[region]) {</span>
<span class="udiff-line-added">+       return false;</span>
      }
<span class="udiff-line-added">+     return !Atomic::cmpxchg(&amp;_collection_set_iter_state[region], false, true);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-     size_t const num_chunks = align_up(_cur_dirty_region * HeapRegion::CardsPerRegion, G1ClearCardTableTask::chunk_size()) / G1ClearCardTableTask::chunk_size();</span>
<span class="udiff-line-modified-removed">-     uint const num_workers = (uint)MIN2(num_chunks, (size_t)workers-&gt;active_workers());</span>
<span class="udiff-line-modified-removed">-     size_t const chunk_length = G1ClearCardTableTask::chunk_size() / HeapRegion::CardsPerRegion;</span>
<span class="udiff-line-modified-added">+   bool has_cards_to_scan(uint region) {</span>
<span class="udiff-line-modified-added">+     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-modified-added">+     return _card_table_scan_state[region] &lt; HeapRegion::CardsPerRegion;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-     // Iterate over the dirty cards region list.</span>
<span class="udiff-line-modified-removed">-     G1ClearCardTableTask cl(G1CollectedHeap::heap(), _dirty_region_buffer, _cur_dirty_region, chunk_length);</span>
<span class="udiff-line-modified-added">+   uint claim_cards_to_scan(uint region, uint increment) {</span>
<span class="udiff-line-modified-added">+     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="udiff-line-added">+     return Atomic::fetch_and_add(&amp;_card_table_scan_state[region], increment);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-     log_debug(gc, ergo)(&quot;Running %s using %u workers for &quot; SIZE_FORMAT &quot; &quot;</span>
<span class="udiff-line-modified-removed">-                         &quot;units of work for &quot; SIZE_FORMAT &quot; regions.&quot;,</span>
<span class="udiff-line-modified-removed">-                         cl.name(), num_workers, num_chunks, _cur_dirty_region);</span>
<span class="udiff-line-modified-removed">-     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="udiff-line-modified-added">+   void add_dirty_region(uint const region) {</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-modified-added">+    HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="udiff-line-modified-added">+    assert(!hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive(),</span>
<span class="udiff-line-added">+           &quot;Region %u is not suitable for scanning, is %sin collection set or %s&quot;,</span>
<span class="udiff-line-added">+           hr-&gt;hrm_index(), hr-&gt;in_collection_set() ? &quot;&quot; : &quot;not &quot;, hr-&gt;get_short_type_str());</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     _next_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-modified-removed">-     G1CollectedHeap::heap()-&gt;verifier()-&gt;verify_card_table_cleanup();</span>
<span class="udiff-line-modified-added">+   void add_all_dirty_region(uint region) {</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="udiff-line-added">+     assert(hr-&gt;in_collection_set(),</span>
<span class="udiff-line-added">+            &quot;Only add young regions to all dirty regions directly but %u is %s&quot;,</span>
<span class="udiff-line-added">+            hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
  #endif
<span class="udiff-line-added">+     _all_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_scan_top(uint region_idx, HeapWord* value) {</span>
<span class="udiff-line-added">+     _scan_top[region_idx] = value;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapWord* scan_top(uint region_idx) const {</span>
<span class="udiff-line-added">+     return _scan_top[region_idx];</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void clear_scan_top(uint region_idx) {</span>
<span class="udiff-line-added">+     set_scan_top(region_idx, NULL);</span>
    }
  };
  
  G1RemSet::G1RemSet(G1CollectedHeap* g1h,
                     G1CardTable* ct,
                     G1HotCardCache* hot_card_cache) :
    _scan_state(new G1RemSetScanState()),
<span class="udiff-line-modified-removed">-   _prev_period_summary(),</span>
<span class="udiff-line-modified-added">+   _prev_period_summary(false),</span>
    _g1h(g1h),
<span class="udiff-line-removed">-   _num_conc_refined_cards(0),</span>
    _ct(ct),
    _g1p(_g1h-&gt;policy()),
    _hot_card_cache(hot_card_cache) {
  }
  
  G1RemSet::~G1RemSet() {
<span class="udiff-line-modified-removed">-   if (_scan_state != NULL) {</span>
<span class="udiff-line-removed">-     delete _scan_state;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   delete _scan_state;</span>
  }
  
  uint G1RemSet::num_par_rem_sets() {
    return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,238 +487,776 @@</span>
  void G1RemSet::initialize(size_t capacity, uint max_regions) {
    G1FromCardCache::initialize(num_par_rem_sets(), max_regions);
    _scan_state-&gt;initialize(max_regions);
  }
  
<span class="udiff-line-modified-removed">- G1ScanRSForRegionClosure::G1ScanRSForRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="udiff-line-modified-removed">-                                                    G1ScanObjsDuringScanRSClosure* scan_obj_on_card,</span>
<span class="udiff-line-modified-removed">-                                                    G1ParScanThreadState* pss,</span>
<span class="udiff-line-modified-removed">-                                                    G1GCPhaseTimes::GCParPhases phase,</span>
<span class="udiff-line-modified-removed">-                                                    uint worker_i) :</span>
<span class="udiff-line-removed">-   _g1h(G1CollectedHeap::heap()),</span>
<span class="udiff-line-removed">-   _ct(_g1h-&gt;card_table()),</span>
<span class="udiff-line-removed">-   _pss(pss),</span>
<span class="udiff-line-removed">-   _scan_objs_on_card_cl(scan_obj_on_card),</span>
<span class="udiff-line-removed">-   _scan_state(scan_state),</span>
<span class="udiff-line-removed">-   _phase(phase),</span>
<span class="udiff-line-removed">-   _worker_i(worker_i),</span>
<span class="udiff-line-removed">-   _cards_scanned(0),</span>
<span class="udiff-line-removed">-   _cards_claimed(0),</span>
<span class="udiff-line-removed">-   _cards_skipped(0),</span>
<span class="udiff-line-removed">-   _rem_set_root_scan_time(),</span>
<span class="udiff-line-removed">-   _rem_set_trim_partially_time(),</span>
<span class="udiff-line-removed">-   _strong_code_root_scan_time(),</span>
<span class="udiff-line-removed">-   _strong_code_trim_partially_time() {</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ // Helper class to scan and detect ranges of cards that need to be scanned on the</span>
<span class="udiff-line-modified-added">+ // card table.</span>
<span class="udiff-line-modified-added">+ class G1CardTableScanner : public StackObj {</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   typedef CardTable::CardValue CardValue;</span>
  
<span class="udiff-line-modified-removed">- void G1ScanRSForRegionClosure::claim_card(size_t card_index, const uint region_idx_for_card){</span>
<span class="udiff-line-modified-removed">-   _ct-&gt;set_card_claimed(card_index);</span>
<span class="udiff-line-removed">-   _scan_state-&gt;add_dirty_region(region_idx_for_card);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ private:</span>
<span class="udiff-line-modified-added">+   CardValue* const _base_addr;</span>
  
<span class="udiff-line-modified-removed">- void G1ScanRSForRegionClosure::scan_card(MemRegion mr, uint region_idx_for_card) {</span>
<span class="udiff-line-modified-removed">-   HeapRegion* const card_region = _g1h-&gt;region_at(region_idx_for_card);</span>
<span class="udiff-line-removed">-   assert(!card_region-&gt;is_young(), &quot;Should not scan card in young region %u&quot;, region_idx_for_card);</span>
<span class="udiff-line-removed">-   card_region-&gt;oops_on_card_seq_iterate_careful&lt;true&gt;(mr, _scan_objs_on_card_cl);</span>
<span class="udiff-line-removed">-   _scan_objs_on_card_cl-&gt;trim_queue_partially();</span>
<span class="udiff-line-removed">-   _cards_scanned++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   CardValue* _cur_addr;</span>
<span class="udiff-line-modified-added">+   CardValue* const _end_addr;</span>
  
<span class="udiff-line-modified-removed">- void G1ScanRSForRegionClosure::scan_rem_set_roots(HeapRegion* r) {</span>
<span class="udiff-line-modified-removed">-   EventGCPhaseParallel event;</span>
<span class="udiff-line-removed">-   uint const region_idx = r-&gt;hrm_index();</span>
<span class="udiff-line-modified-added">+   static const size_t ToScanMask = G1CardTable::g1_card_already_scanned;</span>
<span class="udiff-line-modified-added">+   static const size_t ExpandedToScanMask = G1CardTable::WordAlreadyScanned;</span>
  
<span class="udiff-line-modified-removed">-   if (_scan_state-&gt;claim_iter(region_idx)) {</span>
<span class="udiff-line-modified-removed">-     // If we ever free the collection set concurrently, we should also</span>
<span class="udiff-line-removed">-     // clear the card table concurrently therefore we won&#39;t need to</span>
<span class="udiff-line-removed">-     // add regions of the collection set to the dirty cards region.</span>
<span class="udiff-line-removed">-     _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="udiff-line-modified-added">+   bool cur_addr_aligned() const {</span>
<span class="udiff-line-modified-added">+     return ((uintptr_t)_cur_addr) % sizeof(size_t) == 0;</span>
    }
  
<span class="udiff-line-modified-removed">-   if (r-&gt;rem_set()-&gt;cardset_is_empty()) {</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   bool cur_card_is_dirty() const {</span>
<span class="udiff-line-modified-added">+     CardValue value = *_cur_addr;</span>
<span class="udiff-line-added">+     return (value &amp; ToScanMask) == 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool cur_word_of_cards_contains_any_dirty_card() const {</span>
<span class="udiff-line-added">+     assert(cur_addr_aligned(), &quot;Current address should be aligned&quot;);</span>
<span class="udiff-line-added">+     size_t const value = *(size_t*)_cur_addr;</span>
<span class="udiff-line-added">+     return (~value &amp; ExpandedToScanMask) != 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool cur_word_of_cards_all_dirty_cards() const {</span>
<span class="udiff-line-added">+     size_t const value = *(size_t*)_cur_addr;</span>
<span class="udiff-line-added">+     return value == G1CardTable::WordAllDirty;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t get_and_advance_pos() {</span>
<span class="udiff-line-added">+     _cur_addr++;</span>
<span class="udiff-line-added">+     return pointer_delta(_cur_addr, _base_addr, sizeof(CardValue)) - 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   G1CardTableScanner(CardValue* start_card, size_t size) :</span>
<span class="udiff-line-added">+     _base_addr(start_card),</span>
<span class="udiff-line-added">+     _cur_addr(start_card),</span>
<span class="udiff-line-added">+     _end_addr(start_card + size) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     assert(is_aligned(start_card, sizeof(size_t)), &quot;Unaligned start addr &quot; PTR_FORMAT, p2i(start_card));</span>
<span class="udiff-line-added">+     assert(is_aligned(size, sizeof(size_t)), &quot;Unaligned size &quot; SIZE_FORMAT, size);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t find_next_dirty() {</span>
<span class="udiff-line-added">+     while (!cur_addr_aligned()) {</span>
<span class="udiff-line-added">+       if (cur_card_is_dirty()) {</span>
<span class="udiff-line-added">+         return get_and_advance_pos();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _cur_addr++;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="udiff-line-added">+     while (_cur_addr != _end_addr) {</span>
<span class="udiff-line-added">+       if (cur_word_of_cards_contains_any_dirty_card()) {</span>
<span class="udiff-line-added">+         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="udiff-line-added">+           if (cur_card_is_dirty()) {</span>
<span class="udiff-line-added">+             return get_and_advance_pos();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           _cur_addr++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert(false, &quot;Should not reach here given we detected a dirty card in the word.&quot;);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _cur_addr += sizeof(size_t);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return get_and_advance_pos();</span>
    }
  
<span class="udiff-line-modified-removed">-   // We claim cards in blocks so as to reduce the contention.</span>
<span class="udiff-line-modified-removed">-   size_t const block_size = G1RSetScanBlockSize;</span>
<span class="udiff-line-modified-added">+   size_t find_next_non_dirty() {</span>
<span class="udiff-line-modified-added">+     assert(_cur_addr &lt;= _end_addr, &quot;Not allowed to search for marks after area.&quot;);</span>
  
<span class="udiff-line-modified-removed">-   HeapRegionRemSetIterator iter(r-&gt;rem_set());</span>
<span class="udiff-line-modified-removed">-   size_t card_index;</span>
<span class="udiff-line-modified-added">+     while (!cur_addr_aligned()) {</span>
<span class="udiff-line-modified-added">+       if (!cur_card_is_dirty()) {</span>
<span class="udiff-line-added">+         return get_and_advance_pos();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _cur_addr++;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-   size_t claimed_card_block = _scan_state-&gt;iter_claimed_next(region_idx, block_size);</span>
<span class="udiff-line-modified-removed">-   for (size_t current_card = 0; iter.has_next(card_index); current_card++) {</span>
<span class="udiff-line-modified-removed">-     if (current_card &gt;= claimed_card_block + block_size) {</span>
<span class="udiff-line-modified-removed">-       claimed_card_block = _scan_state-&gt;iter_claimed_next(region_idx, block_size);</span>
<span class="udiff-line-modified-added">+     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="udiff-line-modified-added">+     while (_cur_addr != _end_addr) {</span>
<span class="udiff-line-modified-added">+       if (!cur_word_of_cards_all_dirty_cards()) {</span>
<span class="udiff-line-modified-added">+         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="udiff-line-added">+           if (!cur_card_is_dirty()) {</span>
<span class="udiff-line-added">+             return get_and_advance_pos();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           _cur_addr++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert(false, &quot;Should not reach here given we detected a non-dirty card in the word.&quot;);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _cur_addr += sizeof(size_t);</span>
      }
<span class="udiff-line-modified-removed">-     if (current_card &lt; claimed_card_block) {</span>
<span class="udiff-line-modified-removed">-       _cards_skipped++;</span>
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-added">+     return get_and_advance_pos();</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Helper class to claim dirty chunks within the card table.</span>
<span class="udiff-line-added">+ class G1CardTableChunkClaimer {</span>
<span class="udiff-line-added">+   G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+   uint _region_idx;</span>
<span class="udiff-line-added">+   uint _cur_claim;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   G1CardTableChunkClaimer(G1RemSetScanState* scan_state, uint region_idx) :</span>
<span class="udiff-line-added">+     _scan_state(scan_state),</span>
<span class="udiff-line-added">+     _region_idx(region_idx),</span>
<span class="udiff-line-added">+     _cur_claim(0) {</span>
<span class="udiff-line-added">+     guarantee(size() &lt;= HeapRegion::CardsPerRegion, &quot;Should not claim more space than possible.&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool has_next() {</span>
<span class="udiff-line-added">+     while (true) {</span>
<span class="udiff-line-added">+       _cur_claim = _scan_state-&gt;claim_cards_to_scan(_region_idx, size());</span>
<span class="udiff-line-added">+       if (_cur_claim &gt;= HeapRegion::CardsPerRegion) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (_scan_state-&gt;chunk_needs_scan(_region_idx, _cur_claim)) {</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-modified-removed">-     _cards_claimed++;</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-modified-removed">-     HeapWord* const card_start = _g1h-&gt;bot()-&gt;address_for_index_raw(card_index);</span>
<span class="udiff-line-modified-removed">-     uint const region_idx_for_card = _g1h-&gt;addr_to_region(card_start);</span>
<span class="udiff-line-modified-added">+   uint value() const { return _cur_claim; }</span>
<span class="udiff-line-modified-added">+   uint size() const { return _scan_state-&gt;scan_chunk_size(); }</span>
<span class="udiff-line-added">+ };</span>
  
<span class="udiff-line-added">+ // Scans a heap region for dirty cards.</span>
<span class="udiff-line-added">+ class G1ScanHRForRegionClosure : public HeapRegionClosure {</span>
<span class="udiff-line-added">+   G1CollectedHeap* _g1h;</span>
<span class="udiff-line-added">+   G1CardTable* _ct;</span>
<span class="udiff-line-added">+   G1BlockOffsetTable* _bot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1ParScanThreadState* _pss;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1GCPhaseTimes::GCParPhases _phase;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint   _worker_id;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t _cards_scanned;</span>
<span class="udiff-line-added">+   size_t _blocks_scanned;</span>
<span class="udiff-line-added">+   size_t _chunks_claimed;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Tickspan _rem_set_root_scan_time;</span>
<span class="udiff-line-added">+   Tickspan _rem_set_trim_partially_time;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The address to which this thread already scanned (walked the heap) up to during</span>
<span class="udiff-line-added">+   // card scanning (exclusive).</span>
<span class="udiff-line-added">+   HeapWord* _scanned_to;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapWord* scan_memregion(uint region_idx_for_card, MemRegion mr) {</span>
<span class="udiff-line-added">+     HeapRegion* const card_region = _g1h-&gt;region_at(region_idx_for_card);</span>
<span class="udiff-line-added">+     G1ScanCardClosure card_cl(_g1h, _pss);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     HeapWord* const scanned_to = card_region-&gt;oops_on_memregion_seq_iterate_careful&lt;true&gt;(mr, &amp;card_cl);</span>
<span class="udiff-line-added">+     assert(scanned_to != NULL, &quot;Should be able to scan range&quot;);</span>
<span class="udiff-line-added">+     assert(scanned_to &gt;= mr.end(), &quot;Scanned to &quot; PTR_FORMAT &quot; less than range &quot; PTR_FORMAT, p2i(scanned_to), p2i(mr.end()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _pss-&gt;trim_queue_partially();</span>
<span class="udiff-line-added">+     return scanned_to;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void do_claimed_block(uint const region_idx_for_card, size_t const first_card, size_t const num_cards) {</span>
<span class="udiff-line-added">+     HeapWord* const card_start = _bot-&gt;address_for_index_raw(first_card);</span>
  #ifdef ASSERT
      HeapRegion* hr = _g1h-&gt;region_at_or_null(region_idx_for_card);
      assert(hr == NULL || hr-&gt;is_in_reserved(card_start),
<span class="udiff-line-modified-removed">-            &quot;Card start &quot; PTR_FORMAT &quot; to scan outside of region %u&quot;, p2i(card_start), _g1h-&gt;region_at(region_idx_for_card)-&gt;hrm_index());</span>
<span class="udiff-line-modified-added">+              &quot;Card start &quot; PTR_FORMAT &quot; to scan outside of region %u&quot;, p2i(card_start), _g1h-&gt;region_at(region_idx_for_card)-&gt;hrm_index());</span>
  #endif
      HeapWord* const top = _scan_state-&gt;scan_top(region_idx_for_card);
      if (card_start &gt;= top) {
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     HeapWord* scan_end = MIN2(card_start + (num_cards &lt;&lt; BOTConstants::LogN_words), top);</span>
<span class="udiff-line-added">+     if (_scanned_to &gt;= scan_end) {</span>
<span class="udiff-line-added">+       return;</span>
      }
<span class="udiff-line-added">+     MemRegion mr(MAX2(card_start, _scanned_to), scan_end);</span>
<span class="udiff-line-added">+     _scanned_to = scan_memregion(region_idx_for_card, mr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     _cards_scanned += num_cards;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ALWAYSINLINE void do_card_block(uint const region_idx, size_t const first_card, size_t const num_cards) {</span>
<span class="udiff-line-added">+     _ct-&gt;mark_as_scanned(first_card, num_cards);</span>
<span class="udiff-line-added">+     do_claimed_block(region_idx, first_card, num_cards);</span>
<span class="udiff-line-added">+     _blocks_scanned++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+    void scan_heap_roots(HeapRegion* r) {</span>
<span class="udiff-line-added">+     EventGCPhaseParallel event;</span>
<span class="udiff-line-added">+     uint const region_idx = r-&gt;hrm_index();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     G1CardTableChunkClaimer claim(_scan_state, region_idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Set the current scan &quot;finger&quot; to NULL for every heap region to scan. Since</span>
<span class="udiff-line-added">+     // the claim value is monotonically increasing, the check to not scan below this</span>
<span class="udiff-line-added">+     // will filter out objects spanning chunks within the region too then, as opposed</span>
<span class="udiff-line-added">+     // to resetting this value for every claim.</span>
<span class="udiff-line-added">+     _scanned_to = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     while (claim.has_next()) {</span>
<span class="udiff-line-added">+       size_t const region_card_base_idx = ((size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion) + claim.value();</span>
<span class="udiff-line-added">+       CardTable::CardValue* const base_addr = _ct-&gt;byte_for_index(region_card_base_idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       G1CardTableScanner scan(base_addr, claim.size());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       size_t first_scan_idx = scan.find_next_dirty();</span>
<span class="udiff-line-added">+       while (first_scan_idx != claim.size()) {</span>
<span class="udiff-line-added">+         assert(*_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx) &lt;= 0x1, &quot;is %d at region %u idx &quot; SIZE_FORMAT, *_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx), region_idx, first_scan_idx);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         size_t const last_scan_idx = scan.find_next_non_dirty();</span>
<span class="udiff-line-added">+         size_t const len = last_scan_idx - first_scan_idx;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         do_card_block(region_idx, region_card_base_idx + first_scan_idx, len);</span>
  
<span class="udiff-line-modified-removed">-     // If the card is dirty, then G1 will scan it during Update RS.</span>
<span class="udiff-line-modified-removed">-     if (_ct-&gt;is_card_claimed(card_index) || _ct-&gt;is_card_dirty(card_index)) {</span>
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-added">+         if (last_scan_idx == claim.size()) {</span>
<span class="udiff-line-modified-added">+           break;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         first_scan_idx = scan.find_next_dirty();</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _chunks_claimed++;</span>
      }
  
<span class="udiff-line-modified-removed">-     // We claim lazily (so races are possible but they&#39;re benign), which reduces the</span>
<span class="udiff-line-modified-removed">-     // number of duplicate scans (the rsets of the regions in the cset can intersect).</span>
<span class="udiff-line-modified-removed">-     // Claim the card after checking bounds above: the remembered set may contain</span>
<span class="udiff-line-modified-removed">-     // random cards into current survivor, and we would then have an incorrectly</span>
<span class="udiff-line-modified-removed">-     // claimed card in survivor space. Card table clear does not reset the card table</span>
<span class="udiff-line-modified-removed">-     // of survivor space regions.</span>
<span class="udiff-line-modified-removed">-     claim_card(card_index, region_idx_for_card);</span>
<span class="udiff-line-modified-added">+     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::ScanHR));</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   G1ScanHRForRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="udiff-line-modified-added">+                            G1ParScanThreadState* pss,</span>
<span class="udiff-line-modified-added">+                            uint worker_id,</span>
<span class="udiff-line-added">+                            G1GCPhaseTimes::GCParPhases phase) :</span>
<span class="udiff-line-added">+     _g1h(G1CollectedHeap::heap()),</span>
<span class="udiff-line-added">+     _ct(_g1h-&gt;card_table()),</span>
<span class="udiff-line-added">+     _bot(_g1h-&gt;bot()),</span>
<span class="udiff-line-added">+     _pss(pss),</span>
<span class="udiff-line-added">+     _scan_state(scan_state),</span>
<span class="udiff-line-added">+     _phase(phase),</span>
<span class="udiff-line-added">+     _worker_id(worker_id),</span>
<span class="udiff-line-added">+     _cards_scanned(0),</span>
<span class="udiff-line-added">+     _blocks_scanned(0),</span>
<span class="udiff-line-added">+     _chunks_claimed(0),</span>
<span class="udiff-line-added">+     _rem_set_root_scan_time(),</span>
<span class="udiff-line-added">+     _rem_set_trim_partially_time(),</span>
<span class="udiff-line-added">+     _scanned_to(NULL) {</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-     MemRegion const mr(card_start, MIN2(card_start + BOTConstants::N_words, top));</span>
<span class="udiff-line-modified-added">+   bool do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-added">+     assert(!r-&gt;in_collection_set() &amp;&amp; r-&gt;is_old_or_humongous_or_archive(),</span>
<span class="udiff-line-added">+            &quot;Should only be called on old gen non-collection set regions but region %u is not.&quot;,</span>
<span class="udiff-line-added">+            r-&gt;hrm_index());</span>
<span class="udiff-line-added">+     uint const region_idx = r-&gt;hrm_index();</span>
  
<span class="udiff-line-modified-removed">-     scan_card(mr, region_idx_for_card);</span>
<span class="udiff-line-modified-added">+     if (_scan_state-&gt;has_cards_to_scan(region_idx)) {</span>
<span class="udiff-line-added">+       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_root_scan_time, _rem_set_trim_partially_time);</span>
<span class="udiff-line-added">+       scan_heap_roots(r);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return false;</span>
    }
<span class="udiff-line-removed">-   event.commit(GCId::current(), _worker_i, G1GCPhaseTimes::phase_name(_phase));</span>
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-modified-removed">- void G1ScanRSForRegionClosure::scan_strong_code_roots(HeapRegion* r) {</span>
<span class="udiff-line-modified-removed">-   EventGCPhaseParallel event;</span>
<span class="udiff-line-modified-removed">-   // We pass a weak code blobs closure to the remembered set scanning because we want to avoid</span>
<span class="udiff-line-modified-removed">-   // treating the nmethods visited to act as roots for concurrent marking.</span>
<span class="udiff-line-modified-removed">-   // We only want to make sure that the oops in the nmethods are adjusted with regard to the</span>
<span class="udiff-line-modified-removed">-   // objects copied by the current evacuation.</span>
<span class="udiff-line-modified-removed">-   r-&gt;strong_code_roots_do(_pss-&gt;closures()-&gt;weak_codeblobs());</span>
<span class="udiff-line-modified-removed">-   event.commit(GCId::current(), _worker_i, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::CodeRoots));</span>
<span class="udiff-line-modified-added">+   Tickspan rem_set_root_scan_time() const { return _rem_set_root_scan_time; }</span>
<span class="udiff-line-modified-added">+   Tickspan rem_set_trim_partially_time() const { return _rem_set_trim_partially_time; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   size_t cards_scanned() const { return _cards_scanned; }</span>
<span class="udiff-line-modified-added">+   size_t blocks_scanned() const { return _blocks_scanned; }</span>
<span class="udiff-line-modified-added">+   size_t chunks_claimed() const { return _chunks_claimed; }</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ void G1RemSet::scan_heap_roots(G1ParScanThreadState* pss,</span>
<span class="udiff-line-added">+                             uint worker_id,</span>
<span class="udiff-line-added">+                             G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="udiff-line-added">+                             G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="udiff-line-added">+   G1ScanHRForRegionClosure cl(_scan_state, pss, worker_id, scan_phase);</span>
<span class="udiff-line-added">+   _scan_state-&gt;iterate_dirty_regions_from(&amp;cl, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   p-&gt;record_or_add_time_secs(objcopy_phase, worker_id, cl.rem_set_trim_partially_time().seconds());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_root_scan_time().seconds());</span>
<span class="udiff-line-added">+   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.cards_scanned(), G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="udiff-line-added">+   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.blocks_scanned(), G1GCPhaseTimes::ScanHRScannedBlocks);</span>
<span class="udiff-line-added">+   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.chunks_claimed(), G1GCPhaseTimes::ScanHRClaimedChunks);</span>
  }
  
<span class="udiff-line-modified-removed">- bool G1ScanRSForRegionClosure::do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-modified-removed">-   assert(r-&gt;in_collection_set(),</span>
<span class="udiff-line-modified-removed">-          &quot;Should only be called on elements of the collection set but region %u is not.&quot;,</span>
<span class="udiff-line-modified-removed">-          r-&gt;hrm_index());</span>
<span class="udiff-line-modified-removed">-   uint const region_idx = r-&gt;hrm_index();</span>
<span class="udiff-line-modified-added">+ // Heap region closure to be applied to all regions in the current collection set</span>
<span class="udiff-line-modified-added">+ // increment to fix up non-card related roots.</span>
<span class="udiff-line-modified-added">+ class G1ScanCollectionSetRegionClosure : public HeapRegionClosure {</span>
<span class="udiff-line-modified-added">+   G1ParScanThreadState* _pss;</span>
<span class="udiff-line-modified-added">+   G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1GCPhaseTimes::GCParPhases _scan_phase;</span>
<span class="udiff-line-added">+   G1GCPhaseTimes::GCParPhases _code_roots_phase;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint _worker_id;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t _opt_refs_scanned;</span>
<span class="udiff-line-added">+   size_t _opt_refs_memory_used;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Tickspan _strong_code_root_scan_time;</span>
<span class="udiff-line-added">+   Tickspan _strong_code_trim_partially_time;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Tickspan _rem_set_opt_root_scan_time;</span>
<span class="udiff-line-added">+   Tickspan _rem_set_opt_trim_partially_time;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void scan_opt_rem_set_roots(HeapRegion* r) {</span>
<span class="udiff-line-added">+     EventGCPhaseParallel event;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     G1OopStarChunkedList* opt_rem_set_list = _pss-&gt;oops_into_optional_region(r);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     G1ScanCardClosure scan_cl(G1CollectedHeap::heap(), _pss);</span>
<span class="udiff-line-added">+     G1ScanRSForOptionalClosure cl(G1CollectedHeap::heap(), &amp;scan_cl);</span>
<span class="udiff-line-added">+     _opt_refs_scanned += opt_rem_set_list-&gt;oops_do(&amp;cl, _pss-&gt;closures()-&gt;strong_oops());</span>
<span class="udiff-line-added">+     _opt_refs_memory_used += opt_rem_set_list-&gt;used_memory();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   G1ScanCollectionSetRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="udiff-line-added">+                                    G1ParScanThreadState* pss,</span>
<span class="udiff-line-added">+                                    uint worker_id,</span>
<span class="udiff-line-added">+                                    G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="udiff-line-added">+                                    G1GCPhaseTimes::GCParPhases code_roots_phase) :</span>
<span class="udiff-line-added">+     _pss(pss),</span>
<span class="udiff-line-added">+     _scan_state(scan_state),</span>
<span class="udiff-line-added">+     _scan_phase(scan_phase),</span>
<span class="udiff-line-added">+     _code_roots_phase(code_roots_phase),</span>
<span class="udiff-line-added">+     _worker_id(worker_id),</span>
<span class="udiff-line-added">+     _opt_refs_scanned(0),</span>
<span class="udiff-line-added">+     _opt_refs_memory_used(0),</span>
<span class="udiff-line-added">+     _strong_code_root_scan_time(),</span>
<span class="udiff-line-added">+     _strong_code_trim_partially_time(),</span>
<span class="udiff-line-added">+     _rem_set_opt_root_scan_time(),</span>
<span class="udiff-line-added">+     _rem_set_opt_trim_partially_time() { }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-added">+     uint const region_idx = r-&gt;hrm_index();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // The individual references for the optional remembered set are per-worker, so we</span>
<span class="udiff-line-added">+     // always need to scan them.</span>
<span class="udiff-line-added">+     if (r-&gt;has_index_in_opt_cset()) {</span>
<span class="udiff-line-added">+       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_opt_root_scan_time, _rem_set_opt_trim_partially_time);</span>
<span class="udiff-line-added">+       scan_opt_rem_set_roots(r);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (_scan_state-&gt;claim_collection_set_region(region_idx)) {</span>
<span class="udiff-line-added">+       EventGCPhaseParallel event;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       G1EvacPhaseWithTrimTimeTracker timer(_pss, _strong_code_root_scan_time, _strong_code_trim_partially_time);</span>
<span class="udiff-line-added">+       // Scan the strong code root list attached to the current region</span>
<span class="udiff-line-added">+       r-&gt;strong_code_roots_do(_pss-&gt;closures()-&gt;weak_codeblobs());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-removed">-   // Do an early out if we know we are complete.</span>
<span class="udiff-line-removed">-   if (_scan_state-&gt;iter_is_complete(region_idx)) {</span>
      return false;
    }
  
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-removed">-     G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_root_scan_time, _rem_set_trim_partially_time);</span>
<span class="udiff-line-modified-removed">-     scan_rem_set_roots(r);</span>
<span class="udiff-line-modified-added">+   Tickspan strong_code_root_scan_time() const { return _strong_code_root_scan_time;  }</span>
<span class="udiff-line-modified-added">+   Tickspan strong_code_root_trim_partially_time() const { return _strong_code_trim_partially_time; }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   Tickspan rem_set_opt_root_scan_time() const { return _rem_set_opt_root_scan_time; }</span>
<span class="udiff-line-added">+   Tickspan rem_set_opt_trim_partially_time() const { return _rem_set_opt_trim_partially_time; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t opt_refs_scanned() const { return _opt_refs_scanned; }</span>
<span class="udiff-line-added">+   size_t opt_refs_memory_used() const { return _opt_refs_memory_used; }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1RemSet::scan_collection_set_regions(G1ParScanThreadState* pss,</span>
<span class="udiff-line-added">+                                            uint worker_id,</span>
<span class="udiff-line-added">+                                            G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="udiff-line-added">+                                            G1GCPhaseTimes::GCParPhases coderoots_phase,</span>
<span class="udiff-line-added">+                                            G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="udiff-line-added">+   G1ScanCollectionSetRegionClosure cl(_scan_state, pss, worker_id, scan_phase, coderoots_phase);</span>
<span class="udiff-line-added">+   _g1h-&gt;collection_set_iterate_increment_from(&amp;cl, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1GCPhaseTimes* p = _g1h-&gt;phase_times();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_root_scan_time().seconds());</span>
<span class="udiff-line-added">+   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_trim_partially_time().seconds());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   p-&gt;record_or_add_time_secs(coderoots_phase, worker_id, cl.strong_code_root_scan_time().seconds());</span>
<span class="udiff-line-added">+   p-&gt;add_time_secs(objcopy_phase, worker_id, cl.strong_code_root_trim_partially_time().seconds());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // At this time we record some metrics only for the evacuations after the initial one.</span>
<span class="udiff-line-added">+   if (scan_phase == G1GCPhaseTimes::OptScanHR) {</span>
<span class="udiff-line-added">+     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_scanned(), G1GCPhaseTimes::ScanHRScannedOptRefs);</span>
<span class="udiff-line-added">+     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_memory_used(), G1GCPhaseTimes::ScanHRUsedMemory);</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (_scan_state-&gt;set_iter_complete(region_idx)) {</span>
<span class="udiff-line-modified-removed">-     G1EvacPhaseWithTrimTimeTracker timer(_pss, _strong_code_root_scan_time, _strong_code_trim_partially_time);</span>
<span class="udiff-line-modified-removed">-     // Scan the strong code root list attached to the current region</span>
<span class="udiff-line-modified-removed">-     scan_strong_code_roots(r);</span>
<span class="udiff-line-modified-added">+ void G1RemSet::prepare_region_for_scan(HeapRegion* region) {</span>
<span class="udiff-line-modified-added">+   uint hrm_index = region-&gt;hrm_index();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (region-&gt;in_collection_set()) {</span>
<span class="udiff-line-added">+     // Young regions had their card table marked as young at their allocation;</span>
<span class="udiff-line-added">+     // we need to make sure that these marks are cleared at the end of GC, *but*</span>
<span class="udiff-line-added">+     // they should not be scanned for cards.</span>
<span class="udiff-line-added">+     // So directly add them to the &quot;all_dirty_regions&quot;.</span>
<span class="udiff-line-added">+     // Same for regions in the (initial) collection set: they may contain cards from</span>
<span class="udiff-line-added">+     // the log buffers, make sure they are cleaned.</span>
<span class="udiff-line-added">+     _scan_state-&gt;add_all_dirty_region(hrm_index);</span>
<span class="udiff-line-added">+   } else if (region-&gt;is_old_or_humongous_or_archive()) {</span>
<span class="udiff-line-added">+     _scan_state-&gt;set_scan_top(hrm_index, region-&gt;top());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(region-&gt;is_free(), &quot;Should only be free region at this point %s&quot;, region-&gt;get_type_str());</span>
    }
<span class="udiff-line-removed">-   return false;</span>
  }
  
<span class="udiff-line-modified-removed">- void G1RemSet::scan_rem_set(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="udiff-line-modified-removed">-   G1ScanObjsDuringScanRSClosure scan_cl(_g1h, pss);</span>
<span class="udiff-line-modified-removed">-   G1ScanRSForRegionClosure cl(_scan_state, &amp;scan_cl, pss, G1GCPhaseTimes::ScanRS, worker_i);</span>
<span class="udiff-line-removed">-   _g1h-&gt;collection_set_iterate_from(&amp;cl, worker_i);</span>
<span class="udiff-line-modified-added">+ void G1RemSet::prepare_for_scan_heap_roots() {</span>
<span class="udiff-line-modified-added">+   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-modified-added">+   dcqs.concatenate_logs();</span>
  
<span class="udiff-line-modified-removed">-   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>
<span class="udiff-line-modified-added">+   _scan_state-&gt;prepare();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   p-&gt;record_time_secs(G1GCPhaseTimes::ScanRS, worker_i, cl.rem_set_root_scan_time().seconds());</span>
<span class="udiff-line-removed">-   p-&gt;add_time_secs(G1GCPhaseTimes::ObjCopy, worker_i, cl.rem_set_trim_partially_time().seconds());</span>
<span class="udiff-line-modified-added">+ class G1MergeHeapRootsTask : public AbstractGangTask {</span>
  
<span class="udiff-line-modified-removed">-   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_scanned(), G1GCPhaseTimes::ScanRSScannedCards);</span>
<span class="udiff-line-modified-removed">-   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_claimed(), G1GCPhaseTimes::ScanRSClaimedCards);</span>
<span class="udiff-line-modified-removed">-   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_skipped(), G1GCPhaseTimes::ScanRSSkippedCards);</span>
<span class="udiff-line-modified-added">+   // Visitor for remembered sets, dropping entries onto the card table.</span>
<span class="udiff-line-modified-added">+   class G1MergeCardSetClosure : public HeapRegionClosure {</span>
<span class="udiff-line-modified-added">+     G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+     G1CardTable* _ct;</span>
  
<span class="udiff-line-modified-removed">-   p-&gt;record_time_secs(G1GCPhaseTimes::CodeRoots, worker_i, cl.strong_code_root_scan_time().seconds());</span>
<span class="udiff-line-modified-removed">-   p-&gt;add_time_secs(G1GCPhaseTimes::ObjCopy, worker_i, cl.strong_code_root_trim_partially_time().seconds());</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+     uint _merged_sparse;</span>
<span class="udiff-line-modified-added">+     uint _merged_fine;</span>
<span class="udiff-line-modified-added">+     uint _merged_coarse;</span>
  
<span class="udiff-line-modified-removed">- // Closure used for updating rem sets. Only called during an evacuation pause.</span>
<span class="udiff-line-modified-removed">- class G1RefineCardClosure: public G1CardTableEntryClosure {</span>
<span class="udiff-line-modified-removed">-   G1RemSet* _g1rs;</span>
<span class="udiff-line-modified-removed">-   G1ScanObjsDuringUpdateRSClosure* _update_rs_cl;</span>
<span class="udiff-line-modified-added">+     size_t _cards_dirty;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Returns if the region contains cards we need to scan. If so, remember that</span>
<span class="udiff-line-modified-added">+     // region in the current set of dirty regions.</span>
<span class="udiff-line-added">+     bool remember_if_interesting(uint const region_idx) {</span>
<span class="udiff-line-added">+       if (!_scan_state-&gt;contains_cards_to_process(region_idx)) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+     G1MergeCardSetClosure(G1RemSetScanState* scan_state) :</span>
<span class="udiff-line-added">+       _scan_state(scan_state),</span>
<span class="udiff-line-added">+       _ct(G1CollectedHeap::heap()-&gt;card_table()),</span>
<span class="udiff-line-added">+       _merged_sparse(0),</span>
<span class="udiff-line-added">+       _merged_fine(0),</span>
<span class="udiff-line-added">+       _merged_coarse(0),</span>
<span class="udiff-line-added">+       _cards_dirty(0) { }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void next_coarse_prt(uint const region_idx) {</span>
<span class="udiff-line-added">+       if (!remember_if_interesting(region_idx)) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _merged_coarse++;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       size_t region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="udiff-line-added">+       _cards_dirty += _ct-&gt;mark_region_dirty(region_base_idx, HeapRegion::CardsPerRegion);</span>
<span class="udiff-line-added">+       _scan_state-&gt;set_chunk_region_dirty(region_base_idx);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void next_fine_prt(uint const region_idx, BitMap* bm) {</span>
<span class="udiff-line-added">+       if (!remember_if_interesting(region_idx)) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _merged_fine++;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="udiff-line-added">+       BitMap::idx_t cur = bm-&gt;get_next_one_offset(0);</span>
<span class="udiff-line-added">+       while (cur != bm-&gt;size()) {</span>
<span class="udiff-line-added">+         _cards_dirty += _ct-&gt;mark_clean_as_dirty(region_base_idx + cur);</span>
<span class="udiff-line-added">+         _scan_state-&gt;set_chunk_dirty(region_base_idx + cur);</span>
<span class="udiff-line-added">+         cur = bm-&gt;get_next_one_offset(cur + 1);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {</span>
<span class="udiff-line-added">+       if (!remember_if_interesting(region_idx)) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _merged_sparse++;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="udiff-line-added">+       for (uint i = 0; i &lt; num_cards; i++) {</span>
<span class="udiff-line-added">+         size_t card_idx = region_base_idx + cards[i];</span>
<span class="udiff-line-added">+         _cards_dirty += _ct-&gt;mark_clean_as_dirty(card_idx);</span>
<span class="udiff-line-added">+         _scan_state-&gt;set_chunk_dirty(card_idx);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-added">+       assert(r-&gt;in_collection_set() || r-&gt;is_starts_humongous(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       HeapRegionRemSet* rem_set = r-&gt;rem_set();</span>
<span class="udiff-line-added">+       if (!rem_set-&gt;is_empty()) {</span>
<span class="udiff-line-added">+         rem_set-&gt;iterate_prts(*this);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t merged_sparse() const { return _merged_sparse; }</span>
<span class="udiff-line-added">+     size_t merged_fine() const { return _merged_fine; }</span>
<span class="udiff-line-added">+     size_t merged_coarse() const { return _merged_coarse; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Visitor for the remembered sets of humongous candidate regions to merge their</span>
<span class="udiff-line-added">+   // remembered set into the card table.</span>
<span class="udiff-line-added">+   class G1FlushHumongousCandidateRemSets : public HeapRegionClosure {</span>
<span class="udiff-line-added">+     G1MergeCardSetClosure _cl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+     G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="udiff-line-added">+       G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (!r-&gt;is_starts_humongous() ||</span>
<span class="udiff-line-added">+           !g1h-&gt;region_attr(r-&gt;hrm_index()).is_humongous() ||</span>
<span class="udiff-line-added">+           r-&gt;rem_set()-&gt;is_empty()) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       guarantee(r-&gt;rem_set()-&gt;occupancy_less_or_equal_than(G1RSetSparseRegionEntries),</span>
<span class="udiff-line-added">+                 &quot;Found a not-small remembered set here. This is inconsistent with previous assumptions.&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       _cl.do_heap_region(r);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // We should only clear the card based remembered set here as we will not</span>
<span class="udiff-line-added">+       // implicitly rebuild anything else during eager reclaim. Note that at the moment</span>
<span class="udiff-line-added">+       // (and probably never) we do not enter this path if there are other kind of</span>
<span class="udiff-line-added">+       // remembered sets for this region.</span>
<span class="udiff-line-added">+       r-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);</span>
<span class="udiff-line-added">+       // Clear_locked() above sets the state to Empty. However we want to continue</span>
<span class="udiff-line-added">+       // collecting remembered set entries for humongous regions that were not</span>
<span class="udiff-line-added">+       // reclaimed.</span>
<span class="udiff-line-added">+       r-&gt;rem_set()-&gt;set_state_complete();</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+       G1HeapRegionAttr region_attr = g1h-&gt;region_attr(r-&gt;hrm_index());</span>
<span class="udiff-line-added">+       assert(region_attr.needs_remset_update(), &quot;must be&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       assert(r-&gt;rem_set()-&gt;is_empty(), &quot;At this point any humongous candidate remembered set must be empty.&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t merged_sparse() const { return _cl.merged_sparse(); }</span>
<span class="udiff-line-added">+     size_t merged_fine() const { return _cl.merged_fine(); }</span>
<span class="udiff-line-added">+     size_t merged_coarse() const { return _cl.merged_coarse(); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t cards_dirty() const { return _cl.cards_dirty(); }</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Visitor for the log buffer entries to merge them into the card table.</span>
<span class="udiff-line-added">+   class G1MergeLogBufferCardsClosure : public G1CardTableEntryClosure {</span>
<span class="udiff-line-added">+     G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+     G1CardTable* _ct;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t _cards_dirty;</span>
<span class="udiff-line-added">+     size_t _cards_skipped;</span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+     G1MergeLogBufferCardsClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :</span>
<span class="udiff-line-added">+       _scan_state(scan_state), _ct(g1h-&gt;card_table()), _cards_dirty(0), _cards_skipped(0)</span>
<span class="udiff-line-added">+     {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void do_card_ptr(CardValue* card_ptr, uint worker_id) {</span>
<span class="udiff-line-added">+       // The only time we care about recording cards that</span>
<span class="udiff-line-added">+       // contain references that point into the collection set</span>
<span class="udiff-line-added">+       // is during RSet updating within an evacuation pause.</span>
<span class="udiff-line-added">+       // In this case worker_id should be the id of a GC worker thread.</span>
<span class="udiff-line-added">+       assert(SafepointSynchronize::is_at_safepoint(), &quot;not during an evacuation pause&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       uint const region_idx = _ct-&gt;region_idx_for(card_ptr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // The second clause must come after - the log buffers might contain cards to uncommited</span>
<span class="udiff-line-added">+       // regions.</span>
<span class="udiff-line-added">+       // This code may count duplicate entries in the log buffers (even if rare) multiple</span>
<span class="udiff-line-added">+       // times.</span>
<span class="udiff-line-added">+       if (_scan_state-&gt;contains_cards_to_process(region_idx) &amp;&amp; (*card_ptr == G1CardTable::dirty_card_val())) {</span>
<span class="udiff-line-added">+         _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="udiff-line-added">+         _scan_state-&gt;set_chunk_dirty(_ct-&gt;index_for_cardvalue(card_ptr));</span>
<span class="udiff-line-added">+         _cards_dirty++;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // We may have had dirty cards in the (initial) collection set (or the</span>
<span class="udiff-line-added">+         // young regions which are always in the initial collection set). We do</span>
<span class="udiff-line-added">+         // not fix their cards here: we already added these regions to the set of</span>
<span class="udiff-line-added">+         // regions to clear the card table at the end during the prepare() phase.</span>
<span class="udiff-line-added">+         _cards_skipped++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="udiff-line-added">+     size_t cards_skipped() const { return _cards_skipped; }</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapRegionClaimer _hr_claimer;</span>
<span class="udiff-line-added">+   G1RemSetScanState* _scan_state;</span>
<span class="udiff-line-added">+   BufferNode::Stack _dirty_card_buffers;</span>
<span class="udiff-line-added">+   bool _initial_evacuation;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   volatile bool _fast_reclaim_handled;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void apply_closure_to_dirty_card_buffers(G1MergeLogBufferCardsClosure* cl, uint worker_id) {</span>
<span class="udiff-line-added">+     G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-added">+     size_t buffer_size = dcqs.buffer_size();</span>
<span class="udiff-line-added">+     while (BufferNode* node = _dirty_card_buffers.pop()) {</span>
<span class="udiff-line-added">+       cl-&gt;apply_to_buffer(node, buffer_size, worker_id);</span>
<span class="udiff-line-added">+       dcqs.deallocate_buffer(node);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-removed">-   size_t _cards_scanned;</span>
<span class="udiff-line-removed">-   size_t _cards_skipped;</span>
  public:
<span class="udiff-line-modified-removed">-   G1RefineCardClosure(G1CollectedHeap* g1h, G1ScanObjsDuringUpdateRSClosure* update_rs_cl) :</span>
<span class="udiff-line-modified-removed">-     _g1rs(g1h-&gt;rem_set()), _update_rs_cl(update_rs_cl), _cards_scanned(0), _cards_skipped(0)</span>
<span class="udiff-line-modified-removed">-   {}</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   bool do_card_ptr(CardValue* card_ptr, uint worker_i) {</span>
<span class="udiff-line-modified-removed">-     // The only time we care about recording cards that</span>
<span class="udiff-line-modified-removed">-     // contain references that point into the collection set</span>
<span class="udiff-line-modified-removed">-     // is during RSet updating within an evacuation pause.</span>
<span class="udiff-line-modified-removed">-     // In this case worker_i should be the id of a GC worker thread.</span>
<span class="udiff-line-modified-removed">-     assert(SafepointSynchronize::is_at_safepoint(), &quot;not during an evacuation pause&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     bool card_scanned = _g1rs-&gt;refine_card_during_gc(card_ptr, _update_rs_cl);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (card_scanned) {</span>
<span class="udiff-line-removed">-       _update_rs_cl-&gt;trim_queue_partially();</span>
<span class="udiff-line-removed">-       _cards_scanned++;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _cards_skipped++;</span>
<span class="udiff-line-modified-added">+   G1MergeHeapRootsTask(G1RemSetScanState* scan_state, uint num_workers, bool initial_evacuation) :</span>
<span class="udiff-line-modified-added">+     AbstractGangTask(&quot;G1 Merge Heap Roots&quot;),</span>
<span class="udiff-line-modified-added">+     _hr_claimer(num_workers),</span>
<span class="udiff-line-modified-added">+     _scan_state(scan_state),</span>
<span class="udiff-line-modified-added">+     _dirty_card_buffers(),</span>
<span class="udiff-line-modified-added">+     _initial_evacuation(initial_evacuation),</span>
<span class="udiff-line-modified-added">+     _fast_reclaim_handled(false)</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     if (initial_evacuation) {</span>
<span class="udiff-line-modified-added">+       G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-modified-added">+       G1BufferNodeList buffers = dcqs.take_all_completed_buffers();</span>
<span class="udiff-line-modified-added">+       if (buffers._entry_count != 0) {</span>
<span class="udiff-line-modified-added">+         _dirty_card_buffers.prepend(*buffers._head, *buffers._tail);</span>
<span class="udiff-line-modified-added">+       }</span>
      }
<span class="udiff-line-removed">-     return true;</span>
    }
  
<span class="udiff-line-modified-removed">-   size_t cards_scanned() const { return _cards_scanned; }</span>
<span class="udiff-line-modified-removed">-   size_t cards_skipped() const { return _cards_skipped; }</span>
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-added">+   virtual void work(uint worker_id) {</span>
<span class="udiff-line-modified-added">+     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="udiff-line-modified-added">+     G1GCPhaseTimes* p = g1h-&gt;phase_times();</span>
  
<span class="udiff-line-modified-removed">- void G1RemSet::update_rem_set(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="udiff-line-modified-removed">-   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>
<span class="udiff-line-modified-added">+     G1GCPhaseTimes::GCParPhases merge_remset_phase = _initial_evacuation ?</span>
<span class="udiff-line-modified-added">+                                                      G1GCPhaseTimes::MergeRS :</span>
<span class="udiff-line-added">+                                                      G1GCPhaseTimes::OptMergeRS;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // We schedule flushing the remembered sets of humongous fast reclaim candidates</span>
<span class="udiff-line-added">+     // onto the card table first to allow the remaining parallelized tasks hide it.</span>
<span class="udiff-line-added">+     if (_initial_evacuation &amp;&amp;</span>
<span class="udiff-line-added">+         p-&gt;fast_reclaim_humongous_candidates() &gt; 0 &amp;&amp;</span>
<span class="udiff-line-added">+         !_fast_reclaim_handled &amp;&amp;</span>
<span class="udiff-line-added">+         !Atomic::cmpxchg(&amp;_fast_reclaim_handled, false, true)) {</span>
  
<span class="udiff-line-modified-removed">-   // Apply closure to log entries in the HCC.</span>
<span class="udiff-line-modified-removed">-   if (G1HotCardCache::default_use_cache()) {</span>
<span class="udiff-line-modified-removed">-     G1EvacPhaseTimesTracker x(p, pss, G1GCPhaseTimes::ScanHCC, worker_i);</span>
<span class="udiff-line-modified-added">+       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeER, worker_id);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       G1FlushHumongousCandidateRemSets cl(_scan_state);</span>
<span class="udiff-line-added">+       g1h-&gt;heap_region_iterate(&amp;cl);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Merge remembered sets of current candidates.</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       G1GCParPhaseTimesTracker x(p, merge_remset_phase, worker_id, _initial_evacuation /* must_record */);</span>
<span class="udiff-line-added">+       G1MergeCardSetClosure cl(_scan_state);</span>
<span class="udiff-line-added">+       g1h-&gt;collection_set_iterate_increment_from(&amp;cl, &amp;_hr_claimer, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="udiff-line-added">+       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">-     G1ScanObjsDuringUpdateRSClosure scan_hcc_cl(_g1h, pss);</span>
<span class="udiff-line-modified-removed">-     G1RefineCardClosure refine_card_cl(_g1h, &amp;scan_hcc_cl);</span>
<span class="udiff-line-modified-removed">-     _g1h-&gt;iterate_hcc_closure(&amp;refine_card_cl, worker_i);</span>
<span class="udiff-line-modified-added">+     // Apply closure to log entries in the HCC.</span>
<span class="udiff-line-modified-added">+     if (_initial_evacuation &amp;&amp; G1HotCardCache::default_use_cache()) {</span>
<span class="udiff-line-modified-added">+       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="udiff-line-added">+       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeHCC, worker_id);</span>
<span class="udiff-line-added">+       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="udiff-line-added">+       g1h-&gt;iterate_hcc_closure(&amp;cl, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeHCCDirtyCards);</span>
<span class="udiff-line-added">+       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeHCCSkippedCards);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Now apply the closure to all remaining log entries.</span>
<span class="udiff-line-added">+     if (_initial_evacuation) {</span>
<span class="udiff-line-added">+       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="udiff-line-added">+       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeLB, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="udiff-line-added">+       apply_closure_to_dirty_card_buffers(&amp;cl, worker_id);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="udiff-line-added">+       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeLBSkippedCards);</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1RemSet::print_merge_heap_roots_stats() {</span>
<span class="udiff-line-added">+   size_t num_visited_cards = _scan_state-&gt;num_visited_cards();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t total_dirty_region_cards = _scan_state-&gt;num_cards_in_dirty_regions();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="udiff-line-added">+   size_t total_old_region_cards =</span>
<span class="udiff-line-added">+     (g1h-&gt;num_regions() - (g1h-&gt;num_free_regions() - g1h-&gt;collection_set()-&gt;cur_length())) * HeapRegion::CardsPerRegion;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_debug(gc,remset)(&quot;Visited cards &quot; SIZE_FORMAT &quot; Total dirty &quot; SIZE_FORMAT &quot; (%.2lf%%) Total old &quot; SIZE_FORMAT &quot; (%.2lf%%)&quot;,</span>
<span class="udiff-line-added">+                        num_visited_cards,</span>
<span class="udiff-line-added">+                        total_dirty_region_cards,</span>
<span class="udiff-line-added">+                        percent_of(num_visited_cards, total_dirty_region_cards),</span>
<span class="udiff-line-added">+                        total_old_region_cards,</span>
<span class="udiff-line-added">+                        percent_of(num_visited_cards, total_old_region_cards));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1RemSet::merge_heap_roots(bool initial_evacuation) {</span>
<span class="udiff-line-added">+   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
  
<span class="udiff-line-removed">-   // Now apply the closure to all remaining log entries.</span>
    {
<span class="udiff-line-modified-removed">-     G1EvacPhaseTimesTracker x(p, pss, G1GCPhaseTimes::UpdateRS, worker_i);</span>
<span class="udiff-line-modified-added">+     Ticks start = Ticks::now();</span>
  
<span class="udiff-line-modified-removed">-     G1ScanObjsDuringUpdateRSClosure update_rs_cl(_g1h, pss);</span>
<span class="udiff-line-removed">-     G1RefineCardClosure refine_card_cl(_g1h, &amp;update_rs_cl);</span>
<span class="udiff-line-removed">-     _g1h-&gt;iterate_dirty_card_closure(&amp;refine_card_cl, worker_i);</span>
<span class="udiff-line-modified-added">+     _scan_state-&gt;prepare_for_merge_heap_roots();</span>
  
<span class="udiff-line-modified-removed">-     p-&gt;record_thread_work_item(G1GCPhaseTimes::UpdateRS, worker_i, refine_card_cl.cards_scanned(), G1GCPhaseTimes::UpdateRSScannedCards);</span>
<span class="udiff-line-modified-removed">-     p-&gt;record_thread_work_item(G1GCPhaseTimes::UpdateRS, worker_i, refine_card_cl.cards_skipped(), G1GCPhaseTimes::UpdateRSSkippedCards);</span>
<span class="udiff-line-modified-added">+     Tickspan total = Ticks::now() - start;</span>
<span class="udiff-line-modified-added">+     if (initial_evacuation) {</span>
<span class="udiff-line-added">+       g1h-&gt;phase_times()-&gt;record_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       g1h-&gt;phase_times()-&gt;record_or_add_optional_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-modified-removed">- void G1RemSet::oops_into_collection_set_do(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="udiff-line-modified-removed">-   update_rem_set(pss, worker_i);</span>
<span class="udiff-line-removed">-   scan_rem_set(pss, worker_i);;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   WorkGang* workers = g1h-&gt;workers();</span>
<span class="udiff-line-modified-added">+   size_t const increment_length = g1h-&gt;collection_set()-&gt;increment_length();</span>
  
<span class="udiff-line-modified-removed">- void G1RemSet::prepare_for_oops_into_collection_set_do() {</span>
<span class="udiff-line-modified-removed">-   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="udiff-line-modified-removed">-   dcqs.concatenate_logs();</span>
<span class="udiff-line-modified-added">+   uint const num_workers = initial_evacuation ? workers-&gt;active_workers() :</span>
<span class="udiff-line-modified-added">+                                                 MIN2(workers-&gt;active_workers(), (uint)increment_length);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     G1MergeHeapRootsTask cl(_scan_state, num_workers, initial_evacuation);</span>
<span class="udiff-line-added">+     log_debug(gc, ergo)(&quot;Running %s using %u workers for &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="udiff-line-added">+                         cl.name(), num_workers, increment_length);</span>
<span class="udiff-line-added">+     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (log_is_enabled(Debug, gc, remset)) {</span>
<span class="udiff-line-added">+     print_merge_heap_roots_stats();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   _scan_state-&gt;reset();</span>
<span class="udiff-line-modified-added">+ void G1RemSet::exclude_region_from_scan(uint region_idx) {</span>
<span class="udiff-line-added">+   _scan_state-&gt;clear_scan_top(region_idx);</span>
  }
  
<span class="udiff-line-modified-removed">- void G1RemSet::cleanup_after_oops_into_collection_set_do() {</span>
<span class="udiff-line-modified-added">+ void G1RemSet::cleanup_after_scan_heap_roots() {</span>
    G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
  
    // Set all cards back to clean.
    double start = os::elapsedTime();
<span class="udiff-line-modified-removed">-   _scan_state-&gt;clear_card_table(_g1h-&gt;workers());</span>
<span class="udiff-line-modified-added">+   _scan_state-&gt;cleanup(_g1h-&gt;workers());</span>
    phase_times-&gt;record_clear_ct_time((os::elapsedTime() - start) * 1000.0);
  }
  
  inline void check_card_ptr(CardTable::CardValue* card_ptr, G1CardTable* ct) {
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -544,29 +1268,31 @@</span>
           p2i(ct-&gt;addr_for(card_ptr)),
           g1h-&gt;addr_to_region(ct-&gt;addr_for(card_ptr)));
  #endif
  }
  
<span class="udiff-line-modified-removed">- void G1RemSet::refine_card_concurrently(CardValue* card_ptr,</span>
<span class="udiff-line-removed">-                                         uint worker_i) {</span>
<span class="udiff-line-modified-added">+ bool G1RemSet::clean_card_before_refine(CardValue** const card_ptr_addr) {</span>
    assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);
  
<span class="udiff-line-modified-removed">-   // Construct the region representing the card.</span>
<span class="udiff-line-modified-added">+   CardValue* card_ptr = *card_ptr_addr;</span>
<span class="udiff-line-added">+   // Find the start address represented by the card.</span>
    HeapWord* start = _ct-&gt;addr_for(card_ptr);
    // And find the region containing it.
    HeapRegion* r = _g1h-&gt;heap_region_containing_or_null(start);
  
    // If this is a (stale) card into an uncommitted region, exit.
    if (r == NULL) {
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
    check_card_ptr(card_ptr, _ct);
  
    // If the card is no longer dirty, nothing to do.
<span class="udiff-line-added">+   // We cannot load the card value before the &quot;r == NULL&quot; check, because G1</span>
<span class="udiff-line-added">+   // could uncommit parts of the card table covering uncommitted regions.</span>
    if (*card_ptr != G1CardTable::dirty_card_val()) {
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
    // This check is needed for some uncommon cases where we should
    // ignore the card.
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -585,11 +1311,11 @@</span>
    //
    // In the normal (non-stale) case, the synchronization between the
    // enqueueing of the card and processing it here will have ensured
    // we see the up-to-date region type here.
    if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
    // The result from the hot card cache insert call is either:
    //   * pointer to the current card
    //     (implying that the current card is not &#39;hot&#39;),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,141 +1330,109 @@</span>
  
      const CardValue* orig_card_ptr = card_ptr;
      card_ptr = _hot_card_cache-&gt;insert(card_ptr);
      if (card_ptr == NULL) {
        // There was no eviction. Nothing to do.
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-added">+       return false;</span>
      } else if (card_ptr != orig_card_ptr) {
        // Original card was inserted and an old card was evicted.
        start = _ct-&gt;addr_for(card_ptr);
        r = _g1h-&gt;heap_region_containing(start);
  
        // Check whether the region formerly in the cache should be
        // ignored, as discussed earlier for the original card.  The
        // region could have been freed while in the cache.
        if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         return false;</span>
        }
<span class="udiff-line-added">+       *card_ptr_addr = card_ptr;</span>
      } // Else we still have the original card.
    }
  
    // Trim the region designated by the card to what&#39;s been allocated
    // in the region.  The card could be stale, or the card could cover
    // (part of) an object at the end of the allocated space and extend
    // beyond the end of allocation.
  
<span class="udiff-line-modified-removed">-   // Non-humongous objects are only allocated in the old-gen during</span>
<span class="udiff-line-modified-removed">-   // GC, so if region is old then top is stable.  Humongous object</span>
<span class="udiff-line-modified-removed">-   // allocation sets top last; if top has not yet been set, this is</span>
<span class="udiff-line-modified-removed">-   // a stale card and we&#39;ll end up with an empty intersection.  If</span>
<span class="udiff-line-modified-removed">-   // this is not a stale card, the synchronization between the</span>
<span class="udiff-line-modified-added">+   // Non-humongous objects are either allocated in the old regions during GC,</span>
<span class="udiff-line-modified-added">+   // or mapped in archive regions during startup. So if region is old or</span>
<span class="udiff-line-modified-added">+   // archive then top is stable.</span>
<span class="udiff-line-modified-added">+   // Humongous object allocation sets top last; if top has not yet been set,</span>
<span class="udiff-line-modified-added">+   // this is a stale card and we&#39;ll end up with an empty intersection.</span>
<span class="udiff-line-added">+   // If this is not a stale card, the synchronization between the</span>
    // enqueuing of the card and processing it here will have ensured
    // we see the up-to-date top here.
    HeapWord* scan_limit = r-&gt;top();
  
    if (scan_limit &lt;= start) {
      // If the trimmed region is empty, the card must be stale.
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
  
    // Okay to clean and process the card now.  There are still some
    // stale card cases that may be detected by iteration and dealt with
    // as iteration failure.
    *const_cast&lt;volatile CardValue*&gt;(card_ptr) = G1CardTable::clean_card_val();
  
<span class="udiff-line-modified-removed">-   // This fence serves two purposes.  First, the card must be cleaned</span>
<span class="udiff-line-modified-removed">-   // before processing the contents.  Second, we can&#39;t proceed with</span>
<span class="udiff-line-modified-removed">-   // processing until after the read of top, for synchronization with</span>
<span class="udiff-line-modified-removed">-   // possibly concurrent humongous object allocation.  It&#39;s okay that</span>
<span class="udiff-line-modified-removed">-   // reading top and reading type were racy wrto each other.  We need</span>
<span class="udiff-line-modified-removed">-   // both set, in any order, to proceed.</span>
<span class="udiff-line-modified-removed">-   OrderAccess::fence();</span>
<span class="udiff-line-modified-added">+   return true;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void G1RemSet::refine_card_concurrently(CardValue* const card_ptr,</span>
<span class="udiff-line-modified-added">+                                         const uint worker_id) {</span>
<span class="udiff-line-modified-added">+   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);</span>
<span class="udiff-line-modified-added">+   check_card_ptr(card_ptr, _ct);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Construct the MemRegion representing the card.</span>
<span class="udiff-line-added">+   HeapWord* start = _ct-&gt;addr_for(card_ptr);</span>
<span class="udiff-line-added">+   // And find the region containing it.</span>
<span class="udiff-line-added">+   HeapRegion* r = _g1h-&gt;heap_region_containing(start);</span>
<span class="udiff-line-added">+   // This reload of the top is safe even though it happens after the full</span>
<span class="udiff-line-added">+   // fence, because top is stable for old, archive and unfiltered humongous</span>
<span class="udiff-line-added">+   // regions, so it must return the same value as the previous load when</span>
<span class="udiff-line-added">+   // cleaning the card. Also cleaning the card and refinement of the card</span>
<span class="udiff-line-added">+   // cannot span across safepoint, so we don&#39;t need to worry about top being</span>
<span class="udiff-line-added">+   // changed during safepoint.</span>
<span class="udiff-line-added">+   HeapWord* scan_limit = r-&gt;top();</span>
<span class="udiff-line-added">+   assert(scan_limit &gt; start, &quot;sanity&quot;);</span>
  
    // Don&#39;t use addr_for(card_ptr + 1) which can ask for
    // a card beyond the heap.
    HeapWord* end = start + G1CardTable::card_size_in_words;
    MemRegion dirty_region(start, MIN2(scan_limit, end));
    assert(!dirty_region.is_empty(), &quot;sanity&quot;);
  
<span class="udiff-line-modified-removed">-   G1ConcurrentRefineOopClosure conc_refine_cl(_g1h, worker_i);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   bool card_processed =</span>
<span class="udiff-line-removed">-     r-&gt;oops_on_card_seq_iterate_careful&lt;false&gt;(dirty_region, &amp;conc_refine_cl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If unable to process the card then we encountered an unparsable</span>
<span class="udiff-line-removed">-   // part of the heap (e.g. a partially allocated object) while</span>
<span class="udiff-line-removed">-   // processing a stale card.  Despite the card being stale, redirty</span>
<span class="udiff-line-removed">-   // and re-enqueue, because we&#39;ve already cleaned the card.  Without</span>
<span class="udiff-line-removed">-   // this we could incorrectly discard a non-stale card.</span>
<span class="udiff-line-removed">-   if (!card_processed) {</span>
<span class="udiff-line-removed">-     // The card might have gotten re-dirtied and re-enqueued while we</span>
<span class="udiff-line-removed">-     // worked.  (In fact, it&#39;s pretty likely.)</span>
<span class="udiff-line-removed">-     if (*card_ptr != G1CardTable::dirty_card_val()) {</span>
<span class="udiff-line-removed">-       *card_ptr = G1CardTable::dirty_card_val();</span>
<span class="udiff-line-removed">-       MutexLockerEx x(Shared_DirtyCardQ_lock,</span>
<span class="udiff-line-removed">-                       Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-       G1DirtyCardQueue* sdcq =</span>
<span class="udiff-line-removed">-         G1BarrierSet::dirty_card_queue_set().shared_dirty_card_queue();</span>
<span class="udiff-line-removed">-       sdcq-&gt;enqueue(card_ptr);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     _num_conc_refined_cards++; // Unsynchronized update, only used for logging.</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool G1RemSet::refine_card_during_gc(CardValue* card_ptr,</span>
<span class="udiff-line-removed">-                                      G1ScanObjsDuringUpdateRSClosure* update_rs_cl) {</span>
<span class="udiff-line-removed">-   assert(_g1h-&gt;is_gc_active(), &quot;Only call during GC&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Construct the region representing the card.</span>
<span class="udiff-line-removed">-   HeapWord* card_start = _ct-&gt;addr_for(card_ptr);</span>
<span class="udiff-line-removed">-   // And find the region containing it.</span>
<span class="udiff-line-removed">-   uint const card_region_idx = _g1h-&gt;addr_to_region(card_start);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   HeapWord* scan_limit = _scan_state-&gt;scan_top(card_region_idx);</span>
<span class="udiff-line-removed">-   if (scan_limit == NULL) {</span>
<span class="udiff-line-removed">-     // This is a card into an uncommitted region. We need to bail out early as we</span>
<span class="udiff-line-removed">-     // should not access the corresponding card table entry.</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   check_card_ptr(card_ptr, _ct);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If the card is no longer dirty, nothing to do. This covers cards that were already</span>
<span class="udiff-line-removed">-   // scanned as parts of the remembered sets.</span>
<span class="udiff-line-removed">-   if (*card_ptr != G1CardTable::dirty_card_val()) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineOopClosure conc_refine_cl(_g1h, worker_id);</span>
<span class="udiff-line-modified-added">+   if (r-&gt;oops_on_memregion_seq_iterate_careful&lt;false&gt;(dirty_region, &amp;conc_refine_cl) != NULL) {</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
  
<span class="udiff-line-modified-removed">-   // We claim lazily (so races are possible but they&#39;re benign), which reduces the</span>
<span class="udiff-line-modified-removed">-   // number of potential duplicate scans (multiple threads may enqueue the same card twice).</span>
<span class="udiff-line-modified-removed">-   *card_ptr = G1CardTable::clean_card_val() | G1CardTable::claimed_card_val();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _scan_state-&gt;add_dirty_region(card_region_idx);</span>
<span class="udiff-line-modified-removed">-   if (scan_limit &lt;= card_start) {</span>
<span class="udiff-line-modified-removed">-     // If the card starts above the area in the region containing objects to scan, skip it.</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+   // If unable to process the card then we encountered an unparsable</span>
<span class="udiff-line-modified-added">+   // part of the heap (e.g. a partially allocated object, so only</span>
<span class="udiff-line-modified-added">+   // temporarily a problem) while processing a stale card.  Despite</span>
<span class="udiff-line-modified-added">+   // the card being stale, we can&#39;t simply ignore it, because we&#39;ve</span>
<span class="udiff-line-modified-added">+   // already marked the card cleaned, so taken responsibility for</span>
<span class="udiff-line-modified-added">+   // ensuring the card gets scanned.</span>
<span class="udiff-line-modified-added">+   //</span>
<span class="udiff-line-modified-added">+   // However, the card might have gotten re-dirtied and re-enqueued</span>
<span class="udiff-line-added">+   // while we worked.  (In fact, it&#39;s pretty likely.)</span>
<span class="udiff-line-added">+   if (*card_ptr == G1CardTable::dirty_card_val()) {</span>
<span class="udiff-line-added">+     return;</span>
    }
  
<span class="udiff-line-modified-removed">-   // Don&#39;t use addr_for(card_ptr + 1) which can ask for</span>
<span class="udiff-line-modified-removed">-   // a card beyond the heap.</span>
<span class="udiff-line-modified-removed">-   HeapWord* card_end = card_start + G1CardTable::card_size_in_words;</span>
<span class="udiff-line-modified-removed">-   MemRegion dirty_region(card_start, MIN2(scan_limit, card_end));</span>
<span class="udiff-line-modified-removed">-   assert(!dirty_region.is_empty(), &quot;sanity&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   HeapRegion* const card_region = _g1h-&gt;region_at(card_region_idx);</span>
<span class="udiff-line-removed">-   assert(!card_region-&gt;is_young(), &quot;Should not scan card in young region %u&quot;, card_region_idx);</span>
<span class="udiff-line-removed">-   bool card_processed = card_region-&gt;oops_on_card_seq_iterate_careful&lt;true&gt;(dirty_region, update_rs_cl);</span>
<span class="udiff-line-removed">-   assert(card_processed, &quot;must be&quot;);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-modified-added">+   // Re-dirty the card and enqueue in the *shared* queue.  Can&#39;t use</span>
<span class="udiff-line-modified-added">+   // the thread-local queue, because that might be the queue that is</span>
<span class="udiff-line-modified-added">+   // being processed by us; we could be a Java thread conscripted to</span>
<span class="udiff-line-modified-added">+   // perform refinement on our queue&#39;s current buffer.</span>
<span class="udiff-line-modified-added">+   *card_ptr = G1CardTable::dirty_card_val();</span>
<span class="udiff-line-modified-added">+   G1BarrierSet::shared_dirty_card_queue().enqueue(card_ptr);</span>
  }
  
  void G1RemSet::print_periodic_summary_info(const char* header, uint period_count) {
    if ((G1SummarizeRSetStatsPeriod &gt; 0) &amp;&amp; log_is_enabled(Trace, gc, remset) &amp;&amp;
        (period_count % G1SummarizeRSetStatsPeriod == 0)) {
  
<span class="udiff-line-modified-removed">-     G1RemSetSummary current(this);</span>
<span class="udiff-line-modified-added">+     G1RemSetSummary current;</span>
      _prev_period_summary.subtract_from(&amp;current);
  
      Log(gc, remset) log;
      log.trace(&quot;%s&quot;, header);
      ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -751,11 +1445,11 @@</span>
  
  void G1RemSet::print_summary_info() {
    Log(gc, remset, exit) log;
    if (log.is_trace()) {
      log.trace(&quot; Cumulative RS summary&quot;);
<span class="udiff-line-modified-removed">-     G1RemSetSummary current(this);</span>
<span class="udiff-line-modified-added">+     G1RemSetSummary current;</span>
      ResourceMark rm;
      LogStream ls(log.trace());
      current.print_on(&amp;ls);
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -771,18 +1465,18 @@</span>
      // to the given MemRegion. Returns the amount of words actually scanned.
      size_t scan_for_references(oop const obj, MemRegion mr) {
        size_t const obj_size = obj-&gt;size();
        // All non-objArrays and objArrays completely within the mr
        // can be scanned without passing the mr.
<span class="udiff-line-modified-removed">-       if (!obj-&gt;is_objArray() || mr.contains(MemRegion((HeapWord*)obj, obj_size))) {</span>
<span class="udiff-line-modified-added">+       if (!obj-&gt;is_objArray() || mr.contains(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size))) {</span>
          obj-&gt;oop_iterate(&amp;_update_cl);
          return obj_size;
        }
        // This path is for objArrays crossing the given MemRegion. Only scan the
        // area within the MemRegion.
        obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="udiff-line-modified-removed">-       return mr.intersection(MemRegion((HeapWord*)obj, obj_size)).word_size();</span>
<span class="udiff-line-modified-added">+       return mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size)).word_size();</span>
      }
  
      // A humongous object is live (with respect to the scanning) either
      // a) it is marked on the bitmap as such
      // b) its TARS is larger than TAMS, i.e. has been allocated during marking.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -883,20 +1577,20 @@</span>
            // the same as bottom or top(_at_rebuild_start). There is no way TAMS has a different
            // value: this would mean that TAMS points somewhere into the object.
            assert(hr-&gt;top() == top_at_mark_start || hr-&gt;top() == top_at_rebuild_start,
                   &quot;More than one object in the humongous region?&quot;);
            humongous_obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="udiff-line-modified-removed">-           return top_at_mark_start != hr-&gt;bottom() ? mr.intersection(MemRegion((HeapWord*)humongous_obj, humongous_obj-&gt;size())).byte_size() : 0;</span>
<span class="udiff-line-modified-added">+           return top_at_mark_start != hr-&gt;bottom() ? mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(humongous_obj), humongous_obj-&gt;size())).byte_size() : 0;</span>
          } else {
            return 0;
          }
        }
  
        for (LiveObjIterator it(bitmap, top_at_mark_start, mr, hr-&gt;block_start(mr.start())); it.has_next(); it.move_to_next()) {
          oop obj = it.next();
          size_t scanned_size = scan_for_references(obj, mr);
<span class="udiff-line-modified-removed">-         if ((HeapWord*)obj &lt; top_at_mark_start) {</span>
<span class="udiff-line-modified-added">+         if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; top_at_mark_start) {</span>
            marked_words += scanned_size;
          }
        }
  
        return marked_words * HeapWordSize;
</pre>
<center><a href="g1RegionToSpaceMapper.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
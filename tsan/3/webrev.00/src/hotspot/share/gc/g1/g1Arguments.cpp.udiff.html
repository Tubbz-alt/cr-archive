<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Arguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Analytics.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Arguments.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,19 +24,41 @@</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1Arguments.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
  #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/g1/g1HeterogeneousCollectorPolicy.hpp&quot;</span>
  #include &quot;gc/g1/heapRegion.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/gcArguments.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/cardTableRS.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  #include &quot;gc/shared/workerPolicy.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  
<span class="udiff-line-added">+ static const double MaxRamFractionForYoung = 0.8;</span>
<span class="udiff-line-added">+ size_t G1Arguments::MaxMemoryForYoung;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static size_t calculate_heap_alignment(size_t space_alignment) {</span>
<span class="udiff-line-added">+   size_t card_table_alignment = CardTableRS::ct_max_alignment_constraint();</span>
<span class="udiff-line-added">+   size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();</span>
<span class="udiff-line-added">+   return MAX3(card_table_alignment, space_alignment, page_size);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1Arguments::initialize_alignments() {</span>
<span class="udiff-line-added">+   // Set up the region size and associated fields.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // There is a circular dependency here. We base the region size on the heap</span>
<span class="udiff-line-added">+   // size, but the heap size should be aligned with the region size. To get</span>
<span class="udiff-line-added">+   // around this we use the unaligned values for the heap.</span>
<span class="udiff-line-added">+   HeapRegion::setup_heap_region_size(InitialHeapSize, MaxHeapSize);</span>
<span class="udiff-line-added">+   HeapRegionRemSet::setup_remset_size();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   SpaceAlignment = HeapRegion::GrainBytes;</span>
<span class="udiff-line-added">+   HeapAlignment = calculate_heap_alignment(SpaceAlignment);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  size_t G1Arguments::conservative_max_heap_alignment() {
    return HeapRegion::max_region_size();
  }
  
  void G1Arguments::initialize_verification_types() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,15 +108,15 @@</span>
  
    // When dumping the CDS archive we want to reduce fragmentation by
    // triggering a full collection. To get as low fragmentation as
    // possible we only use one worker thread.
    if (DumpSharedSpaces) {
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(uint, ParallelGCThreads, 1);</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(ParallelGCThreads, 1);</span>
    }
  
    if (FLAG_IS_DEFAULT(G1ConcRefinementThreads)) {
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(uint, G1ConcRefinementThreads, ParallelGCThreads);</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(G1ConcRefinementThreads, ParallelGCThreads);</span>
    }
  
    // MarkStackSize will be set (if it hasn&#39;t been set by the user)
    // when concurrent marking is initialized.
    // Its value will be based upon the number of parallel marking threads.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,11 +160,11 @@</span>
  
    log_trace(gc)(&quot;MarkStackSize: %uk  MarkStackSizeMax: %uk&quot;, (unsigned int) (MarkStackSize / K), (uint) (MarkStackSizeMax / K));
  
    // By default do not let the target stack size to be more than 1/4 of the entries
    if (FLAG_IS_DEFAULT(GCDrainStackTargetSize)) {
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(uintx, GCDrainStackTargetSize, MIN2(GCDrainStackTargetSize, (uintx)TASKQUEUE_SIZE / 4));</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(GCDrainStackTargetSize, MIN2(GCDrainStackTargetSize, (uintx)TASKQUEUE_SIZE / 4));</span>
    }
  
  #ifdef COMPILER2
    // Enable loop strip mining to offer better pause time guarantees
    if (FLAG_IS_DEFAULT(UseCountedLoopSafepoints)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -154,12 +176,87 @@</span>
  #endif
  
    initialize_verification_types();
  }
  
<span class="udiff-line-modified-removed">- CollectedHeap* G1Arguments::create_heap() {</span>
<span class="udiff-line-modified-removed">-   if (AllocateOldGenAt != NULL) {</span>
<span class="udiff-line-modified-removed">-     return create_heap_with_policy&lt;G1CollectedHeap, G1HeterogeneousCollectorPolicy&gt;();</span>
<span class="udiff-line-modified-added">+ static size_t calculate_reasonable_max_memory_for_young(FormatBuffer&lt;100&gt; &amp;calc_str, double max_ram_fraction_for_young) {</span>
<span class="udiff-line-modified-added">+   julong phys_mem;</span>
<span class="udiff-line-modified-added">+   // If MaxRam is specified, we use that as maximum physical memory available.</span>
<span class="udiff-line-added">+   if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="udiff-line-added">+     phys_mem = os::physical_memory();</span>
<span class="udiff-line-added">+     calc_str.append(&quot;Physical_Memory&quot;);</span>
    } else {
<span class="udiff-line-modified-removed">-     return create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;();</span>
<span class="udiff-line-modified-added">+     phys_mem = (julong)MaxRAM;</span>
<span class="udiff-line-added">+     calc_str.append(&quot;MaxRAM&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   julong reasonable_max = phys_mem;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate</span>
<span class="udiff-line-added">+   // reasonable max size of young generation.</span>
<span class="udiff-line-added">+   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {</span>
<span class="udiff-line-added">+     reasonable_max = (julong)(phys_mem / MaxRAMFraction);</span>
<span class="udiff-line-added">+     calc_str.append(&quot; / MaxRAMFraction&quot;);</span>
<span class="udiff-line-added">+   }  else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {</span>
<span class="udiff-line-added">+     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);</span>
<span class="udiff-line-added">+     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);</span>
<span class="udiff-line-added">+   }  else {</span>
<span class="udiff-line-added">+     // We use our own fraction to calculate max size of young generation.</span>
<span class="udiff-line-added">+     reasonable_max = phys_mem * max_ram_fraction_for_young;</span>
<span class="udiff-line-added">+     calc_str.append(&quot; * %0.2f&quot;, max_ram_fraction_for_young);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return (size_t)reasonable_max;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1Arguments::initialize_heap_flags_and_sizes() {</span>
<span class="udiff-line-added">+   if (AllocateOldGenAt != NULL) {</span>
<span class="udiff-line-added">+     initialize_heterogeneous();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GCArguments::initialize_heap_flags_and_sizes();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1Arguments::initialize_heterogeneous() {</span>
<span class="udiff-line-added">+   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   MaxMemoryForYoung = calculate_reasonable_max_memory_for_young(calc_str, MaxRamFractionForYoung);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (MaxNewSize &gt; MaxMemoryForYoung) {</span>
<span class="udiff-line-added">+     if (FLAG_IS_CMDLINE(MaxNewSize)) {</span>
<span class="udiff-line-added">+       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="udiff-line-added">+                             MaxMemoryForYoung, calc_str.buffer());</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;</span>
<span class="udiff-line-added">+                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, MaxMemoryForYoung, calc_str.buffer());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     MaxNewSize = MaxMemoryForYoung;</span>
    }
<span class="udiff-line-added">+   if (NewSize &gt; MaxMemoryForYoung) {</span>
<span class="udiff-line-added">+     if (FLAG_IS_CMDLINE(NewSize)) {</span>
<span class="udiff-line-added">+       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="udiff-line-added">+                             MaxMemoryForYoung, calc_str.buffer());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     NewSize = MaxMemoryForYoung;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ CollectedHeap* G1Arguments::create_heap() {</span>
<span class="udiff-line-added">+   return new G1CollectedHeap();</span>
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool G1Arguments::is_heterogeneous_heap() {</span>
<span class="udiff-line-added">+   return AllocateOldGenAt != NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t G1Arguments::reasonable_max_memory_for_young() {</span>
<span class="udiff-line-added">+   return MaxMemoryForYoung;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t G1Arguments::heap_reserved_size_bytes() {</span>
<span class="udiff-line-added">+   return (is_heterogeneous_heap() ? 2 : 1) * MaxHeapSize;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t G1Arguments::heap_max_size_bytes() {</span>
<span class="udiff-line-added">+   return MaxHeapSize;</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="g1Analytics.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Arguments.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1CollectionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1COLLECTIONSET_HPP
 26 #define SHARE_GC_G1_G1COLLECTIONSET_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class G1CollectedHeap;
 32 class G1CollectionSetCandidates;
 33 class G1CollectorState;
 34 class G1GCPhaseTimes;
 35 class G1ParScanThreadStateSet;
 36 class G1Policy;
 37 class G1SurvivorRegions;
 38 class HeapRegion;
<a name="1" id="anc1"></a>
 39 class HeapRegionClosure;
 40 
<a name="2" id="anc2"></a>

























































































 41 class G1CollectionSet {
 42   G1CollectedHeap* _g1h;
 43   G1Policy* _policy;
 44 
<a name="3" id="anc3"></a><span class="line-modified"> 45   // All old gen collection set candidate regions for the current mixed gc phase.</span>
 46   G1CollectionSetCandidates* _candidates;
 47 
 48   uint _eden_region_length;
 49   uint _survivor_region_length;
 50   uint _old_region_length;
 51 
 52   // The actual collection set as a set of region indices.
 53   // All entries in _collection_set_regions below _collection_set_cur_length are
<a name="4" id="anc4"></a><span class="line-modified"> 54   // assumed to be valid entries.</span>
 55   // We assume that at any time there is at most only one writer and (one or more)
 56   // concurrent readers. This means we are good with using storestore and loadload
 57   // barriers on the writer and reader respectively only.
 58   uint* _collection_set_regions;
 59   volatile size_t _collection_set_cur_length;
 60   size_t _collection_set_max_length;
 61 
<a name="5" id="anc5"></a><span class="line-modified"> 62   // When doing mixed collections we can add old regions to the collection, which</span>
<span class="line-modified"> 63   // can be collected if there is enough time. We call these optional regions and</span>
<span class="line-modified"> 64   // the pointer to these regions are stored in the array below.</span>
<span class="line-modified"> 65   HeapRegion** _optional_regions;</span>
<span class="line-modified"> 66   uint _optional_region_length;</span>
<span class="line-removed"> 67   uint _optional_region_max_length;</span>
 68 
 69   // The number of bytes in the collection set before the pause. Set from
 70   // the incrementally built collection set at the start of an evacuation
<a name="6" id="anc6"></a><span class="line-modified"> 71   // pause, and incremented in finalize_old_part() when adding old regions</span>
<span class="line-removed"> 72   // (if any) to the collection set.</span>
 73   size_t _bytes_used_before;
 74 
<a name="7" id="anc7"></a><span class="line-modified"> 75   size_t _recorded_rs_lengths;</span>
<span class="line-modified"> 76 </span>
<span class="line-modified"> 77   // The associated information that is maintained while the incremental</span>
<span class="line-modified"> 78   // collection set is being built with young regions. Used to populate</span>
<span class="line-removed"> 79   // the recorded info for the evacuation pause.</span>
 80 
 81   enum CSetBuildType {
 82     Active,             // We are actively building the collection set
 83     Inactive            // We are not actively building the collection set
 84   };
 85 
 86   CSetBuildType _inc_build_state;
<a name="8" id="anc8"></a>




















 87 
 88   // The number of bytes in the incrementally built collection set.
 89   // Used to set _collection_set_bytes_used_before at the start of
 90   // an evacuation pause.
 91   size_t _inc_bytes_used_before;
 92 
 93   // The RSet lengths recorded for regions in the CSet. It is updated
 94   // by the thread that adds a new region to the CSet. We assume that
 95   // only one thread can be allocating a new CSet region (currently,
 96   // it does so after taking the Heap_lock) hence no need to
 97   // synchronize updates to this field.
<a name="9" id="anc9"></a><span class="line-modified"> 98   size_t _inc_recorded_rs_lengths;</span>
 99 
100   // A concurrent refinement thread periodically samples the young
<a name="10" id="anc10"></a><span class="line-modified">101   // region RSets and needs to update _inc_recorded_rs_lengths as</span>
102   // the RSets grow. Instead of having to synchronize updates to that
103   // field we accumulate them in this field and add it to
<a name="11" id="anc11"></a><span class="line-modified">104   // _inc_recorded_rs_lengths_diffs at the start of a GC.</span>
<span class="line-modified">105   ssize_t _inc_recorded_rs_lengths_diffs;</span>
106 
107   // The predicted elapsed time it will take to collect the regions in
108   // the CSet. This is updated by the thread that adds a new region to
<a name="12" id="anc12"></a><span class="line-modified">109   // the CSet. See the comment for _inc_recorded_rs_lengths about</span>
110   // MT-safety assumptions.
<a name="13" id="anc13"></a><span class="line-modified">111   double _inc_predicted_elapsed_time_ms;</span>
112 
<a name="14" id="anc14"></a><span class="line-modified">113   // See the comment for _inc_recorded_rs_lengths_diffs.</span>
<span class="line-modified">114   double _inc_predicted_elapsed_time_ms_diffs;</span>
115 
<a name="15" id="anc15"></a><span class="line-modified">116   G1CollectorState* collector_state();</span>


117   G1GCPhaseTimes* phase_times();
118 
119   void verify_young_cset_indices() const NOT_DEBUG_RETURN;
<a name="16" id="anc16"></a><span class="line-removed">120   void add_as_optional(HeapRegion* hr);</span>
<span class="line-removed">121   void add_as_old(HeapRegion* hr);</span>
<span class="line-removed">122   bool optional_is_full();</span>
123 
<a name="17" id="anc17"></a>


































124 public:
125   G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
126   ~G1CollectionSet();
127 
128   // Initializes the collection set giving the maximum possible length of the collection set.
129   void initialize(uint max_region_length);
<a name="18" id="anc18"></a><span class="line-removed">130   void initialize_optional(uint max_length);</span>
<span class="line-removed">131   void free_optional_regions();</span>
132 
133   void clear_candidates();
134 
135   void set_candidates(G1CollectionSetCandidates* candidates) {
136     assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
137     _candidates = candidates;
138   }
139   G1CollectionSetCandidates* candidates() { return _candidates; }
140 
141   void init_region_lengths(uint eden_cset_region_length,
142                            uint survivor_cset_region_length);
143 
<a name="19" id="anc19"></a><span class="line-removed">144   void set_recorded_rs_lengths(size_t rs_lengths);</span>
<span class="line-removed">145 </span>
146   uint region_length() const       { return young_region_length() +
147                                             old_region_length(); }
148   uint young_region_length() const { return eden_region_length() +
149                                             survivor_region_length(); }
150 
151   uint eden_region_length() const     { return _eden_region_length;     }
152   uint survivor_region_length() const { return _survivor_region_length; }
153   uint old_region_length() const      { return _old_region_length;      }
<a name="20" id="anc20"></a><span class="line-modified">154   uint optional_region_length() const { return _optional_region_length; }</span>



155 
156   // Incremental collection set support
157 
158   // Initialize incremental collection set info.
159   void start_incremental_building();
<a name="21" id="anc21"></a>



160 
<a name="22" id="anc22"></a><span class="line-modified">161   // Perform any final calculations on the incremental collection set fields</span>
<span class="line-modified">162   // before we can use them.</span>
<span class="line-modified">163   void finalize_incremental_building();</span>
164 
<a name="23" id="anc23"></a><span class="line-modified">165   // Reset the contents of the collection set.</span>
<span class="line-modified">166   void clear();</span>


167 
<a name="24" id="anc24"></a><span class="line-modified">168   // Iterate over the collection set, applying the given HeapRegionClosure on all of them.</span>
<span class="line-modified">169   // If may_be_aborted is true, iteration may be aborted using the return value of the</span>
<span class="line-removed">170   // called closure method.</span>
171   void iterate(HeapRegionClosure* cl) const;
<a name="25" id="anc25"></a>



172 
<a name="26" id="anc26"></a><span class="line-modified">173   // Iterate over the collection set, applying the given HeapRegionClosure on all of them,</span>
<span class="line-removed">174   // trying to optimally spread out starting position of total_workers workers given the</span>
<span class="line-removed">175   // caller&#39;s worker_id.</span>
<span class="line-removed">176   void iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const;</span>
<span class="line-removed">177 </span>
<span class="line-removed">178   // Stop adding regions to the incremental collection set.</span>
<span class="line-removed">179   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
180 
<a name="27" id="anc27"></a><span class="line-modified">181   size_t recorded_rs_lengths() { return _recorded_rs_lengths; }</span>
182 
183   size_t bytes_used_before() const {
184     return _bytes_used_before;
185   }
186 
187   void reset_bytes_used_before() {
188     _bytes_used_before = 0;
189   }
190 
<a name="28" id="anc28"></a><span class="line-modified">191   // Choose a new collection set.  Marks the chosen regions as being</span>
<span class="line-modified">192   // &quot;in_collection_set&quot;.</span>
<span class="line-modified">193   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-modified">194   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-modified">195 </span>
<span class="line-modified">196   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-modified">197   void add_old_region(HeapRegion* hr);</span>
<span class="line-modified">198 </span>
<span class="line-removed">199   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-removed">200   void add_optional_region(HeapRegion* hr);</span>
201 
202   // Update information about hr in the aggregated information for
203   // the incrementally built collection set.
204   void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
205 
206   // Add eden region to the collection set.
207   void add_eden_region(HeapRegion* hr);
208 
209   // Add survivor region to the collection set.
210   void add_survivor_regions(HeapRegion* hr);
211 
212 #ifndef PRODUCT
213   bool verify_young_ages();
214 
215   void print(outputStream* st);
216 #endif // !PRODUCT
<a name="29" id="anc29"></a><span class="line-removed">217 </span>
<span class="line-removed">218   double predict_region_elapsed_time_ms(HeapRegion* hr);</span>
<span class="line-removed">219 </span>
<span class="line-removed">220   void clear_optional_region(const HeapRegion* hr);</span>
<span class="line-removed">221 </span>
<span class="line-removed">222   HeapRegion* optional_region_at(uint i) const {</span>
<span class="line-removed">223     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">224     assert(i &lt; _optional_region_length, &quot;index %u out of bounds (%u)&quot;, i, _optional_region_length);</span>
<span class="line-removed">225     return _optional_regions[i];</span>
<span class="line-removed">226   }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228   HeapRegion* remove_last_optional_region() {</span>
<span class="line-removed">229     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">230     assert(_optional_region_length != 0, &quot;No region to remove&quot;);</span>
<span class="line-removed">231     _optional_region_length--;</span>
<span class="line-removed">232     HeapRegion* removed = _optional_regions[_optional_region_length];</span>
<span class="line-removed">233     _optional_regions[_optional_region_length] = NULL;</span>
<span class="line-removed">234     return removed;</span>
<span class="line-removed">235   }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 private:</span>
<span class="line-removed">238   // Update the incremental collection set information when adding a region.</span>
<span class="line-removed">239   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-removed">240 };</span>
<span class="line-removed">241 </span>
<span class="line-removed">242 // Helper class to manage the optional regions in a Mixed collection.</span>
<span class="line-removed">243 class G1OptionalCSet : public StackObj {</span>
<span class="line-removed">244 private:</span>
<span class="line-removed">245   G1CollectionSet* _cset;</span>
<span class="line-removed">246   G1ParScanThreadStateSet* _pset;</span>
<span class="line-removed">247   uint _current_index;</span>
<span class="line-removed">248   uint _current_limit;</span>
<span class="line-removed">249   bool _prepare_failed;</span>
<span class="line-removed">250   bool _evacuation_failed;</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   void prepare_to_evacuate_optional_region(HeapRegion* hr);</span>
<span class="line-removed">253 </span>
<span class="line-removed">254 public:</span>
<span class="line-removed">255   static const uint InvalidCSetIndex = UINT_MAX;</span>
<span class="line-removed">256 </span>
<span class="line-removed">257   G1OptionalCSet(G1CollectionSet* cset, G1ParScanThreadStateSet* pset) :</span>
<span class="line-removed">258     _cset(cset),</span>
<span class="line-removed">259     _pset(pset),</span>
<span class="line-removed">260     _current_index(0),</span>
<span class="line-removed">261     _current_limit(0),</span>
<span class="line-removed">262     _prepare_failed(false),</span>
<span class="line-removed">263     _evacuation_failed(false) { }</span>
<span class="line-removed">264   // The destructor returns regions to the collection set candidates set and</span>
<span class="line-removed">265   // frees the optional structure in the collection set.</span>
<span class="line-removed">266   ~G1OptionalCSet();</span>
<span class="line-removed">267 </span>
<span class="line-removed">268   uint current_index() { return _current_index; }</span>
<span class="line-removed">269   uint current_limit() { return _current_limit; }</span>
<span class="line-removed">270 </span>
<span class="line-removed">271   uint size();</span>
<span class="line-removed">272   bool is_empty();</span>
<span class="line-removed">273 </span>
<span class="line-removed">274   HeapRegion* region_at(uint index);</span>
<span class="line-removed">275 </span>
<span class="line-removed">276   // Prepare a set of regions for optional evacuation.</span>
<span class="line-removed">277   void prepare_evacuation(double time_left_ms);</span>
<span class="line-removed">278   bool prepare_failed();</span>
<span class="line-removed">279 </span>
<span class="line-removed">280   // Complete the evacuation of the previously prepared</span>
<span class="line-removed">281   // regions by updating their state and check for failures.</span>
<span class="line-removed">282   void complete_evacuation();</span>
<span class="line-removed">283   bool evacuation_failed();</span>
284 };
285 
286 #endif // SHARE_GC_G1_G1COLLECTIONSET_HPP
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1DirtyCardQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EdenRegions.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 26 #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/shared/cardTable.hpp&quot;</span>

 29 #include &quot;gc/shared/ptrQueue.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;

 31 

 32 class G1DirtyCardQueueSet;
<span class="line-modified"> 33 class G1FreeIdSet;</span>
 34 class Thread;
<span class="line-removed"> 35 class Monitor;</span>
<span class="line-removed"> 36 </span>
<span class="line-removed"> 37 // A closure class for processing card table entries.  Note that we don&#39;t</span>
<span class="line-removed"> 38 // require these closure objects to be stack-allocated.</span>
<span class="line-removed"> 39 class G1CardTableEntryClosure: public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-removed"> 40 public:</span>
<span class="line-removed"> 41   typedef CardTable::CardValue CardValue;</span>
<span class="line-removed"> 42 </span>
<span class="line-removed"> 43   // Process the card whose card table entry is &quot;card_ptr&quot;.  If returns</span>
<span class="line-removed"> 44   // &quot;false&quot;, terminate the iteration early.</span>
<span class="line-removed"> 45   virtual bool do_card_ptr(CardValue* card_ptr, uint worker_i) = 0;</span>
<span class="line-removed"> 46 };</span>
 47 
 48 // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
 49 class G1DirtyCardQueue: public PtrQueue {



 50 public:
<span class="line-modified"> 51   G1DirtyCardQueue(G1DirtyCardQueueSet* qset, bool permanent = false);</span>
 52 
 53   // Flush before destroying; queue may be used to capture pending work while
 54   // doing something else, with auto-flush on completion.
 55   ~G1DirtyCardQueue();
 56 
 57   // Process queue entries and release resources.
 58   void flush() { flush_impl(); }
 59 


 60   // Compiler support.
 61   static ByteSize byte_offset_of_index() {
 62     return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
 63   }
 64   using PtrQueue::byte_width_of_index;
 65 
 66   static ByteSize byte_offset_of_buf() {
 67     return PtrQueue::byte_offset_of_buf&lt;G1DirtyCardQueue&gt;();
 68   }
 69   using PtrQueue::byte_width_of_buf;
 70 
 71 };
 72 
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74 </span>
 75 class G1DirtyCardQueueSet: public PtrQueueSet {
<span class="line-modified"> 76   G1DirtyCardQueue _shared_dirty_card_queue;</span>
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78   // Apply the closure to the elements of &quot;node&quot; from it&#39;s index to</span>
<span class="line-modified"> 79   // buffer_size.  If all closure applications return true, then</span>
<span class="line-modified"> 80   // returns true.  Stops processing after the first closure</span>
<span class="line-modified"> 81   // application that returns false, and returns false from this</span>
<span class="line-modified"> 82   // function.  If &quot;consume&quot; is true, the node&#39;s index is updated to</span>
<span class="line-modified"> 83   // exclude the processed elements, e.g. up to the element for which</span>
<span class="line-modified"> 84   // the closure returned false.</span>
<span class="line-modified"> 85   bool apply_closure_to_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified"> 86                                BufferNode* node,</span>
<span class="line-modified"> 87                                bool consume,</span>
<span class="line-modified"> 88                                uint worker_i = 0);</span>
<span class="line-modified"> 89 </span>
<span class="line-modified"> 90   // If there are more than stop_at completed buffers, pop one, apply</span>
<span class="line-modified"> 91   // the specified closure to its active elements, and return true.</span>
<span class="line-modified"> 92   // Otherwise return false.</span>





































 93   //
<span class="line-modified"> 94   // A completely processed buffer is freed.  However, if a closure</span>
<span class="line-modified"> 95   // invocation returns false, processing is stopped and the partially</span>
<span class="line-modified"> 96   // processed buffer (with its index updated to exclude the processed</span>
<span class="line-modified"> 97   // elements, e.g. up to the element for which the closure returned</span>
<span class="line-modified"> 98   // false) is returned to the completed buffer set.</span>

 99   //
<span class="line-modified">100   // If during_pause is true, stop_at must be zero, and the closure</span>
<span class="line-modified">101   // must never return false.</span>
<span class="line-modified">102   bool apply_closure_to_completed_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified">103                                          uint worker_i,</span>
<span class="line-modified">104                                          size_t stop_at,</span>
<span class="line-modified">105                                          bool during_pause);</span>


















































































































106 
107   bool mut_process_buffer(BufferNode* node);
108 
<span class="line-modified">109   G1FreeIdSet* _free_ids;</span>
<span class="line-modified">110 </span>
<span class="line-modified">111   // The number of completed buffers processed by mutator and rs thread,</span>
<span class="line-removed">112   // respectively.</span>
<span class="line-removed">113   jint _processed_buffers_mut;</span>
<span class="line-removed">114   jint _processed_buffers_rs_thread;</span>
<span class="line-removed">115 </span>
<span class="line-removed">116   // Current buffer node used for parallel iteration.</span>
<span class="line-removed">117   BufferNode* volatile _cur_par_buffer_node;</span>
<span class="line-removed">118 </span>
<span class="line-removed">119   void concatenate_log(G1DirtyCardQueue&amp; dcq);</span>
120 
121 public:
<span class="line-modified">122   G1DirtyCardQueueSet(bool notify_when_complete = true);</span>
123   ~G1DirtyCardQueueSet();
124 
<span class="line-modified">125   void initialize(Monitor* cbl_mon,</span>
<span class="line-modified">126                   BufferNode::Allocator* allocator,</span>
<span class="line-modified">127                   Mutex* lock,</span>
<span class="line-removed">128                   bool init_free_ids = false);</span>
129 
130   // The number of parallel ids that can be claimed to allow collector or
131   // mutator threads to do card-processing work.
132   static uint num_par_ids();
133 
134   static void handle_zero_index_for_thread(Thread* t);
135 
<span class="line-modified">136   // Apply G1RefineCardConcurrentlyClosure to completed buffers until there are stop_at</span>
<span class="line-modified">137   // completed buffers remaining.</span>
<span class="line-modified">138   bool refine_completed_buffer_concurrently(uint worker_i, size_t stop_at);</span>

139 
<span class="line-modified">140   // Apply the given closure to all completed buffers. The given closure&#39;s do_card_ptr</span>
<span class="line-removed">141   // must never return false. Must only be called during GC.</span>
<span class="line-removed">142   bool apply_closure_during_gc(G1CardTableEntryClosure* cl, uint worker_i);</span>
143 
<span class="line-modified">144   void reset_for_par_iteration() { _cur_par_buffer_node = completed_buffers_head(); }</span>
<span class="line-modified">145   // Applies the current closure to all completed buffers, non-consumptively.</span>
<span class="line-modified">146   // Can be used in parallel, all callers using the iteration state initialized</span>
<span class="line-modified">147   // by reset_for_par_iteration.</span>
<span class="line-removed">148   void par_apply_closure_to_all_completed_buffers(G1CardTableEntryClosure* cl);</span>
149 
<span class="line-modified">150   G1DirtyCardQueue* shared_dirty_card_queue() {</span>
<span class="line-modified">151     return &amp;_shared_dirty_card_queue;</span>



152   }









153 
<span class="line-modified">154   // If a full collection is happening, reset partial logs, and ignore</span>
















155   // completed ones: the full collection will make them all irrelevant.
156   void abandon_logs();
157 
158   // If any threads have partial logs, add them to the global list of logs.
159   void concatenate_logs();
160 
<span class="line-modified">161   jint processed_buffers_mut() {</span>
<span class="line-modified">162     return _processed_buffers_mut;</span>
163   }
<span class="line-modified">164   jint processed_buffers_rs_thread() {</span>
<span class="line-modified">165     return _processed_buffers_rs_thread;</span>
166   }
167 









168 };
169 




170 #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 26 #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/g1/g1BufferNodeList.hpp&quot;</span>
<span class="line-added"> 29 #include &quot;gc/g1/g1FreeIdSet.hpp&quot;</span>
 30 #include &quot;gc/shared/ptrQueue.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/padded.hpp&quot;</span>
 33 
<span class="line-added"> 34 class G1ConcurrentRefineThread;</span>
 35 class G1DirtyCardQueueSet;
<span class="line-modified"> 36 class G1RedirtyCardsQueueSet;</span>
 37 class Thread;












 38 
 39 // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
 40 class G1DirtyCardQueue: public PtrQueue {
<span class="line-added"> 41 protected:</span>
<span class="line-added"> 42   virtual void handle_completed_buffer();</span>
<span class="line-added"> 43 </span>
 44 public:
<span class="line-modified"> 45   G1DirtyCardQueue(G1DirtyCardQueueSet* qset);</span>
 46 
 47   // Flush before destroying; queue may be used to capture pending work while
 48   // doing something else, with auto-flush on completion.
 49   ~G1DirtyCardQueue();
 50 
 51   // Process queue entries and release resources.
 52   void flush() { flush_impl(); }
 53 
<span class="line-added"> 54   inline G1DirtyCardQueueSet* dirty_card_qset() const;</span>
<span class="line-added"> 55 </span>
 56   // Compiler support.
 57   static ByteSize byte_offset_of_index() {
 58     return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
 59   }
 60   using PtrQueue::byte_width_of_index;
 61 
 62   static ByteSize byte_offset_of_buf() {
 63     return PtrQueue::byte_offset_of_buf&lt;G1DirtyCardQueue&gt;();
 64   }
 65   using PtrQueue::byte_width_of_buf;
 66 
 67 };
 68 


 69 class G1DirtyCardQueueSet: public PtrQueueSet {
<span class="line-modified"> 70   // Head and tail of a list of BufferNodes, linked through their next()</span>
<span class="line-modified"> 71   // fields.  Similar to G1BufferNodeList, but without the _entry_count.</span>
<span class="line-modified"> 72   struct HeadTail {</span>
<span class="line-modified"> 73     BufferNode* _head;</span>
<span class="line-modified"> 74     BufferNode* _tail;</span>
<span class="line-modified"> 75     HeadTail() : _head(NULL), _tail(NULL) {}</span>
<span class="line-modified"> 76     HeadTail(BufferNode* head, BufferNode* tail) : _head(head), _tail(tail) {}</span>
<span class="line-modified"> 77   };</span>
<span class="line-modified"> 78 </span>
<span class="line-modified"> 79   // A lock-free FIFO of BufferNodes, linked through their next() fields.</span>
<span class="line-modified"> 80   // This class has a restriction that pop() may return NULL when there are</span>
<span class="line-modified"> 81   // buffers in the queue if there is a concurrent push/append operation.</span>
<span class="line-modified"> 82   class Queue {</span>
<span class="line-modified"> 83     BufferNode* volatile _head;</span>
<span class="line-modified"> 84     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));</span>
<span class="line-modified"> 85     BufferNode* volatile _tail;</span>
<span class="line-modified"> 86     DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     NONCOPYABLE(Queue);</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90   public:</span>
<span class="line-added"> 91     Queue() : _head(NULL), _tail(NULL) {}</span>
<span class="line-added"> 92     DEBUG_ONLY(~Queue();)</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94     // Return the first buffer in the queue.</span>
<span class="line-added"> 95     // Thread-safe, but the result may change immediately.</span>
<span class="line-added"> 96     BufferNode* top() const;</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     // Thread-safe add the buffer to the end of the queue.</span>
<span class="line-added"> 99     void push(BufferNode&amp; node) { append(node, node); }</span>
<span class="line-added">100 </span>
<span class="line-added">101     // Thread-safe add the buffers from first to last to the end of the queue.</span>
<span class="line-added">102     void append(BufferNode&amp; first, BufferNode&amp; last);</span>
<span class="line-added">103 </span>
<span class="line-added">104     // Thread-safe attempt to remove and return the first buffer in the queue.</span>
<span class="line-added">105     // Returns NULL if the queue is empty, or if a concurrent push/append</span>
<span class="line-added">106     // interferes.  Uses GlobalCounter critical sections to address the ABA</span>
<span class="line-added">107     // problem; this works with the buffer allocator&#39;s use of GlobalCounter</span>
<span class="line-added">108     // synchronization.</span>
<span class="line-added">109     BufferNode* pop();</span>
<span class="line-added">110 </span>
<span class="line-added">111     // Take all the buffers from the queue, leaving the queue empty.</span>
<span class="line-added">112     // Not thread-safe.</span>
<span class="line-added">113     HeadTail take_all();</span>
<span class="line-added">114   };</span>
<span class="line-added">115 </span>
<span class="line-added">116   // Concurrent refinement may stop processing in the middle of a buffer if</span>
<span class="line-added">117   // there is a pending safepoint, to avoid long delays to safepoint.  A</span>
<span class="line-added">118   // partially processed buffer needs to be recorded for processing by the</span>
<span class="line-added">119   // safepoint if it&#39;s a GC safepoint; otherwise it needs to be recorded for</span>
<span class="line-added">120   // further concurrent refinement work after the safepoint.  But if the</span>
<span class="line-added">121   // buffer was obtained from the completed buffer queue then it can&#39;t simply</span>
<span class="line-added">122   // be added back to the queue, as that would introduce a new source of ABA</span>
<span class="line-added">123   // for the queue.</span>
124   //
<span class="line-modified">125   // The PausedBuffer object is used to record such buffers for the upcoming</span>
<span class="line-modified">126   // safepoint, and provides access to the buffers recorded for previous</span>
<span class="line-modified">127   // safepoints.  Before obtaining a buffer from the completed buffers queue,</span>
<span class="line-modified">128   // we first transfer any buffers from previous safepoints to the queue.</span>
<span class="line-modified">129   // This is ABA-safe because threads cannot be in the midst of a queue pop</span>
<span class="line-added">130   // across a safepoint.</span>
131   //
<span class="line-modified">132   // The paused buffers are conceptually an extension of the completed buffers</span>
<span class="line-modified">133   // queue, and operations which need to deal with all of the queued buffers</span>
<span class="line-modified">134   // (such as concatenate_logs) also need to deal with any paused buffers.  In</span>
<span class="line-modified">135   // general, if a safepoint performs a GC then the paused buffers will be</span>
<span class="line-modified">136   // processed as part of it, and there won&#39;t be any paused buffers after a</span>
<span class="line-modified">137   // GC safepoint.</span>
<span class="line-added">138   class PausedBuffers {</span>
<span class="line-added">139     class PausedList : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added">140       BufferNode* volatile _head;</span>
<span class="line-added">141       BufferNode* _tail;</span>
<span class="line-added">142       size_t _safepoint_id;</span>
<span class="line-added">143 </span>
<span class="line-added">144       NONCOPYABLE(PausedList);</span>
<span class="line-added">145 </span>
<span class="line-added">146     public:</span>
<span class="line-added">147       PausedList();</span>
<span class="line-added">148       DEBUG_ONLY(~PausedList();)</span>
<span class="line-added">149 </span>
<span class="line-added">150       // Return true if this list was created to hold buffers for the</span>
<span class="line-added">151       // next safepoint.</span>
<span class="line-added">152       // precondition: not at safepoint.</span>
<span class="line-added">153       bool is_next() const;</span>
<span class="line-added">154 </span>
<span class="line-added">155       // Thread-safe add the buffer to the list.</span>
<span class="line-added">156       // precondition: not at safepoint.</span>
<span class="line-added">157       // precondition: is_next().</span>
<span class="line-added">158       void add(BufferNode* node);</span>
<span class="line-added">159 </span>
<span class="line-added">160       // Take all the buffers from the list.  Not thread-safe.</span>
<span class="line-added">161       HeadTail take();</span>
<span class="line-added">162     };</span>
<span class="line-added">163 </span>
<span class="line-added">164     // The most recently created list, which might be for either the next or</span>
<span class="line-added">165     // a previous safepoint, or might be NULL if the next list hasn&#39;t been</span>
<span class="line-added">166     // created yet.  We only need one list because of the requirement that</span>
<span class="line-added">167     // threads calling add() must first ensure there are no paused buffers</span>
<span class="line-added">168     // from a previous safepoint.  There might be many list instances existing</span>
<span class="line-added">169     // at the same time though; there can be many threads competing to create</span>
<span class="line-added">170     // and install the next list, and meanwhile there can be a thread dealing</span>
<span class="line-added">171     // with the previous list.</span>
<span class="line-added">172     PausedList* volatile _plist;</span>
<span class="line-added">173     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(PausedList*));</span>
<span class="line-added">174 </span>
<span class="line-added">175     NONCOPYABLE(PausedBuffers);</span>
<span class="line-added">176 </span>
<span class="line-added">177   public:</span>
<span class="line-added">178     PausedBuffers();</span>
<span class="line-added">179     DEBUG_ONLY(~PausedBuffers();)</span>
<span class="line-added">180 </span>
<span class="line-added">181     // Test whether there are any paused lists.</span>
<span class="line-added">182     // Thread-safe, but the answer may change immediately.</span>
<span class="line-added">183     bool is_empty() const;</span>
<span class="line-added">184 </span>
<span class="line-added">185     // Thread-safe add the buffer to paused list for next safepoint.</span>
<span class="line-added">186     // precondition: not at safepoint.</span>
<span class="line-added">187     // precondition: does not have paused buffers from a previous safepoint.</span>
<span class="line-added">188     void add(BufferNode* node);</span>
<span class="line-added">189 </span>
<span class="line-added">190     // Thread-safe take all paused buffers for previous safepoints.</span>
<span class="line-added">191     // precondition: not at safepoint.</span>
<span class="line-added">192     HeadTail take_previous();</span>
<span class="line-added">193 </span>
<span class="line-added">194     // Take all the paused buffers.</span>
<span class="line-added">195     // precondition: at safepoint.</span>
<span class="line-added">196     HeadTail take_all();</span>
<span class="line-added">197   };</span>
<span class="line-added">198 </span>
<span class="line-added">199   // The primary refinement thread, for activation when the processing</span>
<span class="line-added">200   // threshold is reached.  NULL if there aren&#39;t any refinement threads.</span>
<span class="line-added">201   G1ConcurrentRefineThread* _primary_refinement_thread;</span>
<span class="line-added">202   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(G1ConcurrentRefineThread*));</span>
<span class="line-added">203   // Upper bound on the number of cards in the completed and paused buffers.</span>
<span class="line-added">204   volatile size_t _num_cards;</span>
<span class="line-added">205   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));</span>
<span class="line-added">206   // Buffers ready for refinement.</span>
<span class="line-added">207   Queue _completed;           // Has inner padding, including trailer.</span>
<span class="line-added">208   // Buffers for which refinement is temporarily paused.</span>
<span class="line-added">209   PausedBuffers _paused;      // Has inner padding, including trailer.</span>
<span class="line-added">210 </span>
<span class="line-added">211   G1FreeIdSet _free_ids;</span>
<span class="line-added">212 </span>
<span class="line-added">213   // Activation threshold for the primary refinement thread.</span>
<span class="line-added">214   size_t _process_cards_threshold;</span>
<span class="line-added">215 </span>
<span class="line-added">216   // If the queue contains more cards than configured here, the</span>
<span class="line-added">217   // mutator must start doing some of the concurrent refinement work.</span>
<span class="line-added">218   size_t _max_cards;</span>
<span class="line-added">219   size_t _max_cards_padding;</span>
<span class="line-added">220   static const size_t MaxCardsUnlimited = SIZE_MAX;</span>
<span class="line-added">221 </span>
<span class="line-added">222   // Array of cumulative dirty cards refined by mutator threads.</span>
<span class="line-added">223   // Array has an entry per id in _free_ids.</span>
<span class="line-added">224   size_t* _mutator_refined_cards_counters;</span>
<span class="line-added">225 </span>
<span class="line-added">226   // Verify _num_cards == sum of cards in the completed queue.</span>
<span class="line-added">227   void verify_num_cards() const NOT_DEBUG_RETURN;</span>
<span class="line-added">228 </span>
<span class="line-added">229   // Thread-safe add a buffer to paused list for next safepoint.</span>
<span class="line-added">230   // precondition: not at safepoint.</span>
<span class="line-added">231   // precondition: does not have paused buffers from a previous safepoint.</span>
<span class="line-added">232   void record_paused_buffer(BufferNode* node);</span>
<span class="line-added">233   void enqueue_paused_buffers_aux(const HeadTail&amp; paused);</span>
<span class="line-added">234   // Thread-safe transfer paused buffers for previous safepoints to the queue.</span>
<span class="line-added">235   // precondition: not at safepoint.</span>
<span class="line-added">236   void enqueue_previous_paused_buffers();</span>
<span class="line-added">237   // Transfer all paused buffers to the queue.</span>
<span class="line-added">238   // precondition: at safepoint.</span>
<span class="line-added">239   void enqueue_all_paused_buffers();</span>
<span class="line-added">240 </span>
<span class="line-added">241   void abandon_completed_buffers();</span>
<span class="line-added">242 </span>
<span class="line-added">243   // Refine the cards in &quot;node&quot; from its index to buffer_size.</span>
<span class="line-added">244   // Stops processing if SuspendibleThreadSet::should_yield() is true.</span>
<span class="line-added">245   // Returns true if the entire buffer was processed, false if there</span>
<span class="line-added">246   // is a pending yield request.  The node&#39;s index is updated to exclude</span>
<span class="line-added">247   // the processed elements, e.g. up to the element before processing</span>
<span class="line-added">248   // stopped, or one past the last element if the entire buffer was</span>
<span class="line-added">249   // processed. Increments *total_refined_cards by the number of cards</span>
<span class="line-added">250   // processed and removed from the buffer.</span>
<span class="line-added">251   bool refine_buffer(BufferNode* node, uint worker_id, size_t* total_refined_cards);</span>
252 
253   bool mut_process_buffer(BufferNode* node);
254 
<span class="line-modified">255   // If the number of completed buffers is &gt; stop_at, then remove and</span>
<span class="line-modified">256   // return a completed buffer from the list.  Otherwise, return NULL.</span>
<span class="line-modified">257   BufferNode* get_completed_buffer(size_t stop_at = 0);</span>








258 
259 public:
<span class="line-modified">260   G1DirtyCardQueueSet(BufferNode::Allocator* allocator);</span>
261   ~G1DirtyCardQueueSet();
262 
<span class="line-modified">263   void set_primary_refinement_thread(G1ConcurrentRefineThread* thread) {</span>
<span class="line-modified">264     _primary_refinement_thread = thread;</span>
<span class="line-modified">265   }</span>

266 
267   // The number of parallel ids that can be claimed to allow collector or
268   // mutator threads to do card-processing work.
269   static uint num_par_ids();
270 
271   static void handle_zero_index_for_thread(Thread* t);
272 
<span class="line-modified">273   // Either process the entire buffer and return true, or enqueue the</span>
<span class="line-modified">274   // buffer and return false.  If the buffer is completely processed,</span>
<span class="line-modified">275   // it can be reused in place.</span>
<span class="line-added">276   bool process_or_enqueue_completed_buffer(BufferNode* node);</span>
277 
<span class="line-modified">278   virtual void enqueue_completed_buffer(BufferNode* node);</span>


279 
<span class="line-modified">280   // Upper bound on the number of cards currently in in this queue set.</span>
<span class="line-modified">281   // Read without synchronization.  The value may be high because there</span>
<span class="line-modified">282   // is a concurrent modification of the set of buffers.</span>
<span class="line-modified">283   size_t num_cards() const { return _num_cards; }</span>

284 
<span class="line-modified">285   // Get/Set the number of cards that triggers log processing.</span>
<span class="line-modified">286   // Log processing should be done when the number of cards exceeds the</span>
<span class="line-added">287   // threshold.</span>
<span class="line-added">288   void set_process_cards_threshold(size_t sz) {</span>
<span class="line-added">289     _process_cards_threshold = sz;</span>
290   }
<span class="line-added">291   size_t process_cards_threshold() const {</span>
<span class="line-added">292     return _process_cards_threshold;</span>
<span class="line-added">293   }</span>
<span class="line-added">294   static const size_t ProcessCardsThresholdNever = SIZE_MAX;</span>
<span class="line-added">295 </span>
<span class="line-added">296   // Notify the consumer if the number of buffers crossed the threshold</span>
<span class="line-added">297   void notify_if_necessary();</span>
<span class="line-added">298 </span>
<span class="line-added">299   void merge_bufferlists(G1RedirtyCardsQueueSet* src);</span>
300 
<span class="line-modified">301   G1BufferNodeList take_all_completed_buffers();</span>
<span class="line-added">302 </span>
<span class="line-added">303   // If there are more than stop_at cards in the completed buffers, pop</span>
<span class="line-added">304   // a buffer, refine its contents, and return true.  Otherwise return</span>
<span class="line-added">305   // false.</span>
<span class="line-added">306   //</span>
<span class="line-added">307   // Stops processing a buffer if SuspendibleThreadSet::should_yield(),</span>
<span class="line-added">308   // recording the incompletely processed buffer for later processing of</span>
<span class="line-added">309   // the remainder.</span>
<span class="line-added">310   //</span>
<span class="line-added">311   // Increments *total_refined_cards by the number of cards processed and</span>
<span class="line-added">312   // removed from the buffer.</span>
<span class="line-added">313   bool refine_completed_buffer_concurrently(uint worker_id,</span>
<span class="line-added">314                                             size_t stop_at,</span>
<span class="line-added">315                                             size_t* total_refined_cards);</span>
<span class="line-added">316 </span>
<span class="line-added">317   // If a full collection is happening, reset partial logs, and release</span>
318   // completed ones: the full collection will make them all irrelevant.
319   void abandon_logs();
320 
321   // If any threads have partial logs, add them to the global list of logs.
322   void concatenate_logs();
323 
<span class="line-modified">324   void set_max_cards(size_t m) {</span>
<span class="line-modified">325     _max_cards = m;</span>
326   }
<span class="line-modified">327   size_t max_cards() const {</span>
<span class="line-modified">328     return _max_cards;</span>
329   }
330 
<span class="line-added">331   void set_max_cards_padding(size_t padding) {</span>
<span class="line-added">332     _max_cards_padding = padding;</span>
<span class="line-added">333   }</span>
<span class="line-added">334   size_t max_cards_padding() const {</span>
<span class="line-added">335     return _max_cards_padding;</span>
<span class="line-added">336   }</span>
<span class="line-added">337 </span>
<span class="line-added">338   // Total dirty cards refined by mutator threads.</span>
<span class="line-added">339   size_t total_mutator_refined_cards() const;</span>
340 };
341 
<span class="line-added">342 inline G1DirtyCardQueueSet* G1DirtyCardQueue::dirty_card_qset() const {</span>
<span class="line-added">343   return static_cast&lt;G1DirtyCardQueueSet*&gt;(qset());</span>
<span class="line-added">344 }</span>
<span class="line-added">345 </span>
346 #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1DirtyCardQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EdenRegions.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
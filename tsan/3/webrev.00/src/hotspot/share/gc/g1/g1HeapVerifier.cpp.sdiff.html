<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1HeapVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HeapTransition.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapVerifier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HeapVerifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/nmethod.hpp&quot;
 27 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
 30 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/g1RemSet.hpp&quot;
 33 #include &quot;gc/g1/g1RootProcessor.hpp&quot;
 34 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 35 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 36 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;logging/logStream.hpp&quot;
 39 #include &quot;memory/iterator.inline.hpp&quot;
 40 #include &quot;memory/resourceArea.hpp&quot;

 41 #include &quot;oops/access.inline.hpp&quot;
 42 #include &quot;oops/compressedOops.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 
 46 int G1HeapVerifier::_enabled_verification_types = G1HeapVerifier::G1VerifyAll;
 47 
 48 class VerifyRootsClosure: public OopClosure {
 49 private:
 50   G1CollectedHeap* _g1h;
 51   VerifyOption     _vo;
 52   bool             _failures;
 53 public:
 54   // _vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
 55   // _vo == UseNextMarking -&gt; use &quot;next&quot; marking information,
 56   // _vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
 57   VerifyRootsClosure(VerifyOption vo) :
 58     _g1h(G1CollectedHeap::heap()),
 59     _vo(vo),
 60     _failures(false) { }
</pre>
<hr />
<pre>
354 
355 class VerifyRegionClosure: public HeapRegionClosure {
356 private:
357   bool             _par;
358   VerifyOption     _vo;
359   bool             _failures;
360 public:
361   // _vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
362   // _vo == UseNextMarking -&gt; use &quot;next&quot; marking information,
363   // _vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
364   VerifyRegionClosure(bool par, VerifyOption vo)
365     : _par(par),
366       _vo(vo),
367       _failures(false) {}
368 
369   bool failures() {
370     return _failures;
371   }
372 
373   bool do_heap_region(HeapRegion* r) {

374     guarantee(!r-&gt;is_young() || r-&gt;rem_set()-&gt;is_complete(), &quot;Remembered set for Young region %u must be complete, is %s&quot;, r-&gt;hrm_index(), r-&gt;rem_set()-&gt;get_state_str());
375     // Humongous and old regions regions might be of any state, so can&#39;t check here.
376     guarantee(!r-&gt;is_free() || !r-&gt;rem_set()-&gt;is_tracked(), &quot;Remembered set for free region %u must be untracked, is %s&quot;, r-&gt;hrm_index(), r-&gt;rem_set()-&gt;get_state_str());
377     // Verify that the continues humongous regions&#39; remembered set state matches the
378     // one from the starts humongous region.
379     if (r-&gt;is_continues_humongous()) {
380       if (r-&gt;rem_set()-&gt;get_state_str() != r-&gt;humongous_start_region()-&gt;rem_set()-&gt;get_state_str()) {
381          log_error(gc, verify)(&quot;Remset states differ: Region %u (%s) remset %s with starts region %u (%s) remset %s&quot;,
382                                r-&gt;hrm_index(),
383                                r-&gt;get_short_type_str(),
384                                r-&gt;rem_set()-&gt;get_state_str(),
385                                r-&gt;humongous_start_region()-&gt;hrm_index(),
386                                r-&gt;humongous_start_region()-&gt;get_short_type_str(),
387                                r-&gt;humongous_start_region()-&gt;rem_set()-&gt;get_state_str());
388          _failures = true;
389       }
390     }
391     // For archive regions, verify there are no heap pointers to
392     // non-pinned regions. For all others, verify liveness info.
393     if (r-&gt;is_closed_archive()) {
</pre>
<hr />
<pre>
763 
764   virtual bool do_heap_region(HeapRegion* hr) {
765     bool result = _verifier-&gt;verify_bitmaps(_caller, hr);
766     if (!result) {
767       _failures = true;
768     }
769     return false;
770   }
771 };
772 
773 void G1HeapVerifier::check_bitmaps(const char* caller) {
774   if (!G1VerifyBitmaps) {
775     return;
776   }
777 
778   G1VerifyBitmapClosure cl(caller, this);
779   _g1h-&gt;heap_region_iterate(&amp;cl);
780   guarantee(!cl.failures(), &quot;bitmap verification&quot;);
781 }
782 
<span class="line-modified">783 class G1CheckCSetFastTableClosure : public HeapRegionClosure {</span>
<span class="line-modified">784  private:</span>
785   bool _failures;
<span class="line-modified">786  public:</span>
<span class="line-modified">787   G1CheckCSetFastTableClosure() : HeapRegionClosure(), _failures(false) { }</span>

788 
789   virtual bool do_heap_region(HeapRegion* hr) {
790     uint i = hr-&gt;hrm_index();
<span class="line-modified">791     InCSetState cset_state = (InCSetState) G1CollectedHeap::heap()-&gt;_in_cset_fast_test.get_by_index(i);</span>
792     if (hr-&gt;is_humongous()) {
793       if (hr-&gt;in_collection_set()) {
794         log_error(gc, verify)(&quot;## humongous region %u in CSet&quot;, i);
795         _failures = true;
796         return true;
797       }
<span class="line-modified">798       if (cset_state.is_in_cset()) {</span>
<span class="line-modified">799         log_error(gc, verify)(&quot;## inconsistent cset state &quot; CSETSTATE_FORMAT &quot; for humongous region %u&quot;, cset_state.value(), i);</span>
800         _failures = true;
801         return true;
802       }
<span class="line-modified">803       if (hr-&gt;is_continues_humongous() &amp;&amp; cset_state.is_humongous()) {</span>
<span class="line-modified">804         log_error(gc, verify)(&quot;## inconsistent cset state &quot; CSETSTATE_FORMAT &quot; for continues humongous region %u&quot;, cset_state.value(), i);</span>
805         _failures = true;
806         return true;
807       }
808     } else {
<span class="line-modified">809       if (cset_state.is_humongous()) {</span>
<span class="line-modified">810         log_error(gc, verify)(&quot;## inconsistent cset state &quot; CSETSTATE_FORMAT &quot; for non-humongous region %u&quot;, cset_state.value(), i);</span>
811         _failures = true;
812         return true;
813       }
<span class="line-modified">814       if (hr-&gt;in_collection_set() != cset_state.is_in_cset()) {</span>
<span class="line-modified">815         log_error(gc, verify)(&quot;## in CSet %d / cset state &quot; CSETSTATE_FORMAT &quot; inconsistency for region %u&quot;,</span>
<span class="line-modified">816                              hr-&gt;in_collection_set(), cset_state.value(), i);</span>
817         _failures = true;
818         return true;
819       }
<span class="line-modified">820       if (cset_state.is_in_cset()) {</span>
821         if (hr-&gt;is_archive()) {
822           log_error(gc, verify)(&quot;## is_archive in collection set for region %u&quot;, i);
823           _failures = true;
824           return true;
825         }
<span class="line-modified">826         if (hr-&gt;is_young() != (cset_state.is_young())) {</span>
<span class="line-modified">827           log_error(gc, verify)(&quot;## is_young %d / cset state &quot; CSETSTATE_FORMAT &quot; inconsistency for region %u&quot;,</span>
<span class="line-modified">828                                hr-&gt;is_young(), cset_state.value(), i);</span>
829           _failures = true;
830           return true;
831         }
<span class="line-modified">832         if (hr-&gt;is_old() != (cset_state.is_old())) {</span>
<span class="line-modified">833           log_error(gc, verify)(&quot;## is_old %d / cset state &quot; CSETSTATE_FORMAT &quot; inconsistency for region %u&quot;,</span>
<span class="line-modified">834                                hr-&gt;is_old(), cset_state.value(), i);</span>
835           _failures = true;
836           return true;
837         }
838       }
839     }
840     return false;
841   }
842 
843   bool failures() const { return _failures; }
844 };
845 
<span class="line-modified">846 bool G1HeapVerifier::check_cset_fast_test() {</span>
<span class="line-modified">847   G1CheckCSetFastTableClosure cl;</span>
848   _g1h-&gt;_hrm-&gt;iterate(&amp;cl);
849   return !cl.failures();
850 }
851 #endif // PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/nmethod.hpp&quot;
 27 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
 30 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/g1RemSet.hpp&quot;
 33 #include &quot;gc/g1/g1RootProcessor.hpp&quot;
 34 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 35 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 36 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;logging/logStream.hpp&quot;
 39 #include &quot;memory/iterator.inline.hpp&quot;
 40 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 41 #include &quot;memory/universe.hpp&quot;</span>
 42 #include &quot;oops/access.inline.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;runtime/handles.inline.hpp&quot;
 46 
 47 int G1HeapVerifier::_enabled_verification_types = G1HeapVerifier::G1VerifyAll;
 48 
 49 class VerifyRootsClosure: public OopClosure {
 50 private:
 51   G1CollectedHeap* _g1h;
 52   VerifyOption     _vo;
 53   bool             _failures;
 54 public:
 55   // _vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
 56   // _vo == UseNextMarking -&gt; use &quot;next&quot; marking information,
 57   // _vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
 58   VerifyRootsClosure(VerifyOption vo) :
 59     _g1h(G1CollectedHeap::heap()),
 60     _vo(vo),
 61     _failures(false) { }
</pre>
<hr />
<pre>
355 
356 class VerifyRegionClosure: public HeapRegionClosure {
357 private:
358   bool             _par;
359   VerifyOption     _vo;
360   bool             _failures;
361 public:
362   // _vo == UsePrevMarking -&gt; use &quot;prev&quot; marking information,
363   // _vo == UseNextMarking -&gt; use &quot;next&quot; marking information,
364   // _vo == UseFullMarking -&gt; use &quot;next&quot; marking bitmap but no TAMS
365   VerifyRegionClosure(bool par, VerifyOption vo)
366     : _par(par),
367       _vo(vo),
368       _failures(false) {}
369 
370   bool failures() {
371     return _failures;
372   }
373 
374   bool do_heap_region(HeapRegion* r) {
<span class="line-added">375     guarantee(!r-&gt;has_index_in_opt_cset(), &quot;Region %u still has opt collection set index %u&quot;, r-&gt;hrm_index(), r-&gt;index_in_opt_cset());</span>
376     guarantee(!r-&gt;is_young() || r-&gt;rem_set()-&gt;is_complete(), &quot;Remembered set for Young region %u must be complete, is %s&quot;, r-&gt;hrm_index(), r-&gt;rem_set()-&gt;get_state_str());
377     // Humongous and old regions regions might be of any state, so can&#39;t check here.
378     guarantee(!r-&gt;is_free() || !r-&gt;rem_set()-&gt;is_tracked(), &quot;Remembered set for free region %u must be untracked, is %s&quot;, r-&gt;hrm_index(), r-&gt;rem_set()-&gt;get_state_str());
379     // Verify that the continues humongous regions&#39; remembered set state matches the
380     // one from the starts humongous region.
381     if (r-&gt;is_continues_humongous()) {
382       if (r-&gt;rem_set()-&gt;get_state_str() != r-&gt;humongous_start_region()-&gt;rem_set()-&gt;get_state_str()) {
383          log_error(gc, verify)(&quot;Remset states differ: Region %u (%s) remset %s with starts region %u (%s) remset %s&quot;,
384                                r-&gt;hrm_index(),
385                                r-&gt;get_short_type_str(),
386                                r-&gt;rem_set()-&gt;get_state_str(),
387                                r-&gt;humongous_start_region()-&gt;hrm_index(),
388                                r-&gt;humongous_start_region()-&gt;get_short_type_str(),
389                                r-&gt;humongous_start_region()-&gt;rem_set()-&gt;get_state_str());
390          _failures = true;
391       }
392     }
393     // For archive regions, verify there are no heap pointers to
394     // non-pinned regions. For all others, verify liveness info.
395     if (r-&gt;is_closed_archive()) {
</pre>
<hr />
<pre>
765 
766   virtual bool do_heap_region(HeapRegion* hr) {
767     bool result = _verifier-&gt;verify_bitmaps(_caller, hr);
768     if (!result) {
769       _failures = true;
770     }
771     return false;
772   }
773 };
774 
775 void G1HeapVerifier::check_bitmaps(const char* caller) {
776   if (!G1VerifyBitmaps) {
777     return;
778   }
779 
780   G1VerifyBitmapClosure cl(caller, this);
781   _g1h-&gt;heap_region_iterate(&amp;cl);
782   guarantee(!cl.failures(), &quot;bitmap verification&quot;);
783 }
784 
<span class="line-modified">785 class G1CheckRegionAttrTableClosure : public HeapRegionClosure {</span>
<span class="line-modified">786 private:</span>
787   bool _failures;
<span class="line-modified">788 </span>
<span class="line-modified">789 public:</span>
<span class="line-added">790   G1CheckRegionAttrTableClosure() : HeapRegionClosure(), _failures(false) { }</span>
791 
792   virtual bool do_heap_region(HeapRegion* hr) {
793     uint i = hr-&gt;hrm_index();
<span class="line-modified">794     G1HeapRegionAttr region_attr = (G1HeapRegionAttr) G1CollectedHeap::heap()-&gt;_region_attr.get_by_index(i);</span>
795     if (hr-&gt;is_humongous()) {
796       if (hr-&gt;in_collection_set()) {
797         log_error(gc, verify)(&quot;## humongous region %u in CSet&quot;, i);
798         _failures = true;
799         return true;
800       }
<span class="line-modified">801       if (region_attr.is_in_cset()) {</span>
<span class="line-modified">802         log_error(gc, verify)(&quot;## inconsistent region attr type %s for humongous region %u&quot;, region_attr.get_type_str(), i);</span>
803         _failures = true;
804         return true;
805       }
<span class="line-modified">806       if (hr-&gt;is_continues_humongous() &amp;&amp; region_attr.is_humongous()) {</span>
<span class="line-modified">807         log_error(gc, verify)(&quot;## inconsistent region attr type %s for continues humongous region %u&quot;, region_attr.get_type_str(), i);</span>
808         _failures = true;
809         return true;
810       }
811     } else {
<span class="line-modified">812       if (region_attr.is_humongous()) {</span>
<span class="line-modified">813         log_error(gc, verify)(&quot;## inconsistent region attr type %s for non-humongous region %u&quot;, region_attr.get_type_str(), i);</span>
814         _failures = true;
815         return true;
816       }
<span class="line-modified">817       if (hr-&gt;in_collection_set() != region_attr.is_in_cset()) {</span>
<span class="line-modified">818         log_error(gc, verify)(&quot;## in CSet %d / region attr type %s inconsistency for region %u&quot;,</span>
<span class="line-modified">819                              hr-&gt;in_collection_set(), region_attr.get_type_str(), i);</span>
820         _failures = true;
821         return true;
822       }
<span class="line-modified">823       if (region_attr.is_in_cset()) {</span>
824         if (hr-&gt;is_archive()) {
825           log_error(gc, verify)(&quot;## is_archive in collection set for region %u&quot;, i);
826           _failures = true;
827           return true;
828         }
<span class="line-modified">829         if (hr-&gt;is_young() != (region_attr.is_young())) {</span>
<span class="line-modified">830           log_error(gc, verify)(&quot;## is_young %d / region attr type %s inconsistency for region %u&quot;,</span>
<span class="line-modified">831                                hr-&gt;is_young(), region_attr.get_type_str(), i);</span>
832           _failures = true;
833           return true;
834         }
<span class="line-modified">835         if (hr-&gt;is_old() != (region_attr.is_old())) {</span>
<span class="line-modified">836           log_error(gc, verify)(&quot;## is_old %d / region attr type %s inconsistency for region %u&quot;,</span>
<span class="line-modified">837                                hr-&gt;is_old(), region_attr.get_type_str(), i);</span>
838           _failures = true;
839           return true;
840         }
841       }
842     }
843     return false;
844   }
845 
846   bool failures() const { return _failures; }
847 };
848 
<span class="line-modified">849 bool G1HeapVerifier::check_region_attr_table() {</span>
<span class="line-modified">850   G1CheckRegionAttrTableClosure cl;</span>
851   _g1h-&gt;_hrm-&gt;iterate(&amp;cl);
852   return !cl.failures();
853 }
854 #endif // PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="g1HeapTransition.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapVerifier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
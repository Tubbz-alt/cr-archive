<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1HeapTransition.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HeapSizingPolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapTransition.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HeapTransition.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 27 #include &quot;gc/g1/g1HeapTransition.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
<span class="line-modified"> 29 #include &quot;logging/log.hpp&quot;</span>
 30 #include &quot;memory/metaspace.hpp&quot;
 31 
<span class="line-modified"> 32 G1HeapTransition::Data::Data(G1CollectedHeap* g1_heap) {</span>
<span class="line-modified"> 33   _eden_length = g1_heap-&gt;eden_regions_count();</span>
<span class="line-modified"> 34   _survivor_length = g1_heap-&gt;survivor_regions_count();</span>
<span class="line-modified"> 35   _old_length = g1_heap-&gt;old_regions_count();</span>
<span class="line-modified"> 36   _archive_length = g1_heap-&gt;archive_regions_count();</span>
<span class="line-modified"> 37   _humongous_length = g1_heap-&gt;humongous_regions_count();</span>
<span class="line-modified"> 38   _metaspace_used_bytes = MetaspaceUtils::used_bytes();</span>






















 39 }
 40 
 41 G1HeapTransition::G1HeapTransition(G1CollectedHeap* g1_heap) : _g1_heap(g1_heap), _before(g1_heap) { }
 42 
 43 struct DetailedUsage : public StackObj {
 44   size_t _eden_used;
 45   size_t _survivor_used;
 46   size_t _old_used;
 47   size_t _archive_used;
 48   size_t _humongous_used;
 49 
 50   size_t _eden_region_count;
 51   size_t _survivor_region_count;
 52   size_t _old_region_count;
 53   size_t _archive_region_count;
 54   size_t _humongous_region_count;
 55 
 56   DetailedUsage() :
 57     _eden_used(0), _survivor_used(0), _old_used(0), _archive_used(0), _humongous_used(0),
 58     _eden_region_count(0), _survivor_region_count(0), _old_region_count(0),
</pre>
<hr />
<pre>
 68       _usage._old_region_count++;
 69     } else if (r-&gt;is_archive()) {
 70       _usage._archive_used += r-&gt;used();
 71       _usage._archive_region_count++;
 72     } else if (r-&gt;is_survivor()) {
 73       _usage._survivor_used += r-&gt;used();
 74       _usage._survivor_region_count++;
 75     } else if (r-&gt;is_eden()) {
 76       _usage._eden_used += r-&gt;used();
 77       _usage._eden_region_count++;
 78     } else if (r-&gt;is_humongous()) {
 79       _usage._humongous_used += r-&gt;used();
 80       _usage._humongous_region_count++;
 81     } else {
 82       assert(r-&gt;used() == 0, &quot;Expected used to be 0 but it was &quot; SIZE_FORMAT, r-&gt;used());
 83     }
 84     return false;
 85   }
 86 };
 87 




























 88 void G1HeapTransition::print() {
 89   Data after(_g1_heap);
 90 
 91   size_t eden_capacity_length_after_gc = _g1_heap-&gt;policy()-&gt;young_list_target_length() - after._survivor_length;
 92   size_t survivor_capacity_length_before_gc = _g1_heap-&gt;policy()-&gt;max_survivor_regions();
 93 
 94   DetailedUsage usage;
 95   if (log_is_enabled(Trace, gc, heap)) {
 96     DetailedUsageClosure blk;
 97     _g1_heap-&gt;heap_region_iterate(&amp;blk);
 98     usage = blk._usage;
 99     assert(usage._eden_region_count == 0, &quot;Expected no eden regions, but got &quot; SIZE_FORMAT, usage._eden_region_count);
100     assert(usage._survivor_region_count == after._survivor_length, &quot;Expected survivors to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
101         after._survivor_length, usage._survivor_region_count);
102     assert(usage._old_region_count == after._old_length, &quot;Expected old to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
103         after._old_length, usage._old_region_count);
104     assert(usage._archive_region_count == after._archive_length, &quot;Expected archive to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
105         after._archive_length, usage._archive_region_count);
106     assert(usage._humongous_region_count == after._humongous_length, &quot;Expected humongous to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
107         after._humongous_length, usage._humongous_region_count);
108   }
109 
<span class="line-modified">110   log_info(gc, heap)(&quot;Eden regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;(&quot;  SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">111                      _before._eden_length, after._eden_length, eden_capacity_length_after_gc);</span>
112   log_trace(gc, heap)(&quot; Used: 0K, Waste: 0K&quot;);
113 
<span class="line-modified">114   log_info(gc, heap)(&quot;Survivor regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;(&quot;  SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">115                      _before._survivor_length, after._survivor_length, survivor_capacity_length_before_gc);</span>
116   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
117       usage._survivor_used / K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) / K);
118 
119   log_info(gc, heap)(&quot;Old regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
120                      _before._old_length, after._old_length);
121   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
122       usage._old_used / K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) / K);
123 
124   log_info(gc, heap)(&quot;Archive regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
125                      _before._archive_length, after._archive_length);
126   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
127       usage._archive_used / K, ((after._archive_length * HeapRegion::GrainBytes) - usage._archive_used) / K);
128 
129   log_info(gc, heap)(&quot;Humongous regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
130                      _before._humongous_length, after._humongous_length);
131   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
132       usage._humongous_used / K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) / K);
133 
<span class="line-modified">134   MetaspaceUtils::print_metaspace_change(_before._metaspace_used_bytes);</span>
135 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 27 #include &quot;gc/g1/g1HeapTransition.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
<span class="line-modified"> 29 #include &quot;logging/logStream.hpp&quot;</span>
 30 #include &quot;memory/metaspace.hpp&quot;
 31 
<span class="line-modified"> 32 G1HeapTransition::Data::Data(G1CollectedHeap* g1_heap) :</span>
<span class="line-modified"> 33   _eden_length(g1_heap-&gt;eden_regions_count()),</span>
<span class="line-modified"> 34   _survivor_length(g1_heap-&gt;survivor_regions_count()),</span>
<span class="line-modified"> 35   _old_length(g1_heap-&gt;old_regions_count()),</span>
<span class="line-modified"> 36   _archive_length(g1_heap-&gt;archive_regions_count()),</span>
<span class="line-modified"> 37   _humongous_length(g1_heap-&gt;humongous_regions_count()),</span>
<span class="line-modified"> 38   _eden_length_per_node(NULL),</span>
<span class="line-added"> 39   _survivor_length_per_node(NULL) {</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41   uint node_count = G1NUMA::numa()-&gt;num_active_nodes();</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43   if (node_count &gt; 1) {</span>
<span class="line-added"> 44     LogTarget(Debug, gc, heap, numa) lt;</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46     if (lt.is_enabled()) {</span>
<span class="line-added"> 47       _eden_length_per_node = NEW_C_HEAP_ARRAY(uint, node_count, mtGC);</span>
<span class="line-added"> 48       _survivor_length_per_node = NEW_C_HEAP_ARRAY(uint, node_count, mtGC);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50       for (uint i = 0; i &lt; node_count; i++) {</span>
<span class="line-added"> 51         _eden_length_per_node[i] = g1_heap-&gt;eden_regions_count(i);</span>
<span class="line-added"> 52         _survivor_length_per_node[i] = g1_heap-&gt;survivor_regions_count(i);</span>
<span class="line-added"> 53       }</span>
<span class="line-added"> 54     }</span>
<span class="line-added"> 55   }</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 G1HeapTransition::Data::~Data() {</span>
<span class="line-added"> 59   FREE_C_HEAP_ARRAY(uint, _eden_length_per_node);</span>
<span class="line-added"> 60   FREE_C_HEAP_ARRAY(uint, _survivor_length_per_node);</span>
 61 }
 62 
 63 G1HeapTransition::G1HeapTransition(G1CollectedHeap* g1_heap) : _g1_heap(g1_heap), _before(g1_heap) { }
 64 
 65 struct DetailedUsage : public StackObj {
 66   size_t _eden_used;
 67   size_t _survivor_used;
 68   size_t _old_used;
 69   size_t _archive_used;
 70   size_t _humongous_used;
 71 
 72   size_t _eden_region_count;
 73   size_t _survivor_region_count;
 74   size_t _old_region_count;
 75   size_t _archive_region_count;
 76   size_t _humongous_region_count;
 77 
 78   DetailedUsage() :
 79     _eden_used(0), _survivor_used(0), _old_used(0), _archive_used(0), _humongous_used(0),
 80     _eden_region_count(0), _survivor_region_count(0), _old_region_count(0),
</pre>
<hr />
<pre>
 90       _usage._old_region_count++;
 91     } else if (r-&gt;is_archive()) {
 92       _usage._archive_used += r-&gt;used();
 93       _usage._archive_region_count++;
 94     } else if (r-&gt;is_survivor()) {
 95       _usage._survivor_used += r-&gt;used();
 96       _usage._survivor_region_count++;
 97     } else if (r-&gt;is_eden()) {
 98       _usage._eden_used += r-&gt;used();
 99       _usage._eden_region_count++;
100     } else if (r-&gt;is_humongous()) {
101       _usage._humongous_used += r-&gt;used();
102       _usage._humongous_region_count++;
103     } else {
104       assert(r-&gt;used() == 0, &quot;Expected used to be 0 but it was &quot; SIZE_FORMAT, r-&gt;used());
105     }
106     return false;
107   }
108 };
109 
<span class="line-added">110 static void log_regions(const char* msg, size_t before_length, size_t after_length, size_t capacity,</span>
<span class="line-added">111                         uint* before_per_node_length, uint* after_per_node_length) {</span>
<span class="line-added">112   LogTarget(Info, gc, heap) lt;</span>
<span class="line-added">113 </span>
<span class="line-added">114   if (lt.is_enabled()) {</span>
<span class="line-added">115     LogStream ls(lt);</span>
<span class="line-added">116 </span>
<span class="line-added">117     ls.print(&quot;%s regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;(&quot;  SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-added">118              msg, before_length, after_length, capacity);</span>
<span class="line-added">119     // Not NULL only if gc+heap+numa at Debug level is enabled.</span>
<span class="line-added">120     if (before_per_node_length != NULL &amp;&amp; after_per_node_length != NULL) {</span>
<span class="line-added">121       G1NUMA* numa = G1NUMA::numa();</span>
<span class="line-added">122       uint num_nodes = numa-&gt;num_active_nodes();</span>
<span class="line-added">123       const int* node_ids = numa-&gt;node_ids();</span>
<span class="line-added">124       ls.print(&quot; (&quot;);</span>
<span class="line-added">125       for (uint i = 0; i &lt; num_nodes; i++) {</span>
<span class="line-added">126         ls.print(&quot;%d: %u-&gt;%u&quot;, node_ids[i], before_per_node_length[i], after_per_node_length[i]);</span>
<span class="line-added">127         // Skip adding below if it is the last one.</span>
<span class="line-added">128         if (i != num_nodes - 1) {</span>
<span class="line-added">129           ls.print(&quot;, &quot;);</span>
<span class="line-added">130         }</span>
<span class="line-added">131       }</span>
<span class="line-added">132       ls.print(&quot;)&quot;);</span>
<span class="line-added">133     }</span>
<span class="line-added">134     ls.print_cr(&quot;&quot;);</span>
<span class="line-added">135   }</span>
<span class="line-added">136 }</span>
<span class="line-added">137 </span>
138 void G1HeapTransition::print() {
139   Data after(_g1_heap);
140 
141   size_t eden_capacity_length_after_gc = _g1_heap-&gt;policy()-&gt;young_list_target_length() - after._survivor_length;
142   size_t survivor_capacity_length_before_gc = _g1_heap-&gt;policy()-&gt;max_survivor_regions();
143 
144   DetailedUsage usage;
145   if (log_is_enabled(Trace, gc, heap)) {
146     DetailedUsageClosure blk;
147     _g1_heap-&gt;heap_region_iterate(&amp;blk);
148     usage = blk._usage;
149     assert(usage._eden_region_count == 0, &quot;Expected no eden regions, but got &quot; SIZE_FORMAT, usage._eden_region_count);
150     assert(usage._survivor_region_count == after._survivor_length, &quot;Expected survivors to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
151         after._survivor_length, usage._survivor_region_count);
152     assert(usage._old_region_count == after._old_length, &quot;Expected old to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
153         after._old_length, usage._old_region_count);
154     assert(usage._archive_region_count == after._archive_length, &quot;Expected archive to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
155         after._archive_length, usage._archive_region_count);
156     assert(usage._humongous_region_count == after._humongous_length, &quot;Expected humongous to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
157         after._humongous_length, usage._humongous_region_count);
158   }
159 
<span class="line-modified">160   log_regions(&quot;Eden&quot;, _before._eden_length, after._eden_length, eden_capacity_length_after_gc,</span>
<span class="line-modified">161               _before._eden_length_per_node, after._eden_length_per_node);</span>
162   log_trace(gc, heap)(&quot; Used: 0K, Waste: 0K&quot;);
163 
<span class="line-modified">164   log_regions(&quot;Survivor&quot;, _before._survivor_length, after._survivor_length, survivor_capacity_length_before_gc,</span>
<span class="line-modified">165               _before._survivor_length_per_node, after._survivor_length_per_node);</span>
166   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
167       usage._survivor_used / K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) / K);
168 
169   log_info(gc, heap)(&quot;Old regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
170                      _before._old_length, after._old_length);
171   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
172       usage._old_used / K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) / K);
173 
174   log_info(gc, heap)(&quot;Archive regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
175                      _before._archive_length, after._archive_length);
176   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
177       usage._archive_used / K, ((after._archive_length * HeapRegion::GrainBytes) - usage._archive_used) / K);
178 
179   log_info(gc, heap)(&quot;Humongous regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
180                      _before._humongous_length, after._humongous_length);
181   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
182       usage._humongous_used / K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) / K);
183 
<span class="line-modified">184   MetaspaceUtils::print_metaspace_change(_before._meta_sizes);</span>
185 }
</pre>
</td>
</tr>
</table>
<center><a href="g1HeapSizingPolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapTransition.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
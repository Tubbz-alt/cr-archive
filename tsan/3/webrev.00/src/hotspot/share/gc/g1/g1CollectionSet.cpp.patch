diff a/src/hotspot/share/gc/g1/g1CollectionSet.cpp b/src/hotspot/share/gc/g1/g1CollectionSet.cpp
--- a/src/hotspot/share/gc/g1/g1CollectionSet.cpp
+++ b/src/hotspot/share/gc/g1/g1CollectionSet.cpp
@@ -25,30 +25,32 @@
 #include "precompiled.hpp"
 #include "gc/g1/g1CollectedHeap.inline.hpp"
 #include "gc/g1/g1CollectionSet.hpp"
 #include "gc/g1/g1CollectionSetCandidates.hpp"
 #include "gc/g1/g1CollectorState.hpp"
+#include "gc/g1/g1HotCardCache.hpp"
 #include "gc/g1/g1ParScanThreadState.hpp"
 #include "gc/g1/g1Policy.hpp"
 #include "gc/g1/heapRegion.inline.hpp"
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/g1/heapRegionSet.hpp"
 #include "logging/logStream.hpp"
+#include "runtime/orderAccess.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/quickSort.hpp"
 
-G1CollectorState* G1CollectionSet::collector_state() {
+G1CollectorState* G1CollectionSet::collector_state() const {
   return _g1h->collector_state();
 }
 
 G1GCPhaseTimes* G1CollectionSet::phase_times() {
   return _policy->phase_times();
 }
 
-double G1CollectionSet::predict_region_elapsed_time_ms(HeapRegion* hr) {
-  return _policy->predict_region_elapsed_time_ms(hr, collector_state()->in_young_only_phase());
+double G1CollectionSet::predict_region_non_copy_time_ms(HeapRegion* hr) const {
+  return _policy->predict_region_non_copy_time_ms(hr, collector_state()->in_young_only_phase());
 }
 
 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
   _g1h(g1h),
   _policy(policy),
@@ -57,27 +59,26 @@
   _survivor_region_length(0),
   _old_region_length(0),
   _collection_set_regions(NULL),
   _collection_set_cur_length(0),
   _collection_set_max_length(0),
-  _optional_regions(NULL),
-  _optional_region_length(0),
-  _optional_region_max_length(0),
+  _num_optional_regions(0),
   _bytes_used_before(0),
-  _recorded_rs_lengths(0),
+  _recorded_rs_length(0),
   _inc_build_state(Inactive),
+  _inc_part_start(0),
+  _inc_collection_set_stats(NULL),
   _inc_bytes_used_before(0),
-  _inc_recorded_rs_lengths(0),
-  _inc_recorded_rs_lengths_diffs(0),
-  _inc_predicted_elapsed_time_ms(0.0),
-  _inc_predicted_elapsed_time_ms_diffs(0.0) {
+  _inc_recorded_rs_length(0),
+  _inc_recorded_rs_length_diff(0),
+  _inc_predicted_non_copy_time_ms(0.0),
+  _inc_predicted_non_copy_time_ms_diff(0.0) {
 }
 
 G1CollectionSet::~G1CollectionSet() {
-  if (_collection_set_regions != NULL) {
-    FREE_C_HEAP_ARRAY(uint, _collection_set_regions);
-  }
+  FREE_C_HEAP_ARRAY(uint, _collection_set_regions);
+  FREE_C_HEAP_ARRAY(IncCollectionSetRegionStat, _inc_collection_set_stats);
   free_optional_regions();
   clear_candidates();
 }
 
 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
@@ -88,156 +89,168 @@
   _survivor_region_length = survivor_cset_region_length;
 
   assert((size_t) young_region_length() == _collection_set_cur_length,
          "Young region length %u should match collection set length " SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 
-  _old_region_length      = 0;
-  _optional_region_length = 0;
+  _old_region_length = 0;
+  free_optional_regions();
 }
 
 void G1CollectionSet::initialize(uint max_region_length) {
   guarantee(_collection_set_regions == NULL, "Must only initialize once.");
   _collection_set_max_length = max_region_length;
   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
-}
-
-void G1CollectionSet::initialize_optional(uint max_length) {
-  assert(_optional_regions == NULL, "Already initialized");
-  assert(_optional_region_length == 0, "Already initialized");
-  assert(_optional_region_max_length == 0, "Already initialized");
-  _optional_region_max_length = max_length;
-  _optional_regions = NEW_C_HEAP_ARRAY(HeapRegion*, _optional_region_max_length, mtGC);
+  _inc_collection_set_stats = NEW_C_HEAP_ARRAY(IncCollectionSetRegionStat, max_region_length, mtGC);
 }
 
 void G1CollectionSet::free_optional_regions() {
-  _optional_region_length = 0;
-  _optional_region_max_length = 0;
-  if (_optional_regions != NULL) {
-    FREE_C_HEAP_ARRAY(HeapRegion*, _optional_regions);
-    _optional_regions = NULL;
-  }
+  _num_optional_regions = 0;
 }
 
 void G1CollectionSet::clear_candidates() {
   delete _candidates;
   _candidates = NULL;
 }
 
-void G1CollectionSet::set_recorded_rs_lengths(size_t rs_lengths) {
-  _recorded_rs_lengths = rs_lengths;
+void G1CollectionSet::set_recorded_rs_length(size_t rs_length) {
+  _recorded_rs_length = rs_length;
 }
 
 // Add the heap region at the head of the non-incremental collection set
 void G1CollectionSet::add_old_region(HeapRegion* hr) {
   assert_at_safepoint_on_vm_thread();
 
-  assert(_inc_build_state == Active || hr->index_in_opt_cset() != G1OptionalCSet::InvalidCSetIndex,
+  assert(_inc_build_state == Active,
          "Precondition, actively building cset or adding optional later on");
   assert(hr->is_old(), "the region should be old");
 
-  assert(!hr->in_collection_set(), "should not already be in the CSet");
-  _g1h->register_old_region_with_cset(hr);
+  assert(!hr->in_collection_set(), "should not already be in the collection set");
+  _g1h->register_old_region_with_region_attr(hr);
 
   _collection_set_regions[_collection_set_cur_length++] = hr->hrm_index();
   assert(_collection_set_cur_length <= _collection_set_max_length, "Collection set now larger than maximum size.");
 
   _bytes_used_before += hr->used();
-  size_t rs_length = hr->rem_set()->occupied();
-  _recorded_rs_lengths += rs_length;
-  _old_region_length += 1;
+  _recorded_rs_length += hr->rem_set()->occupied();
+  _old_region_length++;
 
-  log_trace(gc, cset)("Added old region %d to collection set", hr->hrm_index());
+  _g1h->old_set_remove(hr);
 }
 
 void G1CollectionSet::add_optional_region(HeapRegion* hr) {
-  assert(!optional_is_full(), "Precondition, must have room left for this region");
   assert(hr->is_old(), "the region should be old");
   assert(!hr->in_collection_set(), "should not already be in the CSet");
 
-  _g1h->register_optional_region_with_cset(hr);
+  _g1h->register_optional_region_with_region_attr(hr);
 
-  _optional_regions[_optional_region_length] = hr;
-  uint index = _optional_region_length++;
-  hr->set_index_in_opt_cset(index);
-
-  log_trace(gc, cset)("Added region %d to optional collection set (%u)", hr->hrm_index(), _optional_region_length);
+  hr->set_index_in_opt_cset(_num_optional_regions++);
 }
 
-// Initialize the per-collection-set information
 void G1CollectionSet::start_incremental_building() {
   assert(_collection_set_cur_length == 0, "Collection set must be empty before starting a new collection set.");
   assert(_inc_build_state == Inactive, "Precondition");
+#ifdef ASSERT
+  for (size_t i = 0; i < _collection_set_max_length; i++) {
+    _inc_collection_set_stats[i].reset();
+  }
+#endif
 
   _inc_bytes_used_before = 0;
 
-  _inc_recorded_rs_lengths = 0;
-  _inc_recorded_rs_lengths_diffs = 0;
-  _inc_predicted_elapsed_time_ms = 0.0;
-  _inc_predicted_elapsed_time_ms_diffs = 0.0;
-  _inc_build_state = Active;
+  _inc_recorded_rs_length = 0;
+  _inc_recorded_rs_length_diff = 0;
+  _inc_predicted_non_copy_time_ms = 0.0;
+  _inc_predicted_non_copy_time_ms_diff = 0.0;
+
+  update_incremental_marker();
 }
 
 void G1CollectionSet::finalize_incremental_building() {
   assert(_inc_build_state == Active, "Precondition");
   assert(SafepointSynchronize::is_at_safepoint(), "should be at a safepoint");
 
-  // The two "main" fields, _inc_recorded_rs_lengths and
-  // _inc_predicted_elapsed_time_ms, are updated by the thread
+  // The two "main" fields, _inc_recorded_rs_length and
+  // _inc_predicted_non_copy_time_ms, are updated by the thread
   // that adds a new region to the CSet. Further updates by the
   // concurrent refinement thread that samples the young RSet lengths
-  // are accumulated in the *_diffs fields. Here we add the diffs to
+  // are accumulated in the *_diff fields. Here we add the diffs to
   // the "main" fields.
 
-  if (_inc_recorded_rs_lengths_diffs >= 0) {
-    _inc_recorded_rs_lengths += _inc_recorded_rs_lengths_diffs;
-  } else {
-    // This is defensive. The diff should in theory be always positive
-    // as RSets can only grow between GCs. However, given that we
-    // sample their size concurrently with other threads updating them
-    // it's possible that we might get the wrong size back, which
-    // could make the calculations somewhat inaccurate.
-    size_t diffs = (size_t) (-_inc_recorded_rs_lengths_diffs);
-    if (_inc_recorded_rs_lengths >= diffs) {
-      _inc_recorded_rs_lengths -= diffs;
-    } else {
-      _inc_recorded_rs_lengths = 0;
-    }
-  }
-  _inc_predicted_elapsed_time_ms += _inc_predicted_elapsed_time_ms_diffs;
+  _inc_recorded_rs_length += _inc_recorded_rs_length_diff;
+  _inc_predicted_non_copy_time_ms += _inc_predicted_non_copy_time_ms_diff;
 
-  _inc_recorded_rs_lengths_diffs = 0;
-  _inc_predicted_elapsed_time_ms_diffs = 0.0;
+  _inc_recorded_rs_length_diff = 0;
+  _inc_predicted_non_copy_time_ms_diff = 0.0;
 }
 
 void G1CollectionSet::clear() {
   assert_at_safepoint_on_vm_thread();
   _collection_set_cur_length = 0;
-  _optional_region_length = 0;
 }
 
 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
-  iterate_from(cl, 0, 1);
-}
-
-void G1CollectionSet::iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const {
   size_t len = _collection_set_cur_length;
   OrderAccess::loadload();
-  if (len == 0) {
-    return;
-  }
-  size_t start_pos = (worker_id * len) / total_workers;
-  size_t cur_pos = start_pos;
 
-  do {
-    HeapRegion* r = _g1h->region_at(_collection_set_regions[cur_pos]);
+  for (uint i = 0; i < len; i++) {
+    HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);
     bool result = cl->do_heap_region(r);
     if (result) {
       cl->set_incomplete();
       return;
     }
+  }
+}
+
+void G1CollectionSet::par_iterate(HeapRegionClosure* cl,
+                                  HeapRegionClaimer* hr_claimer,
+                                  uint worker_id,
+                                  uint total_workers) const {
+  iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);
+}
+
+void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {
+  assert_at_safepoint();
+
+  for (uint i = 0; i < _num_optional_regions; i++) {
+    HeapRegion* r = _candidates->at(i);
+    bool result = cl->do_heap_region(r);
+    guarantee(!result, "Must not cancel iteration");
+  }
+}
+
+void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,
+                                                    HeapRegionClaimer* hr_claimer,
+                                                    uint worker_id,
+                                                    uint total_workers) const {
+  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);
+}
+
+void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,
+                                        HeapRegionClaimer* hr_claimer,
+                                        size_t offset,
+                                        size_t length,
+                                        uint worker_id,
+                                        uint total_workers) const {
+  assert_at_safepoint();
+  if (length == 0) {
+    return;
+  }
+
+  size_t start_pos = (worker_id * length) / total_workers;
+  size_t cur_pos = start_pos;
+
+  do {
+    uint region_idx = _collection_set_regions[cur_pos + offset];
+    if (hr_claimer == NULL || hr_claimer->claim_region(region_idx)) {
+      HeapRegion* r = _g1h->region_at(region_idx);
+      bool result = cl->do_heap_region(r);
+      guarantee(!result, "Must not cancel iteration");
+    }
+
     cur_pos++;
-    if (cur_pos == len) {
+    if (cur_pos == length) {
       cur_pos = 0;
     }
   } while (cur_pos != start_pos);
 }
 
@@ -245,47 +258,33 @@
                                                      size_t new_rs_length) {
   // Update the CSet information that is dependent on the new RS length
   assert(hr->is_young(), "Precondition");
   assert(!SafepointSynchronize::is_at_safepoint(), "should not be at a safepoint");
 
-  // We could have updated _inc_recorded_rs_lengths and
-  // _inc_predicted_elapsed_time_ms directly but we'd need to do
-  // that atomically, as this code is executed by a concurrent
-  // refinement thread, potentially concurrently with a mutator thread
-  // allocating a new region and also updating the same fields. To
-  // avoid the atomic operations we accumulate these updates on two
-  // separate fields (*_diffs) and we'll just add them to the "main"
-  // fields at the start of a GC.
+  IncCollectionSetRegionStat* stat = &_inc_collection_set_stats[hr->hrm_index()];
 
-  ssize_t old_rs_length = (ssize_t) hr->recorded_rs_length();
-  ssize_t rs_lengths_diff = (ssize_t) new_rs_length - old_rs_length;
-  _inc_recorded_rs_lengths_diffs += rs_lengths_diff;
+  size_t old_rs_length = stat->_rs_length;
+  assert(old_rs_length <= new_rs_length,
+         "Remembered set decreased (changed from " SIZE_FORMAT " to " SIZE_FORMAT " region %u type %s)",
+         old_rs_length, new_rs_length, hr->hrm_index(), hr->get_short_type_str());
+  size_t rs_length_diff = new_rs_length - old_rs_length;
+  stat->_rs_length = new_rs_length;
+  _inc_recorded_rs_length_diff += rs_length_diff;
 
-  double old_elapsed_time_ms = hr->predicted_elapsed_time_ms();
-  double new_region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);
-  double elapsed_ms_diff = new_region_elapsed_time_ms - old_elapsed_time_ms;
-  _inc_predicted_elapsed_time_ms_diffs += elapsed_ms_diff;
+  double old_non_copy_time = stat->_non_copy_time_ms;
+  assert(old_non_copy_time >= 0.0, "Non copy time for region %u not initialized yet, is %.3f", hr->hrm_index(), old_non_copy_time);
+  double new_non_copy_time = predict_region_non_copy_time_ms(hr);
+  double non_copy_time_ms_diff = new_non_copy_time - old_non_copy_time;
 
-  hr->set_recorded_rs_length(new_rs_length);
-  hr->set_predicted_elapsed_time_ms(new_region_elapsed_time_ms);
+  stat->_non_copy_time_ms = new_non_copy_time;
+  _inc_predicted_non_copy_time_ms_diff += non_copy_time_ms_diff;
 }
 
 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
   assert(hr->is_young(), "invariant");
   assert(_inc_build_state == Active, "Precondition");
 
-  size_t collection_set_length = _collection_set_cur_length;
-  assert(collection_set_length <= INT_MAX, "Collection set is too large with %d entries", (int)collection_set_length);
-  hr->set_young_index_in_cset((int)collection_set_length);
-
-  _collection_set_regions[collection_set_length] = hr->hrm_index();
-  // Concurrent readers must observe the store of the value in the array before an
-  // update to the length field.
-  OrderAccess::storestore();
-  _collection_set_cur_length++;
-  assert(_collection_set_cur_length <= _collection_set_max_length, "Collection set larger than maximum allowed.");
-
   // This routine is used when:
   // * adding survivor regions to the incremental cset at the end of an
   //   evacuation pause or
   // * adding the current allocation region to the incremental cset
   //   when it is retired.
@@ -300,26 +299,40 @@
   // by the Young List sampling code.
   // Ignore calls to this due to retirement during full gc.
 
   if (!_g1h->collector_state()->in_full_gc()) {
     size_t rs_length = hr->rem_set()->occupied();
-    double region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);
+    double non_copy_time = predict_region_non_copy_time_ms(hr);
 
     // Cache the values we have added to the aggregated information
     // in the heap region in case we have to remove this region from
     // the incremental collection set, or it is updated by the
     // rset sampling code
-    hr->set_recorded_rs_length(rs_length);
-    hr->set_predicted_elapsed_time_ms(region_elapsed_time_ms);
 
-    _inc_recorded_rs_lengths += rs_length;
-    _inc_predicted_elapsed_time_ms += region_elapsed_time_ms;
+    IncCollectionSetRegionStat* stat = &_inc_collection_set_stats[hr->hrm_index()];
+    stat->_rs_length = rs_length;
+    stat->_non_copy_time_ms = non_copy_time;
+
+    _inc_recorded_rs_length += rs_length;
+    _inc_predicted_non_copy_time_ms += non_copy_time;
     _inc_bytes_used_before += hr->used();
   }
 
   assert(!hr->in_collection_set(), "invariant");
-  _g1h->register_young_region_with_cset(hr);
+  _g1h->register_young_region_with_region_attr(hr);
+
+  // We use UINT_MAX as "invalid" marker in verification.
+  assert(_collection_set_cur_length < (UINT_MAX - 1),
+         "Collection set is too large with " SIZE_FORMAT " entries", _collection_set_cur_length);
+  hr->set_young_index_in_cset((uint)_collection_set_cur_length + 1);
+
+  _collection_set_regions[_collection_set_cur_length] = hr->hrm_index();
+  // Concurrent readers must observe the store of the value in the array before an
+  // update to the length field.
+  OrderAccess::storestore();
+  _collection_set_cur_length++;
+  assert(_collection_set_cur_length <= _collection_set_max_length, "Collection set larger than maximum allowed.");
 }
 
 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
   assert(hr->is_survivor(), "Must only add survivor regions, but is %s", hr->get_type_str());
   add_young_region_common(hr);
@@ -332,25 +345,23 @@
 
 #ifndef PRODUCT
 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
 public:
   bool _valid;
-public:
+
   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
 
   virtual bool do_heap_region(HeapRegion* r) {
     guarantee(r->is_young(), "Region must be young but is %s", r->get_type_str());
 
-    SurvRateGroup* group = r->surv_rate_group();
-
-    if (group == NULL) {
-      log_error(gc, verify)("## encountered NULL surv_rate_group in young region");
+    if (!r->has_surv_rate_group()) {
+      log_error(gc, verify)("## encountered young region without surv_rate_group");
       _valid = false;
     }
 
-    if (r->age_in_surv_rate_group() < 0) {
-      log_error(gc, verify)("## encountered negative age in young region");
+    if (!r->has_valid_age_in_surv_rate()) {
+      log_error(gc, verify)("## encountered invalid age in young region");
       _valid = false;
     }
 
     return false;
   }
@@ -381,11 +392,11 @@
     assert(r->in_collection_set(), "Region %u should be in collection set", r->hrm_index());
     _st->print_cr("  " HR_FORMAT ", P: " PTR_FORMAT "N: " PTR_FORMAT ", age: %4d",
                   HR_FORMAT_PARAMS(r),
                   p2i(r->prev_top_at_mark_start()),
                   p2i(r->next_top_at_mark_start()),
-                  r->age_in_surv_rate_group_cond());
+                  r->has_surv_rate_group() ? r->age_in_surv_rate_group() : -1);
     return false;
   }
 };
 
 void G1CollectionSet::print(outputStream* st) {
@@ -395,75 +406,53 @@
   iterate(&cl);
 }
 #endif // !PRODUCT
 
 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
-  double young_start_time_sec = os::elapsedTime();
+  Ticks start_time = Ticks::now();
 
   finalize_incremental_building();
 
   guarantee(target_pause_time_ms > 0.0,
             "target_pause_time_ms = %1.6lf should be positive", target_pause_time_ms);
 
-  size_t pending_cards = _policy->pending_cards();
-  double base_time_ms = _policy->predict_base_elapsed_time_ms(pending_cards);
-  double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);
+  size_t pending_cards = _policy->pending_cards_at_gc_start() + _g1h->hot_card_cache()->num_entries();
 
-  log_trace(gc, ergo, cset)("Start choosing CSet. pending cards: " SIZE_FORMAT " predicted base time: %1.2fms remaining time: %1.2fms target pause time: %1.2fms",
-                            pending_cards, base_time_ms, time_remaining_ms, target_pause_time_ms);
+  log_trace(gc, ergo, cset)("Start choosing CSet. Pending cards: " SIZE_FORMAT " target pause time: %1.2fms",
+                            pending_cards, target_pause_time_ms);
 
   // The young list is laid with the survivor regions from the previous
   // pause are appended to the RHS of the young list, i.e.
   //   [Newly Young Regions ++ Survivors from last pause].
 
-  uint survivor_region_length = survivors->length();
   uint eden_region_length = _g1h->eden_regions_count();
+  uint survivor_region_length = survivors->length();
   init_region_lengths(eden_region_length, survivor_region_length);
 
   verify_young_cset_indices();
 
   // Clear the fields that point to the survivor list - they are all young now.
   survivors->convert_to_eden();
 
   _bytes_used_before = _inc_bytes_used_before;
-  time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);
-
-  log_trace(gc, ergo, cset)("Add young regions to CSet. eden: %u regions, survivors: %u regions, predicted young region time: %1.2fms, target pause time: %1.2fms",
-                            eden_region_length, survivor_region_length, _inc_predicted_elapsed_time_ms, target_pause_time_ms);
 
   // The number of recorded young regions is the incremental
   // collection set's current size
-  set_recorded_rs_lengths(_inc_recorded_rs_lengths);
-
-  double young_end_time_sec = os::elapsedTime();
-  phase_times()->record_young_cset_choice_time_ms((young_end_time_sec - young_start_time_sec) * 1000.0);
-
-  return time_remaining_ms;
-}
+  set_recorded_rs_length(_inc_recorded_rs_length);
 
-void G1CollectionSet::add_as_old(HeapRegion* hr) {
-  candidates()->pop_front(); // already have region via peek()
-  _g1h->old_set_remove(hr);
-  add_old_region(hr);
-}
+  double predicted_base_time_ms = _policy->predict_base_elapsed_time_ms(pending_cards);
+  double predicted_eden_time = _inc_predicted_non_copy_time_ms + _policy->predict_eden_copy_time_ms(eden_region_length);
+  double remaining_time_ms = MAX2(target_pause_time_ms - (predicted_base_time_ms + predicted_eden_time), 0.0);
 
-void G1CollectionSet::add_as_optional(HeapRegion* hr) {
-  assert(_optional_regions != NULL, "Must not be called before array is allocated");
-  candidates()->pop_front(); // already have region via peek()
-  _g1h->old_set_remove(hr);
-  add_optional_region(hr);
-}
+  log_trace(gc, ergo, cset)("Added young regions to CSet. Eden: %u regions, Survivors: %u regions, "
+                            "predicted eden time: %1.2fms, predicted base time: %1.2fms, target pause time: %1.2fms, remaining time: %1.2fms",
+                            eden_region_length, survivor_region_length,
+                            predicted_eden_time, predicted_base_time_ms, target_pause_time_ms, remaining_time_ms);
 
-bool G1CollectionSet::optional_is_full() {
-  assert(_optional_region_length <= _optional_region_max_length, "Invariant");
-  return _optional_region_length == _optional_region_max_length;
-}
+  phase_times()->record_young_cset_choice_time_ms((Ticks::now() - start_time).seconds() * 1000.0);
 
-void G1CollectionSet::clear_optional_region(const HeapRegion* hr) {
-  assert(_optional_regions != NULL, "Must not be called before array is allocated");
-  uint index = hr->index_in_opt_cset();
-  _optional_regions[index] = NULL;
+  return remaining_time_ms;
 }
 
 static int compare_region_idx(const uint a, const uint b) {
   if (a > b) {
     return 1;
@@ -474,216 +463,122 @@
   }
 }
 
 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
   double non_young_start_time_sec = os::elapsedTime();
-  double predicted_old_time_ms = 0.0;
-  double predicted_optional_time_ms = 0.0;
-  double optional_threshold_ms = time_remaining_ms * _policy->optional_prediction_fraction();
-  uint expensive_region_num = 0;
 
   if (collector_state()->in_mixed_phase()) {
     candidates()->verify();
-    const uint min_old_cset_length = _policy->calc_min_old_cset_length();
-    const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());
-    bool check_time_remaining = _policy->adaptive_young_list_length();
-
-    initialize_optional(max_old_cset_length - min_old_cset_length);
-    log_debug(gc, ergo, cset)("Start adding old regions for mixed gc. min %u regions, max %u regions, "
-                              "time remaining %1.2fms, optional threshold %1.2fms",
-                              min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);
-
-    HeapRegion* hr = candidates()->peek_front();
-    while (hr != NULL) {
-      if (old_region_length() + optional_region_length() >= max_old_cset_length) {
-        // Added maximum number of old regions to the CSet.
-        log_debug(gc, ergo, cset)("Finish adding old regions to CSet (old CSet region num reached max). "
-                                  "old %u regions, optional %u regions",
-                                  old_region_length(), optional_region_length());
-        break;
-      }
-
-      // Stop adding regions if the remaining reclaimable space is
-      // not above G1HeapWastePercent.
-      size_t reclaimable_bytes = candidates()->remaining_reclaimable_bytes();
-      double reclaimable_percent = _policy->reclaimable_bytes_percent(reclaimable_bytes);
-      double threshold = (double) G1HeapWastePercent;
-      if (reclaimable_percent <= threshold) {
-        // We've added enough old regions that the amount of uncollected
-        // reclaimable space is at or below the waste threshold. Stop
-        // adding old regions to the CSet.
-        log_debug(gc, ergo, cset)("Finish adding old regions to CSet (reclaimable percentage not over threshold). "
-                                  "reclaimable: " SIZE_FORMAT "%s (%1.2f%%) threshold: " UINTX_FORMAT "%%",
-                                  byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),
-                                  reclaimable_percent, G1HeapWastePercent);
-        break;
-      }
-
-      double predicted_time_ms = predict_region_elapsed_time_ms(hr);
-      time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
-      // Add regions to old set until we reach minimum amount
-      if (old_region_length() < min_old_cset_length) {
-        predicted_old_time_ms += predicted_time_ms;
-        add_as_old(hr);
-        // Record the number of regions added when no time remaining
-        if (time_remaining_ms == 0.0) {
-          expensive_region_num++;
-        }
-      } else {
-        // In the non-auto-tuning case, we'll finish adding regions
-        // to the CSet if we reach the minimum.
-        if (!check_time_remaining) {
-          log_debug(gc, ergo, cset)("Finish adding old regions to CSet (old CSet region num reached min).");
-          break;
-        }
-        // Keep adding regions to old set until we reach optional threshold
-        if (time_remaining_ms > optional_threshold_ms) {
-          predicted_old_time_ms += predicted_time_ms;
-          add_as_old(hr);
-        } else if (time_remaining_ms > 0) {
-          // Keep adding optional regions until time is up
-          if (!optional_is_full()) {
-            predicted_optional_time_ms += predicted_time_ms;
-            add_as_optional(hr);
-          } else {
-            log_debug(gc, ergo, cset)("Finish adding old regions to CSet (optional set full).");
-            break;
-          }
-        } else {
-          log_debug(gc, ergo, cset)("Finish adding old regions to CSet (predicted time is too high).");
-          break;
-        }
-      }
-      hr = candidates()->peek_front();
-    }
-    if (hr == NULL) {
-      log_debug(gc, ergo, cset)("Finish adding old regions to CSet (candidate old regions not available)");
+
+    uint num_initial_old_regions;
+    uint num_optional_old_regions;
+
+    _policy->calculate_old_collection_set_regions(candidates(),
+                                                  time_remaining_ms,
+                                                  num_initial_old_regions,
+                                                  num_optional_old_regions);
+
+    // Prepare initial old regions.
+    move_candidates_to_collection_set(num_initial_old_regions);
+
+    // Prepare optional old regions for evacuation.
+    uint candidate_idx = candidates()->cur_idx();
+    for (uint i = 0; i < num_optional_old_regions; i++) {
+      add_optional_region(candidates()->at(candidate_idx + i));
     }
 
     candidates()->verify();
   }
 
   stop_incremental_building();
 
-  log_debug(gc, ergo, cset)("Finish choosing CSet regions old: %u, optional: %u, "
-                            "predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f",
-                            old_region_length(), optional_region_length(),
-                            predicted_old_time_ms, predicted_optional_time_ms, time_remaining_ms);
-  if (expensive_region_num > 0) {
-    log_debug(gc, ergo, cset)("CSet contains %u old regions that were added although the predicted time was too high.",
-                              expensive_region_num);
-  }
-
   double non_young_end_time_sec = os::elapsedTime();
   phase_times()->record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
 
   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
 }
 
-HeapRegion* G1OptionalCSet::region_at(uint index) {
-  return _cset->optional_region_at(index);
+void G1CollectionSet::move_candidates_to_collection_set(uint num_old_candidate_regions) {
+  if (num_old_candidate_regions == 0) {
+    return;
+  }
+  uint candidate_idx = candidates()->cur_idx();
+  for (uint i = 0; i < num_old_candidate_regions; i++) {
+    HeapRegion* r = candidates()->at(candidate_idx + i);
+    // This potentially optional candidate region is going to be an actual collection
+    // set region. Clear cset marker.
+    _g1h->clear_region_attr(r);
+    add_old_region(r);
+  }
+  candidates()->remove(num_old_candidate_regions);
+
+  candidates()->verify();
 }
 
-void G1OptionalCSet::prepare_evacuation(double time_limit) {
-  assert(_current_index == _current_limit, "Before prepare no regions should be ready for evac");
+void G1CollectionSet::finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {
+  double time_remaining_ms = finalize_young_part(target_pause_time_ms, survivor);
+  finalize_old_part(time_remaining_ms);
+}
 
-  uint prepared_regions = 0;
-  double prediction_ms = 0;
+bool G1CollectionSet::finalize_optional_for_evacuation(double remaining_pause_time) {
+  update_incremental_marker();
 
-  _prepare_failed = true;
-  for (uint i = _current_index; i < _cset->optional_region_length(); i++) {
-    HeapRegion* hr = region_at(i);
-    prediction_ms += _cset->predict_region_elapsed_time_ms(hr);
-    if (prediction_ms > time_limit) {
-      log_debug(gc, cset)("Prepared %u regions for optional evacuation. Predicted time: %.3fms", prepared_regions, prediction_ms);
-      return;
-    }
+  uint num_selected_regions;
+  _policy->calculate_optional_collection_set_regions(candidates(),
+                                                     _num_optional_regions,
+                                                     remaining_pause_time,
+                                                     num_selected_regions);
 
-    // This region will be included in the next optional evacuation.
-    prepare_to_evacuate_optional_region(hr);
-    prepared_regions++;
-    _current_limit++;
-    _prepare_failed = false;
-  }
+  move_candidates_to_collection_set(num_selected_regions);
 
-  log_debug(gc, cset)("Prepared all %u regions for optional evacuation. Predicted time: %.3fms",
-                      prepared_regions, prediction_ms);
-}
+  _num_optional_regions -= num_selected_regions;
 
-bool G1OptionalCSet::prepare_failed() {
-  return _prepare_failed;
-}
+  stop_incremental_building();
 
-void G1OptionalCSet::complete_evacuation() {
-  _evacuation_failed = false;
-  for (uint i = _current_index; i < _current_limit; i++) {
-    HeapRegion* hr = region_at(i);
-    _cset->clear_optional_region(hr);
-    if (hr->evacuation_failed()){
-      _evacuation_failed = true;
-    }
-  }
-  _current_index = _current_limit;
-}
+  _g1h->verify_region_attr_remset_update();
 
-bool G1OptionalCSet::evacuation_failed() {
-  return _evacuation_failed;
+  return num_selected_regions > 0;
 }
 
-G1OptionalCSet::~G1OptionalCSet() {
-  G1CollectedHeap* g1h = G1CollectedHeap::heap();
-  while (!is_empty()) {
-    // We want to return regions not evacuated to the collection set candidates
-    // in reverse order to maintain the old order.
-    HeapRegion* hr = _cset->remove_last_optional_region();
-    assert(hr != NULL, "Should be valid region left");
-    _pset->record_unused_optional_region(hr);
-    g1h->old_set_add(hr);
-    g1h->clear_in_cset(hr);
-    hr->set_index_in_opt_cset(InvalidCSetIndex);
-    _cset->candidates()->push_front(hr);
+void G1CollectionSet::abandon_optional_collection_set(G1ParScanThreadStateSet* pss) {
+  for (uint i = 0; i < _num_optional_regions; i++) {
+    HeapRegion* r = candidates()->at(candidates()->cur_idx() + i);
+    pss->record_unused_optional_region(r);
+    // Clear collection set marker and make sure that the remembered set information
+    // is correct as we still need it later.
+    _g1h->clear_region_attr(r);
+    _g1h->register_region_with_region_attr(r);
+    r->clear_index_in_opt_cset();
   }
-  _cset->free_optional_regions();
-}
-
-uint G1OptionalCSet::size() {
-  return _cset->optional_region_length() - _current_index;
-}
-
-bool G1OptionalCSet::is_empty() {
-  return size() == 0;
-}
+  free_optional_regions();
 
-void G1OptionalCSet::prepare_to_evacuate_optional_region(HeapRegion* hr) {
-  log_trace(gc, cset)("Adding region %u for optional evacuation", hr->hrm_index());
-  G1CollectedHeap::heap()->clear_in_cset(hr);
-  _cset->add_old_region(hr);
+  _g1h->verify_region_attr_remset_update();
 }
 
 #ifdef ASSERT
 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
 private:
   size_t _young_length;
-  int* _heap_region_indices;
+  uint* _heap_region_indices;
 public:
   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
-    _heap_region_indices = NEW_C_HEAP_ARRAY(int, young_length, mtGC);
-    for (size_t i = 0; i < young_length; i++) {
-      _heap_region_indices[i] = -1;
+    _heap_region_indices = NEW_C_HEAP_ARRAY(uint, young_length + 1, mtGC);
+    for (size_t i = 0; i < young_length + 1; i++) {
+      _heap_region_indices[i] = UINT_MAX;
     }
   }
   ~G1VerifyYoungCSetIndicesClosure() {
     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
   }
 
   virtual bool do_heap_region(HeapRegion* r) {
-    const int idx = r->young_index_in_cset();
+    const uint idx = r->young_index_in_cset();
 
-    assert(idx > -1, "Young index must be set for all regions in the incremental collection set but is not for region %u.", r->hrm_index());
-    assert((size_t)idx < _young_length, "Young cset index too large for region %u", r->hrm_index());
+    assert(idx > 0, "Young index must be set for all regions in the incremental collection set but is not for region %u.", r->hrm_index());
+    assert(idx <= _young_length, "Young cset index %u too large for region %u", idx, r->hrm_index());
 
-    assert(_heap_region_indices[idx] == -1,
+    assert(_heap_region_indices[idx] == UINT_MAX,
            "Index %d used by multiple regions, first use by region %u, second by region %u",
            idx, _heap_region_indices[idx], r->hrm_index());
 
     _heap_region_indices[idx] = r->hrm_index();
 

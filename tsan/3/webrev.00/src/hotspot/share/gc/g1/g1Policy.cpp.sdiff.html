<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ParScanThreadState.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;

  27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  28 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  30 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  33 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  34 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  35 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  36 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  37 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  38 #include &quot;gc/g1/g1Policy.hpp&quot;
  39 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  40 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  41 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  42 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  43 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/java.hpp&quot;
  47 #include &quot;runtime/mutexLocker.hpp&quot;
  48 #include &quot;utilities/debug.hpp&quot;
  49 #include &quot;utilities/growableArray.hpp&quot;
  50 #include &quot;utilities/pair.hpp&quot;
  51 
<span class="line-modified">  52 G1Policy::G1Policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer) :</span>
  53   _predictor(G1ConfidencePercent / 100.0),
  54   _analytics(new G1Analytics(&amp;_predictor)),
  55   _remset_tracker(),
  56   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  57   _ihop_control(create_ihop_control(&amp;_predictor)),
  58   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  59   _full_collection_start_sec(0.0),
  60   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
  61   _young_list_target_length(0),
  62   _young_list_fixed_length(0),
  63   _young_list_max_length(0),
<span class="line-modified">  64   _short_lived_surv_rate_group(new SurvRateGroup()),</span>
<span class="line-modified">  65   _survivor_surv_rate_group(new SurvRateGroup()),</span>
  66   _reserve_factor((double) G1ReservePercent / 100.0),
  67   _reserve_regions(0),
<span class="line-modified">  68   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer(policy)),</span>
  69   _free_regions_at_end_of_collection(0),
<span class="line-modified">  70   _max_rs_lengths(0),</span>
<span class="line-modified">  71   _rs_lengths_prediction(0),</span>
<span class="line-modified">  72   _pending_cards(0),</span>




  73   _bytes_allocated_in_old_since_last_gc(0),
  74   _initial_mark_to_mixed(),
  75   _collection_set(NULL),
<span class="line-removed">  76   _bytes_copied_during_gc(0),</span>
  77   _g1h(NULL),
  78   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  79   _mark_remark_start_sec(0),
  80   _mark_cleanup_start_sec(0),
  81   _tenuring_threshold(MaxTenuringThreshold),
  82   _max_survivor_regions(0),
  83   _survivors_age_table(true)
  84 {
  85 }
  86 
  87 G1Policy::~G1Policy() {
  88   delete _ihop_control;
  89   delete _young_gen_sizer;
  90 }
  91 
<span class="line-modified">  92 G1Policy* G1Policy::create_policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer_stw) {</span>
<span class="line-modified">  93   if (policy-&gt;is_heterogeneous_heap()) {</span>
<span class="line-modified">  94     return new G1HeterogeneousHeapPolicy(policy, gc_timer_stw);</span>
  95   } else {
<span class="line-modified">  96     return new G1Policy(policy, gc_timer_stw);</span>
  97   }
  98 }
  99 
 100 G1CollectorState* G1Policy::collector_state() const { return _g1h-&gt;collector_state(); }
 101 
 102 void G1Policy::init(G1CollectedHeap* g1h, G1CollectionSet* collection_set) {
 103   _g1h = g1h;
 104   _collection_set = collection_set;
 105 
 106   assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
 107 
<span class="line-modified"> 108   if (!adaptive_young_list_length()) {</span>
 109     _young_list_fixed_length = _young_gen_sizer-&gt;min_desired_young_length();
 110   }
 111   _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
 112 
 113   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 114 
 115   update_young_list_max_and_target_length();
 116   // We may immediately start allocating regions and placing them on the
 117   // collection set list. Initialize the per-collection set info
 118   _collection_set-&gt;start_incremental_building();
 119 }
 120 
 121 void G1Policy::note_gc_start() {
 122   phase_times()-&gt;note_gc_start();
 123 }
 124 
 125 class G1YoungLengthPredictor {
<span class="line-removed"> 126   const bool _during_cm;</span>
 127   const double _base_time_ms;
 128   const double _base_free_regions;
 129   const double _target_pause_time_ms;
 130   const G1Policy* const _policy;
 131 
 132  public:
<span class="line-modified"> 133   G1YoungLengthPredictor(bool during_cm,</span>
<span class="line-removed"> 134                          double base_time_ms,</span>
 135                          double base_free_regions,
 136                          double target_pause_time_ms,
 137                          const G1Policy* policy) :
<span class="line-removed"> 138     _during_cm(during_cm),</span>
 139     _base_time_ms(base_time_ms),
 140     _base_free_regions(base_free_regions),
 141     _target_pause_time_ms(target_pause_time_ms),
 142     _policy(policy) {}
 143 
 144   bool will_fit(uint young_length) const {
 145     if (young_length &gt;= _base_free_regions) {
 146       // end condition 1: not enough space for the young regions
 147       return false;
 148     }
 149 
<span class="line-modified"> 150     const double accum_surv_rate = _policy-&gt;accum_yg_surv_rate_pred((int) young_length - 1);</span>
<span class="line-modified"> 151     const size_t bytes_to_copy =</span>
<span class="line-removed"> 152                  (size_t) (accum_surv_rate * (double) HeapRegion::GrainBytes);</span>
<span class="line-removed"> 153     const double copy_time_ms =</span>
<span class="line-removed"> 154       _policy-&gt;analytics()-&gt;predict_object_copy_time_ms(bytes_to_copy, _during_cm);</span>
 155     const double young_other_time_ms = _policy-&gt;analytics()-&gt;predict_young_other_time_ms(young_length);
 156     const double pause_time_ms = _base_time_ms + copy_time_ms + young_other_time_ms;
 157     if (pause_time_ms &gt; _target_pause_time_ms) {
 158       // end condition 2: prediction is over the target pause time
 159       return false;
 160     }
 161 
 162     const size_t free_bytes = (_base_free_regions - young_length) * HeapRegion::GrainBytes;
 163 
 164     // When copying, we will likely need more bytes free than is live in the region.
 165     // Add some safety margin to factor in the confidence of our guess, and the
 166     // natural expected waste.
 167     // (100.0 / G1ConfidencePercent) is a scale factor that expresses the uncertainty
 168     // of the calculation: the lower the confidence, the more headroom.
 169     // (100 + TargetPLABWastePct) represents the increase in expected bytes during
 170     // copying due to anticipated waste in the PLABs.
 171     const double safety_factor = (100.0 / G1ConfidencePercent) * (100 + TargetPLABWastePct) / 100.0;
 172     const size_t expected_bytes_to_copy = (size_t)(safety_factor * bytes_to_copy);
 173 
 174     if (expected_bytes_to_copy &gt; free_bytes) {
</pre>
<hr />
<pre>
 178 
 179     // success!
 180     return true;
 181   }
 182 };
 183 
 184 void G1Policy::record_new_heap_size(uint new_number_of_regions) {
 185   // re-calculate the necessary reserve
 186   double reserve_regions_d = (double) new_number_of_regions * _reserve_factor;
 187   // We use ceiling so that if reserve_regions_d is &gt; 0.0 (but
 188   // smaller than 1.0) we&#39;ll get 1.
 189   _reserve_regions = (uint) ceil(reserve_regions_d);
 190 
 191   _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
 192 
 193   _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
 194 }
 195 
 196 uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {
 197   uint desired_min_length = 0;
<span class="line-modified"> 198   if (adaptive_young_list_length()) {</span>
 199     if (_analytics-&gt;num_alloc_rate_ms() &gt; 3) {
 200       double now_sec = os::elapsedTime();
 201       double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;
 202       double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();
 203       desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
 204     } else {
 205       // otherwise we don&#39;t have enough info to make the prediction
 206     }
 207   }
 208   desired_min_length += base_min_length;
 209   // make sure we don&#39;t go below any user-defined minimum bound
 210   return MAX2(_young_gen_sizer-&gt;min_desired_young_length(), desired_min_length);
 211 }
 212 
 213 uint G1Policy::calculate_young_list_desired_max_length() const {
 214   // Here, we might want to also take into account any additional
 215   // constraints (i.e., user-defined minimum bound). Currently, we
 216   // effectively don&#39;t set this bound.
 217   return _young_gen_sizer-&gt;max_desired_young_length();
 218 }
 219 
 220 uint G1Policy::update_young_list_max_and_target_length() {
<span class="line-modified"> 221   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_lengths());</span>
 222 }
 223 
<span class="line-modified"> 224 uint G1Policy::update_young_list_max_and_target_length(size_t rs_lengths) {</span>
<span class="line-modified"> 225   uint unbounded_target_length = update_young_list_target_length(rs_lengths);</span>
 226   update_max_gc_locker_expansion();
 227   return unbounded_target_length;
 228 }
 229 
<span class="line-modified"> 230 uint G1Policy::update_young_list_target_length(size_t rs_lengths) {</span>
<span class="line-modified"> 231   YoungTargetLengths young_lengths = young_list_target_lengths(rs_lengths);</span>
 232   _young_list_target_length = young_lengths.first;
 233 
 234   return young_lengths.second;
 235 }
 236 
<span class="line-modified"> 237 G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_lengths) const {</span>
 238   YoungTargetLengths result;
 239 
 240   // Calculate the absolute and desired min bounds first.
 241 
 242   // This is how many young regions we already have (currently: the survivors).
 243   const uint base_min_length = _g1h-&gt;survivor_regions_count();
 244   uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);
 245   // This is the absolute minimum young length. Ensure that we
 246   // will at least have one eden region available for allocation.
 247   uint absolute_min_length = base_min_length + MAX2(_g1h-&gt;eden_regions_count(), (uint)1);
 248   // If we shrank the young list target it should not shrink below the current size.
 249   desired_min_length = MAX2(desired_min_length, absolute_min_length);
 250   // Calculate the absolute and desired max bounds.
 251 
 252   uint desired_max_length = calculate_young_list_desired_max_length();
 253 
 254   uint young_list_target_length = 0;
<span class="line-modified"> 255   if (adaptive_young_list_length()) {</span>
 256     if (collector_state()-&gt;in_young_only_phase()) {
 257       young_list_target_length =
<span class="line-modified"> 258                         calculate_young_list_target_length(rs_lengths,</span>
 259                                                            base_min_length,
 260                                                            desired_min_length,
 261                                                            desired_max_length);
 262     } else {
 263       // Don&#39;t calculate anything and let the code below bound it to
 264       // the desired_min_length, i.e., do the next GC as soon as
 265       // possible to maximize how many old regions we can add to it.
 266     }
 267   } else {
 268     // The user asked for a fixed young gen so we&#39;ll fix the young gen
 269     // whether the next GC is young or mixed.
 270     young_list_target_length = _young_list_fixed_length;
 271   }
 272 
 273   result.second = young_list_target_length;
 274 
 275   // We will try our best not to &quot;eat&quot; into the reserve.
 276   uint absolute_max_length = 0;
 277   if (_free_regions_at_end_of_collection &gt; _reserve_regions) {
 278     absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;
</pre>
<hr />
<pre>
 282   }
 283 
 284   // Make sure we don&#39;t go over the desired max length, nor under the
 285   // desired min length. In case they clash, desired_min_length wins
 286   // which is why that test is second.
 287   if (young_list_target_length &gt; desired_max_length) {
 288     young_list_target_length = desired_max_length;
 289   }
 290   if (young_list_target_length &lt; desired_min_length) {
 291     young_list_target_length = desired_min_length;
 292   }
 293 
 294   assert(young_list_target_length &gt; base_min_length,
 295          &quot;we should be able to allocate at least one eden region&quot;);
 296   assert(young_list_target_length &gt;= absolute_min_length, &quot;post-condition&quot;);
 297 
 298   result.first = young_list_target_length;
 299   return result;
 300 }
 301 
<span class="line-modified"> 302 uint</span>
<span class="line-modified"> 303 G1Policy::calculate_young_list_target_length(size_t rs_lengths,</span>
<span class="line-modified"> 304                                                     uint base_min_length,</span>
<span class="line-modified"> 305                                                     uint desired_min_length,</span>
<span class="line-modified"> 306                                                     uint desired_max_length) const {</span>
<span class="line-removed"> 307   assert(adaptive_young_list_length(), &quot;pre-condition&quot;);</span>
 308   assert(collector_state()-&gt;in_young_only_phase(), &quot;only call this for young GCs&quot;);
 309 
 310   // In case some edge-condition makes the desired max length too small...
 311   if (desired_max_length &lt;= desired_min_length) {
 312     return desired_min_length;
 313   }
 314 
 315   // We&#39;ll adjust min_young_length and max_young_length not to include
 316   // the already allocated young regions (i.e., so they reflect the
 317   // min and max eden regions we&#39;ll allocate). The base_min_length
 318   // will be reflected in the predictions by the
 319   // survivor_regions_evac_time prediction.
 320   assert(desired_min_length &gt; base_min_length, &quot;invariant&quot;);
 321   uint min_young_length = desired_min_length - base_min_length;
 322   assert(desired_max_length &gt; base_min_length, &quot;invariant&quot;);
 323   uint max_young_length = desired_max_length - base_min_length;
 324 
 325   const double target_pause_time_ms = _mmu_tracker-&gt;max_gc_time() * 1000.0;
<span class="line-removed"> 326   const double survivor_regions_evac_time = predict_survivor_regions_evac_time();</span>
 327   const size_t pending_cards = _analytics-&gt;predict_pending_cards();
<span class="line-modified"> 328   const size_t adj_rs_lengths = rs_lengths + _analytics-&gt;predict_rs_length_diff();</span>
<span class="line-removed"> 329   const size_t scanned_cards = _analytics-&gt;predict_card_num(adj_rs_lengths, true /* for_young_gc */);</span>
<span class="line-removed"> 330   const double base_time_ms =</span>
<span class="line-removed"> 331     predict_base_elapsed_time_ms(pending_cards, scanned_cards) +</span>
<span class="line-removed"> 332     survivor_regions_evac_time;</span>
 333   const uint available_free_regions = _free_regions_at_end_of_collection;
 334   const uint base_free_regions =
 335     available_free_regions &gt; _reserve_regions ? available_free_regions - _reserve_regions : 0;
 336 
 337   // Here, we will make sure that the shortest young length that
 338   // makes sense fits within the target pause time.
 339 
<span class="line-modified"> 340   G1YoungLengthPredictor p(collector_state()-&gt;mark_or_rebuild_in_progress(),</span>
<span class="line-removed"> 341                            base_time_ms,</span>
 342                            base_free_regions,
 343                            target_pause_time_ms,
 344                            this);
 345   if (p.will_fit(min_young_length)) {
 346     // The shortest young length will fit into the target pause time;
 347     // we&#39;ll now check whether the absolute maximum number of young
 348     // regions will fit in the target pause time. If not, we&#39;ll do
 349     // a binary search between min_young_length and max_young_length.
 350     if (p.will_fit(max_young_length)) {
 351       // The maximum young length will fit into the target pause time.
 352       // We are done so set min young length to the maximum length (as
 353       // the result is assumed to be returned in min_young_length).
 354       min_young_length = max_young_length;
 355     } else {
 356       // The maximum possible number of young regions will not fit within
 357       // the target pause time so we&#39;ll search for the optimal
 358       // length. The loop invariants are:
 359       //
 360       // min_young_length &lt; max_young_length
 361       // min_young_length is known to fit into the target pause time
</pre>
<hr />
<pre>
 387       assert(min_young_length &lt; max_young_length,
 388              &quot;otherwise we should have discovered that max_young_length &quot;
 389              &quot;fits into the pause target and not done the binary search&quot;);
 390       assert(p.will_fit(min_young_length),
 391              &quot;min_young_length, the result of the binary search, should &quot;
 392              &quot;fit into the pause target&quot;);
 393       assert(!p.will_fit(min_young_length + 1),
 394              &quot;min_young_length, the result of the binary search, should be &quot;
 395              &quot;optimal, so no larger length should fit into the pause target&quot;);
 396     }
 397   } else {
 398     // Even the minimum length doesn&#39;t fit into the pause time
 399     // target, return it as the result nevertheless.
 400   }
 401   return base_min_length + min_young_length;
 402 }
 403 
 404 double G1Policy::predict_survivor_regions_evac_time() const {
 405   double survivor_regions_evac_time = 0.0;
 406   const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
<span class="line-removed"> 407 </span>
 408   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivor_regions-&gt;begin();
 409        it != survivor_regions-&gt;end();
 410        ++it) {
<span class="line-modified"> 411     survivor_regions_evac_time += predict_region_elapsed_time_ms(*it, collector_state()-&gt;in_young_only_phase());</span>
 412   }
 413   return survivor_regions_evac_time;
 414 }
 415 
<span class="line-modified"> 416 void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_lengths) {</span>
<span class="line-modified"> 417   guarantee( adaptive_young_list_length(), &quot;should not call this otherwise&quot; );</span>
 418 
<span class="line-modified"> 419   if (rs_lengths &gt; _rs_lengths_prediction) {</span>
 420     // add 10% to avoid having to recalculate often
<span class="line-modified"> 421     size_t rs_lengths_prediction = rs_lengths * 1100 / 1000;</span>
<span class="line-modified"> 422     update_rs_lengths_prediction(rs_lengths_prediction);</span>
 423 
<span class="line-modified"> 424     update_young_list_max_and_target_length(rs_lengths_prediction);</span>
 425   }
 426 }
 427 
<span class="line-modified"> 428 void G1Policy::update_rs_lengths_prediction() {</span>
<span class="line-modified"> 429   update_rs_lengths_prediction(_analytics-&gt;predict_rs_lengths());</span>
 430 }
 431 
<span class="line-modified"> 432 void G1Policy::update_rs_lengths_prediction(size_t prediction) {</span>
<span class="line-modified"> 433   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; adaptive_young_list_length()) {</span>
<span class="line-modified"> 434     _rs_lengths_prediction = prediction;</span>
 435   }
 436 }
 437 
 438 void G1Policy::record_full_collection_start() {
 439   _full_collection_start_sec = os::elapsedTime();
 440   // Release the future to-space so that it is available for compaction into.
 441   collector_state()-&gt;set_in_young_only_phase(false);
 442   collector_state()-&gt;set_in_full_gc(true);
 443   _collection_set-&gt;clear_candidates();

 444 }
 445 
 446 void G1Policy::record_full_collection_end() {
 447   // Consider this like a collection pause for the purposes of allocation
 448   // since last pause.
 449   double end_sec = os::elapsedTime();
 450   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 451   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 452 
 453   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 454 
 455   collector_state()-&gt;set_in_full_gc(false);
 456 
 457   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 458   // transitions and make sure we start with young GCs after the Full GC.
 459   collector_state()-&gt;set_in_young_only_phase(true);
 460   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 461   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 462   collector_state()-&gt;set_in_initial_mark_gc(false);
 463   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 464   collector_state()-&gt;set_clearing_next_bitmap(false);
 465 
<span class="line-modified"> 466   _short_lived_surv_rate_group-&gt;start_adding_regions();</span>
 467   // also call this on any additional surv rate groups
 468 
 469   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
<span class="line-removed"> 470   // Reset survivors SurvRateGroup.</span>
 471   _survivor_surv_rate_group-&gt;reset();
 472   update_young_list_max_and_target_length();
<span class="line-modified"> 473   update_rs_lengths_prediction();</span>

 474 
 475   _bytes_allocated_in_old_since_last_gc = 0;
 476 
 477   record_pause(FullGC, _full_collection_start_sec, end_sec);
 478 }
 479 






















































 480 void G1Policy::record_collection_pause_start(double start_time_sec) {
 481   // We only need to do this here as the policy will only be applied
 482   // to the GC we&#39;re about to start. so, no point is calculating this
 483   // every time we calculate / recalculate the target young length.
 484   update_survivors_policy();
 485 
 486   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 487          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 488          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
<span class="line-modified"> 489 </span>
<span class="line-removed"> 490   assert(_g1h-&gt;used() == _g1h-&gt;recalculate_used(),</span>
<span class="line-removed"> 491          &quot;sanity, used: &quot; SIZE_FORMAT &quot; recalculate_used: &quot; SIZE_FORMAT,</span>
<span class="line-removed"> 492          _g1h-&gt;used(), _g1h-&gt;recalculate_used());</span>
 493 
 494   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
<span class="line-modified"> 495   _pending_cards = _g1h-&gt;pending_card_num();</span>

 496 
 497   _collection_set-&gt;reset_bytes_used_before();
<span class="line-removed"> 498   _bytes_copied_during_gc = 0;</span>
 499 
 500   // do that for any other surv rate groups
<span class="line-modified"> 501   _short_lived_surv_rate_group-&gt;stop_adding_regions();</span>
 502   _survivors_age_table.clear();
 503 
 504   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 505 }
 506 
 507 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 508   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 509   collector_state()-&gt;set_in_initial_mark_gc(false);
 510 }
 511 
 512 void G1Policy::record_concurrent_mark_remark_start() {
 513   _mark_remark_start_sec = os::elapsedTime();
 514 }
 515 
 516 void G1Policy::record_concurrent_mark_remark_end() {
 517   double end_time_sec = os::elapsedTime();
 518   double elapsed_time_ms = (end_time_sec - _mark_remark_start_sec)*1000.0;
 519   _analytics-&gt;report_concurrent_mark_remark_times_ms(elapsed_time_ms);
 520   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
 521 
</pre>
<hr />
<pre>
 528 
 529 double G1Policy::average_time_ms(G1GCPhaseTimes::GCParPhases phase) const {
 530   return phase_times()-&gt;average_time_ms(phase);
 531 }
 532 
 533 double G1Policy::young_other_time_ms() const {
 534   return phase_times()-&gt;young_cset_choice_time_ms() +
 535          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::YoungFreeCSet);
 536 }
 537 
 538 double G1Policy::non_young_other_time_ms() const {
 539   return phase_times()-&gt;non_young_cset_choice_time_ms() +
 540          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::NonYoungFreeCSet);
 541 }
 542 
 543 double G1Policy::other_time_ms(double pause_time_ms) const {
 544   return pause_time_ms - phase_times()-&gt;cur_collection_par_time_ms();
 545 }
 546 
 547 double G1Policy::constant_other_time_ms(double pause_time_ms) const {
<span class="line-modified"> 548   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms();</span>
 549 }
 550 
 551 bool G1Policy::about_to_start_mixed_phase() const {
 552   return _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle() || collector_state()-&gt;in_young_gc_before_mixed();
 553 }
 554 
 555 bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
 556   if (about_to_start_mixed_phase()) {
 557     return false;
 558   }
 559 
 560   size_t marking_initiating_used_threshold = _ihop_control-&gt;get_conc_mark_start_threshold();
 561 
 562   size_t cur_used_bytes = _g1h-&gt;non_young_capacity_bytes();
 563   size_t alloc_byte_size = alloc_word_size * HeapWordSize;
 564   size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;
 565 
 566   bool result = false;
 567   if (marking_request_bytes &gt; marking_initiating_used_threshold) {
 568     result = collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;in_young_gc_before_mixed();
 569     log_debug(gc, ergo, ihop)(&quot;%s occupancy: &quot; SIZE_FORMAT &quot;B allocation request: &quot; SIZE_FORMAT &quot;B threshold: &quot; SIZE_FORMAT &quot;B (%1.2f) source: %s&quot;,
 570                               result ? &quot;Request concurrent cycle initiation (occupancy higher than threshold)&quot; : &quot;Do not request concurrent cycle initiation (still doing mixed collections)&quot;,
 571                               cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold / _g1h-&gt;capacity() * 100, source);
 572   }
 573 
 574   return result;
 575 }
 576 












 577 // Anything below that is considered to be zero
 578 #define MIN_TIMER_GRANULARITY 0.0000001
 579 
<span class="line-modified"> 580 void G1Policy::record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc) {</span>


 581   double end_time_sec = os::elapsedTime();
 582 
<span class="line-removed"> 583   size_t cur_used_bytes = _g1h-&gt;used();</span>
<span class="line-removed"> 584   assert(cur_used_bytes == _g1h-&gt;recalculate_used(), &quot;It should!&quot;);</span>
 585   bool this_pause_included_initial_mark = false;
 586   bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();
 587 
 588   bool update_stats = !_g1h-&gt;evacuation_failed();
 589 
 590   record_pause(young_gc_pause_kind(), end_time_sec - pause_time_ms / 1000.0, end_time_sec);
 591 
 592   _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
 593 
 594   this_pause_included_initial_mark = collector_state()-&gt;in_initial_mark_gc();
 595   if (this_pause_included_initial_mark) {
 596     record_concurrent_mark_init_end(0.0);
 597   } else {
 598     maybe_start_marking();
 599   }
 600 
 601   double app_time_ms = (phase_times()-&gt;cur_collection_start_sec() * 1000.0 - _analytics-&gt;prev_collection_pause_end_ms());
 602   if (app_time_ms &lt; MIN_TIMER_GRANULARITY) {
 603     // This usually happens due to the timer not having the required
 604     // granularity. Some Linuxes are the usual culprits.
</pre>
<hr />
<pre>
 627 
 628   if (collector_state()-&gt;in_young_gc_before_mixed()) {
 629     assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
 630     // This has been the young GC before we start doing mixed GCs. We already
 631     // decided to start mixed GCs much earlier, so there is nothing to do except
 632     // advancing the state.
 633     collector_state()-&gt;set_in_young_only_phase(false);
 634     collector_state()-&gt;set_in_young_gc_before_mixed(false);
 635   } else if (!this_pause_was_young_only) {
 636     // This is a mixed GC. Here we decide whether to continue doing more
 637     // mixed GCs or not.
 638     if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
 639                                  &quot;do not continue mixed GCs&quot;)) {
 640       collector_state()-&gt;set_in_young_only_phase(true);
 641 
 642       clear_collection_set_candidates();
 643       maybe_start_marking();
 644     }
 645   }
 646 
<span class="line-modified"> 647   _short_lived_surv_rate_group-&gt;start_adding_regions();</span>
<span class="line-removed"> 648   // Do that for any other surv rate groups</span>
<span class="line-removed"> 649 </span>
<span class="line-removed"> 650   double scan_hcc_time_ms = G1HotCardCache::default_use_cache() ? average_time_ms(G1GCPhaseTimes::ScanHCC) : 0.0;</span>
 651 

 652   if (update_stats) {
<span class="line-modified"> 653     double cost_per_card_ms = 0.0;</span>
<span class="line-modified"> 654     if (_pending_cards &gt; 0) {</span>
<span class="line-modified"> 655       cost_per_card_ms = (average_time_ms(G1GCPhaseTimes::UpdateRS)) / (double) _pending_cards;</span>
<span class="line-modified"> 656       _analytics-&gt;report_cost_per_card_ms(cost_per_card_ms);</span>














 657     }
<span class="line-removed"> 658     _analytics-&gt;report_cost_scan_hcc(scan_hcc_time_ms);</span>
 659 
<span class="line-modified"> 660     double cost_per_entry_ms = 0.0;</span>
<span class="line-modified"> 661     if (cards_scanned &gt; 10) {</span>
<span class="line-modified"> 662       cost_per_entry_ms = average_time_ms(G1GCPhaseTimes::ScanRS) / (double) cards_scanned;</span>
<span class="line-modified"> 663       _analytics-&gt;report_cost_per_entry_ms(cost_per_entry_ms, this_pause_was_young_only);</span>
<span class="line-modified"> 664     }</span>


 665 
<span class="line-modified"> 666     if (_max_rs_lengths &gt; 0) {</span>
<span class="line-removed"> 667       double cards_per_entry_ratio =</span>
<span class="line-removed"> 668         (double) cards_scanned / (double) _max_rs_lengths;</span>
<span class="line-removed"> 669       _analytics-&gt;report_cards_per_entry_ratio(cards_per_entry_ratio, this_pause_was_young_only);</span>
 670     }
 671 
<span class="line-modified"> 672     // This is defensive. For a while _max_rs_lengths could get</span>
<span class="line-modified"> 673     // smaller than _recorded_rs_lengths which was causing</span>
<span class="line-modified"> 674     // rs_length_diff to get very large and mess up the RSet length</span>
<span class="line-modified"> 675     // predictions. The reason was unsafe concurrent updates to the</span>
<span class="line-modified"> 676     // _inc_cset_recorded_rs_lengths field which the code below guards</span>
<span class="line-modified"> 677     // against (see CR 7118202). This bug has now been fixed (see CR</span>
<span class="line-modified"> 678     // 7119027). However, I&#39;m still worried that</span>
<span class="line-modified"> 679     // _inc_cset_recorded_rs_lengths might still end up somewhat</span>
<span class="line-modified"> 680     // inaccurate. The concurrent refinement thread calculates an</span>
<span class="line-modified"> 681     // RSet&#39;s length concurrently with other CR threads updating it</span>
<span class="line-removed"> 682     // which might cause it to calculate the length incorrectly (if,</span>
<span class="line-removed"> 683     // say, it&#39;s in mid-coarsening). So I&#39;ll leave in the defensive</span>
<span class="line-removed"> 684     // conditional below just in case.</span>
<span class="line-removed"> 685     size_t rs_length_diff = 0;</span>
<span class="line-removed"> 686     size_t recorded_rs_lengths = _collection_set-&gt;recorded_rs_lengths();</span>
<span class="line-removed"> 687     if (_max_rs_lengths &gt; recorded_rs_lengths) {</span>
<span class="line-removed"> 688       rs_length_diff = _max_rs_lengths - recorded_rs_lengths;</span>
 689     }
<span class="line-modified"> 690     _analytics-&gt;report_rs_length_diff((double) rs_length_diff);</span>




 691 
<span class="line-modified"> 692     size_t freed_bytes = heap_used_bytes_before_gc - cur_used_bytes;</span>
<span class="line-modified"> 693     size_t copied_bytes = _collection_set-&gt;bytes_used_before() - freed_bytes;</span>
<span class="line-removed"> 694     double cost_per_byte_ms = 0.0;</span>
 695 
 696     if (copied_bytes &gt; 0) {
<span class="line-modified"> 697       cost_per_byte_ms = average_time_ms(G1GCPhaseTimes::ObjCopy) / (double) copied_bytes;</span>
 698       _analytics-&gt;report_cost_per_byte_ms(cost_per_byte_ms, collector_state()-&gt;mark_or_rebuild_in_progress());
 699     }
 700 
 701     if (_collection_set-&gt;young_region_length() &gt; 0) {
 702       _analytics-&gt;report_young_other_cost_per_region_ms(young_other_time_ms() /
 703                                                         _collection_set-&gt;young_region_length());
 704     }
 705 
 706     if (_collection_set-&gt;old_region_length() &gt; 0) {
 707       _analytics-&gt;report_non_young_other_cost_per_region_ms(non_young_other_time_ms() /
 708                                                             _collection_set-&gt;old_region_length());
 709     }
 710 
 711     _analytics-&gt;report_constant_other_time_ms(constant_other_time_ms(pause_time_ms));
 712 
 713     // Do not update RS lengths and the number of pending cards with information from mixed gc:
 714     // these are is wildly different to during young only gc and mess up young gen sizing right
 715     // after the mixed gc phase.
 716     // During mixed gc we do not use them for young gen sizing.
 717     if (this_pause_was_young_only) {
<span class="line-modified"> 718       _analytics-&gt;report_pending_cards((double) _pending_cards);</span>
<span class="line-modified"> 719       _analytics-&gt;report_rs_lengths((double) _max_rs_lengths);</span>
 720     }
 721   }
 722 
 723   assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),
 724          &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);
 725   if (this_pause_included_initial_mark) {
 726     collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
 727   }
 728 
 729   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 730 
<span class="line-modified"> 731   update_rs_lengths_prediction();</span>
 732 
 733   // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
 734   // that in this case we are not running in a &quot;normal&quot; operating mode.
 735   if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
 736     // IHOP control wants to know the expected young gen length if it were not
 737     // restrained by the heap reserve. Using the actual length would make the
 738     // prediction too small and the limit the young gen every time we get to the
 739     // predicted target occupancy.
 740     size_t last_unrestrained_young_length = update_young_list_max_and_target_length();
 741 
 742     update_ihop_prediction(app_time_ms / 1000.0,
 743                            _bytes_allocated_in_old_since_last_gc,
 744                            last_unrestrained_young_length * HeapRegion::GrainBytes,
 745                            this_pause_was_young_only);
 746     _bytes_allocated_in_old_since_last_gc = 0;
 747 
 748     _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
 749   } else {
 750     // Any garbage collection triggered as periodic collection resets the time-to-mixed
 751     // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
 752     // the marking threads may have received an uncharacterisic amount of cpu time
 753     // for completing the marking, i.e. are faster than expected.
 754     // This skews the predicted marking length towards smaller values which might cause
 755     // the mark start being too late.
 756     _initial_mark_to_mixed.reset();
 757   }
 758 
 759   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
<span class="line-modified"> 760   double update_rs_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;</span>
 761 
<span class="line-modified"> 762   if (update_rs_time_goal_ms &lt; scan_hcc_time_ms) {</span>
 763     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
<span class="line-modified"> 764                                 &quot;Update RS time goal: %1.2fms Scan HCC time: %1.2fms&quot;,</span>
<span class="line-modified"> 765                                 update_rs_time_goal_ms, scan_hcc_time_ms);</span>
 766 
<span class="line-modified"> 767     update_rs_time_goal_ms = 0;</span>
 768   } else {
<span class="line-modified"> 769     update_rs_time_goal_ms -= scan_hcc_time_ms;</span>
 770   }
<span class="line-modified"> 771   _g1h-&gt;concurrent_refine()-&gt;adjust(average_time_ms(G1GCPhaseTimes::UpdateRS),</span>
<span class="line-modified"> 772                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::UpdateRS),</span>
<span class="line-modified"> 773                                     update_rs_time_goal_ms);</span>







 774 }
 775 
 776 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 777   if (G1UseAdaptiveIHOP) {
 778     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 779                                      predictor,
 780                                      G1ReservePercent,
 781                                      G1HeapWastePercent);
 782   } else {
 783     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 784   }
 785 }
 786 
 787 void G1Policy::update_ihop_prediction(double mutator_time_s,
 788                                       size_t mutator_alloc_bytes,
 789                                       size_t young_gen_size,
 790                                       bool this_gc_was_young_only) {
 791   // Always try to update IHOP prediction. Even evacuation failures give information
 792   // about e.g. whether to start IHOP earlier next time.
 793 
</pre>
<hr />
<pre>
 814   // marking, which makes any prediction useless. This increases the accuracy of the
 815   // prediction.
 816   if (this_gc_was_young_only &amp;&amp; mutator_time_s &gt; min_valid_time) {
 817     _ihop_control-&gt;update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
 818     report = true;
 819   }
 820 
 821   if (report) {
 822     report_ihop_statistics();
 823   }
 824 }
 825 
 826 void G1Policy::report_ihop_statistics() {
 827   _ihop_control-&gt;print();
 828 }
 829 
 830 void G1Policy::print_phases() {
 831   phase_times()-&gt;print();
 832 }
 833 
<span class="line-removed"> 834 double G1Policy::predict_yg_surv_rate(int age, SurvRateGroup* surv_rate_group) const {</span>
<span class="line-removed"> 835   TruncatedSeq* seq = surv_rate_group-&gt;get_seq(age);</span>
<span class="line-removed"> 836   guarantee(seq-&gt;num() &gt; 0, &quot;There should be some young gen survivor samples available. Tried to access with age %d&quot;, age);</span>
<span class="line-removed"> 837   double pred = _predictor.get_new_prediction(seq);</span>
<span class="line-removed"> 838   if (pred &gt; 1.0) {</span>
<span class="line-removed"> 839     pred = 1.0;</span>
<span class="line-removed"> 840   }</span>
<span class="line-removed"> 841   return pred;</span>
<span class="line-removed"> 842 }</span>
<span class="line-removed"> 843 </span>
<span class="line-removed"> 844 double G1Policy::accum_yg_surv_rate_pred(int age) const {</span>
<span class="line-removed"> 845   return _short_lived_surv_rate_group-&gt;accum_surv_rate_pred(age);</span>
<span class="line-removed"> 846 }</span>
<span class="line-removed"> 847 </span>
 848 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,
<span class="line-modified"> 849                                               size_t scanned_cards) const {</span>

 850   return
<span class="line-modified"> 851     _analytics-&gt;predict_rs_update_time_ms(pending_cards) +</span>
<span class="line-modified"> 852     _analytics-&gt;predict_rs_scan_time_ms(scanned_cards, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="line-modified"> 853     _analytics-&gt;predict_constant_other_time_ms();</span>

 854 }
 855 
 856 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
<span class="line-modified"> 857   size_t rs_length = _analytics-&gt;predict_rs_lengths() + _analytics-&gt;predict_rs_length_diff();</span>
<span class="line-modified"> 858   size_t card_num = _analytics-&gt;predict_card_num(rs_length, collector_state()-&gt;in_young_only_phase());</span>
<span class="line-removed"> 859   return predict_base_elapsed_time_ms(pending_cards, card_num);</span>
 860 }
 861 
 862 size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {
 863   size_t bytes_to_copy;
 864   if (!hr-&gt;is_young()) {
 865     bytes_to_copy = hr-&gt;max_live_bytes();
 866   } else {
<span class="line-modified"> 867     assert(hr-&gt;age_in_surv_rate_group() != -1, &quot;invariant&quot;);</span>
<span class="line-removed"> 868     int age = hr-&gt;age_in_surv_rate_group();</span>
<span class="line-removed"> 869     double yg_surv_rate = predict_yg_surv_rate(age, hr-&gt;surv_rate_group());</span>
<span class="line-removed"> 870     bytes_to_copy = (size_t) (hr-&gt;used() * yg_surv_rate);</span>
 871   }
 872   return bytes_to_copy;
 873 }
 874 
<span class="line-modified"> 875 double G1Policy::predict_region_elapsed_time_ms(HeapRegion* hr,</span>
<span class="line-modified"> 876                                                 bool for_young_gc) const {</span>
















 877   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified"> 878   // Predicting the number of cards is based on which type of GC</span>
<span class="line-removed"> 879   // we&#39;re predicting for.</span>
<span class="line-removed"> 880   size_t card_num = _analytics-&gt;predict_card_num(rs_length, for_young_gc);</span>
<span class="line-removed"> 881   size_t bytes_to_copy = predict_bytes_to_copy(hr);</span>
 882 
 883   double region_elapsed_time_ms =
<span class="line-modified"> 884     _analytics-&gt;predict_rs_scan_time_ms(card_num, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="line-modified"> 885     _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
 886 
 887   // The prediction of the &quot;other&quot; time for this region is based
 888   // upon the region type and NOT the GC type.
 889   if (hr-&gt;is_young()) {
 890     region_elapsed_time_ms += _analytics-&gt;predict_young_other_time_ms(1);
 891   } else {
 892     region_elapsed_time_ms += _analytics-&gt;predict_non_young_other_time_ms(1);
 893   }
 894   return region_elapsed_time_ms;
 895 }
 896 




 897 bool G1Policy::should_allocate_mutator_region() const {
 898   uint young_list_length = _g1h-&gt;young_regions_count();
 899   uint young_list_target_length = _young_list_target_length;
 900   return young_list_length &lt; young_list_target_length;
 901 }
 902 
 903 bool G1Policy::can_expand_young_list() const {
 904   uint young_list_length = _g1h-&gt;young_regions_count();
 905   uint young_list_max_length = _young_list_max_length;
 906   return young_list_length &lt; young_list_max_length;
 907 }
 908 
<span class="line-modified"> 909 bool G1Policy::adaptive_young_list_length() const {</span>
<span class="line-modified"> 910   return _young_gen_sizer-&gt;adaptive_young_list_length();</span>
 911 }
 912 
 913 size_t G1Policy::desired_survivor_size(uint max_regions) const {
 914   size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;
 915   return (size_t)((((double)survivor_capacity) * TargetSurvivorRatio) / 100);
 916 }
 917 
 918 void G1Policy::print_age_table() {
 919   _survivors_age_table.print_age_table(_tenuring_threshold);
 920 }
 921 
 922 void G1Policy::update_max_gc_locker_expansion() {
 923   uint expansion_region_num = 0;
 924   if (GCLockerEdenExpansionPercent &gt; 0) {
 925     double perc = (double) GCLockerEdenExpansionPercent / 100.0;
 926     double expansion_region_num_d = perc * (double) _young_list_target_length;
 927     // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
 928     // less than 1.0) we&#39;ll get 1.
 929     expansion_region_num = (uint) ceil(expansion_region_num_d);
 930   } else {
</pre>
<hr />
<pre>
1171   return (uint) result;
1172 }
1173 
1174 uint G1Policy::calc_max_old_cset_length() const {
1175   // The max old CSet region bound is based on the threshold expressed
1176   // as a percentage of the heap size. I.e., it should bound the
1177   // number of old regions added to the CSet irrespective of how many
1178   // of them are available.
1179 
1180   const G1CollectedHeap* g1h = G1CollectedHeap::heap();
1181   const size_t region_num = g1h-&gt;num_regions();
1182   const size_t perc = (size_t) G1OldCSetRegionThresholdPercent;
1183   size_t result = region_num * perc / 100;
1184   // emulate ceiling
1185   if (100 * result &lt; region_num * perc) {
1186     result += 1;
1187   }
1188   return (uint) result;
1189 }
1190 
<span class="line-modified">1191 void G1Policy::finalize_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {</span>
<span class="line-modified">1192   double time_remaining_ms = _collection_set-&gt;finalize_young_part(target_pause_time_ms, survivor);</span>
<span class="line-modified">1193   _collection_set-&gt;finalize_old_part(time_remaining_ms);</span>






























































































































1194 }
1195 
1196 void G1Policy::transfer_survivors_to_cset(const G1SurvivorRegions* survivors) {
<span class="line-removed">1197 </span>
<span class="line-removed">1198   // Add survivor regions to SurvRateGroup.</span>
1199   note_start_adding_survivor_regions();
<span class="line-removed">1200   finished_recalculating_age_indexes(true /* is_survivors */);</span>
1201 
1202   HeapRegion* last = NULL;
1203   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivors-&gt;regions()-&gt;begin();
1204        it != survivors-&gt;regions()-&gt;end();
1205        ++it) {
1206     HeapRegion* curr = *it;
1207     set_region_survivor(curr);
1208 
1209     // The region is a non-empty survivor so let&#39;s add it to
1210     // the incremental collection set for the next evacuation
1211     // pause.
1212     _collection_set-&gt;add_survivor_regions(curr);
1213 
1214     last = curr;
1215   }
1216   note_stop_adding_survivor_regions();
1217 
1218   // Don&#39;t clear the survivor list handles until the start of
1219   // the next evacuation pause - we need it in order to re-tag
1220   // the survivor regions from this evacuation pause as &#39;young&#39;
1221   // at the start of the next.
<span class="line-removed">1222 </span>
<span class="line-removed">1223   finished_recalculating_age_indexes(false /* is_survivors */);</span>
1224 }
</pre>
</td>
<td>
<hr />
<pre>
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;
<span class="line-added">  27 #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
  28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  30 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  33 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  34 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  35 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  36 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  37 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  38 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  39 #include &quot;gc/g1/g1Policy.hpp&quot;
  40 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  41 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  42 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  43 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  44 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/java.hpp&quot;
  48 #include &quot;runtime/mutexLocker.hpp&quot;
  49 #include &quot;utilities/debug.hpp&quot;
  50 #include &quot;utilities/growableArray.hpp&quot;
  51 #include &quot;utilities/pair.hpp&quot;
  52 
<span class="line-modified">  53 G1Policy::G1Policy(STWGCTimer* gc_timer) :</span>
  54   _predictor(G1ConfidencePercent / 100.0),
  55   _analytics(new G1Analytics(&amp;_predictor)),
  56   _remset_tracker(),
  57   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  58   _ihop_control(create_ihop_control(&amp;_predictor)),
  59   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  60   _full_collection_start_sec(0.0),
  61   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
  62   _young_list_target_length(0),
  63   _young_list_fixed_length(0),
  64   _young_list_max_length(0),
<span class="line-modified">  65   _eden_surv_rate_group(new G1SurvRateGroup()),</span>
<span class="line-modified">  66   _survivor_surv_rate_group(new G1SurvRateGroup()),</span>
  67   _reserve_factor((double) G1ReservePercent / 100.0),
  68   _reserve_regions(0),
<span class="line-modified">  69   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),</span>
  70   _free_regions_at_end_of_collection(0),
<span class="line-modified">  71   _rs_length(0),</span>
<span class="line-modified">  72   _rs_length_prediction(0),</span>
<span class="line-modified">  73   _pending_cards_at_gc_start(0),</span>
<span class="line-added">  74   _pending_cards_at_prev_gc_end(0),</span>
<span class="line-added">  75   _total_mutator_refined_cards(0),</span>
<span class="line-added">  76   _total_concurrent_refined_cards(0),</span>
<span class="line-added">  77   _total_concurrent_refinement_time(),</span>
  78   _bytes_allocated_in_old_since_last_gc(0),
  79   _initial_mark_to_mixed(),
  80   _collection_set(NULL),

  81   _g1h(NULL),
  82   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  83   _mark_remark_start_sec(0),
  84   _mark_cleanup_start_sec(0),
  85   _tenuring_threshold(MaxTenuringThreshold),
  86   _max_survivor_regions(0),
  87   _survivors_age_table(true)
  88 {
  89 }
  90 
  91 G1Policy::~G1Policy() {
  92   delete _ihop_control;
  93   delete _young_gen_sizer;
  94 }
  95 
<span class="line-modified">  96 G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {</span>
<span class="line-modified">  97   if (G1Arguments::is_heterogeneous_heap()) {</span>
<span class="line-modified">  98     return new G1HeterogeneousHeapPolicy(gc_timer_stw);</span>
  99   } else {
<span class="line-modified"> 100     return new G1Policy(gc_timer_stw);</span>
 101   }
 102 }
 103 
 104 G1CollectorState* G1Policy::collector_state() const { return _g1h-&gt;collector_state(); }
 105 
 106 void G1Policy::init(G1CollectedHeap* g1h, G1CollectionSet* collection_set) {
 107   _g1h = g1h;
 108   _collection_set = collection_set;
 109 
 110   assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
 111 
<span class="line-modified"> 112   if (!use_adaptive_young_list_length()) {</span>
 113     _young_list_fixed_length = _young_gen_sizer-&gt;min_desired_young_length();
 114   }
 115   _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
 116 
 117   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 118 
 119   update_young_list_max_and_target_length();
 120   // We may immediately start allocating regions and placing them on the
 121   // collection set list. Initialize the per-collection set info
 122   _collection_set-&gt;start_incremental_building();
 123 }
 124 
 125 void G1Policy::note_gc_start() {
 126   phase_times()-&gt;note_gc_start();
 127 }
 128 
 129 class G1YoungLengthPredictor {

 130   const double _base_time_ms;
 131   const double _base_free_regions;
 132   const double _target_pause_time_ms;
 133   const G1Policy* const _policy;
 134 
 135  public:
<span class="line-modified"> 136   G1YoungLengthPredictor(double base_time_ms,</span>

 137                          double base_free_regions,
 138                          double target_pause_time_ms,
 139                          const G1Policy* policy) :

 140     _base_time_ms(base_time_ms),
 141     _base_free_regions(base_free_regions),
 142     _target_pause_time_ms(target_pause_time_ms),
 143     _policy(policy) {}
 144 
 145   bool will_fit(uint young_length) const {
 146     if (young_length &gt;= _base_free_regions) {
 147       // end condition 1: not enough space for the young regions
 148       return false;
 149     }
 150 
<span class="line-modified"> 151     size_t bytes_to_copy = 0;</span>
<span class="line-modified"> 152     const double copy_time_ms = _policy-&gt;predict_eden_copy_time_ms(young_length, &amp;bytes_to_copy);</span>



 153     const double young_other_time_ms = _policy-&gt;analytics()-&gt;predict_young_other_time_ms(young_length);
 154     const double pause_time_ms = _base_time_ms + copy_time_ms + young_other_time_ms;
 155     if (pause_time_ms &gt; _target_pause_time_ms) {
 156       // end condition 2: prediction is over the target pause time
 157       return false;
 158     }
 159 
 160     const size_t free_bytes = (_base_free_regions - young_length) * HeapRegion::GrainBytes;
 161 
 162     // When copying, we will likely need more bytes free than is live in the region.
 163     // Add some safety margin to factor in the confidence of our guess, and the
 164     // natural expected waste.
 165     // (100.0 / G1ConfidencePercent) is a scale factor that expresses the uncertainty
 166     // of the calculation: the lower the confidence, the more headroom.
 167     // (100 + TargetPLABWastePct) represents the increase in expected bytes during
 168     // copying due to anticipated waste in the PLABs.
 169     const double safety_factor = (100.0 / G1ConfidencePercent) * (100 + TargetPLABWastePct) / 100.0;
 170     const size_t expected_bytes_to_copy = (size_t)(safety_factor * bytes_to_copy);
 171 
 172     if (expected_bytes_to_copy &gt; free_bytes) {
</pre>
<hr />
<pre>
 176 
 177     // success!
 178     return true;
 179   }
 180 };
 181 
 182 void G1Policy::record_new_heap_size(uint new_number_of_regions) {
 183   // re-calculate the necessary reserve
 184   double reserve_regions_d = (double) new_number_of_regions * _reserve_factor;
 185   // We use ceiling so that if reserve_regions_d is &gt; 0.0 (but
 186   // smaller than 1.0) we&#39;ll get 1.
 187   _reserve_regions = (uint) ceil(reserve_regions_d);
 188 
 189   _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
 190 
 191   _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
 192 }
 193 
 194 uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {
 195   uint desired_min_length = 0;
<span class="line-modified"> 196   if (use_adaptive_young_list_length()) {</span>
 197     if (_analytics-&gt;num_alloc_rate_ms() &gt; 3) {
 198       double now_sec = os::elapsedTime();
 199       double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;
 200       double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();
 201       desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
 202     } else {
 203       // otherwise we don&#39;t have enough info to make the prediction
 204     }
 205   }
 206   desired_min_length += base_min_length;
 207   // make sure we don&#39;t go below any user-defined minimum bound
 208   return MAX2(_young_gen_sizer-&gt;min_desired_young_length(), desired_min_length);
 209 }
 210 
 211 uint G1Policy::calculate_young_list_desired_max_length() const {
 212   // Here, we might want to also take into account any additional
 213   // constraints (i.e., user-defined minimum bound). Currently, we
 214   // effectively don&#39;t set this bound.
 215   return _young_gen_sizer-&gt;max_desired_young_length();
 216 }
 217 
 218 uint G1Policy::update_young_list_max_and_target_length() {
<span class="line-modified"> 219   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_length());</span>
 220 }
 221 
<span class="line-modified"> 222 uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {</span>
<span class="line-modified"> 223   uint unbounded_target_length = update_young_list_target_length(rs_length);</span>
 224   update_max_gc_locker_expansion();
 225   return unbounded_target_length;
 226 }
 227 
<span class="line-modified"> 228 uint G1Policy::update_young_list_target_length(size_t rs_length) {</span>
<span class="line-modified"> 229   YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);</span>
 230   _young_list_target_length = young_lengths.first;
 231 
 232   return young_lengths.second;
 233 }
 234 
<span class="line-modified"> 235 G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {</span>
 236   YoungTargetLengths result;
 237 
 238   // Calculate the absolute and desired min bounds first.
 239 
 240   // This is how many young regions we already have (currently: the survivors).
 241   const uint base_min_length = _g1h-&gt;survivor_regions_count();
 242   uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);
 243   // This is the absolute minimum young length. Ensure that we
 244   // will at least have one eden region available for allocation.
 245   uint absolute_min_length = base_min_length + MAX2(_g1h-&gt;eden_regions_count(), (uint)1);
 246   // If we shrank the young list target it should not shrink below the current size.
 247   desired_min_length = MAX2(desired_min_length, absolute_min_length);
 248   // Calculate the absolute and desired max bounds.
 249 
 250   uint desired_max_length = calculate_young_list_desired_max_length();
 251 
 252   uint young_list_target_length = 0;
<span class="line-modified"> 253   if (use_adaptive_young_list_length()) {</span>
 254     if (collector_state()-&gt;in_young_only_phase()) {
 255       young_list_target_length =
<span class="line-modified"> 256                         calculate_young_list_target_length(rs_length,</span>
 257                                                            base_min_length,
 258                                                            desired_min_length,
 259                                                            desired_max_length);
 260     } else {
 261       // Don&#39;t calculate anything and let the code below bound it to
 262       // the desired_min_length, i.e., do the next GC as soon as
 263       // possible to maximize how many old regions we can add to it.
 264     }
 265   } else {
 266     // The user asked for a fixed young gen so we&#39;ll fix the young gen
 267     // whether the next GC is young or mixed.
 268     young_list_target_length = _young_list_fixed_length;
 269   }
 270 
 271   result.second = young_list_target_length;
 272 
 273   // We will try our best not to &quot;eat&quot; into the reserve.
 274   uint absolute_max_length = 0;
 275   if (_free_regions_at_end_of_collection &gt; _reserve_regions) {
 276     absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;
</pre>
<hr />
<pre>
 280   }
 281 
 282   // Make sure we don&#39;t go over the desired max length, nor under the
 283   // desired min length. In case they clash, desired_min_length wins
 284   // which is why that test is second.
 285   if (young_list_target_length &gt; desired_max_length) {
 286     young_list_target_length = desired_max_length;
 287   }
 288   if (young_list_target_length &lt; desired_min_length) {
 289     young_list_target_length = desired_min_length;
 290   }
 291 
 292   assert(young_list_target_length &gt; base_min_length,
 293          &quot;we should be able to allocate at least one eden region&quot;);
 294   assert(young_list_target_length &gt;= absolute_min_length, &quot;post-condition&quot;);
 295 
 296   result.first = young_list_target_length;
 297   return result;
 298 }
 299 
<span class="line-modified"> 300 uint G1Policy::calculate_young_list_target_length(size_t rs_length,</span>
<span class="line-modified"> 301                                                   uint base_min_length,</span>
<span class="line-modified"> 302                                                   uint desired_min_length,</span>
<span class="line-modified"> 303                                                   uint desired_max_length) const {</span>
<span class="line-modified"> 304   assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);</span>

 305   assert(collector_state()-&gt;in_young_only_phase(), &quot;only call this for young GCs&quot;);
 306 
 307   // In case some edge-condition makes the desired max length too small...
 308   if (desired_max_length &lt;= desired_min_length) {
 309     return desired_min_length;
 310   }
 311 
 312   // We&#39;ll adjust min_young_length and max_young_length not to include
 313   // the already allocated young regions (i.e., so they reflect the
 314   // min and max eden regions we&#39;ll allocate). The base_min_length
 315   // will be reflected in the predictions by the
 316   // survivor_regions_evac_time prediction.
 317   assert(desired_min_length &gt; base_min_length, &quot;invariant&quot;);
 318   uint min_young_length = desired_min_length - base_min_length;
 319   assert(desired_max_length &gt; base_min_length, &quot;invariant&quot;);
 320   uint max_young_length = desired_max_length - base_min_length;
 321 
 322   const double target_pause_time_ms = _mmu_tracker-&gt;max_gc_time() * 1000.0;

 323   const size_t pending_cards = _analytics-&gt;predict_pending_cards();
<span class="line-modified"> 324   const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);</span>




 325   const uint available_free_regions = _free_regions_at_end_of_collection;
 326   const uint base_free_regions =
 327     available_free_regions &gt; _reserve_regions ? available_free_regions - _reserve_regions : 0;
 328 
 329   // Here, we will make sure that the shortest young length that
 330   // makes sense fits within the target pause time.
 331 
<span class="line-modified"> 332   G1YoungLengthPredictor p(base_time_ms,</span>

 333                            base_free_regions,
 334                            target_pause_time_ms,
 335                            this);
 336   if (p.will_fit(min_young_length)) {
 337     // The shortest young length will fit into the target pause time;
 338     // we&#39;ll now check whether the absolute maximum number of young
 339     // regions will fit in the target pause time. If not, we&#39;ll do
 340     // a binary search between min_young_length and max_young_length.
 341     if (p.will_fit(max_young_length)) {
 342       // The maximum young length will fit into the target pause time.
 343       // We are done so set min young length to the maximum length (as
 344       // the result is assumed to be returned in min_young_length).
 345       min_young_length = max_young_length;
 346     } else {
 347       // The maximum possible number of young regions will not fit within
 348       // the target pause time so we&#39;ll search for the optimal
 349       // length. The loop invariants are:
 350       //
 351       // min_young_length &lt; max_young_length
 352       // min_young_length is known to fit into the target pause time
</pre>
<hr />
<pre>
 378       assert(min_young_length &lt; max_young_length,
 379              &quot;otherwise we should have discovered that max_young_length &quot;
 380              &quot;fits into the pause target and not done the binary search&quot;);
 381       assert(p.will_fit(min_young_length),
 382              &quot;min_young_length, the result of the binary search, should &quot;
 383              &quot;fit into the pause target&quot;);
 384       assert(!p.will_fit(min_young_length + 1),
 385              &quot;min_young_length, the result of the binary search, should be &quot;
 386              &quot;optimal, so no larger length should fit into the pause target&quot;);
 387     }
 388   } else {
 389     // Even the minimum length doesn&#39;t fit into the pause time
 390     // target, return it as the result nevertheless.
 391   }
 392   return base_min_length + min_young_length;
 393 }
 394 
 395 double G1Policy::predict_survivor_regions_evac_time() const {
 396   double survivor_regions_evac_time = 0.0;
 397   const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();

 398   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivor_regions-&gt;begin();
 399        it != survivor_regions-&gt;end();
 400        ++it) {
<span class="line-modified"> 401     survivor_regions_evac_time += predict_region_total_time_ms(*it, collector_state()-&gt;in_young_only_phase());</span>
 402   }
 403   return survivor_regions_evac_time;
 404 }
 405 
<span class="line-modified"> 406 void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_length) {</span>
<span class="line-modified"> 407   guarantee(use_adaptive_young_list_length(), &quot;should not call this otherwise&quot; );</span>
 408 
<span class="line-modified"> 409   if (rs_length &gt; _rs_length_prediction) {</span>
 410     // add 10% to avoid having to recalculate often
<span class="line-modified"> 411     size_t rs_length_prediction = rs_length * 1100 / 1000;</span>
<span class="line-modified"> 412     update_rs_length_prediction(rs_length_prediction);</span>
 413 
<span class="line-modified"> 414     update_young_list_max_and_target_length(rs_length_prediction);</span>
 415   }
 416 }
 417 
<span class="line-modified"> 418 void G1Policy::update_rs_length_prediction() {</span>
<span class="line-modified"> 419   update_rs_length_prediction(_analytics-&gt;predict_rs_length());</span>
 420 }
 421 
<span class="line-modified"> 422 void G1Policy::update_rs_length_prediction(size_t prediction) {</span>
<span class="line-modified"> 423   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {</span>
<span class="line-modified"> 424     _rs_length_prediction = prediction;</span>
 425   }
 426 }
 427 
 428 void G1Policy::record_full_collection_start() {
 429   _full_collection_start_sec = os::elapsedTime();
 430   // Release the future to-space so that it is available for compaction into.
 431   collector_state()-&gt;set_in_young_only_phase(false);
 432   collector_state()-&gt;set_in_full_gc(true);
 433   _collection_set-&gt;clear_candidates();
<span class="line-added"> 434   record_concurrent_refinement_data(true /* is_full_collection */);</span>
 435 }
 436 
 437 void G1Policy::record_full_collection_end() {
 438   // Consider this like a collection pause for the purposes of allocation
 439   // since last pause.
 440   double end_sec = os::elapsedTime();
 441   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 442   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 443 
 444   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 445 
 446   collector_state()-&gt;set_in_full_gc(false);
 447 
 448   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 449   // transitions and make sure we start with young GCs after the Full GC.
 450   collector_state()-&gt;set_in_young_only_phase(true);
 451   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 452   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 453   collector_state()-&gt;set_in_initial_mark_gc(false);
 454   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 455   collector_state()-&gt;set_clearing_next_bitmap(false);
 456 
<span class="line-modified"> 457   _eden_surv_rate_group-&gt;start_adding_regions();</span>
 458   // also call this on any additional surv rate groups
 459 
 460   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();

 461   _survivor_surv_rate_group-&gt;reset();
 462   update_young_list_max_and_target_length();
<span class="line-modified"> 463   update_rs_length_prediction();</span>
<span class="line-added"> 464   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
 465 
 466   _bytes_allocated_in_old_since_last_gc = 0;
 467 
 468   record_pause(FullGC, _full_collection_start_sec, end_sec);
 469 }
 470 
<span class="line-added"> 471 void G1Policy::record_concurrent_refinement_data(bool is_full_collection) {</span>
<span class="line-added"> 472   _pending_cards_at_gc_start = _g1h-&gt;pending_card_num();</span>
<span class="line-added"> 473 </span>
<span class="line-added"> 474   // Record info about concurrent refinement thread processing.</span>
<span class="line-added"> 475   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();</span>
<span class="line-added"> 476   G1ConcurrentRefine::RefinementStats cr_stats = cr-&gt;total_refinement_stats();</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478   Tickspan cr_time = cr_stats._time - _total_concurrent_refinement_time;</span>
<span class="line-added"> 479   _total_concurrent_refinement_time = cr_stats._time;</span>
<span class="line-added"> 480 </span>
<span class="line-added"> 481   size_t cr_cards = cr_stats._cards - _total_concurrent_refined_cards;</span>
<span class="line-added"> 482   _total_concurrent_refined_cards = cr_stats._cards;</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484   // Don&#39;t update rate if full collection.  We could be in an implicit full</span>
<span class="line-added"> 485   // collection after a non-full collection failure, in which case there</span>
<span class="line-added"> 486   // wasn&#39;t any mutator/cr-thread activity since last recording.  And if</span>
<span class="line-added"> 487   // we&#39;re in an explicit full collection, the time since the last GC can</span>
<span class="line-added"> 488   // be arbitrarily short, so not a very good sample.  Similarly, don&#39;t</span>
<span class="line-added"> 489   // update the rate if the current sample is empty or time is zero.</span>
<span class="line-added"> 490   if (!is_full_collection &amp;&amp; (cr_cards &gt; 0) &amp;&amp; (cr_time &gt; Tickspan())) {</span>
<span class="line-added"> 491     double rate = cr_cards / (cr_time.seconds() * MILLIUNITS);</span>
<span class="line-added"> 492     _analytics-&gt;report_concurrent_refine_rate_ms(rate);</span>
<span class="line-added"> 493   }</span>
<span class="line-added"> 494 </span>
<span class="line-added"> 495   // Record info about mutator thread processing.</span>
<span class="line-added"> 496   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-added"> 497   size_t mut_total_cards = dcqs.total_mutator_refined_cards();</span>
<span class="line-added"> 498   size_t mut_cards = mut_total_cards - _total_mutator_refined_cards;</span>
<span class="line-added"> 499   _total_mutator_refined_cards = mut_total_cards;</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501   // Record mutator&#39;s card logging rate.</span>
<span class="line-added"> 502   // Don&#39;t update if full collection; see above.</span>
<span class="line-added"> 503   if (!is_full_collection) {</span>
<span class="line-added"> 504     size_t total_cards = _pending_cards_at_gc_start + cr_cards + mut_cards;</span>
<span class="line-added"> 505     assert(_pending_cards_at_prev_gc_end &lt;= total_cards,</span>
<span class="line-added"> 506            &quot;untracked cards: last pending: &quot; SIZE_FORMAT</span>
<span class="line-added"> 507            &quot;, pending: &quot; SIZE_FORMAT &quot;, conc refine: &quot; SIZE_FORMAT</span>
<span class="line-added"> 508            &quot;, mut refine:&quot; SIZE_FORMAT,</span>
<span class="line-added"> 509            _pending_cards_at_prev_gc_end, _pending_cards_at_gc_start,</span>
<span class="line-added"> 510            cr_cards, mut_cards);</span>
<span class="line-added"> 511     size_t logged_cards = total_cards - _pending_cards_at_prev_gc_end;</span>
<span class="line-added"> 512     double logging_start_time = _analytics-&gt;prev_collection_pause_end_ms();</span>
<span class="line-added"> 513     double logging_end_time = Ticks::now().seconds() * MILLIUNITS;</span>
<span class="line-added"> 514     double logging_time = logging_end_time - logging_start_time;</span>
<span class="line-added"> 515     // Unlike above for conc-refine rate, here we should not require a</span>
<span class="line-added"> 516     // non-empty sample, since an application could go some time with only</span>
<span class="line-added"> 517     // young-gen or filtered out writes.  But we&#39;ll ignore unusually short</span>
<span class="line-added"> 518     // sample periods, as they may just pollute the predictions.</span>
<span class="line-added"> 519     if (logging_time &gt; 1.0) {   // Require &gt; 1ms sample time.</span>
<span class="line-added"> 520       _analytics-&gt;report_logged_cards_rate_ms(logged_cards / logging_time);</span>
<span class="line-added"> 521     }</span>
<span class="line-added"> 522   }</span>
<span class="line-added"> 523 }</span>
<span class="line-added"> 524 </span>
 525 void G1Policy::record_collection_pause_start(double start_time_sec) {
 526   // We only need to do this here as the policy will only be applied
 527   // to the GC we&#39;re about to start. so, no point is calculating this
 528   // every time we calculate / recalculate the target young length.
 529   update_survivors_policy();
 530 
 531   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 532          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 533          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
<span class="line-modified"> 534   assert_used_and_recalculate_used_equal(_g1h);</span>



 535 
 536   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
<span class="line-modified"> 537 </span>
<span class="line-added"> 538   record_concurrent_refinement_data(false /* is_full_collection */);</span>
 539 
 540   _collection_set-&gt;reset_bytes_used_before();

 541 
 542   // do that for any other surv rate groups
<span class="line-modified"> 543   _eden_surv_rate_group-&gt;stop_adding_regions();</span>
 544   _survivors_age_table.clear();
 545 
 546   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 547 }
 548 
 549 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 550   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 551   collector_state()-&gt;set_in_initial_mark_gc(false);
 552 }
 553 
 554 void G1Policy::record_concurrent_mark_remark_start() {
 555   _mark_remark_start_sec = os::elapsedTime();
 556 }
 557 
 558 void G1Policy::record_concurrent_mark_remark_end() {
 559   double end_time_sec = os::elapsedTime();
 560   double elapsed_time_ms = (end_time_sec - _mark_remark_start_sec)*1000.0;
 561   _analytics-&gt;report_concurrent_mark_remark_times_ms(elapsed_time_ms);
 562   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
 563 
</pre>
<hr />
<pre>
 570 
 571 double G1Policy::average_time_ms(G1GCPhaseTimes::GCParPhases phase) const {
 572   return phase_times()-&gt;average_time_ms(phase);
 573 }
 574 
 575 double G1Policy::young_other_time_ms() const {
 576   return phase_times()-&gt;young_cset_choice_time_ms() +
 577          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::YoungFreeCSet);
 578 }
 579 
 580 double G1Policy::non_young_other_time_ms() const {
 581   return phase_times()-&gt;non_young_cset_choice_time_ms() +
 582          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::NonYoungFreeCSet);
 583 }
 584 
 585 double G1Policy::other_time_ms(double pause_time_ms) const {
 586   return pause_time_ms - phase_times()-&gt;cur_collection_par_time_ms();
 587 }
 588 
 589 double G1Policy::constant_other_time_ms(double pause_time_ms) const {
<span class="line-modified"> 590   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms() - phase_times()-&gt;total_rebuild_freelist_time_ms();</span>
 591 }
 592 
 593 bool G1Policy::about_to_start_mixed_phase() const {
 594   return _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle() || collector_state()-&gt;in_young_gc_before_mixed();
 595 }
 596 
 597 bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
 598   if (about_to_start_mixed_phase()) {
 599     return false;
 600   }
 601 
 602   size_t marking_initiating_used_threshold = _ihop_control-&gt;get_conc_mark_start_threshold();
 603 
 604   size_t cur_used_bytes = _g1h-&gt;non_young_capacity_bytes();
 605   size_t alloc_byte_size = alloc_word_size * HeapWordSize;
 606   size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;
 607 
 608   bool result = false;
 609   if (marking_request_bytes &gt; marking_initiating_used_threshold) {
 610     result = collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;in_young_gc_before_mixed();
 611     log_debug(gc, ergo, ihop)(&quot;%s occupancy: &quot; SIZE_FORMAT &quot;B allocation request: &quot; SIZE_FORMAT &quot;B threshold: &quot; SIZE_FORMAT &quot;B (%1.2f) source: %s&quot;,
 612                               result ? &quot;Request concurrent cycle initiation (occupancy higher than threshold)&quot; : &quot;Do not request concurrent cycle initiation (still doing mixed collections)&quot;,
 613                               cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold / _g1h-&gt;capacity() * 100, source);
 614   }
 615 
 616   return result;
 617 }
 618 
<span class="line-added"> 619 double G1Policy::logged_cards_processing_time() const {</span>
<span class="line-added"> 620   double all_cards_processing_time = average_time_ms(G1GCPhaseTimes::ScanHR) + average_time_ms(G1GCPhaseTimes::OptScanHR);</span>
<span class="line-added"> 621   size_t logged_dirty_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="line-added"> 622   size_t scan_heap_roots_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +</span>
<span class="line-added"> 623                                  phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="line-added"> 624   // This may happen if there are duplicate cards in different log buffers.</span>
<span class="line-added"> 625   if (logged_dirty_cards &gt; scan_heap_roots_cards) {</span>
<span class="line-added"> 626     return all_cards_processing_time + average_time_ms(G1GCPhaseTimes::MergeLB);</span>
<span class="line-added"> 627   }</span>
<span class="line-added"> 628   return (all_cards_processing_time * logged_dirty_cards / scan_heap_roots_cards) + average_time_ms(G1GCPhaseTimes::MergeLB);</span>
<span class="line-added"> 629 }</span>
<span class="line-added"> 630 </span>
 631 // Anything below that is considered to be zero
 632 #define MIN_TIMER_GRANULARITY 0.0000001
 633 
<span class="line-modified"> 634 void G1Policy::record_collection_pause_end(double pause_time_ms) {</span>
<span class="line-added"> 635   G1GCPhaseTimes* p = phase_times();</span>
<span class="line-added"> 636 </span>
 637   double end_time_sec = os::elapsedTime();
 638 


 639   bool this_pause_included_initial_mark = false;
 640   bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();
 641 
 642   bool update_stats = !_g1h-&gt;evacuation_failed();
 643 
 644   record_pause(young_gc_pause_kind(), end_time_sec - pause_time_ms / 1000.0, end_time_sec);
 645 
 646   _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
 647 
 648   this_pause_included_initial_mark = collector_state()-&gt;in_initial_mark_gc();
 649   if (this_pause_included_initial_mark) {
 650     record_concurrent_mark_init_end(0.0);
 651   } else {
 652     maybe_start_marking();
 653   }
 654 
 655   double app_time_ms = (phase_times()-&gt;cur_collection_start_sec() * 1000.0 - _analytics-&gt;prev_collection_pause_end_ms());
 656   if (app_time_ms &lt; MIN_TIMER_GRANULARITY) {
 657     // This usually happens due to the timer not having the required
 658     // granularity. Some Linuxes are the usual culprits.
</pre>
<hr />
<pre>
 681 
 682   if (collector_state()-&gt;in_young_gc_before_mixed()) {
 683     assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
 684     // This has been the young GC before we start doing mixed GCs. We already
 685     // decided to start mixed GCs much earlier, so there is nothing to do except
 686     // advancing the state.
 687     collector_state()-&gt;set_in_young_only_phase(false);
 688     collector_state()-&gt;set_in_young_gc_before_mixed(false);
 689   } else if (!this_pause_was_young_only) {
 690     // This is a mixed GC. Here we decide whether to continue doing more
 691     // mixed GCs or not.
 692     if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
 693                                  &quot;do not continue mixed GCs&quot;)) {
 694       collector_state()-&gt;set_in_young_only_phase(true);
 695 
 696       clear_collection_set_candidates();
 697       maybe_start_marking();
 698     }
 699   }
 700 
<span class="line-modified"> 701   _eden_surv_rate_group-&gt;start_adding_regions();</span>



 702 
<span class="line-added"> 703   double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);</span>
 704   if (update_stats) {
<span class="line-modified"> 705     size_t const total_log_buffer_cards = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +</span>
<span class="line-modified"> 706                                           p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="line-modified"> 707     // Update prediction for card merge; MergeRSDirtyCards includes the cards from the Eager Reclaim phase.</span>
<span class="line-modified"> 708     size_t const total_cards_merged = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +</span>
<span class="line-added"> 709                                       p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +</span>
<span class="line-added"> 710                                       total_log_buffer_cards;</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712     // The threshold for the number of cards in a given sampling which we consider</span>
<span class="line-added"> 713     // large enough so that the impact from setup and other costs is negligible.</span>
<span class="line-added"> 714     size_t const CardsNumSamplingThreshold = 10;</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716     if (total_cards_merged &gt; CardsNumSamplingThreshold) {</span>
<span class="line-added"> 717       double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +</span>
<span class="line-added"> 718                                     average_time_ms(G1GCPhaseTimes::MergeRS) +</span>
<span class="line-added"> 719                                     average_time_ms(G1GCPhaseTimes::MergeHCC) +</span>
<span class="line-added"> 720                                     average_time_ms(G1GCPhaseTimes::MergeLB) +</span>
<span class="line-added"> 721                                     average_time_ms(G1GCPhaseTimes::OptMergeRS);</span>
<span class="line-added"> 722       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged, this_pause_was_young_only);</span>
 723     }

 724 
<span class="line-modified"> 725     // Update prediction for card scan</span>
<span class="line-modified"> 726     size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +</span>
<span class="line-modified"> 727                                        p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="line-modified"> 728 </span>
<span class="line-modified"> 729     if (total_cards_scanned &gt; CardsNumSamplingThreshold) {</span>
<span class="line-added"> 730       double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +</span>
<span class="line-added"> 731                                         average_time_ms(G1GCPhaseTimes::OptScanHR);</span>
 732 
<span class="line-modified"> 733       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned, this_pause_was_young_only);</span>



 734     }
 735 
<span class="line-modified"> 736     // Update prediction for the ratio between cards from the remembered</span>
<span class="line-modified"> 737     // sets and actually scanned cards from the remembered sets.</span>
<span class="line-modified"> 738     // Cards from the remembered sets are all cards not duplicated by cards from</span>
<span class="line-modified"> 739     // the logs.</span>
<span class="line-modified"> 740     // Due to duplicates in the log buffers, the number of actually scanned cards</span>
<span class="line-modified"> 741     // can be smaller than the cards in the log buffers.</span>
<span class="line-modified"> 742     const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;</span>
<span class="line-modified"> 743     double merge_to_scan_ratio = 0.0;</span>
<span class="line-modified"> 744     if (total_cards_scanned &gt; 0) {</span>
<span class="line-modified"> 745       merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;</span>







 746     }
<span class="line-modified"> 747     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio, this_pause_was_young_only);</span>
<span class="line-added"> 748 </span>
<span class="line-added"> 749     const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();</span>
<span class="line-added"> 750     const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;</span>
<span class="line-added"> 751     _analytics-&gt;report_rs_length_diff(rs_length_diff);</span>
 752 
<span class="line-modified"> 753     // Update prediction for copy cost per byte</span>
<span class="line-modified"> 754     size_t copied_bytes = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergePSS, G1GCPhaseTimes::MergePSSCopiedBytes);</span>

 755 
 756     if (copied_bytes &gt; 0) {
<span class="line-modified"> 757       double cost_per_byte_ms = (average_time_ms(G1GCPhaseTimes::ObjCopy) + average_time_ms(G1GCPhaseTimes::OptObjCopy)) / copied_bytes;</span>
 758       _analytics-&gt;report_cost_per_byte_ms(cost_per_byte_ms, collector_state()-&gt;mark_or_rebuild_in_progress());
 759     }
 760 
 761     if (_collection_set-&gt;young_region_length() &gt; 0) {
 762       _analytics-&gt;report_young_other_cost_per_region_ms(young_other_time_ms() /
 763                                                         _collection_set-&gt;young_region_length());
 764     }
 765 
 766     if (_collection_set-&gt;old_region_length() &gt; 0) {
 767       _analytics-&gt;report_non_young_other_cost_per_region_ms(non_young_other_time_ms() /
 768                                                             _collection_set-&gt;old_region_length());
 769     }
 770 
 771     _analytics-&gt;report_constant_other_time_ms(constant_other_time_ms(pause_time_ms));
 772 
 773     // Do not update RS lengths and the number of pending cards with information from mixed gc:
 774     // these are is wildly different to during young only gc and mess up young gen sizing right
 775     // after the mixed gc phase.
 776     // During mixed gc we do not use them for young gen sizing.
 777     if (this_pause_was_young_only) {
<span class="line-modified"> 778       _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);</span>
<span class="line-modified"> 779       _analytics-&gt;report_rs_length((double) _rs_length);</span>
 780     }
 781   }
 782 
 783   assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),
 784          &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);
 785   if (this_pause_included_initial_mark) {
 786     collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
 787   }
 788 
 789   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 790 
<span class="line-modified"> 791   update_rs_length_prediction();</span>
 792 
 793   // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
 794   // that in this case we are not running in a &quot;normal&quot; operating mode.
 795   if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
 796     // IHOP control wants to know the expected young gen length if it were not
 797     // restrained by the heap reserve. Using the actual length would make the
 798     // prediction too small and the limit the young gen every time we get to the
 799     // predicted target occupancy.
 800     size_t last_unrestrained_young_length = update_young_list_max_and_target_length();
 801 
 802     update_ihop_prediction(app_time_ms / 1000.0,
 803                            _bytes_allocated_in_old_since_last_gc,
 804                            last_unrestrained_young_length * HeapRegion::GrainBytes,
 805                            this_pause_was_young_only);
 806     _bytes_allocated_in_old_since_last_gc = 0;
 807 
 808     _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
 809   } else {
 810     // Any garbage collection triggered as periodic collection resets the time-to-mixed
 811     // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
 812     // the marking threads may have received an uncharacterisic amount of cpu time
 813     // for completing the marking, i.e. are faster than expected.
 814     // This skews the predicted marking length towards smaller values which might cause
 815     // the mark start being too late.
 816     _initial_mark_to_mixed.reset();
 817   }
 818 
 819   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
<span class="line-modified"> 820   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;</span>
 821 
<span class="line-modified"> 822   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {</span>
 823     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
<span class="line-modified"> 824                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,</span>
<span class="line-modified"> 825                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);</span>
 826 
<span class="line-modified"> 827     scan_logged_cards_time_goal_ms = 0;</span>
 828   } else {
<span class="line-modified"> 829     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;</span>
 830   }
<span class="line-modified"> 831 </span>
<span class="line-modified"> 832   _pending_cards_at_prev_gc_end = _g1h-&gt;pending_card_num();</span>
<span class="line-modified"> 833   double const logged_cards_time = logged_cards_processing_time();</span>
<span class="line-added"> 834 </span>
<span class="line-added"> 835   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,</span>
<span class="line-added"> 836                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,</span>
<span class="line-added"> 839                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),</span>
<span class="line-added"> 840                                     scan_logged_cards_time_goal_ms);</span>
 841 }
 842 
 843 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 844   if (G1UseAdaptiveIHOP) {
 845     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 846                                      predictor,
 847                                      G1ReservePercent,
 848                                      G1HeapWastePercent);
 849   } else {
 850     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 851   }
 852 }
 853 
 854 void G1Policy::update_ihop_prediction(double mutator_time_s,
 855                                       size_t mutator_alloc_bytes,
 856                                       size_t young_gen_size,
 857                                       bool this_gc_was_young_only) {
 858   // Always try to update IHOP prediction. Even evacuation failures give information
 859   // about e.g. whether to start IHOP earlier next time.
 860 
</pre>
<hr />
<pre>
 881   // marking, which makes any prediction useless. This increases the accuracy of the
 882   // prediction.
 883   if (this_gc_was_young_only &amp;&amp; mutator_time_s &gt; min_valid_time) {
 884     _ihop_control-&gt;update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
 885     report = true;
 886   }
 887 
 888   if (report) {
 889     report_ihop_statistics();
 890   }
 891 }
 892 
 893 void G1Policy::report_ihop_statistics() {
 894   _ihop_control-&gt;print();
 895 }
 896 
 897 void G1Policy::print_phases() {
 898   phase_times()-&gt;print();
 899 }
 900 














 901 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,
<span class="line-modified"> 902                                               size_t rs_length) const {</span>
<span class="line-added"> 903   size_t effective_scanned_cards = _analytics-&gt;predict_scan_card_num(rs_length, collector_state()-&gt;in_young_only_phase());</span>
 904   return
<span class="line-modified"> 905     _analytics-&gt;predict_card_merge_time_ms(pending_cards + rs_length, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="line-modified"> 906     _analytics-&gt;predict_card_scan_time_ms(effective_scanned_cards, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="line-modified"> 907     _analytics-&gt;predict_constant_other_time_ms() +</span>
<span class="line-added"> 908     predict_survivor_regions_evac_time();</span>
 909 }
 910 
 911 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
<span class="line-modified"> 912   size_t rs_length = _analytics-&gt;predict_rs_length();</span>
<span class="line-modified"> 913   return predict_base_elapsed_time_ms(pending_cards, rs_length);</span>

 914 }
 915 
 916 size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {
 917   size_t bytes_to_copy;
 918   if (!hr-&gt;is_young()) {
 919     bytes_to_copy = hr-&gt;max_live_bytes();
 920   } else {
<span class="line-modified"> 921     bytes_to_copy = (size_t) (hr-&gt;used() * hr-&gt;surv_rate_prediction(_predictor));</span>



 922   }
 923   return bytes_to_copy;
 924 }
 925 
<span class="line-modified"> 926 double G1Policy::predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy) const {</span>
<span class="line-modified"> 927   if (count == 0) {</span>
<span class="line-added"> 928     return 0.0;</span>
<span class="line-added"> 929   }</span>
<span class="line-added"> 930   size_t const expected_bytes = _eden_surv_rate_group-&gt;accum_surv_rate_pred(count) * HeapRegion::GrainBytes;</span>
<span class="line-added"> 931   if (bytes_to_copy != NULL) {</span>
<span class="line-added"> 932     *bytes_to_copy = expected_bytes;</span>
<span class="line-added"> 933   }</span>
<span class="line-added"> 934   return _analytics-&gt;predict_object_copy_time_ms(expected_bytes, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
<span class="line-added"> 935 }</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937 double G1Policy::predict_region_copy_time_ms(HeapRegion* hr) const {</span>
<span class="line-added"> 938   size_t const bytes_to_copy = predict_bytes_to_copy(hr);</span>
<span class="line-added"> 939   return _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());</span>
<span class="line-added"> 940 }</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942 double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,</span>
<span class="line-added"> 943                                                  bool for_young_gc) const {</span>
 944   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified"> 945   size_t scan_card_num = _analytics-&gt;predict_scan_card_num(rs_length, for_young_gc);</span>



 946 
 947   double region_elapsed_time_ms =
<span class="line-modified"> 948     _analytics-&gt;predict_card_merge_time_ms(rs_length, collector_state()-&gt;in_young_only_phase()) +</span>
<span class="line-modified"> 949     _analytics-&gt;predict_card_scan_time_ms(scan_card_num, collector_state()-&gt;in_young_only_phase());</span>
 950 
 951   // The prediction of the &quot;other&quot; time for this region is based
 952   // upon the region type and NOT the GC type.
 953   if (hr-&gt;is_young()) {
 954     region_elapsed_time_ms += _analytics-&gt;predict_young_other_time_ms(1);
 955   } else {
 956     region_elapsed_time_ms += _analytics-&gt;predict_non_young_other_time_ms(1);
 957   }
 958   return region_elapsed_time_ms;
 959 }
 960 
<span class="line-added"> 961 double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const {</span>
<span class="line-added"> 962   return predict_region_non_copy_time_ms(hr, for_young_gc) + predict_region_copy_time_ms(hr);</span>
<span class="line-added"> 963 }</span>
<span class="line-added"> 964 </span>
 965 bool G1Policy::should_allocate_mutator_region() const {
 966   uint young_list_length = _g1h-&gt;young_regions_count();
 967   uint young_list_target_length = _young_list_target_length;
 968   return young_list_length &lt; young_list_target_length;
 969 }
 970 
 971 bool G1Policy::can_expand_young_list() const {
 972   uint young_list_length = _g1h-&gt;young_regions_count();
 973   uint young_list_max_length = _young_list_max_length;
 974   return young_list_length &lt; young_list_max_length;
 975 }
 976 
<span class="line-modified"> 977 bool G1Policy::use_adaptive_young_list_length() const {</span>
<span class="line-modified"> 978   return _young_gen_sizer-&gt;use_adaptive_young_list_length();</span>
 979 }
 980 
 981 size_t G1Policy::desired_survivor_size(uint max_regions) const {
 982   size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;
 983   return (size_t)((((double)survivor_capacity) * TargetSurvivorRatio) / 100);
 984 }
 985 
 986 void G1Policy::print_age_table() {
 987   _survivors_age_table.print_age_table(_tenuring_threshold);
 988 }
 989 
 990 void G1Policy::update_max_gc_locker_expansion() {
 991   uint expansion_region_num = 0;
 992   if (GCLockerEdenExpansionPercent &gt; 0) {
 993     double perc = (double) GCLockerEdenExpansionPercent / 100.0;
 994     double expansion_region_num_d = perc * (double) _young_list_target_length;
 995     // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
 996     // less than 1.0) we&#39;ll get 1.
 997     expansion_region_num = (uint) ceil(expansion_region_num_d);
 998   } else {
</pre>
<hr />
<pre>
1239   return (uint) result;
1240 }
1241 
1242 uint G1Policy::calc_max_old_cset_length() const {
1243   // The max old CSet region bound is based on the threshold expressed
1244   // as a percentage of the heap size. I.e., it should bound the
1245   // number of old regions added to the CSet irrespective of how many
1246   // of them are available.
1247 
1248   const G1CollectedHeap* g1h = G1CollectedHeap::heap();
1249   const size_t region_num = g1h-&gt;num_regions();
1250   const size_t perc = (size_t) G1OldCSetRegionThresholdPercent;
1251   size_t result = region_num * perc / 100;
1252   // emulate ceiling
1253   if (100 * result &lt; region_num * perc) {
1254     result += 1;
1255   }
1256   return (uint) result;
1257 }
1258 
<span class="line-modified">1259 void G1Policy::calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="line-modified">1260                                                     double time_remaining_ms,</span>
<span class="line-modified">1261                                                     uint&amp; num_initial_regions,</span>
<span class="line-added">1262                                                     uint&amp; num_optional_regions) {</span>
<span class="line-added">1263   assert(candidates != NULL, &quot;Must be&quot;);</span>
<span class="line-added">1264 </span>
<span class="line-added">1265   num_initial_regions = 0;</span>
<span class="line-added">1266   num_optional_regions = 0;</span>
<span class="line-added">1267   uint num_expensive_regions = 0;</span>
<span class="line-added">1268 </span>
<span class="line-added">1269   double predicted_old_time_ms = 0.0;</span>
<span class="line-added">1270   double predicted_initial_time_ms = 0.0;</span>
<span class="line-added">1271   double predicted_optional_time_ms = 0.0;</span>
<span class="line-added">1272 </span>
<span class="line-added">1273   double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();</span>
<span class="line-added">1274 </span>
<span class="line-added">1275   const uint min_old_cset_length = calc_min_old_cset_length();</span>
<span class="line-added">1276   const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());</span>
<span class="line-added">1277   const uint max_optional_regions = max_old_cset_length - min_old_cset_length;</span>
<span class="line-added">1278   bool check_time_remaining = use_adaptive_young_list_length();</span>
<span class="line-added">1279 </span>
<span class="line-added">1280   uint candidate_idx = candidates-&gt;cur_idx();</span>
<span class="line-added">1281 </span>
<span class="line-added">1282   log_debug(gc, ergo, cset)(&quot;Start adding old regions to collection set. Min %u regions, max %u regions, &quot;</span>
<span class="line-added">1283                             &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,</span>
<span class="line-added">1284                             min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);</span>
<span class="line-added">1285 </span>
<span class="line-added">1286   HeapRegion* hr = candidates-&gt;at(candidate_idx);</span>
<span class="line-added">1287   while (hr != NULL) {</span>
<span class="line-added">1288     if (num_initial_regions + num_optional_regions &gt;= max_old_cset_length) {</span>
<span class="line-added">1289       // Added maximum number of old regions to the CSet.</span>
<span class="line-added">1290       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Maximum number of regions). &quot;</span>
<span class="line-added">1291                                 &quot;Initial %u regions, optional %u regions&quot;,</span>
<span class="line-added">1292                                 num_initial_regions, num_optional_regions);</span>
<span class="line-added">1293       break;</span>
<span class="line-added">1294     }</span>
<span class="line-added">1295 </span>
<span class="line-added">1296     // Stop adding regions if the remaining reclaimable space is</span>
<span class="line-added">1297     // not above G1HeapWastePercent.</span>
<span class="line-added">1298     size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();</span>
<span class="line-added">1299     double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);</span>
<span class="line-added">1300     double threshold = (double) G1HeapWastePercent;</span>
<span class="line-added">1301     if (reclaimable_percent &lt;= threshold) {</span>
<span class="line-added">1302       // We&#39;ve added enough old regions that the amount of uncollected</span>
<span class="line-added">1303       // reclaimable space is at or below the waste threshold. Stop</span>
<span class="line-added">1304       // adding old regions to the CSet.</span>
<span class="line-added">1305       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Reclaimable percentage below threshold). &quot;</span>
<span class="line-added">1306                                 &quot;Reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,</span>
<span class="line-added">1307                                 byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),</span>
<span class="line-added">1308                                 reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-added">1309       break;</span>
<span class="line-added">1310     }</span>
<span class="line-added">1311 </span>
<span class="line-added">1312     double predicted_time_ms = predict_region_total_time_ms(hr, false);</span>
<span class="line-added">1313     time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);</span>
<span class="line-added">1314     // Add regions to old set until we reach the minimum amount</span>
<span class="line-added">1315     if (num_initial_regions &lt; min_old_cset_length) {</span>
<span class="line-added">1316       predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-added">1317       num_initial_regions++;</span>
<span class="line-added">1318       // Record the number of regions added with no time remaining</span>
<span class="line-added">1319       if (time_remaining_ms == 0.0) {</span>
<span class="line-added">1320         num_expensive_regions++;</span>
<span class="line-added">1321       }</span>
<span class="line-added">1322     } else if (!check_time_remaining) {</span>
<span class="line-added">1323       // In the non-auto-tuning case, we&#39;ll finish adding regions</span>
<span class="line-added">1324       // to the CSet if we reach the minimum.</span>
<span class="line-added">1325       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Region amount reached min).&quot;);</span>
<span class="line-added">1326       break;</span>
<span class="line-added">1327     } else {</span>
<span class="line-added">1328       // Keep adding regions to old set until we reach the optional threshold</span>
<span class="line-added">1329       if (time_remaining_ms &gt; optional_threshold_ms) {</span>
<span class="line-added">1330         predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-added">1331         num_initial_regions++;</span>
<span class="line-added">1332       } else if (time_remaining_ms &gt; 0) {</span>
<span class="line-added">1333         // Keep adding optional regions until time is up.</span>
<span class="line-added">1334         assert(num_optional_regions &lt; max_optional_regions, &quot;Should not be possible.&quot;);</span>
<span class="line-added">1335         predicted_optional_time_ms += predicted_time_ms;</span>
<span class="line-added">1336         num_optional_regions++;</span>
<span class="line-added">1337       } else {</span>
<span class="line-added">1338         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Predicted time too high).&quot;);</span>
<span class="line-added">1339         break;</span>
<span class="line-added">1340       }</span>
<span class="line-added">1341     }</span>
<span class="line-added">1342     hr = candidates-&gt;at(++candidate_idx);</span>
<span class="line-added">1343   }</span>
<span class="line-added">1344   if (hr == NULL) {</span>
<span class="line-added">1345     log_debug(gc, ergo, cset)(&quot;Old candidate collection set empty.&quot;);</span>
<span class="line-added">1346   }</span>
<span class="line-added">1347 </span>
<span class="line-added">1348   if (num_expensive_regions &gt; 0) {</span>
<span class="line-added">1349     log_debug(gc, ergo, cset)(&quot;Added %u initial old regions to collection set although the predicted time was too high.&quot;,</span>
<span class="line-added">1350                               num_expensive_regions);</span>
<span class="line-added">1351   }</span>
<span class="line-added">1352 </span>
<span class="line-added">1353   log_debug(gc, ergo, cset)(&quot;Finish choosing collection set old regions. Initial: %u, optional: %u, &quot;</span>
<span class="line-added">1354                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,</span>
<span class="line-added">1355                             num_initial_regions, num_optional_regions,</span>
<span class="line-added">1356                             predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);</span>
<span class="line-added">1357 }</span>
<span class="line-added">1358 </span>
<span class="line-added">1359 void G1Policy::calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="line-added">1360                                                          uint const max_optional_regions,</span>
<span class="line-added">1361                                                          double time_remaining_ms,</span>
<span class="line-added">1362                                                          uint&amp; num_optional_regions) {</span>
<span class="line-added">1363   assert(_g1h-&gt;collector_state()-&gt;in_mixed_phase(), &quot;Should only be called in mixed phase&quot;);</span>
<span class="line-added">1364 </span>
<span class="line-added">1365   num_optional_regions = 0;</span>
<span class="line-added">1366   double prediction_ms = 0;</span>
<span class="line-added">1367   uint candidate_idx = candidates-&gt;cur_idx();</span>
<span class="line-added">1368 </span>
<span class="line-added">1369   HeapRegion* r = candidates-&gt;at(candidate_idx);</span>
<span class="line-added">1370   while (num_optional_regions &lt; max_optional_regions) {</span>
<span class="line-added">1371     assert(r != NULL, &quot;Region must exist&quot;);</span>
<span class="line-added">1372     prediction_ms += predict_region_total_time_ms(r, false);</span>
<span class="line-added">1373 </span>
<span class="line-added">1374     if (prediction_ms &gt; time_remaining_ms) {</span>
<span class="line-added">1375       log_debug(gc, ergo, cset)(&quot;Prediction %.3fms for region %u does not fit remaining time: %.3fms.&quot;,</span>
<span class="line-added">1376                                 prediction_ms, r-&gt;hrm_index(), time_remaining_ms);</span>
<span class="line-added">1377       break;</span>
<span class="line-added">1378     }</span>
<span class="line-added">1379     // This region will be included in the next optional evacuation.</span>
<span class="line-added">1380 </span>
<span class="line-added">1381     time_remaining_ms -= prediction_ms;</span>
<span class="line-added">1382     num_optional_regions++;</span>
<span class="line-added">1383     r = candidates-&gt;at(++candidate_idx);</span>
<span class="line-added">1384   }</span>
<span class="line-added">1385 </span>
<span class="line-added">1386   log_debug(gc, ergo, cset)(&quot;Prepared %u regions out of %u for optional evacuation. Predicted time: %.3fms&quot;,</span>
<span class="line-added">1387                             num_optional_regions, max_optional_regions, prediction_ms);</span>
1388 }
1389 
1390 void G1Policy::transfer_survivors_to_cset(const G1SurvivorRegions* survivors) {


1391   note_start_adding_survivor_regions();

1392 
1393   HeapRegion* last = NULL;
1394   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivors-&gt;regions()-&gt;begin();
1395        it != survivors-&gt;regions()-&gt;end();
1396        ++it) {
1397     HeapRegion* curr = *it;
1398     set_region_survivor(curr);
1399 
1400     // The region is a non-empty survivor so let&#39;s add it to
1401     // the incremental collection set for the next evacuation
1402     // pause.
1403     _collection_set-&gt;add_survivor_regions(curr);
1404 
1405     last = curr;
1406   }
1407   note_stop_adding_survivor_regions();
1408 
1409   // Don&#39;t clear the survivor list handles until the start of
1410   // the next evacuation pause - we need it in order to re-tag
1411   // the survivor regions from this evacuation pause as &#39;young&#39;
1412   // at the start of the next.


1413 }
</pre>
</td>
</tr>
</table>
<center><a href="g1ParScanThreadState.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/sparsePRT.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="sparsePRT.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_g1.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/sparsePRT.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,19 +31,67 @@</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
<span class="udiff-line-added">+ class RSHashTable;</span>
<span class="udiff-line-added">+ class SparsePRTEntry;</span>
<span class="udiff-line-added">+ class SparsePRTIter;</span>
<span class="udiff-line-added">+ </span>
  // Sparse remembered set for a heap region (the &quot;owning&quot; region).  Maps
  // indices of other regions to short sequences of cards in the other region
  // that might contain pointers into the owner region.
<span class="udiff-line-added">+ // Concurrent access to a SparsePRT must be serialized by some external mutex.</span>
<span class="udiff-line-added">+ class SparsePRT {</span>
<span class="udiff-line-added">+   friend class SparsePRTIter;</span>
<span class="udiff-line-added">+   friend class SparsePRTBucketIter;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   RSHashTable* _table;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static const size_t InitialCapacity = 8;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void expand();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   SparsePRT();</span>
<span class="udiff-line-added">+   ~SparsePRT();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t mem_size() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   enum AddCardResult {</span>
<span class="udiff-line-added">+     overflow, // The table is full, could not add the card to the table.</span>
<span class="udiff-line-added">+     found,    // The card is already in the PRT.</span>
<span class="udiff-line-added">+     added     // The card has been added.</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Attempts to ensure that the given card_index in the given region is in</span>
<span class="udiff-line-added">+   // the sparse table.  If successful (because the card was already</span>
<span class="udiff-line-added">+   // present, or because it was successfully added) returns &quot;true&quot;.</span>
<span class="udiff-line-added">+   // Otherwise, returns &quot;false&quot; to indicate that the addition would</span>
<span class="udiff-line-added">+   // overflow the entry for the region.  The caller must transfer these</span>
<span class="udiff-line-added">+   // entries to a larger-capacity representation.</span>
<span class="udiff-line-added">+   AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Return the pointer to the entry associated with the given region.</span>
<span class="udiff-line-added">+   SparsePRTEntry* get_entry(RegionIdx_t region_ind);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // If there is an entry for &quot;region_ind&quot;, removes it and return &quot;true&quot;;</span>
<span class="udiff-line-added">+   // otherwise returns &quot;false.&quot;</span>
<span class="udiff-line-added">+   bool delete_entry(RegionIdx_t region_ind);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Clear the table, and reinitialize to initial capacity.</span>
<span class="udiff-line-added">+   void clear();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;</span>
<span class="udiff-line-added">+ };</span>
  
  class SparsePRTEntry: public CHeapObj&lt;mtGC&gt; {
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-added">+ public:</span>
    // The type of a card entry.
    typedef uint16_t card_elem_t;
  
<span class="udiff-line-added">+ private:</span>
    // We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,
    // in order to force correct alignment that could otherwise cause SIGBUS errors
    // when reading the member variables. This calculates the minimum number of card
    // array elements required to get that alignment.
    static const size_t card_array_alignment = sizeof(int) / sizeof(card_elem_t);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,34 +129,28 @@</span>
    inline bool contains_card(CardIdx_t card_index) const;
  
    // Returns the number of non-NULL card entries.
    inline int num_valid_cards() const { return _next_null; }
  
<span class="udiff-line-modified-removed">-   // Requires that the entry not contain the given card index.  If there is</span>
<span class="udiff-line-removed">-   // space available, add the given card index to the entry and return</span>
<span class="udiff-line-removed">-   // &quot;true&quot;; otherwise, return &quot;false&quot; to indicate that the entry is full.</span>
<span class="udiff-line-removed">-   enum AddCardResult {</span>
<span class="udiff-line-removed">-     overflow,</span>
<span class="udiff-line-removed">-     found,</span>
<span class="udiff-line-removed">-     added</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">-   inline AddCardResult add_card(CardIdx_t card_index);</span>
<span class="udiff-line-modified-added">+   inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);</span>
  
    // Copy the current entry&#39;s cards into the &quot;_card&quot; array of &quot;e.&quot;
    inline void copy_cards(SparsePRTEntry* e) const;
  
<span class="udiff-line-added">+   card_elem_t* cards() { return _cards; }</span>
<span class="udiff-line-added">+ </span>
    inline CardIdx_t card(int i) const {
      assert(i &gt;= 0, &quot;must be nonnegative&quot;);
      assert(i &lt; cards_num(), &quot;range checking&quot;);
      return (CardIdx_t)_cards[i];
    }
  };
  
  class RSHashTable : public CHeapObj&lt;mtGC&gt; {
  
    friend class RSHashTableIter;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   friend class RSHashTableBucketIter;</span>
  
    // Inverse maximum hash table occupancy used.
    static float TableOccupancyFactor;
  
    size_t _num_entries;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,11 +190,11 @@</span>
    // the sparse table.  If successful (because the card was already
    // present, or because it was successfully added) returns &quot;true&quot;.
    // Otherwise, returns &quot;false&quot; to indicate that the addition would
    // overflow the entry for the region.  The caller must transfer these
    // entries to a larger-capacity representation.
<span class="udiff-line-modified-removed">-   bool add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
<span class="udiff-line-modified-added">+   SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
  
    bool delete_entry(RegionIdx_t region_id);
  
    bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163,11 +205,10 @@</span>
    void clear();
  
    size_t capacity() const      { return _capacity; }
    size_t capacity_mask() const { return _capacity_mask;  }
    size_t occupied_entries() const { return _occupied_entries; }
<span class="udiff-line-removed">-   size_t occupied_cards() const   { return _occupied_cards; }</span>
    size_t mem_size() const;
    // The number of SparsePRTEntry instances available.
    size_t num_entries() const { return _num_entries; }
  
    SparsePRTEntry* entry(int i) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,53 +248,24 @@</span>
      _rsht(rsht) {}
  
    bool has_next(size_t&amp; card_index);
  };
  
<span class="udiff-line-modified-removed">- // Concurrent access to a SparsePRT must be serialized by some external mutex.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- class SparsePRTIter;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- class SparsePRT {</span>
<span class="udiff-line-removed">-   friend class SparsePRTIter;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   RSHashTable* _table;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   enum SomeAdditionalPrivateConstants {</span>
<span class="udiff-line-removed">-     InitialCapacity = 16</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-modified-added">+ // This is embedded in HRRS iterator.</span>
<span class="udiff-line-modified-added">+ class RSHashTableBucketIter {</span>
<span class="udiff-line-modified-added">+   int _tbl_ind;         // [-1, 0.._rsht-&gt;_capacity)</span>
<span class="udiff-line-modified-added">+   int _bl_ind;          // [-1, 0.._rsht-&gt;_capacity)</span>
  
<span class="udiff-line-modified-removed">-   void expand();</span>
<span class="udiff-line-modified-added">+   RSHashTable* _rsht;</span>
  
  public:
<span class="udiff-line-modified-removed">-   SparsePRT();</span>
<span class="udiff-line-modified-removed">-   ~SparsePRT();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   size_t occupied() const { return _table-&gt;occupied_cards(); }</span>
<span class="udiff-line-removed">-   size_t mem_size() const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Attempts to ensure that the given card_index in the given region is in</span>
<span class="udiff-line-removed">-   // the sparse table.  If successful (because the card was already</span>
<span class="udiff-line-removed">-   // present, or because it was successfully added) returns &quot;true&quot;.</span>
<span class="udiff-line-removed">-   // Otherwise, returns &quot;false&quot; to indicate that the addition would</span>
<span class="udiff-line-removed">-   // overflow the entry for the region.  The caller must transfer these</span>
<span class="udiff-line-removed">-   // entries to a larger-capacity representation.</span>
<span class="udiff-line-removed">-   bool add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Return the pointer to the entry associated with the given region.</span>
<span class="udiff-line-removed">-   SparsePRTEntry* get_entry(RegionIdx_t region_ind);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If there is an entry for &quot;region_ind&quot;, removes it and return &quot;true&quot;;</span>
<span class="udiff-line-removed">-   // otherwise returns &quot;false.&quot;</span>
<span class="udiff-line-removed">-   bool delete_entry(RegionIdx_t region_ind);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Clear the table, and reinitialize to initial capacity.</span>
<span class="udiff-line-removed">-   void clear();</span>
<span class="udiff-line-modified-added">+   RSHashTableBucketIter(RSHashTable* rsht) :</span>
<span class="udiff-line-modified-added">+     _tbl_ind(0),</span>
<span class="udiff-line-modified-added">+     _bl_ind(rsht-&gt;_buckets[_tbl_ind]),</span>
<span class="udiff-line-modified-added">+     _rsht(rsht) { }</span>
  
<span class="udiff-line-modified-removed">-   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {</span>
<span class="udiff-line-removed">-     return _table-&gt;contains_card(region_id, card_index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   bool has_next(SparsePRTEntry*&amp; entry);</span>
  };
  
  class SparsePRTIter: public RSHashTableIter {
  public:
    SparsePRTIter(const SparsePRT* sprt) :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,6 +274,16 @@</span>
    bool has_next(size_t&amp; card_index) {
      return RSHashTableIter::has_next(card_index);
    }
  };
  
<span class="udiff-line-added">+ class SparsePRTBucketIter: public RSHashTableBucketIter {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   SparsePRTBucketIter(const SparsePRT* sprt) :</span>
<span class="udiff-line-added">+     RSHashTableBucketIter(sprt-&gt;_table) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool has_next(SparsePRTEntry*&amp; entry) {</span>
<span class="udiff-line-added">+     return RSHashTableBucketIter::has_next(entry);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  #endif // SHARE_GC_G1_SPARSEPRT_HPP
</pre>
<center><a href="sparsePRT.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_g1.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
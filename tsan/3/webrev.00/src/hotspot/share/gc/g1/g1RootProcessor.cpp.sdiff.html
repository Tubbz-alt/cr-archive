<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1RootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RootClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1RootProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;aot/aotLoader.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 32 #include &quot;gc/g1/g1CodeBlobClosure.hpp&quot;
 33 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 34 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 35 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
 36 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 37 #include &quot;gc/g1/g1Policy.hpp&quot;
 38 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 39 #include &quot;gc/g1/g1RootProcessor.hpp&quot;
 40 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
<span class="line-removed"> 41 #include &quot;gc/shared/oopStorageParState.hpp&quot;</span>
 42 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 43 #include &quot;memory/allocation.inline.hpp&quot;

 44 #include &quot;runtime/mutex.hpp&quot;
 45 #include &quot;services/management.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
<span class="line-removed"> 48 void G1RootProcessor::worker_has_discovered_all_strong_classes() {</span>
<span class="line-removed"> 49   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   uint new_value = (uint)Atomic::add(1, &amp;_n_workers_discovered_strong_classes);</span>
<span class="line-removed"> 52   if (new_value == n_workers()) {</span>
<span class="line-removed"> 53     // This thread is last. Notify the others.</span>
<span class="line-removed"> 54     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 55     _lock.notify_all();</span>
<span class="line-removed"> 56   }</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
<span class="line-removed"> 59 void G1RootProcessor::wait_until_all_strong_classes_discovered() {</span>
<span class="line-removed"> 60   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62   if ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="line-removed"> 63     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 64     while ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="line-removed"> 65       _lock.wait(Mutex::_no_safepoint_check_flag, 0, false);</span>
<span class="line-removed"> 66     }</span>
<span class="line-removed"> 67   }</span>
<span class="line-removed"> 68 }</span>
<span class="line-removed"> 69 </span>
 70 G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :
 71     _g1h(g1h),
 72     _process_strong_tasks(G1RP_PS_NumElements),
<span class="line-modified"> 73     _srs(n_workers),</span>
<span class="line-removed"> 74     _par_state_string(StringTable::weak_storage()),</span>
<span class="line-removed"> 75     _lock(Mutex::leaf, &quot;G1 Root Scanning barrier lock&quot;, false, Monitor::_safepoint_check_never),</span>
<span class="line-removed"> 76     _n_workers_discovered_strong_classes(0) {}</span>
 77 
<span class="line-modified"> 78 void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_i) {</span>
 79   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
 80 
<span class="line-modified"> 81   G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_i);</span>
 82 
 83   G1EvacuationRootClosures* closures = pss-&gt;closures();
<span class="line-modified"> 84   process_java_roots(closures, phase_times, worker_i);</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86   // This is the point where this worker thread will not find more strong CLDs/nmethods.</span>
<span class="line-removed"> 87   // Report this so G1 can synchronize the strong and weak CLDs/nmethods processing.</span>
<span class="line-removed"> 88   if (closures-&gt;trace_metadata()) {</span>
<span class="line-removed"> 89     worker_has_discovered_all_strong_classes();</span>
<span class="line-removed"> 90   }</span>
 91 
<span class="line-modified"> 92   process_vm_roots(closures, phase_times, worker_i);</span>
 93 
 94   {
 95     // Now the CM ref_processor roots.
<span class="line-modified"> 96     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CMRefRoots, worker_i);</span>
 97     if (_process_strong_tasks.try_claim_task(G1RP_PS_refProcessor_oops_do)) {
 98       // We need to treat the discovered reference lists of the
 99       // concurrent mark ref processor as roots and keep entries
100       // (which are added by the marking threads) on them live
101       // until they can be processed at the end of marking.
102       _g1h-&gt;ref_processor_cm()-&gt;weak_oops_do(closures-&gt;strong_oops());
103     }
104   }
105 
<span class="line-removed">106   if (closures-&gt;trace_metadata()) {</span>
<span class="line-removed">107     {</span>
<span class="line-removed">108       G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WaitForStrongCLD, worker_i);</span>
<span class="line-removed">109       // Barrier to make sure all workers passed</span>
<span class="line-removed">110       // the strong CLD and strong nmethods phases.</span>
<span class="line-removed">111       wait_until_all_strong_classes_discovered();</span>
<span class="line-removed">112     }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114     // Now take the complement of the strong CLDs.</span>
<span class="line-removed">115     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WeakCLDRoots, worker_i);</span>
<span class="line-removed">116     assert(closures-&gt;second_pass_weak_clds() != NULL, &quot;Should be non-null if we are tracing metadata.&quot;);</span>
<span class="line-removed">117     ClassLoaderDataGraph::roots_cld_do(NULL, closures-&gt;second_pass_weak_clds());</span>
<span class="line-removed">118   } else {</span>
<span class="line-removed">119     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WaitForStrongCLD, worker_i, 0.0);</span>
<span class="line-removed">120     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WeakCLDRoots, worker_i, 0.0);</span>
<span class="line-removed">121     assert(closures-&gt;second_pass_weak_clds() == NULL, &quot;Should be null if not tracing metadata.&quot;);</span>
<span class="line-removed">122   }</span>
<span class="line-removed">123 </span>
<span class="line-removed">124   // During conc marking we have to filter the per-thread SATB buffers</span>
<span class="line-removed">125   // to make sure we remove any oops into the CSet (which will show up</span>
<span class="line-removed">126   // as implicitly live).</span>
<span class="line-removed">127   {</span>
<span class="line-removed">128     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SATBFiltering, worker_i);</span>
<span class="line-removed">129     if (_process_strong_tasks.try_claim_task(G1RP_PS_filter_satb_buffers) &amp;&amp; _g1h-&gt;collector_state()-&gt;mark_or_rebuild_in_progress()) {</span>
<span class="line-removed">130       G1BarrierSet::satb_mark_queue_set().filter_thread_buffers();</span>
<span class="line-removed">131     }</span>
<span class="line-removed">132   }</span>
<span class="line-removed">133 </span>
134   _process_strong_tasks.all_tasks_completed(n_workers());
135 }
136 
137 // Adaptor to pass the closures to the strong roots in the VM.
138 class StrongRootsClosures : public G1RootClosures {
139   OopClosure* _roots;
140   CLDClosure* _clds;
141   CodeBlobClosure* _blobs;
142 public:
143   StrongRootsClosures(OopClosure* roots, CLDClosure* clds, CodeBlobClosure* blobs) :
144       _roots(roots), _clds(clds), _blobs(blobs) {}
145 
146   OopClosure* weak_oops()   { return NULL; }
147   OopClosure* strong_oops() { return _roots; }
148 
149   CLDClosure* weak_clds()        { return NULL; }
150   CLDClosure* strong_clds()      { return _clds; }
151 
152   CodeBlobClosure* strong_codeblobs() { return _blobs; }
153 };
</pre>
<hr />
<pre>
183   // We don&#39;t want to visit code blobs more than once, so we return NULL for the
184   // strong case and walk the entire code cache as a separate step.
185   CodeBlobClosure* strong_codeblobs() { return NULL; }
186 };
187 
188 void G1RootProcessor::process_all_roots(OopClosure* oops,
189                                         CLDClosure* clds,
190                                         CodeBlobClosure* blobs) {
191   AllRootsClosures closures(oops, clds);
192 
193   process_java_roots(&amp;closures, NULL, 0);
194   process_vm_roots(&amp;closures, NULL, 0);
195 
196   process_code_cache_roots(blobs, NULL, 0);
197 
198   _process_strong_tasks.all_tasks_completed(n_workers());
199 }
200 
201 void G1RootProcessor::process_java_roots(G1RootClosures* closures,
202                                          G1GCPhaseTimes* phase_times,
<span class="line-modified">203                                          uint worker_i) {</span>
<span class="line-modified">204   // Iterating over the CLDG and the Threads are done early to allow us to</span>
<span class="line-modified">205   // first process the strong CLDs and nmethods and then, after a barrier,</span>
<span class="line-modified">206   // let the thread process the weak CLDs and nmethods.</span>













207   {
<span class="line-modified">208     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_i);</span>
<span class="line-removed">209     if (_process_strong_tasks.try_claim_task(G1RP_PS_ClassLoaderDataGraph_oops_do)) {</span>
<span class="line-removed">210       ClassLoaderDataGraph::roots_cld_do(closures-&gt;strong_clds(), closures-&gt;weak_clds());</span>
<span class="line-removed">211     }</span>
<span class="line-removed">212   }</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   {</span>
<span class="line-removed">215     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_i);</span>
216     bool is_par = n_workers() &gt; 1;
217     Threads::possibly_parallel_oops_do(is_par,
218                                        closures-&gt;strong_oops(),
219                                        closures-&gt;strong_codeblobs());
220   }







221 }
222 
223 void G1RootProcessor::process_vm_roots(G1RootClosures* closures,
224                                        G1GCPhaseTimes* phase_times,
<span class="line-modified">225                                        uint worker_i) {</span>
226   OopClosure* strong_roots = closures-&gt;strong_oops();
227 
228   {
<span class="line-modified">229     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_i);</span>
230     if (_process_strong_tasks.try_claim_task(G1RP_PS_Universe_oops_do)) {
231       Universe::oops_do(strong_roots);
232     }
233   }
234 
235   {
<span class="line-modified">236     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_i);</span>
237     if (_process_strong_tasks.try_claim_task(G1RP_PS_JNIHandles_oops_do)) {
238       JNIHandles::oops_do(strong_roots);
239     }
240   }
241 
242   {
<span class="line-modified">243     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_i);</span>
244     if (_process_strong_tasks.try_claim_task(G1RP_PS_ObjectSynchronizer_oops_do)) {
245       ObjectSynchronizer::oops_do(strong_roots);
246     }
247   }
248 
249   {
<span class="line-modified">250     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_i);</span>
251     if (_process_strong_tasks.try_claim_task(G1RP_PS_Management_oops_do)) {
252       Management::oops_do(strong_roots);
253     }
254   }
255 
256   {
<span class="line-modified">257     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_i);</span>
258     if (_process_strong_tasks.try_claim_task(G1RP_PS_jvmti_oops_do)) {
259       JvmtiExport::oops_do(strong_roots);
260     }
261   }
262 
263 #if INCLUDE_AOT
264   if (UseAOT) {
<span class="line-modified">265     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_i);</span>
266     if (_process_strong_tasks.try_claim_task(G1RP_PS_aot_oops_do)) {
267         AOTLoader::oops_do(strong_roots);
268     }
269   }
270 #endif
271 
272   {
<span class="line-modified">273     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_i);</span>
274     if (_process_strong_tasks.try_claim_task(G1RP_PS_SystemDictionary_oops_do)) {
275       SystemDictionary::oops_do(strong_roots);
276     }
277   }
278 }
279 
280 void G1RootProcessor::process_code_cache_roots(CodeBlobClosure* code_closure,
281                                                G1GCPhaseTimes* phase_times,
<span class="line-modified">282                                                uint worker_i) {</span>
283   if (_process_strong_tasks.try_claim_task(G1RP_PS_CodeCache_oops_do)) {
284     CodeCache::blobs_do(code_closure);
285   }
286 }
287 
288 uint G1RootProcessor::n_workers() const {
289   return _srs.n_threads();
290 }
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;aot/aotLoader.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 32 #include &quot;gc/g1/g1CodeBlobClosure.hpp&quot;
 33 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 34 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 35 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
 36 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 37 #include &quot;gc/g1/g1Policy.hpp&quot;
 38 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 39 #include &quot;gc/g1/g1RootProcessor.hpp&quot;
 40 #include &quot;gc/g1/heapRegion.inline.hpp&quot;

 41 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 42 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 43 #include &quot;memory/universe.hpp&quot;</span>
 44 #include &quot;runtime/mutex.hpp&quot;
 45 #include &quot;services/management.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 






















 48 G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :
 49     _g1h(g1h),
 50     _process_strong_tasks(G1RP_PS_NumElements),
<span class="line-modified"> 51     _srs(n_workers) {}</span>



 52 
<span class="line-modified"> 53 void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_id) {</span>
 54   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
 55 
<span class="line-modified"> 56   G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_id);</span>
 57 
 58   G1EvacuationRootClosures* closures = pss-&gt;closures();
<span class="line-modified"> 59   process_java_roots(closures, phase_times, worker_id);</span>






 60 
<span class="line-modified"> 61   process_vm_roots(closures, phase_times, worker_id);</span>
 62 
 63   {
 64     // Now the CM ref_processor roots.
<span class="line-modified"> 65     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CMRefRoots, worker_id);</span>
 66     if (_process_strong_tasks.try_claim_task(G1RP_PS_refProcessor_oops_do)) {
 67       // We need to treat the discovered reference lists of the
 68       // concurrent mark ref processor as roots and keep entries
 69       // (which are added by the marking threads) on them live
 70       // until they can be processed at the end of marking.
 71       _g1h-&gt;ref_processor_cm()-&gt;weak_oops_do(closures-&gt;strong_oops());
 72     }
 73   }
 74 




























 75   _process_strong_tasks.all_tasks_completed(n_workers());
 76 }
 77 
 78 // Adaptor to pass the closures to the strong roots in the VM.
 79 class StrongRootsClosures : public G1RootClosures {
 80   OopClosure* _roots;
 81   CLDClosure* _clds;
 82   CodeBlobClosure* _blobs;
 83 public:
 84   StrongRootsClosures(OopClosure* roots, CLDClosure* clds, CodeBlobClosure* blobs) :
 85       _roots(roots), _clds(clds), _blobs(blobs) {}
 86 
 87   OopClosure* weak_oops()   { return NULL; }
 88   OopClosure* strong_oops() { return _roots; }
 89 
 90   CLDClosure* weak_clds()        { return NULL; }
 91   CLDClosure* strong_clds()      { return _clds; }
 92 
 93   CodeBlobClosure* strong_codeblobs() { return _blobs; }
 94 };
</pre>
<hr />
<pre>
124   // We don&#39;t want to visit code blobs more than once, so we return NULL for the
125   // strong case and walk the entire code cache as a separate step.
126   CodeBlobClosure* strong_codeblobs() { return NULL; }
127 };
128 
129 void G1RootProcessor::process_all_roots(OopClosure* oops,
130                                         CLDClosure* clds,
131                                         CodeBlobClosure* blobs) {
132   AllRootsClosures closures(oops, clds);
133 
134   process_java_roots(&amp;closures, NULL, 0);
135   process_vm_roots(&amp;closures, NULL, 0);
136 
137   process_code_cache_roots(blobs, NULL, 0);
138 
139   _process_strong_tasks.all_tasks_completed(n_workers());
140 }
141 
142 void G1RootProcessor::process_java_roots(G1RootClosures* closures,
143                                          G1GCPhaseTimes* phase_times,
<span class="line-modified">144                                          uint worker_id) {</span>
<span class="line-modified">145   // We need to make make sure that the &quot;strong&quot; nmethods are processed first</span>
<span class="line-modified">146   // using the strong closure. Only after that we process the weakly reachable</span>
<span class="line-modified">147   // nmethods.</span>
<span class="line-added">148   // We need to strictly separate the strong and weak nmethod processing because</span>
<span class="line-added">149   // any processing claims that nmethod, i.e. will not be iterated again.</span>
<span class="line-added">150   // Which means if an nmethod is processed first and claimed, the strong processing</span>
<span class="line-added">151   // will not happen, and the oops reachable by that nmethod will not be marked</span>
<span class="line-added">152   // properly.</span>
<span class="line-added">153   //</span>
<span class="line-added">154   // That is why we process strong nmethods first, synchronize all threads via a</span>
<span class="line-added">155   // barrier, and only then allow weak processing. To minimize the wait time at</span>
<span class="line-added">156   // that barrier we do the strong nmethod processing first, and immediately after-</span>
<span class="line-added">157   // wards indicate that that thread is done. Hopefully other root processing after</span>
<span class="line-added">158   // nmethod processing is enough so there is no need to wait.</span>
<span class="line-added">159   //</span>
<span class="line-added">160   // This is only required in the concurrent start pause with class unloading enabled.</span>
161   {
<span class="line-modified">162     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_id);</span>







163     bool is_par = n_workers() &gt; 1;
164     Threads::possibly_parallel_oops_do(is_par,
165                                        closures-&gt;strong_oops(),
166                                        closures-&gt;strong_codeblobs());
167   }
<span class="line-added">168 </span>
<span class="line-added">169   {</span>
<span class="line-added">170     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_id);</span>
<span class="line-added">171     if (_process_strong_tasks.try_claim_task(G1RP_PS_ClassLoaderDataGraph_oops_do)) {</span>
<span class="line-added">172       ClassLoaderDataGraph::roots_cld_do(closures-&gt;strong_clds(), closures-&gt;weak_clds());</span>
<span class="line-added">173     }</span>
<span class="line-added">174   }</span>
175 }
176 
177 void G1RootProcessor::process_vm_roots(G1RootClosures* closures,
178                                        G1GCPhaseTimes* phase_times,
<span class="line-modified">179                                        uint worker_id) {</span>
180   OopClosure* strong_roots = closures-&gt;strong_oops();
181 
182   {
<span class="line-modified">183     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_id);</span>
184     if (_process_strong_tasks.try_claim_task(G1RP_PS_Universe_oops_do)) {
185       Universe::oops_do(strong_roots);
186     }
187   }
188 
189   {
<span class="line-modified">190     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_id);</span>
191     if (_process_strong_tasks.try_claim_task(G1RP_PS_JNIHandles_oops_do)) {
192       JNIHandles::oops_do(strong_roots);
193     }
194   }
195 
196   {
<span class="line-modified">197     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_id);</span>
198     if (_process_strong_tasks.try_claim_task(G1RP_PS_ObjectSynchronizer_oops_do)) {
199       ObjectSynchronizer::oops_do(strong_roots);
200     }
201   }
202 
203   {
<span class="line-modified">204     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_id);</span>
205     if (_process_strong_tasks.try_claim_task(G1RP_PS_Management_oops_do)) {
206       Management::oops_do(strong_roots);
207     }
208   }
209 
210   {
<span class="line-modified">211     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_id);</span>
212     if (_process_strong_tasks.try_claim_task(G1RP_PS_jvmti_oops_do)) {
213       JvmtiExport::oops_do(strong_roots);
214     }
215   }
216 
217 #if INCLUDE_AOT
218   if (UseAOT) {
<span class="line-modified">219     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_id);</span>
220     if (_process_strong_tasks.try_claim_task(G1RP_PS_aot_oops_do)) {
221         AOTLoader::oops_do(strong_roots);
222     }
223   }
224 #endif
225 
226   {
<span class="line-modified">227     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_id);</span>
228     if (_process_strong_tasks.try_claim_task(G1RP_PS_SystemDictionary_oops_do)) {
229       SystemDictionary::oops_do(strong_roots);
230     }
231   }
232 }
233 
234 void G1RootProcessor::process_code_cache_roots(CodeBlobClosure* code_closure,
235                                                G1GCPhaseTimes* phase_times,
<span class="line-modified">236                                                uint worker_id) {</span>
237   if (_process_strong_tasks.try_claim_task(G1RP_PS_CodeCache_oops_do)) {
238     CodeCache::blobs_do(code_closure);
239   }
240 }
241 
242 uint G1RootProcessor::n_workers() const {
243   return _srs.n_threads();
244 }
</pre>
</td>
</tr>
</table>
<center><a href="g1RootClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/g1/g1OopClosures.inline.hpp b/src/hotspot/share/gc/g1/g1OopClosures.inline.hpp
--- a/src/hotspot/share/gc/g1/g1OopClosures.inline.hpp
+++ b/src/hotspot/share/gc/g1/g1OopClosures.inline.hpp
@@ -36,10 +36,11 @@
 #include "oops/access.inline.hpp"
 #include "oops/compressedOops.inline.hpp"
 #include "oops/oopsHierarchy.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/prefetch.inline.hpp"
+#include "utilities/align.hpp"
 
 template <class T>
 inline void G1ScanClosureBase::prefetch_and_push(T* p, const oop obj) {
   // We're not going to even bother checking whether the object is
   // already forwarded or not, as this usually causes an immediate
@@ -59,14 +60,14 @@
 
   _par_scan_state->push_on_queue(p);
 }
 
 template <class T>
-inline void G1ScanClosureBase::handle_non_cset_obj_common(InCSetState const state, T* p, oop const obj) {
-  if (state.is_humongous()) {
+inline void G1ScanClosureBase::handle_non_cset_obj_common(G1HeapRegionAttr const region_attr, T* p, oop const obj) {
+  if (region_attr.is_humongous()) {
     _g1h->set_humongous_is_live(obj);
-  } else if (state.is_optional()) {
+  } else if (region_attr.is_optional()) {
     _par_scan_state->remember_reference_into_optional_region(p);
   }
 }
 
 inline void G1ScanClosureBase::trim_queue_partially() {
@@ -79,20 +80,20 @@
 
   if (CompressedOops::is_null(heap_oop)) {
     return;
   }
   oop obj = CompressedOops::decode_not_null(heap_oop);
-  const InCSetState state = _g1h->in_cset_state(obj);
-  if (state.is_in_cset()) {
+  const G1HeapRegionAttr region_attr = _g1h->region_attr(obj);
+  if (region_attr.is_in_cset()) {
     prefetch_and_push(p, obj);
   } else if (!HeapRegion::is_in_same_region(p, obj)) {
-    handle_non_cset_obj_common(state, p, obj);
+    handle_non_cset_obj_common(region_attr, p, obj);
     assert(_scanning_in_young != Uninitialized, "Scan location has not been initialized.");
     if (_scanning_in_young == True) {
       return;
     }
-    _par_scan_state->enqueue_card_if_tracked(p, obj);
+    _par_scan_state->enqueue_card_if_tracked(region_attr, p, obj);
   }
 }
 
 template <class T>
 inline void G1CMOopClosure::do_oop_work(T* p) {
@@ -113,12 +114,12 @@
 inline static void check_obj_during_refinement(T* p, oop const obj) {
 #ifdef ASSERT
   G1CollectedHeap* g1h = G1CollectedHeap::heap();
   // can't do because of races
   // assert(oopDesc::is_oop_or_null(obj), "expected an oop");
-  assert(check_obj_alignment(obj), "not oop aligned");
-  assert(g1h->is_in_reserved(obj), "must be in heap");
+  assert(is_object_aligned(obj), "oop must be aligned");
+  assert(g1h->is_in_reserved(obj), "oop must be in reserved");
 
   HeapRegion* from = g1h->heap_region_containing(p);
 
   assert(from != NULL, "from region must be non-NULL");
   assert(from->is_in_reserved(p) ||
@@ -153,54 +154,48 @@
 
   HeapRegionRemSet* to_rem_set = _g1h->heap_region_containing(obj)->rem_set();
 
   assert(to_rem_set != NULL, "Need per-region 'into' remsets.");
   if (to_rem_set->is_tracked()) {
-    to_rem_set->add_reference(p, _worker_i);
+    to_rem_set->add_reference(p, _worker_id);
   }
 }
 
 template <class T>
-inline void G1ScanObjsDuringUpdateRSClosure::do_oop_work(T* p) {
+inline void G1ScanCardClosure::do_oop_work(T* p) {
   T o = RawAccess<>::oop_load(p);
   if (CompressedOops::is_null(o)) {
     return;
   }
   oop obj = CompressedOops::decode_not_null(o);
 
   check_obj_during_refinement(p, obj);
 
-  assert(!_g1h->is_in_cset((HeapWord*)p), "Oop originates from " PTR_FORMAT " (region: %u) which is in the collection set.", p2i(p), _g1h->addr_to_region((HeapWord*)p));
-  const InCSetState state = _g1h->in_cset_state(obj);
-  if (state.is_in_cset()) {
+  assert(!_g1h->is_in_cset((HeapWord*)p),
+         "Oop originates from " PTR_FORMAT " (region: %u) which is in the collection set.",
+         p2i(p), _g1h->addr_to_region((HeapWord*)p));
+
+  const G1HeapRegionAttr region_attr = _g1h->region_attr(obj);
+  if (region_attr.is_in_cset()) {
     // Since the source is always from outside the collection set, here we implicitly know
     // that this is a cross-region reference too.
     prefetch_and_push(p, obj);
   } else if (!HeapRegion::is_in_same_region(p, obj)) {
-    handle_non_cset_obj_common(state, p, obj);
-    _par_scan_state->enqueue_card_if_tracked(p, obj);
+    handle_non_cset_obj_common(region_attr, p, obj);
+    _par_scan_state->enqueue_card_if_tracked(region_attr, p, obj);
   }
 }
 
 template <class T>
-inline void G1ScanObjsDuringScanRSClosure::do_oop_work(T* p) {
-  T heap_oop = RawAccess<>::oop_load(p);
-  if (CompressedOops::is_null(heap_oop)) {
+inline void G1ScanRSForOptionalClosure::do_oop_work(T* p) {
+  const G1HeapRegionAttr region_attr = _g1h->region_attr(p);
+  // Entries in the optional collection set may start to originate from the collection
+  // set after one or more increments. In this case, previously optional regions
+  // became actual collection set regions. Filter them out here.
+  if (region_attr.is_in_cset()) {
     return;
   }
-  oop obj = CompressedOops::decode_not_null(heap_oop);
-
-  const InCSetState state = _g1h->in_cset_state(obj);
-  if (state.is_in_cset()) {
-    prefetch_and_push(p, obj);
-  } else if (!HeapRegion::is_in_same_region(p, obj)) {
-    handle_non_cset_obj_common(state, p, obj);
-  }
-}
-
-template <class T>
-inline void G1ScanRSForOptionalClosure::do_oop_work(T* p) {
   _scan_cl->do_oop_work(p);
   _scan_cl->trim_queue_partially();
 }
 
 void G1ParCopyHelper::do_cld_barrier(oop new_obj) {
@@ -231,16 +226,16 @@
 
   oop obj = CompressedOops::decode_not_null(heap_oop);
 
   assert(_worker_id == _par_scan_state->worker_id(), "sanity");
 
-  const InCSetState state = _g1h->in_cset_state(obj);
+  const G1HeapRegionAttr state = _g1h->region_attr(obj);
   if (state.is_in_cset()) {
     oop forwardee;
-    markOop m = obj->mark_raw();
-    if (m->is_marked()) {
-      forwardee = (oop) m->decode_pointer();
+    markWord m = obj->mark_raw();
+    if (m.is_marked()) {
+      forwardee = (oop) m.decode_pointer();
     } else {
       forwardee = _par_scan_state->copy_to_survivor_space(state, obj, m);
     }
     assert(forwardee != NULL, "forwardee should not be NULL");
     RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);
@@ -249,11 +244,11 @@
       do_cld_barrier(forwardee);
     }
   } else {
     if (state.is_humongous()) {
       _g1h->set_humongous_is_live(obj);
-    } else if (state.is_optional()) {
+    } else if ((barrier != G1BarrierNoOptRoots) && state.is_optional()) {
       _par_scan_state->remember_root_into_optional_region(p);
     }
 
     // The object is not in collection set. If we're a root scanning
     // closure during an initial mark pause then attempt to mark the object.

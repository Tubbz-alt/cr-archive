<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
 28 #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;
 29 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;

 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 #include &quot;utilities/debug.hpp&quot;
 35 #include &quot;utilities/globalDefinitions.hpp&quot;
 36 #include &quot;utilities/pair.hpp&quot;
 37 #include &lt;math.h&gt;
 38 
 39 G1ConcurrentRefineThread* G1ConcurrentRefineThreadControl::create_refinement_thread(uint worker_id, bool initializing) {
 40   G1ConcurrentRefineThread* result = NULL;
 41   if (initializing || !InjectGCWorkerCreationFailure) {
 42     result = new G1ConcurrentRefineThread(_cr, worker_id);
 43   }
 44   if (result == NULL || result-&gt;osthread() == NULL) {
 45     log_warning(gc)(&quot;Failed to create refinement thread %u, no more %s&quot;,
 46                     worker_id,
 47                     result == NULL ? &quot;memory&quot; : &quot;OS threads&quot;);
 48   }
 49   return result;
 50 }
 51 
</pre>
<hr />
<pre>
 54   _threads(NULL),
 55   _num_max_threads(0)
 56 {
 57 }
 58 
 59 G1ConcurrentRefineThreadControl::~G1ConcurrentRefineThreadControl() {
 60   for (uint i = 0; i &lt; _num_max_threads; i++) {
 61     G1ConcurrentRefineThread* t = _threads[i];
 62     if (t != NULL) {
 63       delete t;
 64     }
 65   }
 66   FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);
 67 }
 68 
 69 jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint num_max_threads) {
 70   assert(cr != NULL, &quot;G1ConcurrentRefine must not be NULL&quot;);
 71   _cr = cr;
 72   _num_max_threads = num_max_threads;
 73 
<span class="line-modified"> 74   _threads = NEW_C_HEAP_ARRAY_RETURN_NULL(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>
<span class="line-removed"> 75   if (_threads == NULL) {</span>
<span class="line-removed"> 76     vm_shutdown_during_initialization(&quot;Could not allocate thread holder array.&quot;);</span>
<span class="line-removed"> 77     return JNI_ENOMEM;</span>
<span class="line-removed"> 78   }</span>
 79 
 80   for (uint i = 0; i &lt; num_max_threads; i++) {
 81     if (UseDynamicNumberOfGCThreads &amp;&amp; i != 0 /* Always start first thread. */) {
 82       _threads[i] = NULL;
 83     } else {
 84       _threads[i] = create_refinement_thread(i, true);
 85       if (_threads[i] == NULL) {
 86         vm_shutdown_during_initialization(&quot;Could not allocate refinement threads.&quot;);
 87         return JNI_ENOMEM;
 88       }
 89     }
 90   }





 91   return JNI_OK;
 92 }
 93 
 94 void G1ConcurrentRefineThreadControl::maybe_activate_next(uint cur_worker_id) {
 95   assert(cur_worker_id &lt; _num_max_threads,
 96          &quot;Activating another thread from %u not allowed since there can be at most %u&quot;,
 97          cur_worker_id, _num_max_threads);
 98   if (cur_worker_id == (_num_max_threads - 1)) {
 99     // Already the last thread, there is no more thread to activate.
100     return;
101   }
102 
103   uint worker_id = cur_worker_id + 1;
104   G1ConcurrentRefineThread* thread_to_activate = _threads[worker_id];
105   if (thread_to_activate == NULL) {
106     // Still need to create the thread...
107     _threads[worker_id] = create_refinement_thread(worker_id, false);
108     thread_to_activate = _threads[worker_id];
109   }
<span class="line-modified">110   if (thread_to_activate != NULL &amp;&amp; !thread_to_activate-&gt;is_active()) {</span>
111     thread_to_activate-&gt;activate();
112   }
113 }
114 
115 void G1ConcurrentRefineThreadControl::print_on(outputStream* st) const {
116   for (uint i = 0; i &lt; _num_max_threads; ++i) {
117     if (_threads[i] != NULL) {
118       _threads[i]-&gt;print_on(st);
119       st-&gt;cr();
120     }
121   }
122 }
123 
124 void G1ConcurrentRefineThreadControl::worker_threads_do(ThreadClosure* tc) {
125   for (uint i = 0; i &lt; _num_max_threads; i++) {
126     if (_threads[i] != NULL) {
127       tc-&gt;do_thread(_threads[i]);
128     }
129   }
130 }
131 
132 void G1ConcurrentRefineThreadControl::stop() {
133   for (uint i = 0; i &lt; _num_max_threads; i++) {
134     if (_threads[i] != NULL) {
135       _threads[i]-&gt;stop();
136     }
137   }
138 }
139 
140 // Arbitrary but large limits, to simplify some of the zone calculations.
141 // The general idea is to allow expressions like
142 //   MIN2(x OP y, max_XXX_zone)
143 // without needing to check for overflow in &quot;x OP y&quot;, because the
144 // ranges for x and y have been restricted.
145 STATIC_ASSERT(sizeof(LP64_ONLY(jint) NOT_LP64(jshort)) &lt;= (sizeof(size_t)/2));
146 const size_t max_yellow_zone = LP64_ONLY(max_jint) NOT_LP64(max_jshort);
147 const size_t max_green_zone = max_yellow_zone / 2;
<span class="line-modified">148 const size_t max_red_zone = INT_MAX; // For dcqs.set_max_completed_buffers.</span>
149 STATIC_ASSERT(max_yellow_zone &lt;= max_red_zone);
150 
151 // Range check assertions for green zone values.
152 #define assert_zone_constraints_g(green)                        \
153   do {                                                          \
154     size_t azc_g_green = (green);                               \
155     assert(azc_g_green &lt;= max_green_zone,                       \
156            &quot;green exceeds max: &quot; SIZE_FORMAT, azc_g_green);     \
157   } while (0)
158 
159 // Range check assertions for green and yellow zone values.
160 #define assert_zone_constraints_gy(green, yellow)                       \
161   do {                                                                  \
162     size_t azc_gy_green = (green);                                      \
163     size_t azc_gy_yellow = (yellow);                                    \
164     assert_zone_constraints_g(azc_gy_green);                            \
165     assert(azc_gy_yellow &lt;= max_yellow_zone,                            \
166            &quot;yellow exceeds max: &quot; SIZE_FORMAT, azc_gy_yellow);          \
167     assert(azc_gy_green &lt;= azc_gy_yellow,                               \
168            &quot;green (&quot; SIZE_FORMAT &quot;) exceeds yellow (&quot; SIZE_FORMAT &quot;)&quot;,  \
</pre>
<hr />
<pre>
172 // Range check assertions for green, yellow, and red zone values.
173 #define assert_zone_constraints_gyr(green, yellow, red)                 \
174   do {                                                                  \
175     size_t azc_gyr_green = (green);                                     \
176     size_t azc_gyr_yellow = (yellow);                                   \
177     size_t azc_gyr_red = (red);                                         \
178     assert_zone_constraints_gy(azc_gyr_green, azc_gyr_yellow);          \
179     assert(azc_gyr_red &lt;= max_red_zone,                                 \
180            &quot;red exceeds max: &quot; SIZE_FORMAT, azc_gyr_red);               \
181     assert(azc_gyr_yellow &lt;= azc_gyr_red,                               \
182            &quot;yellow (&quot; SIZE_FORMAT &quot;) exceeds red (&quot; SIZE_FORMAT &quot;)&quot;,    \
183            azc_gyr_yellow, azc_gyr_red);                                \
184   } while (0)
185 
186 // Logging tag sequence for refinement control updates.
187 #define CTRL_TAGS gc, ergo, refine
188 
189 // For logging zone values, ensuring consistency of level and tags.
190 #define LOG_ZONES(...) log_debug( CTRL_TAGS )(__VA_ARGS__)
191 




192 // Package for pair of refinement thread activation and deactivation
193 // thresholds.  The activation and deactivation levels are resp. the first
194 // and second values of the pair.
195 typedef Pair&lt;size_t, size_t&gt; Thresholds;
196 inline size_t activation_level(const Thresholds&amp; t) { return t.first; }
197 inline size_t deactivation_level(const Thresholds&amp; t) { return t.second; }
198 
199 static Thresholds calc_thresholds(size_t green_zone,
200                                   size_t yellow_zone,
<span class="line-modified">201                                   uint worker_i) {</span>
202   double yellow_size = yellow_zone - green_zone;
203   double step = yellow_size / G1ConcurrentRefine::max_num_threads();
<span class="line-modified">204   if (worker_i == 0) {</span>
205     // Potentially activate worker 0 more aggressively, to keep
206     // available buffers near green_zone value.  When yellow_size is
207     // large we don&#39;t want to allow a full step to accumulate before
208     // doing any processing, as that might lead to significantly more
<span class="line-modified">209     // than green_zone buffers to be processed by update_rs.</span>
<span class="line-modified">210     step = MIN2(step, ParallelGCThreads / 2.0);</span>

211   }
<span class="line-modified">212   size_t activate_offset = static_cast&lt;size_t&gt;(ceil(step * (worker_i + 1)));</span>
<span class="line-modified">213   size_t deactivate_offset = static_cast&lt;size_t&gt;(floor(step * worker_i));</span>
214   return Thresholds(green_zone + activate_offset,
215                     green_zone + deactivate_offset);
216 }
217 
218 G1ConcurrentRefine::G1ConcurrentRefine(size_t green_zone,
219                                        size_t yellow_zone,
220                                        size_t red_zone,
221                                        size_t min_yellow_zone_size) :
222   _thread_control(),
223   _green_zone(green_zone),
224   _yellow_zone(yellow_zone),
225   _red_zone(red_zone),
226   _min_yellow_zone_size(min_yellow_zone_size)
227 {
228   assert_zone_constraints_gyr(green_zone, yellow_zone, red_zone);
229 }
230 
231 jint G1ConcurrentRefine::initialize() {
232   return _thread_control.initialize(this, max_num_threads());
233 }
234 
235 static size_t calc_min_yellow_zone_size() {
<span class="line-modified">236   size_t step = G1ConcRefinementThresholdStep;</span>
237   uint n_workers = G1ConcurrentRefine::max_num_threads();
238   if ((max_yellow_zone / step) &lt; n_workers) {
239     return max_yellow_zone;
240   } else {
241     return step * n_workers;
242   }
243 }
244 
245 static size_t calc_init_green_zone() {
246   size_t green = G1ConcRefinementGreenZone;
247   if (FLAG_IS_DEFAULT(G1ConcRefinementGreenZone)) {
248     green = ParallelGCThreads;
249   }

250   return MIN2(green, max_green_zone);
251 }
252 
253 static size_t calc_init_yellow_zone(size_t green, size_t min_size) {
<span class="line-modified">254   size_t config = G1ConcRefinementYellowZone;</span>
255   size_t size = 0;
256   if (FLAG_IS_DEFAULT(G1ConcRefinementYellowZone)) {
257     size = green * 2;
258   } else if (green &lt; config) {
259     size = config - green;
260   }
261   size = MAX2(size, min_size);
262   size = MIN2(size, max_yellow_zone);
263   return MIN2(green + size, max_yellow_zone);
264 }
265 
266 static size_t calc_init_red_zone(size_t green, size_t yellow) {
267   size_t size = yellow - green;
268   if (!FLAG_IS_DEFAULT(G1ConcRefinementRedZone)) {
<span class="line-modified">269     size_t config = G1ConcRefinementRedZone;</span>
270     if (yellow &lt; config) {
271       size = MAX2(size, config - yellow);
272     }
273   }
274   return MIN2(yellow + size, max_red_zone);
275 }
276 
277 G1ConcurrentRefine* G1ConcurrentRefine::create(jint* ecode) {
278   size_t min_yellow_zone_size = calc_min_yellow_zone_size();
279   size_t green_zone = calc_init_green_zone();
280   size_t yellow_zone = calc_init_yellow_zone(green_zone, min_yellow_zone_size);
281   size_t red_zone = calc_init_red_zone(green_zone, yellow_zone);
282 
283   LOG_ZONES(&quot;Initial Refinement Zones: &quot;
284             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
285             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
286             &quot;red: &quot; SIZE_FORMAT &quot;, &quot;
287             &quot;min yellow size: &quot; SIZE_FORMAT,
288             green_zone, yellow_zone, red_zone, min_yellow_zone_size);
289 
290   G1ConcurrentRefine* cr = new G1ConcurrentRefine(green_zone,
291                                                   yellow_zone,
292                                                   red_zone,
293                                                   min_yellow_zone_size);
<span class="line-removed">294 </span>
<span class="line-removed">295   if (cr == NULL) {</span>
<span class="line-removed">296     *ecode = JNI_ENOMEM;</span>
<span class="line-removed">297     vm_shutdown_during_initialization(&quot;Could not create G1ConcurrentRefine&quot;);</span>
<span class="line-removed">298     return NULL;</span>
<span class="line-removed">299   }</span>
<span class="line-removed">300 </span>
301   *ecode = cr-&gt;initialize();
302   return cr;
303 }
304 
305 void G1ConcurrentRefine::stop() {
306   _thread_control.stop();
307 }
308 
309 G1ConcurrentRefine::~G1ConcurrentRefine() {
310 }
311 
312 void G1ConcurrentRefine::threads_do(ThreadClosure *tc) {
313   _thread_control.worker_threads_do(tc);
314 }
315 
316 uint G1ConcurrentRefine::max_num_threads() {
317   return G1ConcRefinementThreads;
318 }
319 
320 void G1ConcurrentRefine::print_threads_on(outputStream* st) const {
321   _thread_control.print_on(st);
322 }
323 
324 static size_t calc_new_green_zone(size_t green,
<span class="line-modified">325                                   double update_rs_time,</span>
<span class="line-modified">326                                   size_t update_rs_processed_buffers,</span>
327                                   double goal_ms) {
328   // Adjust green zone based on whether we&#39;re meeting the time goal.
329   // Limit to max_green_zone.
330   const double inc_k = 1.1, dec_k = 0.9;
<span class="line-modified">331   if (update_rs_time &gt; goal_ms) {</span>
332     if (green &gt; 0) {
333       green = static_cast&lt;size_t&gt;(green * dec_k);
334     }
<span class="line-modified">335   } else if (update_rs_time &lt; goal_ms &amp;&amp;</span>
<span class="line-modified">336              update_rs_processed_buffers &gt; green) {</span>
337     green = static_cast&lt;size_t&gt;(MAX2(green * inc_k, green + 1.0));
338     green = MIN2(green, max_green_zone);
339   }
340   return green;
341 }
342 
343 static size_t calc_new_yellow_zone(size_t green, size_t min_yellow_size) {
344   size_t size = green * 2;
345   size = MAX2(size, min_yellow_size);
346   return MIN2(green + size, max_yellow_zone);
347 }
348 
349 static size_t calc_new_red_zone(size_t green, size_t yellow) {
350   return MIN2(yellow + (yellow - green), max_red_zone);
351 }
352 
<span class="line-modified">353 void G1ConcurrentRefine::update_zones(double update_rs_time,</span>
<span class="line-modified">354                                       size_t update_rs_processed_buffers,</span>
355                                       double goal_ms) {
356   log_trace( CTRL_TAGS )(&quot;Updating Refinement Zones: &quot;
<span class="line-modified">357                          &quot;update_rs time: %.3fms, &quot;</span>
<span class="line-modified">358                          &quot;update_rs buffers: &quot; SIZE_FORMAT &quot;, &quot;</span>
<span class="line-modified">359                          &quot;update_rs goal time: %.3fms&quot;,</span>
<span class="line-modified">360                          update_rs_time,</span>
<span class="line-modified">361                          update_rs_processed_buffers,</span>
362                          goal_ms);
363 
364   _green_zone = calc_new_green_zone(_green_zone,
<span class="line-modified">365                                     update_rs_time,</span>
<span class="line-modified">366                                     update_rs_processed_buffers,</span>
367                                     goal_ms);
368   _yellow_zone = calc_new_yellow_zone(_green_zone, _min_yellow_zone_size);
369   _red_zone = calc_new_red_zone(_green_zone, _yellow_zone);
370 
371   assert_zone_constraints_gyr(_green_zone, _yellow_zone, _red_zone);
372   LOG_ZONES(&quot;Updated Refinement Zones: &quot;
373             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
374             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
375             &quot;red: &quot; SIZE_FORMAT,
376             _green_zone, _yellow_zone, _red_zone);
377 }
378 
<span class="line-modified">379 void G1ConcurrentRefine::adjust(double update_rs_time,</span>
<span class="line-modified">380                                 size_t update_rs_processed_buffers,</span>
381                                 double goal_ms) {
382   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
383 
384   if (G1UseAdaptiveConcRefinement) {
<span class="line-modified">385     update_zones(update_rs_time, update_rs_processed_buffers, goal_ms);</span>
386 
387     // Change the barrier params
388     if (max_num_threads() == 0) {
389       // Disable dcqs notification when there are no threads to notify.
<span class="line-modified">390       dcqs.set_process_completed_buffers_threshold(G1DirtyCardQueueSet::ProcessCompletedBuffersThresholdNever);</span>
391     } else {
392       // Worker 0 is the primary; wakeup is via dcqs notification.
393       STATIC_ASSERT(max_yellow_zone &lt;= INT_MAX);
394       size_t activate = activation_threshold(0);
<span class="line-modified">395       dcqs.set_process_completed_buffers_threshold(activate);</span>
396     }
<span class="line-modified">397     dcqs.set_max_completed_buffers(red_zone());</span>
398   }
399 
<span class="line-modified">400   size_t curr_queue_size = dcqs.completed_buffers_num();</span>
<span class="line-modified">401   if ((dcqs.max_completed_buffers() &gt; 0) &amp;&amp;</span>
402       (curr_queue_size &gt;= yellow_zone())) {
<span class="line-modified">403     dcqs.set_completed_buffers_padding(curr_queue_size);</span>
404   } else {
<span class="line-modified">405     dcqs.set_completed_buffers_padding(0);</span>
406   }
407   dcqs.notify_if_necessary();
408 }
409 
















410 size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
411   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
412   return activation_level(thresholds);
413 }
414 
415 size_t G1ConcurrentRefine::deactivation_threshold(uint worker_id) const {
416   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
417   return deactivation_level(thresholds);
418 }
419 
420 uint G1ConcurrentRefine::worker_id_offset() {
421   return G1DirtyCardQueueSet::num_par_ids();
422 }
423 
<span class="line-modified">424 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers) {</span>
<span class="line-modified">425   if (num_cur_buffers &gt; activation_threshold(worker_id + 1)) {</span>
426     _thread_control.maybe_activate_next(worker_id);
427   }
428 }
429 
<span class="line-modified">430 bool G1ConcurrentRefine::do_refinement_step(uint worker_id) {</span>

431   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
432 
<span class="line-modified">433   size_t curr_buffer_num = dcqs.completed_buffers_num();</span>
<span class="line-modified">434   // If the number of the buffers falls down into the yellow zone,</span>
435   // that means that the transition period after the evacuation pause has ended.
436   // Since the value written to the DCQS is the same for all threads, there is no
437   // need to synchronize.
<span class="line-modified">438   if (dcqs.completed_buffers_padding() &gt; 0 &amp;&amp; curr_buffer_num &lt;= yellow_zone()) {</span>
<span class="line-modified">439     dcqs.set_completed_buffers_padding(0);</span>
440   }
441 
<span class="line-modified">442   maybe_activate_more_threads(worker_id, curr_buffer_num);</span>
443 
444   // Process the next buffer, if there are enough left.
445   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
<span class="line-modified">446                                                    deactivation_threshold(worker_id));</span>

447 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
 28 #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;
 29 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 32 #include &quot;memory/iterator.hpp&quot;</span>
 33 #include &quot;runtime/java.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/pair.hpp&quot;
 38 #include &lt;math.h&gt;
 39 
 40 G1ConcurrentRefineThread* G1ConcurrentRefineThreadControl::create_refinement_thread(uint worker_id, bool initializing) {
 41   G1ConcurrentRefineThread* result = NULL;
 42   if (initializing || !InjectGCWorkerCreationFailure) {
 43     result = new G1ConcurrentRefineThread(_cr, worker_id);
 44   }
 45   if (result == NULL || result-&gt;osthread() == NULL) {
 46     log_warning(gc)(&quot;Failed to create refinement thread %u, no more %s&quot;,
 47                     worker_id,
 48                     result == NULL ? &quot;memory&quot; : &quot;OS threads&quot;);
 49   }
 50   return result;
 51 }
 52 
</pre>
<hr />
<pre>
 55   _threads(NULL),
 56   _num_max_threads(0)
 57 {
 58 }
 59 
 60 G1ConcurrentRefineThreadControl::~G1ConcurrentRefineThreadControl() {
 61   for (uint i = 0; i &lt; _num_max_threads; i++) {
 62     G1ConcurrentRefineThread* t = _threads[i];
 63     if (t != NULL) {
 64       delete t;
 65     }
 66   }
 67   FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);
 68 }
 69 
 70 jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint num_max_threads) {
 71   assert(cr != NULL, &quot;G1ConcurrentRefine must not be NULL&quot;);
 72   _cr = cr;
 73   _num_max_threads = num_max_threads;
 74 
<span class="line-modified"> 75   _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>




 76 
 77   for (uint i = 0; i &lt; num_max_threads; i++) {
 78     if (UseDynamicNumberOfGCThreads &amp;&amp; i != 0 /* Always start first thread. */) {
 79       _threads[i] = NULL;
 80     } else {
 81       _threads[i] = create_refinement_thread(i, true);
 82       if (_threads[i] == NULL) {
 83         vm_shutdown_during_initialization(&quot;Could not allocate refinement threads.&quot;);
 84         return JNI_ENOMEM;
 85       }
 86     }
 87   }
<span class="line-added"> 88 </span>
<span class="line-added"> 89   if (num_max_threads &gt; 0) {</span>
<span class="line-added"> 90     G1BarrierSet::dirty_card_queue_set().set_primary_refinement_thread(_threads[0]);</span>
<span class="line-added"> 91   }</span>
<span class="line-added"> 92 </span>
 93   return JNI_OK;
 94 }
 95 
 96 void G1ConcurrentRefineThreadControl::maybe_activate_next(uint cur_worker_id) {
 97   assert(cur_worker_id &lt; _num_max_threads,
 98          &quot;Activating another thread from %u not allowed since there can be at most %u&quot;,
 99          cur_worker_id, _num_max_threads);
100   if (cur_worker_id == (_num_max_threads - 1)) {
101     // Already the last thread, there is no more thread to activate.
102     return;
103   }
104 
105   uint worker_id = cur_worker_id + 1;
106   G1ConcurrentRefineThread* thread_to_activate = _threads[worker_id];
107   if (thread_to_activate == NULL) {
108     // Still need to create the thread...
109     _threads[worker_id] = create_refinement_thread(worker_id, false);
110     thread_to_activate = _threads[worker_id];
111   }
<span class="line-modified">112   if (thread_to_activate != NULL) {</span>
113     thread_to_activate-&gt;activate();
114   }
115 }
116 
117 void G1ConcurrentRefineThreadControl::print_on(outputStream* st) const {
118   for (uint i = 0; i &lt; _num_max_threads; ++i) {
119     if (_threads[i] != NULL) {
120       _threads[i]-&gt;print_on(st);
121       st-&gt;cr();
122     }
123   }
124 }
125 
126 void G1ConcurrentRefineThreadControl::worker_threads_do(ThreadClosure* tc) {
127   for (uint i = 0; i &lt; _num_max_threads; i++) {
128     if (_threads[i] != NULL) {
129       tc-&gt;do_thread(_threads[i]);
130     }
131   }
132 }
133 
134 void G1ConcurrentRefineThreadControl::stop() {
135   for (uint i = 0; i &lt; _num_max_threads; i++) {
136     if (_threads[i] != NULL) {
137       _threads[i]-&gt;stop();
138     }
139   }
140 }
141 
142 // Arbitrary but large limits, to simplify some of the zone calculations.
143 // The general idea is to allow expressions like
144 //   MIN2(x OP y, max_XXX_zone)
145 // without needing to check for overflow in &quot;x OP y&quot;, because the
146 // ranges for x and y have been restricted.
147 STATIC_ASSERT(sizeof(LP64_ONLY(jint) NOT_LP64(jshort)) &lt;= (sizeof(size_t)/2));
148 const size_t max_yellow_zone = LP64_ONLY(max_jint) NOT_LP64(max_jshort);
149 const size_t max_green_zone = max_yellow_zone / 2;
<span class="line-modified">150 const size_t max_red_zone = INT_MAX; // For dcqs.set_max_cards.</span>
151 STATIC_ASSERT(max_yellow_zone &lt;= max_red_zone);
152 
153 // Range check assertions for green zone values.
154 #define assert_zone_constraints_g(green)                        \
155   do {                                                          \
156     size_t azc_g_green = (green);                               \
157     assert(azc_g_green &lt;= max_green_zone,                       \
158            &quot;green exceeds max: &quot; SIZE_FORMAT, azc_g_green);     \
159   } while (0)
160 
161 // Range check assertions for green and yellow zone values.
162 #define assert_zone_constraints_gy(green, yellow)                       \
163   do {                                                                  \
164     size_t azc_gy_green = (green);                                      \
165     size_t azc_gy_yellow = (yellow);                                    \
166     assert_zone_constraints_g(azc_gy_green);                            \
167     assert(azc_gy_yellow &lt;= max_yellow_zone,                            \
168            &quot;yellow exceeds max: &quot; SIZE_FORMAT, azc_gy_yellow);          \
169     assert(azc_gy_green &lt;= azc_gy_yellow,                               \
170            &quot;green (&quot; SIZE_FORMAT &quot;) exceeds yellow (&quot; SIZE_FORMAT &quot;)&quot;,  \
</pre>
<hr />
<pre>
174 // Range check assertions for green, yellow, and red zone values.
175 #define assert_zone_constraints_gyr(green, yellow, red)                 \
176   do {                                                                  \
177     size_t azc_gyr_green = (green);                                     \
178     size_t azc_gyr_yellow = (yellow);                                   \
179     size_t azc_gyr_red = (red);                                         \
180     assert_zone_constraints_gy(azc_gyr_green, azc_gyr_yellow);          \
181     assert(azc_gyr_red &lt;= max_red_zone,                                 \
182            &quot;red exceeds max: &quot; SIZE_FORMAT, azc_gyr_red);               \
183     assert(azc_gyr_yellow &lt;= azc_gyr_red,                               \
184            &quot;yellow (&quot; SIZE_FORMAT &quot;) exceeds red (&quot; SIZE_FORMAT &quot;)&quot;,    \
185            azc_gyr_yellow, azc_gyr_red);                                \
186   } while (0)
187 
188 // Logging tag sequence for refinement control updates.
189 #define CTRL_TAGS gc, ergo, refine
190 
191 // For logging zone values, ensuring consistency of level and tags.
192 #define LOG_ZONES(...) log_debug( CTRL_TAGS )(__VA_ARGS__)
193 
<span class="line-added">194 static size_t buffers_to_cards(size_t value) {</span>
<span class="line-added">195   return value * G1UpdateBufferSize;</span>
<span class="line-added">196 }</span>
<span class="line-added">197 </span>
198 // Package for pair of refinement thread activation and deactivation
199 // thresholds.  The activation and deactivation levels are resp. the first
200 // and second values of the pair.
201 typedef Pair&lt;size_t, size_t&gt; Thresholds;
202 inline size_t activation_level(const Thresholds&amp; t) { return t.first; }
203 inline size_t deactivation_level(const Thresholds&amp; t) { return t.second; }
204 
205 static Thresholds calc_thresholds(size_t green_zone,
206                                   size_t yellow_zone,
<span class="line-modified">207                                   uint worker_id) {</span>
208   double yellow_size = yellow_zone - green_zone;
209   double step = yellow_size / G1ConcurrentRefine::max_num_threads();
<span class="line-modified">210   if (worker_id == 0) {</span>
211     // Potentially activate worker 0 more aggressively, to keep
212     // available buffers near green_zone value.  When yellow_size is
213     // large we don&#39;t want to allow a full step to accumulate before
214     // doing any processing, as that might lead to significantly more
<span class="line-modified">215     // than green_zone buffers to be processed during pause.  So limit</span>
<span class="line-modified">216     // to an extra half buffer per pause-time processing thread.</span>
<span class="line-added">217     step = MIN2(step, buffers_to_cards(ParallelGCThreads) / 2.0);</span>
218   }
<span class="line-modified">219   size_t activate_offset = static_cast&lt;size_t&gt;(ceil(step * (worker_id + 1)));</span>
<span class="line-modified">220   size_t deactivate_offset = static_cast&lt;size_t&gt;(floor(step * worker_id));</span>
221   return Thresholds(green_zone + activate_offset,
222                     green_zone + deactivate_offset);
223 }
224 
225 G1ConcurrentRefine::G1ConcurrentRefine(size_t green_zone,
226                                        size_t yellow_zone,
227                                        size_t red_zone,
228                                        size_t min_yellow_zone_size) :
229   _thread_control(),
230   _green_zone(green_zone),
231   _yellow_zone(yellow_zone),
232   _red_zone(red_zone),
233   _min_yellow_zone_size(min_yellow_zone_size)
234 {
235   assert_zone_constraints_gyr(green_zone, yellow_zone, red_zone);
236 }
237 
238 jint G1ConcurrentRefine::initialize() {
239   return _thread_control.initialize(this, max_num_threads());
240 }
241 
242 static size_t calc_min_yellow_zone_size() {
<span class="line-modified">243   size_t step = buffers_to_cards(G1ConcRefinementThresholdStep);</span>
244   uint n_workers = G1ConcurrentRefine::max_num_threads();
245   if ((max_yellow_zone / step) &lt; n_workers) {
246     return max_yellow_zone;
247   } else {
248     return step * n_workers;
249   }
250 }
251 
252 static size_t calc_init_green_zone() {
253   size_t green = G1ConcRefinementGreenZone;
254   if (FLAG_IS_DEFAULT(G1ConcRefinementGreenZone)) {
255     green = ParallelGCThreads;
256   }
<span class="line-added">257   green = buffers_to_cards(green);</span>
258   return MIN2(green, max_green_zone);
259 }
260 
261 static size_t calc_init_yellow_zone(size_t green, size_t min_size) {
<span class="line-modified">262   size_t config = buffers_to_cards(G1ConcRefinementYellowZone);</span>
263   size_t size = 0;
264   if (FLAG_IS_DEFAULT(G1ConcRefinementYellowZone)) {
265     size = green * 2;
266   } else if (green &lt; config) {
267     size = config - green;
268   }
269   size = MAX2(size, min_size);
270   size = MIN2(size, max_yellow_zone);
271   return MIN2(green + size, max_yellow_zone);
272 }
273 
274 static size_t calc_init_red_zone(size_t green, size_t yellow) {
275   size_t size = yellow - green;
276   if (!FLAG_IS_DEFAULT(G1ConcRefinementRedZone)) {
<span class="line-modified">277     size_t config = buffers_to_cards(G1ConcRefinementRedZone);</span>
278     if (yellow &lt; config) {
279       size = MAX2(size, config - yellow);
280     }
281   }
282   return MIN2(yellow + size, max_red_zone);
283 }
284 
285 G1ConcurrentRefine* G1ConcurrentRefine::create(jint* ecode) {
286   size_t min_yellow_zone_size = calc_min_yellow_zone_size();
287   size_t green_zone = calc_init_green_zone();
288   size_t yellow_zone = calc_init_yellow_zone(green_zone, min_yellow_zone_size);
289   size_t red_zone = calc_init_red_zone(green_zone, yellow_zone);
290 
291   LOG_ZONES(&quot;Initial Refinement Zones: &quot;
292             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
293             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
294             &quot;red: &quot; SIZE_FORMAT &quot;, &quot;
295             &quot;min yellow size: &quot; SIZE_FORMAT,
296             green_zone, yellow_zone, red_zone, min_yellow_zone_size);
297 
298   G1ConcurrentRefine* cr = new G1ConcurrentRefine(green_zone,
299                                                   yellow_zone,
300                                                   red_zone,
301                                                   min_yellow_zone_size);







302   *ecode = cr-&gt;initialize();
303   return cr;
304 }
305 
306 void G1ConcurrentRefine::stop() {
307   _thread_control.stop();
308 }
309 
310 G1ConcurrentRefine::~G1ConcurrentRefine() {
311 }
312 
313 void G1ConcurrentRefine::threads_do(ThreadClosure *tc) {
314   _thread_control.worker_threads_do(tc);
315 }
316 
317 uint G1ConcurrentRefine::max_num_threads() {
318   return G1ConcRefinementThreads;
319 }
320 
321 void G1ConcurrentRefine::print_threads_on(outputStream* st) const {
322   _thread_control.print_on(st);
323 }
324 
325 static size_t calc_new_green_zone(size_t green,
<span class="line-modified">326                                   double logged_cards_scan_time,</span>
<span class="line-modified">327                                   size_t processed_logged_cards,</span>
328                                   double goal_ms) {
329   // Adjust green zone based on whether we&#39;re meeting the time goal.
330   // Limit to max_green_zone.
331   const double inc_k = 1.1, dec_k = 0.9;
<span class="line-modified">332   if (logged_cards_scan_time &gt; goal_ms) {</span>
333     if (green &gt; 0) {
334       green = static_cast&lt;size_t&gt;(green * dec_k);
335     }
<span class="line-modified">336   } else if (logged_cards_scan_time &lt; goal_ms &amp;&amp;</span>
<span class="line-modified">337              processed_logged_cards &gt; green) {</span>
338     green = static_cast&lt;size_t&gt;(MAX2(green * inc_k, green + 1.0));
339     green = MIN2(green, max_green_zone);
340   }
341   return green;
342 }
343 
344 static size_t calc_new_yellow_zone(size_t green, size_t min_yellow_size) {
345   size_t size = green * 2;
346   size = MAX2(size, min_yellow_size);
347   return MIN2(green + size, max_yellow_zone);
348 }
349 
350 static size_t calc_new_red_zone(size_t green, size_t yellow) {
351   return MIN2(yellow + (yellow - green), max_red_zone);
352 }
353 
<span class="line-modified">354 void G1ConcurrentRefine::update_zones(double logged_cards_scan_time,</span>
<span class="line-modified">355                                       size_t processed_logged_cards,</span>
356                                       double goal_ms) {
357   log_trace( CTRL_TAGS )(&quot;Updating Refinement Zones: &quot;
<span class="line-modified">358                          &quot;logged cards scan time: %.3fms, &quot;</span>
<span class="line-modified">359                          &quot;processed cards: &quot; SIZE_FORMAT &quot;, &quot;</span>
<span class="line-modified">360                          &quot;goal time: %.3fms&quot;,</span>
<span class="line-modified">361                          logged_cards_scan_time,</span>
<span class="line-modified">362                          processed_logged_cards,</span>
363                          goal_ms);
364 
365   _green_zone = calc_new_green_zone(_green_zone,
<span class="line-modified">366                                     logged_cards_scan_time,</span>
<span class="line-modified">367                                     processed_logged_cards,</span>
368                                     goal_ms);
369   _yellow_zone = calc_new_yellow_zone(_green_zone, _min_yellow_zone_size);
370   _red_zone = calc_new_red_zone(_green_zone, _yellow_zone);
371 
372   assert_zone_constraints_gyr(_green_zone, _yellow_zone, _red_zone);
373   LOG_ZONES(&quot;Updated Refinement Zones: &quot;
374             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
375             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
376             &quot;red: &quot; SIZE_FORMAT,
377             _green_zone, _yellow_zone, _red_zone);
378 }
379 
<span class="line-modified">380 void G1ConcurrentRefine::adjust(double logged_cards_scan_time,</span>
<span class="line-modified">381                                 size_t processed_logged_cards,</span>
382                                 double goal_ms) {
383   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
384 
385   if (G1UseAdaptiveConcRefinement) {
<span class="line-modified">386     update_zones(logged_cards_scan_time, processed_logged_cards, goal_ms);</span>
387 
388     // Change the barrier params
389     if (max_num_threads() == 0) {
390       // Disable dcqs notification when there are no threads to notify.
<span class="line-modified">391       dcqs.set_process_cards_threshold(G1DirtyCardQueueSet::ProcessCardsThresholdNever);</span>
392     } else {
393       // Worker 0 is the primary; wakeup is via dcqs notification.
394       STATIC_ASSERT(max_yellow_zone &lt;= INT_MAX);
395       size_t activate = activation_threshold(0);
<span class="line-modified">396       dcqs.set_process_cards_threshold(activate);</span>
397     }
<span class="line-modified">398     dcqs.set_max_cards(red_zone());</span>
399   }
400 
<span class="line-modified">401   size_t curr_queue_size = dcqs.num_cards();</span>
<span class="line-modified">402   if ((dcqs.max_cards() &gt; 0) &amp;&amp;</span>
403       (curr_queue_size &gt;= yellow_zone())) {
<span class="line-modified">404     dcqs.set_max_cards_padding(curr_queue_size);</span>
405   } else {
<span class="line-modified">406     dcqs.set_max_cards_padding(0);</span>
407   }
408   dcqs.notify_if_necessary();
409 }
410 
<span class="line-added">411 G1ConcurrentRefine::RefinementStats G1ConcurrentRefine::total_refinement_stats() const {</span>
<span class="line-added">412   struct CollectData : public ThreadClosure {</span>
<span class="line-added">413     Tickspan _total_time;</span>
<span class="line-added">414     size_t _total_cards;</span>
<span class="line-added">415     CollectData() : _total_time(), _total_cards(0) {}</span>
<span class="line-added">416     virtual void do_thread(Thread* t) {</span>
<span class="line-added">417       G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);</span>
<span class="line-added">418       _total_time += crt-&gt;total_refinement_time();</span>
<span class="line-added">419       _total_cards += crt-&gt;total_refined_cards();</span>
<span class="line-added">420     }</span>
<span class="line-added">421   } collector;</span>
<span class="line-added">422   // Cast away const so we can call non-modifying closure on threads.</span>
<span class="line-added">423   const_cast&lt;G1ConcurrentRefine*&gt;(this)-&gt;threads_do(&amp;collector);</span>
<span class="line-added">424   return RefinementStats(collector._total_time, collector._total_cards);</span>
<span class="line-added">425 }</span>
<span class="line-added">426 </span>
427 size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
428   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
429   return activation_level(thresholds);
430 }
431 
432 size_t G1ConcurrentRefine::deactivation_threshold(uint worker_id) const {
433   Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
434   return deactivation_level(thresholds);
435 }
436 
437 uint G1ConcurrentRefine::worker_id_offset() {
438   return G1DirtyCardQueueSet::num_par_ids();
439 }
440 
<span class="line-modified">441 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {</span>
<span class="line-modified">442   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {</span>
443     _thread_control.maybe_activate_next(worker_id);
444   }
445 }
446 
<span class="line-modified">447 bool G1ConcurrentRefine::do_refinement_step(uint worker_id,</span>
<span class="line-added">448                                             size_t* total_refined_cards) {</span>
449   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
450 
<span class="line-modified">451   size_t curr_cards = dcqs.num_cards();</span>
<span class="line-modified">452   // If the number of the cards falls down into the yellow zone,</span>
453   // that means that the transition period after the evacuation pause has ended.
454   // Since the value written to the DCQS is the same for all threads, there is no
455   // need to synchronize.
<span class="line-modified">456   if (dcqs.max_cards_padding() &gt; 0 &amp;&amp; curr_cards &lt;= yellow_zone()) {</span>
<span class="line-modified">457     dcqs.set_max_cards_padding(0);</span>
458   }
459 
<span class="line-modified">460   maybe_activate_more_threads(worker_id, curr_cards);</span>
461 
462   // Process the next buffer, if there are enough left.
463   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
<span class="line-modified">464                                                    deactivation_threshold(worker_id),</span>
<span class="line-added">465                                                    total_refined_cards);</span>
466 }
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
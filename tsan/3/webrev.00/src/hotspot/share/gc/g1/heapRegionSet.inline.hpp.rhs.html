<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/heapRegionSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
 26 #define SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
 27 
<a name="1" id="anc1"></a><span class="line-added"> 28 #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
 29 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 30 
 31 inline void HeapRegionSetBase::add(HeapRegion* hr) {
 32   check_mt_safety();
 33   assert_heap_region_set(hr-&gt;containing_set() == NULL, &quot;should not already have a containing set&quot;);
 34   assert_heap_region_set(hr-&gt;next() == NULL, &quot;should not already be linked&quot;);
 35   assert_heap_region_set(hr-&gt;prev() == NULL, &quot;should not already be linked&quot;);
 36 
 37   _length++;
 38   hr-&gt;set_containing_set(this);
 39   verify_region(hr);
 40 }
 41 
 42 inline void HeapRegionSetBase::remove(HeapRegion* hr) {
 43   check_mt_safety();
 44   verify_region(hr);
 45   assert_heap_region_set(hr-&gt;next() == NULL, &quot;should already be unlinked&quot;);
 46   assert_heap_region_set(hr-&gt;prev() == NULL, &quot;should already be unlinked&quot;);
 47 
 48   hr-&gt;set_containing_set(NULL);
 49   assert_heap_region_set(_length &gt; 0, &quot;pre-condition&quot;);
 50   _length--;
 51 }
 52 
<a name="2" id="anc2"></a><span class="line-added"> 53 inline void FreeRegionList::add_to_tail(HeapRegion* region_to_add) {</span>
<span class="line-added"> 54   assert_free_region_list((length() == 0 &amp;&amp; _head == NULL &amp;&amp; _tail == NULL &amp;&amp; _last == NULL) ||</span>
<span class="line-added"> 55                           (length() &gt;  0 &amp;&amp; _head != NULL &amp;&amp; _tail != NULL &amp;&amp; _tail-&gt;hrm_index() &lt; region_to_add-&gt;hrm_index()),</span>
<span class="line-added"> 56                           &quot;invariant&quot;);</span>
<span class="line-added"> 57   // add() will verify the region and check mt safety.</span>
<span class="line-added"> 58   add(region_to_add);</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60   if (_head != NULL) {</span>
<span class="line-added"> 61     // Link into list, next is already NULL, no need to set.</span>
<span class="line-added"> 62     region_to_add-&gt;set_prev(_tail);</span>
<span class="line-added"> 63     _tail-&gt;set_next(region_to_add);</span>
<span class="line-added"> 64     _tail = region_to_add;</span>
<span class="line-added"> 65   } else {</span>
<span class="line-added"> 66     // Empty list, this region is now the list.</span>
<span class="line-added"> 67     _head = region_to_add;</span>
<span class="line-added"> 68     _tail = region_to_add;</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70   increase_length(region_to_add-&gt;node_index());</span>
<span class="line-added"> 71 }</span>
<span class="line-added"> 72 </span>
 73 inline void FreeRegionList::add_ordered(HeapRegion* hr) {
 74   assert_free_region_list((length() == 0 &amp;&amp; _head == NULL &amp;&amp; _tail == NULL &amp;&amp; _last == NULL) ||
 75                           (length() &gt;  0 &amp;&amp; _head != NULL &amp;&amp; _tail != NULL),
 76                           &quot;invariant&quot;);
 77   // add() will verify the region and check mt safety.
 78   add(hr);
 79 
 80   // Now link the region
 81   if (_head != NULL) {
 82     HeapRegion* curr;
 83 
 84     if (_last != NULL &amp;&amp; _last-&gt;hrm_index() &lt; hr-&gt;hrm_index()) {
 85       curr = _last;
 86     } else {
 87       curr = _head;
 88     }
 89 
 90     // Find first entry with a Region Index larger than entry to insert.
 91     while (curr != NULL &amp;&amp; curr-&gt;hrm_index() &lt; hr-&gt;hrm_index()) {
 92       curr = curr-&gt;next();
 93     }
 94 
 95     hr-&gt;set_next(curr);
 96 
 97     if (curr == NULL) {
 98       // Adding at the end
 99       hr-&gt;set_prev(_tail);
100       _tail-&gt;set_next(hr);
101       _tail = hr;
102     } else if (curr-&gt;prev() == NULL) {
103       // Adding at the beginning
104       hr-&gt;set_prev(NULL);
105       _head = hr;
106       curr-&gt;set_prev(hr);
107     } else {
108       hr-&gt;set_prev(curr-&gt;prev());
109       hr-&gt;prev()-&gt;set_next(hr);
110       curr-&gt;set_prev(hr);
111     }
112   } else {
113     // The list was empty
114     _tail = hr;
115     _head = hr;
116   }
117   _last = hr;
<a name="3" id="anc3"></a><span class="line-added">118 </span>
<span class="line-added">119   increase_length(hr-&gt;node_index());</span>
120 }
121 
122 inline HeapRegion* FreeRegionList::remove_from_head_impl() {
123   HeapRegion* result = _head;
124   _head = result-&gt;next();
125   if (_head == NULL) {
126     _tail = NULL;
127   } else {
128     _head-&gt;set_prev(NULL);
129   }
130   result-&gt;set_next(NULL);
131   return result;
132 }
133 
134 inline HeapRegion* FreeRegionList::remove_from_tail_impl() {
135   HeapRegion* result = _tail;
136 
137   _tail = result-&gt;prev();
138   if (_tail == NULL) {
139     _head = NULL;
140   } else {
141     _tail-&gt;set_next(NULL);
142   }
143   result-&gt;set_prev(NULL);
144   return result;
145 }
146 
147 inline HeapRegion* FreeRegionList::remove_region(bool from_head) {
148   check_mt_safety();
149   verify_optional();
150 
151   if (is_empty()) {
152     return NULL;
153   }
154   assert_free_region_list(length() &gt; 0 &amp;&amp; _head != NULL &amp;&amp; _tail != NULL, &quot;invariant&quot;);
155 
156   HeapRegion* hr;
157 
158   if (from_head) {
159     hr = remove_from_head_impl();
160   } else {
161     hr = remove_from_tail_impl();
162   }
163 
164   if (_last == hr) {
165     _last = NULL;
166   }
167 
168   // remove() will verify the region and check mt safety.
169   remove(hr);
<a name="4" id="anc4"></a><span class="line-added">170 </span>
<span class="line-added">171   decrease_length(hr-&gt;node_index());</span>
<span class="line-added">172 </span>
173   return hr;
174 }
175 
<a name="5" id="anc5"></a><span class="line-added">176 inline HeapRegion* FreeRegionList::remove_region_with_node_index(bool from_head,</span>
<span class="line-added">177                                                                  uint requested_node_index) {</span>
<span class="line-added">178   assert(UseNUMA, &quot;Invariant&quot;);</span>
<span class="line-added">179 </span>
<span class="line-added">180   const uint max_search_depth = G1NUMA::numa()-&gt;max_search_depth();</span>
<span class="line-added">181   HeapRegion* cur;</span>
<span class="line-added">182 </span>
<span class="line-added">183   // Find the region to use, searching from _head or _tail as requested.</span>
<span class="line-added">184   size_t cur_depth = 0;</span>
<span class="line-added">185   if (from_head) {</span>
<span class="line-added">186     for (cur = _head;</span>
<span class="line-added">187          cur != NULL &amp;&amp; cur_depth &lt; max_search_depth;</span>
<span class="line-added">188          cur = cur-&gt;next(), ++cur_depth) {</span>
<span class="line-added">189       if (requested_node_index == cur-&gt;node_index()) {</span>
<span class="line-added">190         break;</span>
<span class="line-added">191       }</span>
<span class="line-added">192     }</span>
<span class="line-added">193   } else {</span>
<span class="line-added">194     for (cur = _tail;</span>
<span class="line-added">195          cur != NULL &amp;&amp; cur_depth &lt; max_search_depth;</span>
<span class="line-added">196          cur = cur-&gt;prev(), ++cur_depth) {</span>
<span class="line-added">197       if (requested_node_index == cur-&gt;node_index()) {</span>
<span class="line-added">198         break;</span>
<span class="line-added">199       }</span>
<span class="line-added">200     }</span>
<span class="line-added">201   }</span>
<span class="line-added">202 </span>
<span class="line-added">203   // Didn&#39;t find a region to use.</span>
<span class="line-added">204   if (cur == NULL || cur_depth &gt;= max_search_depth) {</span>
<span class="line-added">205     return NULL;</span>
<span class="line-added">206   }</span>
<span class="line-added">207 </span>
<span class="line-added">208   // Splice the region out of the list.</span>
<span class="line-added">209   HeapRegion* prev = cur-&gt;prev();</span>
<span class="line-added">210   HeapRegion* next = cur-&gt;next();</span>
<span class="line-added">211   if (prev == NULL) {</span>
<span class="line-added">212     _head = next;</span>
<span class="line-added">213   } else {</span>
<span class="line-added">214     prev-&gt;set_next(next);</span>
<span class="line-added">215   }</span>
<span class="line-added">216   if (next == NULL) {</span>
<span class="line-added">217     _tail = prev;</span>
<span class="line-added">218   } else {</span>
<span class="line-added">219     next-&gt;set_prev(prev);</span>
<span class="line-added">220   }</span>
<span class="line-added">221   cur-&gt;set_prev(NULL);</span>
<span class="line-added">222   cur-&gt;set_next(NULL);</span>
<span class="line-added">223 </span>
<span class="line-added">224   if (_last == cur) {</span>
<span class="line-added">225     _last = NULL;</span>
<span class="line-added">226   }</span>
<span class="line-added">227 </span>
<span class="line-added">228   remove(cur);</span>
<span class="line-added">229   decrease_length(cur-&gt;node_index());</span>
<span class="line-added">230 </span>
<span class="line-added">231   return cur;</span>
<span class="line-added">232 }</span>
<span class="line-added">233 </span>
<span class="line-added">234 inline void FreeRegionList::NodeInfo::increase_length(uint node_index) {</span>
<span class="line-added">235   if (node_index &lt; _num_nodes) {</span>
<span class="line-added">236     _length_of_node[node_index] += 1;</span>
<span class="line-added">237   }</span>
<span class="line-added">238 }</span>
<span class="line-added">239 </span>
<span class="line-added">240 inline void FreeRegionList::NodeInfo::decrease_length(uint node_index) {</span>
<span class="line-added">241   if (node_index &lt; _num_nodes) {</span>
<span class="line-added">242     assert(_length_of_node[node_index] &gt; 0,</span>
<span class="line-added">243            &quot;Current length %u should be greater than zero for node %u&quot;,</span>
<span class="line-added">244            _length_of_node[node_index], node_index);</span>
<span class="line-added">245     _length_of_node[node_index] -= 1;</span>
<span class="line-added">246   }</span>
<span class="line-added">247 }</span>
<span class="line-added">248 </span>
<span class="line-added">249 inline uint FreeRegionList::NodeInfo::length(uint node_index) const {</span>
<span class="line-added">250   return _length_of_node[node_index];</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 inline void FreeRegionList::increase_length(uint node_index) {</span>
<span class="line-added">254   if (_node_info != NULL) {</span>
<span class="line-added">255     return _node_info-&gt;increase_length(node_index);</span>
<span class="line-added">256   }</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
<span class="line-added">259 inline void FreeRegionList::decrease_length(uint node_index) {</span>
<span class="line-added">260   if (_node_info != NULL) {</span>
<span class="line-added">261     return _node_info-&gt;decrease_length(node_index);</span>
<span class="line-added">262   }</span>
<span class="line-added">263 }</span>
<span class="line-added">264 </span>
<span class="line-added">265 inline uint FreeRegionList::length(uint node_index) const {</span>
<span class="line-added">266   if (_node_info != NULL) {</span>
<span class="line-added">267     return _node_info-&gt;length(node_index);</span>
<span class="line-added">268   } else {</span>
<span class="line-added">269     return 0;</span>
<span class="line-added">270   }</span>
<span class="line-added">271 }</span>
<span class="line-added">272 </span>
273 #endif // SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
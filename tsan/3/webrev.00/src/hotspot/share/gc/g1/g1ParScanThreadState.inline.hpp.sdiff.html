<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
 26 #define SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1OopStarChunkedList.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 31 #include &quot;gc/g1/g1RemSet.hpp&quot;
 32 #include &quot;oops/access.inline.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 
 35 template &lt;class T&gt; void G1ParScanThreadState::do_oop_evac(T* p) {
 36   // Reference should not be NULL here as such are never pushed to the task queue.
 37   oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 38 
 39   // Although we never intentionally push references outside of the collection
 40   // set, due to (benign) races in the claim mechanism during RSet scanning more
 41   // than one thread might claim the same card. So the same card may be
 42   // processed multiple times, and so we might get references into old gen here.
 43   // So we need to redo this check.
<span class="line-modified"> 44   const InCSetState in_cset_state = _g1h-&gt;in_cset_state(obj);</span>
 45   // References pushed onto the work stack should never point to a humongous region
 46   // as they are not added to the collection set due to above precondition.
<span class="line-modified"> 47   assert(!in_cset_state.is_humongous(),</span>
 48          &quot;Obj &quot; PTR_FORMAT &quot; should not refer to humongous region %u from &quot; PTR_FORMAT,
<span class="line-modified"> 49          p2i(obj), _g1h-&gt;addr_to_region((HeapWord*)obj), p2i(p));</span>
 50 
<span class="line-modified"> 51   if (!in_cset_state.is_in_cset()) {</span>
 52     // In this case somebody else already did all the work.
 53     return;
 54   }
 55 
<span class="line-modified"> 56   markOop m = obj-&gt;mark_raw();</span>
<span class="line-modified"> 57   if (m-&gt;is_marked()) {</span>
<span class="line-modified"> 58     obj = (oop) m-&gt;decode_pointer();</span>
 59   } else {
<span class="line-modified"> 60     obj = copy_to_survivor_space(in_cset_state, obj, m);</span>
 61   }
 62   RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);
 63 
 64   assert(obj != NULL, &quot;Must be&quot;);
 65   if (HeapRegion::is_in_same_region(p, obj)) {
 66     return;
 67   }
 68   HeapRegion* from = _g1h-&gt;heap_region_containing(p);
 69   if (!from-&gt;is_young()) {
<span class="line-modified"> 70     enqueue_card_if_tracked(p, obj);</span>
 71   }
 72 }
 73 
 74 template &lt;class T&gt; inline void G1ParScanThreadState::push_on_queue(T* ref) {
 75   assert(verify_ref(ref), &quot;sanity&quot;);
 76   _refs-&gt;push(ref);
 77 }
 78 
 79 inline void G1ParScanThreadState::do_oop_partial_array(oop* p) {
 80   assert(has_partial_array_mask(p), &quot;invariant&quot;);
 81   oop from_obj = clear_partial_array_mask(p);
 82 
 83   assert(_g1h-&gt;is_in_reserved(from_obj), &quot;must be in heap.&quot;);
 84   assert(from_obj-&gt;is_objArray(), &quot;must be obj array&quot;);
 85   objArrayOop from_obj_array = objArrayOop(from_obj);
 86   // The from-space object contains the real length.
 87   int length                 = from_obj_array-&gt;length();
 88 
 89   assert(from_obj-&gt;is_forwarded(), &quot;must be forwarded&quot;);
 90   oop to_obj                 = from_obj-&gt;forwardee();
</pre>
<hr />
<pre>
191 
192   const Ticks start = Ticks::now();
193   do {
194     trim_queue_to_threshold(_stack_trim_lower_threshold);
195   } while (!is_partially_trimmed());
196   _trim_ticks += Ticks::now() - start;
197 }
198 
199 inline Tickspan G1ParScanThreadState::trim_ticks() const {
200   return _trim_ticks;
201 }
202 
203 inline void G1ParScanThreadState::reset_trim_ticks() {
204   _trim_ticks = Tickspan();
205 }
206 
207 template &lt;typename T&gt;
208 inline void G1ParScanThreadState::remember_root_into_optional_region(T* p) {
209   oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
210   uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();


211   _oops_into_optional_regions[index].push_root(p);
212 }
213 
214 template &lt;typename T&gt;
215 inline void G1ParScanThreadState::remember_reference_into_optional_region(T* p) {
216   oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
217   uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();


218   _oops_into_optional_regions[index].push_oop(p);
219   DEBUG_ONLY(verify_ref(p);)
220 }
221 
222 G1OopStarChunkedList* G1ParScanThreadState::oops_into_optional_region(const HeapRegion* hr) {



223   return &amp;_oops_into_optional_regions[hr-&gt;index_in_opt_cset()];
224 }
225 


























226 #endif // SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #ifndef SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
 26 #define SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1OopStarChunkedList.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 31 #include &quot;gc/g1/g1RemSet.hpp&quot;
 32 #include &quot;oops/access.inline.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 
 35 template &lt;class T&gt; void G1ParScanThreadState::do_oop_evac(T* p) {
 36   // Reference should not be NULL here as such are never pushed to the task queue.
 37   oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 38 
 39   // Although we never intentionally push references outside of the collection
 40   // set, due to (benign) races in the claim mechanism during RSet scanning more
 41   // than one thread might claim the same card. So the same card may be
 42   // processed multiple times, and so we might get references into old gen here.
 43   // So we need to redo this check.
<span class="line-modified"> 44   const G1HeapRegionAttr region_attr = _g1h-&gt;region_attr(obj);</span>
 45   // References pushed onto the work stack should never point to a humongous region
 46   // as they are not added to the collection set due to above precondition.
<span class="line-modified"> 47   assert(!region_attr.is_humongous(),</span>
 48          &quot;Obj &quot; PTR_FORMAT &quot; should not refer to humongous region %u from &quot; PTR_FORMAT,
<span class="line-modified"> 49          p2i(obj), _g1h-&gt;addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj)), p2i(p));</span>
 50 
<span class="line-modified"> 51   if (!region_attr.is_in_cset()) {</span>
 52     // In this case somebody else already did all the work.
 53     return;
 54   }
 55 
<span class="line-modified"> 56   markWord m = obj-&gt;mark_raw();</span>
<span class="line-modified"> 57   if (m.is_marked()) {</span>
<span class="line-modified"> 58     obj = (oop) m.decode_pointer();</span>
 59   } else {
<span class="line-modified"> 60     obj = copy_to_survivor_space(region_attr, obj, m);</span>
 61   }
 62   RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);
 63 
 64   assert(obj != NULL, &quot;Must be&quot;);
 65   if (HeapRegion::is_in_same_region(p, obj)) {
 66     return;
 67   }
 68   HeapRegion* from = _g1h-&gt;heap_region_containing(p);
 69   if (!from-&gt;is_young()) {
<span class="line-modified"> 70     enqueue_card_if_tracked(_g1h-&gt;region_attr(obj), p, obj);</span>
 71   }
 72 }
 73 
 74 template &lt;class T&gt; inline void G1ParScanThreadState::push_on_queue(T* ref) {
 75   assert(verify_ref(ref), &quot;sanity&quot;);
 76   _refs-&gt;push(ref);
 77 }
 78 
 79 inline void G1ParScanThreadState::do_oop_partial_array(oop* p) {
 80   assert(has_partial_array_mask(p), &quot;invariant&quot;);
 81   oop from_obj = clear_partial_array_mask(p);
 82 
 83   assert(_g1h-&gt;is_in_reserved(from_obj), &quot;must be in heap.&quot;);
 84   assert(from_obj-&gt;is_objArray(), &quot;must be obj array&quot;);
 85   objArrayOop from_obj_array = objArrayOop(from_obj);
 86   // The from-space object contains the real length.
 87   int length                 = from_obj_array-&gt;length();
 88 
 89   assert(from_obj-&gt;is_forwarded(), &quot;must be forwarded&quot;);
 90   oop to_obj                 = from_obj-&gt;forwardee();
</pre>
<hr />
<pre>
191 
192   const Ticks start = Ticks::now();
193   do {
194     trim_queue_to_threshold(_stack_trim_lower_threshold);
195   } while (!is_partially_trimmed());
196   _trim_ticks += Ticks::now() - start;
197 }
198 
199 inline Tickspan G1ParScanThreadState::trim_ticks() const {
200   return _trim_ticks;
201 }
202 
203 inline void G1ParScanThreadState::reset_trim_ticks() {
204   _trim_ticks = Tickspan();
205 }
206 
207 template &lt;typename T&gt;
208 inline void G1ParScanThreadState::remember_root_into_optional_region(T* p) {
209   oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
210   uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();
<span class="line-added">211   assert(index &lt; _num_optional_regions,</span>
<span class="line-added">212          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT, index, _num_optional_regions);</span>
213   _oops_into_optional_regions[index].push_root(p);
214 }
215 
216 template &lt;typename T&gt;
217 inline void G1ParScanThreadState::remember_reference_into_optional_region(T* p) {
218   oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
219   uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();
<span class="line-added">220   assert(index &lt; _num_optional_regions,</span>
<span class="line-added">221          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT, index, _num_optional_regions);</span>
222   _oops_into_optional_regions[index].push_oop(p);
223   DEBUG_ONLY(verify_ref(p);)
224 }
225 
226 G1OopStarChunkedList* G1ParScanThreadState::oops_into_optional_region(const HeapRegion* hr) {
<span class="line-added">227   assert(hr-&gt;index_in_opt_cset() &lt; _num_optional_regions,</span>
<span class="line-added">228          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT &quot; &quot; HR_FORMAT,</span>
<span class="line-added">229          hr-&gt;index_in_opt_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));</span>
230   return &amp;_oops_into_optional_regions[hr-&gt;index_in_opt_cset()];
231 }
232 
<span class="line-added">233 void G1ParScanThreadState::initialize_numa_stats() {</span>
<span class="line-added">234   if (_numa-&gt;is_enabled()) {</span>
<span class="line-added">235     LogTarget(Info, gc, heap, numa) lt;</span>
<span class="line-added">236 </span>
<span class="line-added">237     if (lt.is_enabled()) {</span>
<span class="line-added">238       uint num_nodes = _numa-&gt;num_active_nodes();</span>
<span class="line-added">239       // Record only if there are multiple active nodes.</span>
<span class="line-added">240       _obj_alloc_stat = NEW_C_HEAP_ARRAY(size_t, num_nodes, mtGC);</span>
<span class="line-added">241       memset(_obj_alloc_stat, 0, sizeof(size_t) * num_nodes);</span>
<span class="line-added">242     }</span>
<span class="line-added">243   }</span>
<span class="line-added">244 }</span>
<span class="line-added">245 </span>
<span class="line-added">246 void G1ParScanThreadState::flush_numa_stats() {</span>
<span class="line-added">247   if (_obj_alloc_stat != NULL) {</span>
<span class="line-added">248     uint node_index = _numa-&gt;index_of_current_thread();</span>
<span class="line-added">249     _numa-&gt;copy_statistics(G1NUMAStats::LocalObjProcessAtCopyToSurv, node_index, _obj_alloc_stat);</span>
<span class="line-added">250   }</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 void G1ParScanThreadState::update_numa_stats(uint node_index) {</span>
<span class="line-added">254   if (_obj_alloc_stat != NULL) {</span>
<span class="line-added">255     _obj_alloc_stat[node_index]++;</span>
<span class="line-added">256   }</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
259 #endif // SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
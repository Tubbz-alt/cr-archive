<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1FullGCScope.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1GCPhaseTimes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -35,111 +35,125 @@</span>
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;runtime/timer.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
<span class="udiff-line-modified-removed">- static const char* Indents[5] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;};</span>
<span class="udiff-line-modified-added">+ static const char* indent(uint level) {</span>
<span class="udiff-line-added">+   static const char* Indents[] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;, &quot;          &quot;};</span>
<span class="udiff-line-added">+   assert(level &lt; ARRAY_SIZE(Indents), &quot;Too high indent level %u&quot;, level);</span>
<span class="udiff-line-added">+   return Indents[level];</span>
<span class="udiff-line-added">+ }</span>
  
  G1GCPhaseTimes::G1GCPhaseTimes(STWGCTimer* gc_timer, uint max_gc_threads) :
    _max_gc_threads(max_gc_threads),
    _gc_start_counter(0),
    _gc_pause_time_ms(0.0),
    _ref_phase_times(gc_timer, max_gc_threads),
    _weak_phase_times(max_gc_threads)
  {
    assert(max_gc_threads &gt; 0, &quot;Must have some GC threads&quot;);
  
<span class="udiff-line-modified-removed">-   _gc_par_phases[GCWorkerStart] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Start (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ExtRootScan] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Ext Root Scanning (ms):&quot;);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[GCWorkerStart] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Start (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ExtRootScan] = new WorkerDataArray&lt;double&gt;(&quot;Ext Root Scanning (ms):&quot;, max_gc_threads);</span>
  
    // Root scanning phases
<span class="udiff-line-modified-removed">-   _gc_par_phases[ThreadRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Thread Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[UniverseRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Universe Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[JNIRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;JNI Handles Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ObjectSynchronizerRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;ObjectSynchronizer Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ManagementRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Management Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[SystemDictionaryRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;SystemDictionary Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[CLDGRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;CLDG Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[JVMTIRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;JVMTI Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">- #if INCLUDE_AOT</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[AOTCodeRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;AOT Root Scan (ms):&quot;);</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[CMRefRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;CM RefProcessor Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[WaitForStrongCLD] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Wait For Strong CLD (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[WeakCLDRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Weak CLD Roots (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[SATBFiltering] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;SATB Filtering (ms):&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[UpdateRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Update RS (ms):&quot;);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ThreadRoots] = new WorkerDataArray&lt;double&gt;(&quot;Thread Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[UniverseRoots] = new WorkerDataArray&lt;double&gt;(&quot;Universe Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[JNIRoots] = new WorkerDataArray&lt;double&gt;(&quot;JNI Handles Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ObjectSynchronizerRoots] = new WorkerDataArray&lt;double&gt;(&quot;ObjectSynchronizer Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ManagementRoots] = new WorkerDataArray&lt;double&gt;(&quot;Management Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[SystemDictionaryRoots] = new WorkerDataArray&lt;double&gt;(&quot;SystemDictionary Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[CLDGRoots] = new WorkerDataArray&lt;double&gt;(&quot;CLDG Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[JVMTIRoots] = new WorkerDataArray&lt;double&gt;(&quot;JVMTI Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   AOT_ONLY(_gc_par_phases[AOTCodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;AOT Root Scan (ms):&quot;, max_gc_threads);)</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[CMRefRoots] = new WorkerDataArray&lt;double&gt;(&quot;CM RefProcessor Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeER] = new WorkerDataArray&lt;double&gt;(&quot;Eager Reclaim (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeRS] = new WorkerDataArray&lt;double&gt;(&quot;Remembered Sets (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Sparse:&quot;, MergeRSMergedSparse);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Fine:&quot;, MergeRSMergedFine);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Merged Coarse:&quot;, MergeRSMergedCoarse);</span>
<span class="udiff-line-added">+   _gc_par_phases[MergeRS]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeRSDirtyCards);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _gc_par_phases[OptMergeRS] = new WorkerDataArray&lt;double&gt;(&quot;Optional Remembered Sets (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-added">+   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Sparse:&quot;, MergeRSMergedSparse);</span>
<span class="udiff-line-added">+   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Fine:&quot;, MergeRSMergedFine);</span>
<span class="udiff-line-added">+   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Merged Coarse:&quot;, MergeRSMergedCoarse);</span>
<span class="udiff-line-added">+   _gc_par_phases[OptMergeRS]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeRSDirtyCards);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   _gc_par_phases[MergeLB] = new WorkerDataArray&lt;double&gt;(&quot;Log Buffers (ms):&quot;, max_gc_threads);</span>
    if (G1HotCardCache::default_use_cache()) {
<span class="udiff-line-modified-removed">-     _gc_par_phases[ScanHCC] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Scan HCC (ms):&quot;);</span>
<span class="udiff-line-modified-added">+     _gc_par_phases[MergeHCC] = new WorkerDataArray&lt;double&gt;(&quot;Hot Card Cache (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-added">+     _gc_par_phases[MergeHCC]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeHCCDirtyCards);</span>
<span class="udiff-line-added">+     _gc_par_phases[MergeHCC]-&gt;create_thread_work_items(&quot;Skipped Cards:&quot;, MergeHCCSkippedCards);</span>
    } else {
<span class="udiff-line-modified-removed">-     _gc_par_phases[ScanHCC] = NULL;</span>
<span class="udiff-line-modified-added">+     _gc_par_phases[MergeHCC] = NULL;</span>
    }
<span class="udiff-line-modified-removed">-   _gc_par_phases[ScanRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Scan RS (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptScanRS] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Optional Scan RS (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[CodeRoots] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Code Root Scanning (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ObjCopy] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Object Copy (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptObjCopy] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Optional Object Copy (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[Termination] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Termination (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[GCWorkerTotal] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Total (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[GCWorkerEnd] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker End (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[Other] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;GC Worker Other (ms):&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _scan_rs_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_scanned_cards, ScanRSScannedCards);</span>
<span class="udiff-line-modified-removed">-   _scan_rs_claimed_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Claimed Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_claimed_cards, ScanRSClaimedCards);</span>
<span class="udiff-line-modified-removed">-   _scan_rs_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[ScanRS]-&gt;link_thread_work_items(_scan_rs_skipped_cards, ScanRSSkippedCards);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _opt_cset_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_scanned_cards, OptCSetScannedCards);</span>
<span class="udiff-line-modified-removed">-   _opt_cset_claimed_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Claimed Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_claimed_cards, OptCSetClaimedCards);</span>
<span class="udiff-line-modified-removed">-   _opt_cset_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_skipped_cards, OptCSetSkippedCards);</span>
<span class="udiff-line-modified-removed">-   _opt_cset_used_memory = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Used Memory:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[OptScanRS]-&gt;link_thread_work_items(_opt_cset_used_memory, OptCSetUsedMemory);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _update_rs_processed_buffers = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Processed Buffers:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_processed_buffers, UpdateRSProcessedBuffers);</span>
<span class="udiff-line-modified-removed">-   _update_rs_scanned_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Scanned Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_scanned_cards, UpdateRSScannedCards);</span>
<span class="udiff-line-modified-removed">-   _update_rs_skipped_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Skipped Cards:&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[UpdateRS]-&gt;link_thread_work_items(_update_rs_skipped_cards, UpdateRSSkippedCards);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _obj_copy_lab_waste = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;LAB Waste&quot;);</span>
<span class="udiff-line-removed">-   _gc_par_phases[ObjCopy]-&gt;link_thread_work_items(_obj_copy_lab_waste, ObjCopyLABWaste);</span>
<span class="udiff-line-removed">-   _obj_copy_lab_undo_waste = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;LAB Undo Waste&quot;);</span>
<span class="udiff-line-removed">-   _gc_par_phases[ObjCopy]-&gt;link_thread_work_items(_obj_copy_lab_undo_waste, ObjCopyLABUndoWaste);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   _termination_attempts = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Termination Attempts:&quot;);</span>
<span class="udiff-line-removed">-   _gc_par_phases[Termination]-&gt;link_thread_work_items(_termination_attempts);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ScanHR] = new WorkerDataArray&lt;double&gt;(&quot;Scan Heap Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR] = new WorkerDataArray&lt;double&gt;(&quot;Optional Scan Heap Roots (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[CodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;Code Root Scan (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptCodeRoots] = new WorkerDataArray&lt;double&gt;(&quot;Optional Code Root Scan (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ObjCopy] = new WorkerDataArray&lt;double&gt;(&quot;Object Copy (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptObjCopy] = new WorkerDataArray&lt;double&gt;(&quot;Optional Object Copy (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[Termination] = new WorkerDataArray&lt;double&gt;(&quot;Termination (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptTermination] = new WorkerDataArray&lt;double&gt;(&quot;Optional Termination (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[GCWorkerTotal] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Total (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[GCWorkerEnd] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker End (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[Other] = new WorkerDataArray&lt;double&gt;(&quot;GC Worker Other (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Scanned Cards:&quot;, ScanHRScannedCards);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Scanned Blocks:&quot;, ScanHRScannedBlocks);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ScanHR]-&gt;create_thread_work_items(&quot;Claimed Chunks:&quot;, ScanHRClaimedChunks);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Cards:&quot;, ScanHRScannedCards);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Blocks:&quot;, ScanHRScannedBlocks);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Claimed Chunks:&quot;, ScanHRClaimedChunks);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Scanned Refs:&quot;, ScanHRScannedOptRefs);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptScanHR]-&gt;create_thread_work_items(&quot;Used Memory:&quot;, ScanHRUsedMemory);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeLB]-&gt;create_thread_work_items(&quot;Dirty Cards:&quot;, MergeLBDirtyCards);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergeLB]-&gt;create_thread_work_items(&quot;Skipped Cards:&quot;, MergeLBSkippedCards);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergePSS] = new WorkerDataArray&lt;double&gt;(&quot;Merge Per-Thread State&quot;, 1 /* length */, true /* is_serial */);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;Copied Bytes&quot;, MergePSSCopiedBytes, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;LAB Waste&quot;, MergePSSLABWasteBytes, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[MergePSS]-&gt;create_thread_work_items(&quot;LAB Undo Waste&quot;, MergePSSLABUndoWasteBytes, max_gc_threads);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[Termination]-&gt;create_thread_work_items(&quot;Termination Attempts:&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   _gc_par_phases[OptTermination]-&gt;create_thread_work_items(&quot;Optional Termination Attempts:&quot;);</span>
  
    if (UseStringDeduplication) {
<span class="udiff-line-modified-removed">-     _gc_par_phases[StringDedupQueueFixup] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Queue Fixup (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-     _gc_par_phases[StringDedupTableFixup] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Table Fixup (ms):&quot;);</span>
<span class="udiff-line-modified-added">+     _gc_par_phases[StringDedupQueueFixup] = new WorkerDataArray&lt;double&gt;(&quot;Queue Fixup (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+     _gc_par_phases[StringDedupTableFixup] = new WorkerDataArray&lt;double&gt;(&quot;Table Fixup (ms):&quot;, max_gc_threads);</span>
    } else {
      _gc_par_phases[StringDedupQueueFixup] = NULL;
      _gc_par_phases[StringDedupTableFixup] = NULL;
    }
  
<span class="udiff-line-modified-removed">-   _gc_par_phases[RedirtyCards] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Parallel Redirty (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _redirtied_cards = new WorkerDataArray&lt;size_t&gt;(max_gc_threads, &quot;Redirtied Cards:&quot;);</span>
<span class="udiff-line-removed">-   _gc_par_phases[RedirtyCards]-&gt;link_thread_work_items(_redirtied_cards);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[RedirtyCards] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Redirty (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[RedirtyCards]-&gt;create_thread_work_items(&quot;Redirtied Cards:&quot;);</span>
  
<span class="udiff-line-modified-removed">-   _gc_par_phases[YoungFreeCSet] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Young Free Collection Set (ms):&quot;);</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(max_gc_threads, &quot;Non-Young Free Collection Set (ms):&quot;);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[ParFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[YoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Young Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-added">+   _gc_par_phases[NonYoungFreeCSet] = new WorkerDataArray&lt;double&gt;(&quot;Non-Young Free Collection Set (ms):&quot;, max_gc_threads);</span>
<span class="udiff-line-added">+   _gc_par_phases[RebuildFreeList] = new WorkerDataArray&lt;double&gt;(&quot;Parallel Rebuild Free List (ms):&quot;, max_gc_threads);</span>
  
    reset();
  }
  
  void G1GCPhaseTimes::reset() {
<span class="udiff-line-modified-removed">-   _cur_collection_par_time_ms = 0.0;</span>
<span class="udiff-line-modified-removed">-   _cur_optional_evac_ms = 0.0;</span>
<span class="udiff-line-modified-added">+   _cur_collection_initial_evac_time_ms = 0.0;</span>
<span class="udiff-line-modified-added">+   _cur_optional_evac_time_ms = 0.0;</span>
    _cur_collection_code_root_fixup_time_ms = 0.0;
    _cur_strong_code_root_purge_time_ms = 0.0;
<span class="udiff-line-added">+   _cur_merge_heap_roots_time_ms = 0.0;</span>
<span class="udiff-line-added">+   _cur_optional_merge_heap_roots_time_ms = 0.0;</span>
<span class="udiff-line-added">+   _cur_prepare_merge_heap_roots_time_ms = 0.0;</span>
<span class="udiff-line-added">+   _cur_optional_prepare_merge_heap_roots_time_ms = 0.0;</span>
    _cur_evac_fail_recalc_used = 0.0;
    _cur_evac_fail_remove_self_forwards = 0.0;
    _cur_string_deduplication_time_ms = 0.0;
    _cur_prepare_tlab_time_ms = 0.0;
    _cur_resize_tlab_time_ms = 0.0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,21 +162,23 @@</span>
    _cur_expand_heap_time_ms = 0.0;
    _cur_ref_proc_time_ms = 0.0;
    _cur_collection_start_sec = 0.0;
    _root_region_scan_wait_time_ms = 0.0;
    _external_accounted_time_ms = 0.0;
<span class="udiff-line-added">+   _recorded_prepare_heap_roots_time_ms = 0.0;</span>
    _recorded_clear_claimed_marks_time_ms = 0.0;
    _recorded_young_cset_choice_time_ms = 0.0;
    _recorded_non_young_cset_choice_time_ms = 0.0;
    _recorded_redirty_logged_cards_time_ms = 0.0;
    _recorded_preserve_cm_referents_time_ms = 0.0;
<span class="udiff-line-removed">-   _recorded_merge_pss_time_ms = 0.0;</span>
    _recorded_start_new_cset_time_ms = 0.0;
    _recorded_total_free_cset_time_ms = 0.0;
    _recorded_serial_free_cset_time_ms = 0.0;
<span class="udiff-line-added">+   _recorded_total_rebuild_freelist_time_ms = 0.0;</span>
<span class="udiff-line-added">+   _recorded_serial_rebuild_freelist_time_ms = 0.0;</span>
    _cur_fast_reclaim_humongous_time_ms = 0.0;
<span class="udiff-line-modified-removed">-   _cur_fast_reclaim_humongous_register_time_ms = 0.0;</span>
<span class="udiff-line-modified-added">+   _cur_region_register_time = 0.0;</span>
    _cur_fast_reclaim_humongous_total = 0;
    _cur_fast_reclaim_humongous_candidates = 0;
    _cur_fast_reclaim_humongous_reclaimed = 0;
    _cur_verify_before_time_ms = 0.0;
    _cur_verify_after_time_ms = 0.0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,91 +223,108 @@</span>
        assert(_gc_par_phases[GCWorkerEnd]-&gt;get(i) != uninitialized, &quot;Worker started but not ended.&quot;);
        double total_worker_time = _gc_par_phases[GCWorkerEnd]-&gt;get(i) - _gc_par_phases[GCWorkerStart]-&gt;get(i);
        record_time_secs(GCWorkerTotal, i , total_worker_time);
  
        double worker_known_time = worker_time(ExtRootScan, i) +
<span class="udiff-line-modified-removed">-                                  worker_time(ScanHCC, i) +</span>
<span class="udiff-line-removed">-                                  worker_time(UpdateRS, i) +</span>
<span class="udiff-line-removed">-                                  worker_time(ScanRS, i) +</span>
<span class="udiff-line-modified-added">+                                  worker_time(ScanHR, i) +</span>
                                   worker_time(CodeRoots, i) +
                                   worker_time(ObjCopy, i) +
                                   worker_time(Termination, i);
  
        record_time_secs(Other, i, total_worker_time - worker_known_time);
      } else {
        // Make sure all slots are uninitialized since this thread did not seem to have been started
        ASSERT_PHASE_UNINITIALIZED(GCWorkerEnd);
        ASSERT_PHASE_UNINITIALIZED(ExtRootScan);
<span class="udiff-line-modified-removed">-       ASSERT_PHASE_UNINITIALIZED(ScanHCC);</span>
<span class="udiff-line-modified-removed">-       ASSERT_PHASE_UNINITIALIZED(UpdateRS);</span>
<span class="udiff-line-modified-removed">-       ASSERT_PHASE_UNINITIALIZED(ScanRS);</span>
<span class="udiff-line-modified-added">+       ASSERT_PHASE_UNINITIALIZED(MergeER);</span>
<span class="udiff-line-modified-added">+       ASSERT_PHASE_UNINITIALIZED(MergeRS);</span>
<span class="udiff-line-modified-added">+       ASSERT_PHASE_UNINITIALIZED(OptMergeRS);</span>
<span class="udiff-line-added">+       ASSERT_PHASE_UNINITIALIZED(MergeHCC);</span>
<span class="udiff-line-added">+       ASSERT_PHASE_UNINITIALIZED(MergeLB);</span>
<span class="udiff-line-added">+       ASSERT_PHASE_UNINITIALIZED(ScanHR);</span>
        ASSERT_PHASE_UNINITIALIZED(CodeRoots);
<span class="udiff-line-added">+       ASSERT_PHASE_UNINITIALIZED(OptCodeRoots);</span>
        ASSERT_PHASE_UNINITIALIZED(ObjCopy);
<span class="udiff-line-added">+       ASSERT_PHASE_UNINITIALIZED(OptObjCopy);</span>
        ASSERT_PHASE_UNINITIALIZED(Termination);
      }
    }
  }
  
  #undef ASSERT_PHASE_UNINITIALIZED
  
  // record the time a phase took in seconds
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::record_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[phase]-&gt;set(worker_i, secs);</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::record_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[phase]-&gt;set(worker_id, secs);</span>
  }
  
  // add a number of seconds to a phase
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::add_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[phase]-&gt;add(worker_i, secs);</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::add_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[phase]-&gt;add(worker_id, secs);</span>
  }
  
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::record_or_add_time_secs(GCParPhases phase, uint worker_i, double secs) {</span>
<span class="udiff-line-modified-removed">-   if (_gc_par_phases[phase]-&gt;get(worker_i) == _gc_par_phases[phase]-&gt;uninitialized()) {</span>
<span class="udiff-line-modified-removed">-     record_time_secs(phase, worker_i, secs);</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::record_or_add_time_secs(GCParPhases phase, uint worker_id, double secs) {</span>
<span class="udiff-line-modified-added">+   if (_gc_par_phases[phase]-&gt;get(worker_id) == _gc_par_phases[phase]-&gt;uninitialized()) {</span>
<span class="udiff-line-modified-added">+     record_time_secs(phase, worker_id, secs);</span>
    } else {
<span class="udiff-line-modified-removed">-     add_time_secs(phase, worker_i, secs);</span>
<span class="udiff-line-modified-added">+     add_time_secs(phase, worker_id, secs);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::record_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index) {</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[phase]-&gt;set_thread_work_item(worker_i, count, index);</span>
<span class="udiff-line-modified-added">+ double G1GCPhaseTimes::get_time_secs(GCParPhases phase, uint worker_id) {</span>
<span class="udiff-line-modified-added">+   return _gc_par_phases[phase]-&gt;get(worker_id);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1GCPhaseTimes::record_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index) {</span>
<span class="udiff-line-added">+   _gc_par_phases[phase]-&gt;set_thread_work_item(worker_id, count, index);</span>
  }
  
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::record_or_add_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index) {</span>
<span class="udiff-line-modified-removed">-   _gc_par_phases[phase]-&gt;set_or_add_thread_work_item(worker_i, count, index);</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::record_or_add_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index) {</span>
<span class="udiff-line-modified-added">+   _gc_par_phases[phase]-&gt;set_or_add_thread_work_item(worker_id, count, index);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t G1GCPhaseTimes::get_thread_work_item(GCParPhases phase, uint worker_id, uint index) {</span>
<span class="udiff-line-added">+   return _gc_par_phases[phase]-&gt;get_thread_work_item(worker_id, index);</span>
  }
  
  // return the average time for a phase in milliseconds
  double G1GCPhaseTimes::average_time_ms(GCParPhases phase) {
<span class="udiff-line-added">+   if (_gc_par_phases[phase] == NULL) {</span>
<span class="udiff-line-added">+     return 0.0;</span>
<span class="udiff-line-added">+   }</span>
    return _gc_par_phases[phase]-&gt;average() * 1000.0;
  }
  
  size_t G1GCPhaseTimes::sum_thread_work_items(GCParPhases phase, uint index) {
<span class="udiff-line-added">+   if (_gc_par_phases[phase] == NULL) {</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+   }</span>
    assert(_gc_par_phases[phase]-&gt;thread_work_items(index) != NULL, &quot;No sub count&quot;);
    return _gc_par_phases[phase]-&gt;thread_work_items(index)-&gt;sum();
  }
  
  template &lt;class T&gt;
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::details(T* phase, const char* indent) const {</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::details(T* phase, const char* indent_str) const {</span>
    LogTarget(Trace, gc, phases, task) lt;
    if (lt.is_enabled()) {
      LogStream ls(lt);
<span class="udiff-line-modified-removed">-     ls.print(&quot;%s&quot;, indent);</span>
<span class="udiff-line-modified-added">+     ls.print(&quot;%s&quot;, indent_str);</span>
      phase-&gt;print_details_on(&amp;ls);
    }
  }
  
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent, outputStream* out, bool print_sum) const {</span>
<span class="udiff-line-modified-removed">-   out-&gt;print(&quot;%s&quot;, Indents[indent]);</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent_level, outputStream* out, bool print_sum) const {</span>
<span class="udiff-line-modified-added">+   out-&gt;print(&quot;%s&quot;, indent(indent_level));</span>
    phase-&gt;print_summary_on(out, print_sum);
<span class="udiff-line-modified-removed">-   details(phase, Indents[indent]);</span>
<span class="udiff-line-modified-added">+   details(phase, indent(indent_level));</span>
  
    for (uint i = 0; i &lt; phase-&gt;MaxThreadWorkItems; i++) {
      WorkerDataArray&lt;size_t&gt;* work_items = phase-&gt;thread_work_items(i);
      if (work_items != NULL) {
<span class="udiff-line-modified-removed">-       out-&gt;print(&quot;%s&quot;, Indents[indent + 1]);</span>
<span class="udiff-line-modified-added">+       out-&gt;print(&quot;%s&quot;, indent(indent_level + 1));</span>
        work_items-&gt;print_summary_on(out, true);
<span class="udiff-line-modified-removed">-       details(work_items, Indents[indent + 1]);</span>
<span class="udiff-line-modified-added">+       details(work_items, indent(indent_level + 1));</span>
      }
    }
  }
  
  void G1GCPhaseTimes::debug_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,123 +334,139 @@</span>
      LogStream ls(lt);
      log_phase(phase, 2 + extra_indent, &amp;ls, true);
    }
  }
  
<span class="udiff-line-modified-removed">- void G1GCPhaseTimes::trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum) const {</span>
<span class="udiff-line-modified-added">+ void G1GCPhaseTimes::trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum, uint extra_indent) const {</span>
    LogTarget(Trace, gc, phases) lt;
    if (lt.is_enabled()) {
      LogStream ls(lt);
<span class="udiff-line-modified-removed">-     log_phase(phase, 3, &amp;ls, print_sum);</span>
<span class="udiff-line-modified-added">+     log_phase(phase, 3 + extra_indent, &amp;ls, print_sum);</span>
    }
  }
  
  #define TIME_FORMAT &quot;%.1lfms&quot;
  
  void G1GCPhaseTimes::info_time(const char* name, double value) const {
<span class="udiff-line-modified-removed">-   log_info(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[1], name, value);</span>
<span class="udiff-line-modified-added">+   log_info(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(1), name, value);</span>
  }
  
  void G1GCPhaseTimes::debug_time(const char* name, double value) const {
<span class="udiff-line-modified-removed">-   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
<span class="udiff-line-modified-added">+   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
  }
  
  void G1GCPhaseTimes::debug_time_for_reference(const char* name, double value) const {
    LogTarget(Debug, gc, phases) lt;
    LogTarget(Debug, gc, phases, ref) lt2;
  
    if (lt.is_enabled()) {
      LogStream ls(lt);
<span class="udiff-line-modified-removed">-     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
<span class="udiff-line-modified-added">+     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
    } else if (lt2.is_enabled()) {
      LogStream ls(lt2);
<span class="udiff-line-modified-removed">-     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, Indents[2], name, value);</span>
<span class="udiff-line-modified-added">+     ls.print_cr(&quot;%s%s: &quot; TIME_FORMAT, indent(2), name, value);</span>
    }
  }
  
  void G1GCPhaseTimes::trace_time(const char* name, double value) const {
<span class="udiff-line-modified-removed">-   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, Indents[3], name, value);</span>
<span class="udiff-line-modified-added">+   log_trace(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT, indent(3), name, value);</span>
  }
  
  void G1GCPhaseTimes::trace_count(const char* name, size_t value) const {
<span class="udiff-line-modified-removed">-   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, Indents[3], name, value);</span>
<span class="udiff-line-modified-added">+   log_trace(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT, indent(3), name, value);</span>
  }
  
  double G1GCPhaseTimes::print_pre_evacuate_collection_set() const {
    const double sum_ms = _root_region_scan_wait_time_ms +
                          _recorded_young_cset_choice_time_ms +
                          _recorded_non_young_cset_choice_time_ms +
<span class="udiff-line-modified-removed">-                         _cur_fast_reclaim_humongous_register_time_ms +</span>
<span class="udiff-line-modified-added">+                         _cur_region_register_time +</span>
<span class="udiff-line-added">+                         _recorded_prepare_heap_roots_time_ms +</span>
                          _recorded_clear_claimed_marks_time_ms;
  
    info_time(&quot;Pre Evacuate Collection Set&quot;, sum_ms);
  
    if (_root_region_scan_wait_time_ms &gt; 0.0) {
      debug_time(&quot;Root Region Scan Waiting&quot;, _root_region_scan_wait_time_ms);
    }
    debug_time(&quot;Prepare TLABs&quot;, _cur_prepare_tlab_time_ms);
    debug_time(&quot;Choose Collection Set&quot;, (_recorded_young_cset_choice_time_ms + _recorded_non_young_cset_choice_time_ms));
<span class="udiff-line-added">+   debug_time(&quot;Region Register&quot;, _cur_region_register_time);</span>
    if (G1EagerReclaimHumongousObjects) {
<span class="udiff-line-removed">-     debug_time(&quot;Humongous Register&quot;, _cur_fast_reclaim_humongous_register_time_ms);</span>
      trace_count(&quot;Humongous Total&quot;, _cur_fast_reclaim_humongous_total);
      trace_count(&quot;Humongous Candidate&quot;, _cur_fast_reclaim_humongous_candidates);
    }
  
<span class="udiff-line-added">+   debug_time(&quot;Prepare Heap Roots&quot;, _recorded_prepare_heap_roots_time_ms);</span>
    if (_recorded_clear_claimed_marks_time_ms &gt; 0.0) {
      debug_time(&quot;Clear Claimed Marks&quot;, _recorded_clear_claimed_marks_time_ms);
    }
    return sum_ms;
  }
  
  double G1GCPhaseTimes::print_evacuate_optional_collection_set() const {
<span class="udiff-line-modified-removed">-   const double sum_ms = _cur_optional_evac_ms;</span>
<span class="udiff-line-modified-added">+   const double sum_ms = _cur_optional_evac_time_ms + _cur_optional_merge_heap_roots_time_ms;</span>
    if (sum_ms &gt; 0) {
<span class="udiff-line-modified-removed">-     info_time(&quot;Evacuate Optional Collection Set&quot;, sum_ms);</span>
<span class="udiff-line-modified-removed">-     debug_phase(_gc_par_phases[OptScanRS]);</span>
<span class="udiff-line-modified-added">+     info_time(&quot;Merge Optional Heap Roots&quot;, _cur_optional_merge_heap_roots_time_ms);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     debug_time(&quot;Prepare Optional Merge Heap Roots&quot;, _cur_optional_prepare_merge_heap_roots_time_ms);</span>
<span class="udiff-line-added">+     debug_phase(_gc_par_phases[OptMergeRS]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     info_time(&quot;Evacuate Optional Collection Set&quot;, _cur_optional_evac_time_ms);</span>
<span class="udiff-line-added">+     debug_phase(_gc_par_phases[OptScanHR]);</span>
      debug_phase(_gc_par_phases[OptObjCopy]);
<span class="udiff-line-added">+     debug_phase(_gc_par_phases[OptCodeRoots]);</span>
<span class="udiff-line-added">+     debug_phase(_gc_par_phases[OptTermination]);</span>
    }
    return sum_ms;
  }
  
<span class="udiff-line-modified-removed">- double G1GCPhaseTimes::print_evacuate_collection_set() const {</span>
<span class="udiff-line-modified-removed">-   const double sum_ms = _cur_collection_par_time_ms;</span>
<span class="udiff-line-modified-added">+ double G1GCPhaseTimes::print_evacuate_initial_collection_set() const {</span>
<span class="udiff-line-modified-added">+   info_time(&quot;Merge Heap Roots&quot;, _cur_merge_heap_roots_time_ms);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   debug_time(&quot;Prepare Merge Heap Roots&quot;, _cur_prepare_merge_heap_roots_time_ms);</span>
<span class="udiff-line-added">+   debug_phase(_gc_par_phases[MergeER]);</span>
<span class="udiff-line-added">+   debug_phase(_gc_par_phases[MergeRS]);</span>
<span class="udiff-line-added">+   if (G1HotCardCache::default_use_cache()) {</span>
<span class="udiff-line-added">+     debug_phase(_gc_par_phases[MergeHCC]);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   debug_phase(_gc_par_phases[MergeLB]);</span>
  
<span class="udiff-line-modified-removed">-   info_time(&quot;Evacuate Collection Set&quot;, sum_ms);</span>
<span class="udiff-line-modified-added">+   info_time(&quot;Evacuate Collection Set&quot;, _cur_collection_initial_evac_time_ms);</span>
  
    trace_phase(_gc_par_phases[GCWorkerStart], false);
    debug_phase(_gc_par_phases[ExtRootScan]);
<span class="udiff-line-modified-removed">-   for (int i = ExtRootScanSubPhasesStart; i &lt;= ExtRootScanSubPhasesEnd; i++) {</span>
<span class="udiff-line-modified-added">+   for (int i = ExtRootScanSubPhasesFirst; i &lt;= ExtRootScanSubPhasesLast; i++) {</span>
      trace_phase(_gc_par_phases[i]);
    }
<span class="udiff-line-modified-removed">-   if (G1HotCardCache::default_use_cache()) {</span>
<span class="udiff-line-removed">-     debug_phase(_gc_par_phases[ScanHCC]);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   debug_phase(_gc_par_phases[UpdateRS]);</span>
<span class="udiff-line-removed">-   debug_phase(_gc_par_phases[ScanRS]);</span>
<span class="udiff-line-modified-added">+   debug_phase(_gc_par_phases[ScanHR]);</span>
    debug_phase(_gc_par_phases[CodeRoots]);
    debug_phase(_gc_par_phases[ObjCopy]);
    debug_phase(_gc_par_phases[Termination]);
    debug_phase(_gc_par_phases[Other]);
    debug_phase(_gc_par_phases[GCWorkerTotal]);
    trace_phase(_gc_par_phases[GCWorkerEnd], false);
  
<span class="udiff-line-modified-removed">-   return sum_ms;</span>
<span class="udiff-line-modified-added">+   return _cur_collection_initial_evac_time_ms + _cur_merge_heap_roots_time_ms;</span>
  }
  
  double G1GCPhaseTimes::print_post_evacuate_collection_set() const {
    const double evac_fail_handling = _cur_evac_fail_recalc_used +
                                      _cur_evac_fail_remove_self_forwards;
<span class="udiff-line-added">+   assert(_gc_par_phases[MergePSS]-&gt;get(0) != WorkerDataArray&lt;double&gt;::uninitialized(), &quot;must be set&quot;);</span>
<span class="udiff-line-added">+   const double merge_pss = _gc_par_phases[MergePSS]-&gt;get(0) * MILLIUNITS;</span>
    const double sum_ms = evac_fail_handling +
                          _cur_collection_code_root_fixup_time_ms +
                          _recorded_preserve_cm_referents_time_ms +
                          _cur_ref_proc_time_ms +
                          (_weak_phase_times.total_time_sec() * MILLIUNITS) +
                          _cur_clear_ct_time_ms +
<span class="udiff-line-modified-removed">-                         _recorded_merge_pss_time_ms +</span>
<span class="udiff-line-modified-added">+                         merge_pss +</span>
                          _cur_strong_code_root_purge_time_ms +
                          _recorded_redirty_logged_cards_time_ms +
                          _recorded_total_free_cset_time_ms +
<span class="udiff-line-added">+                         _recorded_total_rebuild_freelist_time_ms +</span>
                          _cur_fast_reclaim_humongous_time_ms +
                          _cur_expand_heap_time_ms +
                          _cur_string_deduplication_time_ms;
  
    info_time(&quot;Post Evacuate Collection Set&quot;, sum_ms);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,23 +489,28 @@</span>
      debug_time(&quot;Evacuation Failure&quot;, evac_fail_handling);
      trace_time(&quot;Recalculate Used&quot;, _cur_evac_fail_recalc_used);
      trace_time(&quot;Remove Self Forwards&quot;,_cur_evac_fail_remove_self_forwards);
    }
  
<span class="udiff-line-modified-removed">-   debug_time(&quot;Merge Per-Thread State&quot;, _recorded_merge_pss_time_ms);</span>
<span class="udiff-line-modified-added">+   debug_phase(_gc_par_phases[MergePSS], 0);</span>
    debug_time(&quot;Code Roots Purge&quot;, _cur_strong_code_root_purge_time_ms);
  
    debug_time(&quot;Redirty Cards&quot;, _recorded_redirty_logged_cards_time_ms);
    trace_phase(_gc_par_phases[RedirtyCards]);
  #if COMPILER2_OR_JVMCI
    debug_time(&quot;DerivedPointerTable Update&quot;, _cur_derived_pointer_table_update_time_ms);
  #endif
  
    debug_time(&quot;Free Collection Set&quot;, _recorded_total_free_cset_time_ms);
<span class="udiff-line-modified-removed">-   trace_time(&quot;Free Collection Set Serial&quot;, _recorded_serial_free_cset_time_ms);</span>
<span class="udiff-line-modified-removed">-   trace_phase(_gc_par_phases[YoungFreeCSet]);</span>
<span class="udiff-line-modified-removed">-   trace_phase(_gc_par_phases[NonYoungFreeCSet]);</span>
<span class="udiff-line-modified-added">+   trace_time(&quot;Serial Free Collection Set&quot;, _recorded_serial_free_cset_time_ms);</span>
<span class="udiff-line-modified-added">+   trace_phase(_gc_par_phases[ParFreeCSet]);</span>
<span class="udiff-line-modified-added">+   trace_phase(_gc_par_phases[YoungFreeCSet], true, 1);</span>
<span class="udiff-line-added">+   trace_phase(_gc_par_phases[NonYoungFreeCSet], true, 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   debug_time(&quot;Rebuild Free List&quot;, _recorded_total_rebuild_freelist_time_ms);</span>
<span class="udiff-line-added">+   trace_time(&quot;Serial Rebuild Free List &quot;, _recorded_serial_rebuild_freelist_time_ms);</span>
<span class="udiff-line-added">+   trace_phase(_gc_par_phases[RebuildFreeList]);</span>
  
    if (G1EagerReclaimHumongousObjects) {
      debug_time(&quot;Humongous Reclaim&quot;, _cur_fast_reclaim_humongous_time_ms);
      trace_count(&quot;Humongous Reclaimed&quot;, _cur_fast_reclaim_humongous_reclaimed);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -481,11 +535,11 @@</span>
      debug_time(&quot;Verify Before&quot;, _cur_verify_before_time_ms);
    }
  
    double accounted_ms = 0.0;
    accounted_ms += print_pre_evacuate_collection_set();
<span class="udiff-line-modified-removed">-   accounted_ms += print_evacuate_collection_set();</span>
<span class="udiff-line-modified-added">+   accounted_ms += print_evacuate_initial_collection_set();</span>
    accounted_ms += print_evacuate_optional_collection_set();
    accounted_ms += print_post_evacuate_collection_set();
    print_other(accounted_ms);
  
    if (_cur_verify_after_time_ms &gt; 0.0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -503,33 +557,36 @@</span>
        &quot;ObjectSynchronizerRoots&quot;,
        &quot;ManagementRoots&quot;,
        &quot;SystemDictionaryRoots&quot;,
        &quot;CLDGRoots&quot;,
        &quot;JVMTIRoots&quot;,
<span class="udiff-line-modified-removed">- #if INCLUDE_AOT</span>
<span class="udiff-line-removed">-       &quot;AOTCodeRoots&quot;,</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+       AOT_ONLY(&quot;AOTCodeRoots&quot; COMMA)</span>
        &quot;CMRefRoots&quot;,
<span class="udiff-line-modified-removed">-       &quot;WaitForStrongCLD&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;WeakCLDRoots&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;SATBFiltering&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;UpdateRS&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;ScanHCC&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;ScanRS&quot;,</span>
<span class="udiff-line-modified-removed">-       &quot;OptScanRS&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;MergeER&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;MergeRS&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;OptMergeRS&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;MergeLB&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;MergeHCC&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;ScanHR&quot;,</span>
<span class="udiff-line-modified-added">+       &quot;OptScanHR&quot;,</span>
        &quot;CodeRoots&quot;,
<span class="udiff-line-added">+       &quot;OptCodeRoots&quot;,</span>
        &quot;ObjCopy&quot;,
        &quot;OptObjCopy&quot;,
        &quot;Termination&quot;,
<span class="udiff-line-added">+       &quot;OptTermination&quot;,</span>
        &quot;Other&quot;,
        &quot;GCWorkerTotal&quot;,
        &quot;GCWorkerEnd&quot;,
        &quot;StringDedupQueueFixup&quot;,
        &quot;StringDedupTableFixup&quot;,
        &quot;RedirtyCards&quot;,
<span class="udiff-line-added">+       &quot;ParFreeCSet&quot;,</span>
        &quot;YoungFreeCSet&quot;,
<span class="udiff-line-modified-removed">-       &quot;NonYoungFreeCSet&quot;</span>
<span class="udiff-line-modified-added">+       &quot;NonYoungFreeCSet&quot;,</span>
<span class="udiff-line-added">+       &quot;RebuildFreeList&quot;,</span>
<span class="udiff-line-added">+       &quot;MergePSS&quot;</span>
        //GCParPhasesSentinel only used to tell end of enum
        };
  
    STATIC_ASSERT(ARRAY_SIZE(names) == G1GCPhaseTimes::GCParPhasesSentinel); // GCParPhases enum and corresponding string array should have the same &quot;length&quot;, this tries to assert it
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -558,20 +615,24 @@</span>
    _trim_time += _pss-&gt;trim_ticks();
    _pss-&gt;reset_trim_ticks();
    _stopped = true;
  }
  
<span class="udiff-line-modified-removed">- G1GCParPhaseTimesTracker::G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id) :</span>
<span class="udiff-line-modified-removed">-   _start_time(), _phase(phase), _phase_times(phase_times), _worker_id(worker_id), _event() {</span>
<span class="udiff-line-modified-added">+ G1GCParPhaseTimesTracker::G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id, bool must_record) :</span>
<span class="udiff-line-modified-added">+   _start_time(), _phase(phase), _phase_times(phase_times), _worker_id(worker_id), _event(), _must_record(must_record) {</span>
    if (_phase_times != NULL) {
      _start_time = Ticks::now();
    }
  }
  
  G1GCParPhaseTimesTracker::~G1GCParPhaseTimesTracker() {
    if (_phase_times != NULL) {
<span class="udiff-line-modified-removed">-     _phase_times-&gt;record_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>
<span class="udiff-line-modified-added">+     if (_must_record) {</span>
<span class="udiff-line-added">+       _phase_times-&gt;record_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       _phase_times-&gt;record_or_add_time_secs(_phase, _worker_id, (Ticks::now() - _start_time).seconds());</span>
<span class="udiff-line-added">+     }</span>
      _event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_phase));
    }
  }
  
  G1EvacPhaseTimesTracker::G1EvacPhaseTimesTracker(G1GCPhaseTimes* phase_times,
</pre>
<center><a href="g1FullGCScope.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1GCPhaseTimes.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
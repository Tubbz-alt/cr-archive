<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Allocator.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Allocator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Allocator.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 26 #define SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1Allocator.hpp&quot;
 29 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 30 #include &quot;gc/shared/plab.inline.hpp&quot;

 31 
<span class="line-modified"> 32 inline MutatorAllocRegion* G1Allocator::mutator_alloc_region() {</span>
<span class="line-modified"> 33   return &amp;_mutator_alloc_region;</span>
 34 }
 35 
<span class="line-modified"> 36 inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region() {</span>
<span class="line-modified"> 37   return &amp;_survivor_gc_alloc_region;</span>






 38 }
 39 
 40 inline OldGCAllocRegion* G1Allocator::old_gc_alloc_region() {
 41   return &amp;_old_gc_alloc_region;
 42 }
 43 
 44 inline HeapWord* G1Allocator::attempt_allocation(size_t min_word_size,
 45                                                  size_t desired_word_size,
 46                                                  size_t* actual_word_size) {
<span class="line-modified"> 47   HeapWord* result = mutator_alloc_region()-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);</span>

 48   if (result != NULL) {
 49     return result;
 50   }
<span class="line-modified"> 51   return mutator_alloc_region()-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
 52 }
 53 
 54 inline HeapWord* G1Allocator::attempt_allocation_locked(size_t word_size) {
<span class="line-modified"> 55   HeapWord* result = mutator_alloc_region()-&gt;attempt_allocation_locked(word_size);</span>
<span class="line-modified"> 56   assert(result != NULL || mutator_alloc_region()-&gt;get() == NULL,</span>
<span class="line-modified"> 57          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region()-&gt;get()));</span>

 58   return result;
 59 }
 60 
 61 inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {
<span class="line-modified"> 62   return mutator_alloc_region()-&gt;attempt_allocation_force(word_size);</span>

 63 }
 64 
<span class="line-modified"> 65 inline PLAB* G1PLABAllocator::alloc_buffer(InCSetState dest) {</span>
 66   assert(dest.is_valid(),
<span class="line-modified"> 67          &quot;Allocation buffer index out of bounds: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="line-modified"> 68   assert(_alloc_buffers[dest.value()] != NULL,</span>
<span class="line-modified"> 69          &quot;Allocation buffer is NULL: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="line-modified"> 70   return _alloc_buffers[dest.value()];</span>













 71 }
 72 
<span class="line-modified"> 73 inline HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest,</span>
<span class="line-modified"> 74                                                 size_t word_sz) {</span>
<span class="line-modified"> 75   PLAB* buffer = alloc_buffer(dest);</span>









 76   if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
 77     return buffer-&gt;allocate(word_sz);
 78   } else {
 79     return buffer-&gt;allocate_aligned(word_sz, _survivor_alignment_bytes);
 80   }
 81 }
 82 
<span class="line-modified"> 83 inline HeapWord* G1PLABAllocator::allocate(InCSetState dest,</span>
 84                                            size_t word_sz,
<span class="line-modified"> 85                                            bool* refill_failed) {</span>
<span class="line-modified"> 86   HeapWord* const obj = plab_allocate(dest, word_sz);</span>

 87   if (obj != NULL) {
 88     return obj;
 89   }
<span class="line-modified"> 90   return allocate_direct_or_new_plab(dest, word_sz, refill_failed);</span>
 91 }
 92 
 93 // Create the maps which is used to identify archive objects.
 94 inline void G1ArchiveAllocator::enable_archive_object_check() {
 95   if (_archive_check_enabled) {
 96     return;
 97   }
 98 
 99   _archive_check_enabled = true;
100   size_t length = G1CollectedHeap::heap()-&gt;max_reserved_capacity();
<span class="line-modified">101   _closed_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="line-modified">102                                         (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="line-modified">103                                         HeapRegion::GrainBytes);</span>
<span class="line-removed">104   _open_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="line-removed">105                                       (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="line-removed">106                                       HeapRegion::GrainBytes);</span>
107 }
108 
109 // Set the regions containing the specified address range as archive.
110 inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {
111   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
112   log_info(gc, cds)(&quot;Mark %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
113                      open ? &quot;open&quot; : &quot;closed&quot;,
114                      p2i(range.start()),
115                      p2i(range.last()));
<span class="line-modified">116   if (open) {</span>
<span class="line-modified">117     _open_archive_region_map.set_by_address(range, true);</span>
<span class="line-removed">118   } else {</span>
<span class="line-removed">119     _closed_archive_region_map.set_by_address(range, true);</span>
<span class="line-removed">120   }</span>
121 }
122 
123 // Clear the archive regions map containing the specified address range.
<span class="line-modified">124 inline void G1ArchiveAllocator::clear_range_archive(MemRegion range, bool open) {</span>
125   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
<span class="line-modified">126   log_info(gc, cds)(&quot;Clear %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,</span>
<span class="line-removed">127                     open ? &quot;open&quot; : &quot;closed&quot;,</span>
128                     p2i(range.start()),
129                     p2i(range.last()));
<span class="line-modified">130   if (open) {</span>
<span class="line-removed">131     _open_archive_region_map.set_by_address(range, false);</span>
<span class="line-removed">132   } else {</span>
<span class="line-removed">133     _closed_archive_region_map.set_by_address(range, false);</span>
<span class="line-removed">134   }</span>
135 }
136 
137 // Check if an object is in a closed archive region using the _archive_region_map.
138 inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {
<span class="line-modified">139   // This is the out-of-line part of is_closed_archive_object test, done separately</span>
<span class="line-removed">140   // to avoid additional performance impact when the check is not enabled.</span>
<span class="line-removed">141   return _closed_archive_region_map.get_by_address((HeapWord*)object);</span>
142 }
143 
144 inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {
<span class="line-modified">145   return _open_archive_region_map.get_by_address((HeapWord*)object);</span>
146 }
147 
148 // Check if archive object checking is enabled, to avoid calling in_open/closed_archive_range
149 // unnecessarily.
150 inline bool G1ArchiveAllocator::archive_check_enabled() {
151   return _archive_check_enabled;
152 }
153 
154 inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {
155   return (archive_check_enabled() &amp;&amp; in_closed_archive_range(object));
156 }
157 
158 inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {
159   return (archive_check_enabled() &amp;&amp; in_open_archive_range(object));
160 }
161 
162 inline bool G1ArchiveAllocator::is_archived_object(oop object) {
<span class="line-modified">163   return (archive_check_enabled() &amp;&amp; (in_closed_archive_range(object) ||</span>
<span class="line-modified">164                                       in_open_archive_range(object)));</span>
165 }
166 
167 #endif // SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 26 #define SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1Allocator.hpp&quot;
 29 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 30 #include &quot;gc/shared/plab.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;memory/universe.hpp&quot;</span>
 32 
<span class="line-modified"> 33 inline uint G1Allocator::current_node_index() const {</span>
<span class="line-modified"> 34   return _numa-&gt;index_of_current_thread();</span>
 35 }
 36 
<span class="line-modified"> 37 inline MutatorAllocRegion* G1Allocator::mutator_alloc_region(uint node_index) {</span>
<span class="line-modified"> 38   assert(node_index &lt; _num_alloc_regions, &quot;Invalid index: %u&quot;, node_index);</span>
<span class="line-added"> 39   return &amp;_mutator_alloc_regions[node_index];</span>
<span class="line-added"> 40 }</span>
<span class="line-added"> 41 </span>
<span class="line-added"> 42 inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region(uint node_index) {</span>
<span class="line-added"> 43   assert(node_index &lt; _num_alloc_regions, &quot;Invalid index: %u&quot;, node_index);</span>
<span class="line-added"> 44   return &amp;_survivor_gc_alloc_regions[node_index];</span>
 45 }
 46 
 47 inline OldGCAllocRegion* G1Allocator::old_gc_alloc_region() {
 48   return &amp;_old_gc_alloc_region;
 49 }
 50 
 51 inline HeapWord* G1Allocator::attempt_allocation(size_t min_word_size,
 52                                                  size_t desired_word_size,
 53                                                  size_t* actual_word_size) {
<span class="line-modified"> 54   uint node_index = current_node_index();</span>
<span class="line-added"> 55   HeapWord* result = mutator_alloc_region(node_index)-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);</span>
 56   if (result != NULL) {
 57     return result;
 58   }
<span class="line-modified"> 59   return mutator_alloc_region(node_index)-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
 60 }
 61 
 62 inline HeapWord* G1Allocator::attempt_allocation_locked(size_t word_size) {
<span class="line-modified"> 63   uint node_index = current_node_index();</span>
<span class="line-modified"> 64   HeapWord* result = mutator_alloc_region(node_index)-&gt;attempt_allocation_locked(word_size);</span>
<span class="line-modified"> 65   assert(result != NULL || mutator_alloc_region(node_index)-&gt;get() == NULL,</span>
<span class="line-added"> 66          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region(node_index)-&gt;get()));</span>
 67   return result;
 68 }
 69 
 70 inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {
<span class="line-modified"> 71   uint node_index = current_node_index();</span>
<span class="line-added"> 72   return mutator_alloc_region(node_index)-&gt;attempt_allocation_force(word_size);</span>
 73 }
 74 
<span class="line-modified"> 75 inline PLAB* G1PLABAllocator::alloc_buffer(G1HeapRegionAttr dest, uint node_index) const {</span>
 76   assert(dest.is_valid(),
<span class="line-modified"> 77          &quot;Allocation buffer index out of bounds: %s&quot;, dest.get_type_str());</span>
<span class="line-modified"> 78   assert(_alloc_buffers[dest.type()] != NULL,</span>
<span class="line-modified"> 79          &quot;Allocation buffer is NULL: %s&quot;, dest.get_type_str());</span>
<span class="line-modified"> 80   return alloc_buffer(dest.type(), node_index);</span>
<span class="line-added"> 81 }</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83 inline PLAB* G1PLABAllocator::alloc_buffer(region_type_t dest, uint node_index) const {</span>
<span class="line-added"> 84   assert(dest &lt; G1HeapRegionAttr::Num,</span>
<span class="line-added"> 85          &quot;Allocation buffer index out of bounds: %u&quot;, dest);</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87   if (dest == G1HeapRegionAttr::Young) {</span>
<span class="line-added"> 88     assert(node_index &lt; alloc_buffers_length(dest),</span>
<span class="line-added"> 89            &quot;Allocation buffer index out of bounds: %u, %u&quot;, dest, node_index);</span>
<span class="line-added"> 90     return _alloc_buffers[dest][node_index];</span>
<span class="line-added"> 91   } else {</span>
<span class="line-added"> 92     return _alloc_buffers[dest][0];</span>
<span class="line-added"> 93   }</span>
 94 }
 95 
<span class="line-modified"> 96 inline uint G1PLABAllocator::alloc_buffers_length(region_type_t dest) const {</span>
<span class="line-modified"> 97   if (dest == G1HeapRegionAttr::Young) {</span>
<span class="line-modified"> 98     return _allocator-&gt;num_nodes();</span>
<span class="line-added"> 99   } else {</span>
<span class="line-added">100     return 1;</span>
<span class="line-added">101   }</span>
<span class="line-added">102 }</span>
<span class="line-added">103 </span>
<span class="line-added">104 inline HeapWord* G1PLABAllocator::plab_allocate(G1HeapRegionAttr dest,</span>
<span class="line-added">105                                                 size_t word_sz,</span>
<span class="line-added">106                                                 uint node_index) {</span>
<span class="line-added">107   PLAB* buffer = alloc_buffer(dest, node_index);</span>
108   if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
109     return buffer-&gt;allocate(word_sz);
110   } else {
111     return buffer-&gt;allocate_aligned(word_sz, _survivor_alignment_bytes);
112   }
113 }
114 
<span class="line-modified">115 inline HeapWord* G1PLABAllocator::allocate(G1HeapRegionAttr dest,</span>
116                                            size_t word_sz,
<span class="line-modified">117                                            bool* refill_failed,</span>
<span class="line-modified">118                                            uint node_index) {</span>
<span class="line-added">119   HeapWord* const obj = plab_allocate(dest, word_sz, node_index);</span>
120   if (obj != NULL) {
121     return obj;
122   }
<span class="line-modified">123   return allocate_direct_or_new_plab(dest, word_sz, refill_failed, node_index);</span>
124 }
125 
126 // Create the maps which is used to identify archive objects.
127 inline void G1ArchiveAllocator::enable_archive_object_check() {
128   if (_archive_check_enabled) {
129     return;
130   }
131 
132   _archive_check_enabled = true;
133   size_t length = G1CollectedHeap::heap()-&gt;max_reserved_capacity();
<span class="line-modified">134   _archive_region_map.initialize(G1CollectedHeap::heap()-&gt;base(),</span>
<span class="line-modified">135                                  G1CollectedHeap::heap()-&gt;base() + length,</span>
<span class="line-modified">136                                  HeapRegion::GrainBytes);</span>



137 }
138 
139 // Set the regions containing the specified address range as archive.
140 inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {
141   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
142   log_info(gc, cds)(&quot;Mark %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
143                      open ? &quot;open&quot; : &quot;closed&quot;,
144                      p2i(range.start()),
145                      p2i(range.last()));
<span class="line-modified">146   uint8_t const value = open ? G1ArchiveRegionMap::OpenArchive : G1ArchiveRegionMap::ClosedArchive;</span>
<span class="line-modified">147   _archive_region_map.set_by_address(range, value);</span>



148 }
149 
150 // Clear the archive regions map containing the specified address range.
<span class="line-modified">151 inline void G1ArchiveAllocator::clear_range_archive(MemRegion range) {</span>
152   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
<span class="line-modified">153   log_info(gc, cds)(&quot;Clear archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,</span>

154                     p2i(range.start()),
155                     p2i(range.last()));
<span class="line-modified">156   _archive_region_map.set_by_address(range, G1ArchiveRegionMap::NoArchive);</span>




157 }
158 
159 // Check if an object is in a closed archive region using the _archive_region_map.
160 inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {
<span class="line-modified">161   return _archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) == G1ArchiveRegionMap::ClosedArchive;</span>


162 }
163 
164 inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {
<span class="line-modified">165   return _archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) == G1ArchiveRegionMap::OpenArchive;</span>
166 }
167 
168 // Check if archive object checking is enabled, to avoid calling in_open/closed_archive_range
169 // unnecessarily.
170 inline bool G1ArchiveAllocator::archive_check_enabled() {
171   return _archive_check_enabled;
172 }
173 
174 inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {
175   return (archive_check_enabled() &amp;&amp; in_closed_archive_range(object));
176 }
177 
178 inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {
179   return (archive_check_enabled() &amp;&amp; in_open_archive_range(object));
180 }
181 
182 inline bool G1ArchiveAllocator::is_archived_object(oop object) {
<span class="line-modified">183   return archive_check_enabled() &amp;&amp;</span>
<span class="line-modified">184          (_archive_region_map.get_by_address(cast_from_oop&lt;HeapWord*&gt;(object)) != G1ArchiveRegionMap::NoArchive);</span>
185 }
186 
187 #endif // SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1Allocator.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
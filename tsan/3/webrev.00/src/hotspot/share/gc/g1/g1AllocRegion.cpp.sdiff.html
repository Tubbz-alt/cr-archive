<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1AllocRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1AllocRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1AllocRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
233     } else {
234       out-&gt;print(HR_FORMAT, HR_FORMAT_PARAMS(_alloc_region));
235     }
236 
237     out-&gt;print(&quot; : %s&quot;, str);
238 
239     if (detailed_info) {
240       if (result != NULL) {
241         out-&gt;print(&quot; min &quot; SIZE_FORMAT &quot; desired &quot; SIZE_FORMAT &quot; actual &quot; SIZE_FORMAT &quot; &quot; PTR_FORMAT,
242                      min_word_size, desired_word_size, actual_word_size, p2i(result));
243       } else if (min_word_size != 0) {
244         out-&gt;print(&quot; min &quot; SIZE_FORMAT &quot; desired &quot; SIZE_FORMAT, min_word_size, desired_word_size);
245       }
246     }
247     out-&gt;cr();
248   }
249 }
250 #endif // PRODUCT
251 
252 G1AllocRegion::G1AllocRegion(const char* name,
<span class="line-modified">253                              bool bot_updates)</span>

254   : _alloc_region(NULL),
255     _count(0),
256     _used_bytes_before(0),
257     _bot_updates(bot_updates),
<span class="line-modified">258     _name(name)</span>

259  { }
260 
261 HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size,
262                                                     bool force) {
<span class="line-modified">263   return _g1h-&gt;new_mutator_alloc_region(word_size, force);</span>
264 }
265 
266 void MutatorAllocRegion::retire_region(HeapRegion* alloc_region,
267                                        size_t allocated_bytes) {
268   _g1h-&gt;retire_mutator_alloc_region(alloc_region, allocated_bytes);
269 }
270 
271 void MutatorAllocRegion::init() {
272   assert(_retained_alloc_region == NULL, &quot;Pre-condition&quot;);
273   G1AllocRegion::init();
274   _wasted_bytes = 0;
275 }
276 
277 bool MutatorAllocRegion::should_retain(HeapRegion* region) {
278   size_t free_bytes = region-&gt;free();
279   if (free_bytes &lt; MinTLABSize) {
280     return false;
281   }
282 
283   if (_retained_alloc_region != NULL &amp;&amp;
</pre>
<hr />
<pre>
330   HeapRegion* ret = G1AllocRegion::release();
331 
332   // The retained alloc region must be retired and this must be
333   // done after the above call to release the mutator alloc region,
334   // since it might update the _retained_alloc_region member.
335   if (_retained_alloc_region != NULL) {
336     _wasted_bytes += retire_internal(_retained_alloc_region, false);
337     _retained_alloc_region = NULL;
338   }
339   log_debug(gc, alloc, region)(&quot;Mutator Allocation stats, regions: %u, wasted size: &quot; SIZE_FORMAT &quot;%s (%4.1f%%)&quot;,
340                                count(),
341                                byte_size_in_proper_unit(_wasted_bytes),
342                                proper_unit_for_byte_size(_wasted_bytes),
343                                percent_of(_wasted_bytes, count() * HeapRegion::GrainBytes));
344   return ret;
345 }
346 
347 HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size,
348                                                  bool force) {
349   assert(!force, &quot;not supported for GC alloc regions&quot;);
<span class="line-modified">350   return _g1h-&gt;new_gc_alloc_region(word_size, _purpose);</span>
351 }
352 
353 void G1GCAllocRegion::retire_region(HeapRegion* alloc_region,
354                                     size_t allocated_bytes) {
355   _g1h-&gt;retire_gc_alloc_region(alloc_region, allocated_bytes, _purpose);
356 }
357 
358 size_t G1GCAllocRegion::retire(bool fill_up) {
359   HeapRegion* retired = get();
360   size_t end_waste = G1AllocRegion::retire(fill_up);
361   // Do not count retirement of the dummy allocation region.
362   if (retired != NULL) {
363     _stats-&gt;add_region_end_waste(end_waste / HeapWordSize);
364   }
365   return end_waste;
366 }
367 
368 HeapRegion* OldGCAllocRegion::release() {
369   HeapRegion* cur = get();
370   if (cur != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
233     } else {
234       out-&gt;print(HR_FORMAT, HR_FORMAT_PARAMS(_alloc_region));
235     }
236 
237     out-&gt;print(&quot; : %s&quot;, str);
238 
239     if (detailed_info) {
240       if (result != NULL) {
241         out-&gt;print(&quot; min &quot; SIZE_FORMAT &quot; desired &quot; SIZE_FORMAT &quot; actual &quot; SIZE_FORMAT &quot; &quot; PTR_FORMAT,
242                      min_word_size, desired_word_size, actual_word_size, p2i(result));
243       } else if (min_word_size != 0) {
244         out-&gt;print(&quot; min &quot; SIZE_FORMAT &quot; desired &quot; SIZE_FORMAT, min_word_size, desired_word_size);
245       }
246     }
247     out-&gt;cr();
248   }
249 }
250 #endif // PRODUCT
251 
252 G1AllocRegion::G1AllocRegion(const char* name,
<span class="line-modified">253                              bool bot_updates,</span>
<span class="line-added">254                              uint node_index)</span>
255   : _alloc_region(NULL),
256     _count(0),
257     _used_bytes_before(0),
258     _bot_updates(bot_updates),
<span class="line-modified">259     _name(name),</span>
<span class="line-added">260     _node_index(node_index)</span>
261  { }
262 
263 HeapRegion* MutatorAllocRegion::allocate_new_region(size_t word_size,
264                                                     bool force) {
<span class="line-modified">265   return _g1h-&gt;new_mutator_alloc_region(word_size, force, _node_index);</span>
266 }
267 
268 void MutatorAllocRegion::retire_region(HeapRegion* alloc_region,
269                                        size_t allocated_bytes) {
270   _g1h-&gt;retire_mutator_alloc_region(alloc_region, allocated_bytes);
271 }
272 
273 void MutatorAllocRegion::init() {
274   assert(_retained_alloc_region == NULL, &quot;Pre-condition&quot;);
275   G1AllocRegion::init();
276   _wasted_bytes = 0;
277 }
278 
279 bool MutatorAllocRegion::should_retain(HeapRegion* region) {
280   size_t free_bytes = region-&gt;free();
281   if (free_bytes &lt; MinTLABSize) {
282     return false;
283   }
284 
285   if (_retained_alloc_region != NULL &amp;&amp;
</pre>
<hr />
<pre>
332   HeapRegion* ret = G1AllocRegion::release();
333 
334   // The retained alloc region must be retired and this must be
335   // done after the above call to release the mutator alloc region,
336   // since it might update the _retained_alloc_region member.
337   if (_retained_alloc_region != NULL) {
338     _wasted_bytes += retire_internal(_retained_alloc_region, false);
339     _retained_alloc_region = NULL;
340   }
341   log_debug(gc, alloc, region)(&quot;Mutator Allocation stats, regions: %u, wasted size: &quot; SIZE_FORMAT &quot;%s (%4.1f%%)&quot;,
342                                count(),
343                                byte_size_in_proper_unit(_wasted_bytes),
344                                proper_unit_for_byte_size(_wasted_bytes),
345                                percent_of(_wasted_bytes, count() * HeapRegion::GrainBytes));
346   return ret;
347 }
348 
349 HeapRegion* G1GCAllocRegion::allocate_new_region(size_t word_size,
350                                                  bool force) {
351   assert(!force, &quot;not supported for GC alloc regions&quot;);
<span class="line-modified">352   return _g1h-&gt;new_gc_alloc_region(word_size, _purpose, _node_index);</span>
353 }
354 
355 void G1GCAllocRegion::retire_region(HeapRegion* alloc_region,
356                                     size_t allocated_bytes) {
357   _g1h-&gt;retire_gc_alloc_region(alloc_region, allocated_bytes, _purpose);
358 }
359 
360 size_t G1GCAllocRegion::retire(bool fill_up) {
361   HeapRegion* retired = get();
362   size_t end_waste = G1AllocRegion::retire(fill_up);
363   // Do not count retirement of the dummy allocation region.
364   if (retired != NULL) {
365     _stats-&gt;add_region_end_waste(end_waste / HeapWordSize);
366   }
367   return end_waste;
368 }
369 
370 HeapRegion* OldGCAllocRegion::release() {
371   HeapRegion* cur = get();
372   if (cur != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="c2/g1BarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1AllocRegion.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
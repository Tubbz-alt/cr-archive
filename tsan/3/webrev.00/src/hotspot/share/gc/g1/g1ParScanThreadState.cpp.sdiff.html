<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1PageBasedVirtualSpace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 29 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 31 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 32 #include &quot;gc/g1/g1StringDedup.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/shared/gcTrace.hpp&quot;</span>
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/prefetch.inline.hpp&quot;
 39 
 40 G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,

 41                                            uint worker_id,
 42                                            size_t young_cset_length,
 43                                            size_t optional_cset_length)
 44   : _g1h(g1h),
 45     _refs(g1h-&gt;task_queue(worker_id)),
<span class="line-modified"> 46     _dcq(&amp;g1h-&gt;dirty_card_queue_set()),</span>
 47     _ct(g1h-&gt;card_table()),
 48     _closures(NULL),
 49     _plab_allocator(NULL),
 50     _age_table(false),
 51     _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
 52     _scanner(g1h, this),
 53     _worker_id(worker_id),

 54     _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
 55     _stack_trim_lower_threshold(GCDrainStackTargetSize),
 56     _trim_ticks(),



 57     _old_gen_is_full(false),
<span class="line-modified"> 58     _num_optional_regions(optional_cset_length)</span>


 59 {
<span class="line-modified"> 60   // we allocate G1YoungSurvRateNumRegions plus one entries, since</span>
<span class="line-modified"> 61   // we &quot;sacrifice&quot; entry 0 to keep track of surviving bytes for</span>
<span class="line-removed"> 62   // non-young regions (where the age is -1)</span>
 63   // We also add a few elements at the beginning and at the end in
 64   // an attempt to eliminate cache contention
<span class="line-modified"> 65   size_t real_length = 1 + young_cset_length;</span>
<span class="line-removed"> 66   size_t array_length = PADDING_ELEM_NUM +</span>
<span class="line-removed"> 67                       real_length +</span>
<span class="line-removed"> 68                       PADDING_ELEM_NUM;</span>
 69   _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, array_length, mtGC);
<span class="line-removed"> 70   if (_surviving_young_words_base == NULL)</span>
<span class="line-removed"> 71     vm_exit_out_of_memory(array_length * sizeof(size_t), OOM_MALLOC_ERROR,</span>
<span class="line-removed"> 72                           &quot;Not enough space for young surv histo.&quot;);</span>
 73   _surviving_young_words = _surviving_young_words_base + PADDING_ELEM_NUM;
<span class="line-modified"> 74   memset(_surviving_young_words, 0, real_length * sizeof(size_t));</span>
 75 
 76   _plab_allocator = new G1PLABAllocator(_g1h-&gt;allocator());
 77 
<span class="line-removed"> 78   _dest[InCSetState::NotInCSet]    = InCSetState::NotInCSet;</span>
 79   // The dest for Young is used when the objects are aged enough to
 80   // need to be moved to the next space.
<span class="line-modified"> 81   _dest[InCSetState::Young]        = InCSetState::Old;</span>
<span class="line-modified"> 82   _dest[InCSetState::Old]          = InCSetState::Old;</span>
 83 
 84   _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);
 85 
 86   _oops_into_optional_regions = new G1OopStarChunkedList[_num_optional_regions];


 87 }
 88 
<span class="line-modified"> 89 // Pass locally gathered statistics to global state.</span>
<span class="line-modified"> 90 void G1ParScanThreadState::flush(size_t* surviving_young_words) {</span>
<span class="line-modified"> 91   _dcq.flush();</span>
 92   // Update allocation statistics.
 93   _plab_allocator-&gt;flush_and_retire_stats();
 94   _g1h-&gt;policy()-&gt;record_age_table(&amp;_age_table);
 95 
<span class="line-modified"> 96   uint length = _g1h-&gt;collection_set()-&gt;young_region_length();</span>
<span class="line-modified"> 97   for (uint region_index = 0; region_index &lt; length; region_index++) {</span>
<span class="line-modified"> 98     surviving_young_words[region_index] += _surviving_young_words[region_index];</span>

 99   }

100 }
101 
102 G1ParScanThreadState::~G1ParScanThreadState() {
103   delete _plab_allocator;
104   delete _closures;
105   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
106   delete[] _oops_into_optional_regions;

107 }
108 
109 size_t G1ParScanThreadState::lab_waste_words() const {
110   return _plab_allocator-&gt;waste();
111 }
112 
113 size_t G1ParScanThreadState::lab_undo_waste_words() const {
114   return _plab_allocator-&gt;undo_waste();
115 }
116 
117 #ifdef ASSERT
118 bool G1ParScanThreadState::verify_ref(narrowOop* ref) const {
119   assert(ref != NULL, &quot;invariant&quot;);
120   assert(UseCompressedOops, &quot;sanity&quot;);
121   assert(!has_partial_array_mask(ref), &quot;ref=&quot; PTR_FORMAT, p2i(ref));
122   oop p = RawAccess&lt;&gt;::oop_load(ref);
123   assert(_g1h-&gt;is_in_g1_reserved(p),
124          &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));
125   return true;
126 }
</pre>
<hr />
<pre>
140   return true;
141 }
142 
143 bool G1ParScanThreadState::verify_task(StarTask ref) const {
144   if (ref.is_narrow()) {
145     return verify_ref((narrowOop*) ref);
146   } else {
147     return verify_ref((oop*) ref);
148   }
149 }
150 #endif // ASSERT
151 
152 void G1ParScanThreadState::trim_queue() {
153   StarTask ref;
154   do {
155     // Fully drain the queue.
156     trim_queue_to_threshold(0);
157   } while (!_refs-&gt;is_empty());
158 }
159 
<span class="line-modified">160 HeapWord* G1ParScanThreadState::allocate_in_next_plab(InCSetState const state,</span>
<span class="line-removed">161                                                       InCSetState* dest,</span>
162                                                       size_t word_sz,
<span class="line-modified">163                                                       bool previous_plab_refill_failed) {</span>
<span class="line-modified">164   assert(state.is_in_cset_or_humongous(), &quot;Unexpected state: &quot; CSETSTATE_FORMAT, state.value());</span>
<span class="line-modified">165   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: &quot; CSETSTATE_FORMAT, dest-&gt;value());</span>

166 
167   // Right now we only have two types of regions (young / old) so
168   // let&#39;s keep the logic here simple. We can generalize it when necessary.
169   if (dest-&gt;is_young()) {
170     bool plab_refill_in_old_failed = false;
<span class="line-modified">171     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(InCSetState::Old,</span>
172                                                         word_sz,
<span class="line-modified">173                                                         &amp;plab_refill_in_old_failed);</span>

174     // Make sure that we won&#39;t attempt to copy any other objects out
175     // of a survivor region (given that apparently we cannot allocate
176     // any new ones) to avoid coming into this slow path again and again.
177     // Only consider failed PLAB refill here: failed inline allocations are
178     // typically large, so not indicative of remaining space.
179     if (previous_plab_refill_failed) {
180       _tenuring_threshold = 0;
181     }
182 
183     if (obj_ptr != NULL) {
184       dest-&gt;set_old();
185     } else {
186       // We just failed to allocate in old gen. The same idea as explained above
187       // for making survivor gen unavailable for allocation applies for old gen.
188       _old_gen_is_full = plab_refill_in_old_failed;
189     }
190     return obj_ptr;
191   } else {
192     _old_gen_is_full = previous_plab_refill_failed;
<span class="line-modified">193     assert(dest-&gt;is_old(), &quot;Unexpected dest: &quot; CSETSTATE_FORMAT, dest-&gt;value());</span>
194     // no other space to try.
195     return NULL;
196   }
197 }
198 
<span class="line-modified">199 InCSetState G1ParScanThreadState::next_state(InCSetState const state, markOop const m, uint&amp; age) {</span>
<span class="line-modified">200   if (state.is_young()) {</span>
<span class="line-modified">201     age = !m-&gt;has_displaced_mark_helper() ? m-&gt;age()</span>
<span class="line-modified">202                                           : m-&gt;displaced_mark_helper()-&gt;age();</span>
203     if (age &lt; _tenuring_threshold) {
<span class="line-modified">204       return state;</span>
205     }
206   }
<span class="line-modified">207   return dest(state);</span>
208 }
209 
<span class="line-modified">210 void G1ParScanThreadState::report_promotion_event(InCSetState const dest_state,</span>
211                                                   oop const old, size_t word_sz, uint age,
<span class="line-modified">212                                                   HeapWord * const obj_ptr) const {</span>
<span class="line-modified">213   PLAB* alloc_buf = _plab_allocator-&gt;alloc_buffer(dest_state);</span>
214   if (alloc_buf-&gt;contains(obj_ptr)) {
215     _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_in_new_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">216                                                              dest_state.value() == InCSetState::Old,</span>
217                                                              alloc_buf-&gt;word_sz() * HeapWordSize);
218   } else {
219     _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_outside_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">220                                                               dest_state.value() == InCSetState::Old);</span>
221   }
222 }
223 
<span class="line-modified">224 oop G1ParScanThreadState::copy_to_survivor_space(InCSetState const state,</span>
225                                                  oop const old,
<span class="line-modified">226                                                  markOop const old_mark) {</span>
227   const size_t word_sz = old-&gt;size();
<span class="line-removed">228   HeapRegion* const from_region = _g1h-&gt;heap_region_containing(old);</span>
<span class="line-removed">229   // +1 to make the -1 indexes valid...</span>
<span class="line-removed">230   const int young_index = from_region-&gt;young_index_in_cset()+1;</span>
<span class="line-removed">231   assert( (from_region-&gt;is_young() &amp;&amp; young_index &gt;  0) ||</span>
<span class="line-removed">232          (!from_region-&gt;is_young() &amp;&amp; young_index == 0), &quot;invariant&quot; );</span>
233 
234   uint age = 0;
<span class="line-modified">235   InCSetState dest_state = next_state(state, old_mark, age);</span>
236   // The second clause is to prevent premature evacuation failure in case there
237   // is still space in survivor, but old gen is full.
<span class="line-modified">238   if (_old_gen_is_full &amp;&amp; dest_state.is_old()) {</span>
239     return handle_evacuation_failure_par(old, old_mark);
240   }
<span class="line-modified">241   HeapWord* obj_ptr = _plab_allocator-&gt;plab_allocate(dest_state, word_sz);</span>



242 
243   // PLAB allocations should succeed most of the time, so we&#39;ll
244   // normally check against NULL once and that&#39;s it.
245   if (obj_ptr == NULL) {
246     bool plab_refill_failed = false;
<span class="line-modified">247     obj_ptr = _plab_allocator-&gt;allocate_direct_or_new_plab(dest_state, word_sz, &amp;plab_refill_failed);</span>
248     if (obj_ptr == NULL) {
<span class="line-modified">249       obj_ptr = allocate_in_next_plab(state, &amp;dest_state, word_sz, plab_refill_failed);</span>

250       if (obj_ptr == NULL) {
251         // This will either forward-to-self, or detect that someone else has
252         // installed a forwarding pointer.
253         return handle_evacuation_failure_par(old, old_mark);
254       }
255     }


256     if (_g1h-&gt;_gc_tracer_stw-&gt;should_report_promotion_events()) {
257       // The events are checked individually as part of the actual commit
<span class="line-modified">258       report_promotion_event(dest_state, old, word_sz, age, obj_ptr);</span>
259     }
260   }
261 
262   assert(obj_ptr != NULL, &quot;when we get here, allocation should have succeeded&quot;);
263   assert(_g1h-&gt;is_in_reserved(obj_ptr), &quot;Allocated memory should be in the heap&quot;);
264 
265 #ifndef PRODUCT
266   // Should this evacuation fail?
267   if (_g1h-&gt;evacuation_should_fail()) {
268     // Doing this after all the allocation attempts also tests the
269     // undo_allocation() method too.
<span class="line-modified">270     _plab_allocator-&gt;undo_allocation(dest_state, obj_ptr, word_sz);</span>
271     return handle_evacuation_failure_par(old, old_mark);
272   }
273 #endif // !PRODUCT
274 
275   // We&#39;re going to allocate linearly, so might as well prefetch ahead.
276   Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);
277 
278   const oop obj = oop(obj_ptr);
279   const oop forward_ptr = old-&gt;forward_to_atomic(obj, old_mark, memory_order_relaxed);
280   if (forward_ptr == NULL) {
<span class="line-modified">281     Copy::aligned_disjoint_words((HeapWord*) old, obj_ptr, word_sz);</span>


282 
<span class="line-modified">283     if (dest_state.is_young()) {</span>
<span class="line-modified">284       if (age &lt; markOopDesc::max_age) {</span>



285         age++;
286       }
<span class="line-modified">287       if (old_mark-&gt;has_displaced_mark_helper()) {</span>
288         // In this case, we have to install the mark word first,
289         // otherwise obj looks to be forwarded (the old mark word,
290         // which contains the forward pointer, was copied)
291         obj-&gt;set_mark_raw(old_mark);
<span class="line-modified">292         markOop new_mark = old_mark-&gt;displaced_mark_helper()-&gt;set_age(age);</span>
<span class="line-modified">293         old_mark-&gt;set_displaced_mark_helper(new_mark);</span>
294       } else {
<span class="line-modified">295         obj-&gt;set_mark_raw(old_mark-&gt;set_age(age));</span>
296       }
297       _age_table.add(age, word_sz);
298     } else {
299       obj-&gt;set_mark_raw(old_mark);
300     }
301 
302     if (G1StringDedup::is_enabled()) {
<span class="line-modified">303       const bool is_from_young = state.is_young();</span>
<span class="line-modified">304       const bool is_to_young = dest_state.is_young();</span>
<span class="line-modified">305       assert(is_from_young == _g1h-&gt;heap_region_containing(old)-&gt;is_young(),</span>
306              &quot;sanity&quot;);
307       assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
308              &quot;sanity&quot;);
309       G1StringDedup::enqueue_from_evacuation(is_from_young,
310                                              is_to_young,
311                                              _worker_id,
312                                              obj);
313     }
314 
315     _surviving_young_words[young_index] += word_sz;
316 
317     if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
318       // We keep track of the next start index in the length field of
319       // the to-space object. The actual length can be found in the
320       // length field of the from-space object.
321       arrayOop(obj)-&gt;set_length(0);
322       oop* old_p = set_partial_array_mask(old);
323       do_oop_partial_array(old_p);
324     } else {
<span class="line-modified">325       G1ScanInYoungSetter x(&amp;_scanner, dest_state.is_young());</span>
326       obj-&gt;oop_iterate_backwards(&amp;_scanner);
327     }
328     return obj;
329   } else {
<span class="line-modified">330     _plab_allocator-&gt;undo_allocation(dest_state, obj_ptr, word_sz);</span>
331     return forward_ptr;
332   }
333 }
334 
335 G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
336   assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
337   if (_states[worker_id] == NULL) {
338     _states[worker_id] =
<span class="line-modified">339       new G1ParScanThreadState(_g1h, worker_id, _young_cset_length, _optional_cset_length);</span>
340   }
341   return _states[worker_id];
342 }
343 
344 const size_t* G1ParScanThreadStateSet::surviving_young_words() const {
345   assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
346   return _surviving_young_words_total;
347 }
348 
349 void G1ParScanThreadStateSet::flush() {
350   assert(!_flushed, &quot;thread local state from the per thread states should be flushed once&quot;);
351 
<span class="line-modified">352   for (uint worker_index = 0; worker_index &lt; _n_workers; ++worker_index) {</span>
<span class="line-modified">353     G1ParScanThreadState* pss = _states[worker_index];</span>
354 
355     if (pss == NULL) {
356       continue;
357     }
358 
<span class="line-modified">359     pss-&gt;flush(_surviving_young_words_total);</span>











360     delete pss;
<span class="line-modified">361     _states[worker_index] = NULL;</span>
362   }
363   _flushed = true;
364 }
365 
366 void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {
367   for (uint worker_index = 0; worker_index &lt; _n_workers; ++worker_index) {
368     G1ParScanThreadState* pss = _states[worker_index];
369 
370     if (pss == NULL) {
371       continue;
372     }
373 
374     size_t used_memory = pss-&gt;oops_into_optional_region(hr)-&gt;used_memory();
<span class="line-modified">375     _g1h-&gt;phase_times()-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::OptScanRS, worker_index, used_memory, G1GCPhaseTimes::OptCSetUsedMemory);</span>
376   }
377 }
378 
<span class="line-modified">379 oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {</span>
380   assert(_g1h-&gt;is_in_cset(old), &quot;Object &quot; PTR_FORMAT &quot; should be in the CSet&quot;, p2i(old));
381 
382   oop forward_ptr = old-&gt;forward_to_atomic(old, m, memory_order_relaxed);
383   if (forward_ptr == NULL) {
384     // Forward-to-self succeeded. We are the &quot;owner&quot; of the object.
385     HeapRegion* r = _g1h-&gt;heap_region_containing(old);
386 
387     if (!r-&gt;evacuation_failed()) {
388       r-&gt;set_evacuation_failed(true);
389      _g1h-&gt;hr_printer()-&gt;evac_failure(r);
390     }
391 
392     _g1h-&gt;preserve_mark_during_evac_failure(_worker_id, old, m);
393 
394     G1ScanInYoungSetter x(&amp;_scanner, r-&gt;is_young());
395     old-&gt;oop_iterate_backwards(&amp;_scanner);
396 
397     return old;
398   } else {
399     // Forward-to-self failed. Either someone else managed to allocate
400     // space for this object (old != forward_ptr) or they beat us in
401     // self-forwarding it (old == forward_ptr).
402     assert(old == forward_ptr || !_g1h-&gt;is_in_cset(forward_ptr),
403            &quot;Object &quot; PTR_FORMAT &quot; forwarded to: &quot; PTR_FORMAT &quot; &quot;
404            &quot;should not be in the CSet&quot;,
405            p2i(old), p2i(forward_ptr));
406     return forward_ptr;
407   }
408 }
409 G1ParScanThreadStateSet::G1ParScanThreadStateSet(G1CollectedHeap* g1h,

410                                                  uint n_workers,
411                                                  size_t young_cset_length,
412                                                  size_t optional_cset_length) :
413     _g1h(g1h),

414     _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, n_workers, mtGC)),
<span class="line-modified">415     _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, young_cset_length, mtGC)),</span>
416     _young_cset_length(young_cset_length),
417     _optional_cset_length(optional_cset_length),
418     _n_workers(n_workers),
419     _flushed(false) {
420   for (uint i = 0; i &lt; n_workers; ++i) {
421     _states[i] = NULL;
422   }
<span class="line-modified">423   memset(_surviving_young_words_total, 0, young_cset_length * sizeof(size_t));</span>
424 }
425 
426 G1ParScanThreadStateSet::~G1ParScanThreadStateSet() {
427   assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
428   FREE_C_HEAP_ARRAY(G1ParScanThreadState*, _states);
429   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_total);
430 }
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 29 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 31 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 32 #include &quot;gc/g1/g1StringDedup.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/g1/g1Trace.hpp&quot;</span>
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/prefetch.inline.hpp&quot;
 39 
 40 G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,
<span class="line-added"> 41                                            G1RedirtyCardsQueueSet* rdcqs,</span>
 42                                            uint worker_id,
 43                                            size_t young_cset_length,
 44                                            size_t optional_cset_length)
 45   : _g1h(g1h),
 46     _refs(g1h-&gt;task_queue(worker_id)),
<span class="line-modified"> 47     _rdcq(rdcqs),</span>
 48     _ct(g1h-&gt;card_table()),
 49     _closures(NULL),
 50     _plab_allocator(NULL),
 51     _age_table(false),
 52     _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
 53     _scanner(g1h, this),
 54     _worker_id(worker_id),
<span class="line-added"> 55     _last_enqueued_card(SIZE_MAX),</span>
 56     _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
 57     _stack_trim_lower_threshold(GCDrainStackTargetSize),
 58     _trim_ticks(),
<span class="line-added"> 59     _surviving_young_words_base(NULL),</span>
<span class="line-added"> 60     _surviving_young_words(NULL),</span>
<span class="line-added"> 61     _surviving_words_length(young_cset_length + 1),</span>
 62     _old_gen_is_full(false),
<span class="line-modified"> 63     _num_optional_regions(optional_cset_length),</span>
<span class="line-added"> 64     _numa(g1h-&gt;numa()),</span>
<span class="line-added"> 65     _obj_alloc_stat(NULL)</span>
 66 {
<span class="line-modified"> 67   // We allocate number of young gen regions in the collection set plus one</span>
<span class="line-modified"> 68   // entries, since entry 0 keeps track of surviving bytes for non-young regions.</span>

 69   // We also add a few elements at the beginning and at the end in
 70   // an attempt to eliminate cache contention
<span class="line-modified"> 71   size_t array_length = PADDING_ELEM_NUM + _surviving_words_length + PADDING_ELEM_NUM;</span>



 72   _surviving_young_words_base = NEW_C_HEAP_ARRAY(size_t, array_length, mtGC);



 73   _surviving_young_words = _surviving_young_words_base + PADDING_ELEM_NUM;
<span class="line-modified"> 74   memset(_surviving_young_words, 0, _surviving_words_length * sizeof(size_t));</span>
 75 
 76   _plab_allocator = new G1PLABAllocator(_g1h-&gt;allocator());
 77 

 78   // The dest for Young is used when the objects are aged enough to
 79   // need to be moved to the next space.
<span class="line-modified"> 80   _dest[G1HeapRegionAttr::Young] = G1HeapRegionAttr::Old;</span>
<span class="line-modified"> 81   _dest[G1HeapRegionAttr::Old]   = G1HeapRegionAttr::Old;</span>
 82 
 83   _closures = G1EvacuationRootClosures::create_root_closures(this, _g1h);
 84 
 85   _oops_into_optional_regions = new G1OopStarChunkedList[_num_optional_regions];
<span class="line-added"> 86 </span>
<span class="line-added"> 87   initialize_numa_stats();</span>
 88 }
 89 
<span class="line-modified"> 90 size_t G1ParScanThreadState::flush(size_t* surviving_young_words) {</span>
<span class="line-modified"> 91   _rdcq.flush();</span>
<span class="line-modified"> 92   flush_numa_stats();</span>
 93   // Update allocation statistics.
 94   _plab_allocator-&gt;flush_and_retire_stats();
 95   _g1h-&gt;policy()-&gt;record_age_table(&amp;_age_table);
 96 
<span class="line-modified"> 97   size_t sum = 0;</span>
<span class="line-modified"> 98   for (uint i = 0; i &lt; _surviving_words_length; i++) {</span>
<span class="line-modified"> 99     surviving_young_words[i] += _surviving_young_words[i];</span>
<span class="line-added">100     sum += _surviving_young_words[i];</span>
101   }
<span class="line-added">102   return sum;</span>
103 }
104 
105 G1ParScanThreadState::~G1ParScanThreadState() {
106   delete _plab_allocator;
107   delete _closures;
108   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
109   delete[] _oops_into_optional_regions;
<span class="line-added">110   FREE_C_HEAP_ARRAY(size_t, _obj_alloc_stat);</span>
111 }
112 
113 size_t G1ParScanThreadState::lab_waste_words() const {
114   return _plab_allocator-&gt;waste();
115 }
116 
117 size_t G1ParScanThreadState::lab_undo_waste_words() const {
118   return _plab_allocator-&gt;undo_waste();
119 }
120 
121 #ifdef ASSERT
122 bool G1ParScanThreadState::verify_ref(narrowOop* ref) const {
123   assert(ref != NULL, &quot;invariant&quot;);
124   assert(UseCompressedOops, &quot;sanity&quot;);
125   assert(!has_partial_array_mask(ref), &quot;ref=&quot; PTR_FORMAT, p2i(ref));
126   oop p = RawAccess&lt;&gt;::oop_load(ref);
127   assert(_g1h-&gt;is_in_g1_reserved(p),
128          &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));
129   return true;
130 }
</pre>
<hr />
<pre>
144   return true;
145 }
146 
147 bool G1ParScanThreadState::verify_task(StarTask ref) const {
148   if (ref.is_narrow()) {
149     return verify_ref((narrowOop*) ref);
150   } else {
151     return verify_ref((oop*) ref);
152   }
153 }
154 #endif // ASSERT
155 
156 void G1ParScanThreadState::trim_queue() {
157   StarTask ref;
158   do {
159     // Fully drain the queue.
160     trim_queue_to_threshold(0);
161   } while (!_refs-&gt;is_empty());
162 }
163 
<span class="line-modified">164 HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,</span>

165                                                       size_t word_sz,
<span class="line-modified">166                                                       bool previous_plab_refill_failed,</span>
<span class="line-modified">167                                                       uint node_index) {</span>
<span class="line-modified">168 </span>
<span class="line-added">169   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: %s region attr&quot;, dest-&gt;get_type_str());</span>
170 
171   // Right now we only have two types of regions (young / old) so
172   // let&#39;s keep the logic here simple. We can generalize it when necessary.
173   if (dest-&gt;is_young()) {
174     bool plab_refill_in_old_failed = false;
<span class="line-modified">175     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(G1HeapRegionAttr::Old,</span>
176                                                         word_sz,
<span class="line-modified">177                                                         &amp;plab_refill_in_old_failed,</span>
<span class="line-added">178                                                         node_index);</span>
179     // Make sure that we won&#39;t attempt to copy any other objects out
180     // of a survivor region (given that apparently we cannot allocate
181     // any new ones) to avoid coming into this slow path again and again.
182     // Only consider failed PLAB refill here: failed inline allocations are
183     // typically large, so not indicative of remaining space.
184     if (previous_plab_refill_failed) {
185       _tenuring_threshold = 0;
186     }
187 
188     if (obj_ptr != NULL) {
189       dest-&gt;set_old();
190     } else {
191       // We just failed to allocate in old gen. The same idea as explained above
192       // for making survivor gen unavailable for allocation applies for old gen.
193       _old_gen_is_full = plab_refill_in_old_failed;
194     }
195     return obj_ptr;
196   } else {
197     _old_gen_is_full = previous_plab_refill_failed;
<span class="line-modified">198     assert(dest-&gt;is_old(), &quot;Unexpected dest region attr: %s&quot;, dest-&gt;get_type_str());</span>
199     // no other space to try.
200     return NULL;
201   }
202 }
203 
<span class="line-modified">204 G1HeapRegionAttr G1ParScanThreadState::next_region_attr(G1HeapRegionAttr const region_attr, markWord const m, uint&amp; age) {</span>
<span class="line-modified">205   if (region_attr.is_young()) {</span>
<span class="line-modified">206     age = !m.has_displaced_mark_helper() ? m.age()</span>
<span class="line-modified">207                                          : m.displaced_mark_helper().age();</span>
208     if (age &lt; _tenuring_threshold) {
<span class="line-modified">209       return region_attr;</span>
210     }
211   }
<span class="line-modified">212   return dest(region_attr);</span>
213 }
214 
<span class="line-modified">215 void G1ParScanThreadState::report_promotion_event(G1HeapRegionAttr const dest_attr,</span>
216                                                   oop const old, size_t word_sz, uint age,
<span class="line-modified">217                                                   HeapWord * const obj_ptr, uint node_index) const {</span>
<span class="line-modified">218   PLAB* alloc_buf = _plab_allocator-&gt;alloc_buffer(dest_attr, node_index);</span>
219   if (alloc_buf-&gt;contains(obj_ptr)) {
220     _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_in_new_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">221                                                              dest_attr.type() == G1HeapRegionAttr::Old,</span>
222                                                              alloc_buf-&gt;word_sz() * HeapWordSize);
223   } else {
224     _g1h-&gt;_gc_tracer_stw-&gt;report_promotion_outside_plab_event(old-&gt;klass(), word_sz * HeapWordSize, age,
<span class="line-modified">225                                                               dest_attr.type() == G1HeapRegionAttr::Old);</span>
226   }
227 }
228 
<span class="line-modified">229 oop G1ParScanThreadState::copy_to_survivor_space(G1HeapRegionAttr const region_attr,</span>
230                                                  oop const old,
<span class="line-modified">231                                                  markWord const old_mark) {</span>
232   const size_t word_sz = old-&gt;size();





233 
234   uint age = 0;
<span class="line-modified">235   G1HeapRegionAttr dest_attr = next_region_attr(region_attr, old_mark, age);</span>
236   // The second clause is to prevent premature evacuation failure in case there
237   // is still space in survivor, but old gen is full.
<span class="line-modified">238   if (_old_gen_is_full &amp;&amp; dest_attr.is_old()) {</span>
239     return handle_evacuation_failure_par(old, old_mark);
240   }
<span class="line-modified">241   HeapRegion* const from_region = _g1h-&gt;heap_region_containing(old);</span>
<span class="line-added">242   uint node_index = from_region-&gt;node_index();</span>
<span class="line-added">243 </span>
<span class="line-added">244   HeapWord* obj_ptr = _plab_allocator-&gt;plab_allocate(dest_attr, word_sz, node_index);</span>
245 
246   // PLAB allocations should succeed most of the time, so we&#39;ll
247   // normally check against NULL once and that&#39;s it.
248   if (obj_ptr == NULL) {
249     bool plab_refill_failed = false;
<span class="line-modified">250     obj_ptr = _plab_allocator-&gt;allocate_direct_or_new_plab(dest_attr, word_sz, &amp;plab_refill_failed, node_index);</span>
251     if (obj_ptr == NULL) {
<span class="line-modified">252       assert(region_attr.is_in_cset(), &quot;Unexpected region attr type: %s&quot;, region_attr.get_type_str());</span>
<span class="line-added">253       obj_ptr = allocate_in_next_plab(&amp;dest_attr, word_sz, plab_refill_failed, node_index);</span>
254       if (obj_ptr == NULL) {
255         // This will either forward-to-self, or detect that someone else has
256         // installed a forwarding pointer.
257         return handle_evacuation_failure_par(old, old_mark);
258       }
259     }
<span class="line-added">260     update_numa_stats(node_index);</span>
<span class="line-added">261 </span>
262     if (_g1h-&gt;_gc_tracer_stw-&gt;should_report_promotion_events()) {
263       // The events are checked individually as part of the actual commit
<span class="line-modified">264       report_promotion_event(dest_attr, old, word_sz, age, obj_ptr, node_index);</span>
265     }
266   }
267 
268   assert(obj_ptr != NULL, &quot;when we get here, allocation should have succeeded&quot;);
269   assert(_g1h-&gt;is_in_reserved(obj_ptr), &quot;Allocated memory should be in the heap&quot;);
270 
271 #ifndef PRODUCT
272   // Should this evacuation fail?
273   if (_g1h-&gt;evacuation_should_fail()) {
274     // Doing this after all the allocation attempts also tests the
275     // undo_allocation() method too.
<span class="line-modified">276     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);</span>
277     return handle_evacuation_failure_par(old, old_mark);
278   }
279 #endif // !PRODUCT
280 
281   // We&#39;re going to allocate linearly, so might as well prefetch ahead.
282   Prefetch::write(obj_ptr, PrefetchCopyIntervalInBytes);
283 
284   const oop obj = oop(obj_ptr);
285   const oop forward_ptr = old-&gt;forward_to_atomic(obj, old_mark, memory_order_relaxed);
286   if (forward_ptr == NULL) {
<span class="line-modified">287     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(old), obj_ptr, word_sz);</span>
<span class="line-added">288 </span>
<span class="line-added">289     const uint young_index = from_region-&gt;young_index_in_cset();</span>
290 
<span class="line-modified">291     assert((from_region-&gt;is_young() &amp;&amp; young_index &gt;  0) ||</span>
<span class="line-modified">292            (!from_region-&gt;is_young() &amp;&amp; young_index == 0), &quot;invariant&quot; );</span>
<span class="line-added">293 </span>
<span class="line-added">294     if (dest_attr.is_young()) {</span>
<span class="line-added">295       if (age &lt; markWord::max_age) {</span>
296         age++;
297       }
<span class="line-modified">298       if (old_mark.has_displaced_mark_helper()) {</span>
299         // In this case, we have to install the mark word first,
300         // otherwise obj looks to be forwarded (the old mark word,
301         // which contains the forward pointer, was copied)
302         obj-&gt;set_mark_raw(old_mark);
<span class="line-modified">303         markWord new_mark = old_mark.displaced_mark_helper().set_age(age);</span>
<span class="line-modified">304         old_mark.set_displaced_mark_helper(new_mark);</span>
305       } else {
<span class="line-modified">306         obj-&gt;set_mark_raw(old_mark.set_age(age));</span>
307       }
308       _age_table.add(age, word_sz);
309     } else {
310       obj-&gt;set_mark_raw(old_mark);
311     }
312 
313     if (G1StringDedup::is_enabled()) {
<span class="line-modified">314       const bool is_from_young = region_attr.is_young();</span>
<span class="line-modified">315       const bool is_to_young = dest_attr.is_young();</span>
<span class="line-modified">316       assert(is_from_young == from_region-&gt;is_young(),</span>
317              &quot;sanity&quot;);
318       assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
319              &quot;sanity&quot;);
320       G1StringDedup::enqueue_from_evacuation(is_from_young,
321                                              is_to_young,
322                                              _worker_id,
323                                              obj);
324     }
325 
326     _surviving_young_words[young_index] += word_sz;
327 
328     if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
329       // We keep track of the next start index in the length field of
330       // the to-space object. The actual length can be found in the
331       // length field of the from-space object.
332       arrayOop(obj)-&gt;set_length(0);
333       oop* old_p = set_partial_array_mask(old);
334       do_oop_partial_array(old_p);
335     } else {
<span class="line-modified">336       G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());</span>
337       obj-&gt;oop_iterate_backwards(&amp;_scanner);
338     }
339     return obj;
340   } else {
<span class="line-modified">341     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);</span>
342     return forward_ptr;
343   }
344 }
345 
346 G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
347   assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
348   if (_states[worker_id] == NULL) {
349     _states[worker_id] =
<span class="line-modified">350       new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);</span>
351   }
352   return _states[worker_id];
353 }
354 
355 const size_t* G1ParScanThreadStateSet::surviving_young_words() const {
356   assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
357   return _surviving_young_words_total;
358 }
359 
360 void G1ParScanThreadStateSet::flush() {
361   assert(!_flushed, &quot;thread local state from the per thread states should be flushed once&quot;);
362 
<span class="line-modified">363   for (uint worker_id = 0; worker_id &lt; _n_workers; ++worker_id) {</span>
<span class="line-modified">364     G1ParScanThreadState* pss = _states[worker_id];</span>
365 
366     if (pss == NULL) {
367       continue;
368     }
369 
<span class="line-modified">370     G1GCPhaseTimes* p = _g1h-&gt;phase_times();</span>
<span class="line-added">371 </span>
<span class="line-added">372     // Need to get the following two before the call to G1ParThreadScanState::flush()</span>
<span class="line-added">373     // because it resets the PLAB allocator where we get this info from.</span>
<span class="line-added">374     size_t lab_waste_bytes = pss-&gt;lab_waste_words() * HeapWordSize;</span>
<span class="line-added">375     size_t lab_undo_waste_bytes = pss-&gt;lab_undo_waste_words() * HeapWordSize;</span>
<span class="line-added">376     size_t copied_bytes = pss-&gt;flush(_surviving_young_words_total) * HeapWordSize;</span>
<span class="line-added">377 </span>
<span class="line-added">378     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, copied_bytes, G1GCPhaseTimes::MergePSSCopiedBytes);</span>
<span class="line-added">379     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, lab_waste_bytes, G1GCPhaseTimes::MergePSSLABWasteBytes);</span>
<span class="line-added">380     p-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, lab_undo_waste_bytes, G1GCPhaseTimes::MergePSSLABUndoWasteBytes);</span>
<span class="line-added">381 </span>
382     delete pss;
<span class="line-modified">383     _states[worker_id] = NULL;</span>
384   }
385   _flushed = true;
386 }
387 
388 void G1ParScanThreadStateSet::record_unused_optional_region(HeapRegion* hr) {
389   for (uint worker_index = 0; worker_index &lt; _n_workers; ++worker_index) {
390     G1ParScanThreadState* pss = _states[worker_index];
391 
392     if (pss == NULL) {
393       continue;
394     }
395 
396     size_t used_memory = pss-&gt;oops_into_optional_region(hr)-&gt;used_memory();
<span class="line-modified">397     _g1h-&gt;phase_times()-&gt;record_or_add_thread_work_item(G1GCPhaseTimes::OptScanHR, worker_index, used_memory, G1GCPhaseTimes::ScanHRUsedMemory);</span>
398   }
399 }
400 
<span class="line-modified">401 oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m) {</span>
402   assert(_g1h-&gt;is_in_cset(old), &quot;Object &quot; PTR_FORMAT &quot; should be in the CSet&quot;, p2i(old));
403 
404   oop forward_ptr = old-&gt;forward_to_atomic(old, m, memory_order_relaxed);
405   if (forward_ptr == NULL) {
406     // Forward-to-self succeeded. We are the &quot;owner&quot; of the object.
407     HeapRegion* r = _g1h-&gt;heap_region_containing(old);
408 
409     if (!r-&gt;evacuation_failed()) {
410       r-&gt;set_evacuation_failed(true);
411      _g1h-&gt;hr_printer()-&gt;evac_failure(r);
412     }
413 
414     _g1h-&gt;preserve_mark_during_evac_failure(_worker_id, old, m);
415 
416     G1ScanInYoungSetter x(&amp;_scanner, r-&gt;is_young());
417     old-&gt;oop_iterate_backwards(&amp;_scanner);
418 
419     return old;
420   } else {
421     // Forward-to-self failed. Either someone else managed to allocate
422     // space for this object (old != forward_ptr) or they beat us in
423     // self-forwarding it (old == forward_ptr).
424     assert(old == forward_ptr || !_g1h-&gt;is_in_cset(forward_ptr),
425            &quot;Object &quot; PTR_FORMAT &quot; forwarded to: &quot; PTR_FORMAT &quot; &quot;
426            &quot;should not be in the CSet&quot;,
427            p2i(old), p2i(forward_ptr));
428     return forward_ptr;
429   }
430 }
431 G1ParScanThreadStateSet::G1ParScanThreadStateSet(G1CollectedHeap* g1h,
<span class="line-added">432                                                  G1RedirtyCardsQueueSet* rdcqs,</span>
433                                                  uint n_workers,
434                                                  size_t young_cset_length,
435                                                  size_t optional_cset_length) :
436     _g1h(g1h),
<span class="line-added">437     _rdcqs(rdcqs),</span>
438     _states(NEW_C_HEAP_ARRAY(G1ParScanThreadState*, n_workers, mtGC)),
<span class="line-modified">439     _surviving_young_words_total(NEW_C_HEAP_ARRAY(size_t, young_cset_length + 1, mtGC)),</span>
440     _young_cset_length(young_cset_length),
441     _optional_cset_length(optional_cset_length),
442     _n_workers(n_workers),
443     _flushed(false) {
444   for (uint i = 0; i &lt; n_workers; ++i) {
445     _states[i] = NULL;
446   }
<span class="line-modified">447   memset(_surviving_young_words_total, 0, (young_cset_length + 1) * sizeof(size_t));</span>
448 }
449 
450 G1ParScanThreadStateSet::~G1ParScanThreadStateSet() {
451   assert(_flushed, &quot;thread local state from the per thread states should have been flushed&quot;);
452   FREE_C_HEAP_ARRAY(G1ParScanThreadState*, _states);
453   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_total);
454 }
</pre>
</td>
</tr>
</table>
<center><a href="g1PageBasedVirtualSpace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
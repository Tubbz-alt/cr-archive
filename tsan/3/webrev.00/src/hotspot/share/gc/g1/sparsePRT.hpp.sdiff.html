<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/sparsePRT.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="sparsePRT.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_g1.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/sparsePRT.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_SPARSEPRT_HPP
 26 #define SHARE_GC_G1_SPARSEPRT_HPP
 27 
 28 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;runtime/mutex.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 




 36 // Sparse remembered set for a heap region (the &quot;owning&quot; region).  Maps
 37 // indices of other regions to short sequences of cards in the other region
 38 // that might contain pointers into the owner region.











































 39 
 40 class SparsePRTEntry: public CHeapObj&lt;mtGC&gt; {
<span class="line-modified"> 41 private:</span>
 42   // The type of a card entry.
 43   typedef uint16_t card_elem_t;
 44 

 45   // We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,
 46   // in order to force correct alignment that could otherwise cause SIGBUS errors
 47   // when reading the member variables. This calculates the minimum number of card
 48   // array elements required to get that alignment.
 49   static const size_t card_array_alignment = sizeof(int) / sizeof(card_elem_t);
 50 
 51   RegionIdx_t _region_ind;
 52   int         _next_index;
 53   int         _next_null;
 54   // The actual cards stored in this array.
 55   // WARNING: Don&#39;t put any data members beyond this line. Card array has, in fact, variable length.
 56   // It should always be the last data member.
 57   card_elem_t _cards[card_array_alignment];
 58 
 59   // Copy the current entry&#39;s cards into &quot;cards&quot;.
 60   inline void copy_cards(card_elem_t* cards) const;
 61 public:
 62   // Returns the size of the entry, used for entry allocation.
 63   static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }
 64   // Returns the size of the card array.
</pre>
<hr />
<pre>
 66     return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);
 67   }
 68 
 69   // Set the region_ind to the given value, and delete all cards.
 70   inline void init(RegionIdx_t region_ind);
 71 
 72   RegionIdx_t r_ind() const { return _region_ind; }
 73   bool valid_entry() const { return r_ind() &gt;= 0; }
 74   void set_r_ind(RegionIdx_t rind) { _region_ind = rind; }
 75 
 76   int next_index() const { return _next_index; }
 77   int* next_index_addr() { return &amp;_next_index; }
 78   void set_next_index(int ni) { _next_index = ni; }
 79 
 80   // Returns &quot;true&quot; iff the entry contains the given card index.
 81   inline bool contains_card(CardIdx_t card_index) const;
 82 
 83   // Returns the number of non-NULL card entries.
 84   inline int num_valid_cards() const { return _next_null; }
 85 
<span class="line-modified"> 86   // Requires that the entry not contain the given card index.  If there is</span>
<span class="line-removed"> 87   // space available, add the given card index to the entry and return</span>
<span class="line-removed"> 88   // &quot;true&quot;; otherwise, return &quot;false&quot; to indicate that the entry is full.</span>
<span class="line-removed"> 89   enum AddCardResult {</span>
<span class="line-removed"> 90     overflow,</span>
<span class="line-removed"> 91     found,</span>
<span class="line-removed"> 92     added</span>
<span class="line-removed"> 93   };</span>
<span class="line-removed"> 94   inline AddCardResult add_card(CardIdx_t card_index);</span>
 95 
 96   // Copy the current entry&#39;s cards into the &quot;_card&quot; array of &quot;e.&quot;
 97   inline void copy_cards(SparsePRTEntry* e) const;
 98 


 99   inline CardIdx_t card(int i) const {
100     assert(i &gt;= 0, &quot;must be nonnegative&quot;);
101     assert(i &lt; cards_num(), &quot;range checking&quot;);
102     return (CardIdx_t)_cards[i];
103   }
104 };
105 
106 class RSHashTable : public CHeapObj&lt;mtGC&gt; {
107 
108   friend class RSHashTableIter;
<span class="line-modified">109 </span>
110 
111   // Inverse maximum hash table occupancy used.
112   static float TableOccupancyFactor;
113 
114   size_t _num_entries;
115 
116   size_t _capacity;
117   size_t _capacity_mask;
118   size_t _occupied_entries;
119   size_t _occupied_cards;
120 
121   SparsePRTEntry* _entries;
122   int* _buckets;
123   int  _free_region;
124   int  _free_list;
125 
126   // Requires that the caller hold a lock preventing parallel modifying
127   // operations, and that the the table be less than completely full.  If
128   // an entry for &quot;region_ind&quot; is already in the table, finds it and
129   // returns its address; otherwise allocates, initializes, inserts and
</pre>
<hr />
<pre>
133   // Returns the index of the next free entry in &quot;_entries&quot;.
134   int alloc_entry();
135   // Declares the entry &quot;fi&quot; to be free.  (It must have already been
136   // deleted from any bucket lists.
137   void free_entry(int fi);
138 
139 public:
140   RSHashTable(size_t capacity);
141   ~RSHashTable();
142 
143   static const int NullEntry = -1;
144 
145   bool should_expand() const { return _occupied_entries == _num_entries; }
146 
147   // Attempts to ensure that the given card_index in the given region is in
148   // the sparse table.  If successful (because the card was already
149   // present, or because it was successfully added) returns &quot;true&quot;.
150   // Otherwise, returns &quot;false&quot; to indicate that the addition would
151   // overflow the entry for the region.  The caller must transfer these
152   // entries to a larger-capacity representation.
<span class="line-modified">153   bool add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
154 
155   bool delete_entry(RegionIdx_t region_id);
156 
157   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;
158 
159   void add_entry(SparsePRTEntry* e);
160 
161   SparsePRTEntry* get_entry(RegionIdx_t region_id) const;
162 
163   void clear();
164 
165   size_t capacity() const      { return _capacity; }
166   size_t capacity_mask() const { return _capacity_mask;  }
167   size_t occupied_entries() const { return _occupied_entries; }
<span class="line-removed">168   size_t occupied_cards() const   { return _occupied_cards; }</span>
169   size_t mem_size() const;
170   // The number of SparsePRTEntry instances available.
171   size_t num_entries() const { return _num_entries; }
172 
173   SparsePRTEntry* entry(int i) const {
174     assert(i &gt;= 0 &amp;&amp; (size_t)i &lt; _num_entries, &quot;precondition&quot;);
175     return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);
176   }
177 
178   void print();
179 };
180 
181 // This is embedded in HRRS iterator.
182 class RSHashTableIter {
183   // Return value indicating &quot;invalid/no card&quot;.
184   static const int NoCardFound = -1;
185 
186   int _tbl_ind;         // [-1, 0.._rsht-&gt;_capacity)
187   int _bl_ind;          // [-1, 0.._rsht-&gt;_capacity)
188   short _card_ind;      // [0..SparsePRTEntry::cards_num())
</pre>
<hr />
<pre>
192   // _bl_ind to the index of that entry,
193   // Returns the card found if there is, otherwise returns InvalidCard.
194   CardIdx_t find_first_card_in_list();
195 
196   // Computes the proper card index for the card whose offset in the
197   // current region (as indicated by _bl_ind) is &quot;ci&quot;.
198   // This is subject to errors when there is iteration concurrent with
199   // modification, but these errors should be benign.
200   size_t compute_card_ind(CardIdx_t ci);
201 
202 public:
203   RSHashTableIter(RSHashTable* rsht) :
204     _tbl_ind(RSHashTable::NullEntry), // So that first increment gets to 0.
205     _bl_ind(RSHashTable::NullEntry),
206     _card_ind((SparsePRTEntry::cards_num() - 1)),
207     _rsht(rsht) {}
208 
209   bool has_next(size_t&amp; card_index);
210 };
211 
<span class="line-modified">212 // Concurrent access to a SparsePRT must be serialized by some external mutex.</span>
<span class="line-modified">213 </span>
<span class="line-modified">214 class SparsePRTIter;</span>
<span class="line-modified">215 </span>
<span class="line-removed">216 class SparsePRT {</span>
<span class="line-removed">217   friend class SparsePRTIter;</span>
<span class="line-removed">218 </span>
<span class="line-removed">219   RSHashTable* _table;</span>
<span class="line-removed">220 </span>
<span class="line-removed">221   enum SomeAdditionalPrivateConstants {</span>
<span class="line-removed">222     InitialCapacity = 16</span>
<span class="line-removed">223   };</span>
224 
<span class="line-modified">225   void expand();</span>
226 
227 public:
<span class="line-modified">228   SparsePRT();</span>
<span class="line-modified">229   ~SparsePRT();</span>
<span class="line-modified">230 </span>
<span class="line-modified">231   size_t occupied() const { return _table-&gt;occupied_cards(); }</span>
<span class="line-removed">232   size_t mem_size() const;</span>
<span class="line-removed">233 </span>
<span class="line-removed">234   // Attempts to ensure that the given card_index in the given region is in</span>
<span class="line-removed">235   // the sparse table.  If successful (because the card was already</span>
<span class="line-removed">236   // present, or because it was successfully added) returns &quot;true&quot;.</span>
<span class="line-removed">237   // Otherwise, returns &quot;false&quot; to indicate that the addition would</span>
<span class="line-removed">238   // overflow the entry for the region.  The caller must transfer these</span>
<span class="line-removed">239   // entries to a larger-capacity representation.</span>
<span class="line-removed">240   bool add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
<span class="line-removed">241 </span>
<span class="line-removed">242   // Return the pointer to the entry associated with the given region.</span>
<span class="line-removed">243   SparsePRTEntry* get_entry(RegionIdx_t region_ind);</span>
<span class="line-removed">244 </span>
<span class="line-removed">245   // If there is an entry for &quot;region_ind&quot;, removes it and return &quot;true&quot;;</span>
<span class="line-removed">246   // otherwise returns &quot;false.&quot;</span>
<span class="line-removed">247   bool delete_entry(RegionIdx_t region_ind);</span>
<span class="line-removed">248 </span>
<span class="line-removed">249   // Clear the table, and reinitialize to initial capacity.</span>
<span class="line-removed">250   void clear();</span>
251 
<span class="line-modified">252   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {</span>
<span class="line-removed">253     return _table-&gt;contains_card(region_id, card_index);</span>
<span class="line-removed">254   }</span>
255 };
256 
257 class SparsePRTIter: public RSHashTableIter {
258 public:
259   SparsePRTIter(const SparsePRT* sprt) :
260     RSHashTableIter(sprt-&gt;_table) { }
261 
262   bool has_next(size_t&amp; card_index) {
263     return RSHashTableIter::has_next(card_index);
264   }
265 };
266 










267 #endif // SHARE_GC_G1_SPARSEPRT_HPP
</pre>
</td>
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_SPARSEPRT_HPP
 26 #define SHARE_GC_G1_SPARSEPRT_HPP
 27 
 28 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;runtime/mutex.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
<span class="line-added"> 36 class RSHashTable;</span>
<span class="line-added"> 37 class SparsePRTEntry;</span>
<span class="line-added"> 38 class SparsePRTIter;</span>
<span class="line-added"> 39 </span>
 40 // Sparse remembered set for a heap region (the &quot;owning&quot; region).  Maps
 41 // indices of other regions to short sequences of cards in the other region
 42 // that might contain pointers into the owner region.
<span class="line-added"> 43 // Concurrent access to a SparsePRT must be serialized by some external mutex.</span>
<span class="line-added"> 44 class SparsePRT {</span>
<span class="line-added"> 45   friend class SparsePRTIter;</span>
<span class="line-added"> 46   friend class SparsePRTBucketIter;</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48   RSHashTable* _table;</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50   static const size_t InitialCapacity = 8;</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52   void expand();</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54 public:</span>
<span class="line-added"> 55   SparsePRT();</span>
<span class="line-added"> 56   ~SparsePRT();</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58   size_t mem_size() const;</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60   enum AddCardResult {</span>
<span class="line-added"> 61     overflow, // The table is full, could not add the card to the table.</span>
<span class="line-added"> 62     found,    // The card is already in the PRT.</span>
<span class="line-added"> 63     added     // The card has been added.</span>
<span class="line-added"> 64   };</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66   // Attempts to ensure that the given card_index in the given region is in</span>
<span class="line-added"> 67   // the sparse table.  If successful (because the card was already</span>
<span class="line-added"> 68   // present, or because it was successfully added) returns &quot;true&quot;.</span>
<span class="line-added"> 69   // Otherwise, returns &quot;false&quot; to indicate that the addition would</span>
<span class="line-added"> 70   // overflow the entry for the region.  The caller must transfer these</span>
<span class="line-added"> 71   // entries to a larger-capacity representation.</span>
<span class="line-added"> 72   AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74   // Return the pointer to the entry associated with the given region.</span>
<span class="line-added"> 75   SparsePRTEntry* get_entry(RegionIdx_t region_ind);</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77   // If there is an entry for &quot;region_ind&quot;, removes it and return &quot;true&quot;;</span>
<span class="line-added"> 78   // otherwise returns &quot;false.&quot;</span>
<span class="line-added"> 79   bool delete_entry(RegionIdx_t region_ind);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   // Clear the table, and reinitialize to initial capacity.</span>
<span class="line-added"> 82   void clear();</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;</span>
<span class="line-added"> 85 };</span>
 86 
 87 class SparsePRTEntry: public CHeapObj&lt;mtGC&gt; {
<span class="line-modified"> 88 public:</span>
 89   // The type of a card entry.
 90   typedef uint16_t card_elem_t;
 91 
<span class="line-added"> 92 private:</span>
 93   // We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,
 94   // in order to force correct alignment that could otherwise cause SIGBUS errors
 95   // when reading the member variables. This calculates the minimum number of card
 96   // array elements required to get that alignment.
 97   static const size_t card_array_alignment = sizeof(int) / sizeof(card_elem_t);
 98 
 99   RegionIdx_t _region_ind;
100   int         _next_index;
101   int         _next_null;
102   // The actual cards stored in this array.
103   // WARNING: Don&#39;t put any data members beyond this line. Card array has, in fact, variable length.
104   // It should always be the last data member.
105   card_elem_t _cards[card_array_alignment];
106 
107   // Copy the current entry&#39;s cards into &quot;cards&quot;.
108   inline void copy_cards(card_elem_t* cards) const;
109 public:
110   // Returns the size of the entry, used for entry allocation.
111   static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }
112   // Returns the size of the card array.
</pre>
<hr />
<pre>
114     return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);
115   }
116 
117   // Set the region_ind to the given value, and delete all cards.
118   inline void init(RegionIdx_t region_ind);
119 
120   RegionIdx_t r_ind() const { return _region_ind; }
121   bool valid_entry() const { return r_ind() &gt;= 0; }
122   void set_r_ind(RegionIdx_t rind) { _region_ind = rind; }
123 
124   int next_index() const { return _next_index; }
125   int* next_index_addr() { return &amp;_next_index; }
126   void set_next_index(int ni) { _next_index = ni; }
127 
128   // Returns &quot;true&quot; iff the entry contains the given card index.
129   inline bool contains_card(CardIdx_t card_index) const;
130 
131   // Returns the number of non-NULL card entries.
132   inline int num_valid_cards() const { return _next_null; }
133 
<span class="line-modified">134   inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);</span>








135 
136   // Copy the current entry&#39;s cards into the &quot;_card&quot; array of &quot;e.&quot;
137   inline void copy_cards(SparsePRTEntry* e) const;
138 
<span class="line-added">139   card_elem_t* cards() { return _cards; }</span>
<span class="line-added">140 </span>
141   inline CardIdx_t card(int i) const {
142     assert(i &gt;= 0, &quot;must be nonnegative&quot;);
143     assert(i &lt; cards_num(), &quot;range checking&quot;);
144     return (CardIdx_t)_cards[i];
145   }
146 };
147 
148 class RSHashTable : public CHeapObj&lt;mtGC&gt; {
149 
150   friend class RSHashTableIter;
<span class="line-modified">151   friend class RSHashTableBucketIter;</span>
152 
153   // Inverse maximum hash table occupancy used.
154   static float TableOccupancyFactor;
155 
156   size_t _num_entries;
157 
158   size_t _capacity;
159   size_t _capacity_mask;
160   size_t _occupied_entries;
161   size_t _occupied_cards;
162 
163   SparsePRTEntry* _entries;
164   int* _buckets;
165   int  _free_region;
166   int  _free_list;
167 
168   // Requires that the caller hold a lock preventing parallel modifying
169   // operations, and that the the table be less than completely full.  If
170   // an entry for &quot;region_ind&quot; is already in the table, finds it and
171   // returns its address; otherwise allocates, initializes, inserts and
</pre>
<hr />
<pre>
175   // Returns the index of the next free entry in &quot;_entries&quot;.
176   int alloc_entry();
177   // Declares the entry &quot;fi&quot; to be free.  (It must have already been
178   // deleted from any bucket lists.
179   void free_entry(int fi);
180 
181 public:
182   RSHashTable(size_t capacity);
183   ~RSHashTable();
184 
185   static const int NullEntry = -1;
186 
187   bool should_expand() const { return _occupied_entries == _num_entries; }
188 
189   // Attempts to ensure that the given card_index in the given region is in
190   // the sparse table.  If successful (because the card was already
191   // present, or because it was successfully added) returns &quot;true&quot;.
192   // Otherwise, returns &quot;false&quot; to indicate that the addition would
193   // overflow the entry for the region.  The caller must transfer these
194   // entries to a larger-capacity representation.
<span class="line-modified">195   SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);</span>
196 
197   bool delete_entry(RegionIdx_t region_id);
198 
199   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;
200 
201   void add_entry(SparsePRTEntry* e);
202 
203   SparsePRTEntry* get_entry(RegionIdx_t region_id) const;
204 
205   void clear();
206 
207   size_t capacity() const      { return _capacity; }
208   size_t capacity_mask() const { return _capacity_mask;  }
209   size_t occupied_entries() const { return _occupied_entries; }

210   size_t mem_size() const;
211   // The number of SparsePRTEntry instances available.
212   size_t num_entries() const { return _num_entries; }
213 
214   SparsePRTEntry* entry(int i) const {
215     assert(i &gt;= 0 &amp;&amp; (size_t)i &lt; _num_entries, &quot;precondition&quot;);
216     return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);
217   }
218 
219   void print();
220 };
221 
222 // This is embedded in HRRS iterator.
223 class RSHashTableIter {
224   // Return value indicating &quot;invalid/no card&quot;.
225   static const int NoCardFound = -1;
226 
227   int _tbl_ind;         // [-1, 0.._rsht-&gt;_capacity)
228   int _bl_ind;          // [-1, 0.._rsht-&gt;_capacity)
229   short _card_ind;      // [0..SparsePRTEntry::cards_num())
</pre>
<hr />
<pre>
233   // _bl_ind to the index of that entry,
234   // Returns the card found if there is, otherwise returns InvalidCard.
235   CardIdx_t find_first_card_in_list();
236 
237   // Computes the proper card index for the card whose offset in the
238   // current region (as indicated by _bl_ind) is &quot;ci&quot;.
239   // This is subject to errors when there is iteration concurrent with
240   // modification, but these errors should be benign.
241   size_t compute_card_ind(CardIdx_t ci);
242 
243 public:
244   RSHashTableIter(RSHashTable* rsht) :
245     _tbl_ind(RSHashTable::NullEntry), // So that first increment gets to 0.
246     _bl_ind(RSHashTable::NullEntry),
247     _card_ind((SparsePRTEntry::cards_num() - 1)),
248     _rsht(rsht) {}
249 
250   bool has_next(size_t&amp; card_index);
251 };
252 
<span class="line-modified">253 // This is embedded in HRRS iterator.</span>
<span class="line-modified">254 class RSHashTableBucketIter {</span>
<span class="line-modified">255   int _tbl_ind;         // [-1, 0.._rsht-&gt;_capacity)</span>
<span class="line-modified">256   int _bl_ind;          // [-1, 0.._rsht-&gt;_capacity)</span>








257 
<span class="line-modified">258   RSHashTable* _rsht;</span>
259 
260 public:
<span class="line-modified">261   RSHashTableBucketIter(RSHashTable* rsht) :</span>
<span class="line-modified">262     _tbl_ind(0),</span>
<span class="line-modified">263     _bl_ind(rsht-&gt;_buckets[_tbl_ind]),</span>
<span class="line-modified">264     _rsht(rsht) { }</span>



















265 
<span class="line-modified">266   bool has_next(SparsePRTEntry*&amp; entry);</span>


267 };
268 
269 class SparsePRTIter: public RSHashTableIter {
270 public:
271   SparsePRTIter(const SparsePRT* sprt) :
272     RSHashTableIter(sprt-&gt;_table) { }
273 
274   bool has_next(size_t&amp; card_index) {
275     return RSHashTableIter::has_next(card_index);
276   }
277 };
278 
<span class="line-added">279 class SparsePRTBucketIter: public RSHashTableBucketIter {</span>
<span class="line-added">280 public:</span>
<span class="line-added">281   SparsePRTBucketIter(const SparsePRT* sprt) :</span>
<span class="line-added">282     RSHashTableBucketIter(sprt-&gt;_table) {}</span>
<span class="line-added">283 </span>
<span class="line-added">284   bool has_next(SparsePRTEntry*&amp; entry) {</span>
<span class="line-added">285     return RSHashTableBucketIter::has_next(entry);</span>
<span class="line-added">286   }</span>
<span class="line-added">287 };</span>
<span class="line-added">288 </span>
289 #endif // SHARE_GC_G1_SPARSEPRT_HPP
</pre>
</td>
</tr>
</table>
<center><a href="sparsePRT.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_g1.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
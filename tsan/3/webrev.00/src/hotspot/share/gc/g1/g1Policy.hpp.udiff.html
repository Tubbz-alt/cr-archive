<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Policy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Predictions.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,14 +23,13 @@</span>
   */
  
  #ifndef SHARE_GC_G1_G1POLICY_HPP
  #define SHARE_GC_G1_G1POLICY_HPP
  
<span class="udiff-line-removed">- #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/g1/g1InCSetState.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;</span>
  #include &quot;gc/g1/g1InitialMarkToMixedTimeTracker.hpp&quot;
  #include &quot;gc/g1/g1MMUTracker.hpp&quot;
  #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
  #include &quot;gc/g1/g1Predictions.hpp&quot;
  #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,10 +41,11 @@</span>
  //   * choice of collection set.
  //   * when to collect.
  
  class HeapRegion;
  class G1CollectionSet;
<span class="udiff-line-added">+ class G1CollectionSetCandidates;</span>
  class G1CollectionSetChooser;
  class G1IHOPControl;
  class G1Analytics;
  class G1SurvivorRegions;
  class G1YoungGenSizer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,39 +80,45 @@</span>
  
    // The max number of regions we can extend the eden by while the GC
    // locker is active. This should be &gt;= _young_list_target_length;
    uint _young_list_max_length;
  
<span class="udiff-line-modified-removed">-   // SurvRateGroups below must be initialized after the predictor because they</span>
<span class="udiff-line-modified-removed">-   // indirectly use it through this object passed to their constructor.</span>
<span class="udiff-line-modified-removed">-   SurvRateGroup* _short_lived_surv_rate_group;</span>
<span class="udiff-line-modified-removed">-   SurvRateGroup* _survivor_surv_rate_group;</span>
<span class="udiff-line-modified-added">+   // The survivor rate groups below must be initialized after the predictor because they</span>
<span class="udiff-line-modified-added">+   // indirectly use it through the &quot;this&quot; object passed to their constructor.</span>
<span class="udiff-line-modified-added">+   G1SurvRateGroup* _eden_surv_rate_group;</span>
<span class="udiff-line-modified-added">+   G1SurvRateGroup* _survivor_surv_rate_group;</span>
  
    double _reserve_factor;
    // This will be set when the heap is expanded
    // for the first time during initialization.
    uint   _reserve_regions;
  
    G1YoungGenSizer* _young_gen_sizer;
  
    uint _free_regions_at_end_of_collection;
  
<span class="udiff-line-modified-removed">-   size_t _max_rs_lengths;</span>
<span class="udiff-line-modified-added">+   size_t _rs_length;</span>
  
<span class="udiff-line-modified-removed">-   size_t _rs_lengths_prediction;</span>
<span class="udiff-line-modified-added">+   size_t _rs_length_prediction;</span>
  
<span class="udiff-line-modified-removed">-   size_t _pending_cards;</span>
<span class="udiff-line-modified-added">+   size_t _pending_cards_at_gc_start;</span>
<span class="udiff-line-added">+   size_t _pending_cards_at_prev_gc_end;</span>
<span class="udiff-line-added">+   size_t _total_mutator_refined_cards;</span>
<span class="udiff-line-added">+   size_t _total_concurrent_refined_cards;</span>
<span class="udiff-line-added">+   Tickspan _total_concurrent_refinement_time;</span>
  
    // The amount of allocated bytes in old gen during the last mutator and the following
    // young GC phase.
    size_t _bytes_allocated_in_old_since_last_gc;
  
    G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
  
    bool should_update_surv_rate_group_predictors() {
      return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double logged_cards_processing_time() const;</span>
  public:
    const G1Predictions&amp; predictor() const { return _predictor; }
    const G1Analytics* analytics()   const { return const_cast&lt;const G1Analytics*&gt;(_analytics); }
  
    G1RemSetTrackingPolicy* remset_tracker() { return &amp;_remset_tracker; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,34 +126,39 @@</span>
    // Add the given number of bytes to the total number of allocated bytes in the old gen.
    void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
  
    void set_region_eden(HeapRegion* hr) {
      hr-&gt;set_eden();
<span class="udiff-line-modified-removed">-     hr-&gt;install_surv_rate_group(_short_lived_surv_rate_group);</span>
<span class="udiff-line-modified-added">+     hr-&gt;install_surv_rate_group(_eden_surv_rate_group);</span>
    }
  
    void set_region_survivor(HeapRegion* hr) {
      assert(hr-&gt;is_survivor(), &quot;pre-condition&quot;);
      hr-&gt;install_surv_rate_group(_survivor_surv_rate_group);
    }
  
<span class="udiff-line-modified-removed">-   void record_max_rs_lengths(size_t rs_lengths) {</span>
<span class="udiff-line-modified-removed">-     _max_rs_lengths = rs_lengths;</span>
<span class="udiff-line-modified-added">+   void record_rs_length(size_t rs_length) {</span>
<span class="udiff-line-modified-added">+     _rs_length = rs_length;</span>
    }
  
<span class="udiff-line-modified-removed">-   double predict_base_elapsed_time_ms(size_t pending_cards) const;</span>
<span class="udiff-line-removed">-   double predict_base_elapsed_time_ms(size_t pending_cards,</span>
<span class="udiff-line-removed">-                                       size_t scanned_cards) const;</span>
<span class="udiff-line-removed">-   size_t predict_bytes_to_copy(HeapRegion* hr) const;</span>
<span class="udiff-line-removed">-   double predict_region_elapsed_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
<span class="udiff-line-modified-added">+   double predict_base_elapsed_time_ms(size_t num_pending_cards) const;</span>
  
<span class="udiff-line-modified-removed">-   double predict_survivor_regions_evac_time() const;</span>
<span class="udiff-line-modified-added">+ private:</span>
<span class="udiff-line-added">+   double predict_base_elapsed_time_ms(size_t num_pending_cards, size_t rs_length) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double predict_region_copy_time_ms(HeapRegion* hr) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   double predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy = NULL) const;</span>
<span class="udiff-line-added">+   double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
<span class="udiff-line-added">+   double predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
  
    void cset_regions_freed() {
      bool update = should_update_surv_rate_group_predictors();
  
<span class="udiff-line-modified-removed">-     _short_lived_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);</span>
<span class="udiff-line-modified-added">+     _eden_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);</span>
      _survivor_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
    }
  
    G1MMUTracker* mmu_tracker() {
      return _mmu_tracker;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159,16 +170,10 @@</span>
  
    double max_pause_time_ms() const {
      return _mmu_tracker-&gt;max_gc_time() * 1000.0;
    }
  
<span class="udiff-line-removed">-   double predict_yg_surv_rate(int age, SurvRateGroup* surv_rate_group) const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   double predict_yg_surv_rate(int age) const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   double accum_yg_surv_rate_pred(int age) const;</span>
<span class="udiff-line-removed">- </span>
  private:
    G1CollectionSet* _collection_set;
    double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
    double other_time_ms(double pause_time_ms) const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -176,13 +181,10 @@</span>
    double non_young_other_time_ms() const;
    double constant_other_time_ms(double pause_time_ms) const;
  
    G1CollectionSetChooser* cset_chooser() const;
  
<span class="udiff-line-removed">-   // The number of bytes copied during the GC.</span>
<span class="udiff-line-removed">-   size_t _bytes_copied_during_gc;</span>
<span class="udiff-line-removed">- </span>
    // Stash a pointer to the g1 heap.
    G1CollectedHeap* _g1h;
  
    G1GCPhaseTimes* _phase_times;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -190,21 +192,21 @@</span>
    // determine whether we should initiate a new marking.
    double _mark_remark_start_sec;
    double _mark_cleanup_start_sec;
  
    // Updates the internal young list maximum and target lengths. Returns the
<span class="udiff-line-modified-removed">-   // unbounded young list target length.</span>
<span class="udiff-line-modified-added">+   // unbounded young list target length. If no rs_length parameter is passed,</span>
<span class="udiff-line-added">+   // predict the RS length using the prediction model, otherwise use the</span>
<span class="udiff-line-added">+   // given rs_length as the prediction.</span>
    uint update_young_list_max_and_target_length();
<span class="udiff-line-modified-removed">-   uint update_young_list_max_and_target_length(size_t rs_lengths);</span>
<span class="udiff-line-modified-added">+   uint update_young_list_max_and_target_length(size_t rs_length);</span>
  
    // Update the young list target length either by setting it to the
    // desired fixed value or by calculating it using G1&#39;s pause
<span class="udiff-line-modified-removed">-   // prediction model. If no rs_lengths parameter is passed, predict</span>
<span class="udiff-line-removed">-   // the RS lengths using the prediction model, otherwise use the</span>
<span class="udiff-line-removed">-   // given rs_lengths as the prediction.</span>
<span class="udiff-line-modified-added">+   // prediction model.</span>
    // Returns the unbounded young list target length.
<span class="udiff-line-modified-removed">-   uint update_young_list_target_length(size_t rs_lengths);</span>
<span class="udiff-line-modified-added">+   uint update_young_list_target_length(size_t rs_length);</span>
  
    // Calculate and return the minimum desired young list target
    // length. This is the minimum desired young list length according
    // to the user&#39;s inputs.
    uint calculate_young_list_desired_min_length(uint base_min_length) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -213,38 +215,41 @@</span>
    // length. This is the maximum desired young list length according
    // to the user&#39;s inputs.
    uint calculate_young_list_desired_max_length() const;
  
    // Calculate and return the maximum young list target length that
<span class="udiff-line-modified-removed">-   // can fit into the pause time goal. The parameters are: rs_lengths</span>
<span class="udiff-line-modified-added">+   // can fit into the pause time goal. The parameters are: rs_length</span>
    // represent the prediction of how large the young RSet lengths will
    // be, base_min_length is the already existing number of regions in
    // the young list, min_length and max_length are the desired min and
    // max young list length according to the user&#39;s inputs.
<span class="udiff-line-modified-removed">-   uint calculate_young_list_target_length(size_t rs_lengths,</span>
<span class="udiff-line-modified-added">+   uint calculate_young_list_target_length(size_t rs_length,</span>
                                            uint base_min_length,
                                            uint desired_min_length,
                                            uint desired_max_length) const;
  
    // Result of the bounded_young_list_target_length() method, containing both the
    // bounded as well as the unbounded young list target lengths in this order.
    typedef Pair&lt;uint, uint, StackObj&gt; YoungTargetLengths;
<span class="udiff-line-modified-removed">-   YoungTargetLengths young_list_target_lengths(size_t rs_lengths) const;</span>
<span class="udiff-line-modified-added">+   YoungTargetLengths young_list_target_lengths(size_t rs_length) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void update_rs_length_prediction();</span>
<span class="udiff-line-added">+   void update_rs_length_prediction(size_t prediction);</span>
  
<span class="udiff-line-modified-removed">-   void update_rs_lengths_prediction();</span>
<span class="udiff-line-modified-removed">-   void update_rs_lengths_prediction(size_t prediction);</span>
<span class="udiff-line-modified-added">+   size_t predict_bytes_to_copy(HeapRegion* hr) const;</span>
<span class="udiff-line-modified-added">+   double predict_survivor_regions_evac_time() const;</span>
  
    // Check whether a given young length (young_length) fits into the
    // given target pause time and whether the prediction for the amount
    // of objects to be copied for the given length will fit into the
    // given free space (expressed by base_free_regions).  It is used by
    // calculate_young_list_target_length().
    bool predict_will_fit(uint young_length, double base_time_ms,
                          uint base_free_regions, double target_pause_time_ms) const;
  
  public:
<span class="udiff-line-modified-removed">-   size_t pending_cards() const { return _pending_cards; }</span>
<span class="udiff-line-modified-added">+   size_t pending_cards_at_gc_start() const { return _pending_cards_at_gc_start; }</span>
  
    // Calculate the minimum number of old regions we&#39;ll add to the CSet
    // during a mixed GC.
    uint calc_min_old_cset_length() const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,26 +284,29 @@</span>
    PauseKind young_gc_pause_kind() const;
    // Record the given STW pause with the given start and end times (in s).
    void record_pause(PauseKind kind, double start, double end);
    // Indicate that we aborted marking before doing any mixed GCs.
    void abort_time_to_mixed_tracking();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void record_concurrent_refinement_data(bool is_full_collection);</span>
<span class="udiff-line-added">+ </span>
  public:
  
<span class="udiff-line-modified-removed">-   G1Policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer);</span>
<span class="udiff-line-modified-added">+   G1Policy(STWGCTimer* gc_timer);</span>
  
    virtual ~G1Policy();
  
<span class="udiff-line-modified-removed">-   static G1Policy* create_policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer_stw);</span>
<span class="udiff-line-modified-added">+   static G1Policy* create_policy(STWGCTimer* gc_timer_stw);</span>
  
    G1CollectorState* collector_state() const;
  
    G1GCPhaseTimes* phase_times() const { return _phase_times; }
  
<span class="udiff-line-modified-removed">-   // Check the current value of the young list RSet lengths and</span>
<span class="udiff-line-modified-added">+   // Check the current value of the young list RSet length and</span>
    // compare it against the last prediction. If the current value is
    // higher, recalculate the young list target length prediction.
<span class="udiff-line-modified-removed">-   void revise_young_list_target_length_if_necessary(size_t rs_lengths);</span>
<span class="udiff-line-modified-added">+   void revise_young_list_target_length_if_necessary(size_t rs_length);</span>
  
    // This should be called after the heap is resized.
    void record_new_heap_size(uint new_number_of_regions);
  
    virtual void init(G1CollectedHeap* g1h, G1CollectionSet* collection_set);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,11 +317,11 @@</span>
  
    bool about_to_start_mixed_phase() const;
  
    // Record the start and end of an evacuation pause.
    void record_collection_pause_start(double start_time_sec);
<span class="udiff-line-modified-removed">-   virtual void record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc);</span>
<span class="udiff-line-modified-added">+   virtual void record_collection_pause_end(double pause_time_ms);</span>
  
    // Record the start and end of a full collection.
    void record_full_collection_start();
    virtual void record_full_collection_end();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,25 +336,28 @@</span>
    void record_concurrent_mark_cleanup_start();
    void record_concurrent_mark_cleanup_end();
  
    void print_phases();
  
<span class="udiff-line-removed">-   // Record how much space we copied during a GC. This is typically</span>
<span class="udiff-line-removed">-   // called when a GC alloc region is being retired.</span>
<span class="udiff-line-removed">-   void record_bytes_copied_during_gc(size_t bytes) {</span>
<span class="udiff-line-removed">-     _bytes_copied_during_gc += bytes;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The amount of space we copied during a GC.</span>
<span class="udiff-line-removed">-   size_t bytes_copied_during_gc() const {</span>
<span class="udiff-line-removed">-     return _bytes_copied_during_gc;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    bool next_gc_should_be_mixed(const char* true_action_str,
                                 const char* false_action_str) const;
  
<span class="udiff-line-modified-removed">-   void finalize_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);</span>
<span class="udiff-line-modified-added">+   // Calculate and return the number of initial and optional old gen regions from</span>
<span class="udiff-line-added">+   // the given collection set candidates and the remaining time.</span>
<span class="udiff-line-added">+   void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="udiff-line-added">+                                             double time_remaining_ms,</span>
<span class="udiff-line-added">+                                             uint&amp; num_initial_regions,</span>
<span class="udiff-line-added">+                                             uint&amp; num_optional_regions);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Calculate the number of optional regions from the given collection set candidates,</span>
<span class="udiff-line-added">+   // the remaining time and the maximum number of these regions and return the number</span>
<span class="udiff-line-added">+   // of actually selected regions in num_optional_regions.</span>
<span class="udiff-line-added">+   void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="udiff-line-added">+                                                  uint const max_optional_regions,</span>
<span class="udiff-line-added">+                                                  double time_remaining_ms,</span>
<span class="udiff-line-added">+                                                  uint&amp; num_optional_regions);</span>
<span class="udiff-line-added">+ </span>
  private:
    // Set the state to start a concurrent marking cycle and clear
    // _initiate_conc_mark_if_possible because it has now been
    // acted on.
    void initiate_conc_mark();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -364,29 +375,21 @@</span>
    // marking thread has completed its work during the previous cycle,
    // it will set in_initial_mark_gc() to so that the pause does
    // the initial-mark work and start a marking cycle.
    void decide_on_conc_mark_initiation();
  
<span class="udiff-line-removed">-   void finished_recalculating_age_indexes(bool is_survivors) {</span>
<span class="udiff-line-removed">-     if (is_survivors) {</span>
<span class="udiff-line-removed">-       _survivor_surv_rate_group-&gt;finished_recalculating_age_indexes();</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       _short_lived_surv_rate_group-&gt;finished_recalculating_age_indexes();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    size_t young_list_target_length() const { return _young_list_target_length; }
  
    bool should_allocate_mutator_region() const;
  
    bool can_expand_young_list() const;
  
    uint young_list_max_length() const {
      return _young_list_max_length;
    }
  
<span class="udiff-line-modified-removed">-   bool adaptive_young_list_length() const;</span>
<span class="udiff-line-modified-added">+   bool use_adaptive_young_list_length() const;</span>
  
    void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
  
  private:
    //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -401,15 +404,17 @@</span>
    uint _max_survivor_regions;
  
    AgeTable _survivors_age_table;
  
    size_t desired_survivor_size(uint max_regions) const;
<span class="udiff-line-modified-removed">- public:</span>
<span class="udiff-line-modified-added">+ </span>
    // Fraction used when predicting how many optional regions to include in
    // the CSet. This fraction of the available time is used for optional regions,
    // the rest is used to add old regions to the normal CSet.
    double optional_prediction_fraction() { return 0.2; }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
    // Fraction used when evacuating the optional regions. This fraction of the
    // remaining time is used to choose what regions to include in the evacuation.
    double optional_evacuation_fraction() { return 0.75; }
  
    uint tenuring_threshold() const { return _tenuring_threshold; }
</pre>
<center><a href="g1Policy.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Predictions.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
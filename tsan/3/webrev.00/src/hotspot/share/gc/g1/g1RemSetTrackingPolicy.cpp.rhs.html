<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1RemSetTrackingPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
 27 #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
 28 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 29 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 30 #include &quot;runtime/safepoint.hpp&quot;
 31 
 32 bool G1RemSetTrackingPolicy::needs_scan_for_rebuild(HeapRegion* r) const {
 33   // All non-free, non-young, non-closed archive regions need to be scanned for references;
 34   // At every gc we gather references to other regions in young, and closed archive
 35   // regions by definition do not have references going outside the closed archive.
 36   // Free regions trivially do not need scanning because they do not contain live
 37   // objects.
 38   return !(r-&gt;is_young() || r-&gt;is_closed_archive() || r-&gt;is_free());
 39 }
 40 
 41 void G1RemSetTrackingPolicy::update_at_allocate(HeapRegion* r) {
 42   if (r-&gt;is_young()) {
 43     // Always collect remembered set for young regions.
 44     r-&gt;rem_set()-&gt;set_state_complete();
 45   } else if (r-&gt;is_humongous()) {
 46     // Collect remembered sets for humongous regions by default to allow eager reclaim.
 47     r-&gt;rem_set()-&gt;set_state_complete();
 48   } else if (r-&gt;is_archive()) {
 49     // Archive regions never move ever. So never build remembered sets for them.
 50     r-&gt;rem_set()-&gt;set_state_empty();
 51   } else if (r-&gt;is_old()) {
 52     // By default, do not create remembered set for new old regions.
 53     r-&gt;rem_set()-&gt;set_state_empty();
 54   } else {
 55     guarantee(false, &quot;Unhandled region %u with heap region type %s&quot;, r-&gt;hrm_index(), r-&gt;get_type_str());
 56   }
 57 }
 58 
 59 void G1RemSetTrackingPolicy::update_at_free(HeapRegion* r) {
 60   /* nothing to do */
 61 }
 62 
 63 static void print_before_rebuild(HeapRegion* r, bool selected_for_rebuild, size_t total_live_bytes, size_t live_bytes) {
 64   log_trace(gc, remset, tracking)(&quot;Before rebuild region %u &quot;
 65                                   &quot;(ntams: &quot; PTR_FORMAT &quot;) &quot;
 66                                   &quot;total_live_bytes &quot; SIZE_FORMAT &quot; &quot;
 67                                   &quot;selected %s &quot;
 68                                   &quot;(live_bytes &quot; SIZE_FORMAT &quot; &quot;
 69                                   &quot;next_marked &quot; SIZE_FORMAT &quot; &quot;
 70                                   &quot;marked &quot; SIZE_FORMAT &quot; &quot;
 71                                   &quot;type %s)&quot;,
 72                                   r-&gt;hrm_index(),
 73                                   p2i(r-&gt;next_top_at_mark_start()),
 74                                   total_live_bytes,
 75                                   BOOL_TO_STR(selected_for_rebuild),
 76                                   live_bytes,
 77                                   r-&gt;next_marked_bytes(),
 78                                   r-&gt;marked_bytes(),
 79                                   r-&gt;get_type_str());
 80 }
 81 
 82 bool G1RemSetTrackingPolicy::update_humongous_before_rebuild(HeapRegion* r, bool is_live) {
 83   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
 84   assert(r-&gt;is_humongous(), &quot;Region %u should be humongous&quot;, r-&gt;hrm_index());
 85 
 86   if (r-&gt;is_archive()) {
 87     return false;
 88   }
 89 
 90   assert(!r-&gt;rem_set()-&gt;is_updating(), &quot;Remembered set of region %u is updating before rebuild&quot;, r-&gt;hrm_index());
 91 
 92   bool selected_for_rebuild = false;
 93   // For humongous regions, to be of interest for rebuilding the remembered set the following must apply:
 94   // - We always try to update the remembered sets of humongous regions containing
 95   // type arrays as they might have been reset after full gc.
 96   if (is_live &amp;&amp; oop(r-&gt;humongous_start_region()-&gt;bottom())-&gt;is_typeArray() &amp;&amp; !r-&gt;rem_set()-&gt;is_tracked()) {
 97     r-&gt;rem_set()-&gt;set_state_updating();
 98     selected_for_rebuild = true;
 99   }
100 
101   size_t const live_bytes = is_live ? HeapRegion::GrainBytes : 0;
102   print_before_rebuild(r, selected_for_rebuild, live_bytes, live_bytes);
103 
104   return selected_for_rebuild;
105 }
106 
107 bool G1RemSetTrackingPolicy::update_before_rebuild(HeapRegion* r, size_t live_bytes) {
108   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
109   assert(!r-&gt;is_humongous(), &quot;Region %u is humongous&quot;, r-&gt;hrm_index());
110 
111   // Only consider updating the remembered set for old gen regions - excluding archive regions
112   // which never move (but are &quot;Old&quot; regions).
113   if (!r-&gt;is_old() || r-&gt;is_archive()) {
114     return false;
115   }
116 
117   assert(!r-&gt;rem_set()-&gt;is_updating(), &quot;Remembered set of region %u is updating before rebuild&quot;, r-&gt;hrm_index());
118 
119   size_t between_ntams_and_top = (r-&gt;top() - r-&gt;next_top_at_mark_start()) * HeapWordSize;
120   size_t total_live_bytes = live_bytes + between_ntams_and_top;
121 
122   bool selected_for_rebuild = false;
123   // For old regions, to be of interest for rebuilding the remembered set the following must apply:
124   // - They must contain some live data in them.
125   // - Only need to rebuild non-complete remembered sets.
126   // - Otherwise only add those old gen regions which occupancy is low enough that there
127   // is a chance that we will ever evacuate them in the mixed gcs.
128   if ((total_live_bytes &gt; 0) &amp;&amp;
129       G1CollectionSetChooser::region_occupancy_low_enough_for_evac(total_live_bytes) &amp;&amp;
130       !r-&gt;rem_set()-&gt;is_tracked()) {
131 
132     r-&gt;rem_set()-&gt;set_state_updating();
133     selected_for_rebuild = true;
134   }
135 
136   print_before_rebuild(r, selected_for_rebuild, total_live_bytes, live_bytes);
137 
138   return selected_for_rebuild;
139 }
140 
141 void G1RemSetTrackingPolicy::update_after_rebuild(HeapRegion* r) {
142   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
143 
144   if (r-&gt;is_old_or_humongous_or_archive()) {
145     if (r-&gt;rem_set()-&gt;is_updating()) {
146       assert(!r-&gt;is_archive(), &quot;Archive region %u with remembered set&quot;, r-&gt;hrm_index());
147       r-&gt;rem_set()-&gt;set_state_complete();
148     }
149     G1CollectedHeap* g1h = G1CollectedHeap::heap();
150     // We can drop remembered sets of humongous regions that have a too large remembered set:
151     // We will never try to eagerly reclaim or move them anyway until the next concurrent
152     // cycle as e.g. remembered set entries will always be added.
153     if (r-&gt;is_starts_humongous() &amp;&amp; !g1h-&gt;is_potential_eager_reclaim_candidate(r)) {
154       // Handle HC regions with the HS region.
155       uint const size_in_regions = (uint)g1h-&gt;humongous_obj_size_in_regions(oop(r-&gt;bottom())-&gt;size());
156       uint const region_idx = r-&gt;hrm_index();
157       for (uint j = region_idx; j &lt; (region_idx + size_in_regions); j++) {
158         HeapRegion* const cur = g1h-&gt;region_at(j);
159         assert(!cur-&gt;is_continues_humongous() || cur-&gt;rem_set()-&gt;is_empty(),
160                &quot;Continues humongous region %u remset should be empty&quot;, j);
161         cur-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);
162       }
163     }
164     G1ConcurrentMark* cm = G1CollectedHeap::heap()-&gt;concurrent_mark();
165     log_trace(gc, remset, tracking)(&quot;After rebuild region %u &quot;
166                                     &quot;(ntams &quot; PTR_FORMAT &quot; &quot;
167                                     &quot;liveness &quot; SIZE_FORMAT &quot; &quot;
168                                     &quot;next_marked_bytes &quot; SIZE_FORMAT &quot; &quot;
169                                     &quot;remset occ &quot; SIZE_FORMAT &quot; &quot;
170                                     &quot;size &quot; SIZE_FORMAT &quot;)&quot;,
171                                     r-&gt;hrm_index(),
172                                     p2i(r-&gt;next_top_at_mark_start()),
173                                     cm-&gt;liveness(r-&gt;hrm_index()) * HeapWordSize,
174                                     r-&gt;next_marked_bytes(),
<a name="1" id="anc1"></a><span class="line-modified">175                                     r-&gt;rem_set()-&gt;occupied(),</span>
176                                     r-&gt;rem_set()-&gt;mem_size());
177   }
178 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
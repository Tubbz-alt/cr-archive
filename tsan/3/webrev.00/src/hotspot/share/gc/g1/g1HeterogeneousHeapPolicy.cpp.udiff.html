<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1HeterogeneousHeapPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HeapVerifier.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeterogeneousHeapPolicy.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HeterogeneousHeapPolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,23 +26,23 @@</span>
  #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  
<span class="udiff-line-modified-removed">- G1HeterogeneousHeapPolicy::G1HeterogeneousHeapPolicy(G1CollectorPolicy* policy, STWGCTimer* gc_timer) :</span>
<span class="udiff-line-modified-removed">-   G1Policy(policy, gc_timer), _manager(NULL) {}</span>
<span class="udiff-line-modified-added">+ G1HeterogeneousHeapPolicy::G1HeterogeneousHeapPolicy(STWGCTimer* gc_timer) :</span>
<span class="udiff-line-modified-added">+   G1Policy(gc_timer), _manager(NULL) {}</span>
  
  // We call the super class init(), after which we provision young_list_target_length() regions in dram.
  void G1HeterogeneousHeapPolicy::init(G1CollectedHeap* g1h, G1CollectionSet* collection_set) {
    G1Policy::init(g1h, collection_set);
    _manager = HeterogeneousHeapRegionManager::manager();
    _manager-&gt;adjust_dram_regions((uint)young_list_target_length(), G1CollectedHeap::heap()-&gt;workers());
  }
  
  // After a collection pause, young list target length is updated. So we need to make sure we have enough regions in dram for young gen.
<span class="udiff-line-modified-removed">- void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc) {</span>
<span class="udiff-line-modified-removed">-   G1Policy::record_collection_pause_end(pause_time_ms, cards_scanned, heap_used_bytes_before_gc);</span>
<span class="udiff-line-modified-added">+ void G1HeterogeneousHeapPolicy::record_collection_pause_end(double pause_time_ms) {</span>
<span class="udiff-line-modified-added">+   G1Policy::record_collection_pause_end(pause_time_ms);</span>
    _manager-&gt;adjust_dram_regions((uint)young_list_target_length(), G1CollectedHeap::heap()-&gt;workers());
  }
  
  // After a full collection, young list target length is updated. So we need to make sure we have enough regions in dram for young gen.
  void G1HeterogeneousHeapPolicy::record_full_collection_end() {
</pre>
<center><a href="g1HeapVerifier.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeterogeneousHeapPolicy.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
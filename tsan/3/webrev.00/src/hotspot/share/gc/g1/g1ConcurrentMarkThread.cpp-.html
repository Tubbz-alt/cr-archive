<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;gc/g1/g1Analytics.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
 31 #include &quot;gc/g1/g1MMUTracker.hpp&quot;
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/g1RemSet.hpp&quot;
 34 #include &quot;gc/g1/g1VMOperations.hpp&quot;
 35 #include &quot;gc/shared/concurrentGCPhaseManager.hpp&quot;
 36 #include &quot;gc/shared/gcId.hpp&quot;
 37 #include &quot;gc/shared/gcTrace.hpp&quot;
 38 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 39 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 40 #include &quot;logging/log.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;runtime/handles.inline.hpp&quot;
 43 #include &quot;runtime/vmThread.hpp&quot;
 44 #include &quot;utilities/debug.hpp&quot;
 45 
 46 // ======= Concurrent Mark Thread ========
 47 
 48 // Check order in EXPAND_CURRENT_PHASES
 49 STATIC_ASSERT(ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE &lt;
 50               ConcurrentGCPhaseManager::IDLE_PHASE);
 51 
 52 #define EXPAND_CONCURRENT_PHASES(expander)                                 \
 53   expander(ANY, = ConcurrentGCPhaseManager::UNCONSTRAINED_PHASE, NULL)     \
 54   expander(IDLE, = ConcurrentGCPhaseManager::IDLE_PHASE, NULL)             \
 55   expander(CONCURRENT_CYCLE,, &quot;Concurrent Cycle&quot;)                          \
 56   expander(CLEAR_CLAIMED_MARKS,, &quot;Concurrent Clear Claimed Marks&quot;)         \
 57   expander(SCAN_ROOT_REGIONS,, &quot;Concurrent Scan Root Regions&quot;)             \
 58   expander(CONCURRENT_MARK,, &quot;Concurrent Mark&quot;)                            \
 59   expander(MARK_FROM_ROOTS,, &quot;Concurrent Mark From Roots&quot;)                 \
 60   expander(PRECLEAN,, &quot;Concurrent Preclean&quot;)                               \
 61   expander(BEFORE_REMARK,, NULL)                                           \
 62   expander(REMARK,, NULL)                                                  \
 63   expander(REBUILD_REMEMBERED_SETS,, &quot;Concurrent Rebuild Remembered Sets&quot;) \
 64   expander(CLEANUP_FOR_NEXT_MARK,, &quot;Concurrent Cleanup for Next Mark&quot;)     \
 65   /* */
 66 
 67 class G1ConcurrentPhase : public AllStatic {
 68 public:
 69   enum {
 70 #define CONCURRENT_PHASE_ENUM(tag, value, ignore_title) tag value,
 71     EXPAND_CONCURRENT_PHASES(CONCURRENT_PHASE_ENUM)
 72 #undef CONCURRENT_PHASE_ENUM
 73     PHASE_ID_LIMIT
 74   };
 75 };
 76 
 77 G1ConcurrentMarkThread::G1ConcurrentMarkThread(G1ConcurrentMark* cm) :
 78   ConcurrentGCThread(),
 79   _vtime_start(0.0),
 80   _vtime_accum(0.0),
 81   _vtime_mark_accum(0.0),
 82   _cm(cm),
 83   _state(Idle),
 84   _phase_manager_stack() {
 85 
 86   set_name(&quot;G1 Main Marker&quot;);
 87   create_and_start();
 88 }
 89 
 90 class CMRemark : public VoidClosure {
 91   G1ConcurrentMark* _cm;
 92 public:
 93   CMRemark(G1ConcurrentMark* cm) : _cm(cm) {}
 94 
 95   void do_void(){
 96     _cm-&gt;remark();
 97   }
 98 };
 99 
100 class CMCleanup : public VoidClosure {
101   G1ConcurrentMark* _cm;
102 public:
103   CMCleanup(G1ConcurrentMark* cm) : _cm(cm) {}
104 
105   void do_void(){
106     _cm-&gt;cleanup();
107   }
108 };
109 
110 double G1ConcurrentMarkThread::mmu_sleep_time(G1Policy* g1_policy, bool remark) {
111   // There are 3 reasons to use SuspendibleThreadSetJoiner.
112   // 1. To avoid concurrency problem.
113   //    - G1MMUTracker::add_pause(), when_sec() and its variation(when_ms() etc..) can be called
114   //      concurrently from ConcurrentMarkThread and VMThread.
115   // 2. If currently a gc is running, but it has not yet updated the MMU,
116   //    we will not forget to consider that pause in the MMU calculation.
117   // 3. If currently a gc is running, ConcurrentMarkThread will wait it to be finished.
118   //    And then sleep for predicted amount of time by delay_to_keep_mmu().
119   SuspendibleThreadSetJoiner sts_join;
120 
121   const G1Analytics* analytics = g1_policy-&gt;analytics();
122   double now = os::elapsedTime();
123   double prediction_ms = remark ? analytics-&gt;predict_remark_time_ms()
124                                 : analytics-&gt;predict_cleanup_time_ms();
125   G1MMUTracker *mmu_tracker = g1_policy-&gt;mmu_tracker();
126   return mmu_tracker-&gt;when_ms(now, prediction_ms);
127 }
128 
129 void G1ConcurrentMarkThread::delay_to_keep_mmu(G1Policy* g1_policy, bool remark) {
130   if (g1_policy-&gt;adaptive_young_list_length()) {
131     jlong sleep_time_ms = mmu_sleep_time(g1_policy, remark);
132     if (!_cm-&gt;has_aborted() &amp;&amp; sleep_time_ms &gt; 0) {
133       os::sleep(this, sleep_time_ms, false);
134     }
135   }
136 }
137 
138 class G1ConcPhaseTimer : public GCTraceConcTimeImpl&lt;LogLevel::Info, LOG_TAGS(gc, marking)&gt; {
139   G1ConcurrentMark* _cm;
140 
141  public:
142   G1ConcPhaseTimer(G1ConcurrentMark* cm, const char* title) :
143     GCTraceConcTimeImpl&lt;LogLevel::Info,  LogTag::_gc, LogTag::_marking&gt;(title),
144     _cm(cm)
145   {
146     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_start(title);
147   }
148 
149   ~G1ConcPhaseTimer() {
150     _cm-&gt;gc_timer_cm()-&gt;register_gc_concurrent_end();
151   }
152 };
153 
154 static const char* const concurrent_phase_names[] = {
155 #define CONCURRENT_PHASE_NAME(tag, ignore_value, ignore_title) XSTR(tag),
156   EXPAND_CONCURRENT_PHASES(CONCURRENT_PHASE_NAME)
157 #undef CONCURRENT_PHASE_NAME
158   NULL                          // terminator
159 };
160 // Verify dense enum assumption.  +1 for terminator.
161 STATIC_ASSERT(G1ConcurrentPhase::PHASE_ID_LIMIT + 1 ==
162               ARRAY_SIZE(concurrent_phase_names));
163 
164 // Returns the phase number for name, or a negative value if unknown.
165 static int lookup_concurrent_phase(const char* name) {
166   const char* const* names = concurrent_phase_names;
167   for (uint i = 0; names[i] != NULL; ++i) {
168     if (strcmp(name, names[i]) == 0) {
169       return static_cast&lt;int&gt;(i);
170     }
171   }
172   return -1;
173 }
174 
175 // The phase must be valid and must have a title.
176 static const char* lookup_concurrent_phase_title(int phase) {
177   static const char* const titles[] = {
178 #define CONCURRENT_PHASE_TITLE(ignore_tag, ignore_value, title) title,
179     EXPAND_CONCURRENT_PHASES(CONCURRENT_PHASE_TITLE)
180 #undef CONCURRENT_PHASE_TITLE
181   };
182   // Verify dense enum assumption.
183   STATIC_ASSERT(G1ConcurrentPhase::PHASE_ID_LIMIT == ARRAY_SIZE(titles));
184 
185   assert(0 &lt;= phase, &quot;precondition&quot;);
186   assert((uint)phase &lt; ARRAY_SIZE(titles), &quot;precondition&quot;);
187   const char* title = titles[phase];
188   assert(title != NULL, &quot;precondition&quot;);
189   return title;
190 }
191 
192 class G1ConcPhaseManager : public StackObj {
193   G1ConcurrentMark* _cm;
194   ConcurrentGCPhaseManager _manager;
195 
196 public:
197   G1ConcPhaseManager(int phase, G1ConcurrentMarkThread* thread) :
198     _cm(thread-&gt;cm()),
199     _manager(phase, thread-&gt;phase_manager_stack())
200   { }
201 
202   ~G1ConcPhaseManager() {
203     // Deactivate the manager if marking aborted, to avoid blocking on
204     // phase exit when the phase has been requested.
205     if (_cm-&gt;has_aborted()) {
206       _manager.deactivate();
207     }
208   }
209 
210   void set_phase(int phase, bool force) {
211     _manager.set_phase(phase, force);
212   }
213 };
214 
215 // Combine phase management and timing into one convenient utility.
216 class G1ConcPhase : public StackObj {
217   G1ConcPhaseTimer _timer;
218   G1ConcPhaseManager _manager;
219 
220 public:
221   G1ConcPhase(int phase, G1ConcurrentMarkThread* thread) :
222     _timer(thread-&gt;cm(), lookup_concurrent_phase_title(phase)),
223     _manager(phase, thread)
224   { }
225 };
226 
227 bool G1ConcurrentMarkThread::request_concurrent_phase(const char* phase_name) {
228   int phase = lookup_concurrent_phase(phase_name);
229   if (phase &lt; 0) return false;
230 
231   while (!ConcurrentGCPhaseManager::wait_for_phase(phase,
232                                                    phase_manager_stack())) {
233     assert(phase != G1ConcurrentPhase::ANY, &quot;Wait for ANY phase must succeed&quot;);
234     if ((phase != G1ConcurrentPhase::IDLE) &amp;&amp; !during_cycle()) {
235       // If idle and the goal is !idle, start a collection.
236       G1CollectedHeap::heap()-&gt;collect(GCCause::_wb_conc_mark);
237     }
238   }
239   return true;
240 }
241 
242 void G1ConcurrentMarkThread::run_service() {
243   _vtime_start = os::elapsedVTime();
244 
245   G1CollectedHeap* g1h = G1CollectedHeap::heap();
246   G1Policy* policy = g1h-&gt;policy();
247 
248   G1ConcPhaseManager cpmanager(G1ConcurrentPhase::IDLE, this);
249 
250   while (!should_terminate()) {
251     // wait until started is set.
252     sleep_before_next_cycle();
253     if (should_terminate()) {
254       break;
255     }
256 
257     cpmanager.set_phase(G1ConcurrentPhase::CONCURRENT_CYCLE, false /* force */);
258 
259     GCIdMark gc_id_mark;
260 
261     _cm-&gt;concurrent_cycle_start();
262 
263     GCTraceConcTime(Info, gc) tt(&quot;Concurrent Cycle&quot;);
264     {
265       ResourceMark rm;
266       HandleMark   hm;
267       double cycle_start = os::elapsedVTime();
268 
269       {
270         G1ConcPhase p(G1ConcurrentPhase::CLEAR_CLAIMED_MARKS, this);
271         ClassLoaderDataGraph::clear_claimed_marks();
272       }
273 
274       // We have to ensure that we finish scanning the root regions
275       // before the next GC takes place. To ensure this we have to
276       // make sure that we do not join the STS until the root regions
277       // have been scanned. If we did then it&#39;s possible that a
278       // subsequent GC could block us from joining the STS and proceed
279       // without the root regions have been scanned which would be a
280       // correctness issue.
281 
282       {
283         G1ConcPhase p(G1ConcurrentPhase::SCAN_ROOT_REGIONS, this);
284         _cm-&gt;scan_root_regions();
285       }
286 
287       // It would be nice to use the G1ConcPhase class here but
288       // the &quot;end&quot; logging is inside the loop and not at the end of
289       // a scope. Also, the timer doesn&#39;t support nesting.
290       // Mimicking the same log output instead.
291       {
292         G1ConcPhaseManager mark_manager(G1ConcurrentPhase::CONCURRENT_MARK, this);
293         jlong mark_start = os::elapsed_counter();
294         const char* cm_title = lookup_concurrent_phase_title(G1ConcurrentPhase::CONCURRENT_MARK);
295         log_info(gc, marking)(&quot;%s (%.3fs)&quot;,
296                               cm_title,
297                               TimeHelper::counter_to_seconds(mark_start));
298         for (uint iter = 1; !_cm-&gt;has_aborted(); ++iter) {
299           // Concurrent marking.
300           {
301             G1ConcPhase p(G1ConcurrentPhase::MARK_FROM_ROOTS, this);
302             _cm-&gt;mark_from_roots();
303           }
304           if (_cm-&gt;has_aborted()) {
305             break;
306           }
307 
308           if (G1UseReferencePrecleaning) {
309             G1ConcPhase p(G1ConcurrentPhase::PRECLEAN, this);
310             _cm-&gt;preclean();
311           }
312 
313           // Provide a control point before remark.
314           {
315             G1ConcPhaseManager p(G1ConcurrentPhase::BEFORE_REMARK, this);
316           }
317           if (_cm-&gt;has_aborted()) {
318             break;
319           }
320 
321           // Delay remark pause for MMU.
322           double mark_end_time = os::elapsedVTime();
323           jlong mark_end = os::elapsed_counter();
324           _vtime_mark_accum += (mark_end_time - cycle_start);
325           delay_to_keep_mmu(policy, true /* remark */);
326           if (_cm-&gt;has_aborted()) {
327             break;
328           }
329 
330           // Pause Remark.
331           log_info(gc, marking)(&quot;%s (%.3fs, %.3fs) %.3fms&quot;,
332                                 cm_title,
333                                 TimeHelper::counter_to_seconds(mark_start),
334                                 TimeHelper::counter_to_seconds(mark_end),
335                                 TimeHelper::counter_to_millis(mark_end - mark_start));
336           mark_manager.set_phase(G1ConcurrentPhase::REMARK, false);
337           CMRemark cl(_cm);
338           VM_G1Concurrent op(&amp;cl, &quot;Pause Remark&quot;);
339           VMThread::execute(&amp;op);
340           if (_cm-&gt;has_aborted()) {
341             break;
342           } else if (!_cm-&gt;restart_for_overflow()) {
343             break;              // Exit loop if no restart requested.
344           } else {
345             // Loop to restart for overflow.
346             mark_manager.set_phase(G1ConcurrentPhase::CONCURRENT_MARK, false);
347             log_info(gc, marking)(&quot;%s Restart for Mark Stack Overflow (iteration #%u)&quot;,
348                                   cm_title, iter);
349           }
350         }
351       }
352 
353       if (!_cm-&gt;has_aborted()) {
354         G1ConcPhase p(G1ConcurrentPhase::REBUILD_REMEMBERED_SETS, this);
355         _cm-&gt;rebuild_rem_set_concurrently();
356       }
357 
358       double end_time = os::elapsedVTime();
359       // Update the total virtual time before doing this, since it will try
360       // to measure it to get the vtime for this marking.
361       _vtime_accum = (end_time - _vtime_start);
362 
363       if (!_cm-&gt;has_aborted()) {
364         delay_to_keep_mmu(policy, false /* cleanup */);
365       }
366 
367       if (!_cm-&gt;has_aborted()) {
368         CMCleanup cl_cl(_cm);
369         VM_G1Concurrent op(&amp;cl_cl, &quot;Pause Cleanup&quot;);
370         VMThread::execute(&amp;op);
371       }
372 
373       // We now want to allow clearing of the marking bitmap to be
374       // suspended by a collection pause.
375       // We may have aborted just before the remark. Do not bother clearing the
376       // bitmap then, as it has been done during mark abort.
377       if (!_cm-&gt;has_aborted()) {
378         G1ConcPhase p(G1ConcurrentPhase::CLEANUP_FOR_NEXT_MARK, this);
379         _cm-&gt;cleanup_for_next_mark();
380       }
381     }
382 
383     // Update the number of full collections that have been
384     // completed. This will also notify the FullGCCount_lock in case a
385     // Java thread is waiting for a full GC to happen (e.g., it
386     // called System.gc() with +ExplicitGCInvokesConcurrent).
387     {
388       SuspendibleThreadSetJoiner sts_join;
389       g1h-&gt;increment_old_marking_cycles_completed(true /* concurrent */);
390 
391       _cm-&gt;concurrent_cycle_end();
392     }
393 
394     cpmanager.set_phase(G1ConcurrentPhase::IDLE, _cm-&gt;has_aborted() /* force */);
395   }
396   _cm-&gt;root_regions()-&gt;cancel_scan();
397 }
398 
399 void G1ConcurrentMarkThread::stop_service() {
400   MutexLockerEx ml(CGC_lock, Mutex::_no_safepoint_check_flag);
401   CGC_lock-&gt;notify_all();
402 }
403 
404 
405 void G1ConcurrentMarkThread::sleep_before_next_cycle() {
406   // We join here because we don&#39;t want to do the &quot;shouldConcurrentMark()&quot;
407   // below while the world is otherwise stopped.
408   assert(!in_progress(), &quot;should have been cleared&quot;);
409 
410   MutexLockerEx x(CGC_lock, Mutex::_no_safepoint_check_flag);
411   while (!started() &amp;&amp; !should_terminate()) {
412     CGC_lock-&gt;wait(Mutex::_no_safepoint_check_flag);
413   }
414 
415   if (started()) {
416     set_in_progress();
417   }
418 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1HeapTransition.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
 27 #include &quot;gc/g1/g1HeapTransition.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;logging/logStream.hpp&quot;</span>
 30 #include &quot;memory/metaspace.hpp&quot;
 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32 G1HeapTransition::Data::Data(G1CollectedHeap* g1_heap) :</span>
<span class="line-modified"> 33   _eden_length(g1_heap-&gt;eden_regions_count()),</span>
<span class="line-modified"> 34   _survivor_length(g1_heap-&gt;survivor_regions_count()),</span>
<span class="line-modified"> 35   _old_length(g1_heap-&gt;old_regions_count()),</span>
<span class="line-modified"> 36   _archive_length(g1_heap-&gt;archive_regions_count()),</span>
<span class="line-modified"> 37   _humongous_length(g1_heap-&gt;humongous_regions_count()),</span>
<span class="line-modified"> 38   _eden_length_per_node(NULL),</span>
<span class="line-added"> 39   _survivor_length_per_node(NULL) {</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41   uint node_count = G1NUMA::numa()-&gt;num_active_nodes();</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43   if (node_count &gt; 1) {</span>
<span class="line-added"> 44     LogTarget(Debug, gc, heap, numa) lt;</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46     if (lt.is_enabled()) {</span>
<span class="line-added"> 47       _eden_length_per_node = NEW_C_HEAP_ARRAY(uint, node_count, mtGC);</span>
<span class="line-added"> 48       _survivor_length_per_node = NEW_C_HEAP_ARRAY(uint, node_count, mtGC);</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50       for (uint i = 0; i &lt; node_count; i++) {</span>
<span class="line-added"> 51         _eden_length_per_node[i] = g1_heap-&gt;eden_regions_count(i);</span>
<span class="line-added"> 52         _survivor_length_per_node[i] = g1_heap-&gt;survivor_regions_count(i);</span>
<span class="line-added"> 53       }</span>
<span class="line-added"> 54     }</span>
<span class="line-added"> 55   }</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 G1HeapTransition::Data::~Data() {</span>
<span class="line-added"> 59   FREE_C_HEAP_ARRAY(uint, _eden_length_per_node);</span>
<span class="line-added"> 60   FREE_C_HEAP_ARRAY(uint, _survivor_length_per_node);</span>
 61 }
 62 
 63 G1HeapTransition::G1HeapTransition(G1CollectedHeap* g1_heap) : _g1_heap(g1_heap), _before(g1_heap) { }
 64 
 65 struct DetailedUsage : public StackObj {
 66   size_t _eden_used;
 67   size_t _survivor_used;
 68   size_t _old_used;
 69   size_t _archive_used;
 70   size_t _humongous_used;
 71 
 72   size_t _eden_region_count;
 73   size_t _survivor_region_count;
 74   size_t _old_region_count;
 75   size_t _archive_region_count;
 76   size_t _humongous_region_count;
 77 
 78   DetailedUsage() :
 79     _eden_used(0), _survivor_used(0), _old_used(0), _archive_used(0), _humongous_used(0),
 80     _eden_region_count(0), _survivor_region_count(0), _old_region_count(0),
 81     _archive_region_count(0), _humongous_region_count(0) {}
 82 };
 83 
 84 class DetailedUsageClosure: public HeapRegionClosure {
 85 public:
 86   DetailedUsage _usage;
 87   bool do_heap_region(HeapRegion* r) {
 88     if (r-&gt;is_old()) {
 89       _usage._old_used += r-&gt;used();
 90       _usage._old_region_count++;
 91     } else if (r-&gt;is_archive()) {
 92       _usage._archive_used += r-&gt;used();
 93       _usage._archive_region_count++;
 94     } else if (r-&gt;is_survivor()) {
 95       _usage._survivor_used += r-&gt;used();
 96       _usage._survivor_region_count++;
 97     } else if (r-&gt;is_eden()) {
 98       _usage._eden_used += r-&gt;used();
 99       _usage._eden_region_count++;
100     } else if (r-&gt;is_humongous()) {
101       _usage._humongous_used += r-&gt;used();
102       _usage._humongous_region_count++;
103     } else {
104       assert(r-&gt;used() == 0, &quot;Expected used to be 0 but it was &quot; SIZE_FORMAT, r-&gt;used());
105     }
106     return false;
107   }
108 };
109 
<a name="3" id="anc3"></a><span class="line-added">110 static void log_regions(const char* msg, size_t before_length, size_t after_length, size_t capacity,</span>
<span class="line-added">111                         uint* before_per_node_length, uint* after_per_node_length) {</span>
<span class="line-added">112   LogTarget(Info, gc, heap) lt;</span>
<span class="line-added">113 </span>
<span class="line-added">114   if (lt.is_enabled()) {</span>
<span class="line-added">115     LogStream ls(lt);</span>
<span class="line-added">116 </span>
<span class="line-added">117     ls.print(&quot;%s regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;(&quot;  SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-added">118              msg, before_length, after_length, capacity);</span>
<span class="line-added">119     // Not NULL only if gc+heap+numa at Debug level is enabled.</span>
<span class="line-added">120     if (before_per_node_length != NULL &amp;&amp; after_per_node_length != NULL) {</span>
<span class="line-added">121       G1NUMA* numa = G1NUMA::numa();</span>
<span class="line-added">122       uint num_nodes = numa-&gt;num_active_nodes();</span>
<span class="line-added">123       const int* node_ids = numa-&gt;node_ids();</span>
<span class="line-added">124       ls.print(&quot; (&quot;);</span>
<span class="line-added">125       for (uint i = 0; i &lt; num_nodes; i++) {</span>
<span class="line-added">126         ls.print(&quot;%d: %u-&gt;%u&quot;, node_ids[i], before_per_node_length[i], after_per_node_length[i]);</span>
<span class="line-added">127         // Skip adding below if it is the last one.</span>
<span class="line-added">128         if (i != num_nodes - 1) {</span>
<span class="line-added">129           ls.print(&quot;, &quot;);</span>
<span class="line-added">130         }</span>
<span class="line-added">131       }</span>
<span class="line-added">132       ls.print(&quot;)&quot;);</span>
<span class="line-added">133     }</span>
<span class="line-added">134     ls.print_cr(&quot;&quot;);</span>
<span class="line-added">135   }</span>
<span class="line-added">136 }</span>
<span class="line-added">137 </span>
138 void G1HeapTransition::print() {
139   Data after(_g1_heap);
140 
141   size_t eden_capacity_length_after_gc = _g1_heap-&gt;policy()-&gt;young_list_target_length() - after._survivor_length;
142   size_t survivor_capacity_length_before_gc = _g1_heap-&gt;policy()-&gt;max_survivor_regions();
143 
144   DetailedUsage usage;
145   if (log_is_enabled(Trace, gc, heap)) {
146     DetailedUsageClosure blk;
147     _g1_heap-&gt;heap_region_iterate(&amp;blk);
148     usage = blk._usage;
149     assert(usage._eden_region_count == 0, &quot;Expected no eden regions, but got &quot; SIZE_FORMAT, usage._eden_region_count);
150     assert(usage._survivor_region_count == after._survivor_length, &quot;Expected survivors to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
151         after._survivor_length, usage._survivor_region_count);
152     assert(usage._old_region_count == after._old_length, &quot;Expected old to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
153         after._old_length, usage._old_region_count);
154     assert(usage._archive_region_count == after._archive_length, &quot;Expected archive to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
155         after._archive_length, usage._archive_region_count);
156     assert(usage._humongous_region_count == after._humongous_length, &quot;Expected humongous to be &quot; SIZE_FORMAT &quot; but was &quot; SIZE_FORMAT,
157         after._humongous_length, usage._humongous_region_count);
158   }
159 
<a name="4" id="anc4"></a><span class="line-modified">160   log_regions(&quot;Eden&quot;, _before._eden_length, after._eden_length, eden_capacity_length_after_gc,</span>
<span class="line-modified">161               _before._eden_length_per_node, after._eden_length_per_node);</span>
162   log_trace(gc, heap)(&quot; Used: 0K, Waste: 0K&quot;);
163 
<a name="5" id="anc5"></a><span class="line-modified">164   log_regions(&quot;Survivor&quot;, _before._survivor_length, after._survivor_length, survivor_capacity_length_before_gc,</span>
<span class="line-modified">165               _before._survivor_length_per_node, after._survivor_length_per_node);</span>
166   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
167       usage._survivor_used / K, ((after._survivor_length * HeapRegion::GrainBytes) - usage._survivor_used) / K);
168 
169   log_info(gc, heap)(&quot;Old regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
170                      _before._old_length, after._old_length);
171   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
172       usage._old_used / K, ((after._old_length * HeapRegion::GrainBytes) - usage._old_used) / K);
173 
174   log_info(gc, heap)(&quot;Archive regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
175                      _before._archive_length, after._archive_length);
176   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
177       usage._archive_used / K, ((after._archive_length * HeapRegion::GrainBytes) - usage._archive_used) / K);
178 
179   log_info(gc, heap)(&quot;Humongous regions: &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT,
180                      _before._humongous_length, after._humongous_length);
181   log_trace(gc, heap)(&quot; Used: &quot; SIZE_FORMAT &quot;K, Waste: &quot; SIZE_FORMAT &quot;K&quot;,
182       usage._humongous_used / K, ((after._humongous_length * HeapRegion::GrainBytes) - usage._humongous_used) / K);
183 
<a name="6" id="anc6"></a><span class="line-modified">184   MetaspaceUtils::print_metaspace_change(_before._meta_sizes);</span>
185 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
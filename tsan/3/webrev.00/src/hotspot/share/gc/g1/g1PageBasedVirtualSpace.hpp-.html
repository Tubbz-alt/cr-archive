<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1PAGEBASEDVIRTUALSPACE_HPP
 26 #define SHARE_GC_G1_G1PAGEBASEDVIRTUALSPACE_HPP
 27 
 28 #include &quot;memory/memRegion.hpp&quot;
 29 #include &quot;memory/virtualspace.hpp&quot;
 30 #include &quot;utilities/align.hpp&quot;
 31 #include &quot;utilities/bitMap.hpp&quot;
 32 
 33 class WorkGang;
 34 
 35 // Virtual space management helper for a virtual space with an OS page allocation
 36 // granularity.
 37 // (De-)Allocation requests are always OS page aligned by passing a page index
 38 // and multiples of pages.
 39 // For systems that only commits of memory in a given size (always greater than
 40 // page size) the base address is required to be aligned to that page size.
 41 // The actual size requested need not be aligned to that page size, but the size
 42 // of the reservation passed may be rounded up to this page size. Any fragment
 43 // (less than the page size) of the actual size at the tail of the request will
 44 // be committed using OS small pages.
 45 // The implementation gives an error when trying to commit or uncommit pages that
 46 // have already been committed or uncommitted.
 47 class G1PageBasedVirtualSpace {
 48   friend class VMStructs;
 49  private:
 50   // Reserved area addresses.
 51   char* _low_boundary;
 52   char* _high_boundary;
 53 
 54   // The size of the tail in bytes of the handled space that needs to be committed
 55   // using small pages.
 56   size_t _tail_size;
 57 
 58   // The preferred page size used for commit/uncommit in bytes.
 59   size_t _page_size;
 60 
 61   // Bitmap used for verification of commit/uncommit operations.
 62   CHeapBitMap _committed;
 63 
 64   // Bitmap used to keep track of which pages are dirty or not for _special
 65   // spaces. This is needed because for those spaces the underlying memory
 66   // will only be zero filled the first time it is committed. Calls to commit
 67   // will use this bitmap and return whether or not the memory is zero filled.
 68   CHeapBitMap _dirty;
 69 
 70   // Indicates that the entire space has been committed and pinned in memory,
 71   // os::commit_memory() or os::uncommit_memory() have no function.
 72   bool _special;
 73 
 74   // Indicates whether the committed space should be executable.
 75   bool _executable;
 76 
 77   // Helper function for committing memory. Commit the given memory range by using
 78   // _page_size pages as much as possible and the remainder with small sized pages.
 79   void commit_internal(size_t start_page, size_t end_page);
 80   // Commit num_pages pages of _page_size size starting from start. All argument
 81   // checking has been performed.
 82   void commit_preferred_pages(size_t start_page, size_t end_page);
 83   // Commit space at the high end of the space that needs to be committed with small
 84   // sized pages.
 85   void commit_tail();
 86 
 87   // Uncommit the given memory range.
 88   void uncommit_internal(size_t start_page, size_t end_page);
 89 
 90   // Pretouch the given memory range.
 91   void pretouch_internal(size_t start_page, size_t end_page);
 92 
 93   // Returns the index of the page which contains the given address.
 94   size_t  addr_to_page_index(char* addr) const;
 95   // Returns the address of the given page index.
 96   char*  page_start(size_t index) const;
 97 
 98   // Is the given page index the last page?
 99   bool is_last_page(size_t index) const { return index == (_committed.size() - 1); }
100   // Is the given page index the first after last page?
101   bool is_after_last_page(size_t index) const;
102   // Is the last page only partially covered by this space?
103   bool is_last_page_partial() const { return !is_aligned(_high_boundary, _page_size); }
104   // Returns the end address of the given page bounded by the reserved space.
105   char* bounded_end_addr(size_t end_page) const;
106 
107   // Returns true if the entire area is backed by committed memory.
108   bool is_area_committed(size_t start_page, size_t size_in_pages) const;
109   // Returns true if the entire area is not backed by committed memory.
110   bool is_area_uncommitted(size_t start_page, size_t size_in_pages) const;
111 
112   void initialize_with_page_size(ReservedSpace rs, size_t used_size, size_t page_size);
113  public:
114 
115   // Commit the given area of pages starting at start being size_in_pages large.
116   // Returns true if the given area is zero filled upon completion.
117   bool commit(size_t start_page, size_t size_in_pages);
118 
119   // Uncommit the given area of pages starting at start being size_in_pages large.
120   void uncommit(size_t start_page, size_t size_in_pages);
121 
122   void pretouch(size_t start_page, size_t size_in_pages, WorkGang* pretouch_gang = NULL);
123 
124   // Initialize the given reserved space with the given base address and the size
125   // actually used.
126   // Prefer to commit in page_size chunks.
127   G1PageBasedVirtualSpace(ReservedSpace rs, size_t used_size, size_t page_size);
128 
129   // Destruction
130   ~G1PageBasedVirtualSpace();
131 
132   // Amount of reserved memory.
133   size_t reserved_size() const;
134   // Memory used in this virtual space.
135   size_t committed_size() const;
136   // Memory left to use/expand in this virtual space.
137   size_t uncommitted_size() const;
138 
139   void commit_and_set_special();
140 
141   bool contains(const void* p) const;
142 
143   MemRegion reserved() {
144     MemRegion x((HeapWord*)_low_boundary, reserved_size() / HeapWordSize);
145     return x;
146   }
147 
148   void check_for_contiguity() PRODUCT_RETURN;
149 
150   // Debugging
151   void print_on(outputStream* out) PRODUCT_RETURN;
152   void print();
153 };
154 
155 #endif // SHARE_GC_G1_G1PAGEBASEDVIRTUALSPACE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BlockOffsetTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1BLOCKOFFSETTABLE_HPP
 26 #define SHARE_GC_G1_G1BLOCKOFFSETTABLE_HPP
 27 
 28 #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
 29 #include &quot;gc/shared/blockOffsetTable.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;
 31 #include &quot;memory/virtualspace.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 
 34 // Forward declarations
 35 class G1BlockOffsetTable;
<span class="line-modified"> 36 class G1ContiguousSpace;</span>
 37 
 38 // This implementation of &quot;G1BlockOffsetTable&quot; divides the covered region
 39 // into &quot;N&quot;-word subregions (where &quot;N&quot; = 2^&quot;LogN&quot;.  An array with an entry
 40 // for each such subregion indicates how far back one must go to find the
 41 // start of the chunk that includes the first word of the subregion.
 42 //
<span class="line-modified"> 43 // Each G1BlockOffsetTablePart is owned by a G1ContiguousSpace.</span>
 44 
 45 class G1BlockOffsetTable: public CHeapObj&lt;mtGC&gt; {
 46   friend class G1BlockOffsetTablePart;
 47   friend class VMStructs;
 48 
 49 private:
 50   // The reserved region covered by the table.
 51   MemRegion _reserved;
 52 
 53   // Array for keeping offsets for retrieving object start fast given an
 54   // address.
<span class="line-modified"> 55   u_char* _offset_array;          // byte array keeping backwards offsets</span>
 56 
 57   void check_offset(size_t offset, const char* msg) const {
 58     assert(offset &lt;= BOTConstants::N_words,
 59            &quot;%s - offset: &quot; SIZE_FORMAT &quot;, N_words: %u&quot;,
 60            msg, offset, BOTConstants::N_words);
 61   }
 62 
 63   // Bounds checking accessors:
 64   // For performance these have to devolve to array accesses in product builds.
 65   inline u_char offset_array(size_t index) const;
 66 
<span class="line-modified"> 67   void set_offset_array_raw(size_t index, u_char offset) {</span>
<span class="line-removed"> 68     _offset_array[index] = offset;</span>
<span class="line-removed"> 69   }</span>
<span class="line-removed"> 70 </span>
 71   inline void set_offset_array(size_t index, u_char offset);
 72 
 73   inline void set_offset_array(size_t index, HeapWord* high, HeapWord* low);
 74 
 75   inline void set_offset_array(size_t left, size_t right, u_char offset);
 76 
 77   bool is_card_boundary(HeapWord* p) const;
 78 
 79   void check_index(size_t index, const char* msg) const NOT_DEBUG_RETURN;
 80 
 81 public:
 82 
 83   // Return the number of slots needed for an offset array
 84   // that covers mem_region_words words.
 85   static size_t compute_size(size_t mem_region_words) {
 86     size_t number_of_slots = (mem_region_words / BOTConstants::N_words);
 87     return ReservedSpace::allocation_align_size_up(number_of_slots);
 88   }
 89 
 90   // Returns how many bytes of the heap a single byte of the BOT corresponds to.
</pre>
<hr />
<pre>
106   // Variant of address_for_index that does not check the index for validity.
107   inline HeapWord* address_for_index_raw(size_t index) const {
108     return _reserved.start() + (index &lt;&lt; BOTConstants::LogN_words);
109   }
110 };
111 
112 class G1BlockOffsetTablePart {
113   friend class G1BlockOffsetTable;
114   friend class VMStructs;
115 private:
116   // allocation boundary at which offset array must be updated
117   HeapWord* _next_offset_threshold;
118   size_t    _next_offset_index;      // index corresponding to that boundary
119 
120   // Indicates if an object can span into this G1BlockOffsetTablePart.
121   debug_only(bool _object_can_span;)
122 
123   // This is the global BlockOffsetTable.
124   G1BlockOffsetTable* _bot;
125 
<span class="line-modified">126   // The space that owns this subregion.</span>
<span class="line-modified">127   G1ContiguousSpace* _space;</span>
128 
129   // Sets the entries
130   // corresponding to the cards starting at &quot;start&quot; and ending at &quot;end&quot;
131   // to point back to the card before &quot;start&quot;: the interval [start, end)
132   // is right-open.
133   void set_remainder_to_point_to_start(HeapWord* start, HeapWord* end);
134   // Same as above, except that the args here are a card _index_ interval
135   // that is closed: [start_index, end_index]
136   void set_remainder_to_point_to_start_incl(size_t start, size_t end);
137 
138   // Zero out the entry for _bottom (offset will be zero). Does not check for availability of the
139   // memory first.
140   void zero_bottom_entry_raw();
141   // Variant of initialize_threshold that does not check for availability of the
142   // memory first.
143   HeapWord* initialize_threshold_raw();
144 
145   inline size_t block_size(const HeapWord* p) const;
146 
147   // Returns the address of a block whose start is at most &quot;addr&quot;.
</pre>
<hr />
<pre>
169   // beginning of the block that contains &quot;addr&quot;.  May have side effects
170   // on &quot;this&quot;, by updating imprecise entries.
171   HeapWord* forward_to_block_containing_addr_slow(HeapWord* q,
172                                                   HeapWord* n,
173                                                   const void* addr);
174 
175   // Requires that &quot;*threshold_&quot; be the first array entry boundary at or
176   // above &quot;blk_start&quot;, and that &quot;*index_&quot; be the corresponding array
177   // index.  If the block starts at or crosses &quot;*threshold_&quot;, records
178   // &quot;blk_start&quot; as the appropriate block start for the array index
179   // starting at &quot;*threshold_&quot;, and for any other indices crossed by the
180   // block.  Updates &quot;*threshold_&quot; and &quot;*index_&quot; to correspond to the first
181   // index after the block end.
182   void alloc_block_work(HeapWord** threshold_, size_t* index_,
183                         HeapWord* blk_start, HeapWord* blk_end);
184 
185   void check_all_cards(size_t left_card, size_t right_card) const;
186 
187 public:
188   //  The elements of the array are initialized to zero.
<span class="line-modified">189   G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp);</span>
190 
191   void verify() const;
192 
193   // Returns the address of the start of the block containing &quot;addr&quot;, or
194   // else &quot;null&quot; if it is covered by no block.  (May have side effects,
195   // namely updating of shared array entries that &quot;point&quot; too far
196   // backwards.  This can occur, for example, when lab allocation is used
197   // in a space covered by the table.)
198   inline HeapWord* block_start(const void* addr);
199   // Same as above, but does not have any of the possible side effects
200   // discussed above.
201   inline HeapWord* block_start_const(const void* addr) const;
202 
203   // Initialize the threshold to reflect the first boundary after the
204   // bottom of the covered region.
205   HeapWord* initialize_threshold();
206 
207   void reset_bot() {
208     zero_bottom_entry_raw();
209     initialize_threshold_raw();
</pre>
</td>
<td>
<hr />
<pre>
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1BLOCKOFFSETTABLE_HPP
 26 #define SHARE_GC_G1_G1BLOCKOFFSETTABLE_HPP
 27 
 28 #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
 29 #include &quot;gc/shared/blockOffsetTable.hpp&quot;
 30 #include &quot;memory/memRegion.hpp&quot;
 31 #include &quot;memory/virtualspace.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 
 34 // Forward declarations
 35 class G1BlockOffsetTable;
<span class="line-modified"> 36 class HeapRegion;</span>
 37 
 38 // This implementation of &quot;G1BlockOffsetTable&quot; divides the covered region
 39 // into &quot;N&quot;-word subregions (where &quot;N&quot; = 2^&quot;LogN&quot;.  An array with an entry
 40 // for each such subregion indicates how far back one must go to find the
 41 // start of the chunk that includes the first word of the subregion.
 42 //
<span class="line-modified"> 43 // Each G1BlockOffsetTablePart is owned by a HeapRegion.</span>
 44 
 45 class G1BlockOffsetTable: public CHeapObj&lt;mtGC&gt; {
 46   friend class G1BlockOffsetTablePart;
 47   friend class VMStructs;
 48 
 49 private:
 50   // The reserved region covered by the table.
 51   MemRegion _reserved;
 52 
 53   // Array for keeping offsets for retrieving object start fast given an
 54   // address.
<span class="line-modified"> 55   volatile u_char* _offset_array;  // byte array keeping backwards offsets</span>
 56 
 57   void check_offset(size_t offset, const char* msg) const {
 58     assert(offset &lt;= BOTConstants::N_words,
 59            &quot;%s - offset: &quot; SIZE_FORMAT &quot;, N_words: %u&quot;,
 60            msg, offset, BOTConstants::N_words);
 61   }
 62 
 63   // Bounds checking accessors:
 64   // For performance these have to devolve to array accesses in product builds.
 65   inline u_char offset_array(size_t index) const;
 66 
<span class="line-modified"> 67   inline void set_offset_array_raw(size_t index, u_char offset);</span>



 68   inline void set_offset_array(size_t index, u_char offset);
 69 
 70   inline void set_offset_array(size_t index, HeapWord* high, HeapWord* low);
 71 
 72   inline void set_offset_array(size_t left, size_t right, u_char offset);
 73 
 74   bool is_card_boundary(HeapWord* p) const;
 75 
 76   void check_index(size_t index, const char* msg) const NOT_DEBUG_RETURN;
 77 
 78 public:
 79 
 80   // Return the number of slots needed for an offset array
 81   // that covers mem_region_words words.
 82   static size_t compute_size(size_t mem_region_words) {
 83     size_t number_of_slots = (mem_region_words / BOTConstants::N_words);
 84     return ReservedSpace::allocation_align_size_up(number_of_slots);
 85   }
 86 
 87   // Returns how many bytes of the heap a single byte of the BOT corresponds to.
</pre>
<hr />
<pre>
103   // Variant of address_for_index that does not check the index for validity.
104   inline HeapWord* address_for_index_raw(size_t index) const {
105     return _reserved.start() + (index &lt;&lt; BOTConstants::LogN_words);
106   }
107 };
108 
109 class G1BlockOffsetTablePart {
110   friend class G1BlockOffsetTable;
111   friend class VMStructs;
112 private:
113   // allocation boundary at which offset array must be updated
114   HeapWord* _next_offset_threshold;
115   size_t    _next_offset_index;      // index corresponding to that boundary
116 
117   // Indicates if an object can span into this G1BlockOffsetTablePart.
118   debug_only(bool _object_can_span;)
119 
120   // This is the global BlockOffsetTable.
121   G1BlockOffsetTable* _bot;
122 
<span class="line-modified">123   // The region that owns this subregion.</span>
<span class="line-modified">124   HeapRegion* _hr;</span>
125 
126   // Sets the entries
127   // corresponding to the cards starting at &quot;start&quot; and ending at &quot;end&quot;
128   // to point back to the card before &quot;start&quot;: the interval [start, end)
129   // is right-open.
130   void set_remainder_to_point_to_start(HeapWord* start, HeapWord* end);
131   // Same as above, except that the args here are a card _index_ interval
132   // that is closed: [start_index, end_index]
133   void set_remainder_to_point_to_start_incl(size_t start, size_t end);
134 
135   // Zero out the entry for _bottom (offset will be zero). Does not check for availability of the
136   // memory first.
137   void zero_bottom_entry_raw();
138   // Variant of initialize_threshold that does not check for availability of the
139   // memory first.
140   HeapWord* initialize_threshold_raw();
141 
142   inline size_t block_size(const HeapWord* p) const;
143 
144   // Returns the address of a block whose start is at most &quot;addr&quot;.
</pre>
<hr />
<pre>
166   // beginning of the block that contains &quot;addr&quot;.  May have side effects
167   // on &quot;this&quot;, by updating imprecise entries.
168   HeapWord* forward_to_block_containing_addr_slow(HeapWord* q,
169                                                   HeapWord* n,
170                                                   const void* addr);
171 
172   // Requires that &quot;*threshold_&quot; be the first array entry boundary at or
173   // above &quot;blk_start&quot;, and that &quot;*index_&quot; be the corresponding array
174   // index.  If the block starts at or crosses &quot;*threshold_&quot;, records
175   // &quot;blk_start&quot; as the appropriate block start for the array index
176   // starting at &quot;*threshold_&quot;, and for any other indices crossed by the
177   // block.  Updates &quot;*threshold_&quot; and &quot;*index_&quot; to correspond to the first
178   // index after the block end.
179   void alloc_block_work(HeapWord** threshold_, size_t* index_,
180                         HeapWord* blk_start, HeapWord* blk_end);
181 
182   void check_all_cards(size_t left_card, size_t right_card) const;
183 
184 public:
185   //  The elements of the array are initialized to zero.
<span class="line-modified">186   G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr);</span>
187 
188   void verify() const;
189 
190   // Returns the address of the start of the block containing &quot;addr&quot;, or
191   // else &quot;null&quot; if it is covered by no block.  (May have side effects,
192   // namely updating of shared array entries that &quot;point&quot; too far
193   // backwards.  This can occur, for example, when lab allocation is used
194   // in a space covered by the table.)
195   inline HeapWord* block_start(const void* addr);
196   // Same as above, but does not have any of the possible side effects
197   // discussed above.
198   inline HeapWord* block_start_const(const void* addr) const;
199 
200   // Initialize the threshold to reflect the first boundary after the
201   // bottom of the covered region.
202   HeapWord* initialize_threshold();
203 
204   void reset_bot() {
205     zero_bottom_entry_raw();
206     initialize_threshold_raw();
</pre>
</td>
</tr>
</table>
<center><a href="g1BlockOffsetTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
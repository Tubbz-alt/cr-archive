diff a/src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp b/src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp
--- a/src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp
+++ b/src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp
@@ -30,10 +30,11 @@
 #include "gc/g1/g1Policy.hpp"
 #include "gc/g1/g1YoungRemSetSamplingThread.hpp"
 #include "gc/g1/heapRegion.inline.hpp"
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/shared/suspendibleThreadSet.hpp"
+#include "memory/universe.hpp"
 #include "runtime/mutexLocker.hpp"
 
 G1YoungRemSetSamplingThread::G1YoungRemSetSamplingThread() :
     ConcurrentGCThread(),
     _monitor(Mutex::nonleaf,
@@ -45,14 +46,14 @@
   set_name("G1 Young RemSet Sampling");
   create_and_start();
 }
 
 void G1YoungRemSetSamplingThread::sleep_before_next_cycle() {
-  MutexLockerEx x(&_monitor, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);
   if (!should_terminate()) {
     uintx waitms = G1ConcRefinementServiceIntervalMillis;
-    _monitor.wait(Mutex::_no_safepoint_check_flag, waitms);
+    ml.wait(waitms);
   }
 }
 
 bool G1YoungRemSetSamplingThread::should_start_periodic_gc() {
   // If we are currently in a concurrent mark we are going to uncommit memory soon.
@@ -87,12 +88,11 @@
     return;
   }
   if ((os::elapsedTime() - _last_periodic_gc_attempt_s) > (G1PeriodicGCInterval / 1000.0)) {
     log_debug(gc, periodic)("Checking for periodic GC.");
     if (should_start_periodic_gc()) {
-      if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection,
-                                                    false /* retry_on_vmop_failure */)) {
+      if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {
         log_debug(gc, periodic)("GC request denied. Skipping.");
       }
     }
     _last_periodic_gc_attempt_s = os::elapsedTime();
   }
@@ -107,11 +107,11 @@
   } else {
     log_info(gc)("Periodic GC disabled");
   }
 
   while (!should_terminate()) {
-    sample_young_list_rs_lengths();
+    sample_young_list_rs_length();
 
     if (os::supports_vtime()) {
       _vtime_accum = (os::elapsedVTime() - vtime_start);
     } else {
       _vtime_accum = 0.0;
@@ -122,25 +122,25 @@
     sleep_before_next_cycle();
   }
 }
 
 void G1YoungRemSetSamplingThread::stop_service() {
-  MutexLockerEx x(&_monitor, Mutex::_no_safepoint_check_flag);
+  MutexLocker x(&_monitor, Mutex::_no_safepoint_check_flag);
   _monitor.notify();
 }
 
 class G1YoungRemSetSamplingClosure : public HeapRegionClosure {
   SuspendibleThreadSetJoiner* _sts;
   size_t _regions_visited;
-  size_t _sampled_rs_lengths;
+  size_t _sampled_rs_length;
 public:
   G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :
-    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_lengths(0) { }
+    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }
 
   virtual bool do_heap_region(HeapRegion* r) {
     size_t rs_length = r->rem_set()->occupied();
-    _sampled_rs_lengths += rs_length;
+    _sampled_rs_length += rs_length;
 
     // Update the collection set policy information for this region
     G1CollectedHeap::heap()->collection_set()->update_young_region_prediction(r, rs_length);
 
     _regions_visited++;
@@ -155,24 +155,24 @@
       _regions_visited = 0;
     }
     return false;
   }
 
-  size_t sampled_rs_lengths() const { return _sampled_rs_lengths; }
+  size_t sampled_rs_length() const { return _sampled_rs_length; }
 };
 
-void G1YoungRemSetSamplingThread::sample_young_list_rs_lengths() {
+void G1YoungRemSetSamplingThread::sample_young_list_rs_length() {
   SuspendibleThreadSetJoiner sts;
   G1CollectedHeap* g1h = G1CollectedHeap::heap();
   G1Policy* policy = g1h->policy();
 
-  if (policy->adaptive_young_list_length()) {
+  if (policy->use_adaptive_young_list_length()) {
     G1YoungRemSetSamplingClosure cl(&sts);
 
     G1CollectionSet* g1cs = g1h->collection_set();
     g1cs->iterate(&cl);
 
     if (cl.is_complete()) {
-      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_lengths());
+      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());
     }
   }
 }

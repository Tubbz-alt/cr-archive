<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/heapRegion.hpp&quot;
 29 #include &quot;gc/shared/space.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;services/memTracker.hpp&quot;
 34 
 35 
 36 
 37 //////////////////////////////////////////////////////////////////////
 38 // G1BlockOffsetTable
 39 //////////////////////////////////////////////////////////////////////
 40 
 41 G1BlockOffsetTable::G1BlockOffsetTable(MemRegion heap, G1RegionToSpaceMapper* storage) :
 42   _reserved(heap), _offset_array(NULL) {
 43 
 44   MemRegion bot_reserved = storage-&gt;reserved();
 45 
 46   _offset_array = (u_char*)bot_reserved.start();
 47 
 48   log_trace(gc, bot)(&quot;G1BlockOffsetTable::G1BlockOffsetTable: &quot;);
 49   log_trace(gc, bot)(&quot;    rs.base(): &quot; PTR_FORMAT &quot;  rs.size(): &quot; SIZE_FORMAT &quot;  rs end(): &quot; PTR_FORMAT,
 50                      p2i(bot_reserved.start()), bot_reserved.byte_size(), p2i(bot_reserved.end()));
 51 }
 52 
 53 bool G1BlockOffsetTable::is_card_boundary(HeapWord* p) const {
 54   assert(p &gt;= _reserved.start(), &quot;just checking&quot;);
 55   size_t delta = pointer_delta(p, _reserved.start());
 56   return (delta &amp; right_n_bits((int)BOTConstants::LogN_words)) == (size_t)NoBits;
 57 }
 58 
 59 #ifdef ASSERT
 60 void G1BlockOffsetTable::check_index(size_t index, const char* msg) const {
 61   assert((index) &lt; (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words),
 62          &quot;%s - index: &quot; SIZE_FORMAT &quot;, _vs.committed_size: &quot; SIZE_FORMAT,
 63          msg, (index), (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words));
 64   assert(G1CollectedHeap::heap()-&gt;is_in_exact(address_for_index_raw(index)),
 65          &quot;Index &quot; SIZE_FORMAT &quot; corresponding to &quot; PTR_FORMAT
 66          &quot; (%u) is not in committed area.&quot;,
 67          (index),
 68          p2i(address_for_index_raw(index)),
 69          G1CollectedHeap::heap()-&gt;addr_to_region(address_for_index_raw(index)));
 70 }
 71 #endif // ASSERT
 72 
 73 //////////////////////////////////////////////////////////////////////
 74 // G1BlockOffsetTablePart
 75 //////////////////////////////////////////////////////////////////////
 76 
 77 G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp) :
 78   _next_offset_threshold(NULL),
 79   _next_offset_index(0),
 80   DEBUG_ONLY(_object_can_span(false) COMMA)
 81   _bot(array),
 82   _space(gsp)
 83 {
 84 }
 85 
 86 // The arguments follow the normal convention of denoting
 87 // a right-open interval: [start, end)
 88 void G1BlockOffsetTablePart:: set_remainder_to_point_to_start(HeapWord* start, HeapWord* end) {
 89 
 90   if (start &gt;= end) {
 91     // The start address is equal to the end address (or to
 92     // the right of the end address) so there are not cards
 93     // that need to be updated..
 94     return;
 95   }
 96 
 97   // Write the backskip value for each region.
 98   //
 99   //    offset
100   //    card             2nd                       3rd
101   //     | +- 1st        |                         |
102   //     v v             v                         v
103   //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-
104   //    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...
105   //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-
106   //    11              19                        75
107   //      12
108   //
109   //    offset card is the card that points to the start of an object
110   //      x - offset value of offset card
111   //    1st - start of first logarithmic region
112   //      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1
113   //    2nd - start of second logarithmic region
114   //      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8
115   //    3rd - start of third logarithmic region
116   //      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64
117   //
118   //    integer below the block offset entry is an example of
119   //    the index of the entry
120   //
121   //    Given an address,
122   //      Find the index for the address
123   //      Find the block offset table entry
124   //      Convert the entry to a back slide
125   //        (e.g., with today&#39;s, offset = 0x81 =&gt;
126   //          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8
127   //      Move back N (e.g., 8) entries and repeat with the
128   //        value of the new entry
129   //
130   size_t start_card = _bot-&gt;index_for(start);
131   size_t end_card = _bot-&gt;index_for(end-1);
132   assert(start ==_bot-&gt;address_for_index(start_card), &quot;Precondition&quot;);
133   assert(end ==_bot-&gt;address_for_index(end_card)+BOTConstants::N_words, &quot;Precondition&quot;);
134   set_remainder_to_point_to_start_incl(start_card, end_card); // closed interval
135 }
136 
137 // Unlike the normal convention in this code, the argument here denotes
138 // a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()
139 // above.
140 void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
141   if (start_card &gt; end_card) {
142     return;
143   }
144   assert(start_card &gt; _bot-&gt;index_for(_space-&gt;bottom()), &quot;Cannot be first card&quot;);
145   assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
146          &quot;Offset card has an unexpected value&quot;);
147   size_t start_card_for_region = start_card;
148   u_char offset = max_jubyte;
149   for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
150     // -1 so that the the card with the actual offset is counted.  Another -1
151     // so that the reach ends in this region and not at the start
152     // of the next.
153     size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);
154     offset = BOTConstants::N_words + i;
155     if (reach &gt;= end_card) {
156       _bot-&gt;set_offset_array(start_card_for_region, end_card, offset);
157       start_card_for_region = reach + 1;
158       break;
159     }
160     _bot-&gt;set_offset_array(start_card_for_region, reach, offset);
161     start_card_for_region = reach + 1;
162   }
163   assert(start_card_for_region &gt; end_card, &quot;Sanity check&quot;);
164   DEBUG_ONLY(check_all_cards(start_card, end_card);)
165 }
166 
167 // The card-interval [start_card, end_card] is a closed interval; this
168 // is an expensive check -- use with care and only under protection of
169 // suitable flag.
170 void G1BlockOffsetTablePart::check_all_cards(size_t start_card, size_t end_card) const {
171 
172   if (end_card &lt; start_card) {
173     return;
174   }
175   guarantee(_bot-&gt;offset_array(start_card) == BOTConstants::N_words, &quot;Wrong value in second card&quot;);
176   for (size_t c = start_card + 1; c &lt;= end_card; c++ /* yeah! */) {
177     u_char entry = _bot-&gt;offset_array(c);
178     if (c - start_card &gt; BOTConstants::power_to_cards_back(1)) {
179       guarantee(entry &gt; BOTConstants::N_words,
180                 &quot;Should be in logarithmic region - &quot;
181                 &quot;entry: %u, &quot;
182                 &quot;_array-&gt;offset_array(c): %u, &quot;
183                 &quot;N_words: %u&quot;,
184                 (uint)entry, (uint)_bot-&gt;offset_array(c), BOTConstants::N_words);
185     }
186     size_t backskip = BOTConstants::entry_to_cards_back(entry);
187     size_t landing_card = c - backskip;
188     guarantee(landing_card &gt;= (start_card - 1), &quot;Inv&quot;);
189     if (landing_card &gt;= start_card) {
190       guarantee(_bot-&gt;offset_array(landing_card) &lt;= entry,
191                 &quot;Monotonicity - landing_card offset: %u, &quot;
192                 &quot;entry: %u&quot;,
193                 (uint)_bot-&gt;offset_array(landing_card), (uint)entry);
194     } else {
195       guarantee(landing_card == start_card - 1, &quot;Tautology&quot;);
196       // Note that N_words is the maximum offset value
197       guarantee(_bot-&gt;offset_array(landing_card) &lt;= BOTConstants::N_words,
198                 &quot;landing card offset: %u, &quot;
199                 &quot;N_words: %u&quot;,
200                 (uint)_bot-&gt;offset_array(landing_card), (uint)BOTConstants::N_words);
201     }
202   }
203 }
204 
205 HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_slow(HeapWord* q,
206                                                                         HeapWord* n,
207                                                                         const void* addr) {
208   // We&#39;re not in the normal case.  We need to handle an important subcase
209   // here: LAB allocation.  An allocation previously recorded in the
210   // offset table was actually a lab allocation, and was divided into
211   // several objects subsequently.  Fix this situation as we answer the
212   // query, by updating entries as we cross them.
213 
214   // If the fist object&#39;s end q is at the card boundary. Start refining
215   // with the corresponding card (the value of the entry will be basically
216   // set to 0). If the object crosses the boundary -- start from the next card.
217   size_t n_index = _bot-&gt;index_for(n);
218   size_t next_index = _bot-&gt;index_for(n) + !_bot-&gt;is_card_boundary(n);
219   // Calculate a consistent next boundary.  If &quot;n&quot; is not at the boundary
220   // already, step to the boundary.
221   HeapWord* next_boundary = _bot-&gt;address_for_index(n_index) +
222                             (n_index == next_index ? 0 : BOTConstants::N_words);
223   assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
224          &quot;next_boundary is beyond the end of the covered region &quot;
225          &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
226          p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
227   if (addr &gt;= _space-&gt;top()) return _space-&gt;top();
228   while (next_boundary &lt; addr) {
229     while (n &lt;= next_boundary) {
230       q = n;
231       oop obj = oop(q);
232       if (obj-&gt;klass_or_null_acquire() == NULL) return q;
233       n += block_size(q);
234     }
235     assert(q &lt;= next_boundary &amp;&amp; n &gt; next_boundary, &quot;Consequence of loop&quot;);
236     // [q, n) is the block that crosses the boundary.
237     alloc_block_work(&amp;next_boundary, &amp;next_index, q, n);
238   }
239   return forward_to_block_containing_addr_const(q, n, addr);
240 }
241 
242 //
243 //              threshold_
244 //              |   _index_
245 //              v   v
246 //      +-------+-------+-------+-------+-------+
247 //      | i-1   |   i   | i+1   | i+2   | i+3   |
248 //      +-------+-------+-------+-------+-------+
249 //       ( ^    ]
250 //         block-start
251 //
252 void G1BlockOffsetTablePart::alloc_block_work(HeapWord** threshold_, size_t* index_,
253                                               HeapWord* blk_start, HeapWord* blk_end) {
254   // For efficiency, do copy-in/copy-out.
255   HeapWord* threshold = *threshold_;
256   size_t    index = *index_;
257 
258   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
259          &quot;phantom block&quot;);
260   assert(blk_end &gt; threshold, &quot;should be past threshold&quot;);
261   assert(blk_start &lt;= threshold, &quot;blk_start should be at or before threshold&quot;);
262   assert(pointer_delta(threshold, blk_start) &lt;= BOTConstants::N_words,
263          &quot;offset should be &lt;= BlockOffsetSharedArray::N&quot;);
264   assert(G1CollectedHeap::heap()-&gt;is_in_reserved(blk_start),
265          &quot;reference must be into the heap&quot;);
266   assert(G1CollectedHeap::heap()-&gt;is_in_reserved(blk_end-1),
267          &quot;limit must be within the heap&quot;);
268   assert(threshold == _bot-&gt;_reserved.start() + index*BOTConstants::N_words,
269          &quot;index must agree with threshold&quot;);
270 
271   DEBUG_ONLY(size_t orig_index = index;)
272 
273   // Mark the card that holds the offset into the block.  Note
274   // that _next_offset_index and _next_offset_threshold are not
275   // updated until the end of this method.
276   _bot-&gt;set_offset_array(index, threshold, blk_start);
277 
278   // We need to now mark the subsequent cards that this blk spans.
279 
280   // Index of card on which blk ends.
281   size_t end_index   = _bot-&gt;index_for(blk_end - 1);
282 
283   // Are there more cards left to be updated?
284   if (index + 1 &lt;= end_index) {
285     HeapWord* rem_st  = _bot-&gt;address_for_index(index + 1);
286     // Calculate rem_end this way because end_index
287     // may be the last valid index in the covered region.
288     HeapWord* rem_end = _bot-&gt;address_for_index(end_index) + BOTConstants::N_words;
289     set_remainder_to_point_to_start(rem_st, rem_end);
290   }
291 
292   index = end_index + 1;
293   // Calculate threshold_ this way because end_index
294   // may be the last valid index in the covered region.
295   threshold = _bot-&gt;address_for_index(end_index) + BOTConstants::N_words;
296   assert(threshold &gt;= blk_end, &quot;Incorrect offset threshold&quot;);
297 
298   // index_ and threshold_ updated here.
299   *threshold_ = threshold;
300   *index_ = index;
301 
302 #ifdef ASSERT
303   // The offset can be 0 if the block starts on a boundary.  That
304   // is checked by an assertion above.
305   size_t start_index = _bot-&gt;index_for(blk_start);
306   HeapWord* boundary = _bot-&gt;address_for_index(start_index);
307   assert((_bot-&gt;offset_array(orig_index) == 0 &amp;&amp; blk_start == boundary) ||
308          (_bot-&gt;offset_array(orig_index) &gt; 0 &amp;&amp; _bot-&gt;offset_array(orig_index) &lt;= BOTConstants::N_words),
309          &quot;offset array should have been set - &quot;
310          &quot;orig_index offset: %u, &quot;
311          &quot;blk_start: &quot; PTR_FORMAT &quot;, &quot;
312          &quot;boundary: &quot; PTR_FORMAT,
313          (uint)_bot-&gt;offset_array(orig_index),
314          p2i(blk_start), p2i(boundary));
315   for (size_t j = orig_index + 1; j &lt;= end_index; j++) {
316     assert(_bot-&gt;offset_array(j) &gt; 0 &amp;&amp;
317            _bot-&gt;offset_array(j) &lt;=
318              (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
319            &quot;offset array should have been set - &quot;
320            &quot;%u not &gt; 0 OR %u not &lt;= %u&quot;,
321            (uint) _bot-&gt;offset_array(j),
322            (uint) _bot-&gt;offset_array(j),
323            (uint) (BOTConstants::N_words+BOTConstants::N_powers-1));
324   }
325 #endif
326 }
327 
328 void G1BlockOffsetTablePart::verify() const {
329   assert(_space-&gt;bottom() &lt; _space-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);
330   size_t start_card = _bot-&gt;index_for(_space-&gt;bottom());
331   size_t end_card = _bot-&gt;index_for(_space-&gt;top() - 1);
332 
333   for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
334     u_char entry = _bot-&gt;offset_array(current_card);
335     if (entry &lt; BOTConstants::N_words) {
336       // The entry should point to an object before the current card. Verify that
337       // it is possible to walk from that object in to the current card by just
338       // iterating over the objects following it.
339       HeapWord* card_address = _bot-&gt;address_for_index(current_card);
340       HeapWord* obj_end = card_address - entry;
341       while (obj_end &lt; card_address) {
342         HeapWord* obj = obj_end;
343         size_t obj_size = block_size(obj);
344         obj_end = obj + obj_size;
345         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _space-&gt;top(),
346                   &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
347                   p2i(obj), obj_size, p2i(obj_end), p2i(_space-&gt;top()));
348       }
349     } else {
350       // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
351       // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
352       // corresponding heap region. But that is about all we can verify.
353       size_t backskip = BOTConstants::entry_to_cards_back(entry);
354       guarantee(backskip &gt;= 1, &quot;Must be going back at least one card.&quot;);
355 
356       size_t max_backskip = current_card - start_card;
357       guarantee(backskip &lt;= max_backskip,
358                 &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
359                 start_card, current_card, backskip);
360 
361       HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
362       guarantee(backskip_address &gt;= _space-&gt;bottom(),
363                 &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
364                 p2i(_space-&gt;bottom()), p2i(backskip_address));
365     }
366   }
367 }
368 
369 #ifdef ASSERT
370 void G1BlockOffsetTablePart::set_object_can_span(bool can_span) {
371   _object_can_span = can_span;
372 }
373 #endif
374 
375 #ifndef PRODUCT
376 void
377 G1BlockOffsetTablePart::print_on(outputStream* out) {
378   size_t from_index = _bot-&gt;index_for(_space-&gt;bottom());
379   size_t to_index = _bot-&gt;index_for(_space-&gt;end());
380   out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
381                 &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
382                 p2i(_space-&gt;bottom()), p2i(_space-&gt;end()), from_index, to_index);
383   for (size_t i = from_index; i &lt; to_index; ++i) {
384     out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
385                   i, p2i(_bot-&gt;address_for_index(i)),
386                   (uint) _bot-&gt;offset_array(i));
387   }
388   out-&gt;print_cr(&quot;  next offset threshold: &quot; PTR_FORMAT, p2i(_next_offset_threshold));
389   out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
390 }
391 #endif // !PRODUCT
392 
393 HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
394   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),
395          &quot;just checking&quot;);
396   _next_offset_index = _bot-&gt;index_for_raw(_space-&gt;bottom());
397   _next_offset_index++;
398   _next_offset_threshold =
399     _bot-&gt;address_for_index_raw(_next_offset_index);
400   return _next_offset_threshold;
401 }
402 
403 void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
404   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),
405          &quot;just checking&quot;);
406   size_t bottom_index = _bot-&gt;index_for_raw(_space-&gt;bottom());
407   assert(_bot-&gt;address_for_index_raw(bottom_index) == _space-&gt;bottom(),
408          &quot;Precondition of call&quot;);
409   _bot-&gt;set_offset_array_raw(bottom_index, 0);
410 }
411 
412 HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
413   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),
414          &quot;just checking&quot;);
415   _next_offset_index = _bot-&gt;index_for(_space-&gt;bottom());
416   _next_offset_index++;
417   _next_offset_threshold =
418     _bot-&gt;address_for_index(_next_offset_index);
419   return _next_offset_threshold;
420 }
421 
422 void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
423   // The first BOT entry should have offset 0.
424   reset_bot();
425   alloc_block(_space-&gt;bottom(), obj_top);
426   if (fill_size &gt; 0) {
427     alloc_block(obj_top, fill_size);
428   }
429 }
    </pre>
  </body>
</html>
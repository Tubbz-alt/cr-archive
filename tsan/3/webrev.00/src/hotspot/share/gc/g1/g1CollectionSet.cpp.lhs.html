<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1CollectionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;
<a name="1" id="anc1"></a>
 30 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 33 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 34 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
<a name="2" id="anc2"></a>
 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/globalDefinitions.hpp&quot;
 38 #include &quot;utilities/quickSort.hpp&quot;
 39 
<a name="3" id="anc3"></a><span class="line-modified"> 40 G1CollectorState* G1CollectionSet::collector_state() {</span>
 41   return _g1h-&gt;collector_state();
 42 }
 43 
 44 G1GCPhaseTimes* G1CollectionSet::phase_times() {
 45   return _policy-&gt;phase_times();
 46 }
 47 
<a name="4" id="anc4"></a><span class="line-modified"> 48 double G1CollectionSet::predict_region_elapsed_time_ms(HeapRegion* hr) {</span>
<span class="line-modified"> 49   return _policy-&gt;predict_region_elapsed_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
 50 }
 51 
 52 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
 53   _g1h(g1h),
 54   _policy(policy),
 55   _candidates(NULL),
 56   _eden_region_length(0),
 57   _survivor_region_length(0),
 58   _old_region_length(0),
 59   _collection_set_regions(NULL),
 60   _collection_set_cur_length(0),
 61   _collection_set_max_length(0),
<a name="5" id="anc5"></a><span class="line-modified"> 62   _optional_regions(NULL),</span>
<span class="line-removed"> 63   _optional_region_length(0),</span>
<span class="line-removed"> 64   _optional_region_max_length(0),</span>
 65   _bytes_used_before(0),
<a name="6" id="anc6"></a><span class="line-modified"> 66   _recorded_rs_lengths(0),</span>
 67   _inc_build_state(Inactive),
<a name="7" id="anc7"></a>

 68   _inc_bytes_used_before(0),
<a name="8" id="anc8"></a><span class="line-modified"> 69   _inc_recorded_rs_lengths(0),</span>
<span class="line-modified"> 70   _inc_recorded_rs_lengths_diffs(0),</span>
<span class="line-modified"> 71   _inc_predicted_elapsed_time_ms(0.0),</span>
<span class="line-modified"> 72   _inc_predicted_elapsed_time_ms_diffs(0.0) {</span>
 73 }
 74 
 75 G1CollectionSet::~G1CollectionSet() {
<a name="9" id="anc9"></a><span class="line-modified"> 76   if (_collection_set_regions != NULL) {</span>
<span class="line-modified"> 77     FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-removed"> 78   }</span>
 79   free_optional_regions();
 80   clear_candidates();
 81 }
 82 
 83 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
 84                                           uint survivor_cset_region_length) {
 85   assert_at_safepoint_on_vm_thread();
 86 
 87   _eden_region_length     = eden_cset_region_length;
 88   _survivor_region_length = survivor_cset_region_length;
 89 
 90   assert((size_t) young_region_length() == _collection_set_cur_length,
 91          &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 92 
<a name="10" id="anc10"></a><span class="line-modified"> 93   _old_region_length      = 0;</span>
<span class="line-modified"> 94   _optional_region_length = 0;</span>
 95 }
 96 
 97 void G1CollectionSet::initialize(uint max_region_length) {
 98   guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
 99   _collection_set_max_length = max_region_length;
100   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<a name="11" id="anc11"></a><span class="line-modified">101 }</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 void G1CollectionSet::initialize_optional(uint max_length) {</span>
<span class="line-removed">104   assert(_optional_regions == NULL, &quot;Already initialized&quot;);</span>
<span class="line-removed">105   assert(_optional_region_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">106   assert(_optional_region_max_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">107   _optional_region_max_length = max_length;</span>
<span class="line-removed">108   _optional_regions = NEW_C_HEAP_ARRAY(HeapRegion*, _optional_region_max_length, mtGC);</span>
109 }
110 
111 void G1CollectionSet::free_optional_regions() {
<a name="12" id="anc12"></a><span class="line-modified">112   _optional_region_length = 0;</span>
<span class="line-removed">113   _optional_region_max_length = 0;</span>
<span class="line-removed">114   if (_optional_regions != NULL) {</span>
<span class="line-removed">115     FREE_C_HEAP_ARRAY(HeapRegion*, _optional_regions);</span>
<span class="line-removed">116     _optional_regions = NULL;</span>
<span class="line-removed">117   }</span>
118 }
119 
120 void G1CollectionSet::clear_candidates() {
121   delete _candidates;
122   _candidates = NULL;
123 }
124 
<a name="13" id="anc13"></a><span class="line-modified">125 void G1CollectionSet::set_recorded_rs_lengths(size_t rs_lengths) {</span>
<span class="line-modified">126   _recorded_rs_lengths = rs_lengths;</span>
127 }
128 
129 // Add the heap region at the head of the non-incremental collection set
130 void G1CollectionSet::add_old_region(HeapRegion* hr) {
131   assert_at_safepoint_on_vm_thread();
132 
<a name="14" id="anc14"></a><span class="line-modified">133   assert(_inc_build_state == Active || hr-&gt;index_in_opt_cset() != G1OptionalCSet::InvalidCSetIndex,</span>
134          &quot;Precondition, actively building cset or adding optional later on&quot;);
135   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
136 
<a name="15" id="anc15"></a><span class="line-modified">137   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);</span>
<span class="line-modified">138   _g1h-&gt;register_old_region_with_cset(hr);</span>
139 
140   _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
141   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
142 
143   _bytes_used_before += hr-&gt;used();
<a name="16" id="anc16"></a><span class="line-modified">144   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">145   _recorded_rs_lengths += rs_length;</span>
<span class="line-removed">146   _old_region_length += 1;</span>
147 
<a name="17" id="anc17"></a><span class="line-modified">148   log_trace(gc, cset)(&quot;Added old region %d to collection set&quot;, hr-&gt;hrm_index());</span>
149 }
150 
151 void G1CollectionSet::add_optional_region(HeapRegion* hr) {
<a name="18" id="anc18"></a><span class="line-removed">152   assert(!optional_is_full(), &quot;Precondition, must have room left for this region&quot;);</span>
153   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
154   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
155 
<a name="19" id="anc19"></a><span class="line-modified">156   _g1h-&gt;register_optional_region_with_cset(hr);</span>
157 
<a name="20" id="anc20"></a><span class="line-modified">158   _optional_regions[_optional_region_length] = hr;</span>
<span class="line-removed">159   uint index = _optional_region_length++;</span>
<span class="line-removed">160   hr-&gt;set_index_in_opt_cset(index);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   log_trace(gc, cset)(&quot;Added region %d to optional collection set (%u)&quot;, hr-&gt;hrm_index(), _optional_region_length);</span>
163 }
164 
<a name="21" id="anc21"></a><span class="line-removed">165 // Initialize the per-collection-set information</span>
166 void G1CollectionSet::start_incremental_building() {
167   assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
168   assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
<a name="22" id="anc22"></a>




169 
170   _inc_bytes_used_before = 0;
171 
<a name="23" id="anc23"></a><span class="line-modified">172   _inc_recorded_rs_lengths = 0;</span>
<span class="line-modified">173   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">174   _inc_predicted_elapsed_time_ms = 0.0;</span>
<span class="line-modified">175   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
<span class="line-modified">176   _inc_build_state = Active;</span>

177 }
178 
179 void G1CollectionSet::finalize_incremental_building() {
180   assert(_inc_build_state == Active, &quot;Precondition&quot;);
181   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
182 
<a name="24" id="anc24"></a><span class="line-modified">183   // The two &quot;main&quot; fields, _inc_recorded_rs_lengths and</span>
<span class="line-modified">184   // _inc_predicted_elapsed_time_ms, are updated by the thread</span>
185   // that adds a new region to the CSet. Further updates by the
186   // concurrent refinement thread that samples the young RSet lengths
<a name="25" id="anc25"></a><span class="line-modified">187   // are accumulated in the *_diffs fields. Here we add the diffs to</span>
188   // the &quot;main&quot; fields.
189 
<a name="26" id="anc26"></a><span class="line-modified">190   if (_inc_recorded_rs_lengths_diffs &gt;= 0) {</span>
<span class="line-modified">191     _inc_recorded_rs_lengths += _inc_recorded_rs_lengths_diffs;</span>
<span class="line-removed">192   } else {</span>
<span class="line-removed">193     // This is defensive. The diff should in theory be always positive</span>
<span class="line-removed">194     // as RSets can only grow between GCs. However, given that we</span>
<span class="line-removed">195     // sample their size concurrently with other threads updating them</span>
<span class="line-removed">196     // it&#39;s possible that we might get the wrong size back, which</span>
<span class="line-removed">197     // could make the calculations somewhat inaccurate.</span>
<span class="line-removed">198     size_t diffs = (size_t) (-_inc_recorded_rs_lengths_diffs);</span>
<span class="line-removed">199     if (_inc_recorded_rs_lengths &gt;= diffs) {</span>
<span class="line-removed">200       _inc_recorded_rs_lengths -= diffs;</span>
<span class="line-removed">201     } else {</span>
<span class="line-removed">202       _inc_recorded_rs_lengths = 0;</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204   }</span>
<span class="line-removed">205   _inc_predicted_elapsed_time_ms += _inc_predicted_elapsed_time_ms_diffs;</span>
206 
<a name="27" id="anc27"></a><span class="line-modified">207   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">208   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
209 }
210 
211 void G1CollectionSet::clear() {
212   assert_at_safepoint_on_vm_thread();
213   _collection_set_cur_length = 0;
<a name="28" id="anc28"></a><span class="line-removed">214   _optional_region_length = 0;</span>
215 }
216 
217 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
<a name="29" id="anc29"></a><span class="line-removed">218   iterate_from(cl, 0, 1);</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221 void G1CollectionSet::iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const {</span>
222   size_t len = _collection_set_cur_length;
223   OrderAccess::loadload();
<a name="30" id="anc30"></a><span class="line-removed">224   if (len == 0) {</span>
<span class="line-removed">225     return;</span>
<span class="line-removed">226   }</span>
<span class="line-removed">227   size_t start_pos = (worker_id * len) / total_workers;</span>
<span class="line-removed">228   size_t cur_pos = start_pos;</span>
229 
<a name="31" id="anc31"></a><span class="line-modified">230   do {</span>
<span class="line-modified">231     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[cur_pos]);</span>
232     bool result = cl-&gt;do_heap_region(r);
233     if (result) {
234       cl-&gt;set_incomplete();
235       return;
236     }
<a name="32" id="anc32"></a>
















































237     cur_pos++;
<a name="33" id="anc33"></a><span class="line-modified">238     if (cur_pos == len) {</span>
239       cur_pos = 0;
240     }
241   } while (cur_pos != start_pos);
242 }
243 
244 void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,
245                                                      size_t new_rs_length) {
246   // Update the CSet information that is dependent on the new RS length
247   assert(hr-&gt;is_young(), &quot;Precondition&quot;);
248   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
249 
<a name="34" id="anc34"></a><span class="line-modified">250   // We could have updated _inc_recorded_rs_lengths and</span>
<span class="line-removed">251   // _inc_predicted_elapsed_time_ms directly but we&#39;d need to do</span>
<span class="line-removed">252   // that atomically, as this code is executed by a concurrent</span>
<span class="line-removed">253   // refinement thread, potentially concurrently with a mutator thread</span>
<span class="line-removed">254   // allocating a new region and also updating the same fields. To</span>
<span class="line-removed">255   // avoid the atomic operations we accumulate these updates on two</span>
<span class="line-removed">256   // separate fields (*_diffs) and we&#39;ll just add them to the &quot;main&quot;</span>
<span class="line-removed">257   // fields at the start of a GC.</span>
258 
<a name="35" id="anc35"></a><span class="line-modified">259   ssize_t old_rs_length = (ssize_t) hr-&gt;recorded_rs_length();</span>
<span class="line-modified">260   ssize_t rs_lengths_diff = (ssize_t) new_rs_length - old_rs_length;</span>
<span class="line-modified">261   _inc_recorded_rs_lengths_diffs += rs_lengths_diff;</span>




262 
<a name="36" id="anc36"></a><span class="line-modified">263   double old_elapsed_time_ms = hr-&gt;predicted_elapsed_time_ms();</span>
<span class="line-modified">264   double new_region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">265   double elapsed_ms_diff = new_region_elapsed_time_ms - old_elapsed_time_ms;</span>
<span class="line-modified">266   _inc_predicted_elapsed_time_ms_diffs += elapsed_ms_diff;</span>
267 
<a name="37" id="anc37"></a><span class="line-modified">268   hr-&gt;set_recorded_rs_length(new_rs_length);</span>
<span class="line-modified">269   hr-&gt;set_predicted_elapsed_time_ms(new_region_elapsed_time_ms);</span>
270 }
271 
272 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
273   assert(hr-&gt;is_young(), &quot;invariant&quot;);
274   assert(_inc_build_state == Active, &quot;Precondition&quot;);
275 
<a name="38" id="anc38"></a><span class="line-removed">276   size_t collection_set_length = _collection_set_cur_length;</span>
<span class="line-removed">277   assert(collection_set_length &lt;= INT_MAX, &quot;Collection set is too large with %d entries&quot;, (int)collection_set_length);</span>
<span class="line-removed">278   hr-&gt;set_young_index_in_cset((int)collection_set_length);</span>
<span class="line-removed">279 </span>
<span class="line-removed">280   _collection_set_regions[collection_set_length] = hr-&gt;hrm_index();</span>
<span class="line-removed">281   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-removed">282   // update to the length field.</span>
<span class="line-removed">283   OrderAccess::storestore();</span>
<span class="line-removed">284   _collection_set_cur_length++;</span>
<span class="line-removed">285   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
<span class="line-removed">286 </span>
287   // This routine is used when:
288   // * adding survivor regions to the incremental cset at the end of an
289   //   evacuation pause or
290   // * adding the current allocation region to the incremental cset
291   //   when it is retired.
292   // Therefore this routine may be called at a safepoint by the
293   // VM thread, or in-between safepoints by mutator threads (when
294   // retiring the current allocation region)
295   // We need to clear and set the cached recorded/cached collection set
296   // information in the heap region here (before the region gets added
297   // to the collection set). An individual heap region&#39;s cached values
298   // are calculated, aggregated with the policy collection set info,
299   // and cached in the heap region here (initially) and (subsequently)
300   // by the Young List sampling code.
301   // Ignore calls to this due to retirement during full gc.
302 
303   if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
304     size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<a name="39" id="anc39"></a><span class="line-modified">305     double region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
306 
307     // Cache the values we have added to the aggregated information
308     // in the heap region in case we have to remove this region from
309     // the incremental collection set, or it is updated by the
310     // rset sampling code
<a name="40" id="anc40"></a><span class="line-removed">311     hr-&gt;set_recorded_rs_length(rs_length);</span>
<span class="line-removed">312     hr-&gt;set_predicted_elapsed_time_ms(region_elapsed_time_ms);</span>
313 
<a name="41" id="anc41"></a><span class="line-modified">314     _inc_recorded_rs_lengths += rs_length;</span>
<span class="line-modified">315     _inc_predicted_elapsed_time_ms += region_elapsed_time_ms;</span>




316     _inc_bytes_used_before += hr-&gt;used();
317   }
318 
319   assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<a name="42" id="anc42"></a><span class="line-modified">320   _g1h-&gt;register_young_region_with_cset(hr);</span>












321 }
322 
323 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
324   assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
325   add_young_region_common(hr);
326 }
327 
328 void G1CollectionSet::add_eden_region(HeapRegion* hr) {
329   assert(hr-&gt;is_eden(), &quot;Must only add eden regions, but is %s&quot;, hr-&gt;get_type_str());
330   add_young_region_common(hr);
331 }
332 
333 #ifndef PRODUCT
334 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
335 public:
336   bool _valid;
<a name="43" id="anc43"></a><span class="line-modified">337 public:</span>
338   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
339 
340   virtual bool do_heap_region(HeapRegion* r) {
341     guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
342 
<a name="44" id="anc44"></a><span class="line-modified">343     SurvRateGroup* group = r-&gt;surv_rate_group();</span>
<span class="line-modified">344 </span>
<span class="line-removed">345     if (group == NULL) {</span>
<span class="line-removed">346       log_error(gc, verify)(&quot;## encountered NULL surv_rate_group in young region&quot;);</span>
347       _valid = false;
348     }
349 
<a name="45" id="anc45"></a><span class="line-modified">350     if (r-&gt;age_in_surv_rate_group() &lt; 0) {</span>
<span class="line-modified">351       log_error(gc, verify)(&quot;## encountered negative age in young region&quot;);</span>
352       _valid = false;
353     }
354 
355     return false;
356   }
357 
358   bool valid() const { return _valid; }
359 };
360 
361 bool G1CollectionSet::verify_young_ages() {
362   assert_at_safepoint_on_vm_thread();
363 
364   G1VerifyYoungAgesClosure cl;
365   iterate(&amp;cl);
366 
367   if (!cl.valid()) {
368     LogStreamHandle(Error, gc, verify) log;
369     print(&amp;log);
370   }
371 
372   return cl.valid();
373 }
374 
375 class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {
376   outputStream* _st;
377 public:
378   G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }
379 
380   virtual bool do_heap_region(HeapRegion* r) {
381     assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
382     _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
383                   HR_FORMAT_PARAMS(r),
384                   p2i(r-&gt;prev_top_at_mark_start()),
385                   p2i(r-&gt;next_top_at_mark_start()),
<a name="46" id="anc46"></a><span class="line-modified">386                   r-&gt;age_in_surv_rate_group_cond());</span>
387     return false;
388   }
389 };
390 
391 void G1CollectionSet::print(outputStream* st) {
392   st-&gt;print_cr(&quot;\nCollection_set:&quot;);
393 
394   G1PrintCollectionSetDetailClosure cl(st);
395   iterate(&amp;cl);
396 }
397 #endif // !PRODUCT
398 
399 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<a name="47" id="anc47"></a><span class="line-modified">400   double young_start_time_sec = os::elapsedTime();</span>
401 
402   finalize_incremental_building();
403 
404   guarantee(target_pause_time_ms &gt; 0.0,
405             &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
406 
<a name="48" id="anc48"></a><span class="line-modified">407   size_t pending_cards = _policy-&gt;pending_cards();</span>
<span class="line-removed">408   double base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-removed">409   double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);</span>
410 
<a name="49" id="anc49"></a><span class="line-modified">411   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. pending cards: &quot; SIZE_FORMAT &quot; predicted base time: %1.2fms remaining time: %1.2fms target pause time: %1.2fms&quot;,</span>
<span class="line-modified">412                             pending_cards, base_time_ms, time_remaining_ms, target_pause_time_ms);</span>
413 
414   // The young list is laid with the survivor regions from the previous
415   // pause are appended to the RHS of the young list, i.e.
416   //   [Newly Young Regions ++ Survivors from last pause].
417 
<a name="50" id="anc50"></a><span class="line-removed">418   uint survivor_region_length = survivors-&gt;length();</span>
419   uint eden_region_length = _g1h-&gt;eden_regions_count();
<a name="51" id="anc51"></a>
420   init_region_lengths(eden_region_length, survivor_region_length);
421 
422   verify_young_cset_indices();
423 
424   // Clear the fields that point to the survivor list - they are all young now.
425   survivors-&gt;convert_to_eden();
426 
427   _bytes_used_before = _inc_bytes_used_before;
<a name="52" id="anc52"></a><span class="line-removed">428   time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);</span>
<span class="line-removed">429 </span>
<span class="line-removed">430   log_trace(gc, ergo, cset)(&quot;Add young regions to CSet. eden: %u regions, survivors: %u regions, predicted young region time: %1.2fms, target pause time: %1.2fms&quot;,</span>
<span class="line-removed">431                             eden_region_length, survivor_region_length, _inc_predicted_elapsed_time_ms, target_pause_time_ms);</span>
432 
433   // The number of recorded young regions is the incremental
434   // collection set&#39;s current size
<a name="53" id="anc53"></a><span class="line-modified">435   set_recorded_rs_lengths(_inc_recorded_rs_lengths);</span>
<span class="line-removed">436 </span>
<span class="line-removed">437   double young_end_time_sec = os::elapsedTime();</span>
<span class="line-removed">438   phase_times()-&gt;record_young_cset_choice_time_ms((young_end_time_sec - young_start_time_sec) * 1000.0);</span>
<span class="line-removed">439 </span>
<span class="line-removed">440   return time_remaining_ms;</span>
<span class="line-removed">441 }</span>
442 
<a name="54" id="anc54"></a><span class="line-modified">443 void G1CollectionSet::add_as_old(HeapRegion* hr) {</span>
<span class="line-modified">444   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">445   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">446   add_old_region(hr);</span>
<span class="line-removed">447 }</span>
448 
<a name="55" id="anc55"></a><span class="line-modified">449 void G1CollectionSet::add_as_optional(HeapRegion* hr) {</span>
<span class="line-modified">450   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-modified">451   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">452   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">453   add_optional_region(hr);</span>
<span class="line-removed">454 }</span>
455 
<a name="56" id="anc56"></a><span class="line-modified">456 bool G1CollectionSet::optional_is_full() {</span>
<span class="line-removed">457   assert(_optional_region_length &lt;= _optional_region_max_length, &quot;Invariant&quot;);</span>
<span class="line-removed">458   return _optional_region_length == _optional_region_max_length;</span>
<span class="line-removed">459 }</span>
460 
<a name="57" id="anc57"></a><span class="line-modified">461 void G1CollectionSet::clear_optional_region(const HeapRegion* hr) {</span>
<span class="line-removed">462   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-removed">463   uint index = hr-&gt;index_in_opt_cset();</span>
<span class="line-removed">464   _optional_regions[index] = NULL;</span>
465 }
466 
467 static int compare_region_idx(const uint a, const uint b) {
468   if (a &gt; b) {
469     return 1;
470   } else if (a == b) {
471     return 0;
472   } else {
473     return -1;
474   }
475 }
476 
477 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
478   double non_young_start_time_sec = os::elapsedTime();
<a name="58" id="anc58"></a><span class="line-removed">479   double predicted_old_time_ms = 0.0;</span>
<span class="line-removed">480   double predicted_optional_time_ms = 0.0;</span>
<span class="line-removed">481   double optional_threshold_ms = time_remaining_ms * _policy-&gt;optional_prediction_fraction();</span>
<span class="line-removed">482   uint expensive_region_num = 0;</span>
483 
484   if (collector_state()-&gt;in_mixed_phase()) {
485     candidates()-&gt;verify();
<a name="59" id="anc59"></a><span class="line-modified">486     const uint min_old_cset_length = _policy-&gt;calc_min_old_cset_length();</span>
<span class="line-modified">487     const uint max_old_cset_length = MAX2(min_old_cset_length, _policy-&gt;calc_max_old_cset_length());</span>
<span class="line-modified">488     bool check_time_remaining = _policy-&gt;adaptive_young_list_length();</span>
<span class="line-modified">489 </span>
<span class="line-modified">490     initialize_optional(max_old_cset_length - min_old_cset_length);</span>
<span class="line-modified">491     log_debug(gc, ergo, cset)(&quot;Start adding old regions for mixed gc. min %u regions, max %u regions, &quot;</span>
<span class="line-modified">492                               &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,</span>
<span class="line-modified">493                               min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);</span>
<span class="line-modified">494 </span>
<span class="line-modified">495     HeapRegion* hr = candidates()-&gt;peek_front();</span>
<span class="line-modified">496     while (hr != NULL) {</span>
<span class="line-modified">497       if (old_region_length() + optional_region_length() &gt;= max_old_cset_length) {</span>
<span class="line-modified">498         // Added maximum number of old regions to the CSet.</span>
<span class="line-modified">499         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached max). &quot;</span>
<span class="line-modified">500                                   &quot;old %u regions, optional %u regions&quot;,</span>
<span class="line-modified">501                                   old_region_length(), optional_region_length());</span>
<span class="line-removed">502         break;</span>
<span class="line-removed">503       }</span>
<span class="line-removed">504 </span>
<span class="line-removed">505       // Stop adding regions if the remaining reclaimable space is</span>
<span class="line-removed">506       // not above G1HeapWastePercent.</span>
<span class="line-removed">507       size_t reclaimable_bytes = candidates()-&gt;remaining_reclaimable_bytes();</span>
<span class="line-removed">508       double reclaimable_percent = _policy-&gt;reclaimable_bytes_percent(reclaimable_bytes);</span>
<span class="line-removed">509       double threshold = (double) G1HeapWastePercent;</span>
<span class="line-removed">510       if (reclaimable_percent &lt;= threshold) {</span>
<span class="line-removed">511         // We&#39;ve added enough old regions that the amount of uncollected</span>
<span class="line-removed">512         // reclaimable space is at or below the waste threshold. Stop</span>
<span class="line-removed">513         // adding old regions to the CSet.</span>
<span class="line-removed">514         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (reclaimable percentage not over threshold). &quot;</span>
<span class="line-removed">515                                   &quot;reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,</span>
<span class="line-removed">516                                   byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),</span>
<span class="line-removed">517                                   reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-removed">518         break;</span>
<span class="line-removed">519       }</span>
<span class="line-removed">520 </span>
<span class="line-removed">521       double predicted_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-removed">522       time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);</span>
<span class="line-removed">523       // Add regions to old set until we reach minimum amount</span>
<span class="line-removed">524       if (old_region_length() &lt; min_old_cset_length) {</span>
<span class="line-removed">525         predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">526         add_as_old(hr);</span>
<span class="line-removed">527         // Record the number of regions added when no time remaining</span>
<span class="line-removed">528         if (time_remaining_ms == 0.0) {</span>
<span class="line-removed">529           expensive_region_num++;</span>
<span class="line-removed">530         }</span>
<span class="line-removed">531       } else {</span>
<span class="line-removed">532         // In the non-auto-tuning case, we&#39;ll finish adding regions</span>
<span class="line-removed">533         // to the CSet if we reach the minimum.</span>
<span class="line-removed">534         if (!check_time_remaining) {</span>
<span class="line-removed">535           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached min).&quot;);</span>
<span class="line-removed">536           break;</span>
<span class="line-removed">537         }</span>
<span class="line-removed">538         // Keep adding regions to old set until we reach optional threshold</span>
<span class="line-removed">539         if (time_remaining_ms &gt; optional_threshold_ms) {</span>
<span class="line-removed">540           predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">541           add_as_old(hr);</span>
<span class="line-removed">542         } else if (time_remaining_ms &gt; 0) {</span>
<span class="line-removed">543           // Keep adding optional regions until time is up</span>
<span class="line-removed">544           if (!optional_is_full()) {</span>
<span class="line-removed">545             predicted_optional_time_ms += predicted_time_ms;</span>
<span class="line-removed">546             add_as_optional(hr);</span>
<span class="line-removed">547           } else {</span>
<span class="line-removed">548             log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (optional set full).&quot;);</span>
<span class="line-removed">549             break;</span>
<span class="line-removed">550           }</span>
<span class="line-removed">551         } else {</span>
<span class="line-removed">552           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (predicted time is too high).&quot;);</span>
<span class="line-removed">553           break;</span>
<span class="line-removed">554         }</span>
<span class="line-removed">555       }</span>
<span class="line-removed">556       hr = candidates()-&gt;peek_front();</span>
<span class="line-removed">557     }</span>
<span class="line-removed">558     if (hr == NULL) {</span>
<span class="line-removed">559       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (candidate old regions not available)&quot;);</span>
560     }
561 
562     candidates()-&gt;verify();
563   }
564 
565   stop_incremental_building();
566 
<a name="60" id="anc60"></a><span class="line-removed">567   log_debug(gc, ergo, cset)(&quot;Finish choosing CSet regions old: %u, optional: %u, &quot;</span>
<span class="line-removed">568                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,</span>
<span class="line-removed">569                             old_region_length(), optional_region_length(),</span>
<span class="line-removed">570                             predicted_old_time_ms, predicted_optional_time_ms, time_remaining_ms);</span>
<span class="line-removed">571   if (expensive_region_num &gt; 0) {</span>
<span class="line-removed">572     log_debug(gc, ergo, cset)(&quot;CSet contains %u old regions that were added although the predicted time was too high.&quot;,</span>
<span class="line-removed">573                               expensive_region_num);</span>
<span class="line-removed">574   }</span>
<span class="line-removed">575 </span>
576   double non_young_end_time_sec = os::elapsedTime();
577   phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
578 
579   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
580 }
581 
<a name="61" id="anc61"></a><span class="line-modified">582 HeapRegion* G1OptionalCSet::region_at(uint index) {</span>
<span class="line-modified">583   return _cset-&gt;optional_region_at(index);</span>













584 }
585 
<a name="62" id="anc62"></a><span class="line-modified">586 void G1OptionalCSet::prepare_evacuation(double time_limit) {</span>
<span class="line-modified">587   assert(_current_index == _current_limit, &quot;Before prepare no regions should be ready for evac&quot;);</span>


588 
<a name="63" id="anc63"></a><span class="line-modified">589   uint prepared_regions = 0;</span>
<span class="line-modified">590   double prediction_ms = 0;</span>
591 
<a name="64" id="anc64"></a><span class="line-modified">592   _prepare_failed = true;</span>
<span class="line-modified">593   for (uint i = _current_index; i &lt; _cset-&gt;optional_region_length(); i++) {</span>
<span class="line-modified">594     HeapRegion* hr = region_at(i);</span>
<span class="line-modified">595     prediction_ms += _cset-&gt;predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">596     if (prediction_ms &gt; time_limit) {</span>
<span class="line-removed">597       log_debug(gc, cset)(&quot;Prepared %u regions for optional evacuation. Predicted time: %.3fms&quot;, prepared_regions, prediction_ms);</span>
<span class="line-removed">598       return;</span>
<span class="line-removed">599     }</span>
600 
<a name="65" id="anc65"></a><span class="line-modified">601     // This region will be included in the next optional evacuation.</span>
<span class="line-removed">602     prepare_to_evacuate_optional_region(hr);</span>
<span class="line-removed">603     prepared_regions++;</span>
<span class="line-removed">604     _current_limit++;</span>
<span class="line-removed">605     _prepare_failed = false;</span>
<span class="line-removed">606   }</span>
607 
<a name="66" id="anc66"></a><span class="line-modified">608   log_debug(gc, cset)(&quot;Prepared all %u regions for optional evacuation. Predicted time: %.3fms&quot;,</span>
<span class="line-removed">609                       prepared_regions, prediction_ms);</span>
<span class="line-removed">610 }</span>
611 
<a name="67" id="anc67"></a><span class="line-modified">612 bool G1OptionalCSet::prepare_failed() {</span>
<span class="line-removed">613   return _prepare_failed;</span>
<span class="line-removed">614 }</span>
615 
<a name="68" id="anc68"></a><span class="line-modified">616 void G1OptionalCSet::complete_evacuation() {</span>
<span class="line-removed">617   _evacuation_failed = false;</span>
<span class="line-removed">618   for (uint i = _current_index; i &lt; _current_limit; i++) {</span>
<span class="line-removed">619     HeapRegion* hr = region_at(i);</span>
<span class="line-removed">620     _cset-&gt;clear_optional_region(hr);</span>
<span class="line-removed">621     if (hr-&gt;evacuation_failed()){</span>
<span class="line-removed">622       _evacuation_failed = true;</span>
<span class="line-removed">623     }</span>
<span class="line-removed">624   }</span>
<span class="line-removed">625   _current_index = _current_limit;</span>
<span class="line-removed">626 }</span>
627 
<a name="69" id="anc69"></a><span class="line-modified">628 bool G1OptionalCSet::evacuation_failed() {</span>
<span class="line-removed">629   return _evacuation_failed;</span>
630 }
631 
<a name="70" id="anc70"></a><span class="line-modified">632 G1OptionalCSet::~G1OptionalCSet() {</span>
<span class="line-modified">633   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified">634   while (!is_empty()) {</span>
<span class="line-modified">635     // We want to return regions not evacuated to the collection set candidates</span>
<span class="line-modified">636     // in reverse order to maintain the old order.</span>
<span class="line-modified">637     HeapRegion* hr = _cset-&gt;remove_last_optional_region();</span>
<span class="line-modified">638     assert(hr != NULL, &quot;Should be valid region left&quot;);</span>
<span class="line-modified">639     _pset-&gt;record_unused_optional_region(hr);</span>
<span class="line-modified">640     g1h-&gt;old_set_add(hr);</span>
<span class="line-removed">641     g1h-&gt;clear_in_cset(hr);</span>
<span class="line-removed">642     hr-&gt;set_index_in_opt_cset(InvalidCSetIndex);</span>
<span class="line-removed">643     _cset-&gt;candidates()-&gt;push_front(hr);</span>
644   }
<a name="71" id="anc71"></a><span class="line-modified">645   _cset-&gt;free_optional_regions();</span>
<span class="line-removed">646 }</span>
<span class="line-removed">647 </span>
<span class="line-removed">648 uint G1OptionalCSet::size() {</span>
<span class="line-removed">649   return _cset-&gt;optional_region_length() - _current_index;</span>
<span class="line-removed">650 }</span>
<span class="line-removed">651 </span>
<span class="line-removed">652 bool G1OptionalCSet::is_empty() {</span>
<span class="line-removed">653   return size() == 0;</span>
<span class="line-removed">654 }</span>
655 
<a name="72" id="anc72"></a><span class="line-modified">656 void G1OptionalCSet::prepare_to_evacuate_optional_region(HeapRegion* hr) {</span>
<span class="line-removed">657   log_trace(gc, cset)(&quot;Adding region %u for optional evacuation&quot;, hr-&gt;hrm_index());</span>
<span class="line-removed">658   G1CollectedHeap::heap()-&gt;clear_in_cset(hr);</span>
<span class="line-removed">659   _cset-&gt;add_old_region(hr);</span>
660 }
661 
662 #ifdef ASSERT
663 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
664 private:
665   size_t _young_length;
<a name="73" id="anc73"></a><span class="line-modified">666   int* _heap_region_indices;</span>
667 public:
668   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<a name="74" id="anc74"></a><span class="line-modified">669     _heap_region_indices = NEW_C_HEAP_ARRAY(int, young_length, mtGC);</span>
<span class="line-modified">670     for (size_t i = 0; i &lt; young_length; i++) {</span>
<span class="line-modified">671       _heap_region_indices[i] = -1;</span>
672     }
673   }
674   ~G1VerifyYoungCSetIndicesClosure() {
675     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
676   }
677 
678   virtual bool do_heap_region(HeapRegion* r) {
<a name="75" id="anc75"></a><span class="line-modified">679     const int idx = r-&gt;young_index_in_cset();</span>
680 
<a name="76" id="anc76"></a><span class="line-modified">681     assert(idx &gt; -1, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">682     assert((size_t)idx &lt; _young_length, &quot;Young cset index too large for region %u&quot;, r-&gt;hrm_index());</span>
683 
<a name="77" id="anc77"></a><span class="line-modified">684     assert(_heap_region_indices[idx] == -1,</span>
685            &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
686            idx, _heap_region_indices[idx], r-&gt;hrm_index());
687 
688     _heap_region_indices[idx] = r-&gt;hrm_index();
689 
690     return false;
691   }
692 };
693 
694 void G1CollectionSet::verify_young_cset_indices() const {
695   assert_at_safepoint_on_vm_thread();
696 
697   G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);
698   iterate(&amp;cl);
699 }
700 #endif
<a name="78" id="anc78"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="78" type="hidden" />
</body>
</html>
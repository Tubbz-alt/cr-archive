<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectionSetCandidates.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectionSetCandidates.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetChooser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSetCandidates.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
46   // set candidates.
47   size_t _remaining_reclaimable_bytes;
48   // The index of the next candidate old region to be considered for
49   // addition to the current collection set.
50   uint _front_idx;
51 
52 public:
53   G1CollectionSetCandidates(HeapRegion** regions, uint num_regions, size_t remaining_reclaimable_bytes) :
54     _regions(regions),
55     _num_regions(num_regions),
56     _remaining_reclaimable_bytes(remaining_reclaimable_bytes),
57     _front_idx(0) { }
58 
59   ~G1CollectionSetCandidates() {
60     FREE_C_HEAP_ARRAY(HeapRegion*, _regions);
61   }
62 
63   // Returns the total number of collection set candidate old regions added.
64   uint num_regions() { return _num_regions; }
65 
<span class="line-modified">66   // Return the candidate region at the cursor position to be considered for collection without</span>
<span class="line-modified">67   // removing it.</span>
<span class="line-modified">68   HeapRegion* peek_front() {</span>
69     HeapRegion* res = NULL;
<span class="line-modified">70     if (_front_idx &lt; _num_regions) {</span>
<span class="line-modified">71       res = _regions[_front_idx];</span>
<span class="line-modified">72       assert(res != NULL, &quot;Unexpected NULL HeapRegion at index %u&quot;, _front_idx);</span>
73     }
74     return res;
75   }
76 
<span class="line-modified">77   // Remove the given region from the candidates set and move the cursor to the next one.</span>
<span class="line-removed">78   HeapRegion* pop_front();</span>
<span class="line-removed">79 </span>
<span class="line-removed">80   // Add the given HeapRegion to the front of the collection set candidate set again.</span>
<span class="line-removed">81   void push_front(HeapRegion* hr);</span>
82 
83   // Iterate over all remaining collection set candidate regions.
84   void iterate(HeapRegionClosure* cl);
85 
86   // Return the number of candidate regions remaining.
87   uint num_remaining() { return _num_regions - _front_idx; }
88 
89   bool is_empty() { return num_remaining() == 0; }
90 
91   // Return the amount of reclaimable bytes that may be collected by the remaining
92   // candidate regions.
93   size_t remaining_reclaimable_bytes() { return _remaining_reclaimable_bytes; }
94 
95   void verify() const PRODUCT_RETURN;
96 };
97 
98 #endif /* SHARE_GC_G1_G1COLLECTIONSETCANDIDATES_HPP */
99 
</pre>
</td>
<td>
<hr />
<pre>
46   // set candidates.
47   size_t _remaining_reclaimable_bytes;
48   // The index of the next candidate old region to be considered for
49   // addition to the current collection set.
50   uint _front_idx;
51 
52 public:
53   G1CollectionSetCandidates(HeapRegion** regions, uint num_regions, size_t remaining_reclaimable_bytes) :
54     _regions(regions),
55     _num_regions(num_regions),
56     _remaining_reclaimable_bytes(remaining_reclaimable_bytes),
57     _front_idx(0) { }
58 
59   ~G1CollectionSetCandidates() {
60     FREE_C_HEAP_ARRAY(HeapRegion*, _regions);
61   }
62 
63   // Returns the total number of collection set candidate old regions added.
64   uint num_regions() { return _num_regions; }
65 
<span class="line-modified">66   uint cur_idx() const { return _front_idx; }</span>
<span class="line-modified">67 </span>
<span class="line-modified">68   HeapRegion* at(uint idx) const {</span>
69     HeapRegion* res = NULL;
<span class="line-modified">70     if (idx &lt; _num_regions) {</span>
<span class="line-modified">71       res = _regions[idx];</span>
<span class="line-modified">72       assert(res != NULL, &quot;Unexpected NULL HeapRegion at index %u&quot;, idx);</span>
73     }
74     return res;
75   }
76 
<span class="line-modified">77   void remove(uint num_regions);</span>




78 
79   // Iterate over all remaining collection set candidate regions.
80   void iterate(HeapRegionClosure* cl);
81 
82   // Return the number of candidate regions remaining.
83   uint num_remaining() { return _num_regions - _front_idx; }
84 
85   bool is_empty() { return num_remaining() == 0; }
86 
87   // Return the amount of reclaimable bytes that may be collected by the remaining
88   // candidate regions.
89   size_t remaining_reclaimable_bytes() { return _remaining_reclaimable_bytes; }
90 
91   void verify() const PRODUCT_RETURN;
92 };
93 
94 #endif /* SHARE_GC_G1_G1COLLECTIONSETCANDIDATES_HPP */
95 
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectionSetCandidates.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetChooser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
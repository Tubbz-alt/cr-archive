<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1EvacFailure.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1EdenRegions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EvacFailure.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1EvacFailure.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,31 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
<span class="line-removed">- #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;</span>
  #include &quot;gc/g1/g1EvacFailure.hpp&quot;
  #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/g1_globals.hpp&quot;</span>
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  
<span class="line-modified">! class UpdateRSetDeferred : public BasicOopIterateClosure {</span>
  private:
    G1CollectedHeap* _g1h;
<span class="line-modified">!   G1DirtyCardQueue* _dcq;</span>
    G1CardTable*    _ct;
  
  public:
<span class="line-modified">!   UpdateRSetDeferred(G1DirtyCardQueue* dcq) :</span>
<span class="line-modified">!     _g1h(G1CollectedHeap::heap()), _dcq(dcq), _ct(_g1h-&gt;card_table()) {}</span>
  
    virtual void do_oop(narrowOop* p) { do_oop_work(p); }
    virtual void do_oop(      oop* p) { do_oop_work(p); }
    template &lt;class T&gt; void do_oop_work(T* p) {
      assert(_g1h-&gt;heap_region_containing(p)-&gt;is_in_reserved(p), &quot;paranoia&quot;);
<span class="line-new-header">--- 24,34 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
  #include &quot;gc/g1/g1EvacFailure.hpp&quot;
  #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;</span>
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  
<span class="line-modified">! class UpdateLogBuffersDeferred : public BasicOopIterateClosure {</span>
  private:
    G1CollectedHeap* _g1h;
<span class="line-modified">!   G1RedirtyCardsQueue* _rdcq;</span>
    G1CardTable*    _ct;
  
<span class="line-added">+   // Remember the last enqueued card to avoid enqueuing the same card over and over;</span>
<span class="line-added">+   // since we only ever handle a card once, this is sufficient.</span>
<span class="line-added">+   size_t _last_enqueued_card;</span>
<span class="line-added">+ </span>
  public:
<span class="line-modified">!   UpdateLogBuffersDeferred(G1RedirtyCardsQueue* rdcq) :</span>
<span class="line-modified">!     _g1h(G1CollectedHeap::heap()), _rdcq(rdcq), _ct(_g1h-&gt;card_table()), _last_enqueued_card(SIZE_MAX) {}</span>
  
    virtual void do_oop(narrowOop* p) { do_oop_work(p); }
    virtual void do_oop(      oop* p) { do_oop_work(p); }
    template &lt;class T&gt; void do_oop_work(T* p) {
      assert(_g1h-&gt;heap_region_containing(p)-&gt;is_in_reserved(p), &quot;paranoia&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,36 ***</span>
  
      if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {
        return;
      }
      size_t card_index = _ct-&gt;index_for(p);
<span class="line-modified">!     if (_ct-&gt;mark_card_deferred(card_index)) {</span>
<span class="line-modified">!       _dcq-&gt;enqueue(_ct-&gt;byte_for_index(card_index));</span>
      }
    }
  };
  
  class RemoveSelfForwardPtrObjClosure: public ObjectClosure {
    G1CollectedHeap* _g1h;
    G1ConcurrentMark* _cm;
    HeapRegion* _hr;
    size_t _marked_bytes;
<span class="line-modified">!   UpdateRSetDeferred* _update_rset_cl;</span>
    bool _during_initial_mark;
    uint _worker_id;
    HeapWord* _last_forwarded_object_end;
  
  public:
    RemoveSelfForwardPtrObjClosure(HeapRegion* hr,
<span class="line-modified">!                                  UpdateRSetDeferred* update_rset_cl,</span>
                                   bool during_initial_mark,
                                   uint worker_id) :
      _g1h(G1CollectedHeap::heap()),
      _cm(_g1h-&gt;concurrent_mark()),
      _hr(hr),
      _marked_bytes(0),
<span class="line-modified">!     _update_rset_cl(update_rset_cl),</span>
      _during_initial_mark(during_initial_mark),
      _worker_id(worker_id),
      _last_forwarded_object_end(hr-&gt;bottom()) { }
  
    size_t marked_bytes() { return _marked_bytes; }
<span class="line-new-header">--- 64,37 ---</span>
  
      if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {
        return;
      }
      size_t card_index = _ct-&gt;index_for(p);
<span class="line-modified">!     if (card_index != _last_enqueued_card) {</span>
<span class="line-modified">!       _rdcq-&gt;enqueue(_ct-&gt;byte_for_index(card_index));</span>
<span class="line-added">+       _last_enqueued_card = card_index;</span>
      }
    }
  };
  
  class RemoveSelfForwardPtrObjClosure: public ObjectClosure {
    G1CollectedHeap* _g1h;
    G1ConcurrentMark* _cm;
    HeapRegion* _hr;
    size_t _marked_bytes;
<span class="line-modified">!   UpdateLogBuffersDeferred* _log_buffer_cl;</span>
    bool _during_initial_mark;
    uint _worker_id;
    HeapWord* _last_forwarded_object_end;
  
  public:
    RemoveSelfForwardPtrObjClosure(HeapRegion* hr,
<span class="line-modified">!                                  UpdateLogBuffersDeferred* log_buffer_cl,</span>
                                   bool during_initial_mark,
                                   uint worker_id) :
      _g1h(G1CollectedHeap::heap()),
      _cm(_g1h-&gt;concurrent_mark()),
      _hr(hr),
      _marked_bytes(0),
<span class="line-modified">!     _log_buffer_cl(log_buffer_cl),</span>
      _during_initial_mark(during_initial_mark),
      _worker_id(worker_id),
      _last_forwarded_object_end(hr-&gt;bottom()) { }
  
    size_t marked_bytes() { return _marked_bytes; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
    // objects. Further update the BOT and marks.
    // We can coalesce and overwrite the remaining heap contents with dummy objects
    // as they have either been dead or evacuated (which are unreferenced now, i.e.
    // dead too) already.
    void do_object(oop obj) {
<span class="line-modified">!     HeapWord* obj_addr = (HeapWord*) obj;</span>
      assert(_hr-&gt;is_in(obj_addr), &quot;sanity&quot;);
  
      if (obj-&gt;is_forwarded() &amp;&amp; obj-&gt;forwardee() == obj) {
        // The object failed to move.
  
<span class="line-new-header">--- 104,11 ---</span>
    // objects. Further update the BOT and marks.
    // We can coalesce and overwrite the remaining heap contents with dummy objects
    // as they have either been dead or evacuated (which are unreferenced now, i.e.
    // dead too) already.
    void do_object(oop obj) {
<span class="line-modified">!     HeapWord* obj_addr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
      assert(_hr-&gt;is_in(obj_addr), &quot;sanity&quot;);
  
      if (obj-&gt;is_forwarded() &amp;&amp; obj-&gt;forwardee() == obj) {
        // The object failed to move.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
        // involved scanning a card in the collection set and coming
        // across an array that was being chunked and looking malformed.
        // The problem is that, if evacuation fails, we might have
        // remembered set entries missing given that we skipped cards on
        // the collection set. So, we&#39;ll recreate such entries now.
<span class="line-modified">!       obj-&gt;oop_iterate(_update_rset_cl);</span>
  
        HeapWord* obj_end = obj_addr + obj_size;
        _last_forwarded_object_end = obj_end;
        _hr-&gt;cross_threshold(obj_addr, obj_end);
      }
<span class="line-new-header">--- 147,11 ---</span>
        // involved scanning a card in the collection set and coming
        // across an array that was being chunked and looking malformed.
        // The problem is that, if evacuation fails, we might have
        // remembered set entries missing given that we skipped cards on
        // the collection set. So, we&#39;ll recreate such entries now.
<span class="line-modified">!       obj-&gt;oop_iterate(_log_buffer_cl);</span>
  
        HeapWord* obj_end = obj_addr + obj_size;
        _last_forwarded_object_end = obj_end;
        _hr-&gt;cross_threshold(obj_addr, obj_end);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,29 ***</span>
  };
  
  class RemoveSelfForwardPtrHRClosure: public HeapRegionClosure {
    G1CollectedHeap* _g1h;
    uint _worker_id;
<span class="line-removed">-   HeapRegionClaimer* _hrclaimer;</span>
  
<span class="line-modified">!   G1DirtyCardQueue _dcq;</span>
<span class="line-modified">!   UpdateRSetDeferred _update_rset_cl;</span>
  
  public:
<span class="line-modified">!   RemoveSelfForwardPtrHRClosure(uint worker_id,</span>
<span class="line-removed">-                                 HeapRegionClaimer* hrclaimer) :</span>
      _g1h(G1CollectedHeap::heap()),
      _worker_id(worker_id),
<span class="line-modified">!     _hrclaimer(hrclaimer),</span>
<span class="line-modified">!     _dcq(&amp;_g1h-&gt;dirty_card_queue_set()),</span>
<span class="line-removed">-     _update_rset_cl(&amp;_dcq){</span>
    }
  
    size_t remove_self_forward_ptr_by_walking_hr(HeapRegion* hr,
                                                 bool during_initial_mark) {
      RemoveSelfForwardPtrObjClosure rspc(hr,
<span class="line-modified">!                                         &amp;_update_rset_cl,</span>
                                          during_initial_mark,
                                          _worker_id);
      hr-&gt;object_iterate(&amp;rspc);
      // Need to zap the remainder area of the processed region.
      rspc.zap_remainder();
<span class="line-new-header">--- 196,26 ---</span>
  };
  
  class RemoveSelfForwardPtrHRClosure: public HeapRegionClosure {
    G1CollectedHeap* _g1h;
    uint _worker_id;
  
<span class="line-modified">!   G1RedirtyCardsQueue _rdcq;</span>
<span class="line-modified">!   UpdateLogBuffersDeferred _log_buffer_cl;</span>
  
  public:
<span class="line-modified">!   RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs, uint worker_id) :</span>
      _g1h(G1CollectedHeap::heap()),
      _worker_id(worker_id),
<span class="line-modified">!     _rdcq(rdcqs),</span>
<span class="line-modified">!     _log_buffer_cl(&amp;_rdcq) {</span>
    }
  
    size_t remove_self_forward_ptr_by_walking_hr(HeapRegion* hr,
                                                 bool during_initial_mark) {
      RemoveSelfForwardPtrObjClosure rspc(hr,
<span class="line-modified">!                                         &amp;_log_buffer_cl,</span>
                                          during_initial_mark,
                                          _worker_id);
      hr-&gt;object_iterate(&amp;rspc);
      // Need to zap the remainder area of the processed region.
      rspc.zap_remainder();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,38 ***</span>
  
    bool do_heap_region(HeapRegion *hr) {
      assert(!hr-&gt;is_pinned(), &quot;Unexpected pinned region at index %u&quot;, hr-&gt;hrm_index());
      assert(hr-&gt;in_collection_set(), &quot;bad CS&quot;);
  
<span class="line-modified">!     if (_hrclaimer-&gt;claim_region(hr-&gt;hrm_index())) {</span>
<span class="line-modified">!       if (hr-&gt;evacuation_failed()) {</span>
<span class="line-modified">!         bool during_initial_mark = _g1h-&gt;collector_state()-&gt;in_initial_mark_gc();</span>
<span class="line-modified">!         bool during_conc_mark = _g1h-&gt;collector_state()-&gt;mark_or_rebuild_in_progress();</span>
  
<span class="line-modified">!         hr-&gt;note_self_forwarding_removal_start(during_initial_mark,</span>
                                                 during_conc_mark);
<span class="line-modified">!         _g1h-&gt;verifier()-&gt;check_bitmaps(&quot;Self-Forwarding Ptr Removal&quot;, hr);</span>
  
<span class="line-modified">!         hr-&gt;reset_bot();</span>
  
<span class="line-modified">!         size_t live_bytes = remove_self_forward_ptr_by_walking_hr(hr, during_initial_mark);</span>
  
<span class="line-modified">!         hr-&gt;rem_set()-&gt;clean_strong_code_roots(hr);</span>
<span class="line-modified">!         hr-&gt;rem_set()-&gt;clear_locked(true);</span>
  
<span class="line-modified">!         hr-&gt;note_self_forwarding_removal_end(live_bytes);</span>
<span class="line-removed">-       }</span>
      }
      return false;
    }
  };
  
<span class="line-modified">! G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask() :</span>
    AbstractGangTask(&quot;G1 Remove Self-forwarding Pointers&quot;),
    _g1h(G1CollectedHeap::heap()),
    _hrclaimer(_g1h-&gt;workers()-&gt;active_workers()) { }
  
  void G1ParRemoveSelfForwardPtrsTask::work(uint worker_id) {
<span class="line-modified">!   RemoveSelfForwardPtrHRClosure rsfp_cl(worker_id, &amp;_hrclaimer);</span>
  
<span class="line-modified">!   _g1h-&gt;collection_set_iterate_from(&amp;rsfp_cl, worker_id);</span>
  }
<span class="line-new-header">--- 225,39 ---</span>
  
    bool do_heap_region(HeapRegion *hr) {
      assert(!hr-&gt;is_pinned(), &quot;Unexpected pinned region at index %u&quot;, hr-&gt;hrm_index());
      assert(hr-&gt;in_collection_set(), &quot;bad CS&quot;);
  
<span class="line-modified">!     if (hr-&gt;evacuation_failed()) {</span>
<span class="line-modified">!       hr-&gt;clear_index_in_opt_cset();</span>
<span class="line-modified">! </span>
<span class="line-modified">!       bool during_initial_mark = _g1h-&gt;collector_state()-&gt;in_initial_mark_gc();</span>
<span class="line-added">+       bool during_conc_mark = _g1h-&gt;collector_state()-&gt;mark_or_rebuild_in_progress();</span>
  
<span class="line-modified">!       hr-&gt;note_self_forwarding_removal_start(during_initial_mark,</span>
                                                 during_conc_mark);
<span class="line-modified">!       _g1h-&gt;verifier()-&gt;check_bitmaps(&quot;Self-Forwarding Ptr Removal&quot;, hr);</span>
  
<span class="line-modified">!       hr-&gt;reset_bot();</span>
  
<span class="line-modified">!       size_t live_bytes = remove_self_forward_ptr_by_walking_hr(hr, during_initial_mark);</span>
  
<span class="line-modified">!       hr-&gt;rem_set()-&gt;clean_strong_code_roots(hr);</span>
<span class="line-modified">!       hr-&gt;rem_set()-&gt;clear_locked(true);</span>
  
<span class="line-modified">!       hr-&gt;note_self_forwarding_removal_end(live_bytes);</span>
      }
      return false;
    }
  };
  
<span class="line-modified">! G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs) :</span>
    AbstractGangTask(&quot;G1 Remove Self-forwarding Pointers&quot;),
    _g1h(G1CollectedHeap::heap()),
<span class="line-added">+   _rdcqs(rdcqs),</span>
    _hrclaimer(_g1h-&gt;workers()-&gt;active_workers()) { }
  
  void G1ParRemoveSelfForwardPtrsTask::work(uint worker_id) {
<span class="line-modified">!   RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id);</span>
  
<span class="line-modified">!   _g1h-&gt;collection_set_iterate_increment_from(&amp;rsfp_cl, &amp;_hrclaimer, worker_id);</span>
  }
</pre>
<center><a href="g1EdenRegions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EvacFailure.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
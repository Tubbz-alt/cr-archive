<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 26 #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 27 
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;gc/shared/cardTable.hpp&quot;</span>

 29 #include &quot;gc/shared/ptrQueue.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
<a name="3" id="anc3"></a>
 31 
<a name="4" id="anc4"></a>
 32 class G1DirtyCardQueueSet;
<a name="5" id="anc5"></a><span class="line-modified"> 33 class G1FreeIdSet;</span>
 34 class Thread;
<a name="6" id="anc6"></a><span class="line-removed"> 35 class Monitor;</span>
<span class="line-removed"> 36 </span>
<span class="line-removed"> 37 // A closure class for processing card table entries.  Note that we don&#39;t</span>
<span class="line-removed"> 38 // require these closure objects to be stack-allocated.</span>
<span class="line-removed"> 39 class G1CardTableEntryClosure: public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-removed"> 40 public:</span>
<span class="line-removed"> 41   typedef CardTable::CardValue CardValue;</span>
<span class="line-removed"> 42 </span>
<span class="line-removed"> 43   // Process the card whose card table entry is &quot;card_ptr&quot;.  If returns</span>
<span class="line-removed"> 44   // &quot;false&quot;, terminate the iteration early.</span>
<span class="line-removed"> 45   virtual bool do_card_ptr(CardValue* card_ptr, uint worker_i) = 0;</span>
<span class="line-removed"> 46 };</span>
 47 
 48 // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
 49 class G1DirtyCardQueue: public PtrQueue {
<a name="7" id="anc7"></a>


 50 public:
<a name="8" id="anc8"></a><span class="line-modified"> 51   G1DirtyCardQueue(G1DirtyCardQueueSet* qset, bool permanent = false);</span>
 52 
 53   // Flush before destroying; queue may be used to capture pending work while
 54   // doing something else, with auto-flush on completion.
 55   ~G1DirtyCardQueue();
 56 
 57   // Process queue entries and release resources.
 58   void flush() { flush_impl(); }
 59 
<a name="9" id="anc9"></a>

 60   // Compiler support.
 61   static ByteSize byte_offset_of_index() {
 62     return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
 63   }
 64   using PtrQueue::byte_width_of_index;
 65 
 66   static ByteSize byte_offset_of_buf() {
 67     return PtrQueue::byte_offset_of_buf&lt;G1DirtyCardQueue&gt;();
 68   }
 69   using PtrQueue::byte_width_of_buf;
 70 
 71 };
 72 
<a name="10" id="anc10"></a><span class="line-removed"> 73 </span>
<span class="line-removed"> 74 </span>
 75 class G1DirtyCardQueueSet: public PtrQueueSet {
<a name="11" id="anc11"></a><span class="line-modified"> 76   G1DirtyCardQueue _shared_dirty_card_queue;</span>
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78   // Apply the closure to the elements of &quot;node&quot; from it&#39;s index to</span>
<span class="line-modified"> 79   // buffer_size.  If all closure applications return true, then</span>
<span class="line-modified"> 80   // returns true.  Stops processing after the first closure</span>
<span class="line-modified"> 81   // application that returns false, and returns false from this</span>
<span class="line-modified"> 82   // function.  If &quot;consume&quot; is true, the node&#39;s index is updated to</span>
<span class="line-modified"> 83   // exclude the processed elements, e.g. up to the element for which</span>
<span class="line-modified"> 84   // the closure returned false.</span>
<span class="line-modified"> 85   bool apply_closure_to_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified"> 86                                BufferNode* node,</span>
<span class="line-modified"> 87                                bool consume,</span>
<span class="line-modified"> 88                                uint worker_i = 0);</span>
<span class="line-modified"> 89 </span>
<span class="line-modified"> 90   // If there are more than stop_at completed buffers, pop one, apply</span>
<span class="line-modified"> 91   // the specified closure to its active elements, and return true.</span>
<span class="line-modified"> 92   // Otherwise return false.</span>





































 93   //
<a name="12" id="anc12"></a><span class="line-modified"> 94   // A completely processed buffer is freed.  However, if a closure</span>
<span class="line-modified"> 95   // invocation returns false, processing is stopped and the partially</span>
<span class="line-modified"> 96   // processed buffer (with its index updated to exclude the processed</span>
<span class="line-modified"> 97   // elements, e.g. up to the element for which the closure returned</span>
<span class="line-modified"> 98   // false) is returned to the completed buffer set.</span>

 99   //
<a name="13" id="anc13"></a><span class="line-modified">100   // If during_pause is true, stop_at must be zero, and the closure</span>
<span class="line-modified">101   // must never return false.</span>
<span class="line-modified">102   bool apply_closure_to_completed_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified">103                                          uint worker_i,</span>
<span class="line-modified">104                                          size_t stop_at,</span>
<span class="line-modified">105                                          bool during_pause);</span>


















































































































106 
107   bool mut_process_buffer(BufferNode* node);
108 
<a name="14" id="anc14"></a><span class="line-modified">109   G1FreeIdSet* _free_ids;</span>
<span class="line-modified">110 </span>
<span class="line-modified">111   // The number of completed buffers processed by mutator and rs thread,</span>
<span class="line-removed">112   // respectively.</span>
<span class="line-removed">113   jint _processed_buffers_mut;</span>
<span class="line-removed">114   jint _processed_buffers_rs_thread;</span>
<span class="line-removed">115 </span>
<span class="line-removed">116   // Current buffer node used for parallel iteration.</span>
<span class="line-removed">117   BufferNode* volatile _cur_par_buffer_node;</span>
<span class="line-removed">118 </span>
<span class="line-removed">119   void concatenate_log(G1DirtyCardQueue&amp; dcq);</span>
120 
121 public:
<a name="15" id="anc15"></a><span class="line-modified">122   G1DirtyCardQueueSet(bool notify_when_complete = true);</span>
123   ~G1DirtyCardQueueSet();
124 
<a name="16" id="anc16"></a><span class="line-modified">125   void initialize(Monitor* cbl_mon,</span>
<span class="line-modified">126                   BufferNode::Allocator* allocator,</span>
<span class="line-modified">127                   Mutex* lock,</span>
<span class="line-removed">128                   bool init_free_ids = false);</span>
129 
130   // The number of parallel ids that can be claimed to allow collector or
131   // mutator threads to do card-processing work.
132   static uint num_par_ids();
133 
134   static void handle_zero_index_for_thread(Thread* t);
135 
<a name="17" id="anc17"></a><span class="line-modified">136   // Apply G1RefineCardConcurrentlyClosure to completed buffers until there are stop_at</span>
<span class="line-modified">137   // completed buffers remaining.</span>
<span class="line-modified">138   bool refine_completed_buffer_concurrently(uint worker_i, size_t stop_at);</span>

139 
<a name="18" id="anc18"></a><span class="line-modified">140   // Apply the given closure to all completed buffers. The given closure&#39;s do_card_ptr</span>
<span class="line-removed">141   // must never return false. Must only be called during GC.</span>
<span class="line-removed">142   bool apply_closure_during_gc(G1CardTableEntryClosure* cl, uint worker_i);</span>
143 
<a name="19" id="anc19"></a><span class="line-modified">144   void reset_for_par_iteration() { _cur_par_buffer_node = completed_buffers_head(); }</span>
<span class="line-modified">145   // Applies the current closure to all completed buffers, non-consumptively.</span>
<span class="line-modified">146   // Can be used in parallel, all callers using the iteration state initialized</span>
<span class="line-modified">147   // by reset_for_par_iteration.</span>
<span class="line-removed">148   void par_apply_closure_to_all_completed_buffers(G1CardTableEntryClosure* cl);</span>
149 
<a name="20" id="anc20"></a><span class="line-modified">150   G1DirtyCardQueue* shared_dirty_card_queue() {</span>
<span class="line-modified">151     return &amp;_shared_dirty_card_queue;</span>



152   }
<a name="21" id="anc21"></a>








153 
<a name="22" id="anc22"></a><span class="line-modified">154   // If a full collection is happening, reset partial logs, and ignore</span>
















155   // completed ones: the full collection will make them all irrelevant.
156   void abandon_logs();
157 
158   // If any threads have partial logs, add them to the global list of logs.
159   void concatenate_logs();
160 
<a name="23" id="anc23"></a><span class="line-modified">161   jint processed_buffers_mut() {</span>
<span class="line-modified">162     return _processed_buffers_mut;</span>
163   }
<a name="24" id="anc24"></a><span class="line-modified">164   jint processed_buffers_rs_thread() {</span>
<span class="line-modified">165     return _processed_buffers_rs_thread;</span>
166   }
167 
<a name="25" id="anc25"></a>








168 };
169 
<a name="26" id="anc26"></a>



170 #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
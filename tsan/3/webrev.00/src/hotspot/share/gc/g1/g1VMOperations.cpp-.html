<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1VMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
 29 #include &quot;gc/g1/g1VMOperations.hpp&quot;
 30 #include &quot;gc/shared/gcId.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 33 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 35 
 36 void VM_G1CollectFull::doit() {
 37   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 38   GCCauseSetter x(g1h, _gc_cause);
 39   _gc_succeeded = g1h-&gt;do_full_collection(true /* explicit_gc */, false /* clear_all_soft_refs */);
 40 }
 41 
 42 VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,
 43                                                      uint           gc_count_before,
 44                                                      GCCause::Cause gc_cause,
 45                                                      bool           should_initiate_conc_mark,
 46                                                      double         target_pause_time_ms) :
 47   VM_CollectForAllocation(word_size, gc_count_before, gc_cause),
 48   _gc_succeeded(false),
 49   _should_initiate_conc_mark(should_initiate_conc_mark),
 50   _should_retry_gc(false),
 51   _target_pause_time_ms(target_pause_time_ms),
 52   _old_marking_cycles_completed_before(0) {
 53 
 54   guarantee(target_pause_time_ms &gt; 0.0,
 55             &quot;target_pause_time_ms = %1.6lf should be positive&quot;,
 56             target_pause_time_ms);
 57   _gc_cause = gc_cause;
 58 }
 59 
 60 bool VM_G1CollectForAllocation::doit_prologue() {
 61   bool res = VM_CollectForAllocation::doit_prologue();
 62   if (!res) {
 63     if (_should_initiate_conc_mark) {
 64       // The prologue can fail for a couple of reasons. The first is that another GC
 65       // got scheduled and prevented the scheduling of the initial mark GC. The
 66       // second is that the GC locker may be active and the heap can&#39;t be expanded.
 67       // In both cases we want to retry the GC so that the initial mark pause is
 68       // actually scheduled. In the second case, however, we should stall until
 69       // until the GC locker is no longer active and then retry the initial mark GC.
 70       _should_retry_gc = true;
 71     }
 72   }
 73   return res;
 74 }
 75 
 76 void VM_G1CollectForAllocation::doit() {
 77   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 78   assert(!_should_initiate_conc_mark || g1h-&gt;should_do_concurrent_full_gc(_gc_cause),
 79       &quot;only a GC locker, a System.gc(), stats update, whitebox, or a hum allocation induced GC should start a cycle&quot;);
 80 
 81   if (_word_size &gt; 0) {
 82     // An allocation has been requested. So, try to do that first.
 83     _result = g1h-&gt;attempt_allocation_at_safepoint(_word_size,
 84                                                    false /* expect_null_cur_alloc_region */);
 85     if (_result != NULL) {
 86       // If we can successfully allocate before we actually do the
 87       // pause then we will consider this pause successful.
 88       _gc_succeeded = true;
 89       return;
 90     }
 91   }
 92 
 93   GCCauseSetter x(g1h, _gc_cause);
 94   if (_should_initiate_conc_mark) {
 95     // It&#39;s safer to read old_marking_cycles_completed() here, given
 96     // that noone else will be updating it concurrently. Since we&#39;ll
 97     // only need it if we&#39;re initiating a marking cycle, no point in
 98     // setting it earlier.
 99     _old_marking_cycles_completed_before = g1h-&gt;old_marking_cycles_completed();
100 
101     // At this point we are supposed to start a concurrent cycle. We
102     // will do so if one is not already in progress.
103     bool res = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);
104 
105     // The above routine returns true if we were able to force the
106     // next GC pause to be an initial mark; it returns false if a
107     // marking cycle is already in progress.
108     //
109     // If a marking cycle is already in progress just return and skip the
110     // pause below - if the reason for requesting this initial mark pause
111     // was due to a System.gc() then the requesting thread should block in
112     // doit_epilogue() until the marking cycle is complete.
113     //
114     // If this initial mark pause was requested as part of a humongous
115     // allocation then we know that the marking cycle must just have
116     // been started by another thread (possibly also allocating a humongous
117     // object) as there was no active marking cycle when the requesting
118     // thread checked before calling collect() in
119     // attempt_allocation_humongous(). Retrying the GC, in this case,
120     // will cause the requesting thread to spin inside collect() until the
121     // just started marking cycle is complete - which may be a while. So
122     // we do NOT retry the GC.
123     if (!res) {
124       assert(_word_size == 0, &quot;Concurrent Full GC/Humongous Object IM shouldn&#39;t be allocating&quot;);
125       if (_gc_cause != GCCause::_g1_humongous_allocation) {
126         _should_retry_gc = true;
127       }
128       return;
129     }
130   }
131 
132   // Try a partial collection of some kind.
133   _gc_succeeded = g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms);
134 
135   if (_gc_succeeded) {
136     if (_word_size &gt; 0) {
137       // An allocation had been requested. Do it, eventually trying a stronger
138       // kind of GC.
139       _result = g1h-&gt;satisfy_failed_allocation(_word_size, &amp;_gc_succeeded);
140     } else {
141       bool should_upgrade_to_full = g1h-&gt;should_upgrade_to_full_gc(_gc_cause);
142 
143       if (should_upgrade_to_full) {
144         // There has been a request to perform a GC to free some space. We have no
145         // information on how much memory has been asked for. In case there are
146         // absolutely no regions left to allocate into, do a maximally compacting full GC.
147         log_info(gc, ergo)(&quot;Attempting maximally compacting collection&quot;);
148         _gc_succeeded = g1h-&gt;do_full_collection(false, /* explicit gc */
149                                                    true   /* clear_all_soft_refs */);
150       }
151     }
152     guarantee(_gc_succeeded, &quot;Elevated collections during the safepoint must always succeed.&quot;);
153   } else {
154     assert(_result == NULL, &quot;invariant&quot;);
155     // The only reason for the pause to not be successful is that, the GC locker is
156     // active (or has become active since the prologue was executed). In this case
157     // we should retry the pause after waiting for the GC locker to become inactive.
158     _should_retry_gc = true;
159   }
160 }
161 
162 void VM_G1CollectForAllocation::doit_epilogue() {
163   VM_CollectForAllocation::doit_epilogue();
164 
165   // If the pause was initiated by a System.gc() and
166   // +ExplicitGCInvokesConcurrent, we have to wait here for the cycle
167   // that just started (or maybe one that was already in progress) to
168   // finish.
169   if (GCCause::is_user_requested_gc(_gc_cause) &amp;&amp;
170       _should_initiate_conc_mark) {
171     assert(ExplicitGCInvokesConcurrent,
172            &quot;the only way to be here is if ExplicitGCInvokesConcurrent is set&quot;);
173 
174     G1CollectedHeap* g1h = G1CollectedHeap::heap();
175 
176     // In the doit() method we saved g1h-&gt;old_marking_cycles_completed()
177     // in the _old_marking_cycles_completed_before field. We have to
178     // wait until we observe that g1h-&gt;old_marking_cycles_completed()
179     // has increased by at least one. This can happen if a) we started
180     // a cycle and it completes, b) a cycle already in progress
181     // completes, or c) a Full GC happens.
182 
183     // If the condition has already been reached, there&#39;s no point in
184     // actually taking the lock and doing the wait.
185     if (g1h-&gt;old_marking_cycles_completed() &lt;=
186                                           _old_marking_cycles_completed_before) {
187       // The following is largely copied from CMS
188 
189       Thread* thr = Thread::current();
190       assert(thr-&gt;is_Java_thread(), &quot;invariant&quot;);
191       JavaThread* jt = (JavaThread*)thr;
192       ThreadToNativeFromVM native(jt);
193 
194       MutexLockerEx x(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
195       while (g1h-&gt;old_marking_cycles_completed() &lt;=
196                                           _old_marking_cycles_completed_before) {
197         FullGCCount_lock-&gt;wait(Mutex::_no_safepoint_check_flag);
198       }
199     }
200   }
201 }
202 
203 void VM_G1Concurrent::doit() {
204   GCIdMark gc_id_mark(_gc_id);
205   GCTraceCPUTime tcpu;
206   G1CollectedHeap* g1h = G1CollectedHeap::heap();
207   GCTraceTime(Info, gc) t(_message, g1h-&gt;concurrent_mark()-&gt;gc_timer_cm(), GCCause::_no_gc, true);
208   TraceCollectorStats tcs(g1h-&gt;g1mm()-&gt;conc_collection_counters());
209   SvcGCMarker sgcm(SvcGCMarker::CONCURRENT);
210   IsGCActiveMark x;
211   _cl-&gt;do_void();
212 }
213 
214 bool VM_G1Concurrent::doit_prologue() {
215   Heap_lock-&gt;lock();
216   return true;
217 }
218 
219 void VM_G1Concurrent::doit_epilogue() {
220   if (Universe::has_reference_pending_list()) {
221     Heap_lock-&gt;notify_all();
222   }
223   Heap_lock-&gt;unlock();
224 }
    </pre>
  </body>
</html>
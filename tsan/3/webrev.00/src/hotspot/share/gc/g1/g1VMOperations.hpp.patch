diff a/src/hotspot/share/gc/g1/g1VMOperations.hpp b/src/hotspot/share/gc/g1/g1VMOperations.hpp
--- a/src/hotspot/share/gc/g1/g1VMOperations.hpp
+++ b/src/hotspot/share/gc/g1/g1VMOperations.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,14 +27,10 @@
 
 #include "gc/shared/gcId.hpp"
 #include "gc/shared/gcVMOperations.hpp"
 
 // VM_operations for the G1 collector.
-// VM_GC_Operation:
-//   - VM_G1Concurrent
-//   - VM_G1CollectForAllocation
-//   - VM_G1CollectFull
 
 class VM_G1CollectFull : public VM_GC_Operation {
   bool _gc_succeeded;
 
 public:
@@ -43,33 +39,45 @@
                    GCCause::Cause cause) :
     VM_GC_Operation(gc_count_before, cause, full_gc_count_before, true),
     _gc_succeeded(false) { }
   virtual VMOp_Type type() const { return VMOp_G1CollectFull; }
   virtual void doit();
-  bool gc_succeeded() { return _gc_succeeded; }
+  bool gc_succeeded() const { return _gc_succeeded; }
 };
 
-class VM_G1CollectForAllocation : public VM_CollectForAllocation {
+class VM_G1TryInitiateConcMark : public VM_GC_Operation {
+  double _target_pause_time_ms;
+  bool _transient_failure;
+  bool _cycle_already_in_progress;
+  bool _terminating;
   bool _gc_succeeded;
 
-  bool _should_initiate_conc_mark;
-  bool _should_retry_gc;
+public:
+  VM_G1TryInitiateConcMark(uint gc_count_before,
+                           GCCause::Cause gc_cause,
+                           double target_pause_time_ms);
+  virtual VMOp_Type type() const { return VMOp_G1TryInitiateConcMark; }
+  virtual bool doit_prologue();
+  virtual void doit();
+  bool transient_failure() const { return _transient_failure; }
+  bool cycle_already_in_progress() const { return _cycle_already_in_progress; }
+  bool terminating() const { return _terminating; }
+  bool gc_succeeded() const { return _gc_succeeded; }
+};
+
+class VM_G1CollectForAllocation : public VM_CollectForAllocation {
+  bool _gc_succeeded;
   double _target_pause_time_ms;
-  uint  _old_marking_cycles_completed_before;
 
 public:
   VM_G1CollectForAllocation(size_t         word_size,
                             uint           gc_count_before,
                             GCCause::Cause gc_cause,
-                            bool           should_initiate_conc_mark,
                             double         target_pause_time_ms);
   virtual VMOp_Type type() const { return VMOp_G1CollectForAllocation; }
-  virtual bool doit_prologue();
   virtual void doit();
-  virtual void doit_epilogue();
-  bool should_retry_gc() const { return _should_retry_gc; }
-  bool gc_succeeded() { return _gc_succeeded; }
+  bool gc_succeeded() const { return _gc_succeeded; }
 };
 
 // Concurrent G1 stop-the-world operations such as remark and cleanup.
 class VM_G1Concurrent : public VM_Operation {
   VoidClosure* _cl;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/heapRegionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionManager.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,14 +24,12 @@</span>
  
  #ifndef SHARE_GC_G1_HEAPREGIONMANAGER_HPP
  #define SHARE_GC_G1_HEAPREGIONMANAGER_HPP
  
  #include &quot;gc/g1/g1BiasedArray.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
  #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;services/memoryUsage.hpp&quot;
  
  class HeapRegion;
  class HeapRegionClosure;
  class HeapRegionClaimer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,10 +106,13 @@</span>
    // Finds the next sequence of empty regions starting from start_idx, going backwards in
    // the heap. Returns the length of the sequence found. If this value is zero, no
    // sequence could be found, otherwise res_idx contains the start index of this range.
    uint find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const;
  
<span class="udiff-line-added">+   // Checks the G1MemoryNodeManager to see if this region is on the preferred node.</span>
<span class="udiff-line-added">+   bool is_on_preferred_index(uint region_index, uint preferred_node_index);</span>
<span class="udiff-line-added">+ </span>
  protected:
    G1HeapRegionTable _regions;
    G1RegionToSpaceMapper* _heap_mapper;
    G1RegionToSpaceMapper* _prev_bitmap_mapper;
    G1RegionToSpaceMapper* _next_bitmap_mapper;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,11 +128,11 @@</span>
  #endif
  public:
    // Empty constructor, we&#39;ll initialize it with the initialize() method.
    HeapRegionManager();
  
<span class="udiff-line-modified-removed">-   static HeapRegionManager* create_manager(G1CollectedHeap* heap, G1CollectorPolicy* policy);</span>
<span class="udiff-line-modified-added">+   static HeapRegionManager* create_manager(G1CollectedHeap* heap);</span>
  
    virtual void initialize(G1RegionToSpaceMapper* heap_storage,
                            G1RegionToSpaceMapper* prev_bitmap,
                            G1RegionToSpaceMapper* next_bitmap,
                            G1RegionToSpaceMapper* bot,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -169,24 +170,20 @@</span>
    inline HeapRegion* addr_to_region(HeapWord* addr) const;
  
    // Insert the given region into the free region list.
    inline void insert_into_free_list(HeapRegion* hr);
  
<span class="udiff-line-added">+   // Rebuild the free region list from scratch.</span>
<span class="udiff-line-added">+   void rebuild_free_list(WorkGang* workers);</span>
<span class="udiff-line-added">+ </span>
    // Insert the given region list into the global free region list.
    void insert_list_into_free_list(FreeRegionList* list) {
      _free_list.add_ordered(list);
    }
  
<span class="udiff-line-modified-removed">-   virtual HeapRegion* allocate_free_region(HeapRegionType type) {</span>
<span class="udiff-line-modified-removed">-     HeapRegion* hr = _free_list.remove_region(!type.is_young());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (hr != NULL) {</span>
<span class="udiff-line-removed">-       assert(hr-&gt;next() == NULL, &quot;Single region should not have next&quot;);</span>
<span class="udiff-line-removed">-       assert(is_available(hr-&gt;hrm_index()), &quot;Must be committed&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return hr;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Allocate a free region with specific node index. If fails allocate with next node index.</span>
<span class="udiff-line-modified-added">+   virtual HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);</span>
  
    inline void allocate_free_regions_starting_at(uint first, uint num_regions);
  
    // Remove all regions from the free list.
    void remove_all_free_regions() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,10 +193,14 @@</span>
    // Return the number of committed free regions in the heap.
    uint num_free_regions() const {
      return _free_list.length();
    }
  
<span class="udiff-line-added">+   uint num_free_regions(uint node_index) const {</span>
<span class="udiff-line-added">+     return _free_list.length(node_index);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    size_t total_free_bytes() const {
      return num_free_regions() * HeapRegion::GrainBytes;
    }
  
    // Return the number of available (uncommitted) regions.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227,10 +228,13 @@</span>
    // Makes sure that the regions from start to start+num_regions-1 are available
    // for allocation. Returns the number of regions that were committed to achieve
    // this.
    virtual uint expand_at(uint start, uint num_regions, WorkGang* pretouch_workers);
  
<span class="udiff-line-added">+   // Try to expand on the given node index.</span>
<span class="udiff-line-added">+   virtual uint expand_on_preferred_node(uint node_index);</span>
<span class="udiff-line-added">+ </span>
    // Find a contiguous set of empty regions of length num. Returns the start index of
    // that set, or G1_NO_HRM_INDEX.
    virtual uint find_contiguous_only_empty(size_t num) { return find_contiguous(num, true); }
    // Find a contiguous set of empty or unavailable regions of length num. Returns the
    // start index of that set, or G1_NO_HRM_INDEX.
</pre>
<center><a href="heapRegionManager.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopStarChunkedList.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1PageBasedVirtualSpace.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1PageBasedVirtualSpace.hpp&quot;
 27 #include &quot;gc/shared/workgroup.hpp&quot;
<span class="line-modified"> 28 #include &quot;oops/markOop.hpp&quot;</span>
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 #include &quot;services/memTracker.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/bitMap.inline.hpp&quot;
 35 
 36 G1PageBasedVirtualSpace::G1PageBasedVirtualSpace(ReservedSpace rs, size_t used_size, size_t page_size) :
 37   _low_boundary(NULL), _high_boundary(NULL), _tail_size(0), _page_size(0),
 38   _committed(mtGC), _dirty(mtGC), _special(false), _executable(false) {
 39   initialize_with_page_size(rs, used_size, page_size);
 40 }
 41 
 42 void G1PageBasedVirtualSpace::initialize_with_page_size(ReservedSpace rs, size_t used_size, size_t page_size) {
 43   guarantee(rs.is_reserved(), &quot;Given reserved space must have been reserved already.&quot;);
 44 
 45   vmassert(_low_boundary == NULL, &quot;VirtualSpace already initialized&quot;);
 46   vmassert(page_size &gt; 0, &quot;Page size must be non-zero.&quot;);
 47 
 48   guarantee(is_aligned(rs.base(), page_size),
</pre>
<hr />
<pre>
107 }
108 
109 size_t G1PageBasedVirtualSpace::addr_to_page_index(char* addr) const {
110   return (addr - _low_boundary) / _page_size;
111 }
112 
113 bool G1PageBasedVirtualSpace::is_area_committed(size_t start_page, size_t size_in_pages) const {
114   size_t end_page = start_page + size_in_pages;
115   return _committed.get_next_zero_offset(start_page, end_page) &gt;= end_page;
116 }
117 
118 bool G1PageBasedVirtualSpace::is_area_uncommitted(size_t start_page, size_t size_in_pages) const {
119   size_t end_page = start_page + size_in_pages;
120   return _committed.get_next_one_offset(start_page, end_page) &gt;= end_page;
121 }
122 
123 char* G1PageBasedVirtualSpace::page_start(size_t index) const {
124   return _low_boundary + index * _page_size;
125 }
126 





127 bool G1PageBasedVirtualSpace::is_after_last_page(size_t index) const {
128   guarantee(index &lt;= _committed.size(),
129             &quot;Given boundary page &quot; SIZE_FORMAT &quot; is beyond managed page count &quot; SIZE_FORMAT, index, _committed.size());
130   return index == _committed.size();
131 }
132 
133 void G1PageBasedVirtualSpace::commit_preferred_pages(size_t start, size_t num_pages) {
134   vmassert(num_pages &gt; 0, &quot;No full pages to commit&quot;);
135   vmassert(start + num_pages &lt;= _committed.size(),
136            &quot;Tried to commit area from page &quot; SIZE_FORMAT &quot; to page &quot; SIZE_FORMAT &quot; &quot;
137            &quot;that is outside of managed space of &quot; SIZE_FORMAT &quot; pages&quot;,
138            start, start + num_pages, _committed.size());
139 
140   char* start_addr = page_start(start);
141   size_t size = num_pages * _page_size;
142 
143   os::commit_memory_or_exit(start_addr, size, _page_size, _executable,
144                             err_msg(&quot;Failed to commit area from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot; of length &quot; SIZE_FORMAT &quot;.&quot;,
145                             p2i(start_addr), p2i(start_addr + size), size));
146 }
</pre>
<hr />
<pre>
239   char* const _start_addr;
240   char* const _end_addr;
241   size_t _page_size;
242 public:
243   G1PretouchTask(char* start_address, char* end_address, size_t page_size) :
244     AbstractGangTask(&quot;G1 PreTouch&quot;),
245     _cur_addr(start_address),
246     _start_addr(start_address),
247     _end_addr(end_address),
248     _page_size(0) {
249 #ifdef LINUX
250     _page_size = UseTransparentHugePages ? (size_t)os::vm_page_size(): page_size;
251 #else
252     _page_size = page_size;
253 #endif
254   }
255 
256   virtual void work(uint worker_id) {
257     size_t const actual_chunk_size = MAX2(chunk_size(), _page_size);
258     while (true) {
<span class="line-modified">259       char* touch_addr = Atomic::add(actual_chunk_size, &amp;_cur_addr) - actual_chunk_size;</span>
260       if (touch_addr &lt; _start_addr || touch_addr &gt;= _end_addr) {
261         break;
262       }
263       char* end_addr = touch_addr + MIN2(actual_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));
264       os::pretouch_memory(touch_addr, end_addr, _page_size);
265     }
266   }
267 
268   static size_t chunk_size() { return PreTouchParallelChunkSize; }
269 };
270 
271 void G1PageBasedVirtualSpace::pretouch(size_t start_page, size_t size_in_pages, WorkGang* pretouch_gang) {
272   G1PretouchTask cl(page_start(start_page), bounded_end_addr(start_page + size_in_pages), _page_size);
273 
274   if (pretouch_gang != NULL) {
275     size_t num_chunks = MAX2((size_t)1, size_in_pages * _page_size / MAX2(G1PretouchTask::chunk_size(), _page_size));
276 
<span class="line-modified">277     uint num_workers = MIN2((uint)num_chunks, pretouch_gang-&gt;active_workers());</span>
278     log_debug(gc, heap)(&quot;Running %s with %u workers for &quot; SIZE_FORMAT &quot; work units pre-touching &quot; SIZE_FORMAT &quot;B.&quot;,
279                         cl.name(), num_workers, num_chunks, size_in_pages * _page_size);
280     pretouch_gang-&gt;run_task(&amp;cl, num_workers);
281   } else {
282     log_debug(gc, heap)(&quot;Running %s pre-touching &quot; SIZE_FORMAT &quot;B.&quot;,
283                         cl.name(), size_in_pages * _page_size);
284     cl.work(0);
285   }
286 }
287 
288 bool G1PageBasedVirtualSpace::contains(const void* p) const {
289   return _low_boundary &lt;= (const char*) p &amp;&amp; (const char*) p &lt; _high_boundary;
290 }
291 
292 #ifndef PRODUCT
293 void G1PageBasedVirtualSpace::print_on(outputStream* out) {
294   out-&gt;print   (&quot;Virtual space:&quot;);
295   if (_special) out-&gt;print(&quot; (pinned in memory)&quot;);
296   out-&gt;cr();
297   out-&gt;print_cr(&quot; - committed: &quot; SIZE_FORMAT, committed_size());
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1PageBasedVirtualSpace.hpp&quot;
 27 #include &quot;gc/shared/workgroup.hpp&quot;
<span class="line-modified"> 28 #include &quot;oops/markWord.hpp&quot;</span>
 29 #include &quot;oops/oop.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/os.inline.hpp&quot;
 32 #include &quot;services/memTracker.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/bitMap.inline.hpp&quot;
 35 
 36 G1PageBasedVirtualSpace::G1PageBasedVirtualSpace(ReservedSpace rs, size_t used_size, size_t page_size) :
 37   _low_boundary(NULL), _high_boundary(NULL), _tail_size(0), _page_size(0),
 38   _committed(mtGC), _dirty(mtGC), _special(false), _executable(false) {
 39   initialize_with_page_size(rs, used_size, page_size);
 40 }
 41 
 42 void G1PageBasedVirtualSpace::initialize_with_page_size(ReservedSpace rs, size_t used_size, size_t page_size) {
 43   guarantee(rs.is_reserved(), &quot;Given reserved space must have been reserved already.&quot;);
 44 
 45   vmassert(_low_boundary == NULL, &quot;VirtualSpace already initialized&quot;);
 46   vmassert(page_size &gt; 0, &quot;Page size must be non-zero.&quot;);
 47 
 48   guarantee(is_aligned(rs.base(), page_size),
</pre>
<hr />
<pre>
107 }
108 
109 size_t G1PageBasedVirtualSpace::addr_to_page_index(char* addr) const {
110   return (addr - _low_boundary) / _page_size;
111 }
112 
113 bool G1PageBasedVirtualSpace::is_area_committed(size_t start_page, size_t size_in_pages) const {
114   size_t end_page = start_page + size_in_pages;
115   return _committed.get_next_zero_offset(start_page, end_page) &gt;= end_page;
116 }
117 
118 bool G1PageBasedVirtualSpace::is_area_uncommitted(size_t start_page, size_t size_in_pages) const {
119   size_t end_page = start_page + size_in_pages;
120   return _committed.get_next_one_offset(start_page, end_page) &gt;= end_page;
121 }
122 
123 char* G1PageBasedVirtualSpace::page_start(size_t index) const {
124   return _low_boundary + index * _page_size;
125 }
126 
<span class="line-added">127 size_t G1PageBasedVirtualSpace::page_size() const {</span>
<span class="line-added">128   assert(_page_size &gt; 0, &quot;Page size is not yet initialized.&quot;);</span>
<span class="line-added">129   return _page_size;</span>
<span class="line-added">130 }</span>
<span class="line-added">131 </span>
132 bool G1PageBasedVirtualSpace::is_after_last_page(size_t index) const {
133   guarantee(index &lt;= _committed.size(),
134             &quot;Given boundary page &quot; SIZE_FORMAT &quot; is beyond managed page count &quot; SIZE_FORMAT, index, _committed.size());
135   return index == _committed.size();
136 }
137 
138 void G1PageBasedVirtualSpace::commit_preferred_pages(size_t start, size_t num_pages) {
139   vmassert(num_pages &gt; 0, &quot;No full pages to commit&quot;);
140   vmassert(start + num_pages &lt;= _committed.size(),
141            &quot;Tried to commit area from page &quot; SIZE_FORMAT &quot; to page &quot; SIZE_FORMAT &quot; &quot;
142            &quot;that is outside of managed space of &quot; SIZE_FORMAT &quot; pages&quot;,
143            start, start + num_pages, _committed.size());
144 
145   char* start_addr = page_start(start);
146   size_t size = num_pages * _page_size;
147 
148   os::commit_memory_or_exit(start_addr, size, _page_size, _executable,
149                             err_msg(&quot;Failed to commit area from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot; of length &quot; SIZE_FORMAT &quot;.&quot;,
150                             p2i(start_addr), p2i(start_addr + size), size));
151 }
</pre>
<hr />
<pre>
244   char* const _start_addr;
245   char* const _end_addr;
246   size_t _page_size;
247 public:
248   G1PretouchTask(char* start_address, char* end_address, size_t page_size) :
249     AbstractGangTask(&quot;G1 PreTouch&quot;),
250     _cur_addr(start_address),
251     _start_addr(start_address),
252     _end_addr(end_address),
253     _page_size(0) {
254 #ifdef LINUX
255     _page_size = UseTransparentHugePages ? (size_t)os::vm_page_size(): page_size;
256 #else
257     _page_size = page_size;
258 #endif
259   }
260 
261   virtual void work(uint worker_id) {
262     size_t const actual_chunk_size = MAX2(chunk_size(), _page_size);
263     while (true) {
<span class="line-modified">264       char* touch_addr = Atomic::fetch_and_add(&amp;_cur_addr, actual_chunk_size);</span>
265       if (touch_addr &lt; _start_addr || touch_addr &gt;= _end_addr) {
266         break;
267       }
268       char* end_addr = touch_addr + MIN2(actual_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));
269       os::pretouch_memory(touch_addr, end_addr, _page_size);
270     }
271   }
272 
273   static size_t chunk_size() { return PreTouchParallelChunkSize; }
274 };
275 
276 void G1PageBasedVirtualSpace::pretouch(size_t start_page, size_t size_in_pages, WorkGang* pretouch_gang) {
277   G1PretouchTask cl(page_start(start_page), bounded_end_addr(start_page + size_in_pages), _page_size);
278 
279   if (pretouch_gang != NULL) {
280     size_t num_chunks = MAX2((size_t)1, size_in_pages * _page_size / MAX2(G1PretouchTask::chunk_size(), _page_size));
281 
<span class="line-modified">282     uint num_workers = MIN2((uint)num_chunks, pretouch_gang-&gt;total_workers());</span>
283     log_debug(gc, heap)(&quot;Running %s with %u workers for &quot; SIZE_FORMAT &quot; work units pre-touching &quot; SIZE_FORMAT &quot;B.&quot;,
284                         cl.name(), num_workers, num_chunks, size_in_pages * _page_size);
285     pretouch_gang-&gt;run_task(&amp;cl, num_workers);
286   } else {
287     log_debug(gc, heap)(&quot;Running %s pre-touching &quot; SIZE_FORMAT &quot;B.&quot;,
288                         cl.name(), size_in_pages * _page_size);
289     cl.work(0);
290   }
291 }
292 
293 bool G1PageBasedVirtualSpace::contains(const void* p) const {
294   return _low_boundary &lt;= (const char*) p &amp;&amp; (const char*) p &lt; _high_boundary;
295 }
296 
297 #ifndef PRODUCT
298 void G1PageBasedVirtualSpace::print_on(outputStream* out) {
299   out-&gt;print   (&quot;Virtual space:&quot;);
300   if (_special) out-&gt;print(&quot; (pinned in memory)&quot;);
301   out-&gt;cr();
302   out-&gt;print_cr(&quot; - committed: &quot; SIZE_FORMAT, committed_size());
</pre>
</td>
</tr>
</table>
<center><a href="g1OopStarChunkedList.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1PageBasedVirtualSpace.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
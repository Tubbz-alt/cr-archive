<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CodeBlobClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CodeCacheRemSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;
 28 #include &quot;gc/g1/g1CodeRootSetTable.hpp&quot;
 29 #include &quot;gc/g1/g1CodeCacheRemSet.hpp&quot;
 30 #include &quot;gc/g1/heapRegion.hpp&quot;
 31 #include &quot;memory/heap.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;

 35 #include &quot;utilities/hashtable.inline.hpp&quot;
 36 #include &quot;utilities/stack.inline.hpp&quot;
 37 
 38 G1CodeRootSetTable* volatile G1CodeRootSetTable::_purge_list = NULL;
 39 
 40 size_t G1CodeRootSetTable::mem_size() {
 41   return sizeof(G1CodeRootSetTable) + (entry_size() * number_of_entries()) + (sizeof(HashtableBucket&lt;mtGC&gt;) * table_size());
 42 }
 43 
 44 G1CodeRootSetTable::Entry* G1CodeRootSetTable::new_entry(nmethod* nm) {
 45   unsigned int hash = compute_hash(nm);
 46   Entry* entry = (Entry*) new_entry_free_list();
 47   if (entry == NULL) {
 48     entry = (Entry*) NEW_C_HEAP_ARRAY2(char, entry_size(), mtGC, CURRENT_PC);
 49   }
 50   entry-&gt;set_next(NULL);
 51   entry-&gt;set_hash(hash);
 52   entry-&gt;set_literal(nm);
 53   return entry;
 54 }
</pre>
<hr />
<pre>
141     Entry* e = bucket(index);
142     while (e != NULL) {
143       Entry* next = e-&gt;next();
144       if (should_remove(e-&gt;literal())) {
145         remove_entry(e, previous);
146         ++num_removed;
147       } else {
148         previous = e;
149       }
150       e = next;
151     }
152   }
153   return num_removed;
154 }
155 
156 G1CodeRootSet::~G1CodeRootSet() {
157   delete _table;
158 }
159 
160 G1CodeRootSetTable* G1CodeRootSet::load_acquire_table() {
<span class="line-modified">161   return OrderAccess::load_acquire(&amp;_table);</span>
162 }
163 
164 void G1CodeRootSet::allocate_small_table() {
165   G1CodeRootSetTable* temp = new G1CodeRootSetTable(SmallSize);
166 
<span class="line-modified">167   OrderAccess::release_store(&amp;_table, temp);</span>
168 }
169 
170 void G1CodeRootSetTable::purge_list_append(G1CodeRootSetTable* table) {
171   for (;;) {
172     table-&gt;_purge_next = _purge_list;
<span class="line-modified">173     G1CodeRootSetTable* old = Atomic::cmpxchg(table, &amp;_purge_list, table-&gt;_purge_next);</span>
174     if (old == table-&gt;_purge_next) {
175       break;
176     }
177   }
178 }
179 
180 void G1CodeRootSetTable::purge() {
181   G1CodeRootSetTable* table = _purge_list;
182   _purge_list = NULL;
183   while (table != NULL) {
184     G1CodeRootSetTable* to_purge = table;
185     table = table-&gt;_purge_next;
186     delete to_purge;
187   }
188 }
189 
190 void G1CodeRootSet::move_to_large() {
191   G1CodeRootSetTable* temp = new G1CodeRootSetTable(LargeSize);
192 
193   _table-&gt;copy_to(temp);
194 
195   G1CodeRootSetTable::purge_list_append(_table);
196 
<span class="line-modified">197   OrderAccess::release_store(&amp;_table, temp);</span>
198 }
199 
200 void G1CodeRootSet::purge() {
201   G1CodeRootSetTable::purge();
202 }
203 
204 size_t G1CodeRootSet::static_mem_size() {
205   return G1CodeRootSetTable::static_mem_size();
206 }
207 
208 void G1CodeRootSet::add(nmethod* method) {
209   bool added = false;
210   if (is_empty()) {
211     allocate_small_table();
212   }
213   added = _table-&gt;add(method);
214   if (added) {
215     if (_length == Threshold) {
216       move_to_large();
217     }
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;
 28 #include &quot;gc/g1/g1CodeRootSetTable.hpp&quot;
 29 #include &quot;gc/g1/g1CodeCacheRemSet.hpp&quot;
 30 #include &quot;gc/g1/heapRegion.hpp&quot;
 31 #include &quot;memory/heap.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added"> 35 #include &quot;runtime/atomic.hpp&quot;</span>
 36 #include &quot;utilities/hashtable.inline.hpp&quot;
 37 #include &quot;utilities/stack.inline.hpp&quot;
 38 
 39 G1CodeRootSetTable* volatile G1CodeRootSetTable::_purge_list = NULL;
 40 
 41 size_t G1CodeRootSetTable::mem_size() {
 42   return sizeof(G1CodeRootSetTable) + (entry_size() * number_of_entries()) + (sizeof(HashtableBucket&lt;mtGC&gt;) * table_size());
 43 }
 44 
 45 G1CodeRootSetTable::Entry* G1CodeRootSetTable::new_entry(nmethod* nm) {
 46   unsigned int hash = compute_hash(nm);
 47   Entry* entry = (Entry*) new_entry_free_list();
 48   if (entry == NULL) {
 49     entry = (Entry*) NEW_C_HEAP_ARRAY2(char, entry_size(), mtGC, CURRENT_PC);
 50   }
 51   entry-&gt;set_next(NULL);
 52   entry-&gt;set_hash(hash);
 53   entry-&gt;set_literal(nm);
 54   return entry;
 55 }
</pre>
<hr />
<pre>
142     Entry* e = bucket(index);
143     while (e != NULL) {
144       Entry* next = e-&gt;next();
145       if (should_remove(e-&gt;literal())) {
146         remove_entry(e, previous);
147         ++num_removed;
148       } else {
149         previous = e;
150       }
151       e = next;
152     }
153   }
154   return num_removed;
155 }
156 
157 G1CodeRootSet::~G1CodeRootSet() {
158   delete _table;
159 }
160 
161 G1CodeRootSetTable* G1CodeRootSet::load_acquire_table() {
<span class="line-modified">162   return Atomic::load_acquire(&amp;_table);</span>
163 }
164 
165 void G1CodeRootSet::allocate_small_table() {
166   G1CodeRootSetTable* temp = new G1CodeRootSetTable(SmallSize);
167 
<span class="line-modified">168   Atomic::release_store(&amp;_table, temp);</span>
169 }
170 
171 void G1CodeRootSetTable::purge_list_append(G1CodeRootSetTable* table) {
172   for (;;) {
173     table-&gt;_purge_next = _purge_list;
<span class="line-modified">174     G1CodeRootSetTable* old = Atomic::cmpxchg(&amp;_purge_list, table-&gt;_purge_next, table);</span>
175     if (old == table-&gt;_purge_next) {
176       break;
177     }
178   }
179 }
180 
181 void G1CodeRootSetTable::purge() {
182   G1CodeRootSetTable* table = _purge_list;
183   _purge_list = NULL;
184   while (table != NULL) {
185     G1CodeRootSetTable* to_purge = table;
186     table = table-&gt;_purge_next;
187     delete to_purge;
188   }
189 }
190 
191 void G1CodeRootSet::move_to_large() {
192   G1CodeRootSetTable* temp = new G1CodeRootSetTable(LargeSize);
193 
194   _table-&gt;copy_to(temp);
195 
196   G1CodeRootSetTable::purge_list_append(_table);
197 
<span class="line-modified">198   Atomic::release_store(&amp;_table, temp);</span>
199 }
200 
201 void G1CodeRootSet::purge() {
202   G1CodeRootSetTable::purge();
203 }
204 
205 size_t G1CodeRootSet::static_mem_size() {
206   return G1CodeRootSetTable::static_mem_size();
207 }
208 
209 void G1CodeRootSet::add(nmethod* method) {
210   bool added = false;
211   if (is_empty()) {
212     allocate_small_table();
213   }
214   added = _table-&gt;add(method);
215   if (added) {
216     if (_length == Threshold) {
217       move_to_large();
218     }
</pre>
</td>
</tr>
</table>
<center><a href="g1CodeBlobClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
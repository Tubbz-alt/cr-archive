<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1Allocator.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 26 #define SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1Allocator.hpp&quot;
 29 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 30 #include &quot;gc/shared/plab.inline.hpp&quot;
<a name="2" id="anc2"></a>
 31 
<a name="3" id="anc3"></a><span class="line-modified"> 32 inline MutatorAllocRegion* G1Allocator::mutator_alloc_region() {</span>
<span class="line-modified"> 33   return &amp;_mutator_alloc_region;</span>
 34 }
 35 
<a name="4" id="anc4"></a><span class="line-modified"> 36 inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region() {</span>
<span class="line-modified"> 37   return &amp;_survivor_gc_alloc_region;</span>






 38 }
 39 
 40 inline OldGCAllocRegion* G1Allocator::old_gc_alloc_region() {
 41   return &amp;_old_gc_alloc_region;
 42 }
 43 
 44 inline HeapWord* G1Allocator::attempt_allocation(size_t min_word_size,
 45                                                  size_t desired_word_size,
 46                                                  size_t* actual_word_size) {
<a name="5" id="anc5"></a><span class="line-modified"> 47   HeapWord* result = mutator_alloc_region()-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);</span>

 48   if (result != NULL) {
 49     return result;
 50   }
<a name="6" id="anc6"></a><span class="line-modified"> 51   return mutator_alloc_region()-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
 52 }
 53 
 54 inline HeapWord* G1Allocator::attempt_allocation_locked(size_t word_size) {
<a name="7" id="anc7"></a><span class="line-modified"> 55   HeapWord* result = mutator_alloc_region()-&gt;attempt_allocation_locked(word_size);</span>
<span class="line-modified"> 56   assert(result != NULL || mutator_alloc_region()-&gt;get() == NULL,</span>
<span class="line-modified"> 57          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region()-&gt;get()));</span>

 58   return result;
 59 }
 60 
 61 inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {
<a name="8" id="anc8"></a><span class="line-modified"> 62   return mutator_alloc_region()-&gt;attempt_allocation_force(word_size);</span>

 63 }
 64 
<a name="9" id="anc9"></a><span class="line-modified"> 65 inline PLAB* G1PLABAllocator::alloc_buffer(InCSetState dest) {</span>
 66   assert(dest.is_valid(),
<a name="10" id="anc10"></a><span class="line-modified"> 67          &quot;Allocation buffer index out of bounds: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="line-modified"> 68   assert(_alloc_buffers[dest.value()] != NULL,</span>
<span class="line-modified"> 69          &quot;Allocation buffer is NULL: &quot; CSETSTATE_FORMAT, dest.value());</span>
<span class="line-modified"> 70   return _alloc_buffers[dest.value()];</span>













 71 }
 72 
<a name="11" id="anc11"></a><span class="line-modified"> 73 inline HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest,</span>
<span class="line-modified"> 74                                                 size_t word_sz) {</span>
<span class="line-modified"> 75   PLAB* buffer = alloc_buffer(dest);</span>









 76   if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
 77     return buffer-&gt;allocate(word_sz);
 78   } else {
 79     return buffer-&gt;allocate_aligned(word_sz, _survivor_alignment_bytes);
 80   }
 81 }
 82 
<a name="12" id="anc12"></a><span class="line-modified"> 83 inline HeapWord* G1PLABAllocator::allocate(InCSetState dest,</span>
 84                                            size_t word_sz,
<a name="13" id="anc13"></a><span class="line-modified"> 85                                            bool* refill_failed) {</span>
<span class="line-modified"> 86   HeapWord* const obj = plab_allocate(dest, word_sz);</span>

 87   if (obj != NULL) {
 88     return obj;
 89   }
<a name="14" id="anc14"></a><span class="line-modified"> 90   return allocate_direct_or_new_plab(dest, word_sz, refill_failed);</span>
 91 }
 92 
 93 // Create the maps which is used to identify archive objects.
 94 inline void G1ArchiveAllocator::enable_archive_object_check() {
 95   if (_archive_check_enabled) {
 96     return;
 97   }
 98 
 99   _archive_check_enabled = true;
100   size_t length = G1CollectedHeap::heap()-&gt;max_reserved_capacity();
<a name="15" id="anc15"></a><span class="line-modified">101   _closed_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="line-modified">102                                         (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="line-modified">103                                         HeapRegion::GrainBytes);</span>
<span class="line-removed">104   _open_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),</span>
<span class="line-removed">105                                       (HeapWord*)Universe::heap()-&gt;base() + length,</span>
<span class="line-removed">106                                       HeapRegion::GrainBytes);</span>
107 }
108 
109 // Set the regions containing the specified address range as archive.
110 inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {
111   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
112   log_info(gc, cds)(&quot;Mark %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
113                      open ? &quot;open&quot; : &quot;closed&quot;,
114                      p2i(range.start()),
115                      p2i(range.last()));
<a name="16" id="anc16"></a><span class="line-modified">116   if (open) {</span>
<span class="line-modified">117     _open_archive_region_map.set_by_address(range, true);</span>
<span class="line-removed">118   } else {</span>
<span class="line-removed">119     _closed_archive_region_map.set_by_address(range, true);</span>
<span class="line-removed">120   }</span>
121 }
122 
123 // Clear the archive regions map containing the specified address range.
<a name="17" id="anc17"></a><span class="line-modified">124 inline void G1ArchiveAllocator::clear_range_archive(MemRegion range, bool open) {</span>
125   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
<a name="18" id="anc18"></a><span class="line-modified">126   log_info(gc, cds)(&quot;Clear %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,</span>
<span class="line-removed">127                     open ? &quot;open&quot; : &quot;closed&quot;,</span>
128                     p2i(range.start()),
129                     p2i(range.last()));
<a name="19" id="anc19"></a><span class="line-modified">130   if (open) {</span>
<span class="line-removed">131     _open_archive_region_map.set_by_address(range, false);</span>
<span class="line-removed">132   } else {</span>
<span class="line-removed">133     _closed_archive_region_map.set_by_address(range, false);</span>
<span class="line-removed">134   }</span>
135 }
136 
137 // Check if an object is in a closed archive region using the _archive_region_map.
138 inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {
<a name="20" id="anc20"></a><span class="line-modified">139   // This is the out-of-line part of is_closed_archive_object test, done separately</span>
<span class="line-removed">140   // to avoid additional performance impact when the check is not enabled.</span>
<span class="line-removed">141   return _closed_archive_region_map.get_by_address((HeapWord*)object);</span>
142 }
143 
144 inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {
<a name="21" id="anc21"></a><span class="line-modified">145   return _open_archive_region_map.get_by_address((HeapWord*)object);</span>
146 }
147 
148 // Check if archive object checking is enabled, to avoid calling in_open/closed_archive_range
149 // unnecessarily.
150 inline bool G1ArchiveAllocator::archive_check_enabled() {
151   return _archive_check_enabled;
152 }
153 
154 inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {
155   return (archive_check_enabled() &amp;&amp; in_closed_archive_range(object));
156 }
157 
158 inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {
159   return (archive_check_enabled() &amp;&amp; in_open_archive_range(object));
160 }
161 
162 inline bool G1ArchiveAllocator::is_archived_object(oop object) {
<a name="22" id="anc22"></a><span class="line-modified">163   return (archive_check_enabled() &amp;&amp; (in_closed_archive_range(object) ||</span>
<span class="line-modified">164                                       in_open_archive_range(object)));</span>
165 }
166 
167 #endif // SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegion.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;

 28 #include &quot;gc/g1/heapRegion.hpp&quot;
 29 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
 30 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 31 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
<span class="line-modified"> 32 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 33 #include &quot;memory/allocation.hpp&quot;


 34 #include &quot;utilities/bitMap.inline.hpp&quot;
 35 
 36 class MasterFreeRegionListChecker : public HeapRegionSetChecker {
 37 public:
 38   void check_mt_safety() {
 39     // Master Free List MT safety protocol:
 40     // (a) If we&#39;re at a safepoint, operations on the master free list
 41     // should be invoked by either the VM thread (which will serialize
 42     // them) or by the GC workers while holding the
 43     // FreeList_lock.
 44     // (b) If we&#39;re not at a safepoint, operations on the master free
 45     // list should be invoked while holding the Heap_lock.
 46 
 47     if (SafepointSynchronize::is_at_safepoint()) {
 48       guarantee(Thread::current()-&gt;is_VM_thread() ||
 49                 FreeList_lock-&gt;owned_by_self(), &quot;master free list MT safety protocol at a safepoint&quot;);
 50     } else {
 51       guarantee(Heap_lock-&gt;owned_by_self(), &quot;master free list MT safety protocol outside a safepoint&quot;);
 52     }
 53   }
 54   bool is_correct_type(HeapRegion* hr) { return hr-&gt;is_free(); }
 55   const char* get_description() { return &quot;Free Regions&quot;; }
 56 };
 57 
 58 HeapRegionManager::HeapRegionManager() :
 59   _bot_mapper(NULL),
 60   _cardtable_mapper(NULL),
 61   _card_counts_mapper(NULL),
 62   _available_map(mtGC),
 63   _num_committed(0),
 64   _allocated_heapregions_length(0),
 65   _regions(), _heap_mapper(NULL),
 66   _prev_bitmap_mapper(NULL),
 67   _next_bitmap_mapper(NULL),
 68   _free_list(&quot;Free list&quot;, new MasterFreeRegionListChecker())
 69 { }
 70 
<span class="line-modified"> 71 HeapRegionManager* HeapRegionManager::create_manager(G1CollectedHeap* heap, G1CollectorPolicy* policy) {</span>
<span class="line-modified"> 72   if (policy-&gt;is_heterogeneous_heap()) {</span>
<span class="line-modified"> 73     return new HeterogeneousHeapRegionManager((uint)(policy-&gt;max_heap_byte_size() / HeapRegion::GrainBytes) /*heap size as num of regions*/);</span>
 74   }
 75   return new HeapRegionManager();
 76 }
 77 
 78 void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,
 79                                G1RegionToSpaceMapper* prev_bitmap,
 80                                G1RegionToSpaceMapper* next_bitmap,
 81                                G1RegionToSpaceMapper* bot,
 82                                G1RegionToSpaceMapper* cardtable,
 83                                G1RegionToSpaceMapper* card_counts) {
 84   _allocated_heapregions_length = 0;
 85 
 86   _heap_mapper = heap_storage;
 87 
 88   _prev_bitmap_mapper = prev_bitmap;
 89   _next_bitmap_mapper = next_bitmap;
 90 
 91   _bot_mapper = bot;
 92   _cardtable_mapper = cardtable;
 93 
 94   _card_counts_mapper = card_counts;
 95 
 96   MemRegion reserved = heap_storage-&gt;reserved();
 97   _regions.initialize(reserved.start(), reserved.end(), HeapRegion::GrainBytes);
 98 
 99   _available_map.initialize(_regions.length());
100 }
101 
102 bool HeapRegionManager::is_available(uint region) const {
103   return _available_map.at(region);
104 }
105 




























106 #ifdef ASSERT
107 bool HeapRegionManager::is_free(HeapRegion* hr) const {
108   return _free_list.contains(hr);
109 }
110 #endif
111 
112 HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {
113   G1CollectedHeap* g1h = G1CollectedHeap::heap();
114   HeapWord* bottom = g1h-&gt;bottom_addr_for_region(hrm_index);
115   MemRegion mr(bottom, bottom + HeapRegion::GrainWords);
116   assert(reserved().contains(mr), &quot;invariant&quot;);
117   return g1h-&gt;new_heap_region(hrm_index, mr);
118 }
119 
120 void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkGang* pretouch_gang) {
121   guarantee(num_regions &gt; 0, &quot;Must commit more than zero regions&quot;);
122   guarantee(_num_committed + num_regions &lt;= max_length(), &quot;Cannot commit more than the maximum amount of regions&quot;);
123 
124   _num_committed += (uint)num_regions;
125 
126   _heap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
127 
128   // Also commit auxiliary data
129   _prev_bitmap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
130   _next_bitmap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
131 
132   _bot_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
133   _cardtable_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
134 
135   _card_counts_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
136 }
137 
138 void HeapRegionManager::uncommit_regions(uint start, size_t num_regions) {
139   guarantee(num_regions &gt;= 1, &quot;Need to specify at least one region to uncommit, tried to uncommit zero regions at %u&quot;, start);
140   guarantee(_num_committed &gt;= num_regions, &quot;pre-condition&quot;);
141 





142   // Print before uncommitting.
143   if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
144     for (uint i = start; i &lt; start + num_regions; i++) {
145       HeapRegion* hr = at(i);
146       G1CollectedHeap::heap()-&gt;hr_printer()-&gt;uncommit(hr);
147     }
148   }
149 
150   _num_committed -= (uint)num_regions;
151 
152   _available_map.par_clear_range(start, start + num_regions, BitMap::unknown_range);
153   _heap_mapper-&gt;uncommit_regions(start, num_regions);
154 
155   // Also uncommit auxiliary data
156   _prev_bitmap_mapper-&gt;uncommit_regions(start, num_regions);
157   _next_bitmap_mapper-&gt;uncommit_regions(start, num_regions);
158 
159   _bot_mapper-&gt;uncommit_regions(start, num_regions);
160   _cardtable_mapper-&gt;uncommit_regions(start, num_regions);
161 
</pre>
<hr />
<pre>
165 void HeapRegionManager::make_regions_available(uint start, uint num_regions, WorkGang* pretouch_gang) {
166   guarantee(num_regions &gt; 0, &quot;No point in calling this for zero regions&quot;);
167   commit_regions(start, num_regions, pretouch_gang);
168   for (uint i = start; i &lt; start + num_regions; i++) {
169     if (_regions.get_by_index(i) == NULL) {
170       HeapRegion* new_hr = new_heap_region(i);
171       OrderAccess::storestore();
172       _regions.set_by_index(i, new_hr);
173       _allocated_heapregions_length = MAX2(_allocated_heapregions_length, i + 1);
174     }
175   }
176 
177   _available_map.par_set_range(start, start + num_regions, BitMap::unknown_range);
178 
179   for (uint i = start; i &lt; start + num_regions; i++) {
180     assert(is_available(i), &quot;Just made region %u available but is apparently not.&quot;, i);
181     HeapRegion* hr = at(i);
182     if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
183       G1CollectedHeap::heap()-&gt;hr_printer()-&gt;commit(hr);
184     }
<span class="line-removed">185     HeapWord* bottom = G1CollectedHeap::heap()-&gt;bottom_addr_for_region(i);</span>
<span class="line-removed">186     MemRegion mr(bottom, bottom + HeapRegion::GrainWords);</span>
187 
<span class="line-modified">188     hr-&gt;initialize(mr);</span>

189     insert_into_free_list(at(i));
190   }
191 }
192 
193 MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {
194   size_t used_sz =
195     _prev_bitmap_mapper-&gt;committed_size() +
196     _next_bitmap_mapper-&gt;committed_size() +
197     _bot_mapper-&gt;committed_size() +
198     _cardtable_mapper-&gt;committed_size() +
199     _card_counts_mapper-&gt;committed_size();
200 
201   size_t committed_sz =
202     _prev_bitmap_mapper-&gt;reserved_size() +
203     _next_bitmap_mapper-&gt;reserved_size() +
204     _bot_mapper-&gt;reserved_size() +
205     _cardtable_mapper-&gt;reserved_size() +
206     _card_counts_mapper-&gt;reserved_size();
207 
208   return MemoryUsage(0, used_sz, committed_sz, committed_sz);
</pre>
<hr />
<pre>
218   }
219 
220   uint cur = start;
221   uint idx_last_found = 0;
222   uint num_last_found = 0;
223 
224   uint expanded = 0;
225 
226   while (expanded &lt; num_regions &amp;&amp;
227          (num_last_found = find_unavailable_from_idx(cur, &amp;idx_last_found)) &gt; 0) {
228     uint to_expand = MIN2(num_regions - expanded, num_last_found);
229     make_regions_available(idx_last_found, to_expand, pretouch_workers);
230     expanded += to_expand;
231     cur = idx_last_found + num_last_found + 1;
232   }
233 
234   verify_optional();
235   return expanded;
236 }
237 





























238 uint HeapRegionManager::find_contiguous(size_t num, bool empty_only) {
239   uint found = 0;
240   size_t length_found = 0;
241   uint cur = 0;
242 
243   while (length_found &lt; num &amp;&amp; cur &lt; max_length()) {
244     HeapRegion* hr = _regions.get_by_index(cur);
245     if ((!empty_only &amp;&amp; !is_available(cur)) || (is_available(cur) &amp;&amp; hr != NULL &amp;&amp; hr-&gt;is_empty())) {
246       // This region is a potential candidate for allocation into.
247       length_found++;
248     } else {
249       // This region is not a candidate. The next region is the next possible one.
250       found = cur + 1;
251       length_found = 0;
252     }
253     cur++;
254   }
255 
256   if (length_found == num) {
257     for (uint i = found; i &lt; (found + num); i++) {
</pre>
<hr />
<pre>
514 
515   guarantee(num_committed == _num_committed, &quot;Found %u committed regions, but should be %u&quot;, num_committed, _num_committed);
516   _free_list.verify();
517 }
518 
519 #ifndef PRODUCT
520 void HeapRegionManager::verify_optional() {
521   verify();
522 }
523 #endif // PRODUCT
524 
525 HeapRegionClaimer::HeapRegionClaimer(uint n_workers) :
526     _n_workers(n_workers), _n_regions(G1CollectedHeap::heap()-&gt;_hrm-&gt;_allocated_heapregions_length), _claims(NULL) {
527   assert(n_workers &gt; 0, &quot;Need at least one worker.&quot;);
528   uint* new_claims = NEW_C_HEAP_ARRAY(uint, _n_regions, mtGC);
529   memset(new_claims, Unclaimed, sizeof(*_claims) * _n_regions);
530   _claims = new_claims;
531 }
532 
533 HeapRegionClaimer::~HeapRegionClaimer() {
<span class="line-modified">534   if (_claims != NULL) {</span>
<span class="line-removed">535     FREE_C_HEAP_ARRAY(uint, _claims);</span>
<span class="line-removed">536   }</span>
537 }
538 
539 uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {
540   assert(worker_id &lt; _n_workers, &quot;Invalid worker_id.&quot;);
541   return _n_regions * worker_id / _n_workers;
542 }
543 
544 bool HeapRegionClaimer::is_region_claimed(uint region_index) const {
545   assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
546   return _claims[region_index] == Claimed;
547 }
548 
549 bool HeapRegionClaimer::claim_region(uint region_index) {
550   assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
<span class="line-modified">551   uint old_val = Atomic::cmpxchg(Claimed, &amp;_claims[region_index], Unclaimed);</span>
552   return old_val == Unclaimed;
553 }













































































</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
<span class="line-added"> 29 #include &quot;gc/g1/g1NUMAStats.hpp&quot;</span>
 30 #include &quot;gc/g1/heapRegion.hpp&quot;
 31 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
 32 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 33 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
<span class="line-modified"> 34 #include &quot;logging/logStream.hpp&quot;</span>
 35 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 36 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;runtime/orderAccess.hpp&quot;</span>
 38 #include &quot;utilities/bitMap.inline.hpp&quot;
 39 
 40 class MasterFreeRegionListChecker : public HeapRegionSetChecker {
 41 public:
 42   void check_mt_safety() {
 43     // Master Free List MT safety protocol:
 44     // (a) If we&#39;re at a safepoint, operations on the master free list
 45     // should be invoked by either the VM thread (which will serialize
 46     // them) or by the GC workers while holding the
 47     // FreeList_lock.
 48     // (b) If we&#39;re not at a safepoint, operations on the master free
 49     // list should be invoked while holding the Heap_lock.
 50 
 51     if (SafepointSynchronize::is_at_safepoint()) {
 52       guarantee(Thread::current()-&gt;is_VM_thread() ||
 53                 FreeList_lock-&gt;owned_by_self(), &quot;master free list MT safety protocol at a safepoint&quot;);
 54     } else {
 55       guarantee(Heap_lock-&gt;owned_by_self(), &quot;master free list MT safety protocol outside a safepoint&quot;);
 56     }
 57   }
 58   bool is_correct_type(HeapRegion* hr) { return hr-&gt;is_free(); }
 59   const char* get_description() { return &quot;Free Regions&quot;; }
 60 };
 61 
 62 HeapRegionManager::HeapRegionManager() :
 63   _bot_mapper(NULL),
 64   _cardtable_mapper(NULL),
 65   _card_counts_mapper(NULL),
 66   _available_map(mtGC),
 67   _num_committed(0),
 68   _allocated_heapregions_length(0),
 69   _regions(), _heap_mapper(NULL),
 70   _prev_bitmap_mapper(NULL),
 71   _next_bitmap_mapper(NULL),
 72   _free_list(&quot;Free list&quot;, new MasterFreeRegionListChecker())
 73 { }
 74 
<span class="line-modified"> 75 HeapRegionManager* HeapRegionManager::create_manager(G1CollectedHeap* heap) {</span>
<span class="line-modified"> 76   if (G1Arguments::is_heterogeneous_heap()) {</span>
<span class="line-modified"> 77     return new HeterogeneousHeapRegionManager((uint)(G1Arguments::heap_max_size_bytes() / HeapRegion::GrainBytes) /*heap size as num of regions*/);</span>
 78   }
 79   return new HeapRegionManager();
 80 }
 81 
 82 void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,
 83                                G1RegionToSpaceMapper* prev_bitmap,
 84                                G1RegionToSpaceMapper* next_bitmap,
 85                                G1RegionToSpaceMapper* bot,
 86                                G1RegionToSpaceMapper* cardtable,
 87                                G1RegionToSpaceMapper* card_counts) {
 88   _allocated_heapregions_length = 0;
 89 
 90   _heap_mapper = heap_storage;
 91 
 92   _prev_bitmap_mapper = prev_bitmap;
 93   _next_bitmap_mapper = next_bitmap;
 94 
 95   _bot_mapper = bot;
 96   _cardtable_mapper = cardtable;
 97 
 98   _card_counts_mapper = card_counts;
 99 
100   MemRegion reserved = heap_storage-&gt;reserved();
101   _regions.initialize(reserved.start(), reserved.end(), HeapRegion::GrainBytes);
102 
103   _available_map.initialize(_regions.length());
104 }
105 
106 bool HeapRegionManager::is_available(uint region) const {
107   return _available_map.at(region);
108 }
109 
<span class="line-added">110 HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {</span>
<span class="line-added">111   HeapRegion* hr = NULL;</span>
<span class="line-added">112   bool from_head = !type.is_young();</span>
<span class="line-added">113   G1NUMA* numa = G1NUMA::numa();</span>
<span class="line-added">114 </span>
<span class="line-added">115   if (requested_node_index != G1NUMA::AnyNodeIndex &amp;&amp; numa-&gt;is_enabled()) {</span>
<span class="line-added">116     // Try to allocate with requested node index.</span>
<span class="line-added">117     hr = _free_list.remove_region_with_node_index(from_head, requested_node_index);</span>
<span class="line-added">118   }</span>
<span class="line-added">119 </span>
<span class="line-added">120   if (hr == NULL) {</span>
<span class="line-added">121     // If there&#39;s a single active node or we did not get a region from our requested node,</span>
<span class="line-added">122     // try without requested node index.</span>
<span class="line-added">123     hr = _free_list.remove_region(from_head);</span>
<span class="line-added">124   }</span>
<span class="line-added">125 </span>
<span class="line-added">126   if (hr != NULL) {</span>
<span class="line-added">127     assert(hr-&gt;next() == NULL, &quot;Single region should not have next&quot;);</span>
<span class="line-added">128     assert(is_available(hr-&gt;hrm_index()), &quot;Must be committed&quot;);</span>
<span class="line-added">129 </span>
<span class="line-added">130     if (numa-&gt;is_enabled() &amp;&amp; hr-&gt;node_index() &lt; numa-&gt;num_active_nodes()) {</span>
<span class="line-added">131       numa-&gt;update_statistics(G1NUMAStats::NewRegionAlloc, requested_node_index, hr-&gt;node_index());</span>
<span class="line-added">132     }</span>
<span class="line-added">133   }</span>
<span class="line-added">134 </span>
<span class="line-added">135   return hr;</span>
<span class="line-added">136 }</span>
<span class="line-added">137 </span>
138 #ifdef ASSERT
139 bool HeapRegionManager::is_free(HeapRegion* hr) const {
140   return _free_list.contains(hr);
141 }
142 #endif
143 
144 HeapRegion* HeapRegionManager::new_heap_region(uint hrm_index) {
145   G1CollectedHeap* g1h = G1CollectedHeap::heap();
146   HeapWord* bottom = g1h-&gt;bottom_addr_for_region(hrm_index);
147   MemRegion mr(bottom, bottom + HeapRegion::GrainWords);
148   assert(reserved().contains(mr), &quot;invariant&quot;);
149   return g1h-&gt;new_heap_region(hrm_index, mr);
150 }
151 
152 void HeapRegionManager::commit_regions(uint index, size_t num_regions, WorkGang* pretouch_gang) {
153   guarantee(num_regions &gt; 0, &quot;Must commit more than zero regions&quot;);
154   guarantee(_num_committed + num_regions &lt;= max_length(), &quot;Cannot commit more than the maximum amount of regions&quot;);
155 
156   _num_committed += (uint)num_regions;
157 
158   _heap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
159 
160   // Also commit auxiliary data
161   _prev_bitmap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
162   _next_bitmap_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
163 
164   _bot_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
165   _cardtable_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
166 
167   _card_counts_mapper-&gt;commit_regions(index, num_regions, pretouch_gang);
168 }
169 
170 void HeapRegionManager::uncommit_regions(uint start, size_t num_regions) {
171   guarantee(num_regions &gt;= 1, &quot;Need to specify at least one region to uncommit, tried to uncommit zero regions at %u&quot;, start);
172   guarantee(_num_committed &gt;= num_regions, &quot;pre-condition&quot;);
173 
<span class="line-added">174   // Reset node index to distinguish with committed regions.</span>
<span class="line-added">175   for (uint i = start; i &lt; start + num_regions; i++) {</span>
<span class="line-added">176     at(i)-&gt;set_node_index(G1NUMA::UnknownNodeIndex);</span>
<span class="line-added">177   }</span>
<span class="line-added">178 </span>
179   // Print before uncommitting.
180   if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
181     for (uint i = start; i &lt; start + num_regions; i++) {
182       HeapRegion* hr = at(i);
183       G1CollectedHeap::heap()-&gt;hr_printer()-&gt;uncommit(hr);
184     }
185   }
186 
187   _num_committed -= (uint)num_regions;
188 
189   _available_map.par_clear_range(start, start + num_regions, BitMap::unknown_range);
190   _heap_mapper-&gt;uncommit_regions(start, num_regions);
191 
192   // Also uncommit auxiliary data
193   _prev_bitmap_mapper-&gt;uncommit_regions(start, num_regions);
194   _next_bitmap_mapper-&gt;uncommit_regions(start, num_regions);
195 
196   _bot_mapper-&gt;uncommit_regions(start, num_regions);
197   _cardtable_mapper-&gt;uncommit_regions(start, num_regions);
198 
</pre>
<hr />
<pre>
202 void HeapRegionManager::make_regions_available(uint start, uint num_regions, WorkGang* pretouch_gang) {
203   guarantee(num_regions &gt; 0, &quot;No point in calling this for zero regions&quot;);
204   commit_regions(start, num_regions, pretouch_gang);
205   for (uint i = start; i &lt; start + num_regions; i++) {
206     if (_regions.get_by_index(i) == NULL) {
207       HeapRegion* new_hr = new_heap_region(i);
208       OrderAccess::storestore();
209       _regions.set_by_index(i, new_hr);
210       _allocated_heapregions_length = MAX2(_allocated_heapregions_length, i + 1);
211     }
212   }
213 
214   _available_map.par_set_range(start, start + num_regions, BitMap::unknown_range);
215 
216   for (uint i = start; i &lt; start + num_regions; i++) {
217     assert(is_available(i), &quot;Just made region %u available but is apparently not.&quot;, i);
218     HeapRegion* hr = at(i);
219     if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
220       G1CollectedHeap::heap()-&gt;hr_printer()-&gt;commit(hr);
221     }


222 
<span class="line-modified">223     hr-&gt;initialize();</span>
<span class="line-added">224     hr-&gt;set_node_index(G1NUMA::numa()-&gt;index_for_region(hr));</span>
225     insert_into_free_list(at(i));
226   }
227 }
228 
229 MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {
230   size_t used_sz =
231     _prev_bitmap_mapper-&gt;committed_size() +
232     _next_bitmap_mapper-&gt;committed_size() +
233     _bot_mapper-&gt;committed_size() +
234     _cardtable_mapper-&gt;committed_size() +
235     _card_counts_mapper-&gt;committed_size();
236 
237   size_t committed_sz =
238     _prev_bitmap_mapper-&gt;reserved_size() +
239     _next_bitmap_mapper-&gt;reserved_size() +
240     _bot_mapper-&gt;reserved_size() +
241     _cardtable_mapper-&gt;reserved_size() +
242     _card_counts_mapper-&gt;reserved_size();
243 
244   return MemoryUsage(0, used_sz, committed_sz, committed_sz);
</pre>
<hr />
<pre>
254   }
255 
256   uint cur = start;
257   uint idx_last_found = 0;
258   uint num_last_found = 0;
259 
260   uint expanded = 0;
261 
262   while (expanded &lt; num_regions &amp;&amp;
263          (num_last_found = find_unavailable_from_idx(cur, &amp;idx_last_found)) &gt; 0) {
264     uint to_expand = MIN2(num_regions - expanded, num_last_found);
265     make_regions_available(idx_last_found, to_expand, pretouch_workers);
266     expanded += to_expand;
267     cur = idx_last_found + num_last_found + 1;
268   }
269 
270   verify_optional();
271   return expanded;
272 }
273 
<span class="line-added">274 uint HeapRegionManager::expand_on_preferred_node(uint preferred_index) {</span>
<span class="line-added">275   uint expand_candidate = UINT_MAX;</span>
<span class="line-added">276   for (uint i = 0; i &lt; max_length(); i++) {</span>
<span class="line-added">277     if (is_available(i)) {</span>
<span class="line-added">278       // Already in use continue</span>
<span class="line-added">279       continue;</span>
<span class="line-added">280     }</span>
<span class="line-added">281     // Always save the candidate so we can expand later on.</span>
<span class="line-added">282     expand_candidate = i;</span>
<span class="line-added">283     if (is_on_preferred_index(expand_candidate, preferred_index)) {</span>
<span class="line-added">284       // We have found a candidate on the preffered node, break.</span>
<span class="line-added">285       break;</span>
<span class="line-added">286     }</span>
<span class="line-added">287   }</span>
<span class="line-added">288 </span>
<span class="line-added">289   if (expand_candidate == UINT_MAX) {</span>
<span class="line-added">290      // No regions left, expand failed.</span>
<span class="line-added">291     return 0;</span>
<span class="line-added">292   }</span>
<span class="line-added">293 </span>
<span class="line-added">294   make_regions_available(expand_candidate, 1, NULL);</span>
<span class="line-added">295   return 1;</span>
<span class="line-added">296 }</span>
<span class="line-added">297 </span>
<span class="line-added">298 bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {</span>
<span class="line-added">299   uint region_node_index = G1NUMA::numa()-&gt;preferred_node_index_for_index(region_index);</span>
<span class="line-added">300   return region_node_index == preferred_node_index;</span>
<span class="line-added">301 }</span>
<span class="line-added">302 </span>
303 uint HeapRegionManager::find_contiguous(size_t num, bool empty_only) {
304   uint found = 0;
305   size_t length_found = 0;
306   uint cur = 0;
307 
308   while (length_found &lt; num &amp;&amp; cur &lt; max_length()) {
309     HeapRegion* hr = _regions.get_by_index(cur);
310     if ((!empty_only &amp;&amp; !is_available(cur)) || (is_available(cur) &amp;&amp; hr != NULL &amp;&amp; hr-&gt;is_empty())) {
311       // This region is a potential candidate for allocation into.
312       length_found++;
313     } else {
314       // This region is not a candidate. The next region is the next possible one.
315       found = cur + 1;
316       length_found = 0;
317     }
318     cur++;
319   }
320 
321   if (length_found == num) {
322     for (uint i = found; i &lt; (found + num); i++) {
</pre>
<hr />
<pre>
579 
580   guarantee(num_committed == _num_committed, &quot;Found %u committed regions, but should be %u&quot;, num_committed, _num_committed);
581   _free_list.verify();
582 }
583 
584 #ifndef PRODUCT
585 void HeapRegionManager::verify_optional() {
586   verify();
587 }
588 #endif // PRODUCT
589 
590 HeapRegionClaimer::HeapRegionClaimer(uint n_workers) :
591     _n_workers(n_workers), _n_regions(G1CollectedHeap::heap()-&gt;_hrm-&gt;_allocated_heapregions_length), _claims(NULL) {
592   assert(n_workers &gt; 0, &quot;Need at least one worker.&quot;);
593   uint* new_claims = NEW_C_HEAP_ARRAY(uint, _n_regions, mtGC);
594   memset(new_claims, Unclaimed, sizeof(*_claims) * _n_regions);
595   _claims = new_claims;
596 }
597 
598 HeapRegionClaimer::~HeapRegionClaimer() {
<span class="line-modified">599   FREE_C_HEAP_ARRAY(uint, _claims);</span>


600 }
601 
602 uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {
603   assert(worker_id &lt; _n_workers, &quot;Invalid worker_id.&quot;);
604   return _n_regions * worker_id / _n_workers;
605 }
606 
607 bool HeapRegionClaimer::is_region_claimed(uint region_index) const {
608   assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
609   return _claims[region_index] == Claimed;
610 }
611 
612 bool HeapRegionClaimer::claim_region(uint region_index) {
613   assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
<span class="line-modified">614   uint old_val = Atomic::cmpxchg(&amp;_claims[region_index], Unclaimed, Claimed);</span>
615   return old_val == Unclaimed;
616 }
<span class="line-added">617 </span>
<span class="line-added">618 class G1RebuildFreeListTask : public AbstractGangTask {</span>
<span class="line-added">619   HeapRegionManager* _hrm;</span>
<span class="line-added">620   FreeRegionList*    _worker_freelists;</span>
<span class="line-added">621   uint               _worker_chunk_size;</span>
<span class="line-added">622   uint               _num_workers;</span>
<span class="line-added">623 </span>
<span class="line-added">624 public:</span>
<span class="line-added">625   G1RebuildFreeListTask(HeapRegionManager* hrm, uint num_workers) :</span>
<span class="line-added">626       AbstractGangTask(&quot;G1 Rebuild Free List Task&quot;),</span>
<span class="line-added">627       _hrm(hrm),</span>
<span class="line-added">628       _worker_freelists(NEW_C_HEAP_ARRAY(FreeRegionList, num_workers, mtGC)),</span>
<span class="line-added">629       _worker_chunk_size((_hrm-&gt;max_length() + num_workers - 1) / num_workers),</span>
<span class="line-added">630       _num_workers(num_workers) {</span>
<span class="line-added">631     for (uint worker = 0; worker &lt; _num_workers; worker++) {</span>
<span class="line-added">632       ::new (&amp;_worker_freelists[worker]) FreeRegionList(&quot;Appendable Worker Free List&quot;);</span>
<span class="line-added">633     }</span>
<span class="line-added">634   }</span>
<span class="line-added">635 </span>
<span class="line-added">636   ~G1RebuildFreeListTask() {</span>
<span class="line-added">637     for (uint worker = 0; worker &lt; _num_workers; worker++) {</span>
<span class="line-added">638       _worker_freelists[worker].~FreeRegionList();</span>
<span class="line-added">639     }</span>
<span class="line-added">640     FREE_C_HEAP_ARRAY(FreeRegionList, _worker_freelists);</span>
<span class="line-added">641   }</span>
<span class="line-added">642 </span>
<span class="line-added">643   FreeRegionList* worker_freelist(uint worker) {</span>
<span class="line-added">644     return &amp;_worker_freelists[worker];</span>
<span class="line-added">645   }</span>
<span class="line-added">646 </span>
<span class="line-added">647   // Each worker creates a free list for a chunk of the heap. The chunks won&#39;t</span>
<span class="line-added">648   // be overlapping so we don&#39;t need to do any claiming.</span>
<span class="line-added">649   void work(uint worker_id) {</span>
<span class="line-added">650     Ticks start_time = Ticks::now();</span>
<span class="line-added">651     EventGCPhaseParallel event;</span>
<span class="line-added">652 </span>
<span class="line-added">653     uint start = worker_id * _worker_chunk_size;</span>
<span class="line-added">654     uint end = MIN2(start + _worker_chunk_size, _hrm-&gt;max_length());</span>
<span class="line-added">655 </span>
<span class="line-added">656     // If start is outside the heap, this worker has nothing to do.</span>
<span class="line-added">657     if (start &gt; end) {</span>
<span class="line-added">658       return;</span>
<span class="line-added">659     }</span>
<span class="line-added">660 </span>
<span class="line-added">661     FreeRegionList *free_list = worker_freelist(worker_id);</span>
<span class="line-added">662     for (uint i = start; i &lt; end; i++) {</span>
<span class="line-added">663       HeapRegion *region = _hrm-&gt;at_or_null(i);</span>
<span class="line-added">664       if (region != NULL &amp;&amp; region-&gt;is_free()) {</span>
<span class="line-added">665         // Need to clear old links to allow to be added to new freelist.</span>
<span class="line-added">666         region-&gt;unlink_from_list();</span>
<span class="line-added">667         free_list-&gt;add_to_tail(region);</span>
<span class="line-added">668       }</span>
<span class="line-added">669     }</span>
<span class="line-added">670 </span>
<span class="line-added">671     event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::RebuildFreeList));</span>
<span class="line-added">672     G1CollectedHeap::heap()-&gt;phase_times()-&gt;record_time_secs(G1GCPhaseTimes::RebuildFreeList, worker_id, (Ticks::now() - start_time).seconds());</span>
<span class="line-added">673   }</span>
<span class="line-added">674 };</span>
<span class="line-added">675 </span>
<span class="line-added">676 void HeapRegionManager::rebuild_free_list(WorkGang* workers) {</span>
<span class="line-added">677   // Abandon current free list to allow a rebuild.</span>
<span class="line-added">678   _free_list.abandon();</span>
<span class="line-added">679 </span>
<span class="line-added">680   uint const num_workers = clamp(max_length(), 1u, workers-&gt;active_workers());</span>
<span class="line-added">681   G1RebuildFreeListTask task(this, num_workers);</span>
<span class="line-added">682 </span>
<span class="line-added">683   log_debug(gc, ergo)(&quot;Running %s using %u workers for rebuilding free list of %u (%u) regions&quot;,</span>
<span class="line-added">684                       task.name(), num_workers, num_free_regions(), max_length());</span>
<span class="line-added">685   workers-&gt;run_task(&amp;task, num_workers);</span>
<span class="line-added">686 </span>
<span class="line-added">687   // Link the partial free lists together.</span>
<span class="line-added">688   Ticks serial_time = Ticks::now();</span>
<span class="line-added">689   for (uint worker = 0; worker &lt; num_workers; worker++) {</span>
<span class="line-added">690     _free_list.append_ordered(task.worker_freelist(worker));</span>
<span class="line-added">691   }</span>
<span class="line-added">692   G1CollectedHeap::heap()-&gt;phase_times()-&gt;record_serial_rebuild_freelist_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);</span>
<span class="line-added">693 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="heapRegion.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
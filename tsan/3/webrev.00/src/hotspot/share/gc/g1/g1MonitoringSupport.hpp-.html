<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1MonitoringSupport.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1MONITORINGSUPPORT_HPP
 26 #define SHARE_GC_G1_G1MONITORINGSUPPORT_HPP
 27 
 28 #include &quot;gc/shared/collectorCounters.hpp&quot;
 29 #include &quot;gc/shared/generationCounters.hpp&quot;
 30 #include &quot;services/memoryManager.hpp&quot;
 31 #include &quot;services/memoryService.hpp&quot;
 32 #include &quot;runtime/mutex.hpp&quot;
 33 
 34 class CollectorCounters;
 35 class G1CollectedHeap;
 36 class HSpaceCounters;
 37 class MemoryPool;
 38 
 39 // Class for monitoring logical spaces in G1. It provides data for
 40 // both G1&#39;s jstat counters as well as G1&#39;s memory pools.
 41 //
 42 // G1 splits the heap into heap regions and each heap region belongs
 43 // to one of the following categories:
 44 //
 45 // * eden      : regions that have been allocated since the last GC
 46 // * survivors : regions with objects that survived the last few GCs
 47 // * old       : long-lived non-humongous regions
 48 // * humongous : humongous regions
 49 // * free      : free regions
 50 //
 51 // The combination of eden and survivor regions form the equivalent of
 52 // the young generation in the other GCs. The combination of old and
 53 // humongous regions form the equivalent of the old generation in the
 54 // other GCs. Free regions do not have a good equivalent in the other
 55 // GCs given that they can be allocated as any of the other region types.
 56 //
 57 // The monitoring tools expect the heap to contain a number of
 58 // generations (young, old, perm) and each generation to contain a
 59 // number of spaces (young: eden, survivors, old). Given that G1 does
 60 // not maintain those spaces physically (e.g., the set of
 61 // non-contiguous eden regions can be considered as a &quot;logical&quot;
 62 // space), we&#39;ll provide the illusion that those generations and
 63 // spaces exist. In reality, each generation and space refers to a set
 64 // of heap regions that are potentially non-contiguous.
 65 //
 66 // This class provides interfaces to access the min, current, and max
 67 // capacity and current occupancy for each of G1&#39;s logical spaces and
 68 // generations we expose to the monitoring tools. Also provided are
 69 // counters for G1 concurrent collections and stop-the-world full heap
 70 // collections.
 71 //
 72 // Below is a description of how the various sizes are calculated.
 73 //
 74 // * Current Capacity
 75 //
 76 //    - heap_capacity = current heap capacity (e.g., current committed size)
 77 //    - young_gen_capacity = current max young gen target capacity
 78 //          (i.e., young gen target capacity + max allowed expansion capacity)
 79 //    - survivor_capacity = current survivor region capacity
 80 //    - eden_capacity = young_gen_capacity - survivor_capacity
 81 //    - old_capacity = heap_capacity - young_gen_capacity
 82 //
 83 //    What we do in the above is to distribute the free regions among
 84 //    eden_capacity and old_capacity.
 85 //
 86 // * Occupancy
 87 //
 88 //    - young_gen_used = current young region capacity
 89 //    - survivor_used = survivor_capacity
 90 //    - eden_used = young_gen_used - survivor_used
 91 //    - old_used = overall_used - young_gen_used
 92 //
 93 //    Unfortunately, we currently only keep track of the number of
 94 //    currently allocated young and survivor regions + the overall used
 95 //    bytes in the heap, so the above can be a little inaccurate.
 96 //
 97 // * Min Capacity
 98 //
 99 //    We set this to 0 for all spaces.
100 //
101 // * Max Capacity
102 //
103 //    For jstat, we set the max capacity of all spaces to heap_capacity,
104 //    given that we don&#39;t always have a reasonable upper bound on how big
105 //    each space can grow. For the memory pools, we make the max
106 //    capacity undefined with the exception of the old memory pool for
107 //    which we make the max capacity same as the max heap capacity.
108 //
109 // If we had more accurate occupancy / capacity information per
110 // region set the above calculations would be greatly simplified and
111 // be made more accurate.
112 //
113 // We update all the above synchronously and we store the results in
114 // fields so that we just read said fields when needed. A subtle point
115 // is that all the above sizes need to be recalculated when the old
116 // gen changes capacity (after a GC or after a humongous allocation)
117 // but only the eden occupancy changes when a new eden region is
118 // allocated. So, in the latter case we have minimal recalculation to
119 // do which is important as we want to keep the eden region allocation
120 // path as low-overhead as possible.
121 
122 class G1MonitoringSupport : public CHeapObj&lt;mtGC&gt; {
123   friend class VMStructs;
124   friend class G1MonitoringScope;
125 
126   G1CollectedHeap* _g1h;
127 
128   // java.lang.management MemoryManager and MemoryPool support
129   GCMemoryManager _incremental_memory_manager;
130   GCMemoryManager _full_gc_memory_manager;
131 
132   MemoryPool* _eden_space_pool;
133   MemoryPool* _survivor_space_pool;
134   MemoryPool* _old_gen_pool;
135 
136   // jstat performance counters
137   //  incremental collections both young and mixed
138   CollectorCounters*   _incremental_collection_counters;
139   //  full stop-the-world collections
140   CollectorCounters*   _full_collection_counters;
141   //  stop-the-world phases in G1
142   CollectorCounters*   _conc_collection_counters;
143   //  young collection set counters.  The _eden_counters,
144   // _from_counters, and _to_counters are associated with
145   // this &quot;generational&quot; counter.
146   GenerationCounters*  _young_gen_counters;
147   //  old collection set counters. The _old_space_counters
148   // below are associated with this &quot;generational&quot; counter.
149   GenerationCounters*  _old_gen_counters;
150   // Counters for the capacity and used for
151   //   the whole heap
152   HSpaceCounters*      _old_space_counters;
153   //   the young collection
154   HSpaceCounters*      _eden_space_counters;
155   //   the survivor collection (only one, _to_counters, is actively used)
156   HSpaceCounters*      _from_space_counters;
157   HSpaceCounters*      _to_space_counters;
158 
159   // When it&#39;s appropriate to recalculate the various sizes (at the
160   // end of a GC, when a new eden region is allocated, etc.) we store
161   // them here so that we can easily report them when needed and not
162   // have to recalculate them every time.
163 
164   size_t _overall_committed;
165   size_t _overall_used;
166 
167   size_t _young_gen_committed;
168   size_t _old_gen_committed;
169 
170   size_t _eden_space_committed;
171   size_t _eden_space_used;
172   size_t _survivor_space_committed;
173   size_t _survivor_space_used;
174 
175   size_t _old_gen_used;
176 
177   // It returns x - y if x &gt; y, 0 otherwise.
178   // As described in the comment above, some of the inputs to the
179   // calculations we have to do are obtained concurrently and hence
180   // may be inconsistent with each other. So, this provides a
181   // defensive way of performing the subtraction and avoids the value
182   // going negative (which would mean a very large result, given that
183   // the parameter are size_t).
184   static size_t subtract_up_to_zero(size_t x, size_t y) {
185     if (x &gt; y) {
186       return x - y;
187     } else {
188       return 0;
189     }
190   }
191 
192   // Recalculate all the sizes.
193   void recalculate_sizes();
194 
195   void recalculate_eden_size();
196 
197 public:
198   G1MonitoringSupport(G1CollectedHeap* g1h);
199   ~G1MonitoringSupport();
200 
201   void initialize_serviceability();
202 
203   MemoryUsage memory_usage();
204   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
205   GrowableArray&lt;MemoryPool*&gt; memory_pools();
206 
207   // Unfortunately, the jstat tool assumes that no space has 0
208   // capacity. In our case, given that each space is logical, it&#39;s
209   // possible that no regions will be allocated to it, hence to have 0
210   // capacity (e.g., if there are no survivor regions, the survivor
211   // space has 0 capacity). The way we deal with this is to always pad
212   // each capacity value we report to jstat by a very small amount to
213   // make sure that it&#39;s never zero. Given that we sometimes have to
214   // report a capacity of a generation that contains several spaces
215   // (e.g., young gen includes one eden, two survivor spaces), the
216   // mult parameter is provided in order to adding the appropriate
217   // padding multiple times so that the capacities add up correctly.
218   static size_t pad_capacity(size_t size_bytes, size_t mult = 1) {
219     return size_bytes + MinObjAlignmentInBytes * mult;
220   }
221 
222   // Recalculate all the sizes from scratch and update all the jstat
223   // counters accordingly.
224   void update_sizes();
225 
226   void update_eden_size();
227 
228   CollectorCounters* conc_collection_counters() {
229     return _conc_collection_counters;
230   }
231 
232   // Monitoring support used by
233   //   MemoryService
234   //   jstat counters
235   //   Tracing
236   // Values may not be consistent wrt to each other.
237 
238   size_t young_gen_committed()        { return _young_gen_committed; }
239 
240   size_t eden_space_used()            { return _eden_space_used; }
241   size_t survivor_space_used()        { return _survivor_space_used; }
242 
243   size_t old_gen_committed()          { return _old_gen_committed; }
244   size_t old_gen_used()               { return _old_gen_used; }
245 
246   // Monitoring support for MemoryPools. Values in the returned MemoryUsage are
247   // guaranteed to be consistent with each other.
248   MemoryUsage eden_space_memory_usage(size_t initial_size, size_t max_size);
249   MemoryUsage survivor_space_memory_usage(size_t initial_size, size_t max_size);
250 
251   MemoryUsage old_gen_memory_usage(size_t initial_size, size_t max_size);
252 };
253 
254 // Scope object for java.lang.management support.
255 class G1MonitoringScope : public StackObj {
256   TraceCollectorStats _tcs;
257   TraceMemoryManagerStats _tms;
258 public:
259   G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected);
260 };
261 
262 #endif // SHARE_GC_G1_G1MONITORINGSUPPORT_HPP
    </pre>
  </body>
</html>
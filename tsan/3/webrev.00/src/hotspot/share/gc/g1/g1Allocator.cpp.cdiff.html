<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1AllocRegion.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Allocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,34 ***</span>
  #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
  #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
  #include &quot;gc/g1/g1EvacStats.inline.hpp&quot;
  #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionType.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  G1Allocator::G1Allocator(G1CollectedHeap* heap) :
    _g1h(heap),
    _survivor_is_full(false),
    _old_is_full(false),
<span class="line-modified">!   _mutator_alloc_region(),</span>
<span class="line-modified">!   _survivor_gc_alloc_region(heap-&gt;alloc_buffer_stats(InCSetState::Young)),</span>
<span class="line-modified">!   _old_gc_alloc_region(heap-&gt;alloc_buffer_stats(InCSetState::Old)),</span>
    _retained_old_gc_alloc_region(NULL) {
  }
  
<span class="line-modified">! void G1Allocator::init_mutator_alloc_region() {</span>
<span class="line-modified">!   assert(_mutator_alloc_region.get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-modified">!   _mutator_alloc_region.init();</span>
  }
  
<span class="line-modified">! void G1Allocator::release_mutator_alloc_region() {</span>
<span class="line-modified">!   _mutator_alloc_region.release();</span>
<span class="line-modified">!   assert(_mutator_alloc_region.get() == NULL, &quot;post-condition&quot;);</span>
  }
  
  bool G1Allocator::is_retained_old_region(HeapRegion* hr) {
    return _retained_old_gc_alloc_region == hr;
  }
<span class="line-new-header">--- 26,66 ---</span>
  #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
  #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
  #include &quot;gc/g1/g1EvacStats.inline.hpp&quot;
  #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionType.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  G1Allocator::G1Allocator(G1CollectedHeap* heap) :
    _g1h(heap),
<span class="line-added">+   _numa(heap-&gt;numa()),</span>
    _survivor_is_full(false),
    _old_is_full(false),
<span class="line-modified">!   _num_alloc_regions(_numa-&gt;num_active_nodes()),</span>
<span class="line-modified">!   _mutator_alloc_regions(NULL),</span>
<span class="line-modified">!   _survivor_gc_alloc_regions(NULL),</span>
<span class="line-added">+   _old_gc_alloc_region(heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Old)),</span>
    _retained_old_gc_alloc_region(NULL) {
<span class="line-added">+ </span>
<span class="line-added">+   _mutator_alloc_regions = NEW_C_HEAP_ARRAY(MutatorAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added">+   _survivor_gc_alloc_regions = NEW_C_HEAP_ARRAY(SurvivorGCAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added">+   G1EvacStats* stat = heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Young);</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     ::new(_mutator_alloc_regions + i) MutatorAllocRegion(i);</span>
<span class="line-added">+     ::new(_survivor_gc_alloc_regions + i) SurvivorGCAllocRegion(stat, i);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! G1Allocator::~G1Allocator() {</span>
<span class="line-modified">!   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-modified">!     _mutator_alloc_regions[i].~MutatorAllocRegion();</span>
<span class="line-added">+     _survivor_gc_alloc_regions[i].~SurvivorGCAllocRegion();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(MutatorAllocRegion, _mutator_alloc_regions);</span>
<span class="line-added">+   FREE_C_HEAP_ARRAY(SurvivorGCAllocRegion, _survivor_gc_alloc_regions);</span>
  }
  
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">! bool G1Allocator::has_mutator_alloc_region() {</span>
<span class="line-modified">!   uint node_index = current_node_index();</span>
<span class="line-added">+   return mutator_alloc_region(node_index)-&gt;get() != NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1Allocator::init_mutator_alloc_regions() {</span>
<span class="line-added">+   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">+     mutator_alloc_region(i)-&gt;init();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1Allocator::release_mutator_alloc_regions() {</span>
<span class="line-added">+   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     mutator_alloc_region(i)-&gt;release();</span>
<span class="line-added">+     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;post-condition&quot;);</span>
<span class="line-added">+   }</span>
  }
  
  bool G1Allocator::is_retained_old_region(HeapRegion* hr) {
    return _retained_old_gc_alloc_region == hr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,31 ***</span>
    assert_at_safepoint_on_vm_thread();
  
    _survivor_is_full = false;
    _old_is_full = false;
  
<span class="line-modified">!   _survivor_gc_alloc_region.init();</span>
    _old_gc_alloc_region.init();
    reuse_retained_old_region(evacuation_info,
                              &amp;_old_gc_alloc_region,
                              &amp;_retained_old_gc_alloc_region);
  }
  
  void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
<span class="line-modified">!   evacuation_info.set_allocation_regions(survivor_gc_alloc_region()-&gt;count() +</span>
                                           old_gc_alloc_region()-&gt;count());
<span class="line-modified">!   survivor_gc_alloc_region()-&gt;release();</span>
    // If we have an old GC alloc region to release, we&#39;ll save it in
    // _retained_old_gc_alloc_region. If we don&#39;t
    // _retained_old_gc_alloc_region will become NULL. This is what we
    // want either way so no reason to check explicitly for either
    // condition.
    _retained_old_gc_alloc_region = old_gc_alloc_region()-&gt;release();
  }
  
  void G1Allocator::abandon_gc_alloc_regions() {
<span class="line-modified">!   assert(survivor_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
    assert(old_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);
    _retained_old_gc_alloc_region = NULL;
  }
  
  bool G1Allocator::survivor_is_full() const {
<span class="line-new-header">--- 127,41 ---</span>
    assert_at_safepoint_on_vm_thread();
  
    _survivor_is_full = false;
    _old_is_full = false;
  
<span class="line-modified">!   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     survivor_gc_alloc_region(i)-&gt;init();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    _old_gc_alloc_region.init();
    reuse_retained_old_region(evacuation_info,
                              &amp;_old_gc_alloc_region,
                              &amp;_retained_old_gc_alloc_region);
  }
  
  void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
<span class="line-modified">!   uint survivor_region_count = 0;</span>
<span class="line-added">+   for (uint node_index = 0; node_index &lt; _num_alloc_regions; node_index++) {</span>
<span class="line-added">+     survivor_region_count += survivor_gc_alloc_region(node_index)-&gt;count();</span>
<span class="line-added">+     survivor_gc_alloc_region(node_index)-&gt;release();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   evacuation_info.set_allocation_regions(survivor_region_count +</span>
                                           old_gc_alloc_region()-&gt;count());
<span class="line-modified">! </span>
    // If we have an old GC alloc region to release, we&#39;ll save it in
    // _retained_old_gc_alloc_region. If we don&#39;t
    // _retained_old_gc_alloc_region will become NULL. This is what we
    // want either way so no reason to check explicitly for either
    // condition.
    _retained_old_gc_alloc_region = old_gc_alloc_region()-&gt;release();
  }
  
  void G1Allocator::abandon_gc_alloc_regions() {
<span class="line-modified">!   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     assert(survivor_gc_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">+   }</span>
    assert(old_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);
    _retained_old_gc_alloc_region = NULL;
  }
  
  bool G1Allocator::survivor_is_full() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,64 ***</span>
  
    // Also, this value can be at most the humongous object threshold,
    // since we can&#39;t allow tlabs to grow big enough to accommodate
    // humongous objects.
  
<span class="line-modified">!   HeapRegion* hr = mutator_alloc_region()-&gt;get();</span>
    size_t max_tlab = _g1h-&gt;max_tlab_size() * wordSize;
    if (hr == NULL) {
      return max_tlab;
    } else {
<span class="line-modified">!     return MIN2(MAX2(hr-&gt;free(), (size_t) MinTLABSize), max_tlab);</span>
    }
  }
  
  size_t G1Allocator::used_in_alloc_regions() {
    assert(Heap_lock-&gt;owner() != NULL, &quot;Should be owned on this thread&#39;s behalf.&quot;);
<span class="line-modified">!   return mutator_alloc_region()-&gt;used_in_alloc_regions();</span>
  }
  
  
<span class="line-modified">! HeapWord* G1Allocator::par_allocate_during_gc(InCSetState dest,</span>
<span class="line-modified">!                                               size_t word_size) {</span>
    size_t temp = 0;
<span class="line-modified">!   HeapWord* result = par_allocate_during_gc(dest, word_size, word_size, &amp;temp);</span>
    assert(result == NULL || temp == word_size,
           &quot;Requested &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
           word_size, temp, p2i(result));
    return result;
  }
  
<span class="line-modified">! HeapWord* G1Allocator::par_allocate_during_gc(InCSetState dest,</span>
                                                size_t min_word_size,
                                                size_t desired_word_size,
<span class="line-modified">!                                               size_t* actual_word_size) {</span>
<span class="line-modified">!   switch (dest.value()) {</span>
<span class="line-modified">!     case InCSetState::Young:</span>
<span class="line-modified">!       return survivor_attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
<span class="line-modified">!     case InCSetState::Old:</span>
        return old_attempt_allocation(min_word_size, desired_word_size, actual_word_size);
      default:
        ShouldNotReachHere();
        return NULL; // Keep some compilers happy
    }
  }
  
  HeapWord* G1Allocator::survivor_attempt_allocation(size_t min_word_size,
                                                     size_t desired_word_size,
<span class="line-modified">!                                                    size_t* actual_word_size) {</span>
    assert(!_g1h-&gt;is_humongous(desired_word_size),
           &quot;we should not be seeing humongous-size allocations in this path&quot;);
  
<span class="line-modified">!   HeapWord* result = survivor_gc_alloc_region()-&gt;attempt_allocation(min_word_size,</span>
<span class="line-modified">!                                                                     desired_word_size,</span>
<span class="line-modified">!                                                                     actual_word_size);</span>
    if (result == NULL &amp;&amp; !survivor_is_full()) {
<span class="line-modified">!     MutexLockerEx x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     result = survivor_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,</span>
<span class="line-modified">!                                                                    desired_word_size,</span>
<span class="line-modified">!                                                                    actual_word_size);</span>
      if (result == NULL) {
        set_survivor_full();
      }
    }
    if (result != NULL) {
<span class="line-new-header">--- 186,72 ---</span>
  
    // Also, this value can be at most the humongous object threshold,
    // since we can&#39;t allow tlabs to grow big enough to accommodate
    // humongous objects.
  
<span class="line-modified">!   uint node_index = current_node_index();</span>
<span class="line-added">+   HeapRegion* hr = mutator_alloc_region(node_index)-&gt;get();</span>
    size_t max_tlab = _g1h-&gt;max_tlab_size() * wordSize;
    if (hr == NULL) {
      return max_tlab;
    } else {
<span class="line-modified">!     return clamp(hr-&gt;free(), MinTLABSize, max_tlab);</span>
    }
  }
  
  size_t G1Allocator::used_in_alloc_regions() {
    assert(Heap_lock-&gt;owner() != NULL, &quot;Should be owned on this thread&#39;s behalf.&quot;);
<span class="line-modified">!   size_t used = 0;</span>
<span class="line-added">+   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">+     used += mutator_alloc_region(i)-&gt;used_in_alloc_regions();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return used;</span>
  }
  
  
<span class="line-modified">! HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
<span class="line-modified">!                                               size_t word_size,</span>
<span class="line-added">+                                               uint node_index) {</span>
    size_t temp = 0;
<span class="line-modified">!   HeapWord* result = par_allocate_during_gc(dest, word_size, word_size, &amp;temp, node_index);</span>
    assert(result == NULL || temp == word_size,
           &quot;Requested &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
           word_size, temp, p2i(result));
    return result;
  }
  
<span class="line-modified">! HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
                                                size_t min_word_size,
                                                size_t desired_word_size,
<span class="line-modified">!                                               size_t* actual_word_size,</span>
<span class="line-modified">!                                               uint node_index) {</span>
<span class="line-modified">!   switch (dest.type()) {</span>
<span class="line-modified">!     case G1HeapRegionAttr::Young:</span>
<span class="line-modified">!       return survivor_attempt_allocation(min_word_size, desired_word_size, actual_word_size, node_index);</span>
<span class="line-added">+     case G1HeapRegionAttr::Old:</span>
        return old_attempt_allocation(min_word_size, desired_word_size, actual_word_size);
      default:
        ShouldNotReachHere();
        return NULL; // Keep some compilers happy
    }
  }
  
  HeapWord* G1Allocator::survivor_attempt_allocation(size_t min_word_size,
                                                     size_t desired_word_size,
<span class="line-modified">!                                                    size_t* actual_word_size,</span>
<span class="line-added">+                                                    uint node_index) {</span>
    assert(!_g1h-&gt;is_humongous(desired_word_size),
           &quot;we should not be seeing humongous-size allocations in this path&quot;);
  
<span class="line-modified">!   HeapWord* result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation(min_word_size,</span>
<span class="line-modified">!                                                                               desired_word_size,</span>
<span class="line-modified">!                                                                               actual_word_size);</span>
    if (result == NULL &amp;&amp; !survivor_is_full()) {
<span class="line-modified">!     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">!     result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation_locked(min_word_size,</span>
<span class="line-modified">!                                                                              desired_word_size,</span>
<span class="line-modified">!                                                                              actual_word_size);</span>
      if (result == NULL) {
        set_survivor_full();
      }
    }
    if (result != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,11 ***</span>
  
    HeapWord* result = old_gc_alloc_region()-&gt;attempt_allocation(min_word_size,
                                                                 desired_word_size,
                                                                 actual_word_size);
    if (result == NULL &amp;&amp; !old_is_full()) {
<span class="line-modified">!     MutexLockerEx x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
      result = old_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,
                                                                desired_word_size,
                                                                actual_word_size);
      if (result == NULL) {
        set_old_full();
<span class="line-new-header">--- 268,11 ---</span>
  
    HeapWord* result = old_gc_alloc_region()-&gt;attempt_allocation(min_word_size,
                                                                 desired_word_size,
                                                                 actual_word_size);
    if (result == NULL &amp;&amp; !old_is_full()) {
<span class="line-modified">!     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
      result = old_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,
                                                                desired_word_size,
                                                                actual_word_size);
      if (result == NULL) {
        set_old_full();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,44 ***</span>
  }
  
  G1PLABAllocator::G1PLABAllocator(G1Allocator* allocator) :
    _g1h(G1CollectedHeap::heap()),
    _allocator(allocator),
<span class="line-removed">-   _surviving_alloc_buffer(_g1h-&gt;desired_plab_sz(InCSetState::Young)),</span>
<span class="line-removed">-   _tenured_alloc_buffer(_g1h-&gt;desired_plab_sz(InCSetState::Old)),</span>
    _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {
<span class="line-modified">!   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
      _direct_allocated[state] = 0;
<span class="line-modified">!     _alloc_buffers[state] = NULL;</span>
    }
<span class="line-removed">-   _alloc_buffers[InCSetState::Young] = &amp;_surviving_alloc_buffer;</span>
<span class="line-removed">-   _alloc_buffers[InCSetState::Old]  = &amp;_tenured_alloc_buffer;</span>
  }
  
  bool G1PLABAllocator::may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const {
    return (allocation_word_sz * 100 &lt; buffer_size * ParallelGCBufferWastePct);
  }
  
<span class="line-modified">! HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(InCSetState dest,</span>
                                                         size_t word_sz,
<span class="line-modified">!                                                        bool* plab_refill_failed) {</span>
    size_t plab_word_size = _g1h-&gt;desired_plab_sz(dest);
    size_t required_in_plab = PLAB::size_required_for_allocation(word_sz);
  
    // Only get a new PLAB if the allocation fits and it would not waste more than
    // ParallelGCBufferWastePct in the existing buffer.
    if ((required_in_plab &lt;= plab_word_size) &amp;&amp;
      may_throw_away_buffer(required_in_plab, plab_word_size)) {
  
<span class="line-modified">!     PLAB* alloc_buf = alloc_buffer(dest);</span>
      alloc_buf-&gt;retire();
  
      size_t actual_plab_size = 0;
      HeapWord* buf = _allocator-&gt;par_allocate_during_gc(dest,
                                                         required_in_plab,
                                                         plab_word_size,
<span class="line-modified">!                                                        &amp;actual_plab_size);</span>
  
      assert(buf == NULL || ((actual_plab_size &gt;= required_in_plab) &amp;&amp; (actual_plab_size &lt;= plab_word_size)),
             &quot;Requested at minimum &quot; SIZE_FORMAT &quot;, desired &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
             required_in_plab, plab_word_size, actual_plab_size, p2i(buf));
  
<span class="line-new-header">--- 294,56 ---</span>
  }
  
  G1PLABAllocator::G1PLABAllocator(G1Allocator* allocator) :
    _g1h(G1CollectedHeap::heap()),
    _allocator(allocator),
    _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {
<span class="line-modified">!   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
      _direct_allocated[state] = 0;
<span class="line-modified">!     uint length = alloc_buffers_length(state);</span>
<span class="line-added">+     _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);</span>
<span class="line-added">+     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">+       _alloc_buffers[state][node_index] = new PLAB(_g1h-&gt;desired_plab_sz(state));</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ G1PLABAllocator::~G1PLABAllocator() {</span>
<span class="line-added">+   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-added">+     uint length = alloc_buffers_length(state);</span>
<span class="line-added">+     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">+       delete _alloc_buffers[state][node_index];</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(PLAB*, _alloc_buffers[state]);</span>
    }
  }
  
  bool G1PLABAllocator::may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const {
    return (allocation_word_sz * 100 &lt; buffer_size * ParallelGCBufferWastePct);
  }
  
<span class="line-modified">! HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(G1HeapRegionAttr dest,</span>
                                                         size_t word_sz,
<span class="line-modified">!                                                        bool* plab_refill_failed,</span>
<span class="line-added">+                                                        uint node_index) {</span>
    size_t plab_word_size = _g1h-&gt;desired_plab_sz(dest);
    size_t required_in_plab = PLAB::size_required_for_allocation(word_sz);
  
    // Only get a new PLAB if the allocation fits and it would not waste more than
    // ParallelGCBufferWastePct in the existing buffer.
    if ((required_in_plab &lt;= plab_word_size) &amp;&amp;
      may_throw_away_buffer(required_in_plab, plab_word_size)) {
  
<span class="line-modified">!     PLAB* alloc_buf = alloc_buffer(dest, node_index);</span>
      alloc_buf-&gt;retire();
  
      size_t actual_plab_size = 0;
      HeapWord* buf = _allocator-&gt;par_allocate_during_gc(dest,
                                                         required_in_plab,
                                                         plab_word_size,
<span class="line-modified">!                                                        &amp;actual_plab_size,</span>
<span class="line-added">+                                                        node_index);</span>
  
      assert(buf == NULL || ((actual_plab_size &gt;= required_in_plab) &amp;&amp; (actual_plab_size &lt;= plab_word_size)),
             &quot;Requested at minimum &quot; SIZE_FORMAT &quot;, desired &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
             required_in_plab, plab_word_size, actual_plab_size, p2i(buf));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,58 ***</span>
      }
      // Otherwise.
      *plab_refill_failed = true;
    }
    // Try direct allocation.
<span class="line-modified">!   HeapWord* result = _allocator-&gt;par_allocate_during_gc(dest, word_sz);</span>
    if (result != NULL) {
<span class="line-modified">!     _direct_allocated[dest.value()] += word_sz;</span>
    }
    return result;
  }
  
<span class="line-modified">! void G1PLABAllocator::undo_allocation(InCSetState dest, HeapWord* obj, size_t word_sz) {</span>
<span class="line-modified">!   alloc_buffer(dest)-&gt;undo_allocation(obj, word_sz);</span>
  }
  
  void G1PLABAllocator::flush_and_retire_stats() {
<span class="line-modified">!   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">!     PLAB* const buf = _alloc_buffers[state];</span>
<span class="line-modified">!     if (buf != NULL) {</span>
<span class="line-modified">!       G1EvacStats* stats = _g1h-&gt;alloc_buffer_stats(state);</span>
<span class="line-modified">!       buf-&gt;flush_and_retire_stats(stats);</span>
<span class="line-modified">!       stats-&gt;add_direct_allocated(_direct_allocated[state]);</span>
<span class="line-modified">!       _direct_allocated[state] = 0;</span>
      }
    }
  }
  
  size_t G1PLABAllocator::waste() const {
    size_t result = 0;
<span class="line-modified">!   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">!     PLAB * const buf = _alloc_buffers[state];</span>
<span class="line-modified">!     if (buf != NULL) {</span>
<span class="line-modified">!       result += buf-&gt;waste();</span>
      }
    }
    return result;
  }
  
  size_t G1PLABAllocator::undo_waste() const {
    size_t result = 0;
<span class="line-modified">!   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">!     PLAB * const buf = _alloc_buffers[state];</span>
<span class="line-modified">!     if (buf != NULL) {</span>
<span class="line-modified">!       result += buf-&gt;undo_waste();</span>
      }
    }
    return result;
  }
  
  bool G1ArchiveAllocator::_archive_check_enabled = false;
<span class="line-modified">! G1ArchiveRegionMap G1ArchiveAllocator::_closed_archive_region_map;</span>
<span class="line-removed">- G1ArchiveRegionMap G1ArchiveAllocator::_open_archive_region_map;</span>
  
  G1ArchiveAllocator* G1ArchiveAllocator::create_allocator(G1CollectedHeap* g1h, bool open) {
    // Create the archive allocator, and also enable archive object checking
    // in mark-sweep, since we will be creating archive regions.
    G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);
<span class="line-new-header">--- 358,63 ---</span>
      }
      // Otherwise.
      *plab_refill_failed = true;
    }
    // Try direct allocation.
<span class="line-modified">!   HeapWord* result = _allocator-&gt;par_allocate_during_gc(dest, word_sz, node_index);</span>
    if (result != NULL) {
<span class="line-modified">!     _direct_allocated[dest.type()] += word_sz;</span>
    }
    return result;
  }
  
<span class="line-modified">! void G1PLABAllocator::undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index) {</span>
<span class="line-modified">!   alloc_buffer(dest, node_index)-&gt;undo_allocation(obj, word_sz);</span>
  }
  
  void G1PLABAllocator::flush_and_retire_stats() {
<span class="line-modified">!   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">!     G1EvacStats* stats = _g1h-&gt;alloc_buffer_stats(state);</span>
<span class="line-modified">!     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">!       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">!       if (buf != NULL) {</span>
<span class="line-modified">!         buf-&gt;flush_and_retire_stats(stats);</span>
<span class="line-modified">!       }</span>
      }
<span class="line-added">+     stats-&gt;add_direct_allocated(_direct_allocated[state]);</span>
<span class="line-added">+     _direct_allocated[state] = 0;</span>
    }
  }
  
  size_t G1PLABAllocator::waste() const {
    size_t result = 0;
<span class="line-modified">!   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">!     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">!       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">!       if (buf != NULL) {</span>
<span class="line-added">+         result += buf-&gt;waste();</span>
<span class="line-added">+       }</span>
      }
    }
    return result;
  }
  
  size_t G1PLABAllocator::undo_waste() const {
    size_t result = 0;
<span class="line-modified">!   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">!     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">!       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">!       if (buf != NULL) {</span>
<span class="line-added">+         result += buf-&gt;undo_waste();</span>
<span class="line-added">+       }</span>
      }
    }
    return result;
  }
  
  bool G1ArchiveAllocator::_archive_check_enabled = false;
<span class="line-modified">! G1ArchiveRegionMap G1ArchiveAllocator::_archive_region_map;</span>
  
  G1ArchiveAllocator* G1ArchiveAllocator::create_allocator(G1CollectedHeap* g1h, bool open) {
    // Create the archive allocator, and also enable archive object checking
    // in mark-sweep, since we will be creating archive regions.
    G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);
</pre>
<center><a href="g1AllocRegion.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BiasedArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/g1/heapRegion.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;gc/shared/space.hpp&quot;</span>
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;services/memTracker.hpp&quot;
 34 
 35 
 36 
 37 //////////////////////////////////////////////////////////////////////
 38 // G1BlockOffsetTable
 39 //////////////////////////////////////////////////////////////////////
 40 
 41 G1BlockOffsetTable::G1BlockOffsetTable(MemRegion heap, G1RegionToSpaceMapper* storage) :
 42   _reserved(heap), _offset_array(NULL) {
 43 
 44   MemRegion bot_reserved = storage-&gt;reserved();
 45 
 46   _offset_array = (u_char*)bot_reserved.start();
 47 
 48   log_trace(gc, bot)(&quot;G1BlockOffsetTable::G1BlockOffsetTable: &quot;);
 49   log_trace(gc, bot)(&quot;    rs.base(): &quot; PTR_FORMAT &quot;  rs.size(): &quot; SIZE_FORMAT &quot;  rs end(): &quot; PTR_FORMAT,
</pre>
<hr />
<pre>
 57 }
 58 
 59 #ifdef ASSERT
 60 void G1BlockOffsetTable::check_index(size_t index, const char* msg) const {
 61   assert((index) &lt; (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words),
 62          &quot;%s - index: &quot; SIZE_FORMAT &quot;, _vs.committed_size: &quot; SIZE_FORMAT,
 63          msg, (index), (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words));
 64   assert(G1CollectedHeap::heap()-&gt;is_in_exact(address_for_index_raw(index)),
 65          &quot;Index &quot; SIZE_FORMAT &quot; corresponding to &quot; PTR_FORMAT
 66          &quot; (%u) is not in committed area.&quot;,
 67          (index),
 68          p2i(address_for_index_raw(index)),
 69          G1CollectedHeap::heap()-&gt;addr_to_region(address_for_index_raw(index)));
 70 }
 71 #endif // ASSERT
 72 
 73 //////////////////////////////////////////////////////////////////////
 74 // G1BlockOffsetTablePart
 75 //////////////////////////////////////////////////////////////////////
 76 
<span class="line-modified"> 77 G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp) :</span>
 78   _next_offset_threshold(NULL),
 79   _next_offset_index(0),
 80   DEBUG_ONLY(_object_can_span(false) COMMA)
 81   _bot(array),
<span class="line-modified"> 82   _space(gsp)</span>
 83 {
 84 }
 85 
 86 // The arguments follow the normal convention of denoting
 87 // a right-open interval: [start, end)
 88 void G1BlockOffsetTablePart:: set_remainder_to_point_to_start(HeapWord* start, HeapWord* end) {
 89 
 90   if (start &gt;= end) {
 91     // The start address is equal to the end address (or to
 92     // the right of the end address) so there are not cards
 93     // that need to be updated..
 94     return;
 95   }
 96 
 97   // Write the backskip value for each region.
 98   //
 99   //    offset
100   //    card             2nd                       3rd
101   //     | +- 1st        |                         |
102   //     v v             v                         v
</pre>
<hr />
<pre>
124   //      Convert the entry to a back slide
125   //        (e.g., with today&#39;s, offset = 0x81 =&gt;
126   //          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8
127   //      Move back N (e.g., 8) entries and repeat with the
128   //        value of the new entry
129   //
130   size_t start_card = _bot-&gt;index_for(start);
131   size_t end_card = _bot-&gt;index_for(end-1);
132   assert(start ==_bot-&gt;address_for_index(start_card), &quot;Precondition&quot;);
133   assert(end ==_bot-&gt;address_for_index(end_card)+BOTConstants::N_words, &quot;Precondition&quot;);
134   set_remainder_to_point_to_start_incl(start_card, end_card); // closed interval
135 }
136 
137 // Unlike the normal convention in this code, the argument here denotes
138 // a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()
139 // above.
140 void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
141   if (start_card &gt; end_card) {
142     return;
143   }
<span class="line-modified">144   assert(start_card &gt; _bot-&gt;index_for(_space-&gt;bottom()), &quot;Cannot be first card&quot;);</span>
145   assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
146          &quot;Offset card has an unexpected value&quot;);
147   size_t start_card_for_region = start_card;
148   u_char offset = max_jubyte;
149   for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
150     // -1 so that the the card with the actual offset is counted.  Another -1
151     // so that the reach ends in this region and not at the start
152     // of the next.
153     size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);
154     offset = BOTConstants::N_words + i;
155     if (reach &gt;= end_card) {
156       _bot-&gt;set_offset_array(start_card_for_region, end_card, offset);
157       start_card_for_region = reach + 1;
158       break;
159     }
160     _bot-&gt;set_offset_array(start_card_for_region, reach, offset);
161     start_card_for_region = reach + 1;
162   }
163   assert(start_card_for_region &gt; end_card, &quot;Sanity check&quot;);
164   DEBUG_ONLY(check_all_cards(start_card, end_card);)
</pre>
<hr />
<pre>
207                                                                         const void* addr) {
208   // We&#39;re not in the normal case.  We need to handle an important subcase
209   // here: LAB allocation.  An allocation previously recorded in the
210   // offset table was actually a lab allocation, and was divided into
211   // several objects subsequently.  Fix this situation as we answer the
212   // query, by updating entries as we cross them.
213 
214   // If the fist object&#39;s end q is at the card boundary. Start refining
215   // with the corresponding card (the value of the entry will be basically
216   // set to 0). If the object crosses the boundary -- start from the next card.
217   size_t n_index = _bot-&gt;index_for(n);
218   size_t next_index = _bot-&gt;index_for(n) + !_bot-&gt;is_card_boundary(n);
219   // Calculate a consistent next boundary.  If &quot;n&quot; is not at the boundary
220   // already, step to the boundary.
221   HeapWord* next_boundary = _bot-&gt;address_for_index(n_index) +
222                             (n_index == next_index ? 0 : BOTConstants::N_words);
223   assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
224          &quot;next_boundary is beyond the end of the covered region &quot;
225          &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
226          p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
<span class="line-modified">227   if (addr &gt;= _space-&gt;top()) return _space-&gt;top();</span>
228   while (next_boundary &lt; addr) {
229     while (n &lt;= next_boundary) {
230       q = n;
231       oop obj = oop(q);
232       if (obj-&gt;klass_or_null_acquire() == NULL) return q;
233       n += block_size(q);
234     }
235     assert(q &lt;= next_boundary &amp;&amp; n &gt; next_boundary, &quot;Consequence of loop&quot;);
236     // [q, n) is the block that crosses the boundary.
237     alloc_block_work(&amp;next_boundary, &amp;next_index, q, n);
238   }
239   return forward_to_block_containing_addr_const(q, n, addr);
240 }
241 
242 //
243 //              threshold_
244 //              |   _index_
245 //              v   v
246 //      +-------+-------+-------+-------+-------+
247 //      | i-1   |   i   | i+1   | i+2   | i+3   |
</pre>
<hr />
<pre>
309          &quot;offset array should have been set - &quot;
310          &quot;orig_index offset: %u, &quot;
311          &quot;blk_start: &quot; PTR_FORMAT &quot;, &quot;
312          &quot;boundary: &quot; PTR_FORMAT,
313          (uint)_bot-&gt;offset_array(orig_index),
314          p2i(blk_start), p2i(boundary));
315   for (size_t j = orig_index + 1; j &lt;= end_index; j++) {
316     assert(_bot-&gt;offset_array(j) &gt; 0 &amp;&amp;
317            _bot-&gt;offset_array(j) &lt;=
318              (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
319            &quot;offset array should have been set - &quot;
320            &quot;%u not &gt; 0 OR %u not &lt;= %u&quot;,
321            (uint) _bot-&gt;offset_array(j),
322            (uint) _bot-&gt;offset_array(j),
323            (uint) (BOTConstants::N_words+BOTConstants::N_powers-1));
324   }
325 #endif
326 }
327 
328 void G1BlockOffsetTablePart::verify() const {
<span class="line-modified">329   assert(_space-&gt;bottom() &lt; _space-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);</span>
<span class="line-modified">330   size_t start_card = _bot-&gt;index_for(_space-&gt;bottom());</span>
<span class="line-modified">331   size_t end_card = _bot-&gt;index_for(_space-&gt;top() - 1);</span>
332 
333   for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
334     u_char entry = _bot-&gt;offset_array(current_card);
335     if (entry &lt; BOTConstants::N_words) {
336       // The entry should point to an object before the current card. Verify that
337       // it is possible to walk from that object in to the current card by just
338       // iterating over the objects following it.
339       HeapWord* card_address = _bot-&gt;address_for_index(current_card);
340       HeapWord* obj_end = card_address - entry;
341       while (obj_end &lt; card_address) {
342         HeapWord* obj = obj_end;
343         size_t obj_size = block_size(obj);
344         obj_end = obj + obj_size;
<span class="line-modified">345         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _space-&gt;top(),</span>
346                   &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
<span class="line-modified">347                   p2i(obj), obj_size, p2i(obj_end), p2i(_space-&gt;top()));</span>
348       }
349     } else {
350       // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
351       // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
352       // corresponding heap region. But that is about all we can verify.
353       size_t backskip = BOTConstants::entry_to_cards_back(entry);
354       guarantee(backskip &gt;= 1, &quot;Must be going back at least one card.&quot;);
355 
356       size_t max_backskip = current_card - start_card;
357       guarantee(backskip &lt;= max_backskip,
358                 &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
359                 start_card, current_card, backskip);
360 
361       HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
<span class="line-modified">362       guarantee(backskip_address &gt;= _space-&gt;bottom(),</span>
363                 &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
<span class="line-modified">364                 p2i(_space-&gt;bottom()), p2i(backskip_address));</span>
365     }
366   }
367 }
368 
369 #ifdef ASSERT
370 void G1BlockOffsetTablePart::set_object_can_span(bool can_span) {
371   _object_can_span = can_span;
372 }
373 #endif
374 
375 #ifndef PRODUCT
<span class="line-modified">376 void</span>
<span class="line-modified">377 G1BlockOffsetTablePart::print_on(outputStream* out) {</span>
<span class="line-modified">378   size_t from_index = _bot-&gt;index_for(_space-&gt;bottom());</span>
<span class="line-removed">379   size_t to_index = _bot-&gt;index_for(_space-&gt;end());</span>
380   out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
381                 &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
<span class="line-modified">382                 p2i(_space-&gt;bottom()), p2i(_space-&gt;end()), from_index, to_index);</span>
383   for (size_t i = from_index; i &lt; to_index; ++i) {
384     out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
385                   i, p2i(_bot-&gt;address_for_index(i)),
386                   (uint) _bot-&gt;offset_array(i));
387   }
388   out-&gt;print_cr(&quot;  next offset threshold: &quot; PTR_FORMAT, p2i(_next_offset_threshold));
389   out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
390 }
391 #endif // !PRODUCT
392 
393 HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
<span class="line-modified">394   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-removed">395          &quot;just checking&quot;);</span>
<span class="line-removed">396   _next_offset_index = _bot-&gt;index_for_raw(_space-&gt;bottom());</span>
397   _next_offset_index++;
398   _next_offset_threshold =
399     _bot-&gt;address_for_index_raw(_next_offset_index);
400   return _next_offset_threshold;
401 }
402 
403 void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
<span class="line-modified">404   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-modified">405          &quot;just checking&quot;);</span>
<span class="line-removed">406   size_t bottom_index = _bot-&gt;index_for_raw(_space-&gt;bottom());</span>
<span class="line-removed">407   assert(_bot-&gt;address_for_index_raw(bottom_index) == _space-&gt;bottom(),</span>
408          &quot;Precondition of call&quot;);
409   _bot-&gt;set_offset_array_raw(bottom_index, 0);
410 }
411 
412 HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
<span class="line-modified">413   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-removed">414          &quot;just checking&quot;);</span>
<span class="line-removed">415   _next_offset_index = _bot-&gt;index_for(_space-&gt;bottom());</span>
416   _next_offset_index++;
417   _next_offset_threshold =
418     _bot-&gt;address_for_index(_next_offset_index);
419   return _next_offset_threshold;
420 }
421 
422 void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
423   // The first BOT entry should have offset 0.
424   reset_bot();
<span class="line-modified">425   alloc_block(_space-&gt;bottom(), obj_top);</span>
426   if (fill_size &gt; 0) {
427     alloc_block(obj_top, fill_size);
428   }
429 }
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/g1/heapRegion.inline.hpp&quot;</span>

 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;services/memTracker.hpp&quot;
 33 
 34 
 35 
 36 //////////////////////////////////////////////////////////////////////
 37 // G1BlockOffsetTable
 38 //////////////////////////////////////////////////////////////////////
 39 
 40 G1BlockOffsetTable::G1BlockOffsetTable(MemRegion heap, G1RegionToSpaceMapper* storage) :
 41   _reserved(heap), _offset_array(NULL) {
 42 
 43   MemRegion bot_reserved = storage-&gt;reserved();
 44 
 45   _offset_array = (u_char*)bot_reserved.start();
 46 
 47   log_trace(gc, bot)(&quot;G1BlockOffsetTable::G1BlockOffsetTable: &quot;);
 48   log_trace(gc, bot)(&quot;    rs.base(): &quot; PTR_FORMAT &quot;  rs.size(): &quot; SIZE_FORMAT &quot;  rs end(): &quot; PTR_FORMAT,
</pre>
<hr />
<pre>
 56 }
 57 
 58 #ifdef ASSERT
 59 void G1BlockOffsetTable::check_index(size_t index, const char* msg) const {
 60   assert((index) &lt; (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words),
 61          &quot;%s - index: &quot; SIZE_FORMAT &quot;, _vs.committed_size: &quot; SIZE_FORMAT,
 62          msg, (index), (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words));
 63   assert(G1CollectedHeap::heap()-&gt;is_in_exact(address_for_index_raw(index)),
 64          &quot;Index &quot; SIZE_FORMAT &quot; corresponding to &quot; PTR_FORMAT
 65          &quot; (%u) is not in committed area.&quot;,
 66          (index),
 67          p2i(address_for_index_raw(index)),
 68          G1CollectedHeap::heap()-&gt;addr_to_region(address_for_index_raw(index)));
 69 }
 70 #endif // ASSERT
 71 
 72 //////////////////////////////////////////////////////////////////////
 73 // G1BlockOffsetTablePart
 74 //////////////////////////////////////////////////////////////////////
 75 
<span class="line-modified"> 76 G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :</span>
 77   _next_offset_threshold(NULL),
 78   _next_offset_index(0),
 79   DEBUG_ONLY(_object_can_span(false) COMMA)
 80   _bot(array),
<span class="line-modified"> 81   _hr(hr)</span>
 82 {
 83 }
 84 
 85 // The arguments follow the normal convention of denoting
 86 // a right-open interval: [start, end)
 87 void G1BlockOffsetTablePart:: set_remainder_to_point_to_start(HeapWord* start, HeapWord* end) {
 88 
 89   if (start &gt;= end) {
 90     // The start address is equal to the end address (or to
 91     // the right of the end address) so there are not cards
 92     // that need to be updated..
 93     return;
 94   }
 95 
 96   // Write the backskip value for each region.
 97   //
 98   //    offset
 99   //    card             2nd                       3rd
100   //     | +- 1st        |                         |
101   //     v v             v                         v
</pre>
<hr />
<pre>
123   //      Convert the entry to a back slide
124   //        (e.g., with today&#39;s, offset = 0x81 =&gt;
125   //          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8
126   //      Move back N (e.g., 8) entries and repeat with the
127   //        value of the new entry
128   //
129   size_t start_card = _bot-&gt;index_for(start);
130   size_t end_card = _bot-&gt;index_for(end-1);
131   assert(start ==_bot-&gt;address_for_index(start_card), &quot;Precondition&quot;);
132   assert(end ==_bot-&gt;address_for_index(end_card)+BOTConstants::N_words, &quot;Precondition&quot;);
133   set_remainder_to_point_to_start_incl(start_card, end_card); // closed interval
134 }
135 
136 // Unlike the normal convention in this code, the argument here denotes
137 // a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()
138 // above.
139 void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
140   if (start_card &gt; end_card) {
141     return;
142   }
<span class="line-modified">143   assert(start_card &gt; _bot-&gt;index_for(_hr-&gt;bottom()), &quot;Cannot be first card&quot;);</span>
144   assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
145          &quot;Offset card has an unexpected value&quot;);
146   size_t start_card_for_region = start_card;
147   u_char offset = max_jubyte;
148   for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
149     // -1 so that the the card with the actual offset is counted.  Another -1
150     // so that the reach ends in this region and not at the start
151     // of the next.
152     size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);
153     offset = BOTConstants::N_words + i;
154     if (reach &gt;= end_card) {
155       _bot-&gt;set_offset_array(start_card_for_region, end_card, offset);
156       start_card_for_region = reach + 1;
157       break;
158     }
159     _bot-&gt;set_offset_array(start_card_for_region, reach, offset);
160     start_card_for_region = reach + 1;
161   }
162   assert(start_card_for_region &gt; end_card, &quot;Sanity check&quot;);
163   DEBUG_ONLY(check_all_cards(start_card, end_card);)
</pre>
<hr />
<pre>
206                                                                         const void* addr) {
207   // We&#39;re not in the normal case.  We need to handle an important subcase
208   // here: LAB allocation.  An allocation previously recorded in the
209   // offset table was actually a lab allocation, and was divided into
210   // several objects subsequently.  Fix this situation as we answer the
211   // query, by updating entries as we cross them.
212 
213   // If the fist object&#39;s end q is at the card boundary. Start refining
214   // with the corresponding card (the value of the entry will be basically
215   // set to 0). If the object crosses the boundary -- start from the next card.
216   size_t n_index = _bot-&gt;index_for(n);
217   size_t next_index = _bot-&gt;index_for(n) + !_bot-&gt;is_card_boundary(n);
218   // Calculate a consistent next boundary.  If &quot;n&quot; is not at the boundary
219   // already, step to the boundary.
220   HeapWord* next_boundary = _bot-&gt;address_for_index(n_index) +
221                             (n_index == next_index ? 0 : BOTConstants::N_words);
222   assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
223          &quot;next_boundary is beyond the end of the covered region &quot;
224          &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
225          p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
<span class="line-modified">226   if (addr &gt;= _hr-&gt;top()) return _hr-&gt;top();</span>
227   while (next_boundary &lt; addr) {
228     while (n &lt;= next_boundary) {
229       q = n;
230       oop obj = oop(q);
231       if (obj-&gt;klass_or_null_acquire() == NULL) return q;
232       n += block_size(q);
233     }
234     assert(q &lt;= next_boundary &amp;&amp; n &gt; next_boundary, &quot;Consequence of loop&quot;);
235     // [q, n) is the block that crosses the boundary.
236     alloc_block_work(&amp;next_boundary, &amp;next_index, q, n);
237   }
238   return forward_to_block_containing_addr_const(q, n, addr);
239 }
240 
241 //
242 //              threshold_
243 //              |   _index_
244 //              v   v
245 //      +-------+-------+-------+-------+-------+
246 //      | i-1   |   i   | i+1   | i+2   | i+3   |
</pre>
<hr />
<pre>
308          &quot;offset array should have been set - &quot;
309          &quot;orig_index offset: %u, &quot;
310          &quot;blk_start: &quot; PTR_FORMAT &quot;, &quot;
311          &quot;boundary: &quot; PTR_FORMAT,
312          (uint)_bot-&gt;offset_array(orig_index),
313          p2i(blk_start), p2i(boundary));
314   for (size_t j = orig_index + 1; j &lt;= end_index; j++) {
315     assert(_bot-&gt;offset_array(j) &gt; 0 &amp;&amp;
316            _bot-&gt;offset_array(j) &lt;=
317              (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
318            &quot;offset array should have been set - &quot;
319            &quot;%u not &gt; 0 OR %u not &lt;= %u&quot;,
320            (uint) _bot-&gt;offset_array(j),
321            (uint) _bot-&gt;offset_array(j),
322            (uint) (BOTConstants::N_words+BOTConstants::N_powers-1));
323   }
324 #endif
325 }
326 
327 void G1BlockOffsetTablePart::verify() const {
<span class="line-modified">328   assert(_hr-&gt;bottom() &lt; _hr-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);</span>
<span class="line-modified">329   size_t start_card = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">330   size_t end_card = _bot-&gt;index_for(_hr-&gt;top() - 1);</span>
331 
332   for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
333     u_char entry = _bot-&gt;offset_array(current_card);
334     if (entry &lt; BOTConstants::N_words) {
335       // The entry should point to an object before the current card. Verify that
336       // it is possible to walk from that object in to the current card by just
337       // iterating over the objects following it.
338       HeapWord* card_address = _bot-&gt;address_for_index(current_card);
339       HeapWord* obj_end = card_address - entry;
340       while (obj_end &lt; card_address) {
341         HeapWord* obj = obj_end;
342         size_t obj_size = block_size(obj);
343         obj_end = obj + obj_size;
<span class="line-modified">344         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _hr-&gt;top(),</span>
345                   &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
<span class="line-modified">346                   p2i(obj), obj_size, p2i(obj_end), p2i(_hr-&gt;top()));</span>
347       }
348     } else {
349       // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
350       // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
351       // corresponding heap region. But that is about all we can verify.
352       size_t backskip = BOTConstants::entry_to_cards_back(entry);
353       guarantee(backskip &gt;= 1, &quot;Must be going back at least one card.&quot;);
354 
355       size_t max_backskip = current_card - start_card;
356       guarantee(backskip &lt;= max_backskip,
357                 &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
358                 start_card, current_card, backskip);
359 
360       HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
<span class="line-modified">361       guarantee(backskip_address &gt;= _hr-&gt;bottom(),</span>
362                 &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
<span class="line-modified">363                 p2i(_hr-&gt;bottom()), p2i(backskip_address));</span>
364     }
365   }
366 }
367 
368 #ifdef ASSERT
369 void G1BlockOffsetTablePart::set_object_can_span(bool can_span) {
370   _object_can_span = can_span;
371 }
372 #endif
373 
374 #ifndef PRODUCT
<span class="line-modified">375 void G1BlockOffsetTablePart::print_on(outputStream* out) {</span>
<span class="line-modified">376   size_t from_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">377   size_t to_index = _bot-&gt;index_for(_hr-&gt;end());</span>

378   out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
379                 &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
<span class="line-modified">380                 p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), from_index, to_index);</span>
381   for (size_t i = from_index; i &lt; to_index; ++i) {
382     out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
383                   i, p2i(_bot-&gt;address_for_index(i)),
384                   (uint) _bot-&gt;offset_array(i));
385   }
386   out-&gt;print_cr(&quot;  next offset threshold: &quot; PTR_FORMAT, p2i(_next_offset_threshold));
387   out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
388 }
389 #endif // !PRODUCT
390 
391 HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
<span class="line-modified">392   _next_offset_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>


393   _next_offset_index++;
394   _next_offset_threshold =
395     _bot-&gt;address_for_index_raw(_next_offset_index);
396   return _next_offset_threshold;
397 }
398 
399 void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
<span class="line-modified">400   size_t bottom_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>
<span class="line-modified">401   assert(_bot-&gt;address_for_index_raw(bottom_index) == _hr-&gt;bottom(),</span>


402          &quot;Precondition of call&quot;);
403   _bot-&gt;set_offset_array_raw(bottom_index, 0);
404 }
405 
406 HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
<span class="line-modified">407   _next_offset_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>


408   _next_offset_index++;
409   _next_offset_threshold =
410     _bot-&gt;address_for_index(_next_offset_index);
411   return _next_offset_threshold;
412 }
413 
414 void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
415   // The first BOT entry should have offset 0.
416   reset_bot();
<span class="line-modified">417   alloc_block(_hr-&gt;bottom(), obj_top);</span>
418   if (fill_size &gt; 0) {
419     alloc_block(obj_top, fill_size);
420   }
421 }
</pre>
</td>
</tr>
</table>
<center><a href="g1BiasedArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
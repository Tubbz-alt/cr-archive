<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/g1SATBMarkQueueSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1SATBMarkQueueSet.hpp&quot;
 28 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 G1SATBMarkQueueSet::G1SATBMarkQueueSet(BufferNode::Allocator* allocator) :
 36   SATBMarkQueueSet(allocator)
 37 {}
 38 
 39 void G1SATBMarkQueueSet::handle_zero_index_for_thread(Thread* t) {
 40   G1ThreadLocalData::satb_mark_queue(t).handle_zero_index();
 41 }
 42 
 43 SATBMarkQueue&amp; G1SATBMarkQueueSet::satb_queue_for_thread(Thread* const t) const{
 44   return G1ThreadLocalData::satb_mark_queue(t);
 45 }
 46 
 47 // Return true if a SATB buffer entry refers to an object that
 48 // requires marking.
 49 //
 50 // The entry must point into the G1 heap.  In particular, it must not
 51 // be a NULL pointer.  NULL pointers are pre-filtered and never
 52 // inserted into a SATB buffer.
 53 //
 54 // An entry that is below the NTAMS pointer for the containing heap
 55 // region requires marking. Such an entry must point to a valid object.
 56 //
 57 // An entry that is at least the NTAMS pointer for the containing heap
 58 // region might be any of the following, none of which should be marked.
 59 //
 60 // * A reference to an object allocated since marking started.
 61 //   According to SATB, such objects are implicitly kept live and do
 62 //   not need to be dealt with via SATB buffer processing.
 63 //
 64 // * A reference to a young generation object. Young objects are
 65 //   handled separately and are not marked by concurrent marking.
 66 //
 67 // * A stale reference to a young generation object. If a young
 68 //   generation object reference is recorded and not filtered out
 69 //   before being moved by a young collection, the reference becomes
 70 //   stale.
 71 //
 72 // * A stale reference to an eagerly reclaimed humongous object.  If a
 73 //   humongous object is recorded and then reclaimed, the reference
 74 //   becomes stale.
 75 //
 76 // The stale reference cases are implicitly handled by the NTAMS
 77 // comparison. Because of the possibility of stale references, buffer
 78 // processing must be somewhat circumspect and not assume entries
 79 // in an unfiltered buffer refer to valid objects.
 80 
 81 static inline bool requires_marking(const void* entry, G1CollectedHeap* g1h) {
 82   // Includes rejection of NULL pointers.
 83   assert(g1h-&gt;is_in_reserved(entry),
 84          &quot;Non-heap pointer in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
 85 
 86   HeapRegion* region = g1h-&gt;heap_region_containing(entry);
 87   assert(region != NULL, &quot;No region for &quot; PTR_FORMAT, p2i(entry));
 88   if (entry &gt;= region-&gt;next_top_at_mark_start()) {
 89     return false;
 90   }
 91 
 92   assert(oopDesc::is_oop(oop(entry), true /* ignore mark word */),
 93          &quot;Invalid oop in SATB buffer: &quot; PTR_FORMAT, p2i(entry));
 94 
 95   return true;
 96 }
 97 
 98 static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {
 99   return !requires_marking(entry, g1h) || g1h-&gt;is_marked_next((oop)entry);
100 }
101 
102 // Workaround for not yet having std::bind.
103 class G1SATBMarkQueueFilterFn {
104   G1CollectedHeap* _g1h;
105 
106 public:
107   G1SATBMarkQueueFilterFn() : _g1h(G1CollectedHeap::heap()) {}
108 
109   // Return true if entry should be filtered out (removed), false if
110   // it should be retained.
111   bool operator()(const void* entry) const {
112     return discard_entry(entry, _g1h);
113   }
114 };
115 
116 void G1SATBMarkQueueSet::filter(SATBMarkQueue* queue) {
117   apply_filter(G1SATBMarkQueueFilterFn(), queue);
118 }
    </pre>
  </body>
</html>
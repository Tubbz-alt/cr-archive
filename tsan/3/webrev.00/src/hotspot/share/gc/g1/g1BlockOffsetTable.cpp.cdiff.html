<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BiasedArray.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,12 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/heapRegion.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/space.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  
<span class="line-new-header">--- 23,11 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/heapRegion.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,16 ***</span>
  
  //////////////////////////////////////////////////////////////////////
  // G1BlockOffsetTablePart
  //////////////////////////////////////////////////////////////////////
  
<span class="line-modified">! G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp) :</span>
    _next_offset_threshold(NULL),
    _next_offset_index(0),
    DEBUG_ONLY(_object_can_span(false) COMMA)
    _bot(array),
<span class="line-modified">!   _space(gsp)</span>
  {
  }
  
  // The arguments follow the normal convention of denoting
  // a right-open interval: [start, end)
<span class="line-new-header">--- 71,16 ---</span>
  
  //////////////////////////////////////////////////////////////////////
  // G1BlockOffsetTablePart
  //////////////////////////////////////////////////////////////////////
  
<span class="line-modified">! G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :</span>
    _next_offset_threshold(NULL),
    _next_offset_index(0),
    DEBUG_ONLY(_object_can_span(false) COMMA)
    _bot(array),
<span class="line-modified">!   _hr(hr)</span>
  {
  }
  
  // The arguments follow the normal convention of denoting
  // a right-open interval: [start, end)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,11 ***</span>
  // above.
  void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
    if (start_card &gt; end_card) {
      return;
    }
<span class="line-modified">!   assert(start_card &gt; _bot-&gt;index_for(_space-&gt;bottom()), &quot;Cannot be first card&quot;);</span>
    assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
           &quot;Offset card has an unexpected value&quot;);
    size_t start_card_for_region = start_card;
    u_char offset = max_jubyte;
    for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
<span class="line-new-header">--- 138,11 ---</span>
  // above.
  void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
    if (start_card &gt; end_card) {
      return;
    }
<span class="line-modified">!   assert(start_card &gt; _bot-&gt;index_for(_hr-&gt;bottom()), &quot;Cannot be first card&quot;);</span>
    assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
           &quot;Offset card has an unexpected value&quot;);
    size_t start_card_for_region = start_card;
    u_char offset = max_jubyte;
    for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,11 ***</span>
                              (n_index == next_index ? 0 : BOTConstants::N_words);
    assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
           &quot;next_boundary is beyond the end of the covered region &quot;
           &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
           p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
<span class="line-modified">!   if (addr &gt;= _space-&gt;top()) return _space-&gt;top();</span>
    while (next_boundary &lt; addr) {
      while (n &lt;= next_boundary) {
        q = n;
        oop obj = oop(q);
        if (obj-&gt;klass_or_null_acquire() == NULL) return q;
<span class="line-new-header">--- 221,11 ---</span>
                              (n_index == next_index ? 0 : BOTConstants::N_words);
    assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
           &quot;next_boundary is beyond the end of the covered region &quot;
           &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
           p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
<span class="line-modified">!   if (addr &gt;= _hr-&gt;top()) return _hr-&gt;top();</span>
    while (next_boundary &lt; addr) {
      while (n &lt;= next_boundary) {
        q = n;
        oop obj = oop(q);
        if (obj-&gt;klass_or_null_acquire() == NULL) return q;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,13 ***</span>
    }
  #endif
  }
  
  void G1BlockOffsetTablePart::verify() const {
<span class="line-modified">!   assert(_space-&gt;bottom() &lt; _space-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);</span>
<span class="line-modified">!   size_t start_card = _bot-&gt;index_for(_space-&gt;bottom());</span>
<span class="line-modified">!   size_t end_card = _bot-&gt;index_for(_space-&gt;top() - 1);</span>
  
    for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
      u_char entry = _bot-&gt;offset_array(current_card);
      if (entry &lt; BOTConstants::N_words) {
        // The entry should point to an object before the current card. Verify that
<span class="line-new-header">--- 323,13 ---</span>
    }
  #endif
  }
  
  void G1BlockOffsetTablePart::verify() const {
<span class="line-modified">!   assert(_hr-&gt;bottom() &lt; _hr-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);</span>
<span class="line-modified">!   size_t start_card = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">!   size_t end_card = _bot-&gt;index_for(_hr-&gt;top() - 1);</span>
  
    for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
      u_char entry = _bot-&gt;offset_array(current_card);
      if (entry &lt; BOTConstants::N_words) {
        // The entry should point to an object before the current card. Verify that
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,13 ***</span>
        HeapWord* obj_end = card_address - entry;
        while (obj_end &lt; card_address) {
          HeapWord* obj = obj_end;
          size_t obj_size = block_size(obj);
          obj_end = obj + obj_size;
<span class="line-modified">!         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _space-&gt;top(),</span>
                    &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
<span class="line-modified">!                   p2i(obj), obj_size, p2i(obj_end), p2i(_space-&gt;top()));</span>
        }
      } else {
        // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
        // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
        // corresponding heap region. But that is about all we can verify.
<span class="line-new-header">--- 339,13 ---</span>
        HeapWord* obj_end = card_address - entry;
        while (obj_end &lt; card_address) {
          HeapWord* obj = obj_end;
          size_t obj_size = block_size(obj);
          obj_end = obj + obj_size;
<span class="line-modified">!         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _hr-&gt;top(),</span>
                    &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
<span class="line-modified">!                   p2i(obj), obj_size, p2i(obj_end), p2i(_hr-&gt;top()));</span>
        }
      } else {
        // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
        // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
        // corresponding heap region. But that is about all we can verify.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,13 ***</span>
        guarantee(backskip &lt;= max_backskip,
                  &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
                  start_card, current_card, backskip);
  
        HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
<span class="line-modified">!       guarantee(backskip_address &gt;= _space-&gt;bottom(),</span>
                  &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
<span class="line-modified">!                 p2i(_space-&gt;bottom()), p2i(backskip_address));</span>
      }
    }
  }
  
  #ifdef ASSERT
<span class="line-new-header">--- 356,13 ---</span>
        guarantee(backskip &lt;= max_backskip,
                  &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
                  start_card, current_card, backskip);
  
        HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
<span class="line-modified">!       guarantee(backskip_address &gt;= _hr-&gt;bottom(),</span>
                  &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
<span class="line-modified">!                 p2i(_hr-&gt;bottom()), p2i(backskip_address));</span>
      }
    }
  }
  
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,17 ***</span>
    _object_can_span = can_span;
  }
  #endif
  
  #ifndef PRODUCT
<span class="line-modified">! void</span>
<span class="line-modified">! G1BlockOffsetTablePart::print_on(outputStream* out) {</span>
<span class="line-modified">!   size_t from_index = _bot-&gt;index_for(_space-&gt;bottom());</span>
<span class="line-removed">-   size_t to_index = _bot-&gt;index_for(_space-&gt;end());</span>
    out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
                  &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
<span class="line-modified">!                 p2i(_space-&gt;bottom()), p2i(_space-&gt;end()), from_index, to_index);</span>
    for (size_t i = from_index; i &lt; to_index; ++i) {
      out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
                    i, p2i(_bot-&gt;address_for_index(i)),
                    (uint) _bot-&gt;offset_array(i));
    }
<span class="line-new-header">--- 370,16 ---</span>
    _object_can_span = can_span;
  }
  #endif
  
  #ifndef PRODUCT
<span class="line-modified">! void G1BlockOffsetTablePart::print_on(outputStream* out) {</span>
<span class="line-modified">!   size_t from_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">!   size_t to_index = _bot-&gt;index_for(_hr-&gt;end());</span>
    out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
                  &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
<span class="line-modified">!                 p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), from_index, to_index);</span>
    for (size_t i = from_index; i &lt; to_index; ++i) {
      out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
                    i, p2i(_bot-&gt;address_for_index(i)),
                    (uint) _bot-&gt;offset_array(i));
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,41 ***</span>
    out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
  }
  #endif // !PRODUCT
  
  HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
<span class="line-modified">!   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-removed">-          &quot;just checking&quot;);</span>
<span class="line-removed">-   _next_offset_index = _bot-&gt;index_for_raw(_space-&gt;bottom());</span>
    _next_offset_index++;
    _next_offset_threshold =
      _bot-&gt;address_for_index_raw(_next_offset_index);
    return _next_offset_threshold;
  }
  
  void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
<span class="line-modified">!   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-modified">!          &quot;just checking&quot;);</span>
<span class="line-removed">-   size_t bottom_index = _bot-&gt;index_for_raw(_space-&gt;bottom());</span>
<span class="line-removed">-   assert(_bot-&gt;address_for_index_raw(bottom_index) == _space-&gt;bottom(),</span>
           &quot;Precondition of call&quot;);
    _bot-&gt;set_offset_array_raw(bottom_index, 0);
  }
  
  HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
<span class="line-modified">!   assert(!G1CollectedHeap::heap()-&gt;is_in_reserved(_bot-&gt;_offset_array),</span>
<span class="line-removed">-          &quot;just checking&quot;);</span>
<span class="line-removed">-   _next_offset_index = _bot-&gt;index_for(_space-&gt;bottom());</span>
    _next_offset_index++;
    _next_offset_threshold =
      _bot-&gt;address_for_index(_next_offset_index);
    return _next_offset_threshold;
  }
  
  void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
    // The first BOT entry should have offset 0.
    reset_bot();
<span class="line-modified">!   alloc_block(_space-&gt;bottom(), obj_top);</span>
    if (fill_size &gt; 0) {
      alloc_block(obj_top, fill_size);
    }
  }
<span class="line-new-header">--- 387,35 ---</span>
    out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
  }
  #endif // !PRODUCT
  
  HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
<span class="line-modified">!   _next_offset_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>
    _next_offset_index++;
    _next_offset_threshold =
      _bot-&gt;address_for_index_raw(_next_offset_index);
    return _next_offset_threshold;
  }
  
  void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
<span class="line-modified">!   size_t bottom_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>
<span class="line-modified">!   assert(_bot-&gt;address_for_index_raw(bottom_index) == _hr-&gt;bottom(),</span>
           &quot;Precondition of call&quot;);
    _bot-&gt;set_offset_array_raw(bottom_index, 0);
  }
  
  HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
<span class="line-modified">!   _next_offset_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>
    _next_offset_index++;
    _next_offset_threshold =
      _bot-&gt;address_for_index(_next_offset_index);
    return _next_offset_threshold;
  }
  
  void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
    // The first BOT entry should have offset 0.
    reset_bot();
<span class="line-modified">!   alloc_block(_hr-&gt;bottom(), obj_top);</span>
    if (fill_size &gt; 0) {
      alloc_block(obj_top, fill_size);
    }
  }
</pre>
<center><a href="g1BiasedArray.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1BlockOffsetTable.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1OopClosures.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1OopClosures.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,13 +23,13 @@</span>
   */
  
  #ifndef SHARE_GC_G1_G1OOPCLOSURES_HPP
  #define SHARE_GC_G1_G1OOPCLOSURES_HPP
  
<span class="udiff-line-modified-removed">- #include &quot;gc/g1/g1InCSetState.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;</span>
  #include &quot;memory/iterator.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  
  class HeapRegion;
  class G1CollectedHeap;
  class G1RemSet;
  class G1ConcurrentMark;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,46 +50,35 @@</span>
  
    template &lt;class T&gt;
    inline void prefetch_and_push(T* p, oop const obj);
  
    template &lt;class T&gt;
<span class="udiff-line-modified-removed">-   inline void handle_non_cset_obj_common(InCSetState const state, T* p, oop const obj);</span>
<span class="udiff-line-modified-added">+   inline void handle_non_cset_obj_common(G1HeapRegionAttr const region_attr, T* p, oop const obj);</span>
  public:
    virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
  
    inline void trim_queue_partially();
  };
  
<span class="udiff-line-modified-removed">- // Used during the Update RS phase to refine remaining cards in the DCQ during garbage collection.</span>
<span class="udiff-line-modified-removed">- class G1ScanObjsDuringUpdateRSClosure : public G1ScanClosureBase {</span>
<span class="udiff-line-modified-added">+ // Used to scan cards from the DCQS or the remembered sets during garbage collection.</span>
<span class="udiff-line-modified-added">+ class G1ScanCardClosure : public G1ScanClosureBase {</span>
  public:
<span class="udiff-line-modified-removed">-   G1ScanObjsDuringUpdateRSClosure(G1CollectedHeap* g1h,</span>
<span class="udiff-line-modified-removed">-                                   G1ParScanThreadState* pss) :</span>
<span class="udiff-line-modified-added">+   G1ScanCardClosure(G1CollectedHeap* g1h,</span>
<span class="udiff-line-modified-added">+                     G1ParScanThreadState* pss) :</span>
      G1ScanClosureBase(g1h, pss) { }
  
    template &lt;class T&gt; void do_oop_work(T* p);
    virtual void do_oop(narrowOop* p) { do_oop_work(p); }
    virtual void do_oop(oop* p)       { do_oop_work(p); }
  };
  
<span class="udiff-line-removed">- // Used during the Scan RS phase to scan cards from the remembered set during garbage collection.</span>
<span class="udiff-line-removed">- class G1ScanObjsDuringScanRSClosure : public G1ScanClosureBase {</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   G1ScanObjsDuringScanRSClosure(G1CollectedHeap* g1h,</span>
<span class="udiff-line-removed">-                                 G1ParScanThreadState* par_scan_state):</span>
<span class="udiff-line-removed">-     G1ScanClosureBase(g1h, par_scan_state) { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;class T&gt; void do_oop_work(T* p);</span>
<span class="udiff-line-removed">-   virtual void do_oop(oop* p)          { do_oop_work(p); }</span>
<span class="udiff-line-removed">-   virtual void do_oop(narrowOop* p)    { do_oop_work(p); }</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  // Used during Optional RS scanning to make sure we trim the queues in a timely manner.
  class G1ScanRSForOptionalClosure : public OopClosure {
<span class="udiff-line-modified-removed">-   G1ScanObjsDuringScanRSClosure* _scan_cl;</span>
<span class="udiff-line-modified-added">+   G1CollectedHeap* _g1h;</span>
<span class="udiff-line-added">+   G1ScanCardClosure* _scan_cl;</span>
  public:
<span class="udiff-line-modified-removed">-   G1ScanRSForOptionalClosure(G1ScanObjsDuringScanRSClosure* cl) : _scan_cl(cl) { }</span>
<span class="udiff-line-modified-added">+   G1ScanRSForOptionalClosure(G1CollectedHeap* g1h, G1ScanCardClosure* cl) : _g1h(g1h), _scan_cl(cl) { }</span>
  
    template &lt;class T&gt; void do_oop_work(T* p);
    virtual void do_oop(oop* p)          { do_oop_work(p); }
    virtual void do_oop(narrowOop* p)    { do_oop_work(p); }
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,11 +150,12 @@</span>
    inline void trim_queue_partially();
  };
  
  enum G1Barrier {
    G1BarrierNone,
<span class="udiff-line-modified-removed">-   G1BarrierCLD</span>
<span class="udiff-line-modified-added">+   G1BarrierCLD,</span>
<span class="udiff-line-added">+   G1BarrierNoOptRoots  // Do not collect optional roots.</span>
  };
  
  enum G1Mark {
    G1MarkNone,
    G1MarkFromRoot,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,16 +174,14 @@</span>
  };
  
  class G1CLDScanClosure : public CLDClosure {
    G1ParCopyHelper* _closure;
    bool             _process_only_dirty;
<span class="udiff-line-removed">-   int              _claim;</span>
    int              _count;
  public:
<span class="udiff-line-modified-removed">-   G1CLDScanClosure(G1ParCopyHelper* closure,</span>
<span class="udiff-line-modified-removed">-                    bool process_only_dirty, int claim_value)</span>
<span class="udiff-line-removed">-   : _closure(closure), _process_only_dirty(process_only_dirty), _claim(claim_value), _count(0) {}</span>
<span class="udiff-line-modified-added">+   G1CLDScanClosure(G1ParCopyHelper* closure, bool process_only_dirty)</span>
<span class="udiff-line-modified-added">+   : _closure(closure), _process_only_dirty(process_only_dirty), _count(0) {}</span>
    void do_cld(ClassLoaderData* cld);
  };
  
  // Closure for iterating over object fields during concurrent marking
  class G1CMOopClosure : public MetadataVisitingOopIterateClosure {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,16 +208,16 @@</span>
    virtual void do_oop(narrowOop* p) { do_oop_work(p); }
  };
  
  class G1ConcurrentRefineOopClosure: public BasicOopIterateClosure {
    G1CollectedHeap* _g1h;
<span class="udiff-line-modified-removed">-   uint _worker_i;</span>
<span class="udiff-line-modified-added">+   uint _worker_id;</span>
  
  public:
<span class="udiff-line-modified-removed">-   G1ConcurrentRefineOopClosure(G1CollectedHeap* g1h, uint worker_i) :</span>
<span class="udiff-line-modified-added">+   G1ConcurrentRefineOopClosure(G1CollectedHeap* g1h, uint worker_id) :</span>
      _g1h(g1h),
<span class="udiff-line-modified-removed">-     _worker_i(worker_i) {</span>
<span class="udiff-line-modified-added">+     _worker_id(worker_id) {</span>
    }
  
    virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
  
    template &lt;class T&gt; void do_oop_work(T* p);
</pre>
<center><a href="g1OopClosures.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
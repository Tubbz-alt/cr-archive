<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1DirtyCardQueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EdenRegions.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,42 ***</span>
   */
  
  #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  
<span class="line-modified">! #include &quot;gc/shared/cardTable.hpp&quot;</span>
  #include &quot;gc/shared/ptrQueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  
  class G1DirtyCardQueueSet;
<span class="line-modified">! class G1FreeIdSet;</span>
  class Thread;
<span class="line-removed">- class Monitor;</span>
<span class="line-removed">- </span>
<span class="line-removed">- // A closure class for processing card table entries.  Note that we don&#39;t</span>
<span class="line-removed">- // require these closure objects to be stack-allocated.</span>
<span class="line-removed">- class G1CardTableEntryClosure: public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   typedef CardTable::CardValue CardValue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Process the card whose card table entry is &quot;card_ptr&quot;.  If returns</span>
<span class="line-removed">-   // &quot;false&quot;, terminate the iteration early.</span>
<span class="line-removed">-   virtual bool do_card_ptr(CardValue* card_ptr, uint worker_i) = 0;</span>
<span class="line-removed">- };</span>
  
  // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
  class G1DirtyCardQueue: public PtrQueue {
  public:
<span class="line-modified">!   G1DirtyCardQueue(G1DirtyCardQueueSet* qset, bool permanent = false);</span>
  
    // Flush before destroying; queue may be used to capture pending work while
    // doing something else, with auto-flush on completion.
    ~G1DirtyCardQueue();
  
    // Process queue entries and release resources.
    void flush() { flush_impl(); }
  
    // Compiler support.
    static ByteSize byte_offset_of_index() {
      return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
    }
    using PtrQueue::byte_width_of_index;
<span class="line-new-header">--- 23,38 ---</span>
   */
  
  #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
  
<span class="line-modified">! #include &quot;gc/g1/g1BufferNodeList.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/g1/g1FreeIdSet.hpp&quot;</span>
  #include &quot;gc/shared/ptrQueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;memory/padded.hpp&quot;</span>
  
<span class="line-added">+ class G1ConcurrentRefineThread;</span>
  class G1DirtyCardQueueSet;
<span class="line-modified">! class G1RedirtyCardsQueueSet;</span>
  class Thread;
  
  // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
  class G1DirtyCardQueue: public PtrQueue {
<span class="line-added">+ protected:</span>
<span class="line-added">+   virtual void handle_completed_buffer();</span>
<span class="line-added">+ </span>
  public:
<span class="line-modified">!   G1DirtyCardQueue(G1DirtyCardQueueSet* qset);</span>
  
    // Flush before destroying; queue may be used to capture pending work while
    // doing something else, with auto-flush on completion.
    ~G1DirtyCardQueue();
  
    // Process queue entries and release resources.
    void flush() { flush_impl(); }
  
<span class="line-added">+   inline G1DirtyCardQueueSet* dirty_card_qset() const;</span>
<span class="line-added">+ </span>
    // Compiler support.
    static ByteSize byte_offset_of_index() {
      return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
    }
    using PtrQueue::byte_width_of_index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,103 ***</span>
    }
    using PtrQueue::byte_width_of_buf;
  
  };
  
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  class G1DirtyCardQueueSet: public PtrQueueSet {
<span class="line-modified">!   G1DirtyCardQueue _shared_dirty_card_queue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Apply the closure to the elements of &quot;node&quot; from it&#39;s index to</span>
<span class="line-modified">!   // buffer_size.  If all closure applications return true, then</span>
<span class="line-modified">!   // returns true.  Stops processing after the first closure</span>
<span class="line-modified">!   // application that returns false, and returns false from this</span>
<span class="line-modified">!   // function.  If &quot;consume&quot; is true, the node&#39;s index is updated to</span>
<span class="line-modified">!   // exclude the processed elements, e.g. up to the element for which</span>
<span class="line-modified">!   // the closure returned false.</span>
<span class="line-modified">!   bool apply_closure_to_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified">!                                BufferNode* node,</span>
<span class="line-modified">!                                bool consume,</span>
<span class="line-modified">!                                uint worker_i = 0);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // If there are more than stop_at completed buffers, pop one, apply</span>
<span class="line-modified">!   // the specified closure to its active elements, and return true.</span>
<span class="line-modified">!   // Otherwise return false.</span>
    //
<span class="line-modified">!   // A completely processed buffer is freed.  However, if a closure</span>
<span class="line-modified">!   // invocation returns false, processing is stopped and the partially</span>
<span class="line-modified">!   // processed buffer (with its index updated to exclude the processed</span>
<span class="line-modified">!   // elements, e.g. up to the element for which the closure returned</span>
<span class="line-modified">!   // false) is returned to the completed buffer set.</span>
    //
<span class="line-modified">!   // If during_pause is true, stop_at must be zero, and the closure</span>
<span class="line-modified">!   // must never return false.</span>
<span class="line-modified">!   bool apply_closure_to_completed_buffer(G1CardTableEntryClosure* cl,</span>
<span class="line-modified">!                                          uint worker_i,</span>
<span class="line-modified">!                                          size_t stop_at,</span>
<span class="line-modified">!                                          bool during_pause);</span>
  
    bool mut_process_buffer(BufferNode* node);
  
<span class="line-modified">!   G1FreeIdSet* _free_ids;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // The number of completed buffers processed by mutator and rs thread,</span>
<span class="line-removed">-   // respectively.</span>
<span class="line-removed">-   jint _processed_buffers_mut;</span>
<span class="line-removed">-   jint _processed_buffers_rs_thread;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Current buffer node used for parallel iteration.</span>
<span class="line-removed">-   BufferNode* volatile _cur_par_buffer_node;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void concatenate_log(G1DirtyCardQueue&amp; dcq);</span>
  
  public:
<span class="line-modified">!   G1DirtyCardQueueSet(bool notify_when_complete = true);</span>
    ~G1DirtyCardQueueSet();
  
<span class="line-modified">!   void initialize(Monitor* cbl_mon,</span>
<span class="line-modified">!                   BufferNode::Allocator* allocator,</span>
<span class="line-modified">!                   Mutex* lock,</span>
<span class="line-removed">-                   bool init_free_ids = false);</span>
  
    // The number of parallel ids that can be claimed to allow collector or
    // mutator threads to do card-processing work.
    static uint num_par_ids();
  
    static void handle_zero_index_for_thread(Thread* t);
  
<span class="line-modified">!   // Apply G1RefineCardConcurrentlyClosure to completed buffers until there are stop_at</span>
<span class="line-modified">!   // completed buffers remaining.</span>
<span class="line-modified">!   bool refine_completed_buffer_concurrently(uint worker_i, size_t stop_at);</span>
  
<span class="line-modified">!   // Apply the given closure to all completed buffers. The given closure&#39;s do_card_ptr</span>
<span class="line-removed">-   // must never return false. Must only be called during GC.</span>
<span class="line-removed">-   bool apply_closure_during_gc(G1CardTableEntryClosure* cl, uint worker_i);</span>
  
<span class="line-modified">!   void reset_for_par_iteration() { _cur_par_buffer_node = completed_buffers_head(); }</span>
<span class="line-modified">!   // Applies the current closure to all completed buffers, non-consumptively.</span>
<span class="line-modified">!   // Can be used in parallel, all callers using the iteration state initialized</span>
<span class="line-modified">!   // by reset_for_par_iteration.</span>
<span class="line-removed">-   void par_apply_closure_to_all_completed_buffers(G1CardTableEntryClosure* cl);</span>
  
<span class="line-modified">!   G1DirtyCardQueue* shared_dirty_card_queue() {</span>
<span class="line-modified">!     return &amp;_shared_dirty_card_queue;</span>
    }
  
<span class="line-modified">!   // If a full collection is happening, reset partial logs, and ignore</span>
    // completed ones: the full collection will make them all irrelevant.
    void abandon_logs();
  
    // If any threads have partial logs, add them to the global list of logs.
    void concatenate_logs();
  
<span class="line-modified">!   jint processed_buffers_mut() {</span>
<span class="line-modified">!     return _processed_buffers_mut;</span>
    }
<span class="line-modified">!   jint processed_buffers_rs_thread() {</span>
<span class="line-modified">!     return _processed_buffers_rs_thread;</span>
    }
  
  };
  
  #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
<span class="line-new-header">--- 64,283 ---</span>
    }
    using PtrQueue::byte_width_of_buf;
  
  };
  
  class G1DirtyCardQueueSet: public PtrQueueSet {
<span class="line-modified">!   // Head and tail of a list of BufferNodes, linked through their next()</span>
<span class="line-modified">!   // fields.  Similar to G1BufferNodeList, but without the _entry_count.</span>
<span class="line-modified">!   struct HeadTail {</span>
<span class="line-modified">!     BufferNode* _head;</span>
<span class="line-modified">!     BufferNode* _tail;</span>
<span class="line-modified">!     HeadTail() : _head(NULL), _tail(NULL) {}</span>
<span class="line-modified">!     HeadTail(BufferNode* head, BufferNode* tail) : _head(head), _tail(tail) {}</span>
<span class="line-modified">!   };</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // A lock-free FIFO of BufferNodes, linked through their next() fields.</span>
<span class="line-modified">!   // This class has a restriction that pop() may return NULL when there are</span>
<span class="line-modified">!   // buffers in the queue if there is a concurrent push/append operation.</span>
<span class="line-modified">!   class Queue {</span>
<span class="line-modified">!     BufferNode* volatile _head;</span>
<span class="line-modified">!     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));</span>
<span class="line-modified">!     BufferNode* volatile _tail;</span>
<span class="line-modified">!     DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));</span>
<span class="line-added">+ </span>
<span class="line-added">+     NONCOPYABLE(Queue);</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+     Queue() : _head(NULL), _tail(NULL) {}</span>
<span class="line-added">+     DEBUG_ONLY(~Queue();)</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Return the first buffer in the queue.</span>
<span class="line-added">+     // Thread-safe, but the result may change immediately.</span>
<span class="line-added">+     BufferNode* top() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Thread-safe add the buffer to the end of the queue.</span>
<span class="line-added">+     void push(BufferNode&amp; node) { append(node, node); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Thread-safe add the buffers from first to last to the end of the queue.</span>
<span class="line-added">+     void append(BufferNode&amp; first, BufferNode&amp; last);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Thread-safe attempt to remove and return the first buffer in the queue.</span>
<span class="line-added">+     // Returns NULL if the queue is empty, or if a concurrent push/append</span>
<span class="line-added">+     // interferes.  Uses GlobalCounter critical sections to address the ABA</span>
<span class="line-added">+     // problem; this works with the buffer allocator&#39;s use of GlobalCounter</span>
<span class="line-added">+     // synchronization.</span>
<span class="line-added">+     BufferNode* pop();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Take all the buffers from the queue, leaving the queue empty.</span>
<span class="line-added">+     // Not thread-safe.</span>
<span class="line-added">+     HeadTail take_all();</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Concurrent refinement may stop processing in the middle of a buffer if</span>
<span class="line-added">+   // there is a pending safepoint, to avoid long delays to safepoint.  A</span>
<span class="line-added">+   // partially processed buffer needs to be recorded for processing by the</span>
<span class="line-added">+   // safepoint if it&#39;s a GC safepoint; otherwise it needs to be recorded for</span>
<span class="line-added">+   // further concurrent refinement work after the safepoint.  But if the</span>
<span class="line-added">+   // buffer was obtained from the completed buffer queue then it can&#39;t simply</span>
<span class="line-added">+   // be added back to the queue, as that would introduce a new source of ABA</span>
<span class="line-added">+   // for the queue.</span>
    //
<span class="line-modified">!   // The PausedBuffer object is used to record such buffers for the upcoming</span>
<span class="line-modified">!   // safepoint, and provides access to the buffers recorded for previous</span>
<span class="line-modified">!   // safepoints.  Before obtaining a buffer from the completed buffers queue,</span>
<span class="line-modified">!   // we first transfer any buffers from previous safepoints to the queue.</span>
<span class="line-modified">!   // This is ABA-safe because threads cannot be in the midst of a queue pop</span>
<span class="line-added">+   // across a safepoint.</span>
    //
<span class="line-modified">!   // The paused buffers are conceptually an extension of the completed buffers</span>
<span class="line-modified">!   // queue, and operations which need to deal with all of the queued buffers</span>
<span class="line-modified">!   // (such as concatenate_logs) also need to deal with any paused buffers.  In</span>
<span class="line-modified">!   // general, if a safepoint performs a GC then the paused buffers will be</span>
<span class="line-modified">!   // processed as part of it, and there won&#39;t be any paused buffers after a</span>
<span class="line-modified">!   // GC safepoint.</span>
<span class="line-added">+   class PausedBuffers {</span>
<span class="line-added">+     class PausedList : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added">+       BufferNode* volatile _head;</span>
<span class="line-added">+       BufferNode* _tail;</span>
<span class="line-added">+       size_t _safepoint_id;</span>
<span class="line-added">+ </span>
<span class="line-added">+       NONCOPYABLE(PausedList);</span>
<span class="line-added">+ </span>
<span class="line-added">+     public:</span>
<span class="line-added">+       PausedList();</span>
<span class="line-added">+       DEBUG_ONLY(~PausedList();)</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Return true if this list was created to hold buffers for the</span>
<span class="line-added">+       // next safepoint.</span>
<span class="line-added">+       // precondition: not at safepoint.</span>
<span class="line-added">+       bool is_next() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Thread-safe add the buffer to the list.</span>
<span class="line-added">+       // precondition: not at safepoint.</span>
<span class="line-added">+       // precondition: is_next().</span>
<span class="line-added">+       void add(BufferNode* node);</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Take all the buffers from the list.  Not thread-safe.</span>
<span class="line-added">+       HeadTail take();</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The most recently created list, which might be for either the next or</span>
<span class="line-added">+     // a previous safepoint, or might be NULL if the next list hasn&#39;t been</span>
<span class="line-added">+     // created yet.  We only need one list because of the requirement that</span>
<span class="line-added">+     // threads calling add() must first ensure there are no paused buffers</span>
<span class="line-added">+     // from a previous safepoint.  There might be many list instances existing</span>
<span class="line-added">+     // at the same time though; there can be many threads competing to create</span>
<span class="line-added">+     // and install the next list, and meanwhile there can be a thread dealing</span>
<span class="line-added">+     // with the previous list.</span>
<span class="line-added">+     PausedList* volatile _plist;</span>
<span class="line-added">+     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(PausedList*));</span>
<span class="line-added">+ </span>
<span class="line-added">+     NONCOPYABLE(PausedBuffers);</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+     PausedBuffers();</span>
<span class="line-added">+     DEBUG_ONLY(~PausedBuffers();)</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test whether there are any paused lists.</span>
<span class="line-added">+     // Thread-safe, but the answer may change immediately.</span>
<span class="line-added">+     bool is_empty() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Thread-safe add the buffer to paused list for next safepoint.</span>
<span class="line-added">+     // precondition: not at safepoint.</span>
<span class="line-added">+     // precondition: does not have paused buffers from a previous safepoint.</span>
<span class="line-added">+     void add(BufferNode* node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Thread-safe take all paused buffers for previous safepoints.</span>
<span class="line-added">+     // precondition: not at safepoint.</span>
<span class="line-added">+     HeadTail take_previous();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Take all the paused buffers.</span>
<span class="line-added">+     // precondition: at safepoint.</span>
<span class="line-added">+     HeadTail take_all();</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The primary refinement thread, for activation when the processing</span>
<span class="line-added">+   // threshold is reached.  NULL if there aren&#39;t any refinement threads.</span>
<span class="line-added">+   G1ConcurrentRefineThread* _primary_refinement_thread;</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(G1ConcurrentRefineThread*));</span>
<span class="line-added">+   // Upper bound on the number of cards in the completed and paused buffers.</span>
<span class="line-added">+   volatile size_t _num_cards;</span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));</span>
<span class="line-added">+   // Buffers ready for refinement.</span>
<span class="line-added">+   Queue _completed;           // Has inner padding, including trailer.</span>
<span class="line-added">+   // Buffers for which refinement is temporarily paused.</span>
<span class="line-added">+   PausedBuffers _paused;      // Has inner padding, including trailer.</span>
<span class="line-added">+ </span>
<span class="line-added">+   G1FreeIdSet _free_ids;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Activation threshold for the primary refinement thread.</span>
<span class="line-added">+   size_t _process_cards_threshold;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If the queue contains more cards than configured here, the</span>
<span class="line-added">+   // mutator must start doing some of the concurrent refinement work.</span>
<span class="line-added">+   size_t _max_cards;</span>
<span class="line-added">+   size_t _max_cards_padding;</span>
<span class="line-added">+   static const size_t MaxCardsUnlimited = SIZE_MAX;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Array of cumulative dirty cards refined by mutator threads.</span>
<span class="line-added">+   // Array has an entry per id in _free_ids.</span>
<span class="line-added">+   size_t* _mutator_refined_cards_counters;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Verify _num_cards == sum of cards in the completed queue.</span>
<span class="line-added">+   void verify_num_cards() const NOT_DEBUG_RETURN;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Thread-safe add a buffer to paused list for next safepoint.</span>
<span class="line-added">+   // precondition: not at safepoint.</span>
<span class="line-added">+   // precondition: does not have paused buffers from a previous safepoint.</span>
<span class="line-added">+   void record_paused_buffer(BufferNode* node);</span>
<span class="line-added">+   void enqueue_paused_buffers_aux(const HeadTail&amp; paused);</span>
<span class="line-added">+   // Thread-safe transfer paused buffers for previous safepoints to the queue.</span>
<span class="line-added">+   // precondition: not at safepoint.</span>
<span class="line-added">+   void enqueue_previous_paused_buffers();</span>
<span class="line-added">+   // Transfer all paused buffers to the queue.</span>
<span class="line-added">+   // precondition: at safepoint.</span>
<span class="line-added">+   void enqueue_all_paused_buffers();</span>
<span class="line-added">+ </span>
<span class="line-added">+   void abandon_completed_buffers();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Refine the cards in &quot;node&quot; from its index to buffer_size.</span>
<span class="line-added">+   // Stops processing if SuspendibleThreadSet::should_yield() is true.</span>
<span class="line-added">+   // Returns true if the entire buffer was processed, false if there</span>
<span class="line-added">+   // is a pending yield request.  The node&#39;s index is updated to exclude</span>
<span class="line-added">+   // the processed elements, e.g. up to the element before processing</span>
<span class="line-added">+   // stopped, or one past the last element if the entire buffer was</span>
<span class="line-added">+   // processed. Increments *total_refined_cards by the number of cards</span>
<span class="line-added">+   // processed and removed from the buffer.</span>
<span class="line-added">+   bool refine_buffer(BufferNode* node, uint worker_id, size_t* total_refined_cards);</span>
  
    bool mut_process_buffer(BufferNode* node);
  
<span class="line-modified">!   // If the number of completed buffers is &gt; stop_at, then remove and</span>
<span class="line-modified">!   // return a completed buffer from the list.  Otherwise, return NULL.</span>
<span class="line-modified">!   BufferNode* get_completed_buffer(size_t stop_at = 0);</span>
  
  public:
<span class="line-modified">!   G1DirtyCardQueueSet(BufferNode::Allocator* allocator);</span>
    ~G1DirtyCardQueueSet();
  
<span class="line-modified">!   void set_primary_refinement_thread(G1ConcurrentRefineThread* thread) {</span>
<span class="line-modified">!     _primary_refinement_thread = thread;</span>
<span class="line-modified">!   }</span>
  
    // The number of parallel ids that can be claimed to allow collector or
    // mutator threads to do card-processing work.
    static uint num_par_ids();
  
    static void handle_zero_index_for_thread(Thread* t);
  
<span class="line-modified">!   // Either process the entire buffer and return true, or enqueue the</span>
<span class="line-modified">!   // buffer and return false.  If the buffer is completely processed,</span>
<span class="line-modified">!   // it can be reused in place.</span>
<span class="line-added">+   bool process_or_enqueue_completed_buffer(BufferNode* node);</span>
  
<span class="line-modified">!   virtual void enqueue_completed_buffer(BufferNode* node);</span>
  
<span class="line-modified">!   // Upper bound on the number of cards currently in in this queue set.</span>
<span class="line-modified">!   // Read without synchronization.  The value may be high because there</span>
<span class="line-modified">!   // is a concurrent modification of the set of buffers.</span>
<span class="line-modified">!   size_t num_cards() const { return _num_cards; }</span>
  
<span class="line-modified">!   // Get/Set the number of cards that triggers log processing.</span>
<span class="line-modified">!   // Log processing should be done when the number of cards exceeds the</span>
<span class="line-added">+   // threshold.</span>
<span class="line-added">+   void set_process_cards_threshold(size_t sz) {</span>
<span class="line-added">+     _process_cards_threshold = sz;</span>
    }
<span class="line-added">+   size_t process_cards_threshold() const {</span>
<span class="line-added">+     return _process_cards_threshold;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   static const size_t ProcessCardsThresholdNever = SIZE_MAX;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Notify the consumer if the number of buffers crossed the threshold</span>
<span class="line-added">+   void notify_if_necessary();</span>
<span class="line-added">+ </span>
<span class="line-added">+   void merge_bufferlists(G1RedirtyCardsQueueSet* src);</span>
  
<span class="line-modified">!   G1BufferNodeList take_all_completed_buffers();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If there are more than stop_at cards in the completed buffers, pop</span>
<span class="line-added">+   // a buffer, refine its contents, and return true.  Otherwise return</span>
<span class="line-added">+   // false.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Stops processing a buffer if SuspendibleThreadSet::should_yield(),</span>
<span class="line-added">+   // recording the incompletely processed buffer for later processing of</span>
<span class="line-added">+   // the remainder.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Increments *total_refined_cards by the number of cards processed and</span>
<span class="line-added">+   // removed from the buffer.</span>
<span class="line-added">+   bool refine_completed_buffer_concurrently(uint worker_id,</span>
<span class="line-added">+                                             size_t stop_at,</span>
<span class="line-added">+                                             size_t* total_refined_cards);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If a full collection is happening, reset partial logs, and release</span>
    // completed ones: the full collection will make them all irrelevant.
    void abandon_logs();
  
    // If any threads have partial logs, add them to the global list of logs.
    void concatenate_logs();
  
<span class="line-modified">!   void set_max_cards(size_t m) {</span>
<span class="line-modified">!     _max_cards = m;</span>
    }
<span class="line-modified">!   size_t max_cards() const {</span>
<span class="line-modified">!     return _max_cards;</span>
    }
  
<span class="line-added">+   void set_max_cards_padding(size_t padding) {</span>
<span class="line-added">+     _max_cards_padding = padding;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   size_t max_cards_padding() const {</span>
<span class="line-added">+     return _max_cards_padding;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Total dirty cards refined by mutator threads.</span>
<span class="line-added">+   size_t total_mutator_refined_cards() const;</span>
  };
  
<span class="line-added">+ inline G1DirtyCardQueueSet* G1DirtyCardQueue::dirty_card_qset() const {</span>
<span class="line-added">+   return static_cast&lt;G1DirtyCardQueueSet*&gt;(qset());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
</pre>
<center><a href="g1DirtyCardQueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1EdenRegions.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1CollectionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 33 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 34 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;
 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/globalDefinitions.hpp&quot;
 38 #include &quot;utilities/quickSort.hpp&quot;
 39 
 40 G1CollectorState* G1CollectionSet::collector_state() {
 41   return _g1h-&gt;collector_state();
 42 }
 43 
 44 G1GCPhaseTimes* G1CollectionSet::phase_times() {
 45   return _policy-&gt;phase_times();
 46 }
 47 
 48 double G1CollectionSet::predict_region_elapsed_time_ms(HeapRegion* hr) {
 49   return _policy-&gt;predict_region_elapsed_time_ms(hr, collector_state()-&gt;in_young_only_phase());
 50 }
 51 
 52 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
 53   _g1h(g1h),
 54   _policy(policy),
 55   _candidates(NULL),
 56   _eden_region_length(0),
 57   _survivor_region_length(0),
 58   _old_region_length(0),
 59   _collection_set_regions(NULL),
 60   _collection_set_cur_length(0),
 61   _collection_set_max_length(0),
 62   _optional_regions(NULL),
 63   _optional_region_length(0),
 64   _optional_region_max_length(0),
 65   _bytes_used_before(0),
 66   _recorded_rs_lengths(0),
 67   _inc_build_state(Inactive),
 68   _inc_bytes_used_before(0),
 69   _inc_recorded_rs_lengths(0),
 70   _inc_recorded_rs_lengths_diffs(0),
 71   _inc_predicted_elapsed_time_ms(0.0),
 72   _inc_predicted_elapsed_time_ms_diffs(0.0) {
 73 }
 74 
 75 G1CollectionSet::~G1CollectionSet() {
 76   if (_collection_set_regions != NULL) {
 77     FREE_C_HEAP_ARRAY(uint, _collection_set_regions);
 78   }
 79   free_optional_regions();
 80   clear_candidates();
 81 }
 82 
 83 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
 84                                           uint survivor_cset_region_length) {
 85   assert_at_safepoint_on_vm_thread();
 86 
 87   _eden_region_length     = eden_cset_region_length;
 88   _survivor_region_length = survivor_cset_region_length;
 89 
 90   assert((size_t) young_region_length() == _collection_set_cur_length,
 91          &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 92 
 93   _old_region_length      = 0;
 94   _optional_region_length = 0;
 95 }
 96 
 97 void G1CollectionSet::initialize(uint max_region_length) {
 98   guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
 99   _collection_set_max_length = max_region_length;
100   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
101 }
102 
103 void G1CollectionSet::initialize_optional(uint max_length) {
104   assert(_optional_regions == NULL, &quot;Already initialized&quot;);
105   assert(_optional_region_length == 0, &quot;Already initialized&quot;);
106   assert(_optional_region_max_length == 0, &quot;Already initialized&quot;);
107   _optional_region_max_length = max_length;
108   _optional_regions = NEW_C_HEAP_ARRAY(HeapRegion*, _optional_region_max_length, mtGC);
109 }
110 
111 void G1CollectionSet::free_optional_regions() {
112   _optional_region_length = 0;
113   _optional_region_max_length = 0;
114   if (_optional_regions != NULL) {
115     FREE_C_HEAP_ARRAY(HeapRegion*, _optional_regions);
116     _optional_regions = NULL;
117   }
118 }
119 
120 void G1CollectionSet::clear_candidates() {
121   delete _candidates;
122   _candidates = NULL;
123 }
124 
125 void G1CollectionSet::set_recorded_rs_lengths(size_t rs_lengths) {
126   _recorded_rs_lengths = rs_lengths;
127 }
128 
129 // Add the heap region at the head of the non-incremental collection set
130 void G1CollectionSet::add_old_region(HeapRegion* hr) {
131   assert_at_safepoint_on_vm_thread();
132 
133   assert(_inc_build_state == Active || hr-&gt;index_in_opt_cset() != G1OptionalCSet::InvalidCSetIndex,
134          &quot;Precondition, actively building cset or adding optional later on&quot;);
135   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
136 
137   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
138   _g1h-&gt;register_old_region_with_cset(hr);
139 
140   _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
141   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
142 
143   _bytes_used_before += hr-&gt;used();
144   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
145   _recorded_rs_lengths += rs_length;
146   _old_region_length += 1;
147 
148   log_trace(gc, cset)(&quot;Added old region %d to collection set&quot;, hr-&gt;hrm_index());
149 }
150 
151 void G1CollectionSet::add_optional_region(HeapRegion* hr) {
152   assert(!optional_is_full(), &quot;Precondition, must have room left for this region&quot;);
153   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
154   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
155 
156   _g1h-&gt;register_optional_region_with_cset(hr);
157 
158   _optional_regions[_optional_region_length] = hr;
159   uint index = _optional_region_length++;
160   hr-&gt;set_index_in_opt_cset(index);
161 
162   log_trace(gc, cset)(&quot;Added region %d to optional collection set (%u)&quot;, hr-&gt;hrm_index(), _optional_region_length);
163 }
164 
165 // Initialize the per-collection-set information
166 void G1CollectionSet::start_incremental_building() {
167   assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
168   assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
169 
170   _inc_bytes_used_before = 0;
171 
172   _inc_recorded_rs_lengths = 0;
173   _inc_recorded_rs_lengths_diffs = 0;
174   _inc_predicted_elapsed_time_ms = 0.0;
175   _inc_predicted_elapsed_time_ms_diffs = 0.0;
176   _inc_build_state = Active;
177 }
178 
179 void G1CollectionSet::finalize_incremental_building() {
180   assert(_inc_build_state == Active, &quot;Precondition&quot;);
181   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
182 
183   // The two &quot;main&quot; fields, _inc_recorded_rs_lengths and
184   // _inc_predicted_elapsed_time_ms, are updated by the thread
185   // that adds a new region to the CSet. Further updates by the
186   // concurrent refinement thread that samples the young RSet lengths
187   // are accumulated in the *_diffs fields. Here we add the diffs to
188   // the &quot;main&quot; fields.
189 
190   if (_inc_recorded_rs_lengths_diffs &gt;= 0) {
191     _inc_recorded_rs_lengths += _inc_recorded_rs_lengths_diffs;
192   } else {
193     // This is defensive. The diff should in theory be always positive
194     // as RSets can only grow between GCs. However, given that we
195     // sample their size concurrently with other threads updating them
196     // it&#39;s possible that we might get the wrong size back, which
197     // could make the calculations somewhat inaccurate.
198     size_t diffs = (size_t) (-_inc_recorded_rs_lengths_diffs);
199     if (_inc_recorded_rs_lengths &gt;= diffs) {
200       _inc_recorded_rs_lengths -= diffs;
201     } else {
202       _inc_recorded_rs_lengths = 0;
203     }
204   }
205   _inc_predicted_elapsed_time_ms += _inc_predicted_elapsed_time_ms_diffs;
206 
207   _inc_recorded_rs_lengths_diffs = 0;
208   _inc_predicted_elapsed_time_ms_diffs = 0.0;
209 }
210 
211 void G1CollectionSet::clear() {
212   assert_at_safepoint_on_vm_thread();
213   _collection_set_cur_length = 0;
214   _optional_region_length = 0;
215 }
216 
217 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
218   iterate_from(cl, 0, 1);
219 }
220 
221 void G1CollectionSet::iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const {
222   size_t len = _collection_set_cur_length;
223   OrderAccess::loadload();
224   if (len == 0) {
225     return;
226   }
227   size_t start_pos = (worker_id * len) / total_workers;
228   size_t cur_pos = start_pos;
229 
230   do {
231     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[cur_pos]);
232     bool result = cl-&gt;do_heap_region(r);
233     if (result) {
234       cl-&gt;set_incomplete();
235       return;
236     }
237     cur_pos++;
238     if (cur_pos == len) {
239       cur_pos = 0;
240     }
241   } while (cur_pos != start_pos);
242 }
243 
244 void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,
245                                                      size_t new_rs_length) {
246   // Update the CSet information that is dependent on the new RS length
247   assert(hr-&gt;is_young(), &quot;Precondition&quot;);
248   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
249 
250   // We could have updated _inc_recorded_rs_lengths and
251   // _inc_predicted_elapsed_time_ms directly but we&#39;d need to do
252   // that atomically, as this code is executed by a concurrent
253   // refinement thread, potentially concurrently with a mutator thread
254   // allocating a new region and also updating the same fields. To
255   // avoid the atomic operations we accumulate these updates on two
256   // separate fields (*_diffs) and we&#39;ll just add them to the &quot;main&quot;
257   // fields at the start of a GC.
258 
259   ssize_t old_rs_length = (ssize_t) hr-&gt;recorded_rs_length();
260   ssize_t rs_lengths_diff = (ssize_t) new_rs_length - old_rs_length;
261   _inc_recorded_rs_lengths_diffs += rs_lengths_diff;
262 
263   double old_elapsed_time_ms = hr-&gt;predicted_elapsed_time_ms();
264   double new_region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);
265   double elapsed_ms_diff = new_region_elapsed_time_ms - old_elapsed_time_ms;
266   _inc_predicted_elapsed_time_ms_diffs += elapsed_ms_diff;
267 
268   hr-&gt;set_recorded_rs_length(new_rs_length);
269   hr-&gt;set_predicted_elapsed_time_ms(new_region_elapsed_time_ms);
270 }
271 
272 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
273   assert(hr-&gt;is_young(), &quot;invariant&quot;);
274   assert(_inc_build_state == Active, &quot;Precondition&quot;);
275 
276   size_t collection_set_length = _collection_set_cur_length;
277   assert(collection_set_length &lt;= INT_MAX, &quot;Collection set is too large with %d entries&quot;, (int)collection_set_length);
278   hr-&gt;set_young_index_in_cset((int)collection_set_length);
279 
280   _collection_set_regions[collection_set_length] = hr-&gt;hrm_index();
281   // Concurrent readers must observe the store of the value in the array before an
282   // update to the length field.
283   OrderAccess::storestore();
284   _collection_set_cur_length++;
285   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);
286 
287   // This routine is used when:
288   // * adding survivor regions to the incremental cset at the end of an
289   //   evacuation pause or
290   // * adding the current allocation region to the incremental cset
291   //   when it is retired.
292   // Therefore this routine may be called at a safepoint by the
293   // VM thread, or in-between safepoints by mutator threads (when
294   // retiring the current allocation region)
295   // We need to clear and set the cached recorded/cached collection set
296   // information in the heap region here (before the region gets added
297   // to the collection set). An individual heap region&#39;s cached values
298   // are calculated, aggregated with the policy collection set info,
299   // and cached in the heap region here (initially) and (subsequently)
300   // by the Young List sampling code.
301   // Ignore calls to this due to retirement during full gc.
302 
303   if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
304     size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
305     double region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);
306 
307     // Cache the values we have added to the aggregated information
308     // in the heap region in case we have to remove this region from
309     // the incremental collection set, or it is updated by the
310     // rset sampling code
311     hr-&gt;set_recorded_rs_length(rs_length);
312     hr-&gt;set_predicted_elapsed_time_ms(region_elapsed_time_ms);
313 
314     _inc_recorded_rs_lengths += rs_length;
315     _inc_predicted_elapsed_time_ms += region_elapsed_time_ms;
316     _inc_bytes_used_before += hr-&gt;used();
317   }
318 
319   assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
320   _g1h-&gt;register_young_region_with_cset(hr);
321 }
322 
323 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
324   assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
325   add_young_region_common(hr);
326 }
327 
328 void G1CollectionSet::add_eden_region(HeapRegion* hr) {
329   assert(hr-&gt;is_eden(), &quot;Must only add eden regions, but is %s&quot;, hr-&gt;get_type_str());
330   add_young_region_common(hr);
331 }
332 
333 #ifndef PRODUCT
334 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
335 public:
336   bool _valid;
337 public:
338   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
339 
340   virtual bool do_heap_region(HeapRegion* r) {
341     guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
342 
343     SurvRateGroup* group = r-&gt;surv_rate_group();
344 
345     if (group == NULL) {
346       log_error(gc, verify)(&quot;## encountered NULL surv_rate_group in young region&quot;);
347       _valid = false;
348     }
349 
350     if (r-&gt;age_in_surv_rate_group() &lt; 0) {
351       log_error(gc, verify)(&quot;## encountered negative age in young region&quot;);
352       _valid = false;
353     }
354 
355     return false;
356   }
357 
358   bool valid() const { return _valid; }
359 };
360 
361 bool G1CollectionSet::verify_young_ages() {
362   assert_at_safepoint_on_vm_thread();
363 
364   G1VerifyYoungAgesClosure cl;
365   iterate(&amp;cl);
366 
367   if (!cl.valid()) {
368     LogStreamHandle(Error, gc, verify) log;
369     print(&amp;log);
370   }
371 
372   return cl.valid();
373 }
374 
375 class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {
376   outputStream* _st;
377 public:
378   G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }
379 
380   virtual bool do_heap_region(HeapRegion* r) {
381     assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
382     _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
383                   HR_FORMAT_PARAMS(r),
384                   p2i(r-&gt;prev_top_at_mark_start()),
385                   p2i(r-&gt;next_top_at_mark_start()),
386                   r-&gt;age_in_surv_rate_group_cond());
387     return false;
388   }
389 };
390 
391 void G1CollectionSet::print(outputStream* st) {
392   st-&gt;print_cr(&quot;\nCollection_set:&quot;);
393 
394   G1PrintCollectionSetDetailClosure cl(st);
395   iterate(&amp;cl);
396 }
397 #endif // !PRODUCT
398 
399 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
400   double young_start_time_sec = os::elapsedTime();
401 
402   finalize_incremental_building();
403 
404   guarantee(target_pause_time_ms &gt; 0.0,
405             &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
406 
407   size_t pending_cards = _policy-&gt;pending_cards();
408   double base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);
409   double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);
410 
411   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. pending cards: &quot; SIZE_FORMAT &quot; predicted base time: %1.2fms remaining time: %1.2fms target pause time: %1.2fms&quot;,
412                             pending_cards, base_time_ms, time_remaining_ms, target_pause_time_ms);
413 
414   // The young list is laid with the survivor regions from the previous
415   // pause are appended to the RHS of the young list, i.e.
416   //   [Newly Young Regions ++ Survivors from last pause].
417 
418   uint survivor_region_length = survivors-&gt;length();
419   uint eden_region_length = _g1h-&gt;eden_regions_count();
420   init_region_lengths(eden_region_length, survivor_region_length);
421 
422   verify_young_cset_indices();
423 
424   // Clear the fields that point to the survivor list - they are all young now.
425   survivors-&gt;convert_to_eden();
426 
427   _bytes_used_before = _inc_bytes_used_before;
428   time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);
429 
430   log_trace(gc, ergo, cset)(&quot;Add young regions to CSet. eden: %u regions, survivors: %u regions, predicted young region time: %1.2fms, target pause time: %1.2fms&quot;,
431                             eden_region_length, survivor_region_length, _inc_predicted_elapsed_time_ms, target_pause_time_ms);
432 
433   // The number of recorded young regions is the incremental
434   // collection set&#39;s current size
435   set_recorded_rs_lengths(_inc_recorded_rs_lengths);
436 
437   double young_end_time_sec = os::elapsedTime();
438   phase_times()-&gt;record_young_cset_choice_time_ms((young_end_time_sec - young_start_time_sec) * 1000.0);
439 
440   return time_remaining_ms;
441 }
442 
443 void G1CollectionSet::add_as_old(HeapRegion* hr) {
444   candidates()-&gt;pop_front(); // already have region via peek()
445   _g1h-&gt;old_set_remove(hr);
446   add_old_region(hr);
447 }
448 
449 void G1CollectionSet::add_as_optional(HeapRegion* hr) {
450   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);
451   candidates()-&gt;pop_front(); // already have region via peek()
452   _g1h-&gt;old_set_remove(hr);
453   add_optional_region(hr);
454 }
455 
456 bool G1CollectionSet::optional_is_full() {
457   assert(_optional_region_length &lt;= _optional_region_max_length, &quot;Invariant&quot;);
458   return _optional_region_length == _optional_region_max_length;
459 }
460 
461 void G1CollectionSet::clear_optional_region(const HeapRegion* hr) {
462   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);
463   uint index = hr-&gt;index_in_opt_cset();
464   _optional_regions[index] = NULL;
465 }
466 
467 static int compare_region_idx(const uint a, const uint b) {
468   if (a &gt; b) {
469     return 1;
470   } else if (a == b) {
471     return 0;
472   } else {
473     return -1;
474   }
475 }
476 
477 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
478   double non_young_start_time_sec = os::elapsedTime();
479   double predicted_old_time_ms = 0.0;
480   double predicted_optional_time_ms = 0.0;
481   double optional_threshold_ms = time_remaining_ms * _policy-&gt;optional_prediction_fraction();
482   uint expensive_region_num = 0;
483 
484   if (collector_state()-&gt;in_mixed_phase()) {
485     candidates()-&gt;verify();
486     const uint min_old_cset_length = _policy-&gt;calc_min_old_cset_length();
487     const uint max_old_cset_length = MAX2(min_old_cset_length, _policy-&gt;calc_max_old_cset_length());
488     bool check_time_remaining = _policy-&gt;adaptive_young_list_length();
489 
490     initialize_optional(max_old_cset_length - min_old_cset_length);
491     log_debug(gc, ergo, cset)(&quot;Start adding old regions for mixed gc. min %u regions, max %u regions, &quot;
492                               &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,
493                               min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);
494 
495     HeapRegion* hr = candidates()-&gt;peek_front();
496     while (hr != NULL) {
497       if (old_region_length() + optional_region_length() &gt;= max_old_cset_length) {
498         // Added maximum number of old regions to the CSet.
499         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached max). &quot;
500                                   &quot;old %u regions, optional %u regions&quot;,
501                                   old_region_length(), optional_region_length());
502         break;
503       }
504 
505       // Stop adding regions if the remaining reclaimable space is
506       // not above G1HeapWastePercent.
507       size_t reclaimable_bytes = candidates()-&gt;remaining_reclaimable_bytes();
508       double reclaimable_percent = _policy-&gt;reclaimable_bytes_percent(reclaimable_bytes);
509       double threshold = (double) G1HeapWastePercent;
510       if (reclaimable_percent &lt;= threshold) {
511         // We&#39;ve added enough old regions that the amount of uncollected
512         // reclaimable space is at or below the waste threshold. Stop
513         // adding old regions to the CSet.
514         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (reclaimable percentage not over threshold). &quot;
515                                   &quot;reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,
516                                   byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),
517                                   reclaimable_percent, G1HeapWastePercent);
518         break;
519       }
520 
521       double predicted_time_ms = predict_region_elapsed_time_ms(hr);
522       time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
523       // Add regions to old set until we reach minimum amount
524       if (old_region_length() &lt; min_old_cset_length) {
525         predicted_old_time_ms += predicted_time_ms;
526         add_as_old(hr);
527         // Record the number of regions added when no time remaining
528         if (time_remaining_ms == 0.0) {
529           expensive_region_num++;
530         }
531       } else {
532         // In the non-auto-tuning case, we&#39;ll finish adding regions
533         // to the CSet if we reach the minimum.
534         if (!check_time_remaining) {
535           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached min).&quot;);
536           break;
537         }
538         // Keep adding regions to old set until we reach optional threshold
539         if (time_remaining_ms &gt; optional_threshold_ms) {
540           predicted_old_time_ms += predicted_time_ms;
541           add_as_old(hr);
542         } else if (time_remaining_ms &gt; 0) {
543           // Keep adding optional regions until time is up
544           if (!optional_is_full()) {
545             predicted_optional_time_ms += predicted_time_ms;
546             add_as_optional(hr);
547           } else {
548             log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (optional set full).&quot;);
549             break;
550           }
551         } else {
552           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (predicted time is too high).&quot;);
553           break;
554         }
555       }
556       hr = candidates()-&gt;peek_front();
557     }
558     if (hr == NULL) {
559       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (candidate old regions not available)&quot;);
560     }
561 
562     candidates()-&gt;verify();
563   }
564 
565   stop_incremental_building();
566 
567   log_debug(gc, ergo, cset)(&quot;Finish choosing CSet regions old: %u, optional: %u, &quot;
568                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,
569                             old_region_length(), optional_region_length(),
570                             predicted_old_time_ms, predicted_optional_time_ms, time_remaining_ms);
571   if (expensive_region_num &gt; 0) {
572     log_debug(gc, ergo, cset)(&quot;CSet contains %u old regions that were added although the predicted time was too high.&quot;,
573                               expensive_region_num);
574   }
575 
576   double non_young_end_time_sec = os::elapsedTime();
577   phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
578 
579   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
580 }
581 
582 HeapRegion* G1OptionalCSet::region_at(uint index) {
583   return _cset-&gt;optional_region_at(index);
584 }
585 
586 void G1OptionalCSet::prepare_evacuation(double time_limit) {
587   assert(_current_index == _current_limit, &quot;Before prepare no regions should be ready for evac&quot;);
588 
589   uint prepared_regions = 0;
590   double prediction_ms = 0;
591 
592   _prepare_failed = true;
593   for (uint i = _current_index; i &lt; _cset-&gt;optional_region_length(); i++) {
594     HeapRegion* hr = region_at(i);
595     prediction_ms += _cset-&gt;predict_region_elapsed_time_ms(hr);
596     if (prediction_ms &gt; time_limit) {
597       log_debug(gc, cset)(&quot;Prepared %u regions for optional evacuation. Predicted time: %.3fms&quot;, prepared_regions, prediction_ms);
598       return;
599     }
600 
601     // This region will be included in the next optional evacuation.
602     prepare_to_evacuate_optional_region(hr);
603     prepared_regions++;
604     _current_limit++;
605     _prepare_failed = false;
606   }
607 
608   log_debug(gc, cset)(&quot;Prepared all %u regions for optional evacuation. Predicted time: %.3fms&quot;,
609                       prepared_regions, prediction_ms);
610 }
611 
612 bool G1OptionalCSet::prepare_failed() {
613   return _prepare_failed;
614 }
615 
616 void G1OptionalCSet::complete_evacuation() {
617   _evacuation_failed = false;
618   for (uint i = _current_index; i &lt; _current_limit; i++) {
619     HeapRegion* hr = region_at(i);
620     _cset-&gt;clear_optional_region(hr);
621     if (hr-&gt;evacuation_failed()){
622       _evacuation_failed = true;
623     }
624   }
625   _current_index = _current_limit;
626 }
627 
628 bool G1OptionalCSet::evacuation_failed() {
629   return _evacuation_failed;
630 }
631 
632 G1OptionalCSet::~G1OptionalCSet() {
633   G1CollectedHeap* g1h = G1CollectedHeap::heap();
634   while (!is_empty()) {
635     // We want to return regions not evacuated to the collection set candidates
636     // in reverse order to maintain the old order.
637     HeapRegion* hr = _cset-&gt;remove_last_optional_region();
638     assert(hr != NULL, &quot;Should be valid region left&quot;);
639     _pset-&gt;record_unused_optional_region(hr);
640     g1h-&gt;old_set_add(hr);
641     g1h-&gt;clear_in_cset(hr);
642     hr-&gt;set_index_in_opt_cset(InvalidCSetIndex);
643     _cset-&gt;candidates()-&gt;push_front(hr);
644   }
645   _cset-&gt;free_optional_regions();
646 }
647 
648 uint G1OptionalCSet::size() {
649   return _cset-&gt;optional_region_length() - _current_index;
650 }
651 
652 bool G1OptionalCSet::is_empty() {
653   return size() == 0;
654 }
655 
656 void G1OptionalCSet::prepare_to_evacuate_optional_region(HeapRegion* hr) {
657   log_trace(gc, cset)(&quot;Adding region %u for optional evacuation&quot;, hr-&gt;hrm_index());
658   G1CollectedHeap::heap()-&gt;clear_in_cset(hr);
659   _cset-&gt;add_old_region(hr);
660 }
661 
662 #ifdef ASSERT
663 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
664 private:
665   size_t _young_length;
666   int* _heap_region_indices;
667 public:
668   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
669     _heap_region_indices = NEW_C_HEAP_ARRAY(int, young_length, mtGC);
670     for (size_t i = 0; i &lt; young_length; i++) {
671       _heap_region_indices[i] = -1;
672     }
673   }
674   ~G1VerifyYoungCSetIndicesClosure() {
675     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
676   }
677 
678   virtual bool do_heap_region(HeapRegion* r) {
679     const int idx = r-&gt;young_index_in_cset();
680 
681     assert(idx &gt; -1, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());
682     assert((size_t)idx &lt; _young_length, &quot;Young cset index too large for region %u&quot;, r-&gt;hrm_index());
683 
684     assert(_heap_region_indices[idx] == -1,
685            &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
686            idx, _heap_region_indices[idx], r-&gt;hrm_index());
687 
688     _heap_region_indices[idx] = r-&gt;hrm_index();
689 
690     return false;
691   }
692 };
693 
694 void G1CollectionSet::verify_young_cset_indices() const {
695   assert_at_safepoint_on_vm_thread();
696 
697   G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);
698   iterate(&amp;cl);
699 }
700 #endif
    </pre>
  </body>
</html>
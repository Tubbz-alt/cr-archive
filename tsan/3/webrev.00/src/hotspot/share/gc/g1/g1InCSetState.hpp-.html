<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1InCSetState.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1INCSETSTATE_HPP
 26 #define SHARE_GC_G1_G1INCSETSTATE_HPP
 27 
 28 #include &quot;gc/g1/g1BiasedArray.hpp&quot;
 29 #include &quot;gc/g1/heapRegion.hpp&quot;
 30 
 31 // Per-region state during garbage collection.
 32 struct InCSetState {
 33  public:
 34   // We use different types to represent the state value. Particularly SPARC puts
 35   // values in structs from &quot;left to right&quot;, i.e. MSB to LSB. This results in many
 36   // unnecessary shift operations when loading and storing values of this type.
 37   // This degrades performance significantly (&gt;10%) on that platform.
 38   // Other tested ABIs do not seem to have this problem, and actually tend to
 39   // favor smaller types, so we use the smallest usable type there.
 40 #ifdef SPARC
 41   #define CSETSTATE_FORMAT INTPTR_FORMAT
 42   typedef intptr_t in_cset_state_t;
 43 #else
 44   #define CSETSTATE_FORMAT &quot;%d&quot;
 45   typedef int8_t in_cset_state_t;
 46 #endif
 47  private:
 48   in_cset_state_t _value;
 49  public:
 50   enum {
 51     // Selection of the values were driven to micro-optimize the encoding and
 52     // frequency of the checks.
 53     // The most common check is whether the region is in the collection set or not,
 54     // this encoding allows us to use an &gt; 0 check.
 55     // The positive values are encoded in increasing generation order, which
 56     // makes getting the next generation fast by a simple increment. They are also
 57     // used to index into arrays.
 58     // The negative values are used for objects requiring various special cases,
 59     // for example eager reclamation of humongous objects or optional regions.
 60     Optional     = -2,    // The region is optional
 61     Humongous    = -1,    // The region is humongous
 62     NotInCSet    =  0,    // The region is not in the collection set.
 63     Young        =  1,    // The region is in the collection set and a young region.
 64     Old          =  2,    // The region is in the collection set and an old region.
 65     Num
 66   };
 67 
 68   InCSetState(in_cset_state_t value = NotInCSet) : _value(value) {
 69     assert(is_valid(), &quot;Invalid state %d&quot;, _value);
 70   }
 71 
 72   in_cset_state_t value() const        { return _value; }
 73 
 74   void set_old()                       { _value = Old; }
 75 
 76   bool is_in_cset_or_humongous() const { return is_in_cset() || is_humongous(); }
 77   bool is_in_cset() const              { return _value &gt; NotInCSet; }
 78 
 79   bool is_humongous() const            { return _value == Humongous; }
 80   bool is_young() const                { return _value == Young; }
 81   bool is_old() const                  { return _value == Old; }
 82   bool is_optional() const             { return _value == Optional; }
 83 
 84 #ifdef ASSERT
 85   bool is_default() const              { return _value == NotInCSet; }
 86   bool is_valid() const                { return (_value &gt;= Optional) &amp;&amp; (_value &lt; Num); }
 87   bool is_valid_gen() const            { return (_value &gt;= Young &amp;&amp; _value &lt;= Old); }
 88 #endif
 89 };
 90 
 91 // Instances of this class are used for quick tests on whether a reference points
 92 // into the collection set and into which generation or is a humongous object
 93 //
 94 // Each of the array&#39;s elements indicates whether the corresponding region is in
 95 // the collection set and if so in which generation, or a humongous region.
 96 //
 97 // We use this to speed up reference processing during young collection and
 98 // quickly reclaim humongous objects. For the latter, by making a humongous region
 99 // succeed this test, we sort-of add it to the collection set. During the reference
100 // iteration closures, when we see a humongous region, we then simply mark it as
101 // referenced, i.e. live.
102 class G1InCSetStateFastTestBiasedMappedArray : public G1BiasedMappedArray&lt;InCSetState&gt; {
103  protected:
104   InCSetState default_value() const { return InCSetState::NotInCSet; }
105  public:
106   void set_optional(uintptr_t index) {
107     assert(get_by_index(index).is_default(),
108            &quot;State at index &quot; INTPTR_FORMAT &quot; should be default but is &quot; CSETSTATE_FORMAT, index, get_by_index(index).value());
109     set_by_index(index, InCSetState::Optional);
110   }
111 
112   void set_humongous(uintptr_t index) {
113     assert(get_by_index(index).is_default(),
114            &quot;State at index &quot; INTPTR_FORMAT &quot; should be default but is &quot; CSETSTATE_FORMAT, index, get_by_index(index).value());
115     set_by_index(index, InCSetState::Humongous);
116   }
117 
118   void clear_humongous(uintptr_t index) {
119     set_by_index(index, InCSetState::NotInCSet);
120   }
121 
122   void set_in_young(uintptr_t index) {
123     assert(get_by_index(index).is_default(),
124            &quot;State at index &quot; INTPTR_FORMAT &quot; should be default but is &quot; CSETSTATE_FORMAT, index, get_by_index(index).value());
125     set_by_index(index, InCSetState::Young);
126   }
127 
128   void set_in_old(uintptr_t index) {
129     assert(get_by_index(index).is_default(),
130            &quot;State at index &quot; INTPTR_FORMAT &quot; should be default but is &quot; CSETSTATE_FORMAT, index, get_by_index(index).value());
131     set_by_index(index, InCSetState::Old);
132   }
133 
134   bool is_in_cset_or_humongous(HeapWord* addr) const { return at(addr).is_in_cset_or_humongous(); }
135   bool is_in_cset(HeapWord* addr) const { return at(addr).is_in_cset(); }
136   bool is_in_cset(const HeapRegion* hr) const { return get_by_index(hr-&gt;hrm_index()).is_in_cset(); }
137   InCSetState at(HeapWord* addr) const { return get_by_address(addr); }
138   void clear() { G1BiasedMappedArray&lt;InCSetState&gt;::clear(); }
139   void clear(const HeapRegion* hr) { return set_by_index(hr-&gt;hrm_index(), InCSetState::NotInCSet); }
140 };
141 
142 #endif // SHARE_GC_G1_G1INCSETSTATE_HPP
    </pre>
  </body>
</html>
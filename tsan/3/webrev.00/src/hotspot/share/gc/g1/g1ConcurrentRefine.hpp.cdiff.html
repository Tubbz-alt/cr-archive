<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefine.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,10 ***</span>
<span class="line-new-header">--- 25,11 ---</span>
  #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
  #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added">+ #include &quot;utilities/ticks.hpp&quot;</span>
  
  // Forward decl
  class G1ConcurrentRefine;
  class G1ConcurrentRefineThread;
  class outputStream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,32 ***</span>
    void print_on(outputStream* st) const;
    void worker_threads_do(ThreadClosure* tc);
    void stop();
  };
  
<span class="line-modified">! // Controls refinement threads and their activation based on the number of completed</span>
<span class="line-modified">! // buffers currently available in the global dirty card queue.</span>
<span class="line-modified">! // Refinement threads pick work from the queue based on these thresholds. They are activated</span>
<span class="line-modified">! // gradually based on the amount of work to do.</span>
  // Refinement thread n activates thread n+1 if the instance of this class determines there
  // is enough work available. Threads deactivate themselves if the current amount of
<span class="line-modified">! // completed buffers falls below their individual threshold.</span>
  class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
    G1ConcurrentRefineThreadControl _thread_control;
    /*
     * The value of the completed dirty card queue length falls into one of 3 zones:
     * green, yellow, red. If the value is in [0, green) nothing is
<span class="line-modified">!    * done, the buffers are left unprocessed to enable the caching effect of the</span>
     * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
     * threads are gradually activated. In [yellow, red) all threads are
     * running. If the length becomes red (max queue length) the mutators start
<span class="line-modified">!    * processing the buffers.</span>
     *
     * There are some interesting cases (when G1UseAdaptiveConcRefinement
     * is turned off):
     * 1) green = yellow = red = 0. In this case the mutator will process all
<span class="line-modified">!    *    buffers. Except for those that are created by the deferred updates</span>
     *    machinery during a collection.
     * 2) green = 0. Means no caching. Can be a good way to minimize the
     *    amount of time spent updating remembered sets during a collection.
     */
    size_t _green_zone;
<span class="line-new-header">--- 59,33 ---</span>
    void print_on(outputStream* st) const;
    void worker_threads_do(ThreadClosure* tc);
    void stop();
  };
  
<span class="line-modified">! // Controls refinement threads and their activation based on the number of</span>
<span class="line-modified">! // cards currently available in the global dirty card queue.</span>
<span class="line-modified">! // Refinement threads obtain work from the queue (a buffer at a time) based</span>
<span class="line-modified">! // on these thresholds. They are activated gradually based on the amount of</span>
<span class="line-added">+ // work to do.</span>
  // Refinement thread n activates thread n+1 if the instance of this class determines there
  // is enough work available. Threads deactivate themselves if the current amount of
<span class="line-modified">! // available cards falls below their individual threshold.</span>
  class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
    G1ConcurrentRefineThreadControl _thread_control;
    /*
     * The value of the completed dirty card queue length falls into one of 3 zones:
     * green, yellow, red. If the value is in [0, green) nothing is
<span class="line-modified">!    * done, the buffered cards are left unprocessed to enable the caching effect of the</span>
     * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
     * threads are gradually activated. In [yellow, red) all threads are
     * running. If the length becomes red (max queue length) the mutators start
<span class="line-modified">!    * processing cards too.</span>
     *
     * There are some interesting cases (when G1UseAdaptiveConcRefinement
     * is turned off):
     * 1) green = yellow = red = 0. In this case the mutator will process all
<span class="line-modified">!    *    cards. Except for those that are created by the deferred updates</span>
     *    machinery during a collection.
     * 2) green = 0. Means no caching. Can be a good way to minimize the
     *    amount of time spent updating remembered sets during a collection.
     */
    size_t _green_zone;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,16 ***</span>
                       size_t yellow_zone,
                       size_t red_zone,
                       size_t min_yellow_zone_size);
  
    // Update green/yellow/red zone values based on how well goals are being met.
<span class="line-modified">!   void update_zones(double update_rs_time,</span>
<span class="line-modified">!                     size_t update_rs_processed_buffers,</span>
                      double goal_ms);
  
    static uint worker_id_offset();
<span class="line-modified">!   void maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers);</span>
  
    jint initialize();
  public:
    ~G1ConcurrentRefine();
  
<span class="line-new-header">--- 97,16 ---</span>
                       size_t yellow_zone,
                       size_t red_zone,
                       size_t min_yellow_zone_size);
  
    // Update green/yellow/red zone values based on how well goals are being met.
<span class="line-modified">!   void update_zones(double logged_cards_scan_time,</span>
<span class="line-modified">!                     size_t processed_logged_cards,</span>
                      double goal_ms);
  
    static uint worker_id_offset();
<span class="line-modified">!   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);</span>
  
    jint initialize();
  public:
    ~G1ConcurrentRefine();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,25 ***</span>
    static G1ConcurrentRefine* create(jint* ecode);
  
    void stop();
  
    // Adjust refinement thresholds based on work done during the pause and the goal time.
<span class="line-modified">!   void adjust(double update_rs_time, size_t update_rs_processed_buffers, double goal_ms);</span>
  
    size_t activation_threshold(uint worker_id) const;
    size_t deactivation_threshold(uint worker_id) const;
<span class="line-modified">!   // Perform a single refinement step. Called by the refinement threads when woken up.</span>
<span class="line-modified">!   bool do_refinement_step(uint worker_id);</span>
  
    // Iterate over all concurrent refinement threads applying the given closure.
    void threads_do(ThreadClosure *tc);
  
    // Maximum number of refinement threads.
    static uint max_num_threads();
  
    void print_threads_on(outputStream* st) const;
  
    size_t green_zone() const      { return _green_zone;  }
    size_t yellow_zone() const     { return _yellow_zone; }
    size_t red_zone() const        { return _red_zone;    }
  };
  
<span class="line-new-header">--- 115,38 ---</span>
    static G1ConcurrentRefine* create(jint* ecode);
  
    void stop();
  
    // Adjust refinement thresholds based on work done during the pause and the goal time.
<span class="line-modified">!   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);</span>
  
<span class="line-added">+   struct RefinementStats {</span>
<span class="line-added">+     Tickspan _time;</span>
<span class="line-added">+     size_t _cards;</span>
<span class="line-added">+     RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   RefinementStats total_refinement_stats() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Cards in the dirty card queue set.</span>
    size_t activation_threshold(uint worker_id) const;
    size_t deactivation_threshold(uint worker_id) const;
<span class="line-modified">! </span>
<span class="line-modified">!   // Perform a single refinement step; called by the refinement</span>
<span class="line-added">+   // threads.  Returns true if there was refinement work available.</span>
<span class="line-added">+   // Increments *total_refined_cards.</span>
<span class="line-added">+   bool do_refinement_step(uint worker_id, size_t* total_refined_cards);</span>
  
    // Iterate over all concurrent refinement threads applying the given closure.
    void threads_do(ThreadClosure *tc);
  
    // Maximum number of refinement threads.
    static uint max_num_threads();
  
    void print_threads_on(outputStream* st) const;
  
<span class="line-added">+   // Cards in the dirty card queue set.</span>
    size_t green_zone() const      { return _green_zone;  }
    size_t yellow_zone() const     { return _yellow_zone; }
    size_t red_zone() const        { return _red_zone;    }
  };
  
</pre>
<center><a href="g1ConcurrentRefine.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
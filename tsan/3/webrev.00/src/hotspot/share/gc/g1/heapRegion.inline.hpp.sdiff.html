<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegion.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegion.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGION_INLINE_HPP
 26 #define SHARE_GC_G1_HEAPREGION_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;

 31 #include &quot;gc/g1/heapRegion.hpp&quot;
<span class="line-removed"> 32 #include &quot;gc/shared/space.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;

 37 
<span class="line-modified"> 38 inline HeapWord* G1ContiguousSpace::allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 39                                                   size_t desired_word_size,</span>
<span class="line-modified"> 40                                                   size_t* actual_size) {</span>
 41   HeapWord* obj = top();
 42   size_t available = pointer_delta(end(), obj);
 43   size_t want_to_allocate = MIN2(available, desired_word_size);
 44   if (want_to_allocate &gt;= min_word_size) {
 45     HeapWord* new_top = obj + want_to_allocate;
 46     set_top(new_top);
<span class="line-modified"> 47     assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);</span>
 48     *actual_size = want_to_allocate;
 49     return obj;
 50   } else {
 51     return NULL;
 52   }
 53 }
 54 
<span class="line-modified"> 55 inline HeapWord* G1ContiguousSpace::par_allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 56                                                       size_t desired_word_size,</span>
<span class="line-modified"> 57                                                       size_t* actual_size) {</span>
 58   do {
 59     HeapWord* obj = top();
 60     size_t available = pointer_delta(end(), obj);
 61     size_t want_to_allocate = MIN2(available, desired_word_size);
 62     if (want_to_allocate &gt;= min_word_size) {
 63       HeapWord* new_top = obj + want_to_allocate;
<span class="line-modified"> 64       HeapWord* result = Atomic::cmpxchg(new_top, top_addr(), obj);</span>
 65       // result can be one of two:
 66       //  the old top value: the exchange succeeded
 67       //  otherwise: the new value of the top is returned.
 68       if (result == obj) {
<span class="line-modified"> 69         assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);</span>
 70         *actual_size = want_to_allocate;
 71         return obj;
 72       }
 73     } else {
 74       return NULL;
 75     }
 76   } while (true);
 77 }
 78 
<span class="line-modified"> 79 inline HeapWord* G1ContiguousSpace::allocate(size_t min_word_size,</span>
<span class="line-modified"> 80                                              size_t desired_word_size,</span>
<span class="line-modified"> 81                                              size_t* actual_size) {</span>
 82   HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);
 83   if (res != NULL) {
 84     _bot_part.alloc_block(res, *actual_size);
 85   }
 86   return res;
 87 }
 88 
<span class="line-modified"> 89 inline HeapWord* G1ContiguousSpace::allocate(size_t word_size) {</span>
 90   size_t temp;
 91   return allocate(word_size, word_size, &amp;temp);
 92 }
 93 
<span class="line-modified"> 94 inline HeapWord* G1ContiguousSpace::par_allocate(size_t word_size) {</span>
 95   size_t temp;
 96   return par_allocate(word_size, word_size, &amp;temp);
 97 }
 98 
 99 // Because of the requirement of keeping &quot;_offsets&quot; up to date with the
100 // allocations, we sequentialize these with a lock.  Therefore, best if
101 // this is used for larger LAB allocations only.
<span class="line-modified">102 inline HeapWord* G1ContiguousSpace::par_allocate(size_t min_word_size,</span>
<span class="line-modified">103                                                  size_t desired_word_size,</span>
<span class="line-modified">104                                                  size_t* actual_size) {</span>
105   MutexLocker x(&amp;_par_alloc_lock);
106   return allocate(min_word_size, desired_word_size, actual_size);
107 }
108 
<span class="line-modified">109 inline HeapWord* G1ContiguousSpace::block_start(const void* p) {</span>
110   return _bot_part.block_start(p);
111 }
112 
<span class="line-modified">113 inline HeapWord*</span>
<span class="line-removed">114 G1ContiguousSpace::block_start_const(const void* p) const {</span>
115   return _bot_part.block_start_const(p);
116 }
117 
118 inline bool HeapRegion::is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const {
<span class="line-modified">119   HeapWord* addr = (HeapWord*) obj;</span>
120 
121   assert(addr &lt; top(), &quot;must be&quot;);
122   assert(!is_closed_archive(),
123          &quot;Closed archive regions should not have references into other regions&quot;);
124   assert(!is_humongous(), &quot;Humongous objects not handled here&quot;);
125   bool obj_is_dead = is_obj_dead(obj, prev_bitmap);
126 
127   if (ClassUnloadingWithConcurrentMark &amp;&amp; obj_is_dead) {
128     assert(!block_is_obj(addr), &quot;must be&quot;);
129     *size = block_size_using_bitmap(addr, prev_bitmap);
130   } else {
131     assert(block_is_obj(addr), &quot;must be&quot;);
132     *size = obj-&gt;size();
133   }
134   return obj_is_dead;
135 }
136 
<span class="line-modified">137 inline bool</span>
<span class="line-removed">138 HeapRegion::block_is_obj(const HeapWord* p) const {</span>
139   G1CollectedHeap* g1h = G1CollectedHeap::heap();
140 
141   if (!this-&gt;is_in(p)) {
142     assert(is_continues_humongous(), &quot;This case can only happen for humongous regions&quot;);
143     return (p == humongous_start_region()-&gt;bottom());
144   }
145   if (ClassUnloadingWithConcurrentMark) {
146     return !g1h-&gt;is_obj_dead(oop(p), this);
147   }
148   return p &lt; top();
149 }
150 
151 inline size_t HeapRegion::block_size_using_bitmap(const HeapWord* addr, const G1CMBitMap* const prev_bitmap) const {
152   assert(ClassUnloadingWithConcurrentMark,
153          &quot;All blocks should be objects if class unloading isn&#39;t used, so this method should not be called. &quot;
154          &quot;HR: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
155          &quot;addr: &quot; PTR_FORMAT,
156          p2i(bottom()), p2i(top()), p2i(end()), p2i(addr));
157 
158   // Old regions&#39; dead objects may have dead classes
159   // We need to find the next live object using the bitmap
160   HeapWord* next = prev_bitmap-&gt;get_next_marked_addr(addr, prev_top_at_mark_start());
161 
162   assert(next &gt; addr, &quot;must get the next live object&quot;);
163   return pointer_delta(next, addr);
164 }
165 
166 inline bool HeapRegion::is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const {
167   assert(is_in_reserved(obj), &quot;Object &quot; PTR_FORMAT &quot; must be in region&quot;, p2i(obj));
168   return !obj_allocated_since_prev_marking(obj) &amp;&amp;
<span class="line-modified">169          !prev_bitmap-&gt;is_marked((HeapWord*)obj) &amp;&amp;</span>
170          !is_open_archive();
171 }
172 
173 inline size_t HeapRegion::block_size(const HeapWord *addr) const {
174   if (addr == top()) {
175     return pointer_delta(end(), addr);
176   }
177 
178   if (block_is_obj(addr)) {
179     return oop(addr)-&gt;size();
180   }
181 
182   return block_size_using_bitmap(addr, G1CollectedHeap::heap()-&gt;concurrent_mark()-&gt;prev_mark_bitmap());
183 }
184 
185 inline void HeapRegion::complete_compaction() {
186   // Reset space and bot after compaction is complete if needed.
187   reset_after_compaction();
<span class="line-modified">188   if (used_region().is_empty()) {</span>
189     reset_bot();
190   }
191 
192   // After a compaction the mark bitmap is invalid, so we must
193   // treat all objects as being inside the unmarked area.
194   zero_marked_bytes();
195   init_top_at_mark_start();
196 
197   // Clear unused heap memory in debug builds.
198   if (ZapUnusedHeapArea) {
199     mangle_unused_area();
200   }
201 }
202 
203 template&lt;typename ApplyToMarkedClosure&gt;
204 inline void HeapRegion::apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure) {
<span class="line-modified">205   HeapWord* limit = scan_limit();</span>
206   HeapWord* next_addr = bottom();
207 
208   while (next_addr &lt; limit) {
209     Prefetch::write(next_addr, PrefetchScanIntervalInBytes);
210     // This explicit is_marked check is a way to avoid
211     // some extra work done by get_next_marked_addr for
212     // the case where next_addr is marked.
213     if (bitmap-&gt;is_marked(next_addr)) {
214       oop current = oop(next_addr);
215       next_addr += closure-&gt;apply(current);
216     } else {
217       next_addr = bitmap-&gt;get_next_marked_addr(next_addr, limit);
218     }
219   }
220 
221   assert(next_addr == limit, &quot;Should stop the scan at the limit.&quot;);
222 }
223 
224 inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,
225                                                          size_t desired_word_size,
</pre>
<hr />
<pre>
240   return allocate_impl(min_word_size, desired_word_size, actual_word_size);
241 }
242 
243 inline void HeapRegion::note_start_of_marking() {
244   _next_marked_bytes = 0;
245   _next_top_at_mark_start = top();
246 }
247 
248 inline void HeapRegion::note_end_of_marking() {
249   _prev_top_at_mark_start = _next_top_at_mark_start;
250   _next_top_at_mark_start = bottom();
251   _prev_marked_bytes = _next_marked_bytes;
252   _next_marked_bytes = 0;
253 }
254 
255 inline bool HeapRegion::in_collection_set() const {
256   return G1CollectedHeap::heap()-&gt;is_in_cset(this);
257 }
258 
259 template &lt;class Closure, bool is_gc_active&gt;
<span class="line-modified">260 bool HeapRegion::do_oops_on_card_in_humongous(MemRegion mr,</span>
<span class="line-modified">261                                               Closure* cl,</span>
<span class="line-modified">262                                               G1CollectedHeap* g1h) {</span>
263   assert(is_humongous(), &quot;precondition&quot;);
264   HeapRegion* sr = humongous_start_region();
265   oop obj = oop(sr-&gt;bottom());
266 
267   // If concurrent and klass_or_null is NULL, then space has been
268   // allocated but the object has not yet been published by setting
269   // the klass.  That can only happen if the card is stale.  However,
270   // we&#39;ve already set the card clean, so we must return failure,
271   // since the allocating thread could have performed a write to the
272   // card that might be missed otherwise.
273   if (!is_gc_active &amp;&amp; (obj-&gt;klass_or_null_acquire() == NULL)) {
<span class="line-modified">274     return false;</span>
275   }
276 
277   // We have a well-formed humongous object at the start of sr.
278   // Only filler objects follow a humongous object in the containing
279   // regions, and we can ignore those.  So only process the one
280   // humongous object.
<span class="line-modified">281   if (!g1h-&gt;is_obj_dead(obj, sr)) {</span>
<span class="line-modified">282     if (obj-&gt;is_objArray() || (sr-&gt;bottom() &lt; mr.start())) {</span>
<span class="line-modified">283       // objArrays are always marked precisely, so limit processing</span>
<span class="line-modified">284       // with mr.  Non-objArrays might be precisely marked, and since</span>
<span class="line-modified">285       // it&#39;s humongous it&#39;s worthwhile avoiding full processing.</span>
<span class="line-modified">286       // However, the card could be stale and only cover filler</span>
<span class="line-modified">287       // objects.  That should be rare, so not worth checking for;</span>
<span class="line-modified">288       // instead let it fall out from the bounded iteration.</span>
<span class="line-modified">289       obj-&gt;oop_iterate(cl, mr);</span>
<span class="line-modified">290     } else {</span>
<span class="line-modified">291       // If obj is not an objArray and mr contains the start of the</span>
<span class="line-modified">292       // obj, then this could be an imprecise mark, and we need to</span>
<span class="line-modified">293       // process the entire object.</span>
<span class="line-modified">294       obj-&gt;oop_iterate(cl);</span>
<span class="line-modified">295     }</span>








296   }
<span class="line-removed">297   return true;</span>
298 }
299 
300 template &lt;bool is_gc_active, class Closure&gt;
<span class="line-modified">301 bool HeapRegion::oops_on_card_seq_iterate_careful(MemRegion mr,</span>
<span class="line-modified">302                                                   Closure* cl) {</span>
303   assert(MemRegion(bottom(), end()).contains(mr), &quot;Card region not in heap region&quot;);
304   G1CollectedHeap* g1h = G1CollectedHeap::heap();
305 
306   // Special handling for humongous regions.
307   if (is_humongous()) {
<span class="line-modified">308     return do_oops_on_card_in_humongous&lt;Closure, is_gc_active&gt;(mr, cl, g1h);</span>
309   }
310   assert(is_old() || is_archive(), &quot;Wrongly trying to iterate over region %u type %s&quot;, _hrm_index, get_type_str());
311 
312   // Because mr has been trimmed to what&#39;s been allocated in this
313   // region, the parts of the heap that are examined here are always
314   // parsable; there&#39;s no need to use klass_or_null to detect
315   // in-progress allocation.
316 
317   // Cache the boundaries of the memory region in some const locals
318   HeapWord* const start = mr.start();
319   HeapWord* const end = mr.end();
320 
321   // Find the obj that extends onto mr.start().
322   // Update BOT as needed while finding start of (possibly dead)
323   // object containing the start of the region.
324   HeapWord* cur = block_start(start);
325 
326 #ifdef ASSERT
327   {
328     assert(cur &lt;= start,
329            &quot;cur: &quot; PTR_FORMAT &quot;, start: &quot; PTR_FORMAT, p2i(cur), p2i(start));
330     HeapWord* next = cur + block_size(cur);
331     assert(start &lt; next,
332            &quot;start: &quot; PTR_FORMAT &quot;, next: &quot; PTR_FORMAT, p2i(start), p2i(next));
333   }
334 #endif
335 
336   const G1CMBitMap* const bitmap = g1h-&gt;concurrent_mark()-&gt;prev_mark_bitmap();
<span class="line-modified">337   do {</span>
338     oop obj = oop(cur);
339     assert(oopDesc::is_oop(obj, true), &quot;Not an oop at &quot; PTR_FORMAT, p2i(cur));
340     assert(obj-&gt;klass_or_null() != NULL,
341            &quot;Unparsable heap at &quot; PTR_FORMAT, p2i(cur));
342 
343     size_t size;
344     bool is_dead = is_obj_dead_with_size(obj, bitmap, &amp;size);

345 
346     cur += size;
347     if (!is_dead) {
348       // Process live object&#39;s references.
349 
350       // Non-objArrays are usually marked imprecise at the object
351       // start, in which case we need to iterate over them in full.
352       // objArrays are precisely marked, but can still be iterated
353       // over in full if completely covered.
<span class="line-modified">354       if (!obj-&gt;is_objArray() || (((HeapWord*)obj) &gt;= start &amp;&amp; cur &lt;= end)) {</span>
355         obj-&gt;oop_iterate(cl);
356       } else {
357         obj-&gt;oop_iterate(cl, mr);

358       }
359     }
<span class="line-modified">360   } while (cur &lt; end);</span>












































361 
<span class="line-modified">362   return true;</span>




363 }
364 
365 #endif // SHARE_GC_G1_HEAPREGION_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGION_INLINE_HPP
 26 #define SHARE_GC_G1_HEAPREGION_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;gc/g1/g1Predictions.hpp&quot;</span>
 32 #include &quot;gc/g1/heapRegion.hpp&quot;

 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
<span class="line-added"> 37 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 38 
<span class="line-modified"> 39 inline HeapWord* HeapRegion::allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 40                                            size_t desired_word_size,</span>
<span class="line-modified"> 41                                            size_t* actual_size) {</span>
 42   HeapWord* obj = top();
 43   size_t available = pointer_delta(end(), obj);
 44   size_t want_to_allocate = MIN2(available, desired_word_size);
 45   if (want_to_allocate &gt;= min_word_size) {
 46     HeapWord* new_top = obj + want_to_allocate;
 47     set_top(new_top);
<span class="line-modified"> 48     assert(is_object_aligned(obj) &amp;&amp; is_object_aligned(new_top), &quot;checking alignment&quot;);</span>
 49     *actual_size = want_to_allocate;
 50     return obj;
 51   } else {
 52     return NULL;
 53   }
 54 }
 55 
<span class="line-modified"> 56 inline HeapWord* HeapRegion::par_allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 57                                                size_t desired_word_size,</span>
<span class="line-modified"> 58                                                size_t* actual_size) {</span>
 59   do {
 60     HeapWord* obj = top();
 61     size_t available = pointer_delta(end(), obj);
 62     size_t want_to_allocate = MIN2(available, desired_word_size);
 63     if (want_to_allocate &gt;= min_word_size) {
 64       HeapWord* new_top = obj + want_to_allocate;
<span class="line-modified"> 65       HeapWord* result = Atomic::cmpxchg(&amp;_top, obj, new_top);</span>
 66       // result can be one of two:
 67       //  the old top value: the exchange succeeded
 68       //  otherwise: the new value of the top is returned.
 69       if (result == obj) {
<span class="line-modified"> 70         assert(is_object_aligned(obj) &amp;&amp; is_object_aligned(new_top), &quot;checking alignment&quot;);</span>
 71         *actual_size = want_to_allocate;
 72         return obj;
 73       }
 74     } else {
 75       return NULL;
 76     }
 77   } while (true);
 78 }
 79 
<span class="line-modified"> 80 inline HeapWord* HeapRegion::allocate(size_t min_word_size,</span>
<span class="line-modified"> 81                                       size_t desired_word_size,</span>
<span class="line-modified"> 82                                       size_t* actual_size) {</span>
 83   HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);
 84   if (res != NULL) {
 85     _bot_part.alloc_block(res, *actual_size);
 86   }
 87   return res;
 88 }
 89 
<span class="line-modified"> 90 inline HeapWord* HeapRegion::allocate(size_t word_size) {</span>
 91   size_t temp;
 92   return allocate(word_size, word_size, &amp;temp);
 93 }
 94 
<span class="line-modified"> 95 inline HeapWord* HeapRegion::par_allocate(size_t word_size) {</span>
 96   size_t temp;
 97   return par_allocate(word_size, word_size, &amp;temp);
 98 }
 99 
100 // Because of the requirement of keeping &quot;_offsets&quot; up to date with the
101 // allocations, we sequentialize these with a lock.  Therefore, best if
102 // this is used for larger LAB allocations only.
<span class="line-modified">103 inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,</span>
<span class="line-modified">104                                           size_t desired_word_size,</span>
<span class="line-modified">105                                           size_t* actual_size) {</span>
106   MutexLocker x(&amp;_par_alloc_lock);
107   return allocate(min_word_size, desired_word_size, actual_size);
108 }
109 
<span class="line-modified">110 inline HeapWord* HeapRegion::block_start(const void* p) {</span>
111   return _bot_part.block_start(p);
112 }
113 
<span class="line-modified">114 inline HeapWord* HeapRegion::block_start_const(const void* p) const {</span>

115   return _bot_part.block_start_const(p);
116 }
117 
118 inline bool HeapRegion::is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const {
<span class="line-modified">119   HeapWord* addr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
120 
121   assert(addr &lt; top(), &quot;must be&quot;);
122   assert(!is_closed_archive(),
123          &quot;Closed archive regions should not have references into other regions&quot;);
124   assert(!is_humongous(), &quot;Humongous objects not handled here&quot;);
125   bool obj_is_dead = is_obj_dead(obj, prev_bitmap);
126 
127   if (ClassUnloadingWithConcurrentMark &amp;&amp; obj_is_dead) {
128     assert(!block_is_obj(addr), &quot;must be&quot;);
129     *size = block_size_using_bitmap(addr, prev_bitmap);
130   } else {
131     assert(block_is_obj(addr), &quot;must be&quot;);
132     *size = obj-&gt;size();
133   }
134   return obj_is_dead;
135 }
136 
<span class="line-modified">137 inline bool HeapRegion::block_is_obj(const HeapWord* p) const {</span>

138   G1CollectedHeap* g1h = G1CollectedHeap::heap();
139 
140   if (!this-&gt;is_in(p)) {
141     assert(is_continues_humongous(), &quot;This case can only happen for humongous regions&quot;);
142     return (p == humongous_start_region()-&gt;bottom());
143   }
144   if (ClassUnloadingWithConcurrentMark) {
145     return !g1h-&gt;is_obj_dead(oop(p), this);
146   }
147   return p &lt; top();
148 }
149 
150 inline size_t HeapRegion::block_size_using_bitmap(const HeapWord* addr, const G1CMBitMap* const prev_bitmap) const {
151   assert(ClassUnloadingWithConcurrentMark,
152          &quot;All blocks should be objects if class unloading isn&#39;t used, so this method should not be called. &quot;
153          &quot;HR: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
154          &quot;addr: &quot; PTR_FORMAT,
155          p2i(bottom()), p2i(top()), p2i(end()), p2i(addr));
156 
157   // Old regions&#39; dead objects may have dead classes
158   // We need to find the next live object using the bitmap
159   HeapWord* next = prev_bitmap-&gt;get_next_marked_addr(addr, prev_top_at_mark_start());
160 
161   assert(next &gt; addr, &quot;must get the next live object&quot;);
162   return pointer_delta(next, addr);
163 }
164 
165 inline bool HeapRegion::is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const {
166   assert(is_in_reserved(obj), &quot;Object &quot; PTR_FORMAT &quot; must be in region&quot;, p2i(obj));
167   return !obj_allocated_since_prev_marking(obj) &amp;&amp;
<span class="line-modified">168          !prev_bitmap-&gt;is_marked(obj) &amp;&amp;</span>
169          !is_open_archive();
170 }
171 
172 inline size_t HeapRegion::block_size(const HeapWord *addr) const {
173   if (addr == top()) {
174     return pointer_delta(end(), addr);
175   }
176 
177   if (block_is_obj(addr)) {
178     return oop(addr)-&gt;size();
179   }
180 
181   return block_size_using_bitmap(addr, G1CollectedHeap::heap()-&gt;concurrent_mark()-&gt;prev_mark_bitmap());
182 }
183 
184 inline void HeapRegion::complete_compaction() {
185   // Reset space and bot after compaction is complete if needed.
186   reset_after_compaction();
<span class="line-modified">187   if (is_empty()) {</span>
188     reset_bot();
189   }
190 
191   // After a compaction the mark bitmap is invalid, so we must
192   // treat all objects as being inside the unmarked area.
193   zero_marked_bytes();
194   init_top_at_mark_start();
195 
196   // Clear unused heap memory in debug builds.
197   if (ZapUnusedHeapArea) {
198     mangle_unused_area();
199   }
200 }
201 
202 template&lt;typename ApplyToMarkedClosure&gt;
203 inline void HeapRegion::apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure) {
<span class="line-modified">204   HeapWord* limit = top();</span>
205   HeapWord* next_addr = bottom();
206 
207   while (next_addr &lt; limit) {
208     Prefetch::write(next_addr, PrefetchScanIntervalInBytes);
209     // This explicit is_marked check is a way to avoid
210     // some extra work done by get_next_marked_addr for
211     // the case where next_addr is marked.
212     if (bitmap-&gt;is_marked(next_addr)) {
213       oop current = oop(next_addr);
214       next_addr += closure-&gt;apply(current);
215     } else {
216       next_addr = bitmap-&gt;get_next_marked_addr(next_addr, limit);
217     }
218   }
219 
220   assert(next_addr == limit, &quot;Should stop the scan at the limit.&quot;);
221 }
222 
223 inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,
224                                                          size_t desired_word_size,
</pre>
<hr />
<pre>
239   return allocate_impl(min_word_size, desired_word_size, actual_word_size);
240 }
241 
242 inline void HeapRegion::note_start_of_marking() {
243   _next_marked_bytes = 0;
244   _next_top_at_mark_start = top();
245 }
246 
247 inline void HeapRegion::note_end_of_marking() {
248   _prev_top_at_mark_start = _next_top_at_mark_start;
249   _next_top_at_mark_start = bottom();
250   _prev_marked_bytes = _next_marked_bytes;
251   _next_marked_bytes = 0;
252 }
253 
254 inline bool HeapRegion::in_collection_set() const {
255   return G1CollectedHeap::heap()-&gt;is_in_cset(this);
256 }
257 
258 template &lt;class Closure, bool is_gc_active&gt;
<span class="line-modified">259 HeapWord* HeapRegion::do_oops_on_memregion_in_humongous(MemRegion mr,</span>
<span class="line-modified">260                                                         Closure* cl,</span>
<span class="line-modified">261                                                         G1CollectedHeap* g1h) {</span>
262   assert(is_humongous(), &quot;precondition&quot;);
263   HeapRegion* sr = humongous_start_region();
264   oop obj = oop(sr-&gt;bottom());
265 
266   // If concurrent and klass_or_null is NULL, then space has been
267   // allocated but the object has not yet been published by setting
268   // the klass.  That can only happen if the card is stale.  However,
269   // we&#39;ve already set the card clean, so we must return failure,
270   // since the allocating thread could have performed a write to the
271   // card that might be missed otherwise.
272   if (!is_gc_active &amp;&amp; (obj-&gt;klass_or_null_acquire() == NULL)) {
<span class="line-modified">273     return NULL;</span>
274   }
275 
276   // We have a well-formed humongous object at the start of sr.
277   // Only filler objects follow a humongous object in the containing
278   // regions, and we can ignore those.  So only process the one
279   // humongous object.
<span class="line-modified">280   if (g1h-&gt;is_obj_dead(obj, sr)) {</span>
<span class="line-modified">281     // The object is dead. There can be no other object in this region, so return</span>
<span class="line-modified">282     // the end of that region.</span>
<span class="line-modified">283     return end();</span>
<span class="line-modified">284   }</span>
<span class="line-modified">285   if (obj-&gt;is_objArray() || (sr-&gt;bottom() &lt; mr.start())) {</span>
<span class="line-modified">286     // objArrays are always marked precisely, so limit processing</span>
<span class="line-modified">287     // with mr.  Non-objArrays might be precisely marked, and since</span>
<span class="line-modified">288     // it&#39;s humongous it&#39;s worthwhile avoiding full processing.</span>
<span class="line-modified">289     // However, the card could be stale and only cover filler</span>
<span class="line-modified">290     // objects.  That should be rare, so not worth checking for;</span>
<span class="line-modified">291     // instead let it fall out from the bounded iteration.</span>
<span class="line-modified">292     obj-&gt;oop_iterate(cl, mr);</span>
<span class="line-modified">293     return mr.end();</span>
<span class="line-modified">294   } else {</span>
<span class="line-added">295     // If obj is not an objArray and mr contains the start of the</span>
<span class="line-added">296     // obj, then this could be an imprecise mark, and we need to</span>
<span class="line-added">297     // process the entire object.</span>
<span class="line-added">298     int size = obj-&gt;oop_iterate_size(cl);</span>
<span class="line-added">299     // We have scanned to the end of the object, but since there can be no objects</span>
<span class="line-added">300     // after this humongous object in the region, we can return the end of the</span>
<span class="line-added">301     // region if it is greater.</span>
<span class="line-added">302     return MAX2(cast_from_oop&lt;HeapWord*&gt;(obj) + size, mr.end());</span>
303   }

304 }
305 
306 template &lt;bool is_gc_active, class Closure&gt;
<span class="line-modified">307 HeapWord* HeapRegion::oops_on_memregion_seq_iterate_careful(MemRegion mr,</span>
<span class="line-modified">308                                                             Closure* cl) {</span>
309   assert(MemRegion(bottom(), end()).contains(mr), &quot;Card region not in heap region&quot;);
310   G1CollectedHeap* g1h = G1CollectedHeap::heap();
311 
312   // Special handling for humongous regions.
313   if (is_humongous()) {
<span class="line-modified">314     return do_oops_on_memregion_in_humongous&lt;Closure, is_gc_active&gt;(mr, cl, g1h);</span>
315   }
316   assert(is_old() || is_archive(), &quot;Wrongly trying to iterate over region %u type %s&quot;, _hrm_index, get_type_str());
317 
318   // Because mr has been trimmed to what&#39;s been allocated in this
319   // region, the parts of the heap that are examined here are always
320   // parsable; there&#39;s no need to use klass_or_null to detect
321   // in-progress allocation.
322 
323   // Cache the boundaries of the memory region in some const locals
324   HeapWord* const start = mr.start();
325   HeapWord* const end = mr.end();
326 
327   // Find the obj that extends onto mr.start().
328   // Update BOT as needed while finding start of (possibly dead)
329   // object containing the start of the region.
330   HeapWord* cur = block_start(start);
331 
332 #ifdef ASSERT
333   {
334     assert(cur &lt;= start,
335            &quot;cur: &quot; PTR_FORMAT &quot;, start: &quot; PTR_FORMAT, p2i(cur), p2i(start));
336     HeapWord* next = cur + block_size(cur);
337     assert(start &lt; next,
338            &quot;start: &quot; PTR_FORMAT &quot;, next: &quot; PTR_FORMAT, p2i(start), p2i(next));
339   }
340 #endif
341 
342   const G1CMBitMap* const bitmap = g1h-&gt;concurrent_mark()-&gt;prev_mark_bitmap();
<span class="line-modified">343   while (true) {</span>
344     oop obj = oop(cur);
345     assert(oopDesc::is_oop(obj, true), &quot;Not an oop at &quot; PTR_FORMAT, p2i(cur));
346     assert(obj-&gt;klass_or_null() != NULL,
347            &quot;Unparsable heap at &quot; PTR_FORMAT, p2i(cur));
348 
349     size_t size;
350     bool is_dead = is_obj_dead_with_size(obj, bitmap, &amp;size);
<span class="line-added">351     bool is_precise = false;</span>
352 
353     cur += size;
354     if (!is_dead) {
355       // Process live object&#39;s references.
356 
357       // Non-objArrays are usually marked imprecise at the object
358       // start, in which case we need to iterate over them in full.
359       // objArrays are precisely marked, but can still be iterated
360       // over in full if completely covered.
<span class="line-modified">361       if (!obj-&gt;is_objArray() || (cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= start &amp;&amp; cur &lt;= end)) {</span>
362         obj-&gt;oop_iterate(cl);
363       } else {
364         obj-&gt;oop_iterate(cl, mr);
<span class="line-added">365         is_precise = true;</span>
366       }
367     }
<span class="line-modified">368     if (cur &gt;= end) {</span>
<span class="line-added">369       return is_precise ? end : cur;</span>
<span class="line-added">370     }</span>
<span class="line-added">371   }</span>
<span class="line-added">372 }</span>
<span class="line-added">373 </span>
<span class="line-added">374 inline int HeapRegion::age_in_surv_rate_group() const {</span>
<span class="line-added">375   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">376   assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">377   return _surv_rate_group-&gt;age_in_group(_age_index);</span>
<span class="line-added">378 }</span>
<span class="line-added">379 </span>
<span class="line-added">380 inline bool HeapRegion::has_valid_age_in_surv_rate() const {</span>
<span class="line-added">381   return G1SurvRateGroup::is_valid_age_index(_age_index);</span>
<span class="line-added">382 }</span>
<span class="line-added">383 </span>
<span class="line-added">384 inline bool HeapRegion::has_surv_rate_group() const {</span>
<span class="line-added">385   return _surv_rate_group != NULL;</span>
<span class="line-added">386 }</span>
<span class="line-added">387 </span>
<span class="line-added">388 inline double HeapRegion::surv_rate_prediction(G1Predictions const&amp; predictor) const {</span>
<span class="line-added">389   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">390   return _surv_rate_group-&gt;surv_rate_pred(predictor, age_in_surv_rate_group());</span>
<span class="line-added">391 }</span>
<span class="line-added">392 </span>
<span class="line-added">393 inline void HeapRegion::install_surv_rate_group(G1SurvRateGroup* surv_rate_group) {</span>
<span class="line-added">394   assert(surv_rate_group != NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">395   assert(!has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">396   assert(is_young(), &quot;pre-condition&quot;);</span>
<span class="line-added">397 </span>
<span class="line-added">398   _surv_rate_group = surv_rate_group;</span>
<span class="line-added">399   _age_index = surv_rate_group-&gt;next_age_index();</span>
<span class="line-added">400 }</span>
<span class="line-added">401 </span>
<span class="line-added">402 inline void HeapRegion::uninstall_surv_rate_group() {</span>
<span class="line-added">403   if (has_surv_rate_group()) {</span>
<span class="line-added">404     assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">405     assert(is_young(), &quot;pre-condition&quot;);</span>
<span class="line-added">406 </span>
<span class="line-added">407     _surv_rate_group = NULL;</span>
<span class="line-added">408     _age_index = G1SurvRateGroup::InvalidAgeIndex;</span>
<span class="line-added">409   } else {</span>
<span class="line-added">410     assert(!has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">411   }</span>
<span class="line-added">412 }</span>
413 
<span class="line-modified">414 inline void HeapRegion::record_surv_words_in_group(size_t words_survived) {</span>
<span class="line-added">415   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">416   assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">417   int age_in_group = age_in_surv_rate_group();</span>
<span class="line-added">418   _surv_rate_group-&gt;record_surviving_words(age_in_group, words_survived);</span>
419 }
420 
421 #endif // SHARE_GC_G1_HEAPREGION_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="heapRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
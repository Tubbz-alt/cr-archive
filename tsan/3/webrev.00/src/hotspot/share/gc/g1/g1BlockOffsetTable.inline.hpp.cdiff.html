<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BlockOffsetTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CardTable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,34 ***</span>
  #define SHARE_GC_G1_G1BLOCKOFFSETTABLE_INLINE_HPP
  
  #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/shared/memset_with_concurrent_readers.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/space.hpp&quot;</span>
  
  inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) {
<span class="line-modified">!   if (addr &gt;= _space-&gt;bottom() &amp;&amp; addr &lt; _space-&gt;end()) {</span>
      HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
      return forward_to_block_containing_addr(q, addr);
    } else {
      return NULL;
    }
  }
  
  inline HeapWord* G1BlockOffsetTablePart::block_start_const(const void* addr) const {
<span class="line-modified">!   if (addr &gt;= _space-&gt;bottom() &amp;&amp; addr &lt; _space-&gt;end()) {</span>
      HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
      HeapWord* n = q + block_size(q);
      return forward_to_block_containing_addr_const(q, n, addr);
    } else {
      return NULL;
    }
  }
  
  u_char G1BlockOffsetTable::offset_array(size_t index) const {
    check_index(index, &quot;index out of range&quot;);
<span class="line-modified">!   return _offset_array[index];</span>
  }
  
  void G1BlockOffsetTable::set_offset_array(size_t index, u_char offset) {
    check_index(index, &quot;index out of range&quot;);
    set_offset_array_raw(index, offset);
<span class="line-new-header">--- 26,38 ---</span>
  #define SHARE_GC_G1_G1BLOCKOFFSETTABLE_INLINE_HPP
  
  #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/shared/memset_with_concurrent_readers.hpp&quot;
<span class="line-modified">! #include &quot;runtime/atomic.hpp&quot;</span>
  
  inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) {
<span class="line-modified">!   if (addr &gt;= _hr-&gt;bottom() &amp;&amp; addr &lt; _hr-&gt;end()) {</span>
      HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
      return forward_to_block_containing_addr(q, addr);
    } else {
      return NULL;
    }
  }
  
  inline HeapWord* G1BlockOffsetTablePart::block_start_const(const void* addr) const {
<span class="line-modified">!   if (addr &gt;= _hr-&gt;bottom() &amp;&amp; addr &lt; _hr-&gt;end()) {</span>
      HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
      HeapWord* n = q + block_size(q);
      return forward_to_block_containing_addr_const(q, n, addr);
    } else {
      return NULL;
    }
  }
  
  u_char G1BlockOffsetTable::offset_array(size_t index) const {
    check_index(index, &quot;index out of range&quot;);
<span class="line-modified">!   return Atomic::load(&amp;_offset_array[index]);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1BlockOffsetTable::set_offset_array_raw(size_t index, u_char offset) {</span>
<span class="line-added">+   Atomic::store(&amp;_offset_array[index], offset);</span>
  }
  
  void G1BlockOffsetTable::set_offset_array(size_t index, u_char offset) {
    check_index(index, &quot;index out of range&quot;);
    set_offset_array_raw(index, offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
  
  void G1BlockOffsetTable::set_offset_array(size_t left, size_t right, u_char offset) {
    check_index(right, &quot;right index out of range&quot;);
    assert(left &lt;= right, &quot;indexes out of order&quot;);
    size_t num_cards = right - left + 1;
<span class="line-modified">!   memset_with_concurrent_readers(&amp;_offset_array[left], offset, num_cards);</span>
  }
  
  // Variant of index_for that does not check the index for validity.
  inline size_t G1BlockOffsetTable::index_for_raw(const void* p) const {
    return pointer_delta((char*)p, _reserved.start(), sizeof(char)) &gt;&gt; BOTConstants::LogN;
<span class="line-new-header">--- 73,12 ---</span>
  
  void G1BlockOffsetTable::set_offset_array(size_t left, size_t right, u_char offset) {
    check_index(right, &quot;right index out of range&quot;);
    assert(left &lt;= right, &quot;indexes out of order&quot;);
    size_t num_cards = right - left + 1;
<span class="line-modified">!   memset_with_concurrent_readers</span>
<span class="line-added">+     (const_cast&lt;u_char*&gt; (&amp;_offset_array[left]), offset, num_cards);</span>
  }
  
  // Variant of index_for that does not check the index for validity.
  inline size_t G1BlockOffsetTable::index_for_raw(const void* p) const {
    return pointer_delta((char*)p, _reserved.start(), sizeof(char)) &gt;&gt; BOTConstants::LogN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,19 ***</span>
           p2i(result), p2i(_reserved.start()), p2i(_reserved.end()));
    return result;
  }
  
  inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {
<span class="line-modified">!   return _space-&gt;block_size(p);</span>
  }
  
  inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr,
                                                                 bool has_max_index,
                                                                 size_t max_index) const {
<span class="line-modified">!   assert(_object_can_span || _bot-&gt;offset_array(_bot-&gt;index_for(_space-&gt;bottom())) == 0,</span>
           &quot;Object crossed region boundary, found offset %u instead of 0&quot;,
<span class="line-modified">!          (uint) _bot-&gt;offset_array(_bot-&gt;index_for(_space-&gt;bottom())));</span>
    size_t index = _bot-&gt;index_for(addr);
    // We must make sure that the offset table entry we use is valid.  If
    // &quot;addr&quot; is past the end, start at the last known one and go forward.
    if (has_max_index) {
      index = MIN2(index, max_index);
<span class="line-new-header">--- 104,19 ---</span>
           p2i(result), p2i(_reserved.start()), p2i(_reserved.end()));
    return result;
  }
  
  inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {
<span class="line-modified">!   return _hr-&gt;block_size(p);</span>
  }
  
  inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr,
                                                                 bool has_max_index,
                                                                 size_t max_index) const {
<span class="line-modified">!   assert(_object_can_span || _bot-&gt;offset_array(_bot-&gt;index_for(_hr-&gt;bottom())) == 0,</span>
           &quot;Object crossed region boundary, found offset %u instead of 0&quot;,
<span class="line-modified">!          (uint) _bot-&gt;offset_array(_bot-&gt;index_for(_hr-&gt;bottom())));</span>
    size_t index = _bot-&gt;index_for(addr);
    // We must make sure that the offset table entry we use is valid.  If
    // &quot;addr&quot; is past the end, start at the last known one and go forward.
    if (has_max_index) {
      index = MIN2(index, max_index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
    return q;
  }
  
  inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_const(HeapWord* q, HeapWord* n,
                                                                                  const void* addr) const {
<span class="line-modified">!   if (addr &gt;= _space-&gt;top()) return _space-&gt;top();</span>
    while (n &lt;= addr) {
      q = n;
      oop obj = oop(q);
      if (obj-&gt;klass_or_null_acquire() == NULL) {
        return q;
<span class="line-new-header">--- 137,11 ---</span>
    return q;
  }
  
  inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_const(HeapWord* q, HeapWord* n,
                                                                                  const void* addr) const {
<span class="line-modified">!   if (addr &gt;= _hr-&gt;top()) return _hr-&gt;top();</span>
    while (n &lt;= addr) {
      q = n;
      oop obj = oop(q);
      if (obj-&gt;klass_or_null_acquire() == NULL) {
        return q;
</pre>
<center><a href="g1BlockOffsetTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CardTable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
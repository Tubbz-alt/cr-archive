<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Analytics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Allocator.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Analytics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Analytics.hpp&quot;
 27 #include &quot;gc/g1/g1Predictions.hpp&quot;

 28 #include &quot;runtime/os.hpp&quot;
 29 #include &quot;utilities/debug.hpp&quot;

 30 #include &quot;utilities/numberSeq.hpp&quot;
 31 
 32 // Different defaults for different number of GC threads
 33 // They were chosen by running GCOld and SPECjbb on debris with different
 34 //   numbers of GC threads and choosing them based on the results
 35 
 36 // all the same
 37 static double rs_length_diff_defaults[] = {
 38   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
 39 };
 40 
<span class="line-modified"> 41 static double cost_per_card_ms_defaults[] = {</span>
 42   0.01, 0.005, 0.005, 0.003, 0.003, 0.002, 0.002, 0.0015
 43 };
 44 
 45 // all the same
<span class="line-modified"> 46 static double young_cards_per_entry_ratio_defaults[] = {</span>
 47   1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
 48 };
 49 
<span class="line-modified"> 50 static double cost_per_entry_ms_defaults[] = {</span>
 51   0.015, 0.01, 0.01, 0.008, 0.008, 0.0055, 0.0055, 0.005
 52 };
 53 
 54 static double cost_per_byte_ms_defaults[] = {
 55   0.00006, 0.00003, 0.00003, 0.000015, 0.000015, 0.00001, 0.00001, 0.000009
 56 };
 57 
 58 // these should be pretty consistent
 59 static double constant_other_time_ms_defaults[] = {
 60   5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0
 61 };
 62 
<span class="line-removed"> 63 </span>
 64 static double young_other_cost_per_region_ms_defaults[] = {
 65   0.3, 0.2, 0.2, 0.15, 0.15, 0.12, 0.12, 0.1
 66 };
 67 
 68 static double non_young_other_cost_per_region_ms_defaults[] = {
 69   1.0, 0.7, 0.7, 0.5, 0.5, 0.42, 0.42, 0.30
 70 };
 71 
 72 G1Analytics::G1Analytics(const G1Predictions* predictor) :
 73     _predictor(predictor),
 74     _recent_gc_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 75     _concurrent_mark_remark_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 76     _concurrent_mark_cleanup_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 77     _alloc_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 78     _prev_collection_pause_end_ms(0.0),
 79     _rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified"> 80     _cost_per_card_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 81     _cost_scan_hcc_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 82     _young_cards_per_entry_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 83     _mixed_cards_per_entry_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 84     _cost_per_entry_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 85     _mixed_cost_per_entry_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 86     _cost_per_byte_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>


 87     _constant_other_time_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 88     _young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 89     _non_young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 90     _pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified"> 91     _rs_lengths_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
 92     _cost_per_byte_ms_during_cm_seq(new TruncatedSeq(TruncatedSeqLength)),
 93     _recent_prev_end_times_for_all_gcs_sec(new TruncatedSeq(NumPrevPausesForHeuristics)),
 94     _recent_avg_pause_time_ratio(0.0),
 95     _last_pause_time_ratio(0.0) {
 96 
 97   // Seed sequences with initial values.
 98   _recent_prev_end_times_for_all_gcs_sec-&gt;add(os::elapsedTime());
 99   _prev_collection_pause_end_ms = os::elapsedTime() * 1000.0;
100 
101   int index = MIN2(ParallelGCThreads - 1, 7u);
102 
103   _rs_length_diff_seq-&gt;add(rs_length_diff_defaults[index]);
<span class="line-modified">104   _cost_per_card_ms_seq-&gt;add(cost_per_card_ms_defaults[index]);</span>
<span class="line-modified">105   _cost_scan_hcc_seq-&gt;add(0.0);</span>
<span class="line-modified">106   _young_cards_per_entry_ratio_seq-&gt;add(young_cards_per_entry_ratio_defaults[index]);</span>
<span class="line-modified">107   _cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms_defaults[index]);</span>
<span class="line-modified">108   _cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms_defaults[index]);</span>



109   _constant_other_time_ms_seq-&gt;add(constant_other_time_ms_defaults[index]);
110   _young_other_cost_per_region_ms_seq-&gt;add(young_other_cost_per_region_ms_defaults[index]);
111   _non_young_other_cost_per_region_ms_seq-&gt;add(non_young_other_cost_per_region_ms_defaults[index]);
112 
113   // start conservatively (around 50ms is about right)
114   _concurrent_mark_remark_times_ms-&gt;add(0.05);
115   _concurrent_mark_cleanup_times_ms-&gt;add(0.20);
116 }
117 
<span class="line-modified">118 double G1Analytics::get_new_prediction(TruncatedSeq const* seq) const {</span>
<span class="line-modified">119   return _predictor-&gt;get_new_prediction(seq);</span>




120 }
121 
<span class="line-modified">122 size_t G1Analytics::get_new_size_prediction(TruncatedSeq const* seq) const {</span>
<span class="line-modified">123   return (size_t)get_new_prediction(seq);</span>




124 }
125 
126 int G1Analytics::num_alloc_rate_ms() const {
127   return _alloc_rate_ms_seq-&gt;num();
128 }
129 
130 void G1Analytics::report_concurrent_mark_remark_times_ms(double ms) {
131   _concurrent_mark_remark_times_ms-&gt;add(ms);
132 }
133 
134 void G1Analytics::report_alloc_rate_ms(double alloc_rate) {
135   _alloc_rate_ms_seq-&gt;add(alloc_rate);
136 }
137 
138 void G1Analytics::compute_pause_time_ratio(double interval_ms, double pause_time_ms) {
139   _recent_avg_pause_time_ratio = _recent_gc_times_ms-&gt;sum() / interval_ms;
<span class="line-modified">140   if (_recent_avg_pause_time_ratio &lt; 0.0 ||</span>
<span class="line-modified">141       (_recent_avg_pause_time_ratio - 1.0 &gt; 0.0)) {</span>
<span class="line-modified">142     // Clip ratio between 0.0 and 1.0, and continue. This will be fixed in</span>
<span class="line-removed">143     // CR 6902692 by redoing the manner in which the ratio is incrementally computed.</span>
<span class="line-removed">144     if (_recent_avg_pause_time_ratio &lt; 0.0) {</span>
<span class="line-removed">145       _recent_avg_pause_time_ratio = 0.0;</span>
<span class="line-removed">146     } else {</span>
<span class="line-removed">147       assert(_recent_avg_pause_time_ratio - 1.0 &gt; 0.0, &quot;Ctl-point invariant&quot;);</span>
<span class="line-removed">148       _recent_avg_pause_time_ratio = 1.0;</span>
<span class="line-removed">149     }</span>
<span class="line-removed">150   }</span>
151 
152   // Compute the ratio of just this last pause time to the entire time range stored
153   // in the vectors. Comparing this pause to the entire range, rather than only the
154   // most recent interval, has the effect of smoothing over a possible transient &#39;burst&#39;
155   // of more frequent pauses that don&#39;t really reflect a change in heap occupancy.
156   // This reduces the likelihood of a needless heap expansion being triggered.
157   _last_pause_time_ratio =
158     (pause_time_ms * _recent_prev_end_times_for_all_gcs_sec-&gt;num()) / interval_ms;
159 }
160 
<span class="line-modified">161 void G1Analytics::report_cost_per_card_ms(double cost_per_card_ms) {</span>
<span class="line-modified">162   _cost_per_card_ms_seq-&gt;add(cost_per_card_ms);</span>




163 }
164 
<span class="line-modified">165 void G1Analytics::report_cost_scan_hcc(double cost_scan_hcc) {</span>
<span class="line-modified">166   _cost_scan_hcc_seq-&gt;add(cost_scan_hcc);</span>




167 }
168 
<span class="line-modified">169 void G1Analytics::report_cost_per_entry_ms(double cost_per_entry_ms, bool for_young_gc) {</span>
170   if (for_young_gc) {
<span class="line-modified">171     _cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms);</span>
172   } else {
<span class="line-modified">173     _mixed_cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms);</span>
174   }
175 }
176 
<span class="line-modified">177 void G1Analytics::report_cards_per_entry_ratio(double cards_per_entry_ratio, bool for_young_gc) {</span>
178   if (for_young_gc) {
<span class="line-modified">179     _young_cards_per_entry_ratio_seq-&gt;add(cards_per_entry_ratio);</span>
180   } else {
<span class="line-modified">181     _mixed_cards_per_entry_ratio_seq-&gt;add(cards_per_entry_ratio);</span>
182   }
183 }
184 
185 void G1Analytics::report_rs_length_diff(double rs_length_diff) {
186   _rs_length_diff_seq-&gt;add(rs_length_diff);
187 }
188 
189 void G1Analytics::report_cost_per_byte_ms(double cost_per_byte_ms, bool mark_or_rebuild_in_progress) {
190   if (mark_or_rebuild_in_progress) {
191     _cost_per_byte_ms_during_cm_seq-&gt;add(cost_per_byte_ms);
192   } else {
<span class="line-modified">193     _cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms);</span>
194   }
195 }
196 
197 void G1Analytics::report_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
198   _young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
199 }
200 
201 void G1Analytics::report_non_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
202   _non_young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
203 }
204 
205 void G1Analytics::report_constant_other_time_ms(double constant_other_time_ms) {
206   _constant_other_time_ms_seq-&gt;add(constant_other_time_ms);
207 }
208 
209 void G1Analytics::report_pending_cards(double pending_cards) {
210   _pending_cards_seq-&gt;add(pending_cards);
211 }
212 
<span class="line-modified">213 void G1Analytics::report_rs_lengths(double rs_lengths) {</span>
<span class="line-modified">214   _rs_lengths_seq-&gt;add(rs_lengths);</span>
<span class="line-removed">215 }</span>
<span class="line-removed">216 </span>
<span class="line-removed">217 size_t G1Analytics::predict_rs_length_diff() const {</span>
<span class="line-removed">218   return get_new_size_prediction(_rs_length_diff_seq);</span>
219 }
220 
221 double G1Analytics::predict_alloc_rate_ms() const {
<span class="line-modified">222   return get_new_prediction(_alloc_rate_ms_seq);</span>
<span class="line-removed">223 }</span>
<span class="line-removed">224 </span>
<span class="line-removed">225 double G1Analytics::predict_cost_per_card_ms() const {</span>
<span class="line-removed">226   return get_new_prediction(_cost_per_card_ms_seq);</span>
<span class="line-removed">227 }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229 double G1Analytics::predict_scan_hcc_ms() const {</span>
<span class="line-removed">230   return get_new_prediction(_cost_scan_hcc_seq);</span>
231 }
232 
<span class="line-modified">233 double G1Analytics::predict_rs_update_time_ms(size_t pending_cards) const {</span>
<span class="line-modified">234   return pending_cards * predict_cost_per_card_ms() + predict_scan_hcc_ms();</span>
235 }
236 
<span class="line-modified">237 double G1Analytics::predict_young_cards_per_entry_ratio() const {</span>
<span class="line-modified">238   return get_new_prediction(_young_cards_per_entry_ratio_seq);</span>
239 }
240 
<span class="line-modified">241 double G1Analytics::predict_mixed_cards_per_entry_ratio() const {</span>
<span class="line-modified">242   if (_mixed_cards_per_entry_ratio_seq-&gt;num() &lt; 2) {</span>
<span class="line-removed">243     return predict_young_cards_per_entry_ratio();</span>
<span class="line-removed">244   } else {</span>
<span class="line-removed">245     return get_new_prediction(_mixed_cards_per_entry_ratio_seq);</span>
<span class="line-removed">246   }</span>
247 }
248 
<span class="line-modified">249 size_t G1Analytics::predict_card_num(size_t rs_length, bool for_young_gc) const {</span>
<span class="line-modified">250   if (for_young_gc) {</span>
<span class="line-modified">251     return (size_t) (rs_length * predict_young_cards_per_entry_ratio());</span>
252   } else {
<span class="line-modified">253     return (size_t) (rs_length * predict_mixed_cards_per_entry_ratio());</span>
254   }
255 }
256 
<span class="line-modified">257 double G1Analytics::predict_rs_scan_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">258   if (for_young_gc) {</span>
<span class="line-modified">259     return card_num * get_new_prediction(_cost_per_entry_ms_seq);</span>
260   } else {
<span class="line-modified">261     return predict_mixed_rs_scan_time_ms(card_num);</span>
262   }
263 }
264 
<span class="line-modified">265 double G1Analytics::predict_mixed_rs_scan_time_ms(size_t card_num) const {</span>
<span class="line-modified">266   if (_mixed_cost_per_entry_ms_seq-&gt;num() &lt; 3) {</span>
<span class="line-modified">267     return card_num * get_new_prediction(_cost_per_entry_ms_seq);</span>
268   } else {
<span class="line-modified">269     return card_num * get_new_prediction(_mixed_cost_per_entry_ms_seq);</span>
270   }
271 }
272 
273 double G1Analytics::predict_object_copy_time_ms_during_cm(size_t bytes_to_copy) const {
<span class="line-modified">274   if (_cost_per_byte_ms_during_cm_seq-&gt;num() &lt; 3) {</span>
<span class="line-modified">275     return (1.1 * bytes_to_copy) * get_new_prediction(_cost_per_byte_ms_seq);</span>
276   } else {
<span class="line-modified">277     return bytes_to_copy * get_new_prediction(_cost_per_byte_ms_during_cm_seq);</span>
278   }
279 }
280 
281 double G1Analytics::predict_object_copy_time_ms(size_t bytes_to_copy, bool during_concurrent_mark) const {
282   if (during_concurrent_mark) {
283     return predict_object_copy_time_ms_during_cm(bytes_to_copy);
284   } else {
<span class="line-modified">285     return bytes_to_copy * get_new_prediction(_cost_per_byte_ms_seq);</span>
286   }
287 }
288 
<span class="line-removed">289 double G1Analytics::predict_cost_per_byte_ms() const {</span>
<span class="line-removed">290   return get_new_prediction(_cost_per_byte_ms_seq);</span>
<span class="line-removed">291 }</span>
<span class="line-removed">292 </span>
293 double G1Analytics::predict_constant_other_time_ms() const {
<span class="line-modified">294   return get_new_prediction(_constant_other_time_ms_seq);</span>
295 }
296 
297 double G1Analytics::predict_young_other_time_ms(size_t young_num) const {
<span class="line-modified">298   return young_num * get_new_prediction(_young_other_cost_per_region_ms_seq);</span>
299 }
300 
301 double G1Analytics::predict_non_young_other_time_ms(size_t non_young_num) const {
<span class="line-modified">302   return non_young_num * get_new_prediction(_non_young_other_cost_per_region_ms_seq);</span>
303 }
304 
305 double G1Analytics::predict_remark_time_ms() const {
<span class="line-modified">306   return get_new_prediction(_concurrent_mark_remark_times_ms);</span>
307 }
308 
309 double G1Analytics::predict_cleanup_time_ms() const {
<span class="line-modified">310   return get_new_prediction(_concurrent_mark_cleanup_times_ms);</span>
311 }
312 
<span class="line-modified">313 size_t G1Analytics::predict_rs_lengths() const {</span>
<span class="line-modified">314   return get_new_size_prediction(_rs_lengths_seq);</span>
315 }
316 
317 size_t G1Analytics::predict_pending_cards() const {
<span class="line-modified">318   return get_new_size_prediction(_pending_cards_seq);</span>
319 }
320 
321 double G1Analytics::last_known_gc_end_time_sec() const {
322   return _recent_prev_end_times_for_all_gcs_sec-&gt;oldest();
323 }
324 
325 void G1Analytics::update_recent_gc_times(double end_time_sec,
326                                          double pause_time_ms) {
327   _recent_gc_times_ms-&gt;add(pause_time_ms);
328   _recent_prev_end_times_for_all_gcs_sec-&gt;add(end_time_sec);
329   _prev_collection_pause_end_ms = end_time_sec * 1000.0;
330 }
331 
332 void G1Analytics::report_concurrent_mark_cleanup_times_ms(double ms) {
333   _concurrent_mark_cleanup_times_ms-&gt;add(ms);
334 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Analytics.hpp&quot;
 27 #include &quot;gc/g1/g1Predictions.hpp&quot;
<span class="line-added"> 28 #include &quot;runtime/globals.hpp&quot;</span>
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;utilities/debug.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 32 #include &quot;utilities/numberSeq.hpp&quot;
 33 
 34 // Different defaults for different number of GC threads
 35 // They were chosen by running GCOld and SPECjbb on debris with different
 36 //   numbers of GC threads and choosing them based on the results
 37 
 38 // all the same
 39 static double rs_length_diff_defaults[] = {
 40   0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
 41 };
 42 
<span class="line-modified"> 43 static double cost_per_logged_card_ms_defaults[] = {</span>
 44   0.01, 0.005, 0.005, 0.003, 0.003, 0.002, 0.002, 0.0015
 45 };
 46 
 47 // all the same
<span class="line-modified"> 48 static double young_card_merge_to_scan_ratio_defaults[] = {</span>
 49   1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
 50 };
 51 
<span class="line-modified"> 52 static double young_only_cost_per_card_scan_ms_defaults[] = {</span>
 53   0.015, 0.01, 0.01, 0.008, 0.008, 0.0055, 0.0055, 0.005
 54 };
 55 
 56 static double cost_per_byte_ms_defaults[] = {
 57   0.00006, 0.00003, 0.00003, 0.000015, 0.000015, 0.00001, 0.00001, 0.000009
 58 };
 59 
 60 // these should be pretty consistent
 61 static double constant_other_time_ms_defaults[] = {
 62   5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0
 63 };
 64 

 65 static double young_other_cost_per_region_ms_defaults[] = {
 66   0.3, 0.2, 0.2, 0.15, 0.15, 0.12, 0.12, 0.1
 67 };
 68 
 69 static double non_young_other_cost_per_region_ms_defaults[] = {
 70   1.0, 0.7, 0.7, 0.5, 0.5, 0.42, 0.42, 0.30
 71 };
 72 
 73 G1Analytics::G1Analytics(const G1Predictions* predictor) :
 74     _predictor(predictor),
 75     _recent_gc_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 76     _concurrent_mark_remark_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 77     _concurrent_mark_cleanup_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
 78     _alloc_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 79     _prev_collection_pause_end_ms(0.0),
 80     _rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified"> 81     _concurrent_refine_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 82     _logged_cards_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 83     _young_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 84     _mixed_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 85     _young_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 86     _mixed_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified"> 87     _young_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-added"> 88     _mixed_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-added"> 89     _copy_cost_per_byte_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
 90     _constant_other_time_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 91     _young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 92     _non_young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
 93     _pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified"> 94     _rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
 95     _cost_per_byte_ms_during_cm_seq(new TruncatedSeq(TruncatedSeqLength)),
 96     _recent_prev_end_times_for_all_gcs_sec(new TruncatedSeq(NumPrevPausesForHeuristics)),
 97     _recent_avg_pause_time_ratio(0.0),
 98     _last_pause_time_ratio(0.0) {
 99 
100   // Seed sequences with initial values.
101   _recent_prev_end_times_for_all_gcs_sec-&gt;add(os::elapsedTime());
102   _prev_collection_pause_end_ms = os::elapsedTime() * 1000.0;
103 
104   int index = MIN2(ParallelGCThreads - 1, 7u);
105 
106   _rs_length_diff_seq-&gt;add(rs_length_diff_defaults[index]);
<span class="line-modified">107   // Start with inverse of maximum STW cost.</span>
<span class="line-modified">108   _concurrent_refine_rate_ms_seq-&gt;add(1/cost_per_logged_card_ms_defaults[0]);</span>
<span class="line-modified">109   // Some applications have very low rates for logging cards.</span>
<span class="line-modified">110   _logged_cards_rate_ms_seq-&gt;add(0.0);</span>
<span class="line-modified">111   _young_card_merge_to_scan_ratio_seq-&gt;add(young_card_merge_to_scan_ratio_defaults[index]);</span>
<span class="line-added">112   _young_cost_per_card_scan_ms_seq-&gt;add(young_only_cost_per_card_scan_ms_defaults[index]);</span>
<span class="line-added">113 </span>
<span class="line-added">114   _copy_cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms_defaults[index]);</span>
115   _constant_other_time_ms_seq-&gt;add(constant_other_time_ms_defaults[index]);
116   _young_other_cost_per_region_ms_seq-&gt;add(young_other_cost_per_region_ms_defaults[index]);
117   _non_young_other_cost_per_region_ms_seq-&gt;add(non_young_other_cost_per_region_ms_defaults[index]);
118 
119   // start conservatively (around 50ms is about right)
120   _concurrent_mark_remark_times_ms-&gt;add(0.05);
121   _concurrent_mark_cleanup_times_ms-&gt;add(0.20);
122 }
123 
<span class="line-modified">124 bool G1Analytics::enough_samples_available(TruncatedSeq const* seq) const {</span>
<span class="line-modified">125   return seq-&gt;num() &gt;= 3;</span>
<span class="line-added">126 }</span>
<span class="line-added">127 </span>
<span class="line-added">128 double G1Analytics::predict_in_unit_interval(TruncatedSeq const* seq) const {</span>
<span class="line-added">129   return _predictor-&gt;predict_in_unit_interval(seq);</span>
130 }
131 
<span class="line-modified">132 size_t G1Analytics::predict_size(TruncatedSeq const* seq) const {</span>
<span class="line-modified">133   return (size_t)predict_zero_bounded(seq);</span>
<span class="line-added">134 }</span>
<span class="line-added">135 </span>
<span class="line-added">136 double G1Analytics::predict_zero_bounded(TruncatedSeq const* seq) const {</span>
<span class="line-added">137   return _predictor-&gt;predict_zero_bounded(seq);</span>
138 }
139 
140 int G1Analytics::num_alloc_rate_ms() const {
141   return _alloc_rate_ms_seq-&gt;num();
142 }
143 
144 void G1Analytics::report_concurrent_mark_remark_times_ms(double ms) {
145   _concurrent_mark_remark_times_ms-&gt;add(ms);
146 }
147 
148 void G1Analytics::report_alloc_rate_ms(double alloc_rate) {
149   _alloc_rate_ms_seq-&gt;add(alloc_rate);
150 }
151 
152 void G1Analytics::compute_pause_time_ratio(double interval_ms, double pause_time_ms) {
153   _recent_avg_pause_time_ratio = _recent_gc_times_ms-&gt;sum() / interval_ms;
<span class="line-modified">154 </span>
<span class="line-modified">155   // Clamp the result to [0.0 ... 1.0] to filter out nonsensical results due to bad input.</span>
<span class="line-modified">156   _recent_avg_pause_time_ratio = clamp(_recent_avg_pause_time_ratio, 0.0, 1.0);</span>








157 
158   // Compute the ratio of just this last pause time to the entire time range stored
159   // in the vectors. Comparing this pause to the entire range, rather than only the
160   // most recent interval, has the effect of smoothing over a possible transient &#39;burst&#39;
161   // of more frequent pauses that don&#39;t really reflect a change in heap occupancy.
162   // This reduces the likelihood of a needless heap expansion being triggered.
163   _last_pause_time_ratio =
164     (pause_time_ms * _recent_prev_end_times_for_all_gcs_sec-&gt;num()) / interval_ms;
165 }
166 
<span class="line-modified">167 void G1Analytics::report_concurrent_refine_rate_ms(double cards_per_ms) {</span>
<span class="line-modified">168   _concurrent_refine_rate_ms_seq-&gt;add(cards_per_ms);</span>
<span class="line-added">169 }</span>
<span class="line-added">170 </span>
<span class="line-added">171 void G1Analytics::report_logged_cards_rate_ms(double cards_per_ms) {</span>
<span class="line-added">172   _logged_cards_rate_ms_seq-&gt;add(cards_per_ms);</span>
173 }
174 
<span class="line-modified">175 void G1Analytics::report_cost_per_card_scan_ms(double cost_per_card_ms, bool for_young_gc) {</span>
<span class="line-modified">176   if (for_young_gc) {</span>
<span class="line-added">177     _young_cost_per_card_scan_ms_seq-&gt;add(cost_per_card_ms);</span>
<span class="line-added">178   } else {</span>
<span class="line-added">179     _mixed_cost_per_card_scan_ms_seq-&gt;add(cost_per_card_ms);</span>
<span class="line-added">180   }</span>
181 }
182 
<span class="line-modified">183 void G1Analytics::report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_gc) {</span>
184   if (for_young_gc) {
<span class="line-modified">185     _young_cost_per_card_merge_ms_seq-&gt;add(cost_per_card_ms);</span>
186   } else {
<span class="line-modified">187     _mixed_cost_per_card_merge_ms_seq-&gt;add(cost_per_card_ms);</span>
188   }
189 }
190 
<span class="line-modified">191 void G1Analytics::report_card_merge_to_scan_ratio(double merge_to_scan_ratio, bool for_young_gc) {</span>
192   if (for_young_gc) {
<span class="line-modified">193     _young_card_merge_to_scan_ratio_seq-&gt;add(merge_to_scan_ratio);</span>
194   } else {
<span class="line-modified">195     _mixed_card_merge_to_scan_ratio_seq-&gt;add(merge_to_scan_ratio);</span>
196   }
197 }
198 
199 void G1Analytics::report_rs_length_diff(double rs_length_diff) {
200   _rs_length_diff_seq-&gt;add(rs_length_diff);
201 }
202 
203 void G1Analytics::report_cost_per_byte_ms(double cost_per_byte_ms, bool mark_or_rebuild_in_progress) {
204   if (mark_or_rebuild_in_progress) {
205     _cost_per_byte_ms_during_cm_seq-&gt;add(cost_per_byte_ms);
206   } else {
<span class="line-modified">207     _copy_cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms);</span>
208   }
209 }
210 
211 void G1Analytics::report_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
212   _young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
213 }
214 
215 void G1Analytics::report_non_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
216   _non_young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
217 }
218 
219 void G1Analytics::report_constant_other_time_ms(double constant_other_time_ms) {
220   _constant_other_time_ms_seq-&gt;add(constant_other_time_ms);
221 }
222 
223 void G1Analytics::report_pending_cards(double pending_cards) {
224   _pending_cards_seq-&gt;add(pending_cards);
225 }
226 
<span class="line-modified">227 void G1Analytics::report_rs_length(double rs_length) {</span>
<span class="line-modified">228   _rs_length_seq-&gt;add(rs_length);</span>




229 }
230 
231 double G1Analytics::predict_alloc_rate_ms() const {
<span class="line-modified">232   return predict_zero_bounded(_alloc_rate_ms_seq);</span>








233 }
234 
<span class="line-modified">235 double G1Analytics::predict_concurrent_refine_rate_ms() const {</span>
<span class="line-modified">236   return predict_zero_bounded(_concurrent_refine_rate_ms_seq);</span>
237 }
238 
<span class="line-modified">239 double G1Analytics::predict_logged_cards_rate_ms() const {</span>
<span class="line-modified">240   return predict_zero_bounded(_logged_cards_rate_ms_seq);</span>
241 }
242 
<span class="line-modified">243 double G1Analytics::predict_young_card_merge_to_scan_ratio() const {</span>
<span class="line-modified">244   return predict_in_unit_interval(_young_card_merge_to_scan_ratio_seq);</span>




245 }
246 
<span class="line-modified">247 size_t G1Analytics::predict_scan_card_num(size_t rs_length, bool for_young_gc) const {</span>
<span class="line-modified">248   if (for_young_gc || !enough_samples_available(_mixed_card_merge_to_scan_ratio_seq)) {</span>
<span class="line-modified">249     return (size_t)(rs_length * predict_young_card_merge_to_scan_ratio());</span>
250   } else {
<span class="line-modified">251     return (size_t)(rs_length * predict_in_unit_interval(_mixed_card_merge_to_scan_ratio_seq));</span>
252   }
253 }
254 
<span class="line-modified">255 double G1Analytics::predict_card_merge_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">256   if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_merge_ms_seq)) {</span>
<span class="line-modified">257     return card_num * predict_zero_bounded(_young_cost_per_card_merge_ms_seq);</span>
258   } else {
<span class="line-modified">259     return card_num * predict_zero_bounded(_mixed_cost_per_card_merge_ms_seq);</span>
260   }
261 }
262 
<span class="line-modified">263 double G1Analytics::predict_card_scan_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">264   if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_scan_ms_seq)) {</span>
<span class="line-modified">265     return card_num * predict_zero_bounded(_young_cost_per_card_scan_ms_seq);</span>
266   } else {
<span class="line-modified">267     return card_num * predict_zero_bounded(_mixed_cost_per_card_scan_ms_seq);</span>
268   }
269 }
270 
271 double G1Analytics::predict_object_copy_time_ms_during_cm(size_t bytes_to_copy) const {
<span class="line-modified">272   if (!enough_samples_available(_cost_per_byte_ms_during_cm_seq)) {</span>
<span class="line-modified">273     return (1.1 * bytes_to_copy) * predict_zero_bounded(_copy_cost_per_byte_ms_seq);</span>
274   } else {
<span class="line-modified">275     return bytes_to_copy * predict_zero_bounded(_cost_per_byte_ms_during_cm_seq);</span>
276   }
277 }
278 
279 double G1Analytics::predict_object_copy_time_ms(size_t bytes_to_copy, bool during_concurrent_mark) const {
280   if (during_concurrent_mark) {
281     return predict_object_copy_time_ms_during_cm(bytes_to_copy);
282   } else {
<span class="line-modified">283     return bytes_to_copy * predict_zero_bounded(_copy_cost_per_byte_ms_seq);</span>
284   }
285 }
286 




287 double G1Analytics::predict_constant_other_time_ms() const {
<span class="line-modified">288   return predict_zero_bounded(_constant_other_time_ms_seq);</span>
289 }
290 
291 double G1Analytics::predict_young_other_time_ms(size_t young_num) const {
<span class="line-modified">292   return young_num * predict_zero_bounded(_young_other_cost_per_region_ms_seq);</span>
293 }
294 
295 double G1Analytics::predict_non_young_other_time_ms(size_t non_young_num) const {
<span class="line-modified">296   return non_young_num * predict_zero_bounded(_non_young_other_cost_per_region_ms_seq);</span>
297 }
298 
299 double G1Analytics::predict_remark_time_ms() const {
<span class="line-modified">300   return predict_zero_bounded(_concurrent_mark_remark_times_ms);</span>
301 }
302 
303 double G1Analytics::predict_cleanup_time_ms() const {
<span class="line-modified">304   return predict_zero_bounded(_concurrent_mark_cleanup_times_ms);</span>
305 }
306 
<span class="line-modified">307 size_t G1Analytics::predict_rs_length() const {</span>
<span class="line-modified">308   return predict_size(_rs_length_seq) + predict_size(_rs_length_diff_seq);</span>
309 }
310 
311 size_t G1Analytics::predict_pending_cards() const {
<span class="line-modified">312   return predict_size(_pending_cards_seq);</span>
313 }
314 
315 double G1Analytics::last_known_gc_end_time_sec() const {
316   return _recent_prev_end_times_for_all_gcs_sec-&gt;oldest();
317 }
318 
319 void G1Analytics::update_recent_gc_times(double end_time_sec,
320                                          double pause_time_ms) {
321   _recent_gc_times_ms-&gt;add(pause_time_ms);
322   _recent_prev_end_times_for_all_gcs_sec-&gt;add(end_time_sec);
323   _prev_collection_pause_end_ms = end_time_sec * 1000.0;
324 }
325 
326 void G1Analytics::report_concurrent_mark_cleanup_times_ms(double ms) {
327   _concurrent_mark_cleanup_times_ms-&gt;add(ms);
328 }
</pre>
</td>
</tr>
</table>
<center><a href="g1Allocator.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
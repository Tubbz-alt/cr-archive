<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1OopClosures.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopStarChunkedList.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1OopClosures.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oopsHierarchy.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  
  template &lt;class T&gt;
  inline void G1ScanClosureBase::prefetch_and_push(T* p, const oop obj) {
    // We&#39;re not going to even bother checking whether the object is
    // already forwarded or not, as this usually causes an immediate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,14 ***</span>
  
    _par_scan_state-&gt;push_on_queue(p);
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanClosureBase::handle_non_cset_obj_common(InCSetState const state, T* p, oop const obj) {</span>
<span class="line-modified">!   if (state.is_humongous()) {</span>
      _g1h-&gt;set_humongous_is_live(obj);
<span class="line-modified">!   } else if (state.is_optional()) {</span>
      _par_scan_state-&gt;remember_reference_into_optional_region(p);
    }
  }
  
  inline void G1ScanClosureBase::trim_queue_partially() {
<span class="line-new-header">--- 60,14 ---</span>
  
    _par_scan_state-&gt;push_on_queue(p);
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanClosureBase::handle_non_cset_obj_common(G1HeapRegionAttr const region_attr, T* p, oop const obj) {</span>
<span class="line-modified">!   if (region_attr.is_humongous()) {</span>
      _g1h-&gt;set_humongous_is_live(obj);
<span class="line-modified">!   } else if (region_attr.is_optional()) {</span>
      _par_scan_state-&gt;remember_reference_into_optional_region(p);
    }
  }
  
  inline void G1ScanClosureBase::trim_queue_partially() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,20 ***</span>
  
    if (CompressedOops::is_null(heap_oop)) {
      return;
    }
    oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">!   const InCSetState state = _g1h-&gt;in_cset_state(obj);</span>
<span class="line-modified">!   if (state.is_in_cset()) {</span>
      prefetch_and_push(p, obj);
    } else if (!HeapRegion::is_in_same_region(p, obj)) {
<span class="line-modified">!     handle_non_cset_obj_common(state, p, obj);</span>
      assert(_scanning_in_young != Uninitialized, &quot;Scan location has not been initialized.&quot;);
      if (_scanning_in_young == True) {
        return;
      }
<span class="line-modified">!     _par_scan_state-&gt;enqueue_card_if_tracked(p, obj);</span>
    }
  }
  
  template &lt;class T&gt;
  inline void G1CMOopClosure::do_oop_work(T* p) {
<span class="line-new-header">--- 80,20 ---</span>
  
    if (CompressedOops::is_null(heap_oop)) {
      return;
    }
    oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">!   const G1HeapRegionAttr region_attr = _g1h-&gt;region_attr(obj);</span>
<span class="line-modified">!   if (region_attr.is_in_cset()) {</span>
      prefetch_and_push(p, obj);
    } else if (!HeapRegion::is_in_same_region(p, obj)) {
<span class="line-modified">!     handle_non_cset_obj_common(region_attr, p, obj);</span>
      assert(_scanning_in_young != Uninitialized, &quot;Scan location has not been initialized.&quot;);
      if (_scanning_in_young == True) {
        return;
      }
<span class="line-modified">!     _par_scan_state-&gt;enqueue_card_if_tracked(region_attr, p, obj);</span>
    }
  }
  
  template &lt;class T&gt;
  inline void G1CMOopClosure::do_oop_work(T* p) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,12 ***</span>
  inline static void check_obj_during_refinement(T* p, oop const obj) {
  #ifdef ASSERT
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    // can&#39;t do because of races
    // assert(oopDesc::is_oop_or_null(obj), &quot;expected an oop&quot;);
<span class="line-modified">!   assert(check_obj_alignment(obj), &quot;not oop aligned&quot;);</span>
<span class="line-modified">!   assert(g1h-&gt;is_in_reserved(obj), &quot;must be in heap&quot;);</span>
  
    HeapRegion* from = g1h-&gt;heap_region_containing(p);
  
    assert(from != NULL, &quot;from region must be non-NULL&quot;);
    assert(from-&gt;is_in_reserved(p) ||
<span class="line-new-header">--- 114,12 ---</span>
  inline static void check_obj_during_refinement(T* p, oop const obj) {
  #ifdef ASSERT
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    // can&#39;t do because of races
    // assert(oopDesc::is_oop_or_null(obj), &quot;expected an oop&quot;);
<span class="line-modified">!   assert(is_object_aligned(obj), &quot;oop must be aligned&quot;);</span>
<span class="line-modified">!   assert(g1h-&gt;is_in_reserved(obj), &quot;oop must be in reserved&quot;);</span>
  
    HeapRegion* from = g1h-&gt;heap_region_containing(p);
  
    assert(from != NULL, &quot;from region must be non-NULL&quot;);
    assert(from-&gt;is_in_reserved(p) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,54 ***</span>
  
    HeapRegionRemSet* to_rem_set = _g1h-&gt;heap_region_containing(obj)-&gt;rem_set();
  
    assert(to_rem_set != NULL, &quot;Need per-region &#39;into&#39; remsets.&quot;);
    if (to_rem_set-&gt;is_tracked()) {
<span class="line-modified">!     to_rem_set-&gt;add_reference(p, _worker_i);</span>
    }
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanObjsDuringUpdateRSClosure::do_oop_work(T* p) {</span>
    T o = RawAccess&lt;&gt;::oop_load(p);
    if (CompressedOops::is_null(o)) {
      return;
    }
    oop obj = CompressedOops::decode_not_null(o);
  
    check_obj_during_refinement(p, obj);
  
<span class="line-modified">!   assert(!_g1h-&gt;is_in_cset((HeapWord*)p), &quot;Oop originates from &quot; PTR_FORMAT &quot; (region: %u) which is in the collection set.&quot;, p2i(p), _g1h-&gt;addr_to_region((HeapWord*)p));</span>
<span class="line-modified">!   const InCSetState state = _g1h-&gt;in_cset_state(obj);</span>
<span class="line-modified">!   if (state.is_in_cset()) {</span>
      // Since the source is always from outside the collection set, here we implicitly know
      // that this is a cross-region reference too.
      prefetch_and_push(p, obj);
    } else if (!HeapRegion::is_in_same_region(p, obj)) {
<span class="line-modified">!     handle_non_cset_obj_common(state, p, obj);</span>
<span class="line-modified">!     _par_scan_state-&gt;enqueue_card_if_tracked(p, obj);</span>
    }
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanObjsDuringScanRSClosure::do_oop_work(T* p) {</span>
<span class="line-modified">!   T heap_oop = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-modified">!   if (CompressedOops::is_null(heap_oop)) {</span>
      return;
    }
<span class="line-removed">-   oop obj = CompressedOops::decode_not_null(heap_oop);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   const InCSetState state = _g1h-&gt;in_cset_state(obj);</span>
<span class="line-removed">-   if (state.is_in_cset()) {</span>
<span class="line-removed">-     prefetch_and_push(p, obj);</span>
<span class="line-removed">-   } else if (!HeapRegion::is_in_same_region(p, obj)) {</span>
<span class="line-removed">-     handle_non_cset_obj_common(state, p, obj);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;class T&gt;</span>
<span class="line-removed">- inline void G1ScanRSForOptionalClosure::do_oop_work(T* p) {</span>
    _scan_cl-&gt;do_oop_work(p);
    _scan_cl-&gt;trim_queue_partially();
  }
  
  void G1ParCopyHelper::do_cld_barrier(oop new_obj) {
<span class="line-new-header">--- 154,48 ---</span>
  
    HeapRegionRemSet* to_rem_set = _g1h-&gt;heap_region_containing(obj)-&gt;rem_set();
  
    assert(to_rem_set != NULL, &quot;Need per-region &#39;into&#39; remsets.&quot;);
    if (to_rem_set-&gt;is_tracked()) {
<span class="line-modified">!     to_rem_set-&gt;add_reference(p, _worker_id);</span>
    }
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanCardClosure::do_oop_work(T* p) {</span>
    T o = RawAccess&lt;&gt;::oop_load(p);
    if (CompressedOops::is_null(o)) {
      return;
    }
    oop obj = CompressedOops::decode_not_null(o);
  
    check_obj_during_refinement(p, obj);
  
<span class="line-modified">!   assert(!_g1h-&gt;is_in_cset((HeapWord*)p),</span>
<span class="line-modified">!          &quot;Oop originates from &quot; PTR_FORMAT &quot; (region: %u) which is in the collection set.&quot;,</span>
<span class="line-modified">!          p2i(p), _g1h-&gt;addr_to_region((HeapWord*)p));</span>
<span class="line-added">+ </span>
<span class="line-added">+   const G1HeapRegionAttr region_attr = _g1h-&gt;region_attr(obj);</span>
<span class="line-added">+   if (region_attr.is_in_cset()) {</span>
      // Since the source is always from outside the collection set, here we implicitly know
      // that this is a cross-region reference too.
      prefetch_and_push(p, obj);
    } else if (!HeapRegion::is_in_same_region(p, obj)) {
<span class="line-modified">!     handle_non_cset_obj_common(region_attr, p, obj);</span>
<span class="line-modified">!     _par_scan_state-&gt;enqueue_card_if_tracked(region_attr, p, obj);</span>
    }
  }
  
  template &lt;class T&gt;
<span class="line-modified">! inline void G1ScanRSForOptionalClosure::do_oop_work(T* p) {</span>
<span class="line-modified">!   const G1HeapRegionAttr region_attr = _g1h-&gt;region_attr(p);</span>
<span class="line-modified">!   // Entries in the optional collection set may start to originate from the collection</span>
<span class="line-added">+   // set after one or more increments. In this case, previously optional regions</span>
<span class="line-added">+   // became actual collection set regions. Filter them out here.</span>
<span class="line-added">+   if (region_attr.is_in_cset()) {</span>
      return;
    }
    _scan_cl-&gt;do_oop_work(p);
    _scan_cl-&gt;trim_queue_partially();
  }
  
  void G1ParCopyHelper::do_cld_barrier(oop new_obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,16 ***</span>
  
    oop obj = CompressedOops::decode_not_null(heap_oop);
  
    assert(_worker_id == _par_scan_state-&gt;worker_id(), &quot;sanity&quot;);
  
<span class="line-modified">!   const InCSetState state = _g1h-&gt;in_cset_state(obj);</span>
    if (state.is_in_cset()) {
      oop forwardee;
<span class="line-modified">!     markOop m = obj-&gt;mark_raw();</span>
<span class="line-modified">!     if (m-&gt;is_marked()) {</span>
<span class="line-modified">!       forwardee = (oop) m-&gt;decode_pointer();</span>
      } else {
        forwardee = _par_scan_state-&gt;copy_to_survivor_space(state, obj, m);
      }
      assert(forwardee != NULL, &quot;forwardee should not be NULL&quot;);
      RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forwardee);
<span class="line-new-header">--- 226,16 ---</span>
  
    oop obj = CompressedOops::decode_not_null(heap_oop);
  
    assert(_worker_id == _par_scan_state-&gt;worker_id(), &quot;sanity&quot;);
  
<span class="line-modified">!   const G1HeapRegionAttr state = _g1h-&gt;region_attr(obj);</span>
    if (state.is_in_cset()) {
      oop forwardee;
<span class="line-modified">!     markWord m = obj-&gt;mark_raw();</span>
<span class="line-modified">!     if (m.is_marked()) {</span>
<span class="line-modified">!       forwardee = (oop) m.decode_pointer();</span>
      } else {
        forwardee = _par_scan_state-&gt;copy_to_survivor_space(state, obj, m);
      }
      assert(forwardee != NULL, &quot;forwardee should not be NULL&quot;);
      RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forwardee);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,11 ***</span>
        do_cld_barrier(forwardee);
      }
    } else {
      if (state.is_humongous()) {
        _g1h-&gt;set_humongous_is_live(obj);
<span class="line-modified">!     } else if (state.is_optional()) {</span>
        _par_scan_state-&gt;remember_root_into_optional_region(p);
      }
  
      // The object is not in collection set. If we&#39;re a root scanning
      // closure during an initial mark pause then attempt to mark the object.
<span class="line-new-header">--- 244,11 ---</span>
        do_cld_barrier(forwardee);
      }
    } else {
      if (state.is_humongous()) {
        _g1h-&gt;set_humongous_is_live(obj);
<span class="line-modified">!     } else if ((barrier != G1BarrierNoOptRoots) &amp;&amp; state.is_optional()) {</span>
        _par_scan_state-&gt;remember_root_into_optional_region(p);
      }
  
      // The object is not in collection set. If we&#39;re a root scanning
      // closure during an initial mark pause then attempt to mark the object.
</pre>
<center><a href="g1OopClosures.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopStarChunkedList.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 // Forward decl
 32 class G1ConcurrentRefine;
 33 class G1ConcurrentRefineThread;
 34 class outputStream;
 35 class ThreadClosure;
 36 
 37 // Helper class for refinement thread management. Used to start, stop and
 38 // iterate over them.
 39 class G1ConcurrentRefineThreadControl {
 40   G1ConcurrentRefine* _cr;
 41 
 42   G1ConcurrentRefineThread** _threads;
 43   uint _num_max_threads;
 44 
 45   // Create the refinement thread for the given worker id.
 46   // If initializing is true, ignore InjectGCWorkerCreationFailure.
 47   G1ConcurrentRefineThread* create_refinement_thread(uint worker_id, bool initializing);
 48 public:
 49   G1ConcurrentRefineThreadControl();
 50   ~G1ConcurrentRefineThreadControl();
 51 
 52   jint initialize(G1ConcurrentRefine* cr, uint num_max_threads);
 53 
 54   // If there is a &quot;successor&quot; thread that can be activated given the current id,
 55   // activate it.
 56   void maybe_activate_next(uint cur_worker_id);
 57 
 58   void print_on(outputStream* st) const;
 59   void worker_threads_do(ThreadClosure* tc);
 60   void stop();
 61 };
 62 
 63 // Controls refinement threads and their activation based on the number of completed
 64 // buffers currently available in the global dirty card queue.
 65 // Refinement threads pick work from the queue based on these thresholds. They are activated
 66 // gradually based on the amount of work to do.
 67 // Refinement thread n activates thread n+1 if the instance of this class determines there
 68 // is enough work available. Threads deactivate themselves if the current amount of
 69 // completed buffers falls below their individual threshold.
 70 class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
 71   G1ConcurrentRefineThreadControl _thread_control;
 72   /*
 73    * The value of the completed dirty card queue length falls into one of 3 zones:
 74    * green, yellow, red. If the value is in [0, green) nothing is
 75    * done, the buffers are left unprocessed to enable the caching effect of the
 76    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
 77    * threads are gradually activated. In [yellow, red) all threads are
 78    * running. If the length becomes red (max queue length) the mutators start
 79    * processing the buffers.
 80    *
 81    * There are some interesting cases (when G1UseAdaptiveConcRefinement
 82    * is turned off):
 83    * 1) green = yellow = red = 0. In this case the mutator will process all
 84    *    buffers. Except for those that are created by the deferred updates
 85    *    machinery during a collection.
 86    * 2) green = 0. Means no caching. Can be a good way to minimize the
 87    *    amount of time spent updating remembered sets during a collection.
 88    */
 89   size_t _green_zone;
 90   size_t _yellow_zone;
 91   size_t _red_zone;
 92   size_t _min_yellow_zone_size;
 93 
 94   G1ConcurrentRefine(size_t green_zone,
 95                      size_t yellow_zone,
 96                      size_t red_zone,
 97                      size_t min_yellow_zone_size);
 98 
 99   // Update green/yellow/red zone values based on how well goals are being met.
100   void update_zones(double update_rs_time,
101                     size_t update_rs_processed_buffers,
102                     double goal_ms);
103 
104   static uint worker_id_offset();
105   void maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers);
106 
107   jint initialize();
108 public:
109   ~G1ConcurrentRefine();
110 
111   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
112   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
113   static G1ConcurrentRefine* create(jint* ecode);
114 
115   void stop();
116 
117   // Adjust refinement thresholds based on work done during the pause and the goal time.
118   void adjust(double update_rs_time, size_t update_rs_processed_buffers, double goal_ms);
119 
120   size_t activation_threshold(uint worker_id) const;
121   size_t deactivation_threshold(uint worker_id) const;
122   // Perform a single refinement step. Called by the refinement threads when woken up.
123   bool do_refinement_step(uint worker_id);
124 
125   // Iterate over all concurrent refinement threads applying the given closure.
126   void threads_do(ThreadClosure *tc);
127 
128   // Maximum number of refinement threads.
129   static uint max_num_threads();
130 
131   void print_threads_on(outputStream* st) const;
132 
133   size_t green_zone() const      { return _green_zone;  }
134   size_t yellow_zone() const     { return _yellow_zone; }
135   size_t red_zone() const        { return _red_zone;    }
136 };
137 
138 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
    </pre>
  </body>
</html>
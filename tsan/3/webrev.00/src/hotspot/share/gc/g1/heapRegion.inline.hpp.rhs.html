<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/heapRegion.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGION_INLINE_HPP
 26 #define SHARE_GC_G1_HEAPREGION_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;gc/g1/g1Predictions.hpp&quot;</span>
 32 #include &quot;gc/g1/heapRegion.hpp&quot;
<a name="2" id="anc2"></a>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added"> 37 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 38 
<a name="4" id="anc4"></a><span class="line-modified"> 39 inline HeapWord* HeapRegion::allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 40                                            size_t desired_word_size,</span>
<span class="line-modified"> 41                                            size_t* actual_size) {</span>
 42   HeapWord* obj = top();
 43   size_t available = pointer_delta(end(), obj);
 44   size_t want_to_allocate = MIN2(available, desired_word_size);
 45   if (want_to_allocate &gt;= min_word_size) {
 46     HeapWord* new_top = obj + want_to_allocate;
 47     set_top(new_top);
<a name="5" id="anc5"></a><span class="line-modified"> 48     assert(is_object_aligned(obj) &amp;&amp; is_object_aligned(new_top), &quot;checking alignment&quot;);</span>
 49     *actual_size = want_to_allocate;
 50     return obj;
 51   } else {
 52     return NULL;
 53   }
 54 }
 55 
<a name="6" id="anc6"></a><span class="line-modified"> 56 inline HeapWord* HeapRegion::par_allocate_impl(size_t min_word_size,</span>
<span class="line-modified"> 57                                                size_t desired_word_size,</span>
<span class="line-modified"> 58                                                size_t* actual_size) {</span>
 59   do {
 60     HeapWord* obj = top();
 61     size_t available = pointer_delta(end(), obj);
 62     size_t want_to_allocate = MIN2(available, desired_word_size);
 63     if (want_to_allocate &gt;= min_word_size) {
 64       HeapWord* new_top = obj + want_to_allocate;
<a name="7" id="anc7"></a><span class="line-modified"> 65       HeapWord* result = Atomic::cmpxchg(&amp;_top, obj, new_top);</span>
 66       // result can be one of two:
 67       //  the old top value: the exchange succeeded
 68       //  otherwise: the new value of the top is returned.
 69       if (result == obj) {
<a name="8" id="anc8"></a><span class="line-modified"> 70         assert(is_object_aligned(obj) &amp;&amp; is_object_aligned(new_top), &quot;checking alignment&quot;);</span>
 71         *actual_size = want_to_allocate;
 72         return obj;
 73       }
 74     } else {
 75       return NULL;
 76     }
 77   } while (true);
 78 }
 79 
<a name="9" id="anc9"></a><span class="line-modified"> 80 inline HeapWord* HeapRegion::allocate(size_t min_word_size,</span>
<span class="line-modified"> 81                                       size_t desired_word_size,</span>
<span class="line-modified"> 82                                       size_t* actual_size) {</span>
 83   HeapWord* res = allocate_impl(min_word_size, desired_word_size, actual_size);
 84   if (res != NULL) {
 85     _bot_part.alloc_block(res, *actual_size);
 86   }
 87   return res;
 88 }
 89 
<a name="10" id="anc10"></a><span class="line-modified"> 90 inline HeapWord* HeapRegion::allocate(size_t word_size) {</span>
 91   size_t temp;
 92   return allocate(word_size, word_size, &amp;temp);
 93 }
 94 
<a name="11" id="anc11"></a><span class="line-modified"> 95 inline HeapWord* HeapRegion::par_allocate(size_t word_size) {</span>
 96   size_t temp;
 97   return par_allocate(word_size, word_size, &amp;temp);
 98 }
 99 
100 // Because of the requirement of keeping &quot;_offsets&quot; up to date with the
101 // allocations, we sequentialize these with a lock.  Therefore, best if
102 // this is used for larger LAB allocations only.
<a name="12" id="anc12"></a><span class="line-modified">103 inline HeapWord* HeapRegion::par_allocate(size_t min_word_size,</span>
<span class="line-modified">104                                           size_t desired_word_size,</span>
<span class="line-modified">105                                           size_t* actual_size) {</span>
106   MutexLocker x(&amp;_par_alloc_lock);
107   return allocate(min_word_size, desired_word_size, actual_size);
108 }
109 
<a name="13" id="anc13"></a><span class="line-modified">110 inline HeapWord* HeapRegion::block_start(const void* p) {</span>
111   return _bot_part.block_start(p);
112 }
113 
<a name="14" id="anc14"></a><span class="line-modified">114 inline HeapWord* HeapRegion::block_start_const(const void* p) const {</span>

115   return _bot_part.block_start_const(p);
116 }
117 
118 inline bool HeapRegion::is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const {
<a name="15" id="anc15"></a><span class="line-modified">119   HeapWord* addr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
120 
121   assert(addr &lt; top(), &quot;must be&quot;);
122   assert(!is_closed_archive(),
123          &quot;Closed archive regions should not have references into other regions&quot;);
124   assert(!is_humongous(), &quot;Humongous objects not handled here&quot;);
125   bool obj_is_dead = is_obj_dead(obj, prev_bitmap);
126 
127   if (ClassUnloadingWithConcurrentMark &amp;&amp; obj_is_dead) {
128     assert(!block_is_obj(addr), &quot;must be&quot;);
129     *size = block_size_using_bitmap(addr, prev_bitmap);
130   } else {
131     assert(block_is_obj(addr), &quot;must be&quot;);
132     *size = obj-&gt;size();
133   }
134   return obj_is_dead;
135 }
136 
<a name="16" id="anc16"></a><span class="line-modified">137 inline bool HeapRegion::block_is_obj(const HeapWord* p) const {</span>

138   G1CollectedHeap* g1h = G1CollectedHeap::heap();
139 
140   if (!this-&gt;is_in(p)) {
141     assert(is_continues_humongous(), &quot;This case can only happen for humongous regions&quot;);
142     return (p == humongous_start_region()-&gt;bottom());
143   }
144   if (ClassUnloadingWithConcurrentMark) {
145     return !g1h-&gt;is_obj_dead(oop(p), this);
146   }
147   return p &lt; top();
148 }
149 
150 inline size_t HeapRegion::block_size_using_bitmap(const HeapWord* addr, const G1CMBitMap* const prev_bitmap) const {
151   assert(ClassUnloadingWithConcurrentMark,
152          &quot;All blocks should be objects if class unloading isn&#39;t used, so this method should not be called. &quot;
153          &quot;HR: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
154          &quot;addr: &quot; PTR_FORMAT,
155          p2i(bottom()), p2i(top()), p2i(end()), p2i(addr));
156 
157   // Old regions&#39; dead objects may have dead classes
158   // We need to find the next live object using the bitmap
159   HeapWord* next = prev_bitmap-&gt;get_next_marked_addr(addr, prev_top_at_mark_start());
160 
161   assert(next &gt; addr, &quot;must get the next live object&quot;);
162   return pointer_delta(next, addr);
163 }
164 
165 inline bool HeapRegion::is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const {
166   assert(is_in_reserved(obj), &quot;Object &quot; PTR_FORMAT &quot; must be in region&quot;, p2i(obj));
167   return !obj_allocated_since_prev_marking(obj) &amp;&amp;
<a name="17" id="anc17"></a><span class="line-modified">168          !prev_bitmap-&gt;is_marked(obj) &amp;&amp;</span>
169          !is_open_archive();
170 }
171 
172 inline size_t HeapRegion::block_size(const HeapWord *addr) const {
173   if (addr == top()) {
174     return pointer_delta(end(), addr);
175   }
176 
177   if (block_is_obj(addr)) {
178     return oop(addr)-&gt;size();
179   }
180 
181   return block_size_using_bitmap(addr, G1CollectedHeap::heap()-&gt;concurrent_mark()-&gt;prev_mark_bitmap());
182 }
183 
184 inline void HeapRegion::complete_compaction() {
185   // Reset space and bot after compaction is complete if needed.
186   reset_after_compaction();
<a name="18" id="anc18"></a><span class="line-modified">187   if (is_empty()) {</span>
188     reset_bot();
189   }
190 
191   // After a compaction the mark bitmap is invalid, so we must
192   // treat all objects as being inside the unmarked area.
193   zero_marked_bytes();
194   init_top_at_mark_start();
195 
196   // Clear unused heap memory in debug builds.
197   if (ZapUnusedHeapArea) {
198     mangle_unused_area();
199   }
200 }
201 
202 template&lt;typename ApplyToMarkedClosure&gt;
203 inline void HeapRegion::apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure) {
<a name="19" id="anc19"></a><span class="line-modified">204   HeapWord* limit = top();</span>
205   HeapWord* next_addr = bottom();
206 
207   while (next_addr &lt; limit) {
208     Prefetch::write(next_addr, PrefetchScanIntervalInBytes);
209     // This explicit is_marked check is a way to avoid
210     // some extra work done by get_next_marked_addr for
211     // the case where next_addr is marked.
212     if (bitmap-&gt;is_marked(next_addr)) {
213       oop current = oop(next_addr);
214       next_addr += closure-&gt;apply(current);
215     } else {
216       next_addr = bitmap-&gt;get_next_marked_addr(next_addr, limit);
217     }
218   }
219 
220   assert(next_addr == limit, &quot;Should stop the scan at the limit.&quot;);
221 }
222 
223 inline HeapWord* HeapRegion::par_allocate_no_bot_updates(size_t min_word_size,
224                                                          size_t desired_word_size,
225                                                          size_t* actual_word_size) {
226   assert(is_young(), &quot;we can only skip BOT updates on young regions&quot;);
227   return par_allocate_impl(min_word_size, desired_word_size, actual_word_size);
228 }
229 
230 inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t word_size) {
231   size_t temp;
232   return allocate_no_bot_updates(word_size, word_size, &amp;temp);
233 }
234 
235 inline HeapWord* HeapRegion::allocate_no_bot_updates(size_t min_word_size,
236                                                      size_t desired_word_size,
237                                                      size_t* actual_word_size) {
238   assert(is_young(), &quot;we can only skip BOT updates on young regions&quot;);
239   return allocate_impl(min_word_size, desired_word_size, actual_word_size);
240 }
241 
242 inline void HeapRegion::note_start_of_marking() {
243   _next_marked_bytes = 0;
244   _next_top_at_mark_start = top();
245 }
246 
247 inline void HeapRegion::note_end_of_marking() {
248   _prev_top_at_mark_start = _next_top_at_mark_start;
249   _next_top_at_mark_start = bottom();
250   _prev_marked_bytes = _next_marked_bytes;
251   _next_marked_bytes = 0;
252 }
253 
254 inline bool HeapRegion::in_collection_set() const {
255   return G1CollectedHeap::heap()-&gt;is_in_cset(this);
256 }
257 
258 template &lt;class Closure, bool is_gc_active&gt;
<a name="20" id="anc20"></a><span class="line-modified">259 HeapWord* HeapRegion::do_oops_on_memregion_in_humongous(MemRegion mr,</span>
<span class="line-modified">260                                                         Closure* cl,</span>
<span class="line-modified">261                                                         G1CollectedHeap* g1h) {</span>
262   assert(is_humongous(), &quot;precondition&quot;);
263   HeapRegion* sr = humongous_start_region();
264   oop obj = oop(sr-&gt;bottom());
265 
266   // If concurrent and klass_or_null is NULL, then space has been
267   // allocated but the object has not yet been published by setting
268   // the klass.  That can only happen if the card is stale.  However,
269   // we&#39;ve already set the card clean, so we must return failure,
270   // since the allocating thread could have performed a write to the
271   // card that might be missed otherwise.
272   if (!is_gc_active &amp;&amp; (obj-&gt;klass_or_null_acquire() == NULL)) {
<a name="21" id="anc21"></a><span class="line-modified">273     return NULL;</span>
274   }
275 
276   // We have a well-formed humongous object at the start of sr.
277   // Only filler objects follow a humongous object in the containing
278   // regions, and we can ignore those.  So only process the one
279   // humongous object.
<a name="22" id="anc22"></a><span class="line-modified">280   if (g1h-&gt;is_obj_dead(obj, sr)) {</span>
<span class="line-modified">281     // The object is dead. There can be no other object in this region, so return</span>
<span class="line-modified">282     // the end of that region.</span>
<span class="line-modified">283     return end();</span>
<span class="line-modified">284   }</span>
<span class="line-modified">285   if (obj-&gt;is_objArray() || (sr-&gt;bottom() &lt; mr.start())) {</span>
<span class="line-modified">286     // objArrays are always marked precisely, so limit processing</span>
<span class="line-modified">287     // with mr.  Non-objArrays might be precisely marked, and since</span>
<span class="line-modified">288     // it&#39;s humongous it&#39;s worthwhile avoiding full processing.</span>
<span class="line-modified">289     // However, the card could be stale and only cover filler</span>
<span class="line-modified">290     // objects.  That should be rare, so not worth checking for;</span>
<span class="line-modified">291     // instead let it fall out from the bounded iteration.</span>
<span class="line-modified">292     obj-&gt;oop_iterate(cl, mr);</span>
<span class="line-modified">293     return mr.end();</span>
<span class="line-modified">294   } else {</span>
<span class="line-added">295     // If obj is not an objArray and mr contains the start of the</span>
<span class="line-added">296     // obj, then this could be an imprecise mark, and we need to</span>
<span class="line-added">297     // process the entire object.</span>
<span class="line-added">298     int size = obj-&gt;oop_iterate_size(cl);</span>
<span class="line-added">299     // We have scanned to the end of the object, but since there can be no objects</span>
<span class="line-added">300     // after this humongous object in the region, we can return the end of the</span>
<span class="line-added">301     // region if it is greater.</span>
<span class="line-added">302     return MAX2(cast_from_oop&lt;HeapWord*&gt;(obj) + size, mr.end());</span>
303   }
<a name="23" id="anc23"></a>
304 }
305 
306 template &lt;bool is_gc_active, class Closure&gt;
<a name="24" id="anc24"></a><span class="line-modified">307 HeapWord* HeapRegion::oops_on_memregion_seq_iterate_careful(MemRegion mr,</span>
<span class="line-modified">308                                                             Closure* cl) {</span>
309   assert(MemRegion(bottom(), end()).contains(mr), &quot;Card region not in heap region&quot;);
310   G1CollectedHeap* g1h = G1CollectedHeap::heap();
311 
312   // Special handling for humongous regions.
313   if (is_humongous()) {
<a name="25" id="anc25"></a><span class="line-modified">314     return do_oops_on_memregion_in_humongous&lt;Closure, is_gc_active&gt;(mr, cl, g1h);</span>
315   }
316   assert(is_old() || is_archive(), &quot;Wrongly trying to iterate over region %u type %s&quot;, _hrm_index, get_type_str());
317 
318   // Because mr has been trimmed to what&#39;s been allocated in this
319   // region, the parts of the heap that are examined here are always
320   // parsable; there&#39;s no need to use klass_or_null to detect
321   // in-progress allocation.
322 
323   // Cache the boundaries of the memory region in some const locals
324   HeapWord* const start = mr.start();
325   HeapWord* const end = mr.end();
326 
327   // Find the obj that extends onto mr.start().
328   // Update BOT as needed while finding start of (possibly dead)
329   // object containing the start of the region.
330   HeapWord* cur = block_start(start);
331 
332 #ifdef ASSERT
333   {
334     assert(cur &lt;= start,
335            &quot;cur: &quot; PTR_FORMAT &quot;, start: &quot; PTR_FORMAT, p2i(cur), p2i(start));
336     HeapWord* next = cur + block_size(cur);
337     assert(start &lt; next,
338            &quot;start: &quot; PTR_FORMAT &quot;, next: &quot; PTR_FORMAT, p2i(start), p2i(next));
339   }
340 #endif
341 
342   const G1CMBitMap* const bitmap = g1h-&gt;concurrent_mark()-&gt;prev_mark_bitmap();
<a name="26" id="anc26"></a><span class="line-modified">343   while (true) {</span>
344     oop obj = oop(cur);
345     assert(oopDesc::is_oop(obj, true), &quot;Not an oop at &quot; PTR_FORMAT, p2i(cur));
346     assert(obj-&gt;klass_or_null() != NULL,
347            &quot;Unparsable heap at &quot; PTR_FORMAT, p2i(cur));
348 
349     size_t size;
350     bool is_dead = is_obj_dead_with_size(obj, bitmap, &amp;size);
<a name="27" id="anc27"></a><span class="line-added">351     bool is_precise = false;</span>
352 
353     cur += size;
354     if (!is_dead) {
355       // Process live object&#39;s references.
356 
357       // Non-objArrays are usually marked imprecise at the object
358       // start, in which case we need to iterate over them in full.
359       // objArrays are precisely marked, but can still be iterated
360       // over in full if completely covered.
<a name="28" id="anc28"></a><span class="line-modified">361       if (!obj-&gt;is_objArray() || (cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= start &amp;&amp; cur &lt;= end)) {</span>
362         obj-&gt;oop_iterate(cl);
363       } else {
364         obj-&gt;oop_iterate(cl, mr);
<a name="29" id="anc29"></a><span class="line-added">365         is_precise = true;</span>
366       }
367     }
<a name="30" id="anc30"></a><span class="line-modified">368     if (cur &gt;= end) {</span>
<span class="line-added">369       return is_precise ? end : cur;</span>
<span class="line-added">370     }</span>
<span class="line-added">371   }</span>
<span class="line-added">372 }</span>
<span class="line-added">373 </span>
<span class="line-added">374 inline int HeapRegion::age_in_surv_rate_group() const {</span>
<span class="line-added">375   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">376   assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">377   return _surv_rate_group-&gt;age_in_group(_age_index);</span>
<span class="line-added">378 }</span>
<span class="line-added">379 </span>
<span class="line-added">380 inline bool HeapRegion::has_valid_age_in_surv_rate() const {</span>
<span class="line-added">381   return G1SurvRateGroup::is_valid_age_index(_age_index);</span>
<span class="line-added">382 }</span>
<span class="line-added">383 </span>
<span class="line-added">384 inline bool HeapRegion::has_surv_rate_group() const {</span>
<span class="line-added">385   return _surv_rate_group != NULL;</span>
<span class="line-added">386 }</span>
<span class="line-added">387 </span>
<span class="line-added">388 inline double HeapRegion::surv_rate_prediction(G1Predictions const&amp; predictor) const {</span>
<span class="line-added">389   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">390   return _surv_rate_group-&gt;surv_rate_pred(predictor, age_in_surv_rate_group());</span>
<span class="line-added">391 }</span>
<span class="line-added">392 </span>
<span class="line-added">393 inline void HeapRegion::install_surv_rate_group(G1SurvRateGroup* surv_rate_group) {</span>
<span class="line-added">394   assert(surv_rate_group != NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">395   assert(!has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">396   assert(is_young(), &quot;pre-condition&quot;);</span>
<span class="line-added">397 </span>
<span class="line-added">398   _surv_rate_group = surv_rate_group;</span>
<span class="line-added">399   _age_index = surv_rate_group-&gt;next_age_index();</span>
<span class="line-added">400 }</span>
<span class="line-added">401 </span>
<span class="line-added">402 inline void HeapRegion::uninstall_surv_rate_group() {</span>
<span class="line-added">403   if (has_surv_rate_group()) {</span>
<span class="line-added">404     assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">405     assert(is_young(), &quot;pre-condition&quot;);</span>
<span class="line-added">406 </span>
<span class="line-added">407     _surv_rate_group = NULL;</span>
<span class="line-added">408     _age_index = G1SurvRateGroup::InvalidAgeIndex;</span>
<span class="line-added">409   } else {</span>
<span class="line-added">410     assert(!has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">411   }</span>
<span class="line-added">412 }</span>
413 
<a name="31" id="anc31"></a><span class="line-modified">414 inline void HeapRegion::record_surv_words_in_group(size_t words_survived) {</span>
<span class="line-added">415   assert(has_surv_rate_group(), &quot;pre-condition&quot;);</span>
<span class="line-added">416   assert(has_valid_age_in_surv_rate(), &quot;pre-condition&quot;);</span>
<span class="line-added">417   int age_in_group = age_in_surv_rate_group();</span>
<span class="line-added">418   _surv_rate_group-&gt;record_surviving_words(age_in_group, words_survived);</span>
419 }
420 
421 #endif // SHARE_GC_G1_HEAPREGION_INLINE_HPP
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
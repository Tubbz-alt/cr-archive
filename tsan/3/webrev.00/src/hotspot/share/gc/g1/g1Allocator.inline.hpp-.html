<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1Allocator.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 26 #define SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1Allocator.hpp&quot;
 29 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 30 #include &quot;gc/shared/plab.inline.hpp&quot;
 31 
 32 inline MutatorAllocRegion* G1Allocator::mutator_alloc_region() {
 33   return &amp;_mutator_alloc_region;
 34 }
 35 
 36 inline SurvivorGCAllocRegion* G1Allocator::survivor_gc_alloc_region() {
 37   return &amp;_survivor_gc_alloc_region;
 38 }
 39 
 40 inline OldGCAllocRegion* G1Allocator::old_gc_alloc_region() {
 41   return &amp;_old_gc_alloc_region;
 42 }
 43 
 44 inline HeapWord* G1Allocator::attempt_allocation(size_t min_word_size,
 45                                                  size_t desired_word_size,
 46                                                  size_t* actual_word_size) {
 47   HeapWord* result = mutator_alloc_region()-&gt;attempt_retained_allocation(min_word_size, desired_word_size, actual_word_size);
 48   if (result != NULL) {
 49     return result;
 50   }
 51   return mutator_alloc_region()-&gt;attempt_allocation(min_word_size, desired_word_size, actual_word_size);
 52 }
 53 
 54 inline HeapWord* G1Allocator::attempt_allocation_locked(size_t word_size) {
 55   HeapWord* result = mutator_alloc_region()-&gt;attempt_allocation_locked(word_size);
 56   assert(result != NULL || mutator_alloc_region()-&gt;get() == NULL,
 57          &quot;Must not have a mutator alloc region if there is no memory, but is &quot; PTR_FORMAT, p2i(mutator_alloc_region()-&gt;get()));
 58   return result;
 59 }
 60 
 61 inline HeapWord* G1Allocator::attempt_allocation_force(size_t word_size) {
 62   return mutator_alloc_region()-&gt;attempt_allocation_force(word_size);
 63 }
 64 
 65 inline PLAB* G1PLABAllocator::alloc_buffer(InCSetState dest) {
 66   assert(dest.is_valid(),
 67          &quot;Allocation buffer index out of bounds: &quot; CSETSTATE_FORMAT, dest.value());
 68   assert(_alloc_buffers[dest.value()] != NULL,
 69          &quot;Allocation buffer is NULL: &quot; CSETSTATE_FORMAT, dest.value());
 70   return _alloc_buffers[dest.value()];
 71 }
 72 
 73 inline HeapWord* G1PLABAllocator::plab_allocate(InCSetState dest,
 74                                                 size_t word_sz) {
 75   PLAB* buffer = alloc_buffer(dest);
 76   if (_survivor_alignment_bytes == 0 || !dest.is_young()) {
 77     return buffer-&gt;allocate(word_sz);
 78   } else {
 79     return buffer-&gt;allocate_aligned(word_sz, _survivor_alignment_bytes);
 80   }
 81 }
 82 
 83 inline HeapWord* G1PLABAllocator::allocate(InCSetState dest,
 84                                            size_t word_sz,
 85                                            bool* refill_failed) {
 86   HeapWord* const obj = plab_allocate(dest, word_sz);
 87   if (obj != NULL) {
 88     return obj;
 89   }
 90   return allocate_direct_or_new_plab(dest, word_sz, refill_failed);
 91 }
 92 
 93 // Create the maps which is used to identify archive objects.
 94 inline void G1ArchiveAllocator::enable_archive_object_check() {
 95   if (_archive_check_enabled) {
 96     return;
 97   }
 98 
 99   _archive_check_enabled = true;
100   size_t length = G1CollectedHeap::heap()-&gt;max_reserved_capacity();
101   _closed_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),
102                                         (HeapWord*)Universe::heap()-&gt;base() + length,
103                                         HeapRegion::GrainBytes);
104   _open_archive_region_map.initialize((HeapWord*)Universe::heap()-&gt;base(),
105                                       (HeapWord*)Universe::heap()-&gt;base() + length,
106                                       HeapRegion::GrainBytes);
107 }
108 
109 // Set the regions containing the specified address range as archive.
110 inline void G1ArchiveAllocator::set_range_archive(MemRegion range, bool open) {
111   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
112   log_info(gc, cds)(&quot;Mark %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
113                      open ? &quot;open&quot; : &quot;closed&quot;,
114                      p2i(range.start()),
115                      p2i(range.last()));
116   if (open) {
117     _open_archive_region_map.set_by_address(range, true);
118   } else {
119     _closed_archive_region_map.set_by_address(range, true);
120   }
121 }
122 
123 // Clear the archive regions map containing the specified address range.
124 inline void G1ArchiveAllocator::clear_range_archive(MemRegion range, bool open) {
125   assert(_archive_check_enabled, &quot;archive range check not enabled&quot;);
126   log_info(gc, cds)(&quot;Clear %s archive regions in map: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;]&quot;,
127                     open ? &quot;open&quot; : &quot;closed&quot;,
128                     p2i(range.start()),
129                     p2i(range.last()));
130   if (open) {
131     _open_archive_region_map.set_by_address(range, false);
132   } else {
133     _closed_archive_region_map.set_by_address(range, false);
134   }
135 }
136 
137 // Check if an object is in a closed archive region using the _archive_region_map.
138 inline bool G1ArchiveAllocator::in_closed_archive_range(oop object) {
139   // This is the out-of-line part of is_closed_archive_object test, done separately
140   // to avoid additional performance impact when the check is not enabled.
141   return _closed_archive_region_map.get_by_address((HeapWord*)object);
142 }
143 
144 inline bool G1ArchiveAllocator::in_open_archive_range(oop object) {
145   return _open_archive_region_map.get_by_address((HeapWord*)object);
146 }
147 
148 // Check if archive object checking is enabled, to avoid calling in_open/closed_archive_range
149 // unnecessarily.
150 inline bool G1ArchiveAllocator::archive_check_enabled() {
151   return _archive_check_enabled;
152 }
153 
154 inline bool G1ArchiveAllocator::is_closed_archive_object(oop object) {
155   return (archive_check_enabled() &amp;&amp; in_closed_archive_range(object));
156 }
157 
158 inline bool G1ArchiveAllocator::is_open_archive_object(oop object) {
159   return (archive_check_enabled() &amp;&amp; in_open_archive_range(object));
160 }
161 
162 inline bool G1ArchiveAllocator::is_archived_object(oop object) {
163   return (archive_check_enabled() &amp;&amp; (in_closed_archive_range(object) ||
164                                       in_open_archive_range(object)));
165 }
166 
167 #endif // SHARE_GC_G1_G1ALLOCATOR_INLINE_HPP
    </pre>
  </body>
</html>
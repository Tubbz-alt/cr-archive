<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1MonitoringSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1MMUTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1MonitoringSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1MonitoringSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
186   delete _eden_space_pool;
187   delete _survivor_space_pool;
188   delete _old_gen_pool;
189 }
190 
191 void G1MonitoringSupport::initialize_serviceability() {
192   _eden_space_pool = new G1EdenPool(_g1h, _eden_space_committed);
193   _survivor_space_pool = new G1SurvivorPool(_g1h, _survivor_space_committed);
194   _old_gen_pool = new G1OldGenPool(_g1h, _old_gen_committed, _g1h-&gt;max_capacity());
195 
196   _full_gc_memory_manager.add_pool(_eden_space_pool);
197   _full_gc_memory_manager.add_pool(_survivor_space_pool);
198   _full_gc_memory_manager.add_pool(_old_gen_pool);
199 
200   _incremental_memory_manager.add_pool(_eden_space_pool);
201   _incremental_memory_manager.add_pool(_survivor_space_pool);
202   _incremental_memory_manager.add_pool(_old_gen_pool, false /* always_affected_by_gc */);
203 }
204 
205 MemoryUsage G1MonitoringSupport::memory_usage() {
<span class="line-modified">206   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
207   return MemoryUsage(InitialHeapSize, _overall_used, _overall_committed, _g1h-&gt;max_capacity());
208 }
209 
210 GrowableArray&lt;GCMemoryManager*&gt; G1MonitoringSupport::memory_managers() {
211   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
212   memory_managers.append(&amp;_incremental_memory_manager);
213   memory_managers.append(&amp;_full_gc_memory_manager);
214   return memory_managers;
215 }
216 
217 GrowableArray&lt;MemoryPool*&gt; G1MonitoringSupport::memory_pools() {
218   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
219   memory_pools.append(_eden_space_pool);
220   memory_pools.append(_survivor_space_pool);
221   memory_pools.append(_old_gen_pool);
222   return memory_pools;
223 }
224 
225 void G1MonitoringSupport::recalculate_sizes() {
226   assert_heap_locked_or_at_safepoint(true);
227 
<span class="line-modified">228   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
229   // Recalculate all the sizes from scratch.
230 
<span class="line-modified">231   uint young_list_length = _g1h-&gt;young_regions_count();</span>









232   uint survivor_list_length = _g1h-&gt;survivor_regions_count();
<span class="line-removed">233   assert(young_list_length &gt;= survivor_list_length, &quot;invariant&quot;);</span>
<span class="line-removed">234   uint eden_list_length = young_list_length - survivor_list_length;</span>
235   // Max length includes any potential extensions to the young gen
236   // we&#39;ll do when the GC locker is active.
237   uint young_list_max_length = _g1h-&gt;policy()-&gt;young_list_max_length();
238   assert(young_list_max_length &gt;= survivor_list_length, &quot;invariant&quot;);
239   uint eden_list_max_length = young_list_max_length - survivor_list_length;
240 
<span class="line-removed">241   _overall_used = _g1h-&gt;used_unlocked();</span>
<span class="line-removed">242   _eden_space_used = (size_t) eden_list_length * HeapRegion::GrainBytes;</span>
<span class="line-removed">243   _survivor_space_used = (size_t) survivor_list_length * HeapRegion::GrainBytes;</span>
<span class="line-removed">244   _old_gen_used = subtract_up_to_zero(_overall_used, _eden_space_used + _survivor_space_used);</span>
<span class="line-removed">245 </span>
246   // First calculate the committed sizes that can be calculated independently.
<span class="line-modified">247   _survivor_space_committed = _survivor_space_used;</span>
248   _old_gen_committed = HeapRegion::align_up_to_region_byte_size(_old_gen_used);
249 
250   // Next, start with the overall committed size.
251   _overall_committed = _g1h-&gt;capacity();
252   size_t committed = _overall_committed;
253 
254   // Remove the committed size we have calculated so far (for the
255   // survivor and old space).
256   assert(committed &gt;= (_survivor_space_committed + _old_gen_committed), &quot;sanity&quot;);
257   committed -= _survivor_space_committed + _old_gen_committed;
258 
259   // Next, calculate and remove the committed size for the eden.
260   _eden_space_committed = (size_t) eden_list_max_length * HeapRegion::GrainBytes;
261   // Somewhat defensive: be robust in case there are inaccuracies in
262   // the calculations
263   _eden_space_committed = MIN2(_eden_space_committed, committed);
264   committed -= _eden_space_committed;
265 
266   // Finally, give the rest to the old space...
267   _old_gen_committed += committed;
268   // ..and calculate the young gen committed.
269   _young_gen_committed = _eden_space_committed + _survivor_space_committed;
270 
271   assert(_overall_committed ==
272          (_eden_space_committed + _survivor_space_committed + _old_gen_committed),
273          &quot;the committed sizes should add up&quot;);
274   // Somewhat defensive: cap the eden used size to make sure it
275   // never exceeds the committed size.
276   _eden_space_used = MIN2(_eden_space_used, _eden_space_committed);
<span class="line-modified">277   // _survivor_committed and _old_committed are calculated in terms of</span>
<span class="line-modified">278   // the corresponding _*_used value, so the next two conditions</span>
<span class="line-modified">279   // should hold.</span>
<span class="line-modified">280   assert(_survivor_space_used &lt;= _survivor_space_committed, &quot;post-condition&quot;);</span>
<span class="line-modified">281   assert(_old_gen_used &lt;= _old_gen_committed, &quot;post-condition&quot;);</span>




282 }
283 
284 void G1MonitoringSupport::update_sizes() {
285   recalculate_sizes();
286   if (UsePerfData) {
287     _eden_space_counters-&gt;update_capacity(pad_capacity(_eden_space_committed));
288     _eden_space_counters-&gt;update_used(_eden_space_used);
289    // only the &quot;to&quot; survivor space is active, so we don&#39;t need to
290     // update the counters for the &quot;from&quot; survivor space
291     _to_space_counters-&gt;update_capacity(pad_capacity(_survivor_space_committed));
292     _to_space_counters-&gt;update_used(_survivor_space_used);
293     _old_space_counters-&gt;update_capacity(pad_capacity(_old_gen_committed));
294     _old_space_counters-&gt;update_used(_old_gen_used);
295 
296     _young_gen_counters-&gt;update_all();
297     _old_gen_counters-&gt;update_all();
298 
299     MetaspaceCounters::update_performance_counters();
300     CompressedClassSpaceCounters::update_performance_counters();
301   }
302 }
303 
304 void G1MonitoringSupport::update_eden_size() {
305   // Recalculate everything - this should be fast enough and we are sure that we do not
306   // miss anything.
307   recalculate_sizes();
308   if (UsePerfData) {
309     _eden_space_counters-&gt;update_used(_eden_space_used);
310   }
311 }
312 
313 MemoryUsage G1MonitoringSupport::eden_space_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">314   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
315 
316   return MemoryUsage(initial_size,
317                      _eden_space_used,
318                      _eden_space_committed,
319                      max_size);
320 }
321 
322 MemoryUsage G1MonitoringSupport::survivor_space_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">323   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
324 
325   return MemoryUsage(initial_size,
326                      _survivor_space_used,
327                      _survivor_space_committed,
328                      max_size);
329 }
330 
331 MemoryUsage G1MonitoringSupport::old_gen_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">332   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
333 
334   return MemoryUsage(initial_size,
335                      _old_gen_used,
336                      _old_gen_committed,
337                      max_size);
338 }
339 
340 G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected) :
341   _tcs(full_gc ? g1mm-&gt;_full_collection_counters : g1mm-&gt;_incremental_collection_counters),
342   _tms(full_gc ? &amp;g1mm-&gt;_full_gc_memory_manager : &amp;g1mm-&gt;_incremental_memory_manager,
343        G1CollectedHeap::heap()-&gt;gc_cause(), all_memory_pools_affected) {
344 }
</pre>
</td>
<td>
<hr />
<pre>
186   delete _eden_space_pool;
187   delete _survivor_space_pool;
188   delete _old_gen_pool;
189 }
190 
191 void G1MonitoringSupport::initialize_serviceability() {
192   _eden_space_pool = new G1EdenPool(_g1h, _eden_space_committed);
193   _survivor_space_pool = new G1SurvivorPool(_g1h, _survivor_space_committed);
194   _old_gen_pool = new G1OldGenPool(_g1h, _old_gen_committed, _g1h-&gt;max_capacity());
195 
196   _full_gc_memory_manager.add_pool(_eden_space_pool);
197   _full_gc_memory_manager.add_pool(_survivor_space_pool);
198   _full_gc_memory_manager.add_pool(_old_gen_pool);
199 
200   _incremental_memory_manager.add_pool(_eden_space_pool);
201   _incremental_memory_manager.add_pool(_survivor_space_pool);
202   _incremental_memory_manager.add_pool(_old_gen_pool, false /* always_affected_by_gc */);
203 }
204 
205 MemoryUsage G1MonitoringSupport::memory_usage() {
<span class="line-modified">206   MutexLocker x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
207   return MemoryUsage(InitialHeapSize, _overall_used, _overall_committed, _g1h-&gt;max_capacity());
208 }
209 
210 GrowableArray&lt;GCMemoryManager*&gt; G1MonitoringSupport::memory_managers() {
211   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
212   memory_managers.append(&amp;_incremental_memory_manager);
213   memory_managers.append(&amp;_full_gc_memory_manager);
214   return memory_managers;
215 }
216 
217 GrowableArray&lt;MemoryPool*&gt; G1MonitoringSupport::memory_pools() {
218   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
219   memory_pools.append(_eden_space_pool);
220   memory_pools.append(_survivor_space_pool);
221   memory_pools.append(_old_gen_pool);
222   return memory_pools;
223 }
224 
225 void G1MonitoringSupport::recalculate_sizes() {
226   assert_heap_locked_or_at_safepoint(true);
227 
<span class="line-modified">228   MutexLocker x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
229   // Recalculate all the sizes from scratch.
230 
<span class="line-modified">231   // This never includes used bytes of current allocating heap region.</span>
<span class="line-added">232   _overall_used = _g1h-&gt;used_unlocked();</span>
<span class="line-added">233   _eden_space_used = _g1h-&gt;eden_regions_used_bytes();</span>
<span class="line-added">234   _survivor_space_used = _g1h-&gt;survivor_regions_used_bytes();</span>
<span class="line-added">235 </span>
<span class="line-added">236   // _overall_used and _eden_space_used are obtained concurrently so</span>
<span class="line-added">237   // may be inconsistent with each other. To prevent _old_gen_used going negative,</span>
<span class="line-added">238   // use smaller value to substract.</span>
<span class="line-added">239   _old_gen_used = _overall_used - MIN2(_overall_used, _eden_space_used + _survivor_space_used);</span>
<span class="line-added">240 </span>
241   uint survivor_list_length = _g1h-&gt;survivor_regions_count();


242   // Max length includes any potential extensions to the young gen
243   // we&#39;ll do when the GC locker is active.
244   uint young_list_max_length = _g1h-&gt;policy()-&gt;young_list_max_length();
245   assert(young_list_max_length &gt;= survivor_list_length, &quot;invariant&quot;);
246   uint eden_list_max_length = young_list_max_length - survivor_list_length;
247 





248   // First calculate the committed sizes that can be calculated independently.
<span class="line-modified">249   _survivor_space_committed = survivor_list_length * HeapRegion::GrainBytes;</span>
250   _old_gen_committed = HeapRegion::align_up_to_region_byte_size(_old_gen_used);
251 
252   // Next, start with the overall committed size.
253   _overall_committed = _g1h-&gt;capacity();
254   size_t committed = _overall_committed;
255 
256   // Remove the committed size we have calculated so far (for the
257   // survivor and old space).
258   assert(committed &gt;= (_survivor_space_committed + _old_gen_committed), &quot;sanity&quot;);
259   committed -= _survivor_space_committed + _old_gen_committed;
260 
261   // Next, calculate and remove the committed size for the eden.
262   _eden_space_committed = (size_t) eden_list_max_length * HeapRegion::GrainBytes;
263   // Somewhat defensive: be robust in case there are inaccuracies in
264   // the calculations
265   _eden_space_committed = MIN2(_eden_space_committed, committed);
266   committed -= _eden_space_committed;
267 
268   // Finally, give the rest to the old space...
269   _old_gen_committed += committed;
270   // ..and calculate the young gen committed.
271   _young_gen_committed = _eden_space_committed + _survivor_space_committed;
272 
273   assert(_overall_committed ==
274          (_eden_space_committed + _survivor_space_committed + _old_gen_committed),
275          &quot;the committed sizes should add up&quot;);
276   // Somewhat defensive: cap the eden used size to make sure it
277   // never exceeds the committed size.
278   _eden_space_used = MIN2(_eden_space_used, _eden_space_committed);
<span class="line-modified">279   // _survivor_space_used is calculated during a safepoint and _survivor_space_committed</span>
<span class="line-modified">280   // is calculated from survivor region count * heap region size.</span>
<span class="line-modified">281   assert(_survivor_space_used &lt;= _survivor_space_committed, &quot;Survivor used bytes(&quot; SIZE_FORMAT</span>
<span class="line-modified">282          &quot;) should be less than or equal to survivor committed(&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-modified">283          _survivor_space_used, _survivor_space_committed);</span>
<span class="line-added">284   // _old_gen_committed is calculated in terms of _old_gen_used value.</span>
<span class="line-added">285   assert(_old_gen_used &lt;= _old_gen_committed, &quot;Old gen used bytes(&quot; SIZE_FORMAT</span>
<span class="line-added">286          &quot;) should be less than or equal to old gen committed(&quot; SIZE_FORMAT &quot;)&quot;,</span>
<span class="line-added">287          _old_gen_used, _old_gen_committed);</span>
288 }
289 
290 void G1MonitoringSupport::update_sizes() {
291   recalculate_sizes();
292   if (UsePerfData) {
293     _eden_space_counters-&gt;update_capacity(pad_capacity(_eden_space_committed));
294     _eden_space_counters-&gt;update_used(_eden_space_used);
295    // only the &quot;to&quot; survivor space is active, so we don&#39;t need to
296     // update the counters for the &quot;from&quot; survivor space
297     _to_space_counters-&gt;update_capacity(pad_capacity(_survivor_space_committed));
298     _to_space_counters-&gt;update_used(_survivor_space_used);
299     _old_space_counters-&gt;update_capacity(pad_capacity(_old_gen_committed));
300     _old_space_counters-&gt;update_used(_old_gen_used);
301 
302     _young_gen_counters-&gt;update_all();
303     _old_gen_counters-&gt;update_all();
304 
305     MetaspaceCounters::update_performance_counters();
306     CompressedClassSpaceCounters::update_performance_counters();
307   }
308 }
309 
310 void G1MonitoringSupport::update_eden_size() {
311   // Recalculate everything - this should be fast enough and we are sure that we do not
312   // miss anything.
313   recalculate_sizes();
314   if (UsePerfData) {
315     _eden_space_counters-&gt;update_used(_eden_space_used);
316   }
317 }
318 
319 MemoryUsage G1MonitoringSupport::eden_space_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">320   MutexLocker x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
321 
322   return MemoryUsage(initial_size,
323                      _eden_space_used,
324                      _eden_space_committed,
325                      max_size);
326 }
327 
328 MemoryUsage G1MonitoringSupport::survivor_space_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">329   MutexLocker x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
330 
331   return MemoryUsage(initial_size,
332                      _survivor_space_used,
333                      _survivor_space_committed,
334                      max_size);
335 }
336 
337 MemoryUsage G1MonitoringSupport::old_gen_memory_usage(size_t initial_size, size_t max_size) {
<span class="line-modified">338   MutexLocker x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);</span>
339 
340   return MemoryUsage(initial_size,
341                      _old_gen_used,
342                      _old_gen_committed,
343                      max_size);
344 }
345 
346 G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected) :
347   _tcs(full_gc ? g1mm-&gt;_full_collection_counters : g1mm-&gt;_incremental_collection_counters),
348   _tms(full_gc ? &amp;g1mm-&gt;_full_gc_memory_manager : &amp;g1mm-&gt;_incremental_memory_manager,
349        G1CollectedHeap::heap()-&gt;gc_cause(), all_memory_pools_affected) {
350 }
</pre>
</td>
</tr>
</table>
<center><a href="g1MMUTracker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1MonitoringSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentMark.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkObjArrayProcessor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMark.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55   return _g1h-&gt;heap_region_containing(obj)-&gt;is_old_or_humongous_or_archive();
 56 }
 57 
 58 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, oop const obj) {
 59   HeapRegion* const hr = _g1h-&gt;heap_region_containing(obj);
 60   return mark_in_next_bitmap(worker_id, hr, obj);
 61 }
 62 
 63 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, HeapRegion* const hr, oop const obj) {
 64   assert(hr != NULL, &quot;just checking&quot;);
 65   assert(hr-&gt;is_in_reserved(obj), &quot;Attempting to mark object at &quot; PTR_FORMAT &quot; that is not contained in the given region %u&quot;, p2i(obj), hr-&gt;hrm_index());
 66 
 67   if (hr-&gt;obj_allocated_since_next_marking(obj)) {
 68     return false;
 69   }
 70 
 71   // Some callers may have stale objects to mark above nTAMS after humongous reclaim.
 72   // Can&#39;t assert that this is a valid object at this point, since it might be in the process of being copied by another thread.
 73   assert(!hr-&gt;is_continues_humongous(), &quot;Should not try to mark object &quot; PTR_FORMAT &quot; in Humongous continues region %u above nTAMS &quot; PTR_FORMAT, p2i(obj), hr-&gt;hrm_index(), p2i(hr-&gt;next_top_at_mark_start()));
 74 
<span class="line-modified"> 75   HeapWord* const obj_addr = (HeapWord*)obj;</span>
<span class="line-removed"> 76 </span>
<span class="line-removed"> 77   bool success = _next_mark_bitmap-&gt;par_mark(obj_addr);</span>
 78   if (success) {
 79     add_to_liveness(worker_id, obj, obj-&gt;size());
 80   }
 81   return success;
 82 }
 83 
 84 #ifndef PRODUCT
 85 template&lt;typename Fn&gt;
 86 inline void G1CMMarkStack::iterate(Fn fn) const {
 87   assert_at_safepoint_on_vm_thread();
 88 
 89   size_t num_chunks = 0;
 90 
 91   TaskQueueEntryChunk* cur = _chunk_list;
 92   while (cur != NULL) {
 93     guarantee(num_chunks &lt;= _chunks_in_chunk_list, &quot;Found &quot; SIZE_FORMAT &quot; oop chunks which is more than there should be&quot;, num_chunks);
 94 
 95     for (size_t i = 0; i &lt; EntriesPerChunk; ++i) {
 96       if (cur-&gt;data[i].is_null()) {
 97         break;
 98       }
 99       fn(cur-&gt;data[i]);
100     }
101     cur = cur-&gt;next;
102     num_chunks++;
103   }
104 }
105 #endif
106 
107 // It scans an object and visits its children.
108 inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry) { process_grey_task_entry&lt;true&gt;(task_entry); }
109 
110 inline void G1CMTask::push(G1TaskQueueEntry task_entry) {
111   assert(task_entry.is_array_slice() || _g1h-&gt;is_in_g1_reserved(task_entry.obj()), &quot;invariant&quot;);
112   assert(task_entry.is_array_slice() || !_g1h-&gt;is_on_master_free_list(
113               _g1h-&gt;heap_region_containing(task_entry.obj())), &quot;invariant&quot;);
114   assert(task_entry.is_array_slice() || !_g1h-&gt;is_obj_ill(task_entry.obj()), &quot;invariant&quot;);  // FIXME!!!
<span class="line-modified">115   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked((HeapWord*)task_entry.obj()), &quot;invariant&quot;);</span>
116 
117   if (!_task_queue-&gt;push(task_entry)) {
118     // The local task queue looks full. We need to push some entries
119     // to the global stack.
120     move_entries_to_global_stack();
121 
122     // this should succeed since, even if we overflow the global
123     // stack, we should have definitely removed some entries from the
124     // local queue. So, there must be space on it.
125     bool success = _task_queue-&gt;push(task_entry);
126     assert(success, &quot;invariant&quot;);
127   }
128 }
129 
130 inline bool G1CMTask::is_below_finger(oop obj, HeapWord* global_finger) const {
131   // If obj is above the global finger, then the mark bitmap scan
132   // will find it later, and no push is needed.  Similarly, if we have
133   // a current region and obj is between the local finger and the
134   // end of the current region, then no push is needed.  The tradeoff
135   // of checking both vs only checking the global finger is that the
136   // local check will be more accurate and so result in fewer pushes,
137   // but may also be a little slower.
<span class="line-modified">138   HeapWord* objAddr = (HeapWord*)obj;</span>
139   if (_finger != NULL) {
140     // We have a current region.
141 
142     // Finger and region values are all NULL or all non-NULL.  We
143     // use _finger to check since we immediately use its value.
144     assert(_curr_region != NULL, &quot;invariant&quot;);
145     assert(_region_limit != NULL, &quot;invariant&quot;);
146     assert(_region_limit &lt;= global_finger, &quot;invariant&quot;);
147 
148     // True if obj is less than the local finger, or is between
149     // the region limit and the global finger.
150     if (objAddr &lt; _finger) {
151       return true;
152     } else if (objAddr &lt; _region_limit) {
153       return false;
154     } // Else check global finger.
155   }
156   // Check global finger.
157   return objAddr &lt; global_finger;
158 }
159 
160 template&lt;bool scan&gt;
161 inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {
162   assert(scan || (task_entry.is_oop() &amp;&amp; task_entry.obj()-&gt;is_typeArray()), &quot;Skipping scan of grey non-typeArray&quot;);
<span class="line-modified">163   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked((HeapWord*)task_entry.obj()),</span>
164          &quot;Any stolen object should be a slice or marked&quot;);
165 
166   if (scan) {
167     if (task_entry.is_array_slice()) {
168       _words_scanned += _objArray_processor.process_slice(task_entry.slice());
169     } else {
170       oop obj = task_entry.obj();
171       if (G1CMObjArrayProcessor::should_be_sliced(obj)) {
172         _words_scanned += _objArray_processor.process_obj(obj);
173       } else {
174         _words_scanned += obj-&gt;oop_iterate_size(_cm_oop_closure);;
175       }
176     }
177   }
178   check_limits();
179 }
180 
181 inline size_t G1CMTask::scan_objArray(objArrayOop obj, MemRegion mr) {
182   obj-&gt;oop_iterate(_cm_oop_closure, mr);
183   return mr.word_size();
</pre>
<hr />
<pre>
186 inline HeapWord* G1ConcurrentMark::top_at_rebuild_start(uint region) const {
187   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
188   return _top_at_rebuild_starts[region];
189 }
190 
191 inline void G1ConcurrentMark::update_top_at_rebuild_start(HeapRegion* r) {
192   uint const region = r-&gt;hrm_index();
193   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
194   assert(_top_at_rebuild_starts[region] == NULL,
195          &quot;TARS for region %u has already been set to &quot; PTR_FORMAT &quot; should be NULL&quot;,
196          region, p2i(_top_at_rebuild_starts[region]));
197   G1RemSetTrackingPolicy* tracker = _g1h-&gt;policy()-&gt;remset_tracker();
198   if (tracker-&gt;needs_scan_for_rebuild(r)) {
199     _top_at_rebuild_starts[region] = r-&gt;top();
200   } else {
201     // Leave TARS at NULL.
202   }
203 }
204 
205 inline void G1CMTask::update_liveness(oop const obj, const size_t obj_size) {
<span class="line-modified">206   _mark_stats_cache.add_live_words(_g1h-&gt;addr_to_region((HeapWord*)obj), obj_size);</span>
207 }
208 
209 inline void G1ConcurrentMark::add_to_liveness(uint worker_id, oop const obj, size_t size) {
210   task(worker_id)-&gt;update_liveness(obj, size);
211 }
212 
213 inline void G1CMTask::abort_marking_if_regular_check_fail() {
214   if (!regular_clock_call()) {
215     set_has_aborted();
216   }
217 }
218 
219 inline bool G1CMTask::make_reference_grey(oop obj) {
220   if (!_cm-&gt;mark_in_next_bitmap(_worker_id, obj)) {
221     return false;
222   }
223 
224   // No OrderAccess:store_load() is needed. It is implicit in the
225   // CAS done in G1CMBitMap::parMark() call in the routine above.
226   HeapWord* global_finger = _cm-&gt;finger();
</pre>
<hr />
<pre>
253       // references, and the metadata is built-in.
254       process_grey_task_entry&lt;false&gt;(entry);
255     } else {
256       push(entry);
257     }
258   }
259   return true;
260 }
261 
262 template &lt;class T&gt;
263 inline bool G1CMTask::deal_with_reference(T* p) {
264   increment_refs_reached();
265   oop const obj = RawAccess&lt;MO_VOLATILE&gt;::oop_load(p);
266   if (obj == NULL) {
267     return false;
268   }
269   return make_reference_grey(obj);
270 }
271 
272 inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {
<span class="line-modified">273   assert(!_prev_mark_bitmap-&gt;is_marked((HeapWord*) p), &quot;sanity&quot;);</span>
<span class="line-modified">274  _prev_mark_bitmap-&gt;mark((HeapWord*) p);</span>
275 }
276 
277 bool G1ConcurrentMark::is_marked_in_prev_bitmap(oop p) const {
278   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">279   return _prev_mark_bitmap-&gt;is_marked((HeapWord*)p);</span>
280 }
281 
282 bool G1ConcurrentMark::is_marked_in_next_bitmap(oop p) const {
283   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">284   return _next_mark_bitmap-&gt;is_marked((HeapWord*)p);</span>
285 }
286 
287 inline bool G1ConcurrentMark::do_yield_check() {
288   if (SuspendibleThreadSet::should_yield()) {
289     SuspendibleThreadSet::yield();
290     return true;
291   } else {
292     return false;
293   }
294 }
295 
296 #endif // SHARE_GC_G1_G1CONCURRENTMARK_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 55   return _g1h-&gt;heap_region_containing(obj)-&gt;is_old_or_humongous_or_archive();
 56 }
 57 
 58 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, oop const obj) {
 59   HeapRegion* const hr = _g1h-&gt;heap_region_containing(obj);
 60   return mark_in_next_bitmap(worker_id, hr, obj);
 61 }
 62 
 63 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, HeapRegion* const hr, oop const obj) {
 64   assert(hr != NULL, &quot;just checking&quot;);
 65   assert(hr-&gt;is_in_reserved(obj), &quot;Attempting to mark object at &quot; PTR_FORMAT &quot; that is not contained in the given region %u&quot;, p2i(obj), hr-&gt;hrm_index());
 66 
 67   if (hr-&gt;obj_allocated_since_next_marking(obj)) {
 68     return false;
 69   }
 70 
 71   // Some callers may have stale objects to mark above nTAMS after humongous reclaim.
 72   // Can&#39;t assert that this is a valid object at this point, since it might be in the process of being copied by another thread.
 73   assert(!hr-&gt;is_continues_humongous(), &quot;Should not try to mark object &quot; PTR_FORMAT &quot; in Humongous continues region %u above nTAMS &quot; PTR_FORMAT, p2i(obj), hr-&gt;hrm_index(), p2i(hr-&gt;next_top_at_mark_start()));
 74 
<span class="line-modified"> 75   bool success = _next_mark_bitmap-&gt;par_mark(obj);</span>


 76   if (success) {
 77     add_to_liveness(worker_id, obj, obj-&gt;size());
 78   }
 79   return success;
 80 }
 81 
 82 #ifndef PRODUCT
 83 template&lt;typename Fn&gt;
 84 inline void G1CMMarkStack::iterate(Fn fn) const {
 85   assert_at_safepoint_on_vm_thread();
 86 
 87   size_t num_chunks = 0;
 88 
 89   TaskQueueEntryChunk* cur = _chunk_list;
 90   while (cur != NULL) {
 91     guarantee(num_chunks &lt;= _chunks_in_chunk_list, &quot;Found &quot; SIZE_FORMAT &quot; oop chunks which is more than there should be&quot;, num_chunks);
 92 
 93     for (size_t i = 0; i &lt; EntriesPerChunk; ++i) {
 94       if (cur-&gt;data[i].is_null()) {
 95         break;
 96       }
 97       fn(cur-&gt;data[i]);
 98     }
 99     cur = cur-&gt;next;
100     num_chunks++;
101   }
102 }
103 #endif
104 
105 // It scans an object and visits its children.
106 inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry) { process_grey_task_entry&lt;true&gt;(task_entry); }
107 
108 inline void G1CMTask::push(G1TaskQueueEntry task_entry) {
109   assert(task_entry.is_array_slice() || _g1h-&gt;is_in_g1_reserved(task_entry.obj()), &quot;invariant&quot;);
110   assert(task_entry.is_array_slice() || !_g1h-&gt;is_on_master_free_list(
111               _g1h-&gt;heap_region_containing(task_entry.obj())), &quot;invariant&quot;);
112   assert(task_entry.is_array_slice() || !_g1h-&gt;is_obj_ill(task_entry.obj()), &quot;invariant&quot;);  // FIXME!!!
<span class="line-modified">113   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())), &quot;invariant&quot;);</span>
114 
115   if (!_task_queue-&gt;push(task_entry)) {
116     // The local task queue looks full. We need to push some entries
117     // to the global stack.
118     move_entries_to_global_stack();
119 
120     // this should succeed since, even if we overflow the global
121     // stack, we should have definitely removed some entries from the
122     // local queue. So, there must be space on it.
123     bool success = _task_queue-&gt;push(task_entry);
124     assert(success, &quot;invariant&quot;);
125   }
126 }
127 
128 inline bool G1CMTask::is_below_finger(oop obj, HeapWord* global_finger) const {
129   // If obj is above the global finger, then the mark bitmap scan
130   // will find it later, and no push is needed.  Similarly, if we have
131   // a current region and obj is between the local finger and the
132   // end of the current region, then no push is needed.  The tradeoff
133   // of checking both vs only checking the global finger is that the
134   // local check will be more accurate and so result in fewer pushes,
135   // but may also be a little slower.
<span class="line-modified">136   HeapWord* objAddr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
137   if (_finger != NULL) {
138     // We have a current region.
139 
140     // Finger and region values are all NULL or all non-NULL.  We
141     // use _finger to check since we immediately use its value.
142     assert(_curr_region != NULL, &quot;invariant&quot;);
143     assert(_region_limit != NULL, &quot;invariant&quot;);
144     assert(_region_limit &lt;= global_finger, &quot;invariant&quot;);
145 
146     // True if obj is less than the local finger, or is between
147     // the region limit and the global finger.
148     if (objAddr &lt; _finger) {
149       return true;
150     } else if (objAddr &lt; _region_limit) {
151       return false;
152     } // Else check global finger.
153   }
154   // Check global finger.
155   return objAddr &lt; global_finger;
156 }
157 
158 template&lt;bool scan&gt;
159 inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {
160   assert(scan || (task_entry.is_oop() &amp;&amp; task_entry.obj()-&gt;is_typeArray()), &quot;Skipping scan of grey non-typeArray&quot;);
<span class="line-modified">161   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())),</span>
162          &quot;Any stolen object should be a slice or marked&quot;);
163 
164   if (scan) {
165     if (task_entry.is_array_slice()) {
166       _words_scanned += _objArray_processor.process_slice(task_entry.slice());
167     } else {
168       oop obj = task_entry.obj();
169       if (G1CMObjArrayProcessor::should_be_sliced(obj)) {
170         _words_scanned += _objArray_processor.process_obj(obj);
171       } else {
172         _words_scanned += obj-&gt;oop_iterate_size(_cm_oop_closure);;
173       }
174     }
175   }
176   check_limits();
177 }
178 
179 inline size_t G1CMTask::scan_objArray(objArrayOop obj, MemRegion mr) {
180   obj-&gt;oop_iterate(_cm_oop_closure, mr);
181   return mr.word_size();
</pre>
<hr />
<pre>
184 inline HeapWord* G1ConcurrentMark::top_at_rebuild_start(uint region) const {
185   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
186   return _top_at_rebuild_starts[region];
187 }
188 
189 inline void G1ConcurrentMark::update_top_at_rebuild_start(HeapRegion* r) {
190   uint const region = r-&gt;hrm_index();
191   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
192   assert(_top_at_rebuild_starts[region] == NULL,
193          &quot;TARS for region %u has already been set to &quot; PTR_FORMAT &quot; should be NULL&quot;,
194          region, p2i(_top_at_rebuild_starts[region]));
195   G1RemSetTrackingPolicy* tracker = _g1h-&gt;policy()-&gt;remset_tracker();
196   if (tracker-&gt;needs_scan_for_rebuild(r)) {
197     _top_at_rebuild_starts[region] = r-&gt;top();
198   } else {
199     // Leave TARS at NULL.
200   }
201 }
202 
203 inline void G1CMTask::update_liveness(oop const obj, const size_t obj_size) {
<span class="line-modified">204   _mark_stats_cache.add_live_words(_g1h-&gt;addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj)), obj_size);</span>
205 }
206 
207 inline void G1ConcurrentMark::add_to_liveness(uint worker_id, oop const obj, size_t size) {
208   task(worker_id)-&gt;update_liveness(obj, size);
209 }
210 
211 inline void G1CMTask::abort_marking_if_regular_check_fail() {
212   if (!regular_clock_call()) {
213     set_has_aborted();
214   }
215 }
216 
217 inline bool G1CMTask::make_reference_grey(oop obj) {
218   if (!_cm-&gt;mark_in_next_bitmap(_worker_id, obj)) {
219     return false;
220   }
221 
222   // No OrderAccess:store_load() is needed. It is implicit in the
223   // CAS done in G1CMBitMap::parMark() call in the routine above.
224   HeapWord* global_finger = _cm-&gt;finger();
</pre>
<hr />
<pre>
251       // references, and the metadata is built-in.
252       process_grey_task_entry&lt;false&gt;(entry);
253     } else {
254       push(entry);
255     }
256   }
257   return true;
258 }
259 
260 template &lt;class T&gt;
261 inline bool G1CMTask::deal_with_reference(T* p) {
262   increment_refs_reached();
263   oop const obj = RawAccess&lt;MO_VOLATILE&gt;::oop_load(p);
264   if (obj == NULL) {
265     return false;
266   }
267   return make_reference_grey(obj);
268 }
269 
270 inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {
<span class="line-modified">271   assert(!_prev_mark_bitmap-&gt;is_marked(p), &quot;sanity&quot;);</span>
<span class="line-modified">272  _prev_mark_bitmap-&gt;mark(p);</span>
273 }
274 
275 bool G1ConcurrentMark::is_marked_in_prev_bitmap(oop p) const {
276   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">277   return _prev_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));</span>
278 }
279 
280 bool G1ConcurrentMark::is_marked_in_next_bitmap(oop p) const {
281   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">282   return _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));</span>
283 }
284 
285 inline bool G1ConcurrentMark::do_yield_check() {
286   if (SuspendibleThreadSet::should_yield()) {
287     SuspendibleThreadSet::yield();
288     return true;
289   } else {
290     return false;
291   }
292 }
293 
294 #endif // SHARE_GC_G1_G1CONCURRENTMARK_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkObjArrayProcessor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
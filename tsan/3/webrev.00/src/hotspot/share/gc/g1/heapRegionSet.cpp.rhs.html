<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/heapRegionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 27 #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
 28 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 29 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 30 
 31 uint FreeRegionList::_unrealistically_long_length = 0;
 32 
 33 #ifndef PRODUCT
 34 void HeapRegionSetBase::verify_region(HeapRegion* hr) {
 35   assert(hr-&gt;containing_set() == this, &quot;Inconsistent containing set for %u&quot;, hr-&gt;hrm_index());
 36   assert(!hr-&gt;is_young(), &quot;Adding young region %u&quot;, hr-&gt;hrm_index()); // currently we don&#39;t use these sets for young regions
 37   assert(_checker == NULL || _checker-&gt;is_correct_type(hr), &quot;Wrong type of region %u (%s) and set %s&quot;,
 38          hr-&gt;hrm_index(), hr-&gt;get_type_str(), name());
 39   assert(!hr-&gt;is_free() || hr-&gt;is_empty(), &quot;Free region %u is not empty for set %s&quot;, hr-&gt;hrm_index(), name());
 40   assert(!hr-&gt;is_empty() || hr-&gt;is_free() || hr-&gt;is_archive(),
 41          &quot;Empty region %u is not free or archive for set %s&quot;, hr-&gt;hrm_index(), name());
 42 }
 43 #endif
 44 
 45 void HeapRegionSetBase::verify() {
 46   // It&#39;s important that we also observe the MT safety protocol even
 47   // for the verification calls. If we do verification without the
 48   // appropriate locks and the set changes underneath our feet
 49   // verification might fail and send us on a wild goose chase.
 50   check_mt_safety();
 51 
 52   guarantee_heap_region_set(( is_empty() &amp;&amp; length() == 0) ||
 53                             (!is_empty() &amp;&amp; length() &gt; 0),
 54                             &quot;invariant&quot;);
 55 }
 56 
 57 void HeapRegionSetBase::verify_start() {
 58   // See comment in verify() about MT safety and verification.
 59   check_mt_safety();
 60   assert_heap_region_set(!_verify_in_progress, &quot;verification should not be in progress&quot;);
 61 
 62   // Do the basic verification first before we do the checks over the regions.
 63   HeapRegionSetBase::verify();
 64 
 65   _verify_in_progress = true;
 66 }
 67 
 68 void HeapRegionSetBase::verify_end() {
 69   // See comment in verify() about MT safety and verification.
 70   check_mt_safety();
 71   assert_heap_region_set(_verify_in_progress, &quot;verification should be in progress&quot;);
 72 
 73   _verify_in_progress = false;
 74 }
 75 
 76 void HeapRegionSetBase::print_on(outputStream* out, bool print_contents) {
 77   out-&gt;cr();
 78   out-&gt;print_cr(&quot;Set: %s (&quot; PTR_FORMAT &quot;)&quot;, name(), p2i(this));
 79   out-&gt;print_cr(&quot;  Region Type         : %s&quot;, _checker-&gt;get_description());
 80   out-&gt;print_cr(&quot;  Length              : %14u&quot;, length());
 81 }
 82 
 83 HeapRegionSetBase::HeapRegionSetBase(const char* name, HeapRegionSetChecker* checker)
 84   : _checker(checker), _length(0), _name(name), _verify_in_progress(false)
 85 {
 86 }
 87 
 88 void FreeRegionList::set_unrealistically_long_length(uint len) {
 89   guarantee(_unrealistically_long_length == 0, &quot;should only be set once&quot;);
 90   _unrealistically_long_length = len;
 91 }
 92 
<a name="3" id="anc3"></a><span class="line-added"> 93 void FreeRegionList::abandon() {</span>
<span class="line-added"> 94   check_mt_safety();</span>
<span class="line-added"> 95   clear();</span>
<span class="line-added"> 96   verify_optional();</span>
<span class="line-added"> 97 }</span>
<span class="line-added"> 98 </span>
 99 void FreeRegionList::remove_all() {
100   check_mt_safety();
101   verify_optional();
102 
103   HeapRegion* curr = _head;
104   while (curr != NULL) {
105     verify_region(curr);
106 
107     HeapRegion* next = curr-&gt;next();
108     curr-&gt;set_next(NULL);
109     curr-&gt;set_prev(NULL);
110     curr-&gt;set_containing_set(NULL);
<a name="4" id="anc4"></a><span class="line-added">111 </span>
<span class="line-added">112     decrease_length(curr-&gt;node_index());</span>
<span class="line-added">113 </span>
114     curr = next;
115   }
116   clear();
117 
118   verify_optional();
119 }
120 
<a name="5" id="anc5"></a><span class="line-modified">121 void FreeRegionList::add_list_common_start(FreeRegionList* from_list) {</span>
122   check_mt_safety();
123   from_list-&gt;check_mt_safety();
<a name="6" id="anc6"></a>
124   verify_optional();
125   from_list-&gt;verify_optional();
126 
127   if (from_list-&gt;is_empty()) {
128     return;
129   }
130 
<a name="7" id="anc7"></a><span class="line-added">131   if (_node_info != NULL &amp;&amp; from_list-&gt;_node_info != NULL) {</span>
<span class="line-added">132     _node_info-&gt;add(from_list-&gt;_node_info);</span>
<span class="line-added">133   }</span>
<span class="line-added">134 </span>
135   #ifdef ASSERT
136   FreeRegionListIterator iter(from_list);
137   while (iter.more_available()) {
138     HeapRegion* hr = iter.get_next();
139     // In set_containing_set() we check that we either set the value
140     // from NULL to non-NULL or vice versa to catch bugs. So, we have
141     // to NULL it first before setting it to the value.
142     hr-&gt;set_containing_set(NULL);
143     hr-&gt;set_containing_set(this);
144   }
145   #endif // ASSERT
<a name="8" id="anc8"></a><span class="line-added">146 }</span>
<span class="line-added">147 </span>
<span class="line-added">148 void FreeRegionList::add_list_common_end(FreeRegionList* from_list) {</span>
<span class="line-added">149   _length += from_list-&gt;length();</span>
<span class="line-added">150   from_list-&gt;clear();</span>
<span class="line-added">151 </span>
<span class="line-added">152   verify_optional();</span>
<span class="line-added">153   from_list-&gt;verify_optional();</span>
<span class="line-added">154 }</span>
<span class="line-added">155 </span>
<span class="line-added">156 void FreeRegionList::append_ordered(FreeRegionList* from_list) {</span>
<span class="line-added">157   add_list_common_start(from_list);</span>
<span class="line-added">158 </span>
<span class="line-added">159   if (from_list-&gt;is_empty()) {</span>
<span class="line-added">160     return;</span>
<span class="line-added">161   }</span>
<span class="line-added">162 </span>
<span class="line-added">163   if (is_empty()) {</span>
<span class="line-added">164     // Make from_list the current list.</span>
<span class="line-added">165     assert_free_region_list(length() == 0 &amp;&amp; _tail == NULL, &quot;invariant&quot;);</span>
<span class="line-added">166     _head = from_list-&gt;_head;</span>
<span class="line-added">167     _tail = from_list-&gt;_tail;</span>
<span class="line-added">168   } else {</span>
<span class="line-added">169     // Add the from_list to the end of the current list.</span>
<span class="line-added">170     assert(_tail-&gt;hrm_index() &lt; from_list-&gt;_head-&gt;hrm_index(), &quot;Should be sorted %u &lt; %u&quot;,</span>
<span class="line-added">171            _tail-&gt;hrm_index(), from_list-&gt;_head-&gt;hrm_index());</span>
<span class="line-added">172 </span>
<span class="line-added">173     _tail-&gt;set_next(from_list-&gt;_head);</span>
<span class="line-added">174     from_list-&gt;_head-&gt;set_prev(_tail);</span>
<span class="line-added">175     _tail = from_list-&gt;_tail;</span>
<span class="line-added">176   }</span>
<span class="line-added">177 </span>
<span class="line-added">178   add_list_common_end(from_list);</span>
<span class="line-added">179 }</span>
<span class="line-added">180 </span>
<span class="line-added">181 void FreeRegionList::add_ordered(FreeRegionList* from_list) {</span>
<span class="line-added">182   add_list_common_start(from_list);</span>
<span class="line-added">183 </span>
<span class="line-added">184   if (from_list-&gt;is_empty()) {</span>
<span class="line-added">185     return;</span>
<span class="line-added">186   }</span>
187 
188   if (is_empty()) {
189     assert_free_region_list(length() == 0 &amp;&amp; _tail == NULL, &quot;invariant&quot;);
190     _head = from_list-&gt;_head;
191     _tail = from_list-&gt;_tail;
192   } else {
193     HeapRegion* curr_to = _head;
194     HeapRegion* curr_from = from_list-&gt;_head;
195 
196     while (curr_from != NULL) {
197       while (curr_to != NULL &amp;&amp; curr_to-&gt;hrm_index() &lt; curr_from-&gt;hrm_index()) {
198         curr_to = curr_to-&gt;next();
199       }
200 
201       if (curr_to == NULL) {
202         // The rest of the from list should be added as tail
203         _tail-&gt;set_next(curr_from);
204         curr_from-&gt;set_prev(_tail);
205         curr_from = NULL;
206       } else {
207         HeapRegion* next_from = curr_from-&gt;next();
208 
209         curr_from-&gt;set_next(curr_to);
210         curr_from-&gt;set_prev(curr_to-&gt;prev());
211         if (curr_to-&gt;prev() == NULL) {
212           _head = curr_from;
213         } else {
214           curr_to-&gt;prev()-&gt;set_next(curr_from);
215         }
216         curr_to-&gt;set_prev(curr_from);
217 
218         curr_from = next_from;
219       }
220     }
221 
222     if (_tail-&gt;hrm_index() &lt; from_list-&gt;_tail-&gt;hrm_index()) {
223       _tail = from_list-&gt;_tail;
224     }
225   }
226 
<a name="9" id="anc9"></a><span class="line-modified">227   add_list_common_end(from_list);</span>




228 }
229 
230 void FreeRegionList::remove_starting_at(HeapRegion* first, uint num_regions) {
231   check_mt_safety();
232   assert_free_region_list(num_regions &gt;= 1, &quot;pre-condition&quot;);
233   assert_free_region_list(!is_empty(), &quot;pre-condition&quot;);
234 
235   verify_optional();
236   DEBUG_ONLY(uint old_length = length();)
237 
238   HeapRegion* curr = first;
239   uint count = 0;
240   while (count &lt; num_regions) {
241     verify_region(curr);
242     HeapRegion* next = curr-&gt;next();
243     HeapRegion* prev = curr-&gt;prev();
244 
245     assert(count &lt; num_regions,
246            &quot;[%s] should not come across more regions &quot;
247            &quot;pending for removal than num_regions: %u&quot;,
248            name(), num_regions);
249 
250     if (prev == NULL) {
251       assert_free_region_list(_head == curr, &quot;invariant&quot;);
252       _head = next;
253     } else {
254       assert_free_region_list(_head != curr, &quot;invariant&quot;);
255       prev-&gt;set_next(next);
256     }
257     if (next == NULL) {
258       assert_free_region_list(_tail == curr, &quot;invariant&quot;);
259       _tail = prev;
260     } else {
261       assert_free_region_list(_tail != curr, &quot;invariant&quot;);
262       next-&gt;set_prev(prev);
263     }
264     if (_last == curr) {
265       _last = NULL;
266     }
267 
268     curr-&gt;set_next(NULL);
269     curr-&gt;set_prev(NULL);
270     remove(curr);
271 
272     count++;
<a name="10" id="anc10"></a><span class="line-added">273 </span>
<span class="line-added">274     decrease_length(curr-&gt;node_index());</span>
<span class="line-added">275 </span>
276     curr = next;
277   }
278 
279   assert(count == num_regions,
280          &quot;[%s] count: %u should be == num_regions: %u&quot;,
281          name(), count, num_regions);
282   assert(length() + num_regions == old_length,
283          &quot;[%s] new length should be consistent &quot;
284          &quot;new length: %u old length: %u num_regions: %u&quot;,
285          name(), length(), old_length, num_regions);
286 
287   verify_optional();
288 }
289 
290 uint FreeRegionList::num_of_regions_in_range(uint start, uint end) const {
291   HeapRegion* cur = _head;
292   uint num = 0;
293   while (cur != NULL) {
294     uint index = cur-&gt;hrm_index();
295     if (index &gt; end) {
296       break;
297     } else if (index &gt;= start) {
298       num++;
299     }
300     cur = cur-&gt;next();
301   }
302   return num;
303 }
304 
305 void FreeRegionList::verify() {
306   // See comment in HeapRegionSetBase::verify() about MT safety and
307   // verification.
308   check_mt_safety();
309 
310   // This will also do the basic verification too.
311   verify_start();
312 
313   verify_list();
314 
315   verify_end();
316 }
317 
318 void FreeRegionList::clear() {
319   _length = 0;
320   _head = NULL;
321   _tail = NULL;
322   _last = NULL;
<a name="11" id="anc11"></a><span class="line-added">323 </span>
<span class="line-added">324   if (_node_info!= NULL) {</span>
<span class="line-added">325     _node_info-&gt;clear();</span>
<span class="line-added">326   }</span>
327 }
328 
329 void FreeRegionList::verify_list() {
330   HeapRegion* curr = _head;
331   HeapRegion* prev1 = NULL;
332   HeapRegion* prev0 = NULL;
333   uint count = 0;
334   size_t capacity = 0;
335   uint last_index = 0;
336 
337   guarantee(_head == NULL || _head-&gt;prev() == NULL, &quot;_head should not have a prev&quot;);
338   while (curr != NULL) {
339     verify_region(curr);
340 
341     count++;
342     guarantee(count &lt; _unrealistically_long_length,
343               &quot;[%s] the calculated length: %u seems very long, is there maybe a cycle? curr: &quot; PTR_FORMAT &quot; prev0: &quot; PTR_FORMAT &quot; &quot; &quot;prev1: &quot; PTR_FORMAT &quot; length: %u&quot;,
344               name(), count, p2i(curr), p2i(prev0), p2i(prev1), length());
345 
346     if (curr-&gt;next() != NULL) {
347       guarantee(curr-&gt;next()-&gt;prev() == curr, &quot;Next or prev pointers messed up&quot;);
348     }
349     guarantee(curr-&gt;hrm_index() == 0 || curr-&gt;hrm_index() &gt; last_index, &quot;List should be sorted&quot;);
350     last_index = curr-&gt;hrm_index();
351 
352     capacity += curr-&gt;capacity();
353 
354     prev1 = prev0;
355     prev0 = curr;
356     curr = curr-&gt;next();
357   }
358 
359   guarantee(_tail == prev0, &quot;Expected %s to end with %u but it ended with %u.&quot;, name(), _tail-&gt;hrm_index(), prev0-&gt;hrm_index());
360   guarantee(_tail == NULL || _tail-&gt;next() == NULL, &quot;_tail should not have a next&quot;);
361   guarantee(length() == count, &quot;%s count mismatch. Expected %u, actual %u.&quot;, name(), length(), count);
362 }
<a name="12" id="anc12"></a><span class="line-added">363 </span>
<span class="line-added">364 </span>
<span class="line-added">365 FreeRegionList::FreeRegionList(const char* name, HeapRegionSetChecker* checker):</span>
<span class="line-added">366   HeapRegionSetBase(name, checker),</span>
<span class="line-added">367   _node_info(G1NUMA::numa()-&gt;is_enabled() ? new NodeInfo() : NULL) {</span>
<span class="line-added">368 </span>
<span class="line-added">369   clear();</span>
<span class="line-added">370 }</span>
<span class="line-added">371 </span>
<span class="line-added">372 FreeRegionList::~FreeRegionList() {</span>
<span class="line-added">373   if (_node_info != NULL) {</span>
<span class="line-added">374     delete _node_info;</span>
<span class="line-added">375   }</span>
<span class="line-added">376 }</span>
<span class="line-added">377 </span>
<span class="line-added">378 FreeRegionList::NodeInfo::NodeInfo() : _numa(G1NUMA::numa()), _length_of_node(NULL),</span>
<span class="line-added">379                                        _num_nodes(_numa-&gt;num_active_nodes()) {</span>
<span class="line-added">380   assert(UseNUMA, &quot;Invariant&quot;);</span>
<span class="line-added">381 </span>
<span class="line-added">382   _length_of_node = NEW_C_HEAP_ARRAY(uint, _num_nodes, mtGC);</span>
<span class="line-added">383 }</span>
<span class="line-added">384 </span>
<span class="line-added">385 FreeRegionList::NodeInfo::~NodeInfo() {</span>
<span class="line-added">386   FREE_C_HEAP_ARRAY(uint, _length_of_node);</span>
<span class="line-added">387 }</span>
<span class="line-added">388 </span>
<span class="line-added">389 void FreeRegionList::NodeInfo::clear() {</span>
<span class="line-added">390   for (uint i = 0; i &lt; _num_nodes; ++i) {</span>
<span class="line-added">391     _length_of_node[i] = 0;</span>
<span class="line-added">392   }</span>
<span class="line-added">393 }</span>
<span class="line-added">394 </span>
<span class="line-added">395 void FreeRegionList::NodeInfo::add(NodeInfo* info) {</span>
<span class="line-added">396   for (uint i = 0; i &lt; _num_nodes; ++i) {</span>
<span class="line-added">397     _length_of_node[i] += info-&gt;_length_of_node[i];</span>
<span class="line-added">398   }</span>
<span class="line-added">399 }</span>
<span class="line-added">400 </span>
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
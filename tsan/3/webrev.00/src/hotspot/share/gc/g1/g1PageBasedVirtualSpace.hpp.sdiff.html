<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1PageBasedVirtualSpace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75   bool _executable;
 76 
 77   // Helper function for committing memory. Commit the given memory range by using
 78   // _page_size pages as much as possible and the remainder with small sized pages.
 79   void commit_internal(size_t start_page, size_t end_page);
 80   // Commit num_pages pages of _page_size size starting from start. All argument
 81   // checking has been performed.
 82   void commit_preferred_pages(size_t start_page, size_t end_page);
 83   // Commit space at the high end of the space that needs to be committed with small
 84   // sized pages.
 85   void commit_tail();
 86 
 87   // Uncommit the given memory range.
 88   void uncommit_internal(size_t start_page, size_t end_page);
 89 
 90   // Pretouch the given memory range.
 91   void pretouch_internal(size_t start_page, size_t end_page);
 92 
 93   // Returns the index of the page which contains the given address.
 94   size_t  addr_to_page_index(char* addr) const;
<span class="line-removed"> 95   // Returns the address of the given page index.</span>
<span class="line-removed"> 96   char*  page_start(size_t index) const;</span>
 97 
 98   // Is the given page index the last page?
 99   bool is_last_page(size_t index) const { return index == (_committed.size() - 1); }
100   // Is the given page index the first after last page?
101   bool is_after_last_page(size_t index) const;
102   // Is the last page only partially covered by this space?
103   bool is_last_page_partial() const { return !is_aligned(_high_boundary, _page_size); }
104   // Returns the end address of the given page bounded by the reserved space.
105   char* bounded_end_addr(size_t end_page) const;
106 
107   // Returns true if the entire area is backed by committed memory.
108   bool is_area_committed(size_t start_page, size_t size_in_pages) const;
109   // Returns true if the entire area is not backed by committed memory.
110   bool is_area_uncommitted(size_t start_page, size_t size_in_pages) const;
111 
112   void initialize_with_page_size(ReservedSpace rs, size_t used_size, size_t page_size);
113  public:
114 
115   // Commit the given area of pages starting at start being size_in_pages large.
116   // Returns true if the given area is zero filled upon completion.
</pre>
<hr />
<pre>
130   ~G1PageBasedVirtualSpace();
131 
132   // Amount of reserved memory.
133   size_t reserved_size() const;
134   // Memory used in this virtual space.
135   size_t committed_size() const;
136   // Memory left to use/expand in this virtual space.
137   size_t uncommitted_size() const;
138 
139   void commit_and_set_special();
140 
141   bool contains(const void* p) const;
142 
143   MemRegion reserved() {
144     MemRegion x((HeapWord*)_low_boundary, reserved_size() / HeapWordSize);
145     return x;
146   }
147 
148   void check_for_contiguity() PRODUCT_RETURN;
149 




150   // Debugging
151   void print_on(outputStream* out) PRODUCT_RETURN;
152   void print();
153 };
154 
155 #endif // SHARE_GC_G1_G1PAGEBASEDVIRTUALSPACE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 75   bool _executable;
 76 
 77   // Helper function for committing memory. Commit the given memory range by using
 78   // _page_size pages as much as possible and the remainder with small sized pages.
 79   void commit_internal(size_t start_page, size_t end_page);
 80   // Commit num_pages pages of _page_size size starting from start. All argument
 81   // checking has been performed.
 82   void commit_preferred_pages(size_t start_page, size_t end_page);
 83   // Commit space at the high end of the space that needs to be committed with small
 84   // sized pages.
 85   void commit_tail();
 86 
 87   // Uncommit the given memory range.
 88   void uncommit_internal(size_t start_page, size_t end_page);
 89 
 90   // Pretouch the given memory range.
 91   void pretouch_internal(size_t start_page, size_t end_page);
 92 
 93   // Returns the index of the page which contains the given address.
 94   size_t  addr_to_page_index(char* addr) const;


 95 
 96   // Is the given page index the last page?
 97   bool is_last_page(size_t index) const { return index == (_committed.size() - 1); }
 98   // Is the given page index the first after last page?
 99   bool is_after_last_page(size_t index) const;
100   // Is the last page only partially covered by this space?
101   bool is_last_page_partial() const { return !is_aligned(_high_boundary, _page_size); }
102   // Returns the end address of the given page bounded by the reserved space.
103   char* bounded_end_addr(size_t end_page) const;
104 
105   // Returns true if the entire area is backed by committed memory.
106   bool is_area_committed(size_t start_page, size_t size_in_pages) const;
107   // Returns true if the entire area is not backed by committed memory.
108   bool is_area_uncommitted(size_t start_page, size_t size_in_pages) const;
109 
110   void initialize_with_page_size(ReservedSpace rs, size_t used_size, size_t page_size);
111  public:
112 
113   // Commit the given area of pages starting at start being size_in_pages large.
114   // Returns true if the given area is zero filled upon completion.
</pre>
<hr />
<pre>
128   ~G1PageBasedVirtualSpace();
129 
130   // Amount of reserved memory.
131   size_t reserved_size() const;
132   // Memory used in this virtual space.
133   size_t committed_size() const;
134   // Memory left to use/expand in this virtual space.
135   size_t uncommitted_size() const;
136 
137   void commit_and_set_special();
138 
139   bool contains(const void* p) const;
140 
141   MemRegion reserved() {
142     MemRegion x((HeapWord*)_low_boundary, reserved_size() / HeapWordSize);
143     return x;
144   }
145 
146   void check_for_contiguity() PRODUCT_RETURN;
147 
<span class="line-added">148   // Returns the address of the given page index.</span>
<span class="line-added">149   char*  page_start(size_t index) const;</span>
<span class="line-added">150   size_t page_size() const;</span>
<span class="line-added">151 </span>
152   // Debugging
153   void print_on(outputStream* out) PRODUCT_RETURN;
154   void print();
155 };
156 
157 #endif // SHARE_GC_G1_G1PAGEBASEDVIRTUALSPACE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1PageBasedVirtualSpace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
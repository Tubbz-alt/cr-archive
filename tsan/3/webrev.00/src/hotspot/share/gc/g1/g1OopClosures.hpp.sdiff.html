<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1OopClosures.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1OopClosures.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1OOPCLOSURES_HPP
 26 #define SHARE_GC_G1_G1OOPCLOSURES_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/g1/g1InCSetState.hpp&quot;</span>
 29 #include &quot;memory/iterator.hpp&quot;
<span class="line-modified"> 30 #include &quot;oops/markOop.hpp&quot;</span>
 31 
 32 class HeapRegion;
 33 class G1CollectedHeap;
 34 class G1RemSet;
 35 class G1ConcurrentMark;
 36 class DirtyCardToOopClosure;
 37 class G1CMBitMap;
 38 class G1ParScanThreadState;
 39 class G1ScanEvacuatedObjClosure;
 40 class G1CMTask;
 41 class ReferenceProcessor;
 42 
 43 class G1ScanClosureBase : public BasicOopIterateClosure {
 44 protected:
 45   G1CollectedHeap* _g1h;
 46   G1ParScanThreadState* _par_scan_state;
 47 
 48   G1ScanClosureBase(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state);
 49   ~G1ScanClosureBase() { }
 50 
 51   template &lt;class T&gt;
 52   inline void prefetch_and_push(T* p, oop const obj);
 53 
 54   template &lt;class T&gt;
<span class="line-modified"> 55   inline void handle_non_cset_obj_common(InCSetState const state, T* p, oop const obj);</span>
 56 public:
 57   virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
 58 
 59   inline void trim_queue_partially();
 60 };
 61 
<span class="line-modified"> 62 // Used during the Update RS phase to refine remaining cards in the DCQ during garbage collection.</span>
<span class="line-modified"> 63 class G1ScanObjsDuringUpdateRSClosure : public G1ScanClosureBase {</span>
 64 public:
<span class="line-modified"> 65   G1ScanObjsDuringUpdateRSClosure(G1CollectedHeap* g1h,</span>
<span class="line-modified"> 66                                   G1ParScanThreadState* pss) :</span>
 67     G1ScanClosureBase(g1h, pss) { }
 68 
 69   template &lt;class T&gt; void do_oop_work(T* p);
 70   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
 71   virtual void do_oop(oop* p)       { do_oop_work(p); }
 72 };
 73 
<span class="line-removed"> 74 // Used during the Scan RS phase to scan cards from the remembered set during garbage collection.</span>
<span class="line-removed"> 75 class G1ScanObjsDuringScanRSClosure : public G1ScanClosureBase {</span>
<span class="line-removed"> 76 public:</span>
<span class="line-removed"> 77   G1ScanObjsDuringScanRSClosure(G1CollectedHeap* g1h,</span>
<span class="line-removed"> 78                                 G1ParScanThreadState* par_scan_state):</span>
<span class="line-removed"> 79     G1ScanClosureBase(g1h, par_scan_state) { }</span>
<span class="line-removed"> 80 </span>
<span class="line-removed"> 81   template &lt;class T&gt; void do_oop_work(T* p);</span>
<span class="line-removed"> 82   virtual void do_oop(oop* p)          { do_oop_work(p); }</span>
<span class="line-removed"> 83   virtual void do_oop(narrowOop* p)    { do_oop_work(p); }</span>
<span class="line-removed"> 84 };</span>
<span class="line-removed"> 85 </span>
 86 // Used during Optional RS scanning to make sure we trim the queues in a timely manner.
 87 class G1ScanRSForOptionalClosure : public OopClosure {
<span class="line-modified"> 88   G1ScanObjsDuringScanRSClosure* _scan_cl;</span>

 89 public:
<span class="line-modified"> 90   G1ScanRSForOptionalClosure(G1ScanObjsDuringScanRSClosure* cl) : _scan_cl(cl) { }</span>
 91 
 92   template &lt;class T&gt; void do_oop_work(T* p);
 93   virtual void do_oop(oop* p)          { do_oop_work(p); }
 94   virtual void do_oop(narrowOop* p)    { do_oop_work(p); }
 95 };
 96 
 97 // This closure is applied to the fields of the objects that have just been copied during evacuation.
 98 class G1ScanEvacuatedObjClosure : public G1ScanClosureBase {
 99   friend class G1ScanInYoungSetter;
100 
101   enum ScanningInYoungValues {
102     False = 0,
103     True,
104     Uninitialized
105   };
106 
107   ScanningInYoungValues _scanning_in_young;
108 
109 public:
110   G1ScanEvacuatedObjClosure(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state) :
</pre>
<hr />
<pre>
146   ClassLoaderData* _scanned_cld;
147   G1ConcurrentMark* _cm;
148 
149   // Mark the object if it&#39;s not already marked. This is used to mark
150   // objects pointed to by roots that are guaranteed not to move
151   // during the GC (i.e., non-CSet objects). It is MT-safe.
152   inline void mark_object(oop obj);
153 
154   G1ParCopyHelper(G1CollectedHeap* g1h,  G1ParScanThreadState* par_scan_state);
155   ~G1ParCopyHelper() { }
156 
157  public:
158   void set_scanned_cld(ClassLoaderData* cld) { _scanned_cld = cld; }
159   inline void do_cld_barrier(oop new_obj);
160 
161   inline void trim_queue_partially();
162 };
163 
164 enum G1Barrier {
165   G1BarrierNone,
<span class="line-modified">166   G1BarrierCLD</span>

167 };
168 
169 enum G1Mark {
170   G1MarkNone,
171   G1MarkFromRoot,
172   G1MarkPromotedFromRoot
173 };
174 
175 template &lt;G1Barrier barrier, G1Mark do_mark_object&gt;
176 class G1ParCopyClosure : public G1ParCopyHelper {
177 public:
178   G1ParCopyClosure(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state) :
179       G1ParCopyHelper(g1h, par_scan_state) { }
180 
181   template &lt;class T&gt; void do_oop_work(T* p);
182   virtual void do_oop(oop* p)       { do_oop_work(p); }
183   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
184 };
185 
186 class G1CLDScanClosure : public CLDClosure {
187   G1ParCopyHelper* _closure;
188   bool             _process_only_dirty;
<span class="line-removed">189   int              _claim;</span>
190   int              _count;
191 public:
<span class="line-modified">192   G1CLDScanClosure(G1ParCopyHelper* closure,</span>
<span class="line-modified">193                    bool process_only_dirty, int claim_value)</span>
<span class="line-removed">194   : _closure(closure), _process_only_dirty(process_only_dirty), _claim(claim_value), _count(0) {}</span>
195   void do_cld(ClassLoaderData* cld);
196 };
197 
198 // Closure for iterating over object fields during concurrent marking
199 class G1CMOopClosure : public MetadataVisitingOopIterateClosure {
200   G1CollectedHeap*   _g1h;
201   G1CMTask*          _task;
202 public:
203   G1CMOopClosure(G1CollectedHeap* g1h,G1CMTask* task);
204   template &lt;class T&gt; void do_oop_work(T* p);
205   virtual void do_oop(      oop* p) { do_oop_work(p); }
206   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
207 };
208 
209 // Closure to scan the root regions during concurrent marking
210 class G1RootRegionScanClosure : public MetadataVisitingOopIterateClosure {
211 private:
212   G1CollectedHeap* _g1h;
213   G1ConcurrentMark* _cm;
214   uint _worker_id;
215 public:
216   G1RootRegionScanClosure(G1CollectedHeap* g1h, G1ConcurrentMark* cm, uint worker_id) :
217     _g1h(g1h), _cm(cm), _worker_id(worker_id) { }
218   template &lt;class T&gt; void do_oop_work(T* p);
219   virtual void do_oop(      oop* p) { do_oop_work(p); }
220   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
221 };
222 
223 class G1ConcurrentRefineOopClosure: public BasicOopIterateClosure {
224   G1CollectedHeap* _g1h;
<span class="line-modified">225   uint _worker_i;</span>
226 
227 public:
<span class="line-modified">228   G1ConcurrentRefineOopClosure(G1CollectedHeap* g1h, uint worker_i) :</span>
229     _g1h(g1h),
<span class="line-modified">230     _worker_i(worker_i) {</span>
231   }
232 
233   virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
234 
235   template &lt;class T&gt; void do_oop_work(T* p);
236   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
237   virtual void do_oop(oop* p)       { do_oop_work(p); }
238 };
239 
240 class G1RebuildRemSetClosure : public BasicOopIterateClosure {
241   G1CollectedHeap* _g1h;
242   uint _worker_id;
243 public:
244   G1RebuildRemSetClosure(G1CollectedHeap* g1h, uint worker_id) : _g1h(g1h), _worker_id(worker_id) {
245   }
246 
247   template &lt;class T&gt; void do_oop_work(T* p);
248   virtual void do_oop(oop* p)       { do_oop_work(p); }
249   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
250 
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1OOPCLOSURES_HPP
 26 #define SHARE_GC_G1_G1OOPCLOSURES_HPP
 27 
<span class="line-modified"> 28 #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;</span>
 29 #include &quot;memory/iterator.hpp&quot;
<span class="line-modified"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 
 32 class HeapRegion;
 33 class G1CollectedHeap;
 34 class G1RemSet;
 35 class G1ConcurrentMark;
 36 class DirtyCardToOopClosure;
 37 class G1CMBitMap;
 38 class G1ParScanThreadState;
 39 class G1ScanEvacuatedObjClosure;
 40 class G1CMTask;
 41 class ReferenceProcessor;
 42 
 43 class G1ScanClosureBase : public BasicOopIterateClosure {
 44 protected:
 45   G1CollectedHeap* _g1h;
 46   G1ParScanThreadState* _par_scan_state;
 47 
 48   G1ScanClosureBase(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state);
 49   ~G1ScanClosureBase() { }
 50 
 51   template &lt;class T&gt;
 52   inline void prefetch_and_push(T* p, oop const obj);
 53 
 54   template &lt;class T&gt;
<span class="line-modified"> 55   inline void handle_non_cset_obj_common(G1HeapRegionAttr const region_attr, T* p, oop const obj);</span>
 56 public:
 57   virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
 58 
 59   inline void trim_queue_partially();
 60 };
 61 
<span class="line-modified"> 62 // Used to scan cards from the DCQS or the remembered sets during garbage collection.</span>
<span class="line-modified"> 63 class G1ScanCardClosure : public G1ScanClosureBase {</span>
 64 public:
<span class="line-modified"> 65   G1ScanCardClosure(G1CollectedHeap* g1h,</span>
<span class="line-modified"> 66                     G1ParScanThreadState* pss) :</span>
 67     G1ScanClosureBase(g1h, pss) { }
 68 
 69   template &lt;class T&gt; void do_oop_work(T* p);
 70   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
 71   virtual void do_oop(oop* p)       { do_oop_work(p); }
 72 };
 73 












 74 // Used during Optional RS scanning to make sure we trim the queues in a timely manner.
 75 class G1ScanRSForOptionalClosure : public OopClosure {
<span class="line-modified"> 76   G1CollectedHeap* _g1h;</span>
<span class="line-added"> 77   G1ScanCardClosure* _scan_cl;</span>
 78 public:
<span class="line-modified"> 79   G1ScanRSForOptionalClosure(G1CollectedHeap* g1h, G1ScanCardClosure* cl) : _g1h(g1h), _scan_cl(cl) { }</span>
 80 
 81   template &lt;class T&gt; void do_oop_work(T* p);
 82   virtual void do_oop(oop* p)          { do_oop_work(p); }
 83   virtual void do_oop(narrowOop* p)    { do_oop_work(p); }
 84 };
 85 
 86 // This closure is applied to the fields of the objects that have just been copied during evacuation.
 87 class G1ScanEvacuatedObjClosure : public G1ScanClosureBase {
 88   friend class G1ScanInYoungSetter;
 89 
 90   enum ScanningInYoungValues {
 91     False = 0,
 92     True,
 93     Uninitialized
 94   };
 95 
 96   ScanningInYoungValues _scanning_in_young;
 97 
 98 public:
 99   G1ScanEvacuatedObjClosure(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state) :
</pre>
<hr />
<pre>
135   ClassLoaderData* _scanned_cld;
136   G1ConcurrentMark* _cm;
137 
138   // Mark the object if it&#39;s not already marked. This is used to mark
139   // objects pointed to by roots that are guaranteed not to move
140   // during the GC (i.e., non-CSet objects). It is MT-safe.
141   inline void mark_object(oop obj);
142 
143   G1ParCopyHelper(G1CollectedHeap* g1h,  G1ParScanThreadState* par_scan_state);
144   ~G1ParCopyHelper() { }
145 
146  public:
147   void set_scanned_cld(ClassLoaderData* cld) { _scanned_cld = cld; }
148   inline void do_cld_barrier(oop new_obj);
149 
150   inline void trim_queue_partially();
151 };
152 
153 enum G1Barrier {
154   G1BarrierNone,
<span class="line-modified">155   G1BarrierCLD,</span>
<span class="line-added">156   G1BarrierNoOptRoots  // Do not collect optional roots.</span>
157 };
158 
159 enum G1Mark {
160   G1MarkNone,
161   G1MarkFromRoot,
162   G1MarkPromotedFromRoot
163 };
164 
165 template &lt;G1Barrier barrier, G1Mark do_mark_object&gt;
166 class G1ParCopyClosure : public G1ParCopyHelper {
167 public:
168   G1ParCopyClosure(G1CollectedHeap* g1h, G1ParScanThreadState* par_scan_state) :
169       G1ParCopyHelper(g1h, par_scan_state) { }
170 
171   template &lt;class T&gt; void do_oop_work(T* p);
172   virtual void do_oop(oop* p)       { do_oop_work(p); }
173   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
174 };
175 
176 class G1CLDScanClosure : public CLDClosure {
177   G1ParCopyHelper* _closure;
178   bool             _process_only_dirty;

179   int              _count;
180 public:
<span class="line-modified">181   G1CLDScanClosure(G1ParCopyHelper* closure, bool process_only_dirty)</span>
<span class="line-modified">182   : _closure(closure), _process_only_dirty(process_only_dirty), _count(0) {}</span>

183   void do_cld(ClassLoaderData* cld);
184 };
185 
186 // Closure for iterating over object fields during concurrent marking
187 class G1CMOopClosure : public MetadataVisitingOopIterateClosure {
188   G1CollectedHeap*   _g1h;
189   G1CMTask*          _task;
190 public:
191   G1CMOopClosure(G1CollectedHeap* g1h,G1CMTask* task);
192   template &lt;class T&gt; void do_oop_work(T* p);
193   virtual void do_oop(      oop* p) { do_oop_work(p); }
194   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
195 };
196 
197 // Closure to scan the root regions during concurrent marking
198 class G1RootRegionScanClosure : public MetadataVisitingOopIterateClosure {
199 private:
200   G1CollectedHeap* _g1h;
201   G1ConcurrentMark* _cm;
202   uint _worker_id;
203 public:
204   G1RootRegionScanClosure(G1CollectedHeap* g1h, G1ConcurrentMark* cm, uint worker_id) :
205     _g1h(g1h), _cm(cm), _worker_id(worker_id) { }
206   template &lt;class T&gt; void do_oop_work(T* p);
207   virtual void do_oop(      oop* p) { do_oop_work(p); }
208   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
209 };
210 
211 class G1ConcurrentRefineOopClosure: public BasicOopIterateClosure {
212   G1CollectedHeap* _g1h;
<span class="line-modified">213   uint _worker_id;</span>
214 
215 public:
<span class="line-modified">216   G1ConcurrentRefineOopClosure(G1CollectedHeap* g1h, uint worker_id) :</span>
217     _g1h(g1h),
<span class="line-modified">218     _worker_id(worker_id) {</span>
219   }
220 
221   virtual ReferenceIterationMode reference_iteration_mode() { return DO_FIELDS; }
222 
223   template &lt;class T&gt; void do_oop_work(T* p);
224   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
225   virtual void do_oop(oop* p)       { do_oop_work(p); }
226 };
227 
228 class G1RebuildRemSetClosure : public BasicOopIterateClosure {
229   G1CollectedHeap* _g1h;
230   uint _worker_id;
231 public:
232   G1RebuildRemSetClosure(G1CollectedHeap* g1h, uint worker_id) : _g1h(g1h), _worker_id(worker_id) {
233   }
234 
235   template &lt;class T&gt; void do_oop_work(T* p);
236   virtual void do_oop(oop* p)       { do_oop_work(p); }
237   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
238 
</pre>
</td>
</tr>
</table>
<center><a href="g1OopClosures.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
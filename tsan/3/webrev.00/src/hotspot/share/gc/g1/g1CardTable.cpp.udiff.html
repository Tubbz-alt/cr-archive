<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1CardTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1BlockOffsetTable.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CardTable.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CardTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,34 +25,10 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CardTable.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/shared/memset_with_concurrent_readers.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool G1CardTable::mark_card_deferred(size_t card_index) {</span>
<span class="udiff-line-removed">-   CardValue val = _byte_map[card_index];</span>
<span class="udiff-line-removed">-   // It&#39;s already processed</span>
<span class="udiff-line-removed">-   if ((val &amp; (clean_card_mask_val() | deferred_card_val())) == deferred_card_val()) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Cached bit can be installed either on a clean card or on a claimed card.</span>
<span class="udiff-line-removed">-   CardValue new_val = val;</span>
<span class="udiff-line-removed">-   if (val == clean_card_val()) {</span>
<span class="udiff-line-removed">-     new_val = deferred_card_val();</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (val &amp; claimed_card_val()) {</span>
<span class="udiff-line-removed">-       new_val = val | deferred_card_val();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (new_val != val) {</span>
<span class="udiff-line-removed">-     Atomic::cmpxchg(new_val, &amp;_byte_map[card_index], val);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
  
  void G1CardTable::g1_mark_as_young(const MemRegion&amp; mr) {
    CardValue *const first = byte_for(mr.start());
    CardValue *const last = byte_after(mr.last());
  
</pre>
<center><a href="g1BlockOffsetTable.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CardTable.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
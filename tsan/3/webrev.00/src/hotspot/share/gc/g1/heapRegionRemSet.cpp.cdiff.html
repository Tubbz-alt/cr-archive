<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/heapRegionRemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionRemSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,12 ***</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/shared/space.inline.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
<span class="line-new-header">--- 25,12 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/heapRegionRemSet.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/g1/sparsePRT.inline.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/padded.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,199 ***</span>
  #include &quot;utilities/growableArray.hpp&quot;
  
  const char* HeapRegionRemSet::_state_strings[] =  {&quot;Untracked&quot;, &quot;Updating&quot;, &quot;Complete&quot;};
  const char* HeapRegionRemSet::_short_state_strings[] =  {&quot;UNTRA&quot;, &quot;UPDAT&quot;, &quot;CMPLT&quot;};
  
<span class="line-modified">! class PerRegionTable: public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-modified">!   friend class OtherRegionsTable;</span>
<span class="line-modified">!   friend class HeapRegionRemSetIterator;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   HeapRegion*     _hr;</span>
<span class="line-modified">!   CHeapBitMap     _bm;</span>
<span class="line-modified">!   jint            _occupied;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // next pointer for free/allocated &#39;all&#39; list</span>
<span class="line-modified">!   PerRegionTable* _next;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // prev pointer for the allocated &#39;all&#39; list</span>
<span class="line-removed">-   PerRegionTable* _prev;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // next pointer in collision list</span>
<span class="line-removed">-   PerRegionTable * _collision_list_next;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Global free list of PRTs</span>
<span class="line-removed">-   static PerRegionTable* volatile _free_list;</span>
<span class="line-removed">- </span>
<span class="line-removed">- protected:</span>
<span class="line-removed">-   // We need access in order to union things into the base table.</span>
<span class="line-removed">-   BitMap* bm() { return &amp;_bm; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PerRegionTable(HeapRegion* hr) :</span>
<span class="line-removed">-     _hr(hr),</span>
<span class="line-removed">-     _bm(HeapRegion::CardsPerRegion, mtGC),</span>
<span class="line-removed">-     _occupied(0),</span>
<span class="line-removed">-     _next(NULL), _prev(NULL),</span>
<span class="line-removed">-     _collision_list_next(NULL)</span>
<span class="line-removed">-   {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void add_card_work(CardIdx_t from_card, bool par) {</span>
<span class="line-removed">-     if (!_bm.at(from_card)) {</span>
<span class="line-removed">-       if (par) {</span>
<span class="line-removed">-         if (_bm.par_at_put(from_card, 1)) {</span>
<span class="line-removed">-           Atomic::inc(&amp;_occupied);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         _bm.at_put(from_card, 1);</span>
<span class="line-removed">-         _occupied++;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void add_reference_work(OopOrNarrowOopStar from, bool par) {</span>
<span class="line-removed">-     // Must make this robust in case &quot;from&quot; is not in &quot;_hr&quot;, because of</span>
<span class="line-removed">-     // concurrency.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     HeapRegion* loc_hr = hr();</span>
<span class="line-removed">-     // If the test below fails, then this table was reused concurrently</span>
<span class="line-removed">-     // with this operation.  This is OK, since the old table was coarsened,</span>
<span class="line-removed">-     // and adding a bit to the new table is never incorrect.</span>
<span class="line-removed">-     if (loc_hr-&gt;is_in_reserved(from)) {</span>
<span class="line-removed">-       CardIdx_t from_card = OtherRegionsTable::card_within_region(from, loc_hr);</span>
<span class="line-removed">-       add_card_work(from_card, par);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapRegion* hr() const { return OrderAccess::load_acquire(&amp;_hr); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   jint occupied() const {</span>
<span class="line-removed">-     // Overkill, but if we ever need it...</span>
<span class="line-removed">-     // guarantee(_occupied == _bm.count_one_bits(), &quot;Check&quot;);</span>
<span class="line-removed">-     return _occupied;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void init(HeapRegion* hr, bool clear_links_to_all_list) {</span>
<span class="line-removed">-     if (clear_links_to_all_list) {</span>
<span class="line-removed">-       set_next(NULL);</span>
<span class="line-removed">-       set_prev(NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     _collision_list_next = NULL;</span>
<span class="line-removed">-     _occupied = 0;</span>
<span class="line-removed">-     _bm.clear();</span>
<span class="line-removed">-     // Make sure that the bitmap clearing above has been finished before publishing</span>
<span class="line-removed">-     // this PRT to concurrent threads.</span>
<span class="line-removed">-     OrderAccess::release_store(&amp;_hr, hr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void add_reference(OopOrNarrowOopStar from) {</span>
<span class="line-removed">-     add_reference_work(from, /*parallel*/ true);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void seq_add_reference(OopOrNarrowOopStar from) {</span>
<span class="line-removed">-     add_reference_work(from, /*parallel*/ false);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void add_card(CardIdx_t from_card_index) {</span>
<span class="line-removed">-     add_card_work(from_card_index, /*parallel*/ true);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void seq_add_card(CardIdx_t from_card_index) {</span>
<span class="line-removed">-     add_card_work(from_card_index, /*parallel*/ false);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // (Destructively) union the bitmap of the current table into the given</span>
<span class="line-removed">-   // bitmap (which is assumed to be of the same size.)</span>
<span class="line-removed">-   void union_bitmap_into(BitMap* bm) {</span>
<span class="line-removed">-     bm-&gt;set_union(_bm);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Mem size in bytes.</span>
<span class="line-removed">-   size_t mem_size() const {</span>
<span class="line-removed">-     return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Requires &quot;from&quot; to be in &quot;hr()&quot;.</span>
<span class="line-removed">-   bool contains_reference(OopOrNarrowOopStar from) const {</span>
<span class="line-removed">-     assert(hr()-&gt;is_in_reserved(from), &quot;Precondition.&quot;);</span>
<span class="line-removed">-     size_t card_ind = pointer_delta(from, hr()-&gt;bottom(),</span>
<span class="line-removed">-                                     G1CardTable::card_size);</span>
<span class="line-removed">-     return _bm.at(card_ind);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Bulk-free the PRTs from prt to last, assumes that they are</span>
<span class="line-removed">-   // linked together using their _next field.</span>
<span class="line-removed">-   static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {</span>
<span class="line-removed">-     while (true) {</span>
<span class="line-removed">-       PerRegionTable* fl = _free_list;</span>
<span class="line-removed">-       last-&gt;set_next(fl);</span>
<span class="line-removed">-       PerRegionTable* res = Atomic::cmpxchg(prt, &amp;_free_list, fl);</span>
<span class="line-removed">-       if (res == fl) {</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ShouldNotReachHere();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static void free(PerRegionTable* prt) {</span>
<span class="line-removed">-     bulk_free(prt, prt);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Returns an initialized PerRegionTable instance.</span>
<span class="line-removed">-   static PerRegionTable* alloc(HeapRegion* hr) {</span>
<span class="line-removed">-     PerRegionTable* fl = _free_list;</span>
<span class="line-removed">-     while (fl != NULL) {</span>
<span class="line-removed">-       PerRegionTable* nxt = fl-&gt;next();</span>
<span class="line-removed">-       PerRegionTable* res = Atomic::cmpxchg(nxt, &amp;_free_list, fl);</span>
<span class="line-removed">-       if (res == fl) {</span>
<span class="line-removed">-         fl-&gt;init(hr, true);</span>
<span class="line-removed">-         return fl;</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         fl = _free_list;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(fl == NULL, &quot;Loop condition.&quot;);</span>
<span class="line-removed">-     return new PerRegionTable(hr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PerRegionTable* next() const { return _next; }</span>
<span class="line-removed">-   void set_next(PerRegionTable* next) { _next = next; }</span>
<span class="line-removed">-   PerRegionTable* prev() const { return _prev; }</span>
<span class="line-removed">-   void set_prev(PerRegionTable* prev) { _prev = prev; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Accessor and Modification routines for the pointer for the</span>
<span class="line-removed">-   // singly linked collision list that links the PRTs within the</span>
<span class="line-removed">-   // OtherRegionsTable::_fine_grain_regions hash table.</span>
<span class="line-removed">-   //</span>
<span class="line-removed">-   // It might be useful to also make the collision list doubly linked</span>
<span class="line-removed">-   // to avoid iteration over the collisions list during scrubbing/deletion.</span>
<span class="line-removed">-   // OTOH there might not be many collisions.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PerRegionTable* collision_list_next() const {</span>
<span class="line-removed">-     return _collision_list_next;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void set_collision_list_next(PerRegionTable* next) {</span>
<span class="line-removed">-     _collision_list_next = next;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   PerRegionTable** collision_list_next_addr() {</span>
<span class="line-removed">-     return &amp;_collision_list_next;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static size_t fl_mem_size() {</span>
<span class="line-removed">-     PerRegionTable* cur = _free_list;</span>
<span class="line-removed">-     size_t res = 0;</span>
<span class="line-removed">-     while (cur != NULL) {</span>
<span class="line-removed">-       res += cur-&gt;mem_size();</span>
<span class="line-removed">-       cur = cur-&gt;next();</span>
      }
<span class="line-removed">-     return res;</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   static void test_fl_mem_size();</span>
<span class="line-modified">! };</span>
  
  PerRegionTable* volatile PerRegionTable::_free_list = NULL;
  
  size_t OtherRegionsTable::_max_fine_entries = 0;
  size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;
<span class="line-new-header">--- 40,25 ---</span>
  #include &quot;utilities/growableArray.hpp&quot;
  
  const char* HeapRegionRemSet::_state_strings[] =  {&quot;Untracked&quot;, &quot;Updating&quot;, &quot;Complete&quot;};
  const char* HeapRegionRemSet::_short_state_strings[] =  {&quot;UNTRA&quot;, &quot;UPDAT&quot;, &quot;CMPLT&quot;};
  
<span class="line-modified">! PerRegionTable* PerRegionTable::alloc(HeapRegion* hr) {</span>
<span class="line-modified">!   PerRegionTable* fl = _free_list;</span>
<span class="line-modified">!   while (fl != NULL) {</span>
<span class="line-modified">!     PerRegionTable* nxt = fl-&gt;next();</span>
<span class="line-modified">!     PerRegionTable* res = Atomic::cmpxchg(&amp;_free_list, fl, nxt);</span>
<span class="line-modified">!     if (res == fl) {</span>
<span class="line-modified">!       fl-&gt;init(hr, true);</span>
<span class="line-modified">!       return fl;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       fl = _free_list;</span>
      }
    }
<span class="line-modified">!   assert(fl == NULL, &quot;Loop condition.&quot;);</span>
<span class="line-modified">!   return new PerRegionTable(hr);</span>
<span class="line-modified">! }</span>
  
  PerRegionTable* volatile PerRegionTable::_free_list = NULL;
  
  size_t OtherRegionsTable::_max_fine_entries = 0;
  size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,10 ***</span>
<span class="line-new-header">--- 66,11 ---</span>
  size_t OtherRegionsTable::_fine_eviction_sample_size = 0;
  
  OtherRegionsTable::OtherRegionsTable(Mutex* m) :
    _g1h(G1CollectedHeap::heap()),
    _m(m),
<span class="line-added">+   _num_occupied(0),</span>
    _coarse_map(G1CollectedHeap::heap()-&gt;max_regions(), mtGC),
    _n_coarse_entries(0),
    _fine_grain_regions(NULL),
    _n_fine_entries(0),
    _first_all_fine_prts(NULL),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,18 ***</span>
             &amp;&amp; _fine_eviction_stride == 0, &quot;All init at same time.&quot;);
      _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);
      _fine_eviction_stride = _max_fine_entries / _fine_eviction_sample_size;
    }
  
<span class="line-modified">!   _fine_grain_regions = NEW_C_HEAP_ARRAY3(PerRegionTablePtr, _max_fine_entries,</span>
<span class="line-removed">-                         mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (_fine_grain_regions == NULL) {</span>
<span class="line-removed">-     vm_exit_out_of_memory(sizeof(void*)*_max_fine_entries, OOM_MALLOC_ERROR,</span>
<span class="line-removed">-                           &quot;Failed to allocate _fine_grain_entries.&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    for (size_t i = 0; i &lt; _max_fine_entries; i++) {
      _fine_grain_regions[i] = NULL;
    }
  }
  
<span class="line-new-header">--- 90,11 ---</span>
             &amp;&amp; _fine_eviction_stride == 0, &quot;All init at same time.&quot;);
      _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);
      _fine_eviction_stride = _max_fine_entries / _fine_eviction_sample_size;
    }
  
<span class="line-modified">!   _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);</span>
    for (size_t i = 0; i &lt; _max_fine_entries; i++) {
      _fine_grain_regions[i] = NULL;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,28 ***</span>
    if (_coarse_map.at(from_hrm_ind)) {
      assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the Coarse table&quot;, p2i(from));
      return;
    }
  
    // Otherwise find a per-region table to add it to.
    size_t ind = from_hrm_ind &amp; _mod_max_fine_entries_mask;
    PerRegionTable* prt = find_region_table(ind, from_hr);
    if (prt == NULL) {
<span class="line-modified">!     MutexLockerEx x(_m, Mutex::_no_safepoint_check_flag);</span>
      // Confirm that it&#39;s really not there...
      prt = find_region_table(ind, from_hr);
      if (prt == NULL) {
  
        CardIdx_t card_index = card_within_region(from, from_hr);
  
<span class="line-modified">!       if (_sparse_table.add_card(from_hrm_ind, card_index)) {</span>
          assert(contains_reference_locked(from), &quot;We just added &quot; PTR_FORMAT &quot; to the Sparse table&quot;, p2i(from));
          return;
        }
  
        if (_n_fine_entries == _max_fine_entries) {
<span class="line-modified">!         prt = delete_region_table();</span>
          // There is no need to clear the links to the &#39;all&#39; list here:
          // prt will be reused immediately, i.e. remain in the &#39;all&#39; list.
          prt-&gt;init(from_hr, false /* clear_links_to_all_list */);
        } else {
          prt = PerRegionTable::alloc(from_hr);
<span class="line-new-header">--- 175,33 ---</span>
    if (_coarse_map.at(from_hrm_ind)) {
      assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the Coarse table&quot;, p2i(from));
      return;
    }
  
<span class="line-added">+   size_t num_added_by_coarsening = 0;</span>
    // Otherwise find a per-region table to add it to.
    size_t ind = from_hrm_ind &amp; _mod_max_fine_entries_mask;
    PerRegionTable* prt = find_region_table(ind, from_hr);
    if (prt == NULL) {
<span class="line-modified">!     MutexLocker x(_m, Mutex::_no_safepoint_check_flag);</span>
      // Confirm that it&#39;s really not there...
      prt = find_region_table(ind, from_hr);
      if (prt == NULL) {
  
        CardIdx_t card_index = card_within_region(from, from_hr);
  
<span class="line-modified">!       SparsePRT::AddCardResult result = _sparse_table.add_card(from_hrm_ind, card_index);</span>
<span class="line-added">+       if (result != SparsePRT::overflow) {</span>
<span class="line-added">+         if (result == SparsePRT::added) {</span>
<span class="line-added">+           Atomic::inc(&amp;_num_occupied, memory_order_relaxed);</span>
<span class="line-added">+         }</span>
          assert(contains_reference_locked(from), &quot;We just added &quot; PTR_FORMAT &quot; to the Sparse table&quot;, p2i(from));
          return;
        }
  
        if (_n_fine_entries == _max_fine_entries) {
<span class="line-modified">!         prt = delete_region_table(num_added_by_coarsening);</span>
          // There is no need to clear the links to the &#39;all&#39; list here:
          // prt will be reused immediately, i.e. remain in the &#39;all&#39; list.
          prt-&gt;init(from_hr, false /* clear_links_to_all_list */);
        } else {
          prt = PerRegionTable::alloc(from_hr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,14 ***</span>
        // parsing of the list, if any, may fail to see other entries),
        // the content of the prt must be visible (else for instance
        // some mark bits may not yet seem cleared or a &#39;later&#39; update
        // performed by a concurrent thread could be undone when the
        // zeroing becomes visible). This requires store ordering.
<span class="line-modified">!       OrderAccess::release_store(&amp;_fine_grain_regions[ind], prt);</span>
        _n_fine_entries++;
  
<span class="line-modified">!       // Transfer from sparse to fine-grain.</span>
        SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);
        assert(sprt_entry != NULL, &quot;There should have been an entry&quot;);
        for (int i = 0; i &lt; sprt_entry-&gt;num_valid_cards(); i++) {
          CardIdx_t c = sprt_entry-&gt;card(i);
          prt-&gt;add_card(c);
<span class="line-new-header">--- 216,15 ---</span>
        // parsing of the list, if any, may fail to see other entries),
        // the content of the prt must be visible (else for instance
        // some mark bits may not yet seem cleared or a &#39;later&#39; update
        // performed by a concurrent thread could be undone when the
        // zeroing becomes visible). This requires store ordering.
<span class="line-modified">!       Atomic::release_store(&amp;_fine_grain_regions[ind], prt);</span>
        _n_fine_entries++;
  
<span class="line-modified">!       // Transfer from sparse to fine-grain. The cards from the sparse table</span>
<span class="line-added">+       // were already added to the total in _num_occupied.</span>
        SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);
        assert(sprt_entry != NULL, &quot;There should have been an entry&quot;);
        for (int i = 0; i &lt; sprt_entry-&gt;num_valid_cards(); i++) {
          CardIdx_t c = sprt_entry-&gt;card(i);
          prt-&gt;add_card(c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,11 ***</span>
    // Note that we can&#39;t assert &quot;prt-&gt;hr() == from_hr&quot;, because of the
    // possibility of concurrent reuse.  But see head comment of
    // OtherRegionsTable for why this is OK.
    assert(prt != NULL, &quot;Inv&quot;);
  
<span class="line-modified">!   prt-&gt;add_reference(from);</span>
    assert(contains_reference(from), &quot;We just added &quot; PTR_FORMAT &quot; to the PRT (%d)&quot;, p2i(from), prt-&gt;contains_reference(from));
  }
  
  PerRegionTable*
  OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {
<span class="line-new-header">--- 238,15 ---</span>
    // Note that we can&#39;t assert &quot;prt-&gt;hr() == from_hr&quot;, because of the
    // possibility of concurrent reuse.  But see head comment of
    // OtherRegionsTable for why this is OK.
    assert(prt != NULL, &quot;Inv&quot;);
  
<span class="line-modified">!   bool added = prt-&gt;add_reference(from);</span>
<span class="line-added">+   if (prt-&gt;add_reference(from)) {</span>
<span class="line-added">+     num_added_by_coarsening++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Atomic::add(&amp;_num_occupied, num_added_by_coarsening, memory_order_relaxed);</span>
    assert(contains_reference(from), &quot;We just added &quot; PTR_FORMAT &quot; to the PRT (%d)&quot;, p2i(from), prt-&gt;contains_reference(from));
  }
  
  PerRegionTable*
  OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,11 ***</span>
    return prt;
  }
  
  jint OtherRegionsTable::_n_coarsenings = 0;
  
<span class="line-modified">! PerRegionTable* OtherRegionsTable::delete_region_table() {</span>
    assert(_m-&gt;owned_by_self(), &quot;Precondition&quot;);
    assert(_n_fine_entries == _max_fine_entries, &quot;Precondition&quot;);
    PerRegionTable* max = NULL;
    jint max_occ = 0;
    PerRegionTable** max_prev = NULL;
<span class="line-new-header">--- 259,11 ---</span>
    return prt;
  }
  
  jint OtherRegionsTable::_n_coarsenings = 0;
  
<span class="line-modified">! PerRegionTable* OtherRegionsTable::delete_region_table(size_t&amp; added_by_deleted) {</span>
    assert(_m-&gt;owned_by_self(), &quot;Precondition&quot;);
    assert(_n_fine_entries == _max_fine_entries, &quot;Precondition&quot;);
    PerRegionTable* max = NULL;
    jint max_occ = 0;
    PerRegionTable** max_prev = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,60 ***</span>
    if (!_coarse_map.at(max_hrm_index)) {
      _coarse_map.at_put(max_hrm_index, true);
      _n_coarse_entries++;
    }
  
    // Unsplice.
    *max_prev = max-&gt;collision_list_next();
    Atomic::inc(&amp;_n_coarsenings);
    _n_fine_entries--;
    return max;
  }
  
  bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {
<span class="line-modified">!   if (limit &lt;= (size_t)G1RSetSparseRegionEntries) {</span>
<span class="line-removed">-     return occ_coarse() == 0 &amp;&amp; _first_all_fine_prts == NULL &amp;&amp; occ_sparse() &lt;= limit;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // Current uses of this method may only use values less than G1RSetSparseRegionEntries</span>
<span class="line-removed">-     // for the limit. The solution, comparing against occupied() would be too slow</span>
<span class="line-removed">-     // at this time.</span>
<span class="line-removed">-     Unimplemented();</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
  }
  
  bool OtherRegionsTable::is_empty() const {
<span class="line-modified">!   return occ_sparse() == 0 &amp;&amp; occ_coarse() == 0 &amp;&amp; _first_all_fine_prts == NULL;</span>
  }
  
  size_t OtherRegionsTable::occupied() const {
<span class="line-modified">!   size_t sum = occ_fine();</span>
<span class="line-removed">-   sum += occ_sparse();</span>
<span class="line-removed">-   sum += occ_coarse();</span>
<span class="line-removed">-   return sum;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t OtherRegionsTable::occ_fine() const {</span>
<span class="line-removed">-   size_t sum = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   size_t num = 0;</span>
<span class="line-removed">-   PerRegionTable * cur = _first_all_fine_prts;</span>
<span class="line-removed">-   while (cur != NULL) {</span>
<span class="line-removed">-     sum += cur-&gt;occupied();</span>
<span class="line-removed">-     cur = cur-&gt;next();</span>
<span class="line-removed">-     num++;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   guarantee(num == _n_fine_entries, &quot;just checking&quot;);</span>
<span class="line-removed">-   return sum;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t OtherRegionsTable::occ_coarse() const {</span>
<span class="line-removed">-   return (_n_coarse_entries * HeapRegion::CardsPerRegion);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t OtherRegionsTable::occ_sparse() const {</span>
<span class="line-removed">-   return _sparse_table.occupied();</span>
  }
  
  size_t OtherRegionsTable::mem_size() const {
    size_t sum = 0;
    // all PRTs are of the same size so it is sufficient to query only one of them.
<span class="line-new-header">--- 309,28 ---</span>
    if (!_coarse_map.at(max_hrm_index)) {
      _coarse_map.at_put(max_hrm_index, true);
      _n_coarse_entries++;
    }
  
<span class="line-added">+   added_by_deleted = HeapRegion::CardsPerRegion - max_occ;</span>
    // Unsplice.
    *max_prev = max-&gt;collision_list_next();
    Atomic::inc(&amp;_n_coarsenings);
    _n_fine_entries--;
    return max;
  }
  
  bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {
<span class="line-modified">!   return occupied() &lt;= limit;</span>
  }
  
  bool OtherRegionsTable::is_empty() const {
<span class="line-modified">!   return occupied() == 0;</span>
  }
  
  size_t OtherRegionsTable::occupied() const {
<span class="line-modified">!   return _num_occupied;</span>
  }
  
  size_t OtherRegionsTable::mem_size() const {
    size_t sum = 0;
    // all PRTs are of the same size so it is sufficient to query only one of them.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,15 ***</span>
    if (_n_coarse_entries &gt; 0) {
      _coarse_map.clear();
    }
    _n_fine_entries = 0;
    _n_coarse_entries = 0;
  }
  
  bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {
    // Cast away const in this case.
<span class="line-modified">!   MutexLockerEx x((Mutex*)_m, Mutex::_no_safepoint_check_flag);</span>
    return contains_reference_locked(from);
  }
  
  bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {
    HeapRegion* hr = _g1h-&gt;heap_region_containing(from);
<span class="line-new-header">--- 369,17 ---</span>
    if (_n_coarse_entries &gt; 0) {
      _coarse_map.clear();
    }
    _n_fine_entries = 0;
    _n_coarse_entries = 0;
<span class="line-added">+ </span>
<span class="line-added">+   _num_occupied = 0;</span>
  }
  
  bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {
    // Cast away const in this case.
<span class="line-modified">!   MutexLocker x((Mutex*)_m, Mutex::_no_safepoint_check_flag);</span>
    return contains_reference_locked(from);
  }
  
  bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {
    HeapRegion* hr = _g1h-&gt;heap_region_containing(from);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,11 ***</span>
  
  HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,
                                     HeapRegion* hr)
    : _bot(bot),
      _code_roots(),
<span class="line-modified">!     _m(Mutex::leaf, FormatBuffer&lt;128&gt;(&quot;HeapRegionRemSet lock #%u&quot;, hr-&gt;hrm_index()), true, Monitor::_safepoint_check_never),</span>
      _other_regions(&amp;_m),
      _hr(hr),
      _state(Untracked)
  {
  }
<span class="line-new-header">--- 400,11 ---</span>
  
  HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,
                                     HeapRegion* hr)
    : _bot(bot),
      _code_roots(),
<span class="line-modified">!     _m(Mutex::leaf, FormatBuffer&lt;128&gt;(&quot;HeapRegionRemSet lock #%u&quot;, hr-&gt;hrm_index()), true, Mutex::_safepoint_check_never),</span>
      _other_regions(&amp;_m),
      _hr(hr),
      _state(Untracked)
  {
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,36 ***</span>
  void HeapRegionRemSet::clear_fcc() {
    G1FromCardCache::clear(_hr-&gt;hrm_index());
  }
  
  void HeapRegionRemSet::setup_remset_size() {
<span class="line-removed">-   // Setup sparse and fine-grain tables sizes.</span>
<span class="line-removed">-   // table_size = base * (log(region_size / 1M) + 1)</span>
    const int LOG_M = 20;
<span class="line-modified">!   int region_size_log_mb = MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);</span>
    if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {
<span class="line-modified">!     G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * (region_size_log_mb + 1);</span>
    }
    if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {
      G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);
    }
    guarantee(G1RSetSparseRegionEntries &gt; 0 &amp;&amp; G1RSetRegionEntries &gt; 0 , &quot;Sanity&quot;);
  }
  
  void HeapRegionRemSet::clear(bool only_cardset) {
<span class="line-modified">!   MutexLockerEx x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
    clear_locked(only_cardset);
  }
  
  void HeapRegionRemSet::clear_locked(bool only_cardset) {
    if (!only_cardset) {
      _code_roots.clear();
    }
    clear_fcc();
    _other_regions.clear();
    set_state_empty();
<span class="line-modified">!   assert(occupied_locked() == 0, &quot;Should be clear.&quot;);</span>
  }
  
  // Code roots support
  //
  // The code root set is protected by two separate locking schemes
<span class="line-new-header">--- 412,36 ---</span>
  void HeapRegionRemSet::clear_fcc() {
    G1FromCardCache::clear(_hr-&gt;hrm_index());
  }
  
  void HeapRegionRemSet::setup_remset_size() {
    const int LOG_M = 20;
<span class="line-modified">!   guarantee(HeapRegion::LogOfHRGrainBytes &gt;= LOG_M, &quot;Code assumes the region size &gt;= 1M, but is &quot; SIZE_FORMAT &quot;B&quot;, HeapRegion::GrainBytes);</span>
<span class="line-added">+ </span>
<span class="line-added">+   int region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;</span>
    if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {
<span class="line-modified">!     G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * ((size_t)1 &lt;&lt; (region_size_log_mb + 1));</span>
    }
    if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {
      G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);
    }
    guarantee(G1RSetSparseRegionEntries &gt; 0 &amp;&amp; G1RSetRegionEntries &gt; 0 , &quot;Sanity&quot;);
  }
  
  void HeapRegionRemSet::clear(bool only_cardset) {
<span class="line-modified">!   MutexLocker x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
    clear_locked(only_cardset);
  }
  
  void HeapRegionRemSet::clear_locked(bool only_cardset) {
    if (!only_cardset) {
      _code_roots.clear();
    }
    clear_fcc();
    _other_regions.clear();
    set_state_empty();
<span class="line-modified">!   assert(occupied() == 0, &quot;Should be clear.&quot;);</span>
  }
  
  // Code roots support
  //
  // The code root set is protected by two separate locking schemes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,11 ***</span>
    assert((!CodeCache_lock-&gt;owned_by_self() || SafepointSynchronize::is_at_safepoint()),
            &quot;should call add_strong_code_root_locked instead. CodeCache_lock-&gt;owned_by_self(): %s, is_at_safepoint(): %s&quot;,
            BOOL_TO_STR(CodeCache_lock-&gt;owned_by_self()), BOOL_TO_STR(SafepointSynchronize::is_at_safepoint()));
    // Optimistic unlocked contains-check
    if (!_code_roots.contains(nm)) {
<span class="line-modified">!     MutexLockerEx ml(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
      add_strong_code_root_locked(nm);
    }
  }
  
  void HeapRegionRemSet::add_strong_code_root_locked(nmethod* nm) {
<span class="line-new-header">--- 456,11 ---</span>
    assert((!CodeCache_lock-&gt;owned_by_self() || SafepointSynchronize::is_at_safepoint()),
            &quot;should call add_strong_code_root_locked instead. CodeCache_lock-&gt;owned_by_self(): %s, is_at_safepoint(): %s&quot;,
            BOOL_TO_STR(CodeCache_lock-&gt;owned_by_self()), BOOL_TO_STR(SafepointSynchronize::is_at_safepoint()));
    // Optimistic unlocked contains-check
    if (!_code_roots.contains(nm)) {
<span class="line-modified">!     MutexLocker ml(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
      add_strong_code_root_locked(nm);
    }
  }
  
  void HeapRegionRemSet::add_strong_code_root_locked(nmethod* nm) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,11 ***</span>
  
  void HeapRegionRemSet::remove_strong_code_root(nmethod* nm) {
    assert(nm != NULL, &quot;sanity&quot;);
    assert_locked_or_safepoint(CodeCache_lock);
  
<span class="line-modified">!   MutexLockerEx ml(CodeCache_lock-&gt;owned_by_self() ? NULL : &amp;_m, Mutex::_no_safepoint_check_flag);</span>
    _code_roots.remove(nm);
  
    // Check that there were no duplicates
    guarantee(!_code_roots.contains(nm), &quot;duplicate entry found&quot;);
  }
<span class="line-new-header">--- 476,11 ---</span>
  
  void HeapRegionRemSet::remove_strong_code_root(nmethod* nm) {
    assert(nm != NULL, &quot;sanity&quot;);
    assert_locked_or_safepoint(CodeCache_lock);
  
<span class="line-modified">!   MutexLocker ml(CodeCache_lock-&gt;owned_by_self() ? NULL : &amp;_m, Mutex::_no_safepoint_check_flag);</span>
    _code_roots.remove(nm);
  
    // Check that there were no duplicates
    guarantee(!_code_roots.contains(nm), &quot;duplicate entry found&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,177 ***</span>
  }
  
  size_t HeapRegionRemSet::strong_code_roots_mem_size() {
    return _code_roots.mem_size();
  }
<span class="line-removed">- </span>
<span class="line-removed">- HeapRegionRemSetIterator:: HeapRegionRemSetIterator(HeapRegionRemSet* hrrs) :</span>
<span class="line-removed">-   _hrrs(hrrs),</span>
<span class="line-removed">-   _coarse_map(&amp;hrrs-&gt;_other_regions._coarse_map),</span>
<span class="line-removed">-   _bot(hrrs-&gt;_bot),</span>
<span class="line-removed">-   _g1h(G1CollectedHeap::heap()),</span>
<span class="line-removed">-   _n_yielded_fine(0),</span>
<span class="line-removed">-   _n_yielded_coarse(0),</span>
<span class="line-removed">-   _n_yielded_sparse(0),</span>
<span class="line-removed">-   _is(Sparse),</span>
<span class="line-removed">-   _cur_region_card_offset(0),</span>
<span class="line-removed">-   // Set these values so that we increment to the first region.</span>
<span class="line-removed">-   _coarse_cur_region_index(-1),</span>
<span class="line-removed">-   _coarse_cur_region_cur_card(HeapRegion::CardsPerRegion-1),</span>
<span class="line-removed">-   _fine_cur_prt(NULL),</span>
<span class="line-removed">-   _cur_card_in_prt(HeapRegion::CardsPerRegion),</span>
<span class="line-removed">-   _sparse_iter(&amp;hrrs-&gt;_other_regions._sparse_table) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool HeapRegionRemSetIterator::coarse_has_next(size_t&amp; card_index) {</span>
<span class="line-removed">-   if (_hrrs-&gt;_other_regions._n_coarse_entries == 0) return false;</span>
<span class="line-removed">-   // Go to the next card.</span>
<span class="line-removed">-   _coarse_cur_region_cur_card++;</span>
<span class="line-removed">-   // Was the last the last card in the current region?</span>
<span class="line-removed">-   if (_coarse_cur_region_cur_card == HeapRegion::CardsPerRegion) {</span>
<span class="line-removed">-     // Yes: find the next region.  This may leave _coarse_cur_region_index</span>
<span class="line-removed">-     // Set to the last index, in which case there are no more coarse</span>
<span class="line-removed">-     // regions.</span>
<span class="line-removed">-     _coarse_cur_region_index =</span>
<span class="line-removed">-       (int) _coarse_map-&gt;get_next_one_offset(_coarse_cur_region_index + 1);</span>
<span class="line-removed">-     if ((size_t)_coarse_cur_region_index &lt; _coarse_map-&gt;size()) {</span>
<span class="line-removed">-       _coarse_cur_region_cur_card = 0;</span>
<span class="line-removed">-       HeapWord* r_bot =</span>
<span class="line-removed">-         _g1h-&gt;region_at((uint) _coarse_cur_region_index)-&gt;bottom();</span>
<span class="line-removed">-       _cur_region_card_offset = _bot-&gt;index_for_raw(r_bot);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // If we didn&#39;t return false above, then we can yield a card.</span>
<span class="line-removed">-   card_index = _cur_region_card_offset + _coarse_cur_region_cur_card;</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool HeapRegionRemSetIterator::fine_has_next(size_t&amp; card_index) {</span>
<span class="line-removed">-   if (fine_has_next()) {</span>
<span class="line-removed">-     _cur_card_in_prt =</span>
<span class="line-removed">-       _fine_cur_prt-&gt;_bm.get_next_one_offset(_cur_card_in_prt + 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (_cur_card_in_prt == HeapRegion::CardsPerRegion) {</span>
<span class="line-removed">-     // _fine_cur_prt may still be NULL in case if there are not PRTs at all for</span>
<span class="line-removed">-     // the remembered set.</span>
<span class="line-removed">-     if (_fine_cur_prt == NULL || _fine_cur_prt-&gt;next() == NULL) {</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     PerRegionTable* next_prt = _fine_cur_prt-&gt;next();</span>
<span class="line-removed">-     switch_to_prt(next_prt);</span>
<span class="line-removed">-     _cur_card_in_prt = _fine_cur_prt-&gt;_bm.get_next_one_offset(_cur_card_in_prt + 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   card_index = _cur_region_card_offset + _cur_card_in_prt;</span>
<span class="line-removed">-   guarantee(_cur_card_in_prt &lt; HeapRegion::CardsPerRegion,</span>
<span class="line-removed">-             &quot;Card index &quot; SIZE_FORMAT &quot; must be within the region&quot;, _cur_card_in_prt);</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool HeapRegionRemSetIterator::fine_has_next() {</span>
<span class="line-removed">-   return _cur_card_in_prt != HeapRegion::CardsPerRegion;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void HeapRegionRemSetIterator::switch_to_prt(PerRegionTable* prt) {</span>
<span class="line-removed">-   assert(prt != NULL, &quot;Cannot switch to NULL prt&quot;);</span>
<span class="line-removed">-   _fine_cur_prt = prt;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapWord* r_bot = _fine_cur_prt-&gt;hr()-&gt;bottom();</span>
<span class="line-removed">-   _cur_region_card_offset = _bot-&gt;index_for_raw(r_bot);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The bitmap scan for the PRT always scans from _cur_region_cur_card + 1.</span>
<span class="line-removed">-   // To avoid special-casing this start case, and not miss the first bitmap</span>
<span class="line-removed">-   // entry, initialize _cur_region_cur_card with -1 instead of 0.</span>
<span class="line-removed">-   _cur_card_in_prt = (size_t)-1;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool HeapRegionRemSetIterator::has_next(size_t&amp; card_index) {</span>
<span class="line-removed">-   switch (_is) {</span>
<span class="line-removed">-   case Sparse: {</span>
<span class="line-removed">-     if (_sparse_iter.has_next(card_index)) {</span>
<span class="line-removed">-       _n_yielded_sparse++;</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Otherwise, deliberate fall-through</span>
<span class="line-removed">-     _is = Fine;</span>
<span class="line-removed">-     PerRegionTable* initial_fine_prt = _hrrs-&gt;_other_regions._first_all_fine_prts;</span>
<span class="line-removed">-     if (initial_fine_prt != NULL) {</span>
<span class="line-removed">-       switch_to_prt(_hrrs-&gt;_other_regions._first_all_fine_prts);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   case Fine:</span>
<span class="line-removed">-     if (fine_has_next(card_index)) {</span>
<span class="line-removed">-       _n_yielded_fine++;</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Otherwise, deliberate fall-through</span>
<span class="line-removed">-     _is = Coarse;</span>
<span class="line-removed">-   case Coarse:</span>
<span class="line-removed">-     if (coarse_has_next(card_index)) {</span>
<span class="line-removed">-       _n_yielded_coarse++;</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // Otherwise...</span>
<span class="line-removed">-     break;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">- void HeapRegionRemSet::test() {</span>
<span class="line-removed">-   os::sleep(Thread::current(), (jlong)5000, false);</span>
<span class="line-removed">-   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Run with &quot;-XX:G1LogRSetRegionEntries=2&quot;, so that 1 and 5 end up in same</span>
<span class="line-removed">-   // hash bucket.</span>
<span class="line-removed">-   HeapRegion* hr0 = g1h-&gt;region_at(0);</span>
<span class="line-removed">-   HeapRegion* hr1 = g1h-&gt;region_at(1);</span>
<span class="line-removed">-   HeapRegion* hr2 = g1h-&gt;region_at(5);</span>
<span class="line-removed">-   HeapRegion* hr3 = g1h-&gt;region_at(6);</span>
<span class="line-removed">-   HeapRegion* hr4 = g1h-&gt;region_at(7);</span>
<span class="line-removed">-   HeapRegion* hr5 = g1h-&gt;region_at(8);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapWord* hr1_start = hr1-&gt;bottom();</span>
<span class="line-removed">-   HeapWord* hr1_mid = hr1_start + HeapRegion::GrainWords/2;</span>
<span class="line-removed">-   HeapWord* hr1_last = hr1-&gt;end() - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapWord* hr2_start = hr2-&gt;bottom();</span>
<span class="line-removed">-   HeapWord* hr2_mid = hr2_start + HeapRegion::GrainWords/2;</span>
<span class="line-removed">-   HeapWord* hr2_last = hr2-&gt;end() - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapWord* hr3_start = hr3-&gt;bottom();</span>
<span class="line-removed">-   HeapWord* hr3_mid = hr3_start + HeapRegion::GrainWords/2;</span>
<span class="line-removed">-   HeapWord* hr3_last = hr3-&gt;end() - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   HeapRegionRemSet* hrrs = hr0-&gt;rem_set();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make three references from region 0x101...</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr1_start);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr1_mid);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr1_last);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr2_start);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr2_mid);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr2_last);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr3_start);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr3_mid);</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr3_last);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Now cause a coarsening.</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr4-&gt;bottom());</span>
<span class="line-removed">-   hrrs-&gt;add_reference((OopOrNarrowOopStar)hr5-&gt;bottom());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Now, does iteration yield these three?</span>
<span class="line-removed">-   HeapRegionRemSetIterator iter(hrrs);</span>
<span class="line-removed">-   size_t sum = 0;</span>
<span class="line-removed">-   size_t card_index;</span>
<span class="line-removed">-   while (iter.has_next(card_index)) {</span>
<span class="line-removed">-     HeapWord* card_start = g1h-&gt;bot()-&gt;address_for_index(card_index);</span>
<span class="line-removed">-     tty-&gt;print_cr(&quot;  Card &quot; PTR_FORMAT &quot;.&quot;, p2i(card_start));</span>
<span class="line-removed">-     sum++;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   guarantee(sum == 11 - 3 + 2048, &quot;Failure&quot;);</span>
<span class="line-removed">-   guarantee(sum == hrrs-&gt;occupied(), &quot;Failure&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-new-header">--- 494,5 ---</span>
</pre>
<center><a href="heapRegionManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
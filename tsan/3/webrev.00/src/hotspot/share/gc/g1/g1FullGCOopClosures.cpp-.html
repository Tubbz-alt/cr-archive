<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1FullGCOopClosures.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #include &quot;precompiled.hpp&quot;
26 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
27 #include &quot;gc/g1/g1FullGCMarker.inline.hpp&quot;
28 #include &quot;gc/g1/g1FullGCOopClosures.inline.hpp&quot;
29 #include &quot;logging/logStream.hpp&quot;
30 #include &quot;memory/iterator.inline.hpp&quot;
31 #include &quot;oops/access.inline.hpp&quot;
32 #include &quot;oops/compressedOops.inline.hpp&quot;
33 #include &quot;oops/oop.inline.hpp&quot;
34 
35 void G1FollowStackClosure::do_void() { _marker-&gt;drain_stack(); }
36 
37 void G1FullKeepAliveClosure::do_oop(oop* p) { do_oop_work(p); }
38 void G1FullKeepAliveClosure::do_oop(narrowOop* p) { do_oop_work(p); }
39 
40 G1VerifyOopClosure::G1VerifyOopClosure(VerifyOption option) :
41    _g1h(G1CollectedHeap::heap()),
42    _failures(false),
43    _containing_obj(NULL),
44    _verify_option(option),
45    _cc(0) {
46 }
47 
48 void G1VerifyOopClosure::print_object(outputStream* out, oop obj) {
49 #ifdef PRODUCT
50   Klass* k = obj-&gt;klass();
51   const char* class_name = InstanceKlass::cast(k)-&gt;external_name();
52   out-&gt;print_cr(&quot;class name %s&quot;, class_name);
53 #else // PRODUCT
54   obj-&gt;print_on(out);
55 #endif // PRODUCT
56 }
57 
58 template &lt;class T&gt; void G1VerifyOopClosure::do_oop_work(T* p) {
59   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
60   if (!CompressedOops::is_null(heap_oop)) {
61     _cc++;
62     oop obj = CompressedOops::decode_not_null(heap_oop);
63     bool failed = false;
64     if (!_g1h-&gt;is_in_closed_subset(obj) || _g1h-&gt;is_obj_dead_cond(obj, _verify_option)) {
65       MutexLockerEx x(ParGCRareEvent_lock,
66           Mutex::_no_safepoint_check_flag);
67       LogStreamHandle(Error, gc, verify) yy;
68       if (!_failures) {
69         yy.cr();
70         yy.print_cr(&quot;----------&quot;);
71       }
72       if (!_g1h-&gt;is_in_closed_subset(obj)) {
73         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
74         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
75                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
76         print_object(&amp;yy, _containing_obj);
77         yy.print_cr(&quot;points to obj &quot; PTR_FORMAT &quot; not in the heap&quot;,
78                     p2i(obj));
79       } else {
80         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
81         HeapRegion* to   = _g1h-&gt;heap_region_containing((HeapWord*)obj);
82         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
83                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
84         print_object(&amp;yy, _containing_obj);
85         yy.print_cr(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
86                     p2i(obj), HR_FORMAT_PARAMS(to));
87         print_object(&amp;yy, obj);
88       }
89       yy.print_cr(&quot;----------&quot;);
90       yy.flush();
91       _failures = true;
92       failed = true;
93     }
94   }
95 }
96 
97 template void G1VerifyOopClosure::do_oop_work(oop*);
98 template void G1VerifyOopClosure::do_oop_work(narrowOop*);
    </pre>
  </body>
</html>
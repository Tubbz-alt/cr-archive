<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/heapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegion.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegion.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,43 +25,23 @@</span>
  #ifndef SHARE_GC_G1_HEAPREGION_HPP
  #define SHARE_GC_G1_HEAPREGION_HPP
  
  #include &quot;gc/g1/g1BlockOffsetTable.hpp&quot;
  #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1SurvRateGroup.hpp&quot;</span>
  #include &quot;gc/g1/heapRegionTracer.hpp&quot;
  #include &quot;gc/g1/heapRegionType.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/g1/survRateGroup.hpp&quot;</span>
  #include &quot;gc/shared/ageTable.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/cardTable.hpp&quot;</span>
  #include &quot;gc/shared/spaceDecorator.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/verifyOption.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/mutex.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  
<span class="udiff-line-removed">- // A HeapRegion is the smallest piece of a G1CollectedHeap that</span>
<span class="udiff-line-removed">- // can be collected independently.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // NOTE: Although a HeapRegion is a Space, its</span>
<span class="udiff-line-removed">- // Space::initDirtyCardClosure method must not be called.</span>
<span class="udiff-line-removed">- // The problem is that the existence of this method breaks</span>
<span class="udiff-line-removed">- // the independence of barrier sets from remembered sets.</span>
<span class="udiff-line-removed">- // The solution is to remove this method from the definition</span>
<span class="udiff-line-removed">- // of a Space.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Each heap region is self contained. top() and end() can never</span>
<span class="udiff-line-removed">- // be set beyond the end of the region. For humongous objects,</span>
<span class="udiff-line-removed">- // the first region is a StartsHumongous region. If the humongous</span>
<span class="udiff-line-removed">- // object is larger than a heap region, the following regions will</span>
<span class="udiff-line-removed">- // be of type ContinuesHumongous. In this case the top() of the</span>
<span class="udiff-line-removed">- // StartHumongous region and all ContinuesHumongous regions except</span>
<span class="udiff-line-removed">- // the last will point to their own end. The last ContinuesHumongous</span>
<span class="udiff-line-removed">- // region may have top() equal the end of object if there isn&#39;t</span>
<span class="udiff-line-removed">- // room for filler objects to pad out to the end of the region.</span>
<span class="udiff-line-removed">- </span>
  class G1CollectedHeap;
  class G1CMBitMap;
<span class="udiff-line-modified-removed">- class G1IsAliveAndApplyClosure;</span>
<span class="udiff-line-modified-added">+ class G1Predictions;</span>
  class HeapRegionRemSet;
<span class="udiff-line-removed">- class HeapRegionRemSetIterator;</span>
  class HeapRegion;
  class HeapRegionSetBase;
  class nmethod;
  
  #define HR_FORMAT &quot;%u:(%s)[&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;]&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -71,260 +51,263 @@</span>
                  p2i((_hr_)-&gt;bottom()), p2i((_hr_)-&gt;top()), p2i((_hr_)-&gt;end())
  
  // sentinel value for hrm_index
  #define G1_NO_HRM_INDEX ((uint) -1)
  
<span class="udiff-line-modified-removed">- // The complicating factor is that BlockOffsetTable diverged</span>
<span class="udiff-line-modified-removed">- // significantly, and we need functionality that is only in the G1 version.</span>
<span class="udiff-line-modified-removed">- // So I copied that code, which led to an alternate G1 version of</span>
<span class="udiff-line-modified-removed">- // OffsetTableContigSpace.  If the two versions of BlockOffsetTable could</span>
<span class="udiff-line-modified-removed">- // be reconciled, then G1OffsetTableContigSpace could go away.</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- // The idea behind time stamps is the following. We want to keep track of</span>
<span class="udiff-line-modified-removed">- // the highest address where it&#39;s safe to scan objects for each region.</span>
<span class="udiff-line-modified-removed">- // This is only relevant for current GC alloc regions so we keep a time stamp</span>
<span class="udiff-line-modified-removed">- // per region to determine if the region has been allocated during the current</span>
<span class="udiff-line-modified-removed">- // GC or not. If the time stamp is current we report a scan_top value which</span>
<span class="udiff-line-modified-removed">- // was saved at the end of the previous GC for retained alloc regions and which is</span>
<span class="udiff-line-modified-removed">- // equal to the bottom for all other regions.</span>
<span class="udiff-line-removed">- // There is a race between card scanners and allocating gc workers where we must ensure</span>
<span class="udiff-line-removed">- // that card scanners do not read the memory allocated by the gc workers.</span>
<span class="udiff-line-removed">- // In order to enforce that, we must not return a value of _top which is more recent than the</span>
<span class="udiff-line-removed">- // time stamp. This is due to the fact that a region may become a gc alloc region at</span>
<span class="udiff-line-removed">- // some point after we&#39;ve read the timestamp value as being &lt; the current time stamp.</span>
<span class="udiff-line-removed">- // The time stamps are re-initialized to zero at cleanup and at Full GCs.</span>
<span class="udiff-line-removed">- // The current scheme that uses sequential unsigned ints will fail only if we have 4b</span>
<span class="udiff-line-removed">- // evacuation pauses between two cleanups, which is _highly_ unlikely.</span>
<span class="udiff-line-removed">- class G1ContiguousSpace: public CompactibleSpace {</span>
<span class="udiff-line-modified-added">+ // A HeapRegion is the smallest piece of a G1CollectedHeap that</span>
<span class="udiff-line-modified-added">+ // can be collected independently.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // Each heap region is self contained. top() and end() can never</span>
<span class="udiff-line-modified-added">+ // be set beyond the end of the region. For humongous objects,</span>
<span class="udiff-line-modified-added">+ // the first region is a StartsHumongous region. If the humongous</span>
<span class="udiff-line-modified-added">+ // object is larger than a heap region, the following regions will</span>
<span class="udiff-line-modified-added">+ // be of type ContinuesHumongous. In this case the top() of the</span>
<span class="udiff-line-modified-added">+ // StartHumongous region and all ContinuesHumongous regions except</span>
<span class="udiff-line-modified-added">+ // the last will point to their own end. The last ContinuesHumongous</span>
<span class="udiff-line-modified-added">+ // region may have top() equal the end of object if there isn&#39;t</span>
<span class="udiff-line-modified-added">+ // room for filler objects to pad out to the end of the region.</span>
<span class="udiff-line-modified-added">+ class HeapRegion : public CHeapObj&lt;mtGC&gt; {</span>
    friend class VMStructs;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapWord* const _bottom;</span>
<span class="udiff-line-added">+   HeapWord* const _end;</span>
<span class="udiff-line-added">+ </span>
    HeapWord* volatile _top;
<span class="udiff-line-modified-removed">-  protected:</span>
<span class="udiff-line-modified-added">+   HeapWord* _compaction_top;</span>
<span class="udiff-line-added">+ </span>
    G1BlockOffsetTablePart _bot_part;
    Mutex _par_alloc_lock;
    // When we need to retire an allocation region, while other threads
    // are also concurrently trying to allocate into it, we typically
    // allocate a dummy object at the end of the region to ensure that
    // no more allocations can take place in it. However, sometimes we
    // want to know where the end of the last &quot;real&quot; object we allocated
    // into the region was and this is what this keeps track.
    HeapWord* _pre_dummy_top;
  
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   G1ContiguousSpace(G1BlockOffsetTable* bot);</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   HeapWord* bottom() const         { return _bottom; }</span>
<span class="udiff-line-added">+   HeapWord* end() const            { return _end;    }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_compaction_top(HeapWord* compaction_top) { _compaction_top = compaction_top; }</span>
<span class="udiff-line-added">+   HeapWord* compaction_top() const { return _compaction_top; }</span>
  
    void set_top(HeapWord* value) { _top = value; }
    HeapWord* top() const { return _top; }
  
<span class="udiff-line-modified-removed">-  protected:</span>
<span class="udiff-line-modified-removed">-   // Reset the G1ContiguousSpace.</span>
<span class="udiff-line-modified-removed">-   virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);</span>
<span class="udiff-line-modified-added">+   // See the comment above in the declaration of _pre_dummy_top for an</span>
<span class="udiff-line-modified-added">+   // explanation of what it is.</span>
<span class="udiff-line-modified-added">+   void set_pre_dummy_top(HeapWord* pre_dummy_top) {</span>
<span class="udiff-line-added">+     assert(is_in(pre_dummy_top) &amp;&amp; pre_dummy_top &lt;= top(), &quot;pre-condition&quot;);</span>
<span class="udiff-line-added">+     _pre_dummy_top = pre_dummy_top;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   HeapWord* pre_dummy_top() { return (_pre_dummy_top == NULL) ? top() : _pre_dummy_top; }</span>
<span class="udiff-line-added">+   void reset_pre_dummy_top() { _pre_dummy_top = NULL; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Returns true iff the given the heap  region contains the</span>
<span class="udiff-line-added">+   // given address as part of an allocated object. This may</span>
<span class="udiff-line-added">+   // be a potentially, so we restrict its use to assertion checks only.</span>
<span class="udiff-line-added">+   bool is_in(const void* p) const {</span>
<span class="udiff-line-added">+     return is_in_reserved(p);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   bool is_in(oop obj) const {</span>
<span class="udiff-line-added">+     return is_in((void*)obj);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Returns true iff the given reserved memory of the space contains the</span>
<span class="udiff-line-added">+   // given address.</span>
<span class="udiff-line-added">+   bool is_in_reserved(const void* p) const { return _bottom &lt;= p &amp;&amp; p &lt; _end; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t capacity()     const { return byte_size(bottom(), end()); }</span>
<span class="udiff-line-added">+   size_t used() const { return byte_size(bottom(), top()); }</span>
<span class="udiff-line-added">+   size_t free() const { return byte_size(top(), end()); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool is_empty() const { return used() == 0; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   void reset_after_compaction() { set_top(compaction_top()); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void clear(bool mangle_space);</span>
  
<span class="udiff-line-modified-removed">-   HeapWord* volatile* top_addr() { return &amp;_top; }</span>
<span class="udiff-line-modified-removed">-   // Try to allocate at least min_word_size and up to desired_size from this Space.</span>
<span class="udiff-line-modified-added">+   HeapWord* block_start_const(const void* p) const;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   void mangle_unused_area() PRODUCT_RETURN;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Try to allocate at least min_word_size and up to desired_size from this region.</span>
    // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
    // space allocated.
<span class="udiff-line-modified-removed">-   // This version assumes that all allocation requests to this Space are properly</span>
<span class="udiff-line-modified-added">+   // This version assumes that all allocation requests to this HeapRegion are properly</span>
    // synchronized.
    inline HeapWord* allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
<span class="udiff-line-modified-removed">-   // Try to allocate at least min_word_size and up to desired_size from this Space.</span>
<span class="udiff-line-modified-added">+   // Try to allocate at least min_word_size and up to desired_size from this HeapRegion.</span>
    // Returns NULL if not possible, otherwise sets actual_word_size to the amount of
    // space allocated.
    // This version synchronizes with other calls to par_allocate_impl().
    inline HeapWord* par_allocate_impl(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
  
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   void reset_after_compaction() { set_top(compaction_top()); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t used() const { return byte_size(bottom(), top()); }</span>
<span class="udiff-line-removed">-   size_t free() const { return byte_size(top(), end()); }</span>
<span class="udiff-line-removed">-   bool is_free_block(const HeapWord* p) const { return p &gt;= top(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   MemRegion used_region() const { return MemRegion(bottom(), top()); }</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   HeapWord* block_start(const void* p);</span>
  
    void object_iterate(ObjectClosure* blk);
<span class="udiff-line-removed">-   void safe_object_iterate(ObjectClosure* blk);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void mangle_unused_area() PRODUCT_RETURN;</span>
<span class="udiff-line-removed">-   void mangle_unused_area_complete() PRODUCT_RETURN;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // See the comment above in the declaration of _pre_dummy_top for an</span>
<span class="udiff-line-removed">-   // explanation of what it is.</span>
<span class="udiff-line-removed">-   void set_pre_dummy_top(HeapWord* pre_dummy_top) {</span>
<span class="udiff-line-removed">-     assert(is_in(pre_dummy_top) &amp;&amp; pre_dummy_top &lt;= top(), &quot;pre-condition&quot;);</span>
<span class="udiff-line-removed">-     _pre_dummy_top = pre_dummy_top;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   HeapWord* pre_dummy_top() {</span>
<span class="udiff-line-removed">-     return (_pre_dummy_top == NULL) ? top() : _pre_dummy_top;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   void reset_pre_dummy_top() { _pre_dummy_top = NULL; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   virtual void clear(bool mangle_space);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   HeapWord* block_start(const void* p);</span>
<span class="udiff-line-removed">-   HeapWord* block_start_const(const void* p) const;</span>
  
    // Allocation (return NULL if full).  Assumes the caller has established
<span class="udiff-line-modified-removed">-   // mutually exclusive access to the space.</span>
<span class="udiff-line-modified-added">+   // mutually exclusive access to the HeapRegion.</span>
    HeapWord* allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
    // Allocation (return NULL if full).  Enforces mutual exclusion internally.
    HeapWord* par_allocate(size_t min_word_size, size_t desired_word_size, size_t* actual_word_size);
  
<span class="udiff-line-modified-removed">-   virtual HeapWord* allocate(size_t word_size);</span>
<span class="udiff-line-modified-removed">-   virtual HeapWord* par_allocate(size_t word_size);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   HeapWord* saved_mark_word() const { ShouldNotReachHere(); return NULL; }</span>
<span class="udiff-line-modified-added">+   HeapWord* allocate(size_t word_size);</span>
<span class="udiff-line-modified-added">+   HeapWord* par_allocate(size_t word_size);</span>
  
<span class="udiff-line-modified-removed">-   // MarkSweep support phase3</span>
<span class="udiff-line-modified-removed">-   virtual HeapWord* initialize_threshold();</span>
<span class="udiff-line-modified-removed">-   virtual HeapWord* cross_threshold(HeapWord* start, HeapWord* end);</span>
<span class="udiff-line-modified-added">+   inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);</span>
<span class="udiff-line-modified-added">+   inline HeapWord* allocate_no_bot_updates(size_t word_size);</span>
<span class="udiff-line-modified-added">+   inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);</span>
  
<span class="udiff-line-modified-removed">-   virtual void print() const;</span>
<span class="udiff-line-modified-added">+   // Full GC support methods.</span>
  
<span class="udiff-line-modified-removed">-   void reset_bot() {</span>
<span class="udiff-line-modified-removed">-     _bot_part.reset_bot();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   HeapWord* initialize_threshold();</span>
<span class="udiff-line-modified-added">+   HeapWord* cross_threshold(HeapWord* start, HeapWord* end);</span>
<span class="udiff-line-modified-added">+   // Update heap region to be consistent after Full GC compaction.</span>
<span class="udiff-line-added">+   void reset_humongous_during_compaction() {</span>
<span class="udiff-line-added">+     assert(is_humongous(),</span>
<span class="udiff-line-added">+            &quot;should only be called for humongous regions&quot;);</span>
  
<span class="udiff-line-modified-removed">-   void print_bot_on(outputStream* out) {</span>
<span class="udiff-line-modified-removed">-     _bot_part.print_on(out);</span>
<span class="udiff-line-modified-added">+     zero_marked_bytes();</span>
<span class="udiff-line-modified-added">+     init_top_at_mark_start();</span>
    }
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-added">+   // Update heap region to be consistent after Full GC compaction.</span>
<span class="udiff-line-added">+   void complete_compaction();</span>
  
<span class="udiff-line-modified-removed">- class HeapRegion: public G1ContiguousSpace {</span>
<span class="udiff-line-modified-removed">-   friend class VMStructs;</span>
<span class="udiff-line-removed">-   // Allow scan_and_forward to call (private) overrides for auxiliary functions on this class</span>
<span class="udiff-line-removed">-   template &lt;typename SpaceType&gt;</span>
<span class="udiff-line-removed">-   friend void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp);</span>
<span class="udiff-line-removed">-  private:</span>
<span class="udiff-line-modified-added">+   // All allocated blocks are occupied by objects in a HeapRegion</span>
<span class="udiff-line-modified-added">+   bool block_is_obj(const HeapWord* p) const;</span>
  
<span class="udiff-line-modified-removed">-   // The remembered set for this region.</span>
<span class="udiff-line-modified-removed">-   // (Might want to make this &quot;inline&quot; later, to avoid some alloc failure</span>
<span class="udiff-line-removed">-   // issues.)</span>
<span class="udiff-line-removed">-   HeapRegionRemSet* _rem_set;</span>
<span class="udiff-line-modified-added">+   // Returns whether the given object is dead based on TAMS and bitmap.</span>
<span class="udiff-line-modified-added">+   bool is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const;</span>
  
<span class="udiff-line-modified-removed">-   // Auxiliary functions for scan_and_forward support.</span>
<span class="udiff-line-modified-removed">-   // See comments for CompactibleSpace for more information.</span>
<span class="udiff-line-modified-removed">-   inline HeapWord* scan_limit() const {</span>
<span class="udiff-line-removed">-     return top();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Returns the object size for all valid block starts</span>
<span class="udiff-line-modified-added">+   // and the amount of unallocated words if called on top()</span>
<span class="udiff-line-modified-added">+   size_t block_size(const HeapWord* p) const;</span>
  
<span class="udiff-line-modified-removed">-   inline bool scanned_block_is_obj(const HeapWord* addr) const {</span>
<span class="udiff-line-modified-removed">-     return true; // Always true, since scan_limit is top</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Scans through the region using the bitmap to determine what</span>
<span class="udiff-line-modified-added">+   // objects to call size_t ApplyToMarkedClosure::apply(oop) for.</span>
<span class="udiff-line-modified-added">+   template&lt;typename ApplyToMarkedClosure&gt;</span>
<span class="udiff-line-added">+   inline void apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure);</span>
  
<span class="udiff-line-modified-removed">-   inline size_t scanned_block_size(const HeapWord* addr) const {</span>
<span class="udiff-line-modified-removed">-     return HeapRegion::block_size(addr); // Avoid virtual call</span>
<span class="udiff-line-modified-added">+   void reset_bot() {</span>
<span class="udiff-line-modified-added">+     _bot_part.reset_bot();</span>
    }
  
<span class="udiff-line-modified-removed">-   void report_region_type_change(G1HeapRegionTraceType::Type to);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // Returns whether the given object address refers to a dead object, and either the</span>
<span class="udiff-line-removed">-   // size of the object (if live) or the size of the block (if dead) in size.</span>
<span class="udiff-line-removed">-   // May</span>
<span class="udiff-line-removed">-   // - only called with obj &lt; top()</span>
<span class="udiff-line-removed">-   // - not called on humongous objects or archive regions</span>
<span class="udiff-line-removed">-   inline bool is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const;</span>
<span class="udiff-line-modified-added">+ private:</span>
<span class="udiff-line-modified-added">+   // The remembered set for this region.</span>
<span class="udiff-line-modified-added">+   HeapRegionRemSet* _rem_set;</span>
  
<span class="udiff-line-modified-removed">-  protected:</span>
<span class="udiff-line-modified-removed">-   // The index of this region in the heap region sequence.</span>
<span class="udiff-line-removed">-   uint  _hrm_index;</span>
<span class="udiff-line-modified-added">+   // Cached index of this region in the heap region sequence.</span>
<span class="udiff-line-modified-added">+   const uint _hrm_index;</span>
  
    HeapRegionType _type;
  
    // For a humongous region, region in which it starts.
    HeapRegion* _humongous_start_region;
  
    // True iff an attempt to evacuate an object in the region failed.
    bool _evacuation_failed;
  
<span class="udiff-line-added">+   static const uint InvalidCSetIndex = UINT_MAX;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // The index in the optional regions array, if this region</span>
<span class="udiff-line-added">+   // is considered optional during a mixed collections.</span>
<span class="udiff-line-added">+   uint _index_in_opt_cset;</span>
<span class="udiff-line-added">+ </span>
    // Fields used by the HeapRegionSetBase class and subclasses.
    HeapRegion* _next;
    HeapRegion* _prev;
  #ifdef ASSERT
    HeapRegionSetBase* _containing_set;
  #endif // ASSERT
  
<span class="udiff-line-removed">-   // We use concurrent marking to determine the amount of live data</span>
<span class="udiff-line-removed">-   // in each heap region.</span>
<span class="udiff-line-removed">-   size_t _prev_marked_bytes;    // Bytes known to be live via last completed marking.</span>
<span class="udiff-line-removed">-   size_t _next_marked_bytes;    // Bytes known to be live via in-progress marking.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The calculated GC efficiency of the region.</span>
<span class="udiff-line-removed">-   double _gc_efficiency;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The index in the optional regions array, if this region</span>
<span class="udiff-line-removed">-   // is considered optional during a mixed collections.</span>
<span class="udiff-line-removed">-   uint _index_in_opt_cset;</span>
<span class="udiff-line-removed">-   int  _young_index_in_cset;</span>
<span class="udiff-line-removed">-   SurvRateGroup* _surv_rate_group;</span>
<span class="udiff-line-removed">-   int  _age_index;</span>
<span class="udiff-line-removed">- </span>
    // The start of the unmarked area. The unmarked area extends from this
    // word until the top and/or end of the region, and is the part
    // of the region for which no marking was done, i.e. objects may
    // have been allocated in this part since the last mark phase.
    // &quot;prev&quot; is the top at the start of the last completed marking.
    // &quot;next&quot; is the top at the start of the in-progress marking (if any.)
    HeapWord* _prev_top_at_mark_start;
    HeapWord* _next_top_at_mark_start;
<span class="udiff-line-modified-removed">-   // If a collection pause is in progress, this is the top at the start</span>
<span class="udiff-line-modified-removed">-   // of that pause.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // We use concurrent marking to determine the amount of live data</span>
<span class="udiff-line-added">+   // in each heap region.</span>
<span class="udiff-line-added">+   size_t _prev_marked_bytes;    // Bytes known to be live via last completed marking.</span>
<span class="udiff-line-added">+   size_t _next_marked_bytes;    // Bytes known to be live via in-progress marking.</span>
  
    void init_top_at_mark_start() {
      assert(_prev_marked_bytes == 0 &amp;&amp;
             _next_marked_bytes == 0,
             &quot;Must be called after zero_marked_bytes.&quot;);
<span class="udiff-line-modified-removed">-     HeapWord* bot = bottom();</span>
<span class="udiff-line-removed">-     _prev_top_at_mark_start = bot;</span>
<span class="udiff-line-removed">-     _next_top_at_mark_start = bot;</span>
<span class="udiff-line-modified-added">+     _prev_top_at_mark_start = _next_top_at_mark_start = bottom();</span>
    }
  
<span class="udiff-line-added">+   // Data for young region survivor prediction.</span>
<span class="udiff-line-added">+   uint  _young_index_in_cset;</span>
<span class="udiff-line-added">+   G1SurvRateGroup* _surv_rate_group;</span>
<span class="udiff-line-added">+   int  _age_index;</span>
<span class="udiff-line-added">+ </span>
    // Cached attributes used in the collection set policy information
  
<span class="udiff-line-modified-removed">-   // The RSet length that was added to the total value</span>
<span class="udiff-line-modified-removed">-   // for the collection set.</span>
<span class="udiff-line-removed">-   size_t _recorded_rs_length;</span>
<span class="udiff-line-modified-added">+   // The calculated GC efficiency of the region.</span>
<span class="udiff-line-modified-added">+   double _gc_efficiency;</span>
  
<span class="udiff-line-modified-removed">-   // The predicted elapsed time that was added to total value</span>
<span class="udiff-line-removed">-   // for the collection set.</span>
<span class="udiff-line-removed">-   double _predicted_elapsed_time_ms;</span>
<span class="udiff-line-modified-added">+   uint _node_index;</span>
  
<span class="udiff-line-modified-removed">-   // Iterate over the references in a humongous objects and apply the given closure</span>
<span class="udiff-line-modified-removed">-   // to them.</span>
<span class="udiff-line-modified-added">+   void report_region_type_change(G1HeapRegionTraceType::Type to);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Returns whether the given object address refers to a dead object, and either the</span>
<span class="udiff-line-added">+   // size of the object (if live) or the size of the block (if dead) in size.</span>
<span class="udiff-line-added">+   // May</span>
<span class="udiff-line-added">+   // - only called with obj &lt; top()</span>
<span class="udiff-line-added">+   // - not called on humongous objects or archive regions</span>
<span class="udiff-line-added">+   inline bool is_obj_dead_with_size(const oop obj, const G1CMBitMap* const prev_bitmap, size_t* size) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Iterate over the references covered by the given MemRegion in a humongous</span>
<span class="udiff-line-added">+   // object and apply the given closure to them.</span>
    // Humongous objects are allocated directly in the old-gen. So we need special
    // handling for concurrent processing encountering an in-progress allocation.
<span class="udiff-line-added">+   // Returns the address after the last actually scanned or NULL if the area could</span>
<span class="udiff-line-added">+   // not be scanned (That should only happen when invoked concurrently with the</span>
<span class="udiff-line-added">+   // mutator).</span>
    template &lt;class Closure, bool is_gc_active&gt;
<span class="udiff-line-modified-removed">-   inline bool do_oops_on_card_in_humongous(MemRegion mr,</span>
<span class="udiff-line-modified-removed">-                                            Closure* cl,</span>
<span class="udiff-line-modified-removed">-                                            G1CollectedHeap* g1h);</span>
<span class="udiff-line-modified-added">+   inline HeapWord* do_oops_on_memregion_in_humongous(MemRegion mr,</span>
<span class="udiff-line-modified-added">+                                                      Closure* cl,</span>
<span class="udiff-line-modified-added">+                                                      G1CollectedHeap* g1h);</span>
  
    // Returns the block size of the given (dead, potentially having its class unloaded) object
    // starting at p extending to at most the prev TAMS using the given mark bitmap.
    inline size_t block_size_using_bitmap(const HeapWord* p, const G1CMBitMap* const prev_bitmap) const;
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-removed">-   HeapRegion(uint hrm_index,</span>
<span class="udiff-line-modified-removed">-              G1BlockOffsetTable* bot,</span>
<span class="udiff-line-modified-removed">-              MemRegion mr);</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // If this region is a member of a HeapRegionManager, the index in that</span>
<span class="udiff-line-added">+   // sequence, otherwise -1.</span>
<span class="udiff-line-added">+   uint hrm_index() const { return _hrm_index; }</span>
  
    // Initializing the HeapRegion not only resets the data structure, but also
    // resets the BOT for that heap region.
    // The default values for clear_space means that we will do the clearing if
    // there&#39;s clearing to be done ourselves. We also always mangle the space.
<span class="udiff-line-modified-removed">-   virtual void initialize(MemRegion mr, bool clear_space = false, bool mangle_space = SpaceDecorator::Mangle);</span>
<span class="udiff-line-modified-added">+   void initialize(bool clear_space = false, bool mangle_space = SpaceDecorator::Mangle);</span>
  
    static int    LogOfHRGrainBytes;
    static int    LogOfHRGrainWords;
<span class="udiff-line-added">+   static int    LogCardsPerRegion;</span>
  
    static size_t GrainBytes;
    static size_t GrainWords;
    static size_t CardsPerRegion;
  
    static size_t align_up_to_region_byte_size(size_t sz) {
      return (sz + (size_t) GrainBytes - 1) &amp;
                                        ~((1 &lt;&lt; (size_t) LogOfHRGrainBytes) - 1);
    }
  
<span class="udiff-line-removed">- </span>
    // Returns whether a field is in the same region as the obj it points to.
    template &lt;typename T&gt;
    static bool is_in_same_region(T* p, oop obj) {
      assert(p != NULL, &quot;p can&#39;t be NULL&quot;);
      assert(obj != NULL, &quot;obj can&#39;t be NULL&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -340,37 +323,10 @@</span>
    // CardsPerRegion). All those fields are considered constant
    // throughout the JVM&#39;s execution, therefore they should only be set
    // up once during initialization time.
    static void setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size);
  
<span class="udiff-line-removed">-   // All allocated blocks are occupied by objects in a HeapRegion</span>
<span class="udiff-line-removed">-   bool block_is_obj(const HeapWord* p) const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Returns whether the given object is dead based on TAMS and bitmap.</span>
<span class="udiff-line-removed">-   bool is_obj_dead(const oop obj, const G1CMBitMap* const prev_bitmap) const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Returns the object size for all valid block starts</span>
<span class="udiff-line-removed">-   // and the amount of unallocated words if called on top()</span>
<span class="udiff-line-removed">-   size_t block_size(const HeapWord* p) const;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Scans through the region using the bitmap to determine what</span>
<span class="udiff-line-removed">-   // objects to call size_t ApplyToMarkedClosure::apply(oop) for.</span>
<span class="udiff-line-removed">-   template&lt;typename ApplyToMarkedClosure&gt;</span>
<span class="udiff-line-removed">-   inline void apply_to_marked_objects(G1CMBitMap* bitmap, ApplyToMarkedClosure* closure);</span>
<span class="udiff-line-removed">-   // Override for scan_and_forward support.</span>
<span class="udiff-line-removed">-   void prepare_for_compaction(CompactPoint* cp);</span>
<span class="udiff-line-removed">-   // Update heap region to be consistent after compaction.</span>
<span class="udiff-line-removed">-   void complete_compaction();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline HeapWord* par_allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* word_size);</span>
<span class="udiff-line-removed">-   inline HeapWord* allocate_no_bot_updates(size_t word_size);</span>
<span class="udiff-line-removed">-   inline HeapWord* allocate_no_bot_updates(size_t min_word_size, size_t desired_word_size, size_t* actual_size);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If this region is a member of a HeapRegionManager, the index in that</span>
<span class="udiff-line-removed">-   // sequence, otherwise -1.</span>
<span class="udiff-line-removed">-   uint hrm_index() const { return _hrm_index; }</span>
<span class="udiff-line-removed">- </span>
    // The number of bytes marked live in the region in the last marking phase.
    size_t marked_bytes()    { return _prev_marked_bytes; }
    size_t live_bytes() {
      return (top() - prev_top_at_mark_start()) * HeapWordSize + marked_bytes();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -408,10 +364,26 @@</span>
    }
  
    void zero_marked_bytes()      {
      _prev_marked_bytes = _next_marked_bytes = 0;
    }
<span class="udiff-line-added">+   // Get the start of the unmarked area in this region.</span>
<span class="udiff-line-added">+   HeapWord* prev_top_at_mark_start() const { return _prev_top_at_mark_start; }</span>
<span class="udiff-line-added">+   HeapWord* next_top_at_mark_start() const { return _next_top_at_mark_start; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Note the start or end of marking. This tells the heap region</span>
<span class="udiff-line-added">+   // that the collector is about to start or has finished (concurrently)</span>
<span class="udiff-line-added">+   // marking the heap.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Notify the region that concurrent marking is starting. Initialize</span>
<span class="udiff-line-added">+   // all fields related to the next marking info.</span>
<span class="udiff-line-added">+   inline void note_start_of_marking();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Notify the region that concurrent marking has finished. Copy the</span>
<span class="udiff-line-added">+   // (now finalized) next marking info fields into the prev marking</span>
<span class="udiff-line-added">+   // info fields.</span>
<span class="udiff-line-added">+   inline void note_end_of_marking();</span>
  
    const char* get_type_str() const { return _type.get_str(); }
    const char* get_short_type_str() const { return _type.get_short_str(); }
    G1HeapRegionTraceType::Type get_trace_type() { return _type.get_trace_type(); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,10 +412,22 @@</span>
    // space to be shared by JVM instances.
    bool is_archive()        const { return _type.is_archive(); }
    bool is_open_archive()   const { return _type.is_open_archive(); }
    bool is_closed_archive() const { return _type.is_closed_archive(); }
  
<span class="udiff-line-added">+   void set_free();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_eden();</span>
<span class="udiff-line-added">+   void set_eden_pre_gc();</span>
<span class="udiff-line-added">+   void set_survivor();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void move_to_old();</span>
<span class="udiff-line-added">+   void set_old();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_open_archive();</span>
<span class="udiff-line-added">+   void set_closed_archive();</span>
<span class="udiff-line-added">+ </span>
    // For a humongous region, region in which it starts.
    HeapRegion* humongous_start_region() const {
      return _humongous_start_region;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -472,24 +456,26 @@</span>
  
    // Methods used by the HeapRegionSetBase class and subclasses.
  
    // Getter and setter for the next and prev fields used to link regions into
    // linked lists.
<span class="udiff-line-added">+   void set_next(HeapRegion* next) { _next = next; }</span>
    HeapRegion* next()              { return _next; }
<span class="udiff-line-removed">-   HeapRegion* prev()              { return _prev; }</span>
  
<span class="udiff-line-removed">-   void set_next(HeapRegion* next) { _next = next; }</span>
    void set_prev(HeapRegion* prev) { _prev = prev; }
<span class="udiff-line-added">+   HeapRegion* prev()              { return _prev; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void unlink_from_list();</span>
  
    // Every region added to a set is tagged with a reference to that
    // set. This is used for doing consistency checking to make sure that
    // the contents of a set are as they should be and it&#39;s only
    // available in non-product builds.
  #ifdef ASSERT
    void set_containing_set(HeapRegionSetBase* containing_set) {
<span class="udiff-line-modified-removed">-     assert((containing_set == NULL &amp;&amp; _containing_set != NULL) ||</span>
<span class="udiff-line-modified-removed">-            (containing_set != NULL &amp;&amp; _containing_set == NULL),</span>
<span class="udiff-line-modified-added">+     assert((containing_set != NULL &amp;&amp; _containing_set == NULL) ||</span>
<span class="udiff-line-modified-added">+             containing_set == NULL,</span>
             &quot;containing_set: &quot; PTR_FORMAT &quot; &quot;
             &quot;_containing_set: &quot; PTR_FORMAT,
             p2i(containing_set), p2i(_containing_set));
  
      _containing_set = containing_set;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -502,166 +488,93 @@</span>
    // containing_set() is only used in asserts so there&#39;s no reason
    // to provide a dummy version of it.
  #endif // ASSERT
  
  
<span class="udiff-line-modified-removed">-   // Reset the HeapRegion to default values.</span>
<span class="udiff-line-removed">-   // If skip_remset is true, do not clear the remembered set.</span>
<span class="udiff-line-modified-added">+   // Reset the HeapRegion to default values and clear its remembered set.</span>
    // If clear_space is true, clear the HeapRegion&#39;s memory.
<span class="udiff-line-modified-removed">-   // If locked is true, assume we are the only thread doing this operation.</span>
<span class="udiff-line-modified-removed">-   void hr_clear(bool skip_remset, bool clear_space, bool locked = false);</span>
<span class="udiff-line-modified-added">+   // Callers must ensure this is not called by multiple threads at the same time.</span>
<span class="udiff-line-modified-added">+   void hr_clear(bool clear_space);</span>
    // Clear the card table corresponding to this region.
    void clear_cardtable();
  
<span class="udiff-line-modified-removed">-   // Get the start of the unmarked area in this region.</span>
<span class="udiff-line-modified-removed">-   HeapWord* prev_top_at_mark_start() const { return _prev_top_at_mark_start; }</span>
<span class="udiff-line-removed">-   HeapWord* next_top_at_mark_start() const { return _next_top_at_mark_start; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Note the start or end of marking. This tells the heap region</span>
<span class="udiff-line-removed">-   // that the collector is about to start or has finished (concurrently)</span>
<span class="udiff-line-removed">-   // marking the heap.</span>
<span class="udiff-line-modified-added">+   // Returns the &quot;evacuation_failed&quot; property of the region.</span>
<span class="udiff-line-modified-added">+   bool evacuation_failed() { return _evacuation_failed; }</span>
  
<span class="udiff-line-modified-removed">-   // Notify the region that concurrent marking is starting. Initialize</span>
<span class="udiff-line-modified-removed">-   // all fields related to the next marking info.</span>
<span class="udiff-line-modified-removed">-   inline void note_start_of_marking();</span>
<span class="udiff-line-modified-added">+   // Sets the &quot;evacuation_failed&quot; property of the region.</span>
<span class="udiff-line-modified-added">+   void set_evacuation_failed(bool b) {</span>
<span class="udiff-line-modified-added">+     _evacuation_failed = b;</span>
  
<span class="udiff-line-modified-removed">-   // Notify the region that concurrent marking has finished. Copy the</span>
<span class="udiff-line-modified-removed">-   // (now finalized) next marking info fields into the prev marking</span>
<span class="udiff-line-modified-removed">-   // info fields.</span>
<span class="udiff-line-modified-removed">-   inline void note_end_of_marking();</span>
<span class="udiff-line-modified-added">+     if (b) {</span>
<span class="udiff-line-modified-added">+       _next_marked_bytes = 0;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
  
    // Notify the region that we are about to start processing
    // self-forwarded objects during evac failure handling.
    void note_self_forwarding_removal_start(bool during_initial_mark,
                                            bool during_conc_mark);
  
    // Notify the region that we have finished processing self-forwarded
    // objects during evac failure handling.
    void note_self_forwarding_removal_end(size_t marked_bytes);
  
<span class="udiff-line-modified-removed">-   void reset_during_compaction() {</span>
<span class="udiff-line-modified-removed">-     assert(is_humongous(),</span>
<span class="udiff-line-modified-removed">-            &quot;should only be called for humongous regions&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     zero_marked_bytes();</span>
<span class="udiff-line-removed">-     init_top_at_mark_start();</span>
<span class="udiff-line-modified-added">+   uint index_in_opt_cset() const {</span>
<span class="udiff-line-modified-added">+     assert(has_index_in_opt_cset(), &quot;Opt cset index not set.&quot;);</span>
<span class="udiff-line-modified-added">+     return _index_in_opt_cset;</span>
    }
<span class="udiff-line-added">+   bool has_index_in_opt_cset() const { return _index_in_opt_cset != InvalidCSetIndex; }</span>
<span class="udiff-line-added">+   void set_index_in_opt_cset(uint index) { _index_in_opt_cset = index; }</span>
<span class="udiff-line-added">+   void clear_index_in_opt_cset() { _index_in_opt_cset = InvalidCSetIndex; }</span>
  
    void calc_gc_efficiency(void);
    double gc_efficiency() const { return _gc_efficiency;}
  
<span class="udiff-line-modified-removed">-   uint index_in_opt_cset() const { return _index_in_opt_cset; }</span>
<span class="udiff-line-modified-removed">-   void set_index_in_opt_cset(uint index) { _index_in_opt_cset = index; }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   int  young_index_in_cset() const { return _young_index_in_cset; }</span>
<span class="udiff-line-modified-removed">-   void set_young_index_in_cset(int index) {</span>
<span class="udiff-line-modified-removed">-     assert( (index == -1) || is_young(), &quot;pre-condition&quot; );</span>
<span class="udiff-line-modified-added">+   uint  young_index_in_cset() const { return _young_index_in_cset; }</span>
<span class="udiff-line-modified-added">+   void clear_young_index_in_cset() { _young_index_in_cset = 0; }</span>
<span class="udiff-line-modified-added">+   void set_young_index_in_cset(uint index) {</span>
<span class="udiff-line-modified-added">+     assert(index != UINT_MAX, &quot;just checking&quot;);</span>
<span class="udiff-line-modified-added">+     assert(index != 0, &quot;just checking&quot;);</span>
<span class="udiff-line-modified-added">+     assert(is_young(), &quot;pre-condition&quot;);</span>
      _young_index_in_cset = index;
    }
  
<span class="udiff-line-modified-removed">-   int age_in_surv_rate_group() {</span>
<span class="udiff-line-modified-removed">-     assert( _surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     return _surv_rate_group-&gt;age_in_group(_age_index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void record_surv_words_in_group(size_t words_survived) {</span>
<span class="udiff-line-removed">-     assert( _surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     int age_in_group = age_in_surv_rate_group();</span>
<span class="udiff-line-removed">-     _surv_rate_group-&gt;record_surviving_words(age_in_group, words_survived);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int age_in_surv_rate_group_cond() {</span>
<span class="udiff-line-removed">-     if (_surv_rate_group != NULL)</span>
<span class="udiff-line-removed">-       return age_in_surv_rate_group();</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-       return -1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   SurvRateGroup* surv_rate_group() {</span>
<span class="udiff-line-removed">-     return _surv_rate_group;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void install_surv_rate_group(SurvRateGroup* surv_rate_group) {</span>
<span class="udiff-line-removed">-     assert( surv_rate_group != NULL, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     assert( _surv_rate_group == NULL, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     assert( is_young(), &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     _surv_rate_group = surv_rate_group;</span>
<span class="udiff-line-removed">-     _age_index = surv_rate_group-&gt;next_age_index();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void uninstall_surv_rate_group() {</span>
<span class="udiff-line-removed">-     if (_surv_rate_group != NULL) {</span>
<span class="udiff-line-removed">-       assert( _age_index &gt; -1, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-       assert( is_young(), &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       _surv_rate_group = NULL;</span>
<span class="udiff-line-removed">-       _age_index = -1;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       assert( _age_index == -1, &quot;pre-condition&quot; );</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   int age_in_surv_rate_group() const;</span>
<span class="udiff-line-modified-added">+   bool has_valid_age_in_surv_rate() const;</span>
  
<span class="udiff-line-modified-removed">-   void set_free();</span>
<span class="udiff-line-modified-added">+   bool has_surv_rate_group() const;</span>
  
<span class="udiff-line-modified-removed">-   void set_eden();</span>
<span class="udiff-line-removed">-   void set_eden_pre_gc();</span>
<span class="udiff-line-removed">-   void set_survivor();</span>
<span class="udiff-line-modified-added">+   double surv_rate_prediction(G1Predictions const&amp; predictor) const;</span>
  
<span class="udiff-line-modified-removed">-   void move_to_old();</span>
<span class="udiff-line-modified-removed">-   void set_old();</span>
<span class="udiff-line-modified-added">+   void install_surv_rate_group(G1SurvRateGroup* surv_rate_group);</span>
<span class="udiff-line-modified-added">+   void uninstall_surv_rate_group();</span>
  
<span class="udiff-line-modified-removed">-   void set_open_archive();</span>
<span class="udiff-line-removed">-   void set_closed_archive();</span>
<span class="udiff-line-modified-added">+   void record_surv_words_in_group(size_t words_survived);</span>
  
    // Determine if an object has been allocated since the last
    // mark performed by the collector. This returns true iff the object
    // is within the unmarked area of the region.
    bool obj_allocated_since_prev_marking(oop obj) const {
<span class="udiff-line-modified-removed">-     return (HeapWord *) obj &gt;= prev_top_at_mark_start();</span>
<span class="udiff-line-modified-added">+     return cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= prev_top_at_mark_start();</span>
    }
    bool obj_allocated_since_next_marking(oop obj) const {
<span class="udiff-line-modified-removed">-     return (HeapWord *) obj &gt;= next_top_at_mark_start();</span>
<span class="udiff-line-modified-added">+     return cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= next_top_at_mark_start();</span>
    }
  
<span class="udiff-line-modified-removed">-   // Returns the &quot;evacuation_failed&quot; property of the region.</span>
<span class="udiff-line-modified-removed">-   bool evacuation_failed() { return _evacuation_failed; }</span>
<span class="udiff-line-modified-added">+   // Update the region state after a failed evacuation.</span>
<span class="udiff-line-modified-added">+   void handle_evacuation_failure();</span>
  
<span class="udiff-line-modified-removed">-   // Sets the &quot;evacuation_failed&quot; property of the region.</span>
<span class="udiff-line-removed">-   void set_evacuation_failed(bool b) {</span>
<span class="udiff-line-removed">-     _evacuation_failed = b;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (b) {</span>
<span class="udiff-line-removed">-       _next_marked_bytes = 0;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Iterate over the objects overlapping part of a card, applying cl</span>
<span class="udiff-line-modified-added">+   // Iterate over the objects overlapping the given memory region, applying cl</span>
    // to all references in the region.  This is a helper for
    // G1RemSet::refine_card*, and is tightly coupled with them.
<span class="udiff-line-modified-removed">-   // mr is the memory region covered by the card, trimmed to the</span>
<span class="udiff-line-removed">-   // allocated space for this region.  Must not be empty.</span>
<span class="udiff-line-modified-added">+   // mr must not be empty. Must be trimmed to the allocated/parseable space in this region.</span>
    // This region must be old or humongous.
<span class="udiff-line-modified-removed">-   // Returns true if the designated objects were successfully</span>
<span class="udiff-line-modified-removed">-   // processed, false if an unparsable part of the heap was</span>
<span class="udiff-line-modified-removed">-   // encountered; that only happens when invoked concurrently with the</span>
<span class="udiff-line-removed">-   // mutator.</span>
<span class="udiff-line-modified-added">+   // Returns the next unscanned address if the designated objects were successfully</span>
<span class="udiff-line-modified-added">+   // processed, NULL if an unparseable part of the heap was encountered (That should</span>
<span class="udiff-line-modified-added">+   // only happen when invoked concurrently with the mutator).</span>
    template &lt;bool is_gc_active, class Closure&gt;
<span class="udiff-line-modified-removed">-   inline bool oops_on_card_seq_iterate_careful(MemRegion mr, Closure* cl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t recorded_rs_length() const        { return _recorded_rs_length; }</span>
<span class="udiff-line-removed">-   double predicted_elapsed_time_ms() const { return _predicted_elapsed_time_ms; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_recorded_rs_length(size_t rs_length) {</span>
<span class="udiff-line-removed">-     _recorded_rs_length = rs_length;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_predicted_elapsed_time_ms(double ms) {</span>
<span class="udiff-line-removed">-     _predicted_elapsed_time_ms = ms;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   inline HeapWord* oops_on_memregion_seq_iterate_careful(MemRegion mr, Closure* cl);</span>
  
    // Routines for managing a list of code roots (attached to the
    // this region&#39;s RSet) that point into this heap region.
    void add_strong_code_root(nmethod* nm);
    void add_strong_code_root_locked(nmethod* nm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,10 +582,13 @@</span>
  
    // Applies blk-&gt;do_code_blob() to each of the entries in
    // the strong code roots list for this region
    void strong_code_roots_do(CodeBlobClosure* blk) const;
  
<span class="udiff-line-added">+   uint node_index() const { return _node_index; }</span>
<span class="udiff-line-added">+   void set_node_index(uint node_index) { _node_index = node_index; }</span>
<span class="udiff-line-added">+ </span>
    // Verify that the entries on the strong code root list for this
    // region are live and include at least one pointer into this region.
    void verify_strong_code_roots(VerifyOption vo, bool* failures) const;
  
    void print() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -691,12 +607,12 @@</span>
    // Currently there is only one place where this is called with
    // vo == UseFullMarking, which is to verify the marking during a
    // full GC.
    void verify(VerifyOption vo, bool *failures) const;
  
<span class="udiff-line-modified-removed">-   // Override; it uses the &quot;prev&quot; marking information</span>
<span class="udiff-line-modified-removed">-   virtual void verify() const;</span>
<span class="udiff-line-modified-added">+   // Verify using the &quot;prev&quot; marking information</span>
<span class="udiff-line-modified-added">+   void verify() const;</span>
  
    void verify_rem_set(VerifyOption vo, bool *failures) const;
    void verify_rem_set() const;
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -708,11 +624,11 @@</span>
    friend class G1CollectionSetCandidates;
  
    bool _is_complete;
    void set_incomplete() { _is_complete = false; }
  
<span class="udiff-line-modified-removed">-  public:</span>
<span class="udiff-line-modified-added">+ public:</span>
    HeapRegionClosure(): _is_complete(true) {}
  
    // Typically called on each region until it returns true.
    virtual bool do_heap_region(HeapRegion* r) = 0;
  
</pre>
<center><a href="heapRegion.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
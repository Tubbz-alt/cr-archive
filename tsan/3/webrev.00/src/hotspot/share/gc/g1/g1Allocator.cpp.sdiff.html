<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Allocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1AllocRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Allocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 28 #include &quot;gc/g1/g1EvacStats.inline.hpp&quot;
 29 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
 30 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;

 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 33 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionType.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 
 37 G1Allocator::G1Allocator(G1CollectedHeap* heap) :
 38   _g1h(heap),

 39   _survivor_is_full(false),
 40   _old_is_full(false),
<span class="line-modified"> 41   _mutator_alloc_region(),</span>
<span class="line-modified"> 42   _survivor_gc_alloc_region(heap-&gt;alloc_buffer_stats(InCSetState::Young)),</span>
<span class="line-modified"> 43   _old_gc_alloc_region(heap-&gt;alloc_buffer_stats(InCSetState::Old)),</span>

 44   _retained_old_gc_alloc_region(NULL) {









 45 }
 46 
<span class="line-modified"> 47 void G1Allocator::init_mutator_alloc_region() {</span>
<span class="line-modified"> 48   assert(_mutator_alloc_region.get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-modified"> 49   _mutator_alloc_region.init();</span>




 50 }
 51 
<span class="line-modified"> 52 void G1Allocator::release_mutator_alloc_region() {</span>
<span class="line-modified"> 53   _mutator_alloc_region.release();</span>
<span class="line-modified"> 54   assert(_mutator_alloc_region.get() == NULL, &quot;post-condition&quot;);</span>
















 55 }
 56 
 57 bool G1Allocator::is_retained_old_region(HeapRegion* hr) {
 58   return _retained_old_gc_alloc_region == hr;
 59 }
 60 
 61 void G1Allocator::reuse_retained_old_region(G1EvacuationInfo&amp; evacuation_info,
 62                                             OldGCAllocRegion* old,
 63                                             HeapRegion** retained_old) {
 64   HeapRegion* retained_region = *retained_old;
 65   *retained_old = NULL;
 66   assert(retained_region == NULL || !retained_region-&gt;is_archive(),
 67          &quot;Archive region should not be alloc region (index %u)&quot;, retained_region-&gt;hrm_index());
 68 
 69   // We will discard the current GC alloc region if:
 70   // a) it&#39;s in the collection set (it can happen!),
 71   // b) it&#39;s already full (no point in using it),
 72   // c) it&#39;s empty (this means that it was emptied during
 73   // a cleanup and it should be on the free list now), or
 74   // d) it&#39;s humongous (this means that it was emptied
</pre>
<hr />
<pre>
 80       !(retained_region-&gt;top() == retained_region-&gt;end()) &amp;&amp;
 81       !retained_region-&gt;is_empty() &amp;&amp;
 82       !retained_region-&gt;is_humongous()) {
 83     // The retained region was added to the old region set when it was
 84     // retired. We have to remove it now, since we don&#39;t allow regions
 85     // we allocate to in the region sets. We&#39;ll re-add it later, when
 86     // it&#39;s retired again.
 87     _g1h-&gt;old_set_remove(retained_region);
 88     old-&gt;set(retained_region);
 89     _g1h-&gt;hr_printer()-&gt;reuse(retained_region);
 90     evacuation_info.set_alloc_regions_used_before(retained_region-&gt;used());
 91   }
 92 }
 93 
 94 void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
 95   assert_at_safepoint_on_vm_thread();
 96 
 97   _survivor_is_full = false;
 98   _old_is_full = false;
 99 
<span class="line-modified">100   _survivor_gc_alloc_region.init();</span>



101   _old_gc_alloc_region.init();
102   reuse_retained_old_region(evacuation_info,
103                             &amp;_old_gc_alloc_region,
104                             &amp;_retained_old_gc_alloc_region);
105 }
106 
107 void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
<span class="line-modified">108   evacuation_info.set_allocation_regions(survivor_gc_alloc_region()-&gt;count() +</span>





109                                          old_gc_alloc_region()-&gt;count());
<span class="line-modified">110   survivor_gc_alloc_region()-&gt;release();</span>
111   // If we have an old GC alloc region to release, we&#39;ll save it in
112   // _retained_old_gc_alloc_region. If we don&#39;t
113   // _retained_old_gc_alloc_region will become NULL. This is what we
114   // want either way so no reason to check explicitly for either
115   // condition.
116   _retained_old_gc_alloc_region = old_gc_alloc_region()-&gt;release();
117 }
118 
119 void G1Allocator::abandon_gc_alloc_regions() {
<span class="line-modified">120   assert(survivor_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);</span>


121   assert(old_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);
122   _retained_old_gc_alloc_region = NULL;
123 }
124 
125 bool G1Allocator::survivor_is_full() const {
126   return _survivor_is_full;
127 }
128 
129 bool G1Allocator::old_is_full() const {
130   return _old_is_full;
131 }
132 
133 void G1Allocator::set_survivor_full() {
134   _survivor_is_full = true;
135 }
136 
137 void G1Allocator::set_old_full() {
138   _old_is_full = true;
139 }
140 
141 size_t G1Allocator::unsafe_max_tlab_alloc() {
142   // Return the remaining space in the cur alloc region, but not less than
143   // the min TLAB size.
144 
145   // Also, this value can be at most the humongous object threshold,
146   // since we can&#39;t allow tlabs to grow big enough to accommodate
147   // humongous objects.
148 
<span class="line-modified">149   HeapRegion* hr = mutator_alloc_region()-&gt;get();</span>

150   size_t max_tlab = _g1h-&gt;max_tlab_size() * wordSize;
151   if (hr == NULL) {
152     return max_tlab;
153   } else {
<span class="line-modified">154     return MIN2(MAX2(hr-&gt;free(), (size_t) MinTLABSize), max_tlab);</span>
155   }
156 }
157 
158 size_t G1Allocator::used_in_alloc_regions() {
159   assert(Heap_lock-&gt;owner() != NULL, &quot;Should be owned on this thread&#39;s behalf.&quot;);
<span class="line-modified">160   return mutator_alloc_region()-&gt;used_in_alloc_regions();</span>




161 }
162 
163 
<span class="line-modified">164 HeapWord* G1Allocator::par_allocate_during_gc(InCSetState dest,</span>
<span class="line-modified">165                                               size_t word_size) {</span>

166   size_t temp = 0;
<span class="line-modified">167   HeapWord* result = par_allocate_during_gc(dest, word_size, word_size, &amp;temp);</span>
168   assert(result == NULL || temp == word_size,
169          &quot;Requested &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
170          word_size, temp, p2i(result));
171   return result;
172 }
173 
<span class="line-modified">174 HeapWord* G1Allocator::par_allocate_during_gc(InCSetState dest,</span>
175                                               size_t min_word_size,
176                                               size_t desired_word_size,
<span class="line-modified">177                                               size_t* actual_word_size) {</span>
<span class="line-modified">178   switch (dest.value()) {</span>
<span class="line-modified">179     case InCSetState::Young:</span>
<span class="line-modified">180       return survivor_attempt_allocation(min_word_size, desired_word_size, actual_word_size);</span>
<span class="line-modified">181     case InCSetState::Old:</span>

182       return old_attempt_allocation(min_word_size, desired_word_size, actual_word_size);
183     default:
184       ShouldNotReachHere();
185       return NULL; // Keep some compilers happy
186   }
187 }
188 
189 HeapWord* G1Allocator::survivor_attempt_allocation(size_t min_word_size,
190                                                    size_t desired_word_size,
<span class="line-modified">191                                                    size_t* actual_word_size) {</span>

192   assert(!_g1h-&gt;is_humongous(desired_word_size),
193          &quot;we should not be seeing humongous-size allocations in this path&quot;);
194 
<span class="line-modified">195   HeapWord* result = survivor_gc_alloc_region()-&gt;attempt_allocation(min_word_size,</span>
<span class="line-modified">196                                                                     desired_word_size,</span>
<span class="line-modified">197                                                                     actual_word_size);</span>
198   if (result == NULL &amp;&amp; !survivor_is_full()) {
<span class="line-modified">199     MutexLockerEx x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">200     result = survivor_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,</span>
<span class="line-modified">201                                                                    desired_word_size,</span>
<span class="line-modified">202                                                                    actual_word_size);</span>
203     if (result == NULL) {
204       set_survivor_full();
205     }
206   }
207   if (result != NULL) {
208     _g1h-&gt;dirty_young_block(result, *actual_word_size);
209   }
210   return result;
211 }
212 
213 HeapWord* G1Allocator::old_attempt_allocation(size_t min_word_size,
214                                               size_t desired_word_size,
215                                               size_t* actual_word_size) {
216   assert(!_g1h-&gt;is_humongous(desired_word_size),
217          &quot;we should not be seeing humongous-size allocations in this path&quot;);
218 
219   HeapWord* result = old_gc_alloc_region()-&gt;attempt_allocation(min_word_size,
220                                                                desired_word_size,
221                                                                actual_word_size);
222   if (result == NULL &amp;&amp; !old_is_full()) {
<span class="line-modified">223     MutexLockerEx x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
224     result = old_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,
225                                                               desired_word_size,
226                                                               actual_word_size);
227     if (result == NULL) {
228       set_old_full();
229     }
230   }
231   return result;
232 }
233 
234 uint G1PLABAllocator::calc_survivor_alignment_bytes() {
235   assert(SurvivorAlignmentInBytes &gt;= ObjectAlignmentInBytes, &quot;sanity&quot;);
236   if (SurvivorAlignmentInBytes == ObjectAlignmentInBytes) {
237     // No need to align objects in the survivors differently, return 0
238     // which means &quot;survivor alignment is not used&quot;.
239     return 0;
240   } else {
241     assert(SurvivorAlignmentInBytes &gt; 0, &quot;sanity&quot;);
242     return SurvivorAlignmentInBytes;
243   }
244 }
245 
246 G1PLABAllocator::G1PLABAllocator(G1Allocator* allocator) :
247   _g1h(G1CollectedHeap::heap()),
248   _allocator(allocator),
<span class="line-removed">249   _surviving_alloc_buffer(_g1h-&gt;desired_plab_sz(InCSetState::Young)),</span>
<span class="line-removed">250   _tenured_alloc_buffer(_g1h-&gt;desired_plab_sz(InCSetState::Old)),</span>
251   _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {
<span class="line-modified">252   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
253     _direct_allocated[state] = 0;
<span class="line-modified">254     _alloc_buffers[state] = NULL;</span>














255   }
<span class="line-removed">256   _alloc_buffers[InCSetState::Young] = &amp;_surviving_alloc_buffer;</span>
<span class="line-removed">257   _alloc_buffers[InCSetState::Old]  = &amp;_tenured_alloc_buffer;</span>
258 }
259 
260 bool G1PLABAllocator::may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const {
261   return (allocation_word_sz * 100 &lt; buffer_size * ParallelGCBufferWastePct);
262 }
263 
<span class="line-modified">264 HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(InCSetState dest,</span>
265                                                        size_t word_sz,
<span class="line-modified">266                                                        bool* plab_refill_failed) {</span>

267   size_t plab_word_size = _g1h-&gt;desired_plab_sz(dest);
268   size_t required_in_plab = PLAB::size_required_for_allocation(word_sz);
269 
270   // Only get a new PLAB if the allocation fits and it would not waste more than
271   // ParallelGCBufferWastePct in the existing buffer.
272   if ((required_in_plab &lt;= plab_word_size) &amp;&amp;
273     may_throw_away_buffer(required_in_plab, plab_word_size)) {
274 
<span class="line-modified">275     PLAB* alloc_buf = alloc_buffer(dest);</span>
276     alloc_buf-&gt;retire();
277 
278     size_t actual_plab_size = 0;
279     HeapWord* buf = _allocator-&gt;par_allocate_during_gc(dest,
280                                                        required_in_plab,
281                                                        plab_word_size,
<span class="line-modified">282                                                        &amp;actual_plab_size);</span>

283 
284     assert(buf == NULL || ((actual_plab_size &gt;= required_in_plab) &amp;&amp; (actual_plab_size &lt;= plab_word_size)),
285            &quot;Requested at minimum &quot; SIZE_FORMAT &quot;, desired &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
286            required_in_plab, plab_word_size, actual_plab_size, p2i(buf));
287 
288     if (buf != NULL) {
289       alloc_buf-&gt;set_buf(buf, actual_plab_size);
290 
291       HeapWord* const obj = alloc_buf-&gt;allocate(word_sz);
292       assert(obj != NULL, &quot;PLAB should have been big enough, tried to allocate &quot;
293                           SIZE_FORMAT &quot; requiring &quot; SIZE_FORMAT &quot; PLAB size &quot; SIZE_FORMAT,
294                           word_sz, required_in_plab, plab_word_size);
295       return obj;
296     }
297     // Otherwise.
298     *plab_refill_failed = true;
299   }
300   // Try direct allocation.
<span class="line-modified">301   HeapWord* result = _allocator-&gt;par_allocate_during_gc(dest, word_sz);</span>
302   if (result != NULL) {
<span class="line-modified">303     _direct_allocated[dest.value()] += word_sz;</span>
304   }
305   return result;
306 }
307 
<span class="line-modified">308 void G1PLABAllocator::undo_allocation(InCSetState dest, HeapWord* obj, size_t word_sz) {</span>
<span class="line-modified">309   alloc_buffer(dest)-&gt;undo_allocation(obj, word_sz);</span>
310 }
311 
312 void G1PLABAllocator::flush_and_retire_stats() {
<span class="line-modified">313   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">314     PLAB* const buf = _alloc_buffers[state];</span>
<span class="line-modified">315     if (buf != NULL) {</span>
<span class="line-modified">316       G1EvacStats* stats = _g1h-&gt;alloc_buffer_stats(state);</span>
<span class="line-modified">317       buf-&gt;flush_and_retire_stats(stats);</span>
<span class="line-modified">318       stats-&gt;add_direct_allocated(_direct_allocated[state]);</span>
<span class="line-modified">319       _direct_allocated[state] = 0;</span>
320     }


321   }
322 }
323 
324 size_t G1PLABAllocator::waste() const {
325   size_t result = 0;
<span class="line-modified">326   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">327     PLAB * const buf = _alloc_buffers[state];</span>
<span class="line-modified">328     if (buf != NULL) {</span>
<span class="line-modified">329       result += buf-&gt;waste();</span>


330     }
331   }
332   return result;
333 }
334 
335 size_t G1PLABAllocator::undo_waste() const {
336   size_t result = 0;
<span class="line-modified">337   for (uint state = 0; state &lt; InCSetState::Num; state++) {</span>
<span class="line-modified">338     PLAB * const buf = _alloc_buffers[state];</span>
<span class="line-modified">339     if (buf != NULL) {</span>
<span class="line-modified">340       result += buf-&gt;undo_waste();</span>


341     }
342   }
343   return result;
344 }
345 
346 bool G1ArchiveAllocator::_archive_check_enabled = false;
<span class="line-modified">347 G1ArchiveRegionMap G1ArchiveAllocator::_closed_archive_region_map;</span>
<span class="line-removed">348 G1ArchiveRegionMap G1ArchiveAllocator::_open_archive_region_map;</span>
349 
350 G1ArchiveAllocator* G1ArchiveAllocator::create_allocator(G1CollectedHeap* g1h, bool open) {
351   // Create the archive allocator, and also enable archive object checking
352   // in mark-sweep, since we will be creating archive regions.
353   G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);
354   enable_archive_object_check();
355   return result;
356 }
357 
358 bool G1ArchiveAllocator::alloc_new_region() {
359   // Allocate the highest free region in the reserved heap,
360   // and add it to our list of allocated regions. It is marked
361   // archive and added to the old set.
362   HeapRegion* hr = _g1h-&gt;alloc_highest_free_region();
363   if (hr == NULL) {
364     return false;
365   }
366   assert(hr-&gt;is_empty(), &quot;expected empty region (index %u)&quot;, hr-&gt;hrm_index());
367   if (_open) {
368     hr-&gt;set_open_archive();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1AllocRegion.inline.hpp&quot;
 28 #include &quot;gc/g1/g1EvacStats.inline.hpp&quot;
 29 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;
 30 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
 35 #include &quot;gc/g1/heapRegionType.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 G1Allocator::G1Allocator(G1CollectedHeap* heap) :
 39   _g1h(heap),
<span class="line-added"> 40   _numa(heap-&gt;numa()),</span>
 41   _survivor_is_full(false),
 42   _old_is_full(false),
<span class="line-modified"> 43   _num_alloc_regions(_numa-&gt;num_active_nodes()),</span>
<span class="line-modified"> 44   _mutator_alloc_regions(NULL),</span>
<span class="line-modified"> 45   _survivor_gc_alloc_regions(NULL),</span>
<span class="line-added"> 46   _old_gc_alloc_region(heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Old)),</span>
 47   _retained_old_gc_alloc_region(NULL) {
<span class="line-added"> 48 </span>
<span class="line-added"> 49   _mutator_alloc_regions = NEW_C_HEAP_ARRAY(MutatorAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added"> 50   _survivor_gc_alloc_regions = NEW_C_HEAP_ARRAY(SurvivorGCAllocRegion, _num_alloc_regions, mtGC);</span>
<span class="line-added"> 51   G1EvacStats* stat = heap-&gt;alloc_buffer_stats(G1HeapRegionAttr::Young);</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 54     ::new(_mutator_alloc_regions + i) MutatorAllocRegion(i);</span>
<span class="line-added"> 55     ::new(_survivor_gc_alloc_regions + i) SurvivorGCAllocRegion(stat, i);</span>
<span class="line-added"> 56   }</span>
 57 }
 58 
<span class="line-modified"> 59 G1Allocator::~G1Allocator() {</span>
<span class="line-modified"> 60   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-modified"> 61     _mutator_alloc_regions[i].~MutatorAllocRegion();</span>
<span class="line-added"> 62     _survivor_gc_alloc_regions[i].~SurvivorGCAllocRegion();</span>
<span class="line-added"> 63   }</span>
<span class="line-added"> 64   FREE_C_HEAP_ARRAY(MutatorAllocRegion, _mutator_alloc_regions);</span>
<span class="line-added"> 65   FREE_C_HEAP_ARRAY(SurvivorGCAllocRegion, _survivor_gc_alloc_regions);</span>
 66 }
 67 
<span class="line-modified"> 68 #ifdef ASSERT</span>
<span class="line-modified"> 69 bool G1Allocator::has_mutator_alloc_region() {</span>
<span class="line-modified"> 70   uint node_index = current_node_index();</span>
<span class="line-added"> 71   return mutator_alloc_region(node_index)-&gt;get() != NULL;</span>
<span class="line-added"> 72 }</span>
<span class="line-added"> 73 #endif</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75 void G1Allocator::init_mutator_alloc_regions() {</span>
<span class="line-added"> 76   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 77     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added"> 78     mutator_alloc_region(i)-&gt;init();</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80 }</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 void G1Allocator::release_mutator_alloc_regions() {</span>
<span class="line-added"> 83   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added"> 84     mutator_alloc_region(i)-&gt;release();</span>
<span class="line-added"> 85     assert(mutator_alloc_region(i)-&gt;get() == NULL, &quot;post-condition&quot;);</span>
<span class="line-added"> 86   }</span>
 87 }
 88 
 89 bool G1Allocator::is_retained_old_region(HeapRegion* hr) {
 90   return _retained_old_gc_alloc_region == hr;
 91 }
 92 
 93 void G1Allocator::reuse_retained_old_region(G1EvacuationInfo&amp; evacuation_info,
 94                                             OldGCAllocRegion* old,
 95                                             HeapRegion** retained_old) {
 96   HeapRegion* retained_region = *retained_old;
 97   *retained_old = NULL;
 98   assert(retained_region == NULL || !retained_region-&gt;is_archive(),
 99          &quot;Archive region should not be alloc region (index %u)&quot;, retained_region-&gt;hrm_index());
100 
101   // We will discard the current GC alloc region if:
102   // a) it&#39;s in the collection set (it can happen!),
103   // b) it&#39;s already full (no point in using it),
104   // c) it&#39;s empty (this means that it was emptied during
105   // a cleanup and it should be on the free list now), or
106   // d) it&#39;s humongous (this means that it was emptied
</pre>
<hr />
<pre>
112       !(retained_region-&gt;top() == retained_region-&gt;end()) &amp;&amp;
113       !retained_region-&gt;is_empty() &amp;&amp;
114       !retained_region-&gt;is_humongous()) {
115     // The retained region was added to the old region set when it was
116     // retired. We have to remove it now, since we don&#39;t allow regions
117     // we allocate to in the region sets. We&#39;ll re-add it later, when
118     // it&#39;s retired again.
119     _g1h-&gt;old_set_remove(retained_region);
120     old-&gt;set(retained_region);
121     _g1h-&gt;hr_printer()-&gt;reuse(retained_region);
122     evacuation_info.set_alloc_regions_used_before(retained_region-&gt;used());
123   }
124 }
125 
126 void G1Allocator::init_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
127   assert_at_safepoint_on_vm_thread();
128 
129   _survivor_is_full = false;
130   _old_is_full = false;
131 
<span class="line-modified">132   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">133     survivor_gc_alloc_region(i)-&gt;init();</span>
<span class="line-added">134   }</span>
<span class="line-added">135 </span>
136   _old_gc_alloc_region.init();
137   reuse_retained_old_region(evacuation_info,
138                             &amp;_old_gc_alloc_region,
139                             &amp;_retained_old_gc_alloc_region);
140 }
141 
142 void G1Allocator::release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info) {
<span class="line-modified">143   uint survivor_region_count = 0;</span>
<span class="line-added">144   for (uint node_index = 0; node_index &lt; _num_alloc_regions; node_index++) {</span>
<span class="line-added">145     survivor_region_count += survivor_gc_alloc_region(node_index)-&gt;count();</span>
<span class="line-added">146     survivor_gc_alloc_region(node_index)-&gt;release();</span>
<span class="line-added">147   }</span>
<span class="line-added">148   evacuation_info.set_allocation_regions(survivor_region_count +</span>
149                                          old_gc_alloc_region()-&gt;count());
<span class="line-modified">150 </span>
151   // If we have an old GC alloc region to release, we&#39;ll save it in
152   // _retained_old_gc_alloc_region. If we don&#39;t
153   // _retained_old_gc_alloc_region will become NULL. This is what we
154   // want either way so no reason to check explicitly for either
155   // condition.
156   _retained_old_gc_alloc_region = old_gc_alloc_region()-&gt;release();
157 }
158 
159 void G1Allocator::abandon_gc_alloc_regions() {
<span class="line-modified">160   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">161     assert(survivor_gc_alloc_region(i)-&gt;get() == NULL, &quot;pre-condition&quot;);</span>
<span class="line-added">162   }</span>
163   assert(old_gc_alloc_region()-&gt;get() == NULL, &quot;pre-condition&quot;);
164   _retained_old_gc_alloc_region = NULL;
165 }
166 
167 bool G1Allocator::survivor_is_full() const {
168   return _survivor_is_full;
169 }
170 
171 bool G1Allocator::old_is_full() const {
172   return _old_is_full;
173 }
174 
175 void G1Allocator::set_survivor_full() {
176   _survivor_is_full = true;
177 }
178 
179 void G1Allocator::set_old_full() {
180   _old_is_full = true;
181 }
182 
183 size_t G1Allocator::unsafe_max_tlab_alloc() {
184   // Return the remaining space in the cur alloc region, but not less than
185   // the min TLAB size.
186 
187   // Also, this value can be at most the humongous object threshold,
188   // since we can&#39;t allow tlabs to grow big enough to accommodate
189   // humongous objects.
190 
<span class="line-modified">191   uint node_index = current_node_index();</span>
<span class="line-added">192   HeapRegion* hr = mutator_alloc_region(node_index)-&gt;get();</span>
193   size_t max_tlab = _g1h-&gt;max_tlab_size() * wordSize;
194   if (hr == NULL) {
195     return max_tlab;
196   } else {
<span class="line-modified">197     return clamp(hr-&gt;free(), MinTLABSize, max_tlab);</span>
198   }
199 }
200 
201 size_t G1Allocator::used_in_alloc_regions() {
202   assert(Heap_lock-&gt;owner() != NULL, &quot;Should be owned on this thread&#39;s behalf.&quot;);
<span class="line-modified">203   size_t used = 0;</span>
<span class="line-added">204   for (uint i = 0; i &lt; _num_alloc_regions; i++) {</span>
<span class="line-added">205     used += mutator_alloc_region(i)-&gt;used_in_alloc_regions();</span>
<span class="line-added">206   }</span>
<span class="line-added">207   return used;</span>
208 }
209 
210 
<span class="line-modified">211 HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
<span class="line-modified">212                                               size_t word_size,</span>
<span class="line-added">213                                               uint node_index) {</span>
214   size_t temp = 0;
<span class="line-modified">215   HeapWord* result = par_allocate_during_gc(dest, word_size, word_size, &amp;temp, node_index);</span>
216   assert(result == NULL || temp == word_size,
217          &quot;Requested &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
218          word_size, temp, p2i(result));
219   return result;
220 }
221 
<span class="line-modified">222 HeapWord* G1Allocator::par_allocate_during_gc(G1HeapRegionAttr dest,</span>
223                                               size_t min_word_size,
224                                               size_t desired_word_size,
<span class="line-modified">225                                               size_t* actual_word_size,</span>
<span class="line-modified">226                                               uint node_index) {</span>
<span class="line-modified">227   switch (dest.type()) {</span>
<span class="line-modified">228     case G1HeapRegionAttr::Young:</span>
<span class="line-modified">229       return survivor_attempt_allocation(min_word_size, desired_word_size, actual_word_size, node_index);</span>
<span class="line-added">230     case G1HeapRegionAttr::Old:</span>
231       return old_attempt_allocation(min_word_size, desired_word_size, actual_word_size);
232     default:
233       ShouldNotReachHere();
234       return NULL; // Keep some compilers happy
235   }
236 }
237 
238 HeapWord* G1Allocator::survivor_attempt_allocation(size_t min_word_size,
239                                                    size_t desired_word_size,
<span class="line-modified">240                                                    size_t* actual_word_size,</span>
<span class="line-added">241                                                    uint node_index) {</span>
242   assert(!_g1h-&gt;is_humongous(desired_word_size),
243          &quot;we should not be seeing humongous-size allocations in this path&quot;);
244 
<span class="line-modified">245   HeapWord* result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation(min_word_size,</span>
<span class="line-modified">246                                                                               desired_word_size,</span>
<span class="line-modified">247                                                                               actual_word_size);</span>
248   if (result == NULL &amp;&amp; !survivor_is_full()) {
<span class="line-modified">249     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">250     result = survivor_gc_alloc_region(node_index)-&gt;attempt_allocation_locked(min_word_size,</span>
<span class="line-modified">251                                                                              desired_word_size,</span>
<span class="line-modified">252                                                                              actual_word_size);</span>
253     if (result == NULL) {
254       set_survivor_full();
255     }
256   }
257   if (result != NULL) {
258     _g1h-&gt;dirty_young_block(result, *actual_word_size);
259   }
260   return result;
261 }
262 
263 HeapWord* G1Allocator::old_attempt_allocation(size_t min_word_size,
264                                               size_t desired_word_size,
265                                               size_t* actual_word_size) {
266   assert(!_g1h-&gt;is_humongous(desired_word_size),
267          &quot;we should not be seeing humongous-size allocations in this path&quot;);
268 
269   HeapWord* result = old_gc_alloc_region()-&gt;attempt_allocation(min_word_size,
270                                                                desired_word_size,
271                                                                actual_word_size);
272   if (result == NULL &amp;&amp; !old_is_full()) {
<span class="line-modified">273     MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);</span>
274     result = old_gc_alloc_region()-&gt;attempt_allocation_locked(min_word_size,
275                                                               desired_word_size,
276                                                               actual_word_size);
277     if (result == NULL) {
278       set_old_full();
279     }
280   }
281   return result;
282 }
283 
284 uint G1PLABAllocator::calc_survivor_alignment_bytes() {
285   assert(SurvivorAlignmentInBytes &gt;= ObjectAlignmentInBytes, &quot;sanity&quot;);
286   if (SurvivorAlignmentInBytes == ObjectAlignmentInBytes) {
287     // No need to align objects in the survivors differently, return 0
288     // which means &quot;survivor alignment is not used&quot;.
289     return 0;
290   } else {
291     assert(SurvivorAlignmentInBytes &gt; 0, &quot;sanity&quot;);
292     return SurvivorAlignmentInBytes;
293   }
294 }
295 
296 G1PLABAllocator::G1PLABAllocator(G1Allocator* allocator) :
297   _g1h(G1CollectedHeap::heap()),
298   _allocator(allocator),


299   _survivor_alignment_bytes(calc_survivor_alignment_bytes()) {
<span class="line-modified">300   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
301     _direct_allocated[state] = 0;
<span class="line-modified">302     uint length = alloc_buffers_length(state);</span>
<span class="line-added">303     _alloc_buffers[state] = NEW_C_HEAP_ARRAY(PLAB*, length, mtGC);</span>
<span class="line-added">304     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">305       _alloc_buffers[state][node_index] = new PLAB(_g1h-&gt;desired_plab_sz(state));</span>
<span class="line-added">306     }</span>
<span class="line-added">307   }</span>
<span class="line-added">308 }</span>
<span class="line-added">309 </span>
<span class="line-added">310 G1PLABAllocator::~G1PLABAllocator() {</span>
<span class="line-added">311   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-added">312     uint length = alloc_buffers_length(state);</span>
<span class="line-added">313     for (uint node_index = 0; node_index &lt; length; node_index++) {</span>
<span class="line-added">314       delete _alloc_buffers[state][node_index];</span>
<span class="line-added">315     }</span>
<span class="line-added">316     FREE_C_HEAP_ARRAY(PLAB*, _alloc_buffers[state]);</span>
317   }


318 }
319 
320 bool G1PLABAllocator::may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const {
321   return (allocation_word_sz * 100 &lt; buffer_size * ParallelGCBufferWastePct);
322 }
323 
<span class="line-modified">324 HeapWord* G1PLABAllocator::allocate_direct_or_new_plab(G1HeapRegionAttr dest,</span>
325                                                        size_t word_sz,
<span class="line-modified">326                                                        bool* plab_refill_failed,</span>
<span class="line-added">327                                                        uint node_index) {</span>
328   size_t plab_word_size = _g1h-&gt;desired_plab_sz(dest);
329   size_t required_in_plab = PLAB::size_required_for_allocation(word_sz);
330 
331   // Only get a new PLAB if the allocation fits and it would not waste more than
332   // ParallelGCBufferWastePct in the existing buffer.
333   if ((required_in_plab &lt;= plab_word_size) &amp;&amp;
334     may_throw_away_buffer(required_in_plab, plab_word_size)) {
335 
<span class="line-modified">336     PLAB* alloc_buf = alloc_buffer(dest, node_index);</span>
337     alloc_buf-&gt;retire();
338 
339     size_t actual_plab_size = 0;
340     HeapWord* buf = _allocator-&gt;par_allocate_during_gc(dest,
341                                                        required_in_plab,
342                                                        plab_word_size,
<span class="line-modified">343                                                        &amp;actual_plab_size,</span>
<span class="line-added">344                                                        node_index);</span>
345 
346     assert(buf == NULL || ((actual_plab_size &gt;= required_in_plab) &amp;&amp; (actual_plab_size &lt;= plab_word_size)),
347            &quot;Requested at minimum &quot; SIZE_FORMAT &quot;, desired &quot; SIZE_FORMAT &quot; words, but got &quot; SIZE_FORMAT &quot; at &quot; PTR_FORMAT,
348            required_in_plab, plab_word_size, actual_plab_size, p2i(buf));
349 
350     if (buf != NULL) {
351       alloc_buf-&gt;set_buf(buf, actual_plab_size);
352 
353       HeapWord* const obj = alloc_buf-&gt;allocate(word_sz);
354       assert(obj != NULL, &quot;PLAB should have been big enough, tried to allocate &quot;
355                           SIZE_FORMAT &quot; requiring &quot; SIZE_FORMAT &quot; PLAB size &quot; SIZE_FORMAT,
356                           word_sz, required_in_plab, plab_word_size);
357       return obj;
358     }
359     // Otherwise.
360     *plab_refill_failed = true;
361   }
362   // Try direct allocation.
<span class="line-modified">363   HeapWord* result = _allocator-&gt;par_allocate_during_gc(dest, word_sz, node_index);</span>
364   if (result != NULL) {
<span class="line-modified">365     _direct_allocated[dest.type()] += word_sz;</span>
366   }
367   return result;
368 }
369 
<span class="line-modified">370 void G1PLABAllocator::undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index) {</span>
<span class="line-modified">371   alloc_buffer(dest, node_index)-&gt;undo_allocation(obj, word_sz);</span>
372 }
373 
374 void G1PLABAllocator::flush_and_retire_stats() {
<span class="line-modified">375   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">376     G1EvacStats* stats = _g1h-&gt;alloc_buffer_stats(state);</span>
<span class="line-modified">377     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">378       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">379       if (buf != NULL) {</span>
<span class="line-modified">380         buf-&gt;flush_and_retire_stats(stats);</span>
<span class="line-modified">381       }</span>
382     }
<span class="line-added">383     stats-&gt;add_direct_allocated(_direct_allocated[state]);</span>
<span class="line-added">384     _direct_allocated[state] = 0;</span>
385   }
386 }
387 
388 size_t G1PLABAllocator::waste() const {
389   size_t result = 0;
<span class="line-modified">390   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">391     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">392       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">393       if (buf != NULL) {</span>
<span class="line-added">394         result += buf-&gt;waste();</span>
<span class="line-added">395       }</span>
396     }
397   }
398   return result;
399 }
400 
401 size_t G1PLABAllocator::undo_waste() const {
402   size_t result = 0;
<span class="line-modified">403   for (region_type_t state = 0; state &lt; G1HeapRegionAttr::Num; state++) {</span>
<span class="line-modified">404     for (uint node_index = 0; node_index &lt; alloc_buffers_length(state); node_index++) {</span>
<span class="line-modified">405       PLAB* const buf = alloc_buffer(state, node_index);</span>
<span class="line-modified">406       if (buf != NULL) {</span>
<span class="line-added">407         result += buf-&gt;undo_waste();</span>
<span class="line-added">408       }</span>
409     }
410   }
411   return result;
412 }
413 
414 bool G1ArchiveAllocator::_archive_check_enabled = false;
<span class="line-modified">415 G1ArchiveRegionMap G1ArchiveAllocator::_archive_region_map;</span>

416 
417 G1ArchiveAllocator* G1ArchiveAllocator::create_allocator(G1CollectedHeap* g1h, bool open) {
418   // Create the archive allocator, and also enable archive object checking
419   // in mark-sweep, since we will be creating archive regions.
420   G1ArchiveAllocator* result =  new G1ArchiveAllocator(g1h, open);
421   enable_archive_object_check();
422   return result;
423 }
424 
425 bool G1ArchiveAllocator::alloc_new_region() {
426   // Allocate the highest free region in the reserved heap,
427   // and add it to our list of allocated regions. It is marked
428   // archive and added to the old set.
429   HeapRegion* hr = _g1h-&gt;alloc_highest_free_region();
430   if (hr == NULL) {
431     return false;
432   }
433   assert(hr-&gt;is_empty(), &quot;expected empty region (index %u)&quot;, hr-&gt;hrm_index());
434   if (_open) {
435     hr-&gt;set_open_archive();
</pre>
</td>
</tr>
</table>
<center><a href="g1AllocRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
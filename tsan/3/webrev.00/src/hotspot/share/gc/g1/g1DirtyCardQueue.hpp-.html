<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1DirtyCardQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 26 #define SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
 27 
 28 #include &quot;gc/shared/cardTable.hpp&quot;
 29 #include &quot;gc/shared/ptrQueue.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 
 32 class G1DirtyCardQueueSet;
 33 class G1FreeIdSet;
 34 class Thread;
 35 class Monitor;
 36 
 37 // A closure class for processing card table entries.  Note that we don&#39;t
 38 // require these closure objects to be stack-allocated.
 39 class G1CardTableEntryClosure: public CHeapObj&lt;mtGC&gt; {
 40 public:
 41   typedef CardTable::CardValue CardValue;
 42 
 43   // Process the card whose card table entry is &quot;card_ptr&quot;.  If returns
 44   // &quot;false&quot;, terminate the iteration early.
 45   virtual bool do_card_ptr(CardValue* card_ptr, uint worker_i) = 0;
 46 };
 47 
 48 // A ptrQueue whose elements are &quot;oops&quot;, pointers to object heads.
 49 class G1DirtyCardQueue: public PtrQueue {
 50 public:
 51   G1DirtyCardQueue(G1DirtyCardQueueSet* qset, bool permanent = false);
 52 
 53   // Flush before destroying; queue may be used to capture pending work while
 54   // doing something else, with auto-flush on completion.
 55   ~G1DirtyCardQueue();
 56 
 57   // Process queue entries and release resources.
 58   void flush() { flush_impl(); }
 59 
 60   // Compiler support.
 61   static ByteSize byte_offset_of_index() {
 62     return PtrQueue::byte_offset_of_index&lt;G1DirtyCardQueue&gt;();
 63   }
 64   using PtrQueue::byte_width_of_index;
 65 
 66   static ByteSize byte_offset_of_buf() {
 67     return PtrQueue::byte_offset_of_buf&lt;G1DirtyCardQueue&gt;();
 68   }
 69   using PtrQueue::byte_width_of_buf;
 70 
 71 };
 72 
 73 
 74 
 75 class G1DirtyCardQueueSet: public PtrQueueSet {
 76   G1DirtyCardQueue _shared_dirty_card_queue;
 77 
 78   // Apply the closure to the elements of &quot;node&quot; from it&#39;s index to
 79   // buffer_size.  If all closure applications return true, then
 80   // returns true.  Stops processing after the first closure
 81   // application that returns false, and returns false from this
 82   // function.  If &quot;consume&quot; is true, the node&#39;s index is updated to
 83   // exclude the processed elements, e.g. up to the element for which
 84   // the closure returned false.
 85   bool apply_closure_to_buffer(G1CardTableEntryClosure* cl,
 86                                BufferNode* node,
 87                                bool consume,
 88                                uint worker_i = 0);
 89 
 90   // If there are more than stop_at completed buffers, pop one, apply
 91   // the specified closure to its active elements, and return true.
 92   // Otherwise return false.
 93   //
 94   // A completely processed buffer is freed.  However, if a closure
 95   // invocation returns false, processing is stopped and the partially
 96   // processed buffer (with its index updated to exclude the processed
 97   // elements, e.g. up to the element for which the closure returned
 98   // false) is returned to the completed buffer set.
 99   //
100   // If during_pause is true, stop_at must be zero, and the closure
101   // must never return false.
102   bool apply_closure_to_completed_buffer(G1CardTableEntryClosure* cl,
103                                          uint worker_i,
104                                          size_t stop_at,
105                                          bool during_pause);
106 
107   bool mut_process_buffer(BufferNode* node);
108 
109   G1FreeIdSet* _free_ids;
110 
111   // The number of completed buffers processed by mutator and rs thread,
112   // respectively.
113   jint _processed_buffers_mut;
114   jint _processed_buffers_rs_thread;
115 
116   // Current buffer node used for parallel iteration.
117   BufferNode* volatile _cur_par_buffer_node;
118 
119   void concatenate_log(G1DirtyCardQueue&amp; dcq);
120 
121 public:
122   G1DirtyCardQueueSet(bool notify_when_complete = true);
123   ~G1DirtyCardQueueSet();
124 
125   void initialize(Monitor* cbl_mon,
126                   BufferNode::Allocator* allocator,
127                   Mutex* lock,
128                   bool init_free_ids = false);
129 
130   // The number of parallel ids that can be claimed to allow collector or
131   // mutator threads to do card-processing work.
132   static uint num_par_ids();
133 
134   static void handle_zero_index_for_thread(Thread* t);
135 
136   // Apply G1RefineCardConcurrentlyClosure to completed buffers until there are stop_at
137   // completed buffers remaining.
138   bool refine_completed_buffer_concurrently(uint worker_i, size_t stop_at);
139 
140   // Apply the given closure to all completed buffers. The given closure&#39;s do_card_ptr
141   // must never return false. Must only be called during GC.
142   bool apply_closure_during_gc(G1CardTableEntryClosure* cl, uint worker_i);
143 
144   void reset_for_par_iteration() { _cur_par_buffer_node = completed_buffers_head(); }
145   // Applies the current closure to all completed buffers, non-consumptively.
146   // Can be used in parallel, all callers using the iteration state initialized
147   // by reset_for_par_iteration.
148   void par_apply_closure_to_all_completed_buffers(G1CardTableEntryClosure* cl);
149 
150   G1DirtyCardQueue* shared_dirty_card_queue() {
151     return &amp;_shared_dirty_card_queue;
152   }
153 
154   // If a full collection is happening, reset partial logs, and ignore
155   // completed ones: the full collection will make them all irrelevant.
156   void abandon_logs();
157 
158   // If any threads have partial logs, add them to the global list of logs.
159   void concatenate_logs();
160 
161   jint processed_buffers_mut() {
162     return _processed_buffers_mut;
163   }
164   jint processed_buffers_rs_thread() {
165     return _processed_buffers_rs_thread;
166   }
167 
168 };
169 
170 #endif // SHARE_GC_G1_G1DIRTYCARDQUEUE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1CollectionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1COLLECTIONSET_HPP
 26 #define SHARE_GC_G1_G1COLLECTIONSET_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class G1CollectedHeap;
 32 class G1CollectionSetCandidates;
 33 class G1CollectorState;
 34 class G1GCPhaseTimes;
 35 class G1ParScanThreadStateSet;
 36 class G1Policy;
 37 class G1SurvivorRegions;
 38 class HeapRegion;
<a name="1" id="anc1"></a><span class="line-added"> 39 class HeapRegionClaimer;</span>
 40 class HeapRegionClosure;
 41 
<a name="2" id="anc2"></a><span class="line-added"> 42 // The collection set.</span>
<span class="line-added"> 43 //</span>
<span class="line-added"> 44 // The set of regions that are evacuated during an evacuation pause.</span>
<span class="line-added"> 45 //</span>
<span class="line-added"> 46 // At the end of a collection, before freeing the collection set, this set</span>
<span class="line-added"> 47 // contains all regions that were evacuated during this collection:</span>
<span class="line-added"> 48 //</span>
<span class="line-added"> 49 // - survivor regions from the last collection (if any)</span>
<span class="line-added"> 50 // - eden regions allocated by the mutator</span>
<span class="line-added"> 51 // - old gen regions evacuated during mixed gc</span>
<span class="line-added"> 52 //</span>
<span class="line-added"> 53 // This set is built incrementally at mutator time as regions are retired, and</span>
<span class="line-added"> 54 // if this had been a mixed gc, some additional (during gc) incrementally added</span>
<span class="line-added"> 55 // old regions from the collection set candidates built during the concurrent</span>
<span class="line-added"> 56 // cycle.</span>
<span class="line-added"> 57 //</span>
<span class="line-added"> 58 // A more detailed overview of how the collection set changes over time follows:</span>
<span class="line-added"> 59 //</span>
<span class="line-added"> 60 // 0) at the end of GC the survivor regions are added to this collection set.</span>
<span class="line-added"> 61 // 1) the mutator incrementally adds eden regions as they retire</span>
<span class="line-added"> 62 //</span>
<span class="line-added"> 63 // ----- gc starts</span>
<span class="line-added"> 64 //</span>
<span class="line-added"> 65 // 2) prepare (finalize) young regions of the collection set for collection</span>
<span class="line-added"> 66 //    - relabel the survivors as eden</span>
<span class="line-added"> 67 //    - finish up the incremental building that happened at mutator time</span>
<span class="line-added"> 68 //</span>
<span class="line-added"> 69 // iff this is a young-only collection:</span>
<span class="line-added"> 70 //</span>
<span class="line-added"> 71 // a3) evacuate the current collection set in one &quot;initial evacuation&quot; phase</span>
<span class="line-added"> 72 //</span>
<span class="line-added"> 73 // iff this is a mixed collection:</span>
<span class="line-added"> 74 //</span>
<span class="line-added"> 75 // b3) calculate the set of old gen regions we may be able to collect in this</span>
<span class="line-added"> 76 //     collection from the list of collection set candidates.</span>
<span class="line-added"> 77 //     - one part is added to the current collection set</span>
<span class="line-added"> 78 //     - the remainder regions are labeled as optional, and NOT yet added to the</span>
<span class="line-added"> 79 //     collection set.</span>
<span class="line-added"> 80 // b4) evacuate the current collection set in the &quot;initial evacuation&quot; phase</span>
<span class="line-added"> 81 // b5) evacuate the optional regions in the &quot;optional evacuation&quot; phase. This is</span>
<span class="line-added"> 82 //     done in increments (or rounds).</span>
<span class="line-added"> 83 //     b5-1) add a few of the optional regions to the current collection set</span>
<span class="line-added"> 84 //     b5-2) evacuate only these newly added optional regions. For this mechanism we</span>
<span class="line-added"> 85 //     reuse the incremental collection set building infrastructure (used also at</span>
<span class="line-added"> 86 //     mutator time).</span>
<span class="line-added"> 87 //     b5-3) repeat from b5-1 until the policy determines we are done</span>
<span class="line-added"> 88 //</span>
<span class="line-added"> 89 // all collections</span>
<span class="line-added"> 90 //</span>
<span class="line-added"> 91 // 6) free the collection set (contains all regions now; empties collection set</span>
<span class="line-added"> 92 //    afterwards)</span>
<span class="line-added"> 93 // 7) add survivors to this collection set</span>
<span class="line-added"> 94 //</span>
<span class="line-added"> 95 // ----- gc ends</span>
<span class="line-added"> 96 //</span>
<span class="line-added"> 97 // goto 1)</span>
<span class="line-added"> 98 //</span>
<span class="line-added"> 99 // Examples of how the collection set might look over time:</span>
<span class="line-added">100 //</span>
<span class="line-added">101 // Legend:</span>
<span class="line-added">102 // S = survivor, E = eden, O = old.</span>
<span class="line-added">103 // |xxxx| = increment (with increment markers), containing four regions</span>
<span class="line-added">104 //</span>
<span class="line-added">105 // |SSSS|                         ... after step 0), with four survivor regions</span>
<span class="line-added">106 // |SSSSEE|                       ... at step 1), after retiring two eden regions</span>
<span class="line-added">107 // |SSSSEEEE|                     ... after step 1), after retiring four eden regions</span>
<span class="line-added">108 // |EEEEEEEE|                     ... after step 2)</span>
<span class="line-added">109 //</span>
<span class="line-added">110 // iff this is a young-only collection</span>
<span class="line-added">111 //</span>
<span class="line-added">112 // EEEEEEEE||                      ... after step a3), after initial evacuation phase</span>
<span class="line-added">113 // ||                              ... after step 6)</span>
<span class="line-added">114 // |SS|                            ... after step 7), with two survivor regions</span>
<span class="line-added">115 //</span>
<span class="line-added">116 // iff this is a mixed collection</span>
<span class="line-added">117 //</span>
<span class="line-added">118 // |EEEEEEEEOOOO|                  ... after step b3), added four regions to be</span>
<span class="line-added">119 //                                     evacuated in the &quot;initial evacuation&quot; phase</span>
<span class="line-added">120 // EEEEEEEEOOOO||                  ... after step b4), incremental part is empty</span>
<span class="line-added">121 //                                     after evacuation</span>
<span class="line-added">122 // EEEEEEEEOOOO|OO|                ... after step b5.1), added two regions to be</span>
<span class="line-added">123 //                                     evacuated in the first round of the</span>
<span class="line-added">124 //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">125 // EEEEEEEEOOOOOO|O|               ... after step b5.1), added one region to be</span>
<span class="line-added">126 //                                     evacuated in the second round of the</span>
<span class="line-added">127 //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">128 // EEEEEEEEOOOOOOO||               ... after step b5), the complete collection set.</span>
<span class="line-added">129 // ||                              ... after step b6)</span>
<span class="line-added">130 // |SSS|                           ... after step 7), with three survivor regions</span>
<span class="line-added">131 //</span>
132 class G1CollectionSet {
133   G1CollectedHeap* _g1h;
134   G1Policy* _policy;
135 
<a name="3" id="anc3"></a><span class="line-modified">136   // All old gen collection set candidate regions for the current mixed phase.</span>
137   G1CollectionSetCandidates* _candidates;
138 
139   uint _eden_region_length;
140   uint _survivor_region_length;
141   uint _old_region_length;
142 
143   // The actual collection set as a set of region indices.
144   // All entries in _collection_set_regions below _collection_set_cur_length are
<a name="4" id="anc4"></a><span class="line-modified">145   // assumed to be part of the collection set.</span>
146   // We assume that at any time there is at most only one writer and (one or more)
147   // concurrent readers. This means we are good with using storestore and loadload
148   // barriers on the writer and reader respectively only.
149   uint* _collection_set_regions;
150   volatile size_t _collection_set_cur_length;
151   size_t _collection_set_max_length;
152 
<a name="5" id="anc5"></a><span class="line-modified">153   // When doing mixed collections we can add old regions to the collection set, which</span>
<span class="line-modified">154   // will be collected only if there is enough time. We call these optional regions.</span>
<span class="line-modified">155   // This member records the current number of regions that are of that type that</span>
<span class="line-modified">156   // correspond to the first x entries in the collection set candidates.</span>
<span class="line-modified">157   uint _num_optional_regions;</span>

158 
159   // The number of bytes in the collection set before the pause. Set from
160   // the incrementally built collection set at the start of an evacuation
<a name="6" id="anc6"></a><span class="line-modified">161   // pause, and updated as more regions are added to the collection set.</span>

162   size_t _bytes_used_before;
163 
<a name="7" id="anc7"></a><span class="line-modified">164   // The number of cards in the remembered set in the collection set. Set from</span>
<span class="line-modified">165   // the incrementally built collection set at the start of an evacuation</span>
<span class="line-modified">166   // pause, and updated as more regions are added to the collection set.</span>
<span class="line-modified">167   size_t _recorded_rs_length;</span>

168 
169   enum CSetBuildType {
170     Active,             // We are actively building the collection set
171     Inactive            // We are not actively building the collection set
172   };
173 
174   CSetBuildType _inc_build_state;
<a name="8" id="anc8"></a><span class="line-added">175   size_t _inc_part_start;</span>
<span class="line-added">176 </span>
<span class="line-added">177   // Information about eden regions in the incremental collection set.</span>
<span class="line-added">178   struct IncCollectionSetRegionStat {</span>
<span class="line-added">179     // The predicted non-copy time that was added to the total incremental value</span>
<span class="line-added">180     // for the collection set.</span>
<span class="line-added">181     double _non_copy_time_ms;</span>
<span class="line-added">182     // The remembered set length that was added to the total incremental value</span>
<span class="line-added">183     // for the collection set.</span>
<span class="line-added">184     size_t _rs_length;</span>
<span class="line-added">185 </span>
<span class="line-added">186 #ifdef ASSERT</span>
<span class="line-added">187     // Resets members to &quot;uninitialized&quot; values.</span>
<span class="line-added">188     void reset() { _rs_length = ~(size_t)0; _non_copy_time_ms = -1.0; }</span>
<span class="line-added">189 #endif</span>
<span class="line-added">190   };</span>
<span class="line-added">191 </span>
<span class="line-added">192   IncCollectionSetRegionStat* _inc_collection_set_stats;</span>
<span class="line-added">193   // The associated information that is maintained while the incremental</span>
<span class="line-added">194   // collection set is being built with *young* regions. Used to populate</span>
<span class="line-added">195   // the recorded info for the evacuation pause.</span>
196 
197   // The number of bytes in the incrementally built collection set.
198   // Used to set _collection_set_bytes_used_before at the start of
199   // an evacuation pause.
200   size_t _inc_bytes_used_before;
201 
202   // The RSet lengths recorded for regions in the CSet. It is updated
203   // by the thread that adds a new region to the CSet. We assume that
204   // only one thread can be allocating a new CSet region (currently,
205   // it does so after taking the Heap_lock) hence no need to
206   // synchronize updates to this field.
<a name="9" id="anc9"></a><span class="line-modified">207   size_t _inc_recorded_rs_length;</span>
208 
209   // A concurrent refinement thread periodically samples the young
<a name="10" id="anc10"></a><span class="line-modified">210   // region RSets and needs to update _inc_recorded_rs_length as</span>
211   // the RSets grow. Instead of having to synchronize updates to that
212   // field we accumulate them in this field and add it to
<a name="11" id="anc11"></a><span class="line-modified">213   // _inc_recorded_rs_length_diff at the start of a GC.</span>
<span class="line-modified">214   size_t _inc_recorded_rs_length_diff;</span>
215 
216   // The predicted elapsed time it will take to collect the regions in
217   // the CSet. This is updated by the thread that adds a new region to
<a name="12" id="anc12"></a><span class="line-modified">218   // the CSet. See the comment for _inc_recorded_rs_length about</span>
219   // MT-safety assumptions.
<a name="13" id="anc13"></a><span class="line-modified">220   double _inc_predicted_non_copy_time_ms;</span>
221 
<a name="14" id="anc14"></a><span class="line-modified">222   // See the comment for _inc_recorded_rs_length_diff.</span>
<span class="line-modified">223   double _inc_predicted_non_copy_time_ms_diff;</span>
224 
<a name="15" id="anc15"></a><span class="line-modified">225   void set_recorded_rs_length(size_t rs_length);</span>
<span class="line-added">226 </span>
<span class="line-added">227   G1CollectorState* collector_state() const;</span>
228   G1GCPhaseTimes* phase_times();
229 
230   void verify_young_cset_indices() const NOT_DEBUG_RETURN;
<a name="16" id="anc16"></a>


231 
<a name="17" id="anc17"></a><span class="line-added">232   double predict_region_non_copy_time_ms(HeapRegion* hr) const;</span>
<span class="line-added">233 </span>
<span class="line-added">234   // Update the incremental collection set information when adding a region.</span>
<span class="line-added">235   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-added">236 </span>
<span class="line-added">237   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-added">238   void add_old_region(HeapRegion* hr);</span>
<span class="line-added">239   void free_optional_regions();</span>
<span class="line-added">240 </span>
<span class="line-added">241   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-added">242   void add_optional_region(HeapRegion* hr);</span>
<span class="line-added">243 </span>
<span class="line-added">244   void move_candidates_to_collection_set(uint num_regions);</span>
<span class="line-added">245 </span>
<span class="line-added">246   // Finalize the young part of the initial collection set. Relabel survivor regions</span>
<span class="line-added">247   // as Eden and calculate a prediction on how long the evacuation of all young regions</span>
<span class="line-added">248   // will take.</span>
<span class="line-added">249   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-added">250   // Perform any final calculations on the incremental collection set fields before we</span>
<span class="line-added">251   // can use them.</span>
<span class="line-added">252   void finalize_incremental_building();</span>
<span class="line-added">253 </span>
<span class="line-added">254   // Select the old regions of the initial collection set and determine how many optional</span>
<span class="line-added">255   // regions we might be able to evacuate in this pause.</span>
<span class="line-added">256   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-added">257 </span>
<span class="line-added">258   // Iterate the part of the collection set given by the offset and length applying the given</span>
<span class="line-added">259   // HeapRegionClosure. The worker_id will determine where in the part to start the iteration</span>
<span class="line-added">260   // to allow for more efficient parallel iteration.</span>
<span class="line-added">261   void iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">262                          HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">263                          size_t offset,</span>
<span class="line-added">264                          size_t length,</span>
<span class="line-added">265                          uint worker_id,</span>
<span class="line-added">266                          uint total_workers) const;</span>
267 public:
268   G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
269   ~G1CollectionSet();
270 
271   // Initializes the collection set giving the maximum possible length of the collection set.
272   void initialize(uint max_region_length);
<a name="18" id="anc18"></a>

273 
274   void clear_candidates();
275 
276   void set_candidates(G1CollectionSetCandidates* candidates) {
277     assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
278     _candidates = candidates;
279   }
280   G1CollectionSetCandidates* candidates() { return _candidates; }
281 
282   void init_region_lengths(uint eden_cset_region_length,
283                            uint survivor_cset_region_length);
284 
<a name="19" id="anc19"></a>

285   uint region_length() const       { return young_region_length() +
286                                             old_region_length(); }
287   uint young_region_length() const { return eden_region_length() +
288                                             survivor_region_length(); }
289 
290   uint eden_region_length() const     { return _eden_region_length;     }
291   uint survivor_region_length() const { return _survivor_region_length; }
292   uint old_region_length() const      { return _old_region_length;      }
<a name="20" id="anc20"></a><span class="line-modified">293   uint optional_region_length() const { return _num_optional_regions; }</span>
<span class="line-added">294 </span>
<span class="line-added">295   // Reset the contents of the collection set.</span>
<span class="line-added">296   void clear();</span>
297 
298   // Incremental collection set support
299 
300   // Initialize incremental collection set info.
301   void start_incremental_building();
<a name="21" id="anc21"></a><span class="line-added">302   // Start a new collection set increment.</span>
<span class="line-added">303   void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }</span>
<span class="line-added">304   // Stop adding regions to the current collection set increment.</span>
<span class="line-added">305   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
306 
<a name="22" id="anc22"></a><span class="line-modified">307   // Iterate over the current collection set increment applying the given HeapRegionClosure</span>
<span class="line-modified">308   // from a starting position determined by the given worker id.</span>
<span class="line-modified">309   void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;</span>
310 
<a name="23" id="anc23"></a><span class="line-modified">311   // Returns the length of the current increment in number of regions.</span>
<span class="line-modified">312   size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }</span>
<span class="line-added">313   // Returns the length of the whole current collection set in number of regions</span>
<span class="line-added">314   size_t cur_length() const { return _collection_set_cur_length; }</span>
315 
<a name="24" id="anc24"></a><span class="line-modified">316   // Iterate over the entire collection set (all increments calculated so far), applying</span>
<span class="line-modified">317   // the given HeapRegionClosure on all of them.</span>

318   void iterate(HeapRegionClosure* cl) const;
<a name="25" id="anc25"></a><span class="line-added">319   void par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">320                    HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">321                    uint worker_id,</span>
<span class="line-added">322                    uint total_workers) const;</span>
323 
<a name="26" id="anc26"></a><span class="line-modified">324   void iterate_optional(HeapRegionClosure* cl) const;</span>






325 
<a name="27" id="anc27"></a><span class="line-modified">326   size_t recorded_rs_length() { return _recorded_rs_length; }</span>
327 
328   size_t bytes_used_before() const {
329     return _bytes_used_before;
330   }
331 
332   void reset_bytes_used_before() {
333     _bytes_used_before = 0;
334   }
335 
<a name="28" id="anc28"></a><span class="line-modified">336   // Finalize the initial collection set consisting of all young regions potentially a</span>
<span class="line-modified">337   // few old gen regions.</span>
<span class="line-modified">338   void finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);</span>
<span class="line-modified">339   // Finalize the next collection set from the set of available optional old gen regions.</span>
<span class="line-modified">340   bool finalize_optional_for_evacuation(double remaining_pause_time);</span>
<span class="line-modified">341   // Abandon (clean up) optional collection set regions that were not evacuated in this</span>
<span class="line-modified">342   // pause.</span>
<span class="line-modified">343   void abandon_optional_collection_set(G1ParScanThreadStateSet* pss);</span>


344 
345   // Update information about hr in the aggregated information for
346   // the incrementally built collection set.
347   void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
348 
349   // Add eden region to the collection set.
350   void add_eden_region(HeapRegion* hr);
351 
352   // Add survivor region to the collection set.
353   void add_survivor_regions(HeapRegion* hr);
354 
355 #ifndef PRODUCT
356   bool verify_young_ages();
357 
358   void print(outputStream* st);
359 #endif // !PRODUCT
<a name="29" id="anc29"></a>


































































360 };
361 
362 #endif // SHARE_GC_G1_G1COLLECTIONSET_HPP
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1HotCardCache.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP
 26 #define SHARE_GC_G1_G1HOTCARDCACHE_HPP
 27 
 28 #include &quot;gc/g1/g1CardCounts.hpp&quot;
 29 #include &quot;gc/g1/g1_globals.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 class G1CardTableEntryClosure;
 36 class G1CollectedHeap;
 37 class HeapRegion;
 38 
 39 // An evicting cache of cards that have been logged by the G1 post
 40 // write barrier. Placing a card in the cache delays the refinement
 41 // of the card until the card is evicted, or the cache is drained
 42 // during the next evacuation pause.
 43 //
 44 // The first thing the G1 post write barrier does is to check whether
 45 // the card containing the updated pointer is already dirty and, if
 46 // so, skips the remaining code in the barrier.
 47 //
 48 // Delaying the refinement of a card will make the card fail the
 49 // first is_dirty check in the write barrier, skipping the remainder
 50 // of the write barrier.
 51 //
 52 // This can significantly reduce the overhead of the write barrier
 53 // code, increasing throughput.
 54 
 55 class G1HotCardCache: public CHeapObj&lt;mtGC&gt; {
 56 public:
 57   typedef CardTable::CardValue CardValue;
 58 
 59 private:
 60   G1CollectedHeap*  _g1h;
 61 
 62   bool              _use_cache;
 63 
 64   G1CardCounts      _card_counts;
 65 
 66 
 67   // The card cache table
 68   CardValue** _hot_cache;
 69 
 70   size_t            _hot_cache_size;
 71 
 72   size_t            _hot_cache_par_chunk_size;
 73 
 74   // Avoids false sharing when concurrently updating _hot_cache_idx or
 75   // _hot_cache_par_claimed_idx. These are never updated at the same time
 76   // thus it&#39;s not necessary to separate them as well
 77   char _pad_before[DEFAULT_CACHE_LINE_SIZE];
 78 
 79   volatile size_t _hot_cache_idx;
 80 
 81   volatile size_t _hot_cache_par_claimed_idx;
 82 
 83   char _pad_after[DEFAULT_CACHE_LINE_SIZE];
 84 
 85   // The number of cached cards a thread claims when flushing the cache
 86   static const int ClaimChunkSize = 32;
 87 
 88  public:
 89   static bool default_use_cache() {
 90     return (G1ConcRSLogCacheSize &gt; 0);
 91   }
 92 
 93   G1HotCardCache(G1CollectedHeap* g1h);
 94   ~G1HotCardCache();
 95 
 96   void initialize(G1RegionToSpaceMapper* card_counts_storage);
 97 
 98   bool use_cache() { return _use_cache; }
 99 
100   void set_use_cache(bool b) {
101     _use_cache = (b ? default_use_cache() : false);
102   }
103 
104   // Returns the card to be refined or NULL.
105   //
106   // Increments the count for given the card. if the card is not &#39;hot&#39;,
107   // it is returned for immediate refining. Otherwise the card is
108   // added to the hot card cache.
109   // If there is enough room in the hot card cache for the card we&#39;re
110   // adding, NULL is returned and no further action in needed.
111   // If we evict a card from the cache to make room for the new card,
112   // the evicted card is then returned for refinement.
113   CardValue* insert(CardValue* card_ptr);
114 
115   // Refine the cards that have delayed as a result of
116   // being in the cache.
117   void drain(G1CardTableEntryClosure* cl, uint worker_i);
118 
119   // Set up for parallel processing of the cards in the hot cache
120   void reset_hot_cache_claimed_index() {
121     _hot_cache_par_claimed_idx = 0;
122   }
123 
124   // Resets the hot card cache and discards the entries.
125   void reset_hot_cache() {
126     assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at a safepoint&quot;);
127     assert(Thread::current()-&gt;is_VM_thread(), &quot;Current thread should be the VMthread&quot;);
128     if (default_use_cache()) {
129         reset_hot_cache_internal();
130     }
131   }
132 
133   // Zeros the values in the card counts table for the given region
134   void reset_card_counts(HeapRegion* hr);
135 
136  private:
137   void reset_hot_cache_internal() {
138     assert(_hot_cache != NULL, &quot;Logic&quot;);
139     _hot_cache_idx = 0;
140     for (size_t i = 0; i &lt; _hot_cache_size; i++) {
141       _hot_cache[i] = NULL;
142     }
143   }
144 };
145 
146 #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP
    </pre>
  </body>
</html>
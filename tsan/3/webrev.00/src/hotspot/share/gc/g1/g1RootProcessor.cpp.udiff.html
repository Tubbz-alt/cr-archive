<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1RootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RootClosures.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootProcessor.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1RootProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,103 +36,44 @@</span>
  #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1RootClosures.hpp&quot;
  #include &quot;gc/g1/g1RootProcessor.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/oopStorageParState.hpp&quot;</span>
  #include &quot;gc/shared/referenceProcessor.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;services/management.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
<span class="udiff-line-removed">- void G1RootProcessor::worker_has_discovered_all_strong_classes() {</span>
<span class="udiff-line-removed">-   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint new_value = (uint)Atomic::add(1, &amp;_n_workers_discovered_strong_classes);</span>
<span class="udiff-line-removed">-   if (new_value == n_workers()) {</span>
<span class="udiff-line-removed">-     // This thread is last. Notify the others.</span>
<span class="udiff-line-removed">-     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-     _lock.notify_all();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void G1RootProcessor::wait_until_all_strong_classes_discovered() {</span>
<span class="udiff-line-removed">-   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="udiff-line-removed">-     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-     while ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="udiff-line-removed">-       _lock.wait(Mutex::_no_safepoint_check_flag, 0, false);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :
      _g1h(g1h),
      _process_strong_tasks(G1RP_PS_NumElements),
<span class="udiff-line-modified-removed">-     _srs(n_workers),</span>
<span class="udiff-line-removed">-     _par_state_string(StringTable::weak_storage()),</span>
<span class="udiff-line-removed">-     _lock(Mutex::leaf, &quot;G1 Root Scanning barrier lock&quot;, false, Monitor::_safepoint_check_never),</span>
<span class="udiff-line-removed">-     _n_workers_discovered_strong_classes(0) {}</span>
<span class="udiff-line-modified-added">+     _srs(n_workers) {}</span>
  
<span class="udiff-line-modified-removed">- void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="udiff-line-modified-added">+ void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_id) {</span>
    G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
  
<span class="udiff-line-modified-removed">-   G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_i);</span>
<span class="udiff-line-modified-added">+   G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_id);</span>
  
    G1EvacuationRootClosures* closures = pss-&gt;closures();
<span class="udiff-line-modified-removed">-   process_java_roots(closures, phase_times, worker_i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // This is the point where this worker thread will not find more strong CLDs/nmethods.</span>
<span class="udiff-line-removed">-   // Report this so G1 can synchronize the strong and weak CLDs/nmethods processing.</span>
<span class="udiff-line-removed">-   if (closures-&gt;trace_metadata()) {</span>
<span class="udiff-line-removed">-     worker_has_discovered_all_strong_classes();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   process_java_roots(closures, phase_times, worker_id);</span>
  
<span class="udiff-line-modified-removed">-   process_vm_roots(closures, phase_times, worker_i);</span>
<span class="udiff-line-modified-added">+   process_vm_roots(closures, phase_times, worker_id);</span>
  
    {
      // Now the CM ref_processor roots.
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CMRefRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CMRefRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_refProcessor_oops_do)) {
        // We need to treat the discovered reference lists of the
        // concurrent mark ref processor as roots and keep entries
        // (which are added by the marking threads) on them live
        // until they can be processed at the end of marking.
        _g1h-&gt;ref_processor_cm()-&gt;weak_oops_do(closures-&gt;strong_oops());
      }
    }
  
<span class="udiff-line-removed">-   if (closures-&gt;trace_metadata()) {</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WaitForStrongCLD, worker_i);</span>
<span class="udiff-line-removed">-       // Barrier to make sure all workers passed</span>
<span class="udiff-line-removed">-       // the strong CLD and strong nmethods phases.</span>
<span class="udiff-line-removed">-       wait_until_all_strong_classes_discovered();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Now take the complement of the strong CLDs.</span>
<span class="udiff-line-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WeakCLDRoots, worker_i);</span>
<span class="udiff-line-removed">-     assert(closures-&gt;second_pass_weak_clds() != NULL, &quot;Should be non-null if we are tracing metadata.&quot;);</span>
<span class="udiff-line-removed">-     ClassLoaderDataGraph::roots_cld_do(NULL, closures-&gt;second_pass_weak_clds());</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WaitForStrongCLD, worker_i, 0.0);</span>
<span class="udiff-line-removed">-     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WeakCLDRoots, worker_i, 0.0);</span>
<span class="udiff-line-removed">-     assert(closures-&gt;second_pass_weak_clds() == NULL, &quot;Should be null if not tracing metadata.&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // During conc marking we have to filter the per-thread SATB buffers</span>
<span class="udiff-line-removed">-   // to make sure we remove any oops into the CSet (which will show up</span>
<span class="udiff-line-removed">-   // as implicitly live).</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SATBFiltering, worker_i);</span>
<span class="udiff-line-removed">-     if (_process_strong_tasks.try_claim_task(G1RP_PS_filter_satb_buffers) &amp;&amp; _g1h-&gt;collector_state()-&gt;mark_or_rebuild_in_progress()) {</span>
<span class="udiff-line-removed">-       G1BarrierSet::satb_mark_queue_set().filter_thread_buffers();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    _process_strong_tasks.all_tasks_completed(n_workers());
  }
  
  // Adaptor to pass the closures to the strong roots in the VM.
  class StrongRootsClosures : public G1RootClosures {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,90 +139,103 @@</span>
    _process_strong_tasks.all_tasks_completed(n_workers());
  }
  
  void G1RootProcessor::process_java_roots(G1RootClosures* closures,
                                           G1GCPhaseTimes* phase_times,
<span class="udiff-line-modified-removed">-                                          uint worker_i) {</span>
<span class="udiff-line-modified-removed">-   // Iterating over the CLDG and the Threads are done early to allow us to</span>
<span class="udiff-line-modified-removed">-   // first process the strong CLDs and nmethods and then, after a barrier,</span>
<span class="udiff-line-modified-removed">-   // let the thread process the weak CLDs and nmethods.</span>
<span class="udiff-line-modified-added">+                                          uint worker_id) {</span>
<span class="udiff-line-modified-added">+   // We need to make make sure that the &quot;strong&quot; nmethods are processed first</span>
<span class="udiff-line-modified-added">+   // using the strong closure. Only after that we process the weakly reachable</span>
<span class="udiff-line-modified-added">+   // nmethods.</span>
<span class="udiff-line-added">+   // We need to strictly separate the strong and weak nmethod processing because</span>
<span class="udiff-line-added">+   // any processing claims that nmethod, i.e. will not be iterated again.</span>
<span class="udiff-line-added">+   // Which means if an nmethod is processed first and claimed, the strong processing</span>
<span class="udiff-line-added">+   // will not happen, and the oops reachable by that nmethod will not be marked</span>
<span class="udiff-line-added">+   // properly.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // That is why we process strong nmethods first, synchronize all threads via a</span>
<span class="udiff-line-added">+   // barrier, and only then allow weak processing. To minimize the wait time at</span>
<span class="udiff-line-added">+   // that barrier we do the strong nmethod processing first, and immediately after-</span>
<span class="udiff-line-added">+   // wards indicate that that thread is done. Hopefully other root processing after</span>
<span class="udiff-line-added">+   // nmethod processing is enough so there is no need to wait.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // This is only required in the concurrent start pause with class unloading enabled.</span>
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_i);</span>
<span class="udiff-line-removed">-     if (_process_strong_tasks.try_claim_task(G1RP_PS_ClassLoaderDataGraph_oops_do)) {</span>
<span class="udiff-line-removed">-       ClassLoaderDataGraph::roots_cld_do(closures-&gt;strong_clds(), closures-&gt;weak_clds());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_id);</span>
      bool is_par = n_workers() &gt; 1;
      Threads::possibly_parallel_oops_do(is_par,
                                         closures-&gt;strong_oops(),
                                         closures-&gt;strong_codeblobs());
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_id);</span>
<span class="udiff-line-added">+     if (_process_strong_tasks.try_claim_task(G1RP_PS_ClassLoaderDataGraph_oops_do)) {</span>
<span class="udiff-line-added">+       ClassLoaderDataGraph::roots_cld_do(closures-&gt;strong_clds(), closures-&gt;weak_clds());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  }
  
  void G1RootProcessor::process_vm_roots(G1RootClosures* closures,
                                         G1GCPhaseTimes* phase_times,
<span class="udiff-line-modified-removed">-                                        uint worker_i) {</span>
<span class="udiff-line-modified-added">+                                        uint worker_id) {</span>
    OopClosure* strong_roots = closures-&gt;strong_oops();
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_Universe_oops_do)) {
        Universe::oops_do(strong_roots);
      }
    }
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_JNIHandles_oops_do)) {
        JNIHandles::oops_do(strong_roots);
      }
    }
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_ObjectSynchronizer_oops_do)) {
        ObjectSynchronizer::oops_do(strong_roots);
      }
    }
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_Management_oops_do)) {
        Management::oops_do(strong_roots);
      }
    }
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_jvmti_oops_do)) {
        JvmtiExport::oops_do(strong_roots);
      }
    }
  
  #if INCLUDE_AOT
    if (UseAOT) {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_aot_oops_do)) {
          AOTLoader::oops_do(strong_roots);
      }
    }
  #endif
  
    {
<span class="udiff-line-modified-removed">-     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_i);</span>
<span class="udiff-line-modified-added">+     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_id);</span>
      if (_process_strong_tasks.try_claim_task(G1RP_PS_SystemDictionary_oops_do)) {
        SystemDictionary::oops_do(strong_roots);
      }
    }
  }
  
  void G1RootProcessor::process_code_cache_roots(CodeBlobClosure* code_closure,
                                                 G1GCPhaseTimes* phase_times,
<span class="udiff-line-modified-removed">-                                                uint worker_i) {</span>
<span class="udiff-line-modified-added">+                                                uint worker_id) {</span>
    if (_process_strong_tasks.try_claim_task(G1RP_PS_CodeCache_oops_do)) {
      CodeCache::blobs_do(code_closure);
    }
  }
  
</pre>
<center><a href="g1RootClosures.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RootProcessor.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
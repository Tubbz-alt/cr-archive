<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1HotCardCache.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HotCardCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HotCardCache.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
  
  #ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP
  #define SHARE_GC_G1_G1HOTCARDCACHE_HPP
  
  #include &quot;gc/g1/g1CardCounts.hpp&quot;
<span class="line-removed">- #include &quot;gc/g1/g1_globals.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
<span class="line-new-header">--- 24,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,10 ***</span>
<span class="line-new-header">--- 79,15 ---</span>
  
    volatile size_t _hot_cache_par_claimed_idx;
  
    char _pad_after[DEFAULT_CACHE_LINE_SIZE];
  
<span class="line-added">+   // Records whether insertion overflowed the hot card cache at least once. This</span>
<span class="line-added">+   // avoids the need for a separate atomic counter of how many valid entries are</span>
<span class="line-added">+   // in the HCC.</span>
<span class="line-added">+   volatile bool _cache_wrapped_around;</span>
<span class="line-added">+ </span>
    // The number of cached cards a thread claims when flushing the cache
    static const int ClaimChunkSize = 32;
  
   public:
    static bool default_use_cache() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,11 ***</span>
    // the evicted card is then returned for refinement.
    CardValue* insert(CardValue* card_ptr);
  
    // Refine the cards that have delayed as a result of
    // being in the cache.
<span class="line-modified">!   void drain(G1CardTableEntryClosure* cl, uint worker_i);</span>
  
    // Set up for parallel processing of the cards in the hot cache
    void reset_hot_cache_claimed_index() {
      _hot_cache_par_claimed_idx = 0;
    }
<span class="line-new-header">--- 116,11 ---</span>
    // the evicted card is then returned for refinement.
    CardValue* insert(CardValue* card_ptr);
  
    // Refine the cards that have delayed as a result of
    // being in the cache.
<span class="line-modified">!   void drain(G1CardTableEntryClosure* cl, uint worker_id);</span>
  
    // Set up for parallel processing of the cards in the hot cache
    void reset_hot_cache_claimed_index() {
      _hot_cache_par_claimed_idx = 0;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,23 ***</span>
    // Resets the hot card cache and discards the entries.
    void reset_hot_cache() {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Current thread should be the VMthread&quot;);
      if (default_use_cache()) {
<span class="line-modified">!         reset_hot_cache_internal();</span>
      }
    }
  
    // Zeros the values in the card counts table for the given region
    void reset_card_counts(HeapRegion* hr);
  
   private:
    void reset_hot_cache_internal() {
      assert(_hot_cache != NULL, &quot;Logic&quot;);
      _hot_cache_idx = 0;
      for (size_t i = 0; i &lt; _hot_cache_size; i++) {
        _hot_cache[i] = NULL;
      }
    }
  };
  
  #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP
<span class="line-new-header">--- 128,28 ---</span>
    // Resets the hot card cache and discards the entries.
    void reset_hot_cache() {
      assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at a safepoint&quot;);
      assert(Thread::current()-&gt;is_VM_thread(), &quot;Current thread should be the VMthread&quot;);
      if (default_use_cache()) {
<span class="line-modified">!       reset_hot_cache_internal();</span>
      }
    }
  
    // Zeros the values in the card counts table for the given region
    void reset_card_counts(HeapRegion* hr);
  
<span class="line-added">+   // Number of entries in the HCC.</span>
<span class="line-added">+   size_t num_entries() const {</span>
<span class="line-added">+     return _cache_wrapped_around ? _hot_cache_size : _hot_cache_idx + 1;</span>
<span class="line-added">+   }</span>
   private:
    void reset_hot_cache_internal() {
      assert(_hot_cache != NULL, &quot;Logic&quot;);
      _hot_cache_idx = 0;
      for (size_t i = 0; i &lt; _hot_cache_size; i++) {
        _hot_cache[i] = NULL;
      }
<span class="line-added">+     _cache_wrapped_around = false;</span>
    }
  };
  
  #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP
</pre>
<center><a href="g1HotCardCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1IHOPControl.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
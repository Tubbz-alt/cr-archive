<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1YoungGenSizer.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1YoungRemSetSamplingThread.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1YoungRemSetSamplingThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1YoungRemSetSamplingThread.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  
  G1YoungRemSetSamplingThread::G1YoungRemSetSamplingThread() :
      ConcurrentGCThread(),
      _monitor(Mutex::nonleaf,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,14 ***</span>
    set_name(&quot;G1 Young RemSet Sampling&quot;);
    create_and_start();
  }
  
  void G1YoungRemSetSamplingThread::sleep_before_next_cycle() {
<span class="line-modified">!   MutexLockerEx x(&amp;_monitor, Mutex::_no_safepoint_check_flag);</span>
    if (!should_terminate()) {
      uintx waitms = G1ConcRefinementServiceIntervalMillis;
<span class="line-modified">!     _monitor.wait(Mutex::_no_safepoint_check_flag, waitms);</span>
    }
  }
  
  bool G1YoungRemSetSamplingThread::should_start_periodic_gc() {
    // If we are currently in a concurrent mark we are going to uncommit memory soon.
<span class="line-new-header">--- 46,14 ---</span>
    set_name(&quot;G1 Young RemSet Sampling&quot;);
    create_and_start();
  }
  
  void G1YoungRemSetSamplingThread::sleep_before_next_cycle() {
<span class="line-modified">!   MonitorLocker ml(&amp;_monitor, Mutex::_no_safepoint_check_flag);</span>
    if (!should_terminate()) {
      uintx waitms = G1ConcRefinementServiceIntervalMillis;
<span class="line-modified">!     ml.wait(waitms);</span>
    }
  }
  
  bool G1YoungRemSetSamplingThread::should_start_periodic_gc() {
    // If we are currently in a concurrent mark we are going to uncommit memory soon.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,12 ***</span>
      return;
    }
    if ((os::elapsedTime() - _last_periodic_gc_attempt_s) &gt; (G1PeriodicGCInterval / 1000.0)) {
      log_debug(gc, periodic)(&quot;Checking for periodic GC.&quot;);
      if (should_start_periodic_gc()) {
<span class="line-modified">!       if (!G1CollectedHeap::heap()-&gt;try_collect(GCCause::_g1_periodic_collection,</span>
<span class="line-removed">-                                                     false /* retry_on_vmop_failure */)) {</span>
          log_debug(gc, periodic)(&quot;GC request denied. Skipping.&quot;);
        }
      }
      _last_periodic_gc_attempt_s = os::elapsedTime();
    }
<span class="line-new-header">--- 88,11 ---</span>
      return;
    }
    if ((os::elapsedTime() - _last_periodic_gc_attempt_s) &gt; (G1PeriodicGCInterval / 1000.0)) {
      log_debug(gc, periodic)(&quot;Checking for periodic GC.&quot;);
      if (should_start_periodic_gc()) {
<span class="line-modified">!       if (!G1CollectedHeap::heap()-&gt;try_collect(GCCause::_g1_periodic_collection)) {</span>
          log_debug(gc, periodic)(&quot;GC request denied. Skipping.&quot;);
        }
      }
      _last_periodic_gc_attempt_s = os::elapsedTime();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,11 ***</span>
    } else {
      log_info(gc)(&quot;Periodic GC disabled&quot;);
    }
  
    while (!should_terminate()) {
<span class="line-modified">!     sample_young_list_rs_lengths();</span>
  
      if (os::supports_vtime()) {
        _vtime_accum = (os::elapsedVTime() - vtime_start);
      } else {
        _vtime_accum = 0.0;
<span class="line-new-header">--- 107,11 ---</span>
    } else {
      log_info(gc)(&quot;Periodic GC disabled&quot;);
    }
  
    while (!should_terminate()) {
<span class="line-modified">!     sample_young_list_rs_length();</span>
  
      if (os::supports_vtime()) {
        _vtime_accum = (os::elapsedVTime() - vtime_start);
      } else {
        _vtime_accum = 0.0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,25 ***</span>
      sleep_before_next_cycle();
    }
  }
  
  void G1YoungRemSetSamplingThread::stop_service() {
<span class="line-modified">!   MutexLockerEx x(&amp;_monitor, Mutex::_no_safepoint_check_flag);</span>
    _monitor.notify();
  }
  
  class G1YoungRemSetSamplingClosure : public HeapRegionClosure {
    SuspendibleThreadSetJoiner* _sts;
    size_t _regions_visited;
<span class="line-modified">!   size_t _sampled_rs_lengths;</span>
  public:
    G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :
<span class="line-modified">!     HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_lengths(0) { }</span>
  
    virtual bool do_heap_region(HeapRegion* r) {
      size_t rs_length = r-&gt;rem_set()-&gt;occupied();
<span class="line-modified">!     _sampled_rs_lengths += rs_length;</span>
  
      // Update the collection set policy information for this region
      G1CollectedHeap::heap()-&gt;collection_set()-&gt;update_young_region_prediction(r, rs_length);
  
      _regions_visited++;
<span class="line-new-header">--- 122,25 ---</span>
      sleep_before_next_cycle();
    }
  }
  
  void G1YoungRemSetSamplingThread::stop_service() {
<span class="line-modified">!   MutexLocker x(&amp;_monitor, Mutex::_no_safepoint_check_flag);</span>
    _monitor.notify();
  }
  
  class G1YoungRemSetSamplingClosure : public HeapRegionClosure {
    SuspendibleThreadSetJoiner* _sts;
    size_t _regions_visited;
<span class="line-modified">!   size_t _sampled_rs_length;</span>
  public:
    G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :
<span class="line-modified">!     HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }</span>
  
    virtual bool do_heap_region(HeapRegion* r) {
      size_t rs_length = r-&gt;rem_set()-&gt;occupied();
<span class="line-modified">!     _sampled_rs_length += rs_length;</span>
  
      // Update the collection set policy information for this region
      G1CollectedHeap::heap()-&gt;collection_set()-&gt;update_young_region_prediction(r, rs_length);
  
      _regions_visited++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,24 ***</span>
        _regions_visited = 0;
      }
      return false;
    }
  
<span class="line-modified">!   size_t sampled_rs_lengths() const { return _sampled_rs_lengths; }</span>
  };
  
<span class="line-modified">! void G1YoungRemSetSamplingThread::sample_young_list_rs_lengths() {</span>
    SuspendibleThreadSetJoiner sts;
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    G1Policy* policy = g1h-&gt;policy();
  
<span class="line-modified">!   if (policy-&gt;adaptive_young_list_length()) {</span>
      G1YoungRemSetSamplingClosure cl(&amp;sts);
  
      G1CollectionSet* g1cs = g1h-&gt;collection_set();
      g1cs-&gt;iterate(&amp;cl);
  
      if (cl.is_complete()) {
<span class="line-modified">!       policy-&gt;revise_young_list_target_length_if_necessary(cl.sampled_rs_lengths());</span>
      }
    }
  }
<span class="line-new-header">--- 155,24 ---</span>
        _regions_visited = 0;
      }
      return false;
    }
  
<span class="line-modified">!   size_t sampled_rs_length() const { return _sampled_rs_length; }</span>
  };
  
<span class="line-modified">! void G1YoungRemSetSamplingThread::sample_young_list_rs_length() {</span>
    SuspendibleThreadSetJoiner sts;
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    G1Policy* policy = g1h-&gt;policy();
  
<span class="line-modified">!   if (policy-&gt;use_adaptive_young_list_length()) {</span>
      G1YoungRemSetSamplingClosure cl(&amp;sts);
  
      G1CollectionSet* g1cs = g1h-&gt;collection_set();
      g1cs-&gt;iterate(&amp;cl);
  
      if (cl.is_complete()) {
<span class="line-modified">!       policy-&gt;revise_young_list_target_length_if_necessary(cl.sampled_rs_length());</span>
      }
    }
  }
</pre>
<center><a href="g1YoungGenSizer.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1YoungRemSetSamplingThread.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
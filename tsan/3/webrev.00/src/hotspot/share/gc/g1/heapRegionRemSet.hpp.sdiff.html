<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionRemSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionRemSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionRemSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONREMSET_HPP
 26 #define SHARE_GC_G1_HEAPREGIONREMSET_HPP
 27 
 28 #include &quot;gc/g1/g1CodeCacheRemSet.hpp&quot;
 29 #include &quot;gc/g1/g1FromCardCache.hpp&quot;
 30 #include &quot;gc/g1/sparsePRT.hpp&quot;


 31 
 32 // Remembered set for a heap region.  Represent a set of &quot;cards&quot; that
 33 // contain pointers into the owner heap region.  Cards are defined somewhat
 34 // abstractly, in terms of what the &quot;BlockOffsetTable&quot; in use can parse.
 35 
 36 class G1CollectedHeap;
 37 class G1BlockOffsetTable;
 38 class G1CardLiveData;
 39 class HeapRegion;
<span class="line-removed"> 40 class HeapRegionRemSetIterator;</span>
 41 class PerRegionTable;
 42 class SparsePRT;
 43 class nmethod;
 44 
 45 // The &quot;_coarse_map&quot; is a bitmap with one bit for each region, where set
 46 // bits indicate that the corresponding region may contain some pointer
 47 // into the owning region.
 48 
 49 // The &quot;_fine_grain_entries&quot; array is an open hash table of PerRegionTables
 50 // (PRTs), indicating regions for which we&#39;re keeping the RS as a set of
 51 // cards.  The strategy is to cap the size of the fine-grain table,
 52 // deleting an entry and setting the corresponding coarse-grained bit when
 53 // we would overflow this cap.
 54 
 55 // We use a mixture of locking and lock-free techniques here.  We allow
 56 // threads to locate PRTs without locking, but threads attempting to alter
 57 // a bucket list obtain a lock.  This means that any failing attempt to
 58 // find a PRT must be retried with the lock.  It might seem dangerous that
 59 // a read can find a PRT that is concurrently deleted.  This is all right,
 60 // because:
 61 //
 62 //   1) We only actually free PRT&#39;s at safe points (though we reuse them at
 63 //      other times).
 64 //   2) We find PRT&#39;s in an attempt to add entries.  If a PRT is deleted,
 65 //      it&#39;s _coarse_map bit is set, so the that we were attempting to add
 66 //      is represented.  If a deleted PRT is re-used, a thread adding a bit,
 67 //      thinking the PRT is for a different region, does no harm.
 68 
 69 class OtherRegionsTable {
<span class="line-removed"> 70   friend class HeapRegionRemSetIterator;</span>
<span class="line-removed"> 71 </span>
 72   G1CollectedHeap* _g1h;
 73   Mutex*           _m;
 74 


 75   // These are protected by &quot;_m&quot;.
 76   CHeapBitMap _coarse_map;
 77   size_t      _n_coarse_entries;
 78   static jint _n_coarsenings;
 79 
 80   PerRegionTable** _fine_grain_regions;
 81   size_t           _n_fine_entries;
 82 
 83   // The fine grain remembered sets are doubly linked together using
 84   // their &#39;next&#39; and &#39;prev&#39; fields.
 85   // This allows fast bulk freeing of all the fine grain remembered
 86   // set entries, and fast finding of all of them without iterating
 87   // over the _fine_grain_regions table.
 88   PerRegionTable * _first_all_fine_prts;
 89   PerRegionTable * _last_all_fine_prts;
 90 
 91   // Used to sample a subset of the fine grain PRTs to determine which
 92   // PRT to evict and coarsen.
 93   size_t        _fine_eviction_start;
 94   static size_t _fine_eviction_stride;
 95   static size_t _fine_eviction_sample_size;
 96 
 97   SparsePRT   _sparse_table;
 98 
 99   // These are static after init.
100   static size_t _max_fine_entries;
101   static size_t _mod_max_fine_entries_mask;
102 
103   // Requires &quot;prt&quot; to be the first element of the bucket list appropriate
104   // for &quot;hr&quot;.  If this list contains an entry for &quot;hr&quot;, return it,
105   // otherwise return &quot;NULL&quot;.
106   PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;
107 
108   // Find, delete, and return a candidate PerRegionTable, if any exists,
109   // adding the deleted region to the coarse bitmap.  Requires the caller
110   // to hold _m, and the fine-grain table to be full.
<span class="line-modified">111   PerRegionTable* delete_region_table();</span>
112 
113   // link/add the given fine grain remembered set into the &quot;all&quot; list
114   void link_to_all(PerRegionTable * prt);
115   // unlink/remove the given fine grain remembered set into the &quot;all&quot; list
116   void unlink_from_all(PerRegionTable * prt);
117 
118   bool contains_reference_locked(OopOrNarrowOopStar from) const;
119 
<span class="line-removed">120   size_t occ_fine() const;</span>
<span class="line-removed">121   size_t occ_coarse() const;</span>
<span class="line-removed">122   size_t occ_sparse() const;</span>
<span class="line-removed">123 </span>
124 public:
125   // Create a new remembered set. The given mutex is used to ensure consistency.
126   OtherRegionsTable(Mutex* m);
127 



128   // Returns the card index of the given within_region pointer relative to the bottom
129   // of the given heap region.
130   static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);
131   // Adds the reference from &quot;from to this remembered set.
132   void add_reference(OopOrNarrowOopStar from, uint tid);
133 
134   // Returns whether the remembered set contains the given reference.
135   bool contains_reference(OopOrNarrowOopStar from) const;
136 
137   // Returns whether this remembered set (and all sub-sets) have an occupancy
138   // that is less or equal than the given occupancy.
139   bool occupancy_less_or_equal_than(size_t limit) const;
140 
141   // Returns whether this remembered set (and all sub-sets) does not contain any entry.
142   bool is_empty() const;
143 
144   // Returns the number of cards contained in this remembered set.
145   size_t occupied() const;
146 
147   static jint n_coarsenings() { return _n_coarsenings; }
148 
149   // Returns size of the actual remembered set containers in bytes.
150   size_t mem_size() const;
151   // Returns the size of static data in bytes.
152   static size_t static_mem_size();
153   // Returns the size of the free list content in bytes.
154   static size_t fl_mem_size();
155 
156   // Clear the entire contents of this remembered set.
157   void clear();
158 };
159 


























































































































160 class HeapRegionRemSet : public CHeapObj&lt;mtGC&gt; {
161   friend class VMStructs;
<span class="line-removed">162   friend class HeapRegionRemSetIterator;</span>
163 
164 private:
165   G1BlockOffsetTable* _bot;
166 
167   // A set of code blobs (nmethods) whose code contains pointers into
168   // the region that owns this RSet.
169   G1CodeRootSet _code_roots;
170 
171   Mutex _m;
172 
173   OtherRegionsTable _other_regions;
174 
175   HeapRegion* _hr;
176 
177   void clear_fcc();
178 
179 public:
180   HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);
181 

182   static void setup_remset_size();
183 
<span class="line-removed">184   bool cardset_is_empty() const {</span>
<span class="line-removed">185     return _other_regions.is_empty();</span>
<span class="line-removed">186   }</span>
<span class="line-removed">187 </span>
188   bool is_empty() const {
<span class="line-modified">189     return (strong_code_roots_list_length() == 0) &amp;&amp; cardset_is_empty();</span>
190   }
191 
192   bool occupancy_less_or_equal_than(size_t occ) const {
193     return (strong_code_roots_list_length() == 0) &amp;&amp; _other_regions.occupancy_less_or_equal_than(occ);
194   }
195 









196   size_t occupied() {
<span class="line-removed">197     MutexLockerEx x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">198     return occupied_locked();</span>
<span class="line-removed">199   }</span>
<span class="line-removed">200   size_t occupied_locked() {</span>
201     return _other_regions.occupied();
202   }
203 
204   static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }
205 
206 private:
207   enum RemSetState {
208     Untracked,
209     Updating,
210     Complete
211   };
212 
213   RemSetState _state;
214 
215   static const char* _state_strings[];
216   static const char* _short_state_strings[];
217 public:
218 
219   const char* get_state_str() const { return _state_strings[_state]; }
220   const char* get_short_state_str() const { return _short_state_strings[_state]; }
</pre>
<hr />
<pre>
226   void set_state_empty() {
227     guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), &quot;Should only set to Untracked during safepoint but is %s.&quot;, get_state_str());
228     if (_state == Untracked) {
229       return;
230     }
231     clear_fcc();
232     _state = Untracked;
233   }
234 
235   void set_state_updating() {
236     guarantee(SafepointSynchronize::is_at_safepoint() &amp;&amp; !is_tracked(), &quot;Should only set to Updating from Untracked during safepoint but is %s&quot;, get_state_str());
237     clear_fcc();
238     _state = Updating;
239   }
240 
241   void set_state_complete() {
242     clear_fcc();
243     _state = Complete;
244   }
245 
<span class="line-removed">246   // Used in the sequential case.</span>
<span class="line-removed">247   void add_reference(OopOrNarrowOopStar from) {</span>
<span class="line-removed">248     add_reference(from, 0);</span>
<span class="line-removed">249   }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251   // Used in the parallel case.</span>
252   void add_reference(OopOrNarrowOopStar from, uint tid) {
253     RemSetState state = _state;
254     if (state == Untracked) {
255       return;
256     }
257 
258     uint cur_idx = _hr-&gt;hrm_index();
259     uintptr_t from_card = uintptr_t(from) &gt;&gt; CardTable::card_shift;
260 
261     if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {
262       assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the FromCardCache&quot;, p2i(from));
263       return;
264     }
265 
266     _other_regions.add_reference(from, tid);
267   }
268 
269   // The region is being reclaimed; clear its remset, and any mention of
270   // entries for this region in other remsets.
271   void clear(bool only_cardset = false);
272   void clear_locked(bool only_cardset = false);
273 
274   // The actual # of bytes this hr_remset takes up.
275   // Note also includes the strong code root set.
276   size_t mem_size() {
<span class="line-modified">277     MutexLockerEx x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
278     return _other_regions.mem_size()
279       // This correction is necessary because the above includes the second
280       // part.
281       + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))
282       + strong_code_roots_mem_size();
283   }
284 
285   // Returns the memory occupancy of all static data structures associated
286   // with remembered sets.
287   static size_t static_mem_size() {
288     return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();
289   }
290 
291   // Returns the memory occupancy of all free_list data structures associated
292   // with remembered sets.
293   static size_t fl_mem_size() {
294     return OtherRegionsTable::fl_mem_size();
295   }
296 
297   bool contains_reference(OopOrNarrowOopStar from) const {
</pre>
<hr />
<pre>
321     return _code_roots.contains(nm);
322   }
323 
324   // Returns the amount of memory, in bytes, currently
325   // consumed by the strong code roots.
326   size_t strong_code_roots_mem_size();
327 
328   static void invalidate_from_card_cache(uint start_idx, size_t num_regions) {
329     G1FromCardCache::invalidate(start_idx, num_regions);
330   }
331 
332 #ifndef PRODUCT
333   static void print_from_card_cache() {
334     G1FromCardCache::print();
335   }
336 
337   static void test();
338 #endif
339 };
340 
<span class="line-removed">341 class HeapRegionRemSetIterator : public StackObj {</span>
<span class="line-removed">342 private:</span>
<span class="line-removed">343   // The region RSet over which we are iterating.</span>
<span class="line-removed">344   HeapRegionRemSet* _hrrs;</span>
<span class="line-removed">345 </span>
<span class="line-removed">346   // Local caching of HRRS fields.</span>
<span class="line-removed">347   const BitMap*             _coarse_map;</span>
<span class="line-removed">348 </span>
<span class="line-removed">349   G1BlockOffsetTable*       _bot;</span>
<span class="line-removed">350   G1CollectedHeap*          _g1h;</span>
<span class="line-removed">351 </span>
<span class="line-removed">352   // The number of cards yielded since initialization.</span>
<span class="line-removed">353   size_t _n_yielded_fine;</span>
<span class="line-removed">354   size_t _n_yielded_coarse;</span>
<span class="line-removed">355   size_t _n_yielded_sparse;</span>
<span class="line-removed">356 </span>
<span class="line-removed">357   // Indicates what granularity of table that we are currently iterating over.</span>
<span class="line-removed">358   // We start iterating over the sparse table, progress to the fine grain</span>
<span class="line-removed">359   // table, and then finish with the coarse table.</span>
<span class="line-removed">360   enum IterState {</span>
<span class="line-removed">361     Sparse,</span>
<span class="line-removed">362     Fine,</span>
<span class="line-removed">363     Coarse</span>
<span class="line-removed">364   };</span>
<span class="line-removed">365   IterState _is;</span>
<span class="line-removed">366 </span>
<span class="line-removed">367   // For both Coarse and Fine remembered set iteration this contains the</span>
<span class="line-removed">368   // first card number of the heap region we currently iterate over.</span>
<span class="line-removed">369   size_t _cur_region_card_offset;</span>
<span class="line-removed">370 </span>
<span class="line-removed">371   // Current region index for the Coarse remembered set iteration.</span>
<span class="line-removed">372   int    _coarse_cur_region_index;</span>
<span class="line-removed">373   size_t _coarse_cur_region_cur_card;</span>
<span class="line-removed">374 </span>
<span class="line-removed">375   bool coarse_has_next(size_t&amp; card_index);</span>
<span class="line-removed">376 </span>
<span class="line-removed">377   // The PRT we are currently iterating over.</span>
<span class="line-removed">378   PerRegionTable* _fine_cur_prt;</span>
<span class="line-removed">379   // Card offset within the current PRT.</span>
<span class="line-removed">380   size_t _cur_card_in_prt;</span>
<span class="line-removed">381 </span>
<span class="line-removed">382   // Update internal variables when switching to the given PRT.</span>
<span class="line-removed">383   void switch_to_prt(PerRegionTable* prt);</span>
<span class="line-removed">384   bool fine_has_next();</span>
<span class="line-removed">385   bool fine_has_next(size_t&amp; card_index);</span>
<span class="line-removed">386 </span>
<span class="line-removed">387   // The Sparse remembered set iterator.</span>
<span class="line-removed">388   SparsePRTIter _sparse_iter;</span>
<span class="line-removed">389 </span>
<span class="line-removed">390 public:</span>
<span class="line-removed">391   HeapRegionRemSetIterator(HeapRegionRemSet* hrrs);</span>
<span class="line-removed">392 </span>
<span class="line-removed">393   // If there remains one or more cards to be yielded, returns true and</span>
<span class="line-removed">394   // sets &quot;card_index&quot; to one of those cards (which is then considered</span>
<span class="line-removed">395   // yielded.)   Otherwise, returns false (and leaves &quot;card_index&quot;</span>
<span class="line-removed">396   // undefined.)</span>
<span class="line-removed">397   bool has_next(size_t&amp; card_index);</span>
<span class="line-removed">398 </span>
<span class="line-removed">399   size_t n_yielded_fine() { return _n_yielded_fine; }</span>
<span class="line-removed">400   size_t n_yielded_coarse() { return _n_yielded_coarse; }</span>
<span class="line-removed">401   size_t n_yielded_sparse() { return _n_yielded_sparse; }</span>
<span class="line-removed">402   size_t n_yielded() {</span>
<span class="line-removed">403     return n_yielded_fine() + n_yielded_coarse() + n_yielded_sparse();</span>
<span class="line-removed">404   }</span>
<span class="line-removed">405 };</span>
<span class="line-removed">406 </span>
407 #endif // SHARE_GC_G1_HEAPREGIONREMSET_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONREMSET_HPP
 26 #define SHARE_GC_G1_HEAPREGIONREMSET_HPP
 27 
 28 #include &quot;gc/g1/g1CodeCacheRemSet.hpp&quot;
 29 #include &quot;gc/g1/g1FromCardCache.hpp&quot;
 30 #include &quot;gc/g1/sparsePRT.hpp&quot;
<span class="line-added"> 31 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;utilities/bitMap.hpp&quot;</span>
 33 
 34 // Remembered set for a heap region.  Represent a set of &quot;cards&quot; that
 35 // contain pointers into the owner heap region.  Cards are defined somewhat
 36 // abstractly, in terms of what the &quot;BlockOffsetTable&quot; in use can parse.
 37 
 38 class G1CollectedHeap;
 39 class G1BlockOffsetTable;
 40 class G1CardLiveData;
 41 class HeapRegion;

 42 class PerRegionTable;
 43 class SparsePRT;
 44 class nmethod;
 45 
 46 // The &quot;_coarse_map&quot; is a bitmap with one bit for each region, where set
 47 // bits indicate that the corresponding region may contain some pointer
 48 // into the owning region.
 49 
 50 // The &quot;_fine_grain_entries&quot; array is an open hash table of PerRegionTables
 51 // (PRTs), indicating regions for which we&#39;re keeping the RS as a set of
 52 // cards.  The strategy is to cap the size of the fine-grain table,
 53 // deleting an entry and setting the corresponding coarse-grained bit when
 54 // we would overflow this cap.
 55 
 56 // We use a mixture of locking and lock-free techniques here.  We allow
 57 // threads to locate PRTs without locking, but threads attempting to alter
 58 // a bucket list obtain a lock.  This means that any failing attempt to
 59 // find a PRT must be retried with the lock.  It might seem dangerous that
 60 // a read can find a PRT that is concurrently deleted.  This is all right,
 61 // because:
 62 //
 63 //   1) We only actually free PRT&#39;s at safe points (though we reuse them at
 64 //      other times).
 65 //   2) We find PRT&#39;s in an attempt to add entries.  If a PRT is deleted,
 66 //      it&#39;s _coarse_map bit is set, so the that we were attempting to add
 67 //      is represented.  If a deleted PRT is re-used, a thread adding a bit,
 68 //      thinking the PRT is for a different region, does no harm.
 69 
 70 class OtherRegionsTable {


 71   G1CollectedHeap* _g1h;
 72   Mutex*           _m;
 73 
<span class="line-added"> 74   size_t volatile _num_occupied;</span>
<span class="line-added"> 75 </span>
 76   // These are protected by &quot;_m&quot;.
 77   CHeapBitMap _coarse_map;
 78   size_t      _n_coarse_entries;
 79   static jint _n_coarsenings;
 80 
 81   PerRegionTable** _fine_grain_regions;
 82   size_t           _n_fine_entries;
 83 
 84   // The fine grain remembered sets are doubly linked together using
 85   // their &#39;next&#39; and &#39;prev&#39; fields.
 86   // This allows fast bulk freeing of all the fine grain remembered
 87   // set entries, and fast finding of all of them without iterating
 88   // over the _fine_grain_regions table.
 89   PerRegionTable * _first_all_fine_prts;
 90   PerRegionTable * _last_all_fine_prts;
 91 
 92   // Used to sample a subset of the fine grain PRTs to determine which
 93   // PRT to evict and coarsen.
 94   size_t        _fine_eviction_start;
 95   static size_t _fine_eviction_stride;
 96   static size_t _fine_eviction_sample_size;
 97 
 98   SparsePRT   _sparse_table;
 99 
100   // These are static after init.
101   static size_t _max_fine_entries;
102   static size_t _mod_max_fine_entries_mask;
103 
104   // Requires &quot;prt&quot; to be the first element of the bucket list appropriate
105   // for &quot;hr&quot;.  If this list contains an entry for &quot;hr&quot;, return it,
106   // otherwise return &quot;NULL&quot;.
107   PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;
108 
109   // Find, delete, and return a candidate PerRegionTable, if any exists,
110   // adding the deleted region to the coarse bitmap.  Requires the caller
111   // to hold _m, and the fine-grain table to be full.
<span class="line-modified">112   PerRegionTable* delete_region_table(size_t&amp; added_by_deleted);</span>
113 
114   // link/add the given fine grain remembered set into the &quot;all&quot; list
115   void link_to_all(PerRegionTable * prt);
116   // unlink/remove the given fine grain remembered set into the &quot;all&quot; list
117   void unlink_from_all(PerRegionTable * prt);
118 
119   bool contains_reference_locked(OopOrNarrowOopStar from) const;
120 




121 public:
122   // Create a new remembered set. The given mutex is used to ensure consistency.
123   OtherRegionsTable(Mutex* m);
124 
<span class="line-added">125   template &lt;class Closure&gt;</span>
<span class="line-added">126   void iterate(Closure&amp; v);</span>
<span class="line-added">127 </span>
128   // Returns the card index of the given within_region pointer relative to the bottom
129   // of the given heap region.
130   static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);
131   // Adds the reference from &quot;from to this remembered set.
132   void add_reference(OopOrNarrowOopStar from, uint tid);
133 
134   // Returns whether the remembered set contains the given reference.
135   bool contains_reference(OopOrNarrowOopStar from) const;
136 
137   // Returns whether this remembered set (and all sub-sets) have an occupancy
138   // that is less or equal than the given occupancy.
139   bool occupancy_less_or_equal_than(size_t limit) const;
140 
141   // Returns whether this remembered set (and all sub-sets) does not contain any entry.
142   bool is_empty() const;
143 
144   // Returns the number of cards contained in this remembered set.
145   size_t occupied() const;
146 
147   static jint n_coarsenings() { return _n_coarsenings; }
148 
149   // Returns size of the actual remembered set containers in bytes.
150   size_t mem_size() const;
151   // Returns the size of static data in bytes.
152   static size_t static_mem_size();
153   // Returns the size of the free list content in bytes.
154   static size_t fl_mem_size();
155 
156   // Clear the entire contents of this remembered set.
157   void clear();
158 };
159 
<span class="line-added">160 class PerRegionTable: public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added">161   friend class OtherRegionsTable;</span>
<span class="line-added">162 </span>
<span class="line-added">163   HeapRegion*     _hr;</span>
<span class="line-added">164   CHeapBitMap     _bm;</span>
<span class="line-added">165   jint            _occupied;</span>
<span class="line-added">166 </span>
<span class="line-added">167   // next pointer for free/allocated &#39;all&#39; list</span>
<span class="line-added">168   PerRegionTable* _next;</span>
<span class="line-added">169 </span>
<span class="line-added">170   // prev pointer for the allocated &#39;all&#39; list</span>
<span class="line-added">171   PerRegionTable* _prev;</span>
<span class="line-added">172 </span>
<span class="line-added">173   // next pointer in collision list</span>
<span class="line-added">174   PerRegionTable * _collision_list_next;</span>
<span class="line-added">175 </span>
<span class="line-added">176   // Global free list of PRTs</span>
<span class="line-added">177   static PerRegionTable* volatile _free_list;</span>
<span class="line-added">178 </span>
<span class="line-added">179 protected:</span>
<span class="line-added">180   PerRegionTable(HeapRegion* hr) :</span>
<span class="line-added">181     _hr(hr),</span>
<span class="line-added">182     _bm(HeapRegion::CardsPerRegion, mtGC),</span>
<span class="line-added">183     _occupied(0),</span>
<span class="line-added">184     _next(NULL), _prev(NULL),</span>
<span class="line-added">185     _collision_list_next(NULL)</span>
<span class="line-added">186   {}</span>
<span class="line-added">187 </span>
<span class="line-added">188 public:</span>
<span class="line-added">189   // We need access in order to union things into the base table.</span>
<span class="line-added">190   BitMap* bm() { return &amp;_bm; }</span>
<span class="line-added">191 </span>
<span class="line-added">192   HeapRegion* hr() const { return Atomic::load_acquire(&amp;_hr); }</span>
<span class="line-added">193 </span>
<span class="line-added">194   jint occupied() const {</span>
<span class="line-added">195     return _occupied;</span>
<span class="line-added">196   }</span>
<span class="line-added">197 </span>
<span class="line-added">198   void init(HeapRegion* hr, bool clear_links_to_all_list);</span>
<span class="line-added">199 </span>
<span class="line-added">200   inline bool add_reference(OopOrNarrowOopStar from);</span>
<span class="line-added">201 </span>
<span class="line-added">202   inline bool add_card(CardIdx_t from_card_index);</span>
<span class="line-added">203 </span>
<span class="line-added">204   // (Destructively) union the bitmap of the current table into the given</span>
<span class="line-added">205   // bitmap (which is assumed to be of the same size.)</span>
<span class="line-added">206   void union_bitmap_into(BitMap* bm) {</span>
<span class="line-added">207     bm-&gt;set_union(_bm);</span>
<span class="line-added">208   }</span>
<span class="line-added">209 </span>
<span class="line-added">210   // Mem size in bytes.</span>
<span class="line-added">211   size_t mem_size() const {</span>
<span class="line-added">212     return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;</span>
<span class="line-added">213   }</span>
<span class="line-added">214 </span>
<span class="line-added">215   // Requires &quot;from&quot; to be in &quot;hr()&quot;.</span>
<span class="line-added">216   bool contains_reference(OopOrNarrowOopStar from) const {</span>
<span class="line-added">217     assert(hr()-&gt;is_in_reserved(from), &quot;Precondition.&quot;);</span>
<span class="line-added">218     size_t card_ind = pointer_delta(from, hr()-&gt;bottom(),</span>
<span class="line-added">219                                     G1CardTable::card_size);</span>
<span class="line-added">220     return _bm.at(card_ind);</span>
<span class="line-added">221   }</span>
<span class="line-added">222 </span>
<span class="line-added">223   // Bulk-free the PRTs from prt to last, assumes that they are</span>
<span class="line-added">224   // linked together using their _next field.</span>
<span class="line-added">225   static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {</span>
<span class="line-added">226     while (true) {</span>
<span class="line-added">227       PerRegionTable* fl = _free_list;</span>
<span class="line-added">228       last-&gt;set_next(fl);</span>
<span class="line-added">229       PerRegionTable* res = Atomic::cmpxchg(&amp;_free_list, fl, prt);</span>
<span class="line-added">230       if (res == fl) {</span>
<span class="line-added">231         return;</span>
<span class="line-added">232       }</span>
<span class="line-added">233     }</span>
<span class="line-added">234     ShouldNotReachHere();</span>
<span class="line-added">235   }</span>
<span class="line-added">236 </span>
<span class="line-added">237   static void free(PerRegionTable* prt) {</span>
<span class="line-added">238     bulk_free(prt, prt);</span>
<span class="line-added">239   }</span>
<span class="line-added">240 </span>
<span class="line-added">241   // Returns an initialized PerRegionTable instance.</span>
<span class="line-added">242   static PerRegionTable* alloc(HeapRegion* hr);</span>
<span class="line-added">243 </span>
<span class="line-added">244   PerRegionTable* next() const { return _next; }</span>
<span class="line-added">245   void set_next(PerRegionTable* next) { _next = next; }</span>
<span class="line-added">246   PerRegionTable* prev() const { return _prev; }</span>
<span class="line-added">247   void set_prev(PerRegionTable* prev) { _prev = prev; }</span>
<span class="line-added">248 </span>
<span class="line-added">249   // Accessor and Modification routines for the pointer for the</span>
<span class="line-added">250   // singly linked collision list that links the PRTs within the</span>
<span class="line-added">251   // OtherRegionsTable::_fine_grain_regions hash table.</span>
<span class="line-added">252   //</span>
<span class="line-added">253   // It might be useful to also make the collision list doubly linked</span>
<span class="line-added">254   // to avoid iteration over the collisions list during scrubbing/deletion.</span>
<span class="line-added">255   // OTOH there might not be many collisions.</span>
<span class="line-added">256 </span>
<span class="line-added">257   PerRegionTable* collision_list_next() const {</span>
<span class="line-added">258     return _collision_list_next;</span>
<span class="line-added">259   }</span>
<span class="line-added">260 </span>
<span class="line-added">261   void set_collision_list_next(PerRegionTable* next) {</span>
<span class="line-added">262     _collision_list_next = next;</span>
<span class="line-added">263   }</span>
<span class="line-added">264 </span>
<span class="line-added">265   PerRegionTable** collision_list_next_addr() {</span>
<span class="line-added">266     return &amp;_collision_list_next;</span>
<span class="line-added">267   }</span>
<span class="line-added">268 </span>
<span class="line-added">269   static size_t fl_mem_size() {</span>
<span class="line-added">270     PerRegionTable* cur = _free_list;</span>
<span class="line-added">271     size_t res = 0;</span>
<span class="line-added">272     while (cur != NULL) {</span>
<span class="line-added">273       res += cur-&gt;mem_size();</span>
<span class="line-added">274       cur = cur-&gt;next();</span>
<span class="line-added">275     }</span>
<span class="line-added">276     return res;</span>
<span class="line-added">277   }</span>
<span class="line-added">278 </span>
<span class="line-added">279   static void test_fl_mem_size();</span>
<span class="line-added">280 };</span>
<span class="line-added">281 </span>
282 class HeapRegionRemSet : public CHeapObj&lt;mtGC&gt; {
283   friend class VMStructs;

284 
285 private:
286   G1BlockOffsetTable* _bot;
287 
288   // A set of code blobs (nmethods) whose code contains pointers into
289   // the region that owns this RSet.
290   G1CodeRootSet _code_roots;
291 
292   Mutex _m;
293 
294   OtherRegionsTable _other_regions;
295 
296   HeapRegion* _hr;
297 
298   void clear_fcc();
299 
300 public:
301   HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);
302 
<span class="line-added">303   // Setup sparse and fine-grain tables sizes.</span>
304   static void setup_remset_size();
305 




306   bool is_empty() const {
<span class="line-modified">307     return (strong_code_roots_list_length() == 0) &amp;&amp; _other_regions.is_empty();</span>
308   }
309 
310   bool occupancy_less_or_equal_than(size_t occ) const {
311     return (strong_code_roots_list_length() == 0) &amp;&amp; _other_regions.occupancy_less_or_equal_than(occ);
312   }
313 
<span class="line-added">314   // For each PRT in the card (remembered) set call one of the following methods</span>
<span class="line-added">315   // of the given closure:</span>
<span class="line-added">316   //</span>
<span class="line-added">317   // set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs</span>
<span class="line-added">318   // set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs</span>
<span class="line-added">319   // set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs</span>
<span class="line-added">320   template &lt;class Closure&gt;</span>
<span class="line-added">321   inline void iterate_prts(Closure&amp; cl);</span>
<span class="line-added">322 </span>
323   size_t occupied() {




324     return _other_regions.occupied();
325   }
326 
327   static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }
328 
329 private:
330   enum RemSetState {
331     Untracked,
332     Updating,
333     Complete
334   };
335 
336   RemSetState _state;
337 
338   static const char* _state_strings[];
339   static const char* _short_state_strings[];
340 public:
341 
342   const char* get_state_str() const { return _state_strings[_state]; }
343   const char* get_short_state_str() const { return _short_state_strings[_state]; }
</pre>
<hr />
<pre>
349   void set_state_empty() {
350     guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), &quot;Should only set to Untracked during safepoint but is %s.&quot;, get_state_str());
351     if (_state == Untracked) {
352       return;
353     }
354     clear_fcc();
355     _state = Untracked;
356   }
357 
358   void set_state_updating() {
359     guarantee(SafepointSynchronize::is_at_safepoint() &amp;&amp; !is_tracked(), &quot;Should only set to Updating from Untracked during safepoint but is %s&quot;, get_state_str());
360     clear_fcc();
361     _state = Updating;
362   }
363 
364   void set_state_complete() {
365     clear_fcc();
366     _state = Complete;
367   }
368 






369   void add_reference(OopOrNarrowOopStar from, uint tid) {
370     RemSetState state = _state;
371     if (state == Untracked) {
372       return;
373     }
374 
375     uint cur_idx = _hr-&gt;hrm_index();
376     uintptr_t from_card = uintptr_t(from) &gt;&gt; CardTable::card_shift;
377 
378     if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {
379       assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the FromCardCache&quot;, p2i(from));
380       return;
381     }
382 
383     _other_regions.add_reference(from, tid);
384   }
385 
386   // The region is being reclaimed; clear its remset, and any mention of
387   // entries for this region in other remsets.
388   void clear(bool only_cardset = false);
389   void clear_locked(bool only_cardset = false);
390 
391   // The actual # of bytes this hr_remset takes up.
392   // Note also includes the strong code root set.
393   size_t mem_size() {
<span class="line-modified">394     MutexLocker x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
395     return _other_regions.mem_size()
396       // This correction is necessary because the above includes the second
397       // part.
398       + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))
399       + strong_code_roots_mem_size();
400   }
401 
402   // Returns the memory occupancy of all static data structures associated
403   // with remembered sets.
404   static size_t static_mem_size() {
405     return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();
406   }
407 
408   // Returns the memory occupancy of all free_list data structures associated
409   // with remembered sets.
410   static size_t fl_mem_size() {
411     return OtherRegionsTable::fl_mem_size();
412   }
413 
414   bool contains_reference(OopOrNarrowOopStar from) const {
</pre>
<hr />
<pre>
438     return _code_roots.contains(nm);
439   }
440 
441   // Returns the amount of memory, in bytes, currently
442   // consumed by the strong code roots.
443   size_t strong_code_roots_mem_size();
444 
445   static void invalidate_from_card_cache(uint start_idx, size_t num_regions) {
446     G1FromCardCache::invalidate(start_idx, num_regions);
447   }
448 
449 #ifndef PRODUCT
450   static void print_from_card_cache() {
451     G1FromCardCache::print();
452   }
453 
454   static void test();
455 #endif
456 };
457 


































































458 #endif // SHARE_GC_G1_HEAPREGIONREMSET_HPP
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionRemSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1BlockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 28 #include &quot;gc/g1/heapRegion.inline.hpp&quot;</span>

 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;services/memTracker.hpp&quot;
 33 
 34 
 35 
 36 //////////////////////////////////////////////////////////////////////
 37 // G1BlockOffsetTable
 38 //////////////////////////////////////////////////////////////////////
 39 
 40 G1BlockOffsetTable::G1BlockOffsetTable(MemRegion heap, G1RegionToSpaceMapper* storage) :
 41   _reserved(heap), _offset_array(NULL) {
 42 
 43   MemRegion bot_reserved = storage-&gt;reserved();
 44 
 45   _offset_array = (u_char*)bot_reserved.start();
 46 
 47   log_trace(gc, bot)(&quot;G1BlockOffsetTable::G1BlockOffsetTable: &quot;);
 48   log_trace(gc, bot)(&quot;    rs.base(): &quot; PTR_FORMAT &quot;  rs.size(): &quot; SIZE_FORMAT &quot;  rs end(): &quot; PTR_FORMAT,
 49                      p2i(bot_reserved.start()), bot_reserved.byte_size(), p2i(bot_reserved.end()));
 50 }
 51 
 52 bool G1BlockOffsetTable::is_card_boundary(HeapWord* p) const {
 53   assert(p &gt;= _reserved.start(), &quot;just checking&quot;);
 54   size_t delta = pointer_delta(p, _reserved.start());
 55   return (delta &amp; right_n_bits((int)BOTConstants::LogN_words)) == (size_t)NoBits;
 56 }
 57 
 58 #ifdef ASSERT
 59 void G1BlockOffsetTable::check_index(size_t index, const char* msg) const {
 60   assert((index) &lt; (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words),
 61          &quot;%s - index: &quot; SIZE_FORMAT &quot;, _vs.committed_size: &quot; SIZE_FORMAT,
 62          msg, (index), (_reserved.word_size() &gt;&gt; BOTConstants::LogN_words));
 63   assert(G1CollectedHeap::heap()-&gt;is_in_exact(address_for_index_raw(index)),
 64          &quot;Index &quot; SIZE_FORMAT &quot; corresponding to &quot; PTR_FORMAT
 65          &quot; (%u) is not in committed area.&quot;,
 66          (index),
 67          p2i(address_for_index_raw(index)),
 68          G1CollectedHeap::heap()-&gt;addr_to_region(address_for_index_raw(index)));
 69 }
 70 #endif // ASSERT
 71 
 72 //////////////////////////////////////////////////////////////////////
 73 // G1BlockOffsetTablePart
 74 //////////////////////////////////////////////////////////////////////
 75 
<a name="2" id="anc2"></a><span class="line-modified"> 76 G1BlockOffsetTablePart::G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr) :</span>
 77   _next_offset_threshold(NULL),
 78   _next_offset_index(0),
 79   DEBUG_ONLY(_object_can_span(false) COMMA)
 80   _bot(array),
<a name="3" id="anc3"></a><span class="line-modified"> 81   _hr(hr)</span>
 82 {
 83 }
 84 
 85 // The arguments follow the normal convention of denoting
 86 // a right-open interval: [start, end)
 87 void G1BlockOffsetTablePart:: set_remainder_to_point_to_start(HeapWord* start, HeapWord* end) {
 88 
 89   if (start &gt;= end) {
 90     // The start address is equal to the end address (or to
 91     // the right of the end address) so there are not cards
 92     // that need to be updated..
 93     return;
 94   }
 95 
 96   // Write the backskip value for each region.
 97   //
 98   //    offset
 99   //    card             2nd                       3rd
100   //     | +- 1st        |                         |
101   //     v v             v                         v
102   //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-
103   //    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...
104   //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-
105   //    11              19                        75
106   //      12
107   //
108   //    offset card is the card that points to the start of an object
109   //      x - offset value of offset card
110   //    1st - start of first logarithmic region
111   //      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1
112   //    2nd - start of second logarithmic region
113   //      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8
114   //    3rd - start of third logarithmic region
115   //      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64
116   //
117   //    integer below the block offset entry is an example of
118   //    the index of the entry
119   //
120   //    Given an address,
121   //      Find the index for the address
122   //      Find the block offset table entry
123   //      Convert the entry to a back slide
124   //        (e.g., with today&#39;s, offset = 0x81 =&gt;
125   //          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8
126   //      Move back N (e.g., 8) entries and repeat with the
127   //        value of the new entry
128   //
129   size_t start_card = _bot-&gt;index_for(start);
130   size_t end_card = _bot-&gt;index_for(end-1);
131   assert(start ==_bot-&gt;address_for_index(start_card), &quot;Precondition&quot;);
132   assert(end ==_bot-&gt;address_for_index(end_card)+BOTConstants::N_words, &quot;Precondition&quot;);
133   set_remainder_to_point_to_start_incl(start_card, end_card); // closed interval
134 }
135 
136 // Unlike the normal convention in this code, the argument here denotes
137 // a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()
138 // above.
139 void G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card) {
140   if (start_card &gt; end_card) {
141     return;
142   }
<a name="4" id="anc4"></a><span class="line-modified">143   assert(start_card &gt; _bot-&gt;index_for(_hr-&gt;bottom()), &quot;Cannot be first card&quot;);</span>
144   assert(_bot-&gt;offset_array(start_card-1) &lt;= BOTConstants::N_words,
145          &quot;Offset card has an unexpected value&quot;);
146   size_t start_card_for_region = start_card;
147   u_char offset = max_jubyte;
148   for (uint i = 0; i &lt; BOTConstants::N_powers; i++) {
149     // -1 so that the the card with the actual offset is counted.  Another -1
150     // so that the reach ends in this region and not at the start
151     // of the next.
152     size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);
153     offset = BOTConstants::N_words + i;
154     if (reach &gt;= end_card) {
155       _bot-&gt;set_offset_array(start_card_for_region, end_card, offset);
156       start_card_for_region = reach + 1;
157       break;
158     }
159     _bot-&gt;set_offset_array(start_card_for_region, reach, offset);
160     start_card_for_region = reach + 1;
161   }
162   assert(start_card_for_region &gt; end_card, &quot;Sanity check&quot;);
163   DEBUG_ONLY(check_all_cards(start_card, end_card);)
164 }
165 
166 // The card-interval [start_card, end_card] is a closed interval; this
167 // is an expensive check -- use with care and only under protection of
168 // suitable flag.
169 void G1BlockOffsetTablePart::check_all_cards(size_t start_card, size_t end_card) const {
170 
171   if (end_card &lt; start_card) {
172     return;
173   }
174   guarantee(_bot-&gt;offset_array(start_card) == BOTConstants::N_words, &quot;Wrong value in second card&quot;);
175   for (size_t c = start_card + 1; c &lt;= end_card; c++ /* yeah! */) {
176     u_char entry = _bot-&gt;offset_array(c);
177     if (c - start_card &gt; BOTConstants::power_to_cards_back(1)) {
178       guarantee(entry &gt; BOTConstants::N_words,
179                 &quot;Should be in logarithmic region - &quot;
180                 &quot;entry: %u, &quot;
181                 &quot;_array-&gt;offset_array(c): %u, &quot;
182                 &quot;N_words: %u&quot;,
183                 (uint)entry, (uint)_bot-&gt;offset_array(c), BOTConstants::N_words);
184     }
185     size_t backskip = BOTConstants::entry_to_cards_back(entry);
186     size_t landing_card = c - backskip;
187     guarantee(landing_card &gt;= (start_card - 1), &quot;Inv&quot;);
188     if (landing_card &gt;= start_card) {
189       guarantee(_bot-&gt;offset_array(landing_card) &lt;= entry,
190                 &quot;Monotonicity - landing_card offset: %u, &quot;
191                 &quot;entry: %u&quot;,
192                 (uint)_bot-&gt;offset_array(landing_card), (uint)entry);
193     } else {
194       guarantee(landing_card == start_card - 1, &quot;Tautology&quot;);
195       // Note that N_words is the maximum offset value
196       guarantee(_bot-&gt;offset_array(landing_card) &lt;= BOTConstants::N_words,
197                 &quot;landing card offset: %u, &quot;
198                 &quot;N_words: %u&quot;,
199                 (uint)_bot-&gt;offset_array(landing_card), (uint)BOTConstants::N_words);
200     }
201   }
202 }
203 
204 HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_slow(HeapWord* q,
205                                                                         HeapWord* n,
206                                                                         const void* addr) {
207   // We&#39;re not in the normal case.  We need to handle an important subcase
208   // here: LAB allocation.  An allocation previously recorded in the
209   // offset table was actually a lab allocation, and was divided into
210   // several objects subsequently.  Fix this situation as we answer the
211   // query, by updating entries as we cross them.
212 
213   // If the fist object&#39;s end q is at the card boundary. Start refining
214   // with the corresponding card (the value of the entry will be basically
215   // set to 0). If the object crosses the boundary -- start from the next card.
216   size_t n_index = _bot-&gt;index_for(n);
217   size_t next_index = _bot-&gt;index_for(n) + !_bot-&gt;is_card_boundary(n);
218   // Calculate a consistent next boundary.  If &quot;n&quot; is not at the boundary
219   // already, step to the boundary.
220   HeapWord* next_boundary = _bot-&gt;address_for_index(n_index) +
221                             (n_index == next_index ? 0 : BOTConstants::N_words);
222   assert(next_boundary &lt;= _bot-&gt;_reserved.end(),
223          &quot;next_boundary is beyond the end of the covered region &quot;
224          &quot; next_boundary &quot; PTR_FORMAT &quot; _array-&gt;_end &quot; PTR_FORMAT,
225          p2i(next_boundary), p2i(_bot-&gt;_reserved.end()));
<a name="5" id="anc5"></a><span class="line-modified">226   if (addr &gt;= _hr-&gt;top()) return _hr-&gt;top();</span>
227   while (next_boundary &lt; addr) {
228     while (n &lt;= next_boundary) {
229       q = n;
230       oop obj = oop(q);
231       if (obj-&gt;klass_or_null_acquire() == NULL) return q;
232       n += block_size(q);
233     }
234     assert(q &lt;= next_boundary &amp;&amp; n &gt; next_boundary, &quot;Consequence of loop&quot;);
235     // [q, n) is the block that crosses the boundary.
236     alloc_block_work(&amp;next_boundary, &amp;next_index, q, n);
237   }
238   return forward_to_block_containing_addr_const(q, n, addr);
239 }
240 
241 //
242 //              threshold_
243 //              |   _index_
244 //              v   v
245 //      +-------+-------+-------+-------+-------+
246 //      | i-1   |   i   | i+1   | i+2   | i+3   |
247 //      +-------+-------+-------+-------+-------+
248 //       ( ^    ]
249 //         block-start
250 //
251 void G1BlockOffsetTablePart::alloc_block_work(HeapWord** threshold_, size_t* index_,
252                                               HeapWord* blk_start, HeapWord* blk_end) {
253   // For efficiency, do copy-in/copy-out.
254   HeapWord* threshold = *threshold_;
255   size_t    index = *index_;
256 
257   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
258          &quot;phantom block&quot;);
259   assert(blk_end &gt; threshold, &quot;should be past threshold&quot;);
260   assert(blk_start &lt;= threshold, &quot;blk_start should be at or before threshold&quot;);
261   assert(pointer_delta(threshold, blk_start) &lt;= BOTConstants::N_words,
262          &quot;offset should be &lt;= BlockOffsetSharedArray::N&quot;);
263   assert(G1CollectedHeap::heap()-&gt;is_in_reserved(blk_start),
264          &quot;reference must be into the heap&quot;);
265   assert(G1CollectedHeap::heap()-&gt;is_in_reserved(blk_end-1),
266          &quot;limit must be within the heap&quot;);
267   assert(threshold == _bot-&gt;_reserved.start() + index*BOTConstants::N_words,
268          &quot;index must agree with threshold&quot;);
269 
270   DEBUG_ONLY(size_t orig_index = index;)
271 
272   // Mark the card that holds the offset into the block.  Note
273   // that _next_offset_index and _next_offset_threshold are not
274   // updated until the end of this method.
275   _bot-&gt;set_offset_array(index, threshold, blk_start);
276 
277   // We need to now mark the subsequent cards that this blk spans.
278 
279   // Index of card on which blk ends.
280   size_t end_index   = _bot-&gt;index_for(blk_end - 1);
281 
282   // Are there more cards left to be updated?
283   if (index + 1 &lt;= end_index) {
284     HeapWord* rem_st  = _bot-&gt;address_for_index(index + 1);
285     // Calculate rem_end this way because end_index
286     // may be the last valid index in the covered region.
287     HeapWord* rem_end = _bot-&gt;address_for_index(end_index) + BOTConstants::N_words;
288     set_remainder_to_point_to_start(rem_st, rem_end);
289   }
290 
291   index = end_index + 1;
292   // Calculate threshold_ this way because end_index
293   // may be the last valid index in the covered region.
294   threshold = _bot-&gt;address_for_index(end_index) + BOTConstants::N_words;
295   assert(threshold &gt;= blk_end, &quot;Incorrect offset threshold&quot;);
296 
297   // index_ and threshold_ updated here.
298   *threshold_ = threshold;
299   *index_ = index;
300 
301 #ifdef ASSERT
302   // The offset can be 0 if the block starts on a boundary.  That
303   // is checked by an assertion above.
304   size_t start_index = _bot-&gt;index_for(blk_start);
305   HeapWord* boundary = _bot-&gt;address_for_index(start_index);
306   assert((_bot-&gt;offset_array(orig_index) == 0 &amp;&amp; blk_start == boundary) ||
307          (_bot-&gt;offset_array(orig_index) &gt; 0 &amp;&amp; _bot-&gt;offset_array(orig_index) &lt;= BOTConstants::N_words),
308          &quot;offset array should have been set - &quot;
309          &quot;orig_index offset: %u, &quot;
310          &quot;blk_start: &quot; PTR_FORMAT &quot;, &quot;
311          &quot;boundary: &quot; PTR_FORMAT,
312          (uint)_bot-&gt;offset_array(orig_index),
313          p2i(blk_start), p2i(boundary));
314   for (size_t j = orig_index + 1; j &lt;= end_index; j++) {
315     assert(_bot-&gt;offset_array(j) &gt; 0 &amp;&amp;
316            _bot-&gt;offset_array(j) &lt;=
317              (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
318            &quot;offset array should have been set - &quot;
319            &quot;%u not &gt; 0 OR %u not &lt;= %u&quot;,
320            (uint) _bot-&gt;offset_array(j),
321            (uint) _bot-&gt;offset_array(j),
322            (uint) (BOTConstants::N_words+BOTConstants::N_powers-1));
323   }
324 #endif
325 }
326 
327 void G1BlockOffsetTablePart::verify() const {
<a name="6" id="anc6"></a><span class="line-modified">328   assert(_hr-&gt;bottom() &lt; _hr-&gt;top(), &quot;Only non-empty regions should be verified.&quot;);</span>
<span class="line-modified">329   size_t start_card = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">330   size_t end_card = _bot-&gt;index_for(_hr-&gt;top() - 1);</span>
331 
332   for (size_t current_card = start_card; current_card &lt; end_card; current_card++) {
333     u_char entry = _bot-&gt;offset_array(current_card);
334     if (entry &lt; BOTConstants::N_words) {
335       // The entry should point to an object before the current card. Verify that
336       // it is possible to walk from that object in to the current card by just
337       // iterating over the objects following it.
338       HeapWord* card_address = _bot-&gt;address_for_index(current_card);
339       HeapWord* obj_end = card_address - entry;
340       while (obj_end &lt; card_address) {
341         HeapWord* obj = obj_end;
342         size_t obj_size = block_size(obj);
343         obj_end = obj + obj_size;
<a name="7" id="anc7"></a><span class="line-modified">344         guarantee(obj_end &gt; obj &amp;&amp; obj_end &lt;= _hr-&gt;top(),</span>
345                   &quot;Invalid object end. obj: &quot; PTR_FORMAT &quot; obj_size: &quot; SIZE_FORMAT &quot; obj_end: &quot; PTR_FORMAT &quot; top: &quot; PTR_FORMAT,
<a name="8" id="anc8"></a><span class="line-modified">346                   p2i(obj), obj_size, p2i(obj_end), p2i(_hr-&gt;top()));</span>
347       }
348     } else {
349       // Because we refine the BOT based on which cards are dirty there is not much we can verify here.
350       // We need to make sure that we are going backwards and that we don&#39;t pass the start of the
351       // corresponding heap region. But that is about all we can verify.
352       size_t backskip = BOTConstants::entry_to_cards_back(entry);
353       guarantee(backskip &gt;= 1, &quot;Must be going back at least one card.&quot;);
354 
355       size_t max_backskip = current_card - start_card;
356       guarantee(backskip &lt;= max_backskip,
357                 &quot;Going backwards beyond the start_card. start_card: &quot; SIZE_FORMAT &quot; current_card: &quot; SIZE_FORMAT &quot; backskip: &quot; SIZE_FORMAT,
358                 start_card, current_card, backskip);
359 
360       HeapWord* backskip_address = _bot-&gt;address_for_index(current_card - backskip);
<a name="9" id="anc9"></a><span class="line-modified">361       guarantee(backskip_address &gt;= _hr-&gt;bottom(),</span>
362                 &quot;Going backwards beyond bottom of the region: bottom: &quot; PTR_FORMAT &quot;, backskip_address: &quot; PTR_FORMAT,
<a name="10" id="anc10"></a><span class="line-modified">363                 p2i(_hr-&gt;bottom()), p2i(backskip_address));</span>
364     }
365   }
366 }
367 
368 #ifdef ASSERT
369 void G1BlockOffsetTablePart::set_object_can_span(bool can_span) {
370   _object_can_span = can_span;
371 }
372 #endif
373 
374 #ifndef PRODUCT
<a name="11" id="anc11"></a><span class="line-modified">375 void G1BlockOffsetTablePart::print_on(outputStream* out) {</span>
<span class="line-modified">376   size_t from_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>
<span class="line-modified">377   size_t to_index = _bot-&gt;index_for(_hr-&gt;end());</span>

378   out-&gt;print_cr(&quot;&gt;&gt; BOT for area [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;) &quot;
379                 &quot;cards [&quot; SIZE_FORMAT &quot;,&quot; SIZE_FORMAT &quot;)&quot;,
<a name="12" id="anc12"></a><span class="line-modified">380                 p2i(_hr-&gt;bottom()), p2i(_hr-&gt;end()), from_index, to_index);</span>
381   for (size_t i = from_index; i &lt; to_index; ++i) {
382     out-&gt;print_cr(&quot;  entry &quot; SIZE_FORMAT_W(8) &quot; | &quot; PTR_FORMAT &quot; : %3u&quot;,
383                   i, p2i(_bot-&gt;address_for_index(i)),
384                   (uint) _bot-&gt;offset_array(i));
385   }
386   out-&gt;print_cr(&quot;  next offset threshold: &quot; PTR_FORMAT, p2i(_next_offset_threshold));
387   out-&gt;print_cr(&quot;  next offset index:     &quot; SIZE_FORMAT, _next_offset_index);
388 }
389 #endif // !PRODUCT
390 
391 HeapWord* G1BlockOffsetTablePart::initialize_threshold_raw() {
<a name="13" id="anc13"></a><span class="line-modified">392   _next_offset_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>


393   _next_offset_index++;
394   _next_offset_threshold =
395     _bot-&gt;address_for_index_raw(_next_offset_index);
396   return _next_offset_threshold;
397 }
398 
399 void G1BlockOffsetTablePart::zero_bottom_entry_raw() {
<a name="14" id="anc14"></a><span class="line-modified">400   size_t bottom_index = _bot-&gt;index_for_raw(_hr-&gt;bottom());</span>
<span class="line-modified">401   assert(_bot-&gt;address_for_index_raw(bottom_index) == _hr-&gt;bottom(),</span>


402          &quot;Precondition of call&quot;);
403   _bot-&gt;set_offset_array_raw(bottom_index, 0);
404 }
405 
406 HeapWord* G1BlockOffsetTablePart::initialize_threshold() {
<a name="15" id="anc15"></a><span class="line-modified">407   _next_offset_index = _bot-&gt;index_for(_hr-&gt;bottom());</span>


408   _next_offset_index++;
409   _next_offset_threshold =
410     _bot-&gt;address_for_index(_next_offset_index);
411   return _next_offset_threshold;
412 }
413 
414 void G1BlockOffsetTablePart::set_for_starts_humongous(HeapWord* obj_top, size_t fill_size) {
415   // The first BOT entry should have offset 0.
416   reset_bot();
<a name="16" id="anc16"></a><span class="line-modified">417   alloc_block(_hr-&gt;bottom(), obj_top);</span>
418   if (fill_size &gt; 0) {
419     alloc_block(obj_top, fill_size);
420   }
421 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1RootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;aot/aotLoader.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
 32 #include &quot;gc/g1/g1CodeBlobClosure.hpp&quot;
 33 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 34 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 35 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
 36 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 37 #include &quot;gc/g1/g1Policy.hpp&quot;
 38 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 39 #include &quot;gc/g1/g1RootProcessor.hpp&quot;
 40 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 41 #include &quot;gc/shared/oopStorageParState.hpp&quot;</span>
 42 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 43 #include &quot;memory/allocation.inline.hpp&quot;
<a name="2" id="anc2"></a>
 44 #include &quot;runtime/mutex.hpp&quot;
 45 #include &quot;services/management.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
<a name="3" id="anc3"></a><span class="line-removed"> 48 void G1RootProcessor::worker_has_discovered_all_strong_classes() {</span>
<span class="line-removed"> 49   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   uint new_value = (uint)Atomic::add(1, &amp;_n_workers_discovered_strong_classes);</span>
<span class="line-removed"> 52   if (new_value == n_workers()) {</span>
<span class="line-removed"> 53     // This thread is last. Notify the others.</span>
<span class="line-removed"> 54     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 55     _lock.notify_all();</span>
<span class="line-removed"> 56   }</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
<span class="line-removed"> 59 void G1RootProcessor::wait_until_all_strong_classes_discovered() {</span>
<span class="line-removed"> 60   assert(ClassUnloadingWithConcurrentMark, &quot;Currently only needed when doing G1 Class Unloading&quot;);</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62   if ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="line-removed"> 63     MonitorLockerEx ml(&amp;_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 64     while ((uint)_n_workers_discovered_strong_classes != n_workers()) {</span>
<span class="line-removed"> 65       _lock.wait(Mutex::_no_safepoint_check_flag, 0, false);</span>
<span class="line-removed"> 66     }</span>
<span class="line-removed"> 67   }</span>
<span class="line-removed"> 68 }</span>
<span class="line-removed"> 69 </span>
 70 G1RootProcessor::G1RootProcessor(G1CollectedHeap* g1h, uint n_workers) :
 71     _g1h(g1h),
 72     _process_strong_tasks(G1RP_PS_NumElements),
<a name="4" id="anc4"></a><span class="line-modified"> 73     _srs(n_workers),</span>
<span class="line-removed"> 74     _par_state_string(StringTable::weak_storage()),</span>
<span class="line-removed"> 75     _lock(Mutex::leaf, &quot;G1 Root Scanning barrier lock&quot;, false, Monitor::_safepoint_check_never),</span>
<span class="line-removed"> 76     _n_workers_discovered_strong_classes(0) {}</span>
 77 
<a name="5" id="anc5"></a><span class="line-modified"> 78 void G1RootProcessor::evacuate_roots(G1ParScanThreadState* pss, uint worker_i) {</span>
 79   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
 80 
<a name="6" id="anc6"></a><span class="line-modified"> 81   G1EvacPhaseTimesTracker timer(phase_times, pss, G1GCPhaseTimes::ExtRootScan, worker_i);</span>
 82 
 83   G1EvacuationRootClosures* closures = pss-&gt;closures();
<a name="7" id="anc7"></a><span class="line-modified"> 84   process_java_roots(closures, phase_times, worker_i);</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86   // This is the point where this worker thread will not find more strong CLDs/nmethods.</span>
<span class="line-removed"> 87   // Report this so G1 can synchronize the strong and weak CLDs/nmethods processing.</span>
<span class="line-removed"> 88   if (closures-&gt;trace_metadata()) {</span>
<span class="line-removed"> 89     worker_has_discovered_all_strong_classes();</span>
<span class="line-removed"> 90   }</span>
 91 
<a name="8" id="anc8"></a><span class="line-modified"> 92   process_vm_roots(closures, phase_times, worker_i);</span>
 93 
 94   {
 95     // Now the CM ref_processor roots.
<a name="9" id="anc9"></a><span class="line-modified"> 96     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CMRefRoots, worker_i);</span>
 97     if (_process_strong_tasks.try_claim_task(G1RP_PS_refProcessor_oops_do)) {
 98       // We need to treat the discovered reference lists of the
 99       // concurrent mark ref processor as roots and keep entries
100       // (which are added by the marking threads) on them live
101       // until they can be processed at the end of marking.
102       _g1h-&gt;ref_processor_cm()-&gt;weak_oops_do(closures-&gt;strong_oops());
103     }
104   }
105 
<a name="10" id="anc10"></a><span class="line-removed">106   if (closures-&gt;trace_metadata()) {</span>
<span class="line-removed">107     {</span>
<span class="line-removed">108       G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WaitForStrongCLD, worker_i);</span>
<span class="line-removed">109       // Barrier to make sure all workers passed</span>
<span class="line-removed">110       // the strong CLD and strong nmethods phases.</span>
<span class="line-removed">111       wait_until_all_strong_classes_discovered();</span>
<span class="line-removed">112     }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114     // Now take the complement of the strong CLDs.</span>
<span class="line-removed">115     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::WeakCLDRoots, worker_i);</span>
<span class="line-removed">116     assert(closures-&gt;second_pass_weak_clds() != NULL, &quot;Should be non-null if we are tracing metadata.&quot;);</span>
<span class="line-removed">117     ClassLoaderDataGraph::roots_cld_do(NULL, closures-&gt;second_pass_weak_clds());</span>
<span class="line-removed">118   } else {</span>
<span class="line-removed">119     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WaitForStrongCLD, worker_i, 0.0);</span>
<span class="line-removed">120     phase_times-&gt;record_time_secs(G1GCPhaseTimes::WeakCLDRoots, worker_i, 0.0);</span>
<span class="line-removed">121     assert(closures-&gt;second_pass_weak_clds() == NULL, &quot;Should be null if not tracing metadata.&quot;);</span>
<span class="line-removed">122   }</span>
<span class="line-removed">123 </span>
<span class="line-removed">124   // During conc marking we have to filter the per-thread SATB buffers</span>
<span class="line-removed">125   // to make sure we remove any oops into the CSet (which will show up</span>
<span class="line-removed">126   // as implicitly live).</span>
<span class="line-removed">127   {</span>
<span class="line-removed">128     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SATBFiltering, worker_i);</span>
<span class="line-removed">129     if (_process_strong_tasks.try_claim_task(G1RP_PS_filter_satb_buffers) &amp;&amp; _g1h-&gt;collector_state()-&gt;mark_or_rebuild_in_progress()) {</span>
<span class="line-removed">130       G1BarrierSet::satb_mark_queue_set().filter_thread_buffers();</span>
<span class="line-removed">131     }</span>
<span class="line-removed">132   }</span>
<span class="line-removed">133 </span>
134   _process_strong_tasks.all_tasks_completed(n_workers());
135 }
136 
137 // Adaptor to pass the closures to the strong roots in the VM.
138 class StrongRootsClosures : public G1RootClosures {
139   OopClosure* _roots;
140   CLDClosure* _clds;
141   CodeBlobClosure* _blobs;
142 public:
143   StrongRootsClosures(OopClosure* roots, CLDClosure* clds, CodeBlobClosure* blobs) :
144       _roots(roots), _clds(clds), _blobs(blobs) {}
145 
146   OopClosure* weak_oops()   { return NULL; }
147   OopClosure* strong_oops() { return _roots; }
148 
149   CLDClosure* weak_clds()        { return NULL; }
150   CLDClosure* strong_clds()      { return _clds; }
151 
152   CodeBlobClosure* strong_codeblobs() { return _blobs; }
153 };
154 
155 void G1RootProcessor::process_strong_roots(OopClosure* oops,
156                                            CLDClosure* clds,
157                                            CodeBlobClosure* blobs) {
158   StrongRootsClosures closures(oops, clds, blobs);
159 
160   process_java_roots(&amp;closures, NULL, 0);
161   process_vm_roots(&amp;closures, NULL, 0);
162 
163   _process_strong_tasks.all_tasks_completed(n_workers());
164 }
165 
166 // Adaptor to pass the closures to all the roots in the VM.
167 class AllRootsClosures : public G1RootClosures {
168   OopClosure* _roots;
169   CLDClosure* _clds;
170 public:
171   AllRootsClosures(OopClosure* roots, CLDClosure* clds) :
172       _roots(roots), _clds(clds) {}
173 
174   OopClosure* weak_oops() { return _roots; }
175   OopClosure* strong_oops() { return _roots; }
176 
177   // By returning the same CLDClosure for both weak and strong CLDs we ensure
178   // that a single walk of the CLDG will invoke the closure on all CLDs i the
179   // system.
180   CLDClosure* weak_clds() { return _clds; }
181   CLDClosure* strong_clds() { return _clds; }
182 
183   // We don&#39;t want to visit code blobs more than once, so we return NULL for the
184   // strong case and walk the entire code cache as a separate step.
185   CodeBlobClosure* strong_codeblobs() { return NULL; }
186 };
187 
188 void G1RootProcessor::process_all_roots(OopClosure* oops,
189                                         CLDClosure* clds,
190                                         CodeBlobClosure* blobs) {
191   AllRootsClosures closures(oops, clds);
192 
193   process_java_roots(&amp;closures, NULL, 0);
194   process_vm_roots(&amp;closures, NULL, 0);
195 
196   process_code_cache_roots(blobs, NULL, 0);
197 
198   _process_strong_tasks.all_tasks_completed(n_workers());
199 }
200 
201 void G1RootProcessor::process_java_roots(G1RootClosures* closures,
202                                          G1GCPhaseTimes* phase_times,
<a name="11" id="anc11"></a><span class="line-modified">203                                          uint worker_i) {</span>
<span class="line-modified">204   // Iterating over the CLDG and the Threads are done early to allow us to</span>
<span class="line-modified">205   // first process the strong CLDs and nmethods and then, after a barrier,</span>
<span class="line-modified">206   // let the thread process the weak CLDs and nmethods.</span>













207   {
<a name="12" id="anc12"></a><span class="line-modified">208     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::CLDGRoots, worker_i);</span>
<span class="line-removed">209     if (_process_strong_tasks.try_claim_task(G1RP_PS_ClassLoaderDataGraph_oops_do)) {</span>
<span class="line-removed">210       ClassLoaderDataGraph::roots_cld_do(closures-&gt;strong_clds(), closures-&gt;weak_clds());</span>
<span class="line-removed">211     }</span>
<span class="line-removed">212   }</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   {</span>
<span class="line-removed">215     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ThreadRoots, worker_i);</span>
216     bool is_par = n_workers() &gt; 1;
217     Threads::possibly_parallel_oops_do(is_par,
218                                        closures-&gt;strong_oops(),
219                                        closures-&gt;strong_codeblobs());
220   }
<a name="13" id="anc13"></a>






221 }
222 
223 void G1RootProcessor::process_vm_roots(G1RootClosures* closures,
224                                        G1GCPhaseTimes* phase_times,
<a name="14" id="anc14"></a><span class="line-modified">225                                        uint worker_i) {</span>
226   OopClosure* strong_roots = closures-&gt;strong_oops();
227 
228   {
<a name="15" id="anc15"></a><span class="line-modified">229     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::UniverseRoots, worker_i);</span>
230     if (_process_strong_tasks.try_claim_task(G1RP_PS_Universe_oops_do)) {
231       Universe::oops_do(strong_roots);
232     }
233   }
234 
235   {
<a name="16" id="anc16"></a><span class="line-modified">236     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JNIRoots, worker_i);</span>
237     if (_process_strong_tasks.try_claim_task(G1RP_PS_JNIHandles_oops_do)) {
238       JNIHandles::oops_do(strong_roots);
239     }
240   }
241 
242   {
<a name="17" id="anc17"></a><span class="line-modified">243     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ObjectSynchronizerRoots, worker_i);</span>
244     if (_process_strong_tasks.try_claim_task(G1RP_PS_ObjectSynchronizer_oops_do)) {
245       ObjectSynchronizer::oops_do(strong_roots);
246     }
247   }
248 
249   {
<a name="18" id="anc18"></a><span class="line-modified">250     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::ManagementRoots, worker_i);</span>
251     if (_process_strong_tasks.try_claim_task(G1RP_PS_Management_oops_do)) {
252       Management::oops_do(strong_roots);
253     }
254   }
255 
256   {
<a name="19" id="anc19"></a><span class="line-modified">257     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::JVMTIRoots, worker_i);</span>
258     if (_process_strong_tasks.try_claim_task(G1RP_PS_jvmti_oops_do)) {
259       JvmtiExport::oops_do(strong_roots);
260     }
261   }
262 
263 #if INCLUDE_AOT
264   if (UseAOT) {
<a name="20" id="anc20"></a><span class="line-modified">265     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::AOTCodeRoots, worker_i);</span>
266     if (_process_strong_tasks.try_claim_task(G1RP_PS_aot_oops_do)) {
267         AOTLoader::oops_do(strong_roots);
268     }
269   }
270 #endif
271 
272   {
<a name="21" id="anc21"></a><span class="line-modified">273     G1GCParPhaseTimesTracker x(phase_times, G1GCPhaseTimes::SystemDictionaryRoots, worker_i);</span>
274     if (_process_strong_tasks.try_claim_task(G1RP_PS_SystemDictionary_oops_do)) {
275       SystemDictionary::oops_do(strong_roots);
276     }
277   }
278 }
279 
280 void G1RootProcessor::process_code_cache_roots(CodeBlobClosure* code_closure,
281                                                G1GCPhaseTimes* phase_times,
<a name="22" id="anc22"></a><span class="line-modified">282                                                uint worker_i) {</span>
283   if (_process_strong_tasks.try_claim_task(G1RP_PS_CodeCache_oops_do)) {
284     CodeCache::blobs_do(code_closure);
285   }
286 }
287 
288 uint G1RootProcessor::n_workers() const {
289   return _srs.n_threads();
290 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
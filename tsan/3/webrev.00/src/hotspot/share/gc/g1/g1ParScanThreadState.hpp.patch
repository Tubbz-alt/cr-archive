diff a/src/hotspot/share/gc/g1/g1ParScanThreadState.hpp b/src/hotspot/share/gc/g1/g1ParScanThreadState.hpp
--- a/src/hotspot/share/gc/g1/g1ParScanThreadState.hpp
+++ b/src/hotspot/share/gc/g1/g1ParScanThreadState.hpp
@@ -25,11 +25,11 @@
 #ifndef SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
 #define SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
 
 #include "gc/g1/g1CardTable.hpp"
 #include "gc/g1/g1CollectedHeap.hpp"
-#include "gc/g1/g1DirtyCardQueue.hpp"
+#include "gc/g1/g1RedirtyCardsQueue.hpp"
 #include "gc/g1/g1OopClosures.hpp"
 #include "gc/g1/g1Policy.hpp"
 #include "gc/g1/g1RemSet.hpp"
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/shared/ageTable.hpp"
@@ -43,58 +43,71 @@
 class HeapRegion;
 class outputStream;
 
 class G1ParScanThreadState : public CHeapObj<mtGC> {
   G1CollectedHeap* _g1h;
-  RefToScanQueue*  _refs;
-  G1DirtyCardQueue _dcq;
-  G1CardTable*     _ct;
+  RefToScanQueue* _refs;
+  G1RedirtyCardsQueue _rdcq;
+  G1CardTable* _ct;
   G1EvacuationRootClosures* _closures;
 
-  G1PLABAllocator*  _plab_allocator;
+  G1PLABAllocator* _plab_allocator;
 
-  AgeTable          _age_table;
-  InCSetState       _dest[InCSetState::Num];
+  AgeTable _age_table;
+  G1HeapRegionAttr _dest[G1HeapRegionAttr::Num];
   // Local tenuring threshold.
-  uint              _tenuring_threshold;
+  uint _tenuring_threshold;
   G1ScanEvacuatedObjClosure  _scanner;
 
   uint _worker_id;
 
+  // Remember the last enqueued card to avoid enqueuing the same card over and over;
+  // since we only ever scan a card once, this is sufficient.
+  size_t _last_enqueued_card;
+
   // Upper and lower threshold to start and end work queue draining.
   uint const _stack_trim_upper_threshold;
   uint const _stack_trim_lower_threshold;
 
   Tickspan _trim_ticks;
   // Map from young-age-index (0 == not young, 1 is youngest) to
   // surviving words. base is what we get back from the malloc call
   size_t* _surviving_young_words_base;
   // this points into the array, as we use the first few entries for padding
   size_t* _surviving_young_words;
-
+  // Number of elements in the array above.
+  size_t _surviving_words_length;
   // Indicates whether in the last generation (old) there is no more space
   // available for allocation.
   bool _old_gen_is_full;
 
 #define PADDING_ELEM_NUM (DEFAULT_CACHE_LINE_SIZE / sizeof(size_t))
 
-  G1DirtyCardQueue& dirty_card_queue()           { return _dcq; }
+  G1RedirtyCardsQueue& redirty_cards_queue()     { return _rdcq; }
   G1CardTable* ct()                              { return _ct; }
 
-  InCSetState dest(InCSetState original) const {
+  G1HeapRegionAttr dest(G1HeapRegionAttr original) const {
     assert(original.is_valid(),
-           "Original state invalid: " CSETSTATE_FORMAT, original.value());
-    assert(_dest[original.value()].is_valid_gen(),
-           "Dest state is invalid: " CSETSTATE_FORMAT, _dest[original.value()].value());
-    return _dest[original.value()];
+           "Original region attr invalid: %s", original.get_type_str());
+    assert(_dest[original.type()].is_valid_gen(),
+           "Dest region attr is invalid: %s", _dest[original.type()].get_type_str());
+    return _dest[original.type()];
   }
 
   size_t _num_optional_regions;
   G1OopStarChunkedList* _oops_into_optional_regions;
 
+  G1NUMA* _numa;
+
+  // Records how many object allocations happened at each node during copy to survivor.
+  // Only starts recording when log of gc+heap+numa is enabled and its data is
+  // transferred when flushed.
+  size_t* _obj_alloc_stat;
+
 public:
   G1ParScanThreadState(G1CollectedHeap* g1h,
+                       G1RedirtyCardsQueueSet* rdcqs,
                        uint worker_id,
                        size_t young_cset_length,
                        size_t optional_cset_length);
   virtual ~G1ParScanThreadState();
 
@@ -109,36 +122,42 @@
 #endif // ASSERT
 
   template <class T> void do_oop_ext(T* ref);
   template <class T> void push_on_queue(T* ref);
 
-  template <class T> void enqueue_card_if_tracked(T* p, oop o) {
+  template <class T> void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {
     assert(!HeapRegion::is_in_same_region(p, o), "Should have filtered out cross-region references already.");
     assert(!_g1h->heap_region_containing(p)->is_young(), "Should have filtered out from-young references already.");
-    if (!_g1h->heap_region_containing((HeapWord*)o)->rem_set()->is_tracked()) {
+
+#ifdef ASSERT
+    HeapRegion* const hr_obj = _g1h->heap_region_containing(o);
+    assert(region_attr.needs_remset_update() == hr_obj->rem_set()->is_tracked(),
+           "State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u",
+           BOOL_TO_STR(region_attr.needs_remset_update()),
+           BOOL_TO_STR(hr_obj->rem_set()->is_tracked()),
+           hr_obj->hrm_index());
+#endif
+    if (!region_attr.needs_remset_update()) {
       return;
     }
     size_t card_index = ct()->index_for(p);
     // If the card hasn't been added to the buffer, do it.
-    if (ct()->mark_card_deferred(card_index)) {
-      dirty_card_queue().enqueue(ct()->byte_for_index(card_index));
+    if (_last_enqueued_card != card_index) {
+      redirty_cards_queue().enqueue(ct()->byte_for_index(card_index));
+      _last_enqueued_card = card_index;
     }
   }
 
   G1EvacuationRootClosures* closures() { return _closures; }
   uint worker_id() { return _worker_id; }
 
   size_t lab_waste_words() const;
   size_t lab_undo_waste_words() const;
 
-  size_t* surviving_young_words() {
-    // We add one to hide entry 0 which accumulates surviving words for
-    // age -1 regions (i.e. non-young ones)
-    return _surviving_young_words + 1;
-  }
-
-  void flush(size_t* surviving_young_words);
+  // Pass locally gathered statistics to global state. Returns the total number of
+  // HeapWords copied.
+  size_t flush(size_t* surviving_young_words);
 
 private:
   #define G1_PARTIAL_ARRAY_MASK 0x2
 
   inline bool has_partial_array_mask(oop* ref) const {
@@ -176,44 +195,49 @@
   inline void deal_with_reference(narrowOop* ref_to_scan);
 
   inline void dispatch_reference(StarTask ref);
 
   // Tries to allocate word_sz in the PLAB of the next "generation" after trying to
-  // allocate into dest. State is the original (source) cset state for the object
-  // that is allocated for. Previous_plab_refill_failed indicates whether previously
-  // a PLAB refill into "state" failed.
+  // allocate into dest. Previous_plab_refill_failed indicates whether previous
+  // PLAB refill for the original (source) object failed.
   // Returns a non-NULL pointer if successful, and updates dest if required.
   // Also determines whether we should continue to try to allocate into the various
   // generations or just end trying to allocate.
-  HeapWord* allocate_in_next_plab(InCSetState const state,
-                                  InCSetState* dest,
+  HeapWord* allocate_in_next_plab(G1HeapRegionAttr* dest,
                                   size_t word_sz,
-                                  bool previous_plab_refill_failed);
+                                  bool previous_plab_refill_failed,
+                                  uint node_index);
 
-  inline InCSetState next_state(InCSetState const state, markOop const m, uint& age);
+  inline G1HeapRegionAttr next_region_attr(G1HeapRegionAttr const region_attr, markWord const m, uint& age);
 
-  void report_promotion_event(InCSetState const dest_state,
+  void report_promotion_event(G1HeapRegionAttr const dest_attr,
                               oop const old, size_t word_sz, uint age,
-                              HeapWord * const obj_ptr) const;
+                              HeapWord * const obj_ptr, uint node_index) const;
 
   inline bool needs_partial_trimming() const;
   inline bool is_partially_trimmed() const;
 
   inline void trim_queue_to_threshold(uint threshold);
+
+  // NUMA statistics related methods.
+  inline void initialize_numa_stats();
+  inline void flush_numa_stats();
+  inline void update_numa_stats(uint node_index);
+
 public:
-  oop copy_to_survivor_space(InCSetState const state, oop const obj, markOop const old_mark);
+  oop copy_to_survivor_space(G1HeapRegionAttr const region_attr, oop const obj, markWord const old_mark);
 
   void trim_queue();
   void trim_queue_partially();
 
   Tickspan trim_ticks() const;
   void reset_trim_ticks();
 
   inline void steal_and_trim_queue(RefToScanQueueSet *task_queues);
 
   // An attempt to evacuate "obj" has failed; take necessary steps.
-  oop handle_evacuation_failure_par(oop obj, markOop m);
+  oop handle_evacuation_failure_par(oop obj, markWord m);
 
   template <typename T>
   inline void remember_root_into_optional_region(T* p);
   template <typename T>
   inline void remember_reference_into_optional_region(T* p);
@@ -221,19 +245,21 @@
   inline G1OopStarChunkedList* oops_into_optional_region(const HeapRegion* hr);
 };
 
 class G1ParScanThreadStateSet : public StackObj {
   G1CollectedHeap* _g1h;
+  G1RedirtyCardsQueueSet* _rdcqs;
   G1ParScanThreadState** _states;
   size_t* _surviving_young_words_total;
   size_t _young_cset_length;
   size_t _optional_cset_length;
   uint _n_workers;
   bool _flushed;
 
  public:
   G1ParScanThreadStateSet(G1CollectedHeap* g1h,
+                          G1RedirtyCardsQueueSet* rdcqs,
                           uint n_workers,
                           size_t young_cset_length,
                           size_t optional_cset_length);
   ~G1ParScanThreadStateSet();
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1CollectionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &quot;gc/g1/g1HotCardCache.hpp&quot;</span>
 31 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 35 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 36 #include &quot;logging/logStream.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 37 #include &quot;runtime/orderAccess.hpp&quot;</span>
 38 #include &quot;utilities/debug.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 #include &quot;utilities/quickSort.hpp&quot;
 41 
<a name="3" id="anc3"></a><span class="line-modified"> 42 G1CollectorState* G1CollectionSet::collector_state() const {</span>
 43   return _g1h-&gt;collector_state();
 44 }
 45 
 46 G1GCPhaseTimes* G1CollectionSet::phase_times() {
 47   return _policy-&gt;phase_times();
 48 }
 49 
<a name="4" id="anc4"></a><span class="line-modified"> 50 double G1CollectionSet::predict_region_non_copy_time_ms(HeapRegion* hr) const {</span>
<span class="line-modified"> 51   return _policy-&gt;predict_region_non_copy_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
 52 }
 53 
 54 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
 55   _g1h(g1h),
 56   _policy(policy),
 57   _candidates(NULL),
 58   _eden_region_length(0),
 59   _survivor_region_length(0),
 60   _old_region_length(0),
 61   _collection_set_regions(NULL),
 62   _collection_set_cur_length(0),
 63   _collection_set_max_length(0),
<a name="5" id="anc5"></a><span class="line-modified"> 64   _num_optional_regions(0),</span>


 65   _bytes_used_before(0),
<a name="6" id="anc6"></a><span class="line-modified"> 66   _recorded_rs_length(0),</span>
 67   _inc_build_state(Inactive),
<a name="7" id="anc7"></a><span class="line-added"> 68   _inc_part_start(0),</span>
<span class="line-added"> 69   _inc_collection_set_stats(NULL),</span>
 70   _inc_bytes_used_before(0),
<a name="8" id="anc8"></a><span class="line-modified"> 71   _inc_recorded_rs_length(0),</span>
<span class="line-modified"> 72   _inc_recorded_rs_length_diff(0),</span>
<span class="line-modified"> 73   _inc_predicted_non_copy_time_ms(0.0),</span>
<span class="line-modified"> 74   _inc_predicted_non_copy_time_ms_diff(0.0) {</span>
 75 }
 76 
 77 G1CollectionSet::~G1CollectionSet() {
<a name="9" id="anc9"></a><span class="line-modified"> 78   FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-modified"> 79   FREE_C_HEAP_ARRAY(IncCollectionSetRegionStat, _inc_collection_set_stats);</span>

 80   free_optional_regions();
 81   clear_candidates();
 82 }
 83 
 84 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
 85                                           uint survivor_cset_region_length) {
 86   assert_at_safepoint_on_vm_thread();
 87 
 88   _eden_region_length     = eden_cset_region_length;
 89   _survivor_region_length = survivor_cset_region_length;
 90 
 91   assert((size_t) young_region_length() == _collection_set_cur_length,
 92          &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 93 
<a name="10" id="anc10"></a><span class="line-modified"> 94   _old_region_length = 0;</span>
<span class="line-modified"> 95   free_optional_regions();</span>
 96 }
 97 
 98 void G1CollectionSet::initialize(uint max_region_length) {
 99   guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
100   _collection_set_max_length = max_region_length;
101   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<a name="11" id="anc11"></a><span class="line-modified">102   _inc_collection_set_stats = NEW_C_HEAP_ARRAY(IncCollectionSetRegionStat, max_region_length, mtGC);</span>







103 }
104 
105 void G1CollectionSet::free_optional_regions() {
<a name="12" id="anc12"></a><span class="line-modified">106   _num_optional_regions = 0;</span>





107 }
108 
109 void G1CollectionSet::clear_candidates() {
110   delete _candidates;
111   _candidates = NULL;
112 }
113 
<a name="13" id="anc13"></a><span class="line-modified">114 void G1CollectionSet::set_recorded_rs_length(size_t rs_length) {</span>
<span class="line-modified">115   _recorded_rs_length = rs_length;</span>
116 }
117 
118 // Add the heap region at the head of the non-incremental collection set
119 void G1CollectionSet::add_old_region(HeapRegion* hr) {
120   assert_at_safepoint_on_vm_thread();
121 
<a name="14" id="anc14"></a><span class="line-modified">122   assert(_inc_build_state == Active,</span>
123          &quot;Precondition, actively building cset or adding optional later on&quot;);
124   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
125 
<a name="15" id="anc15"></a><span class="line-modified">126   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the collection set&quot;);</span>
<span class="line-modified">127   _g1h-&gt;register_old_region_with_region_attr(hr);</span>
128 
129   _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
130   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
131 
132   _bytes_used_before += hr-&gt;used();
<a name="16" id="anc16"></a><span class="line-modified">133   _recorded_rs_length += hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">134   _old_region_length++;</span>

135 
<a name="17" id="anc17"></a><span class="line-modified">136   _g1h-&gt;old_set_remove(hr);</span>
137 }
138 
139 void G1CollectionSet::add_optional_region(HeapRegion* hr) {
<a name="18" id="anc18"></a>
140   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
141   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
142 
<a name="19" id="anc19"></a><span class="line-modified">143   _g1h-&gt;register_optional_region_with_region_attr(hr);</span>
144 
<a name="20" id="anc20"></a><span class="line-modified">145   hr-&gt;set_index_in_opt_cset(_num_optional_regions++);</span>




146 }
147 
<a name="21" id="anc21"></a>
148 void G1CollectionSet::start_incremental_building() {
149   assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
150   assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
<a name="22" id="anc22"></a><span class="line-added">151 #ifdef ASSERT</span>
<span class="line-added">152   for (size_t i = 0; i &lt; _collection_set_max_length; i++) {</span>
<span class="line-added">153     _inc_collection_set_stats[i].reset();</span>
<span class="line-added">154   }</span>
<span class="line-added">155 #endif</span>
156 
157   _inc_bytes_used_before = 0;
158 
<a name="23" id="anc23"></a><span class="line-modified">159   _inc_recorded_rs_length = 0;</span>
<span class="line-modified">160   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">161   _inc_predicted_non_copy_time_ms = 0.0;</span>
<span class="line-modified">162   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
<span class="line-modified">163 </span>
<span class="line-added">164   update_incremental_marker();</span>
165 }
166 
167 void G1CollectionSet::finalize_incremental_building() {
168   assert(_inc_build_state == Active, &quot;Precondition&quot;);
169   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
170 
<a name="24" id="anc24"></a><span class="line-modified">171   // The two &quot;main&quot; fields, _inc_recorded_rs_length and</span>
<span class="line-modified">172   // _inc_predicted_non_copy_time_ms, are updated by the thread</span>
173   // that adds a new region to the CSet. Further updates by the
174   // concurrent refinement thread that samples the young RSet lengths
<a name="25" id="anc25"></a><span class="line-modified">175   // are accumulated in the *_diff fields. Here we add the diffs to</span>
176   // the &quot;main&quot; fields.
177 
<a name="26" id="anc26"></a><span class="line-modified">178   _inc_recorded_rs_length += _inc_recorded_rs_length_diff;</span>
<span class="line-modified">179   _inc_predicted_non_copy_time_ms += _inc_predicted_non_copy_time_ms_diff;</span>














180 
<a name="27" id="anc27"></a><span class="line-modified">181   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">182   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
183 }
184 
185 void G1CollectionSet::clear() {
186   assert_at_safepoint_on_vm_thread();
187   _collection_set_cur_length = 0;
<a name="28" id="anc28"></a>
188 }
189 
190 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
<a name="29" id="anc29"></a>



191   size_t len = _collection_set_cur_length;
192   OrderAccess::loadload();
<a name="30" id="anc30"></a>




193 
<a name="31" id="anc31"></a><span class="line-modified">194   for (uint i = 0; i &lt; len; i++) {</span>
<span class="line-modified">195     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[i]);</span>
196     bool result = cl-&gt;do_heap_region(r);
197     if (result) {
198       cl-&gt;set_incomplete();
199       return;
200     }
<a name="32" id="anc32"></a><span class="line-added">201   }</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 void G1CollectionSet::par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">205                                   HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">206                                   uint worker_id,</span>
<span class="line-added">207                                   uint total_workers) const {</span>
<span class="line-added">208   iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {</span>
<span class="line-added">212   assert_at_safepoint();</span>
<span class="line-added">213 </span>
<span class="line-added">214   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-added">215     HeapRegion* r = _candidates-&gt;at(i);</span>
<span class="line-added">216     bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">217     guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">218   }</span>
<span class="line-added">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">222                                                     HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">223                                                     uint worker_id,</span>
<span class="line-added">224                                                     uint total_workers) const {</span>
<span class="line-added">225   iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">229                                         HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">230                                         size_t offset,</span>
<span class="line-added">231                                         size_t length,</span>
<span class="line-added">232                                         uint worker_id,</span>
<span class="line-added">233                                         uint total_workers) const {</span>
<span class="line-added">234   assert_at_safepoint();</span>
<span class="line-added">235   if (length == 0) {</span>
<span class="line-added">236     return;</span>
<span class="line-added">237   }</span>
<span class="line-added">238 </span>
<span class="line-added">239   size_t start_pos = (worker_id * length) / total_workers;</span>
<span class="line-added">240   size_t cur_pos = start_pos;</span>
<span class="line-added">241 </span>
<span class="line-added">242   do {</span>
<span class="line-added">243     uint region_idx = _collection_set_regions[cur_pos + offset];</span>
<span class="line-added">244     if (hr_claimer == NULL || hr_claimer-&gt;claim_region(region_idx)) {</span>
<span class="line-added">245       HeapRegion* r = _g1h-&gt;region_at(region_idx);</span>
<span class="line-added">246       bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">247       guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">248     }</span>
<span class="line-added">249 </span>
250     cur_pos++;
<a name="33" id="anc33"></a><span class="line-modified">251     if (cur_pos == length) {</span>
252       cur_pos = 0;
253     }
254   } while (cur_pos != start_pos);
255 }
256 
257 void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,
258                                                      size_t new_rs_length) {
259   // Update the CSet information that is dependent on the new RS length
260   assert(hr-&gt;is_young(), &quot;Precondition&quot;);
261   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
262 
<a name="34" id="anc34"></a><span class="line-modified">263   IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>







264 
<a name="35" id="anc35"></a><span class="line-modified">265   size_t old_rs_length = stat-&gt;_rs_length;</span>
<span class="line-modified">266   assert(old_rs_length &lt;= new_rs_length,</span>
<span class="line-modified">267          &quot;Remembered set decreased (changed from &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT &quot; region %u type %s)&quot;,</span>
<span class="line-added">268          old_rs_length, new_rs_length, hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
<span class="line-added">269   size_t rs_length_diff = new_rs_length - old_rs_length;</span>
<span class="line-added">270   stat-&gt;_rs_length = new_rs_length;</span>
<span class="line-added">271   _inc_recorded_rs_length_diff += rs_length_diff;</span>
272 
<a name="36" id="anc36"></a><span class="line-modified">273   double old_non_copy_time = stat-&gt;_non_copy_time_ms;</span>
<span class="line-modified">274   assert(old_non_copy_time &gt;= 0.0, &quot;Non copy time for region %u not initialized yet, is %.3f&quot;, hr-&gt;hrm_index(), old_non_copy_time);</span>
<span class="line-modified">275   double new_non_copy_time = predict_region_non_copy_time_ms(hr);</span>
<span class="line-modified">276   double non_copy_time_ms_diff = new_non_copy_time - old_non_copy_time;</span>
277 
<a name="37" id="anc37"></a><span class="line-modified">278   stat-&gt;_non_copy_time_ms = new_non_copy_time;</span>
<span class="line-modified">279   _inc_predicted_non_copy_time_ms_diff += non_copy_time_ms_diff;</span>
280 }
281 
282 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
283   assert(hr-&gt;is_young(), &quot;invariant&quot;);
284   assert(_inc_build_state == Active, &quot;Precondition&quot;);
285 
<a name="38" id="anc38"></a>










286   // This routine is used when:
287   // * adding survivor regions to the incremental cset at the end of an
288   //   evacuation pause or
289   // * adding the current allocation region to the incremental cset
290   //   when it is retired.
291   // Therefore this routine may be called at a safepoint by the
292   // VM thread, or in-between safepoints by mutator threads (when
293   // retiring the current allocation region)
294   // We need to clear and set the cached recorded/cached collection set
295   // information in the heap region here (before the region gets added
296   // to the collection set). An individual heap region&#39;s cached values
297   // are calculated, aggregated with the policy collection set info,
298   // and cached in the heap region here (initially) and (subsequently)
299   // by the Young List sampling code.
300   // Ignore calls to this due to retirement during full gc.
301 
302   if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
303     size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<a name="39" id="anc39"></a><span class="line-modified">304     double non_copy_time = predict_region_non_copy_time_ms(hr);</span>
305 
306     // Cache the values we have added to the aggregated information
307     // in the heap region in case we have to remove this region from
308     // the incremental collection set, or it is updated by the
309     // rset sampling code
<a name="40" id="anc40"></a>

310 
<a name="41" id="anc41"></a><span class="line-modified">311     IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>
<span class="line-modified">312     stat-&gt;_rs_length = rs_length;</span>
<span class="line-added">313     stat-&gt;_non_copy_time_ms = non_copy_time;</span>
<span class="line-added">314 </span>
<span class="line-added">315     _inc_recorded_rs_length += rs_length;</span>
<span class="line-added">316     _inc_predicted_non_copy_time_ms += non_copy_time;</span>
317     _inc_bytes_used_before += hr-&gt;used();
318   }
319 
320   assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<a name="42" id="anc42"></a><span class="line-modified">321   _g1h-&gt;register_young_region_with_region_attr(hr);</span>
<span class="line-added">322 </span>
<span class="line-added">323   // We use UINT_MAX as &quot;invalid&quot; marker in verification.</span>
<span class="line-added">324   assert(_collection_set_cur_length &lt; (UINT_MAX - 1),</span>
<span class="line-added">325          &quot;Collection set is too large with &quot; SIZE_FORMAT &quot; entries&quot;, _collection_set_cur_length);</span>
<span class="line-added">326   hr-&gt;set_young_index_in_cset((uint)_collection_set_cur_length + 1);</span>
<span class="line-added">327 </span>
<span class="line-added">328   _collection_set_regions[_collection_set_cur_length] = hr-&gt;hrm_index();</span>
<span class="line-added">329   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-added">330   // update to the length field.</span>
<span class="line-added">331   OrderAccess::storestore();</span>
<span class="line-added">332   _collection_set_cur_length++;</span>
<span class="line-added">333   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
334 }
335 
336 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
337   assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
338   add_young_region_common(hr);
339 }
340 
341 void G1CollectionSet::add_eden_region(HeapRegion* hr) {
342   assert(hr-&gt;is_eden(), &quot;Must only add eden regions, but is %s&quot;, hr-&gt;get_type_str());
343   add_young_region_common(hr);
344 }
345 
346 #ifndef PRODUCT
347 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
348 public:
349   bool _valid;
<a name="43" id="anc43"></a><span class="line-modified">350 </span>
351   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
352 
353   virtual bool do_heap_region(HeapRegion* r) {
354     guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
355 
<a name="44" id="anc44"></a><span class="line-modified">356     if (!r-&gt;has_surv_rate_group()) {</span>
<span class="line-modified">357       log_error(gc, verify)(&quot;## encountered young region without surv_rate_group&quot;);</span>


358       _valid = false;
359     }
360 
<a name="45" id="anc45"></a><span class="line-modified">361     if (!r-&gt;has_valid_age_in_surv_rate()) {</span>
<span class="line-modified">362       log_error(gc, verify)(&quot;## encountered invalid age in young region&quot;);</span>
363       _valid = false;
364     }
365 
366     return false;
367   }
368 
369   bool valid() const { return _valid; }
370 };
371 
372 bool G1CollectionSet::verify_young_ages() {
373   assert_at_safepoint_on_vm_thread();
374 
375   G1VerifyYoungAgesClosure cl;
376   iterate(&amp;cl);
377 
378   if (!cl.valid()) {
379     LogStreamHandle(Error, gc, verify) log;
380     print(&amp;log);
381   }
382 
383   return cl.valid();
384 }
385 
386 class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {
387   outputStream* _st;
388 public:
389   G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }
390 
391   virtual bool do_heap_region(HeapRegion* r) {
392     assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
393     _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
394                   HR_FORMAT_PARAMS(r),
395                   p2i(r-&gt;prev_top_at_mark_start()),
396                   p2i(r-&gt;next_top_at_mark_start()),
<a name="46" id="anc46"></a><span class="line-modified">397                   r-&gt;has_surv_rate_group() ? r-&gt;age_in_surv_rate_group() : -1);</span>
398     return false;
399   }
400 };
401 
402 void G1CollectionSet::print(outputStream* st) {
403   st-&gt;print_cr(&quot;\nCollection_set:&quot;);
404 
405   G1PrintCollectionSetDetailClosure cl(st);
406   iterate(&amp;cl);
407 }
408 #endif // !PRODUCT
409 
410 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<a name="47" id="anc47"></a><span class="line-modified">411   Ticks start_time = Ticks::now();</span>
412 
413   finalize_incremental_building();
414 
415   guarantee(target_pause_time_ms &gt; 0.0,
416             &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
417 
<a name="48" id="anc48"></a><span class="line-modified">418   size_t pending_cards = _policy-&gt;pending_cards_at_gc_start() + _g1h-&gt;hot_card_cache()-&gt;num_entries();</span>


419 
<a name="49" id="anc49"></a><span class="line-modified">420   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. Pending cards: &quot; SIZE_FORMAT &quot; target pause time: %1.2fms&quot;,</span>
<span class="line-modified">421                             pending_cards, target_pause_time_ms);</span>
422 
423   // The young list is laid with the survivor regions from the previous
424   // pause are appended to the RHS of the young list, i.e.
425   //   [Newly Young Regions ++ Survivors from last pause].
426 
<a name="50" id="anc50"></a>
427   uint eden_region_length = _g1h-&gt;eden_regions_count();
<a name="51" id="anc51"></a><span class="line-added">428   uint survivor_region_length = survivors-&gt;length();</span>
429   init_region_lengths(eden_region_length, survivor_region_length);
430 
431   verify_young_cset_indices();
432 
433   // Clear the fields that point to the survivor list - they are all young now.
434   survivors-&gt;convert_to_eden();
435 
436   _bytes_used_before = _inc_bytes_used_before;
<a name="52" id="anc52"></a>



437 
438   // The number of recorded young regions is the incremental
439   // collection set&#39;s current size
<a name="53" id="anc53"></a><span class="line-modified">440   set_recorded_rs_length(_inc_recorded_rs_length);</span>






441 
<a name="54" id="anc54"></a><span class="line-modified">442   double predicted_base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-modified">443   double predicted_eden_time = _inc_predicted_non_copy_time_ms + _policy-&gt;predict_eden_copy_time_ms(eden_region_length);</span>
<span class="line-modified">444   double remaining_time_ms = MAX2(target_pause_time_ms - (predicted_base_time_ms + predicted_eden_time), 0.0);</span>


445 
<a name="55" id="anc55"></a><span class="line-modified">446   log_trace(gc, ergo, cset)(&quot;Added young regions to CSet. Eden: %u regions, Survivors: %u regions, &quot;</span>
<span class="line-modified">447                             &quot;predicted eden time: %1.2fms, predicted base time: %1.2fms, target pause time: %1.2fms, remaining time: %1.2fms&quot;,</span>
<span class="line-modified">448                             eden_region_length, survivor_region_length,</span>
<span class="line-modified">449                             predicted_eden_time, predicted_base_time_ms, target_pause_time_ms, remaining_time_ms);</span>


450 
<a name="56" id="anc56"></a><span class="line-modified">451   phase_times()-&gt;record_young_cset_choice_time_ms((Ticks::now() - start_time).seconds() * 1000.0);</span>



452 
<a name="57" id="anc57"></a><span class="line-modified">453   return remaining_time_ms;</span>



454 }
455 
456 static int compare_region_idx(const uint a, const uint b) {
457   if (a &gt; b) {
458     return 1;
459   } else if (a == b) {
460     return 0;
461   } else {
462     return -1;
463   }
464 }
465 
466 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
467   double non_young_start_time_sec = os::elapsedTime();
<a name="58" id="anc58"></a>



468 
469   if (collector_state()-&gt;in_mixed_phase()) {
470     candidates()-&gt;verify();
<a name="59" id="anc59"></a><span class="line-modified">471 </span>
<span class="line-modified">472     uint num_initial_old_regions;</span>
<span class="line-modified">473     uint num_optional_old_regions;</span>
<span class="line-modified">474 </span>
<span class="line-modified">475     _policy-&gt;calculate_old_collection_set_regions(candidates(),</span>
<span class="line-modified">476                                                   time_remaining_ms,</span>
<span class="line-modified">477                                                   num_initial_old_regions,</span>
<span class="line-modified">478                                                   num_optional_old_regions);</span>
<span class="line-modified">479 </span>
<span class="line-modified">480     // Prepare initial old regions.</span>
<span class="line-modified">481     move_candidates_to_collection_set(num_initial_old_regions);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483     // Prepare optional old regions for evacuation.</span>
<span class="line-modified">484     uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-modified">485     for (uint i = 0; i &lt; num_optional_old_regions; i++) {</span>
<span class="line-modified">486       add_optional_region(candidates()-&gt;at(candidate_idx + i));</span>


























































487     }
488 
489     candidates()-&gt;verify();
490   }
491 
492   stop_incremental_building();
493 
<a name="60" id="anc60"></a>








494   double non_young_end_time_sec = os::elapsedTime();
495   phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
496 
497   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
498 }
499 
<a name="61" id="anc61"></a><span class="line-modified">500 void G1CollectionSet::move_candidates_to_collection_set(uint num_old_candidate_regions) {</span>
<span class="line-modified">501   if (num_old_candidate_regions == 0) {</span>
<span class="line-added">502     return;</span>
<span class="line-added">503   }</span>
<span class="line-added">504   uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-added">505   for (uint i = 0; i &lt; num_old_candidate_regions; i++) {</span>
<span class="line-added">506     HeapRegion* r = candidates()-&gt;at(candidate_idx + i);</span>
<span class="line-added">507     // This potentially optional candidate region is going to be an actual collection</span>
<span class="line-added">508     // set region. Clear cset marker.</span>
<span class="line-added">509     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-added">510     add_old_region(r);</span>
<span class="line-added">511   }</span>
<span class="line-added">512   candidates()-&gt;remove(num_old_candidate_regions);</span>
<span class="line-added">513 </span>
<span class="line-added">514   candidates()-&gt;verify();</span>
515 }
516 
<a name="62" id="anc62"></a><span class="line-modified">517 void G1CollectionSet::finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {</span>
<span class="line-modified">518   double time_remaining_ms = finalize_young_part(target_pause_time_ms, survivor);</span>
<span class="line-added">519   finalize_old_part(time_remaining_ms);</span>
<span class="line-added">520 }</span>
521 
<a name="63" id="anc63"></a><span class="line-modified">522 bool G1CollectionSet::finalize_optional_for_evacuation(double remaining_pause_time) {</span>
<span class="line-modified">523   update_incremental_marker();</span>
524 
<a name="64" id="anc64"></a><span class="line-modified">525   uint num_selected_regions;</span>
<span class="line-modified">526   _policy-&gt;calculate_optional_collection_set_regions(candidates(),</span>
<span class="line-modified">527                                                      _num_optional_regions,</span>
<span class="line-modified">528                                                      remaining_pause_time,</span>
<span class="line-modified">529                                                      num_selected_regions);</span>



530 
<a name="65" id="anc65"></a><span class="line-modified">531   move_candidates_to_collection_set(num_selected_regions);</span>





532 
<a name="66" id="anc66"></a><span class="line-modified">533   _num_optional_regions -= num_selected_regions;</span>


534 
<a name="67" id="anc67"></a><span class="line-modified">535   stop_incremental_building();</span>


536 
<a name="68" id="anc68"></a><span class="line-modified">537   _g1h-&gt;verify_region_attr_remset_update();</span>










538 
<a name="69" id="anc69"></a><span class="line-modified">539   return num_selected_regions &gt; 0;</span>

540 }
541 
<a name="70" id="anc70"></a><span class="line-modified">542 void G1CollectionSet::abandon_optional_collection_set(G1ParScanThreadStateSet* pss) {</span>
<span class="line-modified">543   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-modified">544     HeapRegion* r = candidates()-&gt;at(candidates()-&gt;cur_idx() + i);</span>
<span class="line-modified">545     pss-&gt;record_unused_optional_region(r);</span>
<span class="line-modified">546     // Clear collection set marker and make sure that the remembered set information</span>
<span class="line-modified">547     // is correct as we still need it later.</span>
<span class="line-modified">548     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-modified">549     _g1h-&gt;register_region_with_region_attr(r);</span>
<span class="line-modified">550     r-&gt;clear_index_in_opt_cset();</span>



551   }
<a name="71" id="anc71"></a><span class="line-modified">552   free_optional_regions();</span>









553 
<a name="72" id="anc72"></a><span class="line-modified">554   _g1h-&gt;verify_region_attr_remset_update();</span>



555 }
556 
557 #ifdef ASSERT
558 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
559 private:
560   size_t _young_length;
<a name="73" id="anc73"></a><span class="line-modified">561   uint* _heap_region_indices;</span>
562 public:
563   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<a name="74" id="anc74"></a><span class="line-modified">564     _heap_region_indices = NEW_C_HEAP_ARRAY(uint, young_length + 1, mtGC);</span>
<span class="line-modified">565     for (size_t i = 0; i &lt; young_length + 1; i++) {</span>
<span class="line-modified">566       _heap_region_indices[i] = UINT_MAX;</span>
567     }
568   }
569   ~G1VerifyYoungCSetIndicesClosure() {
570     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
571   }
572 
573   virtual bool do_heap_region(HeapRegion* r) {
<a name="75" id="anc75"></a><span class="line-modified">574     const uint idx = r-&gt;young_index_in_cset();</span>
575 
<a name="76" id="anc76"></a><span class="line-modified">576     assert(idx &gt; 0, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">577     assert(idx &lt;= _young_length, &quot;Young cset index %u too large for region %u&quot;, idx, r-&gt;hrm_index());</span>
578 
<a name="77" id="anc77"></a><span class="line-modified">579     assert(_heap_region_indices[idx] == UINT_MAX,</span>
580            &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
581            idx, _heap_region_indices[idx], r-&gt;hrm_index());
582 
583     _heap_region_indices[idx] = r-&gt;hrm_index();
584 
585     return false;
586   }
587 };
588 
589 void G1CollectionSet::verify_young_cset_indices() const {
590   assert_at_safepoint_on_vm_thread();
591 
592   G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);
593   iterate(&amp;cl);
594 }
595 #endif
<a name="78" id="anc78"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="78" type="hidden" />
</body>
</html>
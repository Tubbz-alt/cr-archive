<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/g1/g1ConcurrentMark.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTMARK_INLINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTMARK_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
 30 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;
 31 #include &quot;gc/g1/g1ConcurrentMarkObjArrayProcessor.inline.hpp&quot;
 32 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 33 #include &quot;gc/g1/g1Policy.hpp&quot;
 34 #include &quot;gc/g1/g1RegionMarkStatsCache.inline.hpp&quot;
 35 #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
 36 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 37 #include &quot;gc/g1/heapRegion.hpp&quot;
 38 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 39 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 40 #include &quot;utilities/bitMap.inline.hpp&quot;
 41 
 42 inline bool G1CMIsAliveClosure::do_object_b(oop obj) {
 43   return !_g1h-&gt;is_obj_ill(obj);
 44 }
 45 
 46 inline bool G1CMSubjectToDiscoveryClosure::do_object_b(oop obj) {
 47   // Re-check whether the passed object is null. With ReferentBasedDiscovery the
 48   // mutator may have changed the referent&#39;s value (i.e. cleared it) between the
 49   // time the referent was determined to be potentially alive and calling this
 50   // method.
 51   if (obj == NULL) {
 52     return false;
 53   }
 54   assert(_g1h-&gt;is_in_reserved(obj), &quot;Trying to discover obj &quot; PTR_FORMAT &quot; not in heap&quot;, p2i(obj));
 55   return _g1h-&gt;heap_region_containing(obj)-&gt;is_old_or_humongous_or_archive();
 56 }
 57 
 58 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, oop const obj) {
 59   HeapRegion* const hr = _g1h-&gt;heap_region_containing(obj);
 60   return mark_in_next_bitmap(worker_id, hr, obj);
 61 }
 62 
 63 inline bool G1ConcurrentMark::mark_in_next_bitmap(uint const worker_id, HeapRegion* const hr, oop const obj) {
 64   assert(hr != NULL, &quot;just checking&quot;);
 65   assert(hr-&gt;is_in_reserved(obj), &quot;Attempting to mark object at &quot; PTR_FORMAT &quot; that is not contained in the given region %u&quot;, p2i(obj), hr-&gt;hrm_index());
 66 
 67   if (hr-&gt;obj_allocated_since_next_marking(obj)) {
 68     return false;
 69   }
 70 
 71   // Some callers may have stale objects to mark above nTAMS after humongous reclaim.
 72   // Can&#39;t assert that this is a valid object at this point, since it might be in the process of being copied by another thread.
 73   assert(!hr-&gt;is_continues_humongous(), &quot;Should not try to mark object &quot; PTR_FORMAT &quot; in Humongous continues region %u above nTAMS &quot; PTR_FORMAT, p2i(obj), hr-&gt;hrm_index(), p2i(hr-&gt;next_top_at_mark_start()));
 74 
 75   bool success = _next_mark_bitmap-&gt;par_mark(obj);
 76   if (success) {
 77     add_to_liveness(worker_id, obj, obj-&gt;size());
 78   }
 79   return success;
 80 }
 81 
 82 #ifndef PRODUCT
 83 template&lt;typename Fn&gt;
 84 inline void G1CMMarkStack::iterate(Fn fn) const {
 85   assert_at_safepoint_on_vm_thread();
 86 
 87   size_t num_chunks = 0;
 88 
 89   TaskQueueEntryChunk* cur = _chunk_list;
 90   while (cur != NULL) {
 91     guarantee(num_chunks &lt;= _chunks_in_chunk_list, &quot;Found &quot; SIZE_FORMAT &quot; oop chunks which is more than there should be&quot;, num_chunks);
 92 
 93     for (size_t i = 0; i &lt; EntriesPerChunk; ++i) {
 94       if (cur-&gt;data[i].is_null()) {
 95         break;
 96       }
 97       fn(cur-&gt;data[i]);
 98     }
 99     cur = cur-&gt;next;
100     num_chunks++;
101   }
102 }
103 #endif
104 
105 // It scans an object and visits its children.
106 inline void G1CMTask::scan_task_entry(G1TaskQueueEntry task_entry) { process_grey_task_entry&lt;true&gt;(task_entry); }
107 
108 inline void G1CMTask::push(G1TaskQueueEntry task_entry) {
109   assert(task_entry.is_array_slice() || _g1h-&gt;is_in_g1_reserved(task_entry.obj()), &quot;invariant&quot;);
110   assert(task_entry.is_array_slice() || !_g1h-&gt;is_on_master_free_list(
111               _g1h-&gt;heap_region_containing(task_entry.obj())), &quot;invariant&quot;);
112   assert(task_entry.is_array_slice() || !_g1h-&gt;is_obj_ill(task_entry.obj()), &quot;invariant&quot;);  // FIXME!!!
113   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())), &quot;invariant&quot;);
114 
115   if (!_task_queue-&gt;push(task_entry)) {
116     // The local task queue looks full. We need to push some entries
117     // to the global stack.
118     move_entries_to_global_stack();
119 
120     // this should succeed since, even if we overflow the global
121     // stack, we should have definitely removed some entries from the
122     // local queue. So, there must be space on it.
123     bool success = _task_queue-&gt;push(task_entry);
124     assert(success, &quot;invariant&quot;);
125   }
126 }
127 
128 inline bool G1CMTask::is_below_finger(oop obj, HeapWord* global_finger) const {
129   // If obj is above the global finger, then the mark bitmap scan
130   // will find it later, and no push is needed.  Similarly, if we have
131   // a current region and obj is between the local finger and the
132   // end of the current region, then no push is needed.  The tradeoff
133   // of checking both vs only checking the global finger is that the
134   // local check will be more accurate and so result in fewer pushes,
135   // but may also be a little slower.
136   HeapWord* objAddr = cast_from_oop&lt;HeapWord*&gt;(obj);
137   if (_finger != NULL) {
138     // We have a current region.
139 
140     // Finger and region values are all NULL or all non-NULL.  We
141     // use _finger to check since we immediately use its value.
142     assert(_curr_region != NULL, &quot;invariant&quot;);
143     assert(_region_limit != NULL, &quot;invariant&quot;);
144     assert(_region_limit &lt;= global_finger, &quot;invariant&quot;);
145 
146     // True if obj is less than the local finger, or is between
147     // the region limit and the global finger.
148     if (objAddr &lt; _finger) {
149       return true;
150     } else if (objAddr &lt; _region_limit) {
151       return false;
152     } // Else check global finger.
153   }
154   // Check global finger.
155   return objAddr &lt; global_finger;
156 }
157 
158 template&lt;bool scan&gt;
159 inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {
160   assert(scan || (task_entry.is_oop() &amp;&amp; task_entry.obj()-&gt;is_typeArray()), &quot;Skipping scan of grey non-typeArray&quot;);
161   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())),
162          &quot;Any stolen object should be a slice or marked&quot;);
163 
164   if (scan) {
165     if (task_entry.is_array_slice()) {
166       _words_scanned += _objArray_processor.process_slice(task_entry.slice());
167     } else {
168       oop obj = task_entry.obj();
169       if (G1CMObjArrayProcessor::should_be_sliced(obj)) {
170         _words_scanned += _objArray_processor.process_obj(obj);
171       } else {
172         _words_scanned += obj-&gt;oop_iterate_size(_cm_oop_closure);;
173       }
174     }
175   }
176   check_limits();
177 }
178 
179 inline size_t G1CMTask::scan_objArray(objArrayOop obj, MemRegion mr) {
180   obj-&gt;oop_iterate(_cm_oop_closure, mr);
181   return mr.word_size();
182 }
183 
184 inline HeapWord* G1ConcurrentMark::top_at_rebuild_start(uint region) const {
185   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
186   return _top_at_rebuild_starts[region];
187 }
188 
189 inline void G1ConcurrentMark::update_top_at_rebuild_start(HeapRegion* r) {
190   uint const region = r-&gt;hrm_index();
191   assert(region &lt; _g1h-&gt;max_regions(), &quot;Tried to access TARS for region %u out of bounds&quot;, region);
192   assert(_top_at_rebuild_starts[region] == NULL,
193          &quot;TARS for region %u has already been set to &quot; PTR_FORMAT &quot; should be NULL&quot;,
194          region, p2i(_top_at_rebuild_starts[region]));
195   G1RemSetTrackingPolicy* tracker = _g1h-&gt;policy()-&gt;remset_tracker();
196   if (tracker-&gt;needs_scan_for_rebuild(r)) {
197     _top_at_rebuild_starts[region] = r-&gt;top();
198   } else {
199     // Leave TARS at NULL.
200   }
201 }
202 
203 inline void G1CMTask::update_liveness(oop const obj, const size_t obj_size) {
204   _mark_stats_cache.add_live_words(_g1h-&gt;addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj)), obj_size);
205 }
206 
207 inline void G1ConcurrentMark::add_to_liveness(uint worker_id, oop const obj, size_t size) {
208   task(worker_id)-&gt;update_liveness(obj, size);
209 }
210 
211 inline void G1CMTask::abort_marking_if_regular_check_fail() {
212   if (!regular_clock_call()) {
213     set_has_aborted();
214   }
215 }
216 
217 inline bool G1CMTask::make_reference_grey(oop obj) {
218   if (!_cm-&gt;mark_in_next_bitmap(_worker_id, obj)) {
219     return false;
220   }
221 
222   // No OrderAccess:store_load() is needed. It is implicit in the
223   // CAS done in G1CMBitMap::parMark() call in the routine above.
224   HeapWord* global_finger = _cm-&gt;finger();
225 
226   // We only need to push a newly grey object on the mark
227   // stack if it is in a section of memory the mark bitmap
228   // scan has already examined.  Mark bitmap scanning
229   // maintains progress &quot;fingers&quot; for determining that.
230   //
231   // Notice that the global finger might be moving forward
232   // concurrently. This is not a problem. In the worst case, we
233   // mark the object while it is above the global finger and, by
234   // the time we read the global finger, it has moved forward
235   // past this object. In this case, the object will probably
236   // be visited when a task is scanning the region and will also
237   // be pushed on the stack. So, some duplicate work, but no
238   // correctness problems.
239   if (is_below_finger(obj, global_finger)) {
240     G1TaskQueueEntry entry = G1TaskQueueEntry::from_oop(obj);
241     if (obj-&gt;is_typeArray()) {
242       // Immediately process arrays of primitive types, rather
243       // than pushing on the mark stack.  This keeps us from
244       // adding humongous objects to the mark stack that might
245       // be reclaimed before the entry is processed - see
246       // selection of candidates for eager reclaim of humongous
247       // objects.  The cost of the additional type test is
248       // mitigated by avoiding a trip through the mark stack,
249       // by only doing a bookkeeping update and avoiding the
250       // actual scan of the object - a typeArray contains no
251       // references, and the metadata is built-in.
252       process_grey_task_entry&lt;false&gt;(entry);
253     } else {
254       push(entry);
255     }
256   }
257   return true;
258 }
259 
260 template &lt;class T&gt;
261 inline bool G1CMTask::deal_with_reference(T* p) {
262   increment_refs_reached();
263   oop const obj = RawAccess&lt;MO_VOLATILE&gt;::oop_load(p);
264   if (obj == NULL) {
265     return false;
266   }
267   return make_reference_grey(obj);
268 }
269 
270 inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {
271   assert(!_prev_mark_bitmap-&gt;is_marked(p), &quot;sanity&quot;);
272  _prev_mark_bitmap-&gt;mark(p);
273 }
274 
275 bool G1ConcurrentMark::is_marked_in_prev_bitmap(oop p) const {
276   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
277   return _prev_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));
278 }
279 
280 bool G1ConcurrentMark::is_marked_in_next_bitmap(oop p) const {
281   assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
282   return _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));
283 }
284 
285 inline bool G1ConcurrentMark::do_yield_check() {
286   if (SuspendibleThreadSet::should_yield()) {
287     SuspendibleThreadSet::yield();
288     return true;
289   } else {
290     return false;
291   }
292 }
293 
294 #endif // SHARE_GC_G1_G1CONCURRENTMARK_INLINE_HPP
    </pre>
  </body>
</html>
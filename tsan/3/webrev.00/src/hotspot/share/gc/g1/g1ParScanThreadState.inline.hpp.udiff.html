<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ParScanThreadState.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,37 +39,37 @@</span>
    // Although we never intentionally push references outside of the collection
    // set, due to (benign) races in the claim mechanism during RSet scanning more
    // than one thread might claim the same card. So the same card may be
    // processed multiple times, and so we might get references into old gen here.
    // So we need to redo this check.
<span class="udiff-line-modified-removed">-   const InCSetState in_cset_state = _g1h-&gt;in_cset_state(obj);</span>
<span class="udiff-line-modified-added">+   const G1HeapRegionAttr region_attr = _g1h-&gt;region_attr(obj);</span>
    // References pushed onto the work stack should never point to a humongous region
    // as they are not added to the collection set due to above precondition.
<span class="udiff-line-modified-removed">-   assert(!in_cset_state.is_humongous(),</span>
<span class="udiff-line-modified-added">+   assert(!region_attr.is_humongous(),</span>
           &quot;Obj &quot; PTR_FORMAT &quot; should not refer to humongous region %u from &quot; PTR_FORMAT,
<span class="udiff-line-modified-removed">-          p2i(obj), _g1h-&gt;addr_to_region((HeapWord*)obj), p2i(p));</span>
<span class="udiff-line-modified-added">+          p2i(obj), _g1h-&gt;addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj)), p2i(p));</span>
  
<span class="udiff-line-modified-removed">-   if (!in_cset_state.is_in_cset()) {</span>
<span class="udiff-line-modified-added">+   if (!region_attr.is_in_cset()) {</span>
      // In this case somebody else already did all the work.
      return;
    }
  
<span class="udiff-line-modified-removed">-   markOop m = obj-&gt;mark_raw();</span>
<span class="udiff-line-modified-removed">-   if (m-&gt;is_marked()) {</span>
<span class="udiff-line-modified-removed">-     obj = (oop) m-&gt;decode_pointer();</span>
<span class="udiff-line-modified-added">+   markWord m = obj-&gt;mark_raw();</span>
<span class="udiff-line-modified-added">+   if (m.is_marked()) {</span>
<span class="udiff-line-modified-added">+     obj = (oop) m.decode_pointer();</span>
    } else {
<span class="udiff-line-modified-removed">-     obj = copy_to_survivor_space(in_cset_state, obj, m);</span>
<span class="udiff-line-modified-added">+     obj = copy_to_survivor_space(region_attr, obj, m);</span>
    }
    RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);
  
    assert(obj != NULL, &quot;Must be&quot;);
    if (HeapRegion::is_in_same_region(p, obj)) {
      return;
    }
    HeapRegion* from = _g1h-&gt;heap_region_containing(p);
    if (!from-&gt;is_young()) {
<span class="udiff-line-modified-removed">-     enqueue_card_if_tracked(p, obj);</span>
<span class="udiff-line-modified-added">+     enqueue_card_if_tracked(_g1h-&gt;region_attr(obj), p, obj);</span>
    }
  }
  
  template &lt;class T&gt; inline void G1ParScanThreadState::push_on_queue(T* ref) {
    assert(verify_ref(ref), &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -206,21 +206,54 @@</span>
  
  template &lt;typename T&gt;
  inline void G1ParScanThreadState::remember_root_into_optional_region(T* p) {
    oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
    uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();
<span class="udiff-line-added">+   assert(index &lt; _num_optional_regions,</span>
<span class="udiff-line-added">+          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT, index, _num_optional_regions);</span>
    _oops_into_optional_regions[index].push_root(p);
  }
  
  template &lt;typename T&gt;
  inline void G1ParScanThreadState::remember_reference_into_optional_region(T* p) {
    oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
    uint index = _g1h-&gt;heap_region_containing(o)-&gt;index_in_opt_cset();
<span class="udiff-line-added">+   assert(index &lt; _num_optional_regions,</span>
<span class="udiff-line-added">+          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT, index, _num_optional_regions);</span>
    _oops_into_optional_regions[index].push_oop(p);
    DEBUG_ONLY(verify_ref(p);)
  }
  
  G1OopStarChunkedList* G1ParScanThreadState::oops_into_optional_region(const HeapRegion* hr) {
<span class="udiff-line-added">+   assert(hr-&gt;index_in_opt_cset() &lt; _num_optional_regions,</span>
<span class="udiff-line-added">+          &quot;Trying to access optional region idx %u beyond &quot; SIZE_FORMAT &quot; &quot; HR_FORMAT,</span>
<span class="udiff-line-added">+          hr-&gt;index_in_opt_cset(), _num_optional_regions, HR_FORMAT_PARAMS(hr));</span>
    return &amp;_oops_into_optional_regions[hr-&gt;index_in_opt_cset()];
  }
  
<span class="udiff-line-added">+ void G1ParScanThreadState::initialize_numa_stats() {</span>
<span class="udiff-line-added">+   if (_numa-&gt;is_enabled()) {</span>
<span class="udiff-line-added">+     LogTarget(Info, gc, heap, numa) lt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (lt.is_enabled()) {</span>
<span class="udiff-line-added">+       uint num_nodes = _numa-&gt;num_active_nodes();</span>
<span class="udiff-line-added">+       // Record only if there are multiple active nodes.</span>
<span class="udiff-line-added">+       _obj_alloc_stat = NEW_C_HEAP_ARRAY(size_t, num_nodes, mtGC);</span>
<span class="udiff-line-added">+       memset(_obj_alloc_stat, 0, sizeof(size_t) * num_nodes);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1ParScanThreadState::flush_numa_stats() {</span>
<span class="udiff-line-added">+   if (_obj_alloc_stat != NULL) {</span>
<span class="udiff-line-added">+     uint node_index = _numa-&gt;index_of_current_thread();</span>
<span class="udiff-line-added">+     _numa-&gt;copy_statistics(G1NUMAStats::LocalObjProcessAtCopyToSurv, node_index, _obj_alloc_stat);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1ParScanThreadState::update_numa_stats(uint node_index) {</span>
<span class="udiff-line-added">+   if (_obj_alloc_stat != NULL) {</span>
<span class="udiff-line-added">+     _obj_alloc_stat[node_index]++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #endif // SHARE_GC_G1_G1PARSCANTHREADSTATE_INLINE_HPP
</pre>
<center><a href="g1ParScanThreadState.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
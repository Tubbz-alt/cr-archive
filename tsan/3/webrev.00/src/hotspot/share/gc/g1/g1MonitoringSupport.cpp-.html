<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1MonitoringSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1MonitoringSupport.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
 29 #include &quot;gc/g1/g1MemoryPool.hpp&quot;
 30 #include &quot;gc/shared/hSpaceCounters.hpp&quot;
 31 #include &quot;memory/metaspaceCounters.hpp&quot;
 32 #include &quot;services/memoryPool.hpp&quot;
 33 
 34 class G1GenerationCounters : public GenerationCounters {
 35 protected:
 36   G1MonitoringSupport* _g1mm;
 37 
 38 public:
 39   G1GenerationCounters(G1MonitoringSupport* g1mm,
 40                        const char* name, int ordinal, int spaces,
 41                        size_t min_capacity, size_t max_capacity,
 42                        size_t curr_capacity)
 43   : GenerationCounters(name, ordinal, spaces, min_capacity,
 44                        max_capacity, curr_capacity), _g1mm(g1mm) { }
 45 };
 46 
 47 class G1YoungGenerationCounters : public G1GenerationCounters {
 48 public:
 49   // We pad the capacity three times given that the young generation
 50   // contains three spaces (eden and two survivors).
 51   G1YoungGenerationCounters(G1MonitoringSupport* g1mm, const char* name, size_t max_size)
 52   : G1GenerationCounters(g1mm, name, 0 /* ordinal */, 3 /* spaces */,
 53                          G1MonitoringSupport::pad_capacity(0, 3) /* min_capacity */,
 54                          G1MonitoringSupport::pad_capacity(max_size, 3),
 55                          G1MonitoringSupport::pad_capacity(0, 3) /* curr_capacity */) {
 56     if (UsePerfData) {
 57       update_all();
 58     }
 59   }
 60 
 61   virtual void update_all() {
 62     size_t committed =
 63               G1MonitoringSupport::pad_capacity(_g1mm-&gt;young_gen_committed(), 3);
 64     _current_size-&gt;set_value(committed);
 65   }
 66 };
 67 
 68 class G1OldGenerationCounters : public G1GenerationCounters {
 69 public:
 70   G1OldGenerationCounters(G1MonitoringSupport* g1mm, const char* name, size_t max_size)
 71   : G1GenerationCounters(g1mm, name, 1 /* ordinal */, 1 /* spaces */,
 72                          G1MonitoringSupport::pad_capacity(0) /* min_capacity */,
 73                          G1MonitoringSupport::pad_capacity(max_size),
 74                          G1MonitoringSupport::pad_capacity(0) /* curr_capacity */) {
 75     if (UsePerfData) {
 76       update_all();
 77     }
 78   }
 79 
 80   virtual void update_all() {
 81     size_t committed =
 82               G1MonitoringSupport::pad_capacity(_g1mm-&gt;old_gen_committed());
 83     _current_size-&gt;set_value(committed);
 84   }
 85 };
 86 
 87 G1MonitoringSupport::G1MonitoringSupport(G1CollectedHeap* g1h) :
 88   _g1h(g1h),
 89   _incremental_memory_manager(&quot;G1 Young Generation&quot;, &quot;end of minor GC&quot;),
 90   _full_gc_memory_manager(&quot;G1 Old Generation&quot;, &quot;end of major GC&quot;),
 91   _eden_space_pool(NULL),
 92   _survivor_space_pool(NULL),
 93   _old_gen_pool(NULL),
 94   _incremental_collection_counters(NULL),
 95   _full_collection_counters(NULL),
 96   _conc_collection_counters(NULL),
 97   _young_gen_counters(NULL),
 98   _old_gen_counters(NULL),
 99   _old_space_counters(NULL),
100   _eden_space_counters(NULL),
101   _from_space_counters(NULL),
102   _to_space_counters(NULL),
103 
104   _overall_committed(0),
105   _overall_used(0),
106   _young_gen_committed(0),
107   _old_gen_committed(0),
108 
109   _eden_space_committed(0),
110   _eden_space_used(0),
111   _survivor_space_committed(0),
112   _survivor_space_used(0),
113   _old_gen_used(0) {
114 
115   recalculate_sizes();
116 
117   // Counters for garbage collections
118   //
119   //  name &quot;collector.0&quot;.  In a generational collector this would be the
120   // young generation collection.
121   _incremental_collection_counters =
122     new CollectorCounters(&quot;G1 young collection pauses&quot;, 0);
123   //   name &quot;collector.1&quot;.  In a generational collector this would be the
124   // old generation collection.
125   _full_collection_counters =
126     new CollectorCounters(&quot;G1 full collection pauses&quot;, 1);
127   //   name &quot;collector.2&quot;.  In a generational collector this would be the
128   // STW phases in concurrent collection.
129   _conc_collection_counters =
130     new CollectorCounters(&quot;G1 concurrent cycle pauses&quot;, 2);
131 
132   // &quot;Generation&quot; and &quot;Space&quot; counters.
133   //
134   //  name &quot;generation.1&quot; This is logically the old generation in
135   // generational GC terms.  The &quot;1, 1&quot; parameters are for
136   // the n-th generation (=1) with 1 space.
137   // Counters are created from minCapacity, maxCapacity, and capacity
138   _old_gen_counters = new G1OldGenerationCounters(this, &quot;old&quot;, _g1h-&gt;max_capacity());
139 
140   //  name  &quot;generation.1.space.0&quot;
141   // Counters are created from maxCapacity, capacity, initCapacity,
142   // and used.
143   _old_space_counters = new HSpaceCounters(_old_gen_counters-&gt;name_space(),
144     &quot;space&quot;, 0 /* ordinal */,
145     pad_capacity(g1h-&gt;max_capacity()) /* max_capacity */,
146     pad_capacity(_old_gen_committed) /* init_capacity */);
147 
148   //   Young collection set
149   //  name &quot;generation.0&quot;.  This is logically the young generation.
150   //  The &quot;0, 3&quot; are parameters for the n-th generation (=0) with 3 spaces.
151   // See  _old_collection_counters for additional counters
152   _young_gen_counters = new G1YoungGenerationCounters(this, &quot;young&quot;, _g1h-&gt;max_capacity());
153 
154   const char* young_collection_name_space = _young_gen_counters-&gt;name_space();
155 
156   //  name &quot;generation.0.space.0&quot;
157   // See _old_space_counters for additional counters
158   _eden_space_counters = new HSpaceCounters(young_collection_name_space,
159     &quot;eden&quot;, 0 /* ordinal */,
160     pad_capacity(g1h-&gt;max_capacity()) /* max_capacity */,
161     pad_capacity(_eden_space_committed) /* init_capacity */);
162 
163   //  name &quot;generation.0.space.1&quot;
164   // See _old_space_counters for additional counters
165   // Set the arguments to indicate that this survivor space is not used.
166   _from_space_counters = new HSpaceCounters(young_collection_name_space,
167     &quot;s0&quot;, 1 /* ordinal */,
168     pad_capacity(0) /* max_capacity */,
169     pad_capacity(0) /* init_capacity */);
170   // Given that this survivor space is not used, we update it here
171   // once to reflect that its used space is 0 so that we don&#39;t have to
172   // worry about updating it again later.
173   if (UsePerfData) {
174     _from_space_counters-&gt;update_used(0);
175   }
176 
177   //  name &quot;generation.0.space.2&quot;
178   // See _old_space_counters for additional counters
179   _to_space_counters = new HSpaceCounters(young_collection_name_space,
180     &quot;s1&quot;, 2 /* ordinal */,
181     pad_capacity(g1h-&gt;max_capacity()) /* max_capacity */,
182     pad_capacity(_survivor_space_committed) /* init_capacity */);
183 }
184 
185 G1MonitoringSupport::~G1MonitoringSupport() {
186   delete _eden_space_pool;
187   delete _survivor_space_pool;
188   delete _old_gen_pool;
189 }
190 
191 void G1MonitoringSupport::initialize_serviceability() {
192   _eden_space_pool = new G1EdenPool(_g1h, _eden_space_committed);
193   _survivor_space_pool = new G1SurvivorPool(_g1h, _survivor_space_committed);
194   _old_gen_pool = new G1OldGenPool(_g1h, _old_gen_committed, _g1h-&gt;max_capacity());
195 
196   _full_gc_memory_manager.add_pool(_eden_space_pool);
197   _full_gc_memory_manager.add_pool(_survivor_space_pool);
198   _full_gc_memory_manager.add_pool(_old_gen_pool);
199 
200   _incremental_memory_manager.add_pool(_eden_space_pool);
201   _incremental_memory_manager.add_pool(_survivor_space_pool);
202   _incremental_memory_manager.add_pool(_old_gen_pool, false /* always_affected_by_gc */);
203 }
204 
205 MemoryUsage G1MonitoringSupport::memory_usage() {
206   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);
207   return MemoryUsage(InitialHeapSize, _overall_used, _overall_committed, _g1h-&gt;max_capacity());
208 }
209 
210 GrowableArray&lt;GCMemoryManager*&gt; G1MonitoringSupport::memory_managers() {
211   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
212   memory_managers.append(&amp;_incremental_memory_manager);
213   memory_managers.append(&amp;_full_gc_memory_manager);
214   return memory_managers;
215 }
216 
217 GrowableArray&lt;MemoryPool*&gt; G1MonitoringSupport::memory_pools() {
218   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
219   memory_pools.append(_eden_space_pool);
220   memory_pools.append(_survivor_space_pool);
221   memory_pools.append(_old_gen_pool);
222   return memory_pools;
223 }
224 
225 void G1MonitoringSupport::recalculate_sizes() {
226   assert_heap_locked_or_at_safepoint(true);
227 
228   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);
229   // Recalculate all the sizes from scratch.
230 
231   uint young_list_length = _g1h-&gt;young_regions_count();
232   uint survivor_list_length = _g1h-&gt;survivor_regions_count();
233   assert(young_list_length &gt;= survivor_list_length, &quot;invariant&quot;);
234   uint eden_list_length = young_list_length - survivor_list_length;
235   // Max length includes any potential extensions to the young gen
236   // we&#39;ll do when the GC locker is active.
237   uint young_list_max_length = _g1h-&gt;policy()-&gt;young_list_max_length();
238   assert(young_list_max_length &gt;= survivor_list_length, &quot;invariant&quot;);
239   uint eden_list_max_length = young_list_max_length - survivor_list_length;
240 
241   _overall_used = _g1h-&gt;used_unlocked();
242   _eden_space_used = (size_t) eden_list_length * HeapRegion::GrainBytes;
243   _survivor_space_used = (size_t) survivor_list_length * HeapRegion::GrainBytes;
244   _old_gen_used = subtract_up_to_zero(_overall_used, _eden_space_used + _survivor_space_used);
245 
246   // First calculate the committed sizes that can be calculated independently.
247   _survivor_space_committed = _survivor_space_used;
248   _old_gen_committed = HeapRegion::align_up_to_region_byte_size(_old_gen_used);
249 
250   // Next, start with the overall committed size.
251   _overall_committed = _g1h-&gt;capacity();
252   size_t committed = _overall_committed;
253 
254   // Remove the committed size we have calculated so far (for the
255   // survivor and old space).
256   assert(committed &gt;= (_survivor_space_committed + _old_gen_committed), &quot;sanity&quot;);
257   committed -= _survivor_space_committed + _old_gen_committed;
258 
259   // Next, calculate and remove the committed size for the eden.
260   _eden_space_committed = (size_t) eden_list_max_length * HeapRegion::GrainBytes;
261   // Somewhat defensive: be robust in case there are inaccuracies in
262   // the calculations
263   _eden_space_committed = MIN2(_eden_space_committed, committed);
264   committed -= _eden_space_committed;
265 
266   // Finally, give the rest to the old space...
267   _old_gen_committed += committed;
268   // ..and calculate the young gen committed.
269   _young_gen_committed = _eden_space_committed + _survivor_space_committed;
270 
271   assert(_overall_committed ==
272          (_eden_space_committed + _survivor_space_committed + _old_gen_committed),
273          &quot;the committed sizes should add up&quot;);
274   // Somewhat defensive: cap the eden used size to make sure it
275   // never exceeds the committed size.
276   _eden_space_used = MIN2(_eden_space_used, _eden_space_committed);
277   // _survivor_committed and _old_committed are calculated in terms of
278   // the corresponding _*_used value, so the next two conditions
279   // should hold.
280   assert(_survivor_space_used &lt;= _survivor_space_committed, &quot;post-condition&quot;);
281   assert(_old_gen_used &lt;= _old_gen_committed, &quot;post-condition&quot;);
282 }
283 
284 void G1MonitoringSupport::update_sizes() {
285   recalculate_sizes();
286   if (UsePerfData) {
287     _eden_space_counters-&gt;update_capacity(pad_capacity(_eden_space_committed));
288     _eden_space_counters-&gt;update_used(_eden_space_used);
289    // only the &quot;to&quot; survivor space is active, so we don&#39;t need to
290     // update the counters for the &quot;from&quot; survivor space
291     _to_space_counters-&gt;update_capacity(pad_capacity(_survivor_space_committed));
292     _to_space_counters-&gt;update_used(_survivor_space_used);
293     _old_space_counters-&gt;update_capacity(pad_capacity(_old_gen_committed));
294     _old_space_counters-&gt;update_used(_old_gen_used);
295 
296     _young_gen_counters-&gt;update_all();
297     _old_gen_counters-&gt;update_all();
298 
299     MetaspaceCounters::update_performance_counters();
300     CompressedClassSpaceCounters::update_performance_counters();
301   }
302 }
303 
304 void G1MonitoringSupport::update_eden_size() {
305   // Recalculate everything - this should be fast enough and we are sure that we do not
306   // miss anything.
307   recalculate_sizes();
308   if (UsePerfData) {
309     _eden_space_counters-&gt;update_used(_eden_space_used);
310   }
311 }
312 
313 MemoryUsage G1MonitoringSupport::eden_space_memory_usage(size_t initial_size, size_t max_size) {
314   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);
315 
316   return MemoryUsage(initial_size,
317                      _eden_space_used,
318                      _eden_space_committed,
319                      max_size);
320 }
321 
322 MemoryUsage G1MonitoringSupport::survivor_space_memory_usage(size_t initial_size, size_t max_size) {
323   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);
324 
325   return MemoryUsage(initial_size,
326                      _survivor_space_used,
327                      _survivor_space_committed,
328                      max_size);
329 }
330 
331 MemoryUsage G1MonitoringSupport::old_gen_memory_usage(size_t initial_size, size_t max_size) {
332   MutexLockerEx x(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);
333 
334   return MemoryUsage(initial_size,
335                      _old_gen_used,
336                      _old_gen_committed,
337                      max_size);
338 }
339 
340 G1MonitoringScope::G1MonitoringScope(G1MonitoringSupport* g1mm, bool full_gc, bool all_memory_pools_affected) :
341   _tcs(full_gc ? g1mm-&gt;_full_collection_counters : g1mm-&gt;_incremental_collection_counters),
342   _tms(full_gc ? &amp;g1mm-&gt;_full_gc_memory_manager : &amp;g1mm-&gt;_incremental_memory_manager,
343        G1CollectedHeap::heap()-&gt;gc_cause(), all_memory_pools_affected) {
344 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1CardTable.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CardTable.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CodeBlobClosure.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CardTable.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,17 +24,68 @@</span>
  
  #ifndef SHARE_GC_G1_G1CARDTABLE_INLINE_HPP
  #define SHARE_GC_G1_G1CARDTABLE_INLINE_HPP
  
  #include &quot;gc/g1/g1CardTable.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/heapRegion.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- void G1CardTable::set_card_claimed(size_t card_index) {</span>
<span class="udiff-line-modified-removed">-   jbyte val = _byte_map[card_index];</span>
<span class="udiff-line-modified-removed">-   if (val == clean_card_val()) {</span>
<span class="udiff-line-modified-removed">-     val = (jbyte)claimed_card_val();</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     val |= (jbyte)claimed_card_val();</span>
<span class="udiff-line-modified-added">+ inline uint G1CardTable::region_idx_for(CardValue* p) {</span>
<span class="udiff-line-modified-added">+   size_t const card_idx = pointer_delta(p, _byte_map, sizeof(CardValue));</span>
<span class="udiff-line-modified-added">+   return (uint)(card_idx &gt;&gt; (HeapRegion::LogOfHRGrainBytes - card_shift));</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ inline size_t G1CardTable::mark_clean_as_dirty(size_t card_index) {</span>
<span class="udiff-line-added">+   CardValue value = _byte_map[card_index];</span>
<span class="udiff-line-added">+   if (value == clean_card_val()) {</span>
<span class="udiff-line-added">+     _byte_map[card_index] = dirty_card_val();</span>
<span class="udiff-line-added">+     return 1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline size_t G1CardTable::mark_region_dirty(size_t start_card_index, size_t num_cards) {</span>
<span class="udiff-line-added">+   assert(is_aligned(start_card_index, sizeof(size_t)), &quot;Start card index must be aligned.&quot;);</span>
<span class="udiff-line-added">+   assert(is_aligned(num_cards, sizeof(size_t)), &quot;Number of cards to change must be evenly divisible.&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t result = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t const num_chunks = num_cards / sizeof(size_t);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   size_t* cur_word = (size_t*)&amp;_byte_map[start_card_index];</span>
<span class="udiff-line-added">+   size_t* const end_word_map = cur_word + num_chunks;</span>
<span class="udiff-line-added">+   while (cur_word &lt; end_word_map) {</span>
<span class="udiff-line-added">+     size_t value = *cur_word;</span>
<span class="udiff-line-added">+     if (value == WordAllClean) {</span>
<span class="udiff-line-added">+       *cur_word = WordAllDirty;</span>
<span class="udiff-line-added">+       result += sizeof(value);</span>
<span class="udiff-line-added">+     } else if (value == WordAllDirty) {</span>
<span class="udiff-line-added">+       // do nothing.</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // There is a mix of cards in there. Tread slowly.</span>
<span class="udiff-line-added">+       CardValue* cur = (CardValue*)cur_word;</span>
<span class="udiff-line-added">+       for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="udiff-line-added">+         CardValue value = *cur;</span>
<span class="udiff-line-added">+         if (value == clean_card_val()) {</span>
<span class="udiff-line-added">+           *cur = dirty_card_val();</span>
<span class="udiff-line-added">+           result++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         cur++;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     cur_word++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void G1CardTable::mark_as_scanned(size_t start_card_index, size_t num_cards) {</span>
<span class="udiff-line-added">+   CardValue* start = &amp;_byte_map[start_card_index];</span>
<span class="udiff-line-added">+   CardValue* const end = start + num_cards;</span>
<span class="udiff-line-added">+   while (start &lt; end) {</span>
<span class="udiff-line-added">+     CardValue value = *start;</span>
<span class="udiff-line-added">+     assert(value == dirty_card_val(),</span>
<span class="udiff-line-added">+            &quot;Must have been dirty %d start &quot; PTR_FORMAT &quot; &quot; PTR_FORMAT, value, p2i(start), p2i(end));</span>
<span class="udiff-line-added">+     *start++ = g1_card_already_scanned;</span>
    }
<span class="udiff-line-removed">-   _byte_map[card_index] = val;</span>
  }
  
<span class="udiff-line-modified-removed">- #endif // SHARE_GC_G1_G1CARDTABLE_INLINE_HPP</span>
<span class="udiff-line-modified-added">+ #endif /* SHARE_GC_G1_G1CARDTABLE_INLINE_HPP */</span>
</pre>
<center><a href="g1CardTable.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CodeBlobClosure.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
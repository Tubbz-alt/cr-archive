<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1CollectionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,30 ***</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/quickSort.hpp&quot;
  
<span class="line-modified">! G1CollectorState* G1CollectionSet::collector_state() {</span>
    return _g1h-&gt;collector_state();
  }
  
  G1GCPhaseTimes* G1CollectionSet::phase_times() {
    return _policy-&gt;phase_times();
  }
  
<span class="line-modified">! double G1CollectionSet::predict_region_elapsed_time_ms(HeapRegion* hr) {</span>
<span class="line-modified">!   return _policy-&gt;predict_region_elapsed_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
  }
  
  G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
    _g1h(g1h),
    _policy(policy),
<span class="line-new-header">--- 25,32 ---</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1HotCardCache.hpp&quot;</span>
  #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/quickSort.hpp&quot;
  
<span class="line-modified">! G1CollectorState* G1CollectionSet::collector_state() const {</span>
    return _g1h-&gt;collector_state();
  }
  
  G1GCPhaseTimes* G1CollectionSet::phase_times() {
    return _policy-&gt;phase_times();
  }
  
<span class="line-modified">! double G1CollectionSet::predict_region_non_copy_time_ms(HeapRegion* hr) const {</span>
<span class="line-modified">!   return _policy-&gt;predict_region_non_copy_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
  }
  
  G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
    _g1h(g1h),
    _policy(policy),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,27 ***</span>
    _survivor_region_length(0),
    _old_region_length(0),
    _collection_set_regions(NULL),
    _collection_set_cur_length(0),
    _collection_set_max_length(0),
<span class="line-modified">!   _optional_regions(NULL),</span>
<span class="line-removed">-   _optional_region_length(0),</span>
<span class="line-removed">-   _optional_region_max_length(0),</span>
    _bytes_used_before(0),
<span class="line-modified">!   _recorded_rs_lengths(0),</span>
    _inc_build_state(Inactive),
    _inc_bytes_used_before(0),
<span class="line-modified">!   _inc_recorded_rs_lengths(0),</span>
<span class="line-modified">!   _inc_recorded_rs_lengths_diffs(0),</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms(0.0),</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms_diffs(0.0) {</span>
  }
  
  G1CollectionSet::~G1CollectionSet() {
<span class="line-modified">!   if (_collection_set_regions != NULL) {</span>
<span class="line-modified">!     FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-removed">-   }</span>
    free_optional_regions();
    clear_candidates();
  }
  
  void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
<span class="line-new-header">--- 59,26 ---</span>
    _survivor_region_length(0),
    _old_region_length(0),
    _collection_set_regions(NULL),
    _collection_set_cur_length(0),
    _collection_set_max_length(0),
<span class="line-modified">!   _num_optional_regions(0),</span>
    _bytes_used_before(0),
<span class="line-modified">!   _recorded_rs_length(0),</span>
    _inc_build_state(Inactive),
<span class="line-added">+   _inc_part_start(0),</span>
<span class="line-added">+   _inc_collection_set_stats(NULL),</span>
    _inc_bytes_used_before(0),
<span class="line-modified">!   _inc_recorded_rs_length(0),</span>
<span class="line-modified">!   _inc_recorded_rs_length_diff(0),</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms(0.0),</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms_diff(0.0) {</span>
  }
  
  G1CollectionSet::~G1CollectionSet() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(IncCollectionSetRegionStat, _inc_collection_set_stats);</span>
    free_optional_regions();
    clear_candidates();
  }
  
  void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,156 ***</span>
    _survivor_region_length = survivor_cset_region_length;
  
    assert((size_t) young_region_length() == _collection_set_cur_length,
           &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
  
<span class="line-modified">!   _old_region_length      = 0;</span>
<span class="line-modified">!   _optional_region_length = 0;</span>
  }
  
  void G1CollectionSet::initialize(uint max_region_length) {
    guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
    _collection_set_max_length = max_region_length;
    _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void G1CollectionSet::initialize_optional(uint max_length) {</span>
<span class="line-removed">-   assert(_optional_regions == NULL, &quot;Already initialized&quot;);</span>
<span class="line-removed">-   assert(_optional_region_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">-   assert(_optional_region_max_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">-   _optional_region_max_length = max_length;</span>
<span class="line-removed">-   _optional_regions = NEW_C_HEAP_ARRAY(HeapRegion*, _optional_region_max_length, mtGC);</span>
  }
  
  void G1CollectionSet::free_optional_regions() {
<span class="line-modified">!   _optional_region_length = 0;</span>
<span class="line-removed">-   _optional_region_max_length = 0;</span>
<span class="line-removed">-   if (_optional_regions != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(HeapRegion*, _optional_regions);</span>
<span class="line-removed">-     _optional_regions = NULL;</span>
<span class="line-removed">-   }</span>
  }
  
  void G1CollectionSet::clear_candidates() {
    delete _candidates;
    _candidates = NULL;
  }
  
<span class="line-modified">! void G1CollectionSet::set_recorded_rs_lengths(size_t rs_lengths) {</span>
<span class="line-modified">!   _recorded_rs_lengths = rs_lengths;</span>
  }
  
  // Add the heap region at the head of the non-incremental collection set
  void G1CollectionSet::add_old_region(HeapRegion* hr) {
    assert_at_safepoint_on_vm_thread();
  
<span class="line-modified">!   assert(_inc_build_state == Active || hr-&gt;index_in_opt_cset() != G1OptionalCSet::InvalidCSetIndex,</span>
           &quot;Precondition, actively building cset or adding optional later on&quot;);
    assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
  
<span class="line-modified">!   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);</span>
<span class="line-modified">!   _g1h-&gt;register_old_region_with_cset(hr);</span>
  
    _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
    assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
  
    _bytes_used_before += hr-&gt;used();
<span class="line-modified">!   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">!   _recorded_rs_lengths += rs_length;</span>
<span class="line-removed">-   _old_region_length += 1;</span>
  
<span class="line-modified">!   log_trace(gc, cset)(&quot;Added old region %d to collection set&quot;, hr-&gt;hrm_index());</span>
  }
  
  void G1CollectionSet::add_optional_region(HeapRegion* hr) {
<span class="line-removed">-   assert(!optional_is_full(), &quot;Precondition, must have room left for this region&quot;);</span>
    assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
    assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
  
<span class="line-modified">!   _g1h-&gt;register_optional_region_with_cset(hr);</span>
  
<span class="line-modified">!   _optional_regions[_optional_region_length] = hr;</span>
<span class="line-removed">-   uint index = _optional_region_length++;</span>
<span class="line-removed">-   hr-&gt;set_index_in_opt_cset(index);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   log_trace(gc, cset)(&quot;Added region %d to optional collection set (%u)&quot;, hr-&gt;hrm_index(), _optional_region_length);</span>
  }
  
<span class="line-removed">- // Initialize the per-collection-set information</span>
  void G1CollectionSet::start_incremental_building() {
    assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
    assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
  
    _inc_bytes_used_before = 0;
  
<span class="line-modified">!   _inc_recorded_rs_lengths = 0;</span>
<span class="line-modified">!   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms = 0.0;</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
<span class="line-modified">!   _inc_build_state = Active;</span>
  }
  
  void G1CollectionSet::finalize_incremental_building() {
    assert(_inc_build_state == Active, &quot;Precondition&quot;);
    assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
  
<span class="line-modified">!   // The two &quot;main&quot; fields, _inc_recorded_rs_lengths and</span>
<span class="line-modified">!   // _inc_predicted_elapsed_time_ms, are updated by the thread</span>
    // that adds a new region to the CSet. Further updates by the
    // concurrent refinement thread that samples the young RSet lengths
<span class="line-modified">!   // are accumulated in the *_diffs fields. Here we add the diffs to</span>
    // the &quot;main&quot; fields.
  
<span class="line-modified">!   if (_inc_recorded_rs_lengths_diffs &gt;= 0) {</span>
<span class="line-modified">!     _inc_recorded_rs_lengths += _inc_recorded_rs_lengths_diffs;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     // This is defensive. The diff should in theory be always positive</span>
<span class="line-removed">-     // as RSets can only grow between GCs. However, given that we</span>
<span class="line-removed">-     // sample their size concurrently with other threads updating them</span>
<span class="line-removed">-     // it&#39;s possible that we might get the wrong size back, which</span>
<span class="line-removed">-     // could make the calculations somewhat inaccurate.</span>
<span class="line-removed">-     size_t diffs = (size_t) (-_inc_recorded_rs_lengths_diffs);</span>
<span class="line-removed">-     if (_inc_recorded_rs_lengths &gt;= diffs) {</span>
<span class="line-removed">-       _inc_recorded_rs_lengths -= diffs;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       _inc_recorded_rs_lengths = 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _inc_predicted_elapsed_time_ms += _inc_predicted_elapsed_time_ms_diffs;</span>
  
<span class="line-modified">!   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
  }
  
  void G1CollectionSet::clear() {
    assert_at_safepoint_on_vm_thread();
    _collection_set_cur_length = 0;
<span class="line-removed">-   _optional_region_length = 0;</span>
  }
  
  void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
<span class="line-removed">-   iterate_from(cl, 0, 1);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void G1CollectionSet::iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const {</span>
    size_t len = _collection_set_cur_length;
    OrderAccess::loadload();
<span class="line-removed">-   if (len == 0) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   size_t start_pos = (worker_id * len) / total_workers;</span>
<span class="line-removed">-   size_t cur_pos = start_pos;</span>
  
<span class="line-modified">!   do {</span>
<span class="line-modified">!     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[cur_pos]);</span>
      bool result = cl-&gt;do_heap_region(r);
      if (result) {
        cl-&gt;set_incomplete();
        return;
      }
      cur_pos++;
<span class="line-modified">!     if (cur_pos == len) {</span>
        cur_pos = 0;
      }
    } while (cur_pos != start_pos);
  }
  
<span class="line-new-header">--- 89,168 ---</span>
    _survivor_region_length = survivor_cset_region_length;
  
    assert((size_t) young_region_length() == _collection_set_cur_length,
           &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
  
<span class="line-modified">!   _old_region_length = 0;</span>
<span class="line-modified">!   free_optional_regions();</span>
  }
  
  void G1CollectionSet::initialize(uint max_region_length) {
    guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
    _collection_set_max_length = max_region_length;
    _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<span class="line-modified">!   _inc_collection_set_stats = NEW_C_HEAP_ARRAY(IncCollectionSetRegionStat, max_region_length, mtGC);</span>
  }
  
  void G1CollectionSet::free_optional_regions() {
<span class="line-modified">!   _num_optional_regions = 0;</span>
  }
  
  void G1CollectionSet::clear_candidates() {
    delete _candidates;
    _candidates = NULL;
  }
  
<span class="line-modified">! void G1CollectionSet::set_recorded_rs_length(size_t rs_length) {</span>
<span class="line-modified">!   _recorded_rs_length = rs_length;</span>
  }
  
  // Add the heap region at the head of the non-incremental collection set
  void G1CollectionSet::add_old_region(HeapRegion* hr) {
    assert_at_safepoint_on_vm_thread();
  
<span class="line-modified">!   assert(_inc_build_state == Active,</span>
           &quot;Precondition, actively building cset or adding optional later on&quot;);
    assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
  
<span class="line-modified">!   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the collection set&quot;);</span>
<span class="line-modified">!   _g1h-&gt;register_old_region_with_region_attr(hr);</span>
  
    _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
    assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
  
    _bytes_used_before += hr-&gt;used();
<span class="line-modified">!   _recorded_rs_length += hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">!   _old_region_length++;</span>
  
<span class="line-modified">!   _g1h-&gt;old_set_remove(hr);</span>
  }
  
  void G1CollectionSet::add_optional_region(HeapRegion* hr) {
    assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
    assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
  
<span class="line-modified">!   _g1h-&gt;register_optional_region_with_region_attr(hr);</span>
  
<span class="line-modified">!   hr-&gt;set_index_in_opt_cset(_num_optional_regions++);</span>
  }
  
  void G1CollectionSet::start_incremental_building() {
    assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
    assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   for (size_t i = 0; i &lt; _collection_set_max_length; i++) {</span>
<span class="line-added">+     _inc_collection_set_stats[i].reset();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
  
    _inc_bytes_used_before = 0;
  
<span class="line-modified">!   _inc_recorded_rs_length = 0;</span>
<span class="line-modified">!   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms = 0.0;</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
<span class="line-modified">! </span>
<span class="line-added">+   update_incremental_marker();</span>
  }
  
  void G1CollectionSet::finalize_incremental_building() {
    assert(_inc_build_state == Active, &quot;Precondition&quot;);
    assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
  
<span class="line-modified">!   // The two &quot;main&quot; fields, _inc_recorded_rs_length and</span>
<span class="line-modified">!   // _inc_predicted_non_copy_time_ms, are updated by the thread</span>
    // that adds a new region to the CSet. Further updates by the
    // concurrent refinement thread that samples the young RSet lengths
<span class="line-modified">!   // are accumulated in the *_diff fields. Here we add the diffs to</span>
    // the &quot;main&quot; fields.
  
<span class="line-modified">!   _inc_recorded_rs_length += _inc_recorded_rs_length_diff;</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms += _inc_predicted_non_copy_time_ms_diff;</span>
  
<span class="line-modified">!   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
  }
  
  void G1CollectionSet::clear() {
    assert_at_safepoint_on_vm_thread();
    _collection_set_cur_length = 0;
  }
  
  void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
    size_t len = _collection_set_cur_length;
    OrderAccess::loadload();
  
<span class="line-modified">!   for (uint i = 0; i &lt; len; i++) {</span>
<span class="line-modified">!     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[i]);</span>
      bool result = cl-&gt;do_heap_region(r);
      if (result) {
        cl-&gt;set_incomplete();
        return;
      }
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1CollectionSet::par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">+                                   HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">+                                   uint worker_id,</span>
<span class="line-added">+                                   uint total_workers) const {</span>
<span class="line-added">+   iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {</span>
<span class="line-added">+   assert_at_safepoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-added">+     HeapRegion* r = _candidates-&gt;at(i);</span>
<span class="line-added">+     bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">+     guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">+                                                     HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">+                                                     uint worker_id,</span>
<span class="line-added">+                                                     uint total_workers) const {</span>
<span class="line-added">+   iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">+                                         HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">+                                         size_t offset,</span>
<span class="line-added">+                                         size_t length,</span>
<span class="line-added">+                                         uint worker_id,</span>
<span class="line-added">+                                         uint total_workers) const {</span>
<span class="line-added">+   assert_at_safepoint();</span>
<span class="line-added">+   if (length == 0) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t start_pos = (worker_id * length) / total_workers;</span>
<span class="line-added">+   size_t cur_pos = start_pos;</span>
<span class="line-added">+ </span>
<span class="line-added">+   do {</span>
<span class="line-added">+     uint region_idx = _collection_set_regions[cur_pos + offset];</span>
<span class="line-added">+     if (hr_claimer == NULL || hr_claimer-&gt;claim_region(region_idx)) {</span>
<span class="line-added">+       HeapRegion* r = _g1h-&gt;region_at(region_idx);</span>
<span class="line-added">+       bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">+       guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      cur_pos++;
<span class="line-modified">!     if (cur_pos == length) {</span>
        cur_pos = 0;
      }
    } while (cur_pos != start_pos);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,47 ***</span>
                                                       size_t new_rs_length) {
    // Update the CSet information that is dependent on the new RS length
    assert(hr-&gt;is_young(), &quot;Precondition&quot;);
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
  
<span class="line-modified">!   // We could have updated _inc_recorded_rs_lengths and</span>
<span class="line-removed">-   // _inc_predicted_elapsed_time_ms directly but we&#39;d need to do</span>
<span class="line-removed">-   // that atomically, as this code is executed by a concurrent</span>
<span class="line-removed">-   // refinement thread, potentially concurrently with a mutator thread</span>
<span class="line-removed">-   // allocating a new region and also updating the same fields. To</span>
<span class="line-removed">-   // avoid the atomic operations we accumulate these updates on two</span>
<span class="line-removed">-   // separate fields (*_diffs) and we&#39;ll just add them to the &quot;main&quot;</span>
<span class="line-removed">-   // fields at the start of a GC.</span>
  
<span class="line-modified">!   ssize_t old_rs_length = (ssize_t) hr-&gt;recorded_rs_length();</span>
<span class="line-modified">!   ssize_t rs_lengths_diff = (ssize_t) new_rs_length - old_rs_length;</span>
<span class="line-modified">!   _inc_recorded_rs_lengths_diffs += rs_lengths_diff;</span>
  
<span class="line-modified">!   double old_elapsed_time_ms = hr-&gt;predicted_elapsed_time_ms();</span>
<span class="line-modified">!   double new_region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">!   double elapsed_ms_diff = new_region_elapsed_time_ms - old_elapsed_time_ms;</span>
<span class="line-modified">!   _inc_predicted_elapsed_time_ms_diffs += elapsed_ms_diff;</span>
  
<span class="line-modified">!   hr-&gt;set_recorded_rs_length(new_rs_length);</span>
<span class="line-modified">!   hr-&gt;set_predicted_elapsed_time_ms(new_region_elapsed_time_ms);</span>
  }
  
  void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
    assert(hr-&gt;is_young(), &quot;invariant&quot;);
    assert(_inc_build_state == Active, &quot;Precondition&quot;);
  
<span class="line-removed">-   size_t collection_set_length = _collection_set_cur_length;</span>
<span class="line-removed">-   assert(collection_set_length &lt;= INT_MAX, &quot;Collection set is too large with %d entries&quot;, (int)collection_set_length);</span>
<span class="line-removed">-   hr-&gt;set_young_index_in_cset((int)collection_set_length);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   _collection_set_regions[collection_set_length] = hr-&gt;hrm_index();</span>
<span class="line-removed">-   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-removed">-   // update to the length field.</span>
<span class="line-removed">-   OrderAccess::storestore();</span>
<span class="line-removed">-   _collection_set_cur_length++;</span>
<span class="line-removed">-   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
<span class="line-removed">- </span>
    // This routine is used when:
    // * adding survivor regions to the incremental cset at the end of an
    //   evacuation pause or
    // * adding the current allocation region to the incremental cset
    //   when it is retired.
<span class="line-new-header">--- 258,33 ---</span>
                                                       size_t new_rs_length) {
    // Update the CSet information that is dependent on the new RS length
    assert(hr-&gt;is_young(), &quot;Precondition&quot;);
    assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
  
<span class="line-modified">!   IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>
  
<span class="line-modified">!   size_t old_rs_length = stat-&gt;_rs_length;</span>
<span class="line-modified">!   assert(old_rs_length &lt;= new_rs_length,</span>
<span class="line-modified">!          &quot;Remembered set decreased (changed from &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT &quot; region %u type %s)&quot;,</span>
<span class="line-added">+          old_rs_length, new_rs_length, hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
<span class="line-added">+   size_t rs_length_diff = new_rs_length - old_rs_length;</span>
<span class="line-added">+   stat-&gt;_rs_length = new_rs_length;</span>
<span class="line-added">+   _inc_recorded_rs_length_diff += rs_length_diff;</span>
  
<span class="line-modified">!   double old_non_copy_time = stat-&gt;_non_copy_time_ms;</span>
<span class="line-modified">!   assert(old_non_copy_time &gt;= 0.0, &quot;Non copy time for region %u not initialized yet, is %.3f&quot;, hr-&gt;hrm_index(), old_non_copy_time);</span>
<span class="line-modified">!   double new_non_copy_time = predict_region_non_copy_time_ms(hr);</span>
<span class="line-modified">!   double non_copy_time_ms_diff = new_non_copy_time - old_non_copy_time;</span>
  
<span class="line-modified">!   stat-&gt;_non_copy_time_ms = new_non_copy_time;</span>
<span class="line-modified">!   _inc_predicted_non_copy_time_ms_diff += non_copy_time_ms_diff;</span>
  }
  
  void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
    assert(hr-&gt;is_young(), &quot;invariant&quot;);
    assert(_inc_build_state == Active, &quot;Precondition&quot;);
  
    // This routine is used when:
    // * adding survivor regions to the incremental cset at the end of an
    //   evacuation pause or
    // * adding the current allocation region to the incremental cset
    //   when it is retired.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,26 ***</span>
    // by the Young List sampling code.
    // Ignore calls to this due to retirement during full gc.
  
    if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
      size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified">!     double region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
  
      // Cache the values we have added to the aggregated information
      // in the heap region in case we have to remove this region from
      // the incremental collection set, or it is updated by the
      // rset sampling code
<span class="line-removed">-     hr-&gt;set_recorded_rs_length(rs_length);</span>
<span class="line-removed">-     hr-&gt;set_predicted_elapsed_time_ms(region_elapsed_time_ms);</span>
  
<span class="line-modified">!     _inc_recorded_rs_lengths += rs_length;</span>
<span class="line-modified">!     _inc_predicted_elapsed_time_ms += region_elapsed_time_ms;</span>
      _inc_bytes_used_before += hr-&gt;used();
    }
  
    assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<span class="line-modified">!   _g1h-&gt;register_young_region_with_cset(hr);</span>
  }
  
  void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
    assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
    add_young_region_common(hr);
<span class="line-new-header">--- 299,40 ---</span>
    // by the Young List sampling code.
    // Ignore calls to this due to retirement during full gc.
  
    if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
      size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified">!     double non_copy_time = predict_region_non_copy_time_ms(hr);</span>
  
      // Cache the values we have added to the aggregated information
      // in the heap region in case we have to remove this region from
      // the incremental collection set, or it is updated by the
      // rset sampling code
  
<span class="line-modified">!     IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>
<span class="line-modified">!     stat-&gt;_rs_length = rs_length;</span>
<span class="line-added">+     stat-&gt;_non_copy_time_ms = non_copy_time;</span>
<span class="line-added">+ </span>
<span class="line-added">+     _inc_recorded_rs_length += rs_length;</span>
<span class="line-added">+     _inc_predicted_non_copy_time_ms += non_copy_time;</span>
      _inc_bytes_used_before += hr-&gt;used();
    }
  
    assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<span class="line-modified">!   _g1h-&gt;register_young_region_with_region_attr(hr);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // We use UINT_MAX as &quot;invalid&quot; marker in verification.</span>
<span class="line-added">+   assert(_collection_set_cur_length &lt; (UINT_MAX - 1),</span>
<span class="line-added">+          &quot;Collection set is too large with &quot; SIZE_FORMAT &quot; entries&quot;, _collection_set_cur_length);</span>
<span class="line-added">+   hr-&gt;set_young_index_in_cset((uint)_collection_set_cur_length + 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   _collection_set_regions[_collection_set_cur_length] = hr-&gt;hrm_index();</span>
<span class="line-added">+   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-added">+   // update to the length field.</span>
<span class="line-added">+   OrderAccess::storestore();</span>
<span class="line-added">+   _collection_set_cur_length++;</span>
<span class="line-added">+   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
  }
  
  void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
    assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
    add_young_region_common(hr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,25 ***</span>
  
  #ifndef PRODUCT
  class G1VerifyYoungAgesClosure : public HeapRegionClosure {
  public:
    bool _valid;
<span class="line-modified">! public:</span>
    G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
  
    virtual bool do_heap_region(HeapRegion* r) {
      guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
  
<span class="line-modified">!     SurvRateGroup* group = r-&gt;surv_rate_group();</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (group == NULL) {</span>
<span class="line-removed">-       log_error(gc, verify)(&quot;## encountered NULL surv_rate_group in young region&quot;);</span>
        _valid = false;
      }
  
<span class="line-modified">!     if (r-&gt;age_in_surv_rate_group() &lt; 0) {</span>
<span class="line-modified">!       log_error(gc, verify)(&quot;## encountered negative age in young region&quot;);</span>
        _valid = false;
      }
  
      return false;
    }
<span class="line-new-header">--- 345,23 ---</span>
  
  #ifndef PRODUCT
  class G1VerifyYoungAgesClosure : public HeapRegionClosure {
  public:
    bool _valid;
<span class="line-modified">! </span>
    G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
  
    virtual bool do_heap_region(HeapRegion* r) {
      guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
  
<span class="line-modified">!     if (!r-&gt;has_surv_rate_group()) {</span>
<span class="line-modified">!       log_error(gc, verify)(&quot;## encountered young region without surv_rate_group&quot;);</span>
        _valid = false;
      }
  
<span class="line-modified">!     if (!r-&gt;has_valid_age_in_surv_rate()) {</span>
<span class="line-modified">!       log_error(gc, verify)(&quot;## encountered invalid age in young region&quot;);</span>
        _valid = false;
      }
  
      return false;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,11 ***</span>
      assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
      _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
                    HR_FORMAT_PARAMS(r),
                    p2i(r-&gt;prev_top_at_mark_start()),
                    p2i(r-&gt;next_top_at_mark_start()),
<span class="line-modified">!                   r-&gt;age_in_surv_rate_group_cond());</span>
      return false;
    }
  };
  
  void G1CollectionSet::print(outputStream* st) {
<span class="line-new-header">--- 392,11 ---</span>
      assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
      _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
                    HR_FORMAT_PARAMS(r),
                    p2i(r-&gt;prev_top_at_mark_start()),
                    p2i(r-&gt;next_top_at_mark_start()),
<span class="line-modified">!                   r-&gt;has_surv_rate_group() ? r-&gt;age_in_surv_rate_group() : -1);</span>
      return false;
    }
  };
  
  void G1CollectionSet::print(outputStream* st) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,75 ***</span>
    iterate(&amp;cl);
  }
  #endif // !PRODUCT
  
  double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<span class="line-modified">!   double young_start_time_sec = os::elapsedTime();</span>
  
    finalize_incremental_building();
  
    guarantee(target_pause_time_ms &gt; 0.0,
              &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
  
<span class="line-modified">!   size_t pending_cards = _policy-&gt;pending_cards();</span>
<span class="line-removed">-   double base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-removed">-   double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);</span>
  
<span class="line-modified">!   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. pending cards: &quot; SIZE_FORMAT &quot; predicted base time: %1.2fms remaining time: %1.2fms target pause time: %1.2fms&quot;,</span>
<span class="line-modified">!                             pending_cards, base_time_ms, time_remaining_ms, target_pause_time_ms);</span>
  
    // The young list is laid with the survivor regions from the previous
    // pause are appended to the RHS of the young list, i.e.
    //   [Newly Young Regions ++ Survivors from last pause].
  
<span class="line-removed">-   uint survivor_region_length = survivors-&gt;length();</span>
    uint eden_region_length = _g1h-&gt;eden_regions_count();
    init_region_lengths(eden_region_length, survivor_region_length);
  
    verify_young_cset_indices();
  
    // Clear the fields that point to the survivor list - they are all young now.
    survivors-&gt;convert_to_eden();
  
    _bytes_used_before = _inc_bytes_used_before;
<span class="line-removed">-   time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   log_trace(gc, ergo, cset)(&quot;Add young regions to CSet. eden: %u regions, survivors: %u regions, predicted young region time: %1.2fms, target pause time: %1.2fms&quot;,</span>
<span class="line-removed">-                             eden_region_length, survivor_region_length, _inc_predicted_elapsed_time_ms, target_pause_time_ms);</span>
  
    // The number of recorded young regions is the incremental
    // collection set&#39;s current size
<span class="line-modified">!   set_recorded_rs_lengths(_inc_recorded_rs_lengths);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   double young_end_time_sec = os::elapsedTime();</span>
<span class="line-removed">-   phase_times()-&gt;record_young_cset_choice_time_ms((young_end_time_sec - young_start_time_sec) * 1000.0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return time_remaining_ms;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1CollectionSet::add_as_old(HeapRegion* hr) {</span>
<span class="line-modified">!   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">!   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">-   add_old_region(hr);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1CollectionSet::add_as_optional(HeapRegion* hr) {</span>
<span class="line-modified">!   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-modified">!   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">!   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">-   add_optional_region(hr);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool G1CollectionSet::optional_is_full() {</span>
<span class="line-removed">-   assert(_optional_region_length &lt;= _optional_region_max_length, &quot;Invariant&quot;);</span>
<span class="line-removed">-   return _optional_region_length == _optional_region_max_length;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1CollectionSet::clear_optional_region(const HeapRegion* hr) {</span>
<span class="line-removed">-   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-removed">-   uint index = hr-&gt;index_in_opt_cset();</span>
<span class="line-removed">-   _optional_regions[index] = NULL;</span>
  }
  
  static int compare_region_idx(const uint a, const uint b) {
    if (a &gt; b) {
      return 1;
<span class="line-new-header">--- 406,53 ---</span>
    iterate(&amp;cl);
  }
  #endif // !PRODUCT
  
  double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<span class="line-modified">!   Ticks start_time = Ticks::now();</span>
  
    finalize_incremental_building();
  
    guarantee(target_pause_time_ms &gt; 0.0,
              &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
  
<span class="line-modified">!   size_t pending_cards = _policy-&gt;pending_cards_at_gc_start() + _g1h-&gt;hot_card_cache()-&gt;num_entries();</span>
  
<span class="line-modified">!   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. Pending cards: &quot; SIZE_FORMAT &quot; target pause time: %1.2fms&quot;,</span>
<span class="line-modified">!                             pending_cards, target_pause_time_ms);</span>
  
    // The young list is laid with the survivor regions from the previous
    // pause are appended to the RHS of the young list, i.e.
    //   [Newly Young Regions ++ Survivors from last pause].
  
    uint eden_region_length = _g1h-&gt;eden_regions_count();
<span class="line-added">+   uint survivor_region_length = survivors-&gt;length();</span>
    init_region_lengths(eden_region_length, survivor_region_length);
  
    verify_young_cset_indices();
  
    // Clear the fields that point to the survivor list - they are all young now.
    survivors-&gt;convert_to_eden();
  
    _bytes_used_before = _inc_bytes_used_before;
  
    // The number of recorded young regions is the incremental
    // collection set&#39;s current size
<span class="line-modified">!   set_recorded_rs_length(_inc_recorded_rs_length);</span>
  
<span class="line-modified">!   double predicted_base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-modified">!   double predicted_eden_time = _inc_predicted_non_copy_time_ms + _policy-&gt;predict_eden_copy_time_ms(eden_region_length);</span>
<span class="line-modified">!   double remaining_time_ms = MAX2(target_pause_time_ms - (predicted_base_time_ms + predicted_eden_time), 0.0);</span>
  
<span class="line-modified">!   log_trace(gc, ergo, cset)(&quot;Added young regions to CSet. Eden: %u regions, Survivors: %u regions, &quot;</span>
<span class="line-modified">!                             &quot;predicted eden time: %1.2fms, predicted base time: %1.2fms, target pause time: %1.2fms, remaining time: %1.2fms&quot;,</span>
<span class="line-modified">!                             eden_region_length, survivor_region_length,</span>
<span class="line-modified">!                             predicted_eden_time, predicted_base_time_ms, target_pause_time_ms, remaining_time_ms);</span>
  
<span class="line-modified">!   phase_times()-&gt;record_young_cset_choice_time_ms((Ticks::now() - start_time).seconds() * 1000.0);</span>
  
<span class="line-modified">!   return remaining_time_ms;</span>
  }
  
  static int compare_region_idx(const uint a, const uint b) {
    if (a &gt; b) {
      return 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,216 ***</span>
    }
  }
  
  void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
    double non_young_start_time_sec = os::elapsedTime();
<span class="line-removed">-   double predicted_old_time_ms = 0.0;</span>
<span class="line-removed">-   double predicted_optional_time_ms = 0.0;</span>
<span class="line-removed">-   double optional_threshold_ms = time_remaining_ms * _policy-&gt;optional_prediction_fraction();</span>
<span class="line-removed">-   uint expensive_region_num = 0;</span>
  
    if (collector_state()-&gt;in_mixed_phase()) {
      candidates()-&gt;verify();
<span class="line-modified">!     const uint min_old_cset_length = _policy-&gt;calc_min_old_cset_length();</span>
<span class="line-modified">!     const uint max_old_cset_length = MAX2(min_old_cset_length, _policy-&gt;calc_max_old_cset_length());</span>
<span class="line-modified">!     bool check_time_remaining = _policy-&gt;adaptive_young_list_length();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     initialize_optional(max_old_cset_length - min_old_cset_length);</span>
<span class="line-modified">!     log_debug(gc, ergo, cset)(&quot;Start adding old regions for mixed gc. min %u regions, max %u regions, &quot;</span>
<span class="line-modified">!                               &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,</span>
<span class="line-modified">!                               min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     HeapRegion* hr = candidates()-&gt;peek_front();</span>
<span class="line-modified">!     while (hr != NULL) {</span>
<span class="line-modified">!       if (old_region_length() + optional_region_length() &gt;= max_old_cset_length) {</span>
<span class="line-modified">!         // Added maximum number of old regions to the CSet.</span>
<span class="line-modified">!         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached max). &quot;</span>
<span class="line-modified">!                                   &quot;old %u regions, optional %u regions&quot;,</span>
<span class="line-modified">!                                   old_region_length(), optional_region_length());</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Stop adding regions if the remaining reclaimable space is</span>
<span class="line-removed">-       // not above G1HeapWastePercent.</span>
<span class="line-removed">-       size_t reclaimable_bytes = candidates()-&gt;remaining_reclaimable_bytes();</span>
<span class="line-removed">-       double reclaimable_percent = _policy-&gt;reclaimable_bytes_percent(reclaimable_bytes);</span>
<span class="line-removed">-       double threshold = (double) G1HeapWastePercent;</span>
<span class="line-removed">-       if (reclaimable_percent &lt;= threshold) {</span>
<span class="line-removed">-         // We&#39;ve added enough old regions that the amount of uncollected</span>
<span class="line-removed">-         // reclaimable space is at or below the waste threshold. Stop</span>
<span class="line-removed">-         // adding old regions to the CSet.</span>
<span class="line-removed">-         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (reclaimable percentage not over threshold). &quot;</span>
<span class="line-removed">-                                   &quot;reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,</span>
<span class="line-removed">-                                   byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),</span>
<span class="line-removed">-                                   reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       double predicted_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-removed">-       time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);</span>
<span class="line-removed">-       // Add regions to old set until we reach minimum amount</span>
<span class="line-removed">-       if (old_region_length() &lt; min_old_cset_length) {</span>
<span class="line-removed">-         predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">-         add_as_old(hr);</span>
<span class="line-removed">-         // Record the number of regions added when no time remaining</span>
<span class="line-removed">-         if (time_remaining_ms == 0.0) {</span>
<span class="line-removed">-           expensive_region_num++;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         // In the non-auto-tuning case, we&#39;ll finish adding regions</span>
<span class="line-removed">-         // to the CSet if we reach the minimum.</span>
<span class="line-removed">-         if (!check_time_remaining) {</span>
<span class="line-removed">-           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached min).&quot;);</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Keep adding regions to old set until we reach optional threshold</span>
<span class="line-removed">-         if (time_remaining_ms &gt; optional_threshold_ms) {</span>
<span class="line-removed">-           predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">-           add_as_old(hr);</span>
<span class="line-removed">-         } else if (time_remaining_ms &gt; 0) {</span>
<span class="line-removed">-           // Keep adding optional regions until time is up</span>
<span class="line-removed">-           if (!optional_is_full()) {</span>
<span class="line-removed">-             predicted_optional_time_ms += predicted_time_ms;</span>
<span class="line-removed">-             add_as_optional(hr);</span>
<span class="line-removed">-           } else {</span>
<span class="line-removed">-             log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (optional set full).&quot;);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (predicted time is too high).&quot;);</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       hr = candidates()-&gt;peek_front();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (hr == NULL) {</span>
<span class="line-removed">-       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (candidate old regions not available)&quot;);</span>
      }
  
      candidates()-&gt;verify();
    }
  
    stop_incremental_building();
  
<span class="line-removed">-   log_debug(gc, ergo, cset)(&quot;Finish choosing CSet regions old: %u, optional: %u, &quot;</span>
<span class="line-removed">-                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,</span>
<span class="line-removed">-                             old_region_length(), optional_region_length(),</span>
<span class="line-removed">-                             predicted_old_time_ms, predicted_optional_time_ms, time_remaining_ms);</span>
<span class="line-removed">-   if (expensive_region_num &gt; 0) {</span>
<span class="line-removed">-     log_debug(gc, ergo, cset)(&quot;CSet contains %u old regions that were added although the predicted time was too high.&quot;,</span>
<span class="line-removed">-                               expensive_region_num);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    double non_young_end_time_sec = os::elapsedTime();
    phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
  
    QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
  }
  
<span class="line-modified">! HeapRegion* G1OptionalCSet::region_at(uint index) {</span>
<span class="line-modified">!   return _cset-&gt;optional_region_at(index);</span>
  }
  
<span class="line-modified">! void G1OptionalCSet::prepare_evacuation(double time_limit) {</span>
<span class="line-modified">!   assert(_current_index == _current_limit, &quot;Before prepare no regions should be ready for evac&quot;);</span>
  
<span class="line-modified">!   uint prepared_regions = 0;</span>
<span class="line-modified">!   double prediction_ms = 0;</span>
  
<span class="line-modified">!   _prepare_failed = true;</span>
<span class="line-modified">!   for (uint i = _current_index; i &lt; _cset-&gt;optional_region_length(); i++) {</span>
<span class="line-modified">!     HeapRegion* hr = region_at(i);</span>
<span class="line-modified">!     prediction_ms += _cset-&gt;predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">!     if (prediction_ms &gt; time_limit) {</span>
<span class="line-removed">-       log_debug(gc, cset)(&quot;Prepared %u regions for optional evacuation. Predicted time: %.3fms&quot;, prepared_regions, prediction_ms);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // This region will be included in the next optional evacuation.</span>
<span class="line-removed">-     prepare_to_evacuate_optional_region(hr);</span>
<span class="line-removed">-     prepared_regions++;</span>
<span class="line-removed">-     _current_limit++;</span>
<span class="line-removed">-     _prepare_failed = false;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   log_debug(gc, cset)(&quot;Prepared all %u regions for optional evacuation. Predicted time: %.3fms&quot;,</span>
<span class="line-removed">-                       prepared_regions, prediction_ms);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool G1OptionalCSet::prepare_failed() {</span>
<span class="line-removed">-   return _prepare_failed;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1OptionalCSet::complete_evacuation() {</span>
<span class="line-removed">-   _evacuation_failed = false;</span>
<span class="line-removed">-   for (uint i = _current_index; i &lt; _current_limit; i++) {</span>
<span class="line-removed">-     HeapRegion* hr = region_at(i);</span>
<span class="line-removed">-     _cset-&gt;clear_optional_region(hr);</span>
<span class="line-removed">-     if (hr-&gt;evacuation_failed()){</span>
<span class="line-removed">-       _evacuation_failed = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _current_index = _current_limit;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool G1OptionalCSet::evacuation_failed() {</span>
<span class="line-removed">-   return _evacuation_failed;</span>
  }
  
<span class="line-modified">! G1OptionalCSet::~G1OptionalCSet() {</span>
<span class="line-modified">!   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified">!   while (!is_empty()) {</span>
<span class="line-modified">!     // We want to return regions not evacuated to the collection set candidates</span>
<span class="line-modified">!     // in reverse order to maintain the old order.</span>
<span class="line-modified">!     HeapRegion* hr = _cset-&gt;remove_last_optional_region();</span>
<span class="line-modified">!     assert(hr != NULL, &quot;Should be valid region left&quot;);</span>
<span class="line-modified">!     _pset-&gt;record_unused_optional_region(hr);</span>
<span class="line-modified">!     g1h-&gt;old_set_add(hr);</span>
<span class="line-removed">-     g1h-&gt;clear_in_cset(hr);</span>
<span class="line-removed">-     hr-&gt;set_index_in_opt_cset(InvalidCSetIndex);</span>
<span class="line-removed">-     _cset-&gt;candidates()-&gt;push_front(hr);</span>
    }
<span class="line-modified">!   _cset-&gt;free_optional_regions();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint G1OptionalCSet::size() {</span>
<span class="line-removed">-   return _cset-&gt;optional_region_length() - _current_index;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool G1OptionalCSet::is_empty() {</span>
<span class="line-removed">-   return size() == 0;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1OptionalCSet::prepare_to_evacuate_optional_region(HeapRegion* hr) {</span>
<span class="line-removed">-   log_trace(gc, cset)(&quot;Adding region %u for optional evacuation&quot;, hr-&gt;hrm_index());</span>
<span class="line-removed">-   G1CollectedHeap::heap()-&gt;clear_in_cset(hr);</span>
<span class="line-removed">-   _cset-&gt;add_old_region(hr);</span>
  }
  
  #ifdef ASSERT
  class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
  private:
    size_t _young_length;
<span class="line-modified">!   int* _heap_region_indices;</span>
  public:
    G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<span class="line-modified">!     _heap_region_indices = NEW_C_HEAP_ARRAY(int, young_length, mtGC);</span>
<span class="line-modified">!     for (size_t i = 0; i &lt; young_length; i++) {</span>
<span class="line-modified">!       _heap_region_indices[i] = -1;</span>
      }
    }
    ~G1VerifyYoungCSetIndicesClosure() {
      FREE_C_HEAP_ARRAY(int, _heap_region_indices);
    }
  
    virtual bool do_heap_region(HeapRegion* r) {
<span class="line-modified">!     const int idx = r-&gt;young_index_in_cset();</span>
  
<span class="line-modified">!     assert(idx &gt; -1, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">!     assert((size_t)idx &lt; _young_length, &quot;Young cset index too large for region %u&quot;, r-&gt;hrm_index());</span>
  
<span class="line-modified">!     assert(_heap_region_indices[idx] == -1,</span>
             &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
             idx, _heap_region_indices[idx], r-&gt;hrm_index());
  
      _heap_region_indices[idx] = r-&gt;hrm_index();
  
<span class="line-new-header">--- 463,122 ---</span>
    }
  }
  
  void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
    double non_young_start_time_sec = os::elapsedTime();
  
    if (collector_state()-&gt;in_mixed_phase()) {
      candidates()-&gt;verify();
<span class="line-modified">! </span>
<span class="line-modified">!     uint num_initial_old_regions;</span>
<span class="line-modified">!     uint num_optional_old_regions;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     _policy-&gt;calculate_old_collection_set_regions(candidates(),</span>
<span class="line-modified">!                                                   time_remaining_ms,</span>
<span class="line-modified">!                                                   num_initial_old_regions,</span>
<span class="line-modified">!                                                   num_optional_old_regions);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Prepare initial old regions.</span>
<span class="line-modified">!     move_candidates_to_collection_set(num_initial_old_regions);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Prepare optional old regions for evacuation.</span>
<span class="line-modified">!     uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-modified">!     for (uint i = 0; i &lt; num_optional_old_regions; i++) {</span>
<span class="line-modified">!       add_optional_region(candidates()-&gt;at(candidate_idx + i));</span>
      }
  
      candidates()-&gt;verify();
    }
  
    stop_incremental_building();
  
    double non_young_end_time_sec = os::elapsedTime();
    phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
  
    QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
  }
  
<span class="line-modified">! void G1CollectionSet::move_candidates_to_collection_set(uint num_old_candidate_regions) {</span>
<span class="line-modified">!   if (num_old_candidate_regions == 0) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-added">+   for (uint i = 0; i &lt; num_old_candidate_regions; i++) {</span>
<span class="line-added">+     HeapRegion* r = candidates()-&gt;at(candidate_idx + i);</span>
<span class="line-added">+     // This potentially optional candidate region is going to be an actual collection</span>
<span class="line-added">+     // set region. Clear cset marker.</span>
<span class="line-added">+     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-added">+     add_old_region(r);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   candidates()-&gt;remove(num_old_candidate_regions);</span>
<span class="line-added">+ </span>
<span class="line-added">+   candidates()-&gt;verify();</span>
  }
  
<span class="line-modified">! void G1CollectionSet::finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {</span>
<span class="line-modified">!   double time_remaining_ms = finalize_young_part(target_pause_time_ms, survivor);</span>
<span class="line-added">+   finalize_old_part(time_remaining_ms);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool G1CollectionSet::finalize_optional_for_evacuation(double remaining_pause_time) {</span>
<span class="line-modified">!   update_incremental_marker();</span>
  
<span class="line-modified">!   uint num_selected_regions;</span>
<span class="line-modified">!   _policy-&gt;calculate_optional_collection_set_regions(candidates(),</span>
<span class="line-modified">!                                                      _num_optional_regions,</span>
<span class="line-modified">!                                                      remaining_pause_time,</span>
<span class="line-modified">!                                                      num_selected_regions);</span>
  
<span class="line-modified">!   move_candidates_to_collection_set(num_selected_regions);</span>
  
<span class="line-modified">!   _num_optional_regions -= num_selected_regions;</span>
  
<span class="line-modified">!   stop_incremental_building();</span>
  
<span class="line-modified">!   _g1h-&gt;verify_region_attr_remset_update();</span>
  
<span class="line-modified">!   return num_selected_regions &gt; 0;</span>
  }
  
<span class="line-modified">! void G1CollectionSet::abandon_optional_collection_set(G1ParScanThreadStateSet* pss) {</span>
<span class="line-modified">!   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-modified">!     HeapRegion* r = candidates()-&gt;at(candidates()-&gt;cur_idx() + i);</span>
<span class="line-modified">!     pss-&gt;record_unused_optional_region(r);</span>
<span class="line-modified">!     // Clear collection set marker and make sure that the remembered set information</span>
<span class="line-modified">!     // is correct as we still need it later.</span>
<span class="line-modified">!     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-modified">!     _g1h-&gt;register_region_with_region_attr(r);</span>
<span class="line-modified">!     r-&gt;clear_index_in_opt_cset();</span>
    }
<span class="line-modified">!   free_optional_regions();</span>
  
<span class="line-modified">!   _g1h-&gt;verify_region_attr_remset_update();</span>
  }
  
  #ifdef ASSERT
  class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
  private:
    size_t _young_length;
<span class="line-modified">!   uint* _heap_region_indices;</span>
  public:
    G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<span class="line-modified">!     _heap_region_indices = NEW_C_HEAP_ARRAY(uint, young_length + 1, mtGC);</span>
<span class="line-modified">!     for (size_t i = 0; i &lt; young_length + 1; i++) {</span>
<span class="line-modified">!       _heap_region_indices[i] = UINT_MAX;</span>
      }
    }
    ~G1VerifyYoungCSetIndicesClosure() {
      FREE_C_HEAP_ARRAY(int, _heap_region_indices);
    }
  
    virtual bool do_heap_region(HeapRegion* r) {
<span class="line-modified">!     const uint idx = r-&gt;young_index_in_cset();</span>
  
<span class="line-modified">!     assert(idx &gt; 0, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">!     assert(idx &lt;= _young_length, &quot;Young cset index %u too large for region %u&quot;, idx, r-&gt;hrm_index());</span>
  
<span class="line-modified">!     assert(_heap_region_indices[idx] == UINT_MAX,</span>
             &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
             idx, _heap_region_indices[idx], r-&gt;hrm_index());
  
      _heap_region_indices[idx] = r-&gt;hrm_index();
  
</pre>
<center><a href="g1CollectedHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
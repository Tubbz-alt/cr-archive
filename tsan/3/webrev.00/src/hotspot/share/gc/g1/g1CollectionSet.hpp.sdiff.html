<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectionSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetCandidates.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1COLLECTIONSET_HPP
 26 #define SHARE_GC_G1_G1COLLECTIONSET_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class G1CollectedHeap;
 32 class G1CollectionSetCandidates;
 33 class G1CollectorState;
 34 class G1GCPhaseTimes;
 35 class G1ParScanThreadStateSet;
 36 class G1Policy;
 37 class G1SurvivorRegions;
 38 class HeapRegion;

 39 class HeapRegionClosure;
 40 


























































































 41 class G1CollectionSet {
 42   G1CollectedHeap* _g1h;
 43   G1Policy* _policy;
 44 
<span class="line-modified"> 45   // All old gen collection set candidate regions for the current mixed gc phase.</span>
 46   G1CollectionSetCandidates* _candidates;
 47 
 48   uint _eden_region_length;
 49   uint _survivor_region_length;
 50   uint _old_region_length;
 51 
 52   // The actual collection set as a set of region indices.
 53   // All entries in _collection_set_regions below _collection_set_cur_length are
<span class="line-modified"> 54   // assumed to be valid entries.</span>
 55   // We assume that at any time there is at most only one writer and (one or more)
 56   // concurrent readers. This means we are good with using storestore and loadload
 57   // barriers on the writer and reader respectively only.
 58   uint* _collection_set_regions;
 59   volatile size_t _collection_set_cur_length;
 60   size_t _collection_set_max_length;
 61 
<span class="line-modified"> 62   // When doing mixed collections we can add old regions to the collection, which</span>
<span class="line-modified"> 63   // can be collected if there is enough time. We call these optional regions and</span>
<span class="line-modified"> 64   // the pointer to these regions are stored in the array below.</span>
<span class="line-modified"> 65   HeapRegion** _optional_regions;</span>
<span class="line-modified"> 66   uint _optional_region_length;</span>
<span class="line-removed"> 67   uint _optional_region_max_length;</span>
 68 
 69   // The number of bytes in the collection set before the pause. Set from
 70   // the incrementally built collection set at the start of an evacuation
<span class="line-modified"> 71   // pause, and incremented in finalize_old_part() when adding old regions</span>
<span class="line-removed"> 72   // (if any) to the collection set.</span>
 73   size_t _bytes_used_before;
 74 
<span class="line-modified"> 75   size_t _recorded_rs_lengths;</span>
<span class="line-modified"> 76 </span>
<span class="line-modified"> 77   // The associated information that is maintained while the incremental</span>
<span class="line-modified"> 78   // collection set is being built with young regions. Used to populate</span>
<span class="line-removed"> 79   // the recorded info for the evacuation pause.</span>
 80 
 81   enum CSetBuildType {
 82     Active,             // We are actively building the collection set
 83     Inactive            // We are not actively building the collection set
 84   };
 85 
 86   CSetBuildType _inc_build_state;





















 87 
 88   // The number of bytes in the incrementally built collection set.
 89   // Used to set _collection_set_bytes_used_before at the start of
 90   // an evacuation pause.
 91   size_t _inc_bytes_used_before;
 92 
 93   // The RSet lengths recorded for regions in the CSet. It is updated
 94   // by the thread that adds a new region to the CSet. We assume that
 95   // only one thread can be allocating a new CSet region (currently,
 96   // it does so after taking the Heap_lock) hence no need to
 97   // synchronize updates to this field.
<span class="line-modified"> 98   size_t _inc_recorded_rs_lengths;</span>
 99 
100   // A concurrent refinement thread periodically samples the young
<span class="line-modified">101   // region RSets and needs to update _inc_recorded_rs_lengths as</span>
102   // the RSets grow. Instead of having to synchronize updates to that
103   // field we accumulate them in this field and add it to
<span class="line-modified">104   // _inc_recorded_rs_lengths_diffs at the start of a GC.</span>
<span class="line-modified">105   ssize_t _inc_recorded_rs_lengths_diffs;</span>
106 
107   // The predicted elapsed time it will take to collect the regions in
108   // the CSet. This is updated by the thread that adds a new region to
<span class="line-modified">109   // the CSet. See the comment for _inc_recorded_rs_lengths about</span>
110   // MT-safety assumptions.
<span class="line-modified">111   double _inc_predicted_elapsed_time_ms;</span>
112 
<span class="line-modified">113   // See the comment for _inc_recorded_rs_lengths_diffs.</span>
<span class="line-modified">114   double _inc_predicted_elapsed_time_ms_diffs;</span>
115 
<span class="line-modified">116   G1CollectorState* collector_state();</span>


117   G1GCPhaseTimes* phase_times();
118 
119   void verify_young_cset_indices() const NOT_DEBUG_RETURN;
<span class="line-removed">120   void add_as_optional(HeapRegion* hr);</span>
<span class="line-removed">121   void add_as_old(HeapRegion* hr);</span>
<span class="line-removed">122   bool optional_is_full();</span>
123 



































124 public:
125   G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
126   ~G1CollectionSet();
127 
128   // Initializes the collection set giving the maximum possible length of the collection set.
129   void initialize(uint max_region_length);
<span class="line-removed">130   void initialize_optional(uint max_length);</span>
<span class="line-removed">131   void free_optional_regions();</span>
132 
133   void clear_candidates();
134 
135   void set_candidates(G1CollectionSetCandidates* candidates) {
136     assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
137     _candidates = candidates;
138   }
139   G1CollectionSetCandidates* candidates() { return _candidates; }
140 
141   void init_region_lengths(uint eden_cset_region_length,
142                            uint survivor_cset_region_length);
143 
<span class="line-removed">144   void set_recorded_rs_lengths(size_t rs_lengths);</span>
<span class="line-removed">145 </span>
146   uint region_length() const       { return young_region_length() +
147                                             old_region_length(); }
148   uint young_region_length() const { return eden_region_length() +
149                                             survivor_region_length(); }
150 
151   uint eden_region_length() const     { return _eden_region_length;     }
152   uint survivor_region_length() const { return _survivor_region_length; }
153   uint old_region_length() const      { return _old_region_length;      }
<span class="line-modified">154   uint optional_region_length() const { return _optional_region_length; }</span>



155 
156   // Incremental collection set support
157 
158   // Initialize incremental collection set info.
159   void start_incremental_building();




160 
<span class="line-modified">161   // Perform any final calculations on the incremental collection set fields</span>
<span class="line-modified">162   // before we can use them.</span>
<span class="line-modified">163   void finalize_incremental_building();</span>
164 
<span class="line-modified">165   // Reset the contents of the collection set.</span>
<span class="line-modified">166   void clear();</span>


167 
<span class="line-modified">168   // Iterate over the collection set, applying the given HeapRegionClosure on all of them.</span>
<span class="line-modified">169   // If may_be_aborted is true, iteration may be aborted using the return value of the</span>
<span class="line-removed">170   // called closure method.</span>
171   void iterate(HeapRegionClosure* cl) const;




172 
<span class="line-modified">173   // Iterate over the collection set, applying the given HeapRegionClosure on all of them,</span>
<span class="line-removed">174   // trying to optimally spread out starting position of total_workers workers given the</span>
<span class="line-removed">175   // caller&#39;s worker_id.</span>
<span class="line-removed">176   void iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const;</span>
<span class="line-removed">177 </span>
<span class="line-removed">178   // Stop adding regions to the incremental collection set.</span>
<span class="line-removed">179   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
180 
<span class="line-modified">181   size_t recorded_rs_lengths() { return _recorded_rs_lengths; }</span>
182 
183   size_t bytes_used_before() const {
184     return _bytes_used_before;
185   }
186 
187   void reset_bytes_used_before() {
188     _bytes_used_before = 0;
189   }
190 
<span class="line-modified">191   // Choose a new collection set.  Marks the chosen regions as being</span>
<span class="line-modified">192   // &quot;in_collection_set&quot;.</span>
<span class="line-modified">193   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-modified">194   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-modified">195 </span>
<span class="line-modified">196   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-modified">197   void add_old_region(HeapRegion* hr);</span>
<span class="line-modified">198 </span>
<span class="line-removed">199   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-removed">200   void add_optional_region(HeapRegion* hr);</span>
201 
202   // Update information about hr in the aggregated information for
203   // the incrementally built collection set.
204   void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
205 
206   // Add eden region to the collection set.
207   void add_eden_region(HeapRegion* hr);
208 
209   // Add survivor region to the collection set.
210   void add_survivor_regions(HeapRegion* hr);
211 
212 #ifndef PRODUCT
213   bool verify_young_ages();
214 
215   void print(outputStream* st);
216 #endif // !PRODUCT
<span class="line-removed">217 </span>
<span class="line-removed">218   double predict_region_elapsed_time_ms(HeapRegion* hr);</span>
<span class="line-removed">219 </span>
<span class="line-removed">220   void clear_optional_region(const HeapRegion* hr);</span>
<span class="line-removed">221 </span>
<span class="line-removed">222   HeapRegion* optional_region_at(uint i) const {</span>
<span class="line-removed">223     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">224     assert(i &lt; _optional_region_length, &quot;index %u out of bounds (%u)&quot;, i, _optional_region_length);</span>
<span class="line-removed">225     return _optional_regions[i];</span>
<span class="line-removed">226   }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228   HeapRegion* remove_last_optional_region() {</span>
<span class="line-removed">229     assert(_optional_regions != NULL, &quot;Not yet initialized&quot;);</span>
<span class="line-removed">230     assert(_optional_region_length != 0, &quot;No region to remove&quot;);</span>
<span class="line-removed">231     _optional_region_length--;</span>
<span class="line-removed">232     HeapRegion* removed = _optional_regions[_optional_region_length];</span>
<span class="line-removed">233     _optional_regions[_optional_region_length] = NULL;</span>
<span class="line-removed">234     return removed;</span>
<span class="line-removed">235   }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 private:</span>
<span class="line-removed">238   // Update the incremental collection set information when adding a region.</span>
<span class="line-removed">239   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-removed">240 };</span>
<span class="line-removed">241 </span>
<span class="line-removed">242 // Helper class to manage the optional regions in a Mixed collection.</span>
<span class="line-removed">243 class G1OptionalCSet : public StackObj {</span>
<span class="line-removed">244 private:</span>
<span class="line-removed">245   G1CollectionSet* _cset;</span>
<span class="line-removed">246   G1ParScanThreadStateSet* _pset;</span>
<span class="line-removed">247   uint _current_index;</span>
<span class="line-removed">248   uint _current_limit;</span>
<span class="line-removed">249   bool _prepare_failed;</span>
<span class="line-removed">250   bool _evacuation_failed;</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   void prepare_to_evacuate_optional_region(HeapRegion* hr);</span>
<span class="line-removed">253 </span>
<span class="line-removed">254 public:</span>
<span class="line-removed">255   static const uint InvalidCSetIndex = UINT_MAX;</span>
<span class="line-removed">256 </span>
<span class="line-removed">257   G1OptionalCSet(G1CollectionSet* cset, G1ParScanThreadStateSet* pset) :</span>
<span class="line-removed">258     _cset(cset),</span>
<span class="line-removed">259     _pset(pset),</span>
<span class="line-removed">260     _current_index(0),</span>
<span class="line-removed">261     _current_limit(0),</span>
<span class="line-removed">262     _prepare_failed(false),</span>
<span class="line-removed">263     _evacuation_failed(false) { }</span>
<span class="line-removed">264   // The destructor returns regions to the collection set candidates set and</span>
<span class="line-removed">265   // frees the optional structure in the collection set.</span>
<span class="line-removed">266   ~G1OptionalCSet();</span>
<span class="line-removed">267 </span>
<span class="line-removed">268   uint current_index() { return _current_index; }</span>
<span class="line-removed">269   uint current_limit() { return _current_limit; }</span>
<span class="line-removed">270 </span>
<span class="line-removed">271   uint size();</span>
<span class="line-removed">272   bool is_empty();</span>
<span class="line-removed">273 </span>
<span class="line-removed">274   HeapRegion* region_at(uint index);</span>
<span class="line-removed">275 </span>
<span class="line-removed">276   // Prepare a set of regions for optional evacuation.</span>
<span class="line-removed">277   void prepare_evacuation(double time_left_ms);</span>
<span class="line-removed">278   bool prepare_failed();</span>
<span class="line-removed">279 </span>
<span class="line-removed">280   // Complete the evacuation of the previously prepared</span>
<span class="line-removed">281   // regions by updating their state and check for failures.</span>
<span class="line-removed">282   void complete_evacuation();</span>
<span class="line-removed">283   bool evacuation_failed();</span>
284 };
285 
286 #endif // SHARE_GC_G1_G1COLLECTIONSET_HPP
</pre>
</td>
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1COLLECTIONSET_HPP
 26 #define SHARE_GC_G1_G1COLLECTIONSET_HPP
 27 
 28 #include &quot;utilities/debug.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 class G1CollectedHeap;
 32 class G1CollectionSetCandidates;
 33 class G1CollectorState;
 34 class G1GCPhaseTimes;
 35 class G1ParScanThreadStateSet;
 36 class G1Policy;
 37 class G1SurvivorRegions;
 38 class HeapRegion;
<span class="line-added"> 39 class HeapRegionClaimer;</span>
 40 class HeapRegionClosure;
 41 
<span class="line-added"> 42 // The collection set.</span>
<span class="line-added"> 43 //</span>
<span class="line-added"> 44 // The set of regions that are evacuated during an evacuation pause.</span>
<span class="line-added"> 45 //</span>
<span class="line-added"> 46 // At the end of a collection, before freeing the collection set, this set</span>
<span class="line-added"> 47 // contains all regions that were evacuated during this collection:</span>
<span class="line-added"> 48 //</span>
<span class="line-added"> 49 // - survivor regions from the last collection (if any)</span>
<span class="line-added"> 50 // - eden regions allocated by the mutator</span>
<span class="line-added"> 51 // - old gen regions evacuated during mixed gc</span>
<span class="line-added"> 52 //</span>
<span class="line-added"> 53 // This set is built incrementally at mutator time as regions are retired, and</span>
<span class="line-added"> 54 // if this had been a mixed gc, some additional (during gc) incrementally added</span>
<span class="line-added"> 55 // old regions from the collection set candidates built during the concurrent</span>
<span class="line-added"> 56 // cycle.</span>
<span class="line-added"> 57 //</span>
<span class="line-added"> 58 // A more detailed overview of how the collection set changes over time follows:</span>
<span class="line-added"> 59 //</span>
<span class="line-added"> 60 // 0) at the end of GC the survivor regions are added to this collection set.</span>
<span class="line-added"> 61 // 1) the mutator incrementally adds eden regions as they retire</span>
<span class="line-added"> 62 //</span>
<span class="line-added"> 63 // ----- gc starts</span>
<span class="line-added"> 64 //</span>
<span class="line-added"> 65 // 2) prepare (finalize) young regions of the collection set for collection</span>
<span class="line-added"> 66 //    - relabel the survivors as eden</span>
<span class="line-added"> 67 //    - finish up the incremental building that happened at mutator time</span>
<span class="line-added"> 68 //</span>
<span class="line-added"> 69 // iff this is a young-only collection:</span>
<span class="line-added"> 70 //</span>
<span class="line-added"> 71 // a3) evacuate the current collection set in one &quot;initial evacuation&quot; phase</span>
<span class="line-added"> 72 //</span>
<span class="line-added"> 73 // iff this is a mixed collection:</span>
<span class="line-added"> 74 //</span>
<span class="line-added"> 75 // b3) calculate the set of old gen regions we may be able to collect in this</span>
<span class="line-added"> 76 //     collection from the list of collection set candidates.</span>
<span class="line-added"> 77 //     - one part is added to the current collection set</span>
<span class="line-added"> 78 //     - the remainder regions are labeled as optional, and NOT yet added to the</span>
<span class="line-added"> 79 //     collection set.</span>
<span class="line-added"> 80 // b4) evacuate the current collection set in the &quot;initial evacuation&quot; phase</span>
<span class="line-added"> 81 // b5) evacuate the optional regions in the &quot;optional evacuation&quot; phase. This is</span>
<span class="line-added"> 82 //     done in increments (or rounds).</span>
<span class="line-added"> 83 //     b5-1) add a few of the optional regions to the current collection set</span>
<span class="line-added"> 84 //     b5-2) evacuate only these newly added optional regions. For this mechanism we</span>
<span class="line-added"> 85 //     reuse the incremental collection set building infrastructure (used also at</span>
<span class="line-added"> 86 //     mutator time).</span>
<span class="line-added"> 87 //     b5-3) repeat from b5-1 until the policy determines we are done</span>
<span class="line-added"> 88 //</span>
<span class="line-added"> 89 // all collections</span>
<span class="line-added"> 90 //</span>
<span class="line-added"> 91 // 6) free the collection set (contains all regions now; empties collection set</span>
<span class="line-added"> 92 //    afterwards)</span>
<span class="line-added"> 93 // 7) add survivors to this collection set</span>
<span class="line-added"> 94 //</span>
<span class="line-added"> 95 // ----- gc ends</span>
<span class="line-added"> 96 //</span>
<span class="line-added"> 97 // goto 1)</span>
<span class="line-added"> 98 //</span>
<span class="line-added"> 99 // Examples of how the collection set might look over time:</span>
<span class="line-added">100 //</span>
<span class="line-added">101 // Legend:</span>
<span class="line-added">102 // S = survivor, E = eden, O = old.</span>
<span class="line-added">103 // |xxxx| = increment (with increment markers), containing four regions</span>
<span class="line-added">104 //</span>
<span class="line-added">105 // |SSSS|                         ... after step 0), with four survivor regions</span>
<span class="line-added">106 // |SSSSEE|                       ... at step 1), after retiring two eden regions</span>
<span class="line-added">107 // |SSSSEEEE|                     ... after step 1), after retiring four eden regions</span>
<span class="line-added">108 // |EEEEEEEE|                     ... after step 2)</span>
<span class="line-added">109 //</span>
<span class="line-added">110 // iff this is a young-only collection</span>
<span class="line-added">111 //</span>
<span class="line-added">112 // EEEEEEEE||                      ... after step a3), after initial evacuation phase</span>
<span class="line-added">113 // ||                              ... after step 6)</span>
<span class="line-added">114 // |SS|                            ... after step 7), with two survivor regions</span>
<span class="line-added">115 //</span>
<span class="line-added">116 // iff this is a mixed collection</span>
<span class="line-added">117 //</span>
<span class="line-added">118 // |EEEEEEEEOOOO|                  ... after step b3), added four regions to be</span>
<span class="line-added">119 //                                     evacuated in the &quot;initial evacuation&quot; phase</span>
<span class="line-added">120 // EEEEEEEEOOOO||                  ... after step b4), incremental part is empty</span>
<span class="line-added">121 //                                     after evacuation</span>
<span class="line-added">122 // EEEEEEEEOOOO|OO|                ... after step b5.1), added two regions to be</span>
<span class="line-added">123 //                                     evacuated in the first round of the</span>
<span class="line-added">124 //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">125 // EEEEEEEEOOOOOO|O|               ... after step b5.1), added one region to be</span>
<span class="line-added">126 //                                     evacuated in the second round of the</span>
<span class="line-added">127 //                                     &quot;optional evacuation&quot; phase</span>
<span class="line-added">128 // EEEEEEEEOOOOOOO||               ... after step b5), the complete collection set.</span>
<span class="line-added">129 // ||                              ... after step b6)</span>
<span class="line-added">130 // |SSS|                           ... after step 7), with three survivor regions</span>
<span class="line-added">131 //</span>
132 class G1CollectionSet {
133   G1CollectedHeap* _g1h;
134   G1Policy* _policy;
135 
<span class="line-modified">136   // All old gen collection set candidate regions for the current mixed phase.</span>
137   G1CollectionSetCandidates* _candidates;
138 
139   uint _eden_region_length;
140   uint _survivor_region_length;
141   uint _old_region_length;
142 
143   // The actual collection set as a set of region indices.
144   // All entries in _collection_set_regions below _collection_set_cur_length are
<span class="line-modified">145   // assumed to be part of the collection set.</span>
146   // We assume that at any time there is at most only one writer and (one or more)
147   // concurrent readers. This means we are good with using storestore and loadload
148   // barriers on the writer and reader respectively only.
149   uint* _collection_set_regions;
150   volatile size_t _collection_set_cur_length;
151   size_t _collection_set_max_length;
152 
<span class="line-modified">153   // When doing mixed collections we can add old regions to the collection set, which</span>
<span class="line-modified">154   // will be collected only if there is enough time. We call these optional regions.</span>
<span class="line-modified">155   // This member records the current number of regions that are of that type that</span>
<span class="line-modified">156   // correspond to the first x entries in the collection set candidates.</span>
<span class="line-modified">157   uint _num_optional_regions;</span>

158 
159   // The number of bytes in the collection set before the pause. Set from
160   // the incrementally built collection set at the start of an evacuation
<span class="line-modified">161   // pause, and updated as more regions are added to the collection set.</span>

162   size_t _bytes_used_before;
163 
<span class="line-modified">164   // The number of cards in the remembered set in the collection set. Set from</span>
<span class="line-modified">165   // the incrementally built collection set at the start of an evacuation</span>
<span class="line-modified">166   // pause, and updated as more regions are added to the collection set.</span>
<span class="line-modified">167   size_t _recorded_rs_length;</span>

168 
169   enum CSetBuildType {
170     Active,             // We are actively building the collection set
171     Inactive            // We are not actively building the collection set
172   };
173 
174   CSetBuildType _inc_build_state;
<span class="line-added">175   size_t _inc_part_start;</span>
<span class="line-added">176 </span>
<span class="line-added">177   // Information about eden regions in the incremental collection set.</span>
<span class="line-added">178   struct IncCollectionSetRegionStat {</span>
<span class="line-added">179     // The predicted non-copy time that was added to the total incremental value</span>
<span class="line-added">180     // for the collection set.</span>
<span class="line-added">181     double _non_copy_time_ms;</span>
<span class="line-added">182     // The remembered set length that was added to the total incremental value</span>
<span class="line-added">183     // for the collection set.</span>
<span class="line-added">184     size_t _rs_length;</span>
<span class="line-added">185 </span>
<span class="line-added">186 #ifdef ASSERT</span>
<span class="line-added">187     // Resets members to &quot;uninitialized&quot; values.</span>
<span class="line-added">188     void reset() { _rs_length = ~(size_t)0; _non_copy_time_ms = -1.0; }</span>
<span class="line-added">189 #endif</span>
<span class="line-added">190   };</span>
<span class="line-added">191 </span>
<span class="line-added">192   IncCollectionSetRegionStat* _inc_collection_set_stats;</span>
<span class="line-added">193   // The associated information that is maintained while the incremental</span>
<span class="line-added">194   // collection set is being built with *young* regions. Used to populate</span>
<span class="line-added">195   // the recorded info for the evacuation pause.</span>
196 
197   // The number of bytes in the incrementally built collection set.
198   // Used to set _collection_set_bytes_used_before at the start of
199   // an evacuation pause.
200   size_t _inc_bytes_used_before;
201 
202   // The RSet lengths recorded for regions in the CSet. It is updated
203   // by the thread that adds a new region to the CSet. We assume that
204   // only one thread can be allocating a new CSet region (currently,
205   // it does so after taking the Heap_lock) hence no need to
206   // synchronize updates to this field.
<span class="line-modified">207   size_t _inc_recorded_rs_length;</span>
208 
209   // A concurrent refinement thread periodically samples the young
<span class="line-modified">210   // region RSets and needs to update _inc_recorded_rs_length as</span>
211   // the RSets grow. Instead of having to synchronize updates to that
212   // field we accumulate them in this field and add it to
<span class="line-modified">213   // _inc_recorded_rs_length_diff at the start of a GC.</span>
<span class="line-modified">214   size_t _inc_recorded_rs_length_diff;</span>
215 
216   // The predicted elapsed time it will take to collect the regions in
217   // the CSet. This is updated by the thread that adds a new region to
<span class="line-modified">218   // the CSet. See the comment for _inc_recorded_rs_length about</span>
219   // MT-safety assumptions.
<span class="line-modified">220   double _inc_predicted_non_copy_time_ms;</span>
221 
<span class="line-modified">222   // See the comment for _inc_recorded_rs_length_diff.</span>
<span class="line-modified">223   double _inc_predicted_non_copy_time_ms_diff;</span>
224 
<span class="line-modified">225   void set_recorded_rs_length(size_t rs_length);</span>
<span class="line-added">226 </span>
<span class="line-added">227   G1CollectorState* collector_state() const;</span>
228   G1GCPhaseTimes* phase_times();
229 
230   void verify_young_cset_indices() const NOT_DEBUG_RETURN;



231 
<span class="line-added">232   double predict_region_non_copy_time_ms(HeapRegion* hr) const;</span>
<span class="line-added">233 </span>
<span class="line-added">234   // Update the incremental collection set information when adding a region.</span>
<span class="line-added">235   void add_young_region_common(HeapRegion* hr);</span>
<span class="line-added">236 </span>
<span class="line-added">237   // Add old region &quot;hr&quot; to the collection set.</span>
<span class="line-added">238   void add_old_region(HeapRegion* hr);</span>
<span class="line-added">239   void free_optional_regions();</span>
<span class="line-added">240 </span>
<span class="line-added">241   // Add old region &quot;hr&quot; to optional collection set.</span>
<span class="line-added">242   void add_optional_region(HeapRegion* hr);</span>
<span class="line-added">243 </span>
<span class="line-added">244   void move_candidates_to_collection_set(uint num_regions);</span>
<span class="line-added">245 </span>
<span class="line-added">246   // Finalize the young part of the initial collection set. Relabel survivor regions</span>
<span class="line-added">247   // as Eden and calculate a prediction on how long the evacuation of all young regions</span>
<span class="line-added">248   // will take.</span>
<span class="line-added">249   double finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors);</span>
<span class="line-added">250   // Perform any final calculations on the incremental collection set fields before we</span>
<span class="line-added">251   // can use them.</span>
<span class="line-added">252   void finalize_incremental_building();</span>
<span class="line-added">253 </span>
<span class="line-added">254   // Select the old regions of the initial collection set and determine how many optional</span>
<span class="line-added">255   // regions we might be able to evacuate in this pause.</span>
<span class="line-added">256   void finalize_old_part(double time_remaining_ms);</span>
<span class="line-added">257 </span>
<span class="line-added">258   // Iterate the part of the collection set given by the offset and length applying the given</span>
<span class="line-added">259   // HeapRegionClosure. The worker_id will determine where in the part to start the iteration</span>
<span class="line-added">260   // to allow for more efficient parallel iteration.</span>
<span class="line-added">261   void iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">262                          HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">263                          size_t offset,</span>
<span class="line-added">264                          size_t length,</span>
<span class="line-added">265                          uint worker_id,</span>
<span class="line-added">266                          uint total_workers) const;</span>
267 public:
268   G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy);
269   ~G1CollectionSet();
270 
271   // Initializes the collection set giving the maximum possible length of the collection set.
272   void initialize(uint max_region_length);


273 
274   void clear_candidates();
275 
276   void set_candidates(G1CollectionSetCandidates* candidates) {
277     assert(_candidates == NULL, &quot;Trying to replace collection set candidates.&quot;);
278     _candidates = candidates;
279   }
280   G1CollectionSetCandidates* candidates() { return _candidates; }
281 
282   void init_region_lengths(uint eden_cset_region_length,
283                            uint survivor_cset_region_length);
284 


285   uint region_length() const       { return young_region_length() +
286                                             old_region_length(); }
287   uint young_region_length() const { return eden_region_length() +
288                                             survivor_region_length(); }
289 
290   uint eden_region_length() const     { return _eden_region_length;     }
291   uint survivor_region_length() const { return _survivor_region_length; }
292   uint old_region_length() const      { return _old_region_length;      }
<span class="line-modified">293   uint optional_region_length() const { return _num_optional_regions; }</span>
<span class="line-added">294 </span>
<span class="line-added">295   // Reset the contents of the collection set.</span>
<span class="line-added">296   void clear();</span>
297 
298   // Incremental collection set support
299 
300   // Initialize incremental collection set info.
301   void start_incremental_building();
<span class="line-added">302   // Start a new collection set increment.</span>
<span class="line-added">303   void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }</span>
<span class="line-added">304   // Stop adding regions to the current collection set increment.</span>
<span class="line-added">305   void stop_incremental_building() { _inc_build_state = Inactive; }</span>
306 
<span class="line-modified">307   // Iterate over the current collection set increment applying the given HeapRegionClosure</span>
<span class="line-modified">308   // from a starting position determined by the given worker id.</span>
<span class="line-modified">309   void iterate_incremental_part_from(HeapRegionClosure* cl, HeapRegionClaimer* hr_claimer, uint worker_id, uint total_workers) const;</span>
310 
<span class="line-modified">311   // Returns the length of the current increment in number of regions.</span>
<span class="line-modified">312   size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }</span>
<span class="line-added">313   // Returns the length of the whole current collection set in number of regions</span>
<span class="line-added">314   size_t cur_length() const { return _collection_set_cur_length; }</span>
315 
<span class="line-modified">316   // Iterate over the entire collection set (all increments calculated so far), applying</span>
<span class="line-modified">317   // the given HeapRegionClosure on all of them.</span>

318   void iterate(HeapRegionClosure* cl) const;
<span class="line-added">319   void par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">320                    HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">321                    uint worker_id,</span>
<span class="line-added">322                    uint total_workers) const;</span>
323 
<span class="line-modified">324   void iterate_optional(HeapRegionClosure* cl) const;</span>






325 
<span class="line-modified">326   size_t recorded_rs_length() { return _recorded_rs_length; }</span>
327 
328   size_t bytes_used_before() const {
329     return _bytes_used_before;
330   }
331 
332   void reset_bytes_used_before() {
333     _bytes_used_before = 0;
334   }
335 
<span class="line-modified">336   // Finalize the initial collection set consisting of all young regions potentially a</span>
<span class="line-modified">337   // few old gen regions.</span>
<span class="line-modified">338   void finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);</span>
<span class="line-modified">339   // Finalize the next collection set from the set of available optional old gen regions.</span>
<span class="line-modified">340   bool finalize_optional_for_evacuation(double remaining_pause_time);</span>
<span class="line-modified">341   // Abandon (clean up) optional collection set regions that were not evacuated in this</span>
<span class="line-modified">342   // pause.</span>
<span class="line-modified">343   void abandon_optional_collection_set(G1ParScanThreadStateSet* pss);</span>


344 
345   // Update information about hr in the aggregated information for
346   // the incrementally built collection set.
347   void update_young_region_prediction(HeapRegion* hr, size_t new_rs_length);
348 
349   // Add eden region to the collection set.
350   void add_eden_region(HeapRegion* hr);
351 
352   // Add survivor region to the collection set.
353   void add_survivor_regions(HeapRegion* hr);
354 
355 #ifndef PRODUCT
356   bool verify_young_ages();
357 
358   void print(outputStream* st);
359 #endif // !PRODUCT



































































360 };
361 
362 #endif // SHARE_GC_G1_G1COLLECTIONSET_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectionSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSetCandidates.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
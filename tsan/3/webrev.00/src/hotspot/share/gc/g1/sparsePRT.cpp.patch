diff a/src/hotspot/share/gc/g1/sparsePRT.cpp b/src/hotspot/share/gc/g1/sparsePRT.cpp
--- a/src/hotspot/share/gc/g1/sparsePRT.cpp
+++ b/src/hotspot/share/gc/g1/sparsePRT.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,11 +28,10 @@
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/g1/sparsePRT.hpp"
 #include "gc/shared/cardTableBarrierSet.hpp"
 #include "gc/shared/space.inline.hpp"
 #include "memory/allocation.inline.hpp"
-#include "runtime/atomic.hpp"
 #include "runtime/mutexLocker.hpp"
 
 // Check that the size of the SparsePRTEntry is evenly divisible by the maximum
 // member type to avoid SIGBUS when accessing them.
 STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);
@@ -55,23 +54,23 @@
     }
   }
   return false;
 }
 
-SparsePRTEntry::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {
+SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {
   for (int i = 0; i < num_valid_cards(); i++) {
     if (card(i) == card_index) {
-      return found;
+      return SparsePRT::found;
     }
   }
   if (num_valid_cards() < cards_num() - 1) {
     _cards[_next_null] = (card_elem_t)card_index;
     _next_null++;
-    return added;
+    return SparsePRT::added;
    }
   // Otherwise, we're full.
-  return overflow;
+  return SparsePRT::overflow;
 }
 
 void SparsePRTEntry::copy_cards(card_elem_t* cards) const {
   memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));
 }
@@ -90,11 +89,10 @@
 RSHashTable::RSHashTable(size_t capacity) :
   _num_entries(0),
   _capacity(capacity),
   _capacity_mask(capacity-1),
   _occupied_entries(0),
-  _occupied_cards(0),
   _entries(NULL),
   _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),
   _free_region(0),
   _free_list(NullEntry)
 {
@@ -102,23 +100,16 @@
   _entries = (SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC);
   clear();
 }
 
 RSHashTable::~RSHashTable() {
-  if (_entries != NULL) {
-    FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);
-    _entries = NULL;
-  }
-  if (_buckets != NULL) {
-    FREE_C_HEAP_ARRAY(int, _buckets);
-    _buckets = NULL;
-  }
+  FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);
+  FREE_C_HEAP_ARRAY(int, _buckets);
 }
 
 void RSHashTable::clear() {
   _occupied_entries = 0;
-  _occupied_cards = 0;
   guarantee(_entries != NULL, "INV");
   guarantee(_buckets != NULL, "INV");
 
   guarantee(_capacity <= ((size_t)1 << (sizeof(int)*BitsPerByte-1)) - 1,
                 "_capacity too large");
@@ -128,18 +119,17 @@
   memset((void*)_buckets, NullEntry, _capacity * sizeof(int));
   _free_list = NullEntry;
   _free_region = 0;
 }
 
-bool RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {
+SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {
   SparsePRTEntry* e = entry_for_region_ind_create(region_ind);
   assert(e != NULL && e->r_ind() == region_ind,
          "Postcondition of call above.");
-  SparsePRTEntry::AddCardResult res = e->add_card(card_index);
-  if (res == SparsePRTEntry::added) _occupied_cards++;
+  SparsePRT::AddCardResult res = e->add_card(card_index);
   assert(e->num_valid_cards() > 0, "Postcondition");
-  return res != SparsePRTEntry::overflow;
+  return res;
 }
 
 SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {
   int ind = (int) (region_ind & capacity_mask());
   int cur_ind = _buckets[ind];
@@ -168,11 +158,10 @@
   }
 
   if (cur_ind == NullEntry) return false;
   // Otherwise, splice out "cur".
   *prev_loc = cur->next_index();
-  _occupied_cards -= cur->num_valid_cards();
   free_entry(cur_ind);
   _occupied_entries--;
   return true;
 }
 
@@ -214,11 +203,10 @@
 
 void RSHashTable::add_entry(SparsePRTEntry* e) {
   assert(e->num_valid_cards() > 0, "Precondition.");
   SparsePRTEntry* e2 = entry_for_region_ind_create(e->r_ind());
   e->copy_cards(e2);
-  _occupied_cards += e2->num_valid_cards();
   assert(e2->num_valid_cards() > 0, "Postcondition.");
 }
 
 CardIdx_t RSHashTableIter::find_first_card_in_list() {
   while (_bl_ind != RSHashTable::NullEntry) {
@@ -273,10 +261,23 @@
   }
   // Otherwise, there were no entry.
   return false;
 }
 
+bool RSHashTableBucketIter::has_next(SparsePRTEntry*& entry) {
+  while (_bl_ind == RSHashTable::NullEntry)  {
+    if (_tbl_ind == (int)_rsht->capacity() - 1) {
+      return false;
+    }
+    _tbl_ind++;
+    _bl_ind = _rsht->_buckets[_tbl_ind];
+  }
+  entry = _rsht->entry(_bl_ind);
+  _bl_ind = entry->next_index();
+  return true;
+}
+
 bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {
   SparsePRTEntry* e = get_entry(region_index);
   return (e != NULL && e->contains_card(card_index));
 }
 
@@ -301,11 +302,11 @@
   // We ignore "_cur" here, because it either = _next, or else it is
   // on the deleted list.
   return sizeof(SparsePRT) + _table->mem_size();
 }
 
-bool SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {
+SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {
   if (_table->should_expand()) {
     expand();
   }
   return _table->add_card(region_id, card_index);
 }

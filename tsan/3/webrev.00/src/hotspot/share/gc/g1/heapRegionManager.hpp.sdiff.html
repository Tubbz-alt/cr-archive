<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONMANAGER_HPP
 26 #define SHARE_GC_G1_HEAPREGIONMANAGER_HPP
 27 
 28 #include &quot;gc/g1/g1BiasedArray.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
 30 #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
 31 #include &quot;gc/g1/heapRegionSet.hpp&quot;
<span class="line-removed"> 32 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 33 #include &quot;services/memoryUsage.hpp&quot;
 34 
 35 class HeapRegion;
 36 class HeapRegionClosure;
 37 class HeapRegionClaimer;
 38 class FreeRegionList;
 39 class WorkGang;
 40 
 41 class G1HeapRegionTable : public G1BiasedMappedArray&lt;HeapRegion*&gt; {
 42  protected:
 43   virtual HeapRegion* default_value() const { return NULL; }
 44 };
 45 
 46 // This class keeps track of the actual heap memory, auxiliary data
 47 // and its metadata (i.e., HeapRegion instances) and the list of free regions.
 48 //
 49 // This allows maximum flexibility for deciding what to commit or uncommit given
 50 // a request from outside.
 51 //
 52 // HeapRegions are kept in the _regions array in address order. A region&#39;s
</pre>
<hr />
<pre>
 93   // Pass down commit calls to the VirtualSpace.
 94   void commit_regions(uint index, size_t num_regions = 1, WorkGang* pretouch_gang = NULL);
 95 
 96   // Notify other data structures about change in the heap layout.
 97   void update_committed_space(HeapWord* old_end, HeapWord* new_end);
 98 
 99   // Find a contiguous set of empty or uncommitted regions of length num and return
100   // the index of the first region or G1_NO_HRM_INDEX if the search was unsuccessful.
101   // If only_empty is true, only empty regions are considered.
102   // Searches from bottom to top of the heap, doing a first-fit.
103   uint find_contiguous(size_t num, bool only_empty);
104   // Finds the next sequence of unavailable regions starting from start_idx. Returns the
105   // length of the sequence found. If this result is zero, no such sequence could be found,
106   // otherwise res_idx indicates the start index of these regions.
107   uint find_unavailable_from_idx(uint start_idx, uint* res_idx) const;
108   // Finds the next sequence of empty regions starting from start_idx, going backwards in
109   // the heap. Returns the length of the sequence found. If this value is zero, no
110   // sequence could be found, otherwise res_idx contains the start index of this range.
111   uint find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const;
112 



113 protected:
114   G1HeapRegionTable _regions;
115   G1RegionToSpaceMapper* _heap_mapper;
116   G1RegionToSpaceMapper* _prev_bitmap_mapper;
117   G1RegionToSpaceMapper* _next_bitmap_mapper;
118   FreeRegionList _free_list;
119 
120   void make_regions_available(uint index, uint num_regions = 1, WorkGang* pretouch_gang = NULL);
121   void uncommit_regions(uint index, size_t num_regions = 1);
122   // Allocate a new HeapRegion for the given index.
123   HeapRegion* new_heap_region(uint hrm_index);
124 #ifdef ASSERT
125 public:
126   bool is_free(HeapRegion* hr) const;
127 #endif
128 public:
129   // Empty constructor, we&#39;ll initialize it with the initialize() method.
130   HeapRegionManager();
131 
<span class="line-modified">132   static HeapRegionManager* create_manager(G1CollectedHeap* heap, G1CollectorPolicy* policy);</span>
133 
134   virtual void initialize(G1RegionToSpaceMapper* heap_storage,
135                           G1RegionToSpaceMapper* prev_bitmap,
136                           G1RegionToSpaceMapper* next_bitmap,
137                           G1RegionToSpaceMapper* bot,
138                           G1RegionToSpaceMapper* cardtable,
139                           G1RegionToSpaceMapper* card_counts);
140 
141   // Prepare heap regions before and after full collection.
142   // Nothing to be done in this class.
143   virtual void prepare_for_full_collection_start() {}
144   virtual void prepare_for_full_collection_end() {}
145 
146   // Return the &quot;dummy&quot; region used for G1AllocRegion. This is currently a hardwired
147   // new HeapRegion that owns HeapRegion at index 0. Since at the moment we commit
148   // the heap from the lowest address, this region (and its associated data
149   // structures) are available and we do not need to check further.
150   virtual HeapRegion* get_dummy_region() { return new_heap_region(0); }
151 
152   // Return the HeapRegion at the given index. Assume that the index
</pre>
<hr />
<pre>
154   inline HeapRegion* at(uint index) const;
155 
156   // Return the HeapRegion at the given index, NULL if the index
157   // is for an unavailable region.
158   inline HeapRegion* at_or_null(uint index) const;
159 
160   // Returns whether the given region is available for allocation.
161   bool is_available(uint region) const;
162 
163   // Return the next region (by index) that is part of the same
164   // humongous object that hr is part of.
165   inline HeapRegion* next_region_in_humongous(HeapRegion* hr) const;
166 
167   // If addr is within the committed space return its corresponding
168   // HeapRegion, otherwise return NULL.
169   inline HeapRegion* addr_to_region(HeapWord* addr) const;
170 
171   // Insert the given region into the free region list.
172   inline void insert_into_free_list(HeapRegion* hr);
173 



174   // Insert the given region list into the global free region list.
175   void insert_list_into_free_list(FreeRegionList* list) {
176     _free_list.add_ordered(list);
177   }
178 
<span class="line-modified">179   virtual HeapRegion* allocate_free_region(HeapRegionType type) {</span>
<span class="line-modified">180     HeapRegion* hr = _free_list.remove_region(!type.is_young());</span>
<span class="line-removed">181 </span>
<span class="line-removed">182     if (hr != NULL) {</span>
<span class="line-removed">183       assert(hr-&gt;next() == NULL, &quot;Single region should not have next&quot;);</span>
<span class="line-removed">184       assert(is_available(hr-&gt;hrm_index()), &quot;Must be committed&quot;);</span>
<span class="line-removed">185     }</span>
<span class="line-removed">186     return hr;</span>
<span class="line-removed">187   }</span>
188 
189   inline void allocate_free_regions_starting_at(uint first, uint num_regions);
190 
191   // Remove all regions from the free list.
192   void remove_all_free_regions() {
193     _free_list.remove_all();
194   }
195 
196   // Return the number of committed free regions in the heap.
197   uint num_free_regions() const {
198     return _free_list.length();
199   }
200 




201   size_t total_free_bytes() const {
202     return num_free_regions() * HeapRegion::GrainBytes;
203   }
204 
205   // Return the number of available (uncommitted) regions.
206   uint available() const { return max_length() - length(); }
207 
208   // Return the number of regions that have been committed in the heap.
209   uint length() const { return _num_committed; }
210 
211   // Return the maximum number of regions in the heap.
212   uint max_length() const { return (uint)_regions.length(); }
213 
214   // Return maximum number of regions that heap can expand to.
215   virtual uint max_expandable_length() const { return (uint)_regions.length(); }
216 
217   MemoryUsage get_auxiliary_data_memory_usage() const;
218 
219   MemRegion reserved() const { return MemRegion(heap_bottom(), heap_end()); }
220 
221   // Expand the sequence to reflect that the heap has grown. Either create new
222   // HeapRegions, or re-use existing ones. Returns the number of regions the
223   // sequence was expanded by. If a HeapRegion allocation fails, the resulting
224   // number of regions might be smaller than what&#39;s desired.
225   virtual uint expand_by(uint num_regions, WorkGang* pretouch_workers);
226 
227   // Makes sure that the regions from start to start+num_regions-1 are available
228   // for allocation. Returns the number of regions that were committed to achieve
229   // this.
230   virtual uint expand_at(uint start, uint num_regions, WorkGang* pretouch_workers);
231 



232   // Find a contiguous set of empty regions of length num. Returns the start index of
233   // that set, or G1_NO_HRM_INDEX.
234   virtual uint find_contiguous_only_empty(size_t num) { return find_contiguous(num, true); }
235   // Find a contiguous set of empty or unavailable regions of length num. Returns the
236   // start index of that set, or G1_NO_HRM_INDEX.
237   virtual uint find_contiguous_empty_or_unavailable(size_t num) { return find_contiguous(num, false); }
238 
239   HeapRegion* next_region_in_heap(const HeapRegion* r) const;
240 
241   // Find the highest free or uncommitted region in the reserved heap,
242   // and if uncommitted, commit it. If none are available, return G1_NO_HRM_INDEX.
243   // Set the &#39;expanded&#39; boolean true if a new region was committed.
244   virtual uint find_highest_free(bool* expanded);
245 
246   // Allocate the regions that contain the address range specified, committing the
247   // regions if necessary. Return false if any of the regions is already committed
248   // and not free, and return the number of regions newly committed in commit_count.
249   bool allocate_containing_regions(MemRegion range, size_t* commit_count, WorkGang* pretouch_workers);
250 
251   // Apply blk-&gt;do_heap_region() on all committed regions in address order,
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONMANAGER_HPP
 26 #define SHARE_GC_G1_HEAPREGIONMANAGER_HPP
 27 
 28 #include &quot;gc/g1/g1BiasedArray.hpp&quot;

 29 #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
 30 #include &quot;gc/g1/heapRegionSet.hpp&quot;

 31 #include &quot;services/memoryUsage.hpp&quot;
 32 
 33 class HeapRegion;
 34 class HeapRegionClosure;
 35 class HeapRegionClaimer;
 36 class FreeRegionList;
 37 class WorkGang;
 38 
 39 class G1HeapRegionTable : public G1BiasedMappedArray&lt;HeapRegion*&gt; {
 40  protected:
 41   virtual HeapRegion* default_value() const { return NULL; }
 42 };
 43 
 44 // This class keeps track of the actual heap memory, auxiliary data
 45 // and its metadata (i.e., HeapRegion instances) and the list of free regions.
 46 //
 47 // This allows maximum flexibility for deciding what to commit or uncommit given
 48 // a request from outside.
 49 //
 50 // HeapRegions are kept in the _regions array in address order. A region&#39;s
</pre>
<hr />
<pre>
 91   // Pass down commit calls to the VirtualSpace.
 92   void commit_regions(uint index, size_t num_regions = 1, WorkGang* pretouch_gang = NULL);
 93 
 94   // Notify other data structures about change in the heap layout.
 95   void update_committed_space(HeapWord* old_end, HeapWord* new_end);
 96 
 97   // Find a contiguous set of empty or uncommitted regions of length num and return
 98   // the index of the first region or G1_NO_HRM_INDEX if the search was unsuccessful.
 99   // If only_empty is true, only empty regions are considered.
100   // Searches from bottom to top of the heap, doing a first-fit.
101   uint find_contiguous(size_t num, bool only_empty);
102   // Finds the next sequence of unavailable regions starting from start_idx. Returns the
103   // length of the sequence found. If this result is zero, no such sequence could be found,
104   // otherwise res_idx indicates the start index of these regions.
105   uint find_unavailable_from_idx(uint start_idx, uint* res_idx) const;
106   // Finds the next sequence of empty regions starting from start_idx, going backwards in
107   // the heap. Returns the length of the sequence found. If this value is zero, no
108   // sequence could be found, otherwise res_idx contains the start index of this range.
109   uint find_empty_from_idx_reverse(uint start_idx, uint* res_idx) const;
110 
<span class="line-added">111   // Checks the G1MemoryNodeManager to see if this region is on the preferred node.</span>
<span class="line-added">112   bool is_on_preferred_index(uint region_index, uint preferred_node_index);</span>
<span class="line-added">113 </span>
114 protected:
115   G1HeapRegionTable _regions;
116   G1RegionToSpaceMapper* _heap_mapper;
117   G1RegionToSpaceMapper* _prev_bitmap_mapper;
118   G1RegionToSpaceMapper* _next_bitmap_mapper;
119   FreeRegionList _free_list;
120 
121   void make_regions_available(uint index, uint num_regions = 1, WorkGang* pretouch_gang = NULL);
122   void uncommit_regions(uint index, size_t num_regions = 1);
123   // Allocate a new HeapRegion for the given index.
124   HeapRegion* new_heap_region(uint hrm_index);
125 #ifdef ASSERT
126 public:
127   bool is_free(HeapRegion* hr) const;
128 #endif
129 public:
130   // Empty constructor, we&#39;ll initialize it with the initialize() method.
131   HeapRegionManager();
132 
<span class="line-modified">133   static HeapRegionManager* create_manager(G1CollectedHeap* heap);</span>
134 
135   virtual void initialize(G1RegionToSpaceMapper* heap_storage,
136                           G1RegionToSpaceMapper* prev_bitmap,
137                           G1RegionToSpaceMapper* next_bitmap,
138                           G1RegionToSpaceMapper* bot,
139                           G1RegionToSpaceMapper* cardtable,
140                           G1RegionToSpaceMapper* card_counts);
141 
142   // Prepare heap regions before and after full collection.
143   // Nothing to be done in this class.
144   virtual void prepare_for_full_collection_start() {}
145   virtual void prepare_for_full_collection_end() {}
146 
147   // Return the &quot;dummy&quot; region used for G1AllocRegion. This is currently a hardwired
148   // new HeapRegion that owns HeapRegion at index 0. Since at the moment we commit
149   // the heap from the lowest address, this region (and its associated data
150   // structures) are available and we do not need to check further.
151   virtual HeapRegion* get_dummy_region() { return new_heap_region(0); }
152 
153   // Return the HeapRegion at the given index. Assume that the index
</pre>
<hr />
<pre>
155   inline HeapRegion* at(uint index) const;
156 
157   // Return the HeapRegion at the given index, NULL if the index
158   // is for an unavailable region.
159   inline HeapRegion* at_or_null(uint index) const;
160 
161   // Returns whether the given region is available for allocation.
162   bool is_available(uint region) const;
163 
164   // Return the next region (by index) that is part of the same
165   // humongous object that hr is part of.
166   inline HeapRegion* next_region_in_humongous(HeapRegion* hr) const;
167 
168   // If addr is within the committed space return its corresponding
169   // HeapRegion, otherwise return NULL.
170   inline HeapRegion* addr_to_region(HeapWord* addr) const;
171 
172   // Insert the given region into the free region list.
173   inline void insert_into_free_list(HeapRegion* hr);
174 
<span class="line-added">175   // Rebuild the free region list from scratch.</span>
<span class="line-added">176   void rebuild_free_list(WorkGang* workers);</span>
<span class="line-added">177 </span>
178   // Insert the given region list into the global free region list.
179   void insert_list_into_free_list(FreeRegionList* list) {
180     _free_list.add_ordered(list);
181   }
182 
<span class="line-modified">183   // Allocate a free region with specific node index. If fails allocate with next node index.</span>
<span class="line-modified">184   virtual HeapRegion* allocate_free_region(HeapRegionType type, uint requested_node_index);</span>







185 
186   inline void allocate_free_regions_starting_at(uint first, uint num_regions);
187 
188   // Remove all regions from the free list.
189   void remove_all_free_regions() {
190     _free_list.remove_all();
191   }
192 
193   // Return the number of committed free regions in the heap.
194   uint num_free_regions() const {
195     return _free_list.length();
196   }
197 
<span class="line-added">198   uint num_free_regions(uint node_index) const {</span>
<span class="line-added">199     return _free_list.length(node_index);</span>
<span class="line-added">200   }</span>
<span class="line-added">201 </span>
202   size_t total_free_bytes() const {
203     return num_free_regions() * HeapRegion::GrainBytes;
204   }
205 
206   // Return the number of available (uncommitted) regions.
207   uint available() const { return max_length() - length(); }
208 
209   // Return the number of regions that have been committed in the heap.
210   uint length() const { return _num_committed; }
211 
212   // Return the maximum number of regions in the heap.
213   uint max_length() const { return (uint)_regions.length(); }
214 
215   // Return maximum number of regions that heap can expand to.
216   virtual uint max_expandable_length() const { return (uint)_regions.length(); }
217 
218   MemoryUsage get_auxiliary_data_memory_usage() const;
219 
220   MemRegion reserved() const { return MemRegion(heap_bottom(), heap_end()); }
221 
222   // Expand the sequence to reflect that the heap has grown. Either create new
223   // HeapRegions, or re-use existing ones. Returns the number of regions the
224   // sequence was expanded by. If a HeapRegion allocation fails, the resulting
225   // number of regions might be smaller than what&#39;s desired.
226   virtual uint expand_by(uint num_regions, WorkGang* pretouch_workers);
227 
228   // Makes sure that the regions from start to start+num_regions-1 are available
229   // for allocation. Returns the number of regions that were committed to achieve
230   // this.
231   virtual uint expand_at(uint start, uint num_regions, WorkGang* pretouch_workers);
232 
<span class="line-added">233   // Try to expand on the given node index.</span>
<span class="line-added">234   virtual uint expand_on_preferred_node(uint node_index);</span>
<span class="line-added">235 </span>
236   // Find a contiguous set of empty regions of length num. Returns the start index of
237   // that set, or G1_NO_HRM_INDEX.
238   virtual uint find_contiguous_only_empty(size_t num) { return find_contiguous(num, true); }
239   // Find a contiguous set of empty or unavailable regions of length num. Returns the
240   // start index of that set, or G1_NO_HRM_INDEX.
241   virtual uint find_contiguous_empty_or_unavailable(size_t num) { return find_contiguous(num, false); }
242 
243   HeapRegion* next_region_in_heap(const HeapRegion* r) const;
244 
245   // Find the highest free or uncommitted region in the reserved heap,
246   // and if uncommitted, commit it. If none are available, return G1_NO_HRM_INDEX.
247   // Set the &#39;expanded&#39; boolean true if a new region was committed.
248   virtual uint find_highest_free(bool* expanded);
249 
250   // Allocate the regions that contain the address range specified, committing the
251   // regions if necessary. Return false if any of the regions is already committed
252   // and not free, and return the number of regions newly committed in commit_count.
253   bool allocate_containing_regions(MemRegion range, size_t* commit_count, WorkGang* pretouch_workers);
254 
255   // Apply blk-&gt;do_heap_region() on all committed regions in address order,
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
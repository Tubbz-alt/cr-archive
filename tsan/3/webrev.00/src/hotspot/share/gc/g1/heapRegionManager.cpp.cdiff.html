<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/heapRegionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegion.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,18 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
  #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  
  class MasterFreeRegionListChecker : public HeapRegionSetChecker {
  public:
    void check_mt_safety() {
<span class="line-new-header">--- 21,22 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1NUMAStats.hpp&quot;</span>
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
  #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
<span class="line-modified">! #include &quot;logging/logStream.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;utilities/bitMap.inline.hpp&quot;
  
  class MasterFreeRegionListChecker : public HeapRegionSetChecker {
  public:
    void check_mt_safety() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,13 ***</span>
    _prev_bitmap_mapper(NULL),
    _next_bitmap_mapper(NULL),
    _free_list(&quot;Free list&quot;, new MasterFreeRegionListChecker())
  { }
  
<span class="line-modified">! HeapRegionManager* HeapRegionManager::create_manager(G1CollectedHeap* heap, G1CollectorPolicy* policy) {</span>
<span class="line-modified">!   if (policy-&gt;is_heterogeneous_heap()) {</span>
<span class="line-modified">!     return new HeterogeneousHeapRegionManager((uint)(policy-&gt;max_heap_byte_size() / HeapRegion::GrainBytes) /*heap size as num of regions*/);</span>
    }
    return new HeapRegionManager();
  }
  
  void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,
<span class="line-new-header">--- 70,13 ---</span>
    _prev_bitmap_mapper(NULL),
    _next_bitmap_mapper(NULL),
    _free_list(&quot;Free list&quot;, new MasterFreeRegionListChecker())
  { }
  
<span class="line-modified">! HeapRegionManager* HeapRegionManager::create_manager(G1CollectedHeap* heap) {</span>
<span class="line-modified">!   if (G1Arguments::is_heterogeneous_heap()) {</span>
<span class="line-modified">!     return new HeterogeneousHeapRegionManager((uint)(G1Arguments::heap_max_size_bytes() / HeapRegion::GrainBytes) /*heap size as num of regions*/);</span>
    }
    return new HeapRegionManager();
  }
  
  void HeapRegionManager::initialize(G1RegionToSpaceMapper* heap_storage,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,10 ***</span>
<span class="line-new-header">--- 105,38 ---</span>
  
  bool HeapRegionManager::is_available(uint region) const {
    return _available_map.at(region);
  }
  
<span class="line-added">+ HeapRegion* HeapRegionManager::allocate_free_region(HeapRegionType type, uint requested_node_index) {</span>
<span class="line-added">+   HeapRegion* hr = NULL;</span>
<span class="line-added">+   bool from_head = !type.is_young();</span>
<span class="line-added">+   G1NUMA* numa = G1NUMA::numa();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (requested_node_index != G1NUMA::AnyNodeIndex &amp;&amp; numa-&gt;is_enabled()) {</span>
<span class="line-added">+     // Try to allocate with requested node index.</span>
<span class="line-added">+     hr = _free_list.remove_region_with_node_index(from_head, requested_node_index);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (hr == NULL) {</span>
<span class="line-added">+     // If there&#39;s a single active node or we did not get a region from our requested node,</span>
<span class="line-added">+     // try without requested node index.</span>
<span class="line-added">+     hr = _free_list.remove_region(from_head);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (hr != NULL) {</span>
<span class="line-added">+     assert(hr-&gt;next() == NULL, &quot;Single region should not have next&quot;);</span>
<span class="line-added">+     assert(is_available(hr-&gt;hrm_index()), &quot;Must be committed&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (numa-&gt;is_enabled() &amp;&amp; hr-&gt;node_index() &lt; numa-&gt;num_active_nodes()) {</span>
<span class="line-added">+       numa-&gt;update_statistics(G1NUMAStats::NewRegionAlloc, requested_node_index, hr-&gt;node_index());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return hr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifdef ASSERT
  bool HeapRegionManager::is_free(HeapRegion* hr) const {
    return _free_list.contains(hr);
  }
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,10 ***</span>
<span class="line-new-header">--- 169,15 ---</span>
  
  void HeapRegionManager::uncommit_regions(uint start, size_t num_regions) {
    guarantee(num_regions &gt;= 1, &quot;Need to specify at least one region to uncommit, tried to uncommit zero regions at %u&quot;, start);
    guarantee(_num_committed &gt;= num_regions, &quot;pre-condition&quot;);
  
<span class="line-added">+   // Reset node index to distinguish with committed regions.</span>
<span class="line-added">+   for (uint i = start; i &lt; start + num_regions; i++) {</span>
<span class="line-added">+     at(i)-&gt;set_node_index(G1NUMA::UnknownNodeIndex);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Print before uncommitting.
    if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
      for (uint i = start; i &lt; start + num_regions; i++) {
        HeapRegion* hr = at(i);
        G1CollectedHeap::heap()-&gt;hr_printer()-&gt;uncommit(hr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,14 ***</span>
      assert(is_available(i), &quot;Just made region %u available but is apparently not.&quot;, i);
      HeapRegion* hr = at(i);
      if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
        G1CollectedHeap::heap()-&gt;hr_printer()-&gt;commit(hr);
      }
<span class="line-removed">-     HeapWord* bottom = G1CollectedHeap::heap()-&gt;bottom_addr_for_region(i);</span>
<span class="line-removed">-     MemRegion mr(bottom, bottom + HeapRegion::GrainWords);</span>
  
<span class="line-modified">!     hr-&gt;initialize(mr);</span>
      insert_into_free_list(at(i));
    }
  }
  
  MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {
<span class="line-new-header">--- 217,13 ---</span>
      assert(is_available(i), &quot;Just made region %u available but is apparently not.&quot;, i);
      HeapRegion* hr = at(i);
      if (G1CollectedHeap::heap()-&gt;hr_printer()-&gt;is_active()) {
        G1CollectedHeap::heap()-&gt;hr_printer()-&gt;commit(hr);
      }
  
<span class="line-modified">!     hr-&gt;initialize();</span>
<span class="line-added">+     hr-&gt;set_node_index(G1NUMA::numa()-&gt;index_for_region(hr));</span>
      insert_into_free_list(at(i));
    }
  }
  
  MemoryUsage HeapRegionManager::get_auxiliary_data_memory_usage() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,10 ***</span>
<span class="line-new-header">--- 269,39 ---</span>
  
    verify_optional();
    return expanded;
  }
  
<span class="line-added">+ uint HeapRegionManager::expand_on_preferred_node(uint preferred_index) {</span>
<span class="line-added">+   uint expand_candidate = UINT_MAX;</span>
<span class="line-added">+   for (uint i = 0; i &lt; max_length(); i++) {</span>
<span class="line-added">+     if (is_available(i)) {</span>
<span class="line-added">+       // Already in use continue</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Always save the candidate so we can expand later on.</span>
<span class="line-added">+     expand_candidate = i;</span>
<span class="line-added">+     if (is_on_preferred_index(expand_candidate, preferred_index)) {</span>
<span class="line-added">+       // We have found a candidate on the preffered node, break.</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (expand_candidate == UINT_MAX) {</span>
<span class="line-added">+      // No regions left, expand failed.</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   make_regions_available(expand_candidate, 1, NULL);</span>
<span class="line-added">+   return 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool HeapRegionManager::is_on_preferred_index(uint region_index, uint preferred_node_index) {</span>
<span class="line-added">+   uint region_node_index = G1NUMA::numa()-&gt;preferred_node_index_for_index(region_index);</span>
<span class="line-added">+   return region_node_index == preferred_node_index;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  uint HeapRegionManager::find_contiguous(size_t num, bool empty_only) {
    uint found = 0;
    size_t length_found = 0;
    uint cur = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,13 ***</span>
    memset(new_claims, Unclaimed, sizeof(*_claims) * _n_regions);
    _claims = new_claims;
  }
  
  HeapRegionClaimer::~HeapRegionClaimer() {
<span class="line-modified">!   if (_claims != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(uint, _claims);</span>
<span class="line-removed">-   }</span>
  }
  
  uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {
    assert(worker_id &lt; _n_workers, &quot;Invalid worker_id.&quot;);
    return _n_regions * worker_id / _n_workers;
<span class="line-new-header">--- 594,11 ---</span>
    memset(new_claims, Unclaimed, sizeof(*_claims) * _n_regions);
    _claims = new_claims;
  }
  
  HeapRegionClaimer::~HeapRegionClaimer() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(uint, _claims);</span>
  }
  
  uint HeapRegionClaimer::offset_for_worker(uint worker_id) const {
    assert(worker_id &lt; _n_workers, &quot;Invalid worker_id.&quot;);
    return _n_regions * worker_id / _n_workers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,8 ***</span>
    return _claims[region_index] == Claimed;
  }
  
  bool HeapRegionClaimer::claim_region(uint region_index) {
    assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
<span class="line-modified">!   uint old_val = Atomic::cmpxchg(Claimed, &amp;_claims[region_index], Unclaimed);</span>
    return old_val == Unclaimed;
  }
<span class="line-new-header">--- 609,85 ---</span>
    return _claims[region_index] == Claimed;
  }
  
  bool HeapRegionClaimer::claim_region(uint region_index) {
    assert(region_index &lt; _n_regions, &quot;Invalid index.&quot;);
<span class="line-modified">!   uint old_val = Atomic::cmpxchg(&amp;_claims[region_index], Unclaimed, Claimed);</span>
    return old_val == Unclaimed;
  }
<span class="line-added">+ </span>
<span class="line-added">+ class G1RebuildFreeListTask : public AbstractGangTask {</span>
<span class="line-added">+   HeapRegionManager* _hrm;</span>
<span class="line-added">+   FreeRegionList*    _worker_freelists;</span>
<span class="line-added">+   uint               _worker_chunk_size;</span>
<span class="line-added">+   uint               _num_workers;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   G1RebuildFreeListTask(HeapRegionManager* hrm, uint num_workers) :</span>
<span class="line-added">+       AbstractGangTask(&quot;G1 Rebuild Free List Task&quot;),</span>
<span class="line-added">+       _hrm(hrm),</span>
<span class="line-added">+       _worker_freelists(NEW_C_HEAP_ARRAY(FreeRegionList, num_workers, mtGC)),</span>
<span class="line-added">+       _worker_chunk_size((_hrm-&gt;max_length() + num_workers - 1) / num_workers),</span>
<span class="line-added">+       _num_workers(num_workers) {</span>
<span class="line-added">+     for (uint worker = 0; worker &lt; _num_workers; worker++) {</span>
<span class="line-added">+       ::new (&amp;_worker_freelists[worker]) FreeRegionList(&quot;Appendable Worker Free List&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~G1RebuildFreeListTask() {</span>
<span class="line-added">+     for (uint worker = 0; worker &lt; _num_workers; worker++) {</span>
<span class="line-added">+       _worker_freelists[worker].~FreeRegionList();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     FREE_C_HEAP_ARRAY(FreeRegionList, _worker_freelists);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   FreeRegionList* worker_freelist(uint worker) {</span>
<span class="line-added">+     return &amp;_worker_freelists[worker];</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Each worker creates a free list for a chunk of the heap. The chunks won&#39;t</span>
<span class="line-added">+   // be overlapping so we don&#39;t need to do any claiming.</span>
<span class="line-added">+   void work(uint worker_id) {</span>
<span class="line-added">+     Ticks start_time = Ticks::now();</span>
<span class="line-added">+     EventGCPhaseParallel event;</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint start = worker_id * _worker_chunk_size;</span>
<span class="line-added">+     uint end = MIN2(start + _worker_chunk_size, _hrm-&gt;max_length());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If start is outside the heap, this worker has nothing to do.</span>
<span class="line-added">+     if (start &gt; end) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     FreeRegionList *free_list = worker_freelist(worker_id);</span>
<span class="line-added">+     for (uint i = start; i &lt; end; i++) {</span>
<span class="line-added">+       HeapRegion *region = _hrm-&gt;at_or_null(i);</span>
<span class="line-added">+       if (region != NULL &amp;&amp; region-&gt;is_free()) {</span>
<span class="line-added">+         // Need to clear old links to allow to be added to new freelist.</span>
<span class="line-added">+         region-&gt;unlink_from_list();</span>
<span class="line-added">+         free_list-&gt;add_to_tail(region);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::RebuildFreeList));</span>
<span class="line-added">+     G1CollectedHeap::heap()-&gt;phase_times()-&gt;record_time_secs(G1GCPhaseTimes::RebuildFreeList, worker_id, (Ticks::now() - start_time).seconds());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HeapRegionManager::rebuild_free_list(WorkGang* workers) {</span>
<span class="line-added">+   // Abandon current free list to allow a rebuild.</span>
<span class="line-added">+   _free_list.abandon();</span>
<span class="line-added">+ </span>
<span class="line-added">+   uint const num_workers = clamp(max_length(), 1u, workers-&gt;active_workers());</span>
<span class="line-added">+   G1RebuildFreeListTask task(this, num_workers);</span>
<span class="line-added">+ </span>
<span class="line-added">+   log_debug(gc, ergo)(&quot;Running %s using %u workers for rebuilding free list of %u (%u) regions&quot;,</span>
<span class="line-added">+                       task.name(), num_workers, num_free_regions(), max_length());</span>
<span class="line-added">+   workers-&gt;run_task(&amp;task, num_workers);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Link the partial free lists together.</span>
<span class="line-added">+   Ticks serial_time = Ticks::now();</span>
<span class="line-added">+   for (uint worker = 0; worker &lt; num_workers; worker++) {</span>
<span class="line-added">+     _free_list.append_ordered(task.worker_freelist(worker));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   G1CollectedHeap::heap()-&gt;phase_times()-&gt;record_serial_rebuild_freelist_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="heapRegion.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
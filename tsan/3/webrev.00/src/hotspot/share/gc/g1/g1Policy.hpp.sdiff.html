<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Policy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Predictions.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1POLICY_HPP
 26 #define SHARE_GC_G1_G1POLICY_HPP
 27 
<span class="line-removed"> 28 #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 30 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/g1/g1InCSetState.hpp&quot;</span>
 32 #include &quot;gc/g1/g1InitialMarkToMixedTimeTracker.hpp&quot;
 33 #include &quot;gc/g1/g1MMUTracker.hpp&quot;
 34 #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
 35 #include &quot;gc/g1/g1Predictions.hpp&quot;
 36 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
 37 #include &quot;gc/shared/gcCause.hpp&quot;
 38 #include &quot;utilities/pair.hpp&quot;
 39 
 40 // A G1Policy makes policy decisions that determine the
 41 // characteristics of the collector.  Examples include:
 42 //   * choice of collection set.
 43 //   * when to collect.
 44 
 45 class HeapRegion;
 46 class G1CollectionSet;

 47 class G1CollectionSetChooser;
 48 class G1IHOPControl;
 49 class G1Analytics;
 50 class G1SurvivorRegions;
 51 class G1YoungGenSizer;
 52 class GCPolicyCounters;
 53 class STWGCTimer;
 54 
 55 class G1Policy: public CHeapObj&lt;mtGC&gt; {
 56  private:
 57 
 58   static G1IHOPControl* create_ihop_control(const G1Predictions* predictor);
 59   // Update the IHOP control with necessary statistics.
 60   void update_ihop_prediction(double mutator_time_s,
 61                               size_t mutator_alloc_bytes,
 62                               size_t young_gen_size,
 63                               bool this_gc_was_young_only);
 64   void report_ihop_statistics();
 65 
 66   G1Predictions _predictor;
 67   G1Analytics* _analytics;
 68   G1RemSetTrackingPolicy _remset_tracker;
 69   G1MMUTracker* _mmu_tracker;
 70   G1IHOPControl* _ihop_control;
 71 
 72   GCPolicyCounters* _policy_counters;
 73 
 74   double _full_collection_start_sec;
 75 
 76   jlong _collection_pause_end_millis;
 77 
 78   uint _young_list_target_length;
 79   uint _young_list_fixed_length;
 80 
 81   // The max number of regions we can extend the eden by while the GC
 82   // locker is active. This should be &gt;= _young_list_target_length;
 83   uint _young_list_max_length;
 84 
<span class="line-modified"> 85   // SurvRateGroups below must be initialized after the predictor because they</span>
<span class="line-modified"> 86   // indirectly use it through this object passed to their constructor.</span>
<span class="line-modified"> 87   SurvRateGroup* _short_lived_surv_rate_group;</span>
<span class="line-modified"> 88   SurvRateGroup* _survivor_surv_rate_group;</span>
 89 
 90   double _reserve_factor;
 91   // This will be set when the heap is expanded
 92   // for the first time during initialization.
 93   uint   _reserve_regions;
 94 
 95   G1YoungGenSizer* _young_gen_sizer;
 96 
 97   uint _free_regions_at_end_of_collection;
 98 
<span class="line-modified"> 99   size_t _max_rs_lengths;</span>
100 
<span class="line-modified">101   size_t _rs_lengths_prediction;</span>
102 
<span class="line-modified">103   size_t _pending_cards;</span>




104 
105   // The amount of allocated bytes in old gen during the last mutator and the following
106   // young GC phase.
107   size_t _bytes_allocated_in_old_since_last_gc;
108 
109   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
110 
111   bool should_update_surv_rate_group_predictors() {
112     return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
113   }


114 public:
115   const G1Predictions&amp; predictor() const { return _predictor; }
116   const G1Analytics* analytics()   const { return const_cast&lt;const G1Analytics*&gt;(_analytics); }
117 
118   G1RemSetTrackingPolicy* remset_tracker() { return &amp;_remset_tracker; }
119 
120   // Add the given number of bytes to the total number of allocated bytes in the old gen.
121   void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
122 
123   void set_region_eden(HeapRegion* hr) {
124     hr-&gt;set_eden();
<span class="line-modified">125     hr-&gt;install_surv_rate_group(_short_lived_surv_rate_group);</span>
126   }
127 
128   void set_region_survivor(HeapRegion* hr) {
129     assert(hr-&gt;is_survivor(), &quot;pre-condition&quot;);
130     hr-&gt;install_surv_rate_group(_survivor_surv_rate_group);
131   }
132 
<span class="line-modified">133   void record_max_rs_lengths(size_t rs_lengths) {</span>
<span class="line-modified">134     _max_rs_lengths = rs_lengths;</span>
135   }
136 
<span class="line-modified">137   double predict_base_elapsed_time_ms(size_t pending_cards) const;</span>
<span class="line-removed">138   double predict_base_elapsed_time_ms(size_t pending_cards,</span>
<span class="line-removed">139                                       size_t scanned_cards) const;</span>
<span class="line-removed">140   size_t predict_bytes_to_copy(HeapRegion* hr) const;</span>
<span class="line-removed">141   double predict_region_elapsed_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
142 
<span class="line-modified">143   double predict_survivor_regions_evac_time() const;</span>









144 
145   void cset_regions_freed() {
146     bool update = should_update_surv_rate_group_predictors();
147 
<span class="line-modified">148     _short_lived_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);</span>
149     _survivor_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
150   }
151 
152   G1MMUTracker* mmu_tracker() {
153     return _mmu_tracker;
154   }
155 
156   const G1MMUTracker* mmu_tracker() const {
157     return _mmu_tracker;
158   }
159 
160   double max_pause_time_ms() const {
161     return _mmu_tracker-&gt;max_gc_time() * 1000.0;
162   }
163 
<span class="line-removed">164   double predict_yg_surv_rate(int age, SurvRateGroup* surv_rate_group) const;</span>
<span class="line-removed">165 </span>
<span class="line-removed">166   double predict_yg_surv_rate(int age) const;</span>
<span class="line-removed">167 </span>
<span class="line-removed">168   double accum_yg_surv_rate_pred(int age) const;</span>
<span class="line-removed">169 </span>
170 private:
171   G1CollectionSet* _collection_set;
172   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
173   double other_time_ms(double pause_time_ms) const;
174 
175   double young_other_time_ms() const;
176   double non_young_other_time_ms() const;
177   double constant_other_time_ms(double pause_time_ms) const;
178 
179   G1CollectionSetChooser* cset_chooser() const;
180 
<span class="line-removed">181   // The number of bytes copied during the GC.</span>
<span class="line-removed">182   size_t _bytes_copied_during_gc;</span>
<span class="line-removed">183 </span>
184   // Stash a pointer to the g1 heap.
185   G1CollectedHeap* _g1h;
186 
187   G1GCPhaseTimes* _phase_times;
188 
189   // This set of variables tracks the collector efficiency, in order to
190   // determine whether we should initiate a new marking.
191   double _mark_remark_start_sec;
192   double _mark_cleanup_start_sec;
193 
194   // Updates the internal young list maximum and target lengths. Returns the
<span class="line-modified">195   // unbounded young list target length.</span>


196   uint update_young_list_max_and_target_length();
<span class="line-modified">197   uint update_young_list_max_and_target_length(size_t rs_lengths);</span>
198 
199   // Update the young list target length either by setting it to the
200   // desired fixed value or by calculating it using G1&#39;s pause
<span class="line-modified">201   // prediction model. If no rs_lengths parameter is passed, predict</span>
<span class="line-removed">202   // the RS lengths using the prediction model, otherwise use the</span>
<span class="line-removed">203   // given rs_lengths as the prediction.</span>
204   // Returns the unbounded young list target length.
<span class="line-modified">205   uint update_young_list_target_length(size_t rs_lengths);</span>
206 
207   // Calculate and return the minimum desired young list target
208   // length. This is the minimum desired young list length according
209   // to the user&#39;s inputs.
210   uint calculate_young_list_desired_min_length(uint base_min_length) const;
211 
212   // Calculate and return the maximum desired young list target
213   // length. This is the maximum desired young list length according
214   // to the user&#39;s inputs.
215   uint calculate_young_list_desired_max_length() const;
216 
217   // Calculate and return the maximum young list target length that
<span class="line-modified">218   // can fit into the pause time goal. The parameters are: rs_lengths</span>
219   // represent the prediction of how large the young RSet lengths will
220   // be, base_min_length is the already existing number of regions in
221   // the young list, min_length and max_length are the desired min and
222   // max young list length according to the user&#39;s inputs.
<span class="line-modified">223   uint calculate_young_list_target_length(size_t rs_lengths,</span>
224                                           uint base_min_length,
225                                           uint desired_min_length,
226                                           uint desired_max_length) const;
227 
228   // Result of the bounded_young_list_target_length() method, containing both the
229   // bounded as well as the unbounded young list target lengths in this order.
230   typedef Pair&lt;uint, uint, StackObj&gt; YoungTargetLengths;
<span class="line-modified">231   YoungTargetLengths young_list_target_lengths(size_t rs_lengths) const;</span>



232 
<span class="line-modified">233   void update_rs_lengths_prediction();</span>
<span class="line-modified">234   void update_rs_lengths_prediction(size_t prediction);</span>
235 
236   // Check whether a given young length (young_length) fits into the
237   // given target pause time and whether the prediction for the amount
238   // of objects to be copied for the given length will fit into the
239   // given free space (expressed by base_free_regions).  It is used by
240   // calculate_young_list_target_length().
241   bool predict_will_fit(uint young_length, double base_time_ms,
242                         uint base_free_regions, double target_pause_time_ms) const;
243 
244 public:
<span class="line-modified">245   size_t pending_cards() const { return _pending_cards; }</span>
246 
247   // Calculate the minimum number of old regions we&#39;ll add to the CSet
248   // during a mixed GC.
249   uint calc_min_old_cset_length() const;
250 
251   // Calculate the maximum number of old regions we&#39;ll add to the CSet
252   // during a mixed GC.
253   uint calc_max_old_cset_length() const;
254 
255   // Returns the given amount of reclaimable bytes (that represents
256   // the amount of reclaimable space still to be collected) as a
257   // percentage of the current heap capacity.
258   double reclaimable_bytes_percent(size_t reclaimable_bytes) const;
259 
260   jlong collection_pause_end_millis() { return _collection_pause_end_millis; }
261 
262 private:
263   void clear_collection_set_candidates();
264   // Sets up marking if proper conditions are met.
265   void maybe_start_marking();
266 
267   // The kind of STW pause.
268   enum PauseKind {
269     FullGC,
270     YoungOnlyGC,
271     MixedGC,
272     LastYoungGC,
273     InitialMarkGC,
274     Cleanup,
275     Remark
276   };
277 
278   // Calculate PauseKind from internal state.
279   PauseKind young_gc_pause_kind() const;
280   // Record the given STW pause with the given start and end times (in s).
281   void record_pause(PauseKind kind, double start, double end);
282   // Indicate that we aborted marking before doing any mixed GCs.
283   void abort_time_to_mixed_tracking();



284 public:
285 
<span class="line-modified">286   G1Policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer);</span>
287 
288   virtual ~G1Policy();
289 
<span class="line-modified">290   static G1Policy* create_policy(G1CollectorPolicy* policy, STWGCTimer* gc_timer_stw);</span>
291 
292   G1CollectorState* collector_state() const;
293 
294   G1GCPhaseTimes* phase_times() const { return _phase_times; }
295 
<span class="line-modified">296   // Check the current value of the young list RSet lengths and</span>
297   // compare it against the last prediction. If the current value is
298   // higher, recalculate the young list target length prediction.
<span class="line-modified">299   void revise_young_list_target_length_if_necessary(size_t rs_lengths);</span>
300 
301   // This should be called after the heap is resized.
302   void record_new_heap_size(uint new_number_of_regions);
303 
304   virtual void init(G1CollectedHeap* g1h, G1CollectionSet* collection_set);
305 
306   void note_gc_start();
307 
308   bool need_to_start_conc_mark(const char* source, size_t alloc_word_size = 0);
309 
310   bool about_to_start_mixed_phase() const;
311 
312   // Record the start and end of an evacuation pause.
313   void record_collection_pause_start(double start_time_sec);
<span class="line-modified">314   virtual void record_collection_pause_end(double pause_time_ms, size_t cards_scanned, size_t heap_used_bytes_before_gc);</span>
315 
316   // Record the start and end of a full collection.
317   void record_full_collection_start();
318   virtual void record_full_collection_end();
319 
320   // Must currently be called while the world is stopped.
321   void record_concurrent_mark_init_end(double mark_init_elapsed_time_ms);
322 
323   // Record start and end of remark.
324   void record_concurrent_mark_remark_start();
325   void record_concurrent_mark_remark_end();
326 
327   // Record start, end, and completion of cleanup.
328   void record_concurrent_mark_cleanup_start();
329   void record_concurrent_mark_cleanup_end();
330 
331   void print_phases();
332 
<span class="line-removed">333   // Record how much space we copied during a GC. This is typically</span>
<span class="line-removed">334   // called when a GC alloc region is being retired.</span>
<span class="line-removed">335   void record_bytes_copied_during_gc(size_t bytes) {</span>
<span class="line-removed">336     _bytes_copied_during_gc += bytes;</span>
<span class="line-removed">337   }</span>
<span class="line-removed">338 </span>
<span class="line-removed">339   // The amount of space we copied during a GC.</span>
<span class="line-removed">340   size_t bytes_copied_during_gc() const {</span>
<span class="line-removed">341     return _bytes_copied_during_gc;</span>
<span class="line-removed">342   }</span>
<span class="line-removed">343 </span>
344   bool next_gc_should_be_mixed(const char* true_action_str,
345                                const char* false_action_str) const;
346 
<span class="line-modified">347   void finalize_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor);</span>














348 private:
349   // Set the state to start a concurrent marking cycle and clear
350   // _initiate_conc_mark_if_possible because it has now been
351   // acted on.
352   void initiate_conc_mark();
353 
354 public:
355   // This sets the initiate_conc_mark_if_possible() flag to start a
356   // new cycle, as long as we are not already in one. It&#39;s best if it
357   // is called during a safepoint when the test whether a cycle is in
358   // progress or not is stable.
359   bool force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause);
360 
361   // This is called at the very beginning of an evacuation pause (it
362   // has to be the first thing that the pause does). If
363   // initiate_conc_mark_if_possible() is true, and the concurrent
364   // marking thread has completed its work during the previous cycle,
365   // it will set in_initial_mark_gc() to so that the pause does
366   // the initial-mark work and start a marking cycle.
367   void decide_on_conc_mark_initiation();
368 
<span class="line-removed">369   void finished_recalculating_age_indexes(bool is_survivors) {</span>
<span class="line-removed">370     if (is_survivors) {</span>
<span class="line-removed">371       _survivor_surv_rate_group-&gt;finished_recalculating_age_indexes();</span>
<span class="line-removed">372     } else {</span>
<span class="line-removed">373       _short_lived_surv_rate_group-&gt;finished_recalculating_age_indexes();</span>
<span class="line-removed">374     }</span>
<span class="line-removed">375   }</span>
<span class="line-removed">376 </span>
377   size_t young_list_target_length() const { return _young_list_target_length; }
378 
379   bool should_allocate_mutator_region() const;
380 
381   bool can_expand_young_list() const;
382 
383   uint young_list_max_length() const {
384     return _young_list_max_length;
385   }
386 
<span class="line-modified">387   bool adaptive_young_list_length() const;</span>
388 
389   void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
390 
391 private:
392   //
393   // Survivor regions policy.
394   //
395 
396   // Current tenuring threshold, set to 0 if the collector reaches the
397   // maximum amount of survivors regions.
398   uint _tenuring_threshold;
399 
400   // The limit on the number of regions allocated for survivors.
401   uint _max_survivor_regions;
402 
403   AgeTable _survivors_age_table;
404 
405   size_t desired_survivor_size(uint max_regions) const;
<span class="line-modified">406 public:</span>
407   // Fraction used when predicting how many optional regions to include in
408   // the CSet. This fraction of the available time is used for optional regions,
409   // the rest is used to add old regions to the normal CSet.
410   double optional_prediction_fraction() { return 0.2; }


411   // Fraction used when evacuating the optional regions. This fraction of the
412   // remaining time is used to choose what regions to include in the evacuation.
413   double optional_evacuation_fraction() { return 0.75; }
414 
415   uint tenuring_threshold() const { return _tenuring_threshold; }
416 
417   uint max_survivor_regions() {
418     return _max_survivor_regions;
419   }
420 
421   void note_start_adding_survivor_regions() {
422     _survivor_surv_rate_group-&gt;start_adding_regions();
423   }
424 
425   void note_stop_adding_survivor_regions() {
426     _survivor_surv_rate_group-&gt;stop_adding_regions();
427   }
428 
429   void record_age_table(AgeTable* age_table) {
430     _survivors_age_table.merge(age_table);
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1POLICY_HPP
 26 #define SHARE_GC_G1_G1POLICY_HPP
 27 

 28 #include &quot;gc/g1/g1CollectorState.hpp&quot;
 29 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
<span class="line-modified"> 30 #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;</span>
 31 #include &quot;gc/g1/g1InitialMarkToMixedTimeTracker.hpp&quot;
 32 #include &quot;gc/g1/g1MMUTracker.hpp&quot;
 33 #include &quot;gc/g1/g1RemSetTrackingPolicy.hpp&quot;
 34 #include &quot;gc/g1/g1Predictions.hpp&quot;
 35 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
 36 #include &quot;gc/shared/gcCause.hpp&quot;
 37 #include &quot;utilities/pair.hpp&quot;
 38 
 39 // A G1Policy makes policy decisions that determine the
 40 // characteristics of the collector.  Examples include:
 41 //   * choice of collection set.
 42 //   * when to collect.
 43 
 44 class HeapRegion;
 45 class G1CollectionSet;
<span class="line-added"> 46 class G1CollectionSetCandidates;</span>
 47 class G1CollectionSetChooser;
 48 class G1IHOPControl;
 49 class G1Analytics;
 50 class G1SurvivorRegions;
 51 class G1YoungGenSizer;
 52 class GCPolicyCounters;
 53 class STWGCTimer;
 54 
 55 class G1Policy: public CHeapObj&lt;mtGC&gt; {
 56  private:
 57 
 58   static G1IHOPControl* create_ihop_control(const G1Predictions* predictor);
 59   // Update the IHOP control with necessary statistics.
 60   void update_ihop_prediction(double mutator_time_s,
 61                               size_t mutator_alloc_bytes,
 62                               size_t young_gen_size,
 63                               bool this_gc_was_young_only);
 64   void report_ihop_statistics();
 65 
 66   G1Predictions _predictor;
 67   G1Analytics* _analytics;
 68   G1RemSetTrackingPolicy _remset_tracker;
 69   G1MMUTracker* _mmu_tracker;
 70   G1IHOPControl* _ihop_control;
 71 
 72   GCPolicyCounters* _policy_counters;
 73 
 74   double _full_collection_start_sec;
 75 
 76   jlong _collection_pause_end_millis;
 77 
 78   uint _young_list_target_length;
 79   uint _young_list_fixed_length;
 80 
 81   // The max number of regions we can extend the eden by while the GC
 82   // locker is active. This should be &gt;= _young_list_target_length;
 83   uint _young_list_max_length;
 84 
<span class="line-modified"> 85   // The survivor rate groups below must be initialized after the predictor because they</span>
<span class="line-modified"> 86   // indirectly use it through the &quot;this&quot; object passed to their constructor.</span>
<span class="line-modified"> 87   G1SurvRateGroup* _eden_surv_rate_group;</span>
<span class="line-modified"> 88   G1SurvRateGroup* _survivor_surv_rate_group;</span>
 89 
 90   double _reserve_factor;
 91   // This will be set when the heap is expanded
 92   // for the first time during initialization.
 93   uint   _reserve_regions;
 94 
 95   G1YoungGenSizer* _young_gen_sizer;
 96 
 97   uint _free_regions_at_end_of_collection;
 98 
<span class="line-modified"> 99   size_t _rs_length;</span>
100 
<span class="line-modified">101   size_t _rs_length_prediction;</span>
102 
<span class="line-modified">103   size_t _pending_cards_at_gc_start;</span>
<span class="line-added">104   size_t _pending_cards_at_prev_gc_end;</span>
<span class="line-added">105   size_t _total_mutator_refined_cards;</span>
<span class="line-added">106   size_t _total_concurrent_refined_cards;</span>
<span class="line-added">107   Tickspan _total_concurrent_refinement_time;</span>
108 
109   // The amount of allocated bytes in old gen during the last mutator and the following
110   // young GC phase.
111   size_t _bytes_allocated_in_old_since_last_gc;
112 
113   G1InitialMarkToMixedTimeTracker _initial_mark_to_mixed;
114 
115   bool should_update_surv_rate_group_predictors() {
116     return collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;mark_or_rebuild_in_progress();
117   }
<span class="line-added">118 </span>
<span class="line-added">119   double logged_cards_processing_time() const;</span>
120 public:
121   const G1Predictions&amp; predictor() const { return _predictor; }
122   const G1Analytics* analytics()   const { return const_cast&lt;const G1Analytics*&gt;(_analytics); }
123 
124   G1RemSetTrackingPolicy* remset_tracker() { return &amp;_remset_tracker; }
125 
126   // Add the given number of bytes to the total number of allocated bytes in the old gen.
127   void add_bytes_allocated_in_old_since_last_gc(size_t bytes) { _bytes_allocated_in_old_since_last_gc += bytes; }
128 
129   void set_region_eden(HeapRegion* hr) {
130     hr-&gt;set_eden();
<span class="line-modified">131     hr-&gt;install_surv_rate_group(_eden_surv_rate_group);</span>
132   }
133 
134   void set_region_survivor(HeapRegion* hr) {
135     assert(hr-&gt;is_survivor(), &quot;pre-condition&quot;);
136     hr-&gt;install_surv_rate_group(_survivor_surv_rate_group);
137   }
138 
<span class="line-modified">139   void record_rs_length(size_t rs_length) {</span>
<span class="line-modified">140     _rs_length = rs_length;</span>
141   }
142 
<span class="line-modified">143   double predict_base_elapsed_time_ms(size_t num_pending_cards) const;</span>




144 
<span class="line-modified">145 private:</span>
<span class="line-added">146   double predict_base_elapsed_time_ms(size_t num_pending_cards, size_t rs_length) const;</span>
<span class="line-added">147 </span>
<span class="line-added">148   double predict_region_copy_time_ms(HeapRegion* hr) const;</span>
<span class="line-added">149 </span>
<span class="line-added">150 public:</span>
<span class="line-added">151 </span>
<span class="line-added">152   double predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy = NULL) const;</span>
<span class="line-added">153   double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
<span class="line-added">154   double predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const;</span>
155 
156   void cset_regions_freed() {
157     bool update = should_update_surv_rate_group_predictors();
158 
<span class="line-modified">159     _eden_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);</span>
160     _survivor_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
161   }
162 
163   G1MMUTracker* mmu_tracker() {
164     return _mmu_tracker;
165   }
166 
167   const G1MMUTracker* mmu_tracker() const {
168     return _mmu_tracker;
169   }
170 
171   double max_pause_time_ms() const {
172     return _mmu_tracker-&gt;max_gc_time() * 1000.0;
173   }
174 






175 private:
176   G1CollectionSet* _collection_set;
177   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
178   double other_time_ms(double pause_time_ms) const;
179 
180   double young_other_time_ms() const;
181   double non_young_other_time_ms() const;
182   double constant_other_time_ms(double pause_time_ms) const;
183 
184   G1CollectionSetChooser* cset_chooser() const;
185 



186   // Stash a pointer to the g1 heap.
187   G1CollectedHeap* _g1h;
188 
189   G1GCPhaseTimes* _phase_times;
190 
191   // This set of variables tracks the collector efficiency, in order to
192   // determine whether we should initiate a new marking.
193   double _mark_remark_start_sec;
194   double _mark_cleanup_start_sec;
195 
196   // Updates the internal young list maximum and target lengths. Returns the
<span class="line-modified">197   // unbounded young list target length. If no rs_length parameter is passed,</span>
<span class="line-added">198   // predict the RS length using the prediction model, otherwise use the</span>
<span class="line-added">199   // given rs_length as the prediction.</span>
200   uint update_young_list_max_and_target_length();
<span class="line-modified">201   uint update_young_list_max_and_target_length(size_t rs_length);</span>
202 
203   // Update the young list target length either by setting it to the
204   // desired fixed value or by calculating it using G1&#39;s pause
<span class="line-modified">205   // prediction model.</span>


206   // Returns the unbounded young list target length.
<span class="line-modified">207   uint update_young_list_target_length(size_t rs_length);</span>
208 
209   // Calculate and return the minimum desired young list target
210   // length. This is the minimum desired young list length according
211   // to the user&#39;s inputs.
212   uint calculate_young_list_desired_min_length(uint base_min_length) const;
213 
214   // Calculate and return the maximum desired young list target
215   // length. This is the maximum desired young list length according
216   // to the user&#39;s inputs.
217   uint calculate_young_list_desired_max_length() const;
218 
219   // Calculate and return the maximum young list target length that
<span class="line-modified">220   // can fit into the pause time goal. The parameters are: rs_length</span>
221   // represent the prediction of how large the young RSet lengths will
222   // be, base_min_length is the already existing number of regions in
223   // the young list, min_length and max_length are the desired min and
224   // max young list length according to the user&#39;s inputs.
<span class="line-modified">225   uint calculate_young_list_target_length(size_t rs_length,</span>
226                                           uint base_min_length,
227                                           uint desired_min_length,
228                                           uint desired_max_length) const;
229 
230   // Result of the bounded_young_list_target_length() method, containing both the
231   // bounded as well as the unbounded young list target lengths in this order.
232   typedef Pair&lt;uint, uint, StackObj&gt; YoungTargetLengths;
<span class="line-modified">233   YoungTargetLengths young_list_target_lengths(size_t rs_length) const;</span>
<span class="line-added">234 </span>
<span class="line-added">235   void update_rs_length_prediction();</span>
<span class="line-added">236   void update_rs_length_prediction(size_t prediction);</span>
237 
<span class="line-modified">238   size_t predict_bytes_to_copy(HeapRegion* hr) const;</span>
<span class="line-modified">239   double predict_survivor_regions_evac_time() const;</span>
240 
241   // Check whether a given young length (young_length) fits into the
242   // given target pause time and whether the prediction for the amount
243   // of objects to be copied for the given length will fit into the
244   // given free space (expressed by base_free_regions).  It is used by
245   // calculate_young_list_target_length().
246   bool predict_will_fit(uint young_length, double base_time_ms,
247                         uint base_free_regions, double target_pause_time_ms) const;
248 
249 public:
<span class="line-modified">250   size_t pending_cards_at_gc_start() const { return _pending_cards_at_gc_start; }</span>
251 
252   // Calculate the minimum number of old regions we&#39;ll add to the CSet
253   // during a mixed GC.
254   uint calc_min_old_cset_length() const;
255 
256   // Calculate the maximum number of old regions we&#39;ll add to the CSet
257   // during a mixed GC.
258   uint calc_max_old_cset_length() const;
259 
260   // Returns the given amount of reclaimable bytes (that represents
261   // the amount of reclaimable space still to be collected) as a
262   // percentage of the current heap capacity.
263   double reclaimable_bytes_percent(size_t reclaimable_bytes) const;
264 
265   jlong collection_pause_end_millis() { return _collection_pause_end_millis; }
266 
267 private:
268   void clear_collection_set_candidates();
269   // Sets up marking if proper conditions are met.
270   void maybe_start_marking();
271 
272   // The kind of STW pause.
273   enum PauseKind {
274     FullGC,
275     YoungOnlyGC,
276     MixedGC,
277     LastYoungGC,
278     InitialMarkGC,
279     Cleanup,
280     Remark
281   };
282 
283   // Calculate PauseKind from internal state.
284   PauseKind young_gc_pause_kind() const;
285   // Record the given STW pause with the given start and end times (in s).
286   void record_pause(PauseKind kind, double start, double end);
287   // Indicate that we aborted marking before doing any mixed GCs.
288   void abort_time_to_mixed_tracking();
<span class="line-added">289 </span>
<span class="line-added">290   void record_concurrent_refinement_data(bool is_full_collection);</span>
<span class="line-added">291 </span>
292 public:
293 
<span class="line-modified">294   G1Policy(STWGCTimer* gc_timer);</span>
295 
296   virtual ~G1Policy();
297 
<span class="line-modified">298   static G1Policy* create_policy(STWGCTimer* gc_timer_stw);</span>
299 
300   G1CollectorState* collector_state() const;
301 
302   G1GCPhaseTimes* phase_times() const { return _phase_times; }
303 
<span class="line-modified">304   // Check the current value of the young list RSet length and</span>
305   // compare it against the last prediction. If the current value is
306   // higher, recalculate the young list target length prediction.
<span class="line-modified">307   void revise_young_list_target_length_if_necessary(size_t rs_length);</span>
308 
309   // This should be called after the heap is resized.
310   void record_new_heap_size(uint new_number_of_regions);
311 
312   virtual void init(G1CollectedHeap* g1h, G1CollectionSet* collection_set);
313 
314   void note_gc_start();
315 
316   bool need_to_start_conc_mark(const char* source, size_t alloc_word_size = 0);
317 
318   bool about_to_start_mixed_phase() const;
319 
320   // Record the start and end of an evacuation pause.
321   void record_collection_pause_start(double start_time_sec);
<span class="line-modified">322   virtual void record_collection_pause_end(double pause_time_ms);</span>
323 
324   // Record the start and end of a full collection.
325   void record_full_collection_start();
326   virtual void record_full_collection_end();
327 
328   // Must currently be called while the world is stopped.
329   void record_concurrent_mark_init_end(double mark_init_elapsed_time_ms);
330 
331   // Record start and end of remark.
332   void record_concurrent_mark_remark_start();
333   void record_concurrent_mark_remark_end();
334 
335   // Record start, end, and completion of cleanup.
336   void record_concurrent_mark_cleanup_start();
337   void record_concurrent_mark_cleanup_end();
338 
339   void print_phases();
340 











341   bool next_gc_should_be_mixed(const char* true_action_str,
342                                const char* false_action_str) const;
343 
<span class="line-modified">344   // Calculate and return the number of initial and optional old gen regions from</span>
<span class="line-added">345   // the given collection set candidates and the remaining time.</span>
<span class="line-added">346   void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="line-added">347                                             double time_remaining_ms,</span>
<span class="line-added">348                                             uint&amp; num_initial_regions,</span>
<span class="line-added">349                                             uint&amp; num_optional_regions);</span>
<span class="line-added">350 </span>
<span class="line-added">351   // Calculate the number of optional regions from the given collection set candidates,</span>
<span class="line-added">352   // the remaining time and the maximum number of these regions and return the number</span>
<span class="line-added">353   // of actually selected regions in num_optional_regions.</span>
<span class="line-added">354   void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,</span>
<span class="line-added">355                                                  uint const max_optional_regions,</span>
<span class="line-added">356                                                  double time_remaining_ms,</span>
<span class="line-added">357                                                  uint&amp; num_optional_regions);</span>
<span class="line-added">358 </span>
359 private:
360   // Set the state to start a concurrent marking cycle and clear
361   // _initiate_conc_mark_if_possible because it has now been
362   // acted on.
363   void initiate_conc_mark();
364 
365 public:
366   // This sets the initiate_conc_mark_if_possible() flag to start a
367   // new cycle, as long as we are not already in one. It&#39;s best if it
368   // is called during a safepoint when the test whether a cycle is in
369   // progress or not is stable.
370   bool force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause);
371 
372   // This is called at the very beginning of an evacuation pause (it
373   // has to be the first thing that the pause does). If
374   // initiate_conc_mark_if_possible() is true, and the concurrent
375   // marking thread has completed its work during the previous cycle,
376   // it will set in_initial_mark_gc() to so that the pause does
377   // the initial-mark work and start a marking cycle.
378   void decide_on_conc_mark_initiation();
379 








380   size_t young_list_target_length() const { return _young_list_target_length; }
381 
382   bool should_allocate_mutator_region() const;
383 
384   bool can_expand_young_list() const;
385 
386   uint young_list_max_length() const {
387     return _young_list_max_length;
388   }
389 
<span class="line-modified">390   bool use_adaptive_young_list_length() const;</span>
391 
392   void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
393 
394 private:
395   //
396   // Survivor regions policy.
397   //
398 
399   // Current tenuring threshold, set to 0 if the collector reaches the
400   // maximum amount of survivors regions.
401   uint _tenuring_threshold;
402 
403   // The limit on the number of regions allocated for survivors.
404   uint _max_survivor_regions;
405 
406   AgeTable _survivors_age_table;
407 
408   size_t desired_survivor_size(uint max_regions) const;
<span class="line-modified">409 </span>
410   // Fraction used when predicting how many optional regions to include in
411   // the CSet. This fraction of the available time is used for optional regions,
412   // the rest is used to add old regions to the normal CSet.
413   double optional_prediction_fraction() { return 0.2; }
<span class="line-added">414 </span>
<span class="line-added">415 public:</span>
416   // Fraction used when evacuating the optional regions. This fraction of the
417   // remaining time is used to choose what regions to include in the evacuation.
418   double optional_evacuation_fraction() { return 0.75; }
419 
420   uint tenuring_threshold() const { return _tenuring_threshold; }
421 
422   uint max_survivor_regions() {
423     return _max_survivor_regions;
424   }
425 
426   void note_start_adding_survivor_regions() {
427     _survivor_surv_rate_group-&gt;start_adding_regions();
428   }
429 
430   void note_stop_adding_survivor_regions() {
431     _survivor_surv_rate_group-&gt;stop_adding_regions();
432   }
433 
434   void record_age_table(AgeTable* age_table) {
435     _survivors_age_table.merge(age_table);
</pre>
</td>
</tr>
</table>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Predictions.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
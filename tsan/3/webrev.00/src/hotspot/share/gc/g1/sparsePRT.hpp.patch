diff a/src/hotspot/share/gc/g1/sparsePRT.hpp b/src/hotspot/share/gc/g1/sparsePRT.hpp
--- a/src/hotspot/share/gc/g1/sparsePRT.hpp
+++ b/src/hotspot/share/gc/g1/sparsePRT.hpp
@@ -31,19 +31,67 @@
 #include "memory/allocation.hpp"
 #include "runtime/mutex.hpp"
 #include "utilities/align.hpp"
 #include "utilities/globalDefinitions.hpp"
 
+class RSHashTable;
+class SparsePRTEntry;
+class SparsePRTIter;
+
 // Sparse remembered set for a heap region (the "owning" region).  Maps
 // indices of other regions to short sequences of cards in the other region
 // that might contain pointers into the owner region.
+// Concurrent access to a SparsePRT must be serialized by some external mutex.
+class SparsePRT {
+  friend class SparsePRTIter;
+  friend class SparsePRTBucketIter;
+
+  RSHashTable* _table;
+
+  static const size_t InitialCapacity = 8;
+
+  void expand();
+
+public:
+  SparsePRT();
+  ~SparsePRT();
+
+  size_t mem_size() const;
+
+  enum AddCardResult {
+    overflow, // The table is full, could not add the card to the table.
+    found,    // The card is already in the PRT.
+    added     // The card has been added.
+  };
+
+  // Attempts to ensure that the given card_index in the given region is in
+  // the sparse table.  If successful (because the card was already
+  // present, or because it was successfully added) returns "true".
+  // Otherwise, returns "false" to indicate that the addition would
+  // overflow the entry for the region.  The caller must transfer these
+  // entries to a larger-capacity representation.
+  AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);
+
+  // Return the pointer to the entry associated with the given region.
+  SparsePRTEntry* get_entry(RegionIdx_t region_ind);
+
+  // If there is an entry for "region_ind", removes it and return "true";
+  // otherwise returns "false."
+  bool delete_entry(RegionIdx_t region_ind);
+
+  // Clear the table, and reinitialize to initial capacity.
+  void clear();
+
+  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;
+};
 
 class SparsePRTEntry: public CHeapObj<mtGC> {
-private:
+public:
   // The type of a card entry.
   typedef uint16_t card_elem_t;
 
+private:
   // We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,
   // in order to force correct alignment that could otherwise cause SIGBUS errors
   // when reading the member variables. This calculates the minimum number of card
   // array elements required to get that alignment.
   static const size_t card_array_alignment = sizeof(int) / sizeof(card_elem_t);
@@ -81,34 +129,28 @@
   inline bool contains_card(CardIdx_t card_index) const;
 
   // Returns the number of non-NULL card entries.
   inline int num_valid_cards() const { return _next_null; }
 
-  // Requires that the entry not contain the given card index.  If there is
-  // space available, add the given card index to the entry and return
-  // "true"; otherwise, return "false" to indicate that the entry is full.
-  enum AddCardResult {
-    overflow,
-    found,
-    added
-  };
-  inline AddCardResult add_card(CardIdx_t card_index);
+  inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);
 
   // Copy the current entry's cards into the "_card" array of "e."
   inline void copy_cards(SparsePRTEntry* e) const;
 
+  card_elem_t* cards() { return _cards; }
+
   inline CardIdx_t card(int i) const {
     assert(i >= 0, "must be nonnegative");
     assert(i < cards_num(), "range checking");
     return (CardIdx_t)_cards[i];
   }
 };
 
 class RSHashTable : public CHeapObj<mtGC> {
 
   friend class RSHashTableIter;
-
+  friend class RSHashTableBucketIter;
 
   // Inverse maximum hash table occupancy used.
   static float TableOccupancyFactor;
 
   size_t _num_entries;
@@ -148,11 +190,11 @@
   // the sparse table.  If successful (because the card was already
   // present, or because it was successfully added) returns "true".
   // Otherwise, returns "false" to indicate that the addition would
   // overflow the entry for the region.  The caller must transfer these
   // entries to a larger-capacity representation.
-  bool add_card(RegionIdx_t region_id, CardIdx_t card_index);
+  SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);
 
   bool delete_entry(RegionIdx_t region_id);
 
   bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;
 
@@ -163,11 +205,10 @@
   void clear();
 
   size_t capacity() const      { return _capacity; }
   size_t capacity_mask() const { return _capacity_mask;  }
   size_t occupied_entries() const { return _occupied_entries; }
-  size_t occupied_cards() const   { return _occupied_cards; }
   size_t mem_size() const;
   // The number of SparsePRTEntry instances available.
   size_t num_entries() const { return _num_entries; }
 
   SparsePRTEntry* entry(int i) const {
@@ -207,53 +248,24 @@
     _rsht(rsht) {}
 
   bool has_next(size_t& card_index);
 };
 
-// Concurrent access to a SparsePRT must be serialized by some external mutex.
-
-class SparsePRTIter;
-
-class SparsePRT {
-  friend class SparsePRTIter;
-
-  RSHashTable* _table;
-
-  enum SomeAdditionalPrivateConstants {
-    InitialCapacity = 16
-  };
+// This is embedded in HRRS iterator.
+class RSHashTableBucketIter {
+  int _tbl_ind;         // [-1, 0.._rsht->_capacity)
+  int _bl_ind;          // [-1, 0.._rsht->_capacity)
 
-  void expand();
+  RSHashTable* _rsht;
 
 public:
-  SparsePRT();
-  ~SparsePRT();
-
-  size_t occupied() const { return _table->occupied_cards(); }
-  size_t mem_size() const;
-
-  // Attempts to ensure that the given card_index in the given region is in
-  // the sparse table.  If successful (because the card was already
-  // present, or because it was successfully added) returns "true".
-  // Otherwise, returns "false" to indicate that the addition would
-  // overflow the entry for the region.  The caller must transfer these
-  // entries to a larger-capacity representation.
-  bool add_card(RegionIdx_t region_id, CardIdx_t card_index);
-
-  // Return the pointer to the entry associated with the given region.
-  SparsePRTEntry* get_entry(RegionIdx_t region_ind);
-
-  // If there is an entry for "region_ind", removes it and return "true";
-  // otherwise returns "false."
-  bool delete_entry(RegionIdx_t region_ind);
-
-  // Clear the table, and reinitialize to initial capacity.
-  void clear();
+  RSHashTableBucketIter(RSHashTable* rsht) :
+    _tbl_ind(0),
+    _bl_ind(rsht->_buckets[_tbl_ind]),
+    _rsht(rsht) { }
 
-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const {
-    return _table->contains_card(region_id, card_index);
-  }
+  bool has_next(SparsePRTEntry*& entry);
 };
 
 class SparsePRTIter: public RSHashTableIter {
 public:
   SparsePRTIter(const SparsePRT* sprt) :
@@ -262,6 +274,16 @@
   bool has_next(size_t& card_index) {
     return RSHashTableIter::has_next(card_index);
   }
 };
 
+class SparsePRTBucketIter: public RSHashTableBucketIter {
+public:
+  SparsePRTBucketIter(const SparsePRT* sprt) :
+    RSHashTableBucketIter(sprt->_table) {}
+
+  bool has_next(SparsePRTEntry*& entry) {
+    return RSHashTableBucketIter::has_next(entry);
+  }
+};
+
 #endif // SHARE_GC_G1_SPARSEPRT_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/heapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,31 ***</span>
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionTracer.hpp&quot;
  #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/space.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-removed">- #include &quot;utilities/growableArray.hpp&quot;</span>
  
  int    HeapRegion::LogOfHRGrainBytes = 0;
  int    HeapRegion::LogOfHRGrainWords = 0;
  size_t HeapRegion::GrainBytes        = 0;
  size_t HeapRegion::GrainWords        = 0;
  size_t HeapRegion::CardsPerRegion    = 0;
  
  size_t HeapRegion::max_region_size() {
<span class="line-new-header">--- 26,29 ---</span>
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  #include &quot;gc/g1/g1HeapRegionTraceType.hpp&quot;
<span class="line-added">+ #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
  #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionBounds.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionTracer.hpp&quot;
  #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  
  int    HeapRegion::LogOfHRGrainBytes = 0;
  int    HeapRegion::LogOfHRGrainWords = 0;
<span class="line-added">+ int    HeapRegion::LogCardsPerRegion = 0;</span>
  size_t HeapRegion::GrainBytes        = 0;
  size_t HeapRegion::GrainWords        = 0;
  size_t HeapRegion::CardsPerRegion    = 0;
  
  size_t HeapRegion::max_region_size() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,56 ***</span>
    guarantee((size_t) 1 &lt;&lt; LogOfHRGrainWords == GrainWords, &quot;sanity&quot;);
  
    guarantee(CardsPerRegion == 0, &quot;we should only set it once&quot;);
    CardsPerRegion = GrainBytes &gt;&gt; G1CardTable::card_shift;
  
    if (G1HeapRegionSize != GrainBytes) {
<span class="line-modified">!     FLAG_SET_ERGO(size_t, G1HeapRegionSize, GrainBytes);</span>
    }
  }
  
<span class="line-modified">! void HeapRegion::hr_clear(bool keep_remset, bool clear_space, bool locked) {</span>
    assert(_humongous_start_region == NULL,
           &quot;we should have already filtered out humongous regions&quot;);
    assert(!in_collection_set(),
           &quot;Should not clear heap region %u in the collection set&quot;, hrm_index());
  
<span class="line-modified">!   set_young_index_in_cset(-1);</span>
    uninstall_surv_rate_group();
    set_free();
    reset_pre_dummy_top();
  
<span class="line-modified">!   if (!keep_remset) {</span>
<span class="line-removed">-     if (locked) {</span>
<span class="line-removed">-       rem_set()-&gt;clear_locked();</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       rem_set()-&gt;clear();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  
    zero_marked_bytes();
  
    init_top_at_mark_start();
    if (clear_space) clear(SpaceDecorator::Mangle);
  }
  
  void HeapRegion::clear_cardtable() {
    G1CardTable* ct = G1CollectedHeap::heap()-&gt;card_table();
    ct-&gt;clear(MemRegion(bottom(), end()));
  }
  
  void HeapRegion::calc_gc_efficiency() {
    // GC efficiency is the ratio of how much space would be
    // reclaimed over how long we predict it would take to reclaim it.
<span class="line-modified">!   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-removed">-   G1Policy* policy = g1h-&gt;policy();</span>
  
    // Retrieve a prediction of the elapsed time for this region for
    // a mixed gc because the region will only be evacuated during a
    // mixed gc.
<span class="line-modified">!   double region_elapsed_time_ms =</span>
<span class="line-removed">-     policy-&gt;predict_region_elapsed_time_ms(this, false /* for_young_gc */);</span>
    _gc_efficiency = (double) reclaimable_bytes() / region_elapsed_time_ms;
  }
  
  void HeapRegion::set_free() {
    report_region_type_change(G1HeapRegionTraceType::Free);
<span class="line-new-header">--- 101,67 ---</span>
    guarantee((size_t) 1 &lt;&lt; LogOfHRGrainWords == GrainWords, &quot;sanity&quot;);
  
    guarantee(CardsPerRegion == 0, &quot;we should only set it once&quot;);
    CardsPerRegion = GrainBytes &gt;&gt; G1CardTable::card_shift;
  
<span class="line-added">+   LogCardsPerRegion = log2_long((jlong) CardsPerRegion);</span>
<span class="line-added">+ </span>
    if (G1HeapRegionSize != GrainBytes) {
<span class="line-modified">!     FLAG_SET_ERGO(G1HeapRegionSize, GrainBytes);</span>
    }
  }
  
<span class="line-modified">! void HeapRegion::handle_evacuation_failure() {</span>
<span class="line-added">+   uninstall_surv_rate_group();</span>
<span class="line-added">+   clear_young_index_in_cset();</span>
<span class="line-added">+   set_evacuation_failed(false);</span>
<span class="line-added">+   set_old();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HeapRegion::unlink_from_list() {</span>
<span class="line-added">+   set_next(NULL);</span>
<span class="line-added">+   set_prev(NULL);</span>
<span class="line-added">+   set_containing_set(NULL);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void HeapRegion::hr_clear(bool clear_space) {</span>
    assert(_humongous_start_region == NULL,
           &quot;we should have already filtered out humongous regions&quot;);
    assert(!in_collection_set(),
           &quot;Should not clear heap region %u in the collection set&quot;, hrm_index());
  
<span class="line-modified">!   clear_young_index_in_cset();</span>
<span class="line-added">+   clear_index_in_opt_cset();</span>
    uninstall_surv_rate_group();
    set_free();
    reset_pre_dummy_top();
  
<span class="line-modified">!   rem_set()-&gt;clear_locked();</span>
  
    zero_marked_bytes();
  
    init_top_at_mark_start();
    if (clear_space) clear(SpaceDecorator::Mangle);
<span class="line-added">+ </span>
<span class="line-added">+   _evacuation_failed = false;</span>
<span class="line-added">+   _gc_efficiency = 0.0;</span>
  }
  
  void HeapRegion::clear_cardtable() {
    G1CardTable* ct = G1CollectedHeap::heap()-&gt;card_table();
    ct-&gt;clear(MemRegion(bottom(), end()));
  }
  
  void HeapRegion::calc_gc_efficiency() {
    // GC efficiency is the ratio of how much space would be
    // reclaimed over how long we predict it would take to reclaim it.
<span class="line-modified">!   G1Policy* policy = G1CollectedHeap::heap()-&gt;policy();</span>
  
    // Retrieve a prediction of the elapsed time for this region for
    // a mixed gc because the region will only be evacuated during a
    // mixed gc.
<span class="line-modified">!   double region_elapsed_time_ms = policy-&gt;predict_region_total_time_ms(this, false /* for_young_gc */);</span>
    _gc_efficiency = (double) reclaimable_bytes() / region_elapsed_time_ms;
  }
  
  void HeapRegion::set_free() {
    report_region_type_change(G1HeapRegionTraceType::Free);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,38 ***</span>
  }
  
  HeapRegion::HeapRegion(uint hrm_index,
                         G1BlockOffsetTable* bot,
                         MemRegion mr) :
<span class="line-modified">!     G1ContiguousSpace(bot),</span>
<span class="line-modified">!     _rem_set(NULL),</span>
<span class="line-modified">!     _hrm_index(hrm_index),</span>
<span class="line-modified">!     _type(),</span>
<span class="line-modified">!     _humongous_start_region(NULL),</span>
<span class="line-modified">!     _evacuation_failed(false),</span>
<span class="line-modified">!     _next(NULL), _prev(NULL),</span>
  #ifdef ASSERT
<span class="line-modified">!     _containing_set(NULL),</span>
  #endif
<span class="line-modified">!     _prev_marked_bytes(0), _next_marked_bytes(0), _gc_efficiency(0.0),</span>
<span class="line-modified">!     _index_in_opt_cset(G1OptionalCSet::InvalidCSetIndex), _young_index_in_cset(-1),</span>
<span class="line-modified">!     _surv_rate_group(NULL), _age_index(-1),</span>
<span class="line-modified">!     _prev_top_at_mark_start(NULL), _next_top_at_mark_start(NULL),</span>
<span class="line-modified">!     _recorded_rs_length(0), _predicted_elapsed_time_ms(0)</span>
  {
<span class="line-modified">!   _rem_set = new HeapRegionRemSet(bot, this);</span>
  
<span class="line-modified">!   initialize(mr);</span>
  }
  
<span class="line-modified">! void HeapRegion::initialize(MemRegion mr, bool clear_space, bool mangle_space) {</span>
    assert(_rem_set-&gt;is_empty(), &quot;Remembered set must be empty&quot;);
  
<span class="line-modified">!   G1ContiguousSpace::initialize(mr, clear_space, mangle_space);</span>
  
<span class="line-removed">-   hr_clear(false /*par*/, false /*clear_space*/);</span>
    set_top(bottom());
  }
  
  void HeapRegion::report_region_type_change(G1HeapRegionTraceType::Type to) {
    HeapRegionTracer::send_region_type_change(_hrm_index,
                                              get_trace_type(),
<span class="line-new-header">--- 237,52 ---</span>
  }
  
  HeapRegion::HeapRegion(uint hrm_index,
                         G1BlockOffsetTable* bot,
                         MemRegion mr) :
<span class="line-modified">!   _bottom(mr.start()),</span>
<span class="line-modified">!   _end(mr.end()),</span>
<span class="line-modified">!   _top(NULL),</span>
<span class="line-modified">!   _compaction_top(NULL),</span>
<span class="line-modified">!   _bot_part(bot, this),</span>
<span class="line-modified">!   _par_alloc_lock(Mutex::leaf, &quot;HeapRegion par alloc lock&quot;, true),</span>
<span class="line-modified">!   _pre_dummy_top(NULL),</span>
<span class="line-added">+   _rem_set(NULL),</span>
<span class="line-added">+   _hrm_index(hrm_index),</span>
<span class="line-added">+   _type(),</span>
<span class="line-added">+   _humongous_start_region(NULL),</span>
<span class="line-added">+   _evacuation_failed(false),</span>
<span class="line-added">+   _index_in_opt_cset(InvalidCSetIndex),</span>
<span class="line-added">+   _next(NULL), _prev(NULL),</span>
  #ifdef ASSERT
<span class="line-modified">!   _containing_set(NULL),</span>
  #endif
<span class="line-modified">!   _prev_top_at_mark_start(NULL), _next_top_at_mark_start(NULL),</span>
<span class="line-modified">!   _prev_marked_bytes(0), _next_marked_bytes(0),</span>
<span class="line-modified">!   _young_index_in_cset(-1),</span>
<span class="line-modified">!   _surv_rate_group(NULL), _age_index(G1SurvRateGroup::InvalidAgeIndex), _gc_efficiency(0.0),</span>
<span class="line-modified">!   _node_index(G1NUMA::UnknownNodeIndex)</span>
  {
<span class="line-modified">!   assert(Universe::on_page_boundary(mr.start()) &amp;&amp; Universe::on_page_boundary(mr.end()),</span>
<span class="line-added">+          &quot;invalid space boundaries&quot;);</span>
  
<span class="line-modified">!   _rem_set = new HeapRegionRemSet(bot, this);</span>
<span class="line-added">+   initialize();</span>
  }
  
<span class="line-modified">! void HeapRegion::initialize(bool clear_space, bool mangle_space) {</span>
    assert(_rem_set-&gt;is_empty(), &quot;Remembered set must be empty&quot;);
  
<span class="line-modified">!   if (clear_space) {</span>
<span class="line-added">+     clear(mangle_space);</span>
<span class="line-added">+   }</span>
  
    set_top(bottom());
<span class="line-added">+   set_compaction_top(bottom());</span>
<span class="line-added">+   reset_bot();</span>
<span class="line-added">+ </span>
<span class="line-added">+   hr_clear(false /*clear_space*/);</span>
  }
  
  void HeapRegion::report_region_type_change(G1HeapRegionTraceType::Type to) {
    HeapRegionTracer::send_region_type_change(_hrm_index,
                                              get_trace_type(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,11 ***</span>
  
        // Note: not all the oops embedded in the nmethod are in the
        // current region. We only look at those which are.
        if (_hr-&gt;is_in(obj)) {
          // Object is in the region. Check that its less than top
<span class="line-modified">!         if (_hr-&gt;top() &lt;= (HeapWord*)obj) {</span>
            // Object is above top
            log_error(gc, verify)(&quot;Object &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; is above top &quot;,
                                  p2i(obj), HR_FORMAT_PARAMS(_hr));
            _failures = true;
            return;
<span class="line-new-header">--- 355,11 ---</span>
  
        // Note: not all the oops embedded in the nmethod are in the
        // current region. We only look at those which are.
        if (_hr-&gt;is_in(obj)) {
          // Object is in the region. Check that its less than top
<span class="line-modified">!         if (_hr-&gt;top() &lt;= cast_from_oop&lt;HeapWord*&gt;(obj)) {</span>
            // Object is above top
            log_error(gc, verify)(&quot;Object &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; is above top &quot;,
                                  p2i(obj), HR_FORMAT_PARAMS(_hr));
            _failures = true;
            return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,10 ***</span>
<span class="line-new-header">--- 461,11 ---</span>
      *failures = true;
    }
  }
  
  void HeapRegion::print() const { print_on(tty); }
<span class="line-added">+ </span>
  void HeapRegion::print_on(outputStream* st) const {
    st-&gt;print(&quot;|%4u&quot;, this-&gt;_hrm_index);
    st-&gt;print(&quot;|&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT,
              p2i(bottom()), p2i(top()), p2i(end()));
    st-&gt;print(&quot;|%3d%%&quot;, (int) ((double) used() * 100 / capacity()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,12 ***</span>
    if (in_collection_set()) {
      st-&gt;print(&quot;|CS&quot;);
    } else {
      st-&gt;print(&quot;|  &quot;);
    }
<span class="line-modified">!   st-&gt;print_cr(&quot;|TAMS &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;| %s &quot;,</span>
                 p2i(prev_top_at_mark_start()), p2i(next_top_at_mark_start()), rem_set()-&gt;get_state_str());
  }
  
  class G1VerificationClosure : public BasicOopIterateClosure {
  protected:
    G1CollectedHeap* _g1h;
<span class="line-new-header">--- 473,21 ---</span>
    if (in_collection_set()) {
      st-&gt;print(&quot;|CS&quot;);
    } else {
      st-&gt;print(&quot;|  &quot;);
    }
<span class="line-modified">!   st-&gt;print(&quot;|TAMS &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;| %s &quot;,</span>
                 p2i(prev_top_at_mark_start()), p2i(next_top_at_mark_start()), rem_set()-&gt;get_state_str());
<span class="line-added">+   if (UseNUMA) {</span>
<span class="line-added">+     G1NUMA* numa = G1NUMA::numa();</span>
<span class="line-added">+     if (node_index() &lt; numa-&gt;num_active_nodes()) {</span>
<span class="line-added">+       st-&gt;print(&quot;|%d&quot;, numa-&gt;numa_id(node_index()));</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       st-&gt;print(&quot;|-&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   st-&gt;print_cr(&quot;&quot;);</span>
  }
  
  class G1VerificationClosure : public BasicOopIterateClosure {
  protected:
    G1CollectedHeap* _g1h;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 512,30 ***</span>
      T heap_oop = RawAccess&lt;&gt;::oop_load(p);
      Log(gc, verify) log;
      if (!CompressedOops::is_null(heap_oop)) {
        oop obj = CompressedOops::decode_not_null(heap_oop);
        bool failed = false;
<span class="line-modified">!       if (!_g1h-&gt;is_in_closed_subset(obj) || _g1h-&gt;is_obj_dead_cond(obj, _vo)) {</span>
<span class="line-modified">!         MutexLockerEx x(ParGCRareEvent_lock,</span>
            Mutex::_no_safepoint_check_flag);
  
          if (!_failures) {
            log.error(&quot;----------&quot;);
          }
          ResourceMark rm;
<span class="line-modified">!         if (!_g1h-&gt;is_in_closed_subset(obj)) {</span>
            HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
            log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
                      p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
            LogStream ls(log.error());
            print_object(&amp;ls, _containing_obj);
            HeapRegion* const to = _g1h-&gt;heap_region_containing(obj);
            log.error(&quot;points to obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; remset %s&quot;,
                      p2i(obj), HR_FORMAT_PARAMS(to), to-&gt;rem_set()-&gt;get_state_str());
          } else {
            HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
<span class="line-modified">!           HeapRegion* to = _g1h-&gt;heap_region_containing((HeapWord*)obj);</span>
            log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
                      p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
            LogStream ls(log.error());
            print_object(&amp;ls, _containing_obj);
            log.error(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
<span class="line-new-header">--- 545,30 ---</span>
      T heap_oop = RawAccess&lt;&gt;::oop_load(p);
      Log(gc, verify) log;
      if (!CompressedOops::is_null(heap_oop)) {
        oop obj = CompressedOops::decode_not_null(heap_oop);
        bool failed = false;
<span class="line-modified">!       if (!_g1h-&gt;is_in(obj) || _g1h-&gt;is_obj_dead_cond(obj, _vo)) {</span>
<span class="line-modified">!         MutexLocker x(ParGCRareEvent_lock,</span>
            Mutex::_no_safepoint_check_flag);
  
          if (!_failures) {
            log.error(&quot;----------&quot;);
          }
          ResourceMark rm;
<span class="line-modified">!         if (!_g1h-&gt;is_in(obj)) {</span>
            HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
            log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
                      p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
            LogStream ls(log.error());
            print_object(&amp;ls, _containing_obj);
            HeapRegion* const to = _g1h-&gt;heap_region_containing(obj);
            log.error(&quot;points to obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT &quot; remset %s&quot;,
                      p2i(obj), HR_FORMAT_PARAMS(to), to-&gt;rem_set()-&gt;get_state_str());
          } else {
            HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
<span class="line-modified">!           HeapRegion* to = _g1h-&gt;heap_region_containing(obj);</span>
            log.error(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
                      p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
            LogStream ls(log.error());
            print_object(&amp;ls, _containing_obj);
            log.error(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
            || to-&gt;rem_set()-&gt;contains_reference(p)
            || (_containing_obj-&gt;is_objArray() ?
                  cv_field == dirty :
                  cv_obj == dirty || cv_field == dirty));
          if (is_bad) {
<span class="line-modified">!           MutexLockerEx x(ParGCRareEvent_lock,</span>
              Mutex::_no_safepoint_check_flag);
  
            if (!_failures) {
              log.error(&quot;----------&quot;);
            }
<span class="line-new-header">--- 618,11 ---</span>
            || to-&gt;rem_set()-&gt;contains_reference(p)
            || (_containing_obj-&gt;is_objArray() ?
                  cv_field == dirty :
                  cv_obj == dirty || cv_field == dirty));
          if (is_bad) {
<span class="line-modified">!           MutexLocker x(ParGCRareEvent_lock,</span>
              Mutex::_no_safepoint_check_flag);
  
            if (!_failures) {
              log.error(&quot;----------&quot;);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,13 ***</span>
  
    // This closure provides its own oop verification code.
    debug_only(virtual bool should_verify_oops() { return false; })
  };
  
<span class="line-removed">- // This really ought to be commoned up into OffsetTableContigSpace somehow.</span>
<span class="line-removed">- // We would need a mechanism to make that code skip dead objects.</span>
<span class="line-removed">- </span>
  void HeapRegion::verify(VerifyOption vo,
                          bool* failures) const {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    *failures = false;
    HeapWord* p = bottom();
<span class="line-new-header">--- 663,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,11 ***</span>
      _bot_part.verify();
    }
  
    if (is_region_humongous) {
      oop obj = oop(this-&gt;humongous_start_region()-&gt;bottom());
<span class="line-modified">!     if ((HeapWord*)obj &gt; bottom() || (HeapWord*)obj + obj-&gt;size() &lt; bottom()) {</span>
        log_error(gc, verify)(&quot;this humongous region is not part of its&#39; humongous object &quot; PTR_FORMAT, p2i(obj));
        *failures = true;
        return;
      }
    }
<span class="line-new-header">--- 735,11 ---</span>
      _bot_part.verify();
    }
  
    if (is_region_humongous) {
      oop obj = oop(this-&gt;humongous_start_region()-&gt;bottom());
<span class="line-modified">!     if (cast_from_oop&lt;HeapWord*&gt;(obj) &gt; bottom() || cast_from_oop&lt;HeapWord*&gt;(obj) + obj-&gt;size() &lt; bottom()) {</span>
        log_error(gc, verify)(&quot;this humongous region is not part of its&#39; humongous object &quot; PTR_FORMAT, p2i(obj));
        *failures = true;
        return;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,11 ***</span>
    // range [top, end). BOT look-ups in this range should yield
    // top. No point in doing that if top == end (there&#39;s nothing there).
    if (p &lt; the_end) {
      // Look up top
      HeapWord* addr_1 = p;
<span class="line-modified">!     HeapWord* b_start_1 = _bot_part.block_start_const(addr_1);</span>
      if (b_start_1 != p) {
        log_error(gc, verify)(&quot;BOT look up for top: &quot; PTR_FORMAT &quot; &quot;
                              &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                              p2i(addr_1), p2i(b_start_1), p2i(p));
        *failures = true;
<span class="line-new-header">--- 756,11 ---</span>
    // range [top, end). BOT look-ups in this range should yield
    // top. No point in doing that if top == end (there&#39;s nothing there).
    if (p &lt; the_end) {
      // Look up top
      HeapWord* addr_1 = p;
<span class="line-modified">!     HeapWord* b_start_1 = block_start_const(addr_1);</span>
      if (b_start_1 != p) {
        log_error(gc, verify)(&quot;BOT look up for top: &quot; PTR_FORMAT &quot; &quot;
                              &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                              p2i(addr_1), p2i(b_start_1), p2i(p));
        *failures = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,11 ***</span>
      }
  
      // Look up top + 1
      HeapWord* addr_2 = p + 1;
      if (addr_2 &lt; the_end) {
<span class="line-modified">!       HeapWord* b_start_2 = _bot_part.block_start_const(addr_2);</span>
        if (b_start_2 != p) {
          log_error(gc, verify)(&quot;BOT look up for top + 1: &quot; PTR_FORMAT &quot; &quot;
                                &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                                p2i(addr_2), p2i(b_start_2), p2i(p));
          *failures = true;
<span class="line-new-header">--- 768,11 ---</span>
      }
  
      // Look up top + 1
      HeapWord* addr_2 = p + 1;
      if (addr_2 &lt; the_end) {
<span class="line-modified">!       HeapWord* b_start_2 = block_start_const(addr_2);</span>
        if (b_start_2 != p) {
          log_error(gc, verify)(&quot;BOT look up for top + 1: &quot; PTR_FORMAT &quot; &quot;
                                &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                                p2i(addr_2), p2i(b_start_2), p2i(p));
          *failures = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 752,11 ***</span>
  
      // Look up an address between top and end
      size_t diff = pointer_delta(the_end, p) / 2;
      HeapWord* addr_3 = p + diff;
      if (addr_3 &lt; the_end) {
<span class="line-modified">!       HeapWord* b_start_3 = _bot_part.block_start_const(addr_3);</span>
        if (b_start_3 != p) {
          log_error(gc, verify)(&quot;BOT look up for top + diff: &quot; PTR_FORMAT &quot; &quot;
                                &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                                p2i(addr_3), p2i(b_start_3), p2i(p));
          *failures = true;
<span class="line-new-header">--- 782,11 ---</span>
  
      // Look up an address between top and end
      size_t diff = pointer_delta(the_end, p) / 2;
      HeapWord* addr_3 = p + diff;
      if (addr_3 &lt; the_end) {
<span class="line-modified">!       HeapWord* b_start_3 = block_start_const(addr_3);</span>
        if (b_start_3 != p) {
          log_error(gc, verify)(&quot;BOT look up for top + diff: &quot; PTR_FORMAT &quot; &quot;
                                &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                                p2i(addr_3), p2i(b_start_3), p2i(p));
          *failures = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,11 ***</span>
        }
      }
  
      // Look up end - 1
      HeapWord* addr_4 = the_end - 1;
<span class="line-modified">!     HeapWord* b_start_4 = _bot_part.block_start_const(addr_4);</span>
      if (b_start_4 != p) {
        log_error(gc, verify)(&quot;BOT look up for end - 1: &quot; PTR_FORMAT &quot; &quot;
                              &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                              p2i(addr_4), p2i(b_start_4), p2i(p));
        *failures = true;
<span class="line-new-header">--- 794,11 ---</span>
        }
      }
  
      // Look up end - 1
      HeapWord* addr_4 = the_end - 1;
<span class="line-modified">!     HeapWord* b_start_4 = block_start_const(addr_4);</span>
      if (b_start_4 != p) {
        log_error(gc, verify)(&quot;BOT look up for end - 1: &quot; PTR_FORMAT &quot; &quot;
                              &quot; yielded &quot; PTR_FORMAT &quot;, expecting &quot; PTR_FORMAT,
                              p2i(addr_4), p2i(b_start_4), p2i(p));
        *failures = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,73 ***</span>
    bool failures = false;
    verify_rem_set(VerifyOption_G1UsePrevMarking, &amp;failures);
    guarantee(!failures, &quot;HeapRegion RemSet verification failed&quot;);
  }
  
<span class="line-modified">! void HeapRegion::prepare_for_compaction(CompactPoint* cp) {</span>
<span class="line-removed">-   // Not used for G1 anymore, but pure virtual in Space.</span>
<span class="line-removed">-   ShouldNotReachHere();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // G1OffsetTableContigSpace code; copied from space.cpp.  Hope this can go</span>
<span class="line-removed">- // away eventually.</span>
<span class="line-removed">- </span>
<span class="line-removed">- void G1ContiguousSpace::clear(bool mangle_space) {</span>
    set_top(bottom());
<span class="line-modified">!   CompactibleSpace::clear(mangle_space);</span>
    reset_bot();
  }
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">- void G1ContiguousSpace::mangle_unused_area() {</span>
<span class="line-removed">-   mangle_unused_area_complete();</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void G1ContiguousSpace::mangle_unused_area_complete() {</span>
    SpaceMangler::mangle_region(MemRegion(top(), end()));
  }
  #endif
  
<span class="line-modified">! void G1ContiguousSpace::print() const {</span>
<span class="line-removed">-   print_short();</span>
<span class="line-removed">-   tty-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot;</span>
<span class="line-removed">-                 INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="line-removed">-                 p2i(bottom()), p2i(top()), p2i(_bot_part.threshold()), p2i(end()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- HeapWord* G1ContiguousSpace::initialize_threshold() {</span>
    return _bot_part.initialize_threshold();
  }
  
<span class="line-modified">! HeapWord* G1ContiguousSpace::cross_threshold(HeapWord* start,</span>
<span class="line-removed">-                                                     HeapWord* end) {</span>
    _bot_part.alloc_block(start, end);
    return _bot_part.threshold();
  }
  
<span class="line-modified">! void G1ContiguousSpace::safe_object_iterate(ObjectClosure* blk) {</span>
<span class="line-removed">-   object_iterate(blk);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void G1ContiguousSpace::object_iterate(ObjectClosure* blk) {</span>
    HeapWord* p = bottom();
    while (p &lt; top()) {
      if (block_is_obj(p)) {
        blk-&gt;do_object(oop(p));
      }
      p += block_size(p);
    }
  }
<span class="line-removed">- </span>
<span class="line-removed">- G1ContiguousSpace::G1ContiguousSpace(G1BlockOffsetTable* bot) :</span>
<span class="line-removed">-   _top(NULL),</span>
<span class="line-removed">-   _bot_part(bot, this),</span>
<span class="line-removed">-   _par_alloc_lock(Mutex::leaf, &quot;OffsetTableContigSpace par alloc lock&quot;, true),</span>
<span class="line-removed">-   _pre_dummy_top(NULL)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void G1ContiguousSpace::initialize(MemRegion mr, bool clear_space, bool mangle_space) {</span>
<span class="line-removed">-   CompactibleSpace::initialize(mr, clear_space, mangle_space);</span>
<span class="line-removed">-   _top = bottom();</span>
<span class="line-removed">-   set_saved_mark_word(NULL);</span>
<span class="line-removed">-   reset_bot();</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 852,39 ---</span>
    bool failures = false;
    verify_rem_set(VerifyOption_G1UsePrevMarking, &amp;failures);
    guarantee(!failures, &quot;HeapRegion RemSet verification failed&quot;);
  }
  
<span class="line-modified">! void HeapRegion::clear(bool mangle_space) {</span>
    set_top(bottom());
<span class="line-modified">!   set_compaction_top(bottom());</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (ZapUnusedHeapArea &amp;&amp; mangle_space) {</span>
<span class="line-added">+     mangle_unused_area();</span>
<span class="line-added">+   }</span>
    reset_bot();
  }
  
<span class="line-modified">! #ifndef PRODUCT</span>
<span class="line-added">+ void HeapRegion::mangle_unused_area() {</span>
    SpaceMangler::mangle_region(MemRegion(top(), end()));
  }
  #endif
  
<span class="line-modified">! HeapWord* HeapRegion::initialize_threshold() {</span>
    return _bot_part.initialize_threshold();
  }
  
<span class="line-modified">! HeapWord* HeapRegion::cross_threshold(HeapWord* start, HeapWord* end) {</span>
    _bot_part.alloc_block(start, end);
    return _bot_part.threshold();
  }
  
<span class="line-modified">! void HeapRegion::object_iterate(ObjectClosure* blk) {</span>
    HeapWord* p = bottom();
    while (p &lt; top()) {
      if (block_is_obj(p)) {
        blk-&gt;do_object(oop(p));
      }
      p += block_size(p);
    }
  }
</pre>
<center><a href="g1_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
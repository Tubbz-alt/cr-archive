<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1CardTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CardTable.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/shared/memset_with_concurrent_readers.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/orderAccess.hpp&quot;
 32 
 33 bool G1CardTable::mark_card_deferred(size_t card_index) {
 34   CardValue val = _byte_map[card_index];
 35   // It&#39;s already processed
 36   if ((val &amp; (clean_card_mask_val() | deferred_card_val())) == deferred_card_val()) {
 37     return false;
 38   }
 39 
 40   // Cached bit can be installed either on a clean card or on a claimed card.
 41   CardValue new_val = val;
 42   if (val == clean_card_val()) {
 43     new_val = deferred_card_val();
 44   } else {
 45     if (val &amp; claimed_card_val()) {
 46       new_val = val | deferred_card_val();
 47     }
 48   }
 49   if (new_val != val) {
 50     Atomic::cmpxchg(new_val, &amp;_byte_map[card_index], val);
 51   }
 52   return true;
 53 }
 54 
 55 void G1CardTable::g1_mark_as_young(const MemRegion&amp; mr) {
 56   CardValue *const first = byte_for(mr.start());
 57   CardValue *const last = byte_after(mr.last());
 58 
 59   memset_with_concurrent_readers(first, g1_young_gen, last - first);
 60 }
 61 
 62 #ifndef PRODUCT
 63 void G1CardTable::verify_g1_young_region(MemRegion mr) {
 64   verify_region(mr, g1_young_gen,  true);
 65 }
 66 #endif
 67 
 68 void G1CardTableChangedListener::on_commit(uint start_idx, size_t num_regions, bool zero_filled) {
 69   // Default value for a clean card on the card table is -1. So we cannot take advantage of the zero_filled parameter.
 70   MemRegion mr(G1CollectedHeap::heap()-&gt;bottom_addr_for_region(start_idx), num_regions * HeapRegion::GrainWords);
 71   _card_table-&gt;clear(mr);
 72 }
 73 
 74 void G1CardTable::initialize(G1RegionToSpaceMapper* mapper) {
 75   mapper-&gt;set_mapping_changed_listener(&amp;_listener);
 76 
 77   _byte_map_size = mapper-&gt;reserved().byte_size();
 78 
 79   _guard_index = cards_required(_whole_heap.word_size()) - 1;
 80   _last_valid_index = _guard_index - 1;
 81 
 82   HeapWord* low_bound  = _whole_heap.start();
 83   HeapWord* high_bound = _whole_heap.end();
 84 
 85   _cur_covered_regions = 1;
 86   _covered[0] = _whole_heap;
 87 
 88   _byte_map = (CardValue*) mapper-&gt;reserved().start();
 89   _byte_map_base = _byte_map - (uintptr_t(low_bound) &gt;&gt; card_shift);
 90   assert(byte_for(low_bound) == &amp;_byte_map[0], &quot;Checking start of map&quot;);
 91   assert(byte_for(high_bound-1) &lt;= &amp;_byte_map[_last_valid_index], &quot;Checking end of map&quot;);
 92 
 93   log_trace(gc, barrier)(&quot;G1CardTable::G1CardTable: &quot;);
 94   log_trace(gc, barrier)(&quot;    &amp;_byte_map[0]: &quot; INTPTR_FORMAT &quot;  &amp;_byte_map[_last_valid_index]: &quot; INTPTR_FORMAT,
 95                          p2i(&amp;_byte_map[0]), p2i(&amp;_byte_map[_last_valid_index]));
 96   log_trace(gc, barrier)(&quot;    _byte_map_base: &quot; INTPTR_FORMAT,  p2i(_byte_map_base));
 97 }
 98 
 99 bool G1CardTable::is_in_young(oop obj) const {
100   volatile CardValue* p = byte_for(obj);
101   return *p == G1CardTable::g1_young_card_val();
102 }
    </pre>
  </body>
</html>
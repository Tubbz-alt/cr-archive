<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/heapRegionRemSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionRemSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionRemSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,20 +26,21 @@</span>
  #define SHARE_GC_G1_HEAPREGIONREMSET_HPP
  
  #include &quot;gc/g1/g1CodeCacheRemSet.hpp&quot;
  #include &quot;gc/g1/g1FromCardCache.hpp&quot;
  #include &quot;gc/g1/sparsePRT.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/bitMap.hpp&quot;</span>
  
  // Remembered set for a heap region.  Represent a set of &quot;cards&quot; that
  // contain pointers into the owner heap region.  Cards are defined somewhat
  // abstractly, in terms of what the &quot;BlockOffsetTable&quot; in use can parse.
  
  class G1CollectedHeap;
  class G1BlockOffsetTable;
  class G1CardLiveData;
  class HeapRegion;
<span class="udiff-line-removed">- class HeapRegionRemSetIterator;</span>
  class PerRegionTable;
  class SparsePRT;
  class nmethod;
  
  // The &quot;_coarse_map&quot; is a bitmap with one bit for each region, where set
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,15 +66,15 @@</span>
  //      it&#39;s _coarse_map bit is set, so the that we were attempting to add
  //      is represented.  If a deleted PRT is re-used, a thread adding a bit,
  //      thinking the PRT is for a different region, does no harm.
  
  class OtherRegionsTable {
<span class="udiff-line-removed">-   friend class HeapRegionRemSetIterator;</span>
<span class="udiff-line-removed">- </span>
    G1CollectedHeap* _g1h;
    Mutex*           _m;
  
<span class="udiff-line-added">+   size_t volatile _num_occupied;</span>
<span class="udiff-line-added">+ </span>
    // These are protected by &quot;_m&quot;.
    CHeapBitMap _coarse_map;
    size_t      _n_coarse_entries;
    static jint _n_coarsenings;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,27 +107,26 @@</span>
    PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;
  
    // Find, delete, and return a candidate PerRegionTable, if any exists,
    // adding the deleted region to the coarse bitmap.  Requires the caller
    // to hold _m, and the fine-grain table to be full.
<span class="udiff-line-modified-removed">-   PerRegionTable* delete_region_table();</span>
<span class="udiff-line-modified-added">+   PerRegionTable* delete_region_table(size_t&amp; added_by_deleted);</span>
  
    // link/add the given fine grain remembered set into the &quot;all&quot; list
    void link_to_all(PerRegionTable * prt);
    // unlink/remove the given fine grain remembered set into the &quot;all&quot; list
    void unlink_from_all(PerRegionTable * prt);
  
    bool contains_reference_locked(OopOrNarrowOopStar from) const;
  
<span class="udiff-line-removed">-   size_t occ_fine() const;</span>
<span class="udiff-line-removed">-   size_t occ_coarse() const;</span>
<span class="udiff-line-removed">-   size_t occ_sparse() const;</span>
<span class="udiff-line-removed">- </span>
  public:
    // Create a new remembered set. The given mutex is used to ensure consistency.
    OtherRegionsTable(Mutex* m);
  
<span class="udiff-line-added">+   template &lt;class Closure&gt;</span>
<span class="udiff-line-added">+   void iterate(Closure&amp; v);</span>
<span class="udiff-line-added">+ </span>
    // Returns the card index of the given within_region pointer relative to the bottom
    // of the given heap region.
    static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);
    // Adds the reference from &quot;from to this remembered set.
    void add_reference(OopOrNarrowOopStar from, uint tid);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,13 +155,134 @@</span>
  
    // Clear the entire contents of this remembered set.
    void clear();
  };
  
<span class="udiff-line-added">+ class PerRegionTable: public CHeapObj&lt;mtGC&gt; {</span>
<span class="udiff-line-added">+   friend class OtherRegionsTable;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapRegion*     _hr;</span>
<span class="udiff-line-added">+   CHeapBitMap     _bm;</span>
<span class="udiff-line-added">+   jint            _occupied;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // next pointer for free/allocated &#39;all&#39; list</span>
<span class="udiff-line-added">+   PerRegionTable* _next;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // prev pointer for the allocated &#39;all&#39; list</span>
<span class="udiff-line-added">+   PerRegionTable* _prev;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // next pointer in collision list</span>
<span class="udiff-line-added">+   PerRegionTable * _collision_list_next;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Global free list of PRTs</span>
<span class="udiff-line-added">+   static PerRegionTable* volatile _free_list;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ protected:</span>
<span class="udiff-line-added">+   PerRegionTable(HeapRegion* hr) :</span>
<span class="udiff-line-added">+     _hr(hr),</span>
<span class="udiff-line-added">+     _bm(HeapRegion::CardsPerRegion, mtGC),</span>
<span class="udiff-line-added">+     _occupied(0),</span>
<span class="udiff-line-added">+     _next(NULL), _prev(NULL),</span>
<span class="udiff-line-added">+     _collision_list_next(NULL)</span>
<span class="udiff-line-added">+   {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   // We need access in order to union things into the base table.</span>
<span class="udiff-line-added">+   BitMap* bm() { return &amp;_bm; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HeapRegion* hr() const { return Atomic::load_acquire(&amp;_hr); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   jint occupied() const {</span>
<span class="udiff-line-added">+     return _occupied;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void init(HeapRegion* hr, bool clear_links_to_all_list);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   inline bool add_reference(OopOrNarrowOopStar from);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   inline bool add_card(CardIdx_t from_card_index);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // (Destructively) union the bitmap of the current table into the given</span>
<span class="udiff-line-added">+   // bitmap (which is assumed to be of the same size.)</span>
<span class="udiff-line-added">+   void union_bitmap_into(BitMap* bm) {</span>
<span class="udiff-line-added">+     bm-&gt;set_union(_bm);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Mem size in bytes.</span>
<span class="udiff-line-added">+   size_t mem_size() const {</span>
<span class="udiff-line-added">+     return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Requires &quot;from&quot; to be in &quot;hr()&quot;.</span>
<span class="udiff-line-added">+   bool contains_reference(OopOrNarrowOopStar from) const {</span>
<span class="udiff-line-added">+     assert(hr()-&gt;is_in_reserved(from), &quot;Precondition.&quot;);</span>
<span class="udiff-line-added">+     size_t card_ind = pointer_delta(from, hr()-&gt;bottom(),</span>
<span class="udiff-line-added">+                                     G1CardTable::card_size);</span>
<span class="udiff-line-added">+     return _bm.at(card_ind);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Bulk-free the PRTs from prt to last, assumes that they are</span>
<span class="udiff-line-added">+   // linked together using their _next field.</span>
<span class="udiff-line-added">+   static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {</span>
<span class="udiff-line-added">+     while (true) {</span>
<span class="udiff-line-added">+       PerRegionTable* fl = _free_list;</span>
<span class="udiff-line-added">+       last-&gt;set_next(fl);</span>
<span class="udiff-line-added">+       PerRegionTable* res = Atomic::cmpxchg(&amp;_free_list, fl, prt);</span>
<span class="udiff-line-added">+       if (res == fl) {</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ShouldNotReachHere();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static void free(PerRegionTable* prt) {</span>
<span class="udiff-line-added">+     bulk_free(prt, prt);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Returns an initialized PerRegionTable instance.</span>
<span class="udiff-line-added">+   static PerRegionTable* alloc(HeapRegion* hr);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   PerRegionTable* next() const { return _next; }</span>
<span class="udiff-line-added">+   void set_next(PerRegionTable* next) { _next = next; }</span>
<span class="udiff-line-added">+   PerRegionTable* prev() const { return _prev; }</span>
<span class="udiff-line-added">+   void set_prev(PerRegionTable* prev) { _prev = prev; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Accessor and Modification routines for the pointer for the</span>
<span class="udiff-line-added">+   // singly linked collision list that links the PRTs within the</span>
<span class="udiff-line-added">+   // OtherRegionsTable::_fine_grain_regions hash table.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // It might be useful to also make the collision list doubly linked</span>
<span class="udiff-line-added">+   // to avoid iteration over the collisions list during scrubbing/deletion.</span>
<span class="udiff-line-added">+   // OTOH there might not be many collisions.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   PerRegionTable* collision_list_next() const {</span>
<span class="udiff-line-added">+     return _collision_list_next;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void set_collision_list_next(PerRegionTable* next) {</span>
<span class="udiff-line-added">+     _collision_list_next = next;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   PerRegionTable** collision_list_next_addr() {</span>
<span class="udiff-line-added">+     return &amp;_collision_list_next;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static size_t fl_mem_size() {</span>
<span class="udiff-line-added">+     PerRegionTable* cur = _free_list;</span>
<span class="udiff-line-added">+     size_t res = 0;</span>
<span class="udiff-line-added">+     while (cur != NULL) {</span>
<span class="udiff-line-added">+       res += cur-&gt;mem_size();</span>
<span class="udiff-line-added">+       cur = cur-&gt;next();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return res;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   static void test_fl_mem_size();</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  class HeapRegionRemSet : public CHeapObj&lt;mtGC&gt; {
    friend class VMStructs;
<span class="udiff-line-removed">-   friend class HeapRegionRemSetIterator;</span>
  
  private:
    G1BlockOffsetTable* _bot;
  
    // A set of code blobs (nmethods) whose code contains pointers into
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,29 +298,31 @@</span>
    void clear_fcc();
  
  public:
    HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);
  
<span class="udiff-line-added">+   // Setup sparse and fine-grain tables sizes.</span>
    static void setup_remset_size();
  
<span class="udiff-line-removed">-   bool cardset_is_empty() const {</span>
<span class="udiff-line-removed">-     return _other_regions.is_empty();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    bool is_empty() const {
<span class="udiff-line-modified-removed">-     return (strong_code_roots_list_length() == 0) &amp;&amp; cardset_is_empty();</span>
<span class="udiff-line-modified-added">+     return (strong_code_roots_list_length() == 0) &amp;&amp; _other_regions.is_empty();</span>
    }
  
    bool occupancy_less_or_equal_than(size_t occ) const {
      return (strong_code_roots_list_length() == 0) &amp;&amp; _other_regions.occupancy_less_or_equal_than(occ);
    }
  
<span class="udiff-line-added">+   // For each PRT in the card (remembered) set call one of the following methods</span>
<span class="udiff-line-added">+   // of the given closure:</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs</span>
<span class="udiff-line-added">+   // set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs</span>
<span class="udiff-line-added">+   // set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs</span>
<span class="udiff-line-added">+   template &lt;class Closure&gt;</span>
<span class="udiff-line-added">+   inline void iterate_prts(Closure&amp; cl);</span>
<span class="udiff-line-added">+ </span>
    size_t occupied() {
<span class="udiff-line-removed">-     MutexLockerEx x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-     return occupied_locked();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   size_t occupied_locked() {</span>
      return _other_regions.occupied();
    }
  
    static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -241,16 +364,10 @@</span>
    void set_state_complete() {
      clear_fcc();
      _state = Complete;
    }
  
<span class="udiff-line-removed">-   // Used in the sequential case.</span>
<span class="udiff-line-removed">-   void add_reference(OopOrNarrowOopStar from) {</span>
<span class="udiff-line-removed">-     add_reference(from, 0);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Used in the parallel case.</span>
    void add_reference(OopOrNarrowOopStar from, uint tid) {
      RemSetState state = _state;
      if (state == Untracked) {
        return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -272,11 +389,11 @@</span>
    void clear_locked(bool only_cardset = false);
  
    // The actual # of bytes this hr_remset takes up.
    // Note also includes the strong code root set.
    size_t mem_size() {
<span class="udiff-line-modified-removed">-     MutexLockerEx x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MutexLocker x(&amp;_m, Mutex::_no_safepoint_check_flag);</span>
      return _other_regions.mem_size()
        // This correction is necessary because the above includes the second
        // part.
        + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))
        + strong_code_roots_mem_size();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,72 +453,6 @@</span>
  
    static void test();
  #endif
  };
  
<span class="udiff-line-removed">- class HeapRegionRemSetIterator : public StackObj {</span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-   // The region RSet over which we are iterating.</span>
<span class="udiff-line-removed">-   HeapRegionRemSet* _hrrs;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Local caching of HRRS fields.</span>
<span class="udiff-line-removed">-   const BitMap*             _coarse_map;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   G1BlockOffsetTable*       _bot;</span>
<span class="udiff-line-removed">-   G1CollectedHeap*          _g1h;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The number of cards yielded since initialization.</span>
<span class="udiff-line-removed">-   size_t _n_yielded_fine;</span>
<span class="udiff-line-removed">-   size_t _n_yielded_coarse;</span>
<span class="udiff-line-removed">-   size_t _n_yielded_sparse;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Indicates what granularity of table that we are currently iterating over.</span>
<span class="udiff-line-removed">-   // We start iterating over the sparse table, progress to the fine grain</span>
<span class="udiff-line-removed">-   // table, and then finish with the coarse table.</span>
<span class="udiff-line-removed">-   enum IterState {</span>
<span class="udiff-line-removed">-     Sparse,</span>
<span class="udiff-line-removed">-     Fine,</span>
<span class="udiff-line-removed">-     Coarse</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">-   IterState _is;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For both Coarse and Fine remembered set iteration this contains the</span>
<span class="udiff-line-removed">-   // first card number of the heap region we currently iterate over.</span>
<span class="udiff-line-removed">-   size_t _cur_region_card_offset;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Current region index for the Coarse remembered set iteration.</span>
<span class="udiff-line-removed">-   int    _coarse_cur_region_index;</span>
<span class="udiff-line-removed">-   size_t _coarse_cur_region_cur_card;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool coarse_has_next(size_t&amp; card_index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The PRT we are currently iterating over.</span>
<span class="udiff-line-removed">-   PerRegionTable* _fine_cur_prt;</span>
<span class="udiff-line-removed">-   // Card offset within the current PRT.</span>
<span class="udiff-line-removed">-   size_t _cur_card_in_prt;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Update internal variables when switching to the given PRT.</span>
<span class="udiff-line-removed">-   void switch_to_prt(PerRegionTable* prt);</span>
<span class="udiff-line-removed">-   bool fine_has_next();</span>
<span class="udiff-line-removed">-   bool fine_has_next(size_t&amp; card_index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // The Sparse remembered set iterator.</span>
<span class="udiff-line-removed">-   SparsePRTIter _sparse_iter;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   HeapRegionRemSetIterator(HeapRegionRemSet* hrrs);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If there remains one or more cards to be yielded, returns true and</span>
<span class="udiff-line-removed">-   // sets &quot;card_index&quot; to one of those cards (which is then considered</span>
<span class="udiff-line-removed">-   // yielded.)   Otherwise, returns false (and leaves &quot;card_index&quot;</span>
<span class="udiff-line-removed">-   // undefined.)</span>
<span class="udiff-line-removed">-   bool has_next(size_t&amp; card_index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t n_yielded_fine() { return _n_yielded_fine; }</span>
<span class="udiff-line-removed">-   size_t n_yielded_coarse() { return _n_yielded_coarse; }</span>
<span class="udiff-line-removed">-   size_t n_yielded_sparse() { return _n_yielded_sparse; }</span>
<span class="udiff-line-removed">-   size_t n_yielded() {</span>
<span class="udiff-line-removed">-     return n_yielded_fine() + n_yielded_coarse() + n_yielded_sparse();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  #endif // SHARE_GC_G1_HEAPREGIONREMSET_HPP
</pre>
<center><a href="heapRegionRemSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
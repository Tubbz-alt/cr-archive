<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1CollectedHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,32 +27,34 @@</span>
  
  #include &quot;gc/g1/g1BarrierSet.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  #include &quot;gc/g1/g1CollectorState.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1RemSet.hpp&quot;</span>
  #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>
  #include &quot;gc/g1/heapRegionSet.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/markBitMap.inline.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  
  G1GCPhaseTimes* G1CollectedHeap::phase_times() const {
    return _policy-&gt;phase_times();
  }
  
<span class="udiff-line-modified-removed">- G1EvacStats* G1CollectedHeap::alloc_buffer_stats(InCSetState dest) {</span>
<span class="udiff-line-modified-removed">-   switch (dest.value()) {</span>
<span class="udiff-line-modified-removed">-     case InCSetState::Young:</span>
<span class="udiff-line-modified-added">+ G1EvacStats* G1CollectedHeap::alloc_buffer_stats(G1HeapRegionAttr dest) {</span>
<span class="udiff-line-modified-added">+   switch (dest.type()) {</span>
<span class="udiff-line-modified-added">+     case G1HeapRegionAttr::Young:</span>
        return &amp;_survivor_evac_stats;
<span class="udiff-line-modified-removed">-     case InCSetState::Old:</span>
<span class="udiff-line-modified-added">+     case G1HeapRegionAttr::Old:</span>
        return &amp;_old_evac_stats;
      default:
        ShouldNotReachHere();
        return NULL; // Keep some compilers happy
    }
  }
  
<span class="udiff-line-modified-removed">- size_t G1CollectedHeap::desired_plab_sz(InCSetState dest) {</span>
<span class="udiff-line-modified-added">+ size_t G1CollectedHeap::desired_plab_sz(G1HeapRegionAttr dest) {</span>
    size_t gclab_word_size = alloc_buffer_stats(dest)-&gt;desired_plab_sz(workers()-&gt;active_workers());
    // Prevent humongous PLAB sizes for two reasons:
    // * PLABs are allocated using a similar paths as oops, but should
    //   never be in a humongous region
    // * Allowing humongous PLABs needlessly churns the region free lists
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,11 +88,11 @@</span>
  inline HeapRegion* G1CollectedHeap::heap_region_containing(const T addr) const {
    assert(addr != NULL, &quot;invariant&quot;);
    assert(is_in_g1_reserved((const void*) addr),
           &quot;Address &quot; PTR_FORMAT &quot; is outside of the heap ranging from [&quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;)&quot;,
           p2i((void*)addr), p2i(g1_reserved().start()), p2i(g1_reserved().end()));
<span class="udiff-line-modified-removed">-   return _hrm-&gt;addr_to_region((HeapWord*) addr);</span>
<span class="udiff-line-modified-added">+   return _hrm-&gt;addr_to_region((HeapWord*)(void*) addr);</span>
  }
  
  template &lt;class T&gt;
  inline HeapRegion* G1CollectedHeap::heap_region_containing_or_null(const T addr) const {
    assert(addr != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -140,35 +142,52 @@</span>
  inline RefToScanQueue* G1CollectedHeap::task_queue(uint i) const {
    return _task_queues-&gt;queue(i);
  }
  
  inline bool G1CollectedHeap::is_marked_next(oop obj) const {
<span class="udiff-line-modified-removed">-   return _cm-&gt;next_mark_bitmap()-&gt;is_marked((HeapWord*)obj);</span>
<span class="udiff-line-modified-added">+   return _cm-&gt;next_mark_bitmap()-&gt;is_marked(obj);</span>
  }
  
  inline bool G1CollectedHeap::is_in_cset(oop obj) {
<span class="udiff-line-modified-removed">-   return is_in_cset((HeapWord*)obj);</span>
<span class="udiff-line-modified-added">+   return is_in_cset(cast_from_oop&lt;HeapWord*&gt;(obj));</span>
  }
  
  inline bool G1CollectedHeap::is_in_cset(HeapWord* addr) {
<span class="udiff-line-modified-removed">-   return _in_cset_fast_test.is_in_cset(addr);</span>
<span class="udiff-line-modified-added">+   return _region_attr.is_in_cset(addr);</span>
  }
  
  bool G1CollectedHeap::is_in_cset(const HeapRegion* hr) {
<span class="udiff-line-modified-removed">-   return _in_cset_fast_test.is_in_cset(hr);</span>
<span class="udiff-line-modified-added">+   return _region_attr.is_in_cset(hr);</span>
  }
  
  bool G1CollectedHeap::is_in_cset_or_humongous(const oop obj) {
<span class="udiff-line-modified-removed">-   return _in_cset_fast_test.is_in_cset_or_humongous((HeapWord*)obj);</span>
<span class="udiff-line-modified-added">+   return _region_attr.is_in_cset_or_humongous(cast_from_oop&lt;HeapWord*&gt;(obj));</span>
  }
  
<span class="udiff-line-modified-removed">- InCSetState G1CollectedHeap::in_cset_state(const oop obj) {</span>
<span class="udiff-line-modified-removed">-   return _in_cset_fast_test.at((HeapWord*)obj);</span>
<span class="udiff-line-modified-added">+ G1HeapRegionAttr G1CollectedHeap::region_attr(const void* addr) const {</span>
<span class="udiff-line-modified-added">+   return _region_attr.at((HeapWord*)addr);</span>
  }
  
<span class="udiff-line-modified-removed">- void G1CollectedHeap::register_humongous_region_with_cset(uint index) {</span>
<span class="udiff-line-modified-removed">-   _in_cset_fast_test.set_humongous(index);</span>
<span class="udiff-line-modified-added">+ G1HeapRegionAttr G1CollectedHeap::region_attr(uint idx) const {</span>
<span class="udiff-line-modified-added">+   return _region_attr.get_by_index(idx);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1CollectedHeap::register_humongous_region_with_region_attr(uint index) {</span>
<span class="udiff-line-added">+   _region_attr.set_humongous(index, region_at(index)-&gt;rem_set()-&gt;is_tracked());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1CollectedHeap::register_region_with_region_attr(HeapRegion* r) {</span>
<span class="udiff-line-added">+   _region_attr.set_has_remset(r-&gt;hrm_index(), r-&gt;rem_set()-&gt;is_tracked());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1CollectedHeap::register_old_region_with_region_attr(HeapRegion* r) {</span>
<span class="udiff-line-added">+   _region_attr.set_in_old(r-&gt;hrm_index(), r-&gt;rem_set()-&gt;is_tracked());</span>
<span class="udiff-line-added">+   _rem_set-&gt;exclude_region_from_scan(r-&gt;hrm_index());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1CollectedHeap::register_optional_region_with_region_attr(HeapRegion* r) {</span>
<span class="udiff-line-added">+   _region_attr.set_optional(r-&gt;hrm_index(), r-&gt;rem_set()-&gt;is_tracked());</span>
  }
  
  #ifndef PRODUCT
  // Support for G1EvacuationFailureALot
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -278,24 +297,28 @@</span>
  inline bool G1CollectedHeap::is_humongous_reclaim_candidate(uint region) {
    assert(_hrm-&gt;at(region)-&gt;is_starts_humongous(), &quot;Must start a humongous object&quot;);
    return _humongous_reclaim_candidates.is_candidate(region);
  }
  
<span class="udiff-line-added">+ inline void G1CollectedHeap::set_has_humongous_reclaim_candidate(bool value) {</span>
<span class="udiff-line-added">+   _has_humongous_reclaim_candidates = value;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline void G1CollectedHeap::set_humongous_is_live(oop obj) {
<span class="udiff-line-modified-removed">-   uint region = addr_to_region((HeapWord*)obj);</span>
<span class="udiff-line-modified-added">+   uint region = addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj));</span>
    // Clear the flag in the humongous_reclaim_candidates table.  Also
<span class="udiff-line-modified-removed">-   // reset the entry in the _in_cset_fast_test table so that subsequent references</span>
<span class="udiff-line-modified-added">+   // reset the entry in the region attribute table so that subsequent references</span>
    // to the same humongous object do not go into the slow path again.
    // This is racy, as multiple threads may at the same time enter here, but this
    // is benign.
    // During collection we only ever clear the &quot;candidate&quot; flag, and only ever clear the
    // entry in the in_cset_fast_table.
    // We only ever evaluate the contents of these tables (in the VM thread) after
    // having synchronized the worker threads with the VM thread, or in the same
    // thread (i.e. within the VM thread).
    if (is_humongous_reclaim_candidate(region)) {
      set_humongous_reclaim_candidate(region, false);
<span class="udiff-line-modified-removed">-     _in_cset_fast_test.clear_humongous(region);</span>
<span class="udiff-line-modified-added">+     _region_attr.clear_humongous(region);</span>
    }
  }
  
  #endif // SHARE_GC_G1_G1COLLECTEDHEAP_INLINE_HPP
</pre>
<center><a href="g1CollectedHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
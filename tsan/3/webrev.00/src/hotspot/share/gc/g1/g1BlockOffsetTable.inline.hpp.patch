diff a/src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp b/src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp
--- a/src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp
+++ b/src/hotspot/share/gc/g1/g1BlockOffsetTable.inline.hpp
@@ -26,34 +26,38 @@
 #define SHARE_GC_G1_G1BLOCKOFFSETTABLE_INLINE_HPP
 
 #include "gc/g1/g1BlockOffsetTable.hpp"
 #include "gc/g1/heapRegion.hpp"
 #include "gc/shared/memset_with_concurrent_readers.hpp"
-#include "gc/shared/space.hpp"
+#include "runtime/atomic.hpp"
 
 inline HeapWord* G1BlockOffsetTablePart::block_start(const void* addr) {
-  if (addr >= _space->bottom() && addr < _space->end()) {
+  if (addr >= _hr->bottom() && addr < _hr->end()) {
     HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
     return forward_to_block_containing_addr(q, addr);
   } else {
     return NULL;
   }
 }
 
 inline HeapWord* G1BlockOffsetTablePart::block_start_const(const void* addr) const {
-  if (addr >= _space->bottom() && addr < _space->end()) {
+  if (addr >= _hr->bottom() && addr < _hr->end()) {
     HeapWord* q = block_at_or_preceding(addr, true, _next_offset_index-1);
     HeapWord* n = q + block_size(q);
     return forward_to_block_containing_addr_const(q, n, addr);
   } else {
     return NULL;
   }
 }
 
 u_char G1BlockOffsetTable::offset_array(size_t index) const {
   check_index(index, "index out of range");
-  return _offset_array[index];
+  return Atomic::load(&_offset_array[index]);
+}
+
+void G1BlockOffsetTable::set_offset_array_raw(size_t index, u_char offset) {
+  Atomic::store(&_offset_array[index], offset);
 }
 
 void G1BlockOffsetTable::set_offset_array(size_t index, u_char offset) {
   check_index(index, "index out of range");
   set_offset_array_raw(index, offset);
@@ -69,11 +73,12 @@
 
 void G1BlockOffsetTable::set_offset_array(size_t left, size_t right, u_char offset) {
   check_index(right, "right index out of range");
   assert(left <= right, "indexes out of order");
   size_t num_cards = right - left + 1;
-  memset_with_concurrent_readers(&_offset_array[left], offset, num_cards);
+  memset_with_concurrent_readers
+    (const_cast<u_char*> (&_offset_array[left]), offset, num_cards);
 }
 
 // Variant of index_for that does not check the index for validity.
 inline size_t G1BlockOffsetTable::index_for_raw(const void* p) const {
   return pointer_delta((char*)p, _reserved.start(), sizeof(char)) >> BOTConstants::LogN;
@@ -99,19 +104,19 @@
          p2i(result), p2i(_reserved.start()), p2i(_reserved.end()));
   return result;
 }
 
 inline size_t G1BlockOffsetTablePart::block_size(const HeapWord* p) const {
-  return _space->block_size(p);
+  return _hr->block_size(p);
 }
 
 inline HeapWord* G1BlockOffsetTablePart::block_at_or_preceding(const void* addr,
                                                                bool has_max_index,
                                                                size_t max_index) const {
-  assert(_object_can_span || _bot->offset_array(_bot->index_for(_space->bottom())) == 0,
+  assert(_object_can_span || _bot->offset_array(_bot->index_for(_hr->bottom())) == 0,
          "Object crossed region boundary, found offset %u instead of 0",
-         (uint) _bot->offset_array(_bot->index_for(_space->bottom())));
+         (uint) _bot->offset_array(_bot->index_for(_hr->bottom())));
   size_t index = _bot->index_for(addr);
   // We must make sure that the offset table entry we use is valid.  If
   // "addr" is past the end, start at the last known one and go forward.
   if (has_max_index) {
     index = MIN2(index, max_index);
@@ -132,11 +137,11 @@
   return q;
 }
 
 inline HeapWord* G1BlockOffsetTablePart::forward_to_block_containing_addr_const(HeapWord* q, HeapWord* n,
                                                                                 const void* addr) const {
-  if (addr >= _space->top()) return _space->top();
+  if (addr >= _hr->top()) return _hr->top();
   while (n <= addr) {
     q = n;
     oop obj = oop(q);
     if (obj->klass_or_null_acquire() == NULL) {
       return q;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/heapRegionSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
 26 #define SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
 27 
 28 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 29 
 30 inline void HeapRegionSetBase::add(HeapRegion* hr) {
 31   check_mt_safety();
 32   assert_heap_region_set(hr-&gt;containing_set() == NULL, &quot;should not already have a containing set&quot;);
 33   assert_heap_region_set(hr-&gt;next() == NULL, &quot;should not already be linked&quot;);
 34   assert_heap_region_set(hr-&gt;prev() == NULL, &quot;should not already be linked&quot;);
 35 
 36   _length++;
 37   hr-&gt;set_containing_set(this);
 38   verify_region(hr);
 39 }
 40 
 41 inline void HeapRegionSetBase::remove(HeapRegion* hr) {
 42   check_mt_safety();
 43   verify_region(hr);
 44   assert_heap_region_set(hr-&gt;next() == NULL, &quot;should already be unlinked&quot;);
 45   assert_heap_region_set(hr-&gt;prev() == NULL, &quot;should already be unlinked&quot;);
 46 
 47   hr-&gt;set_containing_set(NULL);
 48   assert_heap_region_set(_length &gt; 0, &quot;pre-condition&quot;);
 49   _length--;
 50 }
 51 
 52 inline void FreeRegionList::add_ordered(HeapRegion* hr) {
 53   assert_free_region_list((length() == 0 &amp;&amp; _head == NULL &amp;&amp; _tail == NULL &amp;&amp; _last == NULL) ||
 54                           (length() &gt;  0 &amp;&amp; _head != NULL &amp;&amp; _tail != NULL),
 55                           &quot;invariant&quot;);
 56   // add() will verify the region and check mt safety.
 57   add(hr);
 58 
 59   // Now link the region
 60   if (_head != NULL) {
 61     HeapRegion* curr;
 62 
 63     if (_last != NULL &amp;&amp; _last-&gt;hrm_index() &lt; hr-&gt;hrm_index()) {
 64       curr = _last;
 65     } else {
 66       curr = _head;
 67     }
 68 
 69     // Find first entry with a Region Index larger than entry to insert.
 70     while (curr != NULL &amp;&amp; curr-&gt;hrm_index() &lt; hr-&gt;hrm_index()) {
 71       curr = curr-&gt;next();
 72     }
 73 
 74     hr-&gt;set_next(curr);
 75 
 76     if (curr == NULL) {
 77       // Adding at the end
 78       hr-&gt;set_prev(_tail);
 79       _tail-&gt;set_next(hr);
 80       _tail = hr;
 81     } else if (curr-&gt;prev() == NULL) {
 82       // Adding at the beginning
 83       hr-&gt;set_prev(NULL);
 84       _head = hr;
 85       curr-&gt;set_prev(hr);
 86     } else {
 87       hr-&gt;set_prev(curr-&gt;prev());
 88       hr-&gt;prev()-&gt;set_next(hr);
 89       curr-&gt;set_prev(hr);
 90     }
 91   } else {
 92     // The list was empty
 93     _tail = hr;
 94     _head = hr;
 95   }
 96   _last = hr;
 97 }
 98 
 99 inline HeapRegion* FreeRegionList::remove_from_head_impl() {
100   HeapRegion* result = _head;
101   _head = result-&gt;next();
102   if (_head == NULL) {
103     _tail = NULL;
104   } else {
105     _head-&gt;set_prev(NULL);
106   }
107   result-&gt;set_next(NULL);
108   return result;
109 }
110 
111 inline HeapRegion* FreeRegionList::remove_from_tail_impl() {
112   HeapRegion* result = _tail;
113 
114   _tail = result-&gt;prev();
115   if (_tail == NULL) {
116     _head = NULL;
117   } else {
118     _tail-&gt;set_next(NULL);
119   }
120   result-&gt;set_prev(NULL);
121   return result;
122 }
123 
124 inline HeapRegion* FreeRegionList::remove_region(bool from_head) {
125   check_mt_safety();
126   verify_optional();
127 
128   if (is_empty()) {
129     return NULL;
130   }
131   assert_free_region_list(length() &gt; 0 &amp;&amp; _head != NULL &amp;&amp; _tail != NULL, &quot;invariant&quot;);
132 
133   HeapRegion* hr;
134 
135   if (from_head) {
136     hr = remove_from_head_impl();
137   } else {
138     hr = remove_from_tail_impl();
139   }
140 
141   if (_last == hr) {
142     _last = NULL;
143   }
144 
145   // remove() will verify the region and check mt safety.
146   remove(hr);
147   return hr;
148 }
149 
150 #endif // SHARE_GC_G1_HEAPREGIONSET_INLINE_HPP
    </pre>
  </body>
</html>
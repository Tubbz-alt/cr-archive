<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1VMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1SurvivorRegions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1VMOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1VMOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,56 ***</span>
  #include &quot;gc/g1/g1VMOperations.hpp&quot;
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  
  void VM_G1CollectFull::doit() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    GCCauseSetter x(g1h, _gc_cause);
    _gc_succeeded = g1h-&gt;do_full_collection(true /* explicit_gc */, false /* clear_all_soft_refs */);
  }
  
  VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,
                                                       uint           gc_count_before,
                                                       GCCause::Cause gc_cause,
<span class="line-removed">-                                                      bool           should_initiate_conc_mark,</span>
                                                       double         target_pause_time_ms) :
    VM_CollectForAllocation(word_size, gc_count_before, gc_cause),
    _gc_succeeded(false),
<span class="line-modified">!   _should_initiate_conc_mark(should_initiate_conc_mark),</span>
<span class="line-removed">-   _should_retry_gc(false),</span>
<span class="line-removed">-   _target_pause_time_ms(target_pause_time_ms),</span>
<span class="line-removed">-   _old_marking_cycles_completed_before(0) {</span>
  
    guarantee(target_pause_time_ms &gt; 0.0,
              &quot;target_pause_time_ms = %1.6lf should be positive&quot;,
              target_pause_time_ms);
    _gc_cause = gc_cause;
  }
  
<span class="line-removed">- bool VM_G1CollectForAllocation::doit_prologue() {</span>
<span class="line-removed">-   bool res = VM_CollectForAllocation::doit_prologue();</span>
<span class="line-removed">-   if (!res) {</span>
<span class="line-removed">-     if (_should_initiate_conc_mark) {</span>
<span class="line-removed">-       // The prologue can fail for a couple of reasons. The first is that another GC</span>
<span class="line-removed">-       // got scheduled and prevented the scheduling of the initial mark GC. The</span>
<span class="line-removed">-       // second is that the GC locker may be active and the heap can&#39;t be expanded.</span>
<span class="line-removed">-       // In both cases we want to retry the GC so that the initial mark pause is</span>
<span class="line-removed">-       // actually scheduled. In the second case, however, we should stall until</span>
<span class="line-removed">-       // until the GC locker is no longer active and then retry the initial mark GC.</span>
<span class="line-removed">-       _should_retry_gc = true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return res;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void VM_G1CollectForAllocation::doit() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
<span class="line-removed">-   assert(!_should_initiate_conc_mark || g1h-&gt;should_do_concurrent_full_gc(_gc_cause),</span>
<span class="line-removed">-       &quot;only a GC locker, a System.gc(), stats update, whitebox, or a hum allocation induced GC should start a cycle&quot;);</span>
  
    if (_word_size &gt; 0) {
      // An allocation has been requested. So, try to do that first.
      _result = g1h-&gt;attempt_allocation_at_safepoint(_word_size,
                                                     false /* expect_null_cur_alloc_region */);
<span class="line-new-header">--- 29,88 ---</span>
  #include &quot;gc/g1/g1VMOperations.hpp&quot;
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/isGCActiveMark.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  
  void VM_G1CollectFull::doit() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
    GCCauseSetter x(g1h, _gc_cause);
    _gc_succeeded = g1h-&gt;do_full_collection(true /* explicit_gc */, false /* clear_all_soft_refs */);
  }
  
<span class="line-added">+ VM_G1TryInitiateConcMark::VM_G1TryInitiateConcMark(uint gc_count_before,</span>
<span class="line-added">+                                                    GCCause::Cause gc_cause,</span>
<span class="line-added">+                                                    double target_pause_time_ms) :</span>
<span class="line-added">+   VM_GC_Operation(gc_count_before, gc_cause),</span>
<span class="line-added">+   _target_pause_time_ms(target_pause_time_ms),</span>
<span class="line-added">+   _transient_failure(false),</span>
<span class="line-added">+   _cycle_already_in_progress(false),</span>
<span class="line-added">+   _terminating(false),</span>
<span class="line-added">+   _gc_succeeded(false)</span>
<span class="line-added">+ {}</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool VM_G1TryInitiateConcMark::doit_prologue() {</span>
<span class="line-added">+   bool result = VM_GC_Operation::doit_prologue();</span>
<span class="line-added">+   // The prologue can fail for a couple of reasons. The first is that another GC</span>
<span class="line-added">+   // got scheduled and prevented the scheduling of the initial mark GC. The</span>
<span class="line-added">+   // second is that the GC locker may be active and the heap can&#39;t be expanded.</span>
<span class="line-added">+   // In both cases we want to retry the GC so that the initial mark pause is</span>
<span class="line-added">+   // actually scheduled. In the second case, however, we should stall until</span>
<span class="line-added">+   // until the GC locker is no longer active and then retry the initial mark GC.</span>
<span class="line-added">+   if (!result) _transient_failure = true;</span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void VM_G1TryInitiateConcMark::doit() {</span>
<span class="line-added">+   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-added">+ </span>
<span class="line-added">+   GCCauseSetter x(g1h, _gc_cause);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Record for handling by caller.</span>
<span class="line-added">+   _terminating = g1h-&gt;_cm_thread-&gt;should_terminate();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_terminating &amp;&amp; GCCause::is_user_requested_gc(_gc_cause)) {</span>
<span class="line-added">+     // When terminating, the request to initiate a concurrent cycle will be</span>
<span class="line-added">+     // ignored by do_collection_pause_at_safepoint; instead it will just do</span>
<span class="line-added">+     // a young-only or mixed GC (depending on phase).  For a user request</span>
<span class="line-added">+     // there&#39;s no point in even doing that much, so done.  For some non-user</span>
<span class="line-added">+     // requests the alternative GC might still be needed.</span>
<span class="line-added">+   } else if (!g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause)) {</span>
<span class="line-added">+     // Failure to force the next GC pause to be an initial mark indicates</span>
<span class="line-added">+     // there is already a concurrent marking cycle in progress.  Set flag</span>
<span class="line-added">+     // to notify the caller and return immediately.</span>
<span class="line-added">+     _cycle_already_in_progress = true;</span>
<span class="line-added">+   } else if (g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms)) {</span>
<span class="line-added">+     _gc_succeeded = true;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Failure to perform the collection at all occurs because GCLocker is</span>
<span class="line-added">+     // active, and we have the bad luck to be the collection request that</span>
<span class="line-added">+     // makes a later _gc_locker collection needed.  (Else we would have hit</span>
<span class="line-added">+     // the GCLocker check in the prologue.)</span>
<span class="line-added">+     _transient_failure = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,
                                                       uint           gc_count_before,
                                                       GCCause::Cause gc_cause,
                                                       double         target_pause_time_ms) :
    VM_CollectForAllocation(word_size, gc_count_before, gc_cause),
    _gc_succeeded(false),
<span class="line-modified">!   _target_pause_time_ms(target_pause_time_ms) {</span>
  
    guarantee(target_pause_time_ms &gt; 0.0,
              &quot;target_pause_time_ms = %1.6lf should be positive&quot;,
              target_pause_time_ms);
    _gc_cause = gc_cause;
  }
  
  void VM_G1CollectForAllocation::doit() {
    G1CollectedHeap* g1h = G1CollectedHeap::heap();
  
    if (_word_size &gt; 0) {
      // An allocation has been requested. So, try to do that first.
      _result = g1h-&gt;attempt_allocation_at_safepoint(_word_size,
                                                     false /* expect_null_cur_alloc_region */);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,116 ***</span>
        return;
      }
    }
  
    GCCauseSetter x(g1h, _gc_cause);
<span class="line-removed">-   if (_should_initiate_conc_mark) {</span>
<span class="line-removed">-     // It&#39;s safer to read old_marking_cycles_completed() here, given</span>
<span class="line-removed">-     // that noone else will be updating it concurrently. Since we&#39;ll</span>
<span class="line-removed">-     // only need it if we&#39;re initiating a marking cycle, no point in</span>
<span class="line-removed">-     // setting it earlier.</span>
<span class="line-removed">-     _old_marking_cycles_completed_before = g1h-&gt;old_marking_cycles_completed();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // At this point we are supposed to start a concurrent cycle. We</span>
<span class="line-removed">-     // will do so if one is not already in progress.</span>
<span class="line-removed">-     bool res = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The above routine returns true if we were able to force the</span>
<span class="line-removed">-     // next GC pause to be an initial mark; it returns false if a</span>
<span class="line-removed">-     // marking cycle is already in progress.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // If a marking cycle is already in progress just return and skip the</span>
<span class="line-removed">-     // pause below - if the reason for requesting this initial mark pause</span>
<span class="line-removed">-     // was due to a System.gc() then the requesting thread should block in</span>
<span class="line-removed">-     // doit_epilogue() until the marking cycle is complete.</span>
<span class="line-removed">-     //</span>
<span class="line-removed">-     // If this initial mark pause was requested as part of a humongous</span>
<span class="line-removed">-     // allocation then we know that the marking cycle must just have</span>
<span class="line-removed">-     // been started by another thread (possibly also allocating a humongous</span>
<span class="line-removed">-     // object) as there was no active marking cycle when the requesting</span>
<span class="line-removed">-     // thread checked before calling collect() in</span>
<span class="line-removed">-     // attempt_allocation_humongous(). Retrying the GC, in this case,</span>
<span class="line-removed">-     // will cause the requesting thread to spin inside collect() until the</span>
<span class="line-removed">-     // just started marking cycle is complete - which may be a while. So</span>
<span class="line-removed">-     // we do NOT retry the GC.</span>
<span class="line-removed">-     if (!res) {</span>
<span class="line-removed">-       assert(_word_size == 0, &quot;Concurrent Full GC/Humongous Object IM shouldn&#39;t be allocating&quot;);</span>
<span class="line-removed">-       if (_gc_cause != GCCause::_g1_humongous_allocation) {</span>
<span class="line-removed">-         _should_retry_gc = true;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Try a partial collection of some kind.
    _gc_succeeded = g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms);
  
<span class="line-modified">!   if (_gc_succeeded) {</span>
<span class="line-modified">!     if (_word_size &gt; 0) {</span>
<span class="line-modified">!       // An allocation had been requested. Do it, eventually trying a stronger</span>
<span class="line-modified">!       // kind of GC.</span>
<span class="line-removed">-       _result = g1h-&gt;satisfy_failed_allocation(_word_size, &amp;_gc_succeeded);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       bool should_upgrade_to_full = g1h-&gt;should_upgrade_to_full_gc(_gc_cause);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (should_upgrade_to_full) {</span>
<span class="line-removed">-         // There has been a request to perform a GC to free some space. We have no</span>
<span class="line-removed">-         // information on how much memory has been asked for. In case there are</span>
<span class="line-removed">-         // absolutely no regions left to allocate into, do a maximally compacting full GC.</span>
<span class="line-removed">-         log_info(gc, ergo)(&quot;Attempting maximally compacting collection&quot;);</span>
<span class="line-removed">-         _gc_succeeded = g1h-&gt;do_full_collection(false, /* explicit gc */</span>
<span class="line-removed">-                                                    true   /* clear_all_soft_refs */);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     guarantee(_gc_succeeded, &quot;Elevated collections during the safepoint must always succeed.&quot;);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(_result == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-     // The only reason for the pause to not be successful is that, the GC locker is</span>
<span class="line-removed">-     // active (or has become active since the prologue was executed). In this case</span>
<span class="line-removed">-     // we should retry the pause after waiting for the GC locker to become inactive.</span>
<span class="line-removed">-     _should_retry_gc = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void VM_G1CollectForAllocation::doit_epilogue() {</span>
<span class="line-removed">-   VM_CollectForAllocation::doit_epilogue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // If the pause was initiated by a System.gc() and</span>
<span class="line-removed">-   // +ExplicitGCInvokesConcurrent, we have to wait here for the cycle</span>
<span class="line-removed">-   // that just started (or maybe one that was already in progress) to</span>
<span class="line-removed">-   // finish.</span>
<span class="line-removed">-   if (GCCause::is_user_requested_gc(_gc_cause) &amp;&amp;</span>
<span class="line-removed">-       _should_initiate_conc_mark) {</span>
<span class="line-removed">-     assert(ExplicitGCInvokesConcurrent,</span>
<span class="line-removed">-            &quot;the only way to be here is if ExplicitGCInvokesConcurrent is set&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // In the doit() method we saved g1h-&gt;old_marking_cycles_completed()</span>
<span class="line-removed">-     // in the _old_marking_cycles_completed_before field. We have to</span>
<span class="line-removed">-     // wait until we observe that g1h-&gt;old_marking_cycles_completed()</span>
<span class="line-removed">-     // has increased by at least one. This can happen if a) we started</span>
<span class="line-removed">-     // a cycle and it completes, b) a cycle already in progress</span>
<span class="line-removed">-     // completes, or c) a Full GC happens.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the condition has already been reached, there&#39;s no point in</span>
<span class="line-removed">-     // actually taking the lock and doing the wait.</span>
<span class="line-removed">-     if (g1h-&gt;old_marking_cycles_completed() &lt;=</span>
<span class="line-removed">-                                           _old_marking_cycles_completed_before) {</span>
<span class="line-removed">-       // The following is largely copied from CMS</span>
<span class="line-removed">- </span>
<span class="line-removed">-       Thread* thr = Thread::current();</span>
<span class="line-removed">-       assert(thr-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">-       JavaThread* jt = (JavaThread*)thr;</span>
<span class="line-removed">-       ThreadToNativeFromVM native(jt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       MutexLockerEx x(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-       while (g1h-&gt;old_marking_cycles_completed() &lt;=</span>
<span class="line-removed">-                                           _old_marking_cycles_completed_before) {</span>
<span class="line-removed">-         FullGCCount_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
  }
  
  void VM_G1Concurrent::doit() {
    GCIdMark gc_id_mark(_gc_id);
<span class="line-new-header">--- 121,17 ---</span>
        return;
      }
    }
  
    GCCauseSetter x(g1h, _gc_cause);
    // Try a partial collection of some kind.
    _gc_succeeded = g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms);
  
<span class="line-modified">!   if (_gc_succeeded &amp;&amp; (_word_size &gt; 0)) {</span>
<span class="line-modified">!     // An allocation had been requested. Do it, eventually trying a stronger</span>
<span class="line-modified">!     // kind of GC.</span>
<span class="line-modified">!     _result = g1h-&gt;satisfy_failed_allocation(_word_size, &amp;_gc_succeeded);</span>
    }
  }
  
  void VM_G1Concurrent::doit() {
    GCIdMark gc_id_mark(_gc_id);
</pre>
<center><a href="g1SurvivorRegions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1VMOperations.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMarkThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,10 +27,11 @@</span>
  #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;
  #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  #include &quot;utilities/pair.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,15 +70,11 @@</span>
  jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint num_max_threads) {
    assert(cr != NULL, &quot;G1ConcurrentRefine must not be NULL&quot;);
    _cr = cr;
    _num_max_threads = num_max_threads;
  
<span class="udiff-line-modified-removed">-   _threads = NEW_C_HEAP_ARRAY_RETURN_NULL(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>
<span class="udiff-line-removed">-   if (_threads == NULL) {</span>
<span class="udiff-line-removed">-     vm_shutdown_during_initialization(&quot;Could not allocate thread holder array.&quot;);</span>
<span class="udiff-line-removed">-     return JNI_ENOMEM;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>
  
    for (uint i = 0; i &lt; num_max_threads; i++) {
      if (UseDynamicNumberOfGCThreads &amp;&amp; i != 0 /* Always start first thread. */) {
        _threads[i] = NULL;
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,10 +83,15 @@</span>
          vm_shutdown_during_initialization(&quot;Could not allocate refinement threads.&quot;);
          return JNI_ENOMEM;
        }
      }
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (num_max_threads &gt; 0) {</span>
<span class="udiff-line-added">+     G1BarrierSet::dirty_card_queue_set().set_primary_refinement_thread(_threads[0]);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    return JNI_OK;
  }
  
  void G1ConcurrentRefineThreadControl::maybe_activate_next(uint cur_worker_id) {
    assert(cur_worker_id &lt; _num_max_threads,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,11 +107,11 @@</span>
    if (thread_to_activate == NULL) {
      // Still need to create the thread...
      _threads[worker_id] = create_refinement_thread(worker_id, false);
      thread_to_activate = _threads[worker_id];
    }
<span class="udiff-line-modified-removed">-   if (thread_to_activate != NULL &amp;&amp; !thread_to_activate-&gt;is_active()) {</span>
<span class="udiff-line-modified-added">+   if (thread_to_activate != NULL) {</span>
      thread_to_activate-&gt;activate();
    }
  }
  
  void G1ConcurrentRefineThreadControl::print_on(outputStream* st) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,11 +145,11 @@</span>
  // without needing to check for overflow in &quot;x OP y&quot;, because the
  // ranges for x and y have been restricted.
  STATIC_ASSERT(sizeof(LP64_ONLY(jint) NOT_LP64(jshort)) &lt;= (sizeof(size_t)/2));
  const size_t max_yellow_zone = LP64_ONLY(max_jint) NOT_LP64(max_jshort);
  const size_t max_green_zone = max_yellow_zone / 2;
<span class="udiff-line-modified-removed">- const size_t max_red_zone = INT_MAX; // For dcqs.set_max_completed_buffers.</span>
<span class="udiff-line-modified-added">+ const size_t max_red_zone = INT_MAX; // For dcqs.set_max_cards.</span>
  STATIC_ASSERT(max_yellow_zone &lt;= max_red_zone);
  
  // Range check assertions for green zone values.
  #define assert_zone_constraints_g(green)                        \
    do {                                                          \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,32 +189,37 @@</span>
  #define CTRL_TAGS gc, ergo, refine
  
  // For logging zone values, ensuring consistency of level and tags.
  #define LOG_ZONES(...) log_debug( CTRL_TAGS )(__VA_ARGS__)
  
<span class="udiff-line-added">+ static size_t buffers_to_cards(size_t value) {</span>
<span class="udiff-line-added">+   return value * G1UpdateBufferSize;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Package for pair of refinement thread activation and deactivation
  // thresholds.  The activation and deactivation levels are resp. the first
  // and second values of the pair.
  typedef Pair&lt;size_t, size_t&gt; Thresholds;
  inline size_t activation_level(const Thresholds&amp; t) { return t.first; }
  inline size_t deactivation_level(const Thresholds&amp; t) { return t.second; }
  
  static Thresholds calc_thresholds(size_t green_zone,
                                    size_t yellow_zone,
<span class="udiff-line-modified-removed">-                                   uint worker_i) {</span>
<span class="udiff-line-modified-added">+                                   uint worker_id) {</span>
    double yellow_size = yellow_zone - green_zone;
    double step = yellow_size / G1ConcurrentRefine::max_num_threads();
<span class="udiff-line-modified-removed">-   if (worker_i == 0) {</span>
<span class="udiff-line-modified-added">+   if (worker_id == 0) {</span>
      // Potentially activate worker 0 more aggressively, to keep
      // available buffers near green_zone value.  When yellow_size is
      // large we don&#39;t want to allow a full step to accumulate before
      // doing any processing, as that might lead to significantly more
<span class="udiff-line-modified-removed">-     // than green_zone buffers to be processed by update_rs.</span>
<span class="udiff-line-modified-removed">-     step = MIN2(step, ParallelGCThreads / 2.0);</span>
<span class="udiff-line-modified-added">+     // than green_zone buffers to be processed during pause.  So limit</span>
<span class="udiff-line-modified-added">+     // to an extra half buffer per pause-time processing thread.</span>
<span class="udiff-line-added">+     step = MIN2(step, buffers_to_cards(ParallelGCThreads) / 2.0);</span>
    }
<span class="udiff-line-modified-removed">-   size_t activate_offset = static_cast&lt;size_t&gt;(ceil(step * (worker_i + 1)));</span>
<span class="udiff-line-modified-removed">-   size_t deactivate_offset = static_cast&lt;size_t&gt;(floor(step * worker_i));</span>
<span class="udiff-line-modified-added">+   size_t activate_offset = static_cast&lt;size_t&gt;(ceil(step * (worker_id + 1)));</span>
<span class="udiff-line-modified-added">+   size_t deactivate_offset = static_cast&lt;size_t&gt;(floor(step * worker_id));</span>
    return Thresholds(green_zone + activate_offset,
                      green_zone + deactivate_offset);
  }
  
  G1ConcurrentRefine::G1ConcurrentRefine(size_t green_zone,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -231,11 +238,11 @@</span>
  jint G1ConcurrentRefine::initialize() {
    return _thread_control.initialize(this, max_num_threads());
  }
  
  static size_t calc_min_yellow_zone_size() {
<span class="udiff-line-modified-removed">-   size_t step = G1ConcRefinementThresholdStep;</span>
<span class="udiff-line-modified-added">+   size_t step = buffers_to_cards(G1ConcRefinementThresholdStep);</span>
    uint n_workers = G1ConcurrentRefine::max_num_threads();
    if ((max_yellow_zone / step) &lt; n_workers) {
      return max_yellow_zone;
    } else {
      return step * n_workers;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,15 +252,16 @@</span>
  static size_t calc_init_green_zone() {
    size_t green = G1ConcRefinementGreenZone;
    if (FLAG_IS_DEFAULT(G1ConcRefinementGreenZone)) {
      green = ParallelGCThreads;
    }
<span class="udiff-line-added">+   green = buffers_to_cards(green);</span>
    return MIN2(green, max_green_zone);
  }
  
  static size_t calc_init_yellow_zone(size_t green, size_t min_size) {
<span class="udiff-line-modified-removed">-   size_t config = G1ConcRefinementYellowZone;</span>
<span class="udiff-line-modified-added">+   size_t config = buffers_to_cards(G1ConcRefinementYellowZone);</span>
    size_t size = 0;
    if (FLAG_IS_DEFAULT(G1ConcRefinementYellowZone)) {
      size = green * 2;
    } else if (green &lt; config) {
      size = config - green;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -264,11 +272,11 @@</span>
  }
  
  static size_t calc_init_red_zone(size_t green, size_t yellow) {
    size_t size = yellow - green;
    if (!FLAG_IS_DEFAULT(G1ConcRefinementRedZone)) {
<span class="udiff-line-modified-removed">-     size_t config = G1ConcRefinementRedZone;</span>
<span class="udiff-line-modified-added">+     size_t config = buffers_to_cards(G1ConcRefinementRedZone);</span>
      if (yellow &lt; config) {
        size = MAX2(size, config - yellow);
      }
    }
    return MIN2(yellow + size, max_red_zone);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -289,17 +297,10 @@</span>
  
    G1ConcurrentRefine* cr = new G1ConcurrentRefine(green_zone,
                                                    yellow_zone,
                                                    red_zone,
                                                    min_yellow_zone_size);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (cr == NULL) {</span>
<span class="udiff-line-removed">-     *ecode = JNI_ENOMEM;</span>
<span class="udiff-line-removed">-     vm_shutdown_during_initialization(&quot;Could not create G1ConcurrentRefine&quot;);</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    *ecode = cr-&gt;initialize();
    return cr;
  }
  
  void G1ConcurrentRefine::stop() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,22 +321,22 @@</span>
  void G1ConcurrentRefine::print_threads_on(outputStream* st) const {
    _thread_control.print_on(st);
  }
  
  static size_t calc_new_green_zone(size_t green,
<span class="udiff-line-modified-removed">-                                   double update_rs_time,</span>
<span class="udiff-line-modified-removed">-                                   size_t update_rs_processed_buffers,</span>
<span class="udiff-line-modified-added">+                                   double logged_cards_scan_time,</span>
<span class="udiff-line-modified-added">+                                   size_t processed_logged_cards,</span>
                                    double goal_ms) {
    // Adjust green zone based on whether we&#39;re meeting the time goal.
    // Limit to max_green_zone.
    const double inc_k = 1.1, dec_k = 0.9;
<span class="udiff-line-modified-removed">-   if (update_rs_time &gt; goal_ms) {</span>
<span class="udiff-line-modified-added">+   if (logged_cards_scan_time &gt; goal_ms) {</span>
      if (green &gt; 0) {
        green = static_cast&lt;size_t&gt;(green * dec_k);
      }
<span class="udiff-line-modified-removed">-   } else if (update_rs_time &lt; goal_ms &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              update_rs_processed_buffers &gt; green) {</span>
<span class="udiff-line-modified-added">+   } else if (logged_cards_scan_time &lt; goal_ms &amp;&amp;</span>
<span class="udiff-line-modified-added">+              processed_logged_cards &gt; green) {</span>
      green = static_cast&lt;size_t&gt;(MAX2(green * inc_k, green + 1.0));
      green = MIN2(green, max_green_zone);
    }
    return green;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,24 +349,24 @@</span>
  
  static size_t calc_new_red_zone(size_t green, size_t yellow) {
    return MIN2(yellow + (yellow - green), max_red_zone);
  }
  
<span class="udiff-line-modified-removed">- void G1ConcurrentRefine::update_zones(double update_rs_time,</span>
<span class="udiff-line-modified-removed">-                                       size_t update_rs_processed_buffers,</span>
<span class="udiff-line-modified-added">+ void G1ConcurrentRefine::update_zones(double logged_cards_scan_time,</span>
<span class="udiff-line-modified-added">+                                       size_t processed_logged_cards,</span>
                                        double goal_ms) {
    log_trace( CTRL_TAGS )(&quot;Updating Refinement Zones: &quot;
<span class="udiff-line-modified-removed">-                          &quot;update_rs time: %.3fms, &quot;</span>
<span class="udiff-line-modified-removed">-                          &quot;update_rs buffers: &quot; SIZE_FORMAT &quot;, &quot;</span>
<span class="udiff-line-modified-removed">-                          &quot;update_rs goal time: %.3fms&quot;,</span>
<span class="udiff-line-modified-removed">-                          update_rs_time,</span>
<span class="udiff-line-modified-removed">-                          update_rs_processed_buffers,</span>
<span class="udiff-line-modified-added">+                          &quot;logged cards scan time: %.3fms, &quot;</span>
<span class="udiff-line-modified-added">+                          &quot;processed cards: &quot; SIZE_FORMAT &quot;, &quot;</span>
<span class="udiff-line-modified-added">+                          &quot;goal time: %.3fms&quot;,</span>
<span class="udiff-line-modified-added">+                          logged_cards_scan_time,</span>
<span class="udiff-line-modified-added">+                          processed_logged_cards,</span>
                           goal_ms);
  
    _green_zone = calc_new_green_zone(_green_zone,
<span class="udiff-line-modified-removed">-                                     update_rs_time,</span>
<span class="udiff-line-modified-removed">-                                     update_rs_processed_buffers,</span>
<span class="udiff-line-modified-added">+                                     logged_cards_scan_time,</span>
<span class="udiff-line-modified-added">+                                     processed_logged_cards,</span>
                                      goal_ms);
    _yellow_zone = calc_new_yellow_zone(_green_zone, _min_yellow_zone_size);
    _red_zone = calc_new_red_zone(_green_zone, _yellow_zone);
  
    assert_zone_constraints_gyr(_green_zone, _yellow_zone, _red_zone);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -374,41 +375,57 @@</span>
              &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
              &quot;red: &quot; SIZE_FORMAT,
              _green_zone, _yellow_zone, _red_zone);
  }
  
<span class="udiff-line-modified-removed">- void G1ConcurrentRefine::adjust(double update_rs_time,</span>
<span class="udiff-line-modified-removed">-                                 size_t update_rs_processed_buffers,</span>
<span class="udiff-line-modified-added">+ void G1ConcurrentRefine::adjust(double logged_cards_scan_time,</span>
<span class="udiff-line-modified-added">+                                 size_t processed_logged_cards,</span>
                                  double goal_ms) {
    G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
  
    if (G1UseAdaptiveConcRefinement) {
<span class="udiff-line-modified-removed">-     update_zones(update_rs_time, update_rs_processed_buffers, goal_ms);</span>
<span class="udiff-line-modified-added">+     update_zones(logged_cards_scan_time, processed_logged_cards, goal_ms);</span>
  
      // Change the barrier params
      if (max_num_threads() == 0) {
        // Disable dcqs notification when there are no threads to notify.
<span class="udiff-line-modified-removed">-       dcqs.set_process_completed_buffers_threshold(G1DirtyCardQueueSet::ProcessCompletedBuffersThresholdNever);</span>
<span class="udiff-line-modified-added">+       dcqs.set_process_cards_threshold(G1DirtyCardQueueSet::ProcessCardsThresholdNever);</span>
      } else {
        // Worker 0 is the primary; wakeup is via dcqs notification.
        STATIC_ASSERT(max_yellow_zone &lt;= INT_MAX);
        size_t activate = activation_threshold(0);
<span class="udiff-line-modified-removed">-       dcqs.set_process_completed_buffers_threshold(activate);</span>
<span class="udiff-line-modified-added">+       dcqs.set_process_cards_threshold(activate);</span>
      }
<span class="udiff-line-modified-removed">-     dcqs.set_max_completed_buffers(red_zone());</span>
<span class="udiff-line-modified-added">+     dcqs.set_max_cards(red_zone());</span>
    }
  
<span class="udiff-line-modified-removed">-   size_t curr_queue_size = dcqs.completed_buffers_num();</span>
<span class="udiff-line-modified-removed">-   if ((dcqs.max_completed_buffers() &gt; 0) &amp;&amp;</span>
<span class="udiff-line-modified-added">+   size_t curr_queue_size = dcqs.num_cards();</span>
<span class="udiff-line-modified-added">+   if ((dcqs.max_cards() &gt; 0) &amp;&amp;</span>
        (curr_queue_size &gt;= yellow_zone())) {
<span class="udiff-line-modified-removed">-     dcqs.set_completed_buffers_padding(curr_queue_size);</span>
<span class="udiff-line-modified-added">+     dcqs.set_max_cards_padding(curr_queue_size);</span>
    } else {
<span class="udiff-line-modified-removed">-     dcqs.set_completed_buffers_padding(0);</span>
<span class="udiff-line-modified-added">+     dcqs.set_max_cards_padding(0);</span>
    }
    dcqs.notify_if_necessary();
  }
  
<span class="udiff-line-added">+ G1ConcurrentRefine::RefinementStats G1ConcurrentRefine::total_refinement_stats() const {</span>
<span class="udiff-line-added">+   struct CollectData : public ThreadClosure {</span>
<span class="udiff-line-added">+     Tickspan _total_time;</span>
<span class="udiff-line-added">+     size_t _total_cards;</span>
<span class="udiff-line-added">+     CollectData() : _total_time(), _total_cards(0) {}</span>
<span class="udiff-line-added">+     virtual void do_thread(Thread* t) {</span>
<span class="udiff-line-added">+       G1ConcurrentRefineThread* crt = static_cast&lt;G1ConcurrentRefineThread*&gt;(t);</span>
<span class="udiff-line-added">+       _total_time += crt-&gt;total_refinement_time();</span>
<span class="udiff-line-added">+       _total_cards += crt-&gt;total_refined_cards();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } collector;</span>
<span class="udiff-line-added">+   // Cast away const so we can call non-modifying closure on threads.</span>
<span class="udiff-line-added">+   const_cast&lt;G1ConcurrentRefine*&gt;(this)-&gt;threads_do(&amp;collector);</span>
<span class="udiff-line-added">+   return RefinementStats(collector._total_time, collector._total_cards);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  size_t G1ConcurrentRefine::activation_threshold(uint worker_id) const {
    Thresholds thresholds = calc_thresholds(_green_zone, _yellow_zone, worker_id);
    return activation_level(thresholds);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -419,29 +436,31 @@</span>
  
  uint G1ConcurrentRefine::worker_id_offset() {
    return G1DirtyCardQueueSet::num_par_ids();
  }
  
<span class="udiff-line-modified-removed">- void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers) {</span>
<span class="udiff-line-modified-removed">-   if (num_cur_buffers &gt; activation_threshold(worker_id + 1)) {</span>
<span class="udiff-line-modified-added">+ void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {</span>
<span class="udiff-line-modified-added">+   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {</span>
      _thread_control.maybe_activate_next(worker_id);
    }
  }
  
<span class="udiff-line-modified-removed">- bool G1ConcurrentRefine::do_refinement_step(uint worker_id) {</span>
<span class="udiff-line-modified-added">+ bool G1ConcurrentRefine::do_refinement_step(uint worker_id,</span>
<span class="udiff-line-added">+                                             size_t* total_refined_cards) {</span>
    G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
  
<span class="udiff-line-modified-removed">-   size_t curr_buffer_num = dcqs.completed_buffers_num();</span>
<span class="udiff-line-modified-removed">-   // If the number of the buffers falls down into the yellow zone,</span>
<span class="udiff-line-modified-added">+   size_t curr_cards = dcqs.num_cards();</span>
<span class="udiff-line-modified-added">+   // If the number of the cards falls down into the yellow zone,</span>
    // that means that the transition period after the evacuation pause has ended.
    // Since the value written to the DCQS is the same for all threads, there is no
    // need to synchronize.
<span class="udiff-line-modified-removed">-   if (dcqs.completed_buffers_padding() &gt; 0 &amp;&amp; curr_buffer_num &lt;= yellow_zone()) {</span>
<span class="udiff-line-modified-removed">-     dcqs.set_completed_buffers_padding(0);</span>
<span class="udiff-line-modified-added">+   if (dcqs.max_cards_padding() &gt; 0 &amp;&amp; curr_cards &lt;= yellow_zone()) {</span>
<span class="udiff-line-modified-added">+     dcqs.set_max_cards_padding(0);</span>
    }
  
<span class="udiff-line-modified-removed">-   maybe_activate_more_threads(worker_id, curr_buffer_num);</span>
<span class="udiff-line-modified-added">+   maybe_activate_more_threads(worker_id, curr_cards);</span>
  
    // Process the next buffer, if there are enough left.
    return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
<span class="udiff-line-modified-removed">-                                                    deactivation_threshold(worker_id));</span>
<span class="udiff-line-modified-added">+                                                    deactivation_threshold(worker_id),</span>
<span class="udiff-line-added">+                                                    total_refined_cards);</span>
  }
</pre>
<center><a href="g1ConcurrentMarkThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefine.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
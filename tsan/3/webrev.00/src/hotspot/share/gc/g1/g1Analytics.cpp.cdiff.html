<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1Analytics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Allocator.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Analytics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,12 ***</span>
<span class="line-new-header">--- 23,14 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1Analytics.hpp&quot;
  #include &quot;gc/g1/g1Predictions.hpp&quot;
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  #include &quot;utilities/numberSeq.hpp&quot;
  
  // Different defaults for different number of GC threads
  // They were chosen by running GCOld and SPECjbb on debris with different
  //   numbers of GC threads and choosing them based on the results
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,20 ***</span>
  // all the same
  static double rs_length_diff_defaults[] = {
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
  };
  
<span class="line-modified">! static double cost_per_card_ms_defaults[] = {</span>
    0.01, 0.005, 0.005, 0.003, 0.003, 0.002, 0.002, 0.0015
  };
  
  // all the same
<span class="line-modified">! static double young_cards_per_entry_ratio_defaults[] = {</span>
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
  };
  
<span class="line-modified">! static double cost_per_entry_ms_defaults[] = {</span>
    0.015, 0.01, 0.01, 0.008, 0.008, 0.0055, 0.0055, 0.005
  };
  
  static double cost_per_byte_ms_defaults[] = {
    0.00006, 0.00003, 0.00003, 0.000015, 0.000015, 0.00001, 0.00001, 0.000009
<span class="line-new-header">--- 38,20 ---</span>
  // all the same
  static double rs_length_diff_defaults[] = {
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
  };
  
<span class="line-modified">! static double cost_per_logged_card_ms_defaults[] = {</span>
    0.01, 0.005, 0.005, 0.003, 0.003, 0.002, 0.002, 0.0015
  };
  
  // all the same
<span class="line-modified">! static double young_card_merge_to_scan_ratio_defaults[] = {</span>
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
  };
  
<span class="line-modified">! static double young_only_cost_per_card_scan_ms_defaults[] = {</span>
    0.015, 0.01, 0.01, 0.008, 0.008, 0.0055, 0.0055, 0.005
  };
  
  static double cost_per_byte_ms_defaults[] = {
    0.00006, 0.00003, 0.00003, 0.000015, 0.000015, 0.00001, 0.00001, 0.000009
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,11 ***</span>
  // these should be pretty consistent
  static double constant_other_time_ms_defaults[] = {
    5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0
  };
  
<span class="line-removed">- </span>
  static double young_other_cost_per_region_ms_defaults[] = {
    0.3, 0.2, 0.2, 0.15, 0.15, 0.12, 0.12, 0.1
  };
  
  static double non_young_other_cost_per_region_ms_defaults[] = {
<span class="line-new-header">--- 60,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,22 ***</span>
      _concurrent_mark_remark_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _concurrent_mark_cleanup_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _alloc_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _prev_collection_pause_end_ms(0.0),
      _rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified">!     _cost_per_card_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _cost_scan_hcc_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _young_cards_per_entry_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _mixed_cards_per_entry_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _cost_per_entry_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _mixed_cost_per_entry_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _cost_per_byte_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
      _constant_other_time_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _non_young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified">!     _rs_lengths_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
      _cost_per_byte_ms_during_cm_seq(new TruncatedSeq(TruncatedSeqLength)),
      _recent_prev_end_times_for_all_gcs_sec(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _recent_avg_pause_time_ratio(0.0),
      _last_pause_time_ratio(0.0) {
  
<span class="line-new-header">--- 76,24 ---</span>
      _concurrent_mark_remark_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _concurrent_mark_cleanup_times_ms(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _alloc_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _prev_collection_pause_end_ms(0.0),
      _rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified">!     _concurrent_refine_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _logged_cards_rate_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _young_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _mixed_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _young_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _mixed_cost_per_card_scan_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-modified">!     _young_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-added">+     _mixed_cost_per_card_merge_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
<span class="line-added">+     _copy_cost_per_byte_ms_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
      _constant_other_time_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _non_young_other_cost_per_region_ms_seq(new TruncatedSeq(TruncatedSeqLength)),
      _pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),
<span class="line-modified">!     _rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),</span>
      _cost_per_byte_ms_during_cm_seq(new TruncatedSeq(TruncatedSeqLength)),
      _recent_prev_end_times_for_all_gcs_sec(new TruncatedSeq(NumPrevPausesForHeuristics)),
      _recent_avg_pause_time_ratio(0.0),
      _last_pause_time_ratio(0.0) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,30 ***</span>
    _prev_collection_pause_end_ms = os::elapsedTime() * 1000.0;
  
    int index = MIN2(ParallelGCThreads - 1, 7u);
  
    _rs_length_diff_seq-&gt;add(rs_length_diff_defaults[index]);
<span class="line-modified">!   _cost_per_card_ms_seq-&gt;add(cost_per_card_ms_defaults[index]);</span>
<span class="line-modified">!   _cost_scan_hcc_seq-&gt;add(0.0);</span>
<span class="line-modified">!   _young_cards_per_entry_ratio_seq-&gt;add(young_cards_per_entry_ratio_defaults[index]);</span>
<span class="line-modified">!   _cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms_defaults[index]);</span>
<span class="line-modified">!   _cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms_defaults[index]);</span>
    _constant_other_time_ms_seq-&gt;add(constant_other_time_ms_defaults[index]);
    _young_other_cost_per_region_ms_seq-&gt;add(young_other_cost_per_region_ms_defaults[index]);
    _non_young_other_cost_per_region_ms_seq-&gt;add(non_young_other_cost_per_region_ms_defaults[index]);
  
    // start conservatively (around 50ms is about right)
    _concurrent_mark_remark_times_ms-&gt;add(0.05);
    _concurrent_mark_cleanup_times_ms-&gt;add(0.20);
  }
  
<span class="line-modified">! double G1Analytics::get_new_prediction(TruncatedSeq const* seq) const {</span>
<span class="line-modified">!   return _predictor-&gt;get_new_prediction(seq);</span>
  }
  
<span class="line-modified">! size_t G1Analytics::get_new_size_prediction(TruncatedSeq const* seq) const {</span>
<span class="line-modified">!   return (size_t)get_new_prediction(seq);</span>
  }
  
  int G1Analytics::num_alloc_rate_ms() const {
    return _alloc_rate_ms_seq-&gt;num();
  }
<span class="line-new-header">--- 102,41 ---</span>
    _prev_collection_pause_end_ms = os::elapsedTime() * 1000.0;
  
    int index = MIN2(ParallelGCThreads - 1, 7u);
  
    _rs_length_diff_seq-&gt;add(rs_length_diff_defaults[index]);
<span class="line-modified">!   // Start with inverse of maximum STW cost.</span>
<span class="line-modified">!   _concurrent_refine_rate_ms_seq-&gt;add(1/cost_per_logged_card_ms_defaults[0]);</span>
<span class="line-modified">!   // Some applications have very low rates for logging cards.</span>
<span class="line-modified">!   _logged_cards_rate_ms_seq-&gt;add(0.0);</span>
<span class="line-modified">!   _young_card_merge_to_scan_ratio_seq-&gt;add(young_card_merge_to_scan_ratio_defaults[index]);</span>
<span class="line-added">+   _young_cost_per_card_scan_ms_seq-&gt;add(young_only_cost_per_card_scan_ms_defaults[index]);</span>
<span class="line-added">+ </span>
<span class="line-added">+   _copy_cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms_defaults[index]);</span>
    _constant_other_time_ms_seq-&gt;add(constant_other_time_ms_defaults[index]);
    _young_other_cost_per_region_ms_seq-&gt;add(young_other_cost_per_region_ms_defaults[index]);
    _non_young_other_cost_per_region_ms_seq-&gt;add(non_young_other_cost_per_region_ms_defaults[index]);
  
    // start conservatively (around 50ms is about right)
    _concurrent_mark_remark_times_ms-&gt;add(0.05);
    _concurrent_mark_cleanup_times_ms-&gt;add(0.20);
  }
  
<span class="line-modified">! bool G1Analytics::enough_samples_available(TruncatedSeq const* seq) const {</span>
<span class="line-modified">!   return seq-&gt;num() &gt;= 3;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double G1Analytics::predict_in_unit_interval(TruncatedSeq const* seq) const {</span>
<span class="line-added">+   return _predictor-&gt;predict_in_unit_interval(seq);</span>
  }
  
<span class="line-modified">! size_t G1Analytics::predict_size(TruncatedSeq const* seq) const {</span>
<span class="line-modified">!   return (size_t)predict_zero_bounded(seq);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ double G1Analytics::predict_zero_bounded(TruncatedSeq const* seq) const {</span>
<span class="line-added">+   return _predictor-&gt;predict_zero_bounded(seq);</span>
  }
  
  int G1Analytics::num_alloc_rate_ms() const {
    return _alloc_rate_ms_seq-&gt;num();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,52 ***</span>
    _alloc_rate_ms_seq-&gt;add(alloc_rate);
  }
  
  void G1Analytics::compute_pause_time_ratio(double interval_ms, double pause_time_ms) {
    _recent_avg_pause_time_ratio = _recent_gc_times_ms-&gt;sum() / interval_ms;
<span class="line-modified">!   if (_recent_avg_pause_time_ratio &lt; 0.0 ||</span>
<span class="line-modified">!       (_recent_avg_pause_time_ratio - 1.0 &gt; 0.0)) {</span>
<span class="line-modified">!     // Clip ratio between 0.0 and 1.0, and continue. This will be fixed in</span>
<span class="line-removed">-     // CR 6902692 by redoing the manner in which the ratio is incrementally computed.</span>
<span class="line-removed">-     if (_recent_avg_pause_time_ratio &lt; 0.0) {</span>
<span class="line-removed">-       _recent_avg_pause_time_ratio = 0.0;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(_recent_avg_pause_time_ratio - 1.0 &gt; 0.0, &quot;Ctl-point invariant&quot;);</span>
<span class="line-removed">-       _recent_avg_pause_time_ratio = 1.0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  
    // Compute the ratio of just this last pause time to the entire time range stored
    // in the vectors. Comparing this pause to the entire range, rather than only the
    // most recent interval, has the effect of smoothing over a possible transient &#39;burst&#39;
    // of more frequent pauses that don&#39;t really reflect a change in heap occupancy.
    // This reduces the likelihood of a needless heap expansion being triggered.
    _last_pause_time_ratio =
      (pause_time_ms * _recent_prev_end_times_for_all_gcs_sec-&gt;num()) / interval_ms;
  }
  
<span class="line-modified">! void G1Analytics::report_cost_per_card_ms(double cost_per_card_ms) {</span>
<span class="line-modified">!   _cost_per_card_ms_seq-&gt;add(cost_per_card_ms);</span>
  }
  
<span class="line-modified">! void G1Analytics::report_cost_scan_hcc(double cost_scan_hcc) {</span>
<span class="line-modified">!   _cost_scan_hcc_seq-&gt;add(cost_scan_hcc);</span>
  }
  
<span class="line-modified">! void G1Analytics::report_cost_per_entry_ms(double cost_per_entry_ms, bool for_young_gc) {</span>
    if (for_young_gc) {
<span class="line-modified">!     _cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms);</span>
    } else {
<span class="line-modified">!     _mixed_cost_per_entry_ms_seq-&gt;add(cost_per_entry_ms);</span>
    }
  }
  
<span class="line-modified">! void G1Analytics::report_cards_per_entry_ratio(double cards_per_entry_ratio, bool for_young_gc) {</span>
    if (for_young_gc) {
<span class="line-modified">!     _young_cards_per_entry_ratio_seq-&gt;add(cards_per_entry_ratio);</span>
    } else {
<span class="line-modified">!     _mixed_cards_per_entry_ratio_seq-&gt;add(cards_per_entry_ratio);</span>
    }
  }
  
  void G1Analytics::report_rs_length_diff(double rs_length_diff) {
    _rs_length_diff_seq-&gt;add(rs_length_diff);
<span class="line-new-header">--- 149,52 ---</span>
    _alloc_rate_ms_seq-&gt;add(alloc_rate);
  }
  
  void G1Analytics::compute_pause_time_ratio(double interval_ms, double pause_time_ms) {
    _recent_avg_pause_time_ratio = _recent_gc_times_ms-&gt;sum() / interval_ms;
<span class="line-modified">! </span>
<span class="line-modified">!   // Clamp the result to [0.0 ... 1.0] to filter out nonsensical results due to bad input.</span>
<span class="line-modified">!   _recent_avg_pause_time_ratio = clamp(_recent_avg_pause_time_ratio, 0.0, 1.0);</span>
  
    // Compute the ratio of just this last pause time to the entire time range stored
    // in the vectors. Comparing this pause to the entire range, rather than only the
    // most recent interval, has the effect of smoothing over a possible transient &#39;burst&#39;
    // of more frequent pauses that don&#39;t really reflect a change in heap occupancy.
    // This reduces the likelihood of a needless heap expansion being triggered.
    _last_pause_time_ratio =
      (pause_time_ms * _recent_prev_end_times_for_all_gcs_sec-&gt;num()) / interval_ms;
  }
  
<span class="line-modified">! void G1Analytics::report_concurrent_refine_rate_ms(double cards_per_ms) {</span>
<span class="line-modified">!   _concurrent_refine_rate_ms_seq-&gt;add(cards_per_ms);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void G1Analytics::report_logged_cards_rate_ms(double cards_per_ms) {</span>
<span class="line-added">+   _logged_cards_rate_ms_seq-&gt;add(cards_per_ms);</span>
  }
  
<span class="line-modified">! void G1Analytics::report_cost_per_card_scan_ms(double cost_per_card_ms, bool for_young_gc) {</span>
<span class="line-modified">!   if (for_young_gc) {</span>
<span class="line-added">+     _young_cost_per_card_scan_ms_seq-&gt;add(cost_per_card_ms);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     _mixed_cost_per_card_scan_ms_seq-&gt;add(cost_per_card_ms);</span>
<span class="line-added">+   }</span>
  }
  
<span class="line-modified">! void G1Analytics::report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_gc) {</span>
    if (for_young_gc) {
<span class="line-modified">!     _young_cost_per_card_merge_ms_seq-&gt;add(cost_per_card_ms);</span>
    } else {
<span class="line-modified">!     _mixed_cost_per_card_merge_ms_seq-&gt;add(cost_per_card_ms);</span>
    }
  }
  
<span class="line-modified">! void G1Analytics::report_card_merge_to_scan_ratio(double merge_to_scan_ratio, bool for_young_gc) {</span>
    if (for_young_gc) {
<span class="line-modified">!     _young_card_merge_to_scan_ratio_seq-&gt;add(merge_to_scan_ratio);</span>
    } else {
<span class="line-modified">!     _mixed_card_merge_to_scan_ratio_seq-&gt;add(merge_to_scan_ratio);</span>
    }
  }
  
  void G1Analytics::report_rs_length_diff(double rs_length_diff) {
    _rs_length_diff_seq-&gt;add(rs_length_diff);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,11 ***</span>
  
  void G1Analytics::report_cost_per_byte_ms(double cost_per_byte_ms, bool mark_or_rebuild_in_progress) {
    if (mark_or_rebuild_in_progress) {
      _cost_per_byte_ms_during_cm_seq-&gt;add(cost_per_byte_ms);
    } else {
<span class="line-modified">!     _cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms);</span>
    }
  }
  
  void G1Analytics::report_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
    _young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
<span class="line-new-header">--- 202,11 ---</span>
  
  void G1Analytics::report_cost_per_byte_ms(double cost_per_byte_ms, bool mark_or_rebuild_in_progress) {
    if (mark_or_rebuild_in_progress) {
      _cost_per_byte_ms_during_cm_seq-&gt;add(cost_per_byte_ms);
    } else {
<span class="line-modified">!     _copy_cost_per_byte_ms_seq-&gt;add(cost_per_byte_ms);</span>
    }
  }
  
  void G1Analytics::report_young_other_cost_per_region_ms(double other_cost_per_region_ms) {
    _young_other_cost_per_region_ms_seq-&gt;add(other_cost_per_region_ms);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,116 ***</span>
  
  void G1Analytics::report_pending_cards(double pending_cards) {
    _pending_cards_seq-&gt;add(pending_cards);
  }
  
<span class="line-modified">! void G1Analytics::report_rs_lengths(double rs_lengths) {</span>
<span class="line-modified">!   _rs_lengths_seq-&gt;add(rs_lengths);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t G1Analytics::predict_rs_length_diff() const {</span>
<span class="line-removed">-   return get_new_size_prediction(_rs_length_diff_seq);</span>
  }
  
  double G1Analytics::predict_alloc_rate_ms() const {
<span class="line-modified">!   return get_new_prediction(_alloc_rate_ms_seq);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- double G1Analytics::predict_cost_per_card_ms() const {</span>
<span class="line-removed">-   return get_new_prediction(_cost_per_card_ms_seq);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- double G1Analytics::predict_scan_hcc_ms() const {</span>
<span class="line-removed">-   return get_new_prediction(_cost_scan_hcc_seq);</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_rs_update_time_ms(size_t pending_cards) const {</span>
<span class="line-modified">!   return pending_cards * predict_cost_per_card_ms() + predict_scan_hcc_ms();</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_young_cards_per_entry_ratio() const {</span>
<span class="line-modified">!   return get_new_prediction(_young_cards_per_entry_ratio_seq);</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_mixed_cards_per_entry_ratio() const {</span>
<span class="line-modified">!   if (_mixed_cards_per_entry_ratio_seq-&gt;num() &lt; 2) {</span>
<span class="line-removed">-     return predict_young_cards_per_entry_ratio();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     return get_new_prediction(_mixed_cards_per_entry_ratio_seq);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! size_t G1Analytics::predict_card_num(size_t rs_length, bool for_young_gc) const {</span>
<span class="line-modified">!   if (for_young_gc) {</span>
<span class="line-modified">!     return (size_t) (rs_length * predict_young_cards_per_entry_ratio());</span>
    } else {
<span class="line-modified">!     return (size_t) (rs_length * predict_mixed_cards_per_entry_ratio());</span>
    }
  }
  
<span class="line-modified">! double G1Analytics::predict_rs_scan_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">!   if (for_young_gc) {</span>
<span class="line-modified">!     return card_num * get_new_prediction(_cost_per_entry_ms_seq);</span>
    } else {
<span class="line-modified">!     return predict_mixed_rs_scan_time_ms(card_num);</span>
    }
  }
  
<span class="line-modified">! double G1Analytics::predict_mixed_rs_scan_time_ms(size_t card_num) const {</span>
<span class="line-modified">!   if (_mixed_cost_per_entry_ms_seq-&gt;num() &lt; 3) {</span>
<span class="line-modified">!     return card_num * get_new_prediction(_cost_per_entry_ms_seq);</span>
    } else {
<span class="line-modified">!     return card_num * get_new_prediction(_mixed_cost_per_entry_ms_seq);</span>
    }
  }
  
  double G1Analytics::predict_object_copy_time_ms_during_cm(size_t bytes_to_copy) const {
<span class="line-modified">!   if (_cost_per_byte_ms_during_cm_seq-&gt;num() &lt; 3) {</span>
<span class="line-modified">!     return (1.1 * bytes_to_copy) * get_new_prediction(_cost_per_byte_ms_seq);</span>
    } else {
<span class="line-modified">!     return bytes_to_copy * get_new_prediction(_cost_per_byte_ms_during_cm_seq);</span>
    }
  }
  
  double G1Analytics::predict_object_copy_time_ms(size_t bytes_to_copy, bool during_concurrent_mark) const {
    if (during_concurrent_mark) {
      return predict_object_copy_time_ms_during_cm(bytes_to_copy);
    } else {
<span class="line-modified">!     return bytes_to_copy * get_new_prediction(_cost_per_byte_ms_seq);</span>
    }
  }
  
<span class="line-removed">- double G1Analytics::predict_cost_per_byte_ms() const {</span>
<span class="line-removed">-   return get_new_prediction(_cost_per_byte_ms_seq);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  double G1Analytics::predict_constant_other_time_ms() const {
<span class="line-modified">!   return get_new_prediction(_constant_other_time_ms_seq);</span>
  }
  
  double G1Analytics::predict_young_other_time_ms(size_t young_num) const {
<span class="line-modified">!   return young_num * get_new_prediction(_young_other_cost_per_region_ms_seq);</span>
  }
  
  double G1Analytics::predict_non_young_other_time_ms(size_t non_young_num) const {
<span class="line-modified">!   return non_young_num * get_new_prediction(_non_young_other_cost_per_region_ms_seq);</span>
  }
  
  double G1Analytics::predict_remark_time_ms() const {
<span class="line-modified">!   return get_new_prediction(_concurrent_mark_remark_times_ms);</span>
  }
  
  double G1Analytics::predict_cleanup_time_ms() const {
<span class="line-modified">!   return get_new_prediction(_concurrent_mark_cleanup_times_ms);</span>
  }
  
<span class="line-modified">! size_t G1Analytics::predict_rs_lengths() const {</span>
<span class="line-modified">!   return get_new_size_prediction(_rs_lengths_seq);</span>
  }
  
  size_t G1Analytics::predict_pending_cards() const {
<span class="line-modified">!   return get_new_size_prediction(_pending_cards_seq);</span>
  }
  
  double G1Analytics::last_known_gc_end_time_sec() const {
    return _recent_prev_end_times_for_all_gcs_sec-&gt;oldest();
  }
<span class="line-new-header">--- 222,96 ---</span>
  
  void G1Analytics::report_pending_cards(double pending_cards) {
    _pending_cards_seq-&gt;add(pending_cards);
  }
  
<span class="line-modified">! void G1Analytics::report_rs_length(double rs_length) {</span>
<span class="line-modified">!   _rs_length_seq-&gt;add(rs_length);</span>
  }
  
  double G1Analytics::predict_alloc_rate_ms() const {
<span class="line-modified">!   return predict_zero_bounded(_alloc_rate_ms_seq);</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_concurrent_refine_rate_ms() const {</span>
<span class="line-modified">!   return predict_zero_bounded(_concurrent_refine_rate_ms_seq);</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_logged_cards_rate_ms() const {</span>
<span class="line-modified">!   return predict_zero_bounded(_logged_cards_rate_ms_seq);</span>
  }
  
<span class="line-modified">! double G1Analytics::predict_young_card_merge_to_scan_ratio() const {</span>
<span class="line-modified">!   return predict_in_unit_interval(_young_card_merge_to_scan_ratio_seq);</span>
  }
  
<span class="line-modified">! size_t G1Analytics::predict_scan_card_num(size_t rs_length, bool for_young_gc) const {</span>
<span class="line-modified">!   if (for_young_gc || !enough_samples_available(_mixed_card_merge_to_scan_ratio_seq)) {</span>
<span class="line-modified">!     return (size_t)(rs_length * predict_young_card_merge_to_scan_ratio());</span>
    } else {
<span class="line-modified">!     return (size_t)(rs_length * predict_in_unit_interval(_mixed_card_merge_to_scan_ratio_seq));</span>
    }
  }
  
<span class="line-modified">! double G1Analytics::predict_card_merge_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">!   if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_merge_ms_seq)) {</span>
<span class="line-modified">!     return card_num * predict_zero_bounded(_young_cost_per_card_merge_ms_seq);</span>
    } else {
<span class="line-modified">!     return card_num * predict_zero_bounded(_mixed_cost_per_card_merge_ms_seq);</span>
    }
  }
  
<span class="line-modified">! double G1Analytics::predict_card_scan_time_ms(size_t card_num, bool for_young_gc) const {</span>
<span class="line-modified">!   if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_scan_ms_seq)) {</span>
<span class="line-modified">!     return card_num * predict_zero_bounded(_young_cost_per_card_scan_ms_seq);</span>
    } else {
<span class="line-modified">!     return card_num * predict_zero_bounded(_mixed_cost_per_card_scan_ms_seq);</span>
    }
  }
  
  double G1Analytics::predict_object_copy_time_ms_during_cm(size_t bytes_to_copy) const {
<span class="line-modified">!   if (!enough_samples_available(_cost_per_byte_ms_during_cm_seq)) {</span>
<span class="line-modified">!     return (1.1 * bytes_to_copy) * predict_zero_bounded(_copy_cost_per_byte_ms_seq);</span>
    } else {
<span class="line-modified">!     return bytes_to_copy * predict_zero_bounded(_cost_per_byte_ms_during_cm_seq);</span>
    }
  }
  
  double G1Analytics::predict_object_copy_time_ms(size_t bytes_to_copy, bool during_concurrent_mark) const {
    if (during_concurrent_mark) {
      return predict_object_copy_time_ms_during_cm(bytes_to_copy);
    } else {
<span class="line-modified">!     return bytes_to_copy * predict_zero_bounded(_copy_cost_per_byte_ms_seq);</span>
    }
  }
  
  double G1Analytics::predict_constant_other_time_ms() const {
<span class="line-modified">!   return predict_zero_bounded(_constant_other_time_ms_seq);</span>
  }
  
  double G1Analytics::predict_young_other_time_ms(size_t young_num) const {
<span class="line-modified">!   return young_num * predict_zero_bounded(_young_other_cost_per_region_ms_seq);</span>
  }
  
  double G1Analytics::predict_non_young_other_time_ms(size_t non_young_num) const {
<span class="line-modified">!   return non_young_num * predict_zero_bounded(_non_young_other_cost_per_region_ms_seq);</span>
  }
  
  double G1Analytics::predict_remark_time_ms() const {
<span class="line-modified">!   return predict_zero_bounded(_concurrent_mark_remark_times_ms);</span>
  }
  
  double G1Analytics::predict_cleanup_time_ms() const {
<span class="line-modified">!   return predict_zero_bounded(_concurrent_mark_cleanup_times_ms);</span>
  }
  
<span class="line-modified">! size_t G1Analytics::predict_rs_length() const {</span>
<span class="line-modified">!   return predict_size(_rs_length_seq) + predict_size(_rs_length_diff_seq);</span>
  }
  
  size_t G1Analytics::predict_pending_cards() const {
<span class="line-modified">!   return predict_size(_pending_cards_seq);</span>
  }
  
  double G1Analytics::last_known_gc_end_time_sec() const {
    return _recent_prev_end_times_for_all_gcs_sec-&gt;oldest();
  }
</pre>
<center><a href="g1Allocator.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Analytics.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
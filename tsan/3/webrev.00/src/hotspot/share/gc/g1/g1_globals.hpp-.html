<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1_GLOBALS_HPP
 26 #define SHARE_GC_G1_G1_GLOBALS_HPP
 27 
 28 #include &lt;float.h&gt; // for DBL_MAX
 29 //
 30 // Defines all globals flags used by the garbage-first compiler.
 31 //
 32 
 33 #define GC_G1_FLAGS(develop,                                                \
 34                     develop_pd,                                             \
 35                     product,                                                \
 36                     product_pd,                                             \
 37                     diagnostic,                                             \
 38                     diagnostic_pd,                                          \
 39                     experimental,                                           \
 40                     notproduct,                                             \
 41                     manageable,                                             \
 42                     product_rw,                                             \
 43                     lp64_product,                                           \
 44                     range,                                                  \
 45                     constraint,                                             \
 46                     writeable)                                              \
 47                                                                             \
 48   product(bool, G1UseAdaptiveIHOP, true,                                    \
 49           &quot;Adaptively adjust the initiating heap occupancy from the &quot;       \
 50           &quot;initial value of InitiatingHeapOccupancyPercent. The policy &quot;    \
 51           &quot;attempts to start marking in time based on application &quot;         \
 52           &quot;behavior.&quot;)                                                      \
 53                                                                             \
 54   experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \
 55           &quot;How many completed time periods from initial mark to first &quot;     \
 56           &quot;mixed gc are required to use the input values for prediction &quot;   \
 57           &quot;of the optimal occupancy to start marking.&quot;)                     \
 58           range(1, max_intx)                                                \
 59                                                                             \
 60   product(uintx, G1ConfidencePercent, 50,                                   \
 61           &quot;Confidence level for MMU/pause predictions&quot;)                     \
 62           range(0, 100)                                                     \
 63                                                                             \
 64   diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \
 65           &quot;The period (in number of GCs) at which we will generate &quot;        \
 66           &quot;update buffer processing info &quot;                                  \
 67           &quot;(0 means do not periodically generate this info); &quot;              \
 68           &quot;it also requires that logging is enabled on the trace&quot;           \
 69           &quot;level for gc+remset&quot;)                                            \
 70           range(0, max_intx)                                                \
 71                                                                             \
 72   product(double, G1ConcMarkStepDurationMillis, 10.0,                       \
 73           &quot;Target duration of individual concurrent marking steps &quot;         \
 74           &quot;in milliseconds.&quot;)                                               \
 75           range(1.0, DBL_MAX)                                               \
 76                                                                             \
 77   product(uint, G1RefProcDrainInterval, 1000,                               \
 78           &quot;The number of discovered reference objects to process before &quot;   \
 79           &quot;draining concurrent marking work queues.&quot;)                       \
 80           range(1, INT_MAX)                                                 \
 81                                                                             \
 82   experimental(bool, G1UseReferencePrecleaning, true,                       \
 83                &quot;Concurrently preclean java.lang.ref.references instances &quot;  \
 84                &quot;before the Remark pause.&quot;)                                  \
 85                                                                             \
 86   experimental(double, G1LastPLABAverageOccupancy, 50.0,                    \
 87                &quot;The expected average occupancy of the last PLAB in &quot;        \
 88                &quot;percent.&quot;)                                                  \
 89                range(0.001, 100.0)                                          \
 90                                                                             \
 91   product(size_t, G1SATBBufferSize, 1*K,                                    \
 92           &quot;Number of entries in an SATB log buffer.&quot;)                       \
 93           range(1, max_uintx)                                               \
 94                                                                             \
 95   develop(intx, G1SATBProcessCompletedThreshold, 20,                        \
 96           &quot;Number of completed buffers that triggers log processing.&quot;)      \
 97           range(0, max_jint)                                                \
 98                                                                             \
 99   product(uintx, G1SATBBufferEnqueueingThresholdPercent, 60,                \
100           &quot;Before enqueueing them, each mutator thread tries to do some &quot;   \
101           &quot;filtering on the SATB buffers it generates. If post-filtering &quot;  \
102           &quot;the percentage of retained entries is over this threshold &quot;      \
103           &quot;the buffer will be enqueued for processing. A value of 0 &quot;       \
104           &quot;specifies that mutator threads should not do such filtering.&quot;)   \
105           range(0, 100)                                                     \
106                                                                             \
107   experimental(intx, G1ExpandByPercentOfAvailable, 20,                      \
108           &quot;When expanding, % of uncommitted space to claim.&quot;)               \
109           range(0, 100)                                                     \
110                                                                             \
111   product(size_t, G1UpdateBufferSize, 256,                                  \
112           &quot;Size of an update buffer&quot;)                                       \
113           range(1, NOT_LP64(32*M) LP64_ONLY(1*G))                           \
114                                                                             \
115   product(size_t, G1ConcRefinementYellowZone, 0,                            \
116           &quot;Number of enqueued update buffers that will &quot;                    \
117           &quot;trigger concurrent processing. Will be selected ergonomically &quot;  \
118           &quot;by default.&quot;)                                                    \
119           range(0, max_intx)                                                \
120                                                                             \
121   product(size_t, G1ConcRefinementRedZone, 0,                               \
122           &quot;Maximum number of enqueued update buffers before mutator &quot;       \
123           &quot;threads start processing new ones instead of enqueueing them. &quot;  \
124           &quot;Will be selected ergonomically by default.&quot;)                     \
125           range(0, max_intx)                                                \
126                                                                             \
127   product(size_t, G1ConcRefinementGreenZone, 0,                             \
128           &quot;The number of update buffers that are left in the queue by the &quot; \
129           &quot;concurrent processing threads. Will be selected ergonomically &quot;  \
130           &quot;by default.&quot;)                                                    \
131           range(0, max_intx)                                                \
132                                                                             \
133   product(uintx, G1ConcRefinementServiceIntervalMillis, 300,                \
134           &quot;The last concurrent refinement thread wakes up every &quot;           \
135           &quot;specified number of milliseconds to do miscellaneous work.&quot;)     \
136           range(0, max_jint)                                                \
137                                                                             \
138   product(size_t, G1ConcRefinementThresholdStep, 2,                         \
139           &quot;Each time the rset update queue increases by this amount &quot;       \
140           &quot;activate the next refinement thread if available. &quot;              \
141           &quot;The actual step size will be selected ergonomically by &quot;         \
142           &quot;default, with this value used to determine a lower bound.&quot;)      \
143           range(1, SIZE_MAX)                                                \
144                                                                             \
145   product(intx, G1RSetUpdatingPauseTimePercent, 10,                         \
146           &quot;A target percentage of time that is allowed to be spend on &quot;     \
147           &quot;process RS update buffers during the collection pause.&quot;)         \
148           range(0, 100)                                                     \
149                                                                             \
150   product(bool, G1UseAdaptiveConcRefinement, true,                          \
151           &quot;Select green, yellow and red zones adaptively to meet the &quot;      \
152           &quot;the pause requirements.&quot;)                                        \
153                                                                             \
154   product(size_t, G1ConcRSLogCacheSize, 10,                                 \
155           &quot;Log base 2 of the length of conc RS hot-card cache.&quot;)            \
156           range(0, 27)                                                      \
157                                                                             \
158   product(uintx, G1ConcRSHotCardLimit, 4,                                   \
159           &quot;The threshold that defines (&gt;=) a hot card.&quot;)                    \
160           range(0, max_jubyte)                                              \
161                                                                             \
162   develop(intx, G1RSetRegionEntriesBase, 256,                               \
163           &quot;Max number of regions in a fine-grain table per MB.&quot;)            \
164           range(1, max_jint/wordSize)                                       \
165                                                                             \
166   product(intx, G1RSetRegionEntries, 0,                                     \
167           &quot;Max number of regions for which we keep bitmaps.&quot;                \
168           &quot;Will be set ergonomically by default&quot;)                           \
169           range(0, max_jint/wordSize)                                       \
170           constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \
171                                                                             \
172   develop(intx, G1RSetSparseRegionEntriesBase, 4,                           \
173           &quot;Max number of entries per region in a sparse table &quot;             \
174           &quot;per MB.&quot;)                                                        \
175           range(1, max_jint/wordSize)                                       \
176                                                                             \
177   product(intx, G1RSetSparseRegionEntries, 0,                               \
178           &quot;Max number of entries per region in a sparse table.&quot;             \
179           &quot;Will be set ergonomically by default.&quot;)                          \
180           range(0, max_jint/wordSize)                                       \
181           constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \
182                                                                             \
183   develop(intx, G1MaxVerifyFailures, -1,                                    \
184           &quot;The maximum number of verification failures to print.  &quot;         \
185           &quot;-1 means print all.&quot;)                                            \
186           range(-1, max_jint)                                               \
187                                                                             \
188   product(uintx, G1ReservePercent, 10,                                      \
189           &quot;It determines the minimum reserve we should have in the heap &quot;   \
190           &quot;to minimize the probability of promotion failure.&quot;)              \
191           range(0, 50)                                                      \
192                                                                             \
193   product(size_t, G1HeapRegionSize, 0,                                      \
194           &quot;Size of the G1 regions.&quot;)                                        \
195           range(0, 32*M)                                                    \
196           constraint(G1HeapRegionSizeConstraintFunc,AfterMemoryInit)        \
197                                                                             \
198   product(uint, G1ConcRefinementThreads, 0,                                 \
199           &quot;The number of parallel rem set update threads. &quot;                 \
200           &quot;Will be set ergonomically by default.&quot;)                          \
201           range(0, (max_jint-1)/wordSize)                                   \
202                                                                             \
203   develop(bool, G1VerifyCTCleanup, false,                                   \
204           &quot;Verify card table cleanup.&quot;)                                     \
205                                                                             \
206   product(size_t, G1RSetScanBlockSize, 64,                                  \
207           &quot;Size of a work unit of cards claimed by a worker thread&quot;         \
208           &quot;during RSet scanning.&quot;)                                          \
209           range(1, max_uintx)                                               \
210                                                                             \
211   develop(uintx, G1DummyRegionsPerGC, 0,                                    \
212           &quot;The number of dummy regions G1 will allocate at the end of &quot;     \
213           &quot;each evacuation pause in order to artificially fill up the &quot;     \
214           &quot;heap and stress the marking implementation.&quot;)                    \
215                                                                             \
216   develop(bool, G1ExitOnExpansionFailure, false,                            \
217           &quot;Raise a fatal VM exit out of memory failure in the event &quot;       \
218           &quot; that heap expansion fails due to running out of swap.&quot;)         \
219                                                                             \
220   experimental(uintx, G1MaxNewSizePercent, 60,                              \
221           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
222           &quot; maximum young gen size.&quot;)                                       \
223           range(0, 100)                                                     \
224           constraint(G1MaxNewSizePercentConstraintFunc,AfterErgo)           \
225                                                                             \
226   experimental(uintx, G1NewSizePercent, 5,                                  \
227           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
228           &quot;minimum young gen size.&quot;)                                        \
229           range(0, 100)                                                     \
230           constraint(G1NewSizePercentConstraintFunc,AfterErgo)              \
231                                                                             \
232   experimental(uintx, G1MixedGCLiveThresholdPercent, 85,                    \
233           &quot;Threshold for regions to be considered for inclusion in the &quot;    \
234           &quot;collection set of mixed GCs. &quot;                                   \
235           &quot;Regions with live bytes exceeding this will not be collected.&quot;)  \
236           range(0, 100)                                                     \
237                                                                             \
238   product(uintx, G1HeapWastePercent, 5,                                     \
239           &quot;Amount of space, expressed as a percentage of the heap size, &quot;   \
240           &quot;that G1 is willing not to collect to avoid expensive GCs.&quot;)      \
241           range(0, 100)                                                     \
242                                                                             \
243   product(uintx, G1MixedGCCountTarget, 8,                                   \
244           &quot;The target number of mixed GCs after a marking cycle.&quot;)          \
245           range(0, max_uintx)                                               \
246                                                                             \
247   experimental(bool, G1PretouchAuxiliaryMemory, false,                      \
248           &quot;Pre-touch large auxiliary data structures used by the GC.&quot;)      \
249                                                                             \
250   experimental(bool, G1EagerReclaimHumongousObjects, true,                  \
251           &quot;Try to reclaim dead large objects at every young GC.&quot;)           \
252                                                                             \
253   experimental(bool, G1EagerReclaimHumongousObjectsWithStaleRefs, true,     \
254           &quot;Try to reclaim dead large objects that have a few stale &quot;        \
255           &quot;references at every young GC.&quot;)                                  \
256                                                                             \
257   experimental(size_t, G1RebuildRemSetChunkSize, 256 * K,                   \
258           &quot;Chunk size used for rebuilding the remembered set.&quot;)             \
259           range(4 * K, 32 * M)                                              \
260                                                                             \
261   experimental(uintx, G1OldCSetRegionThresholdPercent, 10,                  \
262           &quot;An upper bound for the number of old CSet regions expressed &quot;    \
263           &quot;as a percentage of the heap size.&quot;)                              \
264           range(0, 100)                                                     \
265                                                                             \
266   notproduct(bool, G1EvacuationFailureALot, false,                          \
267           &quot;Force use of evacuation failure handling during certain &quot;        \
268           &quot;evacuation pauses&quot;)                                              \
269                                                                             \
270   develop(uintx, G1EvacuationFailureALotCount, 1000,                        \
271           &quot;Number of successful evacuations between evacuation failures &quot;   \
272           &quot;occurring at object copying&quot;)                                    \
273                                                                             \
274   develop(uintx, G1EvacuationFailureALotInterval, 5,                        \
275           &quot;Total collections between forced triggering of evacuation &quot;      \
276           &quot;failures&quot;)                                                       \
277                                                                             \
278   develop(bool, G1EvacuationFailureALotDuringConcMark, true,                \
279           &quot;Force use of evacuation failure handling during evacuation &quot;     \
280           &quot;pauses when marking is in progress&quot;)                             \
281                                                                             \
282   develop(bool, G1EvacuationFailureALotDuringInitialMark, true,             \
283           &quot;Force use of evacuation failure handling during initial mark &quot;   \
284           &quot;evacuation pauses&quot;)                                              \
285                                                                             \
286   develop(bool, G1EvacuationFailureALotDuringYoungGC, true,                 \
287           &quot;Force use of evacuation failure handling during young &quot;          \
288           &quot;evacuation pauses&quot;)                                              \
289                                                                             \
290   develop(bool, G1EvacuationFailureALotDuringMixedGC, true,                 \
291           &quot;Force use of evacuation failure handling during mixed &quot;          \
292           &quot;evacuation pauses&quot;)                                              \
293                                                                             \
294   diagnostic(bool, G1VerifyRSetsDuringFullGC, false,                        \
295           &quot;If true, perform verification of each heap region&#39;s &quot;            \
296           &quot;remembered set when verifying the heap during a full GC.&quot;)       \
297                                                                             \
298   diagnostic(bool, G1VerifyHeapRegionCodeRoots, false,                      \
299           &quot;Verify the code root lists attached to each heap region.&quot;)       \
300                                                                             \
301   develop(bool, G1VerifyBitmaps, false,                                     \
302           &quot;Verifies the consistency of the marking bitmaps&quot;)                \
303                                                                             \
304   manageable(uintx, G1PeriodicGCInterval, 0,                                \
305           &quot;Number of milliseconds after a previous GC to wait before &quot;      \
306           &quot;triggering a periodic gc. A value of zero disables periodically &quot;\
307           &quot;enforced gc cycles.&quot;)                                            \
308                                                                             \
309   product(bool, G1PeriodicGCInvokesConcurrent, true,                        \
310           &quot;Determines the kind of periodic GC. Set to true to have G1 &quot;     \
311           &quot;perform a concurrent GC as periodic GC, otherwise use a STW &quot;    \
312           &quot;Full GC.&quot;)                                                       \
313                                                                             \
314   manageable(double, G1PeriodicGCSystemLoadThreshold, 0.0,                  \
315           &quot;Maximum recent system wide load as returned by the 1m value &quot;    \
316           &quot;of getloadavg() at which G1 triggers a periodic GC. A load &quot;     \
317           &quot;above this value cancels a given periodic GC. A value of zero &quot;  \
318           &quot;disables this check.&quot;)                                           \
319           range(0.0, (double)max_uintx)                                     \
320                                                                             \
321   experimental(uintx, G1YoungExpansionBufferPercent, 10,                    \
322                &quot;When heterogenous heap is enabled by AllocateOldGenAt &quot;     \
323                &quot;option, after every GC, young gen is re-sized which &quot;       \
324                &quot;involves system calls to commit/uncommit memory. To &quot;       \
325                &quot;reduce these calls, we keep a buffer of extra regions to &quot;  \
326                &quot;absorb small changes in young gen length. This flag takes &quot; \
327                &quot;the buffer size as an percentage of young gen length&quot;)      \
328                range(0, 100)                                                \
329 
330 
331 #endif // SHARE_GC_G1_G1_GLOBALS_HPP
    </pre>
  </body>
</html>
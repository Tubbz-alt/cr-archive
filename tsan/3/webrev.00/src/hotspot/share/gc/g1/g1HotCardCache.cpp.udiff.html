<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1HotCardCache.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1HeterogeneousHeapYoungGenSizer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HotCardCache.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1HotCardCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -21,19 +21,20 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;</span>
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  
  G1HotCardCache::G1HotCardCache(G1CollectedHeap *g1h):
    _g1h(g1h), _use_cache(false), _card_counts(g1h),
    _hot_cache(NULL), _hot_cache_size(0), _hot_cache_par_chunk_size(0),
<span class="udiff-line-modified-removed">-   _hot_cache_idx(0), _hot_cache_par_claimed_idx(0)</span>
<span class="udiff-line-modified-added">+   _hot_cache_idx(0), _hot_cache_par_claimed_idx(0), _cache_wrapped_around(false)</span>
  {}
  
  void G1HotCardCache::initialize(G1RegionToSpaceMapper* card_counts_storage) {
    if (default_use_cache()) {
      _use_cache = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,10 +46,12 @@</span>
  
      // For refining the cards in the hot cache in parallel
      _hot_cache_par_chunk_size = ClaimChunkSize;
      _hot_cache_par_claimed_idx = 0;
  
<span class="udiff-line-added">+     _cache_wrapped_around = false;</span>
<span class="udiff-line-added">+ </span>
      _card_counts.initialize(card_counts_storage);
    }
  }
  
  G1HotCardCache::~G1HotCardCache() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,43 +68,47 @@</span>
      // The card is not hot so do not store it in the cache;
      // return it for immediate refining.
      return card_ptr;
    }
    // Otherwise, the card is hot.
<span class="udiff-line-modified-removed">-   size_t index = Atomic::add(1u, &amp;_hot_cache_idx) - 1;</span>
<span class="udiff-line-modified-added">+   size_t index = Atomic::fetch_and_add(&amp;_hot_cache_idx, 1u);</span>
<span class="udiff-line-added">+   if (index == _hot_cache_size) {</span>
<span class="udiff-line-added">+     // Can use relaxed store because all racing threads are writing the same</span>
<span class="udiff-line-added">+     // value and there aren&#39;t any concurrent readers.</span>
<span class="udiff-line-added">+     Atomic::store(&amp;_cache_wrapped_around, true);</span>
<span class="udiff-line-added">+   }</span>
    size_t masked_index = index &amp; (_hot_cache_size - 1);
    CardValue* current_ptr = _hot_cache[masked_index];
  
    // Try to store the new card pointer into the cache. Compare-and-swap to guard
    // against the unlikely event of a race resulting in another card pointer to
    // have already been written to the cache. In this case we will return
    // card_ptr in favor of the other option, which would be starting over. This
    // should be OK since card_ptr will likely be the older card already when/if
    // this ever happens.
<span class="udiff-line-modified-removed">-   CardValue* previous_ptr = Atomic::cmpxchg(card_ptr,</span>
<span class="udiff-line-modified-removed">-                                             &amp;_hot_cache[masked_index],</span>
<span class="udiff-line-modified-removed">-                                             current_ptr);</span>
<span class="udiff-line-modified-added">+   CardValue* previous_ptr = Atomic::cmpxchg(&amp;_hot_cache[masked_index],</span>
<span class="udiff-line-modified-added">+                                             current_ptr,</span>
<span class="udiff-line-modified-added">+                                             card_ptr);</span>
    return (previous_ptr == current_ptr) ? previous_ptr : card_ptr;
  }
  
<span class="udiff-line-modified-removed">- void G1HotCardCache::drain(G1CardTableEntryClosure* cl, uint worker_i) {</span>
<span class="udiff-line-modified-added">+ void G1HotCardCache::drain(G1CardTableEntryClosure* cl, uint worker_id) {</span>
    assert(default_use_cache(), &quot;Drain only necessary if we use the hot card cache.&quot;);
  
    assert(_hot_cache != NULL, &quot;Logic&quot;);
    assert(!use_cache(), &quot;cache should be disabled&quot;);
  
    while (_hot_cache_par_claimed_idx &lt; _hot_cache_size) {
<span class="udiff-line-modified-removed">-     size_t end_idx = Atomic::add(_hot_cache_par_chunk_size,</span>
<span class="udiff-line-modified-removed">-                                  &amp;_hot_cache_par_claimed_idx);</span>
<span class="udiff-line-modified-added">+     size_t end_idx = Atomic::add(&amp;_hot_cache_par_claimed_idx,</span>
<span class="udiff-line-modified-added">+                                  _hot_cache_par_chunk_size);</span>
      size_t start_idx = end_idx - _hot_cache_par_chunk_size;
      // The current worker has successfully claimed the chunk [start_idx..end_idx)
      end_idx = MIN2(end_idx, _hot_cache_size);
      for (size_t i = start_idx; i &lt; end_idx; i++) {
        CardValue* card_ptr = _hot_cache[i];
        if (card_ptr != NULL) {
<span class="udiff-line-modified-removed">-         bool result = cl-&gt;do_card_ptr(card_ptr, worker_i);</span>
<span class="udiff-line-removed">-         assert(result, &quot;Closure should always return true&quot;);</span>
<span class="udiff-line-modified-added">+         cl-&gt;do_card_ptr(card_ptr, worker_id);</span>
        } else {
          break;
        }
      }
    }
</pre>
<center><a href="g1HeterogeneousHeapYoungGenSizer.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HotCardCache.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
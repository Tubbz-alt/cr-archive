<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
119 // so that we can reason about all the region groups in the heap using
120 // the same interface (namely, the HeapRegionSetBase API).
121 
122 class HeapRegionSet : public HeapRegionSetBase {
123 public:
124   HeapRegionSet(const char* name, HeapRegionSetChecker* checker):
125     HeapRegionSetBase(name, checker) {
126   }
127 
128   void bulk_remove(const uint removed) {
129     _length -= removed;
130   }
131 };
132 
133 // A set that links all the regions added to it in a doubly-linked
134 // sorted list. We should try to avoid doing operations that iterate over
135 // such lists in performance critical paths. Typically we should
136 // add / remove one region at a time or concatenate two lists.
137 
138 class FreeRegionListIterator;

139 
140 class FreeRegionList : public HeapRegionSetBase {
141   friend class FreeRegionListIterator;
142 
143 private:





















144   HeapRegion* _head;
145   HeapRegion* _tail;
146 
147   // _last is used to keep track of where we added an element the last
148   // time. It helps to improve performance when adding several ordered items in a row.
149   HeapRegion* _last;
150 


151   static uint _unrealistically_long_length;
152 
153   inline HeapRegion* remove_from_head_impl();
154   inline HeapRegion* remove_from_tail_impl();
155 







156 protected:
157   // See the comment for HeapRegionSetBase::clear()
158   virtual void clear();
159 
160 public:
<span class="line-modified">161   FreeRegionList(const char* name, HeapRegionSetChecker* checker = NULL):</span>
<span class="line-modified">162     HeapRegionSetBase(name, checker) {</span>
<span class="line-removed">163     clear();</span>
<span class="line-removed">164   }</span>
165 
166   void verify_list();
167 
168 #ifdef ASSERT
169   bool contains(HeapRegion* hr) const {
170     return hr-&gt;containing_set() == this;
171   }
172 #endif
173 
174   static void set_unrealistically_long_length(uint len);
175 
176   // Add hr to the list. The region should not be a member of another set.
177   // Assumes that the list is ordered and will preserve that order. The order
178   // is determined by hrm_index.
179   inline void add_ordered(HeapRegion* hr);


180 
181   // Removes from head or tail based on the given argument.
182   HeapRegion* remove_region(bool from_head);
183 



184   // Merge two ordered lists. The result is also ordered. The order is
185   // determined by hrm_index.
186   void add_ordered(FreeRegionList* from_list);

187 
188   // It empties the list by removing all regions from it.
189   void remove_all();
190 




191   // Remove all (contiguous) regions from first to first + num_regions -1 from
192   // this list.
193   // Num_regions must be &gt; 1.
194   void remove_starting_at(HeapRegion* first, uint num_regions);
195 
196   virtual void verify();
197 
198   uint num_of_regions_in_range(uint start, uint end) const;



199 };
200 
201 // Iterator class that provides a convenient way to iterate over the
202 // regions of a FreeRegionList.
203 
204 class FreeRegionListIterator : public StackObj {
205 private:
206   FreeRegionList* _list;
207   HeapRegion*     _curr;
208 
209 public:
210   bool more_available() {
211     return _curr != NULL;
212   }
213 
214   HeapRegion* get_next() {
215     assert(more_available(),
216            &quot;get_next() should be called when more regions are available&quot;);
217 
218     // If we are going to introduce a count in the iterator we should
</pre>
</td>
<td>
<hr />
<pre>
119 // so that we can reason about all the region groups in the heap using
120 // the same interface (namely, the HeapRegionSetBase API).
121 
122 class HeapRegionSet : public HeapRegionSetBase {
123 public:
124   HeapRegionSet(const char* name, HeapRegionSetChecker* checker):
125     HeapRegionSetBase(name, checker) {
126   }
127 
128   void bulk_remove(const uint removed) {
129     _length -= removed;
130   }
131 };
132 
133 // A set that links all the regions added to it in a doubly-linked
134 // sorted list. We should try to avoid doing operations that iterate over
135 // such lists in performance critical paths. Typically we should
136 // add / remove one region at a time or concatenate two lists.
137 
138 class FreeRegionListIterator;
<span class="line-added">139 class G1NUMA;</span>
140 
141 class FreeRegionList : public HeapRegionSetBase {
142   friend class FreeRegionListIterator;
143 
144 private:
<span class="line-added">145 </span>
<span class="line-added">146   // This class is only initialized if there are multiple active nodes.</span>
<span class="line-added">147   class NodeInfo : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added">148     G1NUMA* _numa;</span>
<span class="line-added">149     uint*   _length_of_node;</span>
<span class="line-added">150     uint    _num_nodes;</span>
<span class="line-added">151 </span>
<span class="line-added">152   public:</span>
<span class="line-added">153     NodeInfo();</span>
<span class="line-added">154     ~NodeInfo();</span>
<span class="line-added">155 </span>
<span class="line-added">156     inline void increase_length(uint node_index);</span>
<span class="line-added">157     inline void decrease_length(uint node_index);</span>
<span class="line-added">158 </span>
<span class="line-added">159     inline uint length(uint index) const;</span>
<span class="line-added">160 </span>
<span class="line-added">161     void clear();</span>
<span class="line-added">162 </span>
<span class="line-added">163     void add(NodeInfo* info);</span>
<span class="line-added">164   };</span>
<span class="line-added">165 </span>
166   HeapRegion* _head;
167   HeapRegion* _tail;
168 
169   // _last is used to keep track of where we added an element the last
170   // time. It helps to improve performance when adding several ordered items in a row.
171   HeapRegion* _last;
172 
<span class="line-added">173   NodeInfo*   _node_info;</span>
<span class="line-added">174 </span>
175   static uint _unrealistically_long_length;
176 
177   inline HeapRegion* remove_from_head_impl();
178   inline HeapRegion* remove_from_tail_impl();
179 
<span class="line-added">180   inline void increase_length(uint node_index);</span>
<span class="line-added">181   inline void decrease_length(uint node_index);</span>
<span class="line-added">182 </span>
<span class="line-added">183   // Common checks for adding a list.</span>
<span class="line-added">184   void add_list_common_start(FreeRegionList* from_list);</span>
<span class="line-added">185   void add_list_common_end(FreeRegionList* from_list);</span>
<span class="line-added">186 </span>
187 protected:
188   // See the comment for HeapRegionSetBase::clear()
189   virtual void clear();
190 
191 public:
<span class="line-modified">192   FreeRegionList(const char* name, HeapRegionSetChecker* checker = NULL);</span>
<span class="line-modified">193   ~FreeRegionList();</span>


194 
195   void verify_list();
196 
197 #ifdef ASSERT
198   bool contains(HeapRegion* hr) const {
199     return hr-&gt;containing_set() == this;
200   }
201 #endif
202 
203   static void set_unrealistically_long_length(uint len);
204 
205   // Add hr to the list. The region should not be a member of another set.
206   // Assumes that the list is ordered and will preserve that order. The order
207   // is determined by hrm_index.
208   inline void add_ordered(HeapRegion* hr);
<span class="line-added">209   // Same restrictions as above, but adds the region last in the list.</span>
<span class="line-added">210   inline void add_to_tail(HeapRegion* region_to_add);</span>
211 
212   // Removes from head or tail based on the given argument.
213   HeapRegion* remove_region(bool from_head);
214 
<span class="line-added">215   HeapRegion* remove_region_with_node_index(bool from_head,</span>
<span class="line-added">216                                             uint requested_node_index);</span>
<span class="line-added">217 </span>
218   // Merge two ordered lists. The result is also ordered. The order is
219   // determined by hrm_index.
220   void add_ordered(FreeRegionList* from_list);
<span class="line-added">221   void append_ordered(FreeRegionList* from_list);</span>
222 
223   // It empties the list by removing all regions from it.
224   void remove_all();
225 
<span class="line-added">226   // Abandon current free list. Requires that all regions in the current list</span>
<span class="line-added">227   // are taken care of separately, to allow a rebuild.</span>
<span class="line-added">228   void abandon();</span>
<span class="line-added">229 </span>
230   // Remove all (contiguous) regions from first to first + num_regions -1 from
231   // this list.
232   // Num_regions must be &gt; 1.
233   void remove_starting_at(HeapRegion* first, uint num_regions);
234 
235   virtual void verify();
236 
237   uint num_of_regions_in_range(uint start, uint end) const;
<span class="line-added">238 </span>
<span class="line-added">239   using HeapRegionSetBase::length;</span>
<span class="line-added">240   uint length(uint node_index) const;</span>
241 };
242 
243 // Iterator class that provides a convenient way to iterate over the
244 // regions of a FreeRegionList.
245 
246 class FreeRegionListIterator : public StackObj {
247 private:
248   FreeRegionList* _list;
249   HeapRegion*     _curr;
250 
251 public:
252   bool more_available() {
253     return _curr != NULL;
254   }
255 
256   HeapRegion* get_next() {
257     assert(more_available(),
258            &quot;get_next() should be called when more regions are available&quot;);
259 
260     // If we are going to introduce a count in the iterator we should
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionSet.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
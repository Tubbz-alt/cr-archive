<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ConcurrentMark.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMark.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkObjArrayProcessor.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMark.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,13 ***</span>
  
    // Some callers may have stale objects to mark above nTAMS after humongous reclaim.
    // Can&#39;t assert that this is a valid object at this point, since it might be in the process of being copied by another thread.
    assert(!hr-&gt;is_continues_humongous(), &quot;Should not try to mark object &quot; PTR_FORMAT &quot; in Humongous continues region %u above nTAMS &quot; PTR_FORMAT, p2i(obj), hr-&gt;hrm_index(), p2i(hr-&gt;next_top_at_mark_start()));
  
<span class="line-modified">!   HeapWord* const obj_addr = (HeapWord*)obj;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool success = _next_mark_bitmap-&gt;par_mark(obj_addr);</span>
    if (success) {
      add_to_liveness(worker_id, obj, obj-&gt;size());
    }
    return success;
  }
<span class="line-new-header">--- 70,11 ---</span>
  
    // Some callers may have stale objects to mark above nTAMS after humongous reclaim.
    // Can&#39;t assert that this is a valid object at this point, since it might be in the process of being copied by another thread.
    assert(!hr-&gt;is_continues_humongous(), &quot;Should not try to mark object &quot; PTR_FORMAT &quot; in Humongous continues region %u above nTAMS &quot; PTR_FORMAT, p2i(obj), hr-&gt;hrm_index(), p2i(hr-&gt;next_top_at_mark_start()));
  
<span class="line-modified">!   bool success = _next_mark_bitmap-&gt;par_mark(obj);</span>
    if (success) {
      add_to_liveness(worker_id, obj, obj-&gt;size());
    }
    return success;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,11 ***</span>
  inline void G1CMTask::push(G1TaskQueueEntry task_entry) {
    assert(task_entry.is_array_slice() || _g1h-&gt;is_in_g1_reserved(task_entry.obj()), &quot;invariant&quot;);
    assert(task_entry.is_array_slice() || !_g1h-&gt;is_on_master_free_list(
                _g1h-&gt;heap_region_containing(task_entry.obj())), &quot;invariant&quot;);
    assert(task_entry.is_array_slice() || !_g1h-&gt;is_obj_ill(task_entry.obj()), &quot;invariant&quot;);  // FIXME!!!
<span class="line-modified">!   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked((HeapWord*)task_entry.obj()), &quot;invariant&quot;);</span>
  
    if (!_task_queue-&gt;push(task_entry)) {
      // The local task queue looks full. We need to push some entries
      // to the global stack.
      move_entries_to_global_stack();
<span class="line-new-header">--- 108,11 ---</span>
  inline void G1CMTask::push(G1TaskQueueEntry task_entry) {
    assert(task_entry.is_array_slice() || _g1h-&gt;is_in_g1_reserved(task_entry.obj()), &quot;invariant&quot;);
    assert(task_entry.is_array_slice() || !_g1h-&gt;is_on_master_free_list(
                _g1h-&gt;heap_region_containing(task_entry.obj())), &quot;invariant&quot;);
    assert(task_entry.is_array_slice() || !_g1h-&gt;is_obj_ill(task_entry.obj()), &quot;invariant&quot;);  // FIXME!!!
<span class="line-modified">!   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())), &quot;invariant&quot;);</span>
  
    if (!_task_queue-&gt;push(task_entry)) {
      // The local task queue looks full. We need to push some entries
      // to the global stack.
      move_entries_to_global_stack();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
    // a current region and obj is between the local finger and the
    // end of the current region, then no push is needed.  The tradeoff
    // of checking both vs only checking the global finger is that the
    // local check will be more accurate and so result in fewer pushes,
    // but may also be a little slower.
<span class="line-modified">!   HeapWord* objAddr = (HeapWord*)obj;</span>
    if (_finger != NULL) {
      // We have a current region.
  
      // Finger and region values are all NULL or all non-NULL.  We
      // use _finger to check since we immediately use its value.
<span class="line-new-header">--- 131,11 ---</span>
    // a current region and obj is between the local finger and the
    // end of the current region, then no push is needed.  The tradeoff
    // of checking both vs only checking the global finger is that the
    // local check will be more accurate and so result in fewer pushes,
    // but may also be a little slower.
<span class="line-modified">!   HeapWord* objAddr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
    if (_finger != NULL) {
      // We have a current region.
  
      // Finger and region values are all NULL or all non-NULL.  We
      // use _finger to check since we immediately use its value.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
  }
  
  template&lt;bool scan&gt;
  inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {
    assert(scan || (task_entry.is_oop() &amp;&amp; task_entry.obj()-&gt;is_typeArray()), &quot;Skipping scan of grey non-typeArray&quot;);
<span class="line-modified">!   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked((HeapWord*)task_entry.obj()),</span>
           &quot;Any stolen object should be a slice or marked&quot;);
  
    if (scan) {
      if (task_entry.is_array_slice()) {
        _words_scanned += _objArray_processor.process_slice(task_entry.slice());
<span class="line-new-header">--- 156,11 ---</span>
  }
  
  template&lt;bool scan&gt;
  inline void G1CMTask::process_grey_task_entry(G1TaskQueueEntry task_entry) {
    assert(scan || (task_entry.is_oop() &amp;&amp; task_entry.obj()-&gt;is_typeArray()), &quot;Skipping scan of grey non-typeArray&quot;);
<span class="line-modified">!   assert(task_entry.is_array_slice() || _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(task_entry.obj())),</span>
           &quot;Any stolen object should be a slice or marked&quot;);
  
    if (scan) {
      if (task_entry.is_array_slice()) {
        _words_scanned += _objArray_processor.process_slice(task_entry.slice());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
      // Leave TARS at NULL.
    }
  }
  
  inline void G1CMTask::update_liveness(oop const obj, const size_t obj_size) {
<span class="line-modified">!   _mark_stats_cache.add_live_words(_g1h-&gt;addr_to_region((HeapWord*)obj), obj_size);</span>
  }
  
  inline void G1ConcurrentMark::add_to_liveness(uint worker_id, oop const obj, size_t size) {
    task(worker_id)-&gt;update_liveness(obj, size);
  }
<span class="line-new-header">--- 199,11 ---</span>
      // Leave TARS at NULL.
    }
  }
  
  inline void G1CMTask::update_liveness(oop const obj, const size_t obj_size) {
<span class="line-modified">!   _mark_stats_cache.add_live_words(_g1h-&gt;addr_to_region(cast_from_oop&lt;HeapWord*&gt;(obj)), obj_size);</span>
  }
  
  inline void G1ConcurrentMark::add_to_liveness(uint worker_id, oop const obj, size_t size) {
    task(worker_id)-&gt;update_liveness(obj, size);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,22 ***</span>
    }
    return make_reference_grey(obj);
  }
  
  inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {
<span class="line-modified">!   assert(!_prev_mark_bitmap-&gt;is_marked((HeapWord*) p), &quot;sanity&quot;);</span>
<span class="line-modified">!  _prev_mark_bitmap-&gt;mark((HeapWord*) p);</span>
  }
  
  bool G1ConcurrentMark::is_marked_in_prev_bitmap(oop p) const {
    assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">!   return _prev_mark_bitmap-&gt;is_marked((HeapWord*)p);</span>
  }
  
  bool G1ConcurrentMark::is_marked_in_next_bitmap(oop p) const {
    assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">!   return _next_mark_bitmap-&gt;is_marked((HeapWord*)p);</span>
  }
  
  inline bool G1ConcurrentMark::do_yield_check() {
    if (SuspendibleThreadSet::should_yield()) {
      SuspendibleThreadSet::yield();
<span class="line-new-header">--- 266,22 ---</span>
    }
    return make_reference_grey(obj);
  }
  
  inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {
<span class="line-modified">!   assert(!_prev_mark_bitmap-&gt;is_marked(p), &quot;sanity&quot;);</span>
<span class="line-modified">!  _prev_mark_bitmap-&gt;mark(p);</span>
  }
  
  bool G1ConcurrentMark::is_marked_in_prev_bitmap(oop p) const {
    assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">!   return _prev_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));</span>
  }
  
  bool G1ConcurrentMark::is_marked_in_next_bitmap(oop p) const {
    assert(p != NULL &amp;&amp; oopDesc::is_oop(p), &quot;expected an oop&quot;);
<span class="line-modified">!   return _next_mark_bitmap-&gt;is_marked(cast_from_oop&lt;HeapWord*&gt;(p));</span>
  }
  
  inline bool G1ConcurrentMark::do_yield_check() {
    if (SuspendibleThreadSet::should_yield()) {
      SuspendibleThreadSet::yield();
</pre>
<center><a href="g1ConcurrentMark.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkObjArrayProcessor.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/g1/g1HotCardCache.hpp b/src/hotspot/share/gc/g1/g1HotCardCache.hpp
--- a/src/hotspot/share/gc/g1/g1HotCardCache.hpp
+++ b/src/hotspot/share/gc/g1/g1HotCardCache.hpp
@@ -24,11 +24,10 @@
 
 #ifndef SHARE_GC_G1_G1HOTCARDCACHE_HPP
 #define SHARE_GC_G1_G1HOTCARDCACHE_HPP
 
 #include "gc/g1/g1CardCounts.hpp"
-#include "gc/g1/g1_globals.hpp"
 #include "memory/allocation.hpp"
 #include "runtime/safepoint.hpp"
 #include "runtime/thread.hpp"
 #include "utilities/globalDefinitions.hpp"
 
@@ -80,10 +79,15 @@
 
   volatile size_t _hot_cache_par_claimed_idx;
 
   char _pad_after[DEFAULT_CACHE_LINE_SIZE];
 
+  // Records whether insertion overflowed the hot card cache at least once. This
+  // avoids the need for a separate atomic counter of how many valid entries are
+  // in the HCC.
+  volatile bool _cache_wrapped_around;
+
   // The number of cached cards a thread claims when flushing the cache
   static const int ClaimChunkSize = 32;
 
  public:
   static bool default_use_cache() {
@@ -112,11 +116,11 @@
   // the evicted card is then returned for refinement.
   CardValue* insert(CardValue* card_ptr);
 
   // Refine the cards that have delayed as a result of
   // being in the cache.
-  void drain(G1CardTableEntryClosure* cl, uint worker_i);
+  void drain(G1CardTableEntryClosure* cl, uint worker_id);
 
   // Set up for parallel processing of the cards in the hot cache
   void reset_hot_cache_claimed_index() {
     _hot_cache_par_claimed_idx = 0;
   }
@@ -124,23 +128,28 @@
   // Resets the hot card cache and discards the entries.
   void reset_hot_cache() {
     assert(SafepointSynchronize::is_at_safepoint(), "Should be at a safepoint");
     assert(Thread::current()->is_VM_thread(), "Current thread should be the VMthread");
     if (default_use_cache()) {
-        reset_hot_cache_internal();
+      reset_hot_cache_internal();
     }
   }
 
   // Zeros the values in the card counts table for the given region
   void reset_card_counts(HeapRegion* hr);
 
+  // Number of entries in the HCC.
+  size_t num_entries() const {
+    return _cache_wrapped_around ? _hot_cache_size : _hot_cache_idx + 1;
+  }
  private:
   void reset_hot_cache_internal() {
     assert(_hot_cache != NULL, "Logic");
     _hot_cache_idx = 0;
     for (size_t i = 0; i < _hot_cache_size; i++) {
       _hot_cache[i] = NULL;
     }
+    _cache_wrapped_around = false;
   }
 };
 
 #endif // SHARE_GC_G1_G1HOTCARDCACHE_HPP

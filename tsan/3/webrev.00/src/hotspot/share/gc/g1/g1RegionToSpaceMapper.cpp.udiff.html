<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1RegionToSpaceMapper.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RegionMarkStatsCache.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RegionToSpaceMapper.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1RegionToSpaceMapper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,31 +22,34 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BiasedArray.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1NUMA.hpp&quot;</span>
  #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/virtualspace.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.inline.hpp&quot;
  #include &quot;services/memTracker.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  G1RegionToSpaceMapper::G1RegionToSpaceMapper(ReservedSpace rs,
                                               size_t used_size,
                                               size_t page_size,
                                               size_t region_granularity,
                                               size_t commit_factor,
                                               MemoryType type) :
    _listener(NULL),
    _storage(rs, used_size, page_size),
    _region_granularity(region_granularity),
<span class="udiff-line-modified-removed">-   _commit_map(rs.size() * commit_factor / region_granularity, mtGC) {</span>
<span class="udiff-line-modified-added">+   _commit_map(rs.size() * commit_factor / region_granularity, mtGC),</span>
<span class="udiff-line-added">+   _memory_type(type) {</span>
    guarantee(is_power_of_2(page_size), &quot;must be&quot;);
    guarantee(is_power_of_2(region_granularity), &quot;must be&quot;);
  
    MemTracker::record_virtual_memory_type((address)rs.base(), type);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -70,14 +73,22 @@</span>
  
      guarantee(alloc_granularity &gt;= page_size, &quot;allocation granularity smaller than commit granularity&quot;);
    }
  
    virtual void commit_regions(uint start_idx, size_t num_regions, WorkGang* pretouch_gang) {
<span class="udiff-line-modified-removed">-     size_t const start_page = (size_t)start_idx * _pages_per_region;</span>
<span class="udiff-line-modified-removed">-     bool zero_filled = _storage.commit(start_page, num_regions * _pages_per_region);</span>
<span class="udiff-line-modified-added">+     const size_t start_page = (size_t)start_idx * _pages_per_region;</span>
<span class="udiff-line-modified-added">+     const size_t size_in_pages = num_regions * _pages_per_region;</span>
<span class="udiff-line-added">+     bool zero_filled = _storage.commit(start_page, size_in_pages);</span>
<span class="udiff-line-added">+     if (_memory_type == mtJavaHeap) {</span>
<span class="udiff-line-added">+       for (uint region_index = start_idx; region_index &lt; start_idx + num_regions; region_index++ ) {</span>
<span class="udiff-line-added">+         void* address = _storage.page_start(region_index * _pages_per_region);</span>
<span class="udiff-line-added">+         size_t size_in_bytes = _storage.page_size() * _pages_per_region;</span>
<span class="udiff-line-added">+         G1NUMA::numa()-&gt;request_memory_on_node(address, size_in_bytes, region_index);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      if (AlwaysPreTouch) {
<span class="udiff-line-modified-removed">-       _storage.pretouch(start_page, num_regions * _pages_per_region, pretouch_gang);</span>
<span class="udiff-line-modified-added">+       _storage.pretouch(start_page, size_in_pages, pretouch_gang);</span>
      }
      _commit_map.set_range(start_idx, start_idx + num_regions);
      fire_on_commit(start_idx, num_regions, zero_filled);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124,30 +135,36 @@</span>
  
      size_t first_committed = NoPage;
      size_t num_committed = 0;
  
      bool all_zero_filled = true;
<span class="udiff-line-added">+     G1NUMA* numa = G1NUMA::numa();</span>
  
<span class="udiff-line-modified-removed">-     for (uint i = start_idx; i &lt; start_idx + num_regions; i++) {</span>
<span class="udiff-line-modified-removed">-       assert(!_commit_map.at(i), &quot;Trying to commit storage at region %u that is already committed&quot;, i);</span>
<span class="udiff-line-modified-removed">-       size_t idx = region_idx_to_page_idx(i);</span>
<span class="udiff-line-modified-removed">-       uint old_refcount = _refcounts.get_by_index(idx);</span>
<span class="udiff-line-modified-added">+     for (uint region_idx = start_idx; region_idx &lt; start_idx + num_regions; region_idx++) {</span>
<span class="udiff-line-modified-added">+       assert(!_commit_map.at(region_idx), &quot;Trying to commit storage at region %u that is already committed&quot;, region_idx);</span>
<span class="udiff-line-modified-added">+       size_t page_idx = region_idx_to_page_idx(region_idx);</span>
<span class="udiff-line-modified-added">+       uint old_refcount = _refcounts.get_by_index(page_idx);</span>
  
        bool zero_filled = false;
        if (old_refcount == 0) {
          if (first_committed == NoPage) {
<span class="udiff-line-modified-removed">-           first_committed = idx;</span>
<span class="udiff-line-modified-added">+           first_committed = page_idx;</span>
            num_committed = 1;
          } else {
            num_committed++;
          }
<span class="udiff-line-modified-removed">-         zero_filled = _storage.commit(idx, 1);</span>
<span class="udiff-line-modified-added">+         zero_filled = _storage.commit(page_idx, 1);</span>
<span class="udiff-line-added">+         if (_memory_type == mtJavaHeap) {</span>
<span class="udiff-line-added">+           void* address = _storage.page_start(page_idx);</span>
<span class="udiff-line-added">+           size_t size_in_bytes = _storage.page_size();</span>
<span class="udiff-line-added">+           numa-&gt;request_memory_on_node(address, size_in_bytes, region_idx);</span>
<span class="udiff-line-added">+         }</span>
        }
        all_zero_filled &amp;= zero_filled;
  
<span class="udiff-line-modified-removed">-       _refcounts.set_by_index(idx, old_refcount + 1);</span>
<span class="udiff-line-modified-removed">-       _commit_map.set_bit(i);</span>
<span class="udiff-line-modified-added">+       _refcounts.set_by_index(page_idx, old_refcount + 1);</span>
<span class="udiff-line-modified-added">+       _commit_map.set_bit(region_idx);</span>
      }
      if (AlwaysPreTouch &amp;&amp; num_committed &gt; 0) {
        _storage.pretouch(first_committed, num_committed, pretouch_gang);
      }
      fire_on_commit(start_idx, num_regions, all_zero_filled);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,12 +220,14 @@</span>
                                                           size_t alloc_granularity,
                                                           size_t commit_factor,
                                                           MemoryType type) :
    G1RegionToSpaceMapper(rs, actual_size, page_size, alloc_granularity, commit_factor, type),
    _rs(rs),
<span class="udiff-line-added">+   _dram_mapper(NULL),</span>
    _num_committed_dram(0),
    _num_committed_nvdimm(0),
<span class="udiff-line-added">+   _start_index_of_dram(0),</span>
    _page_size(page_size),
    _commit_factor(commit_factor),
    _type(type) {
    assert(actual_size == 2 * MaxHeapSize, &quot;For 2-way heterogenuous heap, reserved space is two times MaxHeapSize&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -246,11 +265,10 @@</span>
      _dram_mapper = new G1RegionsLargerThanCommitSizeMapper(rs_dram, rs_dram.size(), _page_size, _region_granularity, _commit_factor, _type);
    } else {
      _dram_mapper = new G1RegionsSmallerThanCommitSizeMapper(rs_dram, rs_dram.size(), _page_size, _region_granularity, _commit_factor, _type);
    }
  
<span class="udiff-line-removed">-   _start_index_of_nvdimm = 0;</span>
    _start_index_of_dram = (uint)(rs_nvdimm.size() / _region_granularity);
    return true;
  }
  
  void G1RegionToHeteroSpaceMapper::commit_regions(uint start_idx, size_t num_regions, WorkGang* pretouch_gang) {
</pre>
<center><a href="g1RegionMarkStatsCache.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RegionToSpaceMapper.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;

 30 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 31 #include &quot;gc/g1/g1Policy.hpp&quot;
 32 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 33 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 34 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 35 #include &quot;logging/logStream.hpp&quot;

 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/globalDefinitions.hpp&quot;
 38 #include &quot;utilities/quickSort.hpp&quot;
 39 
<span class="line-modified"> 40 G1CollectorState* G1CollectionSet::collector_state() {</span>
 41   return _g1h-&gt;collector_state();
 42 }
 43 
 44 G1GCPhaseTimes* G1CollectionSet::phase_times() {
 45   return _policy-&gt;phase_times();
 46 }
 47 
<span class="line-modified"> 48 double G1CollectionSet::predict_region_elapsed_time_ms(HeapRegion* hr) {</span>
<span class="line-modified"> 49   return _policy-&gt;predict_region_elapsed_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
 50 }
 51 
 52 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
 53   _g1h(g1h),
 54   _policy(policy),
 55   _candidates(NULL),
 56   _eden_region_length(0),
 57   _survivor_region_length(0),
 58   _old_region_length(0),
 59   _collection_set_regions(NULL),
 60   _collection_set_cur_length(0),
 61   _collection_set_max_length(0),
<span class="line-modified"> 62   _optional_regions(NULL),</span>
<span class="line-removed"> 63   _optional_region_length(0),</span>
<span class="line-removed"> 64   _optional_region_max_length(0),</span>
 65   _bytes_used_before(0),
<span class="line-modified"> 66   _recorded_rs_lengths(0),</span>
 67   _inc_build_state(Inactive),


 68   _inc_bytes_used_before(0),
<span class="line-modified"> 69   _inc_recorded_rs_lengths(0),</span>
<span class="line-modified"> 70   _inc_recorded_rs_lengths_diffs(0),</span>
<span class="line-modified"> 71   _inc_predicted_elapsed_time_ms(0.0),</span>
<span class="line-modified"> 72   _inc_predicted_elapsed_time_ms_diffs(0.0) {</span>
 73 }
 74 
 75 G1CollectionSet::~G1CollectionSet() {
<span class="line-modified"> 76   if (_collection_set_regions != NULL) {</span>
<span class="line-modified"> 77     FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-removed"> 78   }</span>
 79   free_optional_regions();
 80   clear_candidates();
 81 }
 82 
 83 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
 84                                           uint survivor_cset_region_length) {
 85   assert_at_safepoint_on_vm_thread();
 86 
 87   _eden_region_length     = eden_cset_region_length;
 88   _survivor_region_length = survivor_cset_region_length;
 89 
 90   assert((size_t) young_region_length() == _collection_set_cur_length,
 91          &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 92 
<span class="line-modified"> 93   _old_region_length      = 0;</span>
<span class="line-modified"> 94   _optional_region_length = 0;</span>
 95 }
 96 
 97 void G1CollectionSet::initialize(uint max_region_length) {
 98   guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
 99   _collection_set_max_length = max_region_length;
100   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<span class="line-modified">101 }</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 void G1CollectionSet::initialize_optional(uint max_length) {</span>
<span class="line-removed">104   assert(_optional_regions == NULL, &quot;Already initialized&quot;);</span>
<span class="line-removed">105   assert(_optional_region_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">106   assert(_optional_region_max_length == 0, &quot;Already initialized&quot;);</span>
<span class="line-removed">107   _optional_region_max_length = max_length;</span>
<span class="line-removed">108   _optional_regions = NEW_C_HEAP_ARRAY(HeapRegion*, _optional_region_max_length, mtGC);</span>
109 }
110 
111 void G1CollectionSet::free_optional_regions() {
<span class="line-modified">112   _optional_region_length = 0;</span>
<span class="line-removed">113   _optional_region_max_length = 0;</span>
<span class="line-removed">114   if (_optional_regions != NULL) {</span>
<span class="line-removed">115     FREE_C_HEAP_ARRAY(HeapRegion*, _optional_regions);</span>
<span class="line-removed">116     _optional_regions = NULL;</span>
<span class="line-removed">117   }</span>
118 }
119 
120 void G1CollectionSet::clear_candidates() {
121   delete _candidates;
122   _candidates = NULL;
123 }
124 
<span class="line-modified">125 void G1CollectionSet::set_recorded_rs_lengths(size_t rs_lengths) {</span>
<span class="line-modified">126   _recorded_rs_lengths = rs_lengths;</span>
127 }
128 
129 // Add the heap region at the head of the non-incremental collection set
130 void G1CollectionSet::add_old_region(HeapRegion* hr) {
131   assert_at_safepoint_on_vm_thread();
132 
<span class="line-modified">133   assert(_inc_build_state == Active || hr-&gt;index_in_opt_cset() != G1OptionalCSet::InvalidCSetIndex,</span>
134          &quot;Precondition, actively building cset or adding optional later on&quot;);
135   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
136 
<span class="line-modified">137   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);</span>
<span class="line-modified">138   _g1h-&gt;register_old_region_with_cset(hr);</span>
139 
140   _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
141   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
142 
143   _bytes_used_before += hr-&gt;used();
<span class="line-modified">144   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">145   _recorded_rs_lengths += rs_length;</span>
<span class="line-removed">146   _old_region_length += 1;</span>
147 
<span class="line-modified">148   log_trace(gc, cset)(&quot;Added old region %d to collection set&quot;, hr-&gt;hrm_index());</span>
149 }
150 
151 void G1CollectionSet::add_optional_region(HeapRegion* hr) {
<span class="line-removed">152   assert(!optional_is_full(), &quot;Precondition, must have room left for this region&quot;);</span>
153   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
154   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
155 
<span class="line-modified">156   _g1h-&gt;register_optional_region_with_cset(hr);</span>
157 
<span class="line-modified">158   _optional_regions[_optional_region_length] = hr;</span>
<span class="line-removed">159   uint index = _optional_region_length++;</span>
<span class="line-removed">160   hr-&gt;set_index_in_opt_cset(index);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   log_trace(gc, cset)(&quot;Added region %d to optional collection set (%u)&quot;, hr-&gt;hrm_index(), _optional_region_length);</span>
163 }
164 
<span class="line-removed">165 // Initialize the per-collection-set information</span>
166 void G1CollectionSet::start_incremental_building() {
167   assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
168   assert(_inc_build_state == Inactive, &quot;Precondition&quot;);





169 
170   _inc_bytes_used_before = 0;
171 
<span class="line-modified">172   _inc_recorded_rs_lengths = 0;</span>
<span class="line-modified">173   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">174   _inc_predicted_elapsed_time_ms = 0.0;</span>
<span class="line-modified">175   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
<span class="line-modified">176   _inc_build_state = Active;</span>

177 }
178 
179 void G1CollectionSet::finalize_incremental_building() {
180   assert(_inc_build_state == Active, &quot;Precondition&quot;);
181   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
182 
<span class="line-modified">183   // The two &quot;main&quot; fields, _inc_recorded_rs_lengths and</span>
<span class="line-modified">184   // _inc_predicted_elapsed_time_ms, are updated by the thread</span>
185   // that adds a new region to the CSet. Further updates by the
186   // concurrent refinement thread that samples the young RSet lengths
<span class="line-modified">187   // are accumulated in the *_diffs fields. Here we add the diffs to</span>
188   // the &quot;main&quot; fields.
189 
<span class="line-modified">190   if (_inc_recorded_rs_lengths_diffs &gt;= 0) {</span>
<span class="line-modified">191     _inc_recorded_rs_lengths += _inc_recorded_rs_lengths_diffs;</span>
<span class="line-removed">192   } else {</span>
<span class="line-removed">193     // This is defensive. The diff should in theory be always positive</span>
<span class="line-removed">194     // as RSets can only grow between GCs. However, given that we</span>
<span class="line-removed">195     // sample their size concurrently with other threads updating them</span>
<span class="line-removed">196     // it&#39;s possible that we might get the wrong size back, which</span>
<span class="line-removed">197     // could make the calculations somewhat inaccurate.</span>
<span class="line-removed">198     size_t diffs = (size_t) (-_inc_recorded_rs_lengths_diffs);</span>
<span class="line-removed">199     if (_inc_recorded_rs_lengths &gt;= diffs) {</span>
<span class="line-removed">200       _inc_recorded_rs_lengths -= diffs;</span>
<span class="line-removed">201     } else {</span>
<span class="line-removed">202       _inc_recorded_rs_lengths = 0;</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204   }</span>
<span class="line-removed">205   _inc_predicted_elapsed_time_ms += _inc_predicted_elapsed_time_ms_diffs;</span>
206 
<span class="line-modified">207   _inc_recorded_rs_lengths_diffs = 0;</span>
<span class="line-modified">208   _inc_predicted_elapsed_time_ms_diffs = 0.0;</span>
209 }
210 
211 void G1CollectionSet::clear() {
212   assert_at_safepoint_on_vm_thread();
213   _collection_set_cur_length = 0;
<span class="line-removed">214   _optional_region_length = 0;</span>
215 }
216 
217 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {
<span class="line-removed">218   iterate_from(cl, 0, 1);</span>
<span class="line-removed">219 }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221 void G1CollectionSet::iterate_from(HeapRegionClosure* cl, uint worker_id, uint total_workers) const {</span>
222   size_t len = _collection_set_cur_length;
223   OrderAccess::loadload();
<span class="line-removed">224   if (len == 0) {</span>
<span class="line-removed">225     return;</span>
<span class="line-removed">226   }</span>
<span class="line-removed">227   size_t start_pos = (worker_id * len) / total_workers;</span>
<span class="line-removed">228   size_t cur_pos = start_pos;</span>
229 
<span class="line-modified">230   do {</span>
<span class="line-modified">231     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[cur_pos]);</span>
232     bool result = cl-&gt;do_heap_region(r);
233     if (result) {
234       cl-&gt;set_incomplete();
235       return;
236     }

















































237     cur_pos++;
<span class="line-modified">238     if (cur_pos == len) {</span>
239       cur_pos = 0;
240     }
241   } while (cur_pos != start_pos);
242 }
243 
244 void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,
245                                                      size_t new_rs_length) {
246   // Update the CSet information that is dependent on the new RS length
247   assert(hr-&gt;is_young(), &quot;Precondition&quot;);
248   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
249 
<span class="line-modified">250   // We could have updated _inc_recorded_rs_lengths and</span>
<span class="line-removed">251   // _inc_predicted_elapsed_time_ms directly but we&#39;d need to do</span>
<span class="line-removed">252   // that atomically, as this code is executed by a concurrent</span>
<span class="line-removed">253   // refinement thread, potentially concurrently with a mutator thread</span>
<span class="line-removed">254   // allocating a new region and also updating the same fields. To</span>
<span class="line-removed">255   // avoid the atomic operations we accumulate these updates on two</span>
<span class="line-removed">256   // separate fields (*_diffs) and we&#39;ll just add them to the &quot;main&quot;</span>
<span class="line-removed">257   // fields at the start of a GC.</span>
258 
<span class="line-modified">259   ssize_t old_rs_length = (ssize_t) hr-&gt;recorded_rs_length();</span>
<span class="line-modified">260   ssize_t rs_lengths_diff = (ssize_t) new_rs_length - old_rs_length;</span>
<span class="line-modified">261   _inc_recorded_rs_lengths_diffs += rs_lengths_diff;</span>




262 
<span class="line-modified">263   double old_elapsed_time_ms = hr-&gt;predicted_elapsed_time_ms();</span>
<span class="line-modified">264   double new_region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">265   double elapsed_ms_diff = new_region_elapsed_time_ms - old_elapsed_time_ms;</span>
<span class="line-modified">266   _inc_predicted_elapsed_time_ms_diffs += elapsed_ms_diff;</span>
267 
<span class="line-modified">268   hr-&gt;set_recorded_rs_length(new_rs_length);</span>
<span class="line-modified">269   hr-&gt;set_predicted_elapsed_time_ms(new_region_elapsed_time_ms);</span>
270 }
271 
272 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
273   assert(hr-&gt;is_young(), &quot;invariant&quot;);
274   assert(_inc_build_state == Active, &quot;Precondition&quot;);
275 
<span class="line-removed">276   size_t collection_set_length = _collection_set_cur_length;</span>
<span class="line-removed">277   assert(collection_set_length &lt;= INT_MAX, &quot;Collection set is too large with %d entries&quot;, (int)collection_set_length);</span>
<span class="line-removed">278   hr-&gt;set_young_index_in_cset((int)collection_set_length);</span>
<span class="line-removed">279 </span>
<span class="line-removed">280   _collection_set_regions[collection_set_length] = hr-&gt;hrm_index();</span>
<span class="line-removed">281   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-removed">282   // update to the length field.</span>
<span class="line-removed">283   OrderAccess::storestore();</span>
<span class="line-removed">284   _collection_set_cur_length++;</span>
<span class="line-removed">285   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
<span class="line-removed">286 </span>
287   // This routine is used when:
288   // * adding survivor regions to the incremental cset at the end of an
289   //   evacuation pause or
290   // * adding the current allocation region to the incremental cset
291   //   when it is retired.
292   // Therefore this routine may be called at a safepoint by the
293   // VM thread, or in-between safepoints by mutator threads (when
294   // retiring the current allocation region)
295   // We need to clear and set the cached recorded/cached collection set
296   // information in the heap region here (before the region gets added
297   // to the collection set). An individual heap region&#39;s cached values
298   // are calculated, aggregated with the policy collection set info,
299   // and cached in the heap region here (initially) and (subsequently)
300   // by the Young List sampling code.
301   // Ignore calls to this due to retirement during full gc.
302 
303   if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
304     size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified">305     double region_elapsed_time_ms = predict_region_elapsed_time_ms(hr);</span>
306 
307     // Cache the values we have added to the aggregated information
308     // in the heap region in case we have to remove this region from
309     // the incremental collection set, or it is updated by the
310     // rset sampling code
<span class="line-removed">311     hr-&gt;set_recorded_rs_length(rs_length);</span>
<span class="line-removed">312     hr-&gt;set_predicted_elapsed_time_ms(region_elapsed_time_ms);</span>
313 
<span class="line-modified">314     _inc_recorded_rs_lengths += rs_length;</span>
<span class="line-modified">315     _inc_predicted_elapsed_time_ms += region_elapsed_time_ms;</span>




316     _inc_bytes_used_before += hr-&gt;used();
317   }
318 
319   assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<span class="line-modified">320   _g1h-&gt;register_young_region_with_cset(hr);</span>












321 }
322 
323 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
324   assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
325   add_young_region_common(hr);
326 }
327 
328 void G1CollectionSet::add_eden_region(HeapRegion* hr) {
329   assert(hr-&gt;is_eden(), &quot;Must only add eden regions, but is %s&quot;, hr-&gt;get_type_str());
330   add_young_region_common(hr);
331 }
332 
333 #ifndef PRODUCT
334 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
335 public:
336   bool _valid;
<span class="line-modified">337 public:</span>
338   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
339 
340   virtual bool do_heap_region(HeapRegion* r) {
341     guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
342 
<span class="line-modified">343     SurvRateGroup* group = r-&gt;surv_rate_group();</span>
<span class="line-modified">344 </span>
<span class="line-removed">345     if (group == NULL) {</span>
<span class="line-removed">346       log_error(gc, verify)(&quot;## encountered NULL surv_rate_group in young region&quot;);</span>
347       _valid = false;
348     }
349 
<span class="line-modified">350     if (r-&gt;age_in_surv_rate_group() &lt; 0) {</span>
<span class="line-modified">351       log_error(gc, verify)(&quot;## encountered negative age in young region&quot;);</span>
352       _valid = false;
353     }
354 
355     return false;
356   }
357 
358   bool valid() const { return _valid; }
359 };
360 
361 bool G1CollectionSet::verify_young_ages() {
362   assert_at_safepoint_on_vm_thread();
363 
364   G1VerifyYoungAgesClosure cl;
365   iterate(&amp;cl);
366 
367   if (!cl.valid()) {
368     LogStreamHandle(Error, gc, verify) log;
369     print(&amp;log);
370   }
371 
372   return cl.valid();
373 }
374 
375 class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {
376   outputStream* _st;
377 public:
378   G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }
379 
380   virtual bool do_heap_region(HeapRegion* r) {
381     assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
382     _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
383                   HR_FORMAT_PARAMS(r),
384                   p2i(r-&gt;prev_top_at_mark_start()),
385                   p2i(r-&gt;next_top_at_mark_start()),
<span class="line-modified">386                   r-&gt;age_in_surv_rate_group_cond());</span>
387     return false;
388   }
389 };
390 
391 void G1CollectionSet::print(outputStream* st) {
392   st-&gt;print_cr(&quot;\nCollection_set:&quot;);
393 
394   G1PrintCollectionSetDetailClosure cl(st);
395   iterate(&amp;cl);
396 }
397 #endif // !PRODUCT
398 
399 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<span class="line-modified">400   double young_start_time_sec = os::elapsedTime();</span>
401 
402   finalize_incremental_building();
403 
404   guarantee(target_pause_time_ms &gt; 0.0,
405             &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
406 
<span class="line-modified">407   size_t pending_cards = _policy-&gt;pending_cards();</span>
<span class="line-removed">408   double base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-removed">409   double time_remaining_ms = MAX2(target_pause_time_ms - base_time_ms, 0.0);</span>
410 
<span class="line-modified">411   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. pending cards: &quot; SIZE_FORMAT &quot; predicted base time: %1.2fms remaining time: %1.2fms target pause time: %1.2fms&quot;,</span>
<span class="line-modified">412                             pending_cards, base_time_ms, time_remaining_ms, target_pause_time_ms);</span>
413 
414   // The young list is laid with the survivor regions from the previous
415   // pause are appended to the RHS of the young list, i.e.
416   //   [Newly Young Regions ++ Survivors from last pause].
417 
<span class="line-removed">418   uint survivor_region_length = survivors-&gt;length();</span>
419   uint eden_region_length = _g1h-&gt;eden_regions_count();

420   init_region_lengths(eden_region_length, survivor_region_length);
421 
422   verify_young_cset_indices();
423 
424   // Clear the fields that point to the survivor list - they are all young now.
425   survivors-&gt;convert_to_eden();
426 
427   _bytes_used_before = _inc_bytes_used_before;
<span class="line-removed">428   time_remaining_ms = MAX2(time_remaining_ms - _inc_predicted_elapsed_time_ms, 0.0);</span>
<span class="line-removed">429 </span>
<span class="line-removed">430   log_trace(gc, ergo, cset)(&quot;Add young regions to CSet. eden: %u regions, survivors: %u regions, predicted young region time: %1.2fms, target pause time: %1.2fms&quot;,</span>
<span class="line-removed">431                             eden_region_length, survivor_region_length, _inc_predicted_elapsed_time_ms, target_pause_time_ms);</span>
432 
433   // The number of recorded young regions is the incremental
434   // collection set&#39;s current size
<span class="line-modified">435   set_recorded_rs_lengths(_inc_recorded_rs_lengths);</span>
<span class="line-removed">436 </span>
<span class="line-removed">437   double young_end_time_sec = os::elapsedTime();</span>
<span class="line-removed">438   phase_times()-&gt;record_young_cset_choice_time_ms((young_end_time_sec - young_start_time_sec) * 1000.0);</span>
<span class="line-removed">439 </span>
<span class="line-removed">440   return time_remaining_ms;</span>
<span class="line-removed">441 }</span>
442 
<span class="line-modified">443 void G1CollectionSet::add_as_old(HeapRegion* hr) {</span>
<span class="line-modified">444   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">445   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">446   add_old_region(hr);</span>
<span class="line-removed">447 }</span>
448 
<span class="line-modified">449 void G1CollectionSet::add_as_optional(HeapRegion* hr) {</span>
<span class="line-modified">450   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-modified">451   candidates()-&gt;pop_front(); // already have region via peek()</span>
<span class="line-modified">452   _g1h-&gt;old_set_remove(hr);</span>
<span class="line-removed">453   add_optional_region(hr);</span>
<span class="line-removed">454 }</span>
455 
<span class="line-modified">456 bool G1CollectionSet::optional_is_full() {</span>
<span class="line-removed">457   assert(_optional_region_length &lt;= _optional_region_max_length, &quot;Invariant&quot;);</span>
<span class="line-removed">458   return _optional_region_length == _optional_region_max_length;</span>
<span class="line-removed">459 }</span>
460 
<span class="line-modified">461 void G1CollectionSet::clear_optional_region(const HeapRegion* hr) {</span>
<span class="line-removed">462   assert(_optional_regions != NULL, &quot;Must not be called before array is allocated&quot;);</span>
<span class="line-removed">463   uint index = hr-&gt;index_in_opt_cset();</span>
<span class="line-removed">464   _optional_regions[index] = NULL;</span>
465 }
466 
467 static int compare_region_idx(const uint a, const uint b) {
468   if (a &gt; b) {
469     return 1;
470   } else if (a == b) {
471     return 0;
472   } else {
473     return -1;
474   }
475 }
476 
477 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
478   double non_young_start_time_sec = os::elapsedTime();
<span class="line-removed">479   double predicted_old_time_ms = 0.0;</span>
<span class="line-removed">480   double predicted_optional_time_ms = 0.0;</span>
<span class="line-removed">481   double optional_threshold_ms = time_remaining_ms * _policy-&gt;optional_prediction_fraction();</span>
<span class="line-removed">482   uint expensive_region_num = 0;</span>
483 
484   if (collector_state()-&gt;in_mixed_phase()) {
485     candidates()-&gt;verify();
<span class="line-modified">486     const uint min_old_cset_length = _policy-&gt;calc_min_old_cset_length();</span>
<span class="line-modified">487     const uint max_old_cset_length = MAX2(min_old_cset_length, _policy-&gt;calc_max_old_cset_length());</span>
<span class="line-modified">488     bool check_time_remaining = _policy-&gt;adaptive_young_list_length();</span>
<span class="line-modified">489 </span>
<span class="line-modified">490     initialize_optional(max_old_cset_length - min_old_cset_length);</span>
<span class="line-modified">491     log_debug(gc, ergo, cset)(&quot;Start adding old regions for mixed gc. min %u regions, max %u regions, &quot;</span>
<span class="line-modified">492                               &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,</span>
<span class="line-modified">493                               min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);</span>
<span class="line-modified">494 </span>
<span class="line-modified">495     HeapRegion* hr = candidates()-&gt;peek_front();</span>
<span class="line-modified">496     while (hr != NULL) {</span>
<span class="line-modified">497       if (old_region_length() + optional_region_length() &gt;= max_old_cset_length) {</span>
<span class="line-modified">498         // Added maximum number of old regions to the CSet.</span>
<span class="line-modified">499         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached max). &quot;</span>
<span class="line-modified">500                                   &quot;old %u regions, optional %u regions&quot;,</span>
<span class="line-modified">501                                   old_region_length(), optional_region_length());</span>
<span class="line-removed">502         break;</span>
<span class="line-removed">503       }</span>
<span class="line-removed">504 </span>
<span class="line-removed">505       // Stop adding regions if the remaining reclaimable space is</span>
<span class="line-removed">506       // not above G1HeapWastePercent.</span>
<span class="line-removed">507       size_t reclaimable_bytes = candidates()-&gt;remaining_reclaimable_bytes();</span>
<span class="line-removed">508       double reclaimable_percent = _policy-&gt;reclaimable_bytes_percent(reclaimable_bytes);</span>
<span class="line-removed">509       double threshold = (double) G1HeapWastePercent;</span>
<span class="line-removed">510       if (reclaimable_percent &lt;= threshold) {</span>
<span class="line-removed">511         // We&#39;ve added enough old regions that the amount of uncollected</span>
<span class="line-removed">512         // reclaimable space is at or below the waste threshold. Stop</span>
<span class="line-removed">513         // adding old regions to the CSet.</span>
<span class="line-removed">514         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (reclaimable percentage not over threshold). &quot;</span>
<span class="line-removed">515                                   &quot;reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,</span>
<span class="line-removed">516                                   byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),</span>
<span class="line-removed">517                                   reclaimable_percent, G1HeapWastePercent);</span>
<span class="line-removed">518         break;</span>
<span class="line-removed">519       }</span>
<span class="line-removed">520 </span>
<span class="line-removed">521       double predicted_time_ms = predict_region_elapsed_time_ms(hr);</span>
<span class="line-removed">522       time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);</span>
<span class="line-removed">523       // Add regions to old set until we reach minimum amount</span>
<span class="line-removed">524       if (old_region_length() &lt; min_old_cset_length) {</span>
<span class="line-removed">525         predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">526         add_as_old(hr);</span>
<span class="line-removed">527         // Record the number of regions added when no time remaining</span>
<span class="line-removed">528         if (time_remaining_ms == 0.0) {</span>
<span class="line-removed">529           expensive_region_num++;</span>
<span class="line-removed">530         }</span>
<span class="line-removed">531       } else {</span>
<span class="line-removed">532         // In the non-auto-tuning case, we&#39;ll finish adding regions</span>
<span class="line-removed">533         // to the CSet if we reach the minimum.</span>
<span class="line-removed">534         if (!check_time_remaining) {</span>
<span class="line-removed">535           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (old CSet region num reached min).&quot;);</span>
<span class="line-removed">536           break;</span>
<span class="line-removed">537         }</span>
<span class="line-removed">538         // Keep adding regions to old set until we reach optional threshold</span>
<span class="line-removed">539         if (time_remaining_ms &gt; optional_threshold_ms) {</span>
<span class="line-removed">540           predicted_old_time_ms += predicted_time_ms;</span>
<span class="line-removed">541           add_as_old(hr);</span>
<span class="line-removed">542         } else if (time_remaining_ms &gt; 0) {</span>
<span class="line-removed">543           // Keep adding optional regions until time is up</span>
<span class="line-removed">544           if (!optional_is_full()) {</span>
<span class="line-removed">545             predicted_optional_time_ms += predicted_time_ms;</span>
<span class="line-removed">546             add_as_optional(hr);</span>
<span class="line-removed">547           } else {</span>
<span class="line-removed">548             log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (optional set full).&quot;);</span>
<span class="line-removed">549             break;</span>
<span class="line-removed">550           }</span>
<span class="line-removed">551         } else {</span>
<span class="line-removed">552           log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (predicted time is too high).&quot;);</span>
<span class="line-removed">553           break;</span>
<span class="line-removed">554         }</span>
<span class="line-removed">555       }</span>
<span class="line-removed">556       hr = candidates()-&gt;peek_front();</span>
<span class="line-removed">557     }</span>
<span class="line-removed">558     if (hr == NULL) {</span>
<span class="line-removed">559       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to CSet (candidate old regions not available)&quot;);</span>
560     }
561 
562     candidates()-&gt;verify();
563   }
564 
565   stop_incremental_building();
566 
<span class="line-removed">567   log_debug(gc, ergo, cset)(&quot;Finish choosing CSet regions old: %u, optional: %u, &quot;</span>
<span class="line-removed">568                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,</span>
<span class="line-removed">569                             old_region_length(), optional_region_length(),</span>
<span class="line-removed">570                             predicted_old_time_ms, predicted_optional_time_ms, time_remaining_ms);</span>
<span class="line-removed">571   if (expensive_region_num &gt; 0) {</span>
<span class="line-removed">572     log_debug(gc, ergo, cset)(&quot;CSet contains %u old regions that were added although the predicted time was too high.&quot;,</span>
<span class="line-removed">573                               expensive_region_num);</span>
<span class="line-removed">574   }</span>
<span class="line-removed">575 </span>
576   double non_young_end_time_sec = os::elapsedTime();
577   phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
578 
579   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
580 }
581 
<span class="line-modified">582 HeapRegion* G1OptionalCSet::region_at(uint index) {</span>
<span class="line-modified">583   return _cset-&gt;optional_region_at(index);</span>













584 }
585 
<span class="line-modified">586 void G1OptionalCSet::prepare_evacuation(double time_limit) {</span>
<span class="line-modified">587   assert(_current_index == _current_limit, &quot;Before prepare no regions should be ready for evac&quot;);</span>


588 
<span class="line-modified">589   uint prepared_regions = 0;</span>
<span class="line-modified">590   double prediction_ms = 0;</span>
591 
<span class="line-modified">592   _prepare_failed = true;</span>
<span class="line-modified">593   for (uint i = _current_index; i &lt; _cset-&gt;optional_region_length(); i++) {</span>
<span class="line-modified">594     HeapRegion* hr = region_at(i);</span>
<span class="line-modified">595     prediction_ms += _cset-&gt;predict_region_elapsed_time_ms(hr);</span>
<span class="line-modified">596     if (prediction_ms &gt; time_limit) {</span>
<span class="line-removed">597       log_debug(gc, cset)(&quot;Prepared %u regions for optional evacuation. Predicted time: %.3fms&quot;, prepared_regions, prediction_ms);</span>
<span class="line-removed">598       return;</span>
<span class="line-removed">599     }</span>
600 
<span class="line-modified">601     // This region will be included in the next optional evacuation.</span>
<span class="line-removed">602     prepare_to_evacuate_optional_region(hr);</span>
<span class="line-removed">603     prepared_regions++;</span>
<span class="line-removed">604     _current_limit++;</span>
<span class="line-removed">605     _prepare_failed = false;</span>
<span class="line-removed">606   }</span>
607 
<span class="line-modified">608   log_debug(gc, cset)(&quot;Prepared all %u regions for optional evacuation. Predicted time: %.3fms&quot;,</span>
<span class="line-removed">609                       prepared_regions, prediction_ms);</span>
<span class="line-removed">610 }</span>
611 
<span class="line-modified">612 bool G1OptionalCSet::prepare_failed() {</span>
<span class="line-removed">613   return _prepare_failed;</span>
<span class="line-removed">614 }</span>
615 
<span class="line-modified">616 void G1OptionalCSet::complete_evacuation() {</span>
<span class="line-removed">617   _evacuation_failed = false;</span>
<span class="line-removed">618   for (uint i = _current_index; i &lt; _current_limit; i++) {</span>
<span class="line-removed">619     HeapRegion* hr = region_at(i);</span>
<span class="line-removed">620     _cset-&gt;clear_optional_region(hr);</span>
<span class="line-removed">621     if (hr-&gt;evacuation_failed()){</span>
<span class="line-removed">622       _evacuation_failed = true;</span>
<span class="line-removed">623     }</span>
<span class="line-removed">624   }</span>
<span class="line-removed">625   _current_index = _current_limit;</span>
<span class="line-removed">626 }</span>
627 
<span class="line-modified">628 bool G1OptionalCSet::evacuation_failed() {</span>
<span class="line-removed">629   return _evacuation_failed;</span>
630 }
631 
<span class="line-modified">632 G1OptionalCSet::~G1OptionalCSet() {</span>
<span class="line-modified">633   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified">634   while (!is_empty()) {</span>
<span class="line-modified">635     // We want to return regions not evacuated to the collection set candidates</span>
<span class="line-modified">636     // in reverse order to maintain the old order.</span>
<span class="line-modified">637     HeapRegion* hr = _cset-&gt;remove_last_optional_region();</span>
<span class="line-modified">638     assert(hr != NULL, &quot;Should be valid region left&quot;);</span>
<span class="line-modified">639     _pset-&gt;record_unused_optional_region(hr);</span>
<span class="line-modified">640     g1h-&gt;old_set_add(hr);</span>
<span class="line-removed">641     g1h-&gt;clear_in_cset(hr);</span>
<span class="line-removed">642     hr-&gt;set_index_in_opt_cset(InvalidCSetIndex);</span>
<span class="line-removed">643     _cset-&gt;candidates()-&gt;push_front(hr);</span>
644   }
<span class="line-modified">645   _cset-&gt;free_optional_regions();</span>
<span class="line-removed">646 }</span>
<span class="line-removed">647 </span>
<span class="line-removed">648 uint G1OptionalCSet::size() {</span>
<span class="line-removed">649   return _cset-&gt;optional_region_length() - _current_index;</span>
<span class="line-removed">650 }</span>
<span class="line-removed">651 </span>
<span class="line-removed">652 bool G1OptionalCSet::is_empty() {</span>
<span class="line-removed">653   return size() == 0;</span>
<span class="line-removed">654 }</span>
655 
<span class="line-modified">656 void G1OptionalCSet::prepare_to_evacuate_optional_region(HeapRegion* hr) {</span>
<span class="line-removed">657   log_trace(gc, cset)(&quot;Adding region %u for optional evacuation&quot;, hr-&gt;hrm_index());</span>
<span class="line-removed">658   G1CollectedHeap::heap()-&gt;clear_in_cset(hr);</span>
<span class="line-removed">659   _cset-&gt;add_old_region(hr);</span>
660 }
661 
662 #ifdef ASSERT
663 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
664 private:
665   size_t _young_length;
<span class="line-modified">666   int* _heap_region_indices;</span>
667 public:
668   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<span class="line-modified">669     _heap_region_indices = NEW_C_HEAP_ARRAY(int, young_length, mtGC);</span>
<span class="line-modified">670     for (size_t i = 0; i &lt; young_length; i++) {</span>
<span class="line-modified">671       _heap_region_indices[i] = -1;</span>
672     }
673   }
674   ~G1VerifyYoungCSetIndicesClosure() {
675     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
676   }
677 
678   virtual bool do_heap_region(HeapRegion* r) {
<span class="line-modified">679     const int idx = r-&gt;young_index_in_cset();</span>
680 
<span class="line-modified">681     assert(idx &gt; -1, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">682     assert((size_t)idx &lt; _young_length, &quot;Young cset index too large for region %u&quot;, r-&gt;hrm_index());</span>
683 
<span class="line-modified">684     assert(_heap_region_indices[idx] == -1,</span>
685            &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
686            idx, _heap_region_indices[idx], r-&gt;hrm_index());
687 
688     _heap_region_indices[idx] = r-&gt;hrm_index();
689 
690     return false;
691   }
692 };
693 
694 void G1CollectionSet::verify_young_cset_indices() const {
695   assert_at_safepoint_on_vm_thread();
696 
697   G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);
698   iterate(&amp;cl);
699 }
700 #endif
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
 29 #include &quot;gc/g1/g1CollectorState.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/g1/g1HotCardCache.hpp&quot;</span>
 31 #include &quot;gc/g1/g1ParScanThreadState.hpp&quot;
 32 #include &quot;gc/g1/g1Policy.hpp&quot;
 33 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
 34 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
 35 #include &quot;gc/g1/heapRegionSet.hpp&quot;
 36 #include &quot;logging/logStream.hpp&quot;
<span class="line-added"> 37 #include &quot;runtime/orderAccess.hpp&quot;</span>
 38 #include &quot;utilities/debug.hpp&quot;
 39 #include &quot;utilities/globalDefinitions.hpp&quot;
 40 #include &quot;utilities/quickSort.hpp&quot;
 41 
<span class="line-modified"> 42 G1CollectorState* G1CollectionSet::collector_state() const {</span>
 43   return _g1h-&gt;collector_state();
 44 }
 45 
 46 G1GCPhaseTimes* G1CollectionSet::phase_times() {
 47   return _policy-&gt;phase_times();
 48 }
 49 
<span class="line-modified"> 50 double G1CollectionSet::predict_region_non_copy_time_ms(HeapRegion* hr) const {</span>
<span class="line-modified"> 51   return _policy-&gt;predict_region_non_copy_time_ms(hr, collector_state()-&gt;in_young_only_phase());</span>
 52 }
 53 
 54 G1CollectionSet::G1CollectionSet(G1CollectedHeap* g1h, G1Policy* policy) :
 55   _g1h(g1h),
 56   _policy(policy),
 57   _candidates(NULL),
 58   _eden_region_length(0),
 59   _survivor_region_length(0),
 60   _old_region_length(0),
 61   _collection_set_regions(NULL),
 62   _collection_set_cur_length(0),
 63   _collection_set_max_length(0),
<span class="line-modified"> 64   _num_optional_regions(0),</span>


 65   _bytes_used_before(0),
<span class="line-modified"> 66   _recorded_rs_length(0),</span>
 67   _inc_build_state(Inactive),
<span class="line-added"> 68   _inc_part_start(0),</span>
<span class="line-added"> 69   _inc_collection_set_stats(NULL),</span>
 70   _inc_bytes_used_before(0),
<span class="line-modified"> 71   _inc_recorded_rs_length(0),</span>
<span class="line-modified"> 72   _inc_recorded_rs_length_diff(0),</span>
<span class="line-modified"> 73   _inc_predicted_non_copy_time_ms(0.0),</span>
<span class="line-modified"> 74   _inc_predicted_non_copy_time_ms_diff(0.0) {</span>
 75 }
 76 
 77 G1CollectionSet::~G1CollectionSet() {
<span class="line-modified"> 78   FREE_C_HEAP_ARRAY(uint, _collection_set_regions);</span>
<span class="line-modified"> 79   FREE_C_HEAP_ARRAY(IncCollectionSetRegionStat, _inc_collection_set_stats);</span>

 80   free_optional_regions();
 81   clear_candidates();
 82 }
 83 
 84 void G1CollectionSet::init_region_lengths(uint eden_cset_region_length,
 85                                           uint survivor_cset_region_length) {
 86   assert_at_safepoint_on_vm_thread();
 87 
 88   _eden_region_length     = eden_cset_region_length;
 89   _survivor_region_length = survivor_cset_region_length;
 90 
 91   assert((size_t) young_region_length() == _collection_set_cur_length,
 92          &quot;Young region length %u should match collection set length &quot; SIZE_FORMAT, young_region_length(), _collection_set_cur_length);
 93 
<span class="line-modified"> 94   _old_region_length = 0;</span>
<span class="line-modified"> 95   free_optional_regions();</span>
 96 }
 97 
 98 void G1CollectionSet::initialize(uint max_region_length) {
 99   guarantee(_collection_set_regions == NULL, &quot;Must only initialize once.&quot;);
100   _collection_set_max_length = max_region_length;
101   _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);
<span class="line-modified">102   _inc_collection_set_stats = NEW_C_HEAP_ARRAY(IncCollectionSetRegionStat, max_region_length, mtGC);</span>







103 }
104 
105 void G1CollectionSet::free_optional_regions() {
<span class="line-modified">106   _num_optional_regions = 0;</span>





107 }
108 
109 void G1CollectionSet::clear_candidates() {
110   delete _candidates;
111   _candidates = NULL;
112 }
113 
<span class="line-modified">114 void G1CollectionSet::set_recorded_rs_length(size_t rs_length) {</span>
<span class="line-modified">115   _recorded_rs_length = rs_length;</span>
116 }
117 
118 // Add the heap region at the head of the non-incremental collection set
119 void G1CollectionSet::add_old_region(HeapRegion* hr) {
120   assert_at_safepoint_on_vm_thread();
121 
<span class="line-modified">122   assert(_inc_build_state == Active,</span>
123          &quot;Precondition, actively building cset or adding optional later on&quot;);
124   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
125 
<span class="line-modified">126   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the collection set&quot;);</span>
<span class="line-modified">127   _g1h-&gt;register_old_region_with_region_attr(hr);</span>
128 
129   _collection_set_regions[_collection_set_cur_length++] = hr-&gt;hrm_index();
130   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set now larger than maximum size.&quot;);
131 
132   _bytes_used_before += hr-&gt;used();
<span class="line-modified">133   _recorded_rs_length += hr-&gt;rem_set()-&gt;occupied();</span>
<span class="line-modified">134   _old_region_length++;</span>

135 
<span class="line-modified">136   _g1h-&gt;old_set_remove(hr);</span>
137 }
138 
139 void G1CollectionSet::add_optional_region(HeapRegion* hr) {

140   assert(hr-&gt;is_old(), &quot;the region should be old&quot;);
141   assert(!hr-&gt;in_collection_set(), &quot;should not already be in the CSet&quot;);
142 
<span class="line-modified">143   _g1h-&gt;register_optional_region_with_region_attr(hr);</span>
144 
<span class="line-modified">145   hr-&gt;set_index_in_opt_cset(_num_optional_regions++);</span>




146 }
147 

148 void G1CollectionSet::start_incremental_building() {
149   assert(_collection_set_cur_length == 0, &quot;Collection set must be empty before starting a new collection set.&quot;);
150   assert(_inc_build_state == Inactive, &quot;Precondition&quot;);
<span class="line-added">151 #ifdef ASSERT</span>
<span class="line-added">152   for (size_t i = 0; i &lt; _collection_set_max_length; i++) {</span>
<span class="line-added">153     _inc_collection_set_stats[i].reset();</span>
<span class="line-added">154   }</span>
<span class="line-added">155 #endif</span>
156 
157   _inc_bytes_used_before = 0;
158 
<span class="line-modified">159   _inc_recorded_rs_length = 0;</span>
<span class="line-modified">160   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">161   _inc_predicted_non_copy_time_ms = 0.0;</span>
<span class="line-modified">162   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
<span class="line-modified">163 </span>
<span class="line-added">164   update_incremental_marker();</span>
165 }
166 
167 void G1CollectionSet::finalize_incremental_building() {
168   assert(_inc_build_state == Active, &quot;Precondition&quot;);
169   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at a safepoint&quot;);
170 
<span class="line-modified">171   // The two &quot;main&quot; fields, _inc_recorded_rs_length and</span>
<span class="line-modified">172   // _inc_predicted_non_copy_time_ms, are updated by the thread</span>
173   // that adds a new region to the CSet. Further updates by the
174   // concurrent refinement thread that samples the young RSet lengths
<span class="line-modified">175   // are accumulated in the *_diff fields. Here we add the diffs to</span>
176   // the &quot;main&quot; fields.
177 
<span class="line-modified">178   _inc_recorded_rs_length += _inc_recorded_rs_length_diff;</span>
<span class="line-modified">179   _inc_predicted_non_copy_time_ms += _inc_predicted_non_copy_time_ms_diff;</span>














180 
<span class="line-modified">181   _inc_recorded_rs_length_diff = 0;</span>
<span class="line-modified">182   _inc_predicted_non_copy_time_ms_diff = 0.0;</span>
183 }
184 
185 void G1CollectionSet::clear() {
186   assert_at_safepoint_on_vm_thread();
187   _collection_set_cur_length = 0;

188 }
189 
190 void G1CollectionSet::iterate(HeapRegionClosure* cl) const {




191   size_t len = _collection_set_cur_length;
192   OrderAccess::loadload();





193 
<span class="line-modified">194   for (uint i = 0; i &lt; len; i++) {</span>
<span class="line-modified">195     HeapRegion* r = _g1h-&gt;region_at(_collection_set_regions[i]);</span>
196     bool result = cl-&gt;do_heap_region(r);
197     if (result) {
198       cl-&gt;set_incomplete();
199       return;
200     }
<span class="line-added">201   }</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 void G1CollectionSet::par_iterate(HeapRegionClosure* cl,</span>
<span class="line-added">205                                   HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">206                                   uint worker_id,</span>
<span class="line-added">207                                   uint total_workers) const {</span>
<span class="line-added">208   iterate_part_from(cl, hr_claimer, 0, cur_length(), worker_id, total_workers);</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 void G1CollectionSet::iterate_optional(HeapRegionClosure* cl) const {</span>
<span class="line-added">212   assert_at_safepoint();</span>
<span class="line-added">213 </span>
<span class="line-added">214   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-added">215     HeapRegion* r = _candidates-&gt;at(i);</span>
<span class="line-added">216     bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">217     guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">218   }</span>
<span class="line-added">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 void G1CollectionSet::iterate_incremental_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">222                                                     HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">223                                                     uint worker_id,</span>
<span class="line-added">224                                                     uint total_workers) const {</span>
<span class="line-added">225   iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id, total_workers);</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void G1CollectionSet::iterate_part_from(HeapRegionClosure* cl,</span>
<span class="line-added">229                                         HeapRegionClaimer* hr_claimer,</span>
<span class="line-added">230                                         size_t offset,</span>
<span class="line-added">231                                         size_t length,</span>
<span class="line-added">232                                         uint worker_id,</span>
<span class="line-added">233                                         uint total_workers) const {</span>
<span class="line-added">234   assert_at_safepoint();</span>
<span class="line-added">235   if (length == 0) {</span>
<span class="line-added">236     return;</span>
<span class="line-added">237   }</span>
<span class="line-added">238 </span>
<span class="line-added">239   size_t start_pos = (worker_id * length) / total_workers;</span>
<span class="line-added">240   size_t cur_pos = start_pos;</span>
<span class="line-added">241 </span>
<span class="line-added">242   do {</span>
<span class="line-added">243     uint region_idx = _collection_set_regions[cur_pos + offset];</span>
<span class="line-added">244     if (hr_claimer == NULL || hr_claimer-&gt;claim_region(region_idx)) {</span>
<span class="line-added">245       HeapRegion* r = _g1h-&gt;region_at(region_idx);</span>
<span class="line-added">246       bool result = cl-&gt;do_heap_region(r);</span>
<span class="line-added">247       guarantee(!result, &quot;Must not cancel iteration&quot;);</span>
<span class="line-added">248     }</span>
<span class="line-added">249 </span>
250     cur_pos++;
<span class="line-modified">251     if (cur_pos == length) {</span>
252       cur_pos = 0;
253     }
254   } while (cur_pos != start_pos);
255 }
256 
257 void G1CollectionSet::update_young_region_prediction(HeapRegion* hr,
258                                                      size_t new_rs_length) {
259   // Update the CSet information that is dependent on the new RS length
260   assert(hr-&gt;is_young(), &quot;Precondition&quot;);
261   assert(!SafepointSynchronize::is_at_safepoint(), &quot;should not be at a safepoint&quot;);
262 
<span class="line-modified">263   IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>







264 
<span class="line-modified">265   size_t old_rs_length = stat-&gt;_rs_length;</span>
<span class="line-modified">266   assert(old_rs_length &lt;= new_rs_length,</span>
<span class="line-modified">267          &quot;Remembered set decreased (changed from &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT &quot; region %u type %s)&quot;,</span>
<span class="line-added">268          old_rs_length, new_rs_length, hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
<span class="line-added">269   size_t rs_length_diff = new_rs_length - old_rs_length;</span>
<span class="line-added">270   stat-&gt;_rs_length = new_rs_length;</span>
<span class="line-added">271   _inc_recorded_rs_length_diff += rs_length_diff;</span>
272 
<span class="line-modified">273   double old_non_copy_time = stat-&gt;_non_copy_time_ms;</span>
<span class="line-modified">274   assert(old_non_copy_time &gt;= 0.0, &quot;Non copy time for region %u not initialized yet, is %.3f&quot;, hr-&gt;hrm_index(), old_non_copy_time);</span>
<span class="line-modified">275   double new_non_copy_time = predict_region_non_copy_time_ms(hr);</span>
<span class="line-modified">276   double non_copy_time_ms_diff = new_non_copy_time - old_non_copy_time;</span>
277 
<span class="line-modified">278   stat-&gt;_non_copy_time_ms = new_non_copy_time;</span>
<span class="line-modified">279   _inc_predicted_non_copy_time_ms_diff += non_copy_time_ms_diff;</span>
280 }
281 
282 void G1CollectionSet::add_young_region_common(HeapRegion* hr) {
283   assert(hr-&gt;is_young(), &quot;invariant&quot;);
284   assert(_inc_build_state == Active, &quot;Precondition&quot;);
285 











286   // This routine is used when:
287   // * adding survivor regions to the incremental cset at the end of an
288   //   evacuation pause or
289   // * adding the current allocation region to the incremental cset
290   //   when it is retired.
291   // Therefore this routine may be called at a safepoint by the
292   // VM thread, or in-between safepoints by mutator threads (when
293   // retiring the current allocation region)
294   // We need to clear and set the cached recorded/cached collection set
295   // information in the heap region here (before the region gets added
296   // to the collection set). An individual heap region&#39;s cached values
297   // are calculated, aggregated with the policy collection set info,
298   // and cached in the heap region here (initially) and (subsequently)
299   // by the Young List sampling code.
300   // Ignore calls to this due to retirement during full gc.
301 
302   if (!_g1h-&gt;collector_state()-&gt;in_full_gc()) {
303     size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
<span class="line-modified">304     double non_copy_time = predict_region_non_copy_time_ms(hr);</span>
305 
306     // Cache the values we have added to the aggregated information
307     // in the heap region in case we have to remove this region from
308     // the incremental collection set, or it is updated by the
309     // rset sampling code


310 
<span class="line-modified">311     IncCollectionSetRegionStat* stat = &amp;_inc_collection_set_stats[hr-&gt;hrm_index()];</span>
<span class="line-modified">312     stat-&gt;_rs_length = rs_length;</span>
<span class="line-added">313     stat-&gt;_non_copy_time_ms = non_copy_time;</span>
<span class="line-added">314 </span>
<span class="line-added">315     _inc_recorded_rs_length += rs_length;</span>
<span class="line-added">316     _inc_predicted_non_copy_time_ms += non_copy_time;</span>
317     _inc_bytes_used_before += hr-&gt;used();
318   }
319 
320   assert(!hr-&gt;in_collection_set(), &quot;invariant&quot;);
<span class="line-modified">321   _g1h-&gt;register_young_region_with_region_attr(hr);</span>
<span class="line-added">322 </span>
<span class="line-added">323   // We use UINT_MAX as &quot;invalid&quot; marker in verification.</span>
<span class="line-added">324   assert(_collection_set_cur_length &lt; (UINT_MAX - 1),</span>
<span class="line-added">325          &quot;Collection set is too large with &quot; SIZE_FORMAT &quot; entries&quot;, _collection_set_cur_length);</span>
<span class="line-added">326   hr-&gt;set_young_index_in_cset((uint)_collection_set_cur_length + 1);</span>
<span class="line-added">327 </span>
<span class="line-added">328   _collection_set_regions[_collection_set_cur_length] = hr-&gt;hrm_index();</span>
<span class="line-added">329   // Concurrent readers must observe the store of the value in the array before an</span>
<span class="line-added">330   // update to the length field.</span>
<span class="line-added">331   OrderAccess::storestore();</span>
<span class="line-added">332   _collection_set_cur_length++;</span>
<span class="line-added">333   assert(_collection_set_cur_length &lt;= _collection_set_max_length, &quot;Collection set larger than maximum allowed.&quot;);</span>
334 }
335 
336 void G1CollectionSet::add_survivor_regions(HeapRegion* hr) {
337   assert(hr-&gt;is_survivor(), &quot;Must only add survivor regions, but is %s&quot;, hr-&gt;get_type_str());
338   add_young_region_common(hr);
339 }
340 
341 void G1CollectionSet::add_eden_region(HeapRegion* hr) {
342   assert(hr-&gt;is_eden(), &quot;Must only add eden regions, but is %s&quot;, hr-&gt;get_type_str());
343   add_young_region_common(hr);
344 }
345 
346 #ifndef PRODUCT
347 class G1VerifyYoungAgesClosure : public HeapRegionClosure {
348 public:
349   bool _valid;
<span class="line-modified">350 </span>
351   G1VerifyYoungAgesClosure() : HeapRegionClosure(), _valid(true) { }
352 
353   virtual bool do_heap_region(HeapRegion* r) {
354     guarantee(r-&gt;is_young(), &quot;Region must be young but is %s&quot;, r-&gt;get_type_str());
355 
<span class="line-modified">356     if (!r-&gt;has_surv_rate_group()) {</span>
<span class="line-modified">357       log_error(gc, verify)(&quot;## encountered young region without surv_rate_group&quot;);</span>


358       _valid = false;
359     }
360 
<span class="line-modified">361     if (!r-&gt;has_valid_age_in_surv_rate()) {</span>
<span class="line-modified">362       log_error(gc, verify)(&quot;## encountered invalid age in young region&quot;);</span>
363       _valid = false;
364     }
365 
366     return false;
367   }
368 
369   bool valid() const { return _valid; }
370 };
371 
372 bool G1CollectionSet::verify_young_ages() {
373   assert_at_safepoint_on_vm_thread();
374 
375   G1VerifyYoungAgesClosure cl;
376   iterate(&amp;cl);
377 
378   if (!cl.valid()) {
379     LogStreamHandle(Error, gc, verify) log;
380     print(&amp;log);
381   }
382 
383   return cl.valid();
384 }
385 
386 class G1PrintCollectionSetDetailClosure : public HeapRegionClosure {
387   outputStream* _st;
388 public:
389   G1PrintCollectionSetDetailClosure(outputStream* st) : HeapRegionClosure(), _st(st) { }
390 
391   virtual bool do_heap_region(HeapRegion* r) {
392     assert(r-&gt;in_collection_set(), &quot;Region %u should be in collection set&quot;, r-&gt;hrm_index());
393     _st-&gt;print_cr(&quot;  &quot; HR_FORMAT &quot;, P: &quot; PTR_FORMAT &quot;N: &quot; PTR_FORMAT &quot;, age: %4d&quot;,
394                   HR_FORMAT_PARAMS(r),
395                   p2i(r-&gt;prev_top_at_mark_start()),
396                   p2i(r-&gt;next_top_at_mark_start()),
<span class="line-modified">397                   r-&gt;has_surv_rate_group() ? r-&gt;age_in_surv_rate_group() : -1);</span>
398     return false;
399   }
400 };
401 
402 void G1CollectionSet::print(outputStream* st) {
403   st-&gt;print_cr(&quot;\nCollection_set:&quot;);
404 
405   G1PrintCollectionSetDetailClosure cl(st);
406   iterate(&amp;cl);
407 }
408 #endif // !PRODUCT
409 
410 double G1CollectionSet::finalize_young_part(double target_pause_time_ms, G1SurvivorRegions* survivors) {
<span class="line-modified">411   Ticks start_time = Ticks::now();</span>
412 
413   finalize_incremental_building();
414 
415   guarantee(target_pause_time_ms &gt; 0.0,
416             &quot;target_pause_time_ms = %1.6lf should be positive&quot;, target_pause_time_ms);
417 
<span class="line-modified">418   size_t pending_cards = _policy-&gt;pending_cards_at_gc_start() + _g1h-&gt;hot_card_cache()-&gt;num_entries();</span>


419 
<span class="line-modified">420   log_trace(gc, ergo, cset)(&quot;Start choosing CSet. Pending cards: &quot; SIZE_FORMAT &quot; target pause time: %1.2fms&quot;,</span>
<span class="line-modified">421                             pending_cards, target_pause_time_ms);</span>
422 
423   // The young list is laid with the survivor regions from the previous
424   // pause are appended to the RHS of the young list, i.e.
425   //   [Newly Young Regions ++ Survivors from last pause].
426 

427   uint eden_region_length = _g1h-&gt;eden_regions_count();
<span class="line-added">428   uint survivor_region_length = survivors-&gt;length();</span>
429   init_region_lengths(eden_region_length, survivor_region_length);
430 
431   verify_young_cset_indices();
432 
433   // Clear the fields that point to the survivor list - they are all young now.
434   survivors-&gt;convert_to_eden();
435 
436   _bytes_used_before = _inc_bytes_used_before;




437 
438   // The number of recorded young regions is the incremental
439   // collection set&#39;s current size
<span class="line-modified">440   set_recorded_rs_length(_inc_recorded_rs_length);</span>






441 
<span class="line-modified">442   double predicted_base_time_ms = _policy-&gt;predict_base_elapsed_time_ms(pending_cards);</span>
<span class="line-modified">443   double predicted_eden_time = _inc_predicted_non_copy_time_ms + _policy-&gt;predict_eden_copy_time_ms(eden_region_length);</span>
<span class="line-modified">444   double remaining_time_ms = MAX2(target_pause_time_ms - (predicted_base_time_ms + predicted_eden_time), 0.0);</span>


445 
<span class="line-modified">446   log_trace(gc, ergo, cset)(&quot;Added young regions to CSet. Eden: %u regions, Survivors: %u regions, &quot;</span>
<span class="line-modified">447                             &quot;predicted eden time: %1.2fms, predicted base time: %1.2fms, target pause time: %1.2fms, remaining time: %1.2fms&quot;,</span>
<span class="line-modified">448                             eden_region_length, survivor_region_length,</span>
<span class="line-modified">449                             predicted_eden_time, predicted_base_time_ms, target_pause_time_ms, remaining_time_ms);</span>


450 
<span class="line-modified">451   phase_times()-&gt;record_young_cset_choice_time_ms((Ticks::now() - start_time).seconds() * 1000.0);</span>



452 
<span class="line-modified">453   return remaining_time_ms;</span>



454 }
455 
456 static int compare_region_idx(const uint a, const uint b) {
457   if (a &gt; b) {
458     return 1;
459   } else if (a == b) {
460     return 0;
461   } else {
462     return -1;
463   }
464 }
465 
466 void G1CollectionSet::finalize_old_part(double time_remaining_ms) {
467   double non_young_start_time_sec = os::elapsedTime();




468 
469   if (collector_state()-&gt;in_mixed_phase()) {
470     candidates()-&gt;verify();
<span class="line-modified">471 </span>
<span class="line-modified">472     uint num_initial_old_regions;</span>
<span class="line-modified">473     uint num_optional_old_regions;</span>
<span class="line-modified">474 </span>
<span class="line-modified">475     _policy-&gt;calculate_old_collection_set_regions(candidates(),</span>
<span class="line-modified">476                                                   time_remaining_ms,</span>
<span class="line-modified">477                                                   num_initial_old_regions,</span>
<span class="line-modified">478                                                   num_optional_old_regions);</span>
<span class="line-modified">479 </span>
<span class="line-modified">480     // Prepare initial old regions.</span>
<span class="line-modified">481     move_candidates_to_collection_set(num_initial_old_regions);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483     // Prepare optional old regions for evacuation.</span>
<span class="line-modified">484     uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-modified">485     for (uint i = 0; i &lt; num_optional_old_regions; i++) {</span>
<span class="line-modified">486       add_optional_region(candidates()-&gt;at(candidate_idx + i));</span>


























































487     }
488 
489     candidates()-&gt;verify();
490   }
491 
492   stop_incremental_building();
493 









494   double non_young_end_time_sec = os::elapsedTime();
495   phase_times()-&gt;record_non_young_cset_choice_time_ms((non_young_end_time_sec - non_young_start_time_sec) * 1000.0);
496 
497   QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx, true);
498 }
499 
<span class="line-modified">500 void G1CollectionSet::move_candidates_to_collection_set(uint num_old_candidate_regions) {</span>
<span class="line-modified">501   if (num_old_candidate_regions == 0) {</span>
<span class="line-added">502     return;</span>
<span class="line-added">503   }</span>
<span class="line-added">504   uint candidate_idx = candidates()-&gt;cur_idx();</span>
<span class="line-added">505   for (uint i = 0; i &lt; num_old_candidate_regions; i++) {</span>
<span class="line-added">506     HeapRegion* r = candidates()-&gt;at(candidate_idx + i);</span>
<span class="line-added">507     // This potentially optional candidate region is going to be an actual collection</span>
<span class="line-added">508     // set region. Clear cset marker.</span>
<span class="line-added">509     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-added">510     add_old_region(r);</span>
<span class="line-added">511   }</span>
<span class="line-added">512   candidates()-&gt;remove(num_old_candidate_regions);</span>
<span class="line-added">513 </span>
<span class="line-added">514   candidates()-&gt;verify();</span>
515 }
516 
<span class="line-modified">517 void G1CollectionSet::finalize_initial_collection_set(double target_pause_time_ms, G1SurvivorRegions* survivor) {</span>
<span class="line-modified">518   double time_remaining_ms = finalize_young_part(target_pause_time_ms, survivor);</span>
<span class="line-added">519   finalize_old_part(time_remaining_ms);</span>
<span class="line-added">520 }</span>
521 
<span class="line-modified">522 bool G1CollectionSet::finalize_optional_for_evacuation(double remaining_pause_time) {</span>
<span class="line-modified">523   update_incremental_marker();</span>
524 
<span class="line-modified">525   uint num_selected_regions;</span>
<span class="line-modified">526   _policy-&gt;calculate_optional_collection_set_regions(candidates(),</span>
<span class="line-modified">527                                                      _num_optional_regions,</span>
<span class="line-modified">528                                                      remaining_pause_time,</span>
<span class="line-modified">529                                                      num_selected_regions);</span>



530 
<span class="line-modified">531   move_candidates_to_collection_set(num_selected_regions);</span>





532 
<span class="line-modified">533   _num_optional_regions -= num_selected_regions;</span>


534 
<span class="line-modified">535   stop_incremental_building();</span>


536 
<span class="line-modified">537   _g1h-&gt;verify_region_attr_remset_update();</span>










538 
<span class="line-modified">539   return num_selected_regions &gt; 0;</span>

540 }
541 
<span class="line-modified">542 void G1CollectionSet::abandon_optional_collection_set(G1ParScanThreadStateSet* pss) {</span>
<span class="line-modified">543   for (uint i = 0; i &lt; _num_optional_regions; i++) {</span>
<span class="line-modified">544     HeapRegion* r = candidates()-&gt;at(candidates()-&gt;cur_idx() + i);</span>
<span class="line-modified">545     pss-&gt;record_unused_optional_region(r);</span>
<span class="line-modified">546     // Clear collection set marker and make sure that the remembered set information</span>
<span class="line-modified">547     // is correct as we still need it later.</span>
<span class="line-modified">548     _g1h-&gt;clear_region_attr(r);</span>
<span class="line-modified">549     _g1h-&gt;register_region_with_region_attr(r);</span>
<span class="line-modified">550     r-&gt;clear_index_in_opt_cset();</span>



551   }
<span class="line-modified">552   free_optional_regions();</span>









553 
<span class="line-modified">554   _g1h-&gt;verify_region_attr_remset_update();</span>



555 }
556 
557 #ifdef ASSERT
558 class G1VerifyYoungCSetIndicesClosure : public HeapRegionClosure {
559 private:
560   size_t _young_length;
<span class="line-modified">561   uint* _heap_region_indices;</span>
562 public:
563   G1VerifyYoungCSetIndicesClosure(size_t young_length) : HeapRegionClosure(), _young_length(young_length) {
<span class="line-modified">564     _heap_region_indices = NEW_C_HEAP_ARRAY(uint, young_length + 1, mtGC);</span>
<span class="line-modified">565     for (size_t i = 0; i &lt; young_length + 1; i++) {</span>
<span class="line-modified">566       _heap_region_indices[i] = UINT_MAX;</span>
567     }
568   }
569   ~G1VerifyYoungCSetIndicesClosure() {
570     FREE_C_HEAP_ARRAY(int, _heap_region_indices);
571   }
572 
573   virtual bool do_heap_region(HeapRegion* r) {
<span class="line-modified">574     const uint idx = r-&gt;young_index_in_cset();</span>
575 
<span class="line-modified">576     assert(idx &gt; 0, &quot;Young index must be set for all regions in the incremental collection set but is not for region %u.&quot;, r-&gt;hrm_index());</span>
<span class="line-modified">577     assert(idx &lt;= _young_length, &quot;Young cset index %u too large for region %u&quot;, idx, r-&gt;hrm_index());</span>
578 
<span class="line-modified">579     assert(_heap_region_indices[idx] == UINT_MAX,</span>
580            &quot;Index %d used by multiple regions, first use by region %u, second by region %u&quot;,
581            idx, _heap_region_indices[idx], r-&gt;hrm_index());
582 
583     _heap_region_indices[idx] = r-&gt;hrm_index();
584 
585     return false;
586   }
587 };
588 
589 void G1CollectionSet::verify_young_cset_indices() const {
590   assert_at_safepoint_on_vm_thread();
591 
592   G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);
593   iterate(&amp;cl);
594 }
595 #endif
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectedHeap.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectionSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
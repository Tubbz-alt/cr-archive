<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1ConcurrentMark.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTMARK_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTMARK_HPP
 27 
 28 #include &quot;gc/g1/g1ConcurrentMarkBitMap.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMarkObjArrayProcessor.hpp&quot;
 30 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
 31 #include &quot;gc/g1/g1RegionMarkStatsCache.hpp&quot;
 32 #include &quot;gc/g1/heapRegionSet.hpp&quot;
<a name="2" id="anc2"></a>
 33 #include &quot;gc/shared/taskqueue.hpp&quot;
<a name="3" id="anc3"></a>

 34 #include &quot;memory/allocation.hpp&quot;
 35 #include &quot;utilities/compilerWarnings.hpp&quot;
 36 
 37 class ConcurrentGCTimer;
 38 class G1ConcurrentMarkThread;
 39 class G1CollectedHeap;
 40 class G1CMOopClosure;
 41 class G1CMTask;
 42 class G1ConcurrentMark;
 43 class G1OldTracer;
 44 class G1RegionToSpaceMapper;
 45 class G1SurvivorRegions;
<a name="4" id="anc4"></a>
 46 
 47 PRAGMA_DIAG_PUSH
 48 // warning C4522: multiple assignment operators specified
 49 PRAGMA_DISABLE_MSVC_WARNING(4522)
 50 
 51 // This is a container class for either an oop or a continuation address for
 52 // mark stack entries. Both are pushed onto the mark stack.
 53 class G1TaskQueueEntry {
 54 private:
 55   void* _holder;
 56 
 57   static const uintptr_t ArraySliceBit = 1;
 58 
 59   G1TaskQueueEntry(oop obj) : _holder(obj) {
 60     assert(_holder != NULL, &quot;Not allowed to set NULL task queue element&quot;);
 61   }
 62   G1TaskQueueEntry(HeapWord* addr) : _holder((void*)((uintptr_t)addr | ArraySliceBit)) { }
 63 public:
 64   G1TaskQueueEntry(const G1TaskQueueEntry&amp; other) { _holder = other._holder; }
 65   G1TaskQueueEntry() : _holder(NULL) { }
 66 
 67   static G1TaskQueueEntry from_slice(HeapWord* what) { return G1TaskQueueEntry(what); }
 68   static G1TaskQueueEntry from_oop(oop obj) { return G1TaskQueueEntry(obj); }
 69 
 70   G1TaskQueueEntry&amp; operator=(const G1TaskQueueEntry&amp; t) {
 71     _holder = t._holder;
 72     return *this;
 73   }
 74 
 75   volatile G1TaskQueueEntry&amp; operator=(const volatile G1TaskQueueEntry&amp; t) volatile {
 76     _holder = t._holder;
 77     return *this;
 78   }
 79 
 80   oop obj() const {
 81     assert(!is_array_slice(), &quot;Trying to read array slice &quot; PTR_FORMAT &quot; as oop&quot;, p2i(_holder));
 82     return (oop)_holder;
 83   }
 84 
 85   HeapWord* slice() const {
 86     assert(is_array_slice(), &quot;Trying to read oop &quot; PTR_FORMAT &quot; as array slice&quot;, p2i(_holder));
 87     return (HeapWord*)((uintptr_t)_holder &amp; ~ArraySliceBit);
 88   }
 89 
 90   bool is_oop() const { return !is_array_slice(); }
 91   bool is_array_slice() const { return ((uintptr_t)_holder &amp; ArraySliceBit) != 0; }
 92   bool is_null() const { return _holder == NULL; }
 93 };
 94 
 95 PRAGMA_DIAG_POP
 96 
 97 typedef GenericTaskQueue&lt;G1TaskQueueEntry, mtGC&gt; G1CMTaskQueue;
 98 typedef GenericTaskQueueSet&lt;G1CMTaskQueue, mtGC&gt; G1CMTaskQueueSet;
 99 
100 // Closure used by CM during concurrent reference discovery
101 // and reference processing (during remarking) to determine
102 // if a particular object is alive. It is primarily used
103 // to determine if referents of discovered reference objects
104 // are alive. An instance is also embedded into the
105 // reference processor as the _is_alive_non_header field
106 class G1CMIsAliveClosure : public BoolObjectClosure {
107   G1CollectedHeap* _g1h;
108 public:
109   G1CMIsAliveClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }
110   bool do_object_b(oop obj);
111 };
112 
113 class G1CMSubjectToDiscoveryClosure : public BoolObjectClosure {
114   G1CollectedHeap* _g1h;
115 public:
116   G1CMSubjectToDiscoveryClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }
117   bool do_object_b(oop obj);
118 };
119 
120 // Represents the overflow mark stack used by concurrent marking.
121 //
122 // Stores oops in a huge buffer in virtual memory that is always fully committed.
123 // Resizing may only happen during a STW pause when the stack is empty.
124 //
125 // Memory is allocated on a &quot;chunk&quot; basis, i.e. a set of oops. For this, the mark
126 // stack memory is split into evenly sized chunks of oops. Users can only
127 // add or remove entries on that basis.
128 // Chunks are filled in increasing address order. Not completely filled chunks
129 // have a NULL element as a terminating element.
130 //
131 // Every chunk has a header containing a single pointer element used for memory
132 // management. This wastes some space, but is negligible (&lt; .1% with current sizing).
133 //
134 // Memory management is done using a mix of tracking a high water-mark indicating
135 // that all chunks at a lower address are valid chunks, and a singly linked free
136 // list connecting all empty chunks.
137 class G1CMMarkStack {
138 public:
139   // Number of TaskQueueEntries that can fit in a single chunk.
140   static const size_t EntriesPerChunk = 1024 - 1 /* One reference for the next pointer */;
141 private:
142   struct TaskQueueEntryChunk {
143     TaskQueueEntryChunk* next;
144     G1TaskQueueEntry data[EntriesPerChunk];
145   };
146 
147   size_t _max_chunk_capacity;    // Maximum number of TaskQueueEntryChunk elements on the stack.
148 
149   TaskQueueEntryChunk* _base;    // Bottom address of allocated memory area.
150   size_t _chunk_capacity;        // Current maximum number of TaskQueueEntryChunk elements.
151 
152   char _pad0[DEFAULT_CACHE_LINE_SIZE];
153   TaskQueueEntryChunk* volatile _free_list;  // Linked list of free chunks that can be allocated by users.
154   char _pad1[DEFAULT_CACHE_LINE_SIZE - sizeof(TaskQueueEntryChunk*)];
155   TaskQueueEntryChunk* volatile _chunk_list; // List of chunks currently containing data.
156   volatile size_t _chunks_in_chunk_list;
157   char _pad2[DEFAULT_CACHE_LINE_SIZE - sizeof(TaskQueueEntryChunk*) - sizeof(size_t)];
158 
159   volatile size_t _hwm;          // High water mark within the reserved space.
160   char _pad4[DEFAULT_CACHE_LINE_SIZE - sizeof(size_t)];
161 
162   // Allocate a new chunk from the reserved memory, using the high water mark. Returns
163   // NULL if out of memory.
164   TaskQueueEntryChunk* allocate_new_chunk();
165 
166   // Atomically add the given chunk to the list.
167   void add_chunk_to_list(TaskQueueEntryChunk* volatile* list, TaskQueueEntryChunk* elem);
168   // Atomically remove and return a chunk from the given list. Returns NULL if the
169   // list is empty.
170   TaskQueueEntryChunk* remove_chunk_from_list(TaskQueueEntryChunk* volatile* list);
171 
172   void add_chunk_to_chunk_list(TaskQueueEntryChunk* elem);
173   void add_chunk_to_free_list(TaskQueueEntryChunk* elem);
174 
175   TaskQueueEntryChunk* remove_chunk_from_chunk_list();
176   TaskQueueEntryChunk* remove_chunk_from_free_list();
177 
178   // Resizes the mark stack to the given new capacity. Releases any previous
179   // memory if successful.
180   bool resize(size_t new_capacity);
181 
182  public:
183   G1CMMarkStack();
184   ~G1CMMarkStack();
185 
186   // Alignment and minimum capacity of this mark stack in number of oops.
187   static size_t capacity_alignment();
188 
189   // Allocate and initialize the mark stack with the given number of oops.
190   bool initialize(size_t initial_capacity, size_t max_capacity);
191 
192   // Pushes the given buffer containing at most EntriesPerChunk elements on the mark
193   // stack. If less than EntriesPerChunk elements are to be pushed, the array must
194   // be terminated with a NULL.
195   // Returns whether the buffer contents were successfully pushed to the global mark
196   // stack.
197   bool par_push_chunk(G1TaskQueueEntry* buffer);
198 
199   // Pops a chunk from this mark stack, copying them into the given buffer. This
200   // chunk may contain up to EntriesPerChunk elements. If there are less, the last
201   // element in the array is a NULL pointer.
202   bool par_pop_chunk(G1TaskQueueEntry* buffer);
203 
204   // Return whether the chunk list is empty. Racy due to unsynchronized access to
205   // _chunk_list.
206   bool is_empty() const { return _chunk_list == NULL; }
207 
208   size_t capacity() const  { return _chunk_capacity; }
209 
210   // Expand the stack, typically in response to an overflow condition
211   void expand();
212 
213   // Return the approximate number of oops on this mark stack. Racy due to
214   // unsynchronized access to _chunks_in_chunk_list.
215   size_t size() const { return _chunks_in_chunk_list * EntriesPerChunk; }
216 
217   void set_empty();
218 
219   // Apply Fn to every oop on the mark stack. The mark stack must not
220   // be modified while iterating.
221   template&lt;typename Fn&gt; void iterate(Fn fn) const PRODUCT_RETURN;
222 };
223 
<a name="5" id="anc5"></a><span class="line-modified">224 // Root Regions are regions that contain objects from nTAMS to top. These are roots</span>
<span class="line-modified">225 // for marking, i.e. their referenced objects must be kept alive to maintain the</span>
226 // SATB invariant.
<a name="6" id="anc6"></a><span class="line-modified">227 // We could scan and mark them through during the initial-mark pause, but for</span>

228 // pause time reasons we move this work to the concurrent phase.
229 // We need to complete this procedure before the next GC because it might determine
230 // that some of these &quot;root objects&quot; are dead, potentially dropping some required
231 // references.
<a name="7" id="anc7"></a><span class="line-modified">232 // Root regions comprise of the complete contents of survivor regions, and any</span>
<span class="line-modified">233 // objects copied into old gen during GC.</span>
<span class="line-modified">234 class G1CMRootRegions {</span>
<span class="line-modified">235   HeapRegion** _root_regions;</span>

236   size_t const _max_regions;
237 
238   volatile size_t _num_root_regions; // Actual number of root regions.
239 
240   volatile size_t _claimed_root_regions; // Number of root regions currently claimed.
241 
242   volatile bool _scan_in_progress;
243   volatile bool _should_abort;
244 
245   void notify_scan_done();
246 
247 public:
<a name="8" id="anc8"></a><span class="line-modified">248   G1CMRootRegions(uint const max_regions);</span>
<span class="line-modified">249   ~G1CMRootRegions();</span>
250 
251   // Reset the data structure to allow addition of new root regions.
252   void reset();
253 
<a name="9" id="anc9"></a><span class="line-modified">254   void add(HeapRegion* hr);</span>
255 
256   // Reset the claiming / scanning of the root regions.
257   void prepare_for_scan();
258 
259   // Forces get_next() to return NULL so that the iteration aborts early.
260   void abort() { _should_abort = true; }
261 
262   // Return true if the CM thread are actively scanning root regions,
263   // false otherwise.
264   bool scan_in_progress() { return _scan_in_progress; }
265 
<a name="10" id="anc10"></a><span class="line-modified">266   // Claim the next root region to scan atomically, or return NULL if</span>
267   // all have been claimed.
<a name="11" id="anc11"></a><span class="line-modified">268   HeapRegion* claim_next();</span>
269 
270   // The number of root regions to scan.
271   uint num_root_regions() const;
272 
273   void cancel_scan();
274 
275   // Flag that we&#39;re done with root region scanning and notify anyone
276   // who&#39;s waiting on it. If aborted is false, assume that all regions
277   // have been claimed.
278   void scan_finished();
279 
280   // If CM threads are still scanning root regions, wait until they
281   // are done. Return true if we had to wait, false otherwise.
282   bool wait_until_scan_finished();
283 };
284 
285 // This class manages data structures and methods for doing liveness analysis in
286 // G1&#39;s concurrent cycle.
287 class G1ConcurrentMark : public CHeapObj&lt;mtGC&gt; {
288   friend class G1ConcurrentMarkThread;
289   friend class G1CMRefProcTaskProxy;
290   friend class G1CMRefProcTaskExecutor;
291   friend class G1CMKeepAliveAndDrainClosure;
292   friend class G1CMDrainMarkingStackClosure;
293   friend class G1CMBitMapClosure;
294   friend class G1CMConcurrentMarkingTask;
295   friend class G1CMRemarkTask;
296   friend class G1CMTask;
297 
298   G1ConcurrentMarkThread* _cm_thread;     // The thread doing the work
299   G1CollectedHeap*        _g1h;           // The heap
300   bool                    _completed_initialization; // Set to true when initialization is complete
301 
302   // Concurrent marking support structures
303   G1CMBitMap              _mark_bitmap_1;
304   G1CMBitMap              _mark_bitmap_2;
305   G1CMBitMap*             _prev_mark_bitmap; // Completed mark bitmap
306   G1CMBitMap*             _next_mark_bitmap; // Under-construction mark bitmap
307 
308   // Heap bounds
309   MemRegion const         _heap;
310 
311   // Root region tracking and claiming
<a name="12" id="anc12"></a><span class="line-modified">312   G1CMRootRegions         _root_regions;</span>
313 
314   // For grey objects
315   G1CMMarkStack           _global_mark_stack; // Grey objects behind global finger
316   HeapWord* volatile      _finger;            // The global finger, region aligned,
317                                               // always pointing to the end of the
318                                               // last claimed region
319 
320   uint                    _worker_id_offset;
321   uint                    _max_num_tasks;    // Maximum number of marking tasks
322   uint                    _num_active_tasks; // Number of tasks currently active
323   G1CMTask**              _tasks;            // Task queue array (max_worker_id length)
324 
325   G1CMTaskQueueSet*       _task_queues; // Task queue set
326   TaskTerminator          _terminator;  // For termination
327 
328   // Two sync barriers that are used to synchronize tasks when an
329   // overflow occurs. The algorithm is the following. All tasks enter
330   // the first one to ensure that they have all stopped manipulating
331   // the global data structures. After they exit it, they re-initialize
332   // their data structures and task 0 re-initializes the global data
333   // structures. Then, they enter the second sync barrier. This
334   // ensure, that no task starts doing work before all data
335   // structures (local and global) have been re-initialized. When they
336   // exit it, they are free to start working again.
337   WorkGangBarrierSync     _first_overflow_barrier_sync;
338   WorkGangBarrierSync     _second_overflow_barrier_sync;
339 
340   // This is set by any task, when an overflow on the global data
341   // structures is detected
342   volatile bool           _has_overflown;
343   // True: marking is concurrent, false: we&#39;re in remark
344   volatile bool           _concurrent;
345   // Set at the end of a Full GC so that marking aborts
346   volatile bool           _has_aborted;
347 
348   // Used when remark aborts due to an overflow to indicate that
349   // another concurrent marking phase should start
350   volatile bool           _restart_for_overflow;
351 
352   ConcurrentGCTimer*      _gc_timer_cm;
353 
354   G1OldTracer*            _gc_tracer_cm;
355 
356   // Timing statistics. All of them are in ms
357   NumberSeq _init_times;
358   NumberSeq _remark_times;
359   NumberSeq _remark_mark_times;
360   NumberSeq _remark_weak_ref_times;
361   NumberSeq _cleanup_times;
362   double    _total_cleanup_time;
363 
364   double*   _accum_task_vtime;   // Accumulated task vtime
365 
366   WorkGang* _concurrent_workers;
367   uint      _num_concurrent_workers; // The number of marking worker threads we&#39;re using
368   uint      _max_concurrent_workers; // Maximum number of marking worker threads
369 
370   void verify_during_pause(G1HeapVerifier::G1VerifyType type, VerifyOption vo, const char* caller);
371 
372   void finalize_marking();
373 
374   void weak_refs_work_parallel_part(BoolObjectClosure* is_alive, bool purged_classes);
375   void weak_refs_work(bool clear_all_soft_refs);
376 
377   void report_object_count(bool mark_completed);
378 
379   void swap_mark_bitmaps();
380 
381   void reclaim_empty_regions();
382 
383   // After reclaiming empty regions, update heap sizes.
384   void compute_new_sizes();
385 
386   // Clear statistics gathered during the concurrent cycle for the given region after
387   // it has been reclaimed.
388   void clear_statistics(HeapRegion* r);
389 
390   // Resets the global marking data structures, as well as the
391   // task local ones; should be called during initial mark.
392   void reset();
393 
394   // Resets all the marking data structures. Called when we have to restart
395   // marking or when marking completes (via set_non_marking_state below).
396   void reset_marking_for_restart();
397 
398   // We do this after we&#39;re done with marking so that the marking data
399   // structures are initialized to a sensible and predictable state.
400   void reset_at_marking_complete();
401 
402   // Called to indicate how many threads are currently active.
403   void set_concurrency(uint active_tasks);
404 
405   // Should be called to indicate which phase we&#39;re in (concurrent
406   // mark or remark) and how many threads are currently active.
407   void set_concurrency_and_phase(uint active_tasks, bool concurrent);
408 
409   // Prints all gathered CM-related statistics
410   void print_stats();
411 
<a name="13" id="anc13"></a><span class="line-modified">412   HeapWord*               finger()           { return _finger;   }</span>
<span class="line-modified">413   bool                    concurrent()       { return _concurrent; }</span>
<span class="line-modified">414   uint                    active_tasks()     { return _num_active_tasks; }</span>
<span class="line-modified">415   ParallelTaskTerminator* terminator() const { return _terminator.terminator(); }</span>
416 
417   // Claims the next available region to be scanned by a marking
418   // task/thread. It might return NULL if the next region is empty or
419   // we have run out of regions. In the latter case, out_of_regions()
420   // determines whether we&#39;ve really run out of regions or the task
421   // should call claim_region() again. This might seem a bit
422   // awkward. Originally, the code was written so that claim_region()
423   // either successfully returned with a non-empty region or there
424   // were no more regions to be claimed. The problem with this was
425   // that, in certain circumstances, it iterated over large chunks of
426   // the heap finding only empty regions and, while it was working, it
427   // was preventing the calling task to call its regular clock
428   // method. So, this way, each task will spend very little time in
429   // claim_region() and is allowed to call the regular clock method
430   // frequently.
431   HeapRegion* claim_region(uint worker_id);
432 
433   // Determines whether we&#39;ve run out of regions to scan. Note that
434   // the finger can point past the heap end in case the heap was expanded
435   // to satisfy an allocation without doing a GC. This is fine, because all
436   // objects in those regions will be considered live anyway because of
437   // SATB guarantees (i.e. their TAMS will be equal to bottom).
438   bool out_of_regions() { return _finger &gt;= _heap.end(); }
439 
440   // Returns the task with the given id
441   G1CMTask* task(uint id) {
442     // During initial mark we use the parallel gc threads to do some work, so
443     // we can only compare against _max_num_tasks.
444     assert(id &lt; _max_num_tasks, &quot;Task id %u not within bounds up to %u&quot;, id, _max_num_tasks);
445     return _tasks[id];
446   }
447 
448   // Access / manipulation of the overflow flag which is set to
449   // indicate that the global stack has overflown
450   bool has_overflown()           { return _has_overflown; }
451   void set_has_overflown()       { _has_overflown = true; }
452   void clear_has_overflown()     { _has_overflown = false; }
453   bool restart_for_overflow()    { return _restart_for_overflow; }
454 
455   // Methods to enter the two overflow sync barriers
456   void enter_first_sync_barrier(uint worker_id);
457   void enter_second_sync_barrier(uint worker_id);
458 
459   // Clear the given bitmap in parallel using the given WorkGang. If may_yield is
460   // true, periodically insert checks to see if this method should exit prematurely.
461   void clear_bitmap(G1CMBitMap* bitmap, WorkGang* workers, bool may_yield);
462 
463   // Region statistics gathered during marking.
464   G1RegionMarkStats* _region_mark_stats;
465   // Top pointer for each region at the start of the rebuild remembered set process
466   // for regions which remembered sets need to be rebuilt. A NULL for a given region
467   // means that this region does not be scanned during the rebuilding remembered
468   // set phase at all.
469   HeapWord* volatile* _top_at_rebuild_starts;
470 public:
471   void add_to_liveness(uint worker_id, oop const obj, size_t size);
472   // Liveness of the given region as determined by concurrent marking, i.e. the amount of
473   // live words between bottom and nTAMS.
474   size_t liveness(uint region) const { return _region_mark_stats[region]._live_words; }
475 
476   // Sets the internal top_at_region_start for the given region to current top of the region.
477   inline void update_top_at_rebuild_start(HeapRegion* r);
478   // TARS for the given region during remembered set rebuilding.
479   inline HeapWord* top_at_rebuild_start(uint region) const;
480 
481   // Clear statistics gathered during the concurrent cycle for the given region after
482   // it has been reclaimed.
483   void clear_statistics_in_region(uint region_idx);
484   // Notification for eagerly reclaimed regions to clean up.
485   void humongous_object_eagerly_reclaimed(HeapRegion* r);
486   // Manipulation of the global mark stack.
487   // The push and pop operations are used by tasks for transfers
488   // between task-local queues and the global mark stack.
489   bool mark_stack_push(G1TaskQueueEntry* arr) {
490     if (!_global_mark_stack.par_push_chunk(arr)) {
491       set_has_overflown();
492       return false;
493     }
494     return true;
495   }
496   bool mark_stack_pop(G1TaskQueueEntry* arr) {
497     return _global_mark_stack.par_pop_chunk(arr);
498   }
499   size_t mark_stack_size() const                { return _global_mark_stack.size(); }
500   size_t partial_mark_stack_size_target() const { return _global_mark_stack.capacity() / 3; }
501   bool mark_stack_empty() const                 { return _global_mark_stack.is_empty(); }
502 
<a name="14" id="anc14"></a><span class="line-modified">503   G1CMRootRegions* root_regions() { return &amp;_root_regions; }</span>
504 
505   void concurrent_cycle_start();
506   // Abandon current marking iteration due to a Full GC.
507   void concurrent_cycle_abort();
508   void concurrent_cycle_end();
509 
510   void update_accum_task_vtime(int i, double vtime) {
511     _accum_task_vtime[i] += vtime;
512   }
513 
514   double all_task_accum_vtime() {
515     double ret = 0.0;
516     for (uint i = 0; i &lt; _max_num_tasks; ++i)
517       ret += _accum_task_vtime[i];
518     return ret;
519   }
520 
521   // Attempts to steal an object from the task queues of other tasks
522   bool try_stealing(uint worker_id, G1TaskQueueEntry&amp; task_entry);
523 
524   G1ConcurrentMark(G1CollectedHeap* g1h,
525                    G1RegionToSpaceMapper* prev_bitmap_storage,
526                    G1RegionToSpaceMapper* next_bitmap_storage);
527   ~G1ConcurrentMark();
528 
529   G1ConcurrentMarkThread* cm_thread() { return _cm_thread; }
530 
531   const G1CMBitMap* const prev_mark_bitmap() const { return _prev_mark_bitmap; }
532   G1CMBitMap* next_mark_bitmap() const { return _next_mark_bitmap; }
533 
534   // Calculates the number of concurrent GC threads to be used in the marking phase.
535   uint calc_active_marking_workers();
536 
537   // Moves all per-task cached data into global state.
538   void flush_all_task_caches();
539   // Prepare internal data structures for the next mark cycle. This includes clearing
540   // the next mark bitmap and some internal data structures. This method is intended
541   // to be called concurrently to the mutator. It will yield to safepoint requests.
542   void cleanup_for_next_mark();
543 
544   // Clear the previous marking bitmap during safepoint.
545   void clear_prev_bitmap(WorkGang* workers);
546 
547   // These two methods do the work that needs to be done at the start and end of the
548   // initial mark pause.
549   void pre_initial_mark();
550   void post_initial_mark();
551 
552   // Scan all the root regions and mark everything reachable from
553   // them.
554   void scan_root_regions();
555 
<a name="15" id="anc15"></a><span class="line-modified">556   // Scan a single root region from nTAMS to top and mark everything reachable from it.</span>
<span class="line-modified">557   void scan_root_region(HeapRegion* hr, uint worker_id);</span>
558 
559   // Do concurrent phase of marking, to a tentative transitive closure.
560   void mark_from_roots();
561 
562   // Do concurrent preclean work.
563   void preclean();
564 
565   void remark();
566 
567   void cleanup();
568   // Mark in the previous bitmap. Caution: the prev bitmap is usually read-only, so use
569   // this carefully.
570   inline void mark_in_prev_bitmap(oop p);
571 
572   // Clears marks for all objects in the given range, for the prev or
573   // next bitmaps.  Caution: the previous bitmap is usually
574   // read-only, so use this carefully!
575   void clear_range_in_prev_bitmap(MemRegion mr);
576 
577   inline bool is_marked_in_prev_bitmap(oop p) const;
578 
579   // Verify that there are no collection set oops on the stacks (taskqueues /
580   // global mark stack) and fingers (global / per-task).
581   // If marking is not in progress, it&#39;s a no-op.
<a name="16" id="anc16"></a><span class="line-modified">582   void verify_no_cset_oops() PRODUCT_RETURN;</span>
583 
584   inline bool do_yield_check();
585 
586   bool has_aborted()      { return _has_aborted; }
587 
588   void print_summary_info();
589 
590   void print_worker_threads_on(outputStream* st) const;
591   void threads_do(ThreadClosure* tc) const;
592 
593   void print_on_error(outputStream* st) const;
594 
595   // Mark the given object on the next bitmap if it is below nTAMS.
596   inline bool mark_in_next_bitmap(uint worker_id, HeapRegion* const hr, oop const obj);
597   inline bool mark_in_next_bitmap(uint worker_id, oop const obj);
598 
599   inline bool is_marked_in_next_bitmap(oop p) const;
600 
601   // Returns true if initialization was successfully completed.
602   bool completed_initialization() const {
603     return _completed_initialization;
604   }
605 
606   ConcurrentGCTimer* gc_timer_cm() const { return _gc_timer_cm; }
607   G1OldTracer* gc_tracer_cm() const { return _gc_tracer_cm; }
608 
609 private:
610   // Rebuilds the remembered sets for chosen regions in parallel and concurrently to the application.
611   void rebuild_rem_set_concurrently();
612 };
613 
614 // A class representing a marking task.
615 class G1CMTask : public TerminatorTerminator {
616 private:
617   enum PrivateConstants {
618     // The regular clock call is called once the scanned words reaches
619     // this limit
620     words_scanned_period          = 12*1024,
621     // The regular clock call is called once the number of visited
622     // references reaches this limit
623     refs_reached_period           = 1024,
624     // Initial value for the hash seed, used in the work stealing code
625     init_hash_seed                = 17
626   };
627 
628   // Number of entries in the per-task stats entry. This seems enough to have a very
629   // low cache miss rate.
630   static const uint RegionMarkStatsCacheSize = 1024;
631 
632   G1CMObjArrayProcessor       _objArray_processor;
633 
634   uint                        _worker_id;
635   G1CollectedHeap*            _g1h;
636   G1ConcurrentMark*           _cm;
637   G1CMBitMap*                 _next_mark_bitmap;
638   // the task queue of this task
639   G1CMTaskQueue*              _task_queue;
640 
641   G1RegionMarkStatsCache      _mark_stats_cache;
642   // Number of calls to this task
643   uint                        _calls;
644 
645   // When the virtual timer reaches this time, the marking step should exit
646   double                      _time_target_ms;
647   // Start time of the current marking step
648   double                      _start_time_ms;
649 
650   // Oop closure used for iterations over oops
651   G1CMOopClosure*             _cm_oop_closure;
652 
653   // Region this task is scanning, NULL if we&#39;re not scanning any
654   HeapRegion*                 _curr_region;
655   // Local finger of this task, NULL if we&#39;re not scanning a region
656   HeapWord*                   _finger;
657   // Limit of the region this task is scanning, NULL if we&#39;re not scanning one
658   HeapWord*                   _region_limit;
659 
660   // Number of words this task has scanned
661   size_t                      _words_scanned;
662   // When _words_scanned reaches this limit, the regular clock is
663   // called. Notice that this might be decreased under certain
664   // circumstances (i.e. when we believe that we did an expensive
665   // operation).
666   size_t                      _words_scanned_limit;
667   // Initial value of _words_scanned_limit (i.e. what it was
668   // before it was decreased).
669   size_t                      _real_words_scanned_limit;
670 
671   // Number of references this task has visited
672   size_t                      _refs_reached;
673   // When _refs_reached reaches this limit, the regular clock is
674   // called. Notice this this might be decreased under certain
675   // circumstances (i.e. when we believe that we did an expensive
676   // operation).
677   size_t                      _refs_reached_limit;
678   // Initial value of _refs_reached_limit (i.e. what it was before
679   // it was decreased).
680   size_t                      _real_refs_reached_limit;
681 
682   // If true, then the task has aborted for some reason
683   bool                        _has_aborted;
684   // Set when the task aborts because it has met its time quota
685   bool                        _has_timed_out;
686   // True when we&#39;re draining SATB buffers; this avoids the task
687   // aborting due to SATB buffers being available (as we&#39;re already
688   // dealing with them)
689   bool                        _draining_satb_buffers;
690 
691   // Number sequence of past step times
692   NumberSeq                   _step_times_ms;
693   // Elapsed time of this task
694   double                      _elapsed_time_ms;
695   // Termination time of this task
696   double                      _termination_time_ms;
697   // When this task got into the termination protocol
698   double                      _termination_start_time_ms;
699 
<a name="17" id="anc17"></a><span class="line-modified">700   TruncatedSeq                _marking_step_diffs_ms;</span>
701 
702   // Updates the local fields after this task has claimed
703   // a new region to scan
704   void setup_for_region(HeapRegion* hr);
705   // Makes the limit of the region up-to-date
706   void update_region_limit();
707 
708   // Called when either the words scanned or the refs visited limit
709   // has been reached
710   void reached_limit();
711   // Recalculates the words scanned and refs visited limits
712   void recalculate_limits();
713   // Decreases the words scanned and refs visited limits when we reach
714   // an expensive operation
715   void decrease_limits();
716   // Checks whether the words scanned or refs visited reached their
717   // respective limit and calls reached_limit() if they have
718   void check_limits() {
719     if (_words_scanned &gt;= _words_scanned_limit ||
720         _refs_reached &gt;= _refs_reached_limit) {
721       reached_limit();
722     }
723   }
724   // Supposed to be called regularly during a marking step as
725   // it checks a bunch of conditions that might cause the marking step
726   // to abort
727   // Return true if the marking step should continue. Otherwise, return false to abort
728   bool regular_clock_call();
729 
730   // Set abort flag if regular_clock_call() check fails
731   inline void abort_marking_if_regular_check_fail();
732 
733   // Test whether obj might have already been passed over by the
734   // mark bitmap scan, and so needs to be pushed onto the mark stack.
735   bool is_below_finger(oop obj, HeapWord* global_finger) const;
736 
737   template&lt;bool scan&gt; void process_grey_task_entry(G1TaskQueueEntry task_entry);
738 public:
739   // Apply the closure on the given area of the objArray. Return the number of words
740   // scanned.
741   inline size_t scan_objArray(objArrayOop obj, MemRegion mr);
742   // Resets the task; should be called right at the beginning of a marking phase.
743   void reset(G1CMBitMap* next_mark_bitmap);
744   // Clears all the fields that correspond to a claimed region.
745   void clear_region_fields();
746 
747   // The main method of this class which performs a marking step
748   // trying not to exceed the given duration. However, it might exit
749   // prematurely, according to some conditions (i.e. SATB buffers are
750   // available for processing).
751   void do_marking_step(double target_ms,
752                        bool do_termination,
753                        bool is_serial);
754 
755   // These two calls start and stop the timer
756   void record_start_time() {
757     _elapsed_time_ms = os::elapsedTime() * 1000.0;
758   }
759   void record_end_time() {
760     _elapsed_time_ms = os::elapsedTime() * 1000.0 - _elapsed_time_ms;
761   }
762 
763   // Returns the worker ID associated with this task.
764   uint worker_id() { return _worker_id; }
765 
766   // From TerminatorTerminator. It determines whether this task should
767   // exit the termination protocol after it&#39;s entered it.
768   virtual bool should_exit_termination();
769 
770   // Resets the local region fields after a task has finished scanning a
771   // region; or when they have become stale as a result of the region
772   // being evacuated.
773   void giveup_current_region();
774 
775   HeapWord* finger()            { return _finger; }
776 
777   bool has_aborted()            { return _has_aborted; }
778   void set_has_aborted()        { _has_aborted = true; }
779   void clear_has_aborted()      { _has_aborted = false; }
780 
781   void set_cm_oop_closure(G1CMOopClosure* cm_oop_closure);
782 
783   // Increment the number of references this task has visited.
784   void increment_refs_reached() { ++_refs_reached; }
785 
786   // Grey the object by marking it.  If not already marked, push it on
787   // the local queue if below the finger. obj is required to be below its region&#39;s NTAMS.
788   // Returns whether there has been a mark to the bitmap.
789   inline bool make_reference_grey(oop obj);
790 
791   // Grey the object (by calling make_grey_reference) if required,
792   // e.g. obj is below its containing region&#39;s NTAMS.
793   // Precondition: obj is a valid heap object.
794   // Returns true if the reference caused a mark to be set in the next bitmap.
795   template &lt;class T&gt;
796   inline bool deal_with_reference(T* p);
797 
798   // Scans an object and visits its children.
799   inline void scan_task_entry(G1TaskQueueEntry task_entry);
800 
801   // Pushes an object on the local queue.
802   inline void push(G1TaskQueueEntry task_entry);
803 
804   // Move entries to the global stack.
805   void move_entries_to_global_stack();
806   // Move entries from the global stack, return true if we were successful to do so.
807   bool get_entries_from_global_stack();
808 
809   // Pops and scans objects from the local queue. If partially is
810   // true, then it stops when the queue size is of a given limit. If
811   // partially is false, then it stops when the queue is empty.
812   void drain_local_queue(bool partially);
813   // Moves entries from the global stack to the local queue and
814   // drains the local queue. If partially is true, then it stops when
815   // both the global stack and the local queue reach a given size. If
816   // partially if false, it tries to empty them totally.
817   void drain_global_stack(bool partially);
818   // Keeps picking SATB buffers and processing them until no SATB
819   // buffers are available.
820   void drain_satb_buffers();
821 
822   // Moves the local finger to a new location
823   inline void move_finger_to(HeapWord* new_finger) {
824     assert(new_finger &gt;= _finger &amp;&amp; new_finger &lt; _region_limit, &quot;invariant&quot;);
825     _finger = new_finger;
826   }
827 
828   G1CMTask(uint worker_id,
829            G1ConcurrentMark *cm,
830            G1CMTaskQueue* task_queue,
831            G1RegionMarkStats* mark_stats,
832            uint max_regions);
833 
834   inline void update_liveness(oop const obj, size_t const obj_size);
835 
836   // Clear (without flushing) the mark cache entry for the given region.
837   void clear_mark_stats_cache(uint region_idx);
838   // Evict the whole statistics cache into the global statistics. Returns the
839   // number of cache hits and misses so far.
840   Pair&lt;size_t, size_t&gt; flush_mark_stats_cache();
841   // Prints statistics associated with this task
842   void print_stats();
843 };
844 
845 // Class that&#39;s used to to print out per-region liveness
846 // information. It&#39;s currently used at the end of marking and also
847 // after we sort the old regions at the end of the cleanup operation.
848 class G1PrintRegionLivenessInfoClosure : public HeapRegionClosure {
849   // Accumulators for these values.
850   size_t _total_used_bytes;
851   size_t _total_capacity_bytes;
852   size_t _total_prev_live_bytes;
853   size_t _total_next_live_bytes;
854 
855   // Accumulator for the remembered set size
856   size_t _total_remset_bytes;
857 
858   // Accumulator for strong code roots memory size
859   size_t _total_strong_code_roots_bytes;
860 
861   static double bytes_to_mb(size_t val) {
862     return (double) val / (double) M;
863   }
864 
865 public:
866   // The header and footer are printed in the constructor and
867   // destructor respectively.
868   G1PrintRegionLivenessInfoClosure(const char* phase_name);
869   virtual bool do_heap_region(HeapRegion* r);
870   ~G1PrintRegionLivenessInfoClosure();
871 };
872 
873 #endif // SHARE_GC_G1_G1CONCURRENTMARK_HPP
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
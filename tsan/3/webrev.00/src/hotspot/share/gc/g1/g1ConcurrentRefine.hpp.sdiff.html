<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefine.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;

 30 
 31 // Forward decl
 32 class G1ConcurrentRefine;
 33 class G1ConcurrentRefineThread;
 34 class outputStream;
 35 class ThreadClosure;
 36 
 37 // Helper class for refinement thread management. Used to start, stop and
 38 // iterate over them.
 39 class G1ConcurrentRefineThreadControl {
 40   G1ConcurrentRefine* _cr;
 41 
 42   G1ConcurrentRefineThread** _threads;
 43   uint _num_max_threads;
 44 
 45   // Create the refinement thread for the given worker id.
 46   // If initializing is true, ignore InjectGCWorkerCreationFailure.
 47   G1ConcurrentRefineThread* create_refinement_thread(uint worker_id, bool initializing);
 48 public:
 49   G1ConcurrentRefineThreadControl();
 50   ~G1ConcurrentRefineThreadControl();
 51 
 52   jint initialize(G1ConcurrentRefine* cr, uint num_max_threads);
 53 
 54   // If there is a &quot;successor&quot; thread that can be activated given the current id,
 55   // activate it.
 56   void maybe_activate_next(uint cur_worker_id);
 57 
 58   void print_on(outputStream* st) const;
 59   void worker_threads_do(ThreadClosure* tc);
 60   void stop();
 61 };
 62 
<span class="line-modified"> 63 // Controls refinement threads and their activation based on the number of completed</span>
<span class="line-modified"> 64 // buffers currently available in the global dirty card queue.</span>
<span class="line-modified"> 65 // Refinement threads pick work from the queue based on these thresholds. They are activated</span>
<span class="line-modified"> 66 // gradually based on the amount of work to do.</span>

 67 // Refinement thread n activates thread n+1 if the instance of this class determines there
 68 // is enough work available. Threads deactivate themselves if the current amount of
<span class="line-modified"> 69 // completed buffers falls below their individual threshold.</span>
 70 class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
 71   G1ConcurrentRefineThreadControl _thread_control;
 72   /*
 73    * The value of the completed dirty card queue length falls into one of 3 zones:
 74    * green, yellow, red. If the value is in [0, green) nothing is
<span class="line-modified"> 75    * done, the buffers are left unprocessed to enable the caching effect of the</span>
 76    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
 77    * threads are gradually activated. In [yellow, red) all threads are
 78    * running. If the length becomes red (max queue length) the mutators start
<span class="line-modified"> 79    * processing the buffers.</span>
 80    *
 81    * There are some interesting cases (when G1UseAdaptiveConcRefinement
 82    * is turned off):
 83    * 1) green = yellow = red = 0. In this case the mutator will process all
<span class="line-modified"> 84    *    buffers. Except for those that are created by the deferred updates</span>
 85    *    machinery during a collection.
 86    * 2) green = 0. Means no caching. Can be a good way to minimize the
 87    *    amount of time spent updating remembered sets during a collection.
 88    */
 89   size_t _green_zone;
 90   size_t _yellow_zone;
 91   size_t _red_zone;
 92   size_t _min_yellow_zone_size;
 93 
 94   G1ConcurrentRefine(size_t green_zone,
 95                      size_t yellow_zone,
 96                      size_t red_zone,
 97                      size_t min_yellow_zone_size);
 98 
 99   // Update green/yellow/red zone values based on how well goals are being met.
<span class="line-modified">100   void update_zones(double update_rs_time,</span>
<span class="line-modified">101                     size_t update_rs_processed_buffers,</span>
102                     double goal_ms);
103 
104   static uint worker_id_offset();
<span class="line-modified">105   void maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers);</span>
106 
107   jint initialize();
108 public:
109   ~G1ConcurrentRefine();
110 
111   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
112   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
113   static G1ConcurrentRefine* create(jint* ecode);
114 
115   void stop();
116 
117   // Adjust refinement thresholds based on work done during the pause and the goal time.
<span class="line-modified">118   void adjust(double update_rs_time, size_t update_rs_processed_buffers, double goal_ms);</span>
119 









120   size_t activation_threshold(uint worker_id) const;
121   size_t deactivation_threshold(uint worker_id) const;
<span class="line-modified">122   // Perform a single refinement step. Called by the refinement threads when woken up.</span>
<span class="line-modified">123   bool do_refinement_step(uint worker_id);</span>



124 
125   // Iterate over all concurrent refinement threads applying the given closure.
126   void threads_do(ThreadClosure *tc);
127 
128   // Maximum number of refinement threads.
129   static uint max_num_threads();
130 
131   void print_threads_on(outputStream* st) const;
132 

133   size_t green_zone() const      { return _green_zone;  }
134   size_t yellow_zone() const     { return _yellow_zone; }
135   size_t red_zone() const        { return _red_zone;    }
136 };
137 
138 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 26 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-added"> 30 #include &quot;utilities/ticks.hpp&quot;</span>
 31 
 32 // Forward decl
 33 class G1ConcurrentRefine;
 34 class G1ConcurrentRefineThread;
 35 class outputStream;
 36 class ThreadClosure;
 37 
 38 // Helper class for refinement thread management. Used to start, stop and
 39 // iterate over them.
 40 class G1ConcurrentRefineThreadControl {
 41   G1ConcurrentRefine* _cr;
 42 
 43   G1ConcurrentRefineThread** _threads;
 44   uint _num_max_threads;
 45 
 46   // Create the refinement thread for the given worker id.
 47   // If initializing is true, ignore InjectGCWorkerCreationFailure.
 48   G1ConcurrentRefineThread* create_refinement_thread(uint worker_id, bool initializing);
 49 public:
 50   G1ConcurrentRefineThreadControl();
 51   ~G1ConcurrentRefineThreadControl();
 52 
 53   jint initialize(G1ConcurrentRefine* cr, uint num_max_threads);
 54 
 55   // If there is a &quot;successor&quot; thread that can be activated given the current id,
 56   // activate it.
 57   void maybe_activate_next(uint cur_worker_id);
 58 
 59   void print_on(outputStream* st) const;
 60   void worker_threads_do(ThreadClosure* tc);
 61   void stop();
 62 };
 63 
<span class="line-modified"> 64 // Controls refinement threads and their activation based on the number of</span>
<span class="line-modified"> 65 // cards currently available in the global dirty card queue.</span>
<span class="line-modified"> 66 // Refinement threads obtain work from the queue (a buffer at a time) based</span>
<span class="line-modified"> 67 // on these thresholds. They are activated gradually based on the amount of</span>
<span class="line-added"> 68 // work to do.</span>
 69 // Refinement thread n activates thread n+1 if the instance of this class determines there
 70 // is enough work available. Threads deactivate themselves if the current amount of
<span class="line-modified"> 71 // available cards falls below their individual threshold.</span>
 72 class G1ConcurrentRefine : public CHeapObj&lt;mtGC&gt; {
 73   G1ConcurrentRefineThreadControl _thread_control;
 74   /*
 75    * The value of the completed dirty card queue length falls into one of 3 zones:
 76    * green, yellow, red. If the value is in [0, green) nothing is
<span class="line-modified"> 77    * done, the buffered cards are left unprocessed to enable the caching effect of the</span>
 78    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
 79    * threads are gradually activated. In [yellow, red) all threads are
 80    * running. If the length becomes red (max queue length) the mutators start
<span class="line-modified"> 81    * processing cards too.</span>
 82    *
 83    * There are some interesting cases (when G1UseAdaptiveConcRefinement
 84    * is turned off):
 85    * 1) green = yellow = red = 0. In this case the mutator will process all
<span class="line-modified"> 86    *    cards. Except for those that are created by the deferred updates</span>
 87    *    machinery during a collection.
 88    * 2) green = 0. Means no caching. Can be a good way to minimize the
 89    *    amount of time spent updating remembered sets during a collection.
 90    */
 91   size_t _green_zone;
 92   size_t _yellow_zone;
 93   size_t _red_zone;
 94   size_t _min_yellow_zone_size;
 95 
 96   G1ConcurrentRefine(size_t green_zone,
 97                      size_t yellow_zone,
 98                      size_t red_zone,
 99                      size_t min_yellow_zone_size);
100 
101   // Update green/yellow/red zone values based on how well goals are being met.
<span class="line-modified">102   void update_zones(double logged_cards_scan_time,</span>
<span class="line-modified">103                     size_t processed_logged_cards,</span>
104                     double goal_ms);
105 
106   static uint worker_id_offset();
<span class="line-modified">107   void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);</span>
108 
109   jint initialize();
110 public:
111   ~G1ConcurrentRefine();
112 
113   // Returns a G1ConcurrentRefine instance if succeeded to create/initialize the
114   // G1ConcurrentRefine instance. Otherwise, returns NULL with error code.
115   static G1ConcurrentRefine* create(jint* ecode);
116 
117   void stop();
118 
119   // Adjust refinement thresholds based on work done during the pause and the goal time.
<span class="line-modified">120   void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);</span>
121 
<span class="line-added">122   struct RefinementStats {</span>
<span class="line-added">123     Tickspan _time;</span>
<span class="line-added">124     size_t _cards;</span>
<span class="line-added">125     RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}</span>
<span class="line-added">126   };</span>
<span class="line-added">127 </span>
<span class="line-added">128   RefinementStats total_refinement_stats() const;</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Cards in the dirty card queue set.</span>
131   size_t activation_threshold(uint worker_id) const;
132   size_t deactivation_threshold(uint worker_id) const;
<span class="line-modified">133 </span>
<span class="line-modified">134   // Perform a single refinement step; called by the refinement</span>
<span class="line-added">135   // threads.  Returns true if there was refinement work available.</span>
<span class="line-added">136   // Increments *total_refined_cards.</span>
<span class="line-added">137   bool do_refinement_step(uint worker_id, size_t* total_refined_cards);</span>
138 
139   // Iterate over all concurrent refinement threads applying the given closure.
140   void threads_do(ThreadClosure *tc);
141 
142   // Maximum number of refinement threads.
143   static uint max_num_threads();
144 
145   void print_threads_on(outputStream* st) const;
146 
<span class="line-added">147   // Cards in the dirty card queue set.</span>
148   size_t green_zone() const      { return _green_zone;  }
149   size_t yellow_zone() const     { return _yellow_zone; }
150   size_t red_zone() const        { return _red_zone;    }
151 };
152 
153 #endif // SHARE_GC_G1_G1CONCURRENTREFINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentRefine.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentRefineThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
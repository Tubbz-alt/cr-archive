<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1FullGCOopClosures.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1FullGCMarker.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1FullGCOopClosures.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1FullGCOopClosures.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
44    _verify_option(option),
45    _cc(0) {
46 }
47 
48 void G1VerifyOopClosure::print_object(outputStream* out, oop obj) {
49 #ifdef PRODUCT
50   Klass* k = obj-&gt;klass();
51   const char* class_name = InstanceKlass::cast(k)-&gt;external_name();
52   out-&gt;print_cr(&quot;class name %s&quot;, class_name);
53 #else // PRODUCT
54   obj-&gt;print_on(out);
55 #endif // PRODUCT
56 }
57 
58 template &lt;class T&gt; void G1VerifyOopClosure::do_oop_work(T* p) {
59   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
60   if (!CompressedOops::is_null(heap_oop)) {
61     _cc++;
62     oop obj = CompressedOops::decode_not_null(heap_oop);
63     bool failed = false;
<span class="line-modified">64     if (!_g1h-&gt;is_in_closed_subset(obj) || _g1h-&gt;is_obj_dead_cond(obj, _verify_option)) {</span>
<span class="line-modified">65       MutexLockerEx x(ParGCRareEvent_lock,</span>
<span class="line-removed">66           Mutex::_no_safepoint_check_flag);</span>
67       LogStreamHandle(Error, gc, verify) yy;
68       if (!_failures) {
69         yy.cr();
70         yy.print_cr(&quot;----------&quot;);
71       }
<span class="line-modified">72       if (!_g1h-&gt;is_in_closed_subset(obj)) {</span>
73         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
74         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
75                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
76         print_object(&amp;yy, _containing_obj);
77         yy.print_cr(&quot;points to obj &quot; PTR_FORMAT &quot; not in the heap&quot;,
78                     p2i(obj));
79       } else {
80         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
<span class="line-modified">81         HeapRegion* to   = _g1h-&gt;heap_region_containing((HeapWord*)obj);</span>
82         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
83                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
84         print_object(&amp;yy, _containing_obj);
85         yy.print_cr(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
86                     p2i(obj), HR_FORMAT_PARAMS(to));
87         print_object(&amp;yy, obj);
88       }
89       yy.print_cr(&quot;----------&quot;);
90       yy.flush();
91       _failures = true;
92       failed = true;
93     }
94   }
95 }
96 
97 template void G1VerifyOopClosure::do_oop_work(oop*);
98 template void G1VerifyOopClosure::do_oop_work(narrowOop*);
</pre>
</td>
<td>
<hr />
<pre>
44    _verify_option(option),
45    _cc(0) {
46 }
47 
48 void G1VerifyOopClosure::print_object(outputStream* out, oop obj) {
49 #ifdef PRODUCT
50   Klass* k = obj-&gt;klass();
51   const char* class_name = InstanceKlass::cast(k)-&gt;external_name();
52   out-&gt;print_cr(&quot;class name %s&quot;, class_name);
53 #else // PRODUCT
54   obj-&gt;print_on(out);
55 #endif // PRODUCT
56 }
57 
58 template &lt;class T&gt; void G1VerifyOopClosure::do_oop_work(T* p) {
59   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
60   if (!CompressedOops::is_null(heap_oop)) {
61     _cc++;
62     oop obj = CompressedOops::decode_not_null(heap_oop);
63     bool failed = false;
<span class="line-modified">64     if (!_g1h-&gt;is_in(obj) || _g1h-&gt;is_obj_dead_cond(obj, _verify_option)) {</span>
<span class="line-modified">65       MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);</span>

66       LogStreamHandle(Error, gc, verify) yy;
67       if (!_failures) {
68         yy.cr();
69         yy.print_cr(&quot;----------&quot;);
70       }
<span class="line-modified">71       if (!_g1h-&gt;is_in(obj)) {</span>
72         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
73         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
74                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
75         print_object(&amp;yy, _containing_obj);
76         yy.print_cr(&quot;points to obj &quot; PTR_FORMAT &quot; not in the heap&quot;,
77                     p2i(obj));
78       } else {
79         HeapRegion* from = _g1h-&gt;heap_region_containing((HeapWord*)p);
<span class="line-modified">80         HeapRegion* to   = _g1h-&gt;heap_region_containing(obj);</span>
81         yy.print_cr(&quot;Field &quot; PTR_FORMAT &quot; of live obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
82                     p2i(p), p2i(_containing_obj), HR_FORMAT_PARAMS(from));
83         print_object(&amp;yy, _containing_obj);
84         yy.print_cr(&quot;points to dead obj &quot; PTR_FORMAT &quot; in region &quot; HR_FORMAT,
85                     p2i(obj), HR_FORMAT_PARAMS(to));
86         print_object(&amp;yy, obj);
87       }
88       yy.print_cr(&quot;----------&quot;);
89       yy.flush();
90       _failures = true;
91       failed = true;
92     }
93   }
94 }
95 
96 template void G1VerifyOopClosure::do_oop_work(oop*);
97 template void G1VerifyOopClosure::do_oop_work(narrowOop*);
</pre>
</td>
</tr>
</table>
<center><a href="g1FullGCMarker.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1FullGCOopClosures.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ParScanThreadState.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ParScanThreadState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
  #ifndef SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
  #define SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
  
  #include &quot;gc/g1/g1CardTable.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;</span>
  #include &quot;gc/g1/g1OopClosures.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/ageTable.hpp&quot;
<span class="line-new-header">--- 25,11 ---</span>
  #ifndef SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
  #define SHARE_GC_G1_G1PARSCANTHREADSTATE_HPP
  
  #include &quot;gc/g1/g1CardTable.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;</span>
  #include &quot;gc/g1/g1OopClosures.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/ageTable.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,58 ***</span>
  class HeapRegion;
  class outputStream;
  
  class G1ParScanThreadState : public CHeapObj&lt;mtGC&gt; {
    G1CollectedHeap* _g1h;
<span class="line-modified">!   RefToScanQueue*  _refs;</span>
<span class="line-modified">!   G1DirtyCardQueue _dcq;</span>
<span class="line-modified">!   G1CardTable*     _ct;</span>
    G1EvacuationRootClosures* _closures;
  
<span class="line-modified">!   G1PLABAllocator*  _plab_allocator;</span>
  
<span class="line-modified">!   AgeTable          _age_table;</span>
<span class="line-modified">!   InCSetState       _dest[InCSetState::Num];</span>
    // Local tenuring threshold.
<span class="line-modified">!   uint              _tenuring_threshold;</span>
    G1ScanEvacuatedObjClosure  _scanner;
  
    uint _worker_id;
  
    // Upper and lower threshold to start and end work queue draining.
    uint const _stack_trim_upper_threshold;
    uint const _stack_trim_lower_threshold;
  
    Tickspan _trim_ticks;
    // Map from young-age-index (0 == not young, 1 is youngest) to
    // surviving words. base is what we get back from the malloc call
    size_t* _surviving_young_words_base;
    // this points into the array, as we use the first few entries for padding
    size_t* _surviving_young_words;
<span class="line-modified">! </span>
    // Indicates whether in the last generation (old) there is no more space
    // available for allocation.
    bool _old_gen_is_full;
  
  #define PADDING_ELEM_NUM (DEFAULT_CACHE_LINE_SIZE / sizeof(size_t))
  
<span class="line-modified">!   G1DirtyCardQueue&amp; dirty_card_queue()           { return _dcq; }</span>
    G1CardTable* ct()                              { return _ct; }
  
<span class="line-modified">!   InCSetState dest(InCSetState original) const {</span>
      assert(original.is_valid(),
<span class="line-modified">!            &quot;Original state invalid: &quot; CSETSTATE_FORMAT, original.value());</span>
<span class="line-modified">!     assert(_dest[original.value()].is_valid_gen(),</span>
<span class="line-modified">!            &quot;Dest state is invalid: &quot; CSETSTATE_FORMAT, _dest[original.value()].value());</span>
<span class="line-modified">!     return _dest[original.value()];</span>
    }
  
    size_t _num_optional_regions;
    G1OopStarChunkedList* _oops_into_optional_regions;
  
  public:
    G1ParScanThreadState(G1CollectedHeap* g1h,
                         uint worker_id,
                         size_t young_cset_length,
                         size_t optional_cset_length);
    virtual ~G1ParScanThreadState();
  
<span class="line-new-header">--- 43,71 ---</span>
  class HeapRegion;
  class outputStream;
  
  class G1ParScanThreadState : public CHeapObj&lt;mtGC&gt; {
    G1CollectedHeap* _g1h;
<span class="line-modified">!   RefToScanQueue* _refs;</span>
<span class="line-modified">!   G1RedirtyCardsQueue _rdcq;</span>
<span class="line-modified">!   G1CardTable* _ct;</span>
    G1EvacuationRootClosures* _closures;
  
<span class="line-modified">!   G1PLABAllocator* _plab_allocator;</span>
  
<span class="line-modified">!   AgeTable _age_table;</span>
<span class="line-modified">!   G1HeapRegionAttr _dest[G1HeapRegionAttr::Num];</span>
    // Local tenuring threshold.
<span class="line-modified">!   uint _tenuring_threshold;</span>
    G1ScanEvacuatedObjClosure  _scanner;
  
    uint _worker_id;
  
<span class="line-added">+   // Remember the last enqueued card to avoid enqueuing the same card over and over;</span>
<span class="line-added">+   // since we only ever scan a card once, this is sufficient.</span>
<span class="line-added">+   size_t _last_enqueued_card;</span>
<span class="line-added">+ </span>
    // Upper and lower threshold to start and end work queue draining.
    uint const _stack_trim_upper_threshold;
    uint const _stack_trim_lower_threshold;
  
    Tickspan _trim_ticks;
    // Map from young-age-index (0 == not young, 1 is youngest) to
    // surviving words. base is what we get back from the malloc call
    size_t* _surviving_young_words_base;
    // this points into the array, as we use the first few entries for padding
    size_t* _surviving_young_words;
<span class="line-modified">!   // Number of elements in the array above.</span>
<span class="line-added">+   size_t _surviving_words_length;</span>
    // Indicates whether in the last generation (old) there is no more space
    // available for allocation.
    bool _old_gen_is_full;
  
  #define PADDING_ELEM_NUM (DEFAULT_CACHE_LINE_SIZE / sizeof(size_t))
  
<span class="line-modified">!   G1RedirtyCardsQueue&amp; redirty_cards_queue()     { return _rdcq; }</span>
    G1CardTable* ct()                              { return _ct; }
  
<span class="line-modified">!   G1HeapRegionAttr dest(G1HeapRegionAttr original) const {</span>
      assert(original.is_valid(),
<span class="line-modified">!            &quot;Original region attr invalid: %s&quot;, original.get_type_str());</span>
<span class="line-modified">!     assert(_dest[original.type()].is_valid_gen(),</span>
<span class="line-modified">!            &quot;Dest region attr is invalid: %s&quot;, _dest[original.type()].get_type_str());</span>
<span class="line-modified">!     return _dest[original.type()];</span>
    }
  
    size_t _num_optional_regions;
    G1OopStarChunkedList* _oops_into_optional_regions;
  
<span class="line-added">+   G1NUMA* _numa;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Records how many object allocations happened at each node during copy to survivor.</span>
<span class="line-added">+   // Only starts recording when log of gc+heap+numa is enabled and its data is</span>
<span class="line-added">+   // transferred when flushed.</span>
<span class="line-added">+   size_t* _obj_alloc_stat;</span>
<span class="line-added">+ </span>
  public:
    G1ParScanThreadState(G1CollectedHeap* g1h,
<span class="line-added">+                        G1RedirtyCardsQueueSet* rdcqs,</span>
                         uint worker_id,
                         size_t young_cset_length,
                         size_t optional_cset_length);
    virtual ~G1ParScanThreadState();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,36 ***</span>
  #endif // ASSERT
  
    template &lt;class T&gt; void do_oop_ext(T* ref);
    template &lt;class T&gt; void push_on_queue(T* ref);
  
<span class="line-modified">!   template &lt;class T&gt; void enqueue_card_if_tracked(T* p, oop o) {</span>
      assert(!HeapRegion::is_in_same_region(p, o), &quot;Should have filtered out cross-region references already.&quot;);
      assert(!_g1h-&gt;heap_region_containing(p)-&gt;is_young(), &quot;Should have filtered out from-young references already.&quot;);
<span class="line-modified">!     if (!_g1h-&gt;heap_region_containing((HeapWord*)o)-&gt;rem_set()-&gt;is_tracked()) {</span>
        return;
      }
      size_t card_index = ct()-&gt;index_for(p);
      // If the card hasn&#39;t been added to the buffer, do it.
<span class="line-modified">!     if (ct()-&gt;mark_card_deferred(card_index)) {</span>
<span class="line-modified">!       dirty_card_queue().enqueue(ct()-&gt;byte_for_index(card_index));</span>
      }
    }
  
    G1EvacuationRootClosures* closures() { return _closures; }
    uint worker_id() { return _worker_id; }
  
    size_t lab_waste_words() const;
    size_t lab_undo_waste_words() const;
  
<span class="line-modified">!   size_t* surviving_young_words() {</span>
<span class="line-modified">!     // We add one to hide entry 0 which accumulates surviving words for</span>
<span class="line-modified">!     // age -1 regions (i.e. non-young ones)</span>
<span class="line-removed">-     return _surviving_young_words + 1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void flush(size_t* surviving_young_words);</span>
  
  private:
    #define G1_PARTIAL_ARRAY_MASK 0x2
  
    inline bool has_partial_array_mask(oop* ref) const {
<span class="line-new-header">--- 122,42 ---</span>
  #endif // ASSERT
  
    template &lt;class T&gt; void do_oop_ext(T* ref);
    template &lt;class T&gt; void push_on_queue(T* ref);
  
<span class="line-modified">!   template &lt;class T&gt; void enqueue_card_if_tracked(G1HeapRegionAttr region_attr, T* p, oop o) {</span>
      assert(!HeapRegion::is_in_same_region(p, o), &quot;Should have filtered out cross-region references already.&quot;);
      assert(!_g1h-&gt;heap_region_containing(p)-&gt;is_young(), &quot;Should have filtered out from-young references already.&quot;);
<span class="line-modified">! </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+     HeapRegion* const hr_obj = _g1h-&gt;heap_region_containing(o);</span>
<span class="line-added">+     assert(region_attr.needs_remset_update() == hr_obj-&gt;rem_set()-&gt;is_tracked(),</span>
<span class="line-added">+            &quot;State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u&quot;,</span>
<span class="line-added">+            BOOL_TO_STR(region_attr.needs_remset_update()),</span>
<span class="line-added">+            BOOL_TO_STR(hr_obj-&gt;rem_set()-&gt;is_tracked()),</span>
<span class="line-added">+            hr_obj-&gt;hrm_index());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     if (!region_attr.needs_remset_update()) {</span>
        return;
      }
      size_t card_index = ct()-&gt;index_for(p);
      // If the card hasn&#39;t been added to the buffer, do it.
<span class="line-modified">!     if (_last_enqueued_card != card_index) {</span>
<span class="line-modified">!       redirty_cards_queue().enqueue(ct()-&gt;byte_for_index(card_index));</span>
<span class="line-added">+       _last_enqueued_card = card_index;</span>
      }
    }
  
    G1EvacuationRootClosures* closures() { return _closures; }
    uint worker_id() { return _worker_id; }
  
    size_t lab_waste_words() const;
    size_t lab_undo_waste_words() const;
  
<span class="line-modified">!   // Pass locally gathered statistics to global state. Returns the total number of</span>
<span class="line-modified">!   // HeapWords copied.</span>
<span class="line-modified">!   size_t flush(size_t* surviving_young_words);</span>
  
  private:
    #define G1_PARTIAL_ARRAY_MASK 0x2
  
    inline bool has_partial_array_mask(oop* ref) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,44 ***</span>
    inline void deal_with_reference(narrowOop* ref_to_scan);
  
    inline void dispatch_reference(StarTask ref);
  
    // Tries to allocate word_sz in the PLAB of the next &quot;generation&quot; after trying to
<span class="line-modified">!   // allocate into dest. State is the original (source) cset state for the object</span>
<span class="line-modified">!   // that is allocated for. Previous_plab_refill_failed indicates whether previously</span>
<span class="line-removed">-   // a PLAB refill into &quot;state&quot; failed.</span>
    // Returns a non-NULL pointer if successful, and updates dest if required.
    // Also determines whether we should continue to try to allocate into the various
    // generations or just end trying to allocate.
<span class="line-modified">!   HeapWord* allocate_in_next_plab(InCSetState const state,</span>
<span class="line-removed">-                                   InCSetState* dest,</span>
                                    size_t word_sz,
<span class="line-modified">!                                   bool previous_plab_refill_failed);</span>
  
<span class="line-modified">!   inline InCSetState next_state(InCSetState const state, markOop const m, uint&amp; age);</span>
  
<span class="line-modified">!   void report_promotion_event(InCSetState const dest_state,</span>
                                oop const old, size_t word_sz, uint age,
<span class="line-modified">!                               HeapWord * const obj_ptr) const;</span>
  
    inline bool needs_partial_trimming() const;
    inline bool is_partially_trimmed() const;
  
    inline void trim_queue_to_threshold(uint threshold);
  public:
<span class="line-modified">!   oop copy_to_survivor_space(InCSetState const state, oop const obj, markOop const old_mark);</span>
  
    void trim_queue();
    void trim_queue_partially();
  
    Tickspan trim_ticks() const;
    void reset_trim_ticks();
  
    inline void steal_and_trim_queue(RefToScanQueueSet *task_queues);
  
    // An attempt to evacuate &quot;obj&quot; has failed; take necessary steps.
<span class="line-modified">!   oop handle_evacuation_failure_par(oop obj, markOop m);</span>
  
    template &lt;typename T&gt;
    inline void remember_root_into_optional_region(T* p);
    template &lt;typename T&gt;
    inline void remember_reference_into_optional_region(T* p);
<span class="line-new-header">--- 195,49 ---</span>
    inline void deal_with_reference(narrowOop* ref_to_scan);
  
    inline void dispatch_reference(StarTask ref);
  
    // Tries to allocate word_sz in the PLAB of the next &quot;generation&quot; after trying to
<span class="line-modified">!   // allocate into dest. Previous_plab_refill_failed indicates whether previous</span>
<span class="line-modified">!   // PLAB refill for the original (source) object failed.</span>
    // Returns a non-NULL pointer if successful, and updates dest if required.
    // Also determines whether we should continue to try to allocate into the various
    // generations or just end trying to allocate.
<span class="line-modified">!   HeapWord* allocate_in_next_plab(G1HeapRegionAttr* dest,</span>
                                    size_t word_sz,
<span class="line-modified">!                                   bool previous_plab_refill_failed,</span>
<span class="line-added">+                                   uint node_index);</span>
  
<span class="line-modified">!   inline G1HeapRegionAttr next_region_attr(G1HeapRegionAttr const region_attr, markWord const m, uint&amp; age);</span>
  
<span class="line-modified">!   void report_promotion_event(G1HeapRegionAttr const dest_attr,</span>
                                oop const old, size_t word_sz, uint age,
<span class="line-modified">!                               HeapWord * const obj_ptr, uint node_index) const;</span>
  
    inline bool needs_partial_trimming() const;
    inline bool is_partially_trimmed() const;
  
    inline void trim_queue_to_threshold(uint threshold);
<span class="line-added">+ </span>
<span class="line-added">+   // NUMA statistics related methods.</span>
<span class="line-added">+   inline void initialize_numa_stats();</span>
<span class="line-added">+   inline void flush_numa_stats();</span>
<span class="line-added">+   inline void update_numa_stats(uint node_index);</span>
<span class="line-added">+ </span>
  public:
<span class="line-modified">!   oop copy_to_survivor_space(G1HeapRegionAttr const region_attr, oop const obj, markWord const old_mark);</span>
  
    void trim_queue();
    void trim_queue_partially();
  
    Tickspan trim_ticks() const;
    void reset_trim_ticks();
  
    inline void steal_and_trim_queue(RefToScanQueueSet *task_queues);
  
    // An attempt to evacuate &quot;obj&quot; has failed; take necessary steps.
<span class="line-modified">!   oop handle_evacuation_failure_par(oop obj, markWord m);</span>
  
    template &lt;typename T&gt;
    inline void remember_root_into_optional_region(T* p);
    template &lt;typename T&gt;
    inline void remember_reference_into_optional_region(T* p);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,19 ***</span>
<span class="line-new-header">--- 245,21 ---</span>
    inline G1OopStarChunkedList* oops_into_optional_region(const HeapRegion* hr);
  };
  
  class G1ParScanThreadStateSet : public StackObj {
    G1CollectedHeap* _g1h;
<span class="line-added">+   G1RedirtyCardsQueueSet* _rdcqs;</span>
    G1ParScanThreadState** _states;
    size_t* _surviving_young_words_total;
    size_t _young_cset_length;
    size_t _optional_cset_length;
    uint _n_workers;
    bool _flushed;
  
   public:
    G1ParScanThreadStateSet(G1CollectedHeap* g1h,
<span class="line-added">+                           G1RedirtyCardsQueueSet* rdcqs,</span>
                            uint n_workers,
                            size_t young_cset_length,
                            size_t optional_cset_length);
    ~G1ParScanThreadStateSet();
  
</pre>
<center><a href="g1ParScanThreadState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
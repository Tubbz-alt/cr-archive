<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1CardTable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1CARDTABLE_HPP
 26 #define SHARE_GC_G1_G1CARDTABLE_HPP
 27 
 28 #include &quot;gc/g1/g1RegionToSpaceMapper.hpp&quot;
 29 #include &quot;gc/shared/cardTable.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 class G1CardTable;
 34 class G1RegionToSpaceMapper;
 35 
 36 class G1CardTableChangedListener : public G1MappingChangedListener {
 37  private:
 38   G1CardTable* _card_table;
 39  public:
 40   G1CardTableChangedListener() : _card_table(NULL) { }
 41 
 42   void set_card_table(G1CardTable* card_table) { _card_table = card_table; }
 43 
 44   virtual void on_commit(uint start_idx, size_t num_regions, bool zero_filled);
 45 };
 46 
 47 class G1CardTable: public CardTable {
 48   friend class VMStructs;
 49   friend class G1CardTableChangedListener;
 50 
 51   G1CardTableChangedListener _listener;
 52 
 53   enum G1CardValues {
 54     g1_young_gen = CT_MR_BS_last_reserved &lt;&lt; 1
 55   };
 56 
 57 public:
 58   G1CardTable(MemRegion whole_heap): CardTable(whole_heap, /* scanned concurrently */ true), _listener() {
 59     _listener.set_card_table(this);
 60   }
 61   bool is_card_dirty(size_t card_index) {
 62     return _byte_map[card_index] == dirty_card_val();
 63   }
 64 
 65   static CardValue g1_young_card_val() { return g1_young_gen; }
 66 
 67 /*
 68    Claimed and deferred bits are used together in G1 during the evacuation
 69    pause. These bits can have the following state transitions:
 70    1. The claimed bit can be put over any other card state. Except that
 71       the &quot;dirty -&gt; dirty and claimed&quot; transition is checked for in
 72       G1 code and is not used.
 73    2. Deferred bit can be set only if the previous state of the card
 74       was either clean or claimed. mark_card_deferred() is wait-free.
 75       We do not care if the operation is be successful because if
 76       it does not it will only result in duplicate entry in the update
 77       buffer because of the &quot;cache-miss&quot;. So it&#39;s not worth spinning.
 78  */
 79 
 80   bool is_card_claimed(size_t card_index) {
 81     CardValue val = _byte_map[card_index];
 82     return (val &amp; (clean_card_mask_val() | claimed_card_val())) == claimed_card_val();
 83   }
 84 
 85   inline void set_card_claimed(size_t card_index);
 86 
 87   void verify_g1_young_region(MemRegion mr) PRODUCT_RETURN;
 88   void g1_mark_as_young(const MemRegion&amp; mr);
 89 
 90   bool mark_card_deferred(size_t card_index);
 91 
 92   bool is_card_deferred(size_t card_index) {
 93     CardValue val = _byte_map[card_index];
 94     return (val &amp; (clean_card_mask_val() | deferred_card_val())) == deferred_card_val();
 95   }
 96 
 97   static size_t compute_size(size_t mem_region_size_in_words) {
 98     size_t number_of_slots = (mem_region_size_in_words / card_size_in_words);
 99     return ReservedSpace::allocation_align_size_up(number_of_slots);
100   }
101 
102   // Returns how many bytes of the heap a single byte of the Card Table corresponds to.
103   static size_t heap_map_factor() { return card_size; }
104 
105   void initialize() {}
106   void initialize(G1RegionToSpaceMapper* mapper);
107 
108   virtual void resize_covered_region(MemRegion new_region) { ShouldNotReachHere(); }
109 
110   virtual bool is_in_young(oop obj) const;
111 };
112 
113 #endif // SHARE_GC_G1_G1CARDTABLE_HPP
    </pre>
  </body>
</html>
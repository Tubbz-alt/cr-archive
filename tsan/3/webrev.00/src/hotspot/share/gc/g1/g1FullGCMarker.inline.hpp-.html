<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1FullGCMarker.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2018 Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1FULLGCMARKER_INLINE_HPP
 26 #define SHARE_GC_G1_G1FULLGCMARKER_INLINE_HPP
 27 
 28 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 29 #include &quot;gc/g1/g1ConcurrentMarkBitMap.inline.hpp&quot;
 30 #include &quot;gc/g1/g1FullGCMarker.hpp&quot;
 31 #include &quot;gc/g1/g1FullGCOopClosures.inline.hpp&quot;
 32 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 33 #include &quot;gc/g1/g1StringDedupQueue.hpp&quot;
 34 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
 35 #include &quot;oops/access.inline.hpp&quot;
 36 #include &quot;oops/compressedOops.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;utilities/debug.hpp&quot;
 39 
 40 inline bool G1FullGCMarker::mark_object(oop obj) {
 41   // Not marking closed archive objects.
 42   if (G1ArchiveAllocator::is_closed_archive_object(obj)) {
 43     return false;
 44   }
 45 
 46   // Try to mark.
 47   if (!_bitmap-&gt;par_mark(obj)) {
 48     // Lost mark race.
 49     return false;
 50   }
 51 
 52   // Marked by us, preserve if needed.
 53   markOop mark = obj-&gt;mark_raw();
 54   if (mark-&gt;must_be_preserved(obj) &amp;&amp;
 55       !G1ArchiveAllocator::is_open_archive_object(obj)) {
 56     preserved_stack()-&gt;push(obj, mark);
 57   }
 58 
 59   // Check if deduplicatable string.
 60   if (G1StringDedup::is_enabled()) {
 61     G1StringDedup::enqueue_from_mark(obj, _worker_id);
 62   }
 63   return true;
 64 }
 65 
 66 template &lt;class T&gt; inline void G1FullGCMarker::mark_and_push(T* p) {
 67   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 68   if (!CompressedOops::is_null(heap_oop)) {
 69     oop obj = CompressedOops::decode_not_null(heap_oop);
 70     if (mark_object(obj)) {
 71       _oop_stack.push(obj);
 72       assert(_bitmap-&gt;is_marked(obj), &quot;Must be marked now - map self&quot;);
 73     } else {
 74       assert(_bitmap-&gt;is_marked(obj) || G1ArchiveAllocator::is_closed_archive_object(obj),
 75              &quot;Must be marked by other or closed archive object&quot;);
 76     }
 77   }
 78 }
 79 
 80 inline bool G1FullGCMarker::is_empty() {
 81   return _oop_stack.is_empty() &amp;&amp; _objarray_stack.is_empty();
 82 }
 83 
 84 inline bool G1FullGCMarker::pop_object(oop&amp; oop) {
 85   return _oop_stack.pop_overflow(oop) || _oop_stack.pop_local(oop);
 86 }
 87 
 88 inline void G1FullGCMarker::push_objarray(oop obj, size_t index) {
 89   ObjArrayTask task(obj, index);
 90   assert(task.is_valid(), &quot;bad ObjArrayTask&quot;);
 91   _objarray_stack.push(task);
 92 }
 93 
 94 inline bool G1FullGCMarker::pop_objarray(ObjArrayTask&amp; arr) {
 95   return _objarray_stack.pop_overflow(arr) || _objarray_stack.pop_local(arr);
 96 }
 97 
 98 inline void G1FullGCMarker::follow_array(objArrayOop array) {
 99   follow_klass(array-&gt;klass());
100   // Don&#39;t push empty arrays to avoid unnecessary work.
101   if (array-&gt;length() &gt; 0) {
102     push_objarray(array, 0);
103   }
104 }
105 
106 void G1FullGCMarker::follow_array_chunk(objArrayOop array, int index) {
107   const int len = array-&gt;length();
108   const int beg_index = index;
109   assert(beg_index &lt; len || len == 0, &quot;index too large&quot;);
110 
111   const int stride = MIN2(len - beg_index, (int) ObjArrayMarkingStride);
112   const int end_index = beg_index + stride;
113 
114   // Push the continuation first to allow more efficient work stealing.
115   if (end_index &lt; len) {
116     push_objarray(array, end_index);
117   }
118 
119   array-&gt;oop_iterate_range(mark_closure(), beg_index, end_index);
120 
121   if (VerifyDuringGC) {
122     _verify_closure.set_containing_obj(array);
123     array-&gt;oop_iterate_range(&amp;_verify_closure, beg_index, end_index);
124     if (_verify_closure.failures()) {
125       assert(false, &quot;Failed&quot;);
126     }
127   }
128 }
129 
130 inline void G1FullGCMarker::follow_object(oop obj) {
131   assert(_bitmap-&gt;is_marked(obj), &quot;should be marked&quot;);
132   if (obj-&gt;is_objArray()) {
133     // Handle object arrays explicitly to allow them to
134     // be split into chunks if needed.
135     follow_array((objArrayOop)obj);
136   } else {
137     obj-&gt;oop_iterate(mark_closure());
138     if (VerifyDuringGC) {
139       if (obj-&gt;is_instance() &amp;&amp; InstanceKlass::cast(obj-&gt;klass())-&gt;is_reference_instance_klass()) {
140         return;
141       }
142       _verify_closure.set_containing_obj(obj);
143       obj-&gt;oop_iterate(&amp;_verify_closure);
144       if (_verify_closure.failures()) {
145         log_warning(gc, verify)(&quot;Failed after %d&quot;, _verify_closure._cc);
146         assert(false, &quot;Failed&quot;);
147       }
148     }
149   }
150 }
151 
152 void G1FullGCMarker::drain_stack() {
153   do {
154     oop obj;
155     while (pop_object(obj)) {
156       assert(_bitmap-&gt;is_marked(obj), &quot;must be marked&quot;);
157       follow_object(obj);
158     }
159     // Process ObjArrays one at a time to avoid marking stack bloat.
160     ObjArrayTask task;
161     if (pop_objarray(task)) {
162       follow_array_chunk(objArrayOop(task.obj()), task.index());
163     }
164   } while (!is_empty());
165 }
166 
167 inline void G1FullGCMarker::follow_klass(Klass* k) {
168   oop op = k-&gt;class_loader_data()-&gt;holder_no_keepalive();
169   mark_and_push(&amp;op);
170 }
171 
172 inline void G1FullGCMarker::follow_cld(ClassLoaderData* cld) {
173   _cld_closure.do_cld(cld);
174 }
175 
176 #endif // SHARE_GC_G1_G1FULLGCMARKER_INLINE_HPP
    </pre>
  </body>
</html>
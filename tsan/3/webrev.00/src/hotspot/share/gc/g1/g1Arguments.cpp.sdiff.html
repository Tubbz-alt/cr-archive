<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Arguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Analytics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;gc/g1/g1Arguments.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
 30 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;
<span class="line-removed"> 31 #include &quot;gc/g1/g1HeterogeneousCollectorPolicy.hpp&quot;</span>
 32 #include &quot;gc/g1/heapRegion.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/shared/gcArguments.inline.hpp&quot;</span>


 34 #include &quot;gc/shared/workerPolicy.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/globals_extension.hpp&quot;
 37 






















 38 size_t G1Arguments::conservative_max_heap_alignment() {
 39   return HeapRegion::max_region_size();
 40 }
 41 
 42 void G1Arguments::initialize_verification_types() {
 43   if (strlen(VerifyGCType) &gt; 0) {
 44     const char delimiter[] = &quot; ,\n&quot;;
 45     size_t length = strlen(VerifyGCType);
 46     char* type_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
 47     strncpy(type_list, VerifyGCType, length + 1);
 48     char* save_ptr;
 49 
 50     char* token = strtok_r(type_list, delimiter, &amp;save_ptr);
 51     while (token != NULL) {
 52       parse_verification_type(token);
 53       token = strtok_r(NULL, delimiter, &amp;save_ptr);
 54     }
 55     FREE_C_HEAP_ARRAY(char, type_list);
 56   }
 57 }
</pre>
<hr />
<pre>
 71     G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyFull);
 72   } else {
 73     log_warning(gc, verify)(&quot;VerifyGCType: &#39;%s&#39; is unknown. Available types are: &quot;
 74                             &quot;young-normal, concurrent-start, mixed, remark, cleanup and full&quot;, type);
 75   }
 76 }
 77 
 78 void G1Arguments::initialize() {
 79   GCArguments::initialize();
 80   assert(UseG1GC, &quot;Error&quot;);
 81   FLAG_SET_DEFAULT(ParallelGCThreads, WorkerPolicy::parallel_worker_threads());
 82   if (ParallelGCThreads == 0) {
 83     assert(!FLAG_IS_DEFAULT(ParallelGCThreads), &quot;The default value for ParallelGCThreads should not be 0.&quot;);
 84     vm_exit_during_initialization(&quot;The flag -XX:+UseG1GC can not be combined with -XX:ParallelGCThreads=0&quot;, NULL);
 85   }
 86 
 87   // When dumping the CDS archive we want to reduce fragmentation by
 88   // triggering a full collection. To get as low fragmentation as
 89   // possible we only use one worker thread.
 90   if (DumpSharedSpaces) {
<span class="line-modified"> 91     FLAG_SET_ERGO(uint, ParallelGCThreads, 1);</span>
 92   }
 93 
 94   if (FLAG_IS_DEFAULT(G1ConcRefinementThreads)) {
<span class="line-modified"> 95     FLAG_SET_ERGO(uint, G1ConcRefinementThreads, ParallelGCThreads);</span>
 96   }
 97 
 98   // MarkStackSize will be set (if it hasn&#39;t been set by the user)
 99   // when concurrent marking is initialized.
100   // Its value will be based upon the number of parallel marking threads.
101   // But we do set the maximum mark stack size here.
102   if (FLAG_IS_DEFAULT(MarkStackSizeMax)) {
103     FLAG_SET_DEFAULT(MarkStackSizeMax, 128 * TASKQUEUE_SIZE);
104   }
105 
106   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {
107     // In G1, we want the default GC overhead goal to be higher than
108     // it is for PS, or the heap might be expanded too aggressively.
109     // We set it here to ~8%.
110     FLAG_SET_DEFAULT(GCTimeRatio, 12);
111   }
112 
113   // Below, we might need to calculate the pause time interval based on
114   // the pause target. When we do so we are going to give G1 maximum
115   // flexibility and allow it to do pauses when it needs to. So, we&#39;ll
</pre>
<hr />
<pre>
123   if (FLAG_IS_DEFAULT(MaxGCPauseMillis)) {
124     // The default pause time target in G1 is 200ms
125     FLAG_SET_DEFAULT(MaxGCPauseMillis, 200);
126   }
127 
128   // Then, if the interval parameter was not set, set it according to
129   // the pause time target (this will also deal with the case when the
130   // pause time target is the default value).
131   if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {
132     FLAG_SET_DEFAULT(GCPauseIntervalMillis, MaxGCPauseMillis + 1);
133   }
134 
135   if (FLAG_IS_DEFAULT(ParallelRefProcEnabled) &amp;&amp; ParallelGCThreads &gt; 1) {
136     FLAG_SET_DEFAULT(ParallelRefProcEnabled, true);
137   }
138 
139   log_trace(gc)(&quot;MarkStackSize: %uk  MarkStackSizeMax: %uk&quot;, (unsigned int) (MarkStackSize / K), (uint) (MarkStackSizeMax / K));
140 
141   // By default do not let the target stack size to be more than 1/4 of the entries
142   if (FLAG_IS_DEFAULT(GCDrainStackTargetSize)) {
<span class="line-modified">143     FLAG_SET_ERGO(uintx, GCDrainStackTargetSize, MIN2(GCDrainStackTargetSize, (uintx)TASKQUEUE_SIZE / 4));</span>
144   }
145 
146 #ifdef COMPILER2
147   // Enable loop strip mining to offer better pause time guarantees
148   if (FLAG_IS_DEFAULT(UseCountedLoopSafepoints)) {
149     FLAG_SET_DEFAULT(UseCountedLoopSafepoints, true);
150     if (FLAG_IS_DEFAULT(LoopStripMiningIter)) {
151       FLAG_SET_DEFAULT(LoopStripMiningIter, 1000);
152     }
153   }
154 #endif
155 
156   initialize_verification_types();
157 }
158 
<span class="line-modified">159 CollectedHeap* G1Arguments::create_heap() {</span>
<span class="line-modified">160   if (AllocateOldGenAt != NULL) {</span>
<span class="line-modified">161     return create_heap_with_policy&lt;G1CollectedHeap, G1HeterogeneousCollectorPolicy&gt;();</span>



162   } else {
<span class="line-modified">163     return create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;();</span>












































164   }












165 }
















</pre>
</td>
<td>
<hr />
<pre>
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;gc/g1/g1Arguments.hpp&quot;
 28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;

 29 #include &quot;gc/g1/g1HeapVerifier.hpp&quot;

 30 #include &quot;gc/g1/heapRegion.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shared/cardTableRS.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
 34 #include &quot;gc/shared/workerPolicy.hpp&quot;
 35 #include &quot;runtime/globals.hpp&quot;
 36 #include &quot;runtime/globals_extension.hpp&quot;
 37 
<span class="line-added"> 38 static const double MaxRamFractionForYoung = 0.8;</span>
<span class="line-added"> 39 size_t G1Arguments::MaxMemoryForYoung;</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 static size_t calculate_heap_alignment(size_t space_alignment) {</span>
<span class="line-added"> 42   size_t card_table_alignment = CardTableRS::ct_max_alignment_constraint();</span>
<span class="line-added"> 43   size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();</span>
<span class="line-added"> 44   return MAX3(card_table_alignment, space_alignment, page_size);</span>
<span class="line-added"> 45 }</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 void G1Arguments::initialize_alignments() {</span>
<span class="line-added"> 48   // Set up the region size and associated fields.</span>
<span class="line-added"> 49   //</span>
<span class="line-added"> 50   // There is a circular dependency here. We base the region size on the heap</span>
<span class="line-added"> 51   // size, but the heap size should be aligned with the region size. To get</span>
<span class="line-added"> 52   // around this we use the unaligned values for the heap.</span>
<span class="line-added"> 53   HeapRegion::setup_heap_region_size(InitialHeapSize, MaxHeapSize);</span>
<span class="line-added"> 54   HeapRegionRemSet::setup_remset_size();</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56   SpaceAlignment = HeapRegion::GrainBytes;</span>
<span class="line-added"> 57   HeapAlignment = calculate_heap_alignment(SpaceAlignment);</span>
<span class="line-added"> 58 }</span>
<span class="line-added"> 59 </span>
 60 size_t G1Arguments::conservative_max_heap_alignment() {
 61   return HeapRegion::max_region_size();
 62 }
 63 
 64 void G1Arguments::initialize_verification_types() {
 65   if (strlen(VerifyGCType) &gt; 0) {
 66     const char delimiter[] = &quot; ,\n&quot;;
 67     size_t length = strlen(VerifyGCType);
 68     char* type_list = NEW_C_HEAP_ARRAY(char, length + 1, mtInternal);
 69     strncpy(type_list, VerifyGCType, length + 1);
 70     char* save_ptr;
 71 
 72     char* token = strtok_r(type_list, delimiter, &amp;save_ptr);
 73     while (token != NULL) {
 74       parse_verification_type(token);
 75       token = strtok_r(NULL, delimiter, &amp;save_ptr);
 76     }
 77     FREE_C_HEAP_ARRAY(char, type_list);
 78   }
 79 }
</pre>
<hr />
<pre>
 93     G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyFull);
 94   } else {
 95     log_warning(gc, verify)(&quot;VerifyGCType: &#39;%s&#39; is unknown. Available types are: &quot;
 96                             &quot;young-normal, concurrent-start, mixed, remark, cleanup and full&quot;, type);
 97   }
 98 }
 99 
100 void G1Arguments::initialize() {
101   GCArguments::initialize();
102   assert(UseG1GC, &quot;Error&quot;);
103   FLAG_SET_DEFAULT(ParallelGCThreads, WorkerPolicy::parallel_worker_threads());
104   if (ParallelGCThreads == 0) {
105     assert(!FLAG_IS_DEFAULT(ParallelGCThreads), &quot;The default value for ParallelGCThreads should not be 0.&quot;);
106     vm_exit_during_initialization(&quot;The flag -XX:+UseG1GC can not be combined with -XX:ParallelGCThreads=0&quot;, NULL);
107   }
108 
109   // When dumping the CDS archive we want to reduce fragmentation by
110   // triggering a full collection. To get as low fragmentation as
111   // possible we only use one worker thread.
112   if (DumpSharedSpaces) {
<span class="line-modified">113     FLAG_SET_ERGO(ParallelGCThreads, 1);</span>
114   }
115 
116   if (FLAG_IS_DEFAULT(G1ConcRefinementThreads)) {
<span class="line-modified">117     FLAG_SET_ERGO(G1ConcRefinementThreads, ParallelGCThreads);</span>
118   }
119 
120   // MarkStackSize will be set (if it hasn&#39;t been set by the user)
121   // when concurrent marking is initialized.
122   // Its value will be based upon the number of parallel marking threads.
123   // But we do set the maximum mark stack size here.
124   if (FLAG_IS_DEFAULT(MarkStackSizeMax)) {
125     FLAG_SET_DEFAULT(MarkStackSizeMax, 128 * TASKQUEUE_SIZE);
126   }
127 
128   if (FLAG_IS_DEFAULT(GCTimeRatio) || GCTimeRatio == 0) {
129     // In G1, we want the default GC overhead goal to be higher than
130     // it is for PS, or the heap might be expanded too aggressively.
131     // We set it here to ~8%.
132     FLAG_SET_DEFAULT(GCTimeRatio, 12);
133   }
134 
135   // Below, we might need to calculate the pause time interval based on
136   // the pause target. When we do so we are going to give G1 maximum
137   // flexibility and allow it to do pauses when it needs to. So, we&#39;ll
</pre>
<hr />
<pre>
145   if (FLAG_IS_DEFAULT(MaxGCPauseMillis)) {
146     // The default pause time target in G1 is 200ms
147     FLAG_SET_DEFAULT(MaxGCPauseMillis, 200);
148   }
149 
150   // Then, if the interval parameter was not set, set it according to
151   // the pause time target (this will also deal with the case when the
152   // pause time target is the default value).
153   if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {
154     FLAG_SET_DEFAULT(GCPauseIntervalMillis, MaxGCPauseMillis + 1);
155   }
156 
157   if (FLAG_IS_DEFAULT(ParallelRefProcEnabled) &amp;&amp; ParallelGCThreads &gt; 1) {
158     FLAG_SET_DEFAULT(ParallelRefProcEnabled, true);
159   }
160 
161   log_trace(gc)(&quot;MarkStackSize: %uk  MarkStackSizeMax: %uk&quot;, (unsigned int) (MarkStackSize / K), (uint) (MarkStackSizeMax / K));
162 
163   // By default do not let the target stack size to be more than 1/4 of the entries
164   if (FLAG_IS_DEFAULT(GCDrainStackTargetSize)) {
<span class="line-modified">165     FLAG_SET_ERGO(GCDrainStackTargetSize, MIN2(GCDrainStackTargetSize, (uintx)TASKQUEUE_SIZE / 4));</span>
166   }
167 
168 #ifdef COMPILER2
169   // Enable loop strip mining to offer better pause time guarantees
170   if (FLAG_IS_DEFAULT(UseCountedLoopSafepoints)) {
171     FLAG_SET_DEFAULT(UseCountedLoopSafepoints, true);
172     if (FLAG_IS_DEFAULT(LoopStripMiningIter)) {
173       FLAG_SET_DEFAULT(LoopStripMiningIter, 1000);
174     }
175   }
176 #endif
177 
178   initialize_verification_types();
179 }
180 
<span class="line-modified">181 static size_t calculate_reasonable_max_memory_for_young(FormatBuffer&lt;100&gt; &amp;calc_str, double max_ram_fraction_for_young) {</span>
<span class="line-modified">182   julong phys_mem;</span>
<span class="line-modified">183   // If MaxRam is specified, we use that as maximum physical memory available.</span>
<span class="line-added">184   if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="line-added">185     phys_mem = os::physical_memory();</span>
<span class="line-added">186     calc_str.append(&quot;Physical_Memory&quot;);</span>
187   } else {
<span class="line-modified">188     phys_mem = (julong)MaxRAM;</span>
<span class="line-added">189     calc_str.append(&quot;MaxRAM&quot;);</span>
<span class="line-added">190   }</span>
<span class="line-added">191 </span>
<span class="line-added">192   julong reasonable_max = phys_mem;</span>
<span class="line-added">193 </span>
<span class="line-added">194   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate</span>
<span class="line-added">195   // reasonable max size of young generation.</span>
<span class="line-added">196   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {</span>
<span class="line-added">197     reasonable_max = (julong)(phys_mem / MaxRAMFraction);</span>
<span class="line-added">198     calc_str.append(&quot; / MaxRAMFraction&quot;);</span>
<span class="line-added">199   }  else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {</span>
<span class="line-added">200     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);</span>
<span class="line-added">201     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);</span>
<span class="line-added">202   }  else {</span>
<span class="line-added">203     // We use our own fraction to calculate max size of young generation.</span>
<span class="line-added">204     reasonable_max = phys_mem * max_ram_fraction_for_young;</span>
<span class="line-added">205     calc_str.append(&quot; * %0.2f&quot;, max_ram_fraction_for_young);</span>
<span class="line-added">206   }</span>
<span class="line-added">207 </span>
<span class="line-added">208   return (size_t)reasonable_max;</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 void G1Arguments::initialize_heap_flags_and_sizes() {</span>
<span class="line-added">212   if (AllocateOldGenAt != NULL) {</span>
<span class="line-added">213     initialize_heterogeneous();</span>
<span class="line-added">214   }</span>
<span class="line-added">215 </span>
<span class="line-added">216   GCArguments::initialize_heap_flags_and_sizes();</span>
<span class="line-added">217 }</span>
<span class="line-added">218 </span>
<span class="line-added">219 void G1Arguments::initialize_heterogeneous() {</span>
<span class="line-added">220   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);</span>
<span class="line-added">221 </span>
<span class="line-added">222   MaxMemoryForYoung = calculate_reasonable_max_memory_for_young(calc_str, MaxRamFractionForYoung);</span>
<span class="line-added">223 </span>
<span class="line-added">224   if (MaxNewSize &gt; MaxMemoryForYoung) {</span>
<span class="line-added">225     if (FLAG_IS_CMDLINE(MaxNewSize)) {</span>
<span class="line-added">226       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">227                             MaxMemoryForYoung, calc_str.buffer());</span>
<span class="line-added">228     } else {</span>
<span class="line-added">229       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;</span>
<span class="line-added">230                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, MaxMemoryForYoung, calc_str.buffer());</span>
<span class="line-added">231     }</span>
<span class="line-added">232     MaxNewSize = MaxMemoryForYoung;</span>
233   }
<span class="line-added">234   if (NewSize &gt; MaxMemoryForYoung) {</span>
<span class="line-added">235     if (FLAG_IS_CMDLINE(NewSize)) {</span>
<span class="line-added">236       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">237                             MaxMemoryForYoung, calc_str.buffer());</span>
<span class="line-added">238     }</span>
<span class="line-added">239     NewSize = MaxMemoryForYoung;</span>
<span class="line-added">240   }</span>
<span class="line-added">241 </span>
<span class="line-added">242 }</span>
<span class="line-added">243 </span>
<span class="line-added">244 CollectedHeap* G1Arguments::create_heap() {</span>
<span class="line-added">245   return new G1CollectedHeap();</span>
246 }
<span class="line-added">247 </span>
<span class="line-added">248 bool G1Arguments::is_heterogeneous_heap() {</span>
<span class="line-added">249   return AllocateOldGenAt != NULL;</span>
<span class="line-added">250 }</span>
<span class="line-added">251 </span>
<span class="line-added">252 size_t G1Arguments::reasonable_max_memory_for_young() {</span>
<span class="line-added">253   return MaxMemoryForYoung;</span>
<span class="line-added">254 }</span>
<span class="line-added">255 </span>
<span class="line-added">256 size_t G1Arguments::heap_reserved_size_bytes() {</span>
<span class="line-added">257   return (is_heterogeneous_heap() ? 2 : 1) * MaxHeapSize;</span>
<span class="line-added">258 }</span>
<span class="line-added">259 </span>
<span class="line-added">260 size_t G1Arguments::heap_max_size_bytes() {</span>
<span class="line-added">261   return MaxHeapSize;</span>
<span class="line-added">262 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="g1Analytics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
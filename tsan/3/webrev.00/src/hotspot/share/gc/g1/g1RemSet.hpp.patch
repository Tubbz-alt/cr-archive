diff a/src/hotspot/share/gc/g1/g1RemSet.hpp b/src/hotspot/share/gc/g1/g1RemSet.hpp
--- a/src/hotspot/share/gc/g1/g1RemSet.hpp
+++ b/src/hotspot/share/gc/g1/g1RemSet.hpp
@@ -44,13 +44,13 @@
 class G1CollectedHeap;
 class G1CMBitMap;
 class G1HotCardCache;
 class G1RemSetScanState;
 class G1ParScanThreadState;
+class G1ParScanThreadStateSet;
 class G1Policy;
-class G1ScanObjsDuringScanRSClosure;
-class G1ScanObjsDuringUpdateRSClosure;
+class G1ScanCardClosure;
 class HeapRegionClaimer;
 
 // A G1RemSet in which each heap region has a rem set that records the
 // external heap references into it.  Uses a mod ref bs to track updates,
 // so that they can be used to update the individual region remsets.
@@ -58,25 +58,17 @@
 private:
   G1RemSetScanState* _scan_state;
 
   G1RemSetSummary _prev_period_summary;
 
-  // Scan all remembered sets of the collection set for references into the collection
-  // set.
-  void scan_rem_set(G1ParScanThreadState* pss, uint worker_i);
-
-  // Flush remaining refinement buffers for cross-region references to either evacuate references
-  // into the collection set or update the remembered set.
-  void update_rem_set(G1ParScanThreadState* pss, uint worker_i);
-
   G1CollectedHeap* _g1h;
-  size_t _num_conc_refined_cards; // Number of cards refined concurrently to the mutator.
 
   G1CardTable*           _ct;
   G1Policy*              _g1p;
   G1HotCardCache*        _hot_card_cache;
 
+  void print_merge_heap_roots_stats();
 public:
 
   typedef CardTable::CardValue CardValue;
   // Gives an approximation on how many threads can be expected to add records to
   // a remembered set in parallel. This can be used for sizing data structures to
@@ -91,92 +83,60 @@
   G1RemSet(G1CollectedHeap* g1h,
            G1CardTable* ct,
            G1HotCardCache* hot_card_cache);
   ~G1RemSet();
 
-  // Process all oops in the collection set from the cards in the refinement buffers and
-  // remembered sets using pss.
-  //
-  // Further applies heap_region_codeblobs on the oops of the unmarked nmethods on the strong code
-  // roots list for each region in the collection set.
-  void oops_into_collection_set_do(G1ParScanThreadState* pss, uint worker_i);
-
-  // Prepare for and cleanup after an oops_into_collection_set_do
-  // call.  Must call each of these once before and after (in sequential
-  // code) any thread calls oops_into_collection_set_do.
-  void prepare_for_oops_into_collection_set_do();
-  void cleanup_after_oops_into_collection_set_do();
-
-  G1RemSetScanState* scan_state() const { return _scan_state; }
-
-  // Refine the card corresponding to "card_ptr". Safe to be called concurrently
-  // to the mutator.
-  void refine_card_concurrently(CardValue* card_ptr,
-                                uint worker_i);
-
-  // Refine the card corresponding to "card_ptr", applying the given closure to
-  // all references found. Must only be called during gc.
-  // Returns whether the card has been scanned.
-  bool refine_card_during_gc(CardValue* card_ptr, G1ScanObjsDuringUpdateRSClosure* update_rs_cl);
+  // Scan all cards in the non-collection set regions that potentially contain
+  // references into the current whole collection set.
+  void scan_heap_roots(G1ParScanThreadState* pss,
+                       uint worker_id,
+                       G1GCPhaseTimes::GCParPhases scan_phase,
+                       G1GCPhaseTimes::GCParPhases objcopy_phase);
+
+  // Merge cards from various sources (remembered sets, hot card cache, log buffers)
+  // and calculate the cards that need to be scanned later (via scan_heap_roots()).
+  // If initial_evacuation is set, this is called during the initial evacuation.
+  void merge_heap_roots(bool initial_evacuation);
+
+  // Prepare for and cleanup after scanning the heap roots. Must be called
+  // once before and after in sequential code.
+  void prepare_for_scan_heap_roots();
+  // Cleans the card table from temporary duplicate detection information.
+  void cleanup_after_scan_heap_roots();
+  // Excludes the given region from heap root scanning.
+  void exclude_region_from_scan(uint region_idx);
+  // Creates a snapshot of the current _top values at the start of collection to
+  // filter out card marks that we do not want to scan.
+  void prepare_region_for_scan(HeapRegion* region);
+
+  // Do work for regions in the current increment of the collection set, scanning
+  // non-card based (heap) roots.
+  void scan_collection_set_regions(G1ParScanThreadState* pss,
+                                   uint worker_id,
+                                   G1GCPhaseTimes::GCParPhases scan_phase,
+                                   G1GCPhaseTimes::GCParPhases coderoots_phase,
+                                   G1GCPhaseTimes::GCParPhases objcopy_phase);
+
+  // Two methods for concurrent refinement support, executed concurrently to
+  // the mutator:
+  // Cleans the card at "*card_ptr_addr" before refinement, returns true iff the
+  // card needs later refinement. Note that "*card_ptr_addr" could be updated to
+  // a different card due to use of hot card cache.
+  bool clean_card_before_refine(CardValue** const card_ptr_addr);
+  // Refine the region corresponding to "card_ptr". Must be called after
+  // being filtered by clean_card_before_refine(), and after proper
+  // fence/synchronization.
+  void refine_card_concurrently(CardValue* const card_ptr,
+                                const uint worker_id);
 
   // Print accumulated summary info from the start of the VM.
   void print_summary_info();
 
   // Print accumulated summary info from the last time called.
   void print_periodic_summary_info(const char* header, uint period_count);
 
-  size_t num_conc_refined_cards() const { return _num_conc_refined_cards; }
-
   // Rebuilds the remembered set by scanning from bottom to TARS for all regions
   // using the given work gang.
   void rebuild_rem_set(G1ConcurrentMark* cm, WorkGang* workers, uint worker_id_offset);
 };
 
-class G1ScanRSForRegionClosure : public HeapRegionClosure {
-  G1CollectedHeap* _g1h;
-  G1CardTable *_ct;
-
-  G1ParScanThreadState* _pss;
-  G1ScanObjsDuringScanRSClosure* _scan_objs_on_card_cl;
-
-  G1RemSetScanState* _scan_state;
-
-  G1GCPhaseTimes::GCParPhases _phase;
-
-  uint   _worker_i;
-
-  size_t _cards_scanned;
-  size_t _cards_claimed;
-  size_t _cards_skipped;
-
-  Tickspan _rem_set_root_scan_time;
-  Tickspan _rem_set_trim_partially_time;
-
-  Tickspan _strong_code_root_scan_time;
-  Tickspan _strong_code_trim_partially_time;
-
-  void claim_card(size_t card_index, const uint region_idx_for_card);
-  void scan_card(MemRegion mr, uint region_idx_for_card);
-
-  void scan_rem_set_roots(HeapRegion* r);
-  void scan_strong_code_roots(HeapRegion* r);
-public:
-  G1ScanRSForRegionClosure(G1RemSetScanState* scan_state,
-                           G1ScanObjsDuringScanRSClosure* scan_obj_on_card,
-                           G1ParScanThreadState* pss,
-                           G1GCPhaseTimes::GCParPhases phase,
-                           uint worker_i);
-
-  bool do_heap_region(HeapRegion* r);
-
-  Tickspan rem_set_root_scan_time() const { return _rem_set_root_scan_time; }
-  Tickspan rem_set_trim_partially_time() const { return _rem_set_trim_partially_time; }
-
-  Tickspan strong_code_root_scan_time() const { return _strong_code_root_scan_time;  }
-  Tickspan strong_code_root_trim_partially_time() const { return _strong_code_trim_partially_time; }
-
-  size_t cards_scanned() const { return _cards_scanned; }
-  size_t cards_claimed() const { return _cards_claimed; }
-  size_t cards_skipped() const { return _cards_skipped; }
-};
-
 #endif // SHARE_GC_G1_G1REMSET_HPP

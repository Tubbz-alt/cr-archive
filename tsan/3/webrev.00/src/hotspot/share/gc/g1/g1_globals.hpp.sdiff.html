<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1YoungRemSetSamplingThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1_GLOBALS_HPP
 26 #define SHARE_GC_G1_G1_GLOBALS_HPP
 27 
<span class="line-modified"> 28 #include &lt;float.h&gt; // for DBL_MAX</span>

 29 //
 30 // Defines all globals flags used by the garbage-first compiler.
 31 //
 32 
 33 #define GC_G1_FLAGS(develop,                                                \
 34                     develop_pd,                                             \
 35                     product,                                                \
 36                     product_pd,                                             \
 37                     diagnostic,                                             \
 38                     diagnostic_pd,                                          \
 39                     experimental,                                           \
 40                     notproduct,                                             \
 41                     manageable,                                             \
 42                     product_rw,                                             \
 43                     lp64_product,                                           \
 44                     range,                                                  \
<span class="line-modified"> 45                     constraint,                                             \</span>
<span class="line-removed"> 46                     writeable)                                              \</span>
 47                                                                             \
 48   product(bool, G1UseAdaptiveIHOP, true,                                    \
 49           &quot;Adaptively adjust the initiating heap occupancy from the &quot;       \
 50           &quot;initial value of InitiatingHeapOccupancyPercent. The policy &quot;    \
 51           &quot;attempts to start marking in time based on application &quot;         \
 52           &quot;behavior.&quot;)                                                      \
 53                                                                             \
 54   experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \
 55           &quot;How many completed time periods from initial mark to first &quot;     \
 56           &quot;mixed gc are required to use the input values for prediction &quot;   \
 57           &quot;of the optimal occupancy to start marking.&quot;)                     \
 58           range(1, max_intx)                                                \
 59                                                                             \
 60   product(uintx, G1ConfidencePercent, 50,                                   \
 61           &quot;Confidence level for MMU/pause predictions&quot;)                     \
 62           range(0, 100)                                                     \
 63                                                                             \
 64   diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \
 65           &quot;The period (in number of GCs) at which we will generate &quot;        \
 66           &quot;update buffer processing info &quot;                                  \
</pre>
<hr />
<pre>
186           range(-1, max_jint)                                               \
187                                                                             \
188   product(uintx, G1ReservePercent, 10,                                      \
189           &quot;It determines the minimum reserve we should have in the heap &quot;   \
190           &quot;to minimize the probability of promotion failure.&quot;)              \
191           range(0, 50)                                                      \
192                                                                             \
193   product(size_t, G1HeapRegionSize, 0,                                      \
194           &quot;Size of the G1 regions.&quot;)                                        \
195           range(0, 32*M)                                                    \
196           constraint(G1HeapRegionSizeConstraintFunc,AfterMemoryInit)        \
197                                                                             \
198   product(uint, G1ConcRefinementThreads, 0,                                 \
199           &quot;The number of parallel rem set update threads. &quot;                 \
200           &quot;Will be set ergonomically by default.&quot;)                          \
201           range(0, (max_jint-1)/wordSize)                                   \
202                                                                             \
203   develop(bool, G1VerifyCTCleanup, false,                                   \
204           &quot;Verify card table cleanup.&quot;)                                     \
205                                                                             \
<span class="line-removed">206   product(size_t, G1RSetScanBlockSize, 64,                                  \</span>
<span class="line-removed">207           &quot;Size of a work unit of cards claimed by a worker thread&quot;         \</span>
<span class="line-removed">208           &quot;during RSet scanning.&quot;)                                          \</span>
<span class="line-removed">209           range(1, max_uintx)                                               \</span>
<span class="line-removed">210                                                                             \</span>
211   develop(uintx, G1DummyRegionsPerGC, 0,                                    \
212           &quot;The number of dummy regions G1 will allocate at the end of &quot;     \
213           &quot;each evacuation pause in order to artificially fill up the &quot;     \
214           &quot;heap and stress the marking implementation.&quot;)                    \
215                                                                             \
216   develop(bool, G1ExitOnExpansionFailure, false,                            \
217           &quot;Raise a fatal VM exit out of memory failure in the event &quot;       \
218           &quot; that heap expansion fails due to running out of swap.&quot;)         \
219                                                                             \
220   experimental(uintx, G1MaxNewSizePercent, 60,                              \
221           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
222           &quot; maximum young gen size.&quot;)                                       \
223           range(0, 100)                                                     \
224           constraint(G1MaxNewSizePercentConstraintFunc,AfterErgo)           \
225                                                                             \
226   experimental(uintx, G1NewSizePercent, 5,                                  \
227           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
228           &quot;minimum young gen size.&quot;)                                        \
229           range(0, 100)                                                     \
230           constraint(G1NewSizePercentConstraintFunc,AfterErgo)              \
231                                                                             \
232   experimental(uintx, G1MixedGCLiveThresholdPercent, 85,                    \
233           &quot;Threshold for regions to be considered for inclusion in the &quot;    \
234           &quot;collection set of mixed GCs. &quot;                                   \
235           &quot;Regions with live bytes exceeding this will not be collected.&quot;)  \
236           range(0, 100)                                                     \
237                                                                             \
238   product(uintx, G1HeapWastePercent, 5,                                     \
239           &quot;Amount of space, expressed as a percentage of the heap size, &quot;   \
240           &quot;that G1 is willing not to collect to avoid expensive GCs.&quot;)      \
241           range(0, 100)                                                     \
242                                                                             \
243   product(uintx, G1MixedGCCountTarget, 8,                                   \
244           &quot;The target number of mixed GCs after a marking cycle.&quot;)          \
245           range(0, max_uintx)                                               \
246                                                                             \
<span class="line-removed">247   experimental(bool, G1PretouchAuxiliaryMemory, false,                      \</span>
<span class="line-removed">248           &quot;Pre-touch large auxiliary data structures used by the GC.&quot;)      \</span>
<span class="line-removed">249                                                                             \</span>
250   experimental(bool, G1EagerReclaimHumongousObjects, true,                  \
251           &quot;Try to reclaim dead large objects at every young GC.&quot;)           \
252                                                                             \
253   experimental(bool, G1EagerReclaimHumongousObjectsWithStaleRefs, true,     \
254           &quot;Try to reclaim dead large objects that have a few stale &quot;        \
255           &quot;references at every young GC.&quot;)                                  \
256                                                                             \
257   experimental(size_t, G1RebuildRemSetChunkSize, 256 * K,                   \
258           &quot;Chunk size used for rebuilding the remembered set.&quot;)             \
259           range(4 * K, 32 * M)                                              \
260                                                                             \
261   experimental(uintx, G1OldCSetRegionThresholdPercent, 10,                  \
262           &quot;An upper bound for the number of old CSet regions expressed &quot;    \
263           &quot;as a percentage of the heap size.&quot;)                              \
264           range(0, 100)                                                     \
265                                                                             \
266   notproduct(bool, G1EvacuationFailureALot, false,                          \
267           &quot;Force use of evacuation failure handling during certain &quot;        \
268           &quot;evacuation pauses&quot;)                                              \
269                                                                             \
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_G1_G1_GLOBALS_HPP
 26 #define SHARE_GC_G1_G1_GLOBALS_HPP
 27 
<span class="line-modified"> 28 #include &quot;runtime/globals_shared.hpp&quot;</span>
<span class="line-added"> 29 </span>
 30 //
 31 // Defines all globals flags used by the garbage-first compiler.
 32 //
 33 
 34 #define GC_G1_FLAGS(develop,                                                \
 35                     develop_pd,                                             \
 36                     product,                                                \
 37                     product_pd,                                             \
 38                     diagnostic,                                             \
 39                     diagnostic_pd,                                          \
 40                     experimental,                                           \
 41                     notproduct,                                             \
 42                     manageable,                                             \
 43                     product_rw,                                             \
 44                     lp64_product,                                           \
 45                     range,                                                  \
<span class="line-modified"> 46                     constraint)                                             \</span>

 47                                                                             \
 48   product(bool, G1UseAdaptiveIHOP, true,                                    \
 49           &quot;Adaptively adjust the initiating heap occupancy from the &quot;       \
 50           &quot;initial value of InitiatingHeapOccupancyPercent. The policy &quot;    \
 51           &quot;attempts to start marking in time based on application &quot;         \
 52           &quot;behavior.&quot;)                                                      \
 53                                                                             \
 54   experimental(size_t, G1AdaptiveIHOPNumInitialSamples, 3,                  \
 55           &quot;How many completed time periods from initial mark to first &quot;     \
 56           &quot;mixed gc are required to use the input values for prediction &quot;   \
 57           &quot;of the optimal occupancy to start marking.&quot;)                     \
 58           range(1, max_intx)                                                \
 59                                                                             \
 60   product(uintx, G1ConfidencePercent, 50,                                   \
 61           &quot;Confidence level for MMU/pause predictions&quot;)                     \
 62           range(0, 100)                                                     \
 63                                                                             \
 64   diagnostic(intx, G1SummarizeRSetStatsPeriod, 0,                           \
 65           &quot;The period (in number of GCs) at which we will generate &quot;        \
 66           &quot;update buffer processing info &quot;                                  \
</pre>
<hr />
<pre>
186           range(-1, max_jint)                                               \
187                                                                             \
188   product(uintx, G1ReservePercent, 10,                                      \
189           &quot;It determines the minimum reserve we should have in the heap &quot;   \
190           &quot;to minimize the probability of promotion failure.&quot;)              \
191           range(0, 50)                                                      \
192                                                                             \
193   product(size_t, G1HeapRegionSize, 0,                                      \
194           &quot;Size of the G1 regions.&quot;)                                        \
195           range(0, 32*M)                                                    \
196           constraint(G1HeapRegionSizeConstraintFunc,AfterMemoryInit)        \
197                                                                             \
198   product(uint, G1ConcRefinementThreads, 0,                                 \
199           &quot;The number of parallel rem set update threads. &quot;                 \
200           &quot;Will be set ergonomically by default.&quot;)                          \
201           range(0, (max_jint-1)/wordSize)                                   \
202                                                                             \
203   develop(bool, G1VerifyCTCleanup, false,                                   \
204           &quot;Verify card table cleanup.&quot;)                                     \
205                                                                             \





206   develop(uintx, G1DummyRegionsPerGC, 0,                                    \
207           &quot;The number of dummy regions G1 will allocate at the end of &quot;     \
208           &quot;each evacuation pause in order to artificially fill up the &quot;     \
209           &quot;heap and stress the marking implementation.&quot;)                    \
210                                                                             \
211   develop(bool, G1ExitOnExpansionFailure, false,                            \
212           &quot;Raise a fatal VM exit out of memory failure in the event &quot;       \
213           &quot; that heap expansion fails due to running out of swap.&quot;)         \
214                                                                             \
215   experimental(uintx, G1MaxNewSizePercent, 60,                              \
216           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
217           &quot; maximum young gen size.&quot;)                                       \
218           range(0, 100)                                                     \
219           constraint(G1MaxNewSizePercentConstraintFunc,AfterErgo)           \
220                                                                             \
221   experimental(uintx, G1NewSizePercent, 5,                                  \
222           &quot;Percentage (0-100) of the heap size to use as default &quot;          \
223           &quot;minimum young gen size.&quot;)                                        \
224           range(0, 100)                                                     \
225           constraint(G1NewSizePercentConstraintFunc,AfterErgo)              \
226                                                                             \
227   experimental(uintx, G1MixedGCLiveThresholdPercent, 85,                    \
228           &quot;Threshold for regions to be considered for inclusion in the &quot;    \
229           &quot;collection set of mixed GCs. &quot;                                   \
230           &quot;Regions with live bytes exceeding this will not be collected.&quot;)  \
231           range(0, 100)                                                     \
232                                                                             \
233   product(uintx, G1HeapWastePercent, 5,                                     \
234           &quot;Amount of space, expressed as a percentage of the heap size, &quot;   \
235           &quot;that G1 is willing not to collect to avoid expensive GCs.&quot;)      \
236           range(0, 100)                                                     \
237                                                                             \
238   product(uintx, G1MixedGCCountTarget, 8,                                   \
239           &quot;The target number of mixed GCs after a marking cycle.&quot;)          \
240           range(0, max_uintx)                                               \
241                                                                             \



242   experimental(bool, G1EagerReclaimHumongousObjects, true,                  \
243           &quot;Try to reclaim dead large objects at every young GC.&quot;)           \
244                                                                             \
245   experimental(bool, G1EagerReclaimHumongousObjectsWithStaleRefs, true,     \
246           &quot;Try to reclaim dead large objects that have a few stale &quot;        \
247           &quot;references at every young GC.&quot;)                                  \
248                                                                             \
249   experimental(size_t, G1RebuildRemSetChunkSize, 256 * K,                   \
250           &quot;Chunk size used for rebuilding the remembered set.&quot;)             \
251           range(4 * K, 32 * M)                                              \
252                                                                             \
253   experimental(uintx, G1OldCSetRegionThresholdPercent, 10,                  \
254           &quot;An upper bound for the number of old CSet regions expressed &quot;    \
255           &quot;as a percentage of the heap size.&quot;)                              \
256           range(0, 100)                                                     \
257                                                                             \
258   notproduct(bool, G1EvacuationFailureALot, false,                          \
259           &quot;Force use of evacuation failure handling during certain &quot;        \
260           &quot;evacuation pauses&quot;)                                              \
261                                                                             \
</pre>
</td>
</tr>
</table>
<center><a href="g1YoungRemSetSamplingThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
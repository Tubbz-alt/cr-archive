<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectionSetChooser.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectionSetCandidates.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMark.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectionSetChooser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 95       return aligned_num_regions + max_waste;
 96     }
 97 
 98   public:
 99     G1BuildCandidateArray(uint max_num_regions, uint chunk_size, uint num_workers) :
100       _max_size(required_array_size(max_num_regions, chunk_size, num_workers)),
101       _chunk_size(chunk_size),
102       _data(NEW_C_HEAP_ARRAY(HeapRegion*, _max_size, mtGC)),
103       _cur_claim_idx(0) {
104       for (uint i = 0; i &lt; _max_size; i++) {
105         _data[i] = NULL;
106       }
107     }
108 
109     ~G1BuildCandidateArray() {
110       FREE_C_HEAP_ARRAY(HeapRegion*, _data);
111     }
112 
113     // Claim a new chunk, returning its bounds [from, to[.
114     void claim_chunk(uint&amp; from, uint&amp; to) {
<span class="line-modified">115       uint result = Atomic::add(_chunk_size, &amp;_cur_claim_idx);</span>
116       assert(_max_size &gt; result - 1,
117              &quot;Array too small, is %u should be %u with chunk size %u.&quot;,
118              _max_size, result, _chunk_size);
119       from = result - _chunk_size;
120       to = result;
121     }
122 
123     // Set element in array.
124     void set(uint idx, HeapRegion* hr) {
125       assert(idx &lt; _max_size, &quot;Index %u out of bounds %u&quot;, idx, _max_size);
126       assert(_data[idx] == NULL, &quot;Value must not have been set.&quot;);
127       _data[idx] = hr;
128     }
129 
130     void sort_and_copy_into(HeapRegion** dest, uint num_regions) {
131       if (_cur_claim_idx == 0) {
132         return;
133       }
134       for (uint i = _cur_claim_idx; i &lt; _max_size; i++) {
135         assert(_data[i] == NULL, &quot;must be&quot;);
</pre>
<hr />
<pre>
197                r-&gt;hrm_index(), r-&gt;get_type_str(), r-&gt;rem_set()-&gt;get_state_str());
198       }
199       return false;
200     }
201 
202     uint regions_added() const { return _regions_added; }
203     size_t reclaimable_bytes_added() const { return _reclaimable_bytes_added; }
204   };
205 
206   G1CollectedHeap* _g1h;
207   HeapRegionClaimer _hrclaimer;
208 
209   uint volatile _num_regions_added;
210   size_t volatile _reclaimable_bytes_added;
211 
212   G1BuildCandidateArray _result;
213 
214   void update_totals(uint num_regions, size_t reclaimable_bytes) {
215     if (num_regions &gt; 0) {
216       assert(reclaimable_bytes &gt; 0, &quot;invariant&quot;);
<span class="line-modified">217       Atomic::add(num_regions, &amp;_num_regions_added);</span>
<span class="line-modified">218       Atomic::add(reclaimable_bytes, &amp;_reclaimable_bytes_added);</span>
219     } else {
220       assert(reclaimable_bytes == 0, &quot;invariant&quot;);
221     }
222   }
223 
224 public:
225   G1BuildCandidateRegionsTask(uint max_num_regions, uint chunk_size, uint num_workers) :
226     AbstractGangTask(&quot;G1 Build Candidate Regions&quot;),
227     _g1h(G1CollectedHeap::heap()),
228     _hrclaimer(num_workers),
229     _num_regions_added(0),
230     _reclaimable_bytes_added(0),
231     _result(max_num_regions, chunk_size, num_workers) { }
232 
233   void work(uint worker_id) {
234     G1BuildCandidateRegionsClosure cl(&amp;_result);
235     _g1h-&gt;heap_region_par_iterate_from_worker_offset(&amp;cl, &amp;_hrclaimer, worker_id);
236     update_totals(cl.regions_added(), cl.reclaimable_bytes_added());
237   }
238 
</pre>
</td>
<td>
<hr />
<pre>
 95       return aligned_num_regions + max_waste;
 96     }
 97 
 98   public:
 99     G1BuildCandidateArray(uint max_num_regions, uint chunk_size, uint num_workers) :
100       _max_size(required_array_size(max_num_regions, chunk_size, num_workers)),
101       _chunk_size(chunk_size),
102       _data(NEW_C_HEAP_ARRAY(HeapRegion*, _max_size, mtGC)),
103       _cur_claim_idx(0) {
104       for (uint i = 0; i &lt; _max_size; i++) {
105         _data[i] = NULL;
106       }
107     }
108 
109     ~G1BuildCandidateArray() {
110       FREE_C_HEAP_ARRAY(HeapRegion*, _data);
111     }
112 
113     // Claim a new chunk, returning its bounds [from, to[.
114     void claim_chunk(uint&amp; from, uint&amp; to) {
<span class="line-modified">115       uint result = Atomic::add(&amp;_cur_claim_idx, _chunk_size);</span>
116       assert(_max_size &gt; result - 1,
117              &quot;Array too small, is %u should be %u with chunk size %u.&quot;,
118              _max_size, result, _chunk_size);
119       from = result - _chunk_size;
120       to = result;
121     }
122 
123     // Set element in array.
124     void set(uint idx, HeapRegion* hr) {
125       assert(idx &lt; _max_size, &quot;Index %u out of bounds %u&quot;, idx, _max_size);
126       assert(_data[idx] == NULL, &quot;Value must not have been set.&quot;);
127       _data[idx] = hr;
128     }
129 
130     void sort_and_copy_into(HeapRegion** dest, uint num_regions) {
131       if (_cur_claim_idx == 0) {
132         return;
133       }
134       for (uint i = _cur_claim_idx; i &lt; _max_size; i++) {
135         assert(_data[i] == NULL, &quot;must be&quot;);
</pre>
<hr />
<pre>
197                r-&gt;hrm_index(), r-&gt;get_type_str(), r-&gt;rem_set()-&gt;get_state_str());
198       }
199       return false;
200     }
201 
202     uint regions_added() const { return _regions_added; }
203     size_t reclaimable_bytes_added() const { return _reclaimable_bytes_added; }
204   };
205 
206   G1CollectedHeap* _g1h;
207   HeapRegionClaimer _hrclaimer;
208 
209   uint volatile _num_regions_added;
210   size_t volatile _reclaimable_bytes_added;
211 
212   G1BuildCandidateArray _result;
213 
214   void update_totals(uint num_regions, size_t reclaimable_bytes) {
215     if (num_regions &gt; 0) {
216       assert(reclaimable_bytes &gt; 0, &quot;invariant&quot;);
<span class="line-modified">217       Atomic::add(&amp;_num_regions_added, num_regions);</span>
<span class="line-modified">218       Atomic::add(&amp;_reclaimable_bytes_added, reclaimable_bytes);</span>
219     } else {
220       assert(reclaimable_bytes == 0, &quot;invariant&quot;);
221     }
222   }
223 
224 public:
225   G1BuildCandidateRegionsTask(uint max_num_regions, uint chunk_size, uint num_workers) :
226     AbstractGangTask(&quot;G1 Build Candidate Regions&quot;),
227     _g1h(G1CollectedHeap::heap()),
228     _hrclaimer(num_workers),
229     _num_regions_added(0),
230     _reclaimable_bytes_added(0),
231     _result(max_num_regions, chunk_size, num_workers) { }
232 
233   void work(uint worker_id) {
234     G1BuildCandidateRegionsClosure cl(&amp;_result);
235     _g1h-&gt;heap_region_par_iterate_from_worker_offset(&amp;cl, &amp;_hrclaimer, worker_id);
236     update_totals(cl.regions_added(), cl.reclaimable_bytes_added());
237   }
238 
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectionSetCandidates.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMark.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
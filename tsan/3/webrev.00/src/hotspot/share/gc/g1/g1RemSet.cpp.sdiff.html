<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1RemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RegionToSpaceMapper.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1RemSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
  27 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  28 #include &quot;gc/g1/g1CardTable.inline.hpp&quot;

  29 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  30 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  31 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  32 #include &quot;gc/g1/g1FromCardCache.hpp&quot;
  33 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  34 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  35 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  36 #include &quot;gc/g1/g1RootClosures.hpp&quot;
  37 #include &quot;gc/g1/g1RemSet.hpp&quot;

  38 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  39 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="line-modified">  40 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;</span>

  41 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;

  42 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  43 #include &quot;jfr/jfrEvents.hpp&quot;
  44 #include &quot;memory/iterator.hpp&quot;
  45 #include &quot;memory/resourceArea.hpp&quot;
  46 #include &quot;oops/access.inline.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;

  48 #include &quot;runtime/os.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/globalDefinitions.hpp&quot;
  51 #include &quot;utilities/stack.inline.hpp&quot;
  52 #include &quot;utilities/ticks.hpp&quot;
  53 
<span class="line-modified">  54 // Collects information about the overall remembered set scan progress during an evacuation.</span>

























  55 class G1RemSetScanState : public CHeapObj&lt;mtGC&gt; {













































  56 private:











































































  57   class G1ClearCardTableTask : public AbstractGangTask {
  58     G1CollectedHeap* _g1h;
<span class="line-modified">  59     uint* _dirty_region_list;</span>
<span class="line-modified">  60     size_t _num_dirty_regions;</span>
<span class="line-modified">  61     size_t _chunk_length;</span>



  62 
<span class="line-removed">  63     size_t volatile _cur_dirty_regions;</span>
  64   public:
  65     G1ClearCardTableTask(G1CollectedHeap* g1h,
<span class="line-modified">  66                          uint* dirty_region_list,</span>
<span class="line-modified">  67                          size_t num_dirty_regions,</span>
<span class="line-modified">  68                          size_t chunk_length) :</span>
  69       AbstractGangTask(&quot;G1 Clear Card Table Task&quot;),
  70       _g1h(g1h),
<span class="line-modified">  71       _dirty_region_list(dirty_region_list),</span>
<span class="line-removed">  72       _num_dirty_regions(num_dirty_regions),</span>
  73       _chunk_length(chunk_length),
<span class="line-modified">  74       _cur_dirty_regions(0) {</span>

  75 
  76       assert(chunk_length &gt; 0, &quot;must be&quot;);
  77     }
  78 
<span class="line-modified">  79     static size_t chunk_size() { return M; }</span>
  80 
  81     void work(uint worker_id) {
<span class="line-modified">  82       while (_cur_dirty_regions &lt; _num_dirty_regions) {</span>
<span class="line-modified">  83         size_t next = Atomic::add(_chunk_length, &amp;_cur_dirty_regions) - _chunk_length;</span>
<span class="line-modified">  84         size_t max = MIN2(next + _chunk_length, _num_dirty_regions);</span>
  85 
<span class="line-modified">  86         for (size_t i = next; i &lt; max; i++) {</span>
<span class="line-modified">  87           HeapRegion* r = _g1h-&gt;region_at(_dirty_region_list[i]);</span>
  88           if (!r-&gt;is_survivor()) {
  89             r-&gt;clear_cardtable();
  90           }
  91         }
  92       }
  93     }
  94   };
  95 
<span class="line-modified">  96   size_t _max_regions;</span>
<span class="line-modified">  97 </span>
<span class="line-modified">  98   // Scan progress for the remembered set of a single region. Transitions from</span>
<span class="line-removed">  99   // Unclaimed -&gt; Claimed -&gt; Complete.</span>
<span class="line-removed"> 100   // At each of the transitions the thread that does the transition needs to perform</span>
<span class="line-removed"> 101   // some special action once. This is the reason for the extra &quot;Claimed&quot; state.</span>
<span class="line-removed"> 102   typedef jint G1RemsetIterState;</span>
<span class="line-removed"> 103 </span>
<span class="line-removed"> 104   static const G1RemsetIterState Unclaimed = 0; // The remembered set has not been scanned yet.</span>
<span class="line-removed"> 105   static const G1RemsetIterState Claimed = 1;   // The remembered set is currently being scanned.</span>
<span class="line-removed"> 106   static const G1RemsetIterState Complete = 2;  // The remembered set has been completely scanned.</span>
<span class="line-removed"> 107 </span>
<span class="line-removed"> 108   G1RemsetIterState volatile* _iter_states;</span>
<span class="line-removed"> 109   // The current location where the next thread should continue scanning in a region&#39;s</span>
<span class="line-removed"> 110   // remembered set.</span>
<span class="line-removed"> 111   size_t volatile* _iter_claims;</span>
<span class="line-removed"> 112 </span>
<span class="line-removed"> 113   // Temporary buffer holding the regions we used to store remembered set scan duplicate</span>
<span class="line-removed"> 114   // information. These are also called &quot;dirty&quot;. Valid entries are from [0.._cur_dirty_region)</span>
<span class="line-removed"> 115   uint* _dirty_region_buffer;</span>
<span class="line-removed"> 116 </span>
<span class="line-removed"> 117   // Flag for every region whether it is in the _dirty_region_buffer already</span>
<span class="line-removed"> 118   // to avoid duplicates.</span>
<span class="line-removed"> 119   bool volatile* _in_dirty_region_buffer;</span>
<span class="line-removed"> 120   size_t _cur_dirty_region;</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122   // Creates a snapshot of the current _top values at the start of collection to</span>
<span class="line-removed"> 123   // filter out card marks that we do not want to scan.</span>
<span class="line-removed"> 124   class G1ResetScanTopClosure : public HeapRegionClosure {</span>
<span class="line-removed"> 125   private:</span>
<span class="line-removed"> 126     HeapWord** _scan_top;</span>
<span class="line-removed"> 127   public:</span>
<span class="line-removed"> 128     G1ResetScanTopClosure(HeapWord** scan_top) : _scan_top(scan_top) { }</span>
 129 
<span class="line-modified"> 130     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="line-modified"> 131       uint hrm_index = r-&gt;hrm_index();</span>
<span class="line-removed"> 132       if (!r-&gt;in_collection_set() &amp;&amp; r-&gt;is_old_or_humongous_or_archive() &amp;&amp; !r-&gt;is_empty()) {</span>
<span class="line-removed"> 133         _scan_top[hrm_index] = r-&gt;top();</span>
<span class="line-removed"> 134       } else {</span>
<span class="line-removed"> 135         _scan_top[hrm_index] = NULL;</span>
<span class="line-removed"> 136       }</span>
<span class="line-removed"> 137       return false;</span>
 138     }
<span class="line-removed"> 139   };</span>
 140 
<span class="line-modified"> 141   // For each region, contains the maximum top() value to be used during this garbage</span>
<span class="line-modified"> 142   // collection. Subsumes common checks like filtering out everything but old and</span>
<span class="line-modified"> 143   // humongous regions outside the collection set.</span>
<span class="line-modified"> 144   // This is valid because we are not interested in scanning stray remembered set</span>
<span class="line-modified"> 145   // entries from free or archive regions.</span>
<span class="line-modified"> 146   HeapWord** _scan_top;</span>











 147 public:
 148   G1RemSetScanState() :
 149     _max_regions(0),
<span class="line-modified"> 150     _iter_states(NULL),</span>
<span class="line-modified"> 151     _iter_claims(NULL),</span>
<span class="line-modified"> 152     _dirty_region_buffer(NULL),</span>
<span class="line-modified"> 153     _in_dirty_region_buffer(NULL),</span>
<span class="line-modified"> 154     _cur_dirty_region(0),</span>




 155     _scan_top(NULL) {
 156   }
 157 
 158   ~G1RemSetScanState() {
<span class="line-modified"> 159     if (_iter_states != NULL) {</span>
<span class="line-modified"> 160       FREE_C_HEAP_ARRAY(G1RemsetIterState, _iter_states);</span>
<span class="line-modified"> 161     }</span>
<span class="line-modified"> 162     if (_iter_claims != NULL) {</span>
<span class="line-removed"> 163       FREE_C_HEAP_ARRAY(size_t, _iter_claims);</span>
<span class="line-removed"> 164     }</span>
<span class="line-removed"> 165     if (_dirty_region_buffer != NULL) {</span>
<span class="line-removed"> 166       FREE_C_HEAP_ARRAY(uint, _dirty_region_buffer);</span>
<span class="line-removed"> 167     }</span>
<span class="line-removed"> 168     if (_in_dirty_region_buffer != NULL) {</span>
<span class="line-removed"> 169       FREE_C_HEAP_ARRAY(bool, _in_dirty_region_buffer);</span>
<span class="line-removed"> 170     }</span>
<span class="line-removed"> 171     if (_scan_top != NULL) {</span>
<span class="line-removed"> 172       FREE_C_HEAP_ARRAY(HeapWord*, _scan_top);</span>
<span class="line-removed"> 173     }</span>
 174   }
 175 
<span class="line-modified"> 176   void initialize(uint max_regions) {</span>
<span class="line-modified"> 177     assert(_iter_states == NULL, &quot;Must not be initialized twice&quot;);</span>
<span class="line-removed"> 178     assert(_iter_claims == NULL, &quot;Must not be initialized twice&quot;);</span>
 179     _max_regions = max_regions;
<span class="line-modified"> 180     _iter_states = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);</span>
<span class="line-modified"> 181     _iter_claims = NEW_C_HEAP_ARRAY(size_t, max_regions, mtGC);</span>
<span class="line-modified"> 182     _dirty_region_buffer = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);</span>
<span class="line-modified"> 183     _in_dirty_region_buffer = NEW_C_HEAP_ARRAY(bool, max_regions, mtGC);</span>


 184     _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_regions, mtGC);
 185   }
 186 
<span class="line-modified"> 187   void reset() {</span>
<span class="line-modified"> 188     for (uint i = 0; i &lt; _max_regions; i++) {</span>
<span class="line-modified"> 189       _iter_states[i] = Unclaimed;</span>
<span class="line-modified"> 190       _scan_top[i] = NULL;</span>




 191     }
 192 
<span class="line-modified"> 193     G1ResetScanTopClosure cl(_scan_top);</span>
<span class="line-modified"> 194     G1CollectedHeap::heap()-&gt;heap_region_iterate(&amp;cl);</span>
<span class="line-removed"> 195 </span>
<span class="line-removed"> 196     memset((void*)_iter_claims, 0, _max_regions * sizeof(size_t));</span>
<span class="line-removed"> 197     memset((void*)_in_dirty_region_buffer, false, _max_regions * sizeof(bool));</span>
<span class="line-removed"> 198     _cur_dirty_region = 0;</span>
 199   }
 200 
<span class="line-modified"> 201   // Attempt to claim the remembered set of the region for iteration. Returns true</span>
<span class="line-modified"> 202   // if this call caused the transition from Unclaimed to Claimed.</span>
<span class="line-modified"> 203   inline bool claim_iter(uint region) {</span>
<span class="line-modified"> 204     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-modified"> 205     if (_iter_states[region] != Unclaimed) {</span>
<span class="line-modified"> 206       return false;</span>
 207     }
<span class="line-modified"> 208     G1RemsetIterState res = Atomic::cmpxchg(Claimed, &amp;_iter_states[region], Unclaimed);</span>
<span class="line-modified"> 209     return (res == Unclaimed);</span>
 210   }
 211 
<span class="line-modified"> 212   // Try to atomically sets the iteration state to &quot;complete&quot;. Returns true for the</span>
<span class="line-modified"> 213   // thread that caused the transition.</span>
<span class="line-modified"> 214   inline bool set_iter_complete(uint region) {</span>
<span class="line-modified"> 215     if (iter_is_complete(region)) {</span>
<span class="line-modified"> 216       return false;</span>












 217     }
<span class="line-modified"> 218     G1RemsetIterState res = Atomic::cmpxchg(Complete, &amp;_iter_states[region], Claimed);</span>
<span class="line-removed"> 219     return (res == Claimed);</span>
 220   }
 221 
<span class="line-modified"> 222   // Returns true if the region&#39;s iteration is complete.</span>
<span class="line-modified"> 223   inline bool iter_is_complete(uint region) const {</span>
<span class="line-removed"> 224     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-removed"> 225     return _iter_states[region] == Complete;</span>
 226   }
 227 
<span class="line-modified"> 228   // The current position within the remembered set of the given region.</span>
<span class="line-modified"> 229   inline size_t iter_claimed(uint region) const {</span>
<span class="line-modified"> 230     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-modified"> 231     return _iter_claims[region];</span>

 232   }
 233 
<span class="line-modified"> 234   // Claim the next block of cards within the remembered set of the region with</span>
<span class="line-modified"> 235   // step size.</span>
<span class="line-modified"> 236   inline size_t iter_claimed_next(uint region, size_t step) {</span>
<span class="line-modified"> 237     return Atomic::add(step, &amp;_iter_claims[region]) - step;</span>
















 238   }
 239 
<span class="line-modified"> 240   void add_dirty_region(uint region) {</span>
<span class="line-modified"> 241     if (_in_dirty_region_buffer[region]) {</span>


 242       return;
 243     }
 244 
<span class="line-modified"> 245     if (!Atomic::cmpxchg(true, &amp;_in_dirty_region_buffer[region], false)) {</span>
<span class="line-modified"> 246       size_t allocated = Atomic::add(1u, &amp;_cur_dirty_region) - 1;</span>
<span class="line-modified"> 247       _dirty_region_buffer[allocated] = region;</span>
<span class="line-modified"> 248     }</span>












 249   }
 250 
<span class="line-modified"> 251   HeapWord* scan_top(uint region_idx) const {</span>
<span class="line-modified"> 252     return _scan_top[region_idx];</span>
 253   }
 254 
<span class="line-modified"> 255   // Clear the card table of &quot;dirty&quot; regions.</span>
<span class="line-modified"> 256   void clear_card_table(WorkGang* workers) {</span>
<span class="line-modified"> 257     if (_cur_dirty_region == 0) {</span>
<span class="line-modified"> 258       return;</span>


 259     }


 260 
<span class="line-modified"> 261     size_t const num_chunks = align_up(_cur_dirty_region * HeapRegion::CardsPerRegion, G1ClearCardTableTask::chunk_size()) / G1ClearCardTableTask::chunk_size();</span>
<span class="line-modified"> 262     uint const num_workers = (uint)MIN2(num_chunks, (size_t)workers-&gt;active_workers());</span>
<span class="line-modified"> 263     size_t const chunk_length = G1ClearCardTableTask::chunk_size() / HeapRegion::CardsPerRegion;</span>

 264 
<span class="line-modified"> 265     // Iterate over the dirty cards region list.</span>
<span class="line-modified"> 266     G1ClearCardTableTask cl(G1CollectedHeap::heap(), _dirty_region_buffer, _cur_dirty_region, chunk_length);</span>


 267 
<span class="line-modified"> 268     log_debug(gc, ergo)(&quot;Running %s using %u workers for &quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified"> 269                         &quot;units of work for &quot; SIZE_FORMAT &quot; regions.&quot;,</span>
<span class="line-modified"> 270                         cl.name(), num_workers, num_chunks, _cur_dirty_region);</span>
<span class="line-modified"> 271     workers-&gt;run_task(&amp;cl, num_workers);</span>





 272 
<span class="line-modified"> 273 #ifndef PRODUCT</span>
<span class="line-modified"> 274     G1CollectedHeap::heap()-&gt;verifier()-&gt;verify_card_table_cleanup();</span>




 275 #endif













 276   }
 277 };
 278 
 279 G1RemSet::G1RemSet(G1CollectedHeap* g1h,
 280                    G1CardTable* ct,
 281                    G1HotCardCache* hot_card_cache) :
 282   _scan_state(new G1RemSetScanState()),
<span class="line-modified"> 283   _prev_period_summary(),</span>
 284   _g1h(g1h),
<span class="line-removed"> 285   _num_conc_refined_cards(0),</span>
 286   _ct(ct),
 287   _g1p(_g1h-&gt;policy()),
 288   _hot_card_cache(hot_card_cache) {
 289 }
 290 
 291 G1RemSet::~G1RemSet() {
<span class="line-modified"> 292   if (_scan_state != NULL) {</span>
<span class="line-removed"> 293     delete _scan_state;</span>
<span class="line-removed"> 294   }</span>
 295 }
 296 
 297 uint G1RemSet::num_par_rem_sets() {
 298   return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);
 299 }
 300 
 301 void G1RemSet::initialize(size_t capacity, uint max_regions) {
 302   G1FromCardCache::initialize(num_par_rem_sets(), max_regions);
 303   _scan_state-&gt;initialize(max_regions);
 304 }
 305 
<span class="line-modified"> 306 G1ScanRSForRegionClosure::G1ScanRSForRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="line-modified"> 307                                                    G1ScanObjsDuringScanRSClosure* scan_obj_on_card,</span>
<span class="line-modified"> 308                                                    G1ParScanThreadState* pss,</span>
<span class="line-modified"> 309                                                    G1GCPhaseTimes::GCParPhases phase,</span>
<span class="line-modified"> 310                                                    uint worker_i) :</span>
<span class="line-removed"> 311   _g1h(G1CollectedHeap::heap()),</span>
<span class="line-removed"> 312   _ct(_g1h-&gt;card_table()),</span>
<span class="line-removed"> 313   _pss(pss),</span>
<span class="line-removed"> 314   _scan_objs_on_card_cl(scan_obj_on_card),</span>
<span class="line-removed"> 315   _scan_state(scan_state),</span>
<span class="line-removed"> 316   _phase(phase),</span>
<span class="line-removed"> 317   _worker_i(worker_i),</span>
<span class="line-removed"> 318   _cards_scanned(0),</span>
<span class="line-removed"> 319   _cards_claimed(0),</span>
<span class="line-removed"> 320   _cards_skipped(0),</span>
<span class="line-removed"> 321   _rem_set_root_scan_time(),</span>
<span class="line-removed"> 322   _rem_set_trim_partially_time(),</span>
<span class="line-removed"> 323   _strong_code_root_scan_time(),</span>
<span class="line-removed"> 324   _strong_code_trim_partially_time() {</span>
<span class="line-removed"> 325 }</span>
 326 
<span class="line-modified"> 327 void G1ScanRSForRegionClosure::claim_card(size_t card_index, const uint region_idx_for_card){</span>
<span class="line-modified"> 328   _ct-&gt;set_card_claimed(card_index);</span>
<span class="line-removed"> 329   _scan_state-&gt;add_dirty_region(region_idx_for_card);</span>
<span class="line-removed"> 330 }</span>
 331 
<span class="line-modified"> 332 void G1ScanRSForRegionClosure::scan_card(MemRegion mr, uint region_idx_for_card) {</span>
<span class="line-modified"> 333   HeapRegion* const card_region = _g1h-&gt;region_at(region_idx_for_card);</span>
<span class="line-removed"> 334   assert(!card_region-&gt;is_young(), &quot;Should not scan card in young region %u&quot;, region_idx_for_card);</span>
<span class="line-removed"> 335   card_region-&gt;oops_on_card_seq_iterate_careful&lt;true&gt;(mr, _scan_objs_on_card_cl);</span>
<span class="line-removed"> 336   _scan_objs_on_card_cl-&gt;trim_queue_partially();</span>
<span class="line-removed"> 337   _cards_scanned++;</span>
<span class="line-removed"> 338 }</span>
 339 
<span class="line-modified"> 340 void G1ScanRSForRegionClosure::scan_rem_set_roots(HeapRegion* r) {</span>
<span class="line-modified"> 341   EventGCPhaseParallel event;</span>
<span class="line-removed"> 342   uint const region_idx = r-&gt;hrm_index();</span>
 343 
<span class="line-modified"> 344   if (_scan_state-&gt;claim_iter(region_idx)) {</span>
<span class="line-modified"> 345     // If we ever free the collection set concurrently, we should also</span>
<span class="line-removed"> 346     // clear the card table concurrently therefore we won&#39;t need to</span>
<span class="line-removed"> 347     // add regions of the collection set to the dirty cards region.</span>
<span class="line-removed"> 348     _scan_state-&gt;add_dirty_region(region_idx);</span>
 349   }
 350 
<span class="line-modified"> 351   if (r-&gt;rem_set()-&gt;cardset_is_empty()) {</span>
<span class="line-modified"> 352     return;</span>



















































 353   }
 354 
<span class="line-modified"> 355   // We claim cards in blocks so as to reduce the contention.</span>
<span class="line-modified"> 356   size_t const block_size = G1RSetScanBlockSize;</span>
 357 
<span class="line-modified"> 358   HeapRegionRemSetIterator iter(r-&gt;rem_set());</span>
<span class="line-modified"> 359   size_t card_index;</span>




 360 
<span class="line-modified"> 361   size_t claimed_card_block = _scan_state-&gt;iter_claimed_next(region_idx, block_size);</span>
<span class="line-modified"> 362   for (size_t current_card = 0; iter.has_next(card_index); current_card++) {</span>
<span class="line-modified"> 363     if (current_card &gt;= claimed_card_block + block_size) {</span>
<span class="line-modified"> 364       claimed_card_block = _scan_state-&gt;iter_claimed_next(region_idx, block_size);</span>








 365     }
<span class="line-modified"> 366     if (current_card &lt; claimed_card_block) {</span>
<span class="line-modified"> 367       _cards_skipped++;</span>
<span class="line-modified"> 368       continue;</span>
























 369     }
<span class="line-modified"> 370     _cards_claimed++;</span>
 371 
<span class="line-modified"> 372     HeapWord* const card_start = _g1h-&gt;bot()-&gt;address_for_index_raw(card_index);</span>
<span class="line-modified"> 373     uint const region_idx_for_card = _g1h-&gt;addr_to_region(card_start);</span>

 374 







































 375 #ifdef ASSERT
 376     HeapRegion* hr = _g1h-&gt;region_at_or_null(region_idx_for_card);
 377     assert(hr == NULL || hr-&gt;is_in_reserved(card_start),
<span class="line-modified"> 378            &quot;Card start &quot; PTR_FORMAT &quot; to scan outside of region %u&quot;, p2i(card_start), _g1h-&gt;region_at(region_idx_for_card)-&gt;hrm_index());</span>
 379 #endif
 380     HeapWord* const top = _scan_state-&gt;scan_top(region_idx_for_card);
 381     if (card_start &gt;= top) {
<span class="line-modified"> 382       continue;</span>





 383     }








































 384 
<span class="line-modified"> 385     // If the card is dirty, then G1 will scan it during Update RS.</span>
<span class="line-modified"> 386     if (_ct-&gt;is_card_claimed(card_index) || _ct-&gt;is_card_dirty(card_index)) {</span>
<span class="line-modified"> 387       continue;</span>




 388     }
 389 
<span class="line-modified"> 390     // We claim lazily (so races are possible but they&#39;re benign), which reduces the</span>
<span class="line-modified"> 391     // number of duplicate scans (the rsets of the regions in the cset can intersect).</span>
<span class="line-modified"> 392     // Claim the card after checking bounds above: the remembered set may contain</span>
<span class="line-modified"> 393     // random cards into current survivor, and we would then have an incorrectly</span>
<span class="line-modified"> 394     // claimed card in survivor space. Card table clear does not reset the card table</span>
<span class="line-modified"> 395     // of survivor space regions.</span>
<span class="line-modified"> 396     claim_card(card_index, region_idx_for_card);</span>















 397 
<span class="line-modified"> 398     MemRegion const mr(card_start, MIN2(card_start + BOTConstants::N_words, top));</span>




 399 
<span class="line-modified"> 400     scan_card(mr, region_idx_for_card);</span>




 401   }
<span class="line-removed"> 402   event.commit(GCId::current(), _worker_i, G1GCPhaseTimes::phase_name(_phase));</span>
<span class="line-removed"> 403 }</span>
 404 
<span class="line-modified"> 405 void G1ScanRSForRegionClosure::scan_strong_code_roots(HeapRegion* r) {</span>
<span class="line-modified"> 406   EventGCPhaseParallel event;</span>
<span class="line-modified"> 407   // We pass a weak code blobs closure to the remembered set scanning because we want to avoid</span>
<span class="line-modified"> 408   // treating the nmethods visited to act as roots for concurrent marking.</span>
<span class="line-modified"> 409   // We only want to make sure that the oops in the nmethods are adjusted with regard to the</span>
<span class="line-modified"> 410   // objects copied by the current evacuation.</span>
<span class="line-modified"> 411   r-&gt;strong_code_roots_do(_pss-&gt;closures()-&gt;weak_codeblobs());</span>
<span class="line-modified"> 412   event.commit(GCId::current(), _worker_i, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::CodeRoots));</span>















 413 }
 414 
<span class="line-modified"> 415 bool G1ScanRSForRegionClosure::do_heap_region(HeapRegion* r) {</span>
<span class="line-modified"> 416   assert(r-&gt;in_collection_set(),</span>
<span class="line-modified"> 417          &quot;Should only be called on elements of the collection set but region %u is not.&quot;,</span>
<span class="line-modified"> 418          r-&gt;hrm_index());</span>
<span class="line-modified"> 419   uint const region_idx = r-&gt;hrm_index();</span>

































































 420 
<span class="line-removed"> 421   // Do an early out if we know we are complete.</span>
<span class="line-removed"> 422   if (_scan_state-&gt;iter_is_complete(region_idx)) {</span>
 423     return false;
 424   }
 425 
<span class="line-modified"> 426   {</span>
<span class="line-modified"> 427     G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_root_scan_time, _rem_set_trim_partially_time);</span>
<span class="line-modified"> 428     scan_rem_set_roots(r);</span>



























 429   }

 430 
<span class="line-modified"> 431   if (_scan_state-&gt;set_iter_complete(region_idx)) {</span>
<span class="line-modified"> 432     G1EvacPhaseWithTrimTimeTracker timer(_pss, _strong_code_root_scan_time, _strong_code_trim_partially_time);</span>
<span class="line-modified"> 433     // Scan the strong code root list attached to the current region</span>
<span class="line-modified"> 434     scan_strong_code_roots(r);</span>











 435   }
<span class="line-removed"> 436   return false;</span>
 437 }
 438 
<span class="line-modified"> 439 void G1RemSet::scan_rem_set(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="line-modified"> 440   G1ScanObjsDuringScanRSClosure scan_cl(_g1h, pss);</span>
<span class="line-modified"> 441   G1ScanRSForRegionClosure cl(_scan_state, &amp;scan_cl, pss, G1GCPhaseTimes::ScanRS, worker_i);</span>
<span class="line-removed"> 442   _g1h-&gt;collection_set_iterate_from(&amp;cl, worker_i);</span>
 443 
<span class="line-modified"> 444   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>

 445 
<span class="line-modified"> 446   p-&gt;record_time_secs(G1GCPhaseTimes::ScanRS, worker_i, cl.rem_set_root_scan_time().seconds());</span>
<span class="line-removed"> 447   p-&gt;add_time_secs(G1GCPhaseTimes::ObjCopy, worker_i, cl.rem_set_trim_partially_time().seconds());</span>
 448 
<span class="line-modified"> 449   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_scanned(), G1GCPhaseTimes::ScanRSScannedCards);</span>
<span class="line-modified"> 450   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_claimed(), G1GCPhaseTimes::ScanRSClaimedCards);</span>
<span class="line-modified"> 451   p-&gt;record_thread_work_item(G1GCPhaseTimes::ScanRS, worker_i, cl.cards_skipped(), G1GCPhaseTimes::ScanRSSkippedCards);</span>

 452 
<span class="line-modified"> 453   p-&gt;record_time_secs(G1GCPhaseTimes::CodeRoots, worker_i, cl.strong_code_root_scan_time().seconds());</span>
<span class="line-modified"> 454   p-&gt;add_time_secs(G1GCPhaseTimes::ObjCopy, worker_i, cl.strong_code_root_trim_partially_time().seconds());</span>
<span class="line-modified"> 455 }</span>
 456 
<span class="line-modified"> 457 // Closure used for updating rem sets. Only called during an evacuation pause.</span>
<span class="line-modified"> 458 class G1RefineCardClosure: public G1CardTableEntryClosure {</span>
<span class="line-modified"> 459   G1RemSet* _g1rs;</span>
<span class="line-modified"> 460   G1ScanObjsDuringUpdateRSClosure* _update_rs_cl;</span>





















































































































































































 461 
<span class="line-removed"> 462   size_t _cards_scanned;</span>
<span class="line-removed"> 463   size_t _cards_skipped;</span>
 464 public:
<span class="line-modified"> 465   G1RefineCardClosure(G1CollectedHeap* g1h, G1ScanObjsDuringUpdateRSClosure* update_rs_cl) :</span>
<span class="line-modified"> 466     _g1rs(g1h-&gt;rem_set()), _update_rs_cl(update_rs_cl), _cards_scanned(0), _cards_skipped(0)</span>
<span class="line-modified"> 467   {}</span>
<span class="line-modified"> 468 </span>
<span class="line-modified"> 469   bool do_card_ptr(CardValue* card_ptr, uint worker_i) {</span>
<span class="line-modified"> 470     // The only time we care about recording cards that</span>
<span class="line-modified"> 471     // contain references that point into the collection set</span>
<span class="line-modified"> 472     // is during RSet updating within an evacuation pause.</span>
<span class="line-modified"> 473     // In this case worker_i should be the id of a GC worker thread.</span>
<span class="line-modified"> 474     assert(SafepointSynchronize::is_at_safepoint(), &quot;not during an evacuation pause&quot;);</span>
<span class="line-modified"> 475 </span>
<span class="line-modified"> 476     bool card_scanned = _g1rs-&gt;refine_card_during_gc(card_ptr, _update_rs_cl);</span>
<span class="line-modified"> 477 </span>
<span class="line-modified"> 478     if (card_scanned) {</span>
<span class="line-removed"> 479       _update_rs_cl-&gt;trim_queue_partially();</span>
<span class="line-removed"> 480       _cards_scanned++;</span>
<span class="line-removed"> 481     } else {</span>
<span class="line-removed"> 482       _cards_skipped++;</span>
 483     }
<span class="line-removed"> 484     return true;</span>
 485   }
 486 
<span class="line-modified"> 487   size_t cards_scanned() const { return _cards_scanned; }</span>
<span class="line-modified"> 488   size_t cards_skipped() const { return _cards_skipped; }</span>
<span class="line-modified"> 489 };</span>
 490 
<span class="line-modified"> 491 void G1RemSet::update_rem_set(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="line-modified"> 492   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>








 493 
<span class="line-modified"> 494   // Apply closure to log entries in the HCC.</span>
<span class="line-modified"> 495   if (G1HotCardCache::default_use_cache()) {</span>
<span class="line-modified"> 496     G1EvacPhaseTimesTracker x(p, pss, G1GCPhaseTimes::ScanHCC, worker_i);</span>



















 497 
<span class="line-modified"> 498     G1ScanObjsDuringUpdateRSClosure scan_hcc_cl(_g1h, pss);</span>
<span class="line-modified"> 499     G1RefineCardClosure refine_card_cl(_g1h, &amp;scan_hcc_cl);</span>
<span class="line-modified"> 500     _g1h-&gt;iterate_hcc_closure(&amp;refine_card_cl, worker_i);</span>



















 501   }





















 502 
<span class="line-removed"> 503   // Now apply the closure to all remaining log entries.</span>
 504   {
<span class="line-modified"> 505     G1EvacPhaseTimesTracker x(p, pss, G1GCPhaseTimes::UpdateRS, worker_i);</span>
 506 
<span class="line-modified"> 507     G1ScanObjsDuringUpdateRSClosure update_rs_cl(_g1h, pss);</span>
<span class="line-removed"> 508     G1RefineCardClosure refine_card_cl(_g1h, &amp;update_rs_cl);</span>
<span class="line-removed"> 509     _g1h-&gt;iterate_dirty_card_closure(&amp;refine_card_cl, worker_i);</span>
 510 
<span class="line-modified"> 511     p-&gt;record_thread_work_item(G1GCPhaseTimes::UpdateRS, worker_i, refine_card_cl.cards_scanned(), G1GCPhaseTimes::UpdateRSScannedCards);</span>
<span class="line-modified"> 512     p-&gt;record_thread_work_item(G1GCPhaseTimes::UpdateRS, worker_i, refine_card_cl.cards_skipped(), G1GCPhaseTimes::UpdateRSSkippedCards);</span>




 513   }
<span class="line-removed"> 514 }</span>
 515 
<span class="line-modified"> 516 void G1RemSet::oops_into_collection_set_do(G1ParScanThreadState* pss, uint worker_i) {</span>
<span class="line-modified"> 517   update_rem_set(pss, worker_i);</span>
<span class="line-removed"> 518   scan_rem_set(pss, worker_i);;</span>
<span class="line-removed"> 519 }</span>
 520 
<span class="line-modified"> 521 void G1RemSet::prepare_for_oops_into_collection_set_do() {</span>
<span class="line-modified"> 522   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-modified"> 523   dcqs.concatenate_logs();</span>











 524 
<span class="line-modified"> 525   _scan_state-&gt;reset();</span>

 526 }
 527 
<span class="line-modified"> 528 void G1RemSet::cleanup_after_oops_into_collection_set_do() {</span>
 529   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
 530 
 531   // Set all cards back to clean.
 532   double start = os::elapsedTime();
<span class="line-modified"> 533   _scan_state-&gt;clear_card_table(_g1h-&gt;workers());</span>
 534   phase_times-&gt;record_clear_ct_time((os::elapsedTime() - start) * 1000.0);
 535 }
 536 
 537 inline void check_card_ptr(CardTable::CardValue* card_ptr, G1CardTable* ct) {
 538 #ifdef ASSERT
 539   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 540   assert(g1h-&gt;is_in_exact(ct-&gt;addr_for(card_ptr)),
 541          &quot;Card at &quot; PTR_FORMAT &quot; index &quot; SIZE_FORMAT &quot; representing heap at &quot; PTR_FORMAT &quot; (%u) must be in committed heap&quot;,
 542          p2i(card_ptr),
 543          ct-&gt;index_for(ct-&gt;addr_for(card_ptr)),
 544          p2i(ct-&gt;addr_for(card_ptr)),
 545          g1h-&gt;addr_to_region(ct-&gt;addr_for(card_ptr)));
 546 #endif
 547 }
 548 
<span class="line-modified"> 549 void G1RemSet::refine_card_concurrently(CardValue* card_ptr,</span>
<span class="line-removed"> 550                                         uint worker_i) {</span>
 551   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);
 552 
<span class="line-modified"> 553   // Construct the region representing the card.</span>

 554   HeapWord* start = _ct-&gt;addr_for(card_ptr);
 555   // And find the region containing it.
 556   HeapRegion* r = _g1h-&gt;heap_region_containing_or_null(start);
 557 
 558   // If this is a (stale) card into an uncommitted region, exit.
 559   if (r == NULL) {
<span class="line-modified"> 560     return;</span>
 561   }
 562 
 563   check_card_ptr(card_ptr, _ct);
 564 
 565   // If the card is no longer dirty, nothing to do.


 566   if (*card_ptr != G1CardTable::dirty_card_val()) {
<span class="line-modified"> 567     return;</span>
 568   }
 569 
 570   // This check is needed for some uncommon cases where we should
 571   // ignore the card.
 572   //
 573   // The region could be young.  Cards for young regions are
 574   // distinctly marked (set to g1_young_gen), so the post-barrier will
 575   // filter them out.  However, that marking is performed
 576   // concurrently.  A write to a young object could occur before the
 577   // card has been marked young, slipping past the filter.
 578   //
 579   // The card could be stale, because the region has been freed since
 580   // the card was recorded. In this case the region type could be
 581   // anything.  If (still) free or (reallocated) young, just ignore
 582   // it.  If (reallocated) old or humongous, the later card trimming
 583   // and additional checks in iteration may detect staleness.  At
 584   // worst, we end up processing a stale card unnecessarily.
 585   //
 586   // In the normal (non-stale) case, the synchronization between the
 587   // enqueueing of the card and processing it here will have ensured
 588   // we see the up-to-date region type here.
 589   if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="line-modified"> 590     return;</span>
 591   }
 592 
 593   // The result from the hot card cache insert call is either:
 594   //   * pointer to the current card
 595   //     (implying that the current card is not &#39;hot&#39;),
 596   //   * null
 597   //     (meaning we had inserted the card ptr into the &quot;hot&quot; card cache,
 598   //     which had some headroom),
 599   //   * a pointer to a &quot;hot&quot; card that was evicted from the &quot;hot&quot; cache.
 600   //
 601 
 602   if (_hot_card_cache-&gt;use_cache()) {
 603     assert(!SafepointSynchronize::is_at_safepoint(), &quot;sanity&quot;);
 604 
 605     const CardValue* orig_card_ptr = card_ptr;
 606     card_ptr = _hot_card_cache-&gt;insert(card_ptr);
 607     if (card_ptr == NULL) {
 608       // There was no eviction. Nothing to do.
<span class="line-modified"> 609       return;</span>
 610     } else if (card_ptr != orig_card_ptr) {
 611       // Original card was inserted and an old card was evicted.
 612       start = _ct-&gt;addr_for(card_ptr);
 613       r = _g1h-&gt;heap_region_containing(start);
 614 
 615       // Check whether the region formerly in the cache should be
 616       // ignored, as discussed earlier for the original card.  The
 617       // region could have been freed while in the cache.
 618       if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="line-modified"> 619         return;</span>
 620       }

 621     } // Else we still have the original card.
 622   }
 623 
 624   // Trim the region designated by the card to what&#39;s been allocated
 625   // in the region.  The card could be stale, or the card could cover
 626   // (part of) an object at the end of the allocated space and extend
 627   // beyond the end of allocation.
 628 
<span class="line-modified"> 629   // Non-humongous objects are only allocated in the old-gen during</span>
<span class="line-modified"> 630   // GC, so if region is old then top is stable.  Humongous object</span>
<span class="line-modified"> 631   // allocation sets top last; if top has not yet been set, this is</span>
<span class="line-modified"> 632   // a stale card and we&#39;ll end up with an empty intersection.  If</span>
<span class="line-modified"> 633   // this is not a stale card, the synchronization between the</span>

 634   // enqueuing of the card and processing it here will have ensured
 635   // we see the up-to-date top here.
 636   HeapWord* scan_limit = r-&gt;top();
 637 
 638   if (scan_limit &lt;= start) {
 639     // If the trimmed region is empty, the card must be stale.
<span class="line-modified"> 640     return;</span>
 641   }
 642 
 643   // Okay to clean and process the card now.  There are still some
 644   // stale card cases that may be detected by iteration and dealt with
 645   // as iteration failure.
 646   *const_cast&lt;volatile CardValue*&gt;(card_ptr) = G1CardTable::clean_card_val();
 647 
<span class="line-modified"> 648   // This fence serves two purposes.  First, the card must be cleaned</span>
<span class="line-modified"> 649   // before processing the contents.  Second, we can&#39;t proceed with</span>
<span class="line-modified"> 650   // processing until after the read of top, for synchronization with</span>
<span class="line-modified"> 651   // possibly concurrent humongous object allocation.  It&#39;s okay that</span>
<span class="line-modified"> 652   // reading top and reading type were racy wrto each other.  We need</span>
<span class="line-modified"> 653   // both set, in any order, to proceed.</span>
<span class="line-modified"> 654   OrderAccess::fence();</span>













 655 
 656   // Don&#39;t use addr_for(card_ptr + 1) which can ask for
 657   // a card beyond the heap.
 658   HeapWord* end = start + G1CardTable::card_size_in_words;
 659   MemRegion dirty_region(start, MIN2(scan_limit, end));
 660   assert(!dirty_region.is_empty(), &quot;sanity&quot;);
 661 
<span class="line-modified"> 662   G1ConcurrentRefineOopClosure conc_refine_cl(_g1h, worker_i);</span>
<span class="line-modified"> 663 </span>
<span class="line-modified"> 664   bool card_processed =</span>
<span class="line-removed"> 665     r-&gt;oops_on_card_seq_iterate_careful&lt;false&gt;(dirty_region, &amp;conc_refine_cl);</span>
<span class="line-removed"> 666 </span>
<span class="line-removed"> 667   // If unable to process the card then we encountered an unparsable</span>
<span class="line-removed"> 668   // part of the heap (e.g. a partially allocated object) while</span>
<span class="line-removed"> 669   // processing a stale card.  Despite the card being stale, redirty</span>
<span class="line-removed"> 670   // and re-enqueue, because we&#39;ve already cleaned the card.  Without</span>
<span class="line-removed"> 671   // this we could incorrectly discard a non-stale card.</span>
<span class="line-removed"> 672   if (!card_processed) {</span>
<span class="line-removed"> 673     // The card might have gotten re-dirtied and re-enqueued while we</span>
<span class="line-removed"> 674     // worked.  (In fact, it&#39;s pretty likely.)</span>
<span class="line-removed"> 675     if (*card_ptr != G1CardTable::dirty_card_val()) {</span>
<span class="line-removed"> 676       *card_ptr = G1CardTable::dirty_card_val();</span>
<span class="line-removed"> 677       MutexLockerEx x(Shared_DirtyCardQ_lock,</span>
<span class="line-removed"> 678                       Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 679       G1DirtyCardQueue* sdcq =</span>
<span class="line-removed"> 680         G1BarrierSet::dirty_card_queue_set().shared_dirty_card_queue();</span>
<span class="line-removed"> 681       sdcq-&gt;enqueue(card_ptr);</span>
<span class="line-removed"> 682     }</span>
<span class="line-removed"> 683   } else {</span>
<span class="line-removed"> 684     _num_conc_refined_cards++; // Unsynchronized update, only used for logging.</span>
<span class="line-removed"> 685   }</span>
<span class="line-removed"> 686 }</span>
<span class="line-removed"> 687 </span>
<span class="line-removed"> 688 bool G1RemSet::refine_card_during_gc(CardValue* card_ptr,</span>
<span class="line-removed"> 689                                      G1ScanObjsDuringUpdateRSClosure* update_rs_cl) {</span>
<span class="line-removed"> 690   assert(_g1h-&gt;is_gc_active(), &quot;Only call during GC&quot;);</span>
<span class="line-removed"> 691 </span>
<span class="line-removed"> 692   // Construct the region representing the card.</span>
<span class="line-removed"> 693   HeapWord* card_start = _ct-&gt;addr_for(card_ptr);</span>
<span class="line-removed"> 694   // And find the region containing it.</span>
<span class="line-removed"> 695   uint const card_region_idx = _g1h-&gt;addr_to_region(card_start);</span>
<span class="line-removed"> 696 </span>
<span class="line-removed"> 697   HeapWord* scan_limit = _scan_state-&gt;scan_top(card_region_idx);</span>
<span class="line-removed"> 698   if (scan_limit == NULL) {</span>
<span class="line-removed"> 699     // This is a card into an uncommitted region. We need to bail out early as we</span>
<span class="line-removed"> 700     // should not access the corresponding card table entry.</span>
<span class="line-removed"> 701     return false;</span>
<span class="line-removed"> 702   }</span>
<span class="line-removed"> 703 </span>
<span class="line-removed"> 704   check_card_ptr(card_ptr, _ct);</span>
<span class="line-removed"> 705 </span>
<span class="line-removed"> 706   // If the card is no longer dirty, nothing to do. This covers cards that were already</span>
<span class="line-removed"> 707   // scanned as parts of the remembered sets.</span>
<span class="line-removed"> 708   if (*card_ptr != G1CardTable::dirty_card_val()) {</span>
<span class="line-removed"> 709     return false;</span>
 710   }
 711 
<span class="line-modified"> 712   // We claim lazily (so races are possible but they&#39;re benign), which reduces the</span>
<span class="line-modified"> 713   // number of potential duplicate scans (multiple threads may enqueue the same card twice).</span>
<span class="line-modified"> 714   *card_ptr = G1CardTable::clean_card_val() | G1CardTable::claimed_card_val();</span>
<span class="line-modified"> 715 </span>
<span class="line-modified"> 716   _scan_state-&gt;add_dirty_region(card_region_idx);</span>
<span class="line-modified"> 717   if (scan_limit &lt;= card_start) {</span>
<span class="line-modified"> 718     // If the card starts above the area in the region containing objects to scan, skip it.</span>
<span class="line-modified"> 719     return false;</span>



 720   }
 721 
<span class="line-modified"> 722   // Don&#39;t use addr_for(card_ptr + 1) which can ask for</span>
<span class="line-modified"> 723   // a card beyond the heap.</span>
<span class="line-modified"> 724   HeapWord* card_end = card_start + G1CardTable::card_size_in_words;</span>
<span class="line-modified"> 725   MemRegion dirty_region(card_start, MIN2(scan_limit, card_end));</span>
<span class="line-modified"> 726   assert(!dirty_region.is_empty(), &quot;sanity&quot;);</span>
<span class="line-modified"> 727 </span>
<span class="line-removed"> 728   HeapRegion* const card_region = _g1h-&gt;region_at(card_region_idx);</span>
<span class="line-removed"> 729   assert(!card_region-&gt;is_young(), &quot;Should not scan card in young region %u&quot;, card_region_idx);</span>
<span class="line-removed"> 730   bool card_processed = card_region-&gt;oops_on_card_seq_iterate_careful&lt;true&gt;(dirty_region, update_rs_cl);</span>
<span class="line-removed"> 731   assert(card_processed, &quot;must be&quot;);</span>
<span class="line-removed"> 732   return true;</span>
 733 }
 734 
 735 void G1RemSet::print_periodic_summary_info(const char* header, uint period_count) {
 736   if ((G1SummarizeRSetStatsPeriod &gt; 0) &amp;&amp; log_is_enabled(Trace, gc, remset) &amp;&amp;
 737       (period_count % G1SummarizeRSetStatsPeriod == 0)) {
 738 
<span class="line-modified"> 739     G1RemSetSummary current(this);</span>
 740     _prev_period_summary.subtract_from(&amp;current);
 741 
 742     Log(gc, remset) log;
 743     log.trace(&quot;%s&quot;, header);
 744     ResourceMark rm;
 745     LogStream ls(log.trace());
 746     _prev_period_summary.print_on(&amp;ls);
 747 
 748     _prev_period_summary.set(&amp;current);
 749   }
 750 }
 751 
 752 void G1RemSet::print_summary_info() {
 753   Log(gc, remset, exit) log;
 754   if (log.is_trace()) {
 755     log.trace(&quot; Cumulative RS summary&quot;);
<span class="line-modified"> 756     G1RemSetSummary current(this);</span>
 757     ResourceMark rm;
 758     LogStream ls(log.trace());
 759     current.print_on(&amp;ls);
 760   }
 761 }
 762 
 763 class G1RebuildRemSetTask: public AbstractGangTask {
 764   // Aggregate the counting data that was constructed concurrently
 765   // with marking.
 766   class G1RebuildRemSetHeapRegionClosure : public HeapRegionClosure {
 767     G1ConcurrentMark* _cm;
 768     G1RebuildRemSetClosure _update_cl;
 769 
 770     // Applies _update_cl to the references of the given object, limiting objArrays
 771     // to the given MemRegion. Returns the amount of words actually scanned.
 772     size_t scan_for_references(oop const obj, MemRegion mr) {
 773       size_t const obj_size = obj-&gt;size();
 774       // All non-objArrays and objArrays completely within the mr
 775       // can be scanned without passing the mr.
<span class="line-modified"> 776       if (!obj-&gt;is_objArray() || mr.contains(MemRegion((HeapWord*)obj, obj_size))) {</span>
 777         obj-&gt;oop_iterate(&amp;_update_cl);
 778         return obj_size;
 779       }
 780       // This path is for objArrays crossing the given MemRegion. Only scan the
 781       // area within the MemRegion.
 782       obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="line-modified"> 783       return mr.intersection(MemRegion((HeapWord*)obj, obj_size)).word_size();</span>
 784     }
 785 
 786     // A humongous object is live (with respect to the scanning) either
 787     // a) it is marked on the bitmap as such
 788     // b) its TARS is larger than TAMS, i.e. has been allocated during marking.
 789     bool is_humongous_live(oop const humongous_obj, const G1CMBitMap* const bitmap, HeapWord* tams, HeapWord* tars) const {
 790       return bitmap-&gt;is_marked(humongous_obj) || (tars &gt; tams);
 791     }
 792 
 793     // Iterator over the live objects within the given MemRegion.
 794     class LiveObjIterator : public StackObj {
 795       const G1CMBitMap* const _bitmap;
 796       const HeapWord* _tams;
 797       const MemRegion _mr;
 798       HeapWord* _current;
 799 
 800       bool is_below_tams() const {
 801         return _current &lt; _tams;
 802       }
 803 
</pre>
<hr />
<pre>
 868     // Returns the number of live words between bottom and TAMS.
 869     size_t rebuild_rem_set_in_region(const G1CMBitMap* const bitmap,
 870                                      HeapWord* const top_at_mark_start,
 871                                      HeapWord* const top_at_rebuild_start,
 872                                      HeapRegion* hr,
 873                                      MemRegion mr) {
 874       size_t marked_words = 0;
 875 
 876       if (hr-&gt;is_humongous()) {
 877         oop const humongous_obj = oop(hr-&gt;humongous_start_region()-&gt;bottom());
 878         if (is_humongous_live(humongous_obj, bitmap, top_at_mark_start, top_at_rebuild_start)) {
 879           // We need to scan both [bottom, TAMS) and [TAMS, top_at_rebuild_start);
 880           // however in case of humongous objects it is sufficient to scan the encompassing
 881           // area (top_at_rebuild_start is always larger or equal to TAMS) as one of the
 882           // two areas will be zero sized. I.e. TAMS is either
 883           // the same as bottom or top(_at_rebuild_start). There is no way TAMS has a different
 884           // value: this would mean that TAMS points somewhere into the object.
 885           assert(hr-&gt;top() == top_at_mark_start || hr-&gt;top() == top_at_rebuild_start,
 886                  &quot;More than one object in the humongous region?&quot;);
 887           humongous_obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="line-modified"> 888           return top_at_mark_start != hr-&gt;bottom() ? mr.intersection(MemRegion((HeapWord*)humongous_obj, humongous_obj-&gt;size())).byte_size() : 0;</span>
 889         } else {
 890           return 0;
 891         }
 892       }
 893 
 894       for (LiveObjIterator it(bitmap, top_at_mark_start, mr, hr-&gt;block_start(mr.start())); it.has_next(); it.move_to_next()) {
 895         oop obj = it.next();
 896         size_t scanned_size = scan_for_references(obj, mr);
<span class="line-modified"> 897         if ((HeapWord*)obj &lt; top_at_mark_start) {</span>
 898           marked_words += scanned_size;
 899         }
 900       }
 901 
 902       return marked_words * HeapWordSize;
 903     }
 904 public:
 905   G1RebuildRemSetHeapRegionClosure(G1CollectedHeap* g1h,
 906                                    G1ConcurrentMark* cm,
 907                                    uint worker_id) :
 908     HeapRegionClosure(),
 909     _cm(cm),
 910     _update_cl(g1h, worker_id) { }
 911 
 912     bool do_heap_region(HeapRegion* hr) {
 913       if (_cm-&gt;has_aborted()) {
 914         return true;
 915       }
 916 
 917       uint const region_idx = hr-&gt;hrm_index();
</pre>
</td>
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1BarrierSet.hpp&quot;
  27 #include &quot;gc/g1/g1BlockOffsetTable.inline.hpp&quot;
  28 #include &quot;gc/g1/g1CardTable.inline.hpp&quot;
<span class="line-added">  29 #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;</span>
  30 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  32 #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  33 #include &quot;gc/g1/g1FromCardCache.hpp&quot;
  34 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  35 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  36 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
  37 #include &quot;gc/g1/g1RootClosures.hpp&quot;
  38 #include &quot;gc/g1/g1RemSet.hpp&quot;
<span class="line-added">  39 #include &quot;gc/g1/g1SharedDirtyCardQueue.hpp&quot;</span>
  40 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  41 #include &quot;gc/g1/heapRegionManager.inline.hpp&quot;
<span class="line-modified">  42 #include &quot;gc/g1/heapRegionRemSet.inline.hpp&quot;</span>
<span class="line-added">  43 #include &quot;gc/g1/sparsePRT.hpp&quot;</span>
  44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-added">  45 #include &quot;gc/shared/ptrQueue.hpp&quot;</span>
  46 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  47 #include &quot;jfr/jfrEvents.hpp&quot;
  48 #include &quot;memory/iterator.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  52 #include &quot;runtime/atomic.hpp&quot;</span>
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;utilities/align.hpp&quot;
  55 #include &quot;utilities/globalDefinitions.hpp&quot;
  56 #include &quot;utilities/stack.inline.hpp&quot;
  57 #include &quot;utilities/ticks.hpp&quot;
  58 
<span class="line-modified">  59 // Collects information about the overall heap root scan progress during an evacuation.</span>
<span class="line-added">  60 //</span>
<span class="line-added">  61 // Scanning the remembered sets works by first merging all sources of cards to be</span>
<span class="line-added">  62 // scanned (log buffers, hcc, remembered sets) into a single data structure to remove</span>
<span class="line-added">  63 // duplicates and simplify work distribution.</span>
<span class="line-added">  64 //</span>
<span class="line-added">  65 // During the following card scanning we not only scan this combined set of cards, but</span>
<span class="line-added">  66 // also remember that these were completely scanned. The following evacuation passes</span>
<span class="line-added">  67 // do not scan these cards again, and so need to be preserved across increments.</span>
<span class="line-added">  68 //</span>
<span class="line-added">  69 // The representation for all the cards to scan is the card table: cards can have</span>
<span class="line-added">  70 // one of three states during GC:</span>
<span class="line-added">  71 // - clean: these cards will not be scanned in this pass</span>
<span class="line-added">  72 // - dirty: these cards will be scanned in this pass</span>
<span class="line-added">  73 // - scanned: these cards have already been scanned in a previous pass</span>
<span class="line-added">  74 //</span>
<span class="line-added">  75 // After all evacuation is done, we reset the card table to clean.</span>
<span class="line-added">  76 //</span>
<span class="line-added">  77 // Work distribution occurs on &quot;chunk&quot; basis, i.e. contiguous ranges of cards. As an</span>
<span class="line-added">  78 // additional optimization, during card merging we remember which regions and which</span>
<span class="line-added">  79 // chunks actually contain cards to be scanned. Threads iterate only across these</span>
<span class="line-added">  80 // regions, and only compete for chunks containing any cards.</span>
<span class="line-added">  81 //</span>
<span class="line-added">  82 // Within these chunks, a worker scans the card table on &quot;blocks&quot; of cards, i.e.</span>
<span class="line-added">  83 // contiguous ranges of dirty cards to be scanned. These blocks are converted to actual</span>
<span class="line-added">  84 // memory ranges and then passed on to actual scanning.</span>
  85 class G1RemSetScanState : public CHeapObj&lt;mtGC&gt; {
<span class="line-added">  86   class G1DirtyRegions;</span>
<span class="line-added">  87 </span>
<span class="line-added">  88   size_t _max_regions;</span>
<span class="line-added">  89 </span>
<span class="line-added">  90   // Has this region that is part of the regions in the collection set been processed yet.</span>
<span class="line-added">  91   typedef bool G1RemsetIterState;</span>
<span class="line-added">  92 </span>
<span class="line-added">  93   G1RemsetIterState volatile* _collection_set_iter_state;</span>
<span class="line-added">  94 </span>
<span class="line-added">  95   // Card table iteration claim for each heap region, from 0 (completely unscanned)</span>
<span class="line-added">  96   // to (&gt;=) HeapRegion::CardsPerRegion (completely scanned).</span>
<span class="line-added">  97   uint volatile* _card_table_scan_state;</span>
<span class="line-added">  98 </span>
<span class="line-added">  99   // Return &quot;optimal&quot; number of chunks per region we want to use for claiming areas</span>
<span class="line-added"> 100   // within a region to claim. Dependent on the region size as proxy for the heap</span>
<span class="line-added"> 101   // size, we limit the total number of chunks to limit memory usage and maintenance</span>
<span class="line-added"> 102   // effort of that table vs. granularity of distributing scanning work.</span>
<span class="line-added"> 103   // Testing showed that 8 for 1M/2M region, 16 for 4M/8M regions, 32 for 16/32M regions</span>
<span class="line-added"> 104   // seems to be such a good trade-off.</span>
<span class="line-added"> 105   static uint get_chunks_per_region(uint log_region_size) {</span>
<span class="line-added"> 106     // Limit the expected input values to current known possible values of the</span>
<span class="line-added"> 107     // (log) region size. Adjust as necessary after testing if changing the permissible</span>
<span class="line-added"> 108     // values for region size.</span>
<span class="line-added"> 109     assert(log_region_size &gt;= 20 &amp;&amp; log_region_size &lt;= 25,</span>
<span class="line-added"> 110            &quot;expected value in [20,25], but got %u&quot;, log_region_size);</span>
<span class="line-added"> 111     return 1u &lt;&lt; (log_region_size / 2 - 7);</span>
<span class="line-added"> 112   }</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114   uint _scan_chunks_per_region;         // Number of chunks per region.</span>
<span class="line-added"> 115   uint8_t _log_scan_chunks_per_region;  // Log of number of chunks per region.</span>
<span class="line-added"> 116   bool* _region_scan_chunks;</span>
<span class="line-added"> 117   size_t _num_total_scan_chunks;        // Total number of elements in _region_scan_chunks.</span>
<span class="line-added"> 118   uint8_t _scan_chunks_shift;           // For conversion between card index and chunk index.</span>
<span class="line-added"> 119 public:</span>
<span class="line-added"> 120   uint scan_chunk_size() const { return (uint)1 &lt;&lt; _scan_chunks_shift; }</span>
<span class="line-added"> 121 </span>
<span class="line-added"> 122   // Returns whether the chunk corresponding to the given region/card in region contain a</span>
<span class="line-added"> 123   // dirty card, i.e. actually needs scanning.</span>
<span class="line-added"> 124   bool chunk_needs_scan(uint const region_idx, uint const card_in_region) const {</span>
<span class="line-added"> 125     size_t const idx = ((size_t)region_idx &lt;&lt; _log_scan_chunks_per_region) + (card_in_region &gt;&gt; _scan_chunks_shift);</span>
<span class="line-added"> 126     assert(idx &lt; _num_total_scan_chunks, &quot;Index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="line-added"> 127            idx, _num_total_scan_chunks);</span>
<span class="line-added"> 128     return _region_scan_chunks[idx];</span>
<span class="line-added"> 129   }</span>
<span class="line-added"> 130 </span>
 131 private:
<span class="line-added"> 132   // The complete set of regions which card table needs to be cleared at the end of GC because</span>
<span class="line-added"> 133   // we scribbled all over them.</span>
<span class="line-added"> 134   G1DirtyRegions* _all_dirty_regions;</span>
<span class="line-added"> 135   // The set of regions which card table needs to be scanned for new dirty cards</span>
<span class="line-added"> 136   // in the current evacuation pass.</span>
<span class="line-added"> 137   G1DirtyRegions* _next_dirty_regions;</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139   // Set of (unique) regions that can be added to concurrently.</span>
<span class="line-added"> 140   class G1DirtyRegions : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added"> 141     uint* _buffer;</span>
<span class="line-added"> 142     uint _cur_idx;</span>
<span class="line-added"> 143     size_t _max_regions;</span>
<span class="line-added"> 144 </span>
<span class="line-added"> 145     bool* _contains;</span>
<span class="line-added"> 146 </span>
<span class="line-added"> 147   public:</span>
<span class="line-added"> 148     G1DirtyRegions(size_t max_regions) :</span>
<span class="line-added"> 149       _buffer(NEW_C_HEAP_ARRAY(uint, max_regions, mtGC)),</span>
<span class="line-added"> 150       _cur_idx(0),</span>
<span class="line-added"> 151       _max_regions(max_regions),</span>
<span class="line-added"> 152       _contains(NEW_C_HEAP_ARRAY(bool, max_regions, mtGC)) {</span>
<span class="line-added"> 153 </span>
<span class="line-added"> 154       reset();</span>
<span class="line-added"> 155     }</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157     static size_t chunk_size() { return M; }</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159     ~G1DirtyRegions() {</span>
<span class="line-added"> 160       FREE_C_HEAP_ARRAY(uint, _buffer);</span>
<span class="line-added"> 161       FREE_C_HEAP_ARRAY(bool, _contains);</span>
<span class="line-added"> 162     }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164     void reset() {</span>
<span class="line-added"> 165       _cur_idx = 0;</span>
<span class="line-added"> 166       ::memset(_contains, false, _max_regions * sizeof(bool));</span>
<span class="line-added"> 167     }</span>
<span class="line-added"> 168 </span>
<span class="line-added"> 169     uint size() const { return _cur_idx; }</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     uint at(uint idx) const {</span>
<span class="line-added"> 172       assert(idx &lt; _cur_idx, &quot;Index %u beyond valid regions&quot;, idx);</span>
<span class="line-added"> 173       return _buffer[idx];</span>
<span class="line-added"> 174     }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176     void add_dirty_region(uint region) {</span>
<span class="line-added"> 177       if (_contains[region]) {</span>
<span class="line-added"> 178         return;</span>
<span class="line-added"> 179       }</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181       bool marked_as_dirty = Atomic::cmpxchg(&amp;_contains[region], false, true) == false;</span>
<span class="line-added"> 182       if (marked_as_dirty) {</span>
<span class="line-added"> 183         uint allocated = Atomic::fetch_and_add(&amp;_cur_idx, 1u);</span>
<span class="line-added"> 184         _buffer[allocated] = region;</span>
<span class="line-added"> 185       }</span>
<span class="line-added"> 186     }</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188     // Creates the union of this and the other G1DirtyRegions.</span>
<span class="line-added"> 189     void merge(const G1DirtyRegions* other) {</span>
<span class="line-added"> 190       for (uint i = 0; i &lt; other-&gt;size(); i++) {</span>
<span class="line-added"> 191         uint region = other-&gt;at(i);</span>
<span class="line-added"> 192         if (!_contains[region]) {</span>
<span class="line-added"> 193           _buffer[_cur_idx++] = region;</span>
<span class="line-added"> 194           _contains[region] = true;</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196       }</span>
<span class="line-added"> 197     }</span>
<span class="line-added"> 198   };</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200   // For each region, contains the maximum top() value to be used during this garbage</span>
<span class="line-added"> 201   // collection. Subsumes common checks like filtering out everything but old and</span>
<span class="line-added"> 202   // humongous regions outside the collection set.</span>
<span class="line-added"> 203   // This is valid because we are not interested in scanning stray remembered set</span>
<span class="line-added"> 204   // entries from free or archive regions.</span>
<span class="line-added"> 205   HeapWord** _scan_top;</span>
<span class="line-added"> 206 </span>
 207   class G1ClearCardTableTask : public AbstractGangTask {
 208     G1CollectedHeap* _g1h;
<span class="line-modified"> 209     G1DirtyRegions* _regions;</span>
<span class="line-modified"> 210     uint _chunk_length;</span>
<span class="line-modified"> 211 </span>
<span class="line-added"> 212     uint volatile _cur_dirty_regions;</span>
<span class="line-added"> 213 </span>
<span class="line-added"> 214     G1RemSetScanState* _scan_state;</span>
 215 

 216   public:
 217     G1ClearCardTableTask(G1CollectedHeap* g1h,
<span class="line-modified"> 218                          G1DirtyRegions* regions,</span>
<span class="line-modified"> 219                          uint chunk_length,</span>
<span class="line-modified"> 220                          G1RemSetScanState* scan_state) :</span>
 221       AbstractGangTask(&quot;G1 Clear Card Table Task&quot;),
 222       _g1h(g1h),
<span class="line-modified"> 223       _regions(regions),</span>

 224       _chunk_length(chunk_length),
<span class="line-modified"> 225       _cur_dirty_regions(0),</span>
<span class="line-added"> 226       _scan_state(scan_state) {</span>
 227 
 228       assert(chunk_length &gt; 0, &quot;must be&quot;);
 229     }
 230 
<span class="line-modified"> 231     static uint chunk_size() { return M; }</span>
 232 
 233     void work(uint worker_id) {
<span class="line-modified"> 234       while (_cur_dirty_regions &lt; _regions-&gt;size()) {</span>
<span class="line-modified"> 235         uint next = Atomic::fetch_and_add(&amp;_cur_dirty_regions, _chunk_length);</span>
<span class="line-modified"> 236         uint max = MIN2(next + _chunk_length, _regions-&gt;size());</span>
 237 
<span class="line-modified"> 238         for (uint i = next; i &lt; max; i++) {</span>
<span class="line-modified"> 239           HeapRegion* r = _g1h-&gt;region_at(_regions-&gt;at(i));</span>
 240           if (!r-&gt;is_survivor()) {
 241             r-&gt;clear_cardtable();
 242           }
 243         }
 244       }
 245     }
 246   };
 247 
<span class="line-modified"> 248   // Clear the card table of &quot;dirty&quot; regions.</span>
<span class="line-modified"> 249   void clear_card_table(WorkGang* workers) {</span>
<span class="line-modified"> 250     uint num_regions = _all_dirty_regions-&gt;size();</span>






























 251 
<span class="line-modified"> 252     if (num_regions == 0) {</span>
<span class="line-modified"> 253       return;</span>






 254     }

 255 
<span class="line-modified"> 256     uint const num_chunks = (uint)(align_up((size_t)num_regions &lt;&lt; HeapRegion::LogCardsPerRegion, G1ClearCardTableTask::chunk_size()) / G1ClearCardTableTask::chunk_size());</span>
<span class="line-modified"> 257     uint const num_workers = MIN2(num_chunks, workers-&gt;active_workers());</span>
<span class="line-modified"> 258     uint const chunk_length = G1ClearCardTableTask::chunk_size() / (uint)HeapRegion::CardsPerRegion;</span>
<span class="line-modified"> 259 </span>
<span class="line-modified"> 260     // Iterate over the dirty cards region list.</span>
<span class="line-modified"> 261     G1ClearCardTableTask cl(G1CollectedHeap::heap(), _all_dirty_regions, chunk_length, this);</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263     log_debug(gc, ergo)(&quot;Running %s using %u workers for %u &quot;</span>
<span class="line-added"> 264                         &quot;units of work for %u regions.&quot;,</span>
<span class="line-added"> 265                         cl.name(), num_workers, num_chunks, num_regions);</span>
<span class="line-added"> 266     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="line-added"> 267 </span>
<span class="line-added"> 268 #ifndef PRODUCT</span>
<span class="line-added"> 269     G1CollectedHeap::heap()-&gt;verifier()-&gt;verify_card_table_cleanup();</span>
<span class="line-added"> 270 #endif</span>
<span class="line-added"> 271   }</span>
<span class="line-added"> 272 </span>
 273 public:
 274   G1RemSetScanState() :
 275     _max_regions(0),
<span class="line-modified"> 276     _collection_set_iter_state(NULL),</span>
<span class="line-modified"> 277     _card_table_scan_state(NULL),</span>
<span class="line-modified"> 278     _scan_chunks_per_region(get_chunks_per_region(HeapRegion::LogOfHRGrainBytes)),</span>
<span class="line-modified"> 279     _log_scan_chunks_per_region(log2_uint(_scan_chunks_per_region)),</span>
<span class="line-modified"> 280     _region_scan_chunks(NULL),</span>
<span class="line-added"> 281     _num_total_scan_chunks(0),</span>
<span class="line-added"> 282     _scan_chunks_shift(0),</span>
<span class="line-added"> 283     _all_dirty_regions(NULL),</span>
<span class="line-added"> 284     _next_dirty_regions(NULL),</span>
 285     _scan_top(NULL) {
 286   }
 287 
 288   ~G1RemSetScanState() {
<span class="line-modified"> 289     FREE_C_HEAP_ARRAY(G1RemsetIterState, _collection_set_iter_state);</span>
<span class="line-modified"> 290     FREE_C_HEAP_ARRAY(uint, _card_table_scan_state);</span>
<span class="line-modified"> 291     FREE_C_HEAP_ARRAY(bool, _region_scan_chunks);</span>
<span class="line-modified"> 292     FREE_C_HEAP_ARRAY(HeapWord*, _scan_top);</span>











 293   }
 294 
<span class="line-modified"> 295   void initialize(size_t max_regions) {</span>
<span class="line-modified"> 296     assert(_collection_set_iter_state == NULL, &quot;Must not be initialized twice&quot;);</span>

 297     _max_regions = max_regions;
<span class="line-modified"> 298     _collection_set_iter_state = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);</span>
<span class="line-modified"> 299     _card_table_scan_state = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);</span>
<span class="line-modified"> 300     _num_total_scan_chunks = max_regions * _scan_chunks_per_region;</span>
<span class="line-modified"> 301     _region_scan_chunks = NEW_C_HEAP_ARRAY(bool, _num_total_scan_chunks, mtGC);</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303     _scan_chunks_shift = (uint8_t)log2_intptr(HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>
 304     _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_regions, mtGC);
 305   }
 306 
<span class="line-modified"> 307   void prepare() {</span>
<span class="line-modified"> 308     // Reset the claim and clear scan top for all regions, including</span>
<span class="line-modified"> 309     // regions currently not available or free. Since regions might</span>
<span class="line-modified"> 310     // become used during the collection these values must be valid</span>
<span class="line-added"> 311     // for those regions as well.</span>
<span class="line-added"> 312     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="line-added"> 313       reset_region_claim((uint)i);</span>
<span class="line-added"> 314       clear_scan_top((uint)i);</span>
 315     }
 316 
<span class="line-modified"> 317     _all_dirty_regions = new G1DirtyRegions(_max_regions);</span>
<span class="line-modified"> 318     _next_dirty_regions = new G1DirtyRegions(_max_regions);</span>




 319   }
 320 
<span class="line-modified"> 321   void prepare_for_merge_heap_roots() {</span>
<span class="line-modified"> 322     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="line-modified"> 323 </span>
<span class="line-modified"> 324     _next_dirty_regions-&gt;reset();</span>
<span class="line-modified"> 325     for (size_t i = 0; i &lt; _max_regions; i++) {</span>
<span class="line-modified"> 326       _card_table_scan_state[i] = 0;</span>
 327     }
<span class="line-modified"> 328 </span>
<span class="line-modified"> 329     ::memset(_region_scan_chunks, false, _num_total_scan_chunks * sizeof(*_region_scan_chunks));</span>
 330   }
 331 
<span class="line-modified"> 332   // Returns whether the given region contains cards we need to scan. The remembered</span>
<span class="line-modified"> 333   // set and other sources may contain cards that</span>
<span class="line-modified"> 334   // - are in uncommitted regions</span>
<span class="line-modified"> 335   // - are located in the collection set</span>
<span class="line-modified"> 336   // - are located in free regions</span>
<span class="line-added"> 337   // as we do not clean up remembered sets before merging heap roots.</span>
<span class="line-added"> 338   bool contains_cards_to_process(uint const region_idx) const {</span>
<span class="line-added"> 339     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at_or_null(region_idx);</span>
<span class="line-added"> 340     return (hr != NULL &amp;&amp; !hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive());</span>
<span class="line-added"> 341   }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   size_t num_visited_cards() const {</span>
<span class="line-added"> 344     size_t result = 0;</span>
<span class="line-added"> 345     for (uint i = 0; i &lt; _num_total_scan_chunks; i++) {</span>
<span class="line-added"> 346       if (_region_scan_chunks[i]) {</span>
<span class="line-added"> 347         result++;</span>
<span class="line-added"> 348       }</span>
 349     }
<span class="line-modified"> 350     return result * (HeapRegion::CardsPerRegion / _scan_chunks_per_region);</span>

 351   }
 352 
<span class="line-modified"> 353   size_t num_cards_in_dirty_regions() const {</span>
<span class="line-modified"> 354     return _next_dirty_regions-&gt;size() * HeapRegion::CardsPerRegion;</span>


 355   }
 356 
<span class="line-modified"> 357   void set_chunk_region_dirty(size_t const region_card_idx) {</span>
<span class="line-modified"> 358     size_t chunk_idx = region_card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="line-modified"> 359     for (uint i = 0; i &lt; _scan_chunks_per_region; i++) {</span>
<span class="line-modified"> 360       _region_scan_chunks[chunk_idx++] = true;</span>
<span class="line-added"> 361     }</span>
 362   }
 363 
<span class="line-modified"> 364   void set_chunk_dirty(size_t const card_idx) {</span>
<span class="line-modified"> 365     assert((card_idx &gt;&gt; _scan_chunks_shift) &lt; _num_total_scan_chunks,</span>
<span class="line-modified"> 366            &quot;Trying to access index &quot; SIZE_FORMAT &quot; out of bounds &quot; SIZE_FORMAT,</span>
<span class="line-modified"> 367            card_idx &gt;&gt; _scan_chunks_shift, _num_total_scan_chunks);</span>
<span class="line-added"> 368     size_t const chunk_idx = card_idx &gt;&gt; _scan_chunks_shift;</span>
<span class="line-added"> 369     if (!_region_scan_chunks[chunk_idx]) {</span>
<span class="line-added"> 370       _region_scan_chunks[chunk_idx] = true;</span>
<span class="line-added"> 371     }</span>
<span class="line-added"> 372   }</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374   void cleanup(WorkGang* workers) {</span>
<span class="line-added"> 375     _all_dirty_regions-&gt;merge(_next_dirty_regions);</span>
<span class="line-added"> 376 </span>
<span class="line-added"> 377     clear_card_table(workers);</span>
<span class="line-added"> 378 </span>
<span class="line-added"> 379     delete _all_dirty_regions;</span>
<span class="line-added"> 380     _all_dirty_regions = NULL;</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382     delete _next_dirty_regions;</span>
<span class="line-added"> 383     _next_dirty_regions = NULL;</span>
 384   }
 385 
<span class="line-modified"> 386   void iterate_dirty_regions_from(HeapRegionClosure* cl, uint worker_id) {</span>
<span class="line-modified"> 387     uint num_regions = _next_dirty_regions-&gt;size();</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389     if (num_regions == 0) {</span>
 390       return;
 391     }
 392 
<span class="line-modified"> 393     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified"> 394 </span>
<span class="line-modified"> 395     WorkGang* workers = g1h-&gt;workers();</span>
<span class="line-modified"> 396     uint const max_workers = workers-&gt;active_workers();</span>
<span class="line-added"> 397 </span>
<span class="line-added"> 398     uint const start_pos = num_regions * worker_id / max_workers;</span>
<span class="line-added"> 399     uint cur = start_pos;</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401     do {</span>
<span class="line-added"> 402       bool result = cl-&gt;do_heap_region(g1h-&gt;region_at(_next_dirty_regions-&gt;at(cur)));</span>
<span class="line-added"> 403       guarantee(!result, &quot;Not allowed to ask for early termination.&quot;);</span>
<span class="line-added"> 404       cur++;</span>
<span class="line-added"> 405       if (cur == _next_dirty_regions-&gt;size()) {</span>
<span class="line-added"> 406         cur = 0;</span>
<span class="line-added"> 407       }</span>
<span class="line-added"> 408     } while (cur != start_pos);</span>
 409   }
 410 
<span class="line-modified"> 411   void reset_region_claim(uint region_idx) {</span>
<span class="line-modified"> 412     _collection_set_iter_state[region_idx] = false;</span>
 413   }
 414 
<span class="line-modified"> 415   // Attempt to claim the given region in the collection set for iteration. Returns true</span>
<span class="line-modified"> 416   // if this call caused the transition from Unclaimed to Claimed.</span>
<span class="line-modified"> 417   inline bool claim_collection_set_region(uint region) {</span>
<span class="line-modified"> 418     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-added"> 419     if (_collection_set_iter_state[region]) {</span>
<span class="line-added"> 420       return false;</span>
 421     }
<span class="line-added"> 422     return !Atomic::cmpxchg(&amp;_collection_set_iter_state[region], false, true);</span>
<span class="line-added"> 423   }</span>
 424 
<span class="line-modified"> 425   bool has_cards_to_scan(uint region) {</span>
<span class="line-modified"> 426     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-modified"> 427     return _card_table_scan_state[region] &lt; HeapRegion::CardsPerRegion;</span>
<span class="line-added"> 428   }</span>
 429 
<span class="line-modified"> 430   uint claim_cards_to_scan(uint region, uint increment) {</span>
<span class="line-modified"> 431     assert(region &lt; _max_regions, &quot;Tried to access invalid region %u&quot;, region);</span>
<span class="line-added"> 432     return Atomic::fetch_and_add(&amp;_card_table_scan_state[region], increment);</span>
<span class="line-added"> 433   }</span>
 434 
<span class="line-modified"> 435   void add_dirty_region(uint const region) {</span>
<span class="line-modified"> 436 #ifdef ASSERT</span>
<span class="line-modified"> 437    HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="line-modified"> 438    assert(!hr-&gt;in_collection_set() &amp;&amp; hr-&gt;is_old_or_humongous_or_archive(),</span>
<span class="line-added"> 439           &quot;Region %u is not suitable for scanning, is %sin collection set or %s&quot;,</span>
<span class="line-added"> 440           hr-&gt;hrm_index(), hr-&gt;in_collection_set() ? &quot;&quot; : &quot;not &quot;, hr-&gt;get_short_type_str());</span>
<span class="line-added"> 441 #endif</span>
<span class="line-added"> 442     _next_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="line-added"> 443   }</span>
 444 
<span class="line-modified"> 445   void add_all_dirty_region(uint region) {</span>
<span class="line-modified"> 446 #ifdef ASSERT</span>
<span class="line-added"> 447     HeapRegion* hr = G1CollectedHeap::heap()-&gt;region_at(region);</span>
<span class="line-added"> 448     assert(hr-&gt;in_collection_set(),</span>
<span class="line-added"> 449            &quot;Only add young regions to all dirty regions directly but %u is %s&quot;,</span>
<span class="line-added"> 450            hr-&gt;hrm_index(), hr-&gt;get_short_type_str());</span>
 451 #endif
<span class="line-added"> 452     _all_dirty_regions-&gt;add_dirty_region(region);</span>
<span class="line-added"> 453   }</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455   void set_scan_top(uint region_idx, HeapWord* value) {</span>
<span class="line-added"> 456     _scan_top[region_idx] = value;</span>
<span class="line-added"> 457   }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459   HeapWord* scan_top(uint region_idx) const {</span>
<span class="line-added"> 460     return _scan_top[region_idx];</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463   void clear_scan_top(uint region_idx) {</span>
<span class="line-added"> 464     set_scan_top(region_idx, NULL);</span>
 465   }
 466 };
 467 
 468 G1RemSet::G1RemSet(G1CollectedHeap* g1h,
 469                    G1CardTable* ct,
 470                    G1HotCardCache* hot_card_cache) :
 471   _scan_state(new G1RemSetScanState()),
<span class="line-modified"> 472   _prev_period_summary(false),</span>
 473   _g1h(g1h),

 474   _ct(ct),
 475   _g1p(_g1h-&gt;policy()),
 476   _hot_card_cache(hot_card_cache) {
 477 }
 478 
 479 G1RemSet::~G1RemSet() {
<span class="line-modified"> 480   delete _scan_state;</span>


 481 }
 482 
 483 uint G1RemSet::num_par_rem_sets() {
 484   return G1DirtyCardQueueSet::num_par_ids() + G1ConcurrentRefine::max_num_threads() + MAX2(ConcGCThreads, ParallelGCThreads);
 485 }
 486 
 487 void G1RemSet::initialize(size_t capacity, uint max_regions) {
 488   G1FromCardCache::initialize(num_par_rem_sets(), max_regions);
 489   _scan_state-&gt;initialize(max_regions);
 490 }
 491 
<span class="line-modified"> 492 // Helper class to scan and detect ranges of cards that need to be scanned on the</span>
<span class="line-modified"> 493 // card table.</span>
<span class="line-modified"> 494 class G1CardTableScanner : public StackObj {</span>
<span class="line-modified"> 495 public:</span>
<span class="line-modified"> 496   typedef CardTable::CardValue CardValue;</span>















 497 
<span class="line-modified"> 498 private:</span>
<span class="line-modified"> 499   CardValue* const _base_addr;</span>


 500 
<span class="line-modified"> 501   CardValue* _cur_addr;</span>
<span class="line-modified"> 502   CardValue* const _end_addr;</span>





 503 
<span class="line-modified"> 504   static const size_t ToScanMask = G1CardTable::g1_card_already_scanned;</span>
<span class="line-modified"> 505   static const size_t ExpandedToScanMask = G1CardTable::WordAlreadyScanned;</span>

 506 
<span class="line-modified"> 507   bool cur_addr_aligned() const {</span>
<span class="line-modified"> 508     return ((uintptr_t)_cur_addr) % sizeof(size_t) == 0;</span>



 509   }
 510 
<span class="line-modified"> 511   bool cur_card_is_dirty() const {</span>
<span class="line-modified"> 512     CardValue value = *_cur_addr;</span>
<span class="line-added"> 513     return (value &amp; ToScanMask) == 0;</span>
<span class="line-added"> 514   }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516   bool cur_word_of_cards_contains_any_dirty_card() const {</span>
<span class="line-added"> 517     assert(cur_addr_aligned(), &quot;Current address should be aligned&quot;);</span>
<span class="line-added"> 518     size_t const value = *(size_t*)_cur_addr;</span>
<span class="line-added"> 519     return (~value &amp; ExpandedToScanMask) != 0;</span>
<span class="line-added"> 520   }</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522   bool cur_word_of_cards_all_dirty_cards() const {</span>
<span class="line-added"> 523     size_t const value = *(size_t*)_cur_addr;</span>
<span class="line-added"> 524     return value == G1CardTable::WordAllDirty;</span>
<span class="line-added"> 525   }</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527   size_t get_and_advance_pos() {</span>
<span class="line-added"> 528     _cur_addr++;</span>
<span class="line-added"> 529     return pointer_delta(_cur_addr, _base_addr, sizeof(CardValue)) - 1;</span>
<span class="line-added"> 530   }</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532 public:</span>
<span class="line-added"> 533   G1CardTableScanner(CardValue* start_card, size_t size) :</span>
<span class="line-added"> 534     _base_addr(start_card),</span>
<span class="line-added"> 535     _cur_addr(start_card),</span>
<span class="line-added"> 536     _end_addr(start_card + size) {</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     assert(is_aligned(start_card, sizeof(size_t)), &quot;Unaligned start addr &quot; PTR_FORMAT, p2i(start_card));</span>
<span class="line-added"> 539     assert(is_aligned(size, sizeof(size_t)), &quot;Unaligned size &quot; SIZE_FORMAT, size);</span>
<span class="line-added"> 540   }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542   size_t find_next_dirty() {</span>
<span class="line-added"> 543     while (!cur_addr_aligned()) {</span>
<span class="line-added"> 544       if (cur_card_is_dirty()) {</span>
<span class="line-added"> 545         return get_and_advance_pos();</span>
<span class="line-added"> 546       }</span>
<span class="line-added"> 547       _cur_addr++;</span>
<span class="line-added"> 548     }</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="line-added"> 551     while (_cur_addr != _end_addr) {</span>
<span class="line-added"> 552       if (cur_word_of_cards_contains_any_dirty_card()) {</span>
<span class="line-added"> 553         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="line-added"> 554           if (cur_card_is_dirty()) {</span>
<span class="line-added"> 555             return get_and_advance_pos();</span>
<span class="line-added"> 556           }</span>
<span class="line-added"> 557           _cur_addr++;</span>
<span class="line-added"> 558         }</span>
<span class="line-added"> 559         assert(false, &quot;Should not reach here given we detected a dirty card in the word.&quot;);</span>
<span class="line-added"> 560       }</span>
<span class="line-added"> 561       _cur_addr += sizeof(size_t);</span>
<span class="line-added"> 562     }</span>
<span class="line-added"> 563     return get_and_advance_pos();</span>
 564   }
 565 
<span class="line-modified"> 566   size_t find_next_non_dirty() {</span>
<span class="line-modified"> 567     assert(_cur_addr &lt;= _end_addr, &quot;Not allowed to search for marks after area.&quot;);</span>
 568 
<span class="line-modified"> 569     while (!cur_addr_aligned()) {</span>
<span class="line-modified"> 570       if (!cur_card_is_dirty()) {</span>
<span class="line-added"> 571         return get_and_advance_pos();</span>
<span class="line-added"> 572       }</span>
<span class="line-added"> 573       _cur_addr++;</span>
<span class="line-added"> 574     }</span>
 575 
<span class="line-modified"> 576     assert(cur_addr_aligned(), &quot;Current address should be aligned now.&quot;);</span>
<span class="line-modified"> 577     while (_cur_addr != _end_addr) {</span>
<span class="line-modified"> 578       if (!cur_word_of_cards_all_dirty_cards()) {</span>
<span class="line-modified"> 579         for (size_t i = 0; i &lt; sizeof(size_t); i++) {</span>
<span class="line-added"> 580           if (!cur_card_is_dirty()) {</span>
<span class="line-added"> 581             return get_and_advance_pos();</span>
<span class="line-added"> 582           }</span>
<span class="line-added"> 583           _cur_addr++;</span>
<span class="line-added"> 584         }</span>
<span class="line-added"> 585         assert(false, &quot;Should not reach here given we detected a non-dirty card in the word.&quot;);</span>
<span class="line-added"> 586       }</span>
<span class="line-added"> 587       _cur_addr += sizeof(size_t);</span>
 588     }
<span class="line-modified"> 589     return get_and_advance_pos();</span>
<span class="line-modified"> 590   }</span>
<span class="line-modified"> 591 };</span>
<span class="line-added"> 592 </span>
<span class="line-added"> 593 // Helper class to claim dirty chunks within the card table.</span>
<span class="line-added"> 594 class G1CardTableChunkClaimer {</span>
<span class="line-added"> 595   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 596   uint _region_idx;</span>
<span class="line-added"> 597   uint _cur_claim;</span>
<span class="line-added"> 598 </span>
<span class="line-added"> 599 public:</span>
<span class="line-added"> 600   G1CardTableChunkClaimer(G1RemSetScanState* scan_state, uint region_idx) :</span>
<span class="line-added"> 601     _scan_state(scan_state),</span>
<span class="line-added"> 602     _region_idx(region_idx),</span>
<span class="line-added"> 603     _cur_claim(0) {</span>
<span class="line-added"> 604     guarantee(size() &lt;= HeapRegion::CardsPerRegion, &quot;Should not claim more space than possible.&quot;);</span>
<span class="line-added"> 605   }</span>
<span class="line-added"> 606 </span>
<span class="line-added"> 607   bool has_next() {</span>
<span class="line-added"> 608     while (true) {</span>
<span class="line-added"> 609       _cur_claim = _scan_state-&gt;claim_cards_to_scan(_region_idx, size());</span>
<span class="line-added"> 610       if (_cur_claim &gt;= HeapRegion::CardsPerRegion) {</span>
<span class="line-added"> 611         return false;</span>
<span class="line-added"> 612       }</span>
<span class="line-added"> 613       if (_scan_state-&gt;chunk_needs_scan(_region_idx, _cur_claim)) {</span>
<span class="line-added"> 614         return true;</span>
<span class="line-added"> 615       }</span>
 616     }
<span class="line-modified"> 617   }</span>
 618 
<span class="line-modified"> 619   uint value() const { return _cur_claim; }</span>
<span class="line-modified"> 620   uint size() const { return _scan_state-&gt;scan_chunk_size(); }</span>
<span class="line-added"> 621 };</span>
 622 
<span class="line-added"> 623 // Scans a heap region for dirty cards.</span>
<span class="line-added"> 624 class G1ScanHRForRegionClosure : public HeapRegionClosure {</span>
<span class="line-added"> 625   G1CollectedHeap* _g1h;</span>
<span class="line-added"> 626   G1CardTable* _ct;</span>
<span class="line-added"> 627   G1BlockOffsetTable* _bot;</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629   G1ParScanThreadState* _pss;</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 632 </span>
<span class="line-added"> 633   G1GCPhaseTimes::GCParPhases _phase;</span>
<span class="line-added"> 634 </span>
<span class="line-added"> 635   uint   _worker_id;</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637   size_t _cards_scanned;</span>
<span class="line-added"> 638   size_t _blocks_scanned;</span>
<span class="line-added"> 639   size_t _chunks_claimed;</span>
<span class="line-added"> 640 </span>
<span class="line-added"> 641   Tickspan _rem_set_root_scan_time;</span>
<span class="line-added"> 642   Tickspan _rem_set_trim_partially_time;</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644   // The address to which this thread already scanned (walked the heap) up to during</span>
<span class="line-added"> 645   // card scanning (exclusive).</span>
<span class="line-added"> 646   HeapWord* _scanned_to;</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648   HeapWord* scan_memregion(uint region_idx_for_card, MemRegion mr) {</span>
<span class="line-added"> 649     HeapRegion* const card_region = _g1h-&gt;region_at(region_idx_for_card);</span>
<span class="line-added"> 650     G1ScanCardClosure card_cl(_g1h, _pss);</span>
<span class="line-added"> 651 </span>
<span class="line-added"> 652     HeapWord* const scanned_to = card_region-&gt;oops_on_memregion_seq_iterate_careful&lt;true&gt;(mr, &amp;card_cl);</span>
<span class="line-added"> 653     assert(scanned_to != NULL, &quot;Should be able to scan range&quot;);</span>
<span class="line-added"> 654     assert(scanned_to &gt;= mr.end(), &quot;Scanned to &quot; PTR_FORMAT &quot; less than range &quot; PTR_FORMAT, p2i(scanned_to), p2i(mr.end()));</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     _pss-&gt;trim_queue_partially();</span>
<span class="line-added"> 657     return scanned_to;</span>
<span class="line-added"> 658   }</span>
<span class="line-added"> 659 </span>
<span class="line-added"> 660   void do_claimed_block(uint const region_idx_for_card, size_t const first_card, size_t const num_cards) {</span>
<span class="line-added"> 661     HeapWord* const card_start = _bot-&gt;address_for_index_raw(first_card);</span>
 662 #ifdef ASSERT
 663     HeapRegion* hr = _g1h-&gt;region_at_or_null(region_idx_for_card);
 664     assert(hr == NULL || hr-&gt;is_in_reserved(card_start),
<span class="line-modified"> 665              &quot;Card start &quot; PTR_FORMAT &quot; to scan outside of region %u&quot;, p2i(card_start), _g1h-&gt;region_at(region_idx_for_card)-&gt;hrm_index());</span>
 666 #endif
 667     HeapWord* const top = _scan_state-&gt;scan_top(region_idx_for_card);
 668     if (card_start &gt;= top) {
<span class="line-modified"> 669       return;</span>
<span class="line-added"> 670     }</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     HeapWord* scan_end = MIN2(card_start + (num_cards &lt;&lt; BOTConstants::LogN_words), top);</span>
<span class="line-added"> 673     if (_scanned_to &gt;= scan_end) {</span>
<span class="line-added"> 674       return;</span>
 675     }
<span class="line-added"> 676     MemRegion mr(MAX2(card_start, _scanned_to), scan_end);</span>
<span class="line-added"> 677     _scanned_to = scan_memregion(region_idx_for_card, mr);</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679     _cards_scanned += num_cards;</span>
<span class="line-added"> 680   }</span>
<span class="line-added"> 681 </span>
<span class="line-added"> 682   ALWAYSINLINE void do_card_block(uint const region_idx, size_t const first_card, size_t const num_cards) {</span>
<span class="line-added"> 683     _ct-&gt;mark_as_scanned(first_card, num_cards);</span>
<span class="line-added"> 684     do_claimed_block(region_idx, first_card, num_cards);</span>
<span class="line-added"> 685     _blocks_scanned++;</span>
<span class="line-added"> 686   }</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688    void scan_heap_roots(HeapRegion* r) {</span>
<span class="line-added"> 689     EventGCPhaseParallel event;</span>
<span class="line-added"> 690     uint const region_idx = r-&gt;hrm_index();</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     ResourceMark rm;</span>
<span class="line-added"> 693 </span>
<span class="line-added"> 694     G1CardTableChunkClaimer claim(_scan_state, region_idx);</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696     // Set the current scan &quot;finger&quot; to NULL for every heap region to scan. Since</span>
<span class="line-added"> 697     // the claim value is monotonically increasing, the check to not scan below this</span>
<span class="line-added"> 698     // will filter out objects spanning chunks within the region too then, as opposed</span>
<span class="line-added"> 699     // to resetting this value for every claim.</span>
<span class="line-added"> 700     _scanned_to = NULL;</span>
<span class="line-added"> 701 </span>
<span class="line-added"> 702     while (claim.has_next()) {</span>
<span class="line-added"> 703       size_t const region_card_base_idx = ((size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion) + claim.value();</span>
<span class="line-added"> 704       CardTable::CardValue* const base_addr = _ct-&gt;byte_for_index(region_card_base_idx);</span>
<span class="line-added"> 705 </span>
<span class="line-added"> 706       G1CardTableScanner scan(base_addr, claim.size());</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708       size_t first_scan_idx = scan.find_next_dirty();</span>
<span class="line-added"> 709       while (first_scan_idx != claim.size()) {</span>
<span class="line-added"> 710         assert(*_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx) &lt;= 0x1, &quot;is %d at region %u idx &quot; SIZE_FORMAT, *_ct-&gt;byte_for_index(region_card_base_idx + first_scan_idx), region_idx, first_scan_idx);</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712         size_t const last_scan_idx = scan.find_next_non_dirty();</span>
<span class="line-added"> 713         size_t const len = last_scan_idx - first_scan_idx;</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715         do_card_block(region_idx, region_card_base_idx + first_scan_idx, len);</span>
 716 
<span class="line-modified"> 717         if (last_scan_idx == claim.size()) {</span>
<span class="line-modified"> 718           break;</span>
<span class="line-modified"> 719         }</span>
<span class="line-added"> 720 </span>
<span class="line-added"> 721         first_scan_idx = scan.find_next_dirty();</span>
<span class="line-added"> 722       }</span>
<span class="line-added"> 723       _chunks_claimed++;</span>
 724     }
 725 
<span class="line-modified"> 726     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::ScanHR));</span>
<span class="line-modified"> 727   }</span>
<span class="line-modified"> 728 </span>
<span class="line-modified"> 729 public:</span>
<span class="line-modified"> 730   G1ScanHRForRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="line-modified"> 731                            G1ParScanThreadState* pss,</span>
<span class="line-modified"> 732                            uint worker_id,</span>
<span class="line-added"> 733                            G1GCPhaseTimes::GCParPhases phase) :</span>
<span class="line-added"> 734     _g1h(G1CollectedHeap::heap()),</span>
<span class="line-added"> 735     _ct(_g1h-&gt;card_table()),</span>
<span class="line-added"> 736     _bot(_g1h-&gt;bot()),</span>
<span class="line-added"> 737     _pss(pss),</span>
<span class="line-added"> 738     _scan_state(scan_state),</span>
<span class="line-added"> 739     _phase(phase),</span>
<span class="line-added"> 740     _worker_id(worker_id),</span>
<span class="line-added"> 741     _cards_scanned(0),</span>
<span class="line-added"> 742     _blocks_scanned(0),</span>
<span class="line-added"> 743     _chunks_claimed(0),</span>
<span class="line-added"> 744     _rem_set_root_scan_time(),</span>
<span class="line-added"> 745     _rem_set_trim_partially_time(),</span>
<span class="line-added"> 746     _scanned_to(NULL) {</span>
<span class="line-added"> 747   }</span>
 748 
<span class="line-modified"> 749   bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 750     assert(!r-&gt;in_collection_set() &amp;&amp; r-&gt;is_old_or_humongous_or_archive(),</span>
<span class="line-added"> 751            &quot;Should only be called on old gen non-collection set regions but region %u is not.&quot;,</span>
<span class="line-added"> 752            r-&gt;hrm_index());</span>
<span class="line-added"> 753     uint const region_idx = r-&gt;hrm_index();</span>
 754 
<span class="line-modified"> 755     if (_scan_state-&gt;has_cards_to_scan(region_idx)) {</span>
<span class="line-added"> 756       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_root_scan_time, _rem_set_trim_partially_time);</span>
<span class="line-added"> 757       scan_heap_roots(r);</span>
<span class="line-added"> 758     }</span>
<span class="line-added"> 759     return false;</span>
 760   }


 761 
<span class="line-modified"> 762   Tickspan rem_set_root_scan_time() const { return _rem_set_root_scan_time; }</span>
<span class="line-modified"> 763   Tickspan rem_set_trim_partially_time() const { return _rem_set_trim_partially_time; }</span>
<span class="line-modified"> 764 </span>
<span class="line-modified"> 765   size_t cards_scanned() const { return _cards_scanned; }</span>
<span class="line-modified"> 766   size_t blocks_scanned() const { return _blocks_scanned; }</span>
<span class="line-modified"> 767   size_t chunks_claimed() const { return _chunks_claimed; }</span>
<span class="line-modified"> 768 };</span>
<span class="line-modified"> 769 </span>
<span class="line-added"> 770 void G1RemSet::scan_heap_roots(G1ParScanThreadState* pss,</span>
<span class="line-added"> 771                             uint worker_id,</span>
<span class="line-added"> 772                             G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 773                             G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="line-added"> 774   G1ScanHRForRegionClosure cl(_scan_state, pss, worker_id, scan_phase);</span>
<span class="line-added"> 775   _scan_state-&gt;iterate_dirty_regions_from(&amp;cl, worker_id);</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777   G1GCPhaseTimes* p = _g1p-&gt;phase_times();</span>
<span class="line-added"> 778 </span>
<span class="line-added"> 779   p-&gt;record_or_add_time_secs(objcopy_phase, worker_id, cl.rem_set_trim_partially_time().seconds());</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_root_scan_time().seconds());</span>
<span class="line-added"> 782   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.cards_scanned(), G1GCPhaseTimes::ScanHRScannedCards);</span>
<span class="line-added"> 783   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.blocks_scanned(), G1GCPhaseTimes::ScanHRScannedBlocks);</span>
<span class="line-added"> 784   p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.chunks_claimed(), G1GCPhaseTimes::ScanHRClaimedChunks);</span>
 785 }
 786 
<span class="line-modified"> 787 // Heap region closure to be applied to all regions in the current collection set</span>
<span class="line-modified"> 788 // increment to fix up non-card related roots.</span>
<span class="line-modified"> 789 class G1ScanCollectionSetRegionClosure : public HeapRegionClosure {</span>
<span class="line-modified"> 790   G1ParScanThreadState* _pss;</span>
<span class="line-modified"> 791   G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 792 </span>
<span class="line-added"> 793   G1GCPhaseTimes::GCParPhases _scan_phase;</span>
<span class="line-added"> 794   G1GCPhaseTimes::GCParPhases _code_roots_phase;</span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796   uint _worker_id;</span>
<span class="line-added"> 797 </span>
<span class="line-added"> 798   size_t _opt_refs_scanned;</span>
<span class="line-added"> 799   size_t _opt_refs_memory_used;</span>
<span class="line-added"> 800 </span>
<span class="line-added"> 801   Tickspan _strong_code_root_scan_time;</span>
<span class="line-added"> 802   Tickspan _strong_code_trim_partially_time;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804   Tickspan _rem_set_opt_root_scan_time;</span>
<span class="line-added"> 805   Tickspan _rem_set_opt_trim_partially_time;</span>
<span class="line-added"> 806 </span>
<span class="line-added"> 807   void scan_opt_rem_set_roots(HeapRegion* r) {</span>
<span class="line-added"> 808     EventGCPhaseParallel event;</span>
<span class="line-added"> 809 </span>
<span class="line-added"> 810     G1OopStarChunkedList* opt_rem_set_list = _pss-&gt;oops_into_optional_region(r);</span>
<span class="line-added"> 811 </span>
<span class="line-added"> 812     G1ScanCardClosure scan_cl(G1CollectedHeap::heap(), _pss);</span>
<span class="line-added"> 813     G1ScanRSForOptionalClosure cl(G1CollectedHeap::heap(), &amp;scan_cl);</span>
<span class="line-added"> 814     _opt_refs_scanned += opt_rem_set_list-&gt;oops_do(&amp;cl, _pss-&gt;closures()-&gt;strong_oops());</span>
<span class="line-added"> 815     _opt_refs_memory_used += opt_rem_set_list-&gt;used_memory();</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817     event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_scan_phase));</span>
<span class="line-added"> 818   }</span>
<span class="line-added"> 819 </span>
<span class="line-added"> 820 public:</span>
<span class="line-added"> 821   G1ScanCollectionSetRegionClosure(G1RemSetScanState* scan_state,</span>
<span class="line-added"> 822                                    G1ParScanThreadState* pss,</span>
<span class="line-added"> 823                                    uint worker_id,</span>
<span class="line-added"> 824                                    G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 825                                    G1GCPhaseTimes::GCParPhases code_roots_phase) :</span>
<span class="line-added"> 826     _pss(pss),</span>
<span class="line-added"> 827     _scan_state(scan_state),</span>
<span class="line-added"> 828     _scan_phase(scan_phase),</span>
<span class="line-added"> 829     _code_roots_phase(code_roots_phase),</span>
<span class="line-added"> 830     _worker_id(worker_id),</span>
<span class="line-added"> 831     _opt_refs_scanned(0),</span>
<span class="line-added"> 832     _opt_refs_memory_used(0),</span>
<span class="line-added"> 833     _strong_code_root_scan_time(),</span>
<span class="line-added"> 834     _strong_code_trim_partially_time(),</span>
<span class="line-added"> 835     _rem_set_opt_root_scan_time(),</span>
<span class="line-added"> 836     _rem_set_opt_trim_partially_time() { }</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838   bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 839     uint const region_idx = r-&gt;hrm_index();</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841     // The individual references for the optional remembered set are per-worker, so we</span>
<span class="line-added"> 842     // always need to scan them.</span>
<span class="line-added"> 843     if (r-&gt;has_index_in_opt_cset()) {</span>
<span class="line-added"> 844       G1EvacPhaseWithTrimTimeTracker timer(_pss, _rem_set_opt_root_scan_time, _rem_set_opt_trim_partially_time);</span>
<span class="line-added"> 845       scan_opt_rem_set_roots(r);</span>
<span class="line-added"> 846     }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848     if (_scan_state-&gt;claim_collection_set_region(region_idx)) {</span>
<span class="line-added"> 849       EventGCPhaseParallel event;</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851       G1EvacPhaseWithTrimTimeTracker timer(_pss, _strong_code_root_scan_time, _strong_code_trim_partially_time);</span>
<span class="line-added"> 852       // Scan the strong code root list attached to the current region</span>
<span class="line-added"> 853       r-&gt;strong_code_roots_do(_pss-&gt;closures()-&gt;weak_codeblobs());</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855       event.commit(GCId::current(), _worker_id, G1GCPhaseTimes::phase_name(_code_roots_phase));</span>
<span class="line-added"> 856     }</span>
 857 


 858     return false;
 859   }
 860 
<span class="line-modified"> 861   Tickspan strong_code_root_scan_time() const { return _strong_code_root_scan_time;  }</span>
<span class="line-modified"> 862   Tickspan strong_code_root_trim_partially_time() const { return _strong_code_trim_partially_time; }</span>
<span class="line-modified"> 863 </span>
<span class="line-added"> 864   Tickspan rem_set_opt_root_scan_time() const { return _rem_set_opt_root_scan_time; }</span>
<span class="line-added"> 865   Tickspan rem_set_opt_trim_partially_time() const { return _rem_set_opt_trim_partially_time; }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867   size_t opt_refs_scanned() const { return _opt_refs_scanned; }</span>
<span class="line-added"> 868   size_t opt_refs_memory_used() const { return _opt_refs_memory_used; }</span>
<span class="line-added"> 869 };</span>
<span class="line-added"> 870 </span>
<span class="line-added"> 871 void G1RemSet::scan_collection_set_regions(G1ParScanThreadState* pss,</span>
<span class="line-added"> 872                                            uint worker_id,</span>
<span class="line-added"> 873                                            G1GCPhaseTimes::GCParPhases scan_phase,</span>
<span class="line-added"> 874                                            G1GCPhaseTimes::GCParPhases coderoots_phase,</span>
<span class="line-added"> 875                                            G1GCPhaseTimes::GCParPhases objcopy_phase) {</span>
<span class="line-added"> 876   G1ScanCollectionSetRegionClosure cl(_scan_state, pss, worker_id, scan_phase, coderoots_phase);</span>
<span class="line-added"> 877   _g1h-&gt;collection_set_iterate_increment_from(&amp;cl, worker_id);</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879   G1GCPhaseTimes* p = _g1h-&gt;phase_times();</span>
<span class="line-added"> 880 </span>
<span class="line-added"> 881   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_root_scan_time().seconds());</span>
<span class="line-added"> 882   p-&gt;record_or_add_time_secs(scan_phase, worker_id, cl.rem_set_opt_trim_partially_time().seconds());</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884   p-&gt;record_or_add_time_secs(coderoots_phase, worker_id, cl.strong_code_root_scan_time().seconds());</span>
<span class="line-added"> 885   p-&gt;add_time_secs(objcopy_phase, worker_id, cl.strong_code_root_trim_partially_time().seconds());</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887   // At this time we record some metrics only for the evacuations after the initial one.</span>
<span class="line-added"> 888   if (scan_phase == G1GCPhaseTimes::OptScanHR) {</span>
<span class="line-added"> 889     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_scanned(), G1GCPhaseTimes::ScanHRScannedOptRefs);</span>
<span class="line-added"> 890     p-&gt;record_or_add_thread_work_item(scan_phase, worker_id, cl.opt_refs_memory_used(), G1GCPhaseTimes::ScanHRUsedMemory);</span>
 891   }
<span class="line-added"> 892 }</span>
 893 
<span class="line-modified"> 894 void G1RemSet::prepare_region_for_scan(HeapRegion* region) {</span>
<span class="line-modified"> 895   uint hrm_index = region-&gt;hrm_index();</span>
<span class="line-modified"> 896 </span>
<span class="line-modified"> 897   if (region-&gt;in_collection_set()) {</span>
<span class="line-added"> 898     // Young regions had their card table marked as young at their allocation;</span>
<span class="line-added"> 899     // we need to make sure that these marks are cleared at the end of GC, *but*</span>
<span class="line-added"> 900     // they should not be scanned for cards.</span>
<span class="line-added"> 901     // So directly add them to the &quot;all_dirty_regions&quot;.</span>
<span class="line-added"> 902     // Same for regions in the (initial) collection set: they may contain cards from</span>
<span class="line-added"> 903     // the log buffers, make sure they are cleaned.</span>
<span class="line-added"> 904     _scan_state-&gt;add_all_dirty_region(hrm_index);</span>
<span class="line-added"> 905   } else if (region-&gt;is_old_or_humongous_or_archive()) {</span>
<span class="line-added"> 906     _scan_state-&gt;set_scan_top(hrm_index, region-&gt;top());</span>
<span class="line-added"> 907   } else {</span>
<span class="line-added"> 908     assert(region-&gt;is_free(), &quot;Should only be free region at this point %s&quot;, region-&gt;get_type_str());</span>
 909   }

 910 }
 911 
<span class="line-modified"> 912 void G1RemSet::prepare_for_scan_heap_roots() {</span>
<span class="line-modified"> 913   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-modified"> 914   dcqs.concatenate_logs();</span>

 915 
<span class="line-modified"> 916   _scan_state-&gt;prepare();</span>
<span class="line-added"> 917 }</span>
 918 
<span class="line-modified"> 919 class G1MergeHeapRootsTask : public AbstractGangTask {</span>

 920 
<span class="line-modified"> 921   // Visitor for remembered sets, dropping entries onto the card table.</span>
<span class="line-modified"> 922   class G1MergeCardSetClosure : public HeapRegionClosure {</span>
<span class="line-modified"> 923     G1RemSetScanState* _scan_state;</span>
<span class="line-added"> 924     G1CardTable* _ct;</span>
 925 
<span class="line-modified"> 926     uint _merged_sparse;</span>
<span class="line-modified"> 927     uint _merged_fine;</span>
<span class="line-modified"> 928     uint _merged_coarse;</span>
 929 
<span class="line-modified"> 930     size_t _cards_dirty;</span>
<span class="line-modified"> 931 </span>
<span class="line-modified"> 932     // Returns if the region contains cards we need to scan. If so, remember that</span>
<span class="line-modified"> 933     // region in the current set of dirty regions.</span>
<span class="line-added"> 934     bool remember_if_interesting(uint const region_idx) {</span>
<span class="line-added"> 935       if (!_scan_state-&gt;contains_cards_to_process(region_idx)) {</span>
<span class="line-added"> 936         return false;</span>
<span class="line-added"> 937       }</span>
<span class="line-added"> 938       _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="line-added"> 939       return true;</span>
<span class="line-added"> 940     }</span>
<span class="line-added"> 941   public:</span>
<span class="line-added"> 942     G1MergeCardSetClosure(G1RemSetScanState* scan_state) :</span>
<span class="line-added"> 943       _scan_state(scan_state),</span>
<span class="line-added"> 944       _ct(G1CollectedHeap::heap()-&gt;card_table()),</span>
<span class="line-added"> 945       _merged_sparse(0),</span>
<span class="line-added"> 946       _merged_fine(0),</span>
<span class="line-added"> 947       _merged_coarse(0),</span>
<span class="line-added"> 948       _cards_dirty(0) { }</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     void next_coarse_prt(uint const region_idx) {</span>
<span class="line-added"> 951       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 952         return;</span>
<span class="line-added"> 953       }</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955       _merged_coarse++;</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957       size_t region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 958       _cards_dirty += _ct-&gt;mark_region_dirty(region_base_idx, HeapRegion::CardsPerRegion);</span>
<span class="line-added"> 959       _scan_state-&gt;set_chunk_region_dirty(region_base_idx);</span>
<span class="line-added"> 960     }</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962     void next_fine_prt(uint const region_idx, BitMap* bm) {</span>
<span class="line-added"> 963       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 964         return;</span>
<span class="line-added"> 965       }</span>
<span class="line-added"> 966 </span>
<span class="line-added"> 967       _merged_fine++;</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 970       BitMap::idx_t cur = bm-&gt;get_next_one_offset(0);</span>
<span class="line-added"> 971       while (cur != bm-&gt;size()) {</span>
<span class="line-added"> 972         _cards_dirty += _ct-&gt;mark_clean_as_dirty(region_base_idx + cur);</span>
<span class="line-added"> 973         _scan_state-&gt;set_chunk_dirty(region_base_idx + cur);</span>
<span class="line-added"> 974         cur = bm-&gt;get_next_one_offset(cur + 1);</span>
<span class="line-added"> 975       }</span>
<span class="line-added"> 976     }</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978     void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {</span>
<span class="line-added"> 979       if (!remember_if_interesting(region_idx)) {</span>
<span class="line-added"> 980         return;</span>
<span class="line-added"> 981       }</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983       _merged_sparse++;</span>
<span class="line-added"> 984 </span>
<span class="line-added"> 985       size_t const region_base_idx = (size_t)region_idx &lt;&lt; HeapRegion::LogCardsPerRegion;</span>
<span class="line-added"> 986       for (uint i = 0; i &lt; num_cards; i++) {</span>
<span class="line-added"> 987         size_t card_idx = region_base_idx + cards[i];</span>
<span class="line-added"> 988         _cards_dirty += _ct-&gt;mark_clean_as_dirty(card_idx);</span>
<span class="line-added"> 989         _scan_state-&gt;set_chunk_dirty(card_idx);</span>
<span class="line-added"> 990       }</span>
<span class="line-added"> 991     }</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added"> 994       assert(r-&gt;in_collection_set() || r-&gt;is_starts_humongous(), &quot;must be&quot;);</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996       HeapRegionRemSet* rem_set = r-&gt;rem_set();</span>
<span class="line-added"> 997       if (!rem_set-&gt;is_empty()) {</span>
<span class="line-added"> 998         rem_set-&gt;iterate_prts(*this);</span>
<span class="line-added"> 999       }</span>
<span class="line-added">1000 </span>
<span class="line-added">1001       return false;</span>
<span class="line-added">1002     }</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     size_t merged_sparse() const { return _merged_sparse; }</span>
<span class="line-added">1005     size_t merged_fine() const { return _merged_fine; }</span>
<span class="line-added">1006     size_t merged_coarse() const { return _merged_coarse; }</span>
<span class="line-added">1007 </span>
<span class="line-added">1008     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="line-added">1009   };</span>
<span class="line-added">1010 </span>
<span class="line-added">1011   // Visitor for the remembered sets of humongous candidate regions to merge their</span>
<span class="line-added">1012   // remembered set into the card table.</span>
<span class="line-added">1013   class G1FlushHumongousCandidateRemSets : public HeapRegionClosure {</span>
<span class="line-added">1014     G1MergeCardSetClosure _cl;</span>
<span class="line-added">1015 </span>
<span class="line-added">1016   public:</span>
<span class="line-added">1017     G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }</span>
<span class="line-added">1018 </span>
<span class="line-added">1019     virtual bool do_heap_region(HeapRegion* r) {</span>
<span class="line-added">1020       G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-added">1021 </span>
<span class="line-added">1022       if (!r-&gt;is_starts_humongous() ||</span>
<span class="line-added">1023           !g1h-&gt;region_attr(r-&gt;hrm_index()).is_humongous() ||</span>
<span class="line-added">1024           r-&gt;rem_set()-&gt;is_empty()) {</span>
<span class="line-added">1025         return false;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027 </span>
<span class="line-added">1028       guarantee(r-&gt;rem_set()-&gt;occupancy_less_or_equal_than(G1RSetSparseRegionEntries),</span>
<span class="line-added">1029                 &quot;Found a not-small remembered set here. This is inconsistent with previous assumptions.&quot;);</span>
<span class="line-added">1030 </span>
<span class="line-added">1031       _cl.do_heap_region(r);</span>
<span class="line-added">1032 </span>
<span class="line-added">1033       // We should only clear the card based remembered set here as we will not</span>
<span class="line-added">1034       // implicitly rebuild anything else during eager reclaim. Note that at the moment</span>
<span class="line-added">1035       // (and probably never) we do not enter this path if there are other kind of</span>
<span class="line-added">1036       // remembered sets for this region.</span>
<span class="line-added">1037       r-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);</span>
<span class="line-added">1038       // Clear_locked() above sets the state to Empty. However we want to continue</span>
<span class="line-added">1039       // collecting remembered set entries for humongous regions that were not</span>
<span class="line-added">1040       // reclaimed.</span>
<span class="line-added">1041       r-&gt;rem_set()-&gt;set_state_complete();</span>
<span class="line-added">1042 #ifdef ASSERT</span>
<span class="line-added">1043       G1HeapRegionAttr region_attr = g1h-&gt;region_attr(r-&gt;hrm_index());</span>
<span class="line-added">1044       assert(region_attr.needs_remset_update(), &quot;must be&quot;);</span>
<span class="line-added">1045 #endif</span>
<span class="line-added">1046       assert(r-&gt;rem_set()-&gt;is_empty(), &quot;At this point any humongous candidate remembered set must be empty.&quot;);</span>
<span class="line-added">1047 </span>
<span class="line-added">1048       return false;</span>
<span class="line-added">1049     }</span>
<span class="line-added">1050 </span>
<span class="line-added">1051     size_t merged_sparse() const { return _cl.merged_sparse(); }</span>
<span class="line-added">1052     size_t merged_fine() const { return _cl.merged_fine(); }</span>
<span class="line-added">1053     size_t merged_coarse() const { return _cl.merged_coarse(); }</span>
<span class="line-added">1054 </span>
<span class="line-added">1055     size_t cards_dirty() const { return _cl.cards_dirty(); }</span>
<span class="line-added">1056   };</span>
<span class="line-added">1057 </span>
<span class="line-added">1058   // Visitor for the log buffer entries to merge them into the card table.</span>
<span class="line-added">1059   class G1MergeLogBufferCardsClosure : public G1CardTableEntryClosure {</span>
<span class="line-added">1060     G1RemSetScanState* _scan_state;</span>
<span class="line-added">1061     G1CardTable* _ct;</span>
<span class="line-added">1062 </span>
<span class="line-added">1063     size_t _cards_dirty;</span>
<span class="line-added">1064     size_t _cards_skipped;</span>
<span class="line-added">1065   public:</span>
<span class="line-added">1066     G1MergeLogBufferCardsClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :</span>
<span class="line-added">1067       _scan_state(scan_state), _ct(g1h-&gt;card_table()), _cards_dirty(0), _cards_skipped(0)</span>
<span class="line-added">1068     {}</span>
<span class="line-added">1069 </span>
<span class="line-added">1070     void do_card_ptr(CardValue* card_ptr, uint worker_id) {</span>
<span class="line-added">1071       // The only time we care about recording cards that</span>
<span class="line-added">1072       // contain references that point into the collection set</span>
<span class="line-added">1073       // is during RSet updating within an evacuation pause.</span>
<span class="line-added">1074       // In this case worker_id should be the id of a GC worker thread.</span>
<span class="line-added">1075       assert(SafepointSynchronize::is_at_safepoint(), &quot;not during an evacuation pause&quot;);</span>
<span class="line-added">1076 </span>
<span class="line-added">1077       uint const region_idx = _ct-&gt;region_idx_for(card_ptr);</span>
<span class="line-added">1078 </span>
<span class="line-added">1079       // The second clause must come after - the log buffers might contain cards to uncommited</span>
<span class="line-added">1080       // regions.</span>
<span class="line-added">1081       // This code may count duplicate entries in the log buffers (even if rare) multiple</span>
<span class="line-added">1082       // times.</span>
<span class="line-added">1083       if (_scan_state-&gt;contains_cards_to_process(region_idx) &amp;&amp; (*card_ptr == G1CardTable::dirty_card_val())) {</span>
<span class="line-added">1084         _scan_state-&gt;add_dirty_region(region_idx);</span>
<span class="line-added">1085         _scan_state-&gt;set_chunk_dirty(_ct-&gt;index_for_cardvalue(card_ptr));</span>
<span class="line-added">1086         _cards_dirty++;</span>
<span class="line-added">1087       } else {</span>
<span class="line-added">1088         // We may have had dirty cards in the (initial) collection set (or the</span>
<span class="line-added">1089         // young regions which are always in the initial collection set). We do</span>
<span class="line-added">1090         // not fix their cards here: we already added these regions to the set of</span>
<span class="line-added">1091         // regions to clear the card table at the end during the prepare() phase.</span>
<span class="line-added">1092         _cards_skipped++;</span>
<span class="line-added">1093       }</span>
<span class="line-added">1094     }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096     size_t cards_dirty() const { return _cards_dirty; }</span>
<span class="line-added">1097     size_t cards_skipped() const { return _cards_skipped; }</span>
<span class="line-added">1098   };</span>
<span class="line-added">1099 </span>
<span class="line-added">1100   HeapRegionClaimer _hr_claimer;</span>
<span class="line-added">1101   G1RemSetScanState* _scan_state;</span>
<span class="line-added">1102   BufferNode::Stack _dirty_card_buffers;</span>
<span class="line-added">1103   bool _initial_evacuation;</span>
<span class="line-added">1104 </span>
<span class="line-added">1105   volatile bool _fast_reclaim_handled;</span>
<span class="line-added">1106 </span>
<span class="line-added">1107   void apply_closure_to_dirty_card_buffers(G1MergeLogBufferCardsClosure* cl, uint worker_id) {</span>
<span class="line-added">1108     G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-added">1109     size_t buffer_size = dcqs.buffer_size();</span>
<span class="line-added">1110     while (BufferNode* node = _dirty_card_buffers.pop()) {</span>
<span class="line-added">1111       cl-&gt;apply_to_buffer(node, buffer_size, worker_id);</span>
<span class="line-added">1112       dcqs.deallocate_buffer(node);</span>
<span class="line-added">1113     }</span>
<span class="line-added">1114   }</span>
1115 


1116 public:
<span class="line-modified">1117   G1MergeHeapRootsTask(G1RemSetScanState* scan_state, uint num_workers, bool initial_evacuation) :</span>
<span class="line-modified">1118     AbstractGangTask(&quot;G1 Merge Heap Roots&quot;),</span>
<span class="line-modified">1119     _hr_claimer(num_workers),</span>
<span class="line-modified">1120     _scan_state(scan_state),</span>
<span class="line-modified">1121     _dirty_card_buffers(),</span>
<span class="line-modified">1122     _initial_evacuation(initial_evacuation),</span>
<span class="line-modified">1123     _fast_reclaim_handled(false)</span>
<span class="line-modified">1124   {</span>
<span class="line-modified">1125     if (initial_evacuation) {</span>
<span class="line-modified">1126       G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();</span>
<span class="line-modified">1127       G1BufferNodeList buffers = dcqs.take_all_completed_buffers();</span>
<span class="line-modified">1128       if (buffers._entry_count != 0) {</span>
<span class="line-modified">1129         _dirty_card_buffers.prepend(*buffers._head, *buffers._tail);</span>
<span class="line-modified">1130       }</span>




1131     }

1132   }
1133 
<span class="line-modified">1134   virtual void work(uint worker_id) {</span>
<span class="line-modified">1135     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-modified">1136     G1GCPhaseTimes* p = g1h-&gt;phase_times();</span>
1137 
<span class="line-modified">1138     G1GCPhaseTimes::GCParPhases merge_remset_phase = _initial_evacuation ?</span>
<span class="line-modified">1139                                                      G1GCPhaseTimes::MergeRS :</span>
<span class="line-added">1140                                                      G1GCPhaseTimes::OptMergeRS;</span>
<span class="line-added">1141 </span>
<span class="line-added">1142     // We schedule flushing the remembered sets of humongous fast reclaim candidates</span>
<span class="line-added">1143     // onto the card table first to allow the remaining parallelized tasks hide it.</span>
<span class="line-added">1144     if (_initial_evacuation &amp;&amp;</span>
<span class="line-added">1145         p-&gt;fast_reclaim_humongous_candidates() &gt; 0 &amp;&amp;</span>
<span class="line-added">1146         !_fast_reclaim_handled &amp;&amp;</span>
<span class="line-added">1147         !Atomic::cmpxchg(&amp;_fast_reclaim_handled, false, true)) {</span>
1148 
<span class="line-modified">1149       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeER, worker_id);</span>
<span class="line-modified">1150 </span>
<span class="line-modified">1151       G1FlushHumongousCandidateRemSets cl(_scan_state);</span>
<span class="line-added">1152       g1h-&gt;heap_region_iterate(&amp;cl);</span>
<span class="line-added">1153 </span>
<span class="line-added">1154       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="line-added">1155       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="line-added">1156       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="line-added">1157       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="line-added">1158     }</span>
<span class="line-added">1159 </span>
<span class="line-added">1160     // Merge remembered sets of current candidates.</span>
<span class="line-added">1161     {</span>
<span class="line-added">1162       G1GCParPhaseTimesTracker x(p, merge_remset_phase, worker_id, _initial_evacuation /* must_record */);</span>
<span class="line-added">1163       G1MergeCardSetClosure cl(_scan_state);</span>
<span class="line-added">1164       g1h-&gt;collection_set_iterate_increment_from(&amp;cl, &amp;_hr_claimer, worker_id);</span>
<span class="line-added">1165 </span>
<span class="line-added">1166       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);</span>
<span class="line-added">1167       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);</span>
<span class="line-added">1168       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);</span>
<span class="line-added">1169       p-&gt;record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);</span>
<span class="line-added">1170     }</span>
1171 
<span class="line-modified">1172     // Apply closure to log entries in the HCC.</span>
<span class="line-modified">1173     if (_initial_evacuation &amp;&amp; G1HotCardCache::default_use_cache()) {</span>
<span class="line-modified">1174       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="line-added">1175       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeHCC, worker_id);</span>
<span class="line-added">1176       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="line-added">1177       g1h-&gt;iterate_hcc_closure(&amp;cl, worker_id);</span>
<span class="line-added">1178 </span>
<span class="line-added">1179       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeHCCDirtyCards);</span>
<span class="line-added">1180       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeHCC, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeHCCSkippedCards);</span>
<span class="line-added">1181     }</span>
<span class="line-added">1182 </span>
<span class="line-added">1183     // Now apply the closure to all remaining log entries.</span>
<span class="line-added">1184     if (_initial_evacuation) {</span>
<span class="line-added">1185       assert(merge_remset_phase == G1GCPhaseTimes::MergeRS, &quot;Wrong merge phase&quot;);</span>
<span class="line-added">1186       G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::MergeLB, worker_id);</span>
<span class="line-added">1187 </span>
<span class="line-added">1188       G1MergeLogBufferCardsClosure cl(g1h, _scan_state);</span>
<span class="line-added">1189       apply_closure_to_dirty_card_buffers(&amp;cl, worker_id);</span>
<span class="line-added">1190 </span>
<span class="line-added">1191       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeLBDirtyCards);</span>
<span class="line-added">1192       p-&gt;record_thread_work_item(G1GCPhaseTimes::MergeLB, worker_id, cl.cards_skipped(), G1GCPhaseTimes::MergeLBSkippedCards);</span>
<span class="line-added">1193     }</span>
1194   }
<span class="line-added">1195 };</span>
<span class="line-added">1196 </span>
<span class="line-added">1197 void G1RemSet::print_merge_heap_roots_stats() {</span>
<span class="line-added">1198   size_t num_visited_cards = _scan_state-&gt;num_visited_cards();</span>
<span class="line-added">1199 </span>
<span class="line-added">1200   size_t total_dirty_region_cards = _scan_state-&gt;num_cards_in_dirty_regions();</span>
<span class="line-added">1201 </span>
<span class="line-added">1202   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-added">1203   size_t total_old_region_cards =</span>
<span class="line-added">1204     (g1h-&gt;num_regions() - (g1h-&gt;num_free_regions() - g1h-&gt;collection_set()-&gt;cur_length())) * HeapRegion::CardsPerRegion;</span>
<span class="line-added">1205 </span>
<span class="line-added">1206   log_debug(gc,remset)(&quot;Visited cards &quot; SIZE_FORMAT &quot; Total dirty &quot; SIZE_FORMAT &quot; (%.2lf%%) Total old &quot; SIZE_FORMAT &quot; (%.2lf%%)&quot;,</span>
<span class="line-added">1207                        num_visited_cards,</span>
<span class="line-added">1208                        total_dirty_region_cards,</span>
<span class="line-added">1209                        percent_of(num_visited_cards, total_dirty_region_cards),</span>
<span class="line-added">1210                        total_old_region_cards,</span>
<span class="line-added">1211                        percent_of(num_visited_cards, total_old_region_cards));</span>
<span class="line-added">1212 }</span>
<span class="line-added">1213 </span>
<span class="line-added">1214 void G1RemSet::merge_heap_roots(bool initial_evacuation) {</span>
<span class="line-added">1215   G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
1216 

1217   {
<span class="line-modified">1218     Ticks start = Ticks::now();</span>
1219 
<span class="line-modified">1220     _scan_state-&gt;prepare_for_merge_heap_roots();</span>


1221 
<span class="line-modified">1222     Tickspan total = Ticks::now() - start;</span>
<span class="line-modified">1223     if (initial_evacuation) {</span>
<span class="line-added">1224       g1h-&gt;phase_times()-&gt;record_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="line-added">1225     } else {</span>
<span class="line-added">1226       g1h-&gt;phase_times()-&gt;record_or_add_optional_prepare_merge_heap_roots_time(total.seconds() * 1000.0);</span>
<span class="line-added">1227     }</span>
1228   }

1229 
<span class="line-modified">1230   WorkGang* workers = g1h-&gt;workers();</span>
<span class="line-modified">1231   size_t const increment_length = g1h-&gt;collection_set()-&gt;increment_length();</span>


1232 
<span class="line-modified">1233   uint const num_workers = initial_evacuation ? workers-&gt;active_workers() :</span>
<span class="line-modified">1234                                                 MIN2(workers-&gt;active_workers(), (uint)increment_length);</span>
<span class="line-modified">1235 </span>
<span class="line-added">1236   {</span>
<span class="line-added">1237     G1MergeHeapRootsTask cl(_scan_state, num_workers, initial_evacuation);</span>
<span class="line-added">1238     log_debug(gc, ergo)(&quot;Running %s using %u workers for &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-added">1239                         cl.name(), num_workers, increment_length);</span>
<span class="line-added">1240     workers-&gt;run_task(&amp;cl, num_workers);</span>
<span class="line-added">1241   }</span>
<span class="line-added">1242 </span>
<span class="line-added">1243   if (log_is_enabled(Debug, gc, remset)) {</span>
<span class="line-added">1244     print_merge_heap_roots_stats();</span>
<span class="line-added">1245   }</span>
<span class="line-added">1246 }</span>
1247 
<span class="line-modified">1248 void G1RemSet::exclude_region_from_scan(uint region_idx) {</span>
<span class="line-added">1249   _scan_state-&gt;clear_scan_top(region_idx);</span>
1250 }
1251 
<span class="line-modified">1252 void G1RemSet::cleanup_after_scan_heap_roots() {</span>
1253   G1GCPhaseTimes* phase_times = _g1h-&gt;phase_times();
1254 
1255   // Set all cards back to clean.
1256   double start = os::elapsedTime();
<span class="line-modified">1257   _scan_state-&gt;cleanup(_g1h-&gt;workers());</span>
1258   phase_times-&gt;record_clear_ct_time((os::elapsedTime() - start) * 1000.0);
1259 }
1260 
1261 inline void check_card_ptr(CardTable::CardValue* card_ptr, G1CardTable* ct) {
1262 #ifdef ASSERT
1263   G1CollectedHeap* g1h = G1CollectedHeap::heap();
1264   assert(g1h-&gt;is_in_exact(ct-&gt;addr_for(card_ptr)),
1265          &quot;Card at &quot; PTR_FORMAT &quot; index &quot; SIZE_FORMAT &quot; representing heap at &quot; PTR_FORMAT &quot; (%u) must be in committed heap&quot;,
1266          p2i(card_ptr),
1267          ct-&gt;index_for(ct-&gt;addr_for(card_ptr)),
1268          p2i(ct-&gt;addr_for(card_ptr)),
1269          g1h-&gt;addr_to_region(ct-&gt;addr_for(card_ptr)));
1270 #endif
1271 }
1272 
<span class="line-modified">1273 bool G1RemSet::clean_card_before_refine(CardValue** const card_ptr_addr) {</span>

1274   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);
1275 
<span class="line-modified">1276   CardValue* card_ptr = *card_ptr_addr;</span>
<span class="line-added">1277   // Find the start address represented by the card.</span>
1278   HeapWord* start = _ct-&gt;addr_for(card_ptr);
1279   // And find the region containing it.
1280   HeapRegion* r = _g1h-&gt;heap_region_containing_or_null(start);
1281 
1282   // If this is a (stale) card into an uncommitted region, exit.
1283   if (r == NULL) {
<span class="line-modified">1284     return false;</span>
1285   }
1286 
1287   check_card_ptr(card_ptr, _ct);
1288 
1289   // If the card is no longer dirty, nothing to do.
<span class="line-added">1290   // We cannot load the card value before the &quot;r == NULL&quot; check, because G1</span>
<span class="line-added">1291   // could uncommit parts of the card table covering uncommitted regions.</span>
1292   if (*card_ptr != G1CardTable::dirty_card_val()) {
<span class="line-modified">1293     return false;</span>
1294   }
1295 
1296   // This check is needed for some uncommon cases where we should
1297   // ignore the card.
1298   //
1299   // The region could be young.  Cards for young regions are
1300   // distinctly marked (set to g1_young_gen), so the post-barrier will
1301   // filter them out.  However, that marking is performed
1302   // concurrently.  A write to a young object could occur before the
1303   // card has been marked young, slipping past the filter.
1304   //
1305   // The card could be stale, because the region has been freed since
1306   // the card was recorded. In this case the region type could be
1307   // anything.  If (still) free or (reallocated) young, just ignore
1308   // it.  If (reallocated) old or humongous, the later card trimming
1309   // and additional checks in iteration may detect staleness.  At
1310   // worst, we end up processing a stale card unnecessarily.
1311   //
1312   // In the normal (non-stale) case, the synchronization between the
1313   // enqueueing of the card and processing it here will have ensured
1314   // we see the up-to-date region type here.
1315   if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="line-modified">1316     return false;</span>
1317   }
1318 
1319   // The result from the hot card cache insert call is either:
1320   //   * pointer to the current card
1321   //     (implying that the current card is not &#39;hot&#39;),
1322   //   * null
1323   //     (meaning we had inserted the card ptr into the &quot;hot&quot; card cache,
1324   //     which had some headroom),
1325   //   * a pointer to a &quot;hot&quot; card that was evicted from the &quot;hot&quot; cache.
1326   //
1327 
1328   if (_hot_card_cache-&gt;use_cache()) {
1329     assert(!SafepointSynchronize::is_at_safepoint(), &quot;sanity&quot;);
1330 
1331     const CardValue* orig_card_ptr = card_ptr;
1332     card_ptr = _hot_card_cache-&gt;insert(card_ptr);
1333     if (card_ptr == NULL) {
1334       // There was no eviction. Nothing to do.
<span class="line-modified">1335       return false;</span>
1336     } else if (card_ptr != orig_card_ptr) {
1337       // Original card was inserted and an old card was evicted.
1338       start = _ct-&gt;addr_for(card_ptr);
1339       r = _g1h-&gt;heap_region_containing(start);
1340 
1341       // Check whether the region formerly in the cache should be
1342       // ignored, as discussed earlier for the original card.  The
1343       // region could have been freed while in the cache.
1344       if (!r-&gt;is_old_or_humongous_or_archive()) {
<span class="line-modified">1345         return false;</span>
1346       }
<span class="line-added">1347       *card_ptr_addr = card_ptr;</span>
1348     } // Else we still have the original card.
1349   }
1350 
1351   // Trim the region designated by the card to what&#39;s been allocated
1352   // in the region.  The card could be stale, or the card could cover
1353   // (part of) an object at the end of the allocated space and extend
1354   // beyond the end of allocation.
1355 
<span class="line-modified">1356   // Non-humongous objects are either allocated in the old regions during GC,</span>
<span class="line-modified">1357   // or mapped in archive regions during startup. So if region is old or</span>
<span class="line-modified">1358   // archive then top is stable.</span>
<span class="line-modified">1359   // Humongous object allocation sets top last; if top has not yet been set,</span>
<span class="line-modified">1360   // this is a stale card and we&#39;ll end up with an empty intersection.</span>
<span class="line-added">1361   // If this is not a stale card, the synchronization between the</span>
1362   // enqueuing of the card and processing it here will have ensured
1363   // we see the up-to-date top here.
1364   HeapWord* scan_limit = r-&gt;top();
1365 
1366   if (scan_limit &lt;= start) {
1367     // If the trimmed region is empty, the card must be stale.
<span class="line-modified">1368     return false;</span>
1369   }
1370 
1371   // Okay to clean and process the card now.  There are still some
1372   // stale card cases that may be detected by iteration and dealt with
1373   // as iteration failure.
1374   *const_cast&lt;volatile CardValue*&gt;(card_ptr) = G1CardTable::clean_card_val();
1375 
<span class="line-modified">1376   return true;</span>
<span class="line-modified">1377 }</span>
<span class="line-modified">1378 </span>
<span class="line-modified">1379 void G1RemSet::refine_card_concurrently(CardValue* const card_ptr,</span>
<span class="line-modified">1380                                         const uint worker_id) {</span>
<span class="line-modified">1381   assert(!_g1h-&gt;is_gc_active(), &quot;Only call concurrently&quot;);</span>
<span class="line-modified">1382   check_card_ptr(card_ptr, _ct);</span>
<span class="line-added">1383 </span>
<span class="line-added">1384   // Construct the MemRegion representing the card.</span>
<span class="line-added">1385   HeapWord* start = _ct-&gt;addr_for(card_ptr);</span>
<span class="line-added">1386   // And find the region containing it.</span>
<span class="line-added">1387   HeapRegion* r = _g1h-&gt;heap_region_containing(start);</span>
<span class="line-added">1388   // This reload of the top is safe even though it happens after the full</span>
<span class="line-added">1389   // fence, because top is stable for old, archive and unfiltered humongous</span>
<span class="line-added">1390   // regions, so it must return the same value as the previous load when</span>
<span class="line-added">1391   // cleaning the card. Also cleaning the card and refinement of the card</span>
<span class="line-added">1392   // cannot span across safepoint, so we don&#39;t need to worry about top being</span>
<span class="line-added">1393   // changed during safepoint.</span>
<span class="line-added">1394   HeapWord* scan_limit = r-&gt;top();</span>
<span class="line-added">1395   assert(scan_limit &gt; start, &quot;sanity&quot;);</span>
1396 
1397   // Don&#39;t use addr_for(card_ptr + 1) which can ask for
1398   // a card beyond the heap.
1399   HeapWord* end = start + G1CardTable::card_size_in_words;
1400   MemRegion dirty_region(start, MIN2(scan_limit, end));
1401   assert(!dirty_region.is_empty(), &quot;sanity&quot;);
1402 
<span class="line-modified">1403   G1ConcurrentRefineOopClosure conc_refine_cl(_g1h, worker_id);</span>
<span class="line-modified">1404   if (r-&gt;oops_on_memregion_seq_iterate_careful&lt;false&gt;(dirty_region, &amp;conc_refine_cl) != NULL) {</span>
<span class="line-modified">1405     return;</span>













































1406   }
1407 
<span class="line-modified">1408   // If unable to process the card then we encountered an unparsable</span>
<span class="line-modified">1409   // part of the heap (e.g. a partially allocated object, so only</span>
<span class="line-modified">1410   // temporarily a problem) while processing a stale card.  Despite</span>
<span class="line-modified">1411   // the card being stale, we can&#39;t simply ignore it, because we&#39;ve</span>
<span class="line-modified">1412   // already marked the card cleaned, so taken responsibility for</span>
<span class="line-modified">1413   // ensuring the card gets scanned.</span>
<span class="line-modified">1414   //</span>
<span class="line-modified">1415   // However, the card might have gotten re-dirtied and re-enqueued</span>
<span class="line-added">1416   // while we worked.  (In fact, it&#39;s pretty likely.)</span>
<span class="line-added">1417   if (*card_ptr == G1CardTable::dirty_card_val()) {</span>
<span class="line-added">1418     return;</span>
1419   }
1420 
<span class="line-modified">1421   // Re-dirty the card and enqueue in the *shared* queue.  Can&#39;t use</span>
<span class="line-modified">1422   // the thread-local queue, because that might be the queue that is</span>
<span class="line-modified">1423   // being processed by us; we could be a Java thread conscripted to</span>
<span class="line-modified">1424   // perform refinement on our queue&#39;s current buffer.</span>
<span class="line-modified">1425   *card_ptr = G1CardTable::dirty_card_val();</span>
<span class="line-modified">1426   G1BarrierSet::shared_dirty_card_queue().enqueue(card_ptr);</span>





1427 }
1428 
1429 void G1RemSet::print_periodic_summary_info(const char* header, uint period_count) {
1430   if ((G1SummarizeRSetStatsPeriod &gt; 0) &amp;&amp; log_is_enabled(Trace, gc, remset) &amp;&amp;
1431       (period_count % G1SummarizeRSetStatsPeriod == 0)) {
1432 
<span class="line-modified">1433     G1RemSetSummary current;</span>
1434     _prev_period_summary.subtract_from(&amp;current);
1435 
1436     Log(gc, remset) log;
1437     log.trace(&quot;%s&quot;, header);
1438     ResourceMark rm;
1439     LogStream ls(log.trace());
1440     _prev_period_summary.print_on(&amp;ls);
1441 
1442     _prev_period_summary.set(&amp;current);
1443   }
1444 }
1445 
1446 void G1RemSet::print_summary_info() {
1447   Log(gc, remset, exit) log;
1448   if (log.is_trace()) {
1449     log.trace(&quot; Cumulative RS summary&quot;);
<span class="line-modified">1450     G1RemSetSummary current;</span>
1451     ResourceMark rm;
1452     LogStream ls(log.trace());
1453     current.print_on(&amp;ls);
1454   }
1455 }
1456 
1457 class G1RebuildRemSetTask: public AbstractGangTask {
1458   // Aggregate the counting data that was constructed concurrently
1459   // with marking.
1460   class G1RebuildRemSetHeapRegionClosure : public HeapRegionClosure {
1461     G1ConcurrentMark* _cm;
1462     G1RebuildRemSetClosure _update_cl;
1463 
1464     // Applies _update_cl to the references of the given object, limiting objArrays
1465     // to the given MemRegion. Returns the amount of words actually scanned.
1466     size_t scan_for_references(oop const obj, MemRegion mr) {
1467       size_t const obj_size = obj-&gt;size();
1468       // All non-objArrays and objArrays completely within the mr
1469       // can be scanned without passing the mr.
<span class="line-modified">1470       if (!obj-&gt;is_objArray() || mr.contains(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size))) {</span>
1471         obj-&gt;oop_iterate(&amp;_update_cl);
1472         return obj_size;
1473       }
1474       // This path is for objArrays crossing the given MemRegion. Only scan the
1475       // area within the MemRegion.
1476       obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="line-modified">1477       return mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), obj_size)).word_size();</span>
1478     }
1479 
1480     // A humongous object is live (with respect to the scanning) either
1481     // a) it is marked on the bitmap as such
1482     // b) its TARS is larger than TAMS, i.e. has been allocated during marking.
1483     bool is_humongous_live(oop const humongous_obj, const G1CMBitMap* const bitmap, HeapWord* tams, HeapWord* tars) const {
1484       return bitmap-&gt;is_marked(humongous_obj) || (tars &gt; tams);
1485     }
1486 
1487     // Iterator over the live objects within the given MemRegion.
1488     class LiveObjIterator : public StackObj {
1489       const G1CMBitMap* const _bitmap;
1490       const HeapWord* _tams;
1491       const MemRegion _mr;
1492       HeapWord* _current;
1493 
1494       bool is_below_tams() const {
1495         return _current &lt; _tams;
1496       }
1497 
</pre>
<hr />
<pre>
1562     // Returns the number of live words between bottom and TAMS.
1563     size_t rebuild_rem_set_in_region(const G1CMBitMap* const bitmap,
1564                                      HeapWord* const top_at_mark_start,
1565                                      HeapWord* const top_at_rebuild_start,
1566                                      HeapRegion* hr,
1567                                      MemRegion mr) {
1568       size_t marked_words = 0;
1569 
1570       if (hr-&gt;is_humongous()) {
1571         oop const humongous_obj = oop(hr-&gt;humongous_start_region()-&gt;bottom());
1572         if (is_humongous_live(humongous_obj, bitmap, top_at_mark_start, top_at_rebuild_start)) {
1573           // We need to scan both [bottom, TAMS) and [TAMS, top_at_rebuild_start);
1574           // however in case of humongous objects it is sufficient to scan the encompassing
1575           // area (top_at_rebuild_start is always larger or equal to TAMS) as one of the
1576           // two areas will be zero sized. I.e. TAMS is either
1577           // the same as bottom or top(_at_rebuild_start). There is no way TAMS has a different
1578           // value: this would mean that TAMS points somewhere into the object.
1579           assert(hr-&gt;top() == top_at_mark_start || hr-&gt;top() == top_at_rebuild_start,
1580                  &quot;More than one object in the humongous region?&quot;);
1581           humongous_obj-&gt;oop_iterate(&amp;_update_cl, mr);
<span class="line-modified">1582           return top_at_mark_start != hr-&gt;bottom() ? mr.intersection(MemRegion(cast_from_oop&lt;HeapWord*&gt;(humongous_obj), humongous_obj-&gt;size())).byte_size() : 0;</span>
1583         } else {
1584           return 0;
1585         }
1586       }
1587 
1588       for (LiveObjIterator it(bitmap, top_at_mark_start, mr, hr-&gt;block_start(mr.start())); it.has_next(); it.move_to_next()) {
1589         oop obj = it.next();
1590         size_t scanned_size = scan_for_references(obj, mr);
<span class="line-modified">1591         if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; top_at_mark_start) {</span>
1592           marked_words += scanned_size;
1593         }
1594       }
1595 
1596       return marked_words * HeapWordSize;
1597     }
1598 public:
1599   G1RebuildRemSetHeapRegionClosure(G1CollectedHeap* g1h,
1600                                    G1ConcurrentMark* cm,
1601                                    uint worker_id) :
1602     HeapRegionClosure(),
1603     _cm(cm),
1604     _update_cl(g1h, worker_id) { }
1605 
1606     bool do_heap_region(HeapRegion* hr) {
1607       if (_cm-&gt;has_aborted()) {
1608         return true;
1609       }
1610 
1611       uint const region_idx = hr-&gt;hrm_index();
</pre>
</td>
</tr>
</table>
<center><a href="g1RegionToSpaceMapper.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1RemSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1YoungGenSizer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1VMOperations.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1YoungGenSizer.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1YoungGenSizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -21,47 +21,48 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/g1/g1CollectorPolicy.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/g1Arguments.hpp&quot;</span>
  #include &quot;gc/g1/g1HeterogeneousHeapYoungGenSizer.hpp&quot;
  #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  #include &quot;gc/g1/heapRegion.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/globals_extension.hpp&quot;</span>
  
  G1YoungGenSizer::G1YoungGenSizer() : _sizer_kind(SizerDefaults),
<span class="udiff-line-modified-removed">-   _adaptive_size(true), _min_desired_young_length(0), _max_desired_young_length(0) {</span>
<span class="udiff-line-modified-added">+   _use_adaptive_sizing(true), _min_desired_young_length(0), _max_desired_young_length(0) {</span>
  
    if (FLAG_IS_CMDLINE(NewRatio)) {
      if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {
        log_warning(gc, ergo)(&quot;-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio&quot;);
      } else {
        _sizer_kind = SizerNewRatio;
<span class="udiff-line-modified-removed">-       _adaptive_size = false;</span>
<span class="udiff-line-modified-added">+       _use_adaptive_sizing = false;</span>
        return;
      }
    }
  
    if (NewSize &gt; MaxNewSize) {
      if (FLAG_IS_CMDLINE(MaxNewSize)) {
        log_warning(gc, ergo)(&quot;NewSize (&quot; SIZE_FORMAT &quot;k) is greater than the MaxNewSize (&quot; SIZE_FORMAT &quot;k). &quot;
                              &quot;A new max generation size of &quot; SIZE_FORMAT &quot;k will be used.&quot;,
                              NewSize/K, MaxNewSize/K, NewSize/K);
      }
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(size_t, MaxNewSize, NewSize);</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(MaxNewSize, NewSize);</span>
    }
  
    if (FLAG_IS_CMDLINE(NewSize)) {
      _min_desired_young_length = MAX2((uint) (NewSize / HeapRegion::GrainBytes),
                                       1U);
      if (FLAG_IS_CMDLINE(MaxNewSize)) {
        _max_desired_young_length =
                               MAX2((uint) (MaxNewSize / HeapRegion::GrainBytes),
                                    1U);
        _sizer_kind = SizerMaxAndNewSize;
<span class="udiff-line-modified-removed">-       _adaptive_size = _min_desired_young_length != _max_desired_young_length;</span>
<span class="udiff-line-modified-added">+       _use_adaptive_sizing = _min_desired_young_length != _max_desired_young_length;</span>
      } else {
        _sizer_kind = SizerNewSizeOnly;
      }
    } else if (FLAG_IS_CMDLINE(MaxNewSize)) {
      _max_desired_young_length =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -119,21 +120,21 @@</span>
    uint result = _max_desired_young_length;
    recalculate_min_max_young_length(number_of_heap_regions, &amp;temp, &amp;result);
  
    size_t max_young_size = result * HeapRegion::GrainBytes;
    if (max_young_size != MaxNewSize) {
<span class="udiff-line-modified-removed">-     FLAG_SET_ERGO(size_t, MaxNewSize, max_young_size);</span>
<span class="udiff-line-modified-added">+     FLAG_SET_ERGO(MaxNewSize, max_young_size);</span>
    }
  }
  
  void G1YoungGenSizer::heap_size_changed(uint new_number_of_heap_regions) {
    recalculate_min_max_young_length(new_number_of_heap_regions, &amp;_min_desired_young_length,
            &amp;_max_desired_young_length);
  }
  
<span class="udiff-line-modified-removed">- G1YoungGenSizer* G1YoungGenSizer::create_gen_sizer(G1CollectorPolicy* policy) {</span>
<span class="udiff-line-modified-removed">-   if (policy-&gt;is_heterogeneous_heap()) {</span>
<span class="udiff-line-modified-added">+ G1YoungGenSizer* G1YoungGenSizer::create_gen_sizer() {</span>
<span class="udiff-line-modified-added">+   if (G1Arguments::is_heterogeneous_heap()) {</span>
      return new G1HeterogeneousHeapYoungGenSizer();
    } else {
      return new G1YoungGenSizer();
    }
  }
</pre>
<center><a href="g1VMOperations.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1YoungGenSizer.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
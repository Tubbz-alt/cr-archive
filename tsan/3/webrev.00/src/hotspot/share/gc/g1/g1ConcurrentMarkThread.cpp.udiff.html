<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMarkObjArrayProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentMarkThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,14 +29,14 @@</span>
  #include &quot;gc/g1/g1ConcurrentMark.inline.hpp&quot;
  #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  #include &quot;gc/g1/g1MMUTracker.hpp&quot;
  #include &quot;gc/g1/g1Policy.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1Trace.hpp&quot;</span>
  #include &quot;gc/g1/g1VMOperations.hpp&quot;
  #include &quot;gc/shared/concurrentGCPhaseManager.hpp&quot;
  #include &quot;gc/shared/gcId.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/gcTrace.hpp&quot;</span>
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,11 +105,11 @@</span>
    void do_void(){
      _cm-&gt;cleanup();
    }
  };
  
<span class="udiff-line-modified-removed">- double G1ConcurrentMarkThread::mmu_sleep_time(G1Policy* g1_policy, bool remark) {</span>
<span class="udiff-line-modified-added">+ double G1ConcurrentMarkThread::mmu_delay_end(G1Policy* g1_policy, bool remark) {</span>
    // There are 3 reasons to use SuspendibleThreadSetJoiner.
    // 1. To avoid concurrency problem.
    //    - G1MMUTracker::add_pause(), when_sec() and its variation(when_ms() etc..) can be called
    //      concurrently from ConcurrentMarkThread and VMThread.
    // 2. If currently a gc is running, but it has not yet updated the MMU,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117,22 +117,34 @@</span>
    // 3. If currently a gc is running, ConcurrentMarkThread will wait it to be finished.
    //    And then sleep for predicted amount of time by delay_to_keep_mmu().
    SuspendibleThreadSetJoiner sts_join;
  
    const G1Analytics* analytics = g1_policy-&gt;analytics();
<span class="udiff-line-removed">-   double now = os::elapsedTime();</span>
    double prediction_ms = remark ? analytics-&gt;predict_remark_time_ms()
                                  : analytics-&gt;predict_cleanup_time_ms();
<span class="udiff-line-added">+   double prediction = prediction_ms / MILLIUNITS;</span>
    G1MMUTracker *mmu_tracker = g1_policy-&gt;mmu_tracker();
<span class="udiff-line-modified-removed">-   return mmu_tracker-&gt;when_ms(now, prediction_ms);</span>
<span class="udiff-line-modified-added">+   double now = os::elapsedTime();</span>
<span class="udiff-line-added">+   return now + mmu_tracker-&gt;when_sec(now, prediction);</span>
  }
  
  void G1ConcurrentMarkThread::delay_to_keep_mmu(G1Policy* g1_policy, bool remark) {
<span class="udiff-line-modified-removed">-   if (g1_policy-&gt;adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-removed">-     jlong sleep_time_ms = mmu_sleep_time(g1_policy, remark);</span>
<span class="udiff-line-modified-removed">-     if (!_cm-&gt;has_aborted() &amp;&amp; sleep_time_ms &gt; 0) {</span>
<span class="udiff-line-modified-removed">-       os::sleep(this, sleep_time_ms, false);</span>
<span class="udiff-line-modified-added">+   if (g1_policy-&gt;use_adaptive_young_list_length()) {</span>
<span class="udiff-line-modified-added">+     double delay_end_sec = mmu_delay_end(g1_policy, remark);</span>
<span class="udiff-line-modified-added">+     // Wait for timeout or thread termination request.</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(CGC_lock, Monitor::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+     while (!_cm-&gt;has_aborted()) {</span>
<span class="udiff-line-added">+       double sleep_time_sec = (delay_end_sec - os::elapsedTime());</span>
<span class="udiff-line-added">+       jlong sleep_time_ms = ceil(sleep_time_sec * MILLIUNITS);</span>
<span class="udiff-line-added">+       if (sleep_time_ms &lt;= 0) {</span>
<span class="udiff-line-added">+         break;                  // Passed end time.</span>
<span class="udiff-line-added">+       } else if (ml.wait(sleep_time_ms, Monitor::_no_safepoint_check_flag)) {</span>
<span class="udiff-line-added">+         break;                  // Timeout =&gt; reached end time.</span>
<span class="udiff-line-added">+       } else if (should_terminate()) {</span>
<span class="udiff-line-added">+         break;                  // Wakeup for pending termination request.</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       // Other (possibly spurious) wakeup.  Retry with updated sleep time.</span>
      }
    }
  }
  
  class G1ConcPhaseTimer : public GCTraceConcTimeImpl&lt;LogLevel::Info, LOG_TAGS(gc, marking)&gt; {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,11 +391,11 @@</span>
          _cm-&gt;cleanup_for_next_mark();
        }
      }
  
      // Update the number of full collections that have been
<span class="udiff-line-modified-removed">-     // completed. This will also notify the FullGCCount_lock in case a</span>
<span class="udiff-line-modified-added">+     // completed. This will also notify the G1OldGCCount_lock in case a</span>
      // Java thread is waiting for a full GC to happen (e.g., it
      // called System.gc() with +ExplicitGCInvokesConcurrent).
      {
        SuspendibleThreadSetJoiner sts_join;
        g1h-&gt;increment_old_marking_cycles_completed(true /* concurrent */);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -395,23 +407,23 @@</span>
    }
    _cm-&gt;root_regions()-&gt;cancel_scan();
  }
  
  void G1ConcurrentMarkThread::stop_service() {
<span class="udiff-line-modified-removed">-   MutexLockerEx ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
    CGC_lock-&gt;notify_all();
  }
  
  
  void G1ConcurrentMarkThread::sleep_before_next_cycle() {
    // We join here because we don&#39;t want to do the &quot;shouldConcurrentMark()&quot;
    // below while the world is otherwise stopped.
    assert(!in_progress(), &quot;should have been cleared&quot;);
  
<span class="udiff-line-modified-removed">-   MutexLockerEx x(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(CGC_lock, Mutex::_no_safepoint_check_flag);</span>
    while (!started() &amp;&amp; !should_terminate()) {
<span class="udiff-line-modified-removed">-     CGC_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     ml.wait();</span>
    }
  
    if (started()) {
      set_in_progress();
    }
</pre>
<center><a href="g1ConcurrentMarkObjArrayProcessor.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ConcurrentMarkThread.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
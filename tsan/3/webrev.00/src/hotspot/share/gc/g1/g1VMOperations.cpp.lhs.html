<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1VMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
 28 #include &quot;gc/g1/g1Policy.hpp&quot;
 29 #include &quot;gc/g1/g1VMOperations.hpp&quot;
 30 #include &quot;gc/shared/gcId.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 33 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
<a name="2" id="anc2"></a>
 34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 35 
 36 void VM_G1CollectFull::doit() {
 37   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 38   GCCauseSetter x(g1h, _gc_cause);
 39   _gc_succeeded = g1h-&gt;do_full_collection(true /* explicit_gc */, false /* clear_all_soft_refs */);
 40 }
 41 
<a name="3" id="anc3"></a>




















































 42 VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,
 43                                                      uint           gc_count_before,
 44                                                      GCCause::Cause gc_cause,
<a name="4" id="anc4"></a><span class="line-removed"> 45                                                      bool           should_initiate_conc_mark,</span>
 46                                                      double         target_pause_time_ms) :
 47   VM_CollectForAllocation(word_size, gc_count_before, gc_cause),
 48   _gc_succeeded(false),
<a name="5" id="anc5"></a><span class="line-modified"> 49   _should_initiate_conc_mark(should_initiate_conc_mark),</span>
<span class="line-removed"> 50   _should_retry_gc(false),</span>
<span class="line-removed"> 51   _target_pause_time_ms(target_pause_time_ms),</span>
<span class="line-removed"> 52   _old_marking_cycles_completed_before(0) {</span>
 53 
 54   guarantee(target_pause_time_ms &gt; 0.0,
 55             &quot;target_pause_time_ms = %1.6lf should be positive&quot;,
 56             target_pause_time_ms);
 57   _gc_cause = gc_cause;
 58 }
 59 
<a name="6" id="anc6"></a><span class="line-removed"> 60 bool VM_G1CollectForAllocation::doit_prologue() {</span>
<span class="line-removed"> 61   bool res = VM_CollectForAllocation::doit_prologue();</span>
<span class="line-removed"> 62   if (!res) {</span>
<span class="line-removed"> 63     if (_should_initiate_conc_mark) {</span>
<span class="line-removed"> 64       // The prologue can fail for a couple of reasons. The first is that another GC</span>
<span class="line-removed"> 65       // got scheduled and prevented the scheduling of the initial mark GC. The</span>
<span class="line-removed"> 66       // second is that the GC locker may be active and the heap can&#39;t be expanded.</span>
<span class="line-removed"> 67       // In both cases we want to retry the GC so that the initial mark pause is</span>
<span class="line-removed"> 68       // actually scheduled. In the second case, however, we should stall until</span>
<span class="line-removed"> 69       // until the GC locker is no longer active and then retry the initial mark GC.</span>
<span class="line-removed"> 70       _should_retry_gc = true;</span>
<span class="line-removed"> 71     }</span>
<span class="line-removed"> 72   }</span>
<span class="line-removed"> 73   return res;</span>
<span class="line-removed"> 74 }</span>
<span class="line-removed"> 75 </span>
 76 void VM_G1CollectForAllocation::doit() {
 77   G1CollectedHeap* g1h = G1CollectedHeap::heap();
<a name="7" id="anc7"></a><span class="line-removed"> 78   assert(!_should_initiate_conc_mark || g1h-&gt;should_do_concurrent_full_gc(_gc_cause),</span>
<span class="line-removed"> 79       &quot;only a GC locker, a System.gc(), stats update, whitebox, or a hum allocation induced GC should start a cycle&quot;);</span>
 80 
 81   if (_word_size &gt; 0) {
 82     // An allocation has been requested. So, try to do that first.
 83     _result = g1h-&gt;attempt_allocation_at_safepoint(_word_size,
 84                                                    false /* expect_null_cur_alloc_region */);
 85     if (_result != NULL) {
 86       // If we can successfully allocate before we actually do the
 87       // pause then we will consider this pause successful.
 88       _gc_succeeded = true;
 89       return;
 90     }
 91   }
 92 
 93   GCCauseSetter x(g1h, _gc_cause);
<a name="8" id="anc8"></a><span class="line-removed"> 94   if (_should_initiate_conc_mark) {</span>
<span class="line-removed"> 95     // It&#39;s safer to read old_marking_cycles_completed() here, given</span>
<span class="line-removed"> 96     // that noone else will be updating it concurrently. Since we&#39;ll</span>
<span class="line-removed"> 97     // only need it if we&#39;re initiating a marking cycle, no point in</span>
<span class="line-removed"> 98     // setting it earlier.</span>
<span class="line-removed"> 99     _old_marking_cycles_completed_before = g1h-&gt;old_marking_cycles_completed();</span>
<span class="line-removed">100 </span>
<span class="line-removed">101     // At this point we are supposed to start a concurrent cycle. We</span>
<span class="line-removed">102     // will do so if one is not already in progress.</span>
<span class="line-removed">103     bool res = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);</span>
<span class="line-removed">104 </span>
<span class="line-removed">105     // The above routine returns true if we were able to force the</span>
<span class="line-removed">106     // next GC pause to be an initial mark; it returns false if a</span>
<span class="line-removed">107     // marking cycle is already in progress.</span>
<span class="line-removed">108     //</span>
<span class="line-removed">109     // If a marking cycle is already in progress just return and skip the</span>
<span class="line-removed">110     // pause below - if the reason for requesting this initial mark pause</span>
<span class="line-removed">111     // was due to a System.gc() then the requesting thread should block in</span>
<span class="line-removed">112     // doit_epilogue() until the marking cycle is complete.</span>
<span class="line-removed">113     //</span>
<span class="line-removed">114     // If this initial mark pause was requested as part of a humongous</span>
<span class="line-removed">115     // allocation then we know that the marking cycle must just have</span>
<span class="line-removed">116     // been started by another thread (possibly also allocating a humongous</span>
<span class="line-removed">117     // object) as there was no active marking cycle when the requesting</span>
<span class="line-removed">118     // thread checked before calling collect() in</span>
<span class="line-removed">119     // attempt_allocation_humongous(). Retrying the GC, in this case,</span>
<span class="line-removed">120     // will cause the requesting thread to spin inside collect() until the</span>
<span class="line-removed">121     // just started marking cycle is complete - which may be a while. So</span>
<span class="line-removed">122     // we do NOT retry the GC.</span>
<span class="line-removed">123     if (!res) {</span>
<span class="line-removed">124       assert(_word_size == 0, &quot;Concurrent Full GC/Humongous Object IM shouldn&#39;t be allocating&quot;);</span>
<span class="line-removed">125       if (_gc_cause != GCCause::_g1_humongous_allocation) {</span>
<span class="line-removed">126         _should_retry_gc = true;</span>
<span class="line-removed">127       }</span>
<span class="line-removed">128       return;</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131 </span>
132   // Try a partial collection of some kind.
133   _gc_succeeded = g1h-&gt;do_collection_pause_at_safepoint(_target_pause_time_ms);
134 
<a name="9" id="anc9"></a><span class="line-modified">135   if (_gc_succeeded) {</span>
<span class="line-modified">136     if (_word_size &gt; 0) {</span>
<span class="line-modified">137       // An allocation had been requested. Do it, eventually trying a stronger</span>
<span class="line-modified">138       // kind of GC.</span>
<span class="line-removed">139       _result = g1h-&gt;satisfy_failed_allocation(_word_size, &amp;_gc_succeeded);</span>
<span class="line-removed">140     } else {</span>
<span class="line-removed">141       bool should_upgrade_to_full = g1h-&gt;should_upgrade_to_full_gc(_gc_cause);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143       if (should_upgrade_to_full) {</span>
<span class="line-removed">144         // There has been a request to perform a GC to free some space. We have no</span>
<span class="line-removed">145         // information on how much memory has been asked for. In case there are</span>
<span class="line-removed">146         // absolutely no regions left to allocate into, do a maximally compacting full GC.</span>
<span class="line-removed">147         log_info(gc, ergo)(&quot;Attempting maximally compacting collection&quot;);</span>
<span class="line-removed">148         _gc_succeeded = g1h-&gt;do_full_collection(false, /* explicit gc */</span>
<span class="line-removed">149                                                    true   /* clear_all_soft_refs */);</span>
<span class="line-removed">150       }</span>
<span class="line-removed">151     }</span>
<span class="line-removed">152     guarantee(_gc_succeeded, &quot;Elevated collections during the safepoint must always succeed.&quot;);</span>
<span class="line-removed">153   } else {</span>
<span class="line-removed">154     assert(_result == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">155     // The only reason for the pause to not be successful is that, the GC locker is</span>
<span class="line-removed">156     // active (or has become active since the prologue was executed). In this case</span>
<span class="line-removed">157     // we should retry the pause after waiting for the GC locker to become inactive.</span>
<span class="line-removed">158     _should_retry_gc = true;</span>
<span class="line-removed">159   }</span>
<span class="line-removed">160 }</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 void VM_G1CollectForAllocation::doit_epilogue() {</span>
<span class="line-removed">163   VM_CollectForAllocation::doit_epilogue();</span>
<span class="line-removed">164 </span>
<span class="line-removed">165   // If the pause was initiated by a System.gc() and</span>
<span class="line-removed">166   // +ExplicitGCInvokesConcurrent, we have to wait here for the cycle</span>
<span class="line-removed">167   // that just started (or maybe one that was already in progress) to</span>
<span class="line-removed">168   // finish.</span>
<span class="line-removed">169   if (GCCause::is_user_requested_gc(_gc_cause) &amp;&amp;</span>
<span class="line-removed">170       _should_initiate_conc_mark) {</span>
<span class="line-removed">171     assert(ExplicitGCInvokesConcurrent,</span>
<span class="line-removed">172            &quot;the only way to be here is if ExplicitGCInvokesConcurrent is set&quot;);</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     G1CollectedHeap* g1h = G1CollectedHeap::heap();</span>
<span class="line-removed">175 </span>
<span class="line-removed">176     // In the doit() method we saved g1h-&gt;old_marking_cycles_completed()</span>
<span class="line-removed">177     // in the _old_marking_cycles_completed_before field. We have to</span>
<span class="line-removed">178     // wait until we observe that g1h-&gt;old_marking_cycles_completed()</span>
<span class="line-removed">179     // has increased by at least one. This can happen if a) we started</span>
<span class="line-removed">180     // a cycle and it completes, b) a cycle already in progress</span>
<span class="line-removed">181     // completes, or c) a Full GC happens.</span>
<span class="line-removed">182 </span>
<span class="line-removed">183     // If the condition has already been reached, there&#39;s no point in</span>
<span class="line-removed">184     // actually taking the lock and doing the wait.</span>
<span class="line-removed">185     if (g1h-&gt;old_marking_cycles_completed() &lt;=</span>
<span class="line-removed">186                                           _old_marking_cycles_completed_before) {</span>
<span class="line-removed">187       // The following is largely copied from CMS</span>
<span class="line-removed">188 </span>
<span class="line-removed">189       Thread* thr = Thread::current();</span>
<span class="line-removed">190       assert(thr-&gt;is_Java_thread(), &quot;invariant&quot;);</span>
<span class="line-removed">191       JavaThread* jt = (JavaThread*)thr;</span>
<span class="line-removed">192       ThreadToNativeFromVM native(jt);</span>
<span class="line-removed">193 </span>
<span class="line-removed">194       MutexLockerEx x(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">195       while (g1h-&gt;old_marking_cycles_completed() &lt;=</span>
<span class="line-removed">196                                           _old_marking_cycles_completed_before) {</span>
<span class="line-removed">197         FullGCCount_lock-&gt;wait(Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">198       }</span>
<span class="line-removed">199     }</span>
200   }
201 }
202 
203 void VM_G1Concurrent::doit() {
204   GCIdMark gc_id_mark(_gc_id);
205   GCTraceCPUTime tcpu;
206   G1CollectedHeap* g1h = G1CollectedHeap::heap();
207   GCTraceTime(Info, gc) t(_message, g1h-&gt;concurrent_mark()-&gt;gc_timer_cm(), GCCause::_no_gc, true);
208   TraceCollectorStats tcs(g1h-&gt;g1mm()-&gt;conc_collection_counters());
209   SvcGCMarker sgcm(SvcGCMarker::CONCURRENT);
210   IsGCActiveMark x;
211   _cl-&gt;do_void();
212 }
213 
214 bool VM_G1Concurrent::doit_prologue() {
215   Heap_lock-&gt;lock();
216   return true;
217 }
218 
219 void VM_G1Concurrent::doit_epilogue() {
220   if (Universe::has_reference_pending_list()) {
221     Heap_lock-&gt;notify_all();
222   }
223   Heap_lock-&gt;unlock();
224 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
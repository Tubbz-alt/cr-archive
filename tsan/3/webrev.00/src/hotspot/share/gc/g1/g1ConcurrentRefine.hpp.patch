diff a/src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp b/src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp
--- a/src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp
+++ b/src/hotspot/share/gc/g1/g1ConcurrentRefine.hpp
@@ -25,10 +25,11 @@
 #ifndef SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 #define SHARE_GC_G1_G1CONCURRENTREFINE_HPP
 
 #include "memory/allocation.hpp"
 #include "utilities/globalDefinitions.hpp"
+#include "utilities/ticks.hpp"
 
 // Forward decl
 class G1ConcurrentRefine;
 class G1ConcurrentRefineThread;
 class outputStream;
@@ -58,32 +59,33 @@
   void print_on(outputStream* st) const;
   void worker_threads_do(ThreadClosure* tc);
   void stop();
 };
 
-// Controls refinement threads and their activation based on the number of completed
-// buffers currently available in the global dirty card queue.
-// Refinement threads pick work from the queue based on these thresholds. They are activated
-// gradually based on the amount of work to do.
+// Controls refinement threads and their activation based on the number of
+// cards currently available in the global dirty card queue.
+// Refinement threads obtain work from the queue (a buffer at a time) based
+// on these thresholds. They are activated gradually based on the amount of
+// work to do.
 // Refinement thread n activates thread n+1 if the instance of this class determines there
 // is enough work available. Threads deactivate themselves if the current amount of
-// completed buffers falls below their individual threshold.
+// available cards falls below their individual threshold.
 class G1ConcurrentRefine : public CHeapObj<mtGC> {
   G1ConcurrentRefineThreadControl _thread_control;
   /*
    * The value of the completed dirty card queue length falls into one of 3 zones:
    * green, yellow, red. If the value is in [0, green) nothing is
-   * done, the buffers are left unprocessed to enable the caching effect of the
+   * done, the buffered cards are left unprocessed to enable the caching effect of the
    * dirtied cards. In the yellow zone [green, yellow) the concurrent refinement
    * threads are gradually activated. In [yellow, red) all threads are
    * running. If the length becomes red (max queue length) the mutators start
-   * processing the buffers.
+   * processing cards too.
    *
    * There are some interesting cases (when G1UseAdaptiveConcRefinement
    * is turned off):
    * 1) green = yellow = red = 0. In this case the mutator will process all
-   *    buffers. Except for those that are created by the deferred updates
+   *    cards. Except for those that are created by the deferred updates
    *    machinery during a collection.
    * 2) green = 0. Means no caching. Can be a good way to minimize the
    *    amount of time spent updating remembered sets during a collection.
    */
   size_t _green_zone;
@@ -95,16 +97,16 @@
                      size_t yellow_zone,
                      size_t red_zone,
                      size_t min_yellow_zone_size);
 
   // Update green/yellow/red zone values based on how well goals are being met.
-  void update_zones(double update_rs_time,
-                    size_t update_rs_processed_buffers,
+  void update_zones(double logged_cards_scan_time,
+                    size_t processed_logged_cards,
                     double goal_ms);
 
   static uint worker_id_offset();
-  void maybe_activate_more_threads(uint worker_id, size_t num_cur_buffers);
+  void maybe_activate_more_threads(uint worker_id, size_t num_cur_cards);
 
   jint initialize();
 public:
   ~G1ConcurrentRefine();
 
@@ -113,25 +115,38 @@
   static G1ConcurrentRefine* create(jint* ecode);
 
   void stop();
 
   // Adjust refinement thresholds based on work done during the pause and the goal time.
-  void adjust(double update_rs_time, size_t update_rs_processed_buffers, double goal_ms);
+  void adjust(double logged_cards_scan_time, size_t processed_logged_cards, double goal_ms);
 
+  struct RefinementStats {
+    Tickspan _time;
+    size_t _cards;
+    RefinementStats(Tickspan time, size_t cards) : _time(time), _cards(cards) {}
+  };
+
+  RefinementStats total_refinement_stats() const;
+
+  // Cards in the dirty card queue set.
   size_t activation_threshold(uint worker_id) const;
   size_t deactivation_threshold(uint worker_id) const;
-  // Perform a single refinement step. Called by the refinement threads when woken up.
-  bool do_refinement_step(uint worker_id);
+
+  // Perform a single refinement step; called by the refinement
+  // threads.  Returns true if there was refinement work available.
+  // Increments *total_refined_cards.
+  bool do_refinement_step(uint worker_id, size_t* total_refined_cards);
 
   // Iterate over all concurrent refinement threads applying the given closure.
   void threads_do(ThreadClosure *tc);
 
   // Maximum number of refinement threads.
   static uint max_num_threads();
 
   void print_threads_on(outputStream* st) const;
 
+  // Cards in the dirty card queue set.
   size_t green_zone() const      { return _green_zone;  }
   size_t yellow_zone() const     { return _yellow_zone; }
   size_t red_zone() const        { return _red_zone;    }
 };
 

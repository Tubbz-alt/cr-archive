<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1HeterogeneousCollectorPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1HeterogeneousCollectorPolicy.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;runtime/globals_extension.hpp&quot;
 29 #include &quot;runtime/os.hpp&quot;
 30 #include &quot;utilities/formatBuffer.hpp&quot;
 31 
 32 const double G1HeterogeneousCollectorPolicy::MaxRamFractionForYoung = 0.8;
 33 size_t G1HeterogeneousCollectorPolicy::MaxMemoryForYoung;
 34 
 35 static size_t calculate_reasonable_max_memory_for_young(FormatBuffer&lt;100&gt; &amp;calc_str, double max_ram_fraction_for_young) {
 36   julong phys_mem;
 37   // If MaxRam is specified, we use that as maximum physical memory available.
 38   if (FLAG_IS_DEFAULT(MaxRAM)) {
 39     phys_mem = os::physical_memory();
 40     calc_str.append(&quot;Physical_Memory&quot;);
 41   } else {
 42     phys_mem = (julong)MaxRAM;
 43     calc_str.append(&quot;MaxRAM&quot;);
 44   }
 45 
 46   julong reasonable_max = phys_mem;
 47 
 48   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate
 49   // reasonable max size of young generation.
 50   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {
 51     reasonable_max = (julong)(phys_mem / MaxRAMFraction);
 52     calc_str.append(&quot; / MaxRAMFraction&quot;);
 53   }  else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {
 54     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
 55     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);
 56   }  else {
 57     // We use our own fraction to calculate max size of young generation.
 58     reasonable_max = phys_mem * max_ram_fraction_for_young;
 59     calc_str.append(&quot; * %0.2f&quot;, max_ram_fraction_for_young);
 60   }
 61 
 62   return (size_t)reasonable_max;
 63 }
 64 
 65 void G1HeterogeneousCollectorPolicy::initialize_flags() {
 66 
 67   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);
 68 
 69   MaxMemoryForYoung = calculate_reasonable_max_memory_for_young(calc_str, MaxRamFractionForYoung);
 70 
 71   if (MaxNewSize &gt; MaxMemoryForYoung) {
 72     if (FLAG_IS_CMDLINE(MaxNewSize)) {
 73       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,
 74                             MaxMemoryForYoung, calc_str.buffer());
 75     } else {
 76       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;
 77                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, MaxMemoryForYoung, calc_str.buffer());
 78     }
 79     MaxNewSize = MaxMemoryForYoung;
 80   }
 81   if (NewSize &gt; MaxMemoryForYoung) {
 82     if (FLAG_IS_CMDLINE(NewSize)) {
 83       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,
 84                             MaxMemoryForYoung, calc_str.buffer());
 85     }
 86     NewSize = MaxMemoryForYoung;
 87   }
 88 
 89   // After setting new size flags, call base class initialize_flags()
 90   G1CollectorPolicy::initialize_flags();
 91 }
 92 
 93 size_t G1HeterogeneousCollectorPolicy::reasonable_max_memory_for_young() {
 94   return MaxMemoryForYoung;
 95 }
 96 
 97 size_t G1HeterogeneousCollectorPolicy::heap_reserved_size_bytes() const {
 98     return 2 * _max_heap_byte_size;
 99 }
100 
101 bool G1HeterogeneousCollectorPolicy::is_heterogeneous_heap() const {
102   return true;
103 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1IHOPControl.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 27 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
 28 #include &quot;gc/g1/g1Predictions.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;gc/g1/g1Trace.hpp&quot;</span>
 30 #include &quot;logging/log.hpp&quot;
 31 
 32 G1IHOPControl::G1IHOPControl(double initial_ihop_percent) :
 33   _initial_ihop_percent(initial_ihop_percent),
 34   _target_occupancy(0),
 35   _last_allocation_time_s(0.0),
 36   _last_allocated_bytes(0)
 37 {
 38   assert(_initial_ihop_percent &gt;= 0.0 &amp;&amp; _initial_ihop_percent &lt;= 100.0, &quot;Initial IHOP value must be between 0 and 100 but is %.3f&quot;, initial_ihop_percent);
 39 }
 40 
 41 void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {
 42   log_debug(gc, ihop)(&quot;Target occupancy update: old: &quot; SIZE_FORMAT &quot;B, new: &quot; SIZE_FORMAT &quot;B&quot;,
 43                       _target_occupancy, new_target_occupancy);
 44   _target_occupancy = new_target_occupancy;
 45 }
 46 
 47 void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size) {
 48   assert(allocation_time_s &gt;= 0.0, &quot;Allocation time must be positive but is %.3f&quot;, allocation_time_s);
 49 
 50   _last_allocation_time_s = allocation_time_s;
 51   _last_allocated_bytes = allocated_bytes;
 52 }
 53 
 54 void G1IHOPControl::print() {
 55   assert(_target_occupancy &gt; 0, &quot;Target occupancy still not updated yet.&quot;);
 56   size_t cur_conc_mark_start_threshold = get_conc_mark_start_threshold();
 57   log_debug(gc, ihop)(&quot;Basic information (value update), threshold: &quot; SIZE_FORMAT &quot;B (%1.2f), target occupancy: &quot; SIZE_FORMAT &quot;B, current occupancy: &quot; SIZE_FORMAT &quot;B, &quot;
 58                       &quot;recent allocation size: &quot; SIZE_FORMAT &quot;B, recent allocation duration: %1.2fms, recent old gen allocation rate: %1.2fB/s, recent marking phase length: %1.2fms&quot;,
 59                       cur_conc_mark_start_threshold,
 60                       percent_of(cur_conc_mark_start_threshold, _target_occupancy),
 61                       _target_occupancy,
 62                       G1CollectedHeap::heap()-&gt;used(),
 63                       _last_allocated_bytes,
 64                       _last_allocation_time_s * 1000.0,
 65                       _last_allocation_time_s &gt; 0.0 ? _last_allocated_bytes / _last_allocation_time_s : 0.0,
 66                       last_marking_length_s() * 1000.0);
 67 }
 68 
 69 void G1IHOPControl::send_trace_event(G1NewTracer* tracer) {
 70   assert(_target_occupancy &gt; 0, &quot;Target occupancy still not updated yet.&quot;);
 71   tracer-&gt;report_basic_ihop_statistics(get_conc_mark_start_threshold(),
 72                                        _target_occupancy,
 73                                        G1CollectedHeap::heap()-&gt;used(),
 74                                        _last_allocated_bytes,
 75                                        _last_allocation_time_s,
 76                                        last_marking_length_s());
 77 }
 78 
 79 G1StaticIHOPControl::G1StaticIHOPControl(double ihop_percent) :
 80   G1IHOPControl(ihop_percent),
 81   _last_marking_length_s(0.0) {
 82 }
 83 
 84 G1AdaptiveIHOPControl::G1AdaptiveIHOPControl(double ihop_percent,
 85                                              G1Predictions const* predictor,
 86                                              size_t heap_reserve_percent,
 87                                              size_t heap_waste_percent) :
 88   G1IHOPControl(ihop_percent),
 89   _heap_reserve_percent(heap_reserve_percent),
 90   _heap_waste_percent(heap_waste_percent),
 91   _predictor(predictor),
 92   _marking_times_s(10, 0.95),
 93   _allocation_rate_s(10, 0.95),
 94   _last_unrestrained_young_size(0)
 95 {
 96 }
 97 
 98 size_t G1AdaptiveIHOPControl::actual_target_threshold() const {
 99   guarantee(_target_occupancy &gt; 0, &quot;Target occupancy still not updated yet.&quot;);
100   // The actual target threshold takes the heap reserve and the expected waste in
101   // free space  into account.
102   // _heap_reserve is that part of the total heap capacity that is reserved for
103   // eventual promotion failure.
104   // _heap_waste is the amount of space will never be reclaimed in any
105   // heap, so can not be used for allocation during marking and must always be
106   // considered.
107 
108   double safe_total_heap_percentage = MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);
109 
110   return (size_t)MIN2(
111     G1CollectedHeap::heap()-&gt;max_capacity() * (100.0 - safe_total_heap_percentage) / 100.0,
112     _target_occupancy * (100.0 - _heap_waste_percent) / 100.0
113     );
114 }
115 
<a name="3" id="anc3"></a><span class="line-added">116 double G1AdaptiveIHOPControl::predict(TruncatedSeq const* seq) const {</span>
<span class="line-added">117   return _predictor-&gt;predict_zero_bounded(seq);</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
120 bool G1AdaptiveIHOPControl::have_enough_data_for_prediction() const {
121   return ((size_t)_marking_times_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples) &amp;&amp;
122          ((size_t)_allocation_rate_s.num() &gt;= G1AdaptiveIHOPNumInitialSamples);
123 }
124 
125 size_t G1AdaptiveIHOPControl::get_conc_mark_start_threshold() {
126   if (have_enough_data_for_prediction()) {
<a name="4" id="anc4"></a><span class="line-modified">127     double pred_marking_time = predict(&amp;_marking_times_s);</span>
<span class="line-modified">128     double pred_promotion_rate = predict(&amp;_allocation_rate_s);</span>
129     size_t pred_promotion_size = (size_t)(pred_marking_time * pred_promotion_rate);
130 
131     size_t predicted_needed_bytes_during_marking =
132       pred_promotion_size +
133       // In reality we would need the maximum size of the young gen during
134       // marking. This is a conservative estimate.
135       _last_unrestrained_young_size;
136 
137     size_t internal_threshold = actual_target_threshold();
138     size_t predicted_initiating_threshold = predicted_needed_bytes_during_marking &lt; internal_threshold ?
139                                             internal_threshold - predicted_needed_bytes_during_marking :
140                                             0;
141     return predicted_initiating_threshold;
142   } else {
143     // Use the initial value.
144     return (size_t)(_initial_ihop_percent * _target_occupancy / 100.0);
145   }
146 }
147 
148 void G1AdaptiveIHOPControl::update_allocation_info(double allocation_time_s,
149                                                    size_t allocated_bytes,
150                                                    size_t additional_buffer_size) {
151   G1IHOPControl::update_allocation_info(allocation_time_s, allocated_bytes, additional_buffer_size);
152 
153   double allocation_rate = (double) allocated_bytes / allocation_time_s;
154   _allocation_rate_s.add(allocation_rate);
155 
156   _last_unrestrained_young_size = additional_buffer_size;
157 }
158 
159 void G1AdaptiveIHOPControl::update_marking_length(double marking_length_s) {
160    assert(marking_length_s &gt;= 0.0, &quot;Marking length must be larger than zero but is %.3f&quot;, marking_length_s);
161   _marking_times_s.add(marking_length_s);
162 }
163 
164 void G1AdaptiveIHOPControl::print() {
165   G1IHOPControl::print();
166   size_t actual_target = actual_target_threshold();
167   log_debug(gc, ihop)(&quot;Adaptive IHOP information (value update), threshold: &quot; SIZE_FORMAT &quot;B (%1.2f), internal target occupancy: &quot; SIZE_FORMAT &quot;B, &quot;
168                       &quot;occupancy: &quot; SIZE_FORMAT &quot;B, additional buffer size: &quot; SIZE_FORMAT &quot;B, predicted old gen allocation rate: %1.2fB/s, &quot;
169                       &quot;predicted marking phase length: %1.2fms, prediction active: %s&quot;,
170                       get_conc_mark_start_threshold(),
171                       percent_of(get_conc_mark_start_threshold(), actual_target),
172                       actual_target,
173                       G1CollectedHeap::heap()-&gt;used(),
174                       _last_unrestrained_young_size,
<a name="5" id="anc5"></a><span class="line-modified">175                       predict(&amp;_allocation_rate_s),</span>
<span class="line-modified">176                       predict(&amp;_marking_times_s) * 1000.0,</span>
177                       have_enough_data_for_prediction() ? &quot;true&quot; : &quot;false&quot;);
178 }
179 
180 void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer) {
181   G1IHOPControl::send_trace_event(tracer);
182   tracer-&gt;report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),
183                                           actual_target_threshold(),
184                                           G1CollectedHeap::heap()-&gt;used(),
185                                           _last_unrestrained_young_size,
<a name="6" id="anc6"></a><span class="line-modified">186                                           predict(&amp;_allocation_rate_s),</span>
<span class="line-modified">187                                           predict(&amp;_marking_times_s),</span>
188                                           have_enough_data_for_prediction());
189 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
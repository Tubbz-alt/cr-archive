<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/c2/g1BarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../epsilon/epsilon_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../g1AllocRegion.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/c2/g1BarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,15 ***</span>
   * the object is newly allocated and that no safepoint exists between the
   * allocation and the store.
   *
   * In the case of slow allocation the allocation code must handle the barrier
   * as part of the allocation in the case the allocated object is not located
<span class="line-modified">!  * in the nursery, this would happen for humongous objects. This is similar to</span>
<span class="line-removed">-  * how CMS is required to handle this case, see the comments for the method</span>
<span class="line-removed">-  * CollectedHeap::new_deferred_store_barrier and OptoRuntime::new_deferred_store_barrier.</span>
<span class="line-removed">-  * A deferred card mark is required for these objects and handled in the above</span>
<span class="line-removed">-  * mentioned methods.</span>
   *
   * Returns true if the post barrier can be removed
   */
  bool G1BarrierSetC2::g1_can_remove_post_barrier(GraphKit* kit,
                                                  PhaseTransform* phase, Node* store,
<span class="line-new-header">--- 296,11 ---</span>
   * the object is newly allocated and that no safepoint exists between the
   * allocation and the store.
   *
   * In the case of slow allocation the allocation code must handle the barrier
   * as part of the allocation in the case the allocated object is not located
<span class="line-modified">!  * in the nursery; this would happen for humongous objects.</span>
   *
   * Returns true if the post barrier can be removed
   */
  bool G1BarrierSetC2::g1_can_remove_post_barrier(GraphKit* kit,
                                                  PhaseTransform* phase, Node* store,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,11 ***</span>
    IdealKit ideal(kit, true);
  
    Node* tls = __ thread(); // ThreadLocalStorage
  
    Node* no_base = __ top();
<span class="line-modified">!   float unlikely  = PROB_UNLIKELY(0.999);</span>
    Node* young_card = __ ConI((jint)G1CardTable::g1_young_card_val());
    Node* dirty_card = __ ConI((jint)G1CardTable::dirty_card_val());
    Node* zeroX = __ ConX(0);
  
    const TypeFunc *tf = write_ref_field_post_entry_Type();
<span class="line-new-header">--- 411,12 ---</span>
    IdealKit ideal(kit, true);
  
    Node* tls = __ thread(); // ThreadLocalStorage
  
    Node* no_base = __ top();
<span class="line-modified">!   float likely = PROB_LIKELY_MAG(3);</span>
<span class="line-added">+   float unlikely = PROB_UNLIKELY_MAG(3);</span>
    Node* young_card = __ ConI((jint)G1CardTable::g1_young_card_val());
    Node* dirty_card = __ ConI((jint)G1CardTable::dirty_card_val());
    Node* zeroX = __ ConX(0);
  
    const TypeFunc *tf = write_ref_field_post_entry_Type();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,21 ***</span>
      // and extra shift. Do we have an unsigned compare??
      // Node* region_size = __ ConI(1 &lt;&lt; HeapRegion::LogOfHRGrainBytes);
      Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(HeapRegion::LogOfHRGrainBytes));
  
      // if (xor_res == 0) same region so skip
<span class="line-modified">!     __ if_then(xor_res, BoolTest::ne, zeroX); {</span>
  
        // No barrier if we are storing a NULL
<span class="line-modified">!       __ if_then(val, BoolTest::ne, kit-&gt;null(), unlikely); {</span>
  
          // Ok must mark the card if not already dirty
  
          // load the original value of the card
          Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
  
<span class="line-modified">!         __ if_then(card_val, BoolTest::ne, young_card); {</span>
            kit-&gt;sync_kit(ideal);
            kit-&gt;insert_mem_bar(Op_MemBarVolatile, oop_store);
            __ sync_kit(kit);
  
            Node* card_val_reload = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
<span class="line-new-header">--- 455,21 ---</span>
      // and extra shift. Do we have an unsigned compare??
      // Node* region_size = __ ConI(1 &lt;&lt; HeapRegion::LogOfHRGrainBytes);
      Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(HeapRegion::LogOfHRGrainBytes));
  
      // if (xor_res == 0) same region so skip
<span class="line-modified">!     __ if_then(xor_res, BoolTest::ne, zeroX, likely); {</span>
  
        // No barrier if we are storing a NULL
<span class="line-modified">!       __ if_then(val, BoolTest::ne, kit-&gt;null(), likely); {</span>
  
          // Ok must mark the card if not already dirty
  
          // load the original value of the card
          Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
  
<span class="line-modified">!         __ if_then(card_val, BoolTest::ne, young_card, unlikely); {</span>
            kit-&gt;sync_kit(ideal);
            kit-&gt;insert_mem_bar(Op_MemBarVolatile, oop_store);
            __ sync_kit(kit);
  
            Node* card_val_reload = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,16 ***</span>
  Node* G1BarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
    DecoratorSet decorators = access.decorators();
    Node* adr = access.addr().node();
    Node* obj = access.base();
  
    bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
    bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
    bool in_heap = (decorators &amp; IN_HEAP) != 0;
    bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
    bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;
<span class="line-modified">!   bool need_cpu_mem_bar = !is_unordered || mismatched || !in_heap;</span>
  
    Node* top = Compile::current()-&gt;top();
    Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;
    Node* load = CardTableBarrierSetC2::load_at_resolved(access, val_type);
  
<span class="line-new-header">--- 595,19 ---</span>
  Node* G1BarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
    DecoratorSet decorators = access.decorators();
    Node* adr = access.addr().node();
    Node* obj = access.base();
  
<span class="line-added">+   bool anonymous = (decorators &amp; C2_UNSAFE_ACCESS) != 0;</span>
    bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
    bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
    bool in_heap = (decorators &amp; IN_HEAP) != 0;
<span class="line-added">+   bool in_native = (decorators &amp; IN_NATIVE) != 0;</span>
    bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
    bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;
<span class="line-modified">!   bool is_mixed = !in_heap &amp;&amp; !in_native;</span>
<span class="line-added">+   bool need_cpu_mem_bar = !is_unordered || mismatched || is_mixed;</span>
  
    Node* top = Compile::current()-&gt;top();
    Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;
    Node* load = CardTableBarrierSetC2::load_at_resolved(access, val_type);
  
</pre>
<center><a href="../../epsilon/epsilon_globals.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../g1AllocRegion.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
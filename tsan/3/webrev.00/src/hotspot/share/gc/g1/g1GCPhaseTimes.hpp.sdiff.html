<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1GCPhaseTimes.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1GCPhaseTimes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapRegionEventSender.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1GCPhaseTimes.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 
 39 template &lt;class T&gt; class WorkerDataArray;
 40 
 41 class G1GCPhaseTimes : public CHeapObj&lt;mtGC&gt; {
 42   uint _max_gc_threads;
 43   jlong _gc_start_counter;
 44   double _gc_pause_time_ms;
 45 
 46  public:
 47   enum GCParPhases {
 48     GCWorkerStart,
 49     ExtRootScan,
 50     ThreadRoots,
 51     UniverseRoots,
 52     JNIRoots,
 53     ObjectSynchronizerRoots,
 54     ManagementRoots,
 55     SystemDictionaryRoots,
 56     CLDGRoots,
 57     JVMTIRoots,
<span class="line-modified"> 58 #if INCLUDE_AOT</span>
<span class="line-removed"> 59     AOTCodeRoots,</span>
<span class="line-removed"> 60 #endif</span>
 61     CMRefRoots,
<span class="line-modified"> 62     WaitForStrongCLD,</span>
<span class="line-modified"> 63     WeakCLDRoots,</span>
<span class="line-modified"> 64     SATBFiltering,</span>
<span class="line-modified"> 65     UpdateRS,</span>
<span class="line-modified"> 66     ScanHCC,</span>
<span class="line-modified"> 67     ScanRS,</span>
<span class="line-modified"> 68     OptScanRS,</span>
 69     CodeRoots,

 70     ObjCopy,
 71     OptObjCopy,
 72     Termination,

 73     Other,
 74     GCWorkerTotal,
 75     GCWorkerEnd,
 76     StringDedupQueueFixup,
 77     StringDedupTableFixup,
 78     RedirtyCards,

 79     YoungFreeCSet,
 80     NonYoungFreeCSet,


 81     GCParPhasesSentinel
 82   };
 83 
<span class="line-modified"> 84   static const GCParPhases ExtRootScanSubPhasesStart = ThreadRoots;</span>
<span class="line-modified"> 85   static const GCParPhases ExtRootScanSubPhasesEnd = SATBFiltering;</span>
 86 
<span class="line-modified"> 87   enum GCScanRSWorkItems {</span>
<span class="line-modified"> 88     ScanRSScannedCards,</span>
<span class="line-modified"> 89     ScanRSClaimedCards,</span>
<span class="line-modified"> 90     ScanRSSkippedCards</span>

 91   };
 92 
<span class="line-modified"> 93   enum GCUpdateRSWorkItems {</span>
<span class="line-modified"> 94     UpdateRSProcessedBuffers,</span>
<span class="line-modified"> 95     UpdateRSScannedCards,</span>
<span class="line-modified"> 96     UpdateRSSkippedCards</span>


 97   };
 98 
<span class="line-modified"> 99   enum GCObjCopyWorkItems {</span>
<span class="line-modified">100     ObjCopyLABWaste,</span>
<span class="line-modified">101     ObjCopyLABUndoWaste</span>
102   };
103 
<span class="line-modified">104   enum GCOptCSetWorkItems {</span>
<span class="line-modified">105       OptCSetScannedCards,</span>
<span class="line-modified">106       OptCSetClaimedCards,</span>
<span class="line-modified">107       OptCSetSkippedCards,</span>
<span class="line-modified">108       OptCSetUsedMemory</span>




109   };
110 
111  private:
112   // Markers for grouping the phases in the GCPhases enum above
113   static const int GCMainParPhasesLast = GCWorkerEnd;
114 
115   WorkerDataArray&lt;double&gt;* _gc_par_phases[GCParPhasesSentinel];
116 
<span class="line-modified">117   WorkerDataArray&lt;size_t&gt;* _update_rs_processed_buffers;</span>
<span class="line-modified">118   WorkerDataArray&lt;size_t&gt;* _update_rs_scanned_cards;</span>
<span class="line-removed">119   WorkerDataArray&lt;size_t&gt;* _update_rs_skipped_cards;</span>
<span class="line-removed">120 </span>
<span class="line-removed">121   WorkerDataArray&lt;size_t&gt;* _scan_rs_scanned_cards;</span>
<span class="line-removed">122   WorkerDataArray&lt;size_t&gt;* _scan_rs_claimed_cards;</span>
<span class="line-removed">123   WorkerDataArray&lt;size_t&gt;* _scan_rs_skipped_cards;</span>
<span class="line-removed">124 </span>
<span class="line-removed">125   WorkerDataArray&lt;size_t&gt;* _obj_copy_lab_waste;</span>
<span class="line-removed">126   WorkerDataArray&lt;size_t&gt;* _obj_copy_lab_undo_waste;</span>
<span class="line-removed">127 </span>
<span class="line-removed">128   WorkerDataArray&lt;size_t&gt;* _opt_cset_scanned_cards;</span>
<span class="line-removed">129   WorkerDataArray&lt;size_t&gt;* _opt_cset_claimed_cards;</span>
<span class="line-removed">130   WorkerDataArray&lt;size_t&gt;* _opt_cset_skipped_cards;</span>
<span class="line-removed">131   WorkerDataArray&lt;size_t&gt;* _opt_cset_used_memory;</span>
<span class="line-removed">132 </span>
<span class="line-removed">133   WorkerDataArray&lt;size_t&gt;* _termination_attempts;</span>
<span class="line-removed">134 </span>
<span class="line-removed">135   WorkerDataArray&lt;size_t&gt;* _redirtied_cards;</span>
<span class="line-removed">136 </span>
<span class="line-removed">137   double _cur_collection_par_time_ms;</span>
<span class="line-removed">138   double _cur_optional_evac_ms;</span>
139   double _cur_collection_code_root_fixup_time_ms;
140   double _cur_strong_code_root_purge_time_ms;
141 
142   double _cur_evac_fail_recalc_used;
143   double _cur_evac_fail_remove_self_forwards;
144 
145   double _cur_string_deduplication_time_ms;
146 






147   double _cur_prepare_tlab_time_ms;
148   double _cur_resize_tlab_time_ms;
149 
150   double _cur_derived_pointer_table_update_time_ms;
151 
152   double _cur_clear_ct_time_ms;
153   double _cur_expand_heap_time_ms;
154   double _cur_ref_proc_time_ms;
155 
156   double _cur_collection_start_sec;
157   double _root_region_scan_wait_time_ms;
158 
159   double _external_accounted_time_ms;
160 


161   double _recorded_clear_claimed_marks_time_ms;
162 
163   double _recorded_young_cset_choice_time_ms;
164   double _recorded_non_young_cset_choice_time_ms;
165 
166   double _recorded_redirty_logged_cards_time_ms;
167 
168   double _recorded_preserve_cm_referents_time_ms;
169 
170   double _recorded_merge_pss_time_ms;
171 
172   double _recorded_start_new_cset_time_ms;
173 
174   double _recorded_total_free_cset_time_ms;
175 
176   double _recorded_serial_free_cset_time_ms;
177 






178   double _cur_fast_reclaim_humongous_time_ms;
<span class="line-removed">179   double _cur_fast_reclaim_humongous_register_time_ms;</span>
180   size_t _cur_fast_reclaim_humongous_total;
181   size_t _cur_fast_reclaim_humongous_candidates;
182   size_t _cur_fast_reclaim_humongous_reclaimed;
183 
184   double _cur_verify_before_time_ms;
185   double _cur_verify_after_time_ms;
186 
187   ReferenceProcessorPhaseTimes _ref_phase_times;
188   WeakProcessorPhaseTimes _weak_phase_times;
189 
190   double worker_time(GCParPhases phase, uint worker);
191   void note_gc_end();
192   void reset();
193 
194   template &lt;class T&gt;
<span class="line-modified">195   void details(T* phase, const char* indent) const;</span>
196 
<span class="line-modified">197   void log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent, outputStream* out, bool print_sum) const;</span>


198   void debug_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent = 0) const;
<span class="line-modified">199   void trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum = true) const;</span>
200 
201   void info_time(const char* name, double value) const;
202   void debug_time(const char* name, double value) const;
203   // This will print logs for both &#39;gc+phases&#39; and &#39;gc+phases+ref&#39;.
204   void debug_time_for_reference(const char* name, double value) const;
205   void trace_time(const char* name, double value) const;
206   void trace_count(const char* name, size_t value) const;
207 
208   double print_pre_evacuate_collection_set() const;
<span class="line-modified">209   double print_evacuate_collection_set() const;</span>

210   double print_evacuate_optional_collection_set() const;
211   double print_post_evacuate_collection_set() const;
212   void print_other(double accounted_ms) const;
213 
214  public:
215   G1GCPhaseTimes(STWGCTimer* gc_timer, uint max_gc_threads);
216   void note_gc_start();
217   void print();
218   static const char* phase_name(GCParPhases phase);
219 
220   // record the time a phase took in seconds
<span class="line-modified">221   void record_time_secs(GCParPhases phase, uint worker_i, double secs);</span>
222 
223   // add a number of seconds to a phase
<span class="line-modified">224   void add_time_secs(GCParPhases phase, uint worker_i, double secs);</span>


225 
<span class="line-modified">226   void record_or_add_time_secs(GCParPhases phase, uint worker_i, double secs);</span>
227 
<span class="line-modified">228   void record_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index = 0);</span>
229 
<span class="line-modified">230   void record_or_add_thread_work_item(GCParPhases phase, uint worker_i, size_t count, uint index = 0);</span>


231 
232   // return the average time for a phase in milliseconds
233   double average_time_ms(GCParPhases phase);
234 
235   size_t sum_thread_work_items(GCParPhases phase, uint index = 0);
236 
<span class="line-removed">237  public:</span>
<span class="line-removed">238 </span>
239   void record_prepare_tlab_time_ms(double ms) {
240     _cur_prepare_tlab_time_ms = ms;
241   }
242 
243   void record_resize_tlab_time_ms(double ms) {
244     _cur_resize_tlab_time_ms = ms;
245   }
246 
247   void record_derived_pointer_table_update_time(double ms) {
248     _cur_derived_pointer_table_update_time_ms = ms;
249   }
250 
251   void record_clear_ct_time(double ms) {
252     _cur_clear_ct_time_ms = ms;
253   }
254 
255   void record_expand_heap_time(double ms) {
256     _cur_expand_heap_time_ms = ms;
257   }
258 
<span class="line-modified">259   void record_par_time(double ms) {</span>
<span class="line-modified">260     _cur_collection_par_time_ms = ms;</span>
261   }
262 
<span class="line-modified">263   void record_optional_evacuation(double ms) {</span>
<span class="line-modified">264     _cur_optional_evac_ms = ms;</span>
265   }
266 
<span class="line-modified">267   void record_code_root_fixup_time(double ms) {</span>
<span class="line-modified">268     _cur_collection_code_root_fixup_time_ms = ms;</span>
269   }
270 
271   void record_strong_code_root_purge_time(double ms) {
272     _cur_strong_code_root_purge_time_ms = ms;
273   }
274 
















275   void record_evac_fail_recalc_used_time(double ms) {
276     _cur_evac_fail_recalc_used = ms;
277   }
278 
279   void record_evac_fail_remove_self_forwards(double ms) {
280     _cur_evac_fail_remove_self_forwards = ms;
281   }
282 
283   void record_string_deduplication_time(double ms) {
284     _cur_string_deduplication_time_ms = ms;
285   }
286 
287   void record_ref_proc_time(double ms) {
288     _cur_ref_proc_time_ms = ms;
289   }
290 
291   void record_root_region_scan_wait_time(double time_ms) {
292     _root_region_scan_wait_time_ms = time_ms;
293   }
294 
295   void record_total_free_cset_time_ms(double time_ms) {
296     _recorded_total_free_cset_time_ms = time_ms;
297   }
298 
299   void record_serial_free_cset_time_ms(double time_ms) {
300     _recorded_serial_free_cset_time_ms = time_ms;
301   }
302 
<span class="line-modified">303   void record_fast_reclaim_humongous_stats(double time_ms, size_t total, size_t candidates) {</span>
<span class="line-modified">304     _cur_fast_reclaim_humongous_register_time_ms = time_ms;</span>








305     _cur_fast_reclaim_humongous_total = total;
306     _cur_fast_reclaim_humongous_candidates = candidates;
307   }
308 
309   void record_fast_reclaim_humongous_time_ms(double value, size_t reclaimed) {
310     _cur_fast_reclaim_humongous_time_ms = value;
311     _cur_fast_reclaim_humongous_reclaimed = reclaimed;
312   }
313 
314   void record_young_cset_choice_time_ms(double time_ms) {
315     _recorded_young_cset_choice_time_ms = time_ms;
316   }
317 
318   void record_non_young_cset_choice_time_ms(double time_ms) {
319     _recorded_non_young_cset_choice_time_ms = time_ms;
320   }
321 
322   void record_redirty_logged_cards_time_ms(double time_ms) {
323     _recorded_redirty_logged_cards_time_ms = time_ms;
324   }
325 
326   void record_preserve_cm_referents_time_ms(double time_ms) {
327     _recorded_preserve_cm_referents_time_ms = time_ms;
328   }
329 
<span class="line-removed">330   void record_merge_pss_time_ms(double time_ms) {</span>
<span class="line-removed">331     _recorded_merge_pss_time_ms = time_ms;</span>
<span class="line-removed">332   }</span>
<span class="line-removed">333 </span>
334   void record_start_new_cset_time_ms(double time_ms) {
335     _recorded_start_new_cset_time_ms = time_ms;
336   }
337 
338   void record_cur_collection_start_sec(double time_ms) {
339     _cur_collection_start_sec = time_ms;
340   }
341 
342   void record_verify_before_time_ms(double time_ms) {
343     _cur_verify_before_time_ms = time_ms;
344   }
345 
346   void record_verify_after_time_ms(double time_ms) {
347     _cur_verify_after_time_ms = time_ms;
348   }
349 
350   void inc_external_accounted_time_ms(double time_ms) {
351     _external_accounted_time_ms += time_ms;
352   }
353 




354   void record_clear_claimed_marks_time_ms(double recorded_clear_claimed_marks_time_ms) {
355     _recorded_clear_claimed_marks_time_ms = recorded_clear_claimed_marks_time_ms;
356   }
357 
358   double cur_collection_start_sec() {
359     return _cur_collection_start_sec;
360   }
361 
362   double cur_collection_par_time_ms() {
<span class="line-modified">363     return _cur_collection_par_time_ms;</span>
364   }
365 
366   double cur_clear_ct_time_ms() {
367     return _cur_clear_ct_time_ms;
368   }
369 
370   double cur_expand_heap_time_ms() {
371     return _cur_expand_heap_time_ms;
372   }
373 
374   double root_region_scan_wait_time_ms() {
375     return _root_region_scan_wait_time_ms;
376   }
377 
378   double young_cset_choice_time_ms() {
379     return _recorded_young_cset_choice_time_ms;
380   }
381 
382   double total_free_cset_time_ms() {
383     return _recorded_total_free_cset_time_ms;
384   }
385 




386   double non_young_cset_choice_time_ms() {
387     return _recorded_non_young_cset_choice_time_ms;
388   }
389 
390   double fast_reclaim_humongous_time_ms() {
391     return _cur_fast_reclaim_humongous_time_ms;
392   }
393 




394   ReferenceProcessorPhaseTimes* ref_phase_times() { return &amp;_ref_phase_times; }
395 
396   WeakProcessorPhaseTimes* weak_phase_times() { return &amp;_weak_phase_times; }
397 };
398 
399 class G1EvacPhaseWithTrimTimeTracker : public StackObj {
400   G1ParScanThreadState* _pss;
401   Ticks _start;
402 
403   Tickspan&amp; _total_time;
404   Tickspan&amp; _trim_time;
405 
406   bool _stopped;
407 public:
408   G1EvacPhaseWithTrimTimeTracker(G1ParScanThreadState* pss, Tickspan&amp; total_time, Tickspan&amp; trim_time);
409   ~G1EvacPhaseWithTrimTimeTracker();
410 
411   void stop();
412 };
413 
414 class G1GCParPhaseTimesTracker : public CHeapObj&lt;mtGC&gt; {
415 protected:
416   Ticks _start_time;
417   G1GCPhaseTimes::GCParPhases _phase;
418   G1GCPhaseTimes* _phase_times;
419   uint _worker_id;
420   EventGCPhaseParallel _event;


421 public:
<span class="line-modified">422   G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id);</span>
423   virtual ~G1GCParPhaseTimesTracker();
424 };
425 
426 class G1EvacPhaseTimesTracker : public G1GCParPhaseTimesTracker {
427   Tickspan _total_time;
428   Tickspan _trim_time;
429 
430   G1EvacPhaseWithTrimTimeTracker _trim_tracker;
431 public:
432   G1EvacPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1ParScanThreadState* pss, G1GCPhaseTimes::GCParPhases phase, uint worker_id);
433   virtual ~G1EvacPhaseTimesTracker();
434 };
435 
436 #endif // SHARE_GC_G1_G1GCPHASETIMES_HPP
</pre>
</td>
<td>
<hr />
<pre>
 38 
 39 template &lt;class T&gt; class WorkerDataArray;
 40 
 41 class G1GCPhaseTimes : public CHeapObj&lt;mtGC&gt; {
 42   uint _max_gc_threads;
 43   jlong _gc_start_counter;
 44   double _gc_pause_time_ms;
 45 
 46  public:
 47   enum GCParPhases {
 48     GCWorkerStart,
 49     ExtRootScan,
 50     ThreadRoots,
 51     UniverseRoots,
 52     JNIRoots,
 53     ObjectSynchronizerRoots,
 54     ManagementRoots,
 55     SystemDictionaryRoots,
 56     CLDGRoots,
 57     JVMTIRoots,
<span class="line-modified"> 58     AOT_ONLY(AOTCodeRoots COMMA)</span>


 59     CMRefRoots,
<span class="line-modified"> 60     MergeER,</span>
<span class="line-modified"> 61     MergeRS,</span>
<span class="line-modified"> 62     OptMergeRS,</span>
<span class="line-modified"> 63     MergeLB,</span>
<span class="line-modified"> 64     MergeHCC,</span>
<span class="line-modified"> 65     ScanHR,</span>
<span class="line-modified"> 66     OptScanHR,</span>
 67     CodeRoots,
<span class="line-added"> 68     OptCodeRoots,</span>
 69     ObjCopy,
 70     OptObjCopy,
 71     Termination,
<span class="line-added"> 72     OptTermination,</span>
 73     Other,
 74     GCWorkerTotal,
 75     GCWorkerEnd,
 76     StringDedupQueueFixup,
 77     StringDedupTableFixup,
 78     RedirtyCards,
<span class="line-added"> 79     ParFreeCSet,</span>
 80     YoungFreeCSet,
 81     NonYoungFreeCSet,
<span class="line-added"> 82     RebuildFreeList,</span>
<span class="line-added"> 83     MergePSS,</span>
 84     GCParPhasesSentinel
 85   };
 86 
<span class="line-modified"> 87   static const GCParPhases ExtRootScanSubPhasesFirst = ThreadRoots;</span>
<span class="line-modified"> 88   static const GCParPhases ExtRootScanSubPhasesLast = CMRefRoots;</span>
 89 
<span class="line-modified"> 90   enum GCMergeRSWorkTimes {</span>
<span class="line-modified"> 91     MergeRSMergedSparse,</span>
<span class="line-modified"> 92     MergeRSMergedFine,</span>
<span class="line-modified"> 93     MergeRSMergedCoarse,</span>
<span class="line-added"> 94     MergeRSDirtyCards</span>
 95   };
 96 
<span class="line-modified"> 97   enum GCScanHRWorkItems {</span>
<span class="line-modified"> 98     ScanHRScannedCards,</span>
<span class="line-modified"> 99     ScanHRScannedBlocks,</span>
<span class="line-modified">100     ScanHRClaimedChunks,</span>
<span class="line-added">101     ScanHRScannedOptRefs,</span>
<span class="line-added">102     ScanHRUsedMemory</span>
103   };
104 
<span class="line-modified">105   enum GCMergeHCCWorkItems {</span>
<span class="line-modified">106     MergeHCCDirtyCards,</span>
<span class="line-modified">107     MergeHCCSkippedCards</span>
108   };
109 
<span class="line-modified">110   enum GCMergeLBWorkItems {</span>
<span class="line-modified">111     MergeLBDirtyCards,</span>
<span class="line-modified">112     MergeLBSkippedCards</span>
<span class="line-modified">113   };</span>
<span class="line-modified">114 </span>
<span class="line-added">115   enum GCMergePSSWorkItems {</span>
<span class="line-added">116     MergePSSCopiedBytes,</span>
<span class="line-added">117     MergePSSLABWasteBytes,</span>
<span class="line-added">118     MergePSSLABUndoWasteBytes</span>
119   };
120 
121  private:
122   // Markers for grouping the phases in the GCPhases enum above
123   static const int GCMainParPhasesLast = GCWorkerEnd;
124 
125   WorkerDataArray&lt;double&gt;* _gc_par_phases[GCParPhasesSentinel];
126 
<span class="line-modified">127   double _cur_collection_initial_evac_time_ms;</span>
<span class="line-modified">128   double _cur_optional_evac_time_ms;</span>




















129   double _cur_collection_code_root_fixup_time_ms;
130   double _cur_strong_code_root_purge_time_ms;
131 
132   double _cur_evac_fail_recalc_used;
133   double _cur_evac_fail_remove_self_forwards;
134 
135   double _cur_string_deduplication_time_ms;
136 
<span class="line-added">137   double _cur_merge_heap_roots_time_ms;</span>
<span class="line-added">138   double _cur_optional_merge_heap_roots_time_ms;</span>
<span class="line-added">139 </span>
<span class="line-added">140   double _cur_prepare_merge_heap_roots_time_ms;</span>
<span class="line-added">141   double _cur_optional_prepare_merge_heap_roots_time_ms;</span>
<span class="line-added">142 </span>
143   double _cur_prepare_tlab_time_ms;
144   double _cur_resize_tlab_time_ms;
145 
146   double _cur_derived_pointer_table_update_time_ms;
147 
148   double _cur_clear_ct_time_ms;
149   double _cur_expand_heap_time_ms;
150   double _cur_ref_proc_time_ms;
151 
152   double _cur_collection_start_sec;
153   double _root_region_scan_wait_time_ms;
154 
155   double _external_accounted_time_ms;
156 
<span class="line-added">157   double _recorded_prepare_heap_roots_time_ms;</span>
<span class="line-added">158 </span>
159   double _recorded_clear_claimed_marks_time_ms;
160 
161   double _recorded_young_cset_choice_time_ms;
162   double _recorded_non_young_cset_choice_time_ms;
163 
164   double _recorded_redirty_logged_cards_time_ms;
165 
166   double _recorded_preserve_cm_referents_time_ms;
167 
168   double _recorded_merge_pss_time_ms;
169 
170   double _recorded_start_new_cset_time_ms;
171 
172   double _recorded_total_free_cset_time_ms;
173 
174   double _recorded_serial_free_cset_time_ms;
175 
<span class="line-added">176   double _recorded_total_rebuild_freelist_time_ms;</span>
<span class="line-added">177 </span>
<span class="line-added">178   double _recorded_serial_rebuild_freelist_time_ms;</span>
<span class="line-added">179 </span>
<span class="line-added">180   double _cur_region_register_time;</span>
<span class="line-added">181 </span>
182   double _cur_fast_reclaim_humongous_time_ms;

183   size_t _cur_fast_reclaim_humongous_total;
184   size_t _cur_fast_reclaim_humongous_candidates;
185   size_t _cur_fast_reclaim_humongous_reclaimed;
186 
187   double _cur_verify_before_time_ms;
188   double _cur_verify_after_time_ms;
189 
190   ReferenceProcessorPhaseTimes _ref_phase_times;
191   WeakProcessorPhaseTimes _weak_phase_times;
192 
193   double worker_time(GCParPhases phase, uint worker);
194   void note_gc_end();
195   void reset();
196 
197   template &lt;class T&gt;
<span class="line-modified">198   void details(T* phase, const char* indent_str) const;</span>
199 
<span class="line-modified">200   void log_work_items(WorkerDataArray&lt;double&gt;* phase, uint indent, outputStream* out) const;</span>
<span class="line-added">201   void log_phase(WorkerDataArray&lt;double&gt;* phase, uint indent_level, outputStream* out, bool print_sum) const;</span>
<span class="line-added">202   void debug_serial_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent = 0) const;</span>
203   void debug_phase(WorkerDataArray&lt;double&gt;* phase, uint extra_indent = 0) const;
<span class="line-modified">204   void trace_phase(WorkerDataArray&lt;double&gt;* phase, bool print_sum = true, uint extra_indent = 0) const;</span>
205 
206   void info_time(const char* name, double value) const;
207   void debug_time(const char* name, double value) const;
208   // This will print logs for both &#39;gc+phases&#39; and &#39;gc+phases+ref&#39;.
209   void debug_time_for_reference(const char* name, double value) const;
210   void trace_time(const char* name, double value) const;
211   void trace_count(const char* name, size_t value) const;
212 
213   double print_pre_evacuate_collection_set() const;
<span class="line-modified">214   double print_merge_heap_roots_time() const;</span>
<span class="line-added">215   double print_evacuate_initial_collection_set() const;</span>
216   double print_evacuate_optional_collection_set() const;
217   double print_post_evacuate_collection_set() const;
218   void print_other(double accounted_ms) const;
219 
220  public:
221   G1GCPhaseTimes(STWGCTimer* gc_timer, uint max_gc_threads);
222   void note_gc_start();
223   void print();
224   static const char* phase_name(GCParPhases phase);
225 
226   // record the time a phase took in seconds
<span class="line-modified">227   void record_time_secs(GCParPhases phase, uint worker_id, double secs);</span>
228 
229   // add a number of seconds to a phase
<span class="line-modified">230   void add_time_secs(GCParPhases phase, uint worker_id, double secs);</span>
<span class="line-added">231 </span>
<span class="line-added">232   void record_or_add_time_secs(GCParPhases phase, uint worker_id, double secs);</span>
233 
<span class="line-modified">234   double get_time_secs(GCParPhases phase, uint worker_id);</span>
235 
<span class="line-modified">236   void record_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index = 0);</span>
237 
<span class="line-modified">238   void record_or_add_thread_work_item(GCParPhases phase, uint worker_id, size_t count, uint index = 0);</span>
<span class="line-added">239 </span>
<span class="line-added">240   size_t get_thread_work_item(GCParPhases phase, uint worker_id, uint index = 0);</span>
241 
242   // return the average time for a phase in milliseconds
243   double average_time_ms(GCParPhases phase);
244 
245   size_t sum_thread_work_items(GCParPhases phase, uint index = 0);
246 


247   void record_prepare_tlab_time_ms(double ms) {
248     _cur_prepare_tlab_time_ms = ms;
249   }
250 
251   void record_resize_tlab_time_ms(double ms) {
252     _cur_resize_tlab_time_ms = ms;
253   }
254 
255   void record_derived_pointer_table_update_time(double ms) {
256     _cur_derived_pointer_table_update_time_ms = ms;
257   }
258 
259   void record_clear_ct_time(double ms) {
260     _cur_clear_ct_time_ms = ms;
261   }
262 
263   void record_expand_heap_time(double ms) {
264     _cur_expand_heap_time_ms = ms;
265   }
266 
<span class="line-modified">267   void record_initial_evac_time(double ms) {</span>
<span class="line-modified">268     _cur_collection_initial_evac_time_ms = ms;</span>
269   }
270 
<span class="line-modified">271   void record_or_add_optional_evac_time(double ms) {</span>
<span class="line-modified">272     _cur_optional_evac_time_ms += ms;</span>
273   }
274 
<span class="line-modified">275   void record_or_add_code_root_fixup_time(double ms) {</span>
<span class="line-modified">276     _cur_collection_code_root_fixup_time_ms += ms;</span>
277   }
278 
279   void record_strong_code_root_purge_time(double ms) {
280     _cur_strong_code_root_purge_time_ms = ms;
281   }
282 
<span class="line-added">283   void record_merge_heap_roots_time(double ms) {</span>
<span class="line-added">284     _cur_merge_heap_roots_time_ms += ms;</span>
<span class="line-added">285   }</span>
<span class="line-added">286 </span>
<span class="line-added">287   void record_or_add_optional_merge_heap_roots_time(double ms) {</span>
<span class="line-added">288     _cur_optional_merge_heap_roots_time_ms += ms;</span>
<span class="line-added">289   }</span>
<span class="line-added">290 </span>
<span class="line-added">291   void record_prepare_merge_heap_roots_time(double ms) {</span>
<span class="line-added">292     _cur_prepare_merge_heap_roots_time_ms += ms;</span>
<span class="line-added">293   }</span>
<span class="line-added">294 </span>
<span class="line-added">295   void record_or_add_optional_prepare_merge_heap_roots_time(double ms) {</span>
<span class="line-added">296     _cur_optional_prepare_merge_heap_roots_time_ms += ms;</span>
<span class="line-added">297   }</span>
<span class="line-added">298 </span>
299   void record_evac_fail_recalc_used_time(double ms) {
300     _cur_evac_fail_recalc_used = ms;
301   }
302 
303   void record_evac_fail_remove_self_forwards(double ms) {
304     _cur_evac_fail_remove_self_forwards = ms;
305   }
306 
307   void record_string_deduplication_time(double ms) {
308     _cur_string_deduplication_time_ms = ms;
309   }
310 
311   void record_ref_proc_time(double ms) {
312     _cur_ref_proc_time_ms = ms;
313   }
314 
315   void record_root_region_scan_wait_time(double time_ms) {
316     _root_region_scan_wait_time_ms = time_ms;
317   }
318 
319   void record_total_free_cset_time_ms(double time_ms) {
320     _recorded_total_free_cset_time_ms = time_ms;
321   }
322 
323   void record_serial_free_cset_time_ms(double time_ms) {
324     _recorded_serial_free_cset_time_ms = time_ms;
325   }
326 
<span class="line-modified">327   void record_total_rebuild_freelist_time_ms(double time_ms) {</span>
<span class="line-modified">328     _recorded_total_rebuild_freelist_time_ms = time_ms;</span>
<span class="line-added">329   }</span>
<span class="line-added">330 </span>
<span class="line-added">331   void record_serial_rebuild_freelist_time_ms(double time_ms) {</span>
<span class="line-added">332     _recorded_serial_rebuild_freelist_time_ms = time_ms;</span>
<span class="line-added">333   }</span>
<span class="line-added">334 </span>
<span class="line-added">335   void record_register_regions(double time_ms, size_t total, size_t candidates) {</span>
<span class="line-added">336     _cur_region_register_time = time_ms;</span>
337     _cur_fast_reclaim_humongous_total = total;
338     _cur_fast_reclaim_humongous_candidates = candidates;
339   }
340 
341   void record_fast_reclaim_humongous_time_ms(double value, size_t reclaimed) {
342     _cur_fast_reclaim_humongous_time_ms = value;
343     _cur_fast_reclaim_humongous_reclaimed = reclaimed;
344   }
345 
346   void record_young_cset_choice_time_ms(double time_ms) {
347     _recorded_young_cset_choice_time_ms = time_ms;
348   }
349 
350   void record_non_young_cset_choice_time_ms(double time_ms) {
351     _recorded_non_young_cset_choice_time_ms = time_ms;
352   }
353 
354   void record_redirty_logged_cards_time_ms(double time_ms) {
355     _recorded_redirty_logged_cards_time_ms = time_ms;
356   }
357 
358   void record_preserve_cm_referents_time_ms(double time_ms) {
359     _recorded_preserve_cm_referents_time_ms = time_ms;
360   }
361 




362   void record_start_new_cset_time_ms(double time_ms) {
363     _recorded_start_new_cset_time_ms = time_ms;
364   }
365 
366   void record_cur_collection_start_sec(double time_ms) {
367     _cur_collection_start_sec = time_ms;
368   }
369 
370   void record_verify_before_time_ms(double time_ms) {
371     _cur_verify_before_time_ms = time_ms;
372   }
373 
374   void record_verify_after_time_ms(double time_ms) {
375     _cur_verify_after_time_ms = time_ms;
376   }
377 
378   void inc_external_accounted_time_ms(double time_ms) {
379     _external_accounted_time_ms += time_ms;
380   }
381 
<span class="line-added">382   void record_prepare_heap_roots_time_ms(double recorded_prepare_heap_roots_time_ms) {</span>
<span class="line-added">383     _recorded_prepare_heap_roots_time_ms = recorded_prepare_heap_roots_time_ms;</span>
<span class="line-added">384   }</span>
<span class="line-added">385 </span>
386   void record_clear_claimed_marks_time_ms(double recorded_clear_claimed_marks_time_ms) {
387     _recorded_clear_claimed_marks_time_ms = recorded_clear_claimed_marks_time_ms;
388   }
389 
390   double cur_collection_start_sec() {
391     return _cur_collection_start_sec;
392   }
393 
394   double cur_collection_par_time_ms() {
<span class="line-modified">395     return _cur_collection_initial_evac_time_ms + _cur_optional_evac_time_ms;</span>
396   }
397 
398   double cur_clear_ct_time_ms() {
399     return _cur_clear_ct_time_ms;
400   }
401 
402   double cur_expand_heap_time_ms() {
403     return _cur_expand_heap_time_ms;
404   }
405 
406   double root_region_scan_wait_time_ms() {
407     return _root_region_scan_wait_time_ms;
408   }
409 
410   double young_cset_choice_time_ms() {
411     return _recorded_young_cset_choice_time_ms;
412   }
413 
414   double total_free_cset_time_ms() {
415     return _recorded_total_free_cset_time_ms;
416   }
417 
<span class="line-added">418   double total_rebuild_freelist_time_ms() {</span>
<span class="line-added">419     return _recorded_total_rebuild_freelist_time_ms;</span>
<span class="line-added">420   }</span>
<span class="line-added">421 </span>
422   double non_young_cset_choice_time_ms() {
423     return _recorded_non_young_cset_choice_time_ms;
424   }
425 
426   double fast_reclaim_humongous_time_ms() {
427     return _cur_fast_reclaim_humongous_time_ms;
428   }
429 
<span class="line-added">430   size_t fast_reclaim_humongous_candidates() const {</span>
<span class="line-added">431     return _cur_fast_reclaim_humongous_candidates;</span>
<span class="line-added">432   }</span>
<span class="line-added">433 </span>
434   ReferenceProcessorPhaseTimes* ref_phase_times() { return &amp;_ref_phase_times; }
435 
436   WeakProcessorPhaseTimes* weak_phase_times() { return &amp;_weak_phase_times; }
437 };
438 
439 class G1EvacPhaseWithTrimTimeTracker : public StackObj {
440   G1ParScanThreadState* _pss;
441   Ticks _start;
442 
443   Tickspan&amp; _total_time;
444   Tickspan&amp; _trim_time;
445 
446   bool _stopped;
447 public:
448   G1EvacPhaseWithTrimTimeTracker(G1ParScanThreadState* pss, Tickspan&amp; total_time, Tickspan&amp; trim_time);
449   ~G1EvacPhaseWithTrimTimeTracker();
450 
451   void stop();
452 };
453 
454 class G1GCParPhaseTimesTracker : public CHeapObj&lt;mtGC&gt; {
455 protected:
456   Ticks _start_time;
457   G1GCPhaseTimes::GCParPhases _phase;
458   G1GCPhaseTimes* _phase_times;
459   uint _worker_id;
460   EventGCPhaseParallel _event;
<span class="line-added">461   bool _must_record;</span>
<span class="line-added">462 </span>
463 public:
<span class="line-modified">464   G1GCParPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1GCPhaseTimes::GCParPhases phase, uint worker_id, bool must_record = true);</span>
465   virtual ~G1GCParPhaseTimesTracker();
466 };
467 
468 class G1EvacPhaseTimesTracker : public G1GCParPhaseTimesTracker {
469   Tickspan _total_time;
470   Tickspan _trim_time;
471 
472   G1EvacPhaseWithTrimTimeTracker _trim_tracker;
473 public:
474   G1EvacPhaseTimesTracker(G1GCPhaseTimes* phase_times, G1ParScanThreadState* pss, G1GCPhaseTimes::GCParPhases phase, uint worker_id);
475   virtual ~G1EvacPhaseTimesTracker();
476 };
477 
478 #endif // SHARE_GC_G1_G1GCPHASETIMES_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1GCPhaseTimes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1HeapRegionEventSender.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
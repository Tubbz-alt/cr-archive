diff a/src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp b/src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp
--- a/src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp
+++ b/src/hotspot/share/gc/g1/g1BlockOffsetTable.hpp
@@ -31,18 +31,18 @@
 #include "memory/virtualspace.hpp"
 #include "utilities/globalDefinitions.hpp"
 
 // Forward declarations
 class G1BlockOffsetTable;
-class G1ContiguousSpace;
+class HeapRegion;
 
 // This implementation of "G1BlockOffsetTable" divides the covered region
 // into "N"-word subregions (where "N" = 2^"LogN".  An array with an entry
 // for each such subregion indicates how far back one must go to find the
 // start of the chunk that includes the first word of the subregion.
 //
-// Each G1BlockOffsetTablePart is owned by a G1ContiguousSpace.
+// Each G1BlockOffsetTablePart is owned by a HeapRegion.
 
 class G1BlockOffsetTable: public CHeapObj<mtGC> {
   friend class G1BlockOffsetTablePart;
   friend class VMStructs;
 
@@ -50,11 +50,11 @@
   // The reserved region covered by the table.
   MemRegion _reserved;
 
   // Array for keeping offsets for retrieving object start fast given an
   // address.
-  u_char* _offset_array;          // byte array keeping backwards offsets
+  volatile u_char* _offset_array;  // byte array keeping backwards offsets
 
   void check_offset(size_t offset, const char* msg) const {
     assert(offset <= BOTConstants::N_words,
            "%s - offset: " SIZE_FORMAT ", N_words: %u",
            msg, offset, BOTConstants::N_words);
@@ -62,14 +62,11 @@
 
   // Bounds checking accessors:
   // For performance these have to devolve to array accesses in product builds.
   inline u_char offset_array(size_t index) const;
 
-  void set_offset_array_raw(size_t index, u_char offset) {
-    _offset_array[index] = offset;
-  }
-
+  inline void set_offset_array_raw(size_t index, u_char offset);
   inline void set_offset_array(size_t index, u_char offset);
 
   inline void set_offset_array(size_t index, HeapWord* high, HeapWord* low);
 
   inline void set_offset_array(size_t left, size_t right, u_char offset);
@@ -121,12 +118,12 @@
   debug_only(bool _object_can_span;)
 
   // This is the global BlockOffsetTable.
   G1BlockOffsetTable* _bot;
 
-  // The space that owns this subregion.
-  G1ContiguousSpace* _space;
+  // The region that owns this subregion.
+  HeapRegion* _hr;
 
   // Sets the entries
   // corresponding to the cards starting at "start" and ending at "end"
   // to point back to the card before "start": the interval [start, end)
   // is right-open.
@@ -184,11 +181,11 @@
 
   void check_all_cards(size_t left_card, size_t right_card) const;
 
 public:
   //  The elements of the array are initialized to zero.
-  G1BlockOffsetTablePart(G1BlockOffsetTable* array, G1ContiguousSpace* gsp);
+  G1BlockOffsetTablePart(G1BlockOffsetTable* array, HeapRegion* hr);
 
   void verify() const;
 
   // Returns the address of the start of the block containing "addr", or
   // else "null" if it is covered by no block.  (May have side effects,

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1Allocator.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Allocator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Allocator.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,34 +24,39 @@</span>
  
  #ifndef SHARE_GC_G1_G1ALLOCATOR_HPP
  #define SHARE_GC_G1_G1ALLOCATOR_HPP
  
  #include &quot;gc/g1/g1AllocRegion.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/g1/g1InCSetState.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/g1/g1HeapRegionAttr.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/plab.hpp&quot;
  
  class G1EvacuationInfo;
<span class="udiff-line-added">+ class G1NUMA;</span>
  
  // Interface to keep track of which regions G1 is currently allocating into. Provides
  // some accessors (e.g. allocating into them, or getting their occupancy).
  // Also keeps track of retained regions across GCs.
  class G1Allocator : public CHeapObj&lt;mtGC&gt; {
    friend class VMStructs;
  
  private:
    G1CollectedHeap* _g1h;
<span class="udiff-line-added">+   G1NUMA* _numa;</span>
  
    bool _survivor_is_full;
    bool _old_is_full;
  
<span class="udiff-line-added">+   // The number of MutatorAllocRegions used, one per memory node.</span>
<span class="udiff-line-added">+   size_t _num_alloc_regions;</span>
<span class="udiff-line-added">+ </span>
    // Alloc region used to satisfy mutator allocation requests.
<span class="udiff-line-modified-removed">-   MutatorAllocRegion _mutator_alloc_region;</span>
<span class="udiff-line-modified-added">+   MutatorAllocRegion* _mutator_alloc_regions;</span>
  
    // Alloc region used to satisfy allocation requests by the GC for
    // survivor objects.
<span class="udiff-line-modified-removed">-   SurvivorGCAllocRegion _survivor_gc_alloc_region;</span>
<span class="udiff-line-modified-added">+   SurvivorGCAllocRegion* _survivor_gc_alloc_regions;</span>
  
    // Alloc region used to satisfy allocation requests by the GC for
    // old objects.
    OldGCAllocRegion _old_gc_alloc_region;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,33 +71,41 @@</span>
    void reuse_retained_old_region(G1EvacuationInfo&amp; evacuation_info,
                                   OldGCAllocRegion* old,
                                   HeapRegion** retained);
  
    // Accessors to the allocation regions.
<span class="udiff-line-modified-removed">-   inline MutatorAllocRegion* mutator_alloc_region();</span>
<span class="udiff-line-modified-removed">-   inline SurvivorGCAllocRegion* survivor_gc_alloc_region();</span>
<span class="udiff-line-modified-added">+   inline MutatorAllocRegion* mutator_alloc_region(uint node_index);</span>
<span class="udiff-line-modified-added">+   inline SurvivorGCAllocRegion* survivor_gc_alloc_region(uint node_index);</span>
    inline OldGCAllocRegion* old_gc_alloc_region();
  
    // Allocation attempt during GC for a survivor object / PLAB.
    HeapWord* survivor_attempt_allocation(size_t min_word_size,
<span class="udiff-line-modified-removed">-                                                size_t desired_word_size,</span>
<span class="udiff-line-modified-removed">-                                                size_t* actual_word_size);</span>
<span class="udiff-line-modified-added">+                                         size_t desired_word_size,</span>
<span class="udiff-line-modified-added">+                                         size_t* actual_word_size,</span>
<span class="udiff-line-added">+                                         uint node_index);</span>
  
    // Allocation attempt during GC for an old object / PLAB.
    HeapWord* old_attempt_allocation(size_t min_word_size,
<span class="udiff-line-modified-removed">-                                           size_t desired_word_size,</span>
<span class="udiff-line-modified-removed">-                                           size_t* actual_word_size);</span>
<span class="udiff-line-modified-added">+                                    size_t desired_word_size,</span>
<span class="udiff-line-modified-added">+                                    size_t* actual_word_size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Node index of current thread.</span>
<span class="udiff-line-added">+   inline uint current_node_index() const;</span>
<span class="udiff-line-added">+ </span>
  public:
    G1Allocator(G1CollectedHeap* heap);
<span class="udiff-line-added">+   ~G1Allocator();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   uint num_nodes() { return (uint)_num_alloc_regions; }</span>
  
  #ifdef ASSERT
    // Do we currently have an active mutator region to allocate into?
<span class="udiff-line-modified-removed">-   bool has_mutator_alloc_region() { return mutator_alloc_region()-&gt;get() != NULL; }</span>
<span class="udiff-line-modified-added">+   bool has_mutator_alloc_region();</span>
  #endif
  
<span class="udiff-line-modified-removed">-   void init_mutator_alloc_region();</span>
<span class="udiff-line-modified-removed">-   void release_mutator_alloc_region();</span>
<span class="udiff-line-modified-added">+   void init_mutator_alloc_regions();</span>
<span class="udiff-line-modified-added">+   void release_mutator_alloc_regions();</span>
  
    void init_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info);
    void release_gc_alloc_regions(G1EvacuationInfo&amp; evacuation_info);
    void abandon_gc_alloc_regions();
    bool is_retained_old_region(HeapRegion* hr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,82 +123,99 @@</span>
  
    // Allocate blocks of memory during garbage collection. Will ensure an
    // allocation region, either by picking one or expanding the
    // heap, and then allocate a block of the given size. The block
    // may not be a humongous - it must fit into a single heap region.
<span class="udiff-line-modified-removed">-   HeapWord* par_allocate_during_gc(InCSetState dest,</span>
<span class="udiff-line-modified-removed">-                                    size_t word_size);</span>
<span class="udiff-line-modified-added">+   HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,</span>
<span class="udiff-line-modified-added">+                                    size_t word_size,</span>
<span class="udiff-line-added">+                                    uint node_index);</span>
  
<span class="udiff-line-modified-removed">-   HeapWord* par_allocate_during_gc(InCSetState dest,</span>
<span class="udiff-line-modified-added">+   HeapWord* par_allocate_during_gc(G1HeapRegionAttr dest,</span>
                                     size_t min_word_size,
                                     size_t desired_word_size,
<span class="udiff-line-modified-removed">-                                    size_t* actual_word_size);</span>
<span class="udiff-line-modified-added">+                                    size_t* actual_word_size,</span>
<span class="udiff-line-added">+                                    uint node_index);</span>
  };
  
  // Manages the PLABs used during garbage collection. Interface for allocation from PLABs.
  // Needs to handle multiple contexts, extra alignment in any &quot;survivor&quot; area and some
  // statistics.
  class G1PLABAllocator : public CHeapObj&lt;mtGC&gt; {
    friend class G1ParScanThreadState;
  private:
<span class="udiff-line-added">+   typedef G1HeapRegionAttr::region_type_t region_type_t;</span>
<span class="udiff-line-added">+ </span>
    G1CollectedHeap* _g1h;
    G1Allocator* _allocator;
  
<span class="udiff-line-modified-removed">-   PLAB  _surviving_alloc_buffer;</span>
<span class="udiff-line-removed">-   PLAB  _tenured_alloc_buffer;</span>
<span class="udiff-line-removed">-   PLAB* _alloc_buffers[InCSetState::Num];</span>
<span class="udiff-line-modified-added">+   PLAB** _alloc_buffers[G1HeapRegionAttr::Num];</span>
  
    // The survivor alignment in effect in bytes.
    // == 0 : don&#39;t align survivors
    // != 0 : align survivors to that alignment
    // These values were chosen to favor the non-alignment case since some
    // architectures have a special compare against zero instructions.
    const uint _survivor_alignment_bytes;
  
    // Number of words allocated directly (not counting PLAB allocation).
<span class="udiff-line-modified-removed">-   size_t _direct_allocated[InCSetState::Num];</span>
<span class="udiff-line-modified-added">+   size_t _direct_allocated[G1HeapRegionAttr::Num];</span>
  
    void flush_and_retire_stats();
<span class="udiff-line-modified-removed">-   inline PLAB* alloc_buffer(InCSetState dest);</span>
<span class="udiff-line-modified-added">+   inline PLAB* alloc_buffer(G1HeapRegionAttr dest, uint node_index) const;</span>
<span class="udiff-line-added">+   inline PLAB* alloc_buffer(region_type_t dest, uint node_index) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Returns the number of allocation buffers for the given dest.</span>
<span class="udiff-line-added">+   // There is only 1 buffer for Old while Young may have multiple buffers depending on</span>
<span class="udiff-line-added">+   // active NUMA nodes.</span>
<span class="udiff-line-added">+   inline uint alloc_buffers_length(region_type_t dest) const;</span>
  
    // Calculate the survivor space object alignment in bytes. Returns that or 0 if
    // there are no restrictions on survivor alignment.
    static uint calc_survivor_alignment_bytes();
  
    bool may_throw_away_buffer(size_t const allocation_word_sz, size_t const buffer_size) const;
  public:
    G1PLABAllocator(G1Allocator* allocator);
<span class="udiff-line-added">+   ~G1PLABAllocator();</span>
  
    size_t waste() const;
    size_t undo_waste() const;
  
    // Allocate word_sz words in dest, either directly into the regions or by
    // allocating a new PLAB. Returns the address of the allocated memory, NULL if
    // not successful. Plab_refill_failed indicates whether an attempt to refill the
    // PLAB failed or not.
<span class="udiff-line-modified-removed">-   HeapWord* allocate_direct_or_new_plab(InCSetState dest,</span>
<span class="udiff-line-modified-added">+   HeapWord* allocate_direct_or_new_plab(G1HeapRegionAttr dest,</span>
                                          size_t word_sz,
<span class="udiff-line-modified-removed">-                                         bool* plab_refill_failed);</span>
<span class="udiff-line-modified-added">+                                         bool* plab_refill_failed,</span>
<span class="udiff-line-added">+                                         uint node_index);</span>
  
    // Allocate word_sz words in the PLAB of dest.  Returns the address of the
    // allocated memory, NULL if not successful.
<span class="udiff-line-modified-removed">-   inline HeapWord* plab_allocate(InCSetState dest,</span>
<span class="udiff-line-modified-removed">-                                  size_t word_sz);</span>
<span class="udiff-line-modified-added">+   inline HeapWord* plab_allocate(G1HeapRegionAttr dest,</span>
<span class="udiff-line-modified-added">+                                  size_t word_sz,</span>
<span class="udiff-line-added">+                                  uint node_index);</span>
  
<span class="udiff-line-modified-removed">-   inline HeapWord* allocate(InCSetState dest,</span>
<span class="udiff-line-modified-added">+   inline HeapWord* allocate(G1HeapRegionAttr dest,</span>
                              size_t word_sz,
<span class="udiff-line-modified-removed">-                             bool* refill_failed);</span>
<span class="udiff-line-modified-added">+                             bool* refill_failed,</span>
<span class="udiff-line-added">+                             uint node_index);</span>
  
<span class="udiff-line-modified-removed">-   void undo_allocation(InCSetState dest, HeapWord* obj, size_t word_sz);</span>
<span class="udiff-line-modified-added">+   void undo_allocation(G1HeapRegionAttr dest, HeapWord* obj, size_t word_sz, uint node_index);</span>
  };
  
<span class="udiff-line-modified-removed">- // G1ArchiveRegionMap is a boolean array used to mark G1 regions as</span>
<span class="udiff-line-modified-added">+ // G1ArchiveRegionMap is an array used to mark G1 regions as</span>
  // archive regions.  This allows a quick check for whether an object
  // should not be marked because it is in an archive region.
<span class="udiff-line-modified-removed">- class G1ArchiveRegionMap : public G1BiasedMappedArray&lt;bool&gt; {</span>
<span class="udiff-line-modified-added">+ class G1ArchiveRegionMap : public G1BiasedMappedArray&lt;uint8_t&gt; {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   static const uint8_t NoArchive = 0;</span>
<span class="udiff-line-added">+   static const uint8_t OpenArchive = 1;</span>
<span class="udiff-line-added">+   static const uint8_t ClosedArchive = 2;</span>
<span class="udiff-line-added">+ </span>
  protected:
<span class="udiff-line-modified-removed">-   bool default_value() const { return false; }</span>
<span class="udiff-line-modified-added">+   uint8_t default_value() const { return NoArchive; }</span>
  };
  
  // G1ArchiveAllocator is used to allocate memory in archive
  // regions. Such regions are not scavenged nor compacted by GC.
  // There are two types of archive regions, which are
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,23 +293,22 @@</span>
    // Create the _archive_region_map which is used to identify archive objects.
    static inline void enable_archive_object_check();
  
    // Mark regions containing the specified address range as archive/non-archive.
    static inline void set_range_archive(MemRegion range, bool open);
<span class="udiff-line-modified-removed">-   static inline void clear_range_archive(MemRegion range, bool open);</span>
<span class="udiff-line-modified-added">+   static inline void clear_range_archive(MemRegion range);</span>
  
    // Check if the object is in closed archive
    static inline bool is_closed_archive_object(oop object);
    // Check if the object is in open archive
    static inline bool is_open_archive_object(oop object);
    // Check if the object is either in closed archive or open archive
    static inline bool is_archived_object(oop object);
  
  private:
    static bool _archive_check_enabled;
<span class="udiff-line-modified-removed">-   static G1ArchiveRegionMap  _closed_archive_region_map;</span>
<span class="udiff-line-removed">-   static G1ArchiveRegionMap  _open_archive_region_map;</span>
<span class="udiff-line-modified-added">+   static G1ArchiveRegionMap  _archive_region_map;</span>
  
    // Check if an object is in a closed archive region using the _closed_archive_region_map.
    static inline bool in_closed_archive_range(oop object);
    // Check if an object is in open archive region using the _open_archive_region_map.
    static inline bool in_open_archive_range(oop object);
</pre>
<center><a href="g1Allocator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Allocator.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
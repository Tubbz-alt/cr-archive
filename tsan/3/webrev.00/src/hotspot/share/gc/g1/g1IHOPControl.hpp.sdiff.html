<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1IHOPControl.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1IHOPControl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1MMUTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1IHOPControl.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
106 // based on predictions of current allocation rate and time periods between
107 // initial mark and the first mixed gc.
108 class G1AdaptiveIHOPControl : public G1IHOPControl {
109   size_t _heap_reserve_percent; // Percentage of maximum heap capacity we should avoid to touch
110   size_t _heap_waste_percent;   // Percentage of free heap that should be considered as waste.
111 
112   const G1Predictions * _predictor;
113 
114   TruncatedSeq _marking_times_s;
115   TruncatedSeq _allocation_rate_s;
116 
117   // The most recent unrestrained size of the young gen. This is used as an additional
118   // factor in the calculation of the threshold, as the threshold is based on
119   // non-young gen occupancy at the end of GC. For the IHOP threshold, we need to
120   // consider the young gen size during that time too.
121   // Since we cannot know what young gen sizes are used in the future, we will just
122   // use the current one. We expect that this one will be one with a fairly large size,
123   // as there is no marking or mixed gc that could impact its size too much.
124   size_t _last_unrestrained_young_size;
125 



126   bool have_enough_data_for_prediction() const;
127 
128   // The &quot;actual&quot; target threshold the algorithm wants to keep during and at the
129   // end of marking. This is typically lower than the requested threshold, as the
130   // algorithm needs to consider restrictions by the environment.
131   size_t actual_target_threshold() const;
132  protected:
133   virtual double last_marking_length_s() const { return _marking_times_s.last(); }
134  public:
135   G1AdaptiveIHOPControl(double ihop_percent,
136                         G1Predictions const* predictor,
137                         size_t heap_reserve_percent, // The percentage of total heap capacity that should not be tapped into.
138                         size_t heap_waste_percent);  // The percentage of the free space in the heap that we think is not usable for allocation.
139 
140   virtual size_t get_conc_mark_start_threshold();
141 
142   virtual void update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size);
143   virtual void update_marking_length(double marking_length_s);
144 
145   virtual void print();
</pre>
</td>
<td>
<hr />
<pre>
106 // based on predictions of current allocation rate and time periods between
107 // initial mark and the first mixed gc.
108 class G1AdaptiveIHOPControl : public G1IHOPControl {
109   size_t _heap_reserve_percent; // Percentage of maximum heap capacity we should avoid to touch
110   size_t _heap_waste_percent;   // Percentage of free heap that should be considered as waste.
111 
112   const G1Predictions * _predictor;
113 
114   TruncatedSeq _marking_times_s;
115   TruncatedSeq _allocation_rate_s;
116 
117   // The most recent unrestrained size of the young gen. This is used as an additional
118   // factor in the calculation of the threshold, as the threshold is based on
119   // non-young gen occupancy at the end of GC. For the IHOP threshold, we need to
120   // consider the young gen size during that time too.
121   // Since we cannot know what young gen sizes are used in the future, we will just
122   // use the current one. We expect that this one will be one with a fairly large size,
123   // as there is no marking or mixed gc that could impact its size too much.
124   size_t _last_unrestrained_young_size;
125 
<span class="line-added">126   // Get a new prediction bounded below by zero from the given sequence.</span>
<span class="line-added">127   double predict(TruncatedSeq const* seq) const;</span>
<span class="line-added">128 </span>
129   bool have_enough_data_for_prediction() const;
130 
131   // The &quot;actual&quot; target threshold the algorithm wants to keep during and at the
132   // end of marking. This is typically lower than the requested threshold, as the
133   // algorithm needs to consider restrictions by the environment.
134   size_t actual_target_threshold() const;
135  protected:
136   virtual double last_marking_length_s() const { return _marking_times_s.last(); }
137  public:
138   G1AdaptiveIHOPControl(double ihop_percent,
139                         G1Predictions const* predictor,
140                         size_t heap_reserve_percent, // The percentage of total heap capacity that should not be tapped into.
141                         size_t heap_waste_percent);  // The percentage of the free space in the heap that we think is not usable for allocation.
142 
143   virtual size_t get_conc_mark_start_threshold();
144 
145   virtual void update_allocation_info(double allocation_time_s, size_t allocated_bytes, size_t additional_buffer_size);
146   virtual void update_marking_length(double marking_length_s);
147 
148   virtual void print();
</pre>
</td>
</tr>
</table>
<center><a href="g1IHOPControl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1MMUTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
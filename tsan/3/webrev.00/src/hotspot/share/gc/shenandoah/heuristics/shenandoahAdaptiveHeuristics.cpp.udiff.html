<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/heuristics/shenandoahAdaptiveHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../c2/shenandoahSupport.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahAdaptiveHeuristics.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/heuristics/shenandoahAdaptiveHeuristics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33,25 +34,11 @@</span>
  
  ShenandoahAdaptiveHeuristics::ShenandoahAdaptiveHeuristics() :
    ShenandoahHeuristics(),
    _cycle_gap_history(new TruncatedSeq(5)),
    _conc_mark_duration_history(new TruncatedSeq(5)),
<span class="udiff-line-modified-removed">-   _conc_uprefs_duration_history(new TruncatedSeq(5)) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);</span>
<span class="udiff-line-removed">-   SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Final configuration checks</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahSATBBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahReadBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahWriteBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahStoreValReadBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahKeepAliveBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahCASBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahAcmpBarrier);</span>
<span class="udiff-line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahCloneBarrier);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   _conc_uprefs_duration_history(new TruncatedSeq(5)) {}</span>
  
  ShenandoahAdaptiveHeuristics::~ShenandoahAdaptiveHeuristics() {}
  
  void ShenandoahAdaptiveHeuristics::choose_collection_set_from_regiondata(ShenandoahCollectionSet* cset,
                                                                           RegionData* data, size_t size,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,18 +60,21 @@</span>
    // Therefore, we start by sorting the regions by garbage. Then we unconditionally add the best candidates
    // before we meet min_garbage. Then we add all candidates that fit with a garbage threshold before
    // we hit max_cset. When max_cset is hit, we terminate the cset selection. Note that in this scheme,
    // ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.
  
<span class="udiff-line-modified-removed">-   size_t capacity    = ShenandoahHeap::heap()-&gt;capacity();</span>
<span class="udiff-line-modified-removed">-   size_t free_target = ShenandoahMinFreeThreshold * capacity / 100;</span>
<span class="udiff-line-modified-added">+   size_t capacity    = ShenandoahHeap::heap()-&gt;max_capacity();</span>
<span class="udiff-line-modified-added">+   size_t free_target = capacity / 100 * ShenandoahMinFreeThreshold;</span>
    size_t min_garbage = free_target &gt; actual_free ? (free_target - actual_free) : 0;
<span class="udiff-line-modified-removed">-   size_t max_cset    = (size_t)(1.0 * ShenandoahEvacReserve * capacity / 100 / ShenandoahEvacWaste);</span>
<span class="udiff-line-modified-added">+   size_t max_cset    = (size_t)((1.0 * capacity / 100 * ShenandoahEvacReserve) / ShenandoahEvacWaste);</span>
  
<span class="udiff-line-modified-removed">-   log_info(gc, ergo)(&quot;Adaptive CSet Selection. Target Free: &quot; SIZE_FORMAT &quot;M, Actual Free: &quot;</span>
<span class="udiff-line-modified-removed">-                      SIZE_FORMAT &quot;M, Max CSet: &quot; SIZE_FORMAT &quot;M, Min Garbage: &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="udiff-line-modified-removed">-                      free_target / M, actual_free / M, max_cset / M, min_garbage / M);</span>
<span class="udiff-line-modified-added">+   log_info(gc, ergo)(&quot;Adaptive CSet Selection. Target Free: &quot; SIZE_FORMAT &quot;%s, Actual Free: &quot;</span>
<span class="udiff-line-modified-added">+                      SIZE_FORMAT &quot;%s, Max CSet: &quot; SIZE_FORMAT &quot;%s, Min Garbage: &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="udiff-line-modified-added">+                      byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),</span>
<span class="udiff-line-added">+                      byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),</span>
<span class="udiff-line-added">+                      byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),</span>
<span class="udiff-line-added">+                      byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));</span>
  
    // Better select garbage-first regions
    QuickSort::sort&lt;RegionData&gt;(data, (int)size, compare_by_garbage, false);
  
    size_t cur_cset = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122,43 +112,46 @@</span>
    } else if (phase == ShenandoahPhaseTimings::conc_update_refs) {
      _conc_uprefs_duration_history-&gt;add(secs);
    } // Else ignore
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahAdaptiveHeuristics::should_start_normal_gc() const {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahAdaptiveHeuristics::should_start_gc() const {</span>
    ShenandoahHeap* heap = ShenandoahHeap::heap();
<span class="udiff-line-modified-removed">-   size_t capacity = heap-&gt;capacity();</span>
<span class="udiff-line-modified-added">+   size_t capacity = heap-&gt;max_capacity();</span>
    size_t available = heap-&gt;free_set()-&gt;available();
  
    // Check if we are falling below the worst limit, time to trigger the GC, regardless of
    // anything else.
<span class="udiff-line-modified-removed">-   size_t min_threshold = ShenandoahMinFreeThreshold * heap-&gt;capacity() / 100;</span>
<span class="udiff-line-modified-added">+   size_t min_threshold = capacity / 100 * ShenandoahMinFreeThreshold;</span>
    if (available &lt; min_threshold) {
<span class="udiff-line-modified-removed">-     log_info(gc)(&quot;Trigger: Free (&quot; SIZE_FORMAT &quot;M) is below minimum threshold (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="udiff-line-modified-removed">-                  available / M, min_threshold / M);</span>
<span class="udiff-line-modified-added">+     log_info(gc)(&quot;Trigger: Free (&quot; SIZE_FORMAT &quot;%s) is below minimum threshold (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="udiff-line-modified-added">+                  byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),</span>
<span class="udiff-line-added">+                  byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));</span>
      return true;
    }
  
    // Check if are need to learn a bit about the application
    const size_t max_learn = ShenandoahLearningSteps;
    if (_gc_times_learned &lt; max_learn) {
<span class="udiff-line-modified-removed">-     size_t init_threshold = ShenandoahInitFreeThreshold * heap-&gt;capacity() / 100;</span>
<span class="udiff-line-modified-added">+     size_t init_threshold = capacity / 100 * ShenandoahInitFreeThreshold;</span>
      if (available &lt; init_threshold) {
<span class="udiff-line-modified-removed">-       log_info(gc)(&quot;Trigger: Learning &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT &quot;. Free (&quot; SIZE_FORMAT &quot;M) is below initial threshold (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="udiff-line-modified-removed">-                    _gc_times_learned + 1, max_learn, available / M, init_threshold / M);</span>
<span class="udiff-line-modified-added">+       log_info(gc)(&quot;Trigger: Learning &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT &quot;. Free (&quot; SIZE_FORMAT &quot;%s) is below initial threshold (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="udiff-line-modified-added">+                    _gc_times_learned + 1, max_learn,</span>
<span class="udiff-line-added">+                    byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),</span>
<span class="udiff-line-added">+                    byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));</span>
        return true;
      }
    }
  
    // Check if allocation headroom is still okay. This also factors in:
    //   1. Some space to absorb allocation spikes
    //   2. Accumulated penalties from Degenerated and Full GC
  
    size_t allocation_headroom = available;
  
<span class="udiff-line-modified-removed">-   size_t spike_headroom = ShenandoahAllocSpikeFactor * capacity / 100;</span>
<span class="udiff-line-modified-removed">-   size_t penalties      = _gc_time_penalties         * capacity / 100;</span>
<span class="udiff-line-modified-added">+   size_t spike_headroom = capacity / 100 * ShenandoahAllocSpikeFactor;</span>
<span class="udiff-line-modified-added">+   size_t penalties      = capacity / 100 * _gc_time_penalties;</span>
  
    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);
    allocation_headroom -= MIN2(allocation_headroom, penalties);
  
    // TODO: Allocation rate is way too averaged to be useful during state changes
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,18 +159,23 @@</span>
    double average_gc = _gc_time_history-&gt;avg();
    double time_since_last = time_since_last_gc();
    double allocation_rate = heap-&gt;bytes_allocated_since_gc_start() / time_since_last;
  
    if (average_gc &gt; allocation_headroom / allocation_rate) {
<span class="udiff-line-modified-removed">-     log_info(gc)(&quot;Trigger: Average GC time (%.2f ms) is above the time for allocation rate (%.2f MB/s) to deplete free headroom (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="udiff-line-modified-removed">-                  average_gc * 1000, allocation_rate / M, allocation_headroom / M);</span>
<span class="udiff-line-modified-removed">-     log_info(gc, ergo)(&quot;Free headroom: &quot; SIZE_FORMAT &quot;M (free) - &quot; SIZE_FORMAT &quot;M (spike) - &quot; SIZE_FORMAT &quot;M (penalties) = &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="udiff-line-modified-removed">-                        available / M, spike_headroom / M, penalties / M, allocation_headroom / M);</span>
<span class="udiff-line-modified-added">+     log_info(gc)(&quot;Trigger: Average GC time (%.2f ms) is above the time for allocation rate (%.0f %sB/s) to deplete free headroom (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="udiff-line-modified-added">+                  average_gc * 1000,</span>
<span class="udiff-line-modified-added">+                  byte_size_in_proper_unit(allocation_rate),     proper_unit_for_byte_size(allocation_rate),</span>
<span class="udiff-line-modified-added">+                  byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));</span>
<span class="udiff-line-added">+     log_info(gc, ergo)(&quot;Free headroom: &quot; SIZE_FORMAT &quot;%s (free) - &quot; SIZE_FORMAT &quot;%s (spike) - &quot; SIZE_FORMAT &quot;%s (penalties) = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="udiff-line-added">+                  byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),</span>
<span class="udiff-line-added">+                  byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),</span>
<span class="udiff-line-added">+                  byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),</span>
<span class="udiff-line-added">+                  byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));</span>
      return true;
    }
  
<span class="udiff-line-modified-removed">-   return ShenandoahHeuristics::should_start_normal_gc();</span>
<span class="udiff-line-modified-added">+   return ShenandoahHeuristics::should_start_gc();</span>
  }
  
  bool ShenandoahAdaptiveHeuristics::should_start_update_refs() {
    if (! _update_refs_adaptive) {
      return _update_refs_early;
</pre>
<center><a href="../c2/shenandoahSupport.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahAdaptiveHeuristics.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
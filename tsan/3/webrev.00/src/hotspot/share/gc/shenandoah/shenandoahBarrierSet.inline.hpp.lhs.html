<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 26 
 27 #include &quot;gc/shared/barrierSet.hpp&quot;
<a name="2" id="anc2"></a>
 28 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 29 #include &quot;gc/shenandoah/shenandoahBrooksPointer.inline.hpp&quot;</span>

 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 31 </span>
<span class="line-modified"> 32 bool ShenandoahBarrierSet::need_update_refs_barrier() {</span>
<span class="line-modified"> 33   return _heap-&gt;is_update_refs_in_progress() ||</span>
<span class="line-modified"> 34          _heap-&gt;is_concurrent_traversal_in_progress() ||</span>
<span class="line-modified"> 35          (_heap-&gt;is_concurrent_mark_in_progress() &amp;&amp; _heap-&gt;has_forwarded_objects());</span>
<span class="line-removed"> 36 }</span>
 37 
 38 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
<a name="5" id="anc5"></a><span class="line-modified"> 39   return ShenandoahBrooksPointer::forwardee(p);</span>
 40 }
 41 
 42 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
<a name="6" id="anc6"></a><span class="line-modified"> 43   if (((HeapWord*) p) != NULL) {</span>
 44     return resolve_forwarded_not_null(p);
 45   } else {
 46     return p;
 47   }
 48 }
 49 
<a name="7" id="anc7"></a><span class="line-modified"> 50 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified"> 51 template &lt;typename T&gt;</span>
<span class="line-modified"> 52 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified"> 53   oop res;</span>
<span class="line-modified"> 54   oop expected = compare_value;</span>
<span class="line-modified"> 55   do {</span>
<span class="line-modified"> 56     compare_value = expected;</span>
<span class="line-modified"> 57     res = Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
<span class="line-modified"> 58     expected = res;</span>
<span class="line-modified"> 59   } while ((! oopDesc::equals_raw(compare_value, expected)) &amp;&amp; oopDesc::equals_raw(resolve_forwarded(compare_value), resolve_forwarded(expected)));</span>
<span class="line-modified"> 60   if (oopDesc::equals_raw(expected, compare_value)) {</span>
<span class="line-modified"> 61     if (ShenandoahSATBBarrier &amp;&amp; !CompressedOops::is_null(compare_value)) {</span>
<span class="line-modified"> 62       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(compare_value);</span>









 63     }
 64   }
<a name="8" id="anc8"></a><span class="line-modified"> 65   return res;</span>





































 66 }
 67 
 68 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 69 template &lt;typename T&gt;
<a name="9" id="anc9"></a><span class="line-modified"> 70 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified"> 71   oop previous = Raw::oop_atomic_xchg(new_value, addr);</span>
<span class="line-modified"> 72   if (ShenandoahSATBBarrier) {</span>
<span class="line-modified"> 73     if (!CompressedOops::is_null(previous)) {</span>
<span class="line-modified"> 74       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(previous);</span>


 75     }
 76   }
<a name="10" id="anc10"></a><span class="line-modified"> 77   return previous;</span>
 78 }
 79 
 80 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 81 template &lt;typename T&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 82 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="line-modified"> 83                                                                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,</span>
<span class="line-modified"> 84                                                                                      size_t length) {</span>
<span class="line-modified"> 85   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="line-modified"> 86     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>

 87   }
<a name="12" id="anc12"></a><span class="line-modified"> 88   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="line-modified"> 89     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>









 90   }
<a name="13" id="anc13"></a><span class="line-modified"> 91   Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
 92 }
 93 
<a name="14" id="anc14"></a>
 94 template &lt;typename T&gt;
<a name="15" id="anc15"></a><span class="line-modified"> 95 bool ShenandoahBarrierSet::arraycopy_loop_1(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="line-modified"> 96                                             bool checkcast, bool satb, bool disjoint,</span>
<span class="line-modified"> 97                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-modified"> 98   if (checkcast) {</span>
<span class="line-modified"> 99     return arraycopy_loop_2&lt;T, true&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="line-modified">100   } else {</span>
<span class="line-removed">101     return arraycopy_loop_2&lt;T, false&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="line-removed">102   }</span>
103 }
104 
<a name="16" id="anc16"></a><span class="line-modified">105 template &lt;typename T, bool CHECKCAST&gt;</span>
<span class="line-modified">106 bool ShenandoahBarrierSet::arraycopy_loop_2(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="line-modified">107                                             bool satb, bool disjoint,</span>
<span class="line-modified">108                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-modified">109   if (satb) {</span>
<span class="line-modified">110     return arraycopy_loop_3&lt;T, CHECKCAST, true&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="line-modified">111   } else {</span>
<span class="line-modified">112     return arraycopy_loop_3&lt;T, CHECKCAST, false&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="line-removed">113   }</span>
114 }
115 
<a name="17" id="anc17"></a><span class="line-modified">116 template &lt;typename T, bool CHECKCAST, bool SATB&gt;</span>
<span class="line-modified">117 bool ShenandoahBarrierSet::arraycopy_loop_3(T* src, T* dst, size_t length, Klass* bound, bool disjoint,</span>
<span class="line-modified">118                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-removed">119   switch (storeval_mode) {</span>
<span class="line-removed">120     case NONE:</span>
<span class="line-removed">121       return arraycopy_loop&lt;T, CHECKCAST, SATB, NONE&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">122     case READ_BARRIER:</span>
<span class="line-removed">123       return arraycopy_loop&lt;T, CHECKCAST, SATB, READ_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">124     case WRITE_BARRIER:</span>
<span class="line-removed">125       return arraycopy_loop&lt;T, CHECKCAST, SATB, WRITE_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">126     default:</span>
<span class="line-removed">127       ShouldNotReachHere();</span>
<span class="line-removed">128       return true; // happy compiler</span>
<span class="line-removed">129   }</span>
130 }
131 
<a name="18" id="anc18"></a><span class="line-modified">132 template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="line-modified">133 bool ShenandoahBarrierSet::arraycopy_loop(T* src, T* dst, size_t length, Klass* bound, bool disjoint) {</span>
<span class="line-modified">134   Thread* thread = Thread::current();</span>


135 
<a name="19" id="anc19"></a><span class="line-modified">136   ShenandoahEvacOOMScope oom_evac_scope;</span>
<span class="line-modified">137 </span>
<span class="line-modified">138   // We need to handle four cases:</span>
<span class="line-modified">139   //</span>
<span class="line-modified">140   // a) src &lt; dst, conjoint, can only copy backward only</span>
<span class="line-modified">141   //   [...src...]</span>
<span class="line-modified">142   //         [...dst...]</span>
<span class="line-modified">143   //</span>
<span class="line-modified">144   // b) src &lt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="line-modified">145   //   [...src...]</span>
<span class="line-modified">146   //              [...dst...]</span>
<span class="line-modified">147   //</span>
<span class="line-modified">148   // c) src &gt; dst, conjoint, can copy forward only</span>
<span class="line-removed">149   //         [...src...]</span>
<span class="line-removed">150   //   [...dst...]</span>
<span class="line-removed">151   //</span>
<span class="line-removed">152   // d) src &gt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="line-removed">153   //              [...src...]</span>
<span class="line-removed">154   //   [...dst...]</span>
<span class="line-removed">155   //</span>
<span class="line-removed">156   if (src &gt; dst || disjoint) {</span>
<span class="line-removed">157     // copy forward:</span>
<span class="line-removed">158     T* cur_src = src;</span>
<span class="line-removed">159     T* cur_dst = dst;</span>
<span class="line-removed">160     T* src_end = src + length;</span>
<span class="line-removed">161     for (; cur_src &lt; src_end; cur_src++, cur_dst++) {</span>
<span class="line-removed">162       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="line-removed">163         return false;</span>
<span class="line-removed">164       }</span>
<span class="line-removed">165     }</span>
<span class="line-removed">166   } else {</span>
<span class="line-removed">167     // copy backward:</span>
<span class="line-removed">168     T* cur_src = src + length - 1;</span>
<span class="line-removed">169     T* cur_dst = dst + length - 1;</span>
<span class="line-removed">170     for (; cur_src &gt;= src; cur_src--, cur_dst--) {</span>
<span class="line-removed">171       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="line-removed">172         return false;</span>
<span class="line-removed">173       }</span>
<span class="line-removed">174     }</span>
175   }
<a name="20" id="anc20"></a><span class="line-modified">176   return true;</span>
177 }
178 
<a name="21" id="anc21"></a><span class="line-modified">179 template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="line-modified">180 bool ShenandoahBarrierSet::arraycopy_element(T* cur_src, T* cur_dst, Klass* bound, Thread* thread) {</span>
<span class="line-modified">181   T o = RawAccess&lt;&gt;::oop_load(cur_src);</span>
<span class="line-modified">182 </span>
<span class="line-modified">183   if (SATB) {</span>
<span class="line-removed">184     T prev = RawAccess&lt;&gt;::oop_load(cur_dst);</span>
<span class="line-removed">185     if (!CompressedOops::is_null(prev)) {</span>
<span class="line-removed">186       oop prev_obj = CompressedOops::decode_not_null(prev);</span>
<span class="line-removed">187       enqueue(prev_obj);</span>
<span class="line-removed">188     }</span>
<span class="line-removed">189   }</span>
190 
<a name="22" id="anc22"></a><span class="line-modified">191   if (!CompressedOops::is_null(o)) {</span>
<span class="line-modified">192     oop obj = CompressedOops::decode_not_null(o);</span>


193 
<a name="23" id="anc23"></a><span class="line-modified">194     if (CHECKCAST) {</span>
<span class="line-modified">195       assert(bound != NULL, &quot;need element klass for checkcast&quot;);</span>
<span class="line-modified">196       if (!oopDesc::is_instanceof_or_null(obj, bound)) {</span>
<span class="line-modified">197         return false;</span>
<span class="line-modified">198       }</span>
<span class="line-removed">199     }</span>
200 
<a name="24" id="anc24"></a><span class="line-modified">201     switch (STOREVAL_MODE) {</span>
<span class="line-removed">202     case NONE:</span>
<span class="line-removed">203       break;</span>
<span class="line-removed">204     case READ_BARRIER:</span>
<span class="line-removed">205       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">206       break;</span>
<span class="line-removed">207     case WRITE_BARRIER:</span>
<span class="line-removed">208       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="line-removed">209         oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">210         if (oopDesc::equals_raw(forw, obj)) {</span>
<span class="line-removed">211           forw = _heap-&gt;evacuate_object(forw, thread);</span>
<span class="line-removed">212         }</span>
<span class="line-removed">213         obj = forw;</span>
<span class="line-removed">214       }</span>
<span class="line-removed">215       enqueue(obj);</span>
<span class="line-removed">216       break;</span>
<span class="line-removed">217     default:</span>
<span class="line-removed">218       ShouldNotReachHere();</span>
<span class="line-removed">219     }</span>
220 
<a name="25" id="anc25"></a><span class="line-modified">221     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(cur_dst, obj);</span>
<span class="line-modified">222   } else {</span>
<span class="line-modified">223     // Store null.</span>
<span class="line-modified">224     RawAccess&lt;&gt;::oop_store(cur_dst, o);</span>

225   }
<a name="26" id="anc26"></a><span class="line-modified">226   return true;</span>











227 }
228 
229 // Clone barrier support
230 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
231 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
<a name="27" id="anc27"></a><span class="line-modified">232   src = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src));</span>
<span class="line-modified">233   dst = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst));</span>

234   Raw::clone(src, dst, size);
<a name="28" id="anc28"></a><span class="line-removed">235   ShenandoahBarrierSet::barrier_set()-&gt;write_region(MemRegion((HeapWord*) dst, size));</span>
236 }
237 
238 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
239 template &lt;typename T&gt;
240 bool ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
241                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
242                                                                                          size_t length) {
<a name="29" id="anc29"></a><span class="line-modified">243   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-modified">244   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="line-modified">245     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>
<span class="line-modified">246   }</span>
<span class="line-modified">247   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="line-modified">248     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>


























249   }
<a name="30" id="anc30"></a>
250 
<a name="31" id="anc31"></a><span class="line-modified">251   bool satb = ShenandoahSATBBarrier &amp;&amp; heap-&gt;is_concurrent_mark_in_progress();</span>
<span class="line-modified">252   bool checkcast = HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value;</span>
<span class="line-modified">253   bool disjoint = HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value;</span>
<span class="line-modified">254   ArrayCopyStoreValMode storeval_mode;</span>
<span class="line-modified">255   if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-removed">256     if (heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-removed">257       storeval_mode = WRITE_BARRIER;</span>
<span class="line-removed">258     } else if (heap-&gt;is_concurrent_mark_in_progress() || heap-&gt;is_update_refs_in_progress()) {</span>
<span class="line-removed">259       storeval_mode = READ_BARRIER;</span>
260     } else {
<a name="32" id="anc32"></a><span class="line-modified">261       assert(heap-&gt;is_idle() || heap-&gt;is_evacuation_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="line-removed">262       storeval_mode = NONE; // E.g. during evac or outside cycle</span>
263     }
<a name="33" id="anc33"></a><span class="line-removed">264   } else {</span>
<span class="line-removed">265     assert(heap-&gt;is_stable() || heap-&gt;is_concurrent_mark_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="line-removed">266     storeval_mode = NONE;</span>
267   }
268 
<a name="34" id="anc34"></a><span class="line-modified">269   if (!satb &amp;&amp; !checkcast &amp;&amp; storeval_mode == NONE) {</span>
<span class="line-modified">270     // Short-circuit to bulk copy.</span>
<span class="line-modified">271     return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>


















272   }
<a name="35" id="anc35"></a>
273 
<a name="36" id="anc36"></a><span class="line-modified">274   src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);</span>
<span class="line-modified">275   dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);</span>

276 
<a name="37" id="anc37"></a><span class="line-modified">277   Klass* bound = objArrayOop(dst_obj)-&gt;element_klass();</span>
<span class="line-modified">278   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-removed">279   return bs-&gt;arraycopy_loop_1(src_raw, dst_raw, length, bound, checkcast, satb, disjoint, storeval_mode);</span>
280 }
281 
282 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
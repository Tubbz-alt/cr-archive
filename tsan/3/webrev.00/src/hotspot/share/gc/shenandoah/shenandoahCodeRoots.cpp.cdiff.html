<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetAssembler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,14 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
<span class="line-removed">- #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  
  ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
    _length = heaps-&gt;length();
    _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
    for (int h = 0; h &lt; _length; h++) {
<span class="line-new-header">--- 22,21 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
<span class="line-added">+ #include &quot;code/icBuffer.hpp&quot;</span>
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
    _length = heaps-&gt;length();
    _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
    for (int h = 0; h &lt; _length; h++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
  
    for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != NULL; cb = CodeCache::next_blob(_heap, cb)) {
      int current = count++;
      if ((current &amp; stride_mask) == 0) {
        process_block = (current &gt;= _claimed_idx) &amp;&amp;
<span class="line-modified">!                       (Atomic::cmpxchg(current + stride, &amp;_claimed_idx, current) == current);</span>
      }
      if (process_block) {
        if (cb-&gt;is_alive()) {
          f-&gt;do_code_blob(cb);
  #ifdef ASSERT
<span class="line-new-header">--- 85,11 ---</span>
  
    for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != NULL; cb = CodeCache::next_blob(_heap, cb)) {
      int current = count++;
      if ((current &amp; stride_mask) == 0) {
        process_block = (current &gt;= _claimed_idx) &amp;&amp;
<span class="line-modified">!                       (Atomic::cmpxchg(&amp;_claimed_idx, current, current + stride) == current);</span>
      }
      if (process_block) {
        if (cb-&gt;is_alive()) {
          f-&gt;do_code_blob(cb);
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,155 ***</span>
    }
  
    _finished = true;
  }
  
<span class="line-modified">! class ShenandoahNMethodOopDetector : public OopClosure {</span>
<span class="line-modified">! private:</span>
<span class="line-removed">-   ResourceMark rm; // For growable array allocation below.</span>
<span class="line-removed">-   GrowableArray&lt;oop*&gt; _oops;</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahNMethodOopDetector() : _oops(10) {};</span>
  
<span class="line-modified">!   void do_oop(oop* o) {</span>
<span class="line-modified">!     _oops.append(o);</span>
<span class="line-modified">!   }</span>
<span class="line-removed">-   void do_oop(narrowOop* o) {</span>
<span class="line-removed">-     fatal(&quot;NMethods should not have compressed oops embedded.&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   GrowableArray&lt;oop*&gt;* oops() {</span>
<span class="line-removed">-     return &amp;_oops;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool has_oops() {</span>
<span class="line-removed">-     return !_oops.is_empty();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ShenandoahNMethodOopInitializer : public OopClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahHeap* const _heap;</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahNMethodOopInitializer() : _heap(ShenandoahHeap::heap()) {};</span>
  
<span class="line-modified">! private:</span>
<span class="line-modified">!   template &lt;class T&gt;</span>
<span class="line-modified">!   inline void do_oop_work(T* p) {</span>
<span class="line-modified">!     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-modified">!     if (! CompressedOops::is_null(o)) {</span>
<span class="line-modified">!       oop obj1 = CompressedOops::decode_not_null(o);</span>
<span class="line-modified">!       oop obj2 = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(obj1);</span>
<span class="line-modified">!       if (! oopDesc::equals_raw(obj1, obj2)) {</span>
<span class="line-modified">!         shenandoah_assert_not_in_cset(NULL, obj2);</span>
<span class="line-removed">-         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj2);</span>
<span class="line-removed">-         if (_heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-removed">-           ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj2);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
      }
    }
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   void do_oop(oop* o) {</span>
<span class="line-removed">-     do_oop_work(o);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   void do_oop(narrowOop* o) {</span>
<span class="line-removed">-     do_oop_work(o);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- ShenandoahCodeRoots::PaddedLock ShenandoahCodeRoots::_recorded_nms_lock;</span>
<span class="line-removed">- GrowableArray&lt;ShenandoahNMethod*&gt;* ShenandoahCodeRoots::_recorded_nms;</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ShenandoahCodeRoots::initialize() {</span>
<span class="line-removed">-   _recorded_nms_lock._lock = 0;</span>
<span class="line-removed">-   _recorded_nms = new (ResourceObj::C_HEAP, mtGC) GrowableArray&lt;ShenandoahNMethod*&gt;(100, true, mtGC);</span>
  }
  
<span class="line-modified">! void ShenandoahCodeRoots::add_nmethod(nmethod* nm) {</span>
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
<span class="line-removed">-       ShenandoahNMethodOopInitializer init;</span>
<span class="line-removed">-       nm-&gt;oops_do(&amp;init);</span>
<span class="line-removed">-       nm-&gt;fix_oop_relocations();</span>
        break;
      }
      case 2: {
<span class="line-modified">!       ShenandoahNMethodOopDetector detector;</span>
<span class="line-modified">!       nm-&gt;oops_do(&amp;detector);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (detector.has_oops()) {</span>
<span class="line-removed">-         ShenandoahNMethodOopInitializer init;</span>
<span class="line-removed">-         nm-&gt;oops_do(&amp;init);</span>
<span class="line-removed">-         nm-&gt;fix_oop_relocations();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ShenandoahNMethod* nmr = new ShenandoahNMethod(nm, detector.oops());</span>
<span class="line-removed">-         nmr-&gt;assert_alive_and_correct();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ShenandoahCodeRootsLock lock(true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int idx = _recorded_nms-&gt;find(nm, ShenandoahNMethod::find_with_nmethod);</span>
<span class="line-removed">-         if (idx != -1) {</span>
<span class="line-removed">-           ShenandoahNMethod* old = _recorded_nms-&gt;at(idx);</span>
<span class="line-removed">-           _recorded_nms-&gt;at_put(idx, nmr);</span>
<span class="line-removed">-           delete old;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           _recorded_nms-&gt;append(nmr);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
<span class="line-modified">! };</span>
  
<span class="line-modified">! void ShenandoahCodeRoots::remove_nmethod(nmethod* nm) {</span>
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
        break;
      }
      case 2: {
<span class="line-modified">!       ShenandoahNMethodOopDetector detector;</span>
<span class="line-modified">!       nm-&gt;oops_do(&amp;detector, /* allow_zombie = */ true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (detector.has_oops()) {</span>
<span class="line-removed">-         ShenandoahCodeRootsLock lock(true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int idx = _recorded_nms-&gt;find(nm, ShenandoahNMethod::find_with_nmethod);</span>
<span class="line-removed">-         assert(idx != -1, &quot;nmethod &quot; PTR_FORMAT &quot; should be registered&quot;, p2i(nm));</span>
<span class="line-removed">-         ShenandoahNMethod* old = _recorded_nms-&gt;at(idx);</span>
<span class="line-removed">-         old-&gt;assert_same_oops(detector.oops());</span>
<span class="line-removed">-         _recorded_nms-&gt;delete_at(idx);</span>
<span class="line-removed">-         delete old;</span>
<span class="line-removed">-       }</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
  }
  
  ShenandoahCodeRootsIterator::ShenandoahCodeRootsIterator() :
<span class="line-removed">-         _heap(ShenandoahHeap::heap()),</span>
          _par_iterator(CodeCache::heaps()),
<span class="line-modified">!         _claimed(0) {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
    assert(!Thread::current()-&gt;is_Worker_thread(), &quot;Should not be acquired by workers&quot;);
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
        // No need to do anything here
        break;
      }
      case 2: {
<span class="line-modified">!       ShenandoahCodeRoots::acquire_lock(false);</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
<span class="line-new-header">--- 101,257 ---</span>
    }
  
    _finished = true;
  }
  
<span class="line-modified">! ShenandoahNMethodTable* ShenandoahCodeRoots::_nmethod_table;</span>
<span class="line-modified">! int ShenandoahCodeRoots::_disarmed_value = 1;</span>
  
<span class="line-modified">! void ShenandoahCodeRoots::initialize() {</span>
<span class="line-modified">!   _nmethod_table = new ShenandoahNMethodTable();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ShenandoahCodeRoots::register_nmethod(nmethod* nm) {</span>
<span class="line-modified">!   switch (ShenandoahCodeRootsStyle) {</span>
<span class="line-modified">!     case 0:</span>
<span class="line-modified">!     case 1:</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case 2: {</span>
<span class="line-modified">!       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">!       _nmethod_table-&gt;register_nmethod(nm);</span>
<span class="line-modified">!       break;</span>
      }
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
    }
  }
  
<span class="line-modified">! void ShenandoahCodeRoots::unregister_nmethod(nmethod* nm) {</span>
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
        break;
      }
      case 2: {
<span class="line-modified">!       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">!       _nmethod_table-&gt;unregister_nmethod(nm);</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ShenandoahCodeRoots::flush_nmethod(nmethod* nm) {</span>
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
        break;
      }
      case 2: {
<span class="line-modified">!       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">!       _nmethod_table-&gt;flush_nmethod(nm);</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
  }
  
<span class="line-added">+ void ShenandoahCodeRoots::arm_nmethods() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+   _disarmed_value ++;</span>
<span class="line-added">+   // 0 is reserved for new nmethod</span>
<span class="line-added">+   if (_disarmed_value == 0) {</span>
<span class="line-added">+     _disarmed_value = 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   JavaThreadIteratorWithHandle jtiwh;</span>
<span class="line-added">+   for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-added">+     ShenandoahThreadLocalData::set_disarmed_value(thr, _disarmed_value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahNMethodUnlinkClosure : public NMethodClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   bool            _unloading_occurred;</span>
<span class="line-added">+   volatile bool   _failed;</span>
<span class="line-added">+   ShenandoahHeap* _heap;</span>
<span class="line-added">+ </span>
<span class="line-added">+   void set_failed() {</span>
<span class="line-added">+     Atomic::store(&amp;_failed, true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+    void unlink(nmethod* nm) {</span>
<span class="line-added">+      // Unlinking of the dependencies must happen before the</span>
<span class="line-added">+      // handshake separating unlink and purge.</span>
<span class="line-added">+      nm-&gt;flush_dependencies(false /* delete_immediately */);</span>
<span class="line-added">+ </span>
<span class="line-added">+      // unlink_from_method will take the CompiledMethod_lock.</span>
<span class="line-added">+      // In this case we don&#39;t strictly need it when unlinking nmethods from</span>
<span class="line-added">+      // the Method, because it is only concurrently unlinked by</span>
<span class="line-added">+      // the entry barrier, which acquires the per nmethod lock.</span>
<span class="line-added">+      nm-&gt;unlink_from_method();</span>
<span class="line-added">+ </span>
<span class="line-added">+      if (nm-&gt;is_osr_method()) {</span>
<span class="line-added">+        // Invalidate the osr nmethod only once</span>
<span class="line-added">+        nm-&gt;invalidate_osr_method();</span>
<span class="line-added">+      }</span>
<span class="line-added">+    }</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahNMethodUnlinkClosure(bool unloading_occurred) :</span>
<span class="line-added">+       _unloading_occurred(unloading_occurred),</span>
<span class="line-added">+       _failed(false),</span>
<span class="line-added">+       _heap(ShenandoahHeap::heap()) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void do_nmethod(nmethod* nm) {</span>
<span class="line-added">+     assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only this phase&quot;);</span>
<span class="line-added">+     if (failed()) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ShenandoahNMethod* nm_data = ShenandoahNMethod::gc_data(nm);</span>
<span class="line-added">+     assert(!nm_data-&gt;is_unregistered(), &quot;Should not see unregistered entry&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!nm-&gt;is_alive()) {</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (nm-&gt;is_unloading()) {</span>
<span class="line-added">+       ShenandoahReentrantLocker locker(nm_data-&gt;lock());</span>
<span class="line-added">+       unlink(nm);</span>
<span class="line-added">+       return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ShenandoahReentrantLocker locker(nm_data-&gt;lock());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Heal oops and disarm</span>
<span class="line-added">+     if (_heap-&gt;is_evacuation_in_progress()) {</span>
<span class="line-added">+       ShenandoahNMethod::heal_nmethod(nm);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ShenandoahNMethod::disarm_nmethod(nm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Clear compiled ICs and exception caches</span>
<span class="line-added">+     if (!nm-&gt;unload_nmethod_caches(_unloading_occurred)) {</span>
<span class="line-added">+       set_failed();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool failed() const {</span>
<span class="line-added">+     return Atomic::load(&amp;_failed);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahUnlinkTask : public AbstractGangTask {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahNMethodUnlinkClosure      _cl;</span>
<span class="line-added">+   ICRefillVerifier*                   _verifier;</span>
<span class="line-added">+   ShenandoahConcurrentNMethodIterator _iterator;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahUnlinkTask(bool unloading_occurred, ICRefillVerifier* verifier) :</span>
<span class="line-added">+     AbstractGangTask(&quot;ShenandoahNMethodUnlinkTask&quot;),</span>
<span class="line-added">+     _cl(unloading_occurred),</span>
<span class="line-added">+     _verifier(verifier),</span>
<span class="line-added">+     _iterator(ShenandoahCodeRoots::table()) {</span>
<span class="line-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+     _iterator.nmethods_do_begin();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~ShenandoahUnlinkTask() {</span>
<span class="line-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+     _iterator.nmethods_do_end();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void work(uint worker_id) {</span>
<span class="line-added">+     ICRefillVerifierMark mark(_verifier);</span>
<span class="line-added">+     _iterator.nmethods_do(&amp;_cl);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool success() const {</span>
<span class="line-added">+     return !_cl.failed();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahCodeRoots::unlink(WorkGang* workers, bool unloading_occurred) {</span>
<span class="line-added">+   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),</span>
<span class="line-added">+          &quot;Only when running concurrent class unloading&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (;;) {</span>
<span class="line-added">+     ICRefillVerifier verifier;</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahUnlinkTask task(unloading_occurred, &amp;verifier);</span>
<span class="line-added">+       workers-&gt;run_task(&amp;task);</span>
<span class="line-added">+       if (task.success()) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Cleaning failed because we ran out of transitional IC stubs,</span>
<span class="line-added">+     // so we have to refill and try again. Refilling requires taking</span>
<span class="line-added">+     // a safepoint, so we temporarily leave the suspendible thread set.</span>
<span class="line-added">+     SuspendibleThreadSetLeaver sts;</span>
<span class="line-added">+     InlineCacheBuffer::refill_ic_stubs();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahNMethodPurgeClosure : public NMethodClosure {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   virtual void do_nmethod(nmethod* nm) {</span>
<span class="line-added">+     if (nm-&gt;is_alive() &amp;&amp; nm-&gt;is_unloading()) {</span>
<span class="line-added">+       nm-&gt;make_unloaded();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahNMethodPurgeTask : public AbstractGangTask {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahNMethodPurgeClosure       _cl;</span>
<span class="line-added">+   ShenandoahConcurrentNMethodIterator _iterator;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahNMethodPurgeTask() :</span>
<span class="line-added">+     AbstractGangTask(&quot;ShenandoahNMethodPurgeTask&quot;),</span>
<span class="line-added">+     _cl(),</span>
<span class="line-added">+     _iterator(ShenandoahCodeRoots::table()) {</span>
<span class="line-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+     _iterator.nmethods_do_begin();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~ShenandoahNMethodPurgeTask() {</span>
<span class="line-added">+     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+     _iterator.nmethods_do_end();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void work(uint worker_id) {</span>
<span class="line-added">+     _iterator.nmethods_do(&amp;_cl);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahCodeRoots::purge(WorkGang* workers) {</span>
<span class="line-added">+   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),</span>
<span class="line-added">+          &quot;Only when running concurrent class unloading&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ShenandoahNMethodPurgeTask task;</span>
<span class="line-added">+   workers-&gt;run_task(&amp;task);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ShenandoahCodeRootsIterator::ShenandoahCodeRootsIterator() :
          _par_iterator(CodeCache::heaps()),
<span class="line-modified">!         _table_snapshot(NULL) {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
    assert(!Thread::current()-&gt;is_Worker_thread(), &quot;Should not be acquired by workers&quot;);
    switch (ShenandoahCodeRootsStyle) {
      case 0:
      case 1: {
        // No need to do anything here
        break;
      }
      case 2: {
<span class="line-modified">!       CodeCache_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-added">+       _table_snapshot = ShenandoahCodeRoots::table()-&gt;snapshot_for_iteration();</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
      case 1: {
        // No need to do anything here
        break;
      }
      case 2: {
<span class="line-modified">!       ShenandoahCodeRoots::release_lock(false);</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
<span class="line-new-header">--- 363,13 ---</span>
      case 1: {
        // No need to do anything here
        break;
      }
      case 2: {
<span class="line-modified">!       ShenandoahCodeRoots::table()-&gt;finish_iteration(_table_snapshot);</span>
<span class="line-added">+       _table_snapshot = NULL;</span>
<span class="line-added">+       CodeCache_lock-&gt;unlock();</span>
        break;
      }
      default:
        ShouldNotReachHere();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,18 ***</span>
      default:
        ShouldNotReachHere();
    }
  }
  
<span class="line-removed">- ShenandoahAllCodeRootsIterator ShenandoahCodeRoots::iterator() {</span>
<span class="line-removed">-   return ShenandoahAllCodeRootsIterator();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ShenandoahCsetCodeRootsIterator ShenandoahCodeRoots::cset_iterator() {</span>
<span class="line-removed">-   return ShenandoahCsetCodeRootsIterator();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ShenandoahAllCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
    ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;false&gt;(f);
  }
  
  void ShenandoahCsetCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
<span class="line-new-header">--- 395,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,75 ***</span>
  }
  
  template &lt;bool CSET_FILTER&gt;
  void ShenandoahCodeRootsIterator::fast_parallel_blobs_do(CodeBlobClosure *f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!   size_t stride = 256; // educated guess</span>
<span class="line-removed">- </span>
<span class="line-removed">-   GrowableArray&lt;ShenandoahNMethod*&gt;* list = ShenandoahCodeRoots::_recorded_nms;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   size_t max = (size_t)list-&gt;length();</span>
<span class="line-removed">-   while (_claimed &lt; max) {</span>
<span class="line-removed">-     size_t cur = Atomic::add(stride, &amp;_claimed) - stride;</span>
<span class="line-removed">-     size_t start = cur;</span>
<span class="line-removed">-     size_t end = MIN2(cur + stride, max);</span>
<span class="line-removed">-     if (start &gt;= max) break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (size_t idx = start; idx &lt; end; idx++) {</span>
<span class="line-removed">-       ShenandoahNMethod* nmr = list-&gt;at((int) idx);</span>
<span class="line-removed">-       nmr-&gt;assert_alive_and_correct();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (CSET_FILTER &amp;&amp; !nmr-&gt;has_cset_oops(_heap)) {</span>
<span class="line-removed">-         continue;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       f-&gt;do_code_blob(nmr-&gt;nm());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- ShenandoahNMethod::ShenandoahNMethod(nmethod* nm, GrowableArray&lt;oop*&gt;* oops) {</span>
<span class="line-removed">-   _nm = nm;</span>
<span class="line-removed">-   _oops = NEW_C_HEAP_ARRAY(oop*, oops-&gt;length(), mtGC);</span>
<span class="line-removed">-   _oops_count = oops-&gt;length();</span>
<span class="line-removed">-   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">-     _oops[c] = oops-&gt;at(c);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ShenandoahNMethod::~ShenandoahNMethod() {</span>
<span class="line-removed">-   if (_oops != NULL) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(oop*, _oops);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {</span>
<span class="line-removed">-   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">-     oop o = RawAccess&lt;&gt;::oop_load(_oops[c]);</span>
<span class="line-removed">-     if (heap-&gt;in_collection_set(o)) {</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">- void ShenandoahNMethod::assert_alive_and_correct() {</span>
<span class="line-removed">-   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);</span>
<span class="line-removed">-   assert(_oops_count &gt; 0, &quot;should have filtered nmethods without oops before&quot;);</span>
<span class="line-removed">-   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-removed">-   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">-     oop *loc = _oops[c];</span>
<span class="line-removed">-     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);</span>
<span class="line-removed">-     oop o = RawAccess&lt;&gt;::oop_load(loc);</span>
<span class="line-removed">-     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ShenandoahNMethod::assert_same_oops(GrowableArray&lt;oop*&gt;* oops) {</span>
<span class="line-removed">-   assert(_oops_count == oops-&gt;length(), &quot;should have the same number of oop*&quot;);</span>
<span class="line-removed">-   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">-     assert(_oops[c] == oops-&gt;at(c), &quot;should be the same oop*&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-new-header">--- 406,9 ---</span>
  }
  
  template &lt;bool CSET_FILTER&gt;
  void ShenandoahCodeRootsIterator::fast_parallel_blobs_do(CodeBlobClosure *f) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
<span class="line-modified">!   assert(_table_snapshot != NULL, &quot;Sanity&quot;);</span>
<span class="line-modified">!   _table_snapshot-&gt;parallel_blobs_do&lt;CSET_FILTER&gt;(f);</span>
  }
  
</pre>
<center><a href="shenandoahBarrierSetAssembler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
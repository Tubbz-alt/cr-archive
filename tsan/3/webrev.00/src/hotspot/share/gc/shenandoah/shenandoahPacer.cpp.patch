diff a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp
@@ -1,7 +1,8 @@
 /*
  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -24,10 +25,11 @@
 #include "precompiled.hpp"
 
 #include "gc/shenandoah/shenandoahFreeSet.hpp"
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahPacer.hpp"
+#include "runtime/atomic.hpp"
 
 /*
  * In normal concurrent cycle, we have to pace the application to let GC finish.
  *
  * Here, we do not know how large would be the collection set, and what are the
@@ -68,13 +70,16 @@
   tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
-  log_info(gc, ergo)("Pacer for Mark. Expected Live: " SIZE_FORMAT "M, Free: " SIZE_FORMAT
-                     "M, Non-Taxable: " SIZE_FORMAT "M, Alloc Tax Rate: %.1fx",
-                     live / M, free / M, non_taxable / M, tax);
+  log_info(gc, ergo)("Pacer for Mark. Expected Live: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
+                     "Non-Taxable: " SIZE_FORMAT "%s, Alloc Tax Rate: %.1fx",
+                     byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),
+                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
+                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
+                     tax);
 }
 
 void ShenandoahPacer::setup_for_evac() {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -89,13 +94,16 @@
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
-  log_info(gc, ergo)("Pacer for Evacuation. Used CSet: " SIZE_FORMAT "M, Free: " SIZE_FORMAT
-                     "M, Non-Taxable: " SIZE_FORMAT "M, Alloc Tax Rate: %.1fx",
-                     used / M, free / M, non_taxable / M, tax);
+  log_info(gc, ergo)("Pacer for Evacuation. Used CSet: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
+                     "Non-Taxable: " SIZE_FORMAT "%s, Alloc Tax Rate: %.1fx",
+                     byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
+                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
+                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
+                     tax);
 }
 
 void ShenandoahPacer::setup_for_updaterefs() {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
@@ -110,13 +118,16 @@
   tax = MAX2<double>(1, tax);        // never allocate more than GC processes during the phase
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
-  log_info(gc, ergo)("Pacer for Update Refs. Used: " SIZE_FORMAT "M, Free: " SIZE_FORMAT
-                     "M, Non-Taxable: " SIZE_FORMAT "M, Alloc Tax Rate: %.1fx",
-                     used / M, free / M, non_taxable / M, tax);
+  log_info(gc, ergo)("Pacer for Update Refs. Used: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
+                     "Non-Taxable: " SIZE_FORMAT "%s, Alloc Tax Rate: %.1fx",
+                     byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),
+                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
+                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
+                     tax);
 }
 
 /*
  * Traversal walks the entire heap once, and therefore we have to make assumptions about its
  * liveness, like concurrent mark does.
@@ -134,13 +145,16 @@
   double tax = 1.0 * live / taxable; // base tax for available free space
   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 
   restart_with(non_taxable, tax);
 
-  log_info(gc, ergo)("Pacer for Traversal. Expected Live: " SIZE_FORMAT "M, Free: " SIZE_FORMAT
-                     "M, Non-Taxable: " SIZE_FORMAT "M, Alloc Tax Rate: %.1fx",
-                     live / M, free / M, non_taxable / M, tax);
+  log_info(gc, ergo)("Pacer for Traversal. Expected Live: " SIZE_FORMAT "%s, Free: " SIZE_FORMAT "%s, "
+                     "Non-Taxable: " SIZE_FORMAT "%s, Alloc Tax Rate: %.1fx",
+                     byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),
+                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),
+                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),
+                     tax);
 }
 
 /*
  * In idle phase, we have to pace the application to let control thread react with GC start.
  *
@@ -151,37 +165,38 @@
  */
 
 void ShenandoahPacer::setup_for_idle() {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
 
-  size_t initial = _heap->capacity() * ShenandoahPacingIdleSlack / 100;
+  size_t initial = _heap->max_capacity() / 100 * ShenandoahPacingIdleSlack;
   double tax = 1;
 
   restart_with(initial, tax);
 
-  log_info(gc, ergo)("Pacer for Idle. Initial: " SIZE_FORMAT "M, Alloc Tax Rate: %.1fx",
-                     initial / M, tax);
+  log_info(gc, ergo)("Pacer for Idle. Initial: " SIZE_FORMAT "%s, Alloc Tax Rate: %.1fx",
+                     byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial),
+                     tax);
 }
 
 size_t ShenandoahPacer::update_and_get_progress_history() {
   if (_progress == -1) {
     // First initialization, report some prior
-    Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &_progress);
-    return (size_t) (_heap->capacity() * 0.1);
+    Atomic::store(&_progress, (intptr_t)PACING_PROGRESS_ZERO);
+    return (size_t) (_heap->max_capacity() * 0.1);
   } else {
     // Record history, and reply historical data
     _progress_history->add(_progress);
-    Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &_progress);
+    Atomic::store(&_progress, (intptr_t)PACING_PROGRESS_ZERO);
     return (size_t) (_progress_history->avg() * HeapWordSize);
   }
 }
 
 void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
   size_t initial = (size_t)(non_taxable_bytes * tax_rate) >> LogHeapWordSize;
   STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));
-  Atomic::xchg((intptr_t)initial, &_budget);
-  Atomic::store(tax_rate, &_tax_rate);
+  Atomic::xchg(&_budget, (intptr_t)initial);
+  Atomic::store(&_tax_rate, tax_rate);
   Atomic::inc(&_epoch);
 }
 
 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
@@ -195,11 +210,11 @@
     if (cur < tax && !force) {
       // Progress depleted, alas.
       return false;
     }
     new_val = cur - tax;
-  } while (Atomic::cmpxchg(new_val, &_budget, cur) != cur);
+  } while (Atomic::cmpxchg(&_budget, cur, new_val) != cur);
   return true;
 }
 
 void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
   assert(ShenandoahPacing, "Only be here when pacing is enabled");
@@ -208,11 +223,11 @@
     // Stale ticket, no need to unpace.
     return;
   }
 
   intptr_t tax = MAX2<intptr_t>(1, words * Atomic::load(&_tax_rate));
-  Atomic::add(tax, &_budget);
+  Atomic::add(&_budget, tax);
 }
 
 intptr_t ShenandoahPacer::epoch() {
   return Atomic::load(&_epoch);
 }
@@ -223,10 +238,19 @@
   // Fast path: try to allocate right away
   if (claim_for_alloc(words, false)) {
     return;
   }
 
+  // Threads that are attaching should not block at all: they are not
+  // fully initialized yet. Calling sleep() on them would be awkward.
+  // This is probably the path that allocates the thread oop itself.
+  // Forcefully claim without waiting.
+  if (JavaThread::current()->is_attaching_via_jni()) {
+    claim_for_alloc(words, true);
+    return;
+  }
+
   size_t max = ShenandoahPacingMaxDelay;
   double start = os::elapsedTime();
 
   size_t total = 0;
   size_t cur = 0;
@@ -240,11 +264,11 @@
     if (total + cur > max) {
       cur = (max > total) ? (max - total) : 0;
     }
     cur = MAX2<size_t>(1, cur);
 
-    os::sleep(Thread::current(), cur, true);
+    JavaThread::current()->sleep(cur);
 
     double end = os::elapsedTime();
     total = (size_t)((end - start) * 1000);
 
     if (total > max) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahThreadLocalData.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 26 
 27 #include &quot;gc/shared/plab.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<a name="2" id="anc2"></a>
 29 #include &quot;gc/shenandoah/shenandoahSATBMarkQueueSet.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/sizes.hpp&quot;
 33 
 34 class ShenandoahThreadLocalData {
 35 public:
 36   static const uint INVALID_WORKER_ID = uint(-1);
 37 
 38 private:
 39   char _gc_state;
 40   char _oom_during_evac;
 41   ShenandoahSATBMarkQueue _satb_mark_queue;
 42   PLAB* _gclab;
 43   size_t _gclab_size;
 44   uint  _worker_id;
 45   bool _force_satb_flush;
<a name="3" id="anc3"></a>
 46 
 47   ShenandoahThreadLocalData() :
 48     _gc_state(0),
 49     _oom_during_evac(0),
 50     _satb_mark_queue(&amp;ShenandoahBarrierSet::satb_mark_queue_set()),
 51     _gclab(NULL),
 52     _gclab_size(0),
 53     _worker_id(INVALID_WORKER_ID),
 54     _force_satb_flush(false) {
 55   }
 56 
 57   ~ShenandoahThreadLocalData() {
 58     if (_gclab != NULL) {
 59       delete _gclab;
 60     }
 61   }
 62 
 63   static ShenandoahThreadLocalData* data(Thread* thread) {
 64     assert(UseShenandoahGC, &quot;Sanity&quot;);
 65     return thread-&gt;gc_data&lt;ShenandoahThreadLocalData&gt;();
 66   }
 67 
 68   static ByteSize satb_mark_queue_offset() {
 69     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _satb_mark_queue);
 70   }
 71 
 72 public:
 73   static void create(Thread* thread) {
 74     new (data(thread)) ShenandoahThreadLocalData();
 75   }
 76 
 77   static void destroy(Thread* thread) {
 78     data(thread)-&gt;~ShenandoahThreadLocalData();
 79   }
 80 
 81   static SATBMarkQueue&amp; satb_mark_queue(Thread* thread) {
 82     return data(thread)-&gt;_satb_mark_queue;
 83   }
 84 
 85   static bool is_oom_during_evac(Thread* thread) {
 86     return (data(thread)-&gt;_oom_during_evac &amp; 1) == 1;
 87   }
 88 
 89   static void set_oom_during_evac(Thread* thread, bool oom) {
 90     if (oom) {
 91       data(thread)-&gt;_oom_during_evac |= 1;
 92     } else {
 93       data(thread)-&gt;_oom_during_evac &amp;= ~1;
 94     }
 95   }
 96 
 97   static void set_gc_state(Thread* thread, char gc_state) {
 98     data(thread)-&gt;_gc_state = gc_state;
 99   }
100 
101   static char gc_state(Thread* thread) {
102     return data(thread)-&gt;_gc_state;
103   }
104 
105   static void set_worker_id(Thread* thread, uint id) {
106     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
107     data(thread)-&gt;_worker_id = id;
108   }
109 
110   static uint worker_id(Thread* thread) {
111     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
112     return data(thread)-&gt;_worker_id;
113   }
114 
115   static void set_force_satb_flush(Thread* thread, bool v) {
116     data(thread)-&gt;_force_satb_flush = v;
117   }
118 
119   static bool is_force_satb_flush(Thread* thread) {
120     return data(thread)-&gt;_force_satb_flush;
121   }
122 
123   static void initialize_gclab(Thread* thread) {
124     assert (thread-&gt;is_Java_thread() || thread-&gt;is_Worker_thread(), &quot;Only Java and GC worker threads are allowed to get GCLABs&quot;);
125     assert(data(thread)-&gt;_gclab == NULL, &quot;Only initialize once&quot;);
126     data(thread)-&gt;_gclab = new PLAB(PLAB::min_size());
127     data(thread)-&gt;_gclab_size = 0;
<a name="4" id="anc4"></a>
128   }
129 
130   static PLAB* gclab(Thread* thread) {
131     return data(thread)-&gt;_gclab;
132   }
133 
134   static size_t gclab_size(Thread* thread) {
135     return data(thread)-&gt;_gclab_size;
136   }
137 
138   static void set_gclab_size(Thread* thread, size_t v) {
139     data(thread)-&gt;_gclab_size = v;
140   }
141 
<a name="5" id="anc5"></a>



142 #ifdef ASSERT
143   static void set_evac_allowed(Thread* thread, bool evac_allowed) {
144     if (evac_allowed) {
145       data(thread)-&gt;_oom_during_evac |= 2;
146     } else {
147       data(thread)-&gt;_oom_during_evac &amp;= ~2;
148     }
149   }
150 
151   static bool is_evac_allowed(Thread* thread) {
152     return (data(thread)-&gt;_oom_during_evac &amp; 2) == 2;
153   }
154 #endif
155 
156   // Offsets
157   static ByteSize satb_mark_queue_active_offset() {
158     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();
159   }
160 
161   static ByteSize satb_mark_queue_index_offset() {
162     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_index();
163   }
164 
165   static ByteSize satb_mark_queue_buffer_offset() {
166     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_buf();
167   }
168 
169   static ByteSize gc_state_offset() {
170     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _gc_state);
171   }
172 
<a name="6" id="anc6"></a>


173 };
174 
175 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
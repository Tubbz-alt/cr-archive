<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
   * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,11 +25,11 @@</span>
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  #include &quot;opto/arraycopynode.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,387 +40,37 @@</span>
  #include &quot;opto/phaseX.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierNode::skip_through_barrier(Node* n) {</span>
<span class="udiff-line-modified-removed">-   if (n == NULL) {</span>
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-modified-removed">-     n = n-&gt;in(1);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-modified-removed">-     return n-&gt;in(ValueIn);</span>
<span class="udiff-line-modified-removed">-   } else if (n-&gt;is_Phi() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              n-&gt;req() == 3 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              n-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(1)-&gt;is_ShenandoahBarrier() &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(2) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(2)-&gt;is_IfProj() &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(0)-&gt;in(1)-&gt;in(0) == n-&gt;in(0)-&gt;in(2)-&gt;in(0) &amp;&amp;</span>
<span class="udiff-line-removed">-              n-&gt;in(1)-&gt;in(ValueIn)-&gt;Opcode() == Op_CastPP) {</span>
<span class="udiff-line-removed">-     Node* iff = n-&gt;in(0)-&gt;in(1)-&gt;in(0);</span>
<span class="udiff-line-removed">-     Node* res = n-&gt;in(1)-&gt;in(ValueIn)-&gt;in(1);</span>
<span class="udiff-line-removed">-     if (iff-&gt;is_If() &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;is_Bool() &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) == res &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-         iff-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-removed">-       return res;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return n;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierNode::needs_barrier(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace) {</span>
<span class="udiff-line-removed">-   Unique_Node_List visited;</span>
<span class="udiff-line-removed">-   return needs_barrier_impl(phase, orig, n, rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierNode::needs_barrier_impl(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace, Unique_Node_List &amp;visited) {</span>
<span class="udiff-line-removed">-   if (visited.member(n)) {</span>
<span class="udiff-line-removed">-     return false; // Been there.</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   visited.push(n);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (n-&gt;is_Allocate()) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (n-&gt;is_Call()) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const Type* type = phase-&gt;type(n);</span>
<span class="udiff-line-removed">-   if (type == Type::TOP) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ShenandoahOptimizeStableFinals) {</span>
<span class="udiff-line-removed">-     const TypeAryPtr* ary = type-&gt;isa_aryptr();</span>
<span class="udiff-line-removed">-     if (ary &amp;&amp; ary-&gt;is_stable() &amp;&amp; allow_fromspace) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (n-&gt;is_CheckCastPP() || n-&gt;is_ConstraintCast() || n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-removed">-     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;is_Parm()) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;is_Proj()) {</span>
<span class="udiff-line-removed">-     return needs_barrier_impl(phase, orig, n-&gt;in(0), rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-     return needs_barrier_impl(phase, orig, n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier), rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-     bool need_barrier = false;</span>
<span class="udiff-line-removed">-     for (uint i = 1; i &lt; n-&gt;req() &amp;&amp; ! need_barrier; i++) {</span>
<span class="udiff-line-removed">-       Node* input = n-&gt;in(i);</span>
<span class="udiff-line-removed">-       if (input == NULL) {</span>
<span class="udiff-line-removed">-         need_barrier = true; // Phi not complete yet?</span>
<span class="udiff-line-removed">-       } else if (needs_barrier_impl(phase, orig, input, rb_mem, allow_fromspace, visited)) {</span>
<span class="udiff-line-removed">-         need_barrier = true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return need_barrier;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;is_CMove()) {</span>
<span class="udiff-line-removed">-     return needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfFalse), rb_mem, allow_fromspace, visited) ||</span>
<span class="udiff-line-removed">-            needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfTrue ), rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_CreateEx) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {</span>
<span class="udiff-line-removed">-     if (rb_mem == n-&gt;in(Memory)) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_LoadP ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_LoadN ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_GetAndSetP ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_CompareAndExchangeP ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_GetAndSetN ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_CompareAndExchangeN ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_EncodeP) {</span>
<span class="udiff-line-removed">-     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   tty-&gt;print(&quot;need barrier on?: &quot;); n-&gt;dump();</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahReadBarrierNode::dominates_memory_rb_impl(PhaseGVN* phase,</span>
<span class="udiff-line-removed">-                                                          Node* b1,</span>
<span class="udiff-line-removed">-                                                          Node* b2,</span>
<span class="udiff-line-removed">-                                                          Node* current,</span>
<span class="udiff-line-removed">-                                                          bool linear) {</span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-removed">-   Node_Stack phis(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for(int i = 0; i &lt; 10; i++) {</span>
<span class="udiff-line-removed">-     if (current == NULL) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="udiff-line-removed">-       current = NULL;</span>
<span class="udiff-line-removed">-       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="udiff-line-removed">-         uint idx = phis.index();</span>
<span class="udiff-line-removed">-         Node* phi = phis.node();</span>
<span class="udiff-line-removed">-         if (idx &gt;= phi-&gt;req()) {</span>
<span class="udiff-line-removed">-           phis.pop();</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           current = phi-&gt;in(idx);</span>
<span class="udiff-line-removed">-           phis.set_index(idx+1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (current == NULL) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else if (current-&gt;isa_Phi()) {</span>
<span class="udiff-line-removed">-       if (!linear) {</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       phis.push(current, 2);</span>
<span class="udiff-line-removed">-       current = current-&gt;in(1);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-       const Type* in_type = current-&gt;bottom_type();</span>
<span class="udiff-line-removed">-       const Type* this_type = b2-&gt;bottom_type();</span>
<span class="udiff-line-removed">-       if (is_independent(in_type, this_type)) {</span>
<span class="udiff-line-removed">-         current = current-&gt;in(Memory);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::expand(Compile* C, PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-modified-added">+   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();</span>
<span class="udiff-line-modified-added">+   if ((state-&gt;enqueue_barriers_count() +</span>
<span class="udiff-line-modified-added">+        state-&gt;load_reference_barriers_count()) &gt; 0) {</span>
<span class="udiff-line-modified-added">+     bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;</span>
<span class="udiff-line-modified-added">+     C-&gt;clear_major_progress();</span>
<span class="udiff-line-modified-added">+     PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);</span>
<span class="udiff-line-modified-added">+     if (C-&gt;failing()) return false;</span>
<span class="udiff-line-modified-added">+     PhaseIdealLoop::verify(igvn);</span>
<span class="udiff-line-modified-added">+     DEBUG_ONLY(verify_raw_mem(C-&gt;root());)</span>
<span class="udiff-line-modified-added">+     if (attempt_more_loopopts) {</span>
<span class="udiff-line-modified-added">+       C-&gt;set_major_progress();</span>
<span class="udiff-line-modified-added">+       if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {</span>
          return false;
        }
<span class="udiff-line-removed">-     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_Proj()) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(0);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_Call()) {</span>
<span class="udiff-line-removed">-       return false; // TODO: Maybe improve by looking at the call&#39;s memory effects?</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_MemBar()) {</span>
<span class="udiff-line-removed">-       return false; // TODO: Do we need to stop at *any* membar?</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="udiff-line-removed">-       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-removed">-       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       current-&gt;dump();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahReadBarrierNode::is_independent(Node* mem) {</span>
<span class="udiff-line-removed">-   if (mem-&gt;is_Phi() || mem-&gt;is_Proj() || mem-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-     const Type* mem_type = mem-&gt;bottom_type();</span>
<span class="udiff-line-removed">-     const Type* this_type = bottom_type();</span>
<span class="udiff-line-removed">-     if (is_independent(mem_type, this_type)) {</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else if (mem-&gt;is_Call() || mem-&gt;is_MemBar()) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   mem-&gt;dump();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahReadBarrierNode::dominates_memory_rb(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="udiff-line-removed">-   return dominates_memory_rb_impl(phase, b1-&gt;in(Memory), b2, b2-&gt;in(Memory), linear);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahReadBarrierNode::is_independent(const Type* in_type, const Type* this_type) {</span>
<span class="udiff-line-removed">-   assert(in_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="udiff-line-removed">-   assert(this_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ciKlass* in_kls = in_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="udiff-line-removed">-   ciKlass* this_kls = this_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="udiff-line-removed">-   if (in_kls != NULL &amp;&amp; this_kls != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-       in_kls-&gt;is_loaded() &amp;&amp; this_kls-&gt;is_loaded() &amp;&amp;</span>
<span class="udiff-line-removed">-       (!in_kls-&gt;is_subclass_of(this_kls)) &amp;&amp;</span>
<span class="udiff-line-removed">-       (!this_kls-&gt;is_subclass_of(in_kls))) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahReadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="udiff-line-removed">-   if (! can_reshape) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (in(Memory) == phase-&gt;C-&gt;immutable_memory()) return NULL;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If memory input is a MergeMem, take the appropriate slice out of it.</span>
<span class="udiff-line-removed">-   Node* mem_in = in(Memory);</span>
<span class="udiff-line-removed">-   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="udiff-line-removed">-     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="udiff-line-removed">-     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-removed">-     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="udiff-line-removed">-     set_req(Memory, mem_in);</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* input = in(Memory);</span>
<span class="udiff-line-removed">-   if (input-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-     ResourceMark rm;</span>
<span class="udiff-line-removed">-     VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-removed">-     Node* n = in(Memory);</span>
<span class="udiff-line-removed">-     while (n-&gt;Opcode() == Op_ShenandoahWBMemProj &amp;&amp;</span>
<span class="udiff-line-removed">-            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="udiff-line-removed">-            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory) != NULL) {</span>
<span class="udiff-line-removed">-       if (seen.test_set(n-&gt;_idx)) {</span>
<span class="udiff-line-removed">-         return NULL; // loop</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       n = n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* wb = input-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="udiff-line-removed">-     const Type* in_type = phase-&gt;type(wb);</span>
<span class="udiff-line-removed">-     // is_top() test not sufficient here: we can come here after CCP</span>
<span class="udiff-line-removed">-     // in a dead branch of the graph that has not yet been removed.</span>
<span class="udiff-line-removed">-     if (in_type == Type::TOP) return NULL; // Dead path.</span>
<span class="udiff-line-removed">-     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="udiff-line-removed">-     if (is_independent(in_type, _type)) {</span>
<span class="udiff-line-removed">-       phase-&gt;igvn_rehash_node_delayed(wb);</span>
<span class="udiff-line-removed">-       set_req(Memory, wb-&gt;in(Memory));</span>
<span class="udiff-line-removed">-       if (can_reshape &amp;&amp; input-&gt;outcnt() == 0) {</span>
<span class="udiff-line-removed">-         phase-&gt;is_IterGVN()-&gt;_worklist.push(input);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       return this;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- ShenandoahWriteBarrierNode::ShenandoahWriteBarrierNode(Compile* C, Node* ctrl, Node* mem, Node* obj)</span>
<span class="udiff-line-removed">-   : ShenandoahBarrierNode(ctrl, mem, obj, false) {</span>
<span class="udiff-line-removed">-   assert(UseShenandoahGC &amp;&amp; ShenandoahWriteBarrier, &quot;should be enabled&quot;);</span>
<span class="udiff-line-removed">-   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_shenandoah_barrier(this);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="udiff-line-removed">-   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="udiff-line-removed">-   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="udiff-line-removed">-   Node* mem_in = in(Memory);</span>
<span class="udiff-line-removed">-   Node* mem_proj = NULL;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (igvn != NULL) {</span>
<span class="udiff-line-removed">-     mem_proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-     if (mem_in == mem_proj) {</span>
<span class="udiff-line-removed">-       return this;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* replacement = Identity_impl(phase);</span>
<span class="udiff-line-removed">-   if (igvn != NULL) {</span>
<span class="udiff-line-removed">-     if (replacement != NULL &amp;&amp; replacement != this &amp;&amp; mem_proj != NULL) {</span>
<span class="udiff-line-removed">-       igvn-&gt;replace_node(mem_proj, mem_in);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return replacement;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="udiff-line-removed">-   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="udiff-line-removed">-   if (!can_reshape) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* mem_in = in(Memory);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="udiff-line-removed">-     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="udiff-line-removed">-     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-removed">-     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="udiff-line-removed">-     set_req(Memory, mem_in);</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-removed">-   if (val-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-     set_req(ValueIn, val-&gt;in(ValueIn));</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahWriteBarrierNode::expand(Compile* C, PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-removed">-   if (UseShenandoahGC) {</span>
<span class="udiff-line-removed">-     if (ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() &gt; 0 || (!ShenandoahWriteBarrier &amp;&amp; ShenandoahStoreValEnqueueBarrier)) {</span>
<span class="udiff-line-removed">-       bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;</span>
        C-&gt;clear_major_progress();
<span class="udiff-line-modified-removed">-       PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);</span>
<span class="udiff-line-modified-removed">-       if (C-&gt;failing()) return false;</span>
<span class="udiff-line-modified-removed">-       PhaseIdealLoop::verify(igvn);</span>
<span class="udiff-line-modified-removed">-       DEBUG_ONLY(ShenandoahBarrierNode::verify_raw_mem(C-&gt;root());)</span>
<span class="udiff-line-removed">-       if (attempt_more_loopopts) {</span>
<span class="udiff-line-removed">-         C-&gt;set_major_progress();</span>
<span class="udiff-line-removed">-         if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {</span>
<span class="udiff-line-removed">-           return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         C-&gt;clear_major_progress();</span>
<span class="udiff-line-modified-added">+       if (C-&gt;range_check_cast_count() &gt; 0) {</span>
<span class="udiff-line-modified-added">+         // No more loop optimizations. Remove all range check dependent CastIINodes.</span>
<span class="udiff-line-modified-added">+         C-&gt;remove_range_check_casts(igvn);</span>
<span class="udiff-line-modified-added">+         igvn.optimize();</span>
        }
      }
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::is_heap_state_test(Node* iff, int mask) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::is_heap_state_test(Node* iff, int mask) {</span>
    if (!UseShenandoahGC) {
      return false;
    }
    assert(iff-&gt;is_If(), &quot;bad input&quot;);
    if (iff-&gt;Opcode() != Op_If) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,15 +99,15 @@</span>
    in1 = in1-&gt;in(1);
  
    return is_gc_state_load(in1);
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::is_heap_stable_test(Node* iff) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::is_heap_stable_test(Node* iff) {</span>
    return is_heap_state_test(iff, ShenandoahHeap::HAS_FORWARDED);
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::is_gc_state_load(Node *n) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::is_gc_state_load(Node *n) {</span>
    if (!UseShenandoahGC) {
      return false;
    }
    if (n-&gt;Opcode() != Op_LoadB &amp;&amp; n-&gt;Opcode() != Op_LoadUB) {
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,11 +125,11 @@</span>
      return false;
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {</span>
    assert(phase-&gt;is_dominator(stop, start), &quot;bad inputs&quot;);
    ResourceMark rm;
    Unique_Node_List wq;
    wq.push(start);
    for (uint next = 0; next &lt; wq.size(); next++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -498,11 +149,11 @@</span>
      }
    }
    return false;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::try_common_gc_state_load(Node *n, PhaseIdealLoop *phase) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::try_common_gc_state_load(Node *n, PhaseIdealLoop *phase) {</span>
    assert(is_gc_state_load(n), &quot;inconsistent&quot;);
    Node* addp = n-&gt;in(MemNode::Address);
    Node* dominator = NULL;
    for (DUIterator_Fast imax, i = addp-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* u = addp-&gt;fast_out(i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -523,235 +174,56 @@</span>
    phase-&gt;igvn().replace_node(n, dominator);
  
    return true;
  }
  
<span class="udiff-line-removed">- bool ShenandoahBarrierNode::dominates_memory_impl(PhaseGVN* phase,</span>
<span class="udiff-line-removed">-                                                   Node* b1,</span>
<span class="udiff-line-removed">-                                                   Node* b2,</span>
<span class="udiff-line-removed">-                                                   Node* current,</span>
<span class="udiff-line-removed">-                                                   bool linear) {</span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-removed">-   Node_Stack phis(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for(int i = 0; i &lt; 10; i++) {</span>
<span class="udiff-line-removed">-     if (current == NULL) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="udiff-line-removed">-       current = NULL;</span>
<span class="udiff-line-removed">-       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="udiff-line-removed">-         uint idx = phis.index();</span>
<span class="udiff-line-removed">-         Node* phi = phis.node();</span>
<span class="udiff-line-removed">-         if (idx &gt;= phi-&gt;req()) {</span>
<span class="udiff-line-removed">-           phis.pop();</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           current = phi-&gt;in(idx);</span>
<span class="udiff-line-removed">-           phis.set_index(idx+1);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (current == NULL) {</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else if (current == b2) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     } else if (current-&gt;isa_Phi()) {</span>
<span class="udiff-line-removed">-       if (!linear) {</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       phis.push(current, 2);</span>
<span class="udiff-line-removed">-       current = current-&gt;in(1);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(Memory);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_Proj()) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(0);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_Call()) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_MemBar()) {</span>
<span class="udiff-line-removed">-       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-removed">-     } else if (current-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="udiff-line-removed">-       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-removed">-       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       current-&gt;dump();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Determines if b1 dominates b2 through memory inputs. It returns true if:</span>
<span class="udiff-line-removed">-  * - b1 can be reached by following each branch in b2&#39;s memory input (through phis, etc)</span>
<span class="udiff-line-removed">-  * - or we get back to b2 (i.e. through a loop) without seeing b1</span>
<span class="udiff-line-removed">-  * In all other cases, (in particular, if we reach immutable_memory without having seen b1)</span>
<span class="udiff-line-removed">-  * we return false.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- bool ShenandoahBarrierNode::dominates_memory(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="udiff-line-removed">-   return dominates_memory_impl(phase, b1, b2, b2-&gt;in(Memory), linear);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierNode::Identity_impl(PhaseGVN* phase) {</span>
<span class="udiff-line-removed">-   Node* n = in(ValueIn);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* rb_mem = Opcode() == Op_ShenandoahReadBarrier ? in(Memory) : NULL;</span>
<span class="udiff-line-removed">-   if (! needs_barrier(phase, this, n, rb_mem, _allow_fromspace)) {</span>
<span class="udiff-line-removed">-     return n;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Try to find a write barrier sibling with identical inputs that we can fold into.</span>
<span class="udiff-line-removed">-   for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="udiff-line-removed">-     Node* sibling = n-&gt;out(i);</span>
<span class="udiff-line-removed">-     if (sibling == this) {</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (sibling-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(sibling-&gt;in(ValueIn) == in(ValueIn), &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-     assert(sibling-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;sanity&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (dominates_memory(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="udiff-line-removed">-       return sibling;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- void ShenandoahBarrierNode::dump_spec(outputStream *st) const {</span>
<span class="udiff-line-removed">-   const TypePtr* adr = adr_type();</span>
<span class="udiff-line-removed">-   if (adr == NULL) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   st-&gt;print(&quot; @&quot;);</span>
<span class="udiff-line-removed">-   adr-&gt;dump_on(st);</span>
<span class="udiff-line-removed">-   st-&gt;print(&quot; (&quot;);</span>
<span class="udiff-line-removed">-   Compile::current()-&gt;alias_type(adr)-&gt;adr_type()-&gt;dump_on(st);</span>
<span class="udiff-line-removed">-   st-&gt;print(&quot;) &quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahReadBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="udiff-line-removed">-   Node* id = Identity_impl(phase);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (id == this &amp;&amp; phase-&gt;is_IterGVN()) {</span>
<span class="udiff-line-removed">-     Node* n = in(ValueIn);</span>
<span class="udiff-line-removed">-     // No success in super call. Try to combine identical read barriers.</span>
<span class="udiff-line-removed">-     for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="udiff-line-removed">-       Node* sibling = n-&gt;out(i);</span>
<span class="udiff-line-removed">-       if (sibling == this || sibling-&gt;Opcode() != Op_ShenandoahReadBarrier) {</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       assert(sibling-&gt;in(ValueIn)  == in(ValueIn), &quot;sanity&quot;);</span>
<span class="udiff-line-removed">-       if (phase-&gt;is_IterGVN()-&gt;hash_find(sibling) &amp;&amp;</span>
<span class="udiff-line-removed">-           sibling-&gt;bottom_type() == bottom_type() &amp;&amp;</span>
<span class="udiff-line-removed">-           sibling-&gt;in(Control) == in(Control) &amp;&amp;</span>
<span class="udiff-line-removed">-           dominates_memory_rb(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="udiff-line-removed">-         return sibling;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return id;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- const Type* ShenandoahBarrierNode::Value(PhaseGVN* phase) const {</span>
<span class="udiff-line-removed">-   // Either input is TOP ==&gt; the result is TOP</span>
<span class="udiff-line-removed">-   const Type *t1 = phase-&gt;type(in(Memory));</span>
<span class="udiff-line-removed">-   if (t1 == Type::TOP) return Type::TOP;</span>
<span class="udiff-line-removed">-   const Type *t2 = phase-&gt;type(in(ValueIn));</span>
<span class="udiff-line-removed">-   if( t2 == Type::TOP ) return Type::TOP;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (t2 == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-removed">-     return _type;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const Type* type = t2-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="udiff-line-removed">-   return type;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- uint ShenandoahBarrierNode::hash() const {</span>
<span class="udiff-line-removed">-   return TypeNode::hash() + _allow_fromspace;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- uint ShenandoahBarrierNode::cmp(const Node&amp; n) const {</span>
<span class="udiff-line-removed">-   return _allow_fromspace == ((ShenandoahBarrierNode&amp;) n)._allow_fromspace</span>
<span class="udiff-line-removed">-     &amp;&amp; TypeNode::cmp(n);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- uint ShenandoahBarrierNode::size_of() const {</span>
<span class="udiff-line-removed">-   return sizeof(*this);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWBMemProjNode::Identity(PhaseGVN* phase) {</span>
<span class="udiff-line-removed">-   Node* wb = in(WriteBarrier);</span>
<span class="udiff-line-removed">-   if (wb-&gt;is_top()) return phase-&gt;C-&gt;top(); // Dead path.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="udiff-line-removed">-   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="udiff-line-removed">-   // We can&#39;t do the below unless the graph is fully constructed.</span>
<span class="udiff-line-removed">-   if (igvn == NULL) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If the mem projection has no barrier users, it&#39;s not needed anymore.</span>
<span class="udiff-line-removed">-   if (wb-&gt;outcnt() == 1) {</span>
<span class="udiff-line-removed">-     return wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  #ifdef ASSERT
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierNode::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {</span>
    assert(phis.size() == 0, &quot;&quot;);
  
    while (true) {
      if (in-&gt;bottom_type() == TypePtr::NULL_PTR) {
        if (trace) {tty-&gt;print_cr(&quot;NULL&quot;);}
      } else if (!in-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
        if (trace) {tty-&gt;print_cr(&quot;Non oop&quot;);}
<span class="udiff-line-removed">-     } else if (t == ShenandoahLoad &amp;&amp; ShenandoahOptimizeStableFinals &amp;&amp;</span>
<span class="udiff-line-removed">-                in-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_aryptr() &amp;&amp;</span>
<span class="udiff-line-removed">-                in-&gt;bottom_type()-&gt;make_ptr()-&gt;is_aryptr()-&gt;is_stable()) {</span>
<span class="udiff-line-removed">-       if (trace) {tty-&gt;print_cr(&quot;Stable array load&quot;);}</span>
      } else {
        if (in-&gt;is_ConstraintCast()) {
          in = in-&gt;in(1);
          continue;
        } else if (in-&gt;is_AddP()) {
          assert(!in-&gt;in(AddPNode::Address)-&gt;is_top(), &quot;no raw memory access&quot;);
          in = in-&gt;in(AddPNode::Address);
          continue;
        } else if (in-&gt;is_Con()) {
<span class="udiff-line-modified-removed">-         if (trace) {tty-&gt;print(&quot;Found constant&quot;); in-&gt;dump();}</span>
<span class="udiff-line-modified-removed">-       } else if (in-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-modified-added">+         if (trace) {</span>
<span class="udiff-line-modified-added">+           tty-&gt;print(&quot;Found constant&quot;);</span>
<span class="udiff-line-added">+           in-&gt;dump();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (in-&gt;Opcode() == Op_Parm) {</span>
<span class="udiff-line-added">+         if (trace) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;Found argument&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (in-&gt;Opcode() == Op_CreateEx) {</span>
<span class="udiff-line-added">+         if (trace) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;Found create-exception&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (in-&gt;Opcode() == Op_LoadP &amp;&amp; in-&gt;adr_type() == TypeRawPtr::BOTTOM) {</span>
<span class="udiff-line-added">+         if (trace) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;Found raw LoadP (OSR argument?)&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (in-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
          if (t == ShenandoahOopStore) {
<span class="udiff-line-removed">-           if (in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-           }</span>
            uint i = 0;
            for (; i &lt; phis.size(); i++) {
              Node* n = phis.node_at(i);
              if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
                break;
              }
            }
            if (i == phis.size()) {
              return false;
            }
<span class="udiff-line-removed">-         } else if (t == ShenandoahStore &amp;&amp; in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-           return false;</span>
          }
          barriers_used.push(in);
          if (trace) {tty-&gt;print(&quot;Found barrier&quot;); in-&gt;dump();}
        } else if (in-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
          if (t != ShenandoahOopStore) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -761,11 +233,18 @@</span>
          if (trace) {tty-&gt;print(&quot;Found enqueue barrier&quot;); in-&gt;dump();}
          phis.push(in, in-&gt;req());
          in = in-&gt;in(1);
          continue;
        } else if (in-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;is_Allocate()) {
<span class="udiff-line-modified-removed">-         if (trace) {tty-&gt;print(&quot;Found alloc&quot;); in-&gt;in(0)-&gt;dump();}</span>
<span class="udiff-line-modified-added">+         if (trace) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;Found alloc&quot;);</span>
<span class="udiff-line-added">+           in-&gt;in(0)-&gt;dump();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else if (in-&gt;is_Proj() &amp;&amp; (in-&gt;in(0)-&gt;Opcode() == Op_CallStaticJava || in-&gt;in(0)-&gt;Opcode() == Op_CallDynamicJava)) {</span>
<span class="udiff-line-added">+         if (trace) {</span>
<span class="udiff-line-added">+           tty-&gt;print(&quot;Found Java call&quot;);</span>
<span class="udiff-line-added">+         }</span>
        } else if (in-&gt;is_Phi()) {
          if (!visited.test_set(in-&gt;_idx)) {
            if (trace) {tty-&gt;print(&quot;Pushed phi:&quot;); in-&gt;dump();}
            phis.push(in, 2);
            in = in-&gt;in(1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -807,21 +286,21 @@</span>
      }
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierNode::report_verify_failure(const char *msg, Node *n1, Node *n2) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::report_verify_failure(const char* msg, Node* n1, Node* n2) {</span>
    if (n1 != NULL) {
      n1-&gt;dump(+10);
    }
    if (n2 != NULL) {
      n2-&gt;dump(+10);
    }
    fatal(&quot;%s&quot;, msg);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierNode::verify(RootNode* root) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::verify(RootNode* root) {</span>
    ResourceMark rm;
    Unique_Node_List wq;
    GrowableArray&lt;Node*&gt; barriers;
    Unique_Node_List barriers_used;
    Node_Stack phis(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -844,38 +323,12 @@</span>
            if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
          } else if (adr_type-&gt;isa_instptr() &amp;&amp;
                     adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
                     adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {
            if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
<span class="udiff-line-modified-removed">-         } else {</span>
<span class="udiff-line-modified-removed">-           bool verify = true;</span>
<span class="udiff-line-removed">-           if (adr_type-&gt;isa_instptr()) {</span>
<span class="udiff-line-removed">-             const TypeInstPtr* tinst = adr_type-&gt;is_instptr();</span>
<span class="udiff-line-removed">-             ciKlass* k = tinst-&gt;klass();</span>
<span class="udiff-line-removed">-             assert(k-&gt;is_instance_klass(), &quot;&quot;);</span>
<span class="udiff-line-removed">-             ciInstanceKlass* ik = (ciInstanceKlass*)k;</span>
<span class="udiff-line-removed">-             int offset = adr_type-&gt;offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if ((ik-&gt;debug_final_field_at(offset) &amp;&amp; ShenandoahOptimizeInstanceFinals) ||</span>
<span class="udiff-line-removed">-                 (ik-&gt;debug_stable_field_at(offset) &amp;&amp; ShenandoahOptimizeStableFinals)) {</span>
<span class="udiff-line-removed">-               if (trace) {tty-&gt;print_cr(&quot;Final/stable&quot;);}</span>
<span class="udiff-line-removed">-               verify = false;</span>
<span class="udiff-line-removed">-             } else if (k == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="udiff-line-removed">-                        tinst-&gt;const_oop() != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-                        tinst-&gt;offset() &gt;= (ik-&gt;size_helper() * wordSize)) {</span>
<span class="udiff-line-removed">-               ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="udiff-line-removed">-               ciField* field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);</span>
<span class="udiff-line-removed">-               if ((ShenandoahOptimizeStaticFinals &amp;&amp; field-&gt;is_final()) ||</span>
<span class="udiff-line-removed">-                   (ShenandoahOptimizeStableFinals &amp;&amp; field-&gt;is_stable())) {</span>
<span class="udiff-line-removed">-                 verify = false;</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="udiff-line-removed">-             report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-modified-added">+         } else if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+           report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);</span>
          }
        }
      } else if (n-&gt;is_Store()) {
        const bool trace = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -897,15 +350,15 @@</span>
                verify = false;
              }
            }
          }
  
<span class="udiff-line-modified-removed">-         if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+         if (verify &amp;&amp; !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
            report_verify_failure(&quot;Shenandoah verification: Store should have barriers&quot;, n);
          }
        }
<span class="udiff-line-modified-removed">-       if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+       if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
          report_verify_failure(&quot;Shenandoah verification: Store (address) should have barriers&quot;, n);
        }
      } else if (n-&gt;Opcode() == Op_CmpP) {
        const bool trace = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -924,30 +377,30 @@</span>
            if (trace) {tty-&gt;print_cr(&quot;Comparison with newly alloc&#39;ed object&quot;);}
            mark_inputs = true;
          } else {
            assert(in2-&gt;bottom_type()-&gt;isa_oopptr(), &quot;&quot;);
  
<span class="udiff-line-modified-removed">-           if (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||</span>
<span class="udiff-line-modified-removed">-               !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+           if (!verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||</span>
<span class="udiff-line-modified-added">+               !verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
              report_verify_failure(&quot;Shenandoah verification: Cmp should have barriers&quot;, n);
            }
          }
          if (verify_no_useless_barrier &amp;&amp;
              mark_inputs &amp;&amp;
<span class="udiff-line-modified-removed">-             (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||</span>
<span class="udiff-line-modified-removed">-              !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {</span>
<span class="udiff-line-modified-added">+             (!verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||</span>
<span class="udiff-line-modified-added">+              !verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {</span>
            phis.clear();
<span class="udiff-line-modified-removed">-           visited.Reset();</span>
<span class="udiff-line-modified-added">+           visited.reset();</span>
          }
        }
      } else if (n-&gt;is_LoadStore()) {
        if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
<span class="udiff-line-modified-removed">-           !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+           !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
          report_verify_failure(&quot;Shenandoah verification: LoadStore (value) should have barriers&quot;, n);
        }
  
<span class="udiff-line-modified-removed">-       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
          report_verify_failure(&quot;Shenandoah verification: LoadStore (address) should have barriers&quot;, n);
        }
      } else if (n-&gt;Opcode() == Op_CallLeafNoFP || n-&gt;Opcode() == Op_CallLeaf) {
        CallNode* call = n-&gt;as_Call();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1039,17 +492,17 @@</span>
                dest = n-&gt;in(i);
                break;
              }
            }
          }
<span class="udiff-line-modified-removed">-         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||</span>
<span class="udiff-line-modified-removed">-             !ShenandoahBarrierNode::verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||</span>
<span class="udiff-line-modified-added">+             !verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
            report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
          }
        } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
                   !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
<span class="udiff-line-modified-removed">-         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
            report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
          }
        } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
          // skip
        } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1065,11 +518,11 @@</span>
            for (uint j = 0; j &lt; args_len; j++) {
              int pos = calls[i].args[j].pos;
              if (pos == -1) {
                break;
              }
<span class="udiff-line-modified-removed">-             if (!ShenandoahBarrierNode::verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+             if (!verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {</span>
                report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
              }
            }
            for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
              if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1088,19 +541,12 @@</span>
                fatal(&quot;%s not covered&quot;, call-&gt;_name);
              }
            }
          }
        }
<span class="udiff-line-modified-removed">-     } else if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-       assert(!barriers.contains(n), &quot;&quot;);</span>
<span class="udiff-line-removed">-       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;find_out_with(Op_ShenandoahWBMemProj) != NULL, &quot;bad shenandoah write barrier&quot;);</span>
<span class="udiff-line-removed">-       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;outcnt() &gt; 1, &quot;bad shenandoah write barrier&quot;);</span>
<span class="udiff-line-removed">-       barriers.push(n);</span>
<span class="udiff-line-removed">-     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier || n-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
        // skip
<span class="udiff-line-removed">-     } else if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-       assert(n-&gt;in(0) == NULL &amp;&amp; n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;strange ShenandoahWBMemProj&quot;);</span>
      } else if (n-&gt;is_AddP()
                 || n-&gt;is_Phi()
                 || n-&gt;is_ConstraintCast()
                 || n-&gt;Opcode() == Op_Return
                 || n-&gt;Opcode() == Op_CMoveP
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,11 +609,11 @@</span>
          for (uint j = 0; j &lt; inputs_len; j++) {
            int pos = others[i].inputs[j].pos;
            if (pos == -1) {
              break;
            }
<span class="udiff-line-modified-removed">-           if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+           if (!verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {</span>
              report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
            }
          }
          for (uint j = 1; j &lt; stop; j++) {
            if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1191,55 +637,18 @@</span>
  
      if (n-&gt;is_SafePoint()) {
        SafePointNode* sfpt = n-&gt;as_SafePoint();
        if (verify_no_useless_barrier &amp;&amp; sfpt-&gt;jvms() != NULL) {
          for (uint i = sfpt-&gt;jvms()-&gt;scloff(); i &lt; sfpt-&gt;jvms()-&gt;endoff(); i++) {
<span class="udiff-line-modified-removed">-           if (!ShenandoahBarrierNode::verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="udiff-line-modified-added">+           if (!verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
              phis.clear();
<span class="udiff-line-modified-removed">-             visited.Reset();</span>
<span class="udiff-line-modified-added">+             visited.reset();</span>
            }
          }
        }
      }
<span class="udiff-line-modified-removed">-     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {</span>
<span class="udiff-line-removed">-       Node *m = n-&gt;in(i);</span>
<span class="udiff-line-removed">-       if (m == NULL) continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // In most cases, inputs should be known to be non null. If it&#39;s</span>
<span class="udiff-line-removed">-       // not the case, it could be a missing cast_not_null() in an</span>
<span class="udiff-line-removed">-       // intrinsic or support might be needed in AddPNode::Ideal() to</span>
<span class="udiff-line-removed">-       // avoid a NULL+offset input.</span>
<span class="udiff-line-removed">-       if (!(n-&gt;is_Phi() ||</span>
<span class="udiff-line-removed">-             (n-&gt;is_SafePoint() &amp;&amp; (!n-&gt;is_CallRuntime() || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;shenandoah_wb_pre&quot;) || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;unsafe_arraycopy&quot;))) ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_CmpP ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_CmpN ||</span>
<span class="udiff-line-removed">-             (n-&gt;Opcode() == Op_StoreP &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="udiff-line-removed">-             (n-&gt;Opcode() == Op_StoreN &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="udiff-line-removed">-             n-&gt;is_ConstraintCast() ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_Return ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_Conv2B ||</span>
<span class="udiff-line-removed">-             n-&gt;is_AddP() ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_CMoveP ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_CMoveN ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_Rethrow ||</span>
<span class="udiff-line-removed">-             n-&gt;is_MemBar() ||</span>
<span class="udiff-line-removed">-             n-&gt;is_Mem() ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_AryEq ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_SCMemProj ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_EncodeP ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_ShenandoahWBMemProj ||</span>
<span class="udiff-line-removed">-             n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier)) {</span>
<span class="udiff-line-removed">-         if (m-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; m-&gt;bottom_type()-&gt;make_oopptr()-&gt;meet(TypePtr::NULL_PTR) == m-&gt;bottom_type()) {</span>
<span class="udiff-line-removed">-           report_verify_failure(&quot;Shenandoah verification: null input&quot;, n, m);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       wq.push(m);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   }</span>
  
    if (verify_no_useless_barrier) {
      for (int i = 0; i &lt; barriers.length(); i++) {
        Node* n = barriers.at(i);
        if (!barriers_used.member(n)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1249,11 +658,11 @@</span>
      }
    }
  }
  #endif
  
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierNode::is_dominator_same_ctrl(Node*c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::is_dominator_same_ctrl(Node* c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
    // That both nodes have the same control is not sufficient to prove
    // domination, verify that there&#39;s no path from d to n
    ResourceMark rm;
    Unique_Node_List wq;
    wq.push(d);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1263,21 +672,32 @@</span>
        return false;
      }
      if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0)-&gt;is_Loop()) {
        assert(phase-&gt;ctrl_or_self(m-&gt;in(LoopNode::EntryControl)) != c, &quot;following loop entry should lead to new control&quot;);
      } else {
<span class="udiff-line-added">+       if (m-&gt;is_Store() || m-&gt;is_LoadStore()) {</span>
<span class="udiff-line-added">+         // Take anti-dependencies into account</span>
<span class="udiff-line-added">+         Node* mem = m-&gt;in(MemNode::Memory);</span>
<span class="udiff-line-added">+         for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+           Node* u = mem-&gt;fast_out(i);</span>
<span class="udiff-line-added">+           if (u-&gt;is_Load() &amp;&amp; phase-&gt;C-&gt;can_alias(m-&gt;adr_type(), phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type())) &amp;&amp;</span>
<span class="udiff-line-added">+               phase-&gt;ctrl_or_self(u) == c) {</span>
<span class="udiff-line-added">+             wq.push(u);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
        for (uint i = 0; i &lt; m-&gt;req(); i++) {
          if (m-&gt;in(i) != NULL &amp;&amp; phase-&gt;ctrl_or_self(m-&gt;in(i)) == c) {
            wq.push(m-&gt;in(i));
          }
        }
      }
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierNode::is_dominator(Node *d_c, Node *n_c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::is_dominator(Node* d_c, Node* n_c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
    if (d_c != n_c) {
      return phase-&gt;is_dominator(d_c, n_c);
    }
    return is_dominator_same_ctrl(d_c, d, n, phase);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1288,29 +708,25 @@</span>
      res = mem-&gt;in(0);
    } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
      res = mem-&gt;in(TypeFunc::Memory);
    } else if (mem-&gt;is_Phi()) {
      res = mem-&gt;in(1);
<span class="udiff-line-removed">-   } else if (mem-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-     res = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
    } else if (mem-&gt;is_MergeMem()) {
      res = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
    } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
      assert(alias = Compile::AliasIdxRaw, &quot;following raw memory can&#39;t lead to a barrier&quot;);
      res = mem-&gt;in(MemNode::Memory);
<span class="udiff-line-removed">-   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-     res = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
    } else {
  #ifdef ASSERT
      mem-&gt;dump();
  #endif
      ShouldNotReachHere();
    }
    return res;
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierNode::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierC2Support::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {</span>
    Node* iffproj = NULL;
    while (c != dom) {
      Node* next = phase-&gt;idom(c);
      assert(next-&gt;unique_ctrl_out() == c || c-&gt;is_Proj() || c-&gt;is_Region(), &quot;multiple control flow out but no proj or region?&quot;);
      if (c-&gt;is_Region()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1371,274 +787,11 @@</span>
      c = next;
    }
    return iffproj;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierNode::build_loop_late_post(PhaseIdealLoop* phase, Node* n) {</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="udiff-line-removed">-       n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;build_loop_late_post_work(n, false);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-       // The write barrier and its memory proj must have the same</span>
<span class="udiff-line-removed">-       // control otherwise some loop opts could put nodes (Phis) between</span>
<span class="udiff-line-removed">-       // them</span>
<span class="udiff-line-removed">-       Node* proj = n-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-       if (proj != NULL) {</span>
<span class="udiff-line-removed">-         phase-&gt;set_ctrl_and_loop(proj, phase-&gt;get_ctrl(n));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierNode::sink_node(PhaseIdealLoop* phase, Node* ctrl, Node* n_ctrl) {</span>
<span class="udiff-line-removed">-   ctrl = phase-&gt;find_non_split_ctrl(ctrl);</span>
<span class="udiff-line-removed">-   assert(phase-&gt;dom_depth(n_ctrl) &lt;= phase-&gt;dom_depth(ctrl), &quot;n is later than its clone&quot;);</span>
<span class="udiff-line-removed">-   set_req(0, ctrl);</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(this, ctrl);</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::memory_dominates_all_paths_helper(Node* c, Node* rep_ctrl, Unique_Node_List&amp; controls, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   const bool trace = false;</span>
<span class="udiff-line-removed">-   if (trace) { tty-&gt;print(&quot;X control is&quot;); c-&gt;dump(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint start = controls.size();</span>
<span class="udiff-line-removed">-   controls.push(c);</span>
<span class="udiff-line-removed">-   for (uint i = start; i &lt; controls.size(); i++) {</span>
<span class="udiff-line-removed">-     Node *n = controls.at(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (trace) { tty-&gt;print(&quot;X from&quot;); n-&gt;dump(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n == rep_ctrl) {</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n-&gt;is_Proj()) {</span>
<span class="udiff-line-removed">-       Node* n_dom = n-&gt;in(0);</span>
<span class="udiff-line-removed">-       IdealLoopTree* n_dom_loop = phase-&gt;get_loop(n_dom);</span>
<span class="udiff-line-removed">-       if (n-&gt;is_IfProj() &amp;&amp; n_dom-&gt;outcnt() == 2) {</span>
<span class="udiff-line-removed">-         n_dom_loop = phase-&gt;get_loop(n_dom-&gt;as_If()-&gt;proj_out(n-&gt;as_Proj()-&gt;_con == 0 ? 1 : 0));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (n_dom_loop != phase-&gt;ltree_root()) {</span>
<span class="udiff-line-removed">-         Node* tail = n_dom_loop-&gt;tail();</span>
<span class="udiff-line-removed">-         if (tail-&gt;is_Region()) {</span>
<span class="udiff-line-removed">-           for (uint j = 1; j &lt; tail-&gt;req(); j++) {</span>
<span class="udiff-line-removed">-             if (phase-&gt;is_dominator(n_dom, tail-&gt;in(j)) &amp;&amp; !phase-&gt;is_dominator(n, tail-&gt;in(j))) {</span>
<span class="udiff-line-removed">-               assert(phase-&gt;is_dominator(rep_ctrl, tail-&gt;in(j)), &quot;why are we here?&quot;);</span>
<span class="udiff-line-removed">-               // entering loop from below, mark backedge</span>
<span class="udiff-line-removed">-               if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;in(j)-&gt;dump(); }</span>
<span class="udiff-line-removed">-               controls.push(tail-&gt;in(j));</span>
<span class="udiff-line-removed">-               //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         } else if (phase-&gt;get_loop(n) != n_dom_loop &amp;&amp; phase-&gt;is_dominator(n_dom, tail)) {</span>
<span class="udiff-line-removed">-           // entering loop from below, mark backedge</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;dump(); }</span>
<span class="udiff-line-removed">-           controls.push(tail);</span>
<span class="udiff-line-removed">-           //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n-&gt;is_Loop()) {</span>
<span class="udiff-line-removed">-       Node* c = n-&gt;in(LoopNode::EntryControl);</span>
<span class="udiff-line-removed">-       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="udiff-line-removed">-       controls.push(c);</span>
<span class="udiff-line-removed">-     } else if (n-&gt;is_Region()) {</span>
<span class="udiff-line-removed">-       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="udiff-line-removed">-         Node* c = n-&gt;in(i);</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="udiff-line-removed">-         controls.push(c);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       Node* c = n-&gt;in(0);</span>
<span class="udiff-line-removed">-       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="udiff-line-removed">-       controls.push(c);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahWriteBarrierNode::memory_dominates_all_paths(Node* mem, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   const bool trace = false;</span>
<span class="udiff-line-removed">-   if (trace) {</span>
<span class="udiff-line-removed">-     tty-&gt;print(&quot;XXX mem is&quot;); mem-&gt;dump();</span>
<span class="udiff-line-removed">-     tty-&gt;print(&quot;XXX rep ctrl is&quot;); rep_ctrl-&gt;dump();</span>
<span class="udiff-line-removed">-     tty-&gt;print_cr(&quot;XXX alias is %d&quot;, alias);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   Unique_Node_List wq;</span>
<span class="udiff-line-removed">-   Unique_Node_List controls;</span>
<span class="udiff-line-removed">-   wq.push(mem);</span>
<span class="udiff-line-removed">-   for (uint next = 0; next &lt; wq.size(); next++) {</span>
<span class="udiff-line-removed">-     Node *nn = wq.at(next);</span>
<span class="udiff-line-removed">-     if (trace) { tty-&gt;print(&quot;XX from mem&quot;); nn-&gt;dump(); }</span>
<span class="udiff-line-removed">-     assert(nn-&gt;bottom_type() == Type::MEMORY, &quot;memory only&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (nn-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-       Node* r = nn-&gt;in(0);</span>
<span class="udiff-line-removed">-       for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-removed">-         Node* u = r-&gt;fast_out(j);</span>
<span class="udiff-line-removed">-         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u != nn &amp;&amp;</span>
<span class="udiff-line-removed">-             (u-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias)) {</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XX Next mem (other phi)&quot;); u-&gt;dump(); }</span>
<span class="udiff-line-removed">-           wq.push(u);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (DUIterator_Fast imax, i = nn-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node* use = nn-&gt;fast_out(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (trace) { tty-&gt;print(&quot;XX use %p&quot;, use-&gt;adr_type()); use-&gt;dump(); }</span>
<span class="udiff-line-removed">-       if (use-&gt;is_CFG() &amp;&amp; use-&gt;in(TypeFunc::Memory) == nn) {</span>
<span class="udiff-line-removed">-         Node* c = use-&gt;in(0);</span>
<span class="udiff-line-removed">-         if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="udiff-line-removed">-           memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="udiff-line-removed">-         } else if (use-&gt;is_CallStaticJava() &amp;&amp; use-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0 &amp;&amp; c-&gt;is_Region()) {</span>
<span class="udiff-line-removed">-           Node* region = c;</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XX unc region&quot;); region-&gt;dump(); }</span>
<span class="udiff-line-removed">-           for (uint j = 1; j &lt; region-&gt;req(); j++) {</span>
<span class="udiff-line-removed">-             if (phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {</span>
<span class="udiff-line-removed">-               if (trace) { tty-&gt;print(&quot;XX unc follows&quot;); region-&gt;in(j)-&gt;dump(); }</span>
<span class="udiff-line-removed">-               memory_dominates_all_paths_helper(region-&gt;in(j), rep_ctrl, controls, phase);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         //continue;</span>
<span class="udiff-line-removed">-       } else if (use-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="udiff-line-removed">-         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="udiff-line-removed">-             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="udiff-line-removed">-           for (uint j = 1; j &lt; use-&gt;req(); j++) {</span>
<span class="udiff-line-removed">-             if (use-&gt;in(j) == nn) {</span>
<span class="udiff-line-removed">-               Node* c = use-&gt;in(0)-&gt;in(j);</span>
<span class="udiff-line-removed">-               if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="udiff-line-removed">-                 memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         //        continue;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (use-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-         if (use-&gt;as_MergeMem()-&gt;memory_at(alias) == nn) {</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="udiff-line-removed">-           // follow the memory edges</span>
<span class="udiff-line-removed">-           wq.push(use);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else if (use-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="udiff-line-removed">-         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="udiff-line-removed">-             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="udiff-line-removed">-           // follow the memory edges</span>
<span class="udiff-line-removed">-           wq.push(use);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else if (use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="udiff-line-removed">-                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="udiff-line-removed">-         // follow the memory edges</span>
<span class="udiff-line-removed">-         wq.push(use);</span>
<span class="udiff-line-removed">-       } else if ((use-&gt;is_SafePoint() || use-&gt;is_MemBar()) &amp;&amp;</span>
<span class="udiff-line-removed">-                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="udiff-line-removed">-         for (DUIterator_Fast jmax, j = use-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-removed">-           Node* u = use-&gt;fast_out(j);</span>
<span class="udiff-line-removed">-           if (u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="udiff-line-removed">-             if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); u-&gt;dump(); }</span>
<span class="udiff-line-removed">-             // follow the memory edges</span>
<span class="udiff-line-removed">-             wq.push(u);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else if (use-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="udiff-line-removed">-         Node* m = use-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-         if (m != NULL) {</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); m-&gt;dump(); }</span>
<span class="udiff-line-removed">-           // follow the memory edges</span>
<span class="udiff-line-removed">-           wq.push(m);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (controls.size() == 0) {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (uint i = 0; i &lt; controls.size(); i++) {</span>
<span class="udiff-line-removed">-     Node *n = controls.at(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (trace) { tty-&gt;print(&quot;X checking&quot;); n-&gt;dump(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n-&gt;unique_ctrl_out() != NULL) {</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (n-&gt;Opcode() == Op_NeverBranch) {</span>
<span class="udiff-line-removed">-       Node* taken = n-&gt;as_Multi()-&gt;proj_out(0);</span>
<span class="udiff-line-removed">-       if (!controls.member(taken)) {</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print(&quot;X not seen&quot;); taken-&gt;dump(); }</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-removed">-       Node* u = n-&gt;fast_out(j);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (u-&gt;is_CFG()) {</span>
<span class="udiff-line-removed">-         if (!controls.member(u)) {</span>
<span class="udiff-line-removed">-           if (u-&gt;is_Proj() &amp;&amp; u-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {</span>
<span class="udiff-line-removed">-             if (trace) { tty-&gt;print(&quot;X not seen but unc&quot;); u-&gt;dump(); }</span>
<span class="udiff-line-removed">-           } else {</span>
<span class="udiff-line-removed">-             Node* c = u;</span>
<span class="udiff-line-removed">-             do {</span>
<span class="udiff-line-removed">-               c = c-&gt;unique_ctrl_out();</span>
<span class="udiff-line-removed">-             } while (c != NULL &amp;&amp; c-&gt;is_Region());</span>
<span class="udiff-line-removed">-             if (c != NULL &amp;&amp; c-&gt;Opcode() == Op_Halt) {</span>
<span class="udiff-line-removed">-               if (trace) { tty-&gt;print(&quot;X not seen but halt&quot;); c-&gt;dump(); }</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-               if (trace) { tty-&gt;print(&quot;X not seen&quot;); u-&gt;dump(); }</span>
<span class="udiff-line-removed">-               return false;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;X seen&quot;); u-&gt;dump(); }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node*&amp; mem_ctrl, Node* n, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   VectorSet wq(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-removed">-   wq.set(mem-&gt;_idx);</span>
<span class="udiff-line-removed">-   mem_ctrl = phase-&gt;get_ctrl(mem);</span>
<span class="udiff-line-removed">-   while (!is_dominator(mem_ctrl, rep_ctrl, mem, n, phase)) {</span>
<span class="udiff-line-removed">-     mem = next_mem(mem, alias);</span>
<span class="udiff-line-removed">-     if (wq.test_set(mem-&gt;_idx)) {</span>
<span class="udiff-line-removed">-       return NULL; // hit an unexpected loop</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (mem-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="udiff-line-removed">-     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return mem;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierC2Support::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {</span>
    ResourceMark rm;
    VectorSet wq(Thread::current()-&gt;resource_area());
    wq.set(mem-&gt;_idx);
    mem_ctrl = phase-&gt;ctrl_or_self(mem);
    while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1653,801 +806,158 @@</span>
      mem_ctrl = phase-&gt;ctrl_or_self(mem);
    }
    return mem;
  }
  
<span class="udiff-line-modified-removed">- static void disconnect_barrier_mem(Node* wb, PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-modified-removed">-   Node* mem_in = wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="udiff-line-modified-removed">-   Node* proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   for (DUIterator_Last imin, i = proj-&gt;last_outs(imin); i &gt;= imin; ) {</span>
<span class="udiff-line-modified-removed">-     Node* u = proj-&gt;last_out(i);</span>
<span class="udiff-line-modified-removed">-     igvn.rehash_node_delayed(u);</span>
<span class="udiff-line-modified-removed">-     int nb = u-&gt;replace_edge(proj, mem_in);</span>
<span class="udiff-line-modified-removed">-     assert(nb &gt; 0, &quot;no replacement?&quot;);</span>
<span class="udiff-line-modified-removed">-     i -= nb;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- Node* ShenandoahWriteBarrierNode::move_above_predicates(LoopNode* cl, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-removed">-   Node* entry = cl-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl);</span>
<span class="udiff-line-modified-removed">-   Node* above_pred = phase-&gt;skip_all_loop_predicates(entry);</span>
<span class="udiff-line-modified-removed">-   Node* ctrl = entry;</span>
<span class="udiff-line-modified-removed">-   while (ctrl != above_pred) {</span>
<span class="udiff-line-modified-removed">-     Node* next = ctrl-&gt;in(0);</span>
<span class="udiff-line-modified-removed">-     if (!phase-&gt;is_dominator(val_ctrl, next)) {</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   Node* mem = NULL;</span>
<span class="udiff-line-modified-added">+   Node* c = ctrl;</span>
<span class="udiff-line-modified-added">+   do {</span>
<span class="udiff-line-modified-added">+     if (c-&gt;is_Region()) {</span>
<span class="udiff-line-modified-added">+       Node* phi_bottom = NULL;</span>
<span class="udiff-line-modified-added">+       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="udiff-line-modified-added">+         Node* u = c-&gt;fast_out(i);</span>
<span class="udiff-line-modified-added">+         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="udiff-line-modified-added">+           if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-modified-added">+             mem = u;</span>
<span class="udiff-line-modified-added">+           }</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {</span>
<span class="udiff-line-modified-added">+         CallProjections projs;</span>
<span class="udiff-line-modified-added">+         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="udiff-line-modified-added">+         if (projs.fallthrough_memproj != NULL) {</span>
<span class="udiff-line-modified-added">+           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-modified-added">+             if (projs.catchall_memproj == NULL) {</span>
<span class="udiff-line-added">+               mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="udiff-line-added">+                 mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-added">+               } else {</span>
<span class="udiff-line-added">+                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="udiff-line-added">+                 mem = projs.catchall_memproj;</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);</span>
<span class="udiff-line-added">+           if (proj != NULL &amp;&amp;</span>
<span class="udiff-line-added">+               proj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-added">+             mem = proj;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+           Node* u = c-&gt;fast_out(i);</span>
<span class="udiff-line-added">+           if (u-&gt;is_Proj() &amp;&amp;</span>
<span class="udiff-line-added">+               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="udiff-line-added">+               u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-added">+               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);</span>
<span class="udiff-line-added">+               assert(mem == NULL, &quot;only one proj&quot;);</span>
<span class="udiff-line-added">+               mem = u;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);</span>
<span class="udiff-line-added">+       }</span>
      }
<span class="udiff-line-modified-removed">-     ctrl = next;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   return ctrl;</span>
<span class="udiff-line-modified-added">+     c = phase-&gt;idom(c);</span>
<span class="udiff-line-modified-added">+   } while (mem == NULL);</span>
<span class="udiff-line-modified-added">+   return mem;</span>
  }
  
<span class="udiff-line-modified-removed">- static MemoryGraphFixer* find_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias) {</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; memory_graph_fixers.length(); i++) {</span>
<span class="udiff-line-modified-removed">-     if (memory_graph_fixers.at(i)-&gt;alias() == alias) {</span>
<span class="udiff-line-modified-removed">-       return memory_graph_fixers.at(i);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-added">+     Node* u = n-&gt;fast_out(i);</span>
<span class="udiff-line-modified-added">+     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {</span>
<span class="udiff-line-added">+       uses.push(u);</span>
      }
    }
<span class="udiff-line-removed">-   return NULL;</span>
  }
  
<span class="udiff-line-modified-removed">- static MemoryGraphFixer* create_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias, PhaseIdealLoop* phase, bool include_lsm) {</span>
<span class="udiff-line-modified-removed">-   assert(find_fixer(memory_graph_fixers, alias) == NULL, &quot;none should exist yet&quot;);</span>
<span class="udiff-line-modified-removed">-   MemoryGraphFixer* fixer = new MemoryGraphFixer(alias, include_lsm, phase);</span>
<span class="udiff-line-modified-removed">-   memory_graph_fixers.push(fixer);</span>
<span class="udiff-line-modified-removed">-   return fixer;</span>
<span class="udiff-line-modified-added">+ static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();</span>
<span class="udiff-line-modified-added">+   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));</span>
<span class="udiff-line-modified-added">+   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);</span>
<span class="udiff-line-added">+   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));</span>
<span class="udiff-line-added">+   phase-&gt;lazy_replace(outer, new_outer);</span>
<span class="udiff-line-added">+   phase-&gt;lazy_replace(le, new_le);</span>
<span class="udiff-line-added">+   inner-&gt;clear_strip_mined();</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::try_move_before_loop_helper(LoopNode* cl, Node* val_ctrl, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="udiff-line-modified-removed">-   assert(cl-&gt;is_Loop(), &quot;bad control&quot;);</span>
<span class="udiff-line-modified-removed">-   Node* ctrl = move_above_predicates(cl, val_ctrl, phase);</span>
<span class="udiff-line-modified-removed">-   Node* mem_ctrl = NULL;</span>
<span class="udiff-line-modified-removed">-   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="udiff-line-modified-removed">-   if (fixer == NULL) {</span>
<span class="udiff-line-modified-removed">-     fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   fixer-&gt;remove(proj);</span>
<span class="udiff-line-removed">-   Node* mem = fixer-&gt;find_mem(ctrl, NULL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(!ShenandoahVerifyOptoBarriers || memory_dominates_all_paths(mem, ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   phase-&gt;set_ctrl_and_loop(this, ctrl);</span>
<span class="udiff-line-removed">-   phase-&gt;igvn().replace_input_of(this, Control, ctrl);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="udiff-line-modified-added">+                                                   PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-modified-added">+   Node* thread = new ThreadLocalNode();</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_new_node(thread, ctrl);</span>
<span class="udiff-line-modified-added">+   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-modified-added">+   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());</span>
<span class="udiff-line-modified-added">+   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_new_node(gc_state_addr, ctrl);</span>
<span class="udiff-line-modified-added">+   uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="udiff-line-modified-added">+   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="udiff-line-modified-added">+   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
  
<span class="udiff-line-modified-removed">-   disconnect_barrier_mem(this, phase-&gt;igvn());</span>
<span class="udiff-line-modified-added">+   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);</span>
<span class="udiff-line-added">+   phase-&gt;register_new_node(gc_state, ctrl);</span>
<span class="udiff-line-added">+   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
<span class="udiff-line-added">+   phase-&gt;register_new_node(heap_stable_and, ctrl);</span>
<span class="udiff-line-added">+   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));</span>
<span class="udiff-line-added">+   phase-&gt;register_new_node(heap_stable_cmp, ctrl);</span>
<span class="udiff-line-added">+   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);</span>
<span class="udiff-line-added">+   phase-&gt;register_new_node(heap_stable_test, ctrl);</span>
<span class="udiff-line-added">+   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="udiff-line-added">+   phase-&gt;register_control(heap_stable_iff, loop, ctrl);</span>
  
<span class="udiff-line-modified-removed">-   phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="udiff-line-modified-removed">-   phase-&gt;set_ctrl_and_loop(proj, ctrl);</span>
<span class="udiff-line-modified-added">+   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);</span>
<span class="udiff-line-added">+   ctrl = new IfTrueNode(heap_stable_iff);</span>
<span class="udiff-line-added">+   phase-&gt;register_control(ctrl, loop, heap_stable_iff);</span>
  
<span class="udiff-line-modified-removed">-   fixer-&gt;fix_mem(ctrl, ctrl, mem, mem, proj, uses);</span>
<span class="udiff-line-removed">-   assert(proj-&gt;outcnt() &gt; 0, &quot;disconnected write barrier&quot;);</span>
<span class="udiff-line-modified-added">+   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>
  }
  
<span class="udiff-line-modified-removed">- LoopNode* ShenandoahWriteBarrierNode::try_move_before_pre_loop(Node* c, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-removed">-   // A write barrier between a pre and main loop can get in the way of</span>
<span class="udiff-line-modified-removed">-   // vectorization. Move it above the pre loop if possible</span>
<span class="udiff-line-modified-removed">-   CountedLoopNode* cl = NULL;</span>
<span class="udiff-line-modified-removed">-   if (c-&gt;is_IfFalse() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       c-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="udiff-line-modified-removed">-     cl = c-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="udiff-line-modified-removed">-   } else if (c-&gt;is_IfProj() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              c-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              c-&gt;in(0)-&gt;in(0)-&gt;is_IfFalse() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-              c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="udiff-line-modified-removed">-     cl = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (cl != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-       cl-&gt;is_pre_loop() &amp;&amp;</span>
<span class="udiff-line-removed">-       val_ctrl != cl &amp;&amp;</span>
<span class="udiff-line-removed">-       phase-&gt;is_dominator(val_ctrl, cl)) {</span>
<span class="udiff-line-removed">-     return cl;</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   const Type* val_t = phase-&gt;igvn().type(val);</span>
<span class="udiff-line-modified-added">+   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {</span>
<span class="udiff-line-modified-added">+     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-modified-added">+     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(null_cmp, ctrl);</span>
<span class="udiff-line-modified-added">+     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(null_test, ctrl);</span>
<span class="udiff-line-modified-added">+     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(null_iff, loop, ctrl);</span>
<span class="udiff-line-modified-added">+     ctrl = new IfTrueNode(null_iff);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(ctrl, loop, null_iff);</span>
<span class="udiff-line-modified-added">+     null_ctrl = new IfFalseNode(null_iff);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(null_ctrl, loop, null_iff);</span>
    }
<span class="udiff-line-removed">-   return NULL;</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::try_move_before_loop(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="udiff-line-modified-removed">-   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-modified-removed">-   IdealLoopTree *n_loop = phase-&gt;get_loop(n_ctrl);</span>
<span class="udiff-line-modified-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-modified-removed">-   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="udiff-line-modified-removed">-   if (n_loop != phase-&gt;ltree_root() &amp;&amp; !n_loop-&gt;_irreducible) {</span>
<span class="udiff-line-modified-removed">-     IdealLoopTree *val_loop = phase-&gt;get_loop(val_ctrl);</span>
<span class="udiff-line-modified-removed">-     Node* mem = in(Memory);</span>
<span class="udiff-line-modified-removed">-     IdealLoopTree *mem_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(mem));</span>
<span class="udiff-line-modified-removed">-     if (!n_loop-&gt;is_member(val_loop) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         n_loop-&gt;is_member(mem_loop)) {</span>
<span class="udiff-line-modified-removed">-       Node* n_loop_head = n_loop-&gt;_head;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       if (n_loop_head-&gt;is_Loop()) {</span>
<span class="udiff-line-modified-removed">-         LoopNode* loop = n_loop_head-&gt;as_Loop();</span>
<span class="udiff-line-modified-removed">-         if (n_loop_head-&gt;is_CountedLoop() &amp;&amp; n_loop_head-&gt;as_CountedLoop()-&gt;is_main_loop()) {</span>
<span class="udiff-line-modified-removed">-           LoopNode* res = try_move_before_pre_loop(n_loop_head-&gt;in(LoopNode::EntryControl), val_ctrl, phase);</span>
<span class="udiff-line-modified-removed">-           if (res != NULL) {</span>
<span class="udiff-line-modified-removed">-             loop = res;</span>
<span class="udiff-line-modified-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="udiff-line-modified-added">+   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="udiff-line-modified-added">+   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="udiff-line-modified-added">+   Node* new_iff = iff-&gt;clone();</span>
<span class="udiff-line-modified-added">+   new_iff-&gt;set_req(0, c);</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="udiff-line-modified-added">+   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="udiff-line-modified-added">+   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="udiff-line-modified-added">+   c = iftrue;</span>
<span class="udiff-line-modified-added">+   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="udiff-line-modified-added">+   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="udiff-line-modified-added">+   Node* uncasted_val = val-&gt;in(1);</span>
<span class="udiff-line-modified-added">+   val = new CastPPNode(uncasted_val, t);</span>
<span class="udiff-line-modified-added">+   val-&gt;init_req(0, c);</span>
<span class="udiff-line-modified-added">+   phase-&gt;register_new_node(val, c);</span>
<span class="udiff-line-modified-added">+   return val;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-         try_move_before_loop_helper(loop, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   LoopNode* ctrl = try_move_before_pre_loop(in(0), val_ctrl, phase);</span>
<span class="udiff-line-removed">-   if (ctrl != NULL) {</span>
<span class="udiff-line-removed">-     try_move_before_loop_helper(ctrl, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::would_subsume(ShenandoahBarrierNode* other, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-removed">-   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="udiff-line-removed">-   Node* other_mem = other-&gt;in(Memory);</span>
<span class="udiff-line-removed">-   Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="udiff-line-removed">-   Node* this_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-removed">-   IdealLoopTree* this_loop = phase-&gt;get_loop(this_ctrl);</span>
<span class="udiff-line-removed">-   IdealLoopTree* other_loop = phase-&gt;get_loop(other_ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* ctrl = phase-&gt;dom_lca(other_ctrl, this_ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="udiff-line-removed">-       ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="udiff-line-removed">-       ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-       ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch &amp;&amp;</span>
<span class="udiff-line-removed">-       !phase-&gt;is_dominator(val_ctrl, ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // We don&#39;t want to move a write barrier in a loop</span>
<span class="udiff-line-removed">-   // If the LCA is in a inner loop, try a control out of loop if possible</span>
<span class="udiff-line-removed">-   while (!loop-&gt;is_member(this_loop) &amp;&amp; (other-&gt;Opcode() != Op_ShenandoahWriteBarrier || !loop-&gt;is_member(other_loop))) {</span>
<span class="udiff-line-removed">-     ctrl = phase-&gt;idom(ctrl);</span>
<span class="udiff-line-removed">-     if (ctrl-&gt;is_MultiBranch()) {</span>
<span class="udiff-line-removed">-       ctrl = ctrl-&gt;in(0);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (ctrl != val_ctrl &amp;&amp; phase-&gt;is_dominator(ctrl, val_ctrl)) {</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (ShenandoahDontIncreaseWBFreq) {</span>
<span class="udiff-line-removed">-     Node* this_iffproj = no_branches(this_ctrl, ctrl, true, phase);</span>
<span class="udiff-line-removed">-     if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-       Node* other_iffproj = no_branches(other_ctrl, ctrl, true, phase);</span>
<span class="udiff-line-removed">-       if (other_iffproj == NULL || this_iffproj == NULL) {</span>
<span class="udiff-line-removed">-         return ctrl;</span>
<span class="udiff-line-removed">-       } else if (other_iffproj != NodeSentinel &amp;&amp; this_iffproj != NodeSentinel &amp;&amp;</span>
<span class="udiff-line-removed">-                  other_iffproj-&gt;in(0) == this_iffproj-&gt;in(0)) {</span>
<span class="udiff-line-removed">-         return ctrl;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else if (this_iffproj == NULL) {</span>
<span class="udiff-line-removed">-       return ctrl;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return ctrl;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::optimize_before_expansion(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers, bool include_lsm) {</span>
<span class="udiff-line-removed">-   bool progress = false;</span>
<span class="udiff-line-removed">-   Unique_Node_List uses;</span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-removed">-     progress = false;</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="udiff-line-removed">-       ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       wb-&gt;try_move_before_loop(memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       Node* val = wb-&gt;in(ValueIn);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-removed">-         Node* u = val-&gt;fast_out(j);</span>
<span class="udiff-line-removed">-         if (u != wb &amp;&amp; u-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-           Node* rep_ctrl = wb-&gt;would_subsume(u-&gt;as_ShenandoahBarrier(), phase);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           if (rep_ctrl != NULL) {</span>
<span class="udiff-line-removed">-             Node* other = u;</span>
<span class="udiff-line-removed">-             Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="udiff-line-removed">-             if (rep_ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="udiff-line-removed">-                 rep_ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="udiff-line-removed">-                 rep_ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-                 rep_ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch) {</span>
<span class="udiff-line-removed">-               rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               assert(phase-&gt;is_dominator(val_ctrl, rep_ctrl), &quot;bad control&quot;);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-               LoopNode* c = ShenandoahWriteBarrierNode::try_move_before_pre_loop(rep_ctrl, val_ctrl, phase);</span>
<span class="udiff-line-removed">-               if (c != NULL) {</span>
<span class="udiff-line-removed">-                 rep_ctrl = ShenandoahWriteBarrierNode::move_above_predicates(c, val_ctrl, phase);</span>
<span class="udiff-line-removed">-               } else {</span>
<span class="udiff-line-removed">-                 while (rep_ctrl-&gt;is_IfProj()) {</span>
<span class="udiff-line-removed">-                   CallStaticJavaNode* unc = rep_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="udiff-line-removed">-                   if (unc != NULL) {</span>
<span class="udiff-line-removed">-                     int req = unc-&gt;uncommon_trap_request();</span>
<span class="udiff-line-removed">-                     Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);</span>
<span class="udiff-line-removed">-                     if ((trap_reason == Deoptimization::Reason_loop_limit_check ||</span>
<span class="udiff-line-removed">-                          trap_reason == Deoptimization::Reason_predicate ||</span>
<span class="udiff-line-removed">-                          trap_reason == Deoptimization::Reason_profile_predicate) &amp;&amp;</span>
<span class="udiff-line-removed">-                         phase-&gt;is_dominator(val_ctrl, rep_ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="udiff-line-removed">-                       rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="udiff-line-removed">-                       continue;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                   }</span>
<span class="udiff-line-removed">-                   break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Node* wb_ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="udiff-line-removed">-             Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="udiff-line-removed">-             int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="udiff-line-removed">-             MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);;</span>
<span class="udiff-line-removed">-             if (!is_dominator(wb_ctrl, other_ctrl, wb, other, phase)) {</span>
<span class="udiff-line-removed">-               if (fixer == NULL) {</span>
<span class="udiff-line-removed">-                 fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-               Node* mem = fixer-&gt;find_mem(rep_ctrl, phase-&gt;get_ctrl(other) == rep_ctrl ? other : NULL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               if (mem-&gt;has_out_with(Op_Lock) || mem-&gt;has_out_with(Op_Unlock)) {</span>
<span class="udiff-line-removed">-                 continue;</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               Node* wb_proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-               fixer-&gt;remove(wb_proj);</span>
<span class="udiff-line-removed">-               Node* mem_for_ctrl = fixer-&gt;find_mem(rep_ctrl, NULL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               if (wb-&gt;in(Memory) != mem) {</span>
<span class="udiff-line-removed">-                 disconnect_barrier_mem(wb, phase-&gt;igvn());</span>
<span class="udiff-line-removed">-                 phase-&gt;igvn().replace_input_of(wb, Memory, mem);</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-               if (rep_ctrl != wb_ctrl) {</span>
<span class="udiff-line-removed">-                 phase-&gt;set_ctrl_and_loop(wb, rep_ctrl);</span>
<span class="udiff-line-removed">-                 phase-&gt;igvn().replace_input_of(wb, Control, rep_ctrl);</span>
<span class="udiff-line-removed">-                 phase-&gt;set_ctrl_and_loop(wb_proj, rep_ctrl);</span>
<span class="udiff-line-removed">-                 progress = true;</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               fixer-&gt;fix_mem(rep_ctrl, rep_ctrl, mem, mem_for_ctrl, wb_proj, uses);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-               assert(!ShenandoahVerifyOptoBarriers || ShenandoahWriteBarrierNode::memory_dominates_all_paths(mem, rep_ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-               Node* other_proj = other-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-               if (fixer != NULL) {</span>
<span class="udiff-line-removed">-                 fixer-&gt;remove(other_proj);</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-               phase-&gt;igvn().replace_node(other_proj, other-&gt;in(Memory));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             phase-&gt;igvn().replace_node(other, wb);</span>
<span class="udiff-line-removed">-             --j; --jmax;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } while(progress);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Some code duplication with PhaseIdealLoop::split_if_with_blocks_pre()</span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::try_split_thru_phi(PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   Node *ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-removed">-   if (ctrl == NULL) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   Node *blk = phase-&gt;has_local_phi_input(this);</span>
<span class="udiff-line-removed">-   if (blk == NULL) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (in(0) != blk) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int policy = blk-&gt;req() &gt;&gt; 2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (blk-&gt;is_CountedLoop()) {</span>
<span class="udiff-line-removed">-     IdealLoopTree *lp = phase-&gt;get_loop(blk);</span>
<span class="udiff-line-removed">-     if (lp &amp;&amp; lp-&gt;_rce_candidate) {</span>
<span class="udiff-line-removed">-       return this;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (phase-&gt;C-&gt;live_nodes() &gt; 35000) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint unique = phase-&gt;C-&gt;unique();</span>
<span class="udiff-line-removed">-   Node *phi = phase-&gt;split_thru_phi(this, blk, policy);</span>
<span class="udiff-line-removed">-   if (phi == NULL) {</span>
<span class="udiff-line-removed">-     return this;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* mem_phi = new PhiNode(blk, Type::MEMORY, phase-&gt;C-&gt;alias_type(adr_type())-&gt;adr_type());</span>
<span class="udiff-line-removed">-   for (uint i = 1; i &lt; blk-&gt;req(); i++) {</span>
<span class="udiff-line-removed">-     Node* n = phi-&gt;in(i);</span>
<span class="udiff-line-removed">-     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="udiff-line-removed">-         n-&gt;_idx &gt;= unique) {</span>
<span class="udiff-line-removed">-       Node* proj = new ShenandoahWBMemProjNode(n);</span>
<span class="udiff-line-removed">-       phase-&gt;register_new_node(proj, phase-&gt;get_ctrl(n));</span>
<span class="udiff-line-removed">-       mem_phi-&gt;init_req(i, proj);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       Node* mem = in(ShenandoahBarrierNode::Memory);</span>
<span class="udiff-line-removed">-       if (mem-&gt;is_Phi() &amp;&amp; mem-&gt;in(0) == blk) {</span>
<span class="udiff-line-removed">-         mem = mem-&gt;in(i);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       mem_phi-&gt;init_req(i, mem);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(mem_phi, blk);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-   phase-&gt;igvn().replace_node(proj, mem_phi);</span>
<span class="udiff-line-removed">-   phase-&gt;igvn().replace_node(this, phi);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return phi;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahReadBarrierNode::try_move(PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-removed">-   if (n_ctrl == NULL) {</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   Node* mem = in(MemNode::Memory);</span>
<span class="udiff-line-removed">-   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="udiff-line-removed">-   const bool trace = false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-   if (trace) { tty-&gt;print(&quot;Trying to move mem of&quot;); dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* new_mem = mem;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">-   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-removed">-   Node_List phis;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (;;) {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-     if (trace) { tty-&gt;print(&quot;Looking for dominator from&quot;); mem-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Start()) {</span>
<span class="udiff-line-removed">-       if (new_mem != in(MemNode::Memory)) {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* candidate = mem;</span>
<span class="udiff-line-removed">-     do {</span>
<span class="udiff-line-removed">-       if (!is_independent(mem)) {</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="udiff-line-removed">-         if (new_mem != in(MemNode::Memory)) {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (seen.test_set(mem-&gt;_idx)) {</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print_cr(&quot;Already seen&quot;); }</span>
<span class="udiff-line-removed">-         ShouldNotReachHere();</span>
<span class="udiff-line-removed">-         // Strange graph</span>
<span class="udiff-line-removed">-         if (new_mem != in(MemNode::Memory)) {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (mem-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-         phis.push(mem);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       mem = next_mem(mem, alias);</span>
<span class="udiff-line-removed">-       if (mem-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="udiff-line-removed">-         candidate = mem;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       assert(is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl, mem, this, phase) == phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl), &quot;strange dominator&quot;);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       if (trace) { tty-&gt;print(&quot;Next mem is&quot;); mem-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     } while (mem-&gt;bottom_type() != Type::MEMORY || !phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;bad mem&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bool not_dom = false;</span>
<span class="udiff-line-removed">-     for (uint i = 0; i &lt; phis.size() &amp;&amp; !not_dom; i++) {</span>
<span class="udiff-line-removed">-       Node* nn = phis.at(i);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-       if (trace) { tty-&gt;print(&quot;Looking from phi&quot;); nn-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       assert(nn-&gt;is_Phi(), &quot;phis only&quot;);</span>
<span class="udiff-line-removed">-       for (uint j = 2; j &lt; nn-&gt;req() &amp;&amp; !not_dom; j++) {</span>
<span class="udiff-line-removed">-         Node* m = nn-&gt;in(j);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-         if (trace) { tty-&gt;print(&quot;Input %d is&quot;, j); m-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         while (m != mem &amp;&amp; !seen.test_set(m-&gt;_idx)) {</span>
<span class="udiff-line-removed">-           if (is_dominator(phase-&gt;ctrl_or_self(m), phase-&gt;ctrl_or_self(mem), m, mem, phase)) {</span>
<span class="udiff-line-removed">-             not_dom = true;</span>
<span class="udiff-line-removed">-             // Scheduling anomaly</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-             if (trace) { tty-&gt;print(&quot;Giving up&quot;); m-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           if (!is_independent(m)) {</span>
<span class="udiff-line-removed">-             if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="udiff-line-removed">-             if (new_mem != in(MemNode::Memory)) {</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-               if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-               phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           if (m-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-             phis.push(m);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           m = next_mem(m, alias);</span>
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">-           if (trace) { tty-&gt;print(&quot;Next mem is&quot;); m-&gt;dump(); }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (!not_dom) {</span>
<span class="udiff-line-removed">-       new_mem = mem;</span>
<span class="udiff-line-removed">-       phis.clear();</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       seen.Clear();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- CallStaticJavaNode* ShenandoahWriteBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const Type* val_t = igvn.type(val);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="udiff-line-removed">-       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-removed">-     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="udiff-line-removed">-     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="udiff-line-removed">-     return unc;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::pin_and_expand_move_barrier(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, Unique_Node_List&amp; uses) {</span>
<span class="udiff-line-removed">-   Node* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="udiff-line-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (unc != NULL) {</span>
<span class="udiff-line-removed">-     Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-removed">-     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Don&#39;t move write barrier in a loop</span>
<span class="udiff-line-removed">-     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">-     IdealLoopTree* unc_loop = phase-&gt;get_loop(unc_ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* branch = no_branches(ctrl, unc_ctrl, false, phase);</span>
<span class="udiff-line-removed">-     assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="udiff-line-removed">-     if (branch == NodeSentinel) {</span>
<span class="udiff-line-removed">-       return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     RegionNode* r = new RegionNode(3);</span>
<span class="udiff-line-removed">-     IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="udiff-line-removed">-     Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="udiff-line-removed">-     Node* c = unc_ctrl_clone;</span>
<span class="udiff-line-removed">-     Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="udiff-line-removed">-     r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="udiff-line-removed">-     phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="udiff-line-removed">-     phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="udiff-line-removed">-     c = NULL;;</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="udiff-line-removed">-     phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-removed">-     fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="udiff-line-removed">-     Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="udiff-line-removed">-     r-&gt;init_req(2, iff_proj);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="udiff-line-removed">-     Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="udiff-line-removed">-     assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="udiff-line-removed">-     assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="udiff-line-removed">-     new_bol-&gt;set_req(1, new_cmp);</span>
<span class="udiff-line-removed">-     new_cmp-&gt;set_req(1, this);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(new_cast, 1, this);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (DUIterator_Fast imax, i = this-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node* u = this-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       if (u == new_cast || u-&gt;Opcode() == Op_ShenandoahWBMemProj || u == new_cmp) {</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-removed">-       int nb = u-&gt;replace_edge(this, new_cast);</span>
<span class="udiff-line-removed">-       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="udiff-line-removed">-       --i; imax -= nb;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node* u = val-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       if (u == this) {</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-removed">-       int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="udiff-line-removed">-       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="udiff-line-removed">-       --i; imax -= nb;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* new_ctrl = unc_ctrl_clone;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="udiff-line-removed">-     MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="udiff-line-removed">-     if (fixer == NULL) {</span>
<span class="udiff-line-removed">-       fixer = create_fixer(memory_graph_fixers, alias, phase, true);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-     fixer-&gt;remove(proj);</span>
<span class="udiff-line-removed">-     Node* mem = fixer-&gt;find_mem(new_ctrl, NULL);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (in(Memory) != mem) {</span>
<span class="udiff-line-removed">-       disconnect_barrier_mem(this, phase-&gt;igvn());</span>
<span class="udiff-line-removed">-       phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;set_ctrl_and_loop(this, new_ctrl);</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(this, Control, new_ctrl);</span>
<span class="udiff-line-removed">-     phase-&gt;set_ctrl_and_loop(proj, new_ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     fixer-&gt;fix_mem(new_ctrl, new_ctrl, mem, mem, proj, uses);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::pin_and_expand_helper(PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   Node* val = in(ValueIn);</span>
<span class="udiff-line-removed">-   CallStaticJavaNode* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="udiff-line-removed">-   Node* rep = this;</span>
<span class="udiff-line-removed">-   Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="udiff-line-removed">-   if (unc != NULL &amp;&amp; val-&gt;in(0) == ctrl) {</span>
<span class="udiff-line-removed">-     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="udiff-line-removed">-     IfNode* other_iff = unc_ctrl-&gt;unique_ctrl_out()-&gt;as_If();</span>
<span class="udiff-line-removed">-     ProjNode* other_unc_ctrl = other_iff-&gt;proj_out(1);</span>
<span class="udiff-line-removed">-     Node* cast = NULL;</span>
<span class="udiff-line-removed">-     for (DUIterator_Fast imax, i = other_unc_ctrl-&gt;fast_outs(imax); i &lt; imax &amp;&amp; cast == NULL; i++) {</span>
<span class="udiff-line-removed">-       Node* u = other_unc_ctrl-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       if (u-&gt;Opcode() == Op_CastPP &amp;&amp; u-&gt;in(1) == this) {</span>
<span class="udiff-line-removed">-         cast = u;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(other_unc_ctrl-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) == unc, &quot;broken&quot;);</span>
<span class="udiff-line-removed">-     rep = cast;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Replace all uses of barrier&#39;s input that are dominated by ctrl</span>
<span class="udiff-line-removed">-   // with the value returned by the barrier: no need to keep both</span>
<span class="udiff-line-removed">-   // live.</span>
<span class="udiff-line-removed">-   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-     Node* u = val-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-     if (u != this) {</span>
<span class="udiff-line-removed">-       if (u-&gt;is_Phi()) {</span>
<span class="udiff-line-removed">-         int nb = 0;</span>
<span class="udiff-line-removed">-         for (uint j = 1; j &lt; u-&gt;req(); j++) {</span>
<span class="udiff-line-removed">-           if (u-&gt;in(j) == val) {</span>
<span class="udiff-line-removed">-             Node* c = u-&gt;in(0)-&gt;in(j);</span>
<span class="udiff-line-removed">-             if (phase-&gt;is_dominator(ctrl, c)) {</span>
<span class="udiff-line-removed">-               phase-&gt;igvn().replace_input_of(u, j, rep);</span>
<span class="udiff-line-removed">-               nb++;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (nb &gt; 0) {</span>
<span class="udiff-line-removed">-           imax -= nb;</span>
<span class="udiff-line-removed">-           --i;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="udiff-line-removed">-         if (is_dominator(ctrl, c, this, u, phase)) {</span>
<span class="udiff-line-removed">-           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-removed">-           int nb = u-&gt;replace_edge(val, rep);</span>
<span class="udiff-line-removed">-           assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="udiff-line-removed">-           --i, imax -= nb;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   Node* mem = NULL;</span>
<span class="udiff-line-removed">-   Node* c = ctrl;</span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-removed">-     if (c-&gt;is_Region()) {</span>
<span class="udiff-line-removed">-       Node* phi_bottom = NULL;</span>
<span class="udiff-line-removed">-       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="udiff-line-removed">-         Node* u = c-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="udiff-line-removed">-           if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-removed">-             mem = u;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {</span>
<span class="udiff-line-removed">-         CallProjections projs;</span>
<span class="udiff-line-removed">-         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="udiff-line-removed">-         if (projs.fallthrough_memproj != NULL) {</span>
<span class="udiff-line-removed">-           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-removed">-             if (projs.catchall_memproj == NULL) {</span>
<span class="udiff-line-removed">-               mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="udiff-line-removed">-                 mem = projs.fallthrough_memproj;</span>
<span class="udiff-line-removed">-               } else {</span>
<span class="udiff-line-removed">-                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="udiff-line-removed">-                 mem = projs.catchall_memproj;</span>
<span class="udiff-line-removed">-               }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);</span>
<span class="udiff-line-removed">-           if (proj != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-               proj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-removed">-             mem = proj;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-           Node* u = c-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-           if (u-&gt;is_Proj() &amp;&amp;</span>
<span class="udiff-line-removed">-               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="udiff-line-removed">-               u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-removed">-               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);</span>
<span class="udiff-line-removed">-               assert(mem == NULL, &quot;only one proj&quot;);</span>
<span class="udiff-line-removed">-               mem = u;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     c = phase-&gt;idom(c);</span>
<span class="udiff-line-removed">-   } while (mem == NULL);</span>
<span class="udiff-line-removed">-   return mem;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-     Node* u = n-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {</span>
<span class="udiff-line-removed">-       uses.push(u);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();</span>
<span class="udiff-line-removed">-   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));</span>
<span class="udiff-line-removed">-   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));</span>
<span class="udiff-line-removed">-   phase-&gt;lazy_replace(outer, new_outer);</span>
<span class="udiff-line-removed">-   phase-&gt;lazy_replace(le, new_le);</span>
<span class="udiff-line-removed">-   inner-&gt;clear_strip_mined();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="udiff-line-removed">-                                                   PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">-   Node* thread = new ThreadLocalNode();</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(thread, ctrl);</span>
<span class="udiff-line-removed">-   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-removed">-   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());</span>
<span class="udiff-line-removed">-   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(gc_state_addr, ctrl);</span>
<span class="udiff-line-removed">-   uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="udiff-line-removed">-   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="udiff-line-removed">-   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(gc_state, ctrl);</span>
<span class="udiff-line-removed">-   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(heap_stable_and, ctrl);</span>
<span class="udiff-line-removed">-   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(heap_stable_cmp, ctrl);</span>
<span class="udiff-line-removed">-   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(heap_stable_test, ctrl);</span>
<span class="udiff-line-removed">-   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(heap_stable_iff, loop, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);</span>
<span class="udiff-line-removed">-   ctrl = new IfTrueNode(heap_stable_iff);</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(ctrl, loop, heap_stable_iff);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   const Type* val_t = phase-&gt;igvn().type(val);</span>
<span class="udiff-line-removed">-   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {</span>
<span class="udiff-line-removed">-     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">-     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(null_cmp, ctrl);</span>
<span class="udiff-line-removed">-     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(null_test, ctrl);</span>
<span class="udiff-line-removed">-     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(null_iff, loop, ctrl);</span>
<span class="udiff-line-removed">-     ctrl = new IfTrueNode(null_iff);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(ctrl, loop, null_iff);</span>
<span class="udiff-line-removed">-     null_ctrl = new IfFalseNode(null_iff);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(null_ctrl, loop, null_iff);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahWriteBarrierNode::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-removed">-   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="udiff-line-removed">-   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="udiff-line-removed">-   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="udiff-line-removed">-   Node* new_iff = iff-&gt;clone();</span>
<span class="udiff-line-removed">-   new_iff-&gt;set_req(0, c);</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="udiff-line-removed">-   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="udiff-line-removed">-   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="udiff-line-removed">-   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="udiff-line-removed">-   c = iftrue;</span>
<span class="udiff-line-removed">-   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="udiff-line-removed">-   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="udiff-line-removed">-   Node* uncasted_val = val-&gt;in(1);</span>
<span class="udiff-line-removed">-   val = new CastPPNode(uncasted_val, t);</span>
<span class="udiff-line-removed">-   val-&gt;init_req(0, c);</span>
<span class="udiff-line-removed">-   phase-&gt;register_new_node(val, c);</span>
<span class="udiff-line-removed">-   return val;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahWriteBarrierNode::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
                                                  Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
    IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();
    Node* proj = iff-&gt;proj_out(0);
    assert(proj != unc_ctrl, &quot;bad projection&quot;);
    Node* use = proj-&gt;unique_ctrl_out();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2492,11 +1002,11 @@</span>
    phase-&gt;igvn().rehash_node_delayed(use);
    int nb = use-&gt;replace_edge(proj, new_unc_ctrl);
    assert(nb == 1, &quot;only use expected&quot;);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {</span>
    IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
    Node* raw_rbtrue = new CastP2XNode(ctrl, val);
    phase-&gt;register_new_node(raw_rbtrue, ctrl);
    Node* cset_offset = new URShiftXNode(raw_rbtrue, phase-&gt;igvn().intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
    phase-&gt;register_new_node(cset_offset, ctrl);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2521,33 +1031,37 @@</span>
  
    ctrl = new IfFalseNode(in_cset_fast_test_iff);
    phase-&gt;register_control(ctrl, loop, in_cset_fast_test_iff);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::call_wb_stub(Node*&amp; ctrl, Node*&amp; val, Node*&amp; result_mem,</span>
<span class="udiff-line-removed">-                                               Node* raw_mem, Node* wb_mem,</span>
<span class="udiff-line-removed">-                                               int alias,</span>
<span class="udiff-line-removed">-                                               PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {</span>
    IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
<span class="udiff-line-modified-removed">-   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="udiff-line-modified-added">+   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr();</span>
  
    // The slow path stub consumes and produces raw memory in addition
    // to the existing memory edges
    Node* base = find_bottom_mem(ctrl, phase);
<span class="udiff-line-removed">- </span>
    MergeMemNode* mm = MergeMemNode::make(base);
<span class="udiff-line-removed">-   mm-&gt;set_memory_at(alias, wb_mem);</span>
    mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
    phase-&gt;register_new_node(mm, ctrl);
  
<span class="udiff-line-modified-removed">-   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_write_barrier_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), &quot;shenandoah_write_barrier&quot;, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-added">+   address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?</span>
<span class="udiff-line-added">+           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :</span>
<span class="udiff-line-added">+           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)</span>
<span class="udiff-line-added">+                                : target;</span>
<span class="udiff-line-added">+   const char* name = is_native ? &quot;load_reference_barrier_native&quot; : &quot;load_reference_barrier&quot;;</span>
<span class="udiff-line-added">+   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-added">+ </span>
    call-&gt;init_req(TypeFunc::Control, ctrl);
    call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
    call-&gt;init_req(TypeFunc::Memory, mm);
    call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
    call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
    call-&gt;init_req(TypeFunc::Parms, val);
<span class="udiff-line-added">+   call-&gt;init_req(TypeFunc::Parms+1, load_addr);</span>
    phase-&gt;register_control(call, loop, ctrl);
    ctrl = new ProjNode(call, TypeFunc::Control);
    phase-&gt;register_control(ctrl, loop, call);
    result_mem = new ProjNode(call, TypeFunc::Memory);
    phase-&gt;register_new_node(result_mem, call);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2555,11 +1069,11 @@</span>
    phase-&gt;register_new_node(val, call);
    val = new CheckCastPPNode(ctrl, val, obj_type);
    phase-&gt;register_new_node(val, ctrl);
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {</span>
    Node* ctrl = phase-&gt;get_ctrl(barrier);
    Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
  
    // Update the control of all nodes that should be after the
    // barrier control flow
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2608,94 +1122,482 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::pin_and_expand(PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-removed">-   Node_List enqueue_barriers;</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="udiff-line-modified-removed">-     Unique_Node_List wq;</span>
<span class="udiff-line-modified-removed">-     wq.push(phase-&gt;C-&gt;root());</span>
<span class="udiff-line-modified-removed">-     for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="udiff-line-modified-removed">-       Node* n = wq.at(i);</span>
<span class="udiff-line-modified-removed">-       if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-modified-removed">-         enqueue_barriers.push(n);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       for (uint i = 0; i &lt; n-&gt;req(); i++) {</span>
<span class="udiff-line-modified-removed">-         Node* in = n-&gt;in(i);</span>
<span class="udiff-line-modified-removed">-         if (in != NULL) {</span>
<span class="udiff-line-modified-removed">-           wq.push(in);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+ static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections&amp; projs, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+   Node* region = NULL;</span>
<span class="udiff-line-modified-added">+   while (c != ctrl) {</span>
<span class="udiff-line-modified-added">+     if (c-&gt;is_Region()) {</span>
<span class="udiff-line-modified-added">+       region = c;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     c = phase-&gt;idom(c);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   assert(region != NULL, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   Node* phi = new PhiNode(region, n-&gt;bottom_type());</span>
<span class="udiff-line-modified-added">+   for (uint j = 1; j &lt; region-&gt;req(); j++) {</span>
<span class="udiff-line-modified-added">+     Node* in = region-&gt;in(j);</span>
<span class="udiff-line-modified-added">+     if (phase-&gt;is_dominator(projs.fallthrough_catchproj, in)) {</span>
<span class="udiff-line-modified-added">+       phi-&gt;init_req(j, n);</span>
<span class="udiff-line-modified-added">+     } else if (phase-&gt;is_dominator(projs.catchall_catchproj, in)) {</span>
<span class="udiff-line-modified-added">+       phi-&gt;init_req(j, n_clone);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       phi-&gt;init_req(j, create_phis_on_call_return(ctrl, in, n, n_clone, projs, phase));</span>
      }
    }
<span class="udiff-line-added">+   phase-&gt;register_new_node(phi, region);</span>
<span class="udiff-line-added">+   return phi;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   const bool trace = false;</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::pin_and_expand(PhaseIdealLoop* phase) {</span>
<span class="udiff-line-added">+   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Unique_Node_List uses;</span>
<span class="udiff-line-added">+   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {</span>
<span class="udiff-line-added">+     Node* barrier = state-&gt;enqueue_barrier(i);</span>
<span class="udiff-line-added">+     Node* ctrl = phase-&gt;get_ctrl(barrier);</span>
<span class="udiff-line-added">+     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-added">+     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {</span>
<span class="udiff-line-added">+       // Expanding a barrier here will break loop strip mining</span>
<span class="udiff-line-added">+       // verification. Transform the loop so the loop nest doesn&#39;t</span>
<span class="udiff-line-added">+       // appear as strip mined.</span>
<span class="udiff-line-added">+       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();</span>
<span class="udiff-line-added">+       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node_Stack stack(0);</span>
<span class="udiff-line-added">+   Node_List clones;</span>
<span class="udiff-line-added">+   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-added">+     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="udiff-line-added">+     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
<span class="udiff-line-added">+     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CallStaticJavaNode* unc = NULL;</span>
<span class="udiff-line-added">+     Node* unc_ctrl = NULL;</span>
<span class="udiff-line-added">+     Node* uncasted_val = val;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+       Node* u = lrb-&gt;fast_out(i);</span>
<span class="udiff-line-added">+       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="udiff-line-added">+           u-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-added">+           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {</span>
<span class="udiff-line-added">+         const Type* u_t = phase-&gt;igvn().type(u);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;</span>
<span class="udiff-line-added">+             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-added">+           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+           }</span>
  
<span class="udiff-line-modified-removed">-   // Collect raw memory state at CFG points in the entire graph and</span>
<span class="udiff-line-modified-removed">-   // record it in memory_nodes. Optimize the raw memory graph in the</span>
<span class="udiff-line-modified-removed">-   // process. Optimizing the memory graph also makes the memory graph</span>
<span class="udiff-line-modified-removed">-   // simpler.</span>
<span class="udiff-line-modified-removed">-   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;</span>
<span class="udiff-line-modified-added">+           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);</span>
<span class="udiff-line-modified-added">+           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="udiff-line-modified-added">+           if (branch == NodeSentinel) {</span>
<span class="udiff-line-modified-added">+             continue;</span>
<span class="udiff-line-modified-added">+           }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(u, 1, val);</span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(lrb, ShenandoahLoadReferenceBarrierNode::ValueIn, u);</span>
<span class="udiff-line-added">+           phase-&gt;set_ctrl(u, u-&gt;in(0));</span>
<span class="udiff-line-added">+           phase-&gt;set_ctrl(lrb, u-&gt;in(0));</span>
<span class="udiff-line-added">+           unc = u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="udiff-line-added">+           unc_ctrl = u-&gt;in(0);</span>
<span class="udiff-line-added">+           val = u;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-added">+             Node* u = val-&gt;fast_out(j);</span>
<span class="udiff-line-added">+             if (u == lrb) continue;</span>
<span class="udiff-line-added">+             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+             int nb = u-&gt;replace_edge(val, lrb);</span>
<span class="udiff-line-added">+             --j; jmax -= nb;</span>
<span class="udiff-line-added">+           }</span>
  
<span class="udiff-line-modified-removed">-   // Let&#39;s try to common write barriers again</span>
<span class="udiff-line-modified-removed">-   optimize_before_expansion(phase, memory_graph_fixers, true);</span>
<span class="udiff-line-modified-added">+           RegionNode* r = new RegionNode(3);</span>
<span class="udiff-line-modified-added">+           IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="udiff-line-added">+           Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="udiff-line-added">+           phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="udiff-line-added">+           Node* c = unc_ctrl_clone;</span>
<span class="udiff-line-added">+           Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="udiff-line-added">+           r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="udiff-line-added">+           phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="udiff-line-added">+           phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="udiff-line-added">+           c = NULL;;</span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="udiff-line-added">+           phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-added">+           fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="udiff-line-added">+           Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="udiff-line-added">+           r-&gt;init_req(2, iff_proj);</span>
<span class="udiff-line-added">+           phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="udiff-line-added">+           Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="udiff-line-added">+           assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="udiff-line-added">+           assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="udiff-line-added">+           new_bol-&gt;set_req(1, new_cmp);</span>
<span class="udiff-line-added">+           new_cmp-&gt;set_req(1, lrb);</span>
<span class="udiff-line-added">+           phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="udiff-line-added">+           phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="udiff-line-added">+           phase-&gt;igvn().replace_input_of(new_cast, 1, lrb);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+             Node* u = lrb-&gt;fast_out(i);</span>
<span class="udiff-line-added">+             if (u == new_cast || u == new_cmp) {</span>
<span class="udiff-line-added">+               continue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+             int nb = u-&gt;replace_edge(lrb, new_cast);</span>
<span class="udiff-line-added">+             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="udiff-line-added">+             --i; imax -= nb;</span>
<span class="udiff-line-added">+           }</span>
  
<span class="udiff-line-modified-removed">-   Unique_Node_List uses;</span>
<span class="udiff-line-modified-removed">-   for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="udiff-line-modified-removed">-     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="udiff-line-modified-removed">-     Node* ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="udiff-line-modified-added">+           for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-modified-added">+             Node* u = val-&gt;fast_out(i);</span>
<span class="udiff-line-modified-added">+             if (u == lrb) {</span>
<span class="udiff-line-modified-added">+               continue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+             int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="udiff-line-added">+             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="udiff-line-added">+             --i; imax -= nb;</span>
<span class="udiff-line-added">+           }</span>
  
<span class="udiff-line-modified-removed">-     Node* val = wb-&gt;in(ValueIn);</span>
<span class="udiff-line-modified-removed">-     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {</span>
<span class="udiff-line-modified-removed">-       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0)-&gt;in(0), val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);</span>
<span class="udiff-line-modified-removed">-       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0)-&gt;in(0));</span>
<span class="udiff-line-modified-removed">-     } else if (ctrl-&gt;is_CallRuntime()) {</span>
<span class="udiff-line-removed">-       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0), val, ctrl, phase), &quot;can&#39;t move&quot;);</span>
<span class="udiff-line-removed">-       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0));</span>
<span class="udiff-line-modified-added">+           ctrl = unc_ctrl_clone;</span>
<span class="udiff-line-modified-added">+           phase-&gt;set_ctrl_and_loop(lrb, ctrl);</span>
<span class="udiff-line-modified-added">+           break;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+       }</span>
      }
<span class="udiff-line-added">+     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {</span>
<span class="udiff-line-added">+       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();</span>
<span class="udiff-line-added">+       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {</span>
<span class="udiff-line-added">+         // The rethrow call may have too many projections to be</span>
<span class="udiff-line-added">+         // properly handled here. Given there&#39;s no reason for a</span>
<span class="udiff-line-added">+         // barrier to depend on the call, move it above the call</span>
<span class="udiff-line-added">+         stack.push(lrb, 0);</span>
<span class="udiff-line-added">+         do {</span>
<span class="udiff-line-added">+           Node* n = stack.node();</span>
<span class="udiff-line-added">+           uint idx = stack.index();</span>
<span class="udiff-line-added">+           if (idx &lt; n-&gt;req()) {</span>
<span class="udiff-line-added">+             Node* in = n-&gt;in(idx);</span>
<span class="udiff-line-added">+             stack.set_index(idx+1);</span>
<span class="udiff-line-added">+             if (in != NULL) {</span>
<span class="udiff-line-added">+               if (phase-&gt;has_ctrl(in)) {</span>
<span class="udiff-line-added">+                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+                   for (uint i = 0; i &lt; stack.size(); i++) {</span>
<span class="udiff-line-added">+                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);</span>
<span class="udiff-line-added">+                   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+                   stack.push(in, 0);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+               } else {</span>
<span class="udiff-line-added">+                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+             phase-&gt;set_ctrl(n, call-&gt;in(0));</span>
<span class="udiff-line-added">+             stack.pop();</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } while(stack.size() &gt; 0);</span>
<span class="udiff-line-added">+         continue;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       CallProjections projs;</span>
<span class="udiff-line-added">+       call-&gt;extract_projections(&amp;projs, false, false);</span>
  
<span class="udiff-line-modified-removed">-     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;only for write barriers&quot;);</span>
<span class="udiff-line-modified-removed">-     // Look for a null check that dominates this barrier and move the</span>
<span class="udiff-line-modified-removed">-     // barrier right after the null check to enable implicit null</span>
<span class="udiff-line-removed">-     // checks</span>
<span class="udiff-line-removed">-     wb-&gt;pin_and_expand_move_barrier(phase, memory_graph_fixers, uses);</span>
<span class="udiff-line-modified-added">+       Node* lrb_clone = lrb-&gt;clone();</span>
<span class="udiff-line-modified-added">+       phase-&gt;register_new_node(lrb_clone, projs.catchall_catchproj);</span>
<span class="udiff-line-modified-added">+       phase-&gt;set_ctrl(lrb, projs.fallthrough_catchproj);</span>
  
<span class="udiff-line-modified-removed">-     wb-&gt;pin_and_expand_helper(phase);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+       stack.push(lrb, 0);</span>
<span class="udiff-line-modified-added">+       clones.push(lrb_clone);</span>
  
<span class="udiff-line-modified-removed">-   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="udiff-line-modified-removed">-     Node* barrier = enqueue_barriers.at(i);</span>
<span class="udiff-line-modified-removed">-     Node* ctrl = phase-&gt;get_ctrl(barrier);</span>
<span class="udiff-line-modified-removed">-     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-modified-removed">-     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {</span>
<span class="udiff-line-modified-removed">-       // Expanding a barrier here will break loop strip mining</span>
<span class="udiff-line-modified-removed">-       // verification. Transform the loop so the loop nest doesn&#39;t</span>
<span class="udiff-line-modified-removed">-       // appear as strip mined.</span>
<span class="udiff-line-modified-removed">-       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();</span>
<span class="udiff-line-modified-removed">-       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);</span>
<span class="udiff-line-modified-added">+       do {</span>
<span class="udiff-line-modified-added">+         assert(stack.size() == clones.size(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+         Node* n = stack.node();</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-modified-added">+         if (n-&gt;is_Load()) {</span>
<span class="udiff-line-modified-added">+           Node* mem = n-&gt;in(MemNode::Memory);</span>
<span class="udiff-line-modified-added">+           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-modified-added">+             Node* u = mem-&gt;fast_out(j);</span>
<span class="udiff-line-modified-added">+             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);</span>
<span class="udiff-line-modified-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         uint idx = stack.index();</span>
<span class="udiff-line-added">+         Node* n_clone = clones.at(clones.size()-1);</span>
<span class="udiff-line-added">+         if (idx &lt; n-&gt;outcnt()) {</span>
<span class="udiff-line-added">+           Node* u = n-&gt;raw_out(idx);</span>
<span class="udiff-line-added">+           Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="udiff-line-added">+           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs.fallthrough_proj)) {</span>
<span class="udiff-line-added">+             stack.set_index(idx+1);</span>
<span class="udiff-line-added">+             assert(!u-&gt;is_CFG(), &quot;&quot;);</span>
<span class="udiff-line-added">+             stack.push(u, 0);</span>
<span class="udiff-line-added">+             Node* u_clone = u-&gt;clone();</span>
<span class="udiff-line-added">+             int nb = u_clone-&gt;replace_edge(n, n_clone);</span>
<span class="udiff-line-added">+             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="udiff-line-added">+             phase-&gt;register_new_node(u_clone, projs.catchall_catchproj);</span>
<span class="udiff-line-added">+             clones.push(u_clone);</span>
<span class="udiff-line-added">+             phase-&gt;set_ctrl(u, projs.fallthrough_catchproj);</span>
<span class="udiff-line-added">+           } else {</span>
<span class="udiff-line-added">+             bool replaced = false;</span>
<span class="udiff-line-added">+             if (u-&gt;is_Phi()) {</span>
<span class="udiff-line-added">+               for (uint k = 1; k &lt; u-&gt;req(); k++) {</span>
<span class="udiff-line-added">+                 if (u-&gt;in(k) == n) {</span>
<span class="udiff-line-added">+                   if (phase-&gt;is_dominator(projs.catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
<span class="udiff-line-added">+                     phase-&gt;igvn().replace_input_of(u, k, n_clone);</span>
<span class="udiff-line-added">+                     replaced = true;</span>
<span class="udiff-line-added">+                   } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
<span class="udiff-line-added">+                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));</span>
<span class="udiff-line-added">+                     replaced = true;</span>
<span class="udiff-line-added">+                   }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+               if (phase-&gt;is_dominator(projs.catchall_catchproj, c)) {</span>
<span class="udiff-line-added">+                 phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+                 int nb = u-&gt;replace_edge(n, n_clone);</span>
<span class="udiff-line-added">+                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="udiff-line-added">+                 replaced = true;</span>
<span class="udiff-line-added">+               } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, c)) {</span>
<span class="udiff-line-added">+                 phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));</span>
<span class="udiff-line-added">+                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="udiff-line-added">+                 replaced = true;</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!replaced) {</span>
<span class="udiff-line-added">+               stack.set_index(idx+1);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           stack.pop();</span>
<span class="udiff-line-added">+           clones.pop();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       } while (stack.size() &gt; 0);</span>
<span class="udiff-line-added">+       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);</span>
      }
    }
  
<span class="udiff-line-modified-removed">-   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="udiff-line-modified-removed">-     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="udiff-line-modified-removed">-     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="udiff-line-modified-removed">-     Node* ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="udiff-line-modified-added">+   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {</span>
<span class="udiff-line-modified-added">+     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="udiff-line-modified-added">+     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="udiff-line-modified-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
      IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
      if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
        // Expanding a barrier here will break loop strip mining
        // verification. Transform the loop so the loop nest doesn&#39;t
        // appear as strip mined.
        OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
        hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
      }
    }
  
<span class="udiff-line-added">+   // Expand load-reference-barriers</span>
    MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
    Unique_Node_List uses_to_ignore;
<span class="udiff-line-modified-removed">-   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="udiff-line-modified-removed">-     Node* barrier = enqueue_barriers.at(i);</span>
<span class="udiff-line-modified-added">+   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-modified-added">+     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="udiff-line-added">+     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="udiff-line-added">+       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     uint last = phase-&gt;C-&gt;unique();</span>
<span class="udiff-line-added">+     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
<span class="udiff-line-added">+     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* orig_ctrl = ctrl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* raw_mem = fixer.find_mem(ctrl, lrb);</span>
<span class="udiff-line-added">+     Node* init_raw_mem = raw_mem;</span>
<span class="udiff-line-added">+     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-added">+     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="udiff-line-added">+     Node* unc_ctrl = NULL;</span>
<span class="udiff-line-added">+     if (unc != NULL) {</span>
<span class="udiff-line-added">+       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {</span>
<span class="udiff-line-added">+         unc = NULL;</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         unc_ctrl = val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* uncasted_val = val;</span>
<span class="udiff-line-added">+     if (unc != NULL) {</span>
<span class="udiff-line-added">+       uncasted_val = val-&gt;in(1);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* heap_stable_ctrl = NULL;</span>
<span class="udiff-line-added">+     Node* null_ctrl = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);</span>
<span class="udiff-line-added">+     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };</span>
<span class="udiff-line-added">+     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="udiff-line-added">+     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="udiff-line-added">+     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Stable path.</span>
<span class="udiff-line-added">+     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
<span class="udiff-line-added">+     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Heap stable case</span>
<span class="udiff-line-added">+     region-&gt;init_req(_heap_stable, heap_stable_ctrl);</span>
<span class="udiff-line-added">+     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
<span class="udiff-line-added">+     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* reg2_ctrl = NULL;</span>
<span class="udiff-line-added">+     // Null case</span>
<span class="udiff-line-added">+     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="udiff-line-added">+     if (null_ctrl != NULL) {</span>
<span class="udiff-line-added">+       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="udiff-line-added">+       region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="udiff-line-added">+       val_phi-&gt;init_req(_null_path, uncasted_val);</span>
<span class="udiff-line-added">+       raw_mem_phi-&gt;init_req(_null_path, raw_mem);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       region-&gt;del_req(_null_path);</span>
<span class="udiff-line-added">+       val_phi-&gt;del_req(_null_path);</span>
<span class="udiff-line-added">+       raw_mem_phi-&gt;del_req(_null_path);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Test for in-cset.</span>
<span class="udiff-line-added">+     // Wires !in_cset(obj) to slot 2 of region and phis</span>
<span class="udiff-line-added">+     Node* not_cset_ctrl = NULL;</span>
<span class="udiff-line-added">+     in_cset_fast_test(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
<span class="udiff-line-added">+     if (not_cset_ctrl != NULL) {</span>
<span class="udiff-line-added">+       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="udiff-line-added">+       region-&gt;init_req(_not_cset, not_cset_ctrl);</span>
<span class="udiff-line-added">+       val_phi-&gt;init_req(_not_cset, uncasted_val);</span>
<span class="udiff-line-added">+       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Resolve object when orig-value is in cset.</span>
<span class="udiff-line-added">+     // Make the unconditional resolve for fwdptr.</span>
<span class="udiff-line-added">+     Node* new_val = uncasted_val;</span>
<span class="udiff-line-added">+     if (unc_ctrl != NULL) {</span>
<span class="udiff-line-added">+       // Clone the null check in this branch to allow implicit null check</span>
<span class="udiff-line-added">+       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="udiff-line-added">+       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-added">+       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Call lrb-stub and wire up that path in slots 4</span>
<span class="udiff-line-added">+     Node* result_mem = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* fwd = new_val;</span>
<span class="udiff-line-added">+     Node* addr;</span>
<span class="udiff-line-added">+     if (ShenandoahSelfFixing) {</span>
<span class="udiff-line-added">+       VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="udiff-line-added">+       addr = get_load_addr(phase, visited, lrb);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       addr = phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (addr-&gt;Opcode() == Op_AddP) {</span>
<span class="udiff-line-added">+       Node* orig_base = addr-&gt;in(AddPNode::Base);</span>
<span class="udiff-line-added">+       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);</span>
<span class="udiff-line-added">+       phase-&gt;register_new_node(base, ctrl);</span>
<span class="udiff-line-added">+       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {</span>
<span class="udiff-line-added">+         // Field access</span>
<span class="udiff-line-added">+         addr = addr-&gt;clone();</span>
<span class="udiff-line-added">+         addr-&gt;set_req(AddPNode::Base, base);</span>
<span class="udiff-line-added">+         addr-&gt;set_req(AddPNode::Address, base);</span>
<span class="udiff-line-added">+         phase-&gt;register_new_node(addr, ctrl);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         Node* addr2 = addr-&gt;in(AddPNode::Address);</span>
<span class="udiff-line-added">+         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;</span>
<span class="udiff-line-added">+               addr2-&gt;in(AddPNode::Base) == orig_base) {</span>
<span class="udiff-line-added">+           addr2 = addr2-&gt;clone();</span>
<span class="udiff-line-added">+           addr2-&gt;set_req(AddPNode::Base, base);</span>
<span class="udiff-line-added">+           addr2-&gt;set_req(AddPNode::Address, base);</span>
<span class="udiff-line-added">+           phase-&gt;register_new_node(addr2, ctrl);</span>
<span class="udiff-line-added">+           addr = addr-&gt;clone();</span>
<span class="udiff-line-added">+           addr-&gt;set_req(AddPNode::Base, base);</span>
<span class="udiff-line-added">+           addr-&gt;set_req(AddPNode::Address, addr2);</span>
<span class="udiff-line-added">+           phase-&gt;register_new_node(addr, ctrl);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     call_lrb_stub(ctrl, fwd, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
<span class="udiff-line-added">+     region-&gt;init_req(_evac_path, ctrl);</span>
<span class="udiff-line-added">+     val_phi-&gt;init_req(_evac_path, fwd);</span>
<span class="udiff-line-added">+     raw_mem_phi-&gt;init_req(_evac_path, result_mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     phase-&gt;register_control(region, loop, heap_stable_iff);</span>
<span class="udiff-line-added">+     Node* out_val = val_phi;</span>
<span class="udiff-line-added">+     phase-&gt;register_new_node(val_phi, region);</span>
<span class="udiff-line-added">+     phase-&gt;register_new_node(raw_mem_phi, region);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ctrl = orig_ctrl;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (unc != NULL) {</span>
<span class="udiff-line-added">+       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+         Node* u = val-&gt;fast_out(i);</span>
<span class="udiff-line-added">+         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="udiff-line-added">+         if (u != lrb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, lrb, u, phase))) {</span>
<span class="udiff-line-added">+           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-added">+           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="udiff-line-added">+           --i, imax -= nb;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (val-&gt;outcnt() == 0) {</span>
<span class="udiff-line-added">+         phase-&gt;igvn()._worklist.push(val);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     phase-&gt;igvn().replace_node(lrb, out_val);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     follow_barrier_uses(out_val, ctrl, uses, phase);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="udiff-line-added">+       Node *n = uses.at(next);</span>
<span class="udiff-line-added">+       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);</span>
<span class="udiff-line-added">+       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);</span>
<span class="udiff-line-added">+       phase-&gt;set_ctrl(n, region);</span>
<span class="udiff-line-added">+       follow_barrier_uses(n, ctrl, uses, phase);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // The slow path call produces memory: hook the raw memory phi</span>
<span class="udiff-line-added">+     // from the expanded load reference barrier with the rest of the graph</span>
<span class="udiff-line-added">+     // which may require adding memory phis at every post dominated</span>
<span class="udiff-line-added">+     // region and at enclosing loop heads. Use the memory state</span>
<span class="udiff-line-added">+     // collected in memory_nodes to fix the memory graph. Update that</span>
<span class="udiff-line-added">+     // memory state as we go.</span>
<span class="udiff-line-added">+     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // Done expanding load-reference-barriers.</span>
<span class="udiff-line-added">+   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;load_reference_barriers_count() == 0, &quot;all load reference barrier nodes should have been replaced&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   for (int i = state-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-added">+     Node* barrier = state-&gt;enqueue_barrier(i);</span>
      Node* pre_val = barrier-&gt;in(1);
  
      if (phase-&gt;igvn().type(pre_val)-&gt;higher_equal(TypePtr::NULL_PTR)) {
        ShouldNotReachHere();
        continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2783,271 +1685,139 @@</span>
      Node *log_addr = new AddPNode(phase-&gt;C-&gt;top(), buffer, next_index);
      phase-&gt;register_new_node(log_addr, ctrl);
      Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);
      phase-&gt;register_new_node(log_store, ctrl);
      // update the index
<span class="udiff-line-modified-removed">-     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);</span>
<span class="udiff-line-modified-removed">-     phase-&gt;register_new_node(index_update, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Fast-path case</span>
<span class="udiff-line-removed">-     region2-&gt;init_req(_fast_path, ctrl);</span>
<span class="udiff-line-removed">-     phi2-&gt;init_req(_fast_path, index_update);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ctrl = full;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* base = find_bottom_mem(ctrl, phase);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     MergeMemNode* mm = MergeMemNode::make(base);</span>
<span class="udiff-line-removed">-     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(mm, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::Memory, mm);</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::Parms, pre_val);</span>
<span class="udiff-line-removed">-     call-&gt;init_req(TypeFunc::Parms+1, thread);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(call, loop, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(ctrl_proj, loop, call);</span>
<span class="udiff-line-removed">-     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(mem_proj, call);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Slow-path case</span>
<span class="udiff-line-removed">-     region2-&gt;init_req(_slow_path, ctrl_proj);</span>
<span class="udiff-line-removed">-     phi2-&gt;init_req(_slow_path, mem_proj);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;register_control(region2, loop, reg2_ctrl);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(phi2, region2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     region-&gt;init_req(_heap_unstable, region2);</span>
<span class="udiff-line-removed">-     phi-&gt;init_req(_heap_unstable, phi2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(phi, region);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="udiff-line-removed">-     for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="udiff-line-removed">-       Node *n = uses.at(next);</span>
<span class="udiff-line-removed">-       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);</span>
<span class="udiff-line-removed">-       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);</span>
<span class="udiff-line-removed">-       phase-&gt;set_ctrl(n, region);</span>
<span class="udiff-line-removed">-       follow_barrier_uses(n, init_ctrl, uses, phase);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_node(barrier, pre_val);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="udiff-line-removed">-     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="udiff-line-removed">-     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     uint last = phase-&gt;C-&gt;unique();</span>
<span class="udiff-line-removed">-     Node* ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="udiff-line-removed">-     Node* orig_ctrl = ctrl;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* raw_mem = fixer.find_mem(ctrl, wb);</span>
<span class="udiff-line-removed">-     Node* init_raw_mem = raw_mem;</span>
<span class="udiff-line-removed">-     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);</span>
<span class="udiff-line-removed">-     int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="udiff-line-removed">-     Node* wb_mem =  wb-&gt;in(Memory);</span>
<span class="udiff-line-removed">-     Node* init_wb_mem = wb_mem;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* val = wb-&gt;in(ValueIn);</span>
<span class="udiff-line-removed">-     Node* wbproj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="udiff-line-removed">-     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(val-&gt;Opcode() != Op_ShenandoahWriteBarrier, &quot;No chain of write barriers&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     CallStaticJavaNode* unc = wb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="udiff-line-removed">-     Node* unc_ctrl = NULL;</span>
<span class="udiff-line-removed">-     if (unc != NULL) {</span>
<span class="udiff-line-removed">-       if (val-&gt;in(0) != ctrl) {</span>
<span class="udiff-line-removed">-         unc = NULL;</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         unc_ctrl = val-&gt;in(0);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* uncasted_val = val;</span>
<span class="udiff-line-removed">-     if (unc != NULL) {</span>
<span class="udiff-line-removed">-       uncasted_val = val-&gt;in(1);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* heap_stable_ctrl = NULL;</span>
<span class="udiff-line-removed">-     Node* null_ctrl = NULL;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);</span>
<span class="udiff-line-removed">-     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };</span>
<span class="udiff-line-removed">-     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="udiff-line-removed">-     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="udiff-line-removed">-     Node* mem_phi = PhiNode::make(region, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="udiff-line-removed">-     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-added">+     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(index_update, ctrl);</span>
  
<span class="udiff-line-modified-removed">-     enum { _not_cset = 1, _not_equal, _evac_path, _null_path, PATH_LIMIT2 };</span>
<span class="udiff-line-modified-removed">-     Node* region2 = new RegionNode(PATH_LIMIT2);</span>
<span class="udiff-line-modified-removed">-     Node* val_phi2 = new PhiNode(region2, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="udiff-line-removed">-     Node* mem_phi2 = PhiNode::make(region2, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="udiff-line-removed">-     Node* raw_mem_phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-added">+     // Fast-path case</span>
<span class="udiff-line-modified-added">+     region2-&gt;init_req(_fast_path, ctrl);</span>
<span class="udiff-line-modified-added">+     phi2-&gt;init_req(_fast_path, index_update);</span>
  
<span class="udiff-line-modified-removed">-       // Stable path.</span>
<span class="udiff-line-removed">-     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
<span class="udiff-line-removed">-     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-modified-added">+     ctrl = full;</span>
  
<span class="udiff-line-modified-removed">-     // Heap stable case</span>
<span class="udiff-line-removed">-     region-&gt;init_req(_heap_stable, heap_stable_ctrl);</span>
<span class="udiff-line-removed">-     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
<span class="udiff-line-removed">-     mem_phi-&gt;init_req(_heap_stable, wb_mem);</span>
<span class="udiff-line-removed">-     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);</span>
<span class="udiff-line-modified-added">+     Node* base = find_bottom_mem(ctrl, phase);</span>
  
<span class="udiff-line-modified-removed">-     Node* reg2_ctrl = NULL;</span>
<span class="udiff-line-modified-removed">-     // Null case</span>
<span class="udiff-line-modified-removed">-     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="udiff-line-removed">-     if (null_ctrl != NULL) {</span>
<span class="udiff-line-removed">-       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="udiff-line-removed">-       region2-&gt;init_req(_null_path, null_ctrl);</span>
<span class="udiff-line-removed">-       val_phi2-&gt;init_req(_null_path, uncasted_val);</span>
<span class="udiff-line-removed">-       mem_phi2-&gt;init_req(_null_path, wb_mem);</span>
<span class="udiff-line-removed">-       raw_mem_phi2-&gt;init_req(_null_path, raw_mem);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       region2-&gt;del_req(_null_path);</span>
<span class="udiff-line-removed">-       val_phi2-&gt;del_req(_null_path);</span>
<span class="udiff-line-removed">-       mem_phi2-&gt;del_req(_null_path);</span>
<span class="udiff-line-removed">-       raw_mem_phi2-&gt;del_req(_null_path);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     MergeMemNode* mm = MergeMemNode::make(base);</span>
<span class="udiff-line-modified-added">+     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(mm, ctrl);</span>
  
<span class="udiff-line-modified-removed">-     // Test for in-cset.</span>
<span class="udiff-line-modified-removed">-     // Wires !in_cset(obj) to slot 2 of region and phis</span>
<span class="udiff-line-modified-removed">-     Node* not_cset_ctrl = NULL;</span>
<span class="udiff-line-modified-removed">-     in_cset_fast_test(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
<span class="udiff-line-modified-removed">-     if (not_cset_ctrl != NULL) {</span>
<span class="udiff-line-modified-removed">-       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="udiff-line-modified-removed">-       region2-&gt;init_req(_not_cset, not_cset_ctrl);</span>
<span class="udiff-line-modified-removed">-       val_phi2-&gt;init_req(_not_cset, uncasted_val);</span>
<span class="udiff-line-modified-removed">-       mem_phi2-&gt;init_req(_not_cset, wb_mem);</span>
<span class="udiff-line-removed">-       raw_mem_phi2-&gt;init_req(_not_cset, raw_mem);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::Memory, mm);</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::Parms, pre_val);</span>
<span class="udiff-line-modified-added">+     call-&gt;init_req(TypeFunc::Parms+1, thread);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(call, loop, ctrl);</span>
  
<span class="udiff-line-modified-removed">-     // Resolve object when orig-value is in cset.</span>
<span class="udiff-line-modified-removed">-     // Make the unconditional resolve for fwdptr, not the read barrier.</span>
<span class="udiff-line-modified-removed">-     Node* new_val = uncasted_val;</span>
<span class="udiff-line-modified-removed">-     if (unc_ctrl != NULL) {</span>
<span class="udiff-line-removed">-       // Clone the null check in this branch to allow implicit null check</span>
<span class="udiff-line-removed">-       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="udiff-line-removed">-       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
<span class="udiff-line-modified-added">+     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(ctrl_proj, loop, call);</span>
<span class="udiff-line-modified-added">+     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(mem_proj, call);</span>
  
<span class="udiff-line-modified-removed">-       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="udiff-line-modified-removed">-       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-     Node* addr = new AddPNode(new_val, uncasted_val, phase-&gt;igvn().MakeConX(ShenandoahBrooksPointer::byte_offset()));</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(addr, ctrl);</span>
<span class="udiff-line-removed">-     assert(val-&gt;bottom_type()-&gt;isa_oopptr(), &quot;what else?&quot;);</span>
<span class="udiff-line-removed">-     const TypePtr* obj_type =  val-&gt;bottom_type()-&gt;is_oopptr();</span>
<span class="udiff-line-removed">-     const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="udiff-line-removed">-     Node* fwd = new LoadPNode(ctrl, wb_mem, addr, adr_type, obj_type, MemNode::unordered);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(fwd, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Only branch to WB stub if object is not forwarded; otherwise reply with fwd ptr</span>
<span class="udiff-line-removed">-     Node* cmp = new CmpPNode(fwd, new_val);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(cmp, ctrl);</span>
<span class="udiff-line-removed">-     Node* bol = new BoolNode(cmp, BoolTest::eq);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(bol, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     IfNode* iff = new IfNode(ctrl, bol, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">-     if (reg2_ctrl == NULL) reg2_ctrl = iff;</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(iff, loop, ctrl);</span>
<span class="udiff-line-removed">-     Node* if_not_eq = new IfFalseNode(iff);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(if_not_eq, loop, iff);</span>
<span class="udiff-line-removed">-     Node* if_eq = new IfTrueNode(iff);</span>
<span class="udiff-line-removed">-     phase-&gt;register_control(if_eq, loop, iff);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Wire up not-equal-path in slots 3.</span>
<span class="udiff-line-removed">-     region2-&gt;init_req(_not_equal, if_not_eq);</span>
<span class="udiff-line-removed">-     val_phi2-&gt;init_req(_not_equal, fwd);</span>
<span class="udiff-line-removed">-     mem_phi2-&gt;init_req(_not_equal, wb_mem);</span>
<span class="udiff-line-removed">-     raw_mem_phi2-&gt;init_req(_not_equal, raw_mem);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Call wb-stub and wire up that path in slots 4</span>
<span class="udiff-line-removed">-     Node* result_mem = NULL;</span>
<span class="udiff-line-removed">-     ctrl = if_eq;</span>
<span class="udiff-line-removed">-     call_wb_stub(ctrl, new_val, result_mem,</span>
<span class="udiff-line-removed">-                  raw_mem, wb_mem,</span>
<span class="udiff-line-removed">-                  alias, phase);</span>
<span class="udiff-line-removed">-     region2-&gt;init_req(_evac_path, ctrl);</span>
<span class="udiff-line-removed">-     val_phi2-&gt;init_req(_evac_path, new_val);</span>
<span class="udiff-line-removed">-     mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
<span class="udiff-line-removed">-     raw_mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
<span class="udiff-line-modified-added">+     // Slow-path case</span>
<span class="udiff-line-modified-added">+     region2-&gt;init_req(_slow_path, ctrl_proj);</span>
<span class="udiff-line-modified-added">+     phi2-&gt;init_req(_slow_path, mem_proj);</span>
  
      phase-&gt;register_control(region2, loop, reg2_ctrl);
<span class="udiff-line-modified-removed">-     phase-&gt;register_new_node(val_phi2, region2);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(mem_phi2, region2);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(raw_mem_phi2, region2);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(phi2, region2);</span>
  
      region-&gt;init_req(_heap_unstable, region2);
<span class="udiff-line-modified-removed">-     val_phi-&gt;init_req(_heap_unstable, val_phi2);</span>
<span class="udiff-line-removed">-     mem_phi-&gt;init_req(_heap_unstable, mem_phi2);</span>
<span class="udiff-line-removed">-     raw_mem_phi-&gt;init_req(_heap_unstable, raw_mem_phi2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;register_control(region, loop, heap_stable_iff);</span>
<span class="udiff-line-removed">-     Node* out_val = val_phi;</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(val_phi, region);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(mem_phi, region);</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(raw_mem_phi, region);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     fix_ctrl(wb, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ctrl = orig_ctrl;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_input_of(wbproj, ShenandoahWBMemProjNode::WriteBarrier, phase-&gt;C-&gt;top());</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_node(wbproj, mem_phi);</span>
<span class="udiff-line-removed">-     if (unc != NULL) {</span>
<span class="udiff-line-removed">-       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-         Node* u = val-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="udiff-line-removed">-         if (u != wb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, wb, u, phase))) {</span>
<span class="udiff-line-removed">-           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="udiff-line-removed">-           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="udiff-line-removed">-           --i, imax -= nb;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (val-&gt;outcnt() == 0) {</span>
<span class="udiff-line-removed">-         phase-&gt;igvn()._worklist.push(val);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     phase-&gt;igvn().replace_node(wb, out_val);</span>
<span class="udiff-line-modified-added">+     phi-&gt;init_req(_heap_unstable, phi2);</span>
  
<span class="udiff-line-modified-removed">-     follow_barrier_uses(mem_phi, ctrl, uses, phase);</span>
<span class="udiff-line-modified-removed">-     follow_barrier_uses(out_val, ctrl, uses, phase);</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));</span>
<span class="udiff-line-modified-added">+     phase-&gt;register_new_node(phi, region);</span>
  
<span class="udiff-line-added">+     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);</span>
      for(uint next = 0; next &lt; uses.size(); next++ ) {
        Node *n = uses.at(next);
<span class="udiff-line-modified-removed">-       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);</span>
<span class="udiff-line-modified-added">+       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);</span>
        assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
        phase-&gt;set_ctrl(n, region);
<span class="udiff-line-modified-removed">-       follow_barrier_uses(n, ctrl, uses, phase);</span>
<span class="udiff-line-modified-added">+       follow_barrier_uses(n, init_ctrl, uses, phase);</span>
      }
<span class="udiff-line-added">+     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);</span>
  
<span class="udiff-line-modified-removed">-     // The slow path call produces memory: hook the raw memory phi</span>
<span class="udiff-line-modified-removed">-     // from the expanded write barrier with the rest of the graph</span>
<span class="udiff-line-modified-removed">-     // which may require adding memory phis at every post dominated</span>
<span class="udiff-line-modified-removed">-     // region and at enclosing loop heads. Use the memory state</span>
<span class="udiff-line-modified-removed">-     // collected in memory_nodes to fix the memory graph. Update that</span>
<span class="udiff-line-modified-removed">-     // memory state as we go.</span>
<span class="udiff-line-modified-removed">-     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);</span>
<span class="udiff-line-modified-removed">-     assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == cnt - 1, &quot;not replaced&quot;);</span>
<span class="udiff-line-modified-added">+     phase-&gt;igvn().replace_node(barrier, pre_val);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   assert(state-&gt;enqueue_barriers_count() == 0, &quot;all enqueue barrier nodes should have been replaced&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierC2Support::get_load_addr(PhaseIdealLoop* phase, VectorSet&amp; visited, Node* in) {</span>
<span class="udiff-line-modified-added">+   if (visited.test_set(in-&gt;_idx)) {</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   switch (in-&gt;Opcode()) {</span>
<span class="udiff-line-added">+     case Op_Proj:</span>
<span class="udiff-line-added">+       return get_load_addr(phase, visited, in-&gt;in(0));</span>
<span class="udiff-line-added">+     case Op_CastPP:</span>
<span class="udiff-line-added">+     case Op_CheckCastPP:</span>
<span class="udiff-line-added">+     case Op_DecodeN:</span>
<span class="udiff-line-added">+     case Op_EncodeP:</span>
<span class="udiff-line-added">+       return get_load_addr(phase, visited, in-&gt;in(1));</span>
<span class="udiff-line-added">+     case Op_LoadN:</span>
<span class="udiff-line-added">+     case Op_LoadP:</span>
<span class="udiff-line-added">+       return in-&gt;in(MemNode::Address);</span>
<span class="udiff-line-added">+     case Op_CompareAndExchangeN:</span>
<span class="udiff-line-added">+     case Op_CompareAndExchangeP:</span>
<span class="udiff-line-added">+     case Op_GetAndSetN:</span>
<span class="udiff-line-added">+     case Op_GetAndSetP:</span>
<span class="udiff-line-added">+     case Op_ShenandoahCompareAndExchangeP:</span>
<span class="udiff-line-added">+     case Op_ShenandoahCompareAndExchangeN:</span>
<span class="udiff-line-added">+       // Those instructions would just have stored a different</span>
<span class="udiff-line-added">+       // value into the field. No use to attempt to fix it at this point.</span>
<span class="udiff-line-added">+       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="udiff-line-added">+     case Op_CMoveP:</span>
<span class="udiff-line-added">+     case Op_CMoveN: {</span>
<span class="udiff-line-added">+       Node* t = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfTrue));</span>
<span class="udiff-line-added">+       Node* f = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfFalse));</span>
<span class="udiff-line-added">+       // Handle unambiguous cases: single address reported on both branches.</span>
<span class="udiff-line-added">+       if (t != NULL &amp;&amp; f == NULL) return t;</span>
<span class="udiff-line-added">+       if (t == NULL &amp;&amp; f != NULL) return f;</span>
<span class="udiff-line-added">+       if (t != NULL &amp;&amp; t == f)    return t;</span>
<span class="udiff-line-added">+       // Ambiguity.</span>
<span class="udiff-line-added">+       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case Op_Phi: {</span>
<span class="udiff-line-added">+       Node* addr = NULL;</span>
<span class="udiff-line-added">+       for (uint i = 1; i &lt; in-&gt;req(); i++) {</span>
<span class="udiff-line-added">+         Node* addr1 = get_load_addr(phase, visited, in-&gt;in(i));</span>
<span class="udiff-line-added">+         if (addr == NULL) {</span>
<span class="udiff-line-added">+           addr = addr1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (addr != addr1) {</span>
<span class="udiff-line-added">+           return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return addr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="udiff-line-added">+       return get_load_addr(phase, visited, in-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="udiff-line-added">+     case Op_ShenandoahEnqueueBarrier:</span>
<span class="udiff-line-added">+       return get_load_addr(phase, visited, in-&gt;in(1));</span>
<span class="udiff-line-added">+     case Op_CallDynamicJava:</span>
<span class="udiff-line-added">+     case Op_CallLeaf:</span>
<span class="udiff-line-added">+     case Op_CallStaticJava:</span>
<span class="udiff-line-added">+     case Op_ConN:</span>
<span class="udiff-line-added">+     case Op_ConP:</span>
<span class="udiff-line-added">+     case Op_Parm:</span>
<span class="udiff-line-added">+     case Op_CreateEx:</span>
<span class="udiff-line-added">+       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+       fatal(&quot;Unknown node in get_load_addr: %s&quot;, NodeClassNames[in-&gt;Opcode()]);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
    }
  
<span class="udiff-line-removed">-   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == 0, &quot;all write barrier nodes should have been replaced&quot;);</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {</span>
    IdealLoopTree *loop = phase-&gt;get_loop(iff);
    Node* loop_head = loop-&gt;_head;
    Node* entry_c = loop_head-&gt;in(LoopNode::EntryControl);
  
    Node* bol = iff-&gt;in(1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3076,11 +1846,11 @@</span>
      Node* old_bol =iff-&gt;in(1);
      phase-&gt;igvn().replace_input_of(iff, 1, bol);
    }
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahWriteBarrierNode::identical_backtoback_ifs(Node *n, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {</span>
    if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
      return false;
    }
    Node* region = n-&gt;in(0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3111,11 +1881,11 @@</span>
    }
  
    return true;
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {</span>
    assert(is_heap_stable_test(n), &quot;no other tests&quot;);
    if (identical_backtoback_ifs(n, phase)) {
      Node* n_ctrl = n-&gt;in(0);
      if (phase-&gt;can_split_if(n_ctrl)) {
        IfNode* dom_if = phase-&gt;idom(n_ctrl)-&gt;as_If();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3147,11 +1917,11 @@</span>
        phase-&gt;do_split_if(n);
      }
    }
  }
  
<span class="udiff-line-modified-removed">- IfNode* ShenandoahWriteBarrierNode::find_unswitching_candidate(const IdealLoopTree *loop, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ IfNode* ShenandoahBarrierC2Support::find_unswitching_candidate(const IdealLoopTree* loop, PhaseIdealLoop* phase) {</span>
    // Find first invariant test that doesn&#39;t exit the loop
    LoopNode *head = loop-&gt;_head-&gt;as_Loop();
    IfNode* unswitch_iff = NULL;
    Node* n = head-&gt;in(LoopNode::LoopBackControl);
    int loop_has_sfpts = -1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3192,14 +1962,13 @@</span>
    }
    return unswitch_iff;
  }
  
  
<span class="udiff-line-modified-removed">- void ShenandoahWriteBarrierNode::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {</span>
    Node_List heap_stable_tests;
    Node_List gc_state_loads;
<span class="udiff-line-removed">- </span>
    stack.push(phase-&gt;C-&gt;start(), 0);
    do {
      Node* n = stack.node();
      uint i = stack.index();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3243,22 +2012,26 @@</span>
        Node* n = heap_stable_tests.at(i);
        IdealLoopTree* loop = phase-&gt;get_loop(n);
        if (loop != phase-&gt;ltree_root() &amp;&amp;
            loop-&gt;_child == NULL &amp;&amp;
            !loop-&gt;_irreducible) {
<span class="udiff-line-modified-removed">-         LoopNode* head = loop-&gt;_head-&gt;as_Loop();</span>
<span class="udiff-line-modified-removed">-         if ((!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         Node* head = loop-&gt;_head;</span>
<span class="udiff-line-modified-added">+         if (head-&gt;is_Loop() &amp;&amp;</span>
<span class="udiff-line-added">+             (!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;</span>
              !seen.test_set(head-&gt;_idx)) {
            IfNode* iff = find_unswitching_candidate(loop, phase);
            if (iff != NULL) {
              Node* bol = iff-&gt;in(1);
<span class="udiff-line-modified-removed">-             if (head-&gt;is_strip_mined()) {</span>
<span class="udiff-line-modified-removed">-               head-&gt;verify_strip_mined(0);</span>
<span class="udiff-line-modified-added">+             if (head-&gt;as_Loop()-&gt;is_strip_mined()) {</span>
<span class="udiff-line-modified-added">+               head-&gt;as_Loop()-&gt;verify_strip_mined(0);</span>
              }
              move_heap_stable_test_out_of_loop(iff, phase);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             AutoNodeBudget node_budget(phase);</span>
<span class="udiff-line-added">+ </span>
              if (loop-&gt;policy_unswitching(phase)) {
<span class="udiff-line-modified-removed">-               if (head-&gt;is_strip_mined()) {</span>
<span class="udiff-line-modified-added">+               if (head-&gt;as_Loop()-&gt;is_strip_mined()) {</span>
                  OuterStripMinedLoopNode* outer = head-&gt;as_CountedLoop()-&gt;outer_loop();
                  hide_strip_mined_loop(outer, head-&gt;as_CountedLoop(), phase);
                }
                phase-&gt;do_unswitching(loop, old_new);
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3272,21 +2045,21 @@</span>
      }
    }
  }
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">- void ShenandoahBarrierNode::verify_raw_mem(RootNode* root) {</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierC2Support::verify_raw_mem(RootNode* root) {</span>
    const bool trace = false;
    ResourceMark rm;
    Unique_Node_List nodes;
    Unique_Node_List controls;
    Unique_Node_List memories;
  
    nodes.push(root);
    for (uint next = 0; next &lt; nodes.size(); next++) {
      Node *n  = nodes.at(next);
<span class="udiff-line-modified-removed">-     if (ShenandoahBarrierSetC2::is_shenandoah_wb_call(n)) {</span>
<span class="udiff-line-modified-added">+     if (ShenandoahBarrierSetC2::is_shenandoah_lrb_call(n)) {</span>
        controls.push(n);
        if (trace) { tty-&gt;print(&quot;XXXXXX verifying&quot;); n-&gt;dump(); }
        for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
          Node *m = controls.at(next2);
          for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3370,19 +2143,23 @@</span>
      }
    }
  }
  #endif
  
<span class="udiff-line-added">+ ShenandoahEnqueueBarrierNode::ShenandoahEnqueueBarrierNode(Node* val) : Node(NULL, val) {</span>
<span class="udiff-line-added">+   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_enqueue_barrier(this);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {
    if (in(1) == NULL || in(1)-&gt;is_top()) {
      return Type::TOP;
    }
    const Type* t = in(1)-&gt;bottom_type();
    if (t == TypePtr::NULL_PTR) {
      return t;
    }
<span class="udiff-line-modified-removed">-   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="udiff-line-modified-added">+   return t-&gt;is_oopptr();</span>
  }
  
  const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {
    if (in(1) == NULL) {
      return Type::TOP;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3392,16 +2169,17 @@</span>
      return Type::TOP;
    }
    if (t == TypePtr::NULL_PTR) {
      return t;
    }
<span class="udiff-line-modified-removed">-   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="udiff-line-modified-added">+   return t-&gt;is_oopptr();</span>
  }
  
  int ShenandoahEnqueueBarrierNode::needed(Node* n) {
    if (n == NULL ||
        n-&gt;is_Allocate() ||
<span class="udiff-line-added">+       n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier ||</span>
        n-&gt;bottom_type() == TypePtr::NULL_PTR ||
        (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL)) {
      return NotNeeded;
    }
    if (n-&gt;is_Phi() ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3517,21 +2295,58 @@</span>
          Node* in = n-&gt;in(i);
          int in_opc = in-&gt;Opcode();
          if (in_opc == Op_Return || in_opc == Op_Rethrow) {
            mem = in-&gt;in(TypeFunc::Memory);
          } else if (in_opc == Op_Halt) {
<span class="udiff-line-modified-removed">-           if (!in-&gt;in(0)-&gt;is_Region()) {</span>
<span class="udiff-line-modified-added">+           if (in-&gt;in(0)-&gt;is_Region()) {</span>
<span class="udiff-line-added">+             Node* r = in-&gt;in(0);</span>
<span class="udiff-line-added">+             for (uint j = 1; j &lt; r-&gt;req(); j++) {</span>
<span class="udiff-line-added">+               assert(r-&gt;in(j)-&gt;Opcode() != Op_NeverBranch, &quot;&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           } else {</span>
              Node* proj = in-&gt;in(0);
              assert(proj-&gt;is_Proj(), &quot;&quot;);
              Node* in = proj-&gt;in(0);
              assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
              if (in-&gt;is_CallStaticJava()) {
                mem = in-&gt;in(TypeFunc::Memory);
              } else if (in-&gt;Opcode() == Op_Catch) {
                Node* call = in-&gt;in(0)-&gt;in(0);
                assert(call-&gt;is_Call(), &quot;&quot;);
                mem = call-&gt;in(TypeFunc::Memory);
<span class="udiff-line-added">+             } else if (in-&gt;Opcode() == Op_NeverBranch) {</span>
<span class="udiff-line-added">+               Node* head = in-&gt;in(0);</span>
<span class="udiff-line-added">+               assert(head-&gt;is_Region() &amp;&amp; head-&gt;req() == 3, &quot;unexpected infinite loop graph shape&quot;);</span>
<span class="udiff-line-added">+               assert(_phase-&gt;is_dominator(head, head-&gt;in(1)) || _phase-&gt;is_dominator(head, head-&gt;in(2)), &quot;no back branch?&quot;);</span>
<span class="udiff-line-added">+               Node* tail = _phase-&gt;is_dominator(head, head-&gt;in(1)) ? head-&gt;in(1) : head-&gt;in(2);</span>
<span class="udiff-line-added">+               Node* c = tail;</span>
<span class="udiff-line-added">+               while (c != head) {</span>
<span class="udiff-line-added">+                 if (c-&gt;is_SafePoint() &amp;&amp; !c-&gt;is_CallLeaf()) {</span>
<span class="udiff-line-added">+                   mem = c-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 c = _phase-&gt;idom(c);</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+               assert(mem != NULL, &quot;should have found safepoint&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+               Node* phi_mem = NULL;</span>
<span class="udiff-line-added">+               for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="udiff-line-added">+                 Node* u = head-&gt;fast_out(j);</span>
<span class="udiff-line-added">+                 if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="udiff-line-added">+                   if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {</span>
<span class="udiff-line-added">+                     assert(phi_mem == NULL || phi_mem-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);</span>
<span class="udiff-line-added">+                     phi_mem = u;</span>
<span class="udiff-line-added">+                   } else if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="udiff-line-added">+                     assert(phi_mem == NULL || _phase-&gt;C-&gt;get_alias_index(phi_mem-&gt;adr_type()) == _alias, &quot;&quot;);</span>
<span class="udiff-line-added">+                     if (phi_mem == NULL) {</span>
<span class="udiff-line-added">+                       phi_mem = u;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                   }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+               if (phi_mem != NULL) {</span>
<span class="udiff-line-added">+                 mem = phi_mem;</span>
<span class="udiff-line-added">+               }</span>
              }
            }
          } else {
  #ifdef ASSERT
            n-&gt;dump();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3566,16 +2381,10 @@</span>
            mem = mm-&gt;memory_at(_alias);
          } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
            assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
            stack.push(mem, mem-&gt;req());
            mem = mem-&gt;in(MemNode::Memory);
<span class="udiff-line-removed">-         } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-           assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="udiff-line-removed">-           mem = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="udiff-line-removed">-         } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-           stack.push(mem, mem-&gt;req());</span>
<span class="udiff-line-removed">-           mem = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
          } else {
  #ifdef ASSERT
            mem-&gt;dump();
  #endif
            ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3593,11 +2402,11 @@</span>
    } while(stack.is_nonempty());
  
    // Iterate over CFG nodes in rpo and propagate memory state to
    // compute memory state at regions, creating new phis if needed.
    Node_List rpo_list;
<span class="udiff-line-modified-removed">-   visited.Clear();</span>
<span class="udiff-line-modified-added">+   visited.clear();</span>
    _phase-&gt;rpo(_phase-&gt;C-&gt;root(), stack, visited, rpo_list);
    Node* root = rpo_list.pop();
    assert(root == _phase-&gt;C-&gt;root(), &quot;&quot;);
  
    const bool trace = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3625,11 +2434,11 @@</span>
    int iteration = 0;
    Node_List dead_phis;
    while (progress) {
      progress = false;
      iteration++;
<span class="udiff-line-modified-removed">-     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);</span>
      if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
      IdealLoopTree* last_updated_ilt = NULL;
      for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
        Node* c = rpo_list.at(i);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3793,11 +2602,11 @@</span>
           (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem))) {
      c = _phase-&gt;idom(c);
      mem = _memory_nodes[c-&gt;_idx];
    }
    if (n != NULL &amp;&amp; mem_is_valid(mem, c)) {
<span class="udiff-line-modified-removed">-     while (!ShenandoahWriteBarrierNode::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {</span>
<span class="udiff-line-modified-added">+     while (!ShenandoahBarrierC2Support::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {</span>
        mem = next_mem(mem, _alias);
      }
      if (mem-&gt;is_MergeMem()) {
        mem = mem-&gt;as_MergeMem()-&gt;memory_at(_alias);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3839,26 +2648,20 @@</span>
          assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
          old = old-&gt;in(MemNode::Memory);
        } else if (old-&gt;Opcode() == Op_SCMemProj) {
          assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
          old = old-&gt;in(0);
<span class="udiff-line-removed">-       } else if (old-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-removed">-         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="udiff-line-removed">-         old = old-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="udiff-line-removed">-       } else if (old-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="udiff-line-removed">-         old = old-&gt;in(ShenandoahBarrierNode::Memory);</span>
        } else {
          ShouldNotReachHere();
        }
      }
      assert(prev != NULL, &quot;&quot;);
      if (new_ctrl != ctrl) {
        _memory_nodes.map(ctrl-&gt;_idx, mem);
        _memory_nodes.map(new_ctrl-&gt;_idx, mem_for_ctrl);
      }
<span class="udiff-line-modified-removed">-     uint input = prev-&gt;Opcode() == Op_ShenandoahWriteBarrier ? (uint)ShenandoahBarrierNode::Memory : (uint)MemNode::Memory;</span>
<span class="udiff-line-modified-added">+     uint input = (uint)MemNode::Memory;</span>
      _phase-&gt;igvn().replace_input_of(prev, input, new_mem);
    } else {
      uses.clear();
      _memory_nodes.map(new_ctrl-&gt;_idx, new_mem);
      uses.push(new_ctrl);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3885,11 +2688,15 @@</span>
                  IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);
                  bool do_check = true;
                  IdealLoopTree* l = loop;
                  create_phi = false;
                  while (l != _phase-&gt;ltree_root()) {
<span class="udiff-line-modified-removed">-                   if (_phase-&gt;is_dominator(l-&gt;_head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), l-&gt;_head)) {</span>
<span class="udiff-line-modified-added">+                   Node* head = l-&gt;_head;</span>
<span class="udiff-line-added">+                   if (head-&gt;in(0) == NULL) {</span>
<span class="udiff-line-added">+                     head = _phase-&gt;get_ctrl(head);</span>
<span class="udiff-line-added">+                   }</span>
<span class="udiff-line-added">+                   if (_phase-&gt;is_dominator(head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), head)) {</span>
                      create_phi = true;
                      do_check = false;
                      break;
                    }
                    l = l-&gt;_parent;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3922,23 +2729,18 @@</span>
                    DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
                    _memory_nodes.map(u-&gt;_idx, phi);
                  } else {
                    DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
                    for (;;) {
<span class="udiff-line-modified-removed">-                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier || m-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);</span>
                      Node* next = NULL;
                      if (m-&gt;is_Proj()) {
                        next = m-&gt;in(0);
<span class="udiff-line-modified-removed">-                     } else if (m-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="udiff-line-modified-removed">-                       next = m-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="udiff-line-removed">-                     } else if (m-&gt;is_Mem() || m-&gt;is_LoadStore()) {</span>
<span class="udiff-line-modified-added">+                     } else {</span>
<span class="udiff-line-modified-added">+                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);</span>
                        assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
                        next = m-&gt;in(MemNode::Memory);
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                       assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="udiff-line-removed">-                       assert (m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="udiff-line-removed">-                       next = m-&gt;in(ShenandoahBarrierNode::Memory);</span>
                      }
                      if (_phase-&gt;get_ctrl(next) != u) {
                        break;
                      }
                      if (next-&gt;is_MergeMem()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3951,12 +2753,12 @@</span>
                      }
                      m = next;
                    }
  
                    DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting to phi&quot;); m-&gt;dump(); });
<span class="udiff-line-modified-removed">-                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="udiff-line-modified-removed">-                   uint input = (m-&gt;is_Mem() || m-&gt;is_LoadStore()) ? (uint)MemNode::Memory : (uint)ShenandoahBarrierNode::Memory;</span>
<span class="udiff-line-modified-added">+                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+                   uint input = (uint)MemNode::Memory;</span>
                    _phase-&gt;igvn().replace_input_of(m, input, phi);
                    push = false;
                  }
                } else {
                  DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ skipping region&quot;); u-&gt;dump(); });
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3985,10 +2787,24 @@</span>
    }
    uint last = _phase-&gt;C-&gt;unique();
    MergeMemNode* mm = NULL;
    int alias = _alias;
    DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ raw mem is&quot;); mem-&gt;dump(); });
<span class="udiff-line-added">+   // Process loads first to not miss an anti-dependency: if the memory</span>
<span class="udiff-line-added">+   // edge of a store is updated before a load is processed then an</span>
<span class="udiff-line-added">+   // anti-dependency may be missed.</span>
<span class="udiff-line-added">+   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {</span>
<span class="udiff-line-added">+     Node* u = mem-&gt;out(i);</span>
<span class="udiff-line-added">+     if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;is_Load() &amp;&amp; _phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {</span>
<span class="udiff-line-added">+       Node* m = find_mem(_phase-&gt;get_ctrl(u), u);</span>
<span class="udiff-line-added">+       if (m != mem) {</span>
<span class="udiff-line-added">+         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });</span>
<span class="udiff-line-added">+         _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);</span>
<span class="udiff-line-added">+         --i;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
    for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
      Node* u = mem-&gt;out(i);
      if (u-&gt;_idx &lt; last) {
        if (u-&gt;is_Mem()) {
          if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4178,24 +2994,11 @@</span>
    MergeMemNode* mm = NULL;
    assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
    for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
      Node* u = mem-&gt;out(i);
      if (u != replacement &amp;&amp; u-&gt;_idx &lt; last) {
<span class="udiff-line-modified-removed">-       if (u-&gt;is_ShenandoahBarrier() &amp;&amp; _alias != Compile::AliasIdxRaw) {</span>
<span class="udiff-line-removed">-         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="udiff-line-removed">-           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="udiff-line-removed">-           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="udiff-line-removed">-           --i;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else if (u-&gt;is_Mem()) {</span>
<span class="udiff-line-removed">-         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="udiff-line-removed">-           assert(_alias == Compile::AliasIdxRaw , &quot;only raw memory can lead to a memory operation&quot;);</span>
<span class="udiff-line-removed">-           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="udiff-line-removed">-           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="udiff-line-removed">-           --i;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else if (u-&gt;is_MergeMem()) {</span>
<span class="udiff-line-modified-added">+       if (u-&gt;is_MergeMem()) {</span>
          MergeMemNode* u_mm = u-&gt;as_MergeMem();
          if (u_mm-&gt;memory_at(_alias) == mem) {
            MergeMemNode* newmm = NULL;
            for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
              Node* uu = u-&gt;fast_out(j);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4219,11 +3022,11 @@</span>
                  if (nb &gt; 0) {
                    --j;
                  }
                }
              } else {
<span class="udiff-line-modified-removed">-               if (rep_ctrl != uu &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {</span>
<span class="udiff-line-modified-added">+               if (rep_ctrl != uu &amp;&amp; ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {</span>
                  if (newmm == NULL) {
                    newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
                  }
                  if (newmm != u) {
                    _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4260,33 +3063,352 @@</span>
                   u-&gt;adr_type() == NULL) {
          assert(u-&gt;adr_type() != NULL ||
                 u-&gt;Opcode() == Op_Rethrow ||
                 u-&gt;Opcode() == Op_Return ||
                 u-&gt;Opcode() == Op_SafePoint ||
<span class="udiff-line-added">+                u-&gt;Opcode() == Op_StoreIConditional ||</span>
<span class="udiff-line-added">+                u-&gt;Opcode() == Op_StoreLConditional ||</span>
                 (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
                 (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
<span class="udiff-line-modified-removed">-                u-&gt;Opcode() == Op_CallLeaf, &quot;&quot;);</span>
<span class="udiff-line-modified-removed">-         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="udiff-line-modified-added">+                u-&gt;Opcode() == Op_CallLeaf, &quot;%s&quot;, u-&gt;Name());</span>
<span class="udiff-line-modified-added">+         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
            if (mm == NULL) {
              mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
            }
            _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
            --i;
          }
        } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
<span class="udiff-line-modified-removed">-         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="udiff-line-modified-added">+         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
            _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);
            --i;
          }
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- void MemoryGraphFixer::remove(Node* n) {</span>
<span class="udiff-line-modified-removed">-   assert(n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
<span class="udiff-line-modified-removed">-   Node* c = _phase-&gt;get_ctrl(n);</span>
<span class="udiff-line-modified-removed">-   Node* mem = find_mem(c, NULL);</span>
<span class="udiff-line-modified-removed">-   if (mem == n) {</span>
<span class="udiff-line-modified-removed">-     _memory_nodes.map(c-&gt;_idx, mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(ShenandoahBarrierNode::Memory));</span>
<span class="udiff-line-modified-added">+ ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool native)</span>
<span class="udiff-line-modified-added">+ : Node(ctrl, obj), _native(native) {</span>
<span class="udiff-line-modified-added">+   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_load_reference_barrier(this);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool ShenandoahLoadReferenceBarrierNode::is_native() const {</span>
<span class="udiff-line-added">+   return _native;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint ShenandoahLoadReferenceBarrierNode::size_of() const {</span>
<span class="udiff-line-added">+   return sizeof(*this);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint ShenandoahLoadReferenceBarrierNode::hash() const {</span>
<span class="udiff-line-added">+   return Node::hash() + (_native ? 1 : 0);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool ShenandoahLoadReferenceBarrierNode::cmp( const Node &amp;n ) const {</span>
<span class="udiff-line-added">+   return Node::cmp(n) &amp;&amp; n.Opcode() == Op_ShenandoahLoadReferenceBarrier &amp;&amp;</span>
<span class="udiff-line-added">+          _native == ((const ShenandoahLoadReferenceBarrierNode&amp;)n)._native;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type* ShenandoahLoadReferenceBarrierNode::bottom_type() const {</span>
<span class="udiff-line-added">+   if (in(ValueIn) == NULL || in(ValueIn)-&gt;is_top()) {</span>
<span class="udiff-line-added">+     return Type::TOP;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   const Type* t = in(ValueIn)-&gt;bottom_type();</span>
<span class="udiff-line-added">+   if (t == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+     return t;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return t-&gt;is_oopptr();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const Type* ShenandoahLoadReferenceBarrierNode::Value(PhaseGVN* phase) const {</span>
<span class="udiff-line-added">+   // Either input is TOP ==&gt; the result is TOP</span>
<span class="udiff-line-added">+   const Type *t2 = phase-&gt;type(in(ValueIn));</span>
<span class="udiff-line-added">+   if( t2 == Type::TOP ) return Type::TOP;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (t2 == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+     return t2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Type* type = t2-&gt;is_oopptr();</span>
<span class="udiff-line-added">+   return type;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Node* ShenandoahLoadReferenceBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="udiff-line-added">+   Node* value = in(ValueIn);</span>
<span class="udiff-line-added">+   if (!needs_barrier(phase, value)) {</span>
<span class="udiff-line-added">+     return value;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return this;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool ShenandoahLoadReferenceBarrierNode::needs_barrier(PhaseGVN* phase, Node* n) {</span>
<span class="udiff-line-added">+   Unique_Node_List visited;</span>
<span class="udiff-line-added">+   return needs_barrier_impl(phase, n, visited);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool ShenandoahLoadReferenceBarrierNode::needs_barrier_impl(PhaseGVN* phase, Node* n, Unique_Node_List &amp;visited) {</span>
<span class="udiff-line-added">+   if (n == NULL) return false;</span>
<span class="udiff-line-added">+   if (visited.member(n)) {</span>
<span class="udiff-line-added">+     return false; // Been there.</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   visited.push(n);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (n-&gt;is_Allocate()) {</span>
<span class="udiff-line-added">+     // tty-&gt;print_cr(&quot;optimize barrier on alloc&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (n-&gt;is_Call()) {</span>
<span class="udiff-line-added">+     // tty-&gt;print_cr(&quot;optimize barrier on call&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Type* type = phase-&gt;type(n);</span>
<span class="udiff-line-added">+   if (type == Type::TOP) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="udiff-line-added">+     // tty-&gt;print_cr(&quot;optimize barrier on null&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {</span>
<span class="udiff-line-added">+     // tty-&gt;print_cr(&quot;optimize barrier on constant&quot;);</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   switch (n-&gt;Opcode()) {</span>
<span class="udiff-line-added">+     case Op_AddP:</span>
<span class="udiff-line-added">+       return true; // TODO: Can refine?</span>
<span class="udiff-line-added">+     case Op_LoadP:</span>
<span class="udiff-line-added">+     case Op_ShenandoahCompareAndExchangeN:</span>
<span class="udiff-line-added">+     case Op_ShenandoahCompareAndExchangeP:</span>
<span class="udiff-line-added">+     case Op_CompareAndExchangeN:</span>
<span class="udiff-line-added">+     case Op_CompareAndExchangeP:</span>
<span class="udiff-line-added">+     case Op_GetAndSetN:</span>
<span class="udiff-line-added">+     case Op_GetAndSetP:</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     case Op_Phi: {</span>
<span class="udiff-line-added">+       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="udiff-line-added">+         if (needs_barrier_impl(phase, n-&gt;in(i), visited)) return true;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case Op_CheckCastPP:</span>
<span class="udiff-line-added">+     case Op_CastPP:</span>
<span class="udiff-line-added">+       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="udiff-line-added">+     case Op_Proj:</span>
<span class="udiff-line-added">+       return needs_barrier_impl(phase, n-&gt;in(0), visited);</span>
<span class="udiff-line-added">+     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="udiff-line-added">+       // tty-&gt;print_cr(&quot;optimize barrier on barrier&quot;);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     case Op_Parm:</span>
<span class="udiff-line-added">+       // tty-&gt;print_cr(&quot;optimize barrier on input arg&quot;);</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     case Op_DecodeN:</span>
<span class="udiff-line-added">+     case Op_EncodeP:</span>
<span class="udiff-line-added">+       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="udiff-line-added">+     case Op_LoadN:</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     case Op_CMoveN:</span>
<span class="udiff-line-added">+     case Op_CMoveP:</span>
<span class="udiff-line-added">+       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||</span>
<span class="udiff-line-added">+              needs_barrier_impl(phase, n-&gt;in(3), visited);</span>
<span class="udiff-line-added">+     case Op_ShenandoahEnqueueBarrier:</span>
<span class="udiff-line-added">+       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="udiff-line-added">+     case Op_CreateEx:</span>
<span class="udiff-line-added">+       return false;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   tty-&gt;print(&quot;need barrier on?: &quot;);</span>
<span class="udiff-line-added">+   tty-&gt;print_cr(&quot;ins:&quot;);</span>
<span class="udiff-line-added">+   n-&gt;dump(2);</span>
<span class="udiff-line-added">+   tty-&gt;print_cr(&quot;outs:&quot;);</span>
<span class="udiff-line-added">+   n-&gt;dump(-2);</span>
<span class="udiff-line-added">+   ShouldNotReachHere();</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ShenandoahLoadReferenceBarrierNode::Strength ShenandoahLoadReferenceBarrierNode::get_barrier_strength() {</span>
<span class="udiff-line-added">+   Unique_Node_List visited;</span>
<span class="udiff-line-added">+   Node_Stack stack(0);</span>
<span class="udiff-line-added">+   stack.push(this, 0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Look for strongest strength: go over nodes looking for STRONG ones.</span>
<span class="udiff-line-added">+   // Stop once we encountered STRONG. Otherwise, walk until we ran out of nodes,</span>
<span class="udiff-line-added">+   // and then the overall strength is NONE.</span>
<span class="udiff-line-added">+   Strength strength = NONE;</span>
<span class="udiff-line-added">+   while (strength != STRONG &amp;&amp; stack.size() &gt; 0) {</span>
<span class="udiff-line-added">+     Node* n = stack.node();</span>
<span class="udiff-line-added">+     if (visited.member(n)) {</span>
<span class="udiff-line-added">+       stack.pop();</span>
<span class="udiff-line-added">+       continue;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     visited.push(n);</span>
<span class="udiff-line-added">+     bool visit_users = false;</span>
<span class="udiff-line-added">+     switch (n-&gt;Opcode()) {</span>
<span class="udiff-line-added">+       case Op_CallStaticJava:</span>
<span class="udiff-line-added">+       case Op_CallDynamicJava:</span>
<span class="udiff-line-added">+       case Op_CallLeaf:</span>
<span class="udiff-line-added">+       case Op_CallLeafNoFP:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapL:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapI:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapB:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapS:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapN:</span>
<span class="udiff-line-added">+       case Op_CompareAndSwapP:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeL:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeI:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeB:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeS:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeN:</span>
<span class="udiff-line-added">+       case Op_CompareAndExchangeP:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapL:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapI:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapB:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapS:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapN:</span>
<span class="udiff-line-added">+       case Op_WeakCompareAndSwapP:</span>
<span class="udiff-line-added">+       case Op_ShenandoahCompareAndSwapN:</span>
<span class="udiff-line-added">+       case Op_ShenandoahCompareAndSwapP:</span>
<span class="udiff-line-added">+       case Op_ShenandoahWeakCompareAndSwapN:</span>
<span class="udiff-line-added">+       case Op_ShenandoahWeakCompareAndSwapP:</span>
<span class="udiff-line-added">+       case Op_ShenandoahCompareAndExchangeN:</span>
<span class="udiff-line-added">+       case Op_ShenandoahCompareAndExchangeP:</span>
<span class="udiff-line-added">+       case Op_GetAndSetL:</span>
<span class="udiff-line-added">+       case Op_GetAndSetI:</span>
<span class="udiff-line-added">+       case Op_GetAndSetB:</span>
<span class="udiff-line-added">+       case Op_GetAndSetS:</span>
<span class="udiff-line-added">+       case Op_GetAndSetP:</span>
<span class="udiff-line-added">+       case Op_GetAndSetN:</span>
<span class="udiff-line-added">+       case Op_GetAndAddL:</span>
<span class="udiff-line-added">+       case Op_GetAndAddI:</span>
<span class="udiff-line-added">+       case Op_GetAndAddB:</span>
<span class="udiff-line-added">+       case Op_GetAndAddS:</span>
<span class="udiff-line-added">+       case Op_ShenandoahEnqueueBarrier:</span>
<span class="udiff-line-added">+       case Op_FastLock:</span>
<span class="udiff-line-added">+       case Op_FastUnlock:</span>
<span class="udiff-line-added">+       case Op_Rethrow:</span>
<span class="udiff-line-added">+       case Op_Return:</span>
<span class="udiff-line-added">+       case Op_StoreB:</span>
<span class="udiff-line-added">+       case Op_StoreC:</span>
<span class="udiff-line-added">+       case Op_StoreD:</span>
<span class="udiff-line-added">+       case Op_StoreF:</span>
<span class="udiff-line-added">+       case Op_StoreL:</span>
<span class="udiff-line-added">+       case Op_StoreLConditional:</span>
<span class="udiff-line-added">+       case Op_StoreI:</span>
<span class="udiff-line-added">+       case Op_StoreIConditional:</span>
<span class="udiff-line-added">+       case Op_StoreN:</span>
<span class="udiff-line-added">+       case Op_StoreP:</span>
<span class="udiff-line-added">+       case Op_StoreVector:</span>
<span class="udiff-line-added">+       case Op_StrInflatedCopy:</span>
<span class="udiff-line-added">+       case Op_StrCompressedCopy:</span>
<span class="udiff-line-added">+       case Op_EncodeP:</span>
<span class="udiff-line-added">+       case Op_CastP2X:</span>
<span class="udiff-line-added">+       case Op_SafePoint:</span>
<span class="udiff-line-added">+       case Op_EncodeISOArray:</span>
<span class="udiff-line-added">+       case Op_AryEq:</span>
<span class="udiff-line-added">+       case Op_StrEquals:</span>
<span class="udiff-line-added">+       case Op_StrComp:</span>
<span class="udiff-line-added">+       case Op_StrIndexOf:</span>
<span class="udiff-line-added">+       case Op_StrIndexOfChar:</span>
<span class="udiff-line-added">+       case Op_HasNegatives:</span>
<span class="udiff-line-added">+         // Known to require barriers</span>
<span class="udiff-line-added">+         strength = STRONG;</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Op_CmpP: {</span>
<span class="udiff-line-added">+         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||</span>
<span class="udiff-line-added">+             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="udiff-line-added">+           // One of the sides is known null, no need for barrier.</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           strength = STRONG;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       case Op_LoadB:</span>
<span class="udiff-line-added">+       case Op_LoadUB:</span>
<span class="udiff-line-added">+       case Op_LoadUS:</span>
<span class="udiff-line-added">+       case Op_LoadD:</span>
<span class="udiff-line-added">+       case Op_LoadF:</span>
<span class="udiff-line-added">+       case Op_LoadL:</span>
<span class="udiff-line-added">+       case Op_LoadI:</span>
<span class="udiff-line-added">+       case Op_LoadS:</span>
<span class="udiff-line-added">+       case Op_LoadN:</span>
<span class="udiff-line-added">+       case Op_LoadP:</span>
<span class="udiff-line-added">+       case Op_LoadVector: {</span>
<span class="udiff-line-added">+         const TypePtr* adr_type = n-&gt;adr_type();</span>
<span class="udiff-line-added">+         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-added">+         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);</span>
<span class="udiff-line-added">+         ciField* field = alias_type-&gt;field();</span>
<span class="udiff-line-added">+         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();</span>
<span class="udiff-line-added">+         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {</span>
<span class="udiff-line-added">+           // Loading the constant does not require barriers: it should be handled</span>
<span class="udiff-line-added">+           // as part of GC roots already.</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+           strength = STRONG;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       case Op_Conv2B:</span>
<span class="udiff-line-added">+       case Op_LoadRange:</span>
<span class="udiff-line-added">+       case Op_LoadKlass:</span>
<span class="udiff-line-added">+       case Op_LoadNKlass:</span>
<span class="udiff-line-added">+         // Do not require barriers</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       case Op_AddP:</span>
<span class="udiff-line-added">+       case Op_CheckCastPP:</span>
<span class="udiff-line-added">+       case Op_CastPP:</span>
<span class="udiff-line-added">+       case Op_CMoveP:</span>
<span class="udiff-line-added">+       case Op_Phi:</span>
<span class="udiff-line-added">+       case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="udiff-line-added">+         // Whether or not these need the barriers depends on their users</span>
<span class="udiff-line-added">+         visit_users = true;</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       default: {</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+         fatal(&quot;Unknown node in get_barrier_strength: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+         // Default to strong: better to have excess barriers, rather than miss some.</span>
<span class="udiff-line-added">+         strength = STRONG;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     stack.pop();</span>
<span class="udiff-line-added">+     if (visit_users) {</span>
<span class="udiff-line-added">+       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+         Node* user = n-&gt;fast_out(i);</span>
<span class="udiff-line-added">+         if (user != NULL) {</span>
<span class="udiff-line-added">+           stack.push(user, 0);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return strength;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-added">+   Node* val = in(ValueIn);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const Type* val_t = igvn.type(val);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="udiff-line-added">+       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="udiff-line-added">+     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="udiff-line-added">+     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="udiff-line-added">+     return unc;</span>
    }
<span class="udiff-line-added">+   return NULL;</span>
  }
</pre>
<center><a href="shenandoahBarrierSetC2.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahEvacOOMHandler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  
  ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :
    _heap(heap),
    _mutator_free_bitmap(max_regions, mtGC),
    _collector_free_bitmap(max_regions, mtGC),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,11 ***</span>
        // Try to steal the empty region from the mutator view
        for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
          size_t idx = c - 1;
          if (is_mutator_free(idx)) {
            ShenandoahHeapRegion* r = _heap-&gt;get_region(idx);
<span class="line-modified">!           if (is_empty_or_trash(r)) {</span>
              flip_to_gc(r);
              HeapWord *result = try_allocate_in(r, req, in_new_region);
              if (result != NULL) {
                return result;
              }
<span class="line-new-header">--- 114,11 ---</span>
        // Try to steal the empty region from the mutator view
        for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
          size_t idx = c - 1;
          if (is_mutator_free(idx)) {
            ShenandoahHeapRegion* r = _heap-&gt;get_region(idx);
<span class="line-modified">!           if (can_allocate_from(r)) {</span>
              flip_to_gc(r);
              HeapWord *result = try_allocate_in(r, req, in_new_region);
              if (result != NULL) {
                return result;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,10 ***</span>
<span class="line-new-header">--- 148,15 ---</span>
  }
  
  HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
    assert (!has_no_alloc_capacity(r), &quot;Performance: should avoid full regions on this path: &quot; SIZE_FORMAT, r-&gt;region_number());
  
<span class="line-added">+   if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp;</span>
<span class="line-added">+       r-&gt;is_trash()) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    try_recycle_trashed(r);
  
    in_new_region = r-&gt;is_empty();
  
    HeapWord* result = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,11 ***</span>
        return NULL;
      }
  
      // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
      // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
<span class="line-modified">!     if (!is_mutator_free(end) || !is_empty_or_trash(_heap-&gt;get_region(end))) {</span>
        end++;
        beg = end;
        continue;
      }
  
<span class="line-new-header">--- 278,11 ---</span>
        return NULL;
      }
  
      // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
      // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
<span class="line-modified">!     if (!is_mutator_free(end) || !can_allocate_from(_heap-&gt;get_region(end))) {</span>
        end++;
        beg = end;
        continue;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,12 ***</span>
  
    req.set_actual_size(words_size);
    return _heap-&gt;get_region(beg)-&gt;bottom();
  }
  
<span class="line-modified">! bool ShenandoahFreeSet::is_empty_or_trash(ShenandoahHeapRegion *r) {</span>
<span class="line-modified">!   return r-&gt;is_empty() || r-&gt;is_trash();</span>
  }
  
  size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {
    if (r-&gt;is_trash()) {
      // This would be recycled on allocation path
<span class="line-new-header">--- 341,12 ---</span>
  
    req.set_actual_size(words_size);
    return _heap-&gt;get_region(beg)-&gt;bottom();
  }
  
<span class="line-modified">! bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {</span>
<span class="line-modified">!   return r-&gt;is_empty() || (r-&gt;is_trash() &amp;&amp; !_heap-&gt;is_concurrent_root_in_progress());</span>
  }
  
  size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {
    if (r-&gt;is_trash()) {
      // This would be recycled on allocation path
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,11 ***</span>
  
  void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {
    size_t idx = r-&gt;region_number();
  
    assert(_mutator_free_bitmap.at(idx), &quot;Should be in mutator view&quot;);
<span class="line-modified">!   assert(is_empty_or_trash(r), &quot;Should not be allocated&quot;);</span>
  
    _mutator_free_bitmap.clear_bit(idx);
    _collector_free_bitmap.set_bit(idx);
    _collector_leftmost = MIN2(idx, _collector_leftmost);
    _collector_rightmost = MAX2(idx, _collector_rightmost);
<span class="line-new-header">--- 383,11 ---</span>
  
  void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {
    size_t idx = r-&gt;region_number();
  
    assert(_mutator_free_bitmap.at(idx), &quot;Should be in mutator view&quot;);
<span class="line-modified">!   assert(can_allocate_from(r), &quot;Should not be allocated&quot;);</span>
  
    _mutator_free_bitmap.clear_bit(idx);
    _collector_free_bitmap.set_bit(idx);
    _collector_leftmost = MIN2(idx, _collector_leftmost);
    _collector_rightmost = MAX2(idx, _collector_rightmost);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,18 ***</span>
        _mutator_free_bitmap.set_bit(idx);
      }
    }
  
    // Evac reserve: reserve trailing space for evacuations
<span class="line-modified">!   size_t to_reserve = ShenandoahEvacReserve * _heap-&gt;capacity() / 100;</span>
    size_t reserved = 0;
  
    for (size_t idx = _heap-&gt;num_regions() - 1; idx &gt; 0; idx--) {
      if (reserved &gt;= to_reserve) break;
  
      ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
<span class="line-modified">!     if (_mutator_free_bitmap.at(idx) &amp;&amp; is_empty_or_trash(region)) {</span>
        _mutator_free_bitmap.clear_bit(idx);
        _collector_free_bitmap.set_bit(idx);
        size_t ac = alloc_capacity(region);
        _capacity -= ac;
        reserved += ac;
<span class="line-new-header">--- 435,18 ---</span>
        _mutator_free_bitmap.set_bit(idx);
      }
    }
  
    // Evac reserve: reserve trailing space for evacuations
<span class="line-modified">!   size_t to_reserve = _heap-&gt;max_capacity() / 100 * ShenandoahEvacReserve;</span>
    size_t reserved = 0;
  
    for (size_t idx = _heap-&gt;num_regions() - 1; idx &gt; 0; idx--) {
      if (reserved &gt;= to_reserve) break;
  
      ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
<span class="line-modified">!     if (_mutator_free_bitmap.at(idx) &amp;&amp; can_allocate_from(region)) {</span>
        _mutator_free_bitmap.clear_bit(idx);
        _collector_free_bitmap.set_bit(idx);
        size_t ac = alloc_capacity(region);
        _capacity -= ac;
        reserved += ac;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 489,12 ***</span>
        }
  
        size_t max_humongous = max_contig * ShenandoahHeapRegion::region_size_bytes();
        size_t free = capacity() - used();
  
<span class="line-modified">!       ls.print(&quot;Free: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;K, Max humongous: &quot; SIZE_FORMAT &quot;K, &quot;,</span>
<span class="line-modified">!                total_free / M, mutator_count(), max / K, max_humongous / K);</span>
  
        size_t frag_ext;
        if (free &gt; 0) {
          frag_ext = 100 - (100 * max_humongous / free);
        } else {
<span class="line-new-header">--- 496,16 ---</span>
        }
  
        size_t max_humongous = max_contig * ShenandoahHeapRegion::region_size_bytes();
        size_t free = capacity() - used();
  
<span class="line-modified">!       ls.print(&quot;Free: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;%s, Max humongous: &quot; SIZE_FORMAT &quot;%s, &quot;,</span>
<span class="line-modified">!                byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),</span>
<span class="line-added">+                mutator_count(),</span>
<span class="line-added">+                byte_size_in_proper_unit(max),           proper_unit_for_byte_size(max),</span>
<span class="line-added">+                byte_size_in_proper_unit(max_humongous), proper_unit_for_byte_size(max_humongous)</span>
<span class="line-added">+       );</span>
  
        size_t frag_ext;
        if (free &gt; 0) {
          frag_ext = 100 - (100 * max_humongous / free);
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,12 ***</span>
            max = MAX2(max, free);
            total_free += free;
          }
        }
  
<span class="line-modified">!       ls.print_cr(&quot;Evacuation Reserve: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">!                   total_free / M, collector_count(), max / K);</span>
      }
    }
  }
  
  HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
<span class="line-new-header">--- 534,14 ---</span>
            max = MAX2(max, free);
            total_free += free;
          }
        }
  
<span class="line-modified">!       ls.print_cr(&quot;Evacuation Reserve: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!                   byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),</span>
<span class="line-added">+                   collector_count(),</span>
<span class="line-added">+                   byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));</span>
      }
    }
  }
  
  HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
</pre>
<center><a href="shenandoahEvacOOMHandler.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 26 
 27 #include &quot;gc/shared/barrierSet.hpp&quot;

 28 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified"> 29 #include &quot;gc/shenandoah/shenandoahBrooksPointer.inline.hpp&quot;</span>

 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="line-modified"> 31 </span>
<span class="line-modified"> 32 bool ShenandoahBarrierSet::need_update_refs_barrier() {</span>
<span class="line-modified"> 33   return _heap-&gt;is_update_refs_in_progress() ||</span>
<span class="line-modified"> 34          _heap-&gt;is_concurrent_traversal_in_progress() ||</span>
<span class="line-modified"> 35          (_heap-&gt;is_concurrent_mark_in_progress() &amp;&amp; _heap-&gt;has_forwarded_objects());</span>
<span class="line-removed"> 36 }</span>
 37 
 38 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
<span class="line-modified"> 39   return ShenandoahBrooksPointer::forwardee(p);</span>
 40 }
 41 
 42 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
<span class="line-modified"> 43   if (((HeapWord*) p) != NULL) {</span>
 44     return resolve_forwarded_not_null(p);
 45   } else {
 46     return p;
 47   }
 48 }
 49 
<span class="line-modified"> 50 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified"> 51 template &lt;typename T&gt;</span>
<span class="line-modified"> 52 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified"> 53   oop res;</span>
<span class="line-modified"> 54   oop expected = compare_value;</span>
<span class="line-modified"> 55   do {</span>
<span class="line-modified"> 56     compare_value = expected;</span>
<span class="line-modified"> 57     res = Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
<span class="line-modified"> 58     expected = res;</span>
<span class="line-modified"> 59   } while ((! oopDesc::equals_raw(compare_value, expected)) &amp;&amp; oopDesc::equals_raw(resolve_forwarded(compare_value), resolve_forwarded(expected)));</span>
<span class="line-modified"> 60   if (oopDesc::equals_raw(expected, compare_value)) {</span>
<span class="line-modified"> 61     if (ShenandoahSATBBarrier &amp;&amp; !CompressedOops::is_null(compare_value)) {</span>
<span class="line-modified"> 62       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(compare_value);</span>









 63     }
 64   }
<span class="line-modified"> 65   return res;</span>





































 66 }
 67 
 68 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 69 template &lt;typename T&gt;
<span class="line-modified"> 70 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified"> 71   oop previous = Raw::oop_atomic_xchg(new_value, addr);</span>
<span class="line-modified"> 72   if (ShenandoahSATBBarrier) {</span>
<span class="line-modified"> 73     if (!CompressedOops::is_null(previous)) {</span>
<span class="line-modified"> 74       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(previous);</span>


 75     }
 76   }
<span class="line-modified"> 77   return previous;</span>
 78 }
 79 
 80 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 81 template &lt;typename T&gt;
<span class="line-modified"> 82 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="line-modified"> 83                                                                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,</span>
<span class="line-modified"> 84                                                                                      size_t length) {</span>
<span class="line-modified"> 85   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="line-modified"> 86     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>

 87   }
<span class="line-modified"> 88   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="line-modified"> 89     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>









 90   }
<span class="line-modified"> 91   Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
 92 }
 93 

 94 template &lt;typename T&gt;
<span class="line-modified"> 95 bool ShenandoahBarrierSet::arraycopy_loop_1(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="line-modified"> 96                                             bool checkcast, bool satb, bool disjoint,</span>
<span class="line-modified"> 97                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-modified"> 98   if (checkcast) {</span>
<span class="line-modified"> 99     return arraycopy_loop_2&lt;T, true&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="line-modified">100   } else {</span>
<span class="line-removed">101     return arraycopy_loop_2&lt;T, false&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="line-removed">102   }</span>
103 }
104 
<span class="line-modified">105 template &lt;typename T, bool CHECKCAST&gt;</span>
<span class="line-modified">106 bool ShenandoahBarrierSet::arraycopy_loop_2(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="line-modified">107                                             bool satb, bool disjoint,</span>
<span class="line-modified">108                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-modified">109   if (satb) {</span>
<span class="line-modified">110     return arraycopy_loop_3&lt;T, CHECKCAST, true&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="line-modified">111   } else {</span>
<span class="line-modified">112     return arraycopy_loop_3&lt;T, CHECKCAST, false&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="line-removed">113   }</span>
114 }
115 
<span class="line-modified">116 template &lt;typename T, bool CHECKCAST, bool SATB&gt;</span>
<span class="line-modified">117 bool ShenandoahBarrierSet::arraycopy_loop_3(T* src, T* dst, size_t length, Klass* bound, bool disjoint,</span>
<span class="line-modified">118                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="line-removed">119   switch (storeval_mode) {</span>
<span class="line-removed">120     case NONE:</span>
<span class="line-removed">121       return arraycopy_loop&lt;T, CHECKCAST, SATB, NONE&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">122     case READ_BARRIER:</span>
<span class="line-removed">123       return arraycopy_loop&lt;T, CHECKCAST, SATB, READ_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">124     case WRITE_BARRIER:</span>
<span class="line-removed">125       return arraycopy_loop&lt;T, CHECKCAST, SATB, WRITE_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="line-removed">126     default:</span>
<span class="line-removed">127       ShouldNotReachHere();</span>
<span class="line-removed">128       return true; // happy compiler</span>
<span class="line-removed">129   }</span>
130 }
131 
<span class="line-modified">132 template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="line-modified">133 bool ShenandoahBarrierSet::arraycopy_loop(T* src, T* dst, size_t length, Klass* bound, bool disjoint) {</span>
<span class="line-modified">134   Thread* thread = Thread::current();</span>


135 
<span class="line-modified">136   ShenandoahEvacOOMScope oom_evac_scope;</span>
<span class="line-modified">137 </span>
<span class="line-modified">138   // We need to handle four cases:</span>
<span class="line-modified">139   //</span>
<span class="line-modified">140   // a) src &lt; dst, conjoint, can only copy backward only</span>
<span class="line-modified">141   //   [...src...]</span>
<span class="line-modified">142   //         [...dst...]</span>
<span class="line-modified">143   //</span>
<span class="line-modified">144   // b) src &lt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="line-modified">145   //   [...src...]</span>
<span class="line-modified">146   //              [...dst...]</span>
<span class="line-modified">147   //</span>
<span class="line-modified">148   // c) src &gt; dst, conjoint, can copy forward only</span>
<span class="line-removed">149   //         [...src...]</span>
<span class="line-removed">150   //   [...dst...]</span>
<span class="line-removed">151   //</span>
<span class="line-removed">152   // d) src &gt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="line-removed">153   //              [...src...]</span>
<span class="line-removed">154   //   [...dst...]</span>
<span class="line-removed">155   //</span>
<span class="line-removed">156   if (src &gt; dst || disjoint) {</span>
<span class="line-removed">157     // copy forward:</span>
<span class="line-removed">158     T* cur_src = src;</span>
<span class="line-removed">159     T* cur_dst = dst;</span>
<span class="line-removed">160     T* src_end = src + length;</span>
<span class="line-removed">161     for (; cur_src &lt; src_end; cur_src++, cur_dst++) {</span>
<span class="line-removed">162       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="line-removed">163         return false;</span>
<span class="line-removed">164       }</span>
<span class="line-removed">165     }</span>
<span class="line-removed">166   } else {</span>
<span class="line-removed">167     // copy backward:</span>
<span class="line-removed">168     T* cur_src = src + length - 1;</span>
<span class="line-removed">169     T* cur_dst = dst + length - 1;</span>
<span class="line-removed">170     for (; cur_src &gt;= src; cur_src--, cur_dst--) {</span>
<span class="line-removed">171       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="line-removed">172         return false;</span>
<span class="line-removed">173       }</span>
<span class="line-removed">174     }</span>
175   }
<span class="line-modified">176   return true;</span>
177 }
178 
<span class="line-modified">179 template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="line-modified">180 bool ShenandoahBarrierSet::arraycopy_element(T* cur_src, T* cur_dst, Klass* bound, Thread* thread) {</span>
<span class="line-modified">181   T o = RawAccess&lt;&gt;::oop_load(cur_src);</span>
<span class="line-modified">182 </span>
<span class="line-modified">183   if (SATB) {</span>
<span class="line-removed">184     T prev = RawAccess&lt;&gt;::oop_load(cur_dst);</span>
<span class="line-removed">185     if (!CompressedOops::is_null(prev)) {</span>
<span class="line-removed">186       oop prev_obj = CompressedOops::decode_not_null(prev);</span>
<span class="line-removed">187       enqueue(prev_obj);</span>
<span class="line-removed">188     }</span>
<span class="line-removed">189   }</span>
190 
<span class="line-modified">191   if (!CompressedOops::is_null(o)) {</span>
<span class="line-modified">192     oop obj = CompressedOops::decode_not_null(o);</span>


193 
<span class="line-modified">194     if (CHECKCAST) {</span>
<span class="line-modified">195       assert(bound != NULL, &quot;need element klass for checkcast&quot;);</span>
<span class="line-modified">196       if (!oopDesc::is_instanceof_or_null(obj, bound)) {</span>
<span class="line-modified">197         return false;</span>
<span class="line-modified">198       }</span>
<span class="line-removed">199     }</span>
200 
<span class="line-modified">201     switch (STOREVAL_MODE) {</span>
<span class="line-removed">202     case NONE:</span>
<span class="line-removed">203       break;</span>
<span class="line-removed">204     case READ_BARRIER:</span>
<span class="line-removed">205       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">206       break;</span>
<span class="line-removed">207     case WRITE_BARRIER:</span>
<span class="line-removed">208       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="line-removed">209         oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">210         if (oopDesc::equals_raw(forw, obj)) {</span>
<span class="line-removed">211           forw = _heap-&gt;evacuate_object(forw, thread);</span>
<span class="line-removed">212         }</span>
<span class="line-removed">213         obj = forw;</span>
<span class="line-removed">214       }</span>
<span class="line-removed">215       enqueue(obj);</span>
<span class="line-removed">216       break;</span>
<span class="line-removed">217     default:</span>
<span class="line-removed">218       ShouldNotReachHere();</span>
<span class="line-removed">219     }</span>
220 
<span class="line-modified">221     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(cur_dst, obj);</span>
<span class="line-modified">222   } else {</span>
<span class="line-modified">223     // Store null.</span>
<span class="line-modified">224     RawAccess&lt;&gt;::oop_store(cur_dst, o);</span>

225   }
<span class="line-modified">226   return true;</span>











227 }
228 
229 // Clone barrier support
230 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
231 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
<span class="line-modified">232   src = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src));</span>
<span class="line-modified">233   dst = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst));</span>

234   Raw::clone(src, dst, size);
<span class="line-removed">235   ShenandoahBarrierSet::barrier_set()-&gt;write_region(MemRegion((HeapWord*) dst, size));</span>
236 }
237 
238 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
239 template &lt;typename T&gt;
240 bool ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
241                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
242                                                                                          size_t length) {
<span class="line-modified">243   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-modified">244   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="line-modified">245     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>
<span class="line-modified">246   }</span>
<span class="line-modified">247   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="line-modified">248     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>


























249   }

250 
<span class="line-modified">251   bool satb = ShenandoahSATBBarrier &amp;&amp; heap-&gt;is_concurrent_mark_in_progress();</span>
<span class="line-modified">252   bool checkcast = HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value;</span>
<span class="line-modified">253   bool disjoint = HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value;</span>
<span class="line-modified">254   ArrayCopyStoreValMode storeval_mode;</span>
<span class="line-modified">255   if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-removed">256     if (heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-removed">257       storeval_mode = WRITE_BARRIER;</span>
<span class="line-removed">258     } else if (heap-&gt;is_concurrent_mark_in_progress() || heap-&gt;is_update_refs_in_progress()) {</span>
<span class="line-removed">259       storeval_mode = READ_BARRIER;</span>
260     } else {
<span class="line-modified">261       assert(heap-&gt;is_idle() || heap-&gt;is_evacuation_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="line-removed">262       storeval_mode = NONE; // E.g. during evac or outside cycle</span>
263     }
<span class="line-removed">264   } else {</span>
<span class="line-removed">265     assert(heap-&gt;is_stable() || heap-&gt;is_concurrent_mark_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="line-removed">266     storeval_mode = NONE;</span>
267   }
268 
<span class="line-modified">269   if (!satb &amp;&amp; !checkcast &amp;&amp; storeval_mode == NONE) {</span>
<span class="line-modified">270     // Short-circuit to bulk copy.</span>
<span class="line-modified">271     return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>


















272   }

273 
<span class="line-modified">274   src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);</span>
<span class="line-modified">275   dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);</span>

276 
<span class="line-modified">277   Klass* bound = objArrayOop(dst_obj)-&gt;element_klass();</span>
<span class="line-modified">278   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-removed">279   return bs-&gt;arraycopy_loop_1(src_raw, dst_raw, length, bound, checkcast, satb, disjoint, storeval_mode);</span>
280 }
281 
282 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 27 
 28 #include &quot;gc/shared/barrierSet.hpp&quot;
<span class="line-added"> 29 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;</span>
 30 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="line-modified"> 34 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;</span>
<span class="line-modified"> 35 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;</span>
<span class="line-modified"> 37 #include &quot;memory/iterator.inline.hpp&quot;</span>
<span class="line-modified"> 38 #include &quot;oops/oop.inline.hpp&quot;</span>

 39 
 40 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
<span class="line-modified"> 41   return ShenandoahForwarding::get_forwardee(p);</span>
 42 }
 43 
 44 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
<span class="line-modified"> 45   if (p != NULL) {</span>
 46     return resolve_forwarded_not_null(p);
 47   } else {
 48     return p;
 49   }
 50 }
 51 
<span class="line-modified"> 52 inline void ShenandoahBarrierSet::enqueue(oop obj) {</span>
<span class="line-modified"> 53   shenandoah_assert_not_forwarded_if(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress());</span>
<span class="line-modified"> 54   assert(_satb_mark_queue_set.is_active(), &quot;only get here when SATB active&quot;);</span>
<span class="line-modified"> 55 </span>
<span class="line-modified"> 56   // Filter marked objects before hitting the SATB queues. The same predicate would</span>
<span class="line-modified"> 57   // be used by SATBMQ::filter to eliminate already marked objects downstream, but</span>
<span class="line-modified"> 58   // filtering here helps to avoid wasteful SATB queueing work to begin with.</span>
<span class="line-modified"> 59   if (!_heap-&gt;requires_marking&lt;false&gt;(obj)) return;</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61   ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);</span>
<span class="line-modified"> 62 }</span>
<span class="line-modified"> 63 </span>
<span class="line-modified"> 64 template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-added"> 65 inline void ShenandoahBarrierSet::satb_barrier(T *field) {</span>
<span class="line-added"> 66   if (HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value ||</span>
<span class="line-added"> 67       HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="line-added"> 68     return;</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 71     T heap_oop = RawAccess&lt;&gt;::oop_load(field);</span>
<span class="line-added"> 72     if (!CompressedOops::is_null(heap_oop)) {</span>
<span class="line-added"> 73       enqueue(CompressedOops::decode(heap_oop));</span>
 74     }
 75   }
<span class="line-modified"> 76 }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 inline void ShenandoahBarrierSet::satb_enqueue(oop value) {</span>
<span class="line-added"> 79   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="line-added"> 80   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 81     enqueue(value);</span>
<span class="line-added"> 82   }</span>
<span class="line-added"> 83 }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85 inline void ShenandoahBarrierSet::storeval_barrier(oop obj) {</span>
<span class="line-added"> 86   if (obj != NULL &amp;&amp; ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-added"> 87     enqueue(obj);</span>
<span class="line-added"> 88   }</span>
<span class="line-added"> 89 }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91 inline void ShenandoahBarrierSet::keep_alive_barrier(oop value) {</span>
<span class="line-added"> 92   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="line-added"> 93   if (ShenandoahKeepAliveBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 94     enqueue(value);</span>
<span class="line-added"> 95   }</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 inline void ShenandoahBarrierSet::keep_alive_if_weak(DecoratorSet decorators, oop value) {</span>
<span class="line-added"> 99   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="line-added">100   const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;</span>
<span class="line-added">101   const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;</span>
<span class="line-added">102   if (!peek &amp;&amp; !on_strong_oop_ref) {</span>
<span class="line-added">103     keep_alive_barrier(value);</span>
<span class="line-added">104   }</span>
<span class="line-added">105 }</span>
<span class="line-added">106 </span>
<span class="line-added">107 template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added">108 inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {</span>
<span class="line-added">109   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="line-added">110   if (!HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value &amp;&amp;</span>
<span class="line-added">111       !HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="line-added">112     keep_alive_barrier(value);</span>
<span class="line-added">113   }</span>
114 }
115 
116 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
117 template &lt;typename T&gt;
<span class="line-modified">118 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {</span>
<span class="line-modified">119   oop value = Raw::oop_load_not_in_heap(addr);</span>
<span class="line-modified">120   if (value != NULL) {</span>
<span class="line-modified">121     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">122     value = bs-&gt;load_reference_barrier_native(value, addr);</span>
<span class="line-added">123     if (value != NULL) {</span>
<span class="line-added">124       bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
125     }
126   }
<span class="line-modified">127   return value;</span>
128 }
129 
130 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
131 template &lt;typename T&gt;
<span class="line-modified">132 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {</span>
<span class="line-modified">133   oop value = Raw::oop_load_in_heap(addr);</span>
<span class="line-modified">134   if (value != NULL) {</span>
<span class="line-modified">135     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">136     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="line-added">137     bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
138   }
<span class="line-modified">139   return value;</span>
<span class="line-modified">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">143 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap_at(oop base, ptrdiff_t offset) {</span>
<span class="line-added">144   oop value = Raw::oop_load_in_heap_at(base, offset);</span>
<span class="line-added">145   if (value != NULL) {</span>
<span class="line-added">146     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-added">147     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="line-added">148     bs-&gt;keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset),</span>
<span class="line-added">149                            value);</span>
150   }
<span class="line-modified">151   return value;</span>
152 }
153 
<span class="line-added">154 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
155 template &lt;typename T&gt;
<span class="line-modified">156 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_not_in_heap(T* addr, oop value) {</span>
<span class="line-modified">157   shenandoah_assert_marked_if(NULL, value, !CompressedOops::is_null(value) &amp;&amp; ShenandoahHeap::heap()-&gt;is_evacuation_in_progress());</span>
<span class="line-modified">158   ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">159   bs-&gt;storeval_barrier(value);</span>
<span class="line-modified">160   bs-&gt;satb_barrier&lt;decorators&gt;(addr);</span>
<span class="line-modified">161   Raw::oop_store(addr, value);</span>


162 }
163 
<span class="line-modified">164 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">165 template &lt;typename T&gt;</span>
<span class="line-modified">166 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap(T* addr, oop value) {</span>
<span class="line-modified">167   shenandoah_assert_not_in_cset_loc_except(addr, ShenandoahHeap::heap()-&gt;cancelled_gc());</span>
<span class="line-modified">168   shenandoah_assert_not_forwarded_except  (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="line-modified">169   shenandoah_assert_not_in_cset_except    (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="line-modified">170 </span>
<span class="line-modified">171   oop_store_not_in_heap(addr, value);</span>

172 }
173 
<span class="line-modified">174 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">175 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {</span>
<span class="line-modified">176   oop_store_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), value);</span>











177 }
178 
<span class="line-modified">179 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">180 template &lt;typename T&gt;</span>
<span class="line-modified">181 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-added">182   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-added">183   bs-&gt;storeval_barrier(new_value);</span>
184 
<span class="line-modified">185   oop res;</span>
<span class="line-modified">186   oop expected = compare_value;</span>
<span class="line-modified">187   do {</span>
<span class="line-modified">188     compare_value = expected;</span>
<span class="line-modified">189     res = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
<span class="line-modified">190     expected = res;</span>
<span class="line-modified">191   } while ((compare_value != expected) &amp;&amp; (resolve_forwarded(compare_value) == resolve_forwarded(expected)));</span>
<span class="line-modified">192 </span>
<span class="line-modified">193   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="line-modified">194   // because it must be the previous value.</span>
<span class="line-modified">195   if (res != NULL) {</span>
<span class="line-modified">196     res = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(res);</span>
<span class="line-modified">197     bs-&gt;satb_enqueue(res);</span>


























198   }
<span class="line-modified">199   return res;</span>
200 }
201 
<span class="line-modified">202 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">203 template &lt;typename T&gt;</span>
<span class="line-modified">204 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-modified">205   return oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);</span>
<span class="line-modified">206 }</span>






207 
<span class="line-modified">208 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">209 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
<span class="line-added">210   return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), compare_value, new_value);</span>
<span class="line-added">211 }</span>
212 
<span class="line-modified">213 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">214 template &lt;typename T&gt;</span>
<span class="line-modified">215 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
<span class="line-modified">216   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">217   bs-&gt;storeval_barrier(new_value);</span>

218 
<span class="line-modified">219   oop previous = Raw::oop_atomic_xchg(addr, new_value);</span>


















220 
<span class="line-modified">221   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="line-modified">222   // because it must be the previous value.</span>
<span class="line-modified">223   if (previous != NULL) {</span>
<span class="line-modified">224     previous = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(previous);</span>
<span class="line-added">225     bs-&gt;satb_enqueue(previous);</span>
226   }
<span class="line-modified">227   return previous;</span>
<span class="line-added">228 }</span>
<span class="line-added">229 </span>
<span class="line-added">230 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">231 template &lt;typename T&gt;</span>
<span class="line-added">232 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
<span class="line-added">233   return oop_atomic_xchg_not_in_heap(addr, new_value);</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
<span class="line-added">236 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">237 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
<span class="line-added">238   return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), new_value);</span>
239 }
240 
241 // Clone barrier support
242 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
243 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
<span class="line-modified">244   if (ShenandoahCloneBarrier) {</span>
<span class="line-modified">245     ShenandoahBarrierSet::barrier_set()-&gt;clone_barrier_runtime(src);</span>
<span class="line-added">246   }</span>
247   Raw::clone(src, dst, size);

248 }
249 
250 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
251 template &lt;typename T&gt;
252 bool ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
253                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
254                                                                                          size_t length) {
<span class="line-modified">255   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">256   bs-&gt;arraycopy_pre(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),</span>
<span class="line-modified">257                     arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),</span>
<span class="line-modified">258                     length);</span>
<span class="line-modified">259   return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
<span class="line-modified">260 }</span>
<span class="line-added">261 </span>
<span class="line-added">262 template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;</span>
<span class="line-added">263 void ShenandoahBarrierSet::arraycopy_work(T* src, size_t count) {</span>
<span class="line-added">264   Thread* thread = Thread::current();</span>
<span class="line-added">265   SATBMarkQueue&amp; queue = ShenandoahThreadLocalData::satb_mark_queue(thread);</span>
<span class="line-added">266   ShenandoahMarkingContext* ctx = _heap-&gt;marking_context();</span>
<span class="line-added">267   const ShenandoahCollectionSet* const cset = _heap-&gt;collection_set();</span>
<span class="line-added">268   T* end = src + count;</span>
<span class="line-added">269   for (T* elem_ptr = src; elem_ptr &lt; end; elem_ptr++) {</span>
<span class="line-added">270     T o = RawAccess&lt;&gt;::oop_load(elem_ptr);</span>
<span class="line-added">271     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">272       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">273       if (HAS_FWD &amp;&amp; cset-&gt;is_in(obj)) {</span>
<span class="line-added">274         assert(_heap-&gt;has_forwarded_objects(), &quot;only get here with forwarded objects&quot;);</span>
<span class="line-added">275         oop fwd = resolve_forwarded_not_null(obj);</span>
<span class="line-added">276         if (EVAC &amp;&amp; obj == fwd) {</span>
<span class="line-added">277           fwd = _heap-&gt;evacuate_object(obj, thread);</span>
<span class="line-added">278         }</span>
<span class="line-added">279         assert(obj != fwd || _heap-&gt;cancelled_gc(), &quot;must be forwarded&quot;);</span>
<span class="line-added">280         oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);</span>
<span class="line-added">281         obj = fwd;</span>
<span class="line-added">282       }</span>
<span class="line-added">283       if (ENQUEUE &amp;&amp; !ctx-&gt;is_marked(obj)) {</span>
<span class="line-added">284         queue.enqueue_known_active(obj);</span>
<span class="line-added">285       }</span>
<span class="line-added">286     }</span>
287   }
<span class="line-added">288 }</span>
289 
<span class="line-modified">290 template &lt;class T&gt;</span>
<span class="line-modified">291 void ShenandoahBarrierSet::arraycopy_pre_work(T* src, T* dst, size_t count) {</span>
<span class="line-modified">292   if (_heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-modified">293     if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">294       arraycopy_work&lt;T, true, false, true&gt;(dst, count);</span>




295     } else {
<span class="line-modified">296       arraycopy_work&lt;T, false, false, true&gt;(dst, count);</span>

297     }



298   }
299 
<span class="line-modified">300   arraycopy_update_impl(src, count);</span>
<span class="line-modified">301 }</span>
<span class="line-modified">302 </span>
<span class="line-added">303 void ShenandoahBarrierSet::arraycopy_pre(oop* src, oop* dst, size_t count) {</span>
<span class="line-added">304   arraycopy_pre_work(src, dst, count);</span>
<span class="line-added">305 }</span>
<span class="line-added">306 </span>
<span class="line-added">307 void ShenandoahBarrierSet::arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count) {</span>
<span class="line-added">308   arraycopy_pre_work(src, dst, count);</span>
<span class="line-added">309 }</span>
<span class="line-added">310 </span>
<span class="line-added">311 template &lt;class T&gt;</span>
<span class="line-added">312 void ShenandoahBarrierSet::arraycopy_update_impl(T* src, size_t count) {</span>
<span class="line-added">313   if (_heap-&gt;is_evacuation_in_progress()) {</span>
<span class="line-added">314     ShenandoahEvacOOMScope oom_evac;</span>
<span class="line-added">315     arraycopy_work&lt;T, true, true, false&gt;(src, count);</span>
<span class="line-added">316   } else if (_heap-&gt;is_concurrent_traversal_in_progress()){</span>
<span class="line-added">317     ShenandoahEvacOOMScope oom_evac;</span>
<span class="line-added">318     arraycopy_work&lt;T, true, true, true&gt;(src, count);</span>
<span class="line-added">319   } else if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added">320     arraycopy_work&lt;T, true, false, false&gt;(src, count);</span>
321   }
<span class="line-added">322 }</span>
323 
<span class="line-modified">324 void ShenandoahBarrierSet::arraycopy_update(oop* src, size_t count) {</span>
<span class="line-modified">325   arraycopy_update_impl(src, count);</span>
<span class="line-added">326 }</span>
327 
<span class="line-modified">328 void ShenandoahBarrierSet::arraycopy_update(narrowOop* src, size_t count) {</span>
<span class="line-modified">329   arraycopy_update_impl(src, count);</span>

330 }
331 
332 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;gc/shared/gcCause.hpp&quot;
<a name="2" id="anc2"></a>
 28 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logTag.hpp&quot;
 36 
 37 int ShenandoahHeuristics::compare_by_garbage(RegionData a, RegionData b) {
 38   if (a._garbage &gt; b._garbage)
 39     return -1;
 40   else if (a._garbage &lt; b._garbage)
 41     return 1;
 42   else return 0;
 43 }
 44 
 45 int ShenandoahHeuristics::compare_by_garbage_then_alloc_seq_ascending(RegionData a, RegionData b) {
 46   int r = compare_by_garbage(a, b);
 47   if (r != 0) {
 48     return r;
 49   }
 50   return compare_by_alloc_seq_ascending(a, b);
 51 }
 52 
 53 int ShenandoahHeuristics::compare_by_alloc_seq_ascending(RegionData a, RegionData b) {
 54   if (a._seqnum_last_alloc == b._seqnum_last_alloc)
 55     return 0;
 56   else if (a._seqnum_last_alloc &lt; b._seqnum_last_alloc)
 57     return -1;
 58   else return 1;
 59 }
 60 
 61 int ShenandoahHeuristics::compare_by_alloc_seq_descending(RegionData a, RegionData b) {
 62   return -compare_by_alloc_seq_ascending(a, b);
 63 }
 64 
 65 ShenandoahHeuristics::ShenandoahHeuristics() :
 66   _update_refs_early(false),
 67   _update_refs_adaptive(false),
 68   _region_data(NULL),
 69   _region_data_size(0),
 70   _degenerated_cycles_in_a_row(0),
 71   _successful_cycles_in_a_row(0),
 72   _bytes_in_cset(0),
 73   _cycle_start(os::elapsedTime()),
 74   _last_cycle_end(0),
 75   _gc_times_learned(0),
 76   _gc_time_penalties(0),
 77   _gc_time_history(new TruncatedSeq(5)),
 78   _metaspace_oom()
 79 {
 80   if (strcmp(ShenandoahUpdateRefsEarly, &quot;on&quot;) == 0 ||
 81       strcmp(ShenandoahUpdateRefsEarly, &quot;true&quot;) == 0 ) {
 82     _update_refs_early = true;
 83   } else if (strcmp(ShenandoahUpdateRefsEarly, &quot;off&quot;) == 0 ||
 84              strcmp(ShenandoahUpdateRefsEarly, &quot;false&quot;) == 0 ) {
 85     _update_refs_early = false;
 86   } else if (strcmp(ShenandoahUpdateRefsEarly, &quot;adaptive&quot;) == 0) {
 87     _update_refs_adaptive = true;
 88     _update_refs_early = true;
 89   } else {
 90     vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahUpdateRefsEarly option: %s&quot;, ShenandoahUpdateRefsEarly);
 91   }
 92 
 93   // No unloading during concurrent mark? Communicate that to heuristics
 94   if (!ClassUnloadingWithConcurrentMark) {
 95     FLAG_SET_DEFAULT(ShenandoahUnloadClassesFrequency, 0);
 96   }
 97 }
 98 
 99 ShenandoahHeuristics::~ShenandoahHeuristics() {
100   if (_region_data != NULL) {
101     FREE_C_HEAP_ARRAY(RegionGarbage, _region_data);
102   }
103 }
104 
105 ShenandoahHeuristics::RegionData* ShenandoahHeuristics::get_region_data_cache(size_t num) {
106   RegionData* res = _region_data;
107   if (res == NULL) {
108     res = NEW_C_HEAP_ARRAY(RegionData, num, mtGC);
109     _region_data = res;
110     _region_data_size = num;
111   } else if (_region_data_size &lt; num) {
112     res = REALLOC_C_HEAP_ARRAY(RegionData, _region_data, num, mtGC);
113     _region_data = res;
114     _region_data_size = num;
115   }
116   return res;
117 }
118 
119 void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
120   assert(collection_set-&gt;count() == 0, &quot;Must be empty&quot;);
121 
122   ShenandoahHeap* heap = ShenandoahHeap::heap();
123 
<a name="3" id="anc3"></a><span class="line-added">124   // Check all pinned regions have updated status before choosing the collection set.</span>
<span class="line-added">125   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">126 </span>
127   // Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.
128 
129   size_t num_regions = heap-&gt;num_regions();
130 
131   RegionData* candidates = get_region_data_cache(num_regions);
132 
133   size_t cand_idx = 0;
134 
135   size_t total_garbage = 0;
136 
137   size_t immediate_garbage = 0;
138   size_t immediate_regions = 0;
139 
140   size_t free = 0;
141   size_t free_regions = 0;
142 
143   ShenandoahMarkingContext* const ctx = heap-&gt;complete_marking_context();
144 
145   for (size_t i = 0; i &lt; num_regions; i++) {
146     ShenandoahHeapRegion* region = heap-&gt;get_region(i);
147 
148     size_t garbage = region-&gt;garbage();
149     total_garbage += garbage;
150 
151     if (region-&gt;is_empty()) {
152       free_regions++;
153       free += ShenandoahHeapRegion::region_size_bytes();
154     } else if (region-&gt;is_regular()) {
155       if (!region-&gt;has_live()) {
156         // We can recycle it right away and put it in the free set.
157         immediate_regions++;
158         immediate_garbage += garbage;
159         region-&gt;make_trash_immediate();
160       } else {
161         // This is our candidate for later consideration.
162         candidates[cand_idx]._region = region;
163         candidates[cand_idx]._garbage = garbage;
164         cand_idx++;
165       }
166     } else if (region-&gt;is_humongous_start()) {
167       // Reclaim humongous regions here, and count them as the immediate garbage
168 #ifdef ASSERT
169       bool reg_live = region-&gt;has_live();
<a name="4" id="anc4"></a><span class="line-modified">170       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom()));</span>
171       assert(reg_live == bm_live,
172              &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
173              BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
174 #endif
175       if (!region-&gt;has_live()) {
176         heap-&gt;trash_humongous_region_at(region);
177 
178         // Count only the start. Continuations would be counted on &quot;trash&quot; path
179         immediate_regions++;
180         immediate_garbage += garbage;
181       }
182     } else if (region-&gt;is_trash()) {
183       // Count in just trashed collection set, during coalesced CM-with-UR
184       immediate_regions++;
185       immediate_garbage += garbage;
186     }
187   }
188 
189   // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
190   // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
191 
192   assert (immediate_garbage &lt;= total_garbage,
<a name="5" id="anc5"></a><span class="line-modified">193           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;%s vs &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">194           byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">195           byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));</span>
196 
197   size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
198 
199   if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
200     choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
201     collection_set-&gt;update_region_status();
202 
203     size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<a name="6" id="anc6"></a><span class="line-modified">204     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;%s CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">205                        byte_size_in_proper_unit(collection_set-&gt;garbage()),   proper_unit_for_byte_size(collection_set-&gt;garbage()),</span>
<span class="line-added">206                        cset_percent,</span>
<span class="line-added">207                        byte_size_in_proper_unit(collection_set-&gt;live_data()), proper_unit_for_byte_size(collection_set-&gt;live_data()),</span>
<span class="line-added">208                        collection_set-&gt;count());</span>
209   }
210 
<a name="7" id="anc7"></a><span class="line-modified">211   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">212                      byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">213                      immediate_percent, immediate_regions);</span>
214 }
215 
216 void ShenandoahHeuristics::record_gc_start() {
217   // Do nothing
218 }
219 
220 void ShenandoahHeuristics::record_gc_end() {
221   // Do nothing
222 }
223 
224 void ShenandoahHeuristics::record_cycle_start() {
225   _cycle_start = os::elapsedTime();
226 }
227 
228 void ShenandoahHeuristics::record_cycle_end() {
229   _last_cycle_end = os::elapsedTime();
230 }
231 
232 void ShenandoahHeuristics::record_phase_time(ShenandoahPhaseTimings::Phase phase, double secs) {
233   // Do nothing
234 }
235 
236 bool ShenandoahHeuristics::should_start_update_refs() {
237   return _update_refs_early;
238 }
239 
<a name="8" id="anc8"></a><span class="line-modified">240 bool ShenandoahHeuristics::should_start_gc() const {</span>
241   // Perform GC to cleanup metaspace
242   if (has_metaspace_oom()) {
243     // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
244     log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
245     return true;
246   }
247 
<a name="9" id="anc9"></a><span class="line-modified">248   if (ShenandoahGuaranteedGCInterval &gt; 0) {</span>
<span class="line-modified">249     double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">250     if (last_time_ms &gt; ShenandoahGuaranteedGCInterval) {</span>
<span class="line-modified">251       log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">252                    last_time_ms, ShenandoahGuaranteedGCInterval);</span>
<span class="line-added">253       return true;</span>
<span class="line-added">254     }</span>
255   }
<a name="10" id="anc10"></a>





256 
<a name="11" id="anc11"></a>
257   return false;
258 }
259 
260 bool ShenandoahHeuristics::should_degenerate_cycle() {
261   return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
262 }
263 
264 void ShenandoahHeuristics::record_success_concurrent() {
265   _degenerated_cycles_in_a_row = 0;
266   _successful_cycles_in_a_row++;
267 
268   _gc_time_history-&gt;add(time_since_last_gc());
269   _gc_times_learned++;
270   _gc_time_penalties -= MIN2&lt;size_t&gt;(_gc_time_penalties, Concurrent_Adjust);
271 }
272 
273 void ShenandoahHeuristics::record_success_degenerated() {
274   _degenerated_cycles_in_a_row++;
275   _successful_cycles_in_a_row = 0;
276   _gc_time_penalties += Degenerated_Penalty;
277 }
278 
279 void ShenandoahHeuristics::record_success_full() {
280   _degenerated_cycles_in_a_row = 0;
281   _successful_cycles_in_a_row++;
282   _gc_time_penalties += Full_Penalty;
283 }
284 
285 void ShenandoahHeuristics::record_allocation_failure_gc() {
286   _bytes_in_cset = 0;
287 }
288 
289 void ShenandoahHeuristics::record_requested_gc() {
290   _bytes_in_cset = 0;
291 
292   // Assume users call System.gc() when external state changes significantly,
293   // which forces us to re-learn the GC timings and allocation rates.
294   _gc_times_learned = 0;
295 }
296 
297 bool ShenandoahHeuristics::can_process_references() {
298   if (ShenandoahRefProcFrequency == 0) return false;
299   return true;
300 }
301 
302 bool ShenandoahHeuristics::should_process_references() {
303   if (!can_process_references()) return false;
304   size_t cycle = ShenandoahHeap::heap()-&gt;shenandoah_policy()-&gt;cycle_counter();
305   // Process references every Nth GC cycle.
306   return cycle % ShenandoahRefProcFrequency == 0;
307 }
308 
309 bool ShenandoahHeuristics::can_unload_classes() {
310   if (!ClassUnloading) return false;
311   return true;
312 }
313 
314 bool ShenandoahHeuristics::can_unload_classes_normal() {
315   if (!can_unload_classes()) return false;
316   if (has_metaspace_oom()) return true;
317   if (!ClassUnloadingWithConcurrentMark) return false;
318   if (ShenandoahUnloadClassesFrequency == 0) return false;
319   return true;
320 }
321 
322 bool ShenandoahHeuristics::should_unload_classes() {
323   if (!can_unload_classes_normal()) return false;
324   if (has_metaspace_oom()) return true;
325   size_t cycle = ShenandoahHeap::heap()-&gt;shenandoah_policy()-&gt;cycle_counter();
326   // Unload classes every Nth GC cycle.
327   // This should not happen in the same cycle as process_references to amortize costs.
328   // Offsetting by one is enough to break the rendezvous when periods are equal.
329   // When periods are not equal, offsetting by one is just as good as any other guess.
330   return (cycle + 1) % ShenandoahUnloadClassesFrequency == 0;
331 }
332 
333 void ShenandoahHeuristics::initialize() {
334   // Nothing to do by default.
335 }
336 
337 double ShenandoahHeuristics::time_since_last_gc() const {
338   return os::elapsedTime() - _cycle_start;
339 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
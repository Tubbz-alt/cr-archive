<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shared/gcCause.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 28 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logTag.hpp&quot;
 36 
 37 int ShenandoahHeuristics::compare_by_garbage(RegionData a, RegionData b) {
 38   if (a._garbage &gt; b._garbage)
 39     return -1;
 40   else if (a._garbage &lt; b._garbage)
 41     return 1;
 42   else return 0;
 43 }
 44 
 45 int ShenandoahHeuristics::compare_by_garbage_then_alloc_seq_ascending(RegionData a, RegionData b) {
 46   int r = compare_by_garbage(a, b);
 47   if (r != 0) {
 48     return r;
 49   }
 50   return compare_by_alloc_seq_ascending(a, b);
 51 }
 52 
 53 int ShenandoahHeuristics::compare_by_alloc_seq_ascending(RegionData a, RegionData b) {
 54   if (a._seqnum_last_alloc == b._seqnum_last_alloc)
 55     return 0;
 56   else if (a._seqnum_last_alloc &lt; b._seqnum_last_alloc)
 57     return -1;
 58   else return 1;
 59 }
 60 
 61 int ShenandoahHeuristics::compare_by_alloc_seq_descending(RegionData a, RegionData b) {
 62   return -compare_by_alloc_seq_ascending(a, b);
 63 }
 64 
 65 ShenandoahHeuristics::ShenandoahHeuristics() :
 66   _update_refs_early(false),
 67   _update_refs_adaptive(false),
 68   _region_data(NULL),
 69   _region_data_size(0),
 70   _degenerated_cycles_in_a_row(0),
 71   _successful_cycles_in_a_row(0),
 72   _bytes_in_cset(0),
 73   _cycle_start(os::elapsedTime()),
 74   _last_cycle_end(0),
 75   _gc_times_learned(0),
 76   _gc_time_penalties(0),
 77   _gc_time_history(new TruncatedSeq(5)),
 78   _metaspace_oom()
 79 {
 80   if (strcmp(ShenandoahUpdateRefsEarly, &quot;on&quot;) == 0 ||
 81       strcmp(ShenandoahUpdateRefsEarly, &quot;true&quot;) == 0 ) {
 82     _update_refs_early = true;
 83   } else if (strcmp(ShenandoahUpdateRefsEarly, &quot;off&quot;) == 0 ||
 84              strcmp(ShenandoahUpdateRefsEarly, &quot;false&quot;) == 0 ) {
 85     _update_refs_early = false;
 86   } else if (strcmp(ShenandoahUpdateRefsEarly, &quot;adaptive&quot;) == 0) {
 87     _update_refs_adaptive = true;
 88     _update_refs_early = true;
 89   } else {
 90     vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahUpdateRefsEarly option: %s&quot;, ShenandoahUpdateRefsEarly);
 91   }
 92 
 93   // No unloading during concurrent mark? Communicate that to heuristics
 94   if (!ClassUnloadingWithConcurrentMark) {
 95     FLAG_SET_DEFAULT(ShenandoahUnloadClassesFrequency, 0);
 96   }
 97 }
 98 
 99 ShenandoahHeuristics::~ShenandoahHeuristics() {
100   if (_region_data != NULL) {
101     FREE_C_HEAP_ARRAY(RegionGarbage, _region_data);
102   }
103 }
104 
105 ShenandoahHeuristics::RegionData* ShenandoahHeuristics::get_region_data_cache(size_t num) {
106   RegionData* res = _region_data;
107   if (res == NULL) {
108     res = NEW_C_HEAP_ARRAY(RegionData, num, mtGC);
109     _region_data = res;
110     _region_data_size = num;
111   } else if (_region_data_size &lt; num) {
112     res = REALLOC_C_HEAP_ARRAY(RegionData, _region_data, num, mtGC);
113     _region_data = res;
114     _region_data_size = num;
115   }
116   return res;
117 }
118 
119 void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
120   assert(collection_set-&gt;count() == 0, &quot;Must be empty&quot;);
121 
122   ShenandoahHeap* heap = ShenandoahHeap::heap();
123 
<a name="3" id="anc3"></a>


124   // Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.
125 
126   size_t num_regions = heap-&gt;num_regions();
127 
128   RegionData* candidates = get_region_data_cache(num_regions);
129 
130   size_t cand_idx = 0;
131 
132   size_t total_garbage = 0;
133 
134   size_t immediate_garbage = 0;
135   size_t immediate_regions = 0;
136 
137   size_t free = 0;
138   size_t free_regions = 0;
139 
140   ShenandoahMarkingContext* const ctx = heap-&gt;complete_marking_context();
141 
142   for (size_t i = 0; i &lt; num_regions; i++) {
143     ShenandoahHeapRegion* region = heap-&gt;get_region(i);
144 
145     size_t garbage = region-&gt;garbage();
146     total_garbage += garbage;
147 
148     if (region-&gt;is_empty()) {
149       free_regions++;
150       free += ShenandoahHeapRegion::region_size_bytes();
151     } else if (region-&gt;is_regular()) {
152       if (!region-&gt;has_live()) {
153         // We can recycle it right away and put it in the free set.
154         immediate_regions++;
155         immediate_garbage += garbage;
156         region-&gt;make_trash_immediate();
157       } else {
158         // This is our candidate for later consideration.
159         candidates[cand_idx]._region = region;
160         candidates[cand_idx]._garbage = garbage;
161         cand_idx++;
162       }
163     } else if (region-&gt;is_humongous_start()) {
164       // Reclaim humongous regions here, and count them as the immediate garbage
165 #ifdef ASSERT
166       bool reg_live = region-&gt;has_live();
<a name="4" id="anc4"></a><span class="line-modified">167       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom() + ShenandoahBrooksPointer::word_size()));</span>
168       assert(reg_live == bm_live,
169              &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
170              BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
171 #endif
172       if (!region-&gt;has_live()) {
173         heap-&gt;trash_humongous_region_at(region);
174 
175         // Count only the start. Continuations would be counted on &quot;trash&quot; path
176         immediate_regions++;
177         immediate_garbage += garbage;
178       }
179     } else if (region-&gt;is_trash()) {
180       // Count in just trashed collection set, during coalesced CM-with-UR
181       immediate_regions++;
182       immediate_garbage += garbage;
183     }
184   }
185 
186   // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
187   // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
188 
189   assert (immediate_garbage &lt;= total_garbage,
<a name="5" id="anc5"></a><span class="line-modified">190           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;M vs &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-modified">191           immediate_garbage / M, total_garbage / M);</span>

192 
193   size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
194 
195   if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
196     choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
197     collection_set-&gt;update_region_status();
198 
199     size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<a name="6" id="anc6"></a><span class="line-modified">200     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;M CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">201                        collection_set-&gt;garbage() / M, cset_percent, collection_set-&gt;live_data() / M, collection_set-&gt;count());</span>



202   }
203 
<a name="7" id="anc7"></a><span class="line-modified">204   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">205                      immediate_garbage / M, immediate_percent, immediate_regions);</span>

206 }
207 
208 void ShenandoahHeuristics::record_gc_start() {
209   // Do nothing
210 }
211 
212 void ShenandoahHeuristics::record_gc_end() {
213   // Do nothing
214 }
215 
216 void ShenandoahHeuristics::record_cycle_start() {
217   _cycle_start = os::elapsedTime();
218 }
219 
220 void ShenandoahHeuristics::record_cycle_end() {
221   _last_cycle_end = os::elapsedTime();
222 }
223 
224 void ShenandoahHeuristics::record_phase_time(ShenandoahPhaseTimings::Phase phase, double secs) {
225   // Do nothing
226 }
227 
228 bool ShenandoahHeuristics::should_start_update_refs() {
229   return _update_refs_early;
230 }
231 
<a name="8" id="anc8"></a><span class="line-modified">232 bool ShenandoahHeuristics::should_start_normal_gc() const {</span>
233   // Perform GC to cleanup metaspace
234   if (has_metaspace_oom()) {
235     // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
236     log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
237     return true;
238   }
239 
<a name="9" id="anc9"></a><span class="line-modified">240   double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">241   bool periodic_gc = (last_time_ms &gt; ShenandoahGuaranteedGCInterval);</span>
<span class="line-modified">242   if (periodic_gc) {</span>
<span class="line-modified">243     log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">244                   last_time_ms, ShenandoahGuaranteedGCInterval);</span>


245   }
<a name="10" id="anc10"></a><span class="line-removed">246   return periodic_gc;</span>
<span class="line-removed">247 }</span>
<span class="line-removed">248 </span>
<span class="line-removed">249 bool ShenandoahHeuristics::should_start_traversal_gc() {</span>
<span class="line-removed">250   return false;</span>
<span class="line-removed">251 }</span>
252 
<a name="11" id="anc11"></a><span class="line-removed">253 bool ShenandoahHeuristics::can_do_traversal_gc() {</span>
254   return false;
255 }
256 
257 bool ShenandoahHeuristics::should_degenerate_cycle() {
258   return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
259 }
260 
261 void ShenandoahHeuristics::record_success_concurrent() {
262   _degenerated_cycles_in_a_row = 0;
263   _successful_cycles_in_a_row++;
264 
265   _gc_time_history-&gt;add(time_since_last_gc());
266   _gc_times_learned++;
267   _gc_time_penalties -= MIN2&lt;size_t&gt;(_gc_time_penalties, Concurrent_Adjust);
268 }
269 
270 void ShenandoahHeuristics::record_success_degenerated() {
271   _degenerated_cycles_in_a_row++;
272   _successful_cycles_in_a_row = 0;
273   _gc_time_penalties += Degenerated_Penalty;
274 }
275 
276 void ShenandoahHeuristics::record_success_full() {
277   _degenerated_cycles_in_a_row = 0;
278   _successful_cycles_in_a_row++;
279   _gc_time_penalties += Full_Penalty;
280 }
281 
282 void ShenandoahHeuristics::record_allocation_failure_gc() {
283   _bytes_in_cset = 0;
284 }
285 
286 void ShenandoahHeuristics::record_requested_gc() {
287   _bytes_in_cset = 0;
288 
289   // Assume users call System.gc() when external state changes significantly,
290   // which forces us to re-learn the GC timings and allocation rates.
291   _gc_times_learned = 0;
292 }
293 
294 bool ShenandoahHeuristics::can_process_references() {
295   if (ShenandoahRefProcFrequency == 0) return false;
296   return true;
297 }
298 
299 bool ShenandoahHeuristics::should_process_references() {
300   if (!can_process_references()) return false;
301   size_t cycle = ShenandoahHeap::heap()-&gt;shenandoah_policy()-&gt;cycle_counter();
302   // Process references every Nth GC cycle.
303   return cycle % ShenandoahRefProcFrequency == 0;
304 }
305 
306 bool ShenandoahHeuristics::can_unload_classes() {
307   if (!ClassUnloading) return false;
308   return true;
309 }
310 
311 bool ShenandoahHeuristics::can_unload_classes_normal() {
312   if (!can_unload_classes()) return false;
313   if (has_metaspace_oom()) return true;
314   if (!ClassUnloadingWithConcurrentMark) return false;
315   if (ShenandoahUnloadClassesFrequency == 0) return false;
316   return true;
317 }
318 
319 bool ShenandoahHeuristics::should_unload_classes() {
320   if (!can_unload_classes_normal()) return false;
321   if (has_metaspace_oom()) return true;
322   size_t cycle = ShenandoahHeap::heap()-&gt;shenandoah_policy()-&gt;cycle_counter();
323   // Unload classes every Nth GC cycle.
324   // This should not happen in the same cycle as process_references to amortize costs.
325   // Offsetting by one is enough to break the rendezvous when periods are equal.
326   // When periods are not equal, offsetting by one is just as good as any other guess.
327   return (cycle + 1) % ShenandoahUnloadClassesFrequency == 0;
328 }
329 
330 void ShenandoahHeuristics::initialize() {
331   // Nothing to do by default.
332 }
333 
334 double ShenandoahHeuristics::time_since_last_gc() const {
335   return os::elapsedTime() - _cycle_start;
336 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
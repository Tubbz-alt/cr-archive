<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_INLINE_HPP
 26 
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;gc/shared/markBitMap.inline.hpp&quot;
 29 #include &quot;gc/shared/threadLocalAllocBuffer.inline.hpp&quot;
 30 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
<span class="line-removed"> 33 #include &quot;gc/shenandoah/shenandoahBrooksPointer.inline.hpp&quot;</span>
 34 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;

 35 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;

 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;runtime/atomic.hpp&quot;
 44 #include &quot;runtime/prefetch.inline.hpp&quot;
 45 #include &quot;runtime/thread.hpp&quot;
 46 #include &quot;utilities/copy.hpp&quot;
 47 #include &quot;utilities/globalDefinitions.hpp&quot;
 48 
<span class="line-removed"> 49 template &lt;class T&gt;</span>
<span class="line-removed"> 50 void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {</span>
<span class="line-removed"> 51   T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 52   if (!CompressedOops::is_null(o)) {</span>
<span class="line-removed"> 53     oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed"> 54     _heap-&gt;update_with_forwarded_not_null(p, obj);</span>
<span class="line-removed"> 55   }</span>
<span class="line-removed"> 56 }</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58 void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed"> 59 void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }</span>
 60 
 61 inline ShenandoahHeapRegion* ShenandoahRegionIterator::next() {
<span class="line-modified"> 62   size_t new_index = Atomic::add((size_t) 1, &amp;_index);</span>
 63   // get_region() provides the bounds-check and returns NULL on OOB.
 64   return _heap-&gt;get_region(new_index - 1);
 65 }
 66 
 67 inline bool ShenandoahHeap::has_forwarded_objects() const {
 68   return _gc_state.is_set(HAS_FORWARDED);
 69 }
 70 
 71 inline WorkGang* ShenandoahHeap::workers() const {
 72   return _workers;
 73 }
 74 
 75 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 76   return _safepoint_workers;
 77 }
 78 
 79 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
 80   uintptr_t region_start = ((uintptr_t) addr);
 81   uintptr_t index = (region_start - (uintptr_t) base()) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
 82   assert(index &lt; num_regions(), &quot;Region index is in bounds: &quot; PTR_FORMAT, p2i(addr));
</pre>
<hr />
<pre>
106 }
107 
108 template &lt;class T&gt;
109 inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {
110   T o = RawAccess&lt;&gt;::oop_load(p);
111   if (!CompressedOops::is_null(o)) {
112     oop obj = CompressedOops::decode_not_null(o);
113     return maybe_update_with_forwarded_not_null(p, obj);
114   } else {
115     return NULL;
116   }
117 }
118 
119 template &lt;class T&gt;
120 inline oop ShenandoahHeap::evac_update_with_forwarded(T* p) {
121   T o = RawAccess&lt;&gt;::oop_load(p);
122   if (!CompressedOops::is_null(o)) {
123     oop heap_oop = CompressedOops::decode_not_null(o);
124     if (in_collection_set(heap_oop)) {
125       oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="line-modified">126       if (oopDesc::equals_raw(forwarded_oop, heap_oop)) {</span>
127         forwarded_oop = evacuate_object(heap_oop, Thread::current());
128       }
<span class="line-modified">129       oop prev = atomic_compare_exchange_oop(forwarded_oop, p, heap_oop);</span>
<span class="line-modified">130       if (oopDesc::equals_raw(prev, heap_oop)) {</span>
131         return forwarded_oop;
132       } else {
133         return NULL;
134       }
135     }
136     return heap_oop;
137   } else {
138     return NULL;
139   }
140 }
141 
<span class="line-modified">142 inline oop ShenandoahHeap::atomic_compare_exchange_oop(oop n, oop* addr, oop c) {</span>
<span class="line-modified">143   return (oop) Atomic::cmpxchg(n, addr, c);</span>

144 }
145 
<span class="line-modified">146 inline oop ShenandoahHeap::atomic_compare_exchange_oop(oop n, narrowOop* addr, oop c) {</span>







147   narrowOop cmp = CompressedOops::encode(c);
148   narrowOop val = CompressedOops::encode(n);
<span class="line-modified">149   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(val, addr, cmp));</span>
150 }
151 
152 template &lt;class T&gt;
153 inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {
154   shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());
155   shenandoah_assert_correct(p, heap_oop);
156 
157   if (in_collection_set(heap_oop)) {
158     oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="line-modified">159     if (oopDesc::equals_raw(forwarded_oop, heap_oop)) {</span>
160       // E.g. during evacuation.
161       return forwarded_oop;
162     }
163 
164     shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());

165     shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());
166 
167     // If this fails, another thread wrote to p before us, it will be logged in SATB and the
168     // reference be updated later.
<span class="line-modified">169     oop result = atomic_compare_exchange_oop(forwarded_oop, p, heap_oop);</span>
<span class="line-modified">170 </span>
<span class="line-modified">171     if (oopDesc::equals_raw(result, heap_oop)) { // CAS successful.</span>
<span class="line-modified">172       return forwarded_oop;</span>











173     } else {
<span class="line-modified">174       // Note: we used to assert the following here. This doesn&#39;t work because sometimes, during</span>
<span class="line-modified">175       // marking/updating-refs, it can happen that a Java thread beats us with an arraycopy,</span>
<span class="line-removed">176       // which first copies the array, which potentially contains from-space refs, and only afterwards</span>
<span class="line-removed">177       // updates all from-space refs to to-space refs, which leaves a short window where the new array</span>
<span class="line-removed">178       // elements can be from-space.</span>
<span class="line-removed">179       // assert(CompressedOops::is_null(result) ||</span>
<span class="line-removed">180       //        oopDesc::equals_raw(result, ShenandoahBarrierSet::resolve_oop_static_not_null(result)),</span>
<span class="line-removed">181       //       &quot;expect not forwarded&quot;);</span>
<span class="line-removed">182       return NULL;</span>
183     }
184   } else {
185     shenandoah_assert_not_forwarded(p, heap_oop);
186     return heap_oop;
187   }
188 }
189 
190 inline bool ShenandoahHeap::cancelled_gc() const {
191   return _cancelled_gc.get() == CANCELLED;
192 }
193 
194 inline bool ShenandoahHeap::check_cancelled_gc_and_yield(bool sts_active) {
195   if (! (sts_active &amp;&amp; ShenandoahSuspendibleWorkers)) {
196     return cancelled_gc();
197   }
198 
199   jbyte prev = _cancelled_gc.cmpxchg(NOT_CANCELLED, CANCELLABLE);
200   if (prev == CANCELLABLE || prev == NOT_CANCELLED) {
201     if (SuspendibleThreadSet::should_yield()) {
202       SuspendibleThreadSet::yield();
</pre>
<hr />
<pre>
228     // No GCLABs in this thread, fallback to shared allocation
229     return NULL;
230   }
231   HeapWord* obj = gclab-&gt;allocate(size);
232   if (obj != NULL) {
233     return obj;
234   }
235   // Otherwise...
236   return allocate_from_gclab_slow(thread, size);
237 }
238 
239 inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {
240   if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {
241     // This thread went through the OOM during evac protocol and it is safe to return
242     // the forward pointer. It must not attempt to evacuate any more.
243     return ShenandoahBarrierSet::resolve_forwarded(p);
244   }
245 
246   assert(ShenandoahThreadLocalData::is_evac_allowed(thread), &quot;must be enclosed in oom-evac scope&quot;);
247 
<span class="line-modified">248   size_t size_no_fwdptr = (size_t) p-&gt;size();</span>
<span class="line-removed">249   size_t size_with_fwdptr = size_no_fwdptr + ShenandoahBrooksPointer::word_size();</span>
250 
251   assert(!heap_region_containing(p)-&gt;is_humongous(), &quot;never evacuate humongous objects&quot;);
252 
253   bool alloc_from_gclab = true;
<span class="line-modified">254   HeapWord* filler = NULL;</span>
255 
256 #ifdef ASSERT
257   if (ShenandoahOOMDuringEvacALot &amp;&amp;
258       (os::random() &amp; 1) == 0) { // Simulate OOM every ~2nd slow-path call
<span class="line-modified">259         filler = NULL;</span>
260   } else {
261 #endif
262     if (UseTLAB) {
<span class="line-modified">263       filler = allocate_from_gclab(thread, size_with_fwdptr);</span>
264     }
<span class="line-modified">265     if (filler == NULL) {</span>
<span class="line-modified">266       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size_with_fwdptr);</span>
<span class="line-modified">267       filler = allocate_memory(req);</span>
268       alloc_from_gclab = false;
269     }
270 #ifdef ASSERT
271   }
272 #endif
273 
<span class="line-modified">274   if (filler == NULL) {</span>
<span class="line-modified">275     control_thread()-&gt;handle_alloc_failure_evac(size_with_fwdptr);</span>
276 
277     _oom_evac_handler.handle_out_of_memory_during_evacuation();
278 
279     return ShenandoahBarrierSet::resolve_forwarded(p);
280   }
281 
<span class="line-modified">282   // Copy the object and initialize its forwarding ptr:</span>
<span class="line-modified">283   HeapWord* copy = filler + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">284   oop copy_val = oop(copy);</span>
<span class="line-removed">285 </span>
<span class="line-removed">286   Copy::aligned_disjoint_words((HeapWord*) p, copy, size_no_fwdptr);</span>
<span class="line-removed">287   ShenandoahBrooksPointer::initialize(oop(copy));</span>
288 
289   // Try to install the new forwarding pointer.
<span class="line-modified">290   oop result = ShenandoahBrooksPointer::try_update_forwardee(p, copy_val);</span>
<span class="line-modified">291 </span>
<span class="line-modified">292   if (oopDesc::equals_raw(result, p)) {</span>
293     // Successfully evacuated. Our copy is now the public one!
294     shenandoah_assert_correct(NULL, copy_val);
295     return copy_val;
296   }  else {
297     // Failed to evacuate. We need to deal with the object that is left behind. Since this
298     // new allocation is certainly after TAMS, it will be considered live in the next cycle.
299     // But if it happens to contain references to evacuated regions, those references would
300     // not get updated for this stale copy during this cycle, and we will crash while scanning
301     // it the next cycle.
302     //
303     // For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next
304     // object will overwrite this stale copy, or the filler object on LAB retirement will
305     // do this. For non-GCLAB allocations, we have no way to retract the allocation, and
306     // have to explicitly overwrite the copy with the filler object. With that overwrite,
307     // we have to keep the fwdptr initialized and pointing to our (stale) copy.
308     if (alloc_from_gclab) {
<span class="line-modified">309       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(filler, size_with_fwdptr);</span>
310     } else {
<span class="line-modified">311       fill_with_object(copy, size_no_fwdptr);</span>

312     }
<span class="line-removed">313     shenandoah_assert_correct(NULL, copy_val);</span>
314     shenandoah_assert_correct(NULL, result);
315     return result;
316   }
317 }
318 
319 template&lt;bool RESOLVE&gt;
320 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
321   oop obj = oop(entry);
322   if (RESOLVE) {
323     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
324   }
325   return !_marking_context-&gt;is_marked(obj);
326 }
327 
<span class="line-modified">328 template &lt;class T&gt;</span>
<span class="line-removed">329 inline bool ShenandoahHeap::in_collection_set(T p) const {</span>
<span class="line-removed">330   HeapWord* obj = (HeapWord*) p;</span>
331   assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="line-modified">332   assert(is_in(obj), &quot;should be in heap&quot;);</span>


333 
<span class="line-modified">334   return collection_set()-&gt;is_in(obj);</span>



335 }
336 
337 inline bool ShenandoahHeap::is_stable() const {
338   return _gc_state.is_clear();
339 }
340 
341 inline bool ShenandoahHeap::is_idle() const {
342   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS | TRAVERSAL);
343 }
344 
345 inline bool ShenandoahHeap::is_concurrent_mark_in_progress() const {
346   return _gc_state.is_set(MARKING);
347 }
348 
349 inline bool ShenandoahHeap::is_concurrent_traversal_in_progress() const {
350   return _gc_state.is_set(TRAVERSAL);
351 }
352 
353 inline bool ShenandoahHeap::is_evacuation_in_progress() const {
354   return _gc_state.is_set(EVACUATION);
</pre>
<hr />
<pre>
357 inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {
358   return _gc_state.is_set(mask);
359 }
360 
361 inline bool ShenandoahHeap::is_degenerated_gc_in_progress() const {
362   return _degenerated_gc_in_progress.is_set();
363 }
364 
365 inline bool ShenandoahHeap::is_full_gc_in_progress() const {
366   return _full_gc_in_progress.is_set();
367 }
368 
369 inline bool ShenandoahHeap::is_full_gc_move_in_progress() const {
370   return _full_gc_move_in_progress.is_set();
371 }
372 
373 inline bool ShenandoahHeap::is_update_refs_in_progress() const {
374   return _gc_state.is_set(UPDATEREFS);
375 }
376 








377 template&lt;class T&gt;
378 inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl) {
379   marked_object_iterate(region, cl, region-&gt;top());
380 }
381 
382 template&lt;class T&gt;
383 inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit) {
<span class="line-removed">384   assert(ShenandoahBrooksPointer::word_offset() &lt; 0, &quot;skip_delta calculation below assumes the forwarding ptr is before obj&quot;);</span>
385   assert(! region-&gt;is_humongous_continuation(), &quot;no humongous continuation regions here&quot;);
386 
387   ShenandoahMarkingContext* const ctx = complete_marking_context();
388   assert(ctx-&gt;is_complete(), &quot;sanity&quot;);
389 
390   MarkBitMap* mark_bit_map = ctx-&gt;mark_bit_map();
391   HeapWord* tams = ctx-&gt;top_at_mark_start(region);
392 
<span class="line-modified">393   size_t skip_bitmap_delta = ShenandoahBrooksPointer::word_size() + 1;</span>
<span class="line-modified">394   size_t skip_objsize_delta = ShenandoahBrooksPointer::word_size() /* + actual obj.size() below */;</span>
<span class="line-modified">395   HeapWord* start = region-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">396   HeapWord* end = MIN2(tams + ShenandoahBrooksPointer::word_size(), region-&gt;end());</span>
397 
398   // Step 1. Scan below the TAMS based on bitmap data.
399   HeapWord* limit_bitmap = MIN2(limit, tams);
400 
401   // Try to scan the initial candidate. If the candidate is above the TAMS, it would
402   // fail the subsequent &quot;&lt; limit_bitmap&quot; checks, and fall through to Step 2.
403   HeapWord* cb = mark_bit_map-&gt;get_next_marked_addr(start, end);
404 
405   intx dist = ShenandoahMarkScanPrefetch;
406   if (dist &gt; 0) {
407     // Batched scan that prefetches the oop data, anticipating the access to
408     // either header, oop field, or forwarding pointer. Not that we cannot
409     // touch anything in oop, while it still being prefetched to get enough
410     // time for prefetch to work. This is why we try to scan the bitmap linearly,
411     // disregarding the object size. However, since we know forwarding pointer
412     // preceeds the object, we can skip over it. Once we cannot trust the bitmap,
413     // there is no point for prefetching the oop contents, as oop-&gt;size() will
414     // touch it prematurely.
415 
416     // No variable-length arrays in standard C++, have enough slots to fit
417     // the prefetch distance.
418     static const int SLOT_COUNT = 256;
419     guarantee(dist &lt;= SLOT_COUNT, &quot;adjust slot count&quot;);
420     HeapWord* slots[SLOT_COUNT];
421 
422     int avail;
423     do {
424       avail = 0;
425       for (int c = 0; (c &lt; dist) &amp;&amp; (cb &lt; limit_bitmap); c++) {
<span class="line-modified">426         Prefetch::read(cb, ShenandoahBrooksPointer::byte_offset());</span>
427         slots[avail++] = cb;
428         cb += skip_bitmap_delta;
429         if (cb &lt; limit_bitmap) {
430           cb = mark_bit_map-&gt;get_next_marked_addr(cb, limit_bitmap);
431         }
432       }
433 
434       for (int c = 0; c &lt; avail; c++) {
435         assert (slots[c] &lt; tams,  &quot;only objects below TAMS here: &quot;  PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(slots[c]), p2i(tams));
436         assert (slots[c] &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(slots[c]), p2i(limit));
437         oop obj = oop(slots[c]);
438         assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
439         assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
440         cl-&gt;do_object(obj);
441       }
442     } while (avail &gt; 0);
443   } else {
444     while (cb &lt; limit_bitmap) {
445       assert (cb &lt; tams,  &quot;only objects below TAMS here: &quot;  PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb), p2i(tams));
446       assert (cb &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb), p2i(limit));
447       oop obj = oop(cb);
448       assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
449       assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
450       cl-&gt;do_object(obj);
451       cb += skip_bitmap_delta;
452       if (cb &lt; limit_bitmap) {
453         cb = mark_bit_map-&gt;get_next_marked_addr(cb, limit_bitmap);
454       }
455     }
456   }
457 
458   // Step 2. Accurate size-based traversal, happens past the TAMS.
459   // This restarts the scan at TAMS, which makes sure we traverse all objects,
460   // regardless of what happened at Step 1.
<span class="line-modified">461   HeapWord* cs = tams + ShenandoahBrooksPointer::word_size();</span>
462   while (cs &lt; limit) {
<span class="line-modified">463     assert (cs &gt; tams,  &quot;only objects past TAMS here: &quot;   PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(tams));</span>
464     assert (cs &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(limit));
465     oop obj = oop(cs);
466     assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
467     assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
468     int size = obj-&gt;size();
469     cl-&gt;do_object(obj);
<span class="line-modified">470     cs += size + skip_objsize_delta;</span>
471   }
472 }
473 
474 template &lt;class T&gt;
475 class ShenandoahObjectToOopClosure : public ObjectClosure {
476   T* _cl;
477 public:
478   ShenandoahObjectToOopClosure(T* cl) : _cl(cl) {}
479 
480   void do_object(oop obj) {
481     obj-&gt;oop_iterate(_cl);
482   }
483 };
484 
485 template &lt;class T&gt;
486 class ShenandoahObjectToOopBoundedClosure : public ObjectClosure {
487   T* _cl;
488   MemRegion _bounds;
489 public:
490   ShenandoahObjectToOopBoundedClosure(T* cl, HeapWord* bottom, HeapWord* top) :
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_INLINE_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_INLINE_HPP
 27 
 28 #include &quot;classfile/javaClasses.inline.hpp&quot;
 29 #include &quot;gc/shared/markBitMap.inline.hpp&quot;
 30 #include &quot;gc/shared/threadLocalAllocBuffer.inline.hpp&quot;
 31 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;

 34 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
 36 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
<span class="line-added"> 43 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/prefetch.inline.hpp&quot;
 47 #include &quot;runtime/thread.hpp&quot;
 48 #include &quot;utilities/copy.hpp&quot;
 49 #include &quot;utilities/globalDefinitions.hpp&quot;
 50 











 51 
 52 inline ShenandoahHeapRegion* ShenandoahRegionIterator::next() {
<span class="line-modified"> 53   size_t new_index = Atomic::add(&amp;_index, (size_t) 1);</span>
 54   // get_region() provides the bounds-check and returns NULL on OOB.
 55   return _heap-&gt;get_region(new_index - 1);
 56 }
 57 
 58 inline bool ShenandoahHeap::has_forwarded_objects() const {
 59   return _gc_state.is_set(HAS_FORWARDED);
 60 }
 61 
 62 inline WorkGang* ShenandoahHeap::workers() const {
 63   return _workers;
 64 }
 65 
 66 inline WorkGang* ShenandoahHeap::get_safepoint_workers() {
 67   return _safepoint_workers;
 68 }
 69 
 70 inline size_t ShenandoahHeap::heap_region_index_containing(const void* addr) const {
 71   uintptr_t region_start = ((uintptr_t) addr);
 72   uintptr_t index = (region_start - (uintptr_t) base()) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
 73   assert(index &lt; num_regions(), &quot;Region index is in bounds: &quot; PTR_FORMAT, p2i(addr));
</pre>
<hr />
<pre>
 97 }
 98 
 99 template &lt;class T&gt;
100 inline oop ShenandoahHeap::maybe_update_with_forwarded(T* p) {
101   T o = RawAccess&lt;&gt;::oop_load(p);
102   if (!CompressedOops::is_null(o)) {
103     oop obj = CompressedOops::decode_not_null(o);
104     return maybe_update_with_forwarded_not_null(p, obj);
105   } else {
106     return NULL;
107   }
108 }
109 
110 template &lt;class T&gt;
111 inline oop ShenandoahHeap::evac_update_with_forwarded(T* p) {
112   T o = RawAccess&lt;&gt;::oop_load(p);
113   if (!CompressedOops::is_null(o)) {
114     oop heap_oop = CompressedOops::decode_not_null(o);
115     if (in_collection_set(heap_oop)) {
116       oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="line-modified">117       if (forwarded_oop == heap_oop) {</span>
118         forwarded_oop = evacuate_object(heap_oop, Thread::current());
119       }
<span class="line-modified">120       oop prev = cas_oop(forwarded_oop, p, heap_oop);</span>
<span class="line-modified">121       if (prev == heap_oop) {</span>
122         return forwarded_oop;
123       } else {
124         return NULL;
125       }
126     }
127     return heap_oop;
128   } else {
129     return NULL;
130   }
131 }
132 
<span class="line-modified">133 inline oop ShenandoahHeap::cas_oop(oop n, oop* addr, oop c) {</span>
<span class="line-modified">134   assert(is_aligned(addr, HeapWordSize), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
<span class="line-added">135   return (oop) Atomic::cmpxchg(addr, c, n);</span>
136 }
137 
<span class="line-modified">138 inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, narrowOop c) {</span>
<span class="line-added">139   assert(is_aligned(addr, sizeof(narrowOop)), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
<span class="line-added">140   narrowOop val = CompressedOops::encode(n);</span>
<span class="line-added">141   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, c, val));</span>
<span class="line-added">142 }</span>
<span class="line-added">143 </span>
<span class="line-added">144 inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, oop c) {</span>
<span class="line-added">145   assert(is_aligned(addr, sizeof(narrowOop)), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
146   narrowOop cmp = CompressedOops::encode(c);
147   narrowOop val = CompressedOops::encode(n);
<span class="line-modified">148   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, cmp, val));</span>
149 }
150 
151 template &lt;class T&gt;
152 inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {
153   shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());
154   shenandoah_assert_correct(p, heap_oop);
155 
156   if (in_collection_set(heap_oop)) {
157     oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="line-modified">158     if (forwarded_oop == heap_oop) {</span>
159       // E.g. during evacuation.
160       return forwarded_oop;
161     }
162 
163     shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());
<span class="line-added">164     shenandoah_assert_not_forwarded(p, forwarded_oop);</span>
165     shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());
166 
167     // If this fails, another thread wrote to p before us, it will be logged in SATB and the
168     // reference be updated later.
<span class="line-modified">169     oop witness = cas_oop(forwarded_oop, p, heap_oop);</span>
<span class="line-modified">170 </span>
<span class="line-modified">171     if (witness != heap_oop) {</span>
<span class="line-modified">172       // CAS failed, someone had beat us to it. Normally, we would return the failure witness,</span>
<span class="line-added">173       // because that would be the proper write of to-space object, enforced by strong barriers.</span>
<span class="line-added">174       // However, there is a corner case with arraycopy. It can happen that a Java thread</span>
<span class="line-added">175       // beats us with an arraycopy, which first copies the array, which potentially contains</span>
<span class="line-added">176       // from-space refs, and only afterwards updates all from-space refs to to-space refs,</span>
<span class="line-added">177       // which leaves a short window where the new array elements can be from-space.</span>
<span class="line-added">178       // In this case, we can just resolve the result again. As we resolve, we need to consider</span>
<span class="line-added">179       // the contended write might have been NULL.</span>
<span class="line-added">180       oop result = ShenandoahBarrierSet::resolve_forwarded(witness);</span>
<span class="line-added">181       shenandoah_assert_not_forwarded_except(p, result, (result == NULL));</span>
<span class="line-added">182       shenandoah_assert_not_in_cset_except(p, result, (result == NULL) || cancelled_gc());</span>
<span class="line-added">183       return result;</span>
184     } else {
<span class="line-modified">185       // Success! We have updated with known to-space copy. We have already asserted it is sane.</span>
<span class="line-modified">186       return forwarded_oop;</span>







187     }
188   } else {
189     shenandoah_assert_not_forwarded(p, heap_oop);
190     return heap_oop;
191   }
192 }
193 
194 inline bool ShenandoahHeap::cancelled_gc() const {
195   return _cancelled_gc.get() == CANCELLED;
196 }
197 
198 inline bool ShenandoahHeap::check_cancelled_gc_and_yield(bool sts_active) {
199   if (! (sts_active &amp;&amp; ShenandoahSuspendibleWorkers)) {
200     return cancelled_gc();
201   }
202 
203   jbyte prev = _cancelled_gc.cmpxchg(NOT_CANCELLED, CANCELLABLE);
204   if (prev == CANCELLABLE || prev == NOT_CANCELLED) {
205     if (SuspendibleThreadSet::should_yield()) {
206       SuspendibleThreadSet::yield();
</pre>
<hr />
<pre>
232     // No GCLABs in this thread, fallback to shared allocation
233     return NULL;
234   }
235   HeapWord* obj = gclab-&gt;allocate(size);
236   if (obj != NULL) {
237     return obj;
238   }
239   // Otherwise...
240   return allocate_from_gclab_slow(thread, size);
241 }
242 
243 inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {
244   if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {
245     // This thread went through the OOM during evac protocol and it is safe to return
246     // the forward pointer. It must not attempt to evacuate any more.
247     return ShenandoahBarrierSet::resolve_forwarded(p);
248   }
249 
250   assert(ShenandoahThreadLocalData::is_evac_allowed(thread), &quot;must be enclosed in oom-evac scope&quot;);
251 
<span class="line-modified">252   size_t size = p-&gt;size();</span>

253 
254   assert(!heap_region_containing(p)-&gt;is_humongous(), &quot;never evacuate humongous objects&quot;);
255 
256   bool alloc_from_gclab = true;
<span class="line-modified">257   HeapWord* copy = NULL;</span>
258 
259 #ifdef ASSERT
260   if (ShenandoahOOMDuringEvacALot &amp;&amp;
261       (os::random() &amp; 1) == 0) { // Simulate OOM every ~2nd slow-path call
<span class="line-modified">262         copy = NULL;</span>
263   } else {
264 #endif
265     if (UseTLAB) {
<span class="line-modified">266       copy = allocate_from_gclab(thread, size);</span>
267     }
<span class="line-modified">268     if (copy == NULL) {</span>
<span class="line-modified">269       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);</span>
<span class="line-modified">270       copy = allocate_memory(req);</span>
271       alloc_from_gclab = false;
272     }
273 #ifdef ASSERT
274   }
275 #endif
276 
<span class="line-modified">277   if (copy == NULL) {</span>
<span class="line-modified">278     control_thread()-&gt;handle_alloc_failure_evac(size);</span>
279 
280     _oom_evac_handler.handle_out_of_memory_during_evacuation();
281 
282     return ShenandoahBarrierSet::resolve_forwarded(p);
283   }
284 
<span class="line-modified">285   // Copy the object:</span>
<span class="line-modified">286   Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(p), copy, size);</span>




287 
288   // Try to install the new forwarding pointer.
<span class="line-modified">289   oop copy_val = oop(copy);</span>
<span class="line-modified">290   oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);</span>
<span class="line-modified">291   if (result == copy_val) {</span>
292     // Successfully evacuated. Our copy is now the public one!
293     shenandoah_assert_correct(NULL, copy_val);
294     return copy_val;
295   }  else {
296     // Failed to evacuate. We need to deal with the object that is left behind. Since this
297     // new allocation is certainly after TAMS, it will be considered live in the next cycle.
298     // But if it happens to contain references to evacuated regions, those references would
299     // not get updated for this stale copy during this cycle, and we will crash while scanning
300     // it the next cycle.
301     //
302     // For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next
303     // object will overwrite this stale copy, or the filler object on LAB retirement will
304     // do this. For non-GCLAB allocations, we have no way to retract the allocation, and
305     // have to explicitly overwrite the copy with the filler object. With that overwrite,
306     // we have to keep the fwdptr initialized and pointing to our (stale) copy.
307     if (alloc_from_gclab) {
<span class="line-modified">308       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(copy, size);</span>
309     } else {
<span class="line-modified">310       fill_with_object(copy, size);</span>
<span class="line-added">311       shenandoah_assert_correct(NULL, copy_val);</span>
312     }

313     shenandoah_assert_correct(NULL, result);
314     return result;
315   }
316 }
317 
318 template&lt;bool RESOLVE&gt;
319 inline bool ShenandoahHeap::requires_marking(const void* entry) const {
320   oop obj = oop(entry);
321   if (RESOLVE) {
322     obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
323   }
324   return !_marking_context-&gt;is_marked(obj);
325 }
326 
<span class="line-modified">327 inline bool ShenandoahHeap::in_collection_set(oop p) const {</span>


328   assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="line-modified">329   assert(is_in(p), &quot;should be in heap&quot;);</span>
<span class="line-added">330   return collection_set()-&gt;is_in(p);</span>
<span class="line-added">331 }</span>
332 
<span class="line-modified">333 inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {</span>
<span class="line-added">334   assert(collection_set() != NULL, &quot;Sanity&quot;);</span>
<span class="line-added">335   assert(is_in(p), &quot;should be in heap&quot;);</span>
<span class="line-added">336   return collection_set()-&gt;is_in((HeapWord*)p);</span>
337 }
338 
339 inline bool ShenandoahHeap::is_stable() const {
340   return _gc_state.is_clear();
341 }
342 
343 inline bool ShenandoahHeap::is_idle() const {
344   return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS | TRAVERSAL);
345 }
346 
347 inline bool ShenandoahHeap::is_concurrent_mark_in_progress() const {
348   return _gc_state.is_set(MARKING);
349 }
350 
351 inline bool ShenandoahHeap::is_concurrent_traversal_in_progress() const {
352   return _gc_state.is_set(TRAVERSAL);
353 }
354 
355 inline bool ShenandoahHeap::is_evacuation_in_progress() const {
356   return _gc_state.is_set(EVACUATION);
</pre>
<hr />
<pre>
359 inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {
360   return _gc_state.is_set(mask);
361 }
362 
363 inline bool ShenandoahHeap::is_degenerated_gc_in_progress() const {
364   return _degenerated_gc_in_progress.is_set();
365 }
366 
367 inline bool ShenandoahHeap::is_full_gc_in_progress() const {
368   return _full_gc_in_progress.is_set();
369 }
370 
371 inline bool ShenandoahHeap::is_full_gc_move_in_progress() const {
372   return _full_gc_move_in_progress.is_set();
373 }
374 
375 inline bool ShenandoahHeap::is_update_refs_in_progress() const {
376   return _gc_state.is_set(UPDATEREFS);
377 }
378 
<span class="line-added">379 inline bool ShenandoahHeap::is_stw_gc_in_progress() const {</span>
<span class="line-added">380   return is_full_gc_in_progress() || is_degenerated_gc_in_progress();</span>
<span class="line-added">381 }</span>
<span class="line-added">382 </span>
<span class="line-added">383 inline bool ShenandoahHeap::is_concurrent_root_in_progress() const {</span>
<span class="line-added">384   return _concurrent_root_in_progress.is_set();</span>
<span class="line-added">385 }</span>
<span class="line-added">386 </span>
387 template&lt;class T&gt;
388 inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl) {
389   marked_object_iterate(region, cl, region-&gt;top());
390 }
391 
392 template&lt;class T&gt;
393 inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit) {

394   assert(! region-&gt;is_humongous_continuation(), &quot;no humongous continuation regions here&quot;);
395 
396   ShenandoahMarkingContext* const ctx = complete_marking_context();
397   assert(ctx-&gt;is_complete(), &quot;sanity&quot;);
398 
399   MarkBitMap* mark_bit_map = ctx-&gt;mark_bit_map();
400   HeapWord* tams = ctx-&gt;top_at_mark_start(region);
401 
<span class="line-modified">402   size_t skip_bitmap_delta = 1;</span>
<span class="line-modified">403   HeapWord* start = region-&gt;bottom();</span>
<span class="line-modified">404   HeapWord* end = MIN2(tams, region-&gt;end());</span>

405 
406   // Step 1. Scan below the TAMS based on bitmap data.
407   HeapWord* limit_bitmap = MIN2(limit, tams);
408 
409   // Try to scan the initial candidate. If the candidate is above the TAMS, it would
410   // fail the subsequent &quot;&lt; limit_bitmap&quot; checks, and fall through to Step 2.
411   HeapWord* cb = mark_bit_map-&gt;get_next_marked_addr(start, end);
412 
413   intx dist = ShenandoahMarkScanPrefetch;
414   if (dist &gt; 0) {
415     // Batched scan that prefetches the oop data, anticipating the access to
416     // either header, oop field, or forwarding pointer. Not that we cannot
417     // touch anything in oop, while it still being prefetched to get enough
418     // time for prefetch to work. This is why we try to scan the bitmap linearly,
419     // disregarding the object size. However, since we know forwarding pointer
420     // preceeds the object, we can skip over it. Once we cannot trust the bitmap,
421     // there is no point for prefetching the oop contents, as oop-&gt;size() will
422     // touch it prematurely.
423 
424     // No variable-length arrays in standard C++, have enough slots to fit
425     // the prefetch distance.
426     static const int SLOT_COUNT = 256;
427     guarantee(dist &lt;= SLOT_COUNT, &quot;adjust slot count&quot;);
428     HeapWord* slots[SLOT_COUNT];
429 
430     int avail;
431     do {
432       avail = 0;
433       for (int c = 0; (c &lt; dist) &amp;&amp; (cb &lt; limit_bitmap); c++) {
<span class="line-modified">434         Prefetch::read(cb, oopDesc::mark_offset_in_bytes());</span>
435         slots[avail++] = cb;
436         cb += skip_bitmap_delta;
437         if (cb &lt; limit_bitmap) {
438           cb = mark_bit_map-&gt;get_next_marked_addr(cb, limit_bitmap);
439         }
440       }
441 
442       for (int c = 0; c &lt; avail; c++) {
443         assert (slots[c] &lt; tams,  &quot;only objects below TAMS here: &quot;  PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(slots[c]), p2i(tams));
444         assert (slots[c] &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(slots[c]), p2i(limit));
445         oop obj = oop(slots[c]);
446         assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
447         assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
448         cl-&gt;do_object(obj);
449       }
450     } while (avail &gt; 0);
451   } else {
452     while (cb &lt; limit_bitmap) {
453       assert (cb &lt; tams,  &quot;only objects below TAMS here: &quot;  PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb), p2i(tams));
454       assert (cb &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cb), p2i(limit));
455       oop obj = oop(cb);
456       assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
457       assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
458       cl-&gt;do_object(obj);
459       cb += skip_bitmap_delta;
460       if (cb &lt; limit_bitmap) {
461         cb = mark_bit_map-&gt;get_next_marked_addr(cb, limit_bitmap);
462       }
463     }
464   }
465 
466   // Step 2. Accurate size-based traversal, happens past the TAMS.
467   // This restarts the scan at TAMS, which makes sure we traverse all objects,
468   // regardless of what happened at Step 1.
<span class="line-modified">469   HeapWord* cs = tams;</span>
470   while (cs &lt; limit) {
<span class="line-modified">471     assert (cs &gt;= tams, &quot;only objects past TAMS here: &quot;   PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(tams));</span>
472     assert (cs &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(limit));
473     oop obj = oop(cs);
474     assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
475     assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
476     int size = obj-&gt;size();
477     cl-&gt;do_object(obj);
<span class="line-modified">478     cs += size;</span>
479   }
480 }
481 
482 template &lt;class T&gt;
483 class ShenandoahObjectToOopClosure : public ObjectClosure {
484   T* _cl;
485 public:
486   ShenandoahObjectToOopClosure(T* cl) : _cl(cl) {}
487 
488   void do_object(oop obj) {
489     obj-&gt;oop_iterate(_cl);
490   }
491 };
492 
493 template &lt;class T&gt;
494 class ShenandoahObjectToOopBoundedClosure : public ObjectClosure {
495   T* _cl;
496   MemRegion _bounds;
497 public:
498   ShenandoahObjectToOopBoundedClosure(T* cl, HeapWord* bottom, HeapWord* top) :
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
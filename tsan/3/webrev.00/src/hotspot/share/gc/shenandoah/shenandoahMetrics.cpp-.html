<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shenandoah/shenandoahMetrics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 29 
 30 /*
 31  * Internal fragmentation metric: describes how fragmented the heap regions are.
 32  *
 33  * It is derived as:
 34  *
 35  *               sum(used[i]^2, i=0..k)
 36  *   IF = 1 - ------------------------------
 37  *              C * sum(used[i], i=0..k)
 38  *
 39  * ...where k is the number of regions in computation, C is the region capacity, and
 40  * used[i] is the used space in the region.
 41  *
 42  * The non-linearity causes IF to be lower for the cases where the same total heap
 43  * used is densely packed. For example:
 44  *   a) Heap is completely full  =&gt; IF = 0
 45  *   b) Heap is half full, first 50% regions are completely full =&gt; IF = 0
 46  *   c) Heap is half full, each region is 50% full =&gt; IF = 1/2
 47  *   d) Heap is quarter full, first 50% regions are completely full =&gt; IF = 0
 48  *   e) Heap is quarter full, each region is 25% full =&gt; IF = 3/4
 49  *   f) Heap has the small object per each region =&gt; IF =~ 1
 50  */
 51 double ShenandoahMetrics::internal_fragmentation() {
 52   ShenandoahHeap* heap = ShenandoahHeap::heap();
 53 
 54   double squared = 0;
 55   double linear = 0;
 56   int count = 0;
 57   for (size_t c = 0; c &lt; heap-&gt;num_regions(); c++) {
 58     ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 59     size_t used = r-&gt;used();
 60     squared += used * used;
 61     linear += used;
 62     count++;
 63   }
 64 
 65   if (count &gt; 0) {
 66     double s = squared / (ShenandoahHeapRegion::region_size_bytes() * linear);
 67     return 1 - s;
 68   } else {
 69     return 0;
 70   }
 71 }
 72 
 73 /*
 74  * External fragmentation metric: describes how fragmented the heap is.
 75  *
 76  * It is derived as:
 77  *
 78  *   EF = 1 - largest_contiguous_free / total_free
 79  *
 80  * For example:
 81  *   a) Heap is completely empty =&gt; EF = 0
 82  *   b) Heap is completely full =&gt; EF = 1
 83  *   c) Heap is first-half full =&gt; EF = 1/2
 84  *   d) Heap is half full, full and empty regions interleave =&gt; EF =~ 1
 85  */
 86 double ShenandoahMetrics::external_fragmentation() {
 87   ShenandoahHeap* heap = ShenandoahHeap::heap();
 88 
 89   size_t last_idx = 0;
 90   size_t max_contig = 0;
 91   size_t empty_contig = 0;
 92 
 93   size_t free = 0;
 94   for (size_t c = 0; c &lt; heap-&gt;num_regions(); c++) {
 95     ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 96 
 97     if (r-&gt;is_empty() &amp;&amp; (last_idx + 1 == c)) {
 98       empty_contig++;
 99     } else {
100       empty_contig = 0;
101     }
102 
103     free += r-&gt;free();
104     max_contig = MAX2(max_contig, empty_contig);
105     last_idx = c;
106   }
107 
108   if (free &gt; 0) {
109     return 1 - (1.0 * max_contig * ShenandoahHeapRegion::region_size_bytes() / free);
110   } else {
111     return 1;
112   }
113 }
114 
115 ShenandoahMetricsSnapshot::ShenandoahMetricsSnapshot() {
116   _heap = ShenandoahHeap::heap();
117 }
118 
119 void ShenandoahMetricsSnapshot::snap_before() {
120   _used_before = _heap-&gt;used();
121   _if_before = ShenandoahMetrics::internal_fragmentation();
122   _ef_before = ShenandoahMetrics::external_fragmentation();
123 }
124 void ShenandoahMetricsSnapshot::snap_after() {
125   _used_after = _heap-&gt;used();
126   _if_after = ShenandoahMetrics::internal_fragmentation();
127   _ef_after = ShenandoahMetrics::external_fragmentation();
128 }
129 
130 void ShenandoahMetricsSnapshot::print() {
131   log_info(gc, ergo)(&quot;Used: before: &quot; SIZE_FORMAT &quot;M, after: &quot; SIZE_FORMAT &quot;M&quot;, _used_before/M, _used_after/M);
132   log_info(gc, ergo)(&quot;Internal frag: before: %.1f%%, after: %.1f%%&quot;, _if_before * 100, _if_after * 100);
133   log_info(gc, ergo)(&quot;External frag: before: %.1f%%, after: %.1f%%&quot;, _ef_before * 100, _ef_after * 100);
134 }
135 
136 bool ShenandoahMetricsSnapshot::is_good_progress(const char *label) {
137   // Under the critical threshold? Declare failure.
138   size_t free_actual   = _heap-&gt;free_set()-&gt;available();
139   size_t free_expected = _heap-&gt;max_capacity() / 100 * ShenandoahCriticalFreeThreshold;
140   if (free_actual &lt; free_expected) {
141     log_info(gc, ergo)(&quot;Not enough free space (&quot; SIZE_FORMAT &quot;M, need &quot; SIZE_FORMAT &quot;M) after %s&quot;,
142                        free_actual / M, free_expected / M, label);
143     return false;
144   }
145 
146   // Freed up enough? Good! Declare victory.
147   size_t progress_actual   = (_used_before &gt; _used_after) ? _used_before - _used_after : 0;
148   size_t progress_expected = ShenandoahHeapRegion::region_size_bytes();
149   if (progress_actual &gt;= progress_expected) {
150     return true;
151   }
152   log_info(gc,ergo)(&quot;Not enough progress (&quot; SIZE_FORMAT &quot;M, need &quot; SIZE_FORMAT &quot;M) after %s&quot;,
153                     progress_actual / M, progress_expected / M, label);
154 
155   // Internal fragmentation is down? Good! Declare victory.
156   double if_actual = _if_before - _if_after;
157   double if_expected = 0.01; // 1% should be enough
158   if (if_actual &gt; if_expected) {
159     return true;
160   }
161   log_info(gc,ergo)(&quot;Not enough internal fragmentation improvement (%.1f%%, need %.1f%%) after %s&quot;,
162                     if_actual * 100, if_expected * 100, label);
163 
164   // External fragmentation is down? Good! Declare victory.
165   double ef_actual = _ef_before - _ef_after;
166   double ef_expected = 0.01; // 1% should be enough
167   if (ef_actual &gt; ef_expected) {
168     return true;
169   }
170   log_info(gc,ergo)(&quot;Not enough external fragmentation improvement (%.1f%%, need %.1f%%) after %s&quot;,
171                     if_actual * 100, if_expected * 100, label);
172 
173   // Nothing good had happened.
174   return false;
175 }
    </pre>
  </body>
</html>
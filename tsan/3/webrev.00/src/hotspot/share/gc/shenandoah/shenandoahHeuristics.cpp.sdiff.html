<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeapRegionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeuristics.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shared/gcCause.hpp&quot;
<span class="line-removed"> 27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 28 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logTag.hpp&quot;
 36 
 37 int ShenandoahHeuristics::compare_by_garbage(RegionData a, RegionData b) {
 38   if (a._garbage &gt; b._garbage)
 39     return -1;
 40   else if (a._garbage &lt; b._garbage)
 41     return 1;
 42   else return 0;
 43 }
 44 
 45 int ShenandoahHeuristics::compare_by_garbage_then_alloc_seq_ascending(RegionData a, RegionData b) {
 46   int r = compare_by_garbage(a, b);
 47   if (r != 0) {
</pre>
<hr />
<pre>
104 
105 ShenandoahHeuristics::RegionData* ShenandoahHeuristics::get_region_data_cache(size_t num) {
106   RegionData* res = _region_data;
107   if (res == NULL) {
108     res = NEW_C_HEAP_ARRAY(RegionData, num, mtGC);
109     _region_data = res;
110     _region_data_size = num;
111   } else if (_region_data_size &lt; num) {
112     res = REALLOC_C_HEAP_ARRAY(RegionData, _region_data, num, mtGC);
113     _region_data = res;
114     _region_data_size = num;
115   }
116   return res;
117 }
118 
119 void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
120   assert(collection_set-&gt;count() == 0, &quot;Must be empty&quot;);
121 
122   ShenandoahHeap* heap = ShenandoahHeap::heap();
123 



124   // Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.
125 
126   size_t num_regions = heap-&gt;num_regions();
127 
128   RegionData* candidates = get_region_data_cache(num_regions);
129 
130   size_t cand_idx = 0;
131 
132   size_t total_garbage = 0;
133 
134   size_t immediate_garbage = 0;
135   size_t immediate_regions = 0;
136 
137   size_t free = 0;
138   size_t free_regions = 0;
139 
140   ShenandoahMarkingContext* const ctx = heap-&gt;complete_marking_context();
141 
142   for (size_t i = 0; i &lt; num_regions; i++) {
143     ShenandoahHeapRegion* region = heap-&gt;get_region(i);
</pre>
<hr />
<pre>
147 
148     if (region-&gt;is_empty()) {
149       free_regions++;
150       free += ShenandoahHeapRegion::region_size_bytes();
151     } else if (region-&gt;is_regular()) {
152       if (!region-&gt;has_live()) {
153         // We can recycle it right away and put it in the free set.
154         immediate_regions++;
155         immediate_garbage += garbage;
156         region-&gt;make_trash_immediate();
157       } else {
158         // This is our candidate for later consideration.
159         candidates[cand_idx]._region = region;
160         candidates[cand_idx]._garbage = garbage;
161         cand_idx++;
162       }
163     } else if (region-&gt;is_humongous_start()) {
164       // Reclaim humongous regions here, and count them as the immediate garbage
165 #ifdef ASSERT
166       bool reg_live = region-&gt;has_live();
<span class="line-modified">167       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom() + ShenandoahBrooksPointer::word_size()));</span>
168       assert(reg_live == bm_live,
169              &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
170              BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
171 #endif
172       if (!region-&gt;has_live()) {
173         heap-&gt;trash_humongous_region_at(region);
174 
175         // Count only the start. Continuations would be counted on &quot;trash&quot; path
176         immediate_regions++;
177         immediate_garbage += garbage;
178       }
179     } else if (region-&gt;is_trash()) {
180       // Count in just trashed collection set, during coalesced CM-with-UR
181       immediate_regions++;
182       immediate_garbage += garbage;
183     }
184   }
185 
186   // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
187   // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
188 
189   assert (immediate_garbage &lt;= total_garbage,
<span class="line-modified">190           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;M vs &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-modified">191           immediate_garbage / M, total_garbage / M);</span>

192 
193   size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
194 
195   if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
196     choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
197     collection_set-&gt;update_region_status();
198 
199     size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<span class="line-modified">200     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;M CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">201                        collection_set-&gt;garbage() / M, cset_percent, collection_set-&gt;live_data() / M, collection_set-&gt;count());</span>



202   }
203 
<span class="line-modified">204   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">205                      immediate_garbage / M, immediate_percent, immediate_regions);</span>

206 }
207 
208 void ShenandoahHeuristics::record_gc_start() {
209   // Do nothing
210 }
211 
212 void ShenandoahHeuristics::record_gc_end() {
213   // Do nothing
214 }
215 
216 void ShenandoahHeuristics::record_cycle_start() {
217   _cycle_start = os::elapsedTime();
218 }
219 
220 void ShenandoahHeuristics::record_cycle_end() {
221   _last_cycle_end = os::elapsedTime();
222 }
223 
224 void ShenandoahHeuristics::record_phase_time(ShenandoahPhaseTimings::Phase phase, double secs) {
225   // Do nothing
226 }
227 
228 bool ShenandoahHeuristics::should_start_update_refs() {
229   return _update_refs_early;
230 }
231 
<span class="line-modified">232 bool ShenandoahHeuristics::should_start_normal_gc() const {</span>
233   // Perform GC to cleanup metaspace
234   if (has_metaspace_oom()) {
235     // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
236     log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
237     return true;
238   }
239 
<span class="line-modified">240   double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">241   bool periodic_gc = (last_time_ms &gt; ShenandoahGuaranteedGCInterval);</span>
<span class="line-modified">242   if (periodic_gc) {</span>
<span class="line-modified">243     log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">244                   last_time_ms, ShenandoahGuaranteedGCInterval);</span>


245   }
<span class="line-removed">246   return periodic_gc;</span>
<span class="line-removed">247 }</span>
<span class="line-removed">248 </span>
<span class="line-removed">249 bool ShenandoahHeuristics::should_start_traversal_gc() {</span>
<span class="line-removed">250   return false;</span>
<span class="line-removed">251 }</span>
252 
<span class="line-removed">253 bool ShenandoahHeuristics::can_do_traversal_gc() {</span>
254   return false;
255 }
256 
257 bool ShenandoahHeuristics::should_degenerate_cycle() {
258   return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
259 }
260 
261 void ShenandoahHeuristics::record_success_concurrent() {
262   _degenerated_cycles_in_a_row = 0;
263   _successful_cycles_in_a_row++;
264 
265   _gc_time_history-&gt;add(time_since_last_gc());
266   _gc_times_learned++;
267   _gc_time_penalties -= MIN2&lt;size_t&gt;(_gc_time_penalties, Concurrent_Adjust);
268 }
269 
270 void ShenandoahHeuristics::record_success_degenerated() {
271   _degenerated_cycles_in_a_row++;
272   _successful_cycles_in_a_row = 0;
273   _gc_time_penalties += Degenerated_Penalty;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;gc/shared/gcCause.hpp&quot;

 28 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;logging/logTag.hpp&quot;
 36 
 37 int ShenandoahHeuristics::compare_by_garbage(RegionData a, RegionData b) {
 38   if (a._garbage &gt; b._garbage)
 39     return -1;
 40   else if (a._garbage &lt; b._garbage)
 41     return 1;
 42   else return 0;
 43 }
 44 
 45 int ShenandoahHeuristics::compare_by_garbage_then_alloc_seq_ascending(RegionData a, RegionData b) {
 46   int r = compare_by_garbage(a, b);
 47   if (r != 0) {
</pre>
<hr />
<pre>
104 
105 ShenandoahHeuristics::RegionData* ShenandoahHeuristics::get_region_data_cache(size_t num) {
106   RegionData* res = _region_data;
107   if (res == NULL) {
108     res = NEW_C_HEAP_ARRAY(RegionData, num, mtGC);
109     _region_data = res;
110     _region_data_size = num;
111   } else if (_region_data_size &lt; num) {
112     res = REALLOC_C_HEAP_ARRAY(RegionData, _region_data, num, mtGC);
113     _region_data = res;
114     _region_data_size = num;
115   }
116   return res;
117 }
118 
119 void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
120   assert(collection_set-&gt;count() == 0, &quot;Must be empty&quot;);
121 
122   ShenandoahHeap* heap = ShenandoahHeap::heap();
123 
<span class="line-added">124   // Check all pinned regions have updated status before choosing the collection set.</span>
<span class="line-added">125   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">126 </span>
127   // Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.
128 
129   size_t num_regions = heap-&gt;num_regions();
130 
131   RegionData* candidates = get_region_data_cache(num_regions);
132 
133   size_t cand_idx = 0;
134 
135   size_t total_garbage = 0;
136 
137   size_t immediate_garbage = 0;
138   size_t immediate_regions = 0;
139 
140   size_t free = 0;
141   size_t free_regions = 0;
142 
143   ShenandoahMarkingContext* const ctx = heap-&gt;complete_marking_context();
144 
145   for (size_t i = 0; i &lt; num_regions; i++) {
146     ShenandoahHeapRegion* region = heap-&gt;get_region(i);
</pre>
<hr />
<pre>
150 
151     if (region-&gt;is_empty()) {
152       free_regions++;
153       free += ShenandoahHeapRegion::region_size_bytes();
154     } else if (region-&gt;is_regular()) {
155       if (!region-&gt;has_live()) {
156         // We can recycle it right away and put it in the free set.
157         immediate_regions++;
158         immediate_garbage += garbage;
159         region-&gt;make_trash_immediate();
160       } else {
161         // This is our candidate for later consideration.
162         candidates[cand_idx]._region = region;
163         candidates[cand_idx]._garbage = garbage;
164         cand_idx++;
165       }
166     } else if (region-&gt;is_humongous_start()) {
167       // Reclaim humongous regions here, and count them as the immediate garbage
168 #ifdef ASSERT
169       bool reg_live = region-&gt;has_live();
<span class="line-modified">170       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom()));</span>
171       assert(reg_live == bm_live,
172              &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
173              BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
174 #endif
175       if (!region-&gt;has_live()) {
176         heap-&gt;trash_humongous_region_at(region);
177 
178         // Count only the start. Continuations would be counted on &quot;trash&quot; path
179         immediate_regions++;
180         immediate_garbage += garbage;
181       }
182     } else if (region-&gt;is_trash()) {
183       // Count in just trashed collection set, during coalesced CM-with-UR
184       immediate_regions++;
185       immediate_garbage += garbage;
186     }
187   }
188 
189   // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
190   // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
191 
192   assert (immediate_garbage &lt;= total_garbage,
<span class="line-modified">193           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;%s vs &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">194           byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">195           byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));</span>
196 
197   size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
198 
199   if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
200     choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
201     collection_set-&gt;update_region_status();
202 
203     size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<span class="line-modified">204     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;%s CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">205                        byte_size_in_proper_unit(collection_set-&gt;garbage()),   proper_unit_for_byte_size(collection_set-&gt;garbage()),</span>
<span class="line-added">206                        cset_percent,</span>
<span class="line-added">207                        byte_size_in_proper_unit(collection_set-&gt;live_data()), proper_unit_for_byte_size(collection_set-&gt;live_data()),</span>
<span class="line-added">208                        collection_set-&gt;count());</span>
209   }
210 
<span class="line-modified">211   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">212                      byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">213                      immediate_percent, immediate_regions);</span>
214 }
215 
216 void ShenandoahHeuristics::record_gc_start() {
217   // Do nothing
218 }
219 
220 void ShenandoahHeuristics::record_gc_end() {
221   // Do nothing
222 }
223 
224 void ShenandoahHeuristics::record_cycle_start() {
225   _cycle_start = os::elapsedTime();
226 }
227 
228 void ShenandoahHeuristics::record_cycle_end() {
229   _last_cycle_end = os::elapsedTime();
230 }
231 
232 void ShenandoahHeuristics::record_phase_time(ShenandoahPhaseTimings::Phase phase, double secs) {
233   // Do nothing
234 }
235 
236 bool ShenandoahHeuristics::should_start_update_refs() {
237   return _update_refs_early;
238 }
239 
<span class="line-modified">240 bool ShenandoahHeuristics::should_start_gc() const {</span>
241   // Perform GC to cleanup metaspace
242   if (has_metaspace_oom()) {
243     // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
244     log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
245     return true;
246   }
247 
<span class="line-modified">248   if (ShenandoahGuaranteedGCInterval &gt; 0) {</span>
<span class="line-modified">249     double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">250     if (last_time_ms &gt; ShenandoahGuaranteedGCInterval) {</span>
<span class="line-modified">251       log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">252                    last_time_ms, ShenandoahGuaranteedGCInterval);</span>
<span class="line-added">253       return true;</span>
<span class="line-added">254     }</span>
255   }






256 

257   return false;
258 }
259 
260 bool ShenandoahHeuristics::should_degenerate_cycle() {
261   return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
262 }
263 
264 void ShenandoahHeuristics::record_success_concurrent() {
265   _degenerated_cycles_in_a_row = 0;
266   _successful_cycles_in_a_row++;
267 
268   _gc_time_history-&gt;add(time_since_last_gc());
269   _gc_times_learned++;
270   _gc_time_penalties -= MIN2&lt;size_t&gt;(_gc_time_penalties, Concurrent_Adjust);
271 }
272 
273 void ShenandoahHeuristics::record_success_degenerated() {
274   _degenerated_cycles_in_a_row++;
275   _successful_cycles_in_a_row = 0;
276   _gc_time_penalties += Degenerated_Penalty;
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeapRegionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeuristics.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTaskqueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTaskqueue.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,13 ***</span>
   *
   */
  
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<span class="line-modified">! #include &quot;gc/shared/owstTaskTerminator.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  
  template&lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
  class BufferedOverflowTaskQueue: public OverflowTaskQueue&lt;E, F, N&gt;
<span class="line-new-header">--- 22,15 ---</span>
   *
   */
  
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<span class="line-modified">! </span>
<span class="line-added">+ #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  
  template&lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
  class BufferedOverflowTaskQueue: public OverflowTaskQueue&lt;E, F, N&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,47 ***</span>
  // In future, these might be rebalanced to favor one degree of freedom against another. For example,
  // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
  // some bits back if chunks are counted in ObjArrayMarkingStride units.
  //
  // There is also a fallback version that uses plain fields, when we don&#39;t have enough space to steal the
<span class="line-modified">! // bits from the native pointer. It is useful to debug the _LP64 version.</span>
  //
  
  #ifdef _MSC_VER
  #pragma warning(push)
  // warning C4522: multiple assignment operators specified
  #pragma warning( disable:4522 )
  #endif
  
  #ifdef _LP64
  class ObjArrayChunkedTask
  {
  public:
    enum {
      chunk_bits   = 10,
      pow_bits     = 5,
<span class="line-modified">!     oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits,</span>
    };
    enum {
      oop_shift    = 0,
      pow_shift    = oop_shift + oop_bits,
<span class="line-modified">!     chunk_shift  = pow_shift + pow_bits,</span>
    };
  
  public:
    ObjArrayChunkedTask(oop o = NULL) {
<span class="line-modified">!     _obj = ((uintptr_t)(void*) o) &lt;&lt; oop_shift;</span>
    }
<span class="line-modified">!   ObjArrayChunkedTask(oop o, int chunk, int mult) {</span>
<span class="line-modified">!     assert(0 &lt;= chunk &amp;&amp; chunk &lt; nth_bit(chunk_bits), &quot;chunk is sane: %d&quot;, chunk);</span>
<span class="line-modified">!     assert(0 &lt;= mult &amp;&amp; mult &lt; nth_bit(pow_bits), &quot;pow is sane: %d&quot;, mult);</span>
<span class="line-modified">!     uintptr_t t_b = ((uintptr_t) chunk) &lt;&lt; chunk_shift;</span>
<span class="line-modified">!     uintptr_t t_m = ((uintptr_t) mult) &lt;&lt; pow_shift;</span>
<span class="line-removed">-     uintptr_t obj = (uintptr_t)(void*)o;</span>
<span class="line-removed">-     assert(obj &lt; nth_bit(oop_bits), &quot;obj ref is sane: &quot; PTR_FORMAT, obj);</span>
<span class="line-removed">-     intptr_t t_o = obj &lt;&lt; oop_shift;</span>
<span class="line-removed">-     _obj = t_o | t_m | t_b;</span>
    }
    ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj) { }
  
    ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
      _obj = t._obj;
<span class="line-new-header">--- 110,50 ---</span>
  // In future, these might be rebalanced to favor one degree of freedom against another. For example,
  // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
  // some bits back if chunks are counted in ObjArrayMarkingStride units.
  //
  // There is also a fallback version that uses plain fields, when we don&#39;t have enough space to steal the
<span class="line-modified">! // bits from the native pointer. It is useful to debug the optimized version.</span>
  //
  
  #ifdef _MSC_VER
  #pragma warning(push)
  // warning C4522: multiple assignment operators specified
  #pragma warning( disable:4522 )
  #endif
  
  #ifdef _LP64
<span class="line-added">+ #define SHENANDOAH_OPTIMIZED_OBJTASK 1</span>
<span class="line-added">+ #else</span>
<span class="line-added">+ #define SHENANDOAH_OPTIMIZED_OBJTASK 0</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if SHENANDOAH_OPTIMIZED_OBJTASK</span>
  class ObjArrayChunkedTask
  {
  public:
    enum {
      chunk_bits   = 10,
      pow_bits     = 5,
<span class="line-modified">!     oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits</span>
    };
    enum {
      oop_shift    = 0,
      pow_shift    = oop_shift + oop_bits,
<span class="line-modified">!     chunk_shift  = pow_shift + pow_bits</span>
    };
  
  public:
    ObjArrayChunkedTask(oop o = NULL) {
<span class="line-modified">!     assert(decode_oop(encode_oop(o)) ==  o, &quot;oop can be encoded: &quot; PTR_FORMAT, p2i(o));</span>
<span class="line-added">+     _obj = encode_oop(o);</span>
    }
<span class="line-modified">!   ObjArrayChunkedTask(oop o, int chunk, int pow) {</span>
<span class="line-modified">!     assert(decode_oop(encode_oop(o)) == o, &quot;oop can be encoded: &quot; PTR_FORMAT, p2i(o));</span>
<span class="line-modified">!     assert(decode_chunk(encode_chunk(chunk)) == chunk, &quot;chunk can be encoded: %d&quot;, chunk);</span>
<span class="line-modified">!     assert(decode_pow(encode_pow(pow)) == pow, &quot;pow can be encoded: %d&quot;, pow);</span>
<span class="line-modified">!     _obj = encode_oop(o) | encode_chunk(chunk) | encode_pow(pow);</span>
    }
    ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj) { }
  
    ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
      _obj = t._obj;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,18 ***</span>
    operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
      (void)const_cast&lt;uintptr_t&amp;&gt;(_obj = t._obj);
      return *this;
    }
  
<span class="line-modified">!   inline oop obj()   const { return (oop) reinterpret_cast&lt;void*&gt;((_obj &gt;&gt; oop_shift) &amp; right_n_bits(oop_bits)); }</span>
<span class="line-modified">!   inline int chunk() const { return (int) (_obj &gt;&gt; chunk_shift) &amp; right_n_bits(chunk_bits); }</span>
<span class="line-modified">!   inline int pow()   const { return (int) ((_obj &gt;&gt; pow_shift) &amp; right_n_bits(pow_bits)); }</span>
    inline bool is_not_chunked() const { return (_obj &amp; ~right_n_bits(oop_bits + pow_bits)) == 0; }
  
    DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
  
<span class="line-modified">!   static size_t max_addressable() {</span>
      return nth_bit(oop_bits);
    }
  
    static int chunk_size() {
      return nth_bit(chunk_bits);
<span class="line-new-header">--- 163,42 ---</span>
    operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
      (void)const_cast&lt;uintptr_t&amp;&gt;(_obj = t._obj);
      return *this;
    }
  
<span class="line-modified">!   inline oop decode_oop(uintptr_t val) const {</span>
<span class="line-modified">!     return (oop) reinterpret_cast&lt;void*&gt;((val &gt;&gt; oop_shift) &amp; right_n_bits(oop_bits));</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline int decode_chunk(uintptr_t val) const {</span>
<span class="line-added">+     return (int) ((val &gt;&gt; chunk_shift) &amp; right_n_bits(chunk_bits));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline int decode_pow(uintptr_t val) const {</span>
<span class="line-added">+     return (int) ((val &gt;&gt; pow_shift) &amp; right_n_bits(pow_bits));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline uintptr_t encode_oop(oop obj) const {</span>
<span class="line-added">+     return ((uintptr_t)(void*) obj) &lt;&lt; oop_shift;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline uintptr_t encode_chunk(int chunk) const {</span>
<span class="line-added">+     return ((uintptr_t) chunk) &lt;&lt; chunk_shift;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline uintptr_t encode_pow(int pow) const {</span>
<span class="line-added">+     return ((uintptr_t) pow) &lt;&lt; pow_shift;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline oop obj()   const { return decode_oop(_obj);   }</span>
<span class="line-added">+   inline int chunk() const { return decode_chunk(_obj); }</span>
<span class="line-added">+   inline int pow()   const { return decode_pow(_obj);   }</span>
    inline bool is_not_chunked() const { return (_obj &amp; ~right_n_bits(oop_bits + pow_bits)) == 0; }
  
    DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
  
<span class="line-modified">!   static uintptr_t max_addressable() {</span>
      return nth_bit(oop_bits);
    }
  
    static int chunk_size() {
      return nth_bit(chunk_bits);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,11 ***</span>
  private:
    oop _obj;
    int _chunk;
    int _pow;
  };
<span class="line-modified">! #endif</span>
  
  #ifdef _MSC_VER
  #pragma warning(pop)
  #endif
  
<span class="line-new-header">--- 257,11 ---</span>
  private:
    oop _obj;
    int _chunk;
    int _pow;
  };
<span class="line-modified">! #endif // SHENANDOAH_OPTIMIZED_OBJTASK</span>
  
  #ifdef _MSC_VER
  #pragma warning(pop)
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
  
    if (_claimed_index &gt;= size) {
      return NULL;
    }
  
<span class="line-modified">!   jint index = Atomic::add(1, &amp;_claimed_index);</span>
  
    if (index &lt;= size) {
      return GenericTaskQueueSet&lt;T, F&gt;::queue((uint)index - 1);
    } else {
      return NULL;
<span class="line-new-header">--- 305,11 ---</span>
  
    if (_claimed_index &gt;= size) {
      return NULL;
    }
  
<span class="line-modified">!   jint index = Atomic::add(&amp;_claimed_index, 1);</span>
  
    if (index &lt;= size) {
      return GenericTaskQueueSet&lt;T, F&gt;::queue((uint)index - 1);
    } else {
      return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,21 ***</span>
    ShenandoahTerminatorTerminator(ShenandoahHeap* const heap) : _heap(heap) { }
    // return true, terminates immediately, even if there&#39;s remaining work left
    virtual bool should_exit_termination() { return _heap-&gt;cancelled_gc(); }
  };
  
<span class="line-removed">- class ShenandoahTaskTerminator : public StackObj {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   OWSTTaskTerminator* const   _terminator;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahTaskTerminator(uint n_threads, TaskQueueSetSuper* queue_set);</span>
<span class="line-removed">-   ~ShenandoahTaskTerminator();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool offer_termination(ShenandoahTerminatorTerminator* terminator) {</span>
<span class="line-removed">-     return _terminator-&gt;offer_termination(terminator);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void reset_for_reuse() { _terminator-&gt;reset_for_reuse(); }</span>
<span class="line-removed">-   bool offer_termination() { return offer_termination((ShenandoahTerminatorTerminator*)NULL); }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<span class="line-new-header">--- 337,6 ---</span>
</pre>
<center><a href="shenandoahTaskqueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTaskqueue.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
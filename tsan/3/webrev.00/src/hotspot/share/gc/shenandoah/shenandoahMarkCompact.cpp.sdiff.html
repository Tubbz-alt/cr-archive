<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeuristics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>

 29 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;

 30 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-modified"> 38 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
 39 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
 44 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
 45 #include &quot;memory/metaspace.hpp&quot;


 46 #include &quot;oops/oop.inline.hpp&quot;


 47 #include &quot;runtime/thread.hpp&quot;
 48 #include &quot;utilities/copy.hpp&quot;
 49 #include &quot;utilities/growableArray.hpp&quot;
 50 #include &quot;gc/shared/workgroup.hpp&quot;
 51 




 52 void ShenandoahMarkCompact::initialize(GCTimer* gc_timer) {
 53   _gc_timer = gc_timer;
 54 }
 55 
 56 void ShenandoahMarkCompact::do_it(GCCause::Cause gc_cause) {
 57   ShenandoahHeap* heap = ShenandoahHeap::heap();
 58 
 59   if (ShenandoahVerify) {
 60     heap-&gt;verifier()-&gt;verify_before_fullgc();
 61   }
 62 
 63   if (VerifyBeforeGC) {
 64     Universe::verify();
 65   }
 66 






 67   heap-&gt;set_full_gc_in_progress(true);
 68 
 69   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at a safepoint&quot;);
 70   assert(Thread::current()-&gt;is_VM_thread(), &quot;Do full GC only while world is stopped&quot;);
 71 
 72   {
 73     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 74     heap-&gt;pre_full_gc_dump(_gc_timer);
 75   }
 76 
 77   {
 78     ShenandoahGCPhase prepare_phase(ShenandoahPhaseTimings::full_gc_prepare);
 79     // Full GC is supposed to recover from any GC state:
 80 
 81     // a0. Remember if we have forwarded objects
 82     bool has_forwarded_objects = heap-&gt;has_forwarded_objects();
 83 
 84     // a1. Cancel evacuation, if in progress
 85     if (heap-&gt;is_evacuation_in_progress()) {
 86       heap-&gt;set_evacuation_in_progress(false);
 87     }
 88     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 89 
 90     // a2. Cancel update-refs, if in progress
 91     if (heap-&gt;is_update_refs_in_progress()) {
 92       heap-&gt;set_update_refs_in_progress(false);
 93     }
 94     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 95 
 96     // a3. Cancel concurrent traversal GC, if in progress
 97     if (heap-&gt;is_concurrent_traversal_in_progress()) {
 98       heap-&gt;traversal_gc()-&gt;reset();
 99       heap-&gt;set_concurrent_traversal_in_progress(false);
100     }
101 
102     // b. Cancel concurrent mark, if in progress
103     if (heap-&gt;is_concurrent_mark_in_progress()) {
104       heap-&gt;concurrent_mark()-&gt;cancel();
<span class="line-modified">105       heap-&gt;stop_concurrent_marking();</span>
106     }
107     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
108 
109     // c. Reset the bitmaps for new marking
110     heap-&gt;reset_mark_bitmap();
111     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
112     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
113 
114     // d. Abandon reference discovery and clear all discovered references.
115     ReferenceProcessor* rp = heap-&gt;ref_processor();
116     rp-&gt;disable_discovery();
117     rp-&gt;abandon_partial_discovery();
118     rp-&gt;verify_no_references_recorded();
119 
120     // e. Set back forwarded objects bit back, in case some steps above dropped it.
121     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);







122   }
123 
124   heap-&gt;make_parsable(true);
125 
126   OrderAccess::fence();
127 
128   phase1_mark_heap();
129 
130   // Once marking is done, which may have fixed up forwarded objects, we can drop it.
131   // Coming out of Full GC, we would not have any forwarded objects.
<span class="line-modified">132   // This also prevents read barrier from kicking in while adjusting pointers in phase3.</span>
133   heap-&gt;set_has_forwarded_objects(false);
134 
135   heap-&gt;set_full_gc_move_in_progress(true);
136 
137   // Setup workers for the rest
138   OrderAccess::fence();
139 
140   // Initialize worker slices
141   ShenandoahHeapRegionSet** worker_slices = NEW_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, heap-&gt;max_workers(), mtGC);
142   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
143     worker_slices[i] = new ShenandoahHeapRegionSet();
144   }
145 
146   {
147     // The rest of code performs region moves, where region status is undefined
148     // until all phases run together.
149     ShenandoahHeapLocker lock(heap-&gt;lock());
150 
151     phase2_calculate_target_addresses(worker_slices);
152 
153     OrderAccess::fence();
154 
155     phase3_update_references();
156 
157     phase4_compact_objects(worker_slices);
158   }
159 







160   // Resize metaspace
161   MetaspaceGC::compute_new_size();
162 
163   // Free worker slices
164   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
165     delete worker_slices[i];
166   }
167   FREE_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, worker_slices);
168 
<span class="line-removed">169   JvmtiExport::gc_epilogue();</span>
<span class="line-removed">170 </span>
171   heap-&gt;set_full_gc_move_in_progress(false);
172   heap-&gt;set_full_gc_in_progress(false);
173 
174   if (ShenandoahVerify) {
175     heap-&gt;verifier()-&gt;verify_after_fullgc();
176   }
177 
178   if (VerifyAfterGC) {
179     Universe::verify();
180   }
181 
182   {
183     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
184     heap-&gt;post_full_gc_dump(_gc_timer);
185   }
186 }
187 
188 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
189 private:
190   ShenandoahMarkingContext* const _ctx;
</pre>
<hr />
<pre>
205 
206   ShenandoahHeap* heap = ShenandoahHeap::heap();
207 
208   ShenandoahPrepareForMarkClosure cl;
209   heap-&gt;heap_region_iterate(&amp;cl);
210 
211   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
212 
213   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
214   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
215 
216   ReferenceProcessor* rp = heap-&gt;ref_processor();
217   // enable (&quot;weak&quot;) refs discovery
218   rp-&gt;enable_discovery(true /*verify_no_refs*/);
219   rp-&gt;setup_policy(true); // forcefully purge all soft references
220   rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
221 
222   cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_roots);
223   cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_roots);
224   cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
<span class="line-removed">225 </span>
226   heap-&gt;mark_complete_marking_context();

227 }
228 
229 class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
230 private:

231   ShenandoahHeap*          const _heap;
232   GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
233   int _empty_regions_pos;
234   ShenandoahHeapRegion*          _to_region;
235   ShenandoahHeapRegion*          _from_region;
236   HeapWord* _compact_point;
237 
238 public:
<span class="line-modified">239   ShenandoahPrepareForCompactionObjectClosure(GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions, ShenandoahHeapRegion* to_region) :</span>



240     _heap(ShenandoahHeap::heap()),
241     _empty_regions(empty_regions),
242     _empty_regions_pos(0),
243     _to_region(to_region),
244     _from_region(NULL),
245     _compact_point(to_region-&gt;bottom()) {}
246 
247   void set_from_region(ShenandoahHeapRegion* from_region) {
248     _from_region = from_region;
249   }
250 
251   void finish_region() {
252     assert(_to_region != NULL, &quot;should not happen&quot;);
253     _to_region-&gt;set_new_top(_compact_point);
254   }
255 
256   bool is_compact_same_region() {
257     return _from_region == _to_region;
258   }
259 
260   int empty_regions_pos() {
261     return _empty_regions_pos;
262   }
263 
264   void do_object(oop p) {
265     assert(_from_region != NULL, &quot;must set before work&quot;);
266     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-modified">267     assert(!_heap-&gt;complete_marking_context()-&gt;allocated_after_mark_start((HeapWord*) p), &quot;must be truly marked&quot;);</span>
268 
<span class="line-modified">269     size_t obj_size = p-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
270     if (_compact_point + obj_size &gt; _to_region-&gt;end()) {
271       finish_region();
272 
273       // Object doesn&#39;t fit. Pick next empty region and start compacting there.
274       ShenandoahHeapRegion* new_to_region;
275       if (_empty_regions_pos &lt; _empty_regions.length()) {
276         new_to_region = _empty_regions.at(_empty_regions_pos);
277         _empty_regions_pos++;
278       } else {
279         // Out of empty region? Compact within the same region.
280         new_to_region = _from_region;
281       }
282 
283       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
284       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
285       _to_region = new_to_region;
286       _compact_point = _to_region-&gt;bottom();
287     }
288 
289     // Object fits into current region, record new location:
290     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
291     shenandoah_assert_not_forwarded(NULL, p);
<span class="line-modified">292     ShenandoahBrooksPointer::set_raw(p, _compact_point + ShenandoahBrooksPointer::word_size());</span>

293     _compact_point += obj_size;
294   }
295 };
296 
297 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
298 private:

299   ShenandoahHeap*           const _heap;
300   ShenandoahHeapRegionSet** const _worker_slices;
301   ShenandoahRegionIterator        _heap_regions;
302 
303   ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {
304     ShenandoahHeapRegion* from_region = _heap_regions.next();
305 
<span class="line-modified">306     while (from_region != NULL &amp;&amp; (!from_region-&gt;is_move_allowed() || from_region-&gt;is_humongous())) {</span>











307       from_region = _heap_regions.next();
308     }
309 
310     if (from_region != NULL) {
311       assert(slice != NULL, &quot;sanity&quot;);
312       assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);
<span class="line-modified">313       assert(from_region-&gt;is_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
314       slice-&gt;add_region(from_region);
315     }
316 
317     return from_region;
318   }
319 
320 public:
<span class="line-modified">321   ShenandoahPrepareForCompactionTask(ShenandoahHeapRegionSet** worker_slices) :</span>
322     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),

323     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
324   }
325 
326   void work(uint worker_id) {
327     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
328     ShenandoahHeapRegion* from_region = next_from_region(slice);
329     // No work?
330     if (from_region == NULL) {
331       return;
332     }
333 
334     // Sliding compaction. Walk all regions in the slice, and compact them.
335     // Remember empty regions and reuse them as needed.
336     ResourceMark rm;
337     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-modified">338     ShenandoahPrepareForCompactionObjectClosure cl(empty_regions, from_region);</span>
339     while (from_region != NULL) {
340       cl.set_from_region(from_region);
341       if (from_region-&gt;has_live()) {
342         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
343       }
344 
345       // Compacted the region to somewhere else? From-region is empty then.
346       if (!cl.is_compact_same_region()) {
347         empty_regions.append(from_region);
348       }
349       from_region = next_from_region(slice);
350     }
351     cl.finish_region();
352 
353     // Mark all remaining regions as empty
354     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
355       ShenandoahHeapRegion* r = empty_regions.at(pos);
356       r-&gt;set_new_top(r-&gt;bottom());
357     }
358   }
359 };
360 
361 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
362   ShenandoahHeap* heap = ShenandoahHeap::heap();
363 
364   // Compute the new addresses for humongous objects. We need to do this after addresses
365   // for regular objects are calculated, and we know what regions in heap suffix are
366   // available for humongous moves.
367   //
368   // Scan the heap backwards, because we are compacting humongous regions towards the end.
369   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
370   // humongous start there.
371   //
372   // The complication is potential non-movable regions during the scan. If such region is
373   // detected, then sliding restarts towards that non-movable region.
374 
375   size_t to_begin = heap-&gt;num_regions();
376   size_t to_end = heap-&gt;num_regions();
377 
<span class="line-modified">378   for (size_t c = heap-&gt;num_regions() - 1; c &gt; 0; c--) {</span>
<span class="line-modified">379     ShenandoahHeapRegion *r = heap-&gt;get_region(c);</span>
380     if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
381       // To-region candidate: record this, and continue scan
382       to_begin = r-&gt;region_number();
383       continue;
384     }
385 
<span class="line-modified">386     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_move_allowed()) {</span>
387       // From-region candidate: movable humongous region
<span class="line-modified">388       oop old_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">389       size_t words_size = old_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
390       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
391 
392       size_t start = to_end - num_regions;
393 
394       if (start &gt;= to_begin &amp;&amp; start != r-&gt;region_number()) {
395         // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
<span class="line-modified">396         ShenandoahBrooksPointer::set_raw(old_obj, heap-&gt;get_region(start)-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>

397         to_end = start;
398         continue;
399       }
400     }
401 
402     // Failed to fit. Scan starting from current region.
403     to_begin = r-&gt;region_number();
404     to_end = r-&gt;region_number();
405   }
406 }
407 
408 class ShenandoahEnsureHeapActiveClosure: public ShenandoahHeapRegionClosure {
409 private:
410   ShenandoahHeap* const _heap;
411 
412 public:
413   ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}
414   void heap_region_do(ShenandoahHeapRegion* r) {
415     if (r-&gt;is_trash()) {
416       r-&gt;recycle();
</pre>
<hr />
<pre>
424     assert (r-&gt;is_committed(), &quot;only committed regions in heap now, see region &quot; SIZE_FORMAT, r-&gt;region_number());
425 
426     // Record current region occupancy: this communicates empty regions are free
427     // to the rest of Full GC code.
428     r-&gt;set_new_top(r-&gt;top());
429   }
430 };
431 
432 class ShenandoahTrashImmediateGarbageClosure: public ShenandoahHeapRegionClosure {
433 private:
434   ShenandoahHeap* const _heap;
435   ShenandoahMarkingContext* const _ctx;
436 
437 public:
438   ShenandoahTrashImmediateGarbageClosure() :
439     _heap(ShenandoahHeap::heap()),
440     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
441 
442   void heap_region_do(ShenandoahHeapRegion* r) {
443     if (r-&gt;is_humongous_start()) {
<span class="line-modified">444       oop humongous_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
445       if (!_ctx-&gt;is_marked(humongous_obj)) {
446         assert(!r-&gt;has_live(),
447                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
448         _heap-&gt;trash_humongous_region_at(r);
449       } else {
450         assert(r-&gt;has_live(),
451                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
452       }
453     } else if (r-&gt;is_humongous_continuation()) {
454       // If we hit continuation, the non-live humongous starts should have been trashed already
455       assert(r-&gt;humongous_start_region()-&gt;has_live(),
456              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
457     } else if (r-&gt;is_regular()) {
458       if (!r-&gt;has_live()) {
459         r-&gt;make_trash_immediate();
460       }
461     }
462   }
463 };
464 
465 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
466   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
467   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
468 
469   ShenandoahHeap* heap = ShenandoahHeap::heap();
470 




471   {
472     // Trash the immediately collectible regions before computing addresses
473     ShenandoahTrashImmediateGarbageClosure tigcl;
474     heap-&gt;heap_region_iterate(&amp;tigcl);
475 
476     // Make sure regions are in good state: committed, active, clean.
477     // This is needed because we are potentially sliding the data through them.
478     ShenandoahEnsureHeapActiveClosure ecl;
479     heap-&gt;heap_region_iterate(&amp;ecl);
480   }
481 
482   // Compute the new addresses for regular objects
483   {
484     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified">485     ShenandoahPrepareForCompactionTask prepare_task(worker_slices);</span>
486     heap-&gt;workers()-&gt;run_task(&amp;prepare_task);
487   }
488 
489   // Compute the new addresses for humongous objects
490   {
491     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
492     calculate_target_humongous_objects();
493   }
494 }
495 
496 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
497 private:
498   ShenandoahHeap* const _heap;
499   ShenandoahMarkingContext* const _ctx;
500 
501   template &lt;class T&gt;
502   inline void do_oop_work(T* p) {
503     T o = RawAccess&lt;&gt;::oop_load(p);
504     if (!CompressedOops::is_null(o)) {
505       oop obj = CompressedOops::decode_not_null(o);
506       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
<span class="line-modified">507       oop forw = oop(ShenandoahBrooksPointer::get_raw(obj));</span>
<span class="line-modified">508       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);</span>


509     }
510   }
511 
512 public:
513   ShenandoahAdjustPointersClosure() :
514     _heap(ShenandoahHeap::heap()),
515     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
516 
517   void do_oop(oop* p)       { do_oop_work(p); }
518   void do_oop(narrowOop* p) { do_oop_work(p); }
519 };
520 
521 class ShenandoahAdjustPointersObjectClosure : public ObjectClosure {
522 private:
523   ShenandoahHeap* const _heap;
524   ShenandoahAdjustPointersClosure _cl;
525 
526 public:
527   ShenandoahAdjustPointersObjectClosure() :
528     _heap(ShenandoahHeap::heap()) {
529   }
530   void do_object(oop p) {
531     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-removed">532     HeapWord* forw = ShenandoahBrooksPointer::get_raw(p);</span>
533     p-&gt;oop_iterate(&amp;_cl);
534   }
535 };
536 
537 class ShenandoahAdjustPointersTask : public AbstractGangTask {
538 private:
539   ShenandoahHeap*          const _heap;
540   ShenandoahRegionIterator       _regions;
541 
542 public:
543   ShenandoahAdjustPointersTask() :
544     AbstractGangTask(&quot;Shenandoah Adjust Pointers Task&quot;),
545     _heap(ShenandoahHeap::heap()) {
546   }
547 
548   void work(uint worker_id) {
549     ShenandoahAdjustPointersObjectClosure obj_cl;
550     ShenandoahHeapRegion* r = _regions.next();
551     while (r != NULL) {
552       if (!r-&gt;is_humongous_continuation() &amp;&amp; r-&gt;has_live()) {
553         _heap-&gt;marked_object_iterate(r, &amp;obj_cl);
554       }
555       r = _regions.next();
556     }
557   }
558 };
559 
560 class ShenandoahAdjustRootPointersTask : public AbstractGangTask {
561 private:
<span class="line-modified">562   ShenandoahRootProcessor* _rp;</span>
<span class="line-modified">563 </span>
564 public:
<span class="line-modified">565   ShenandoahAdjustRootPointersTask(ShenandoahRootProcessor* rp) :</span>
566     AbstractGangTask(&quot;Shenandoah Adjust Root Pointers Task&quot;),
<span class="line-modified">567     _rp(rp) {}</span>

568 
569   void work(uint worker_id) {
570     ShenandoahAdjustPointersClosure cl;
<span class="line-modified">571     CLDToOopClosure adjust_cld_closure(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-modified">572     MarkingCodeBlobClosure adjust_code_closure(&amp;cl,</span>
<span class="line-removed">573                                              CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">574 </span>
<span class="line-removed">575     _rp-&gt;process_all_roots(&amp;cl, &amp;cl,</span>
<span class="line-removed">576                            &amp;adjust_cld_closure,</span>
<span class="line-removed">577                            &amp;adjust_code_closure, NULL, worker_id);</span>
578   }
579 };
580 
581 void ShenandoahMarkCompact::phase3_update_references() {
582   GCTraceTime(Info, gc, phases) time(&quot;Phase 3: Adjust pointers&quot;, _gc_timer);
583   ShenandoahGCPhase adjust_pointer_phase(ShenandoahPhaseTimings::full_gc_adjust_pointers);
584 
585   ShenandoahHeap* heap = ShenandoahHeap::heap();
586 
587   WorkGang* workers = heap-&gt;workers();
588   uint nworkers = workers-&gt;active_workers();
589   {
590 #if COMPILER2_OR_JVMCI
591     DerivedPointerTable::clear();
592 #endif
<span class="line-modified">593     ShenandoahRootProcessor rp(heap, nworkers, ShenandoahPhaseTimings::full_gc_roots);</span>
<span class="line-modified">594     ShenandoahAdjustRootPointersTask task(&amp;rp);</span>
595     workers-&gt;run_task(&amp;task);
596 #if COMPILER2_OR_JVMCI
597     DerivedPointerTable::update_pointers();
598 #endif
599   }
600 
601   ShenandoahAdjustPointersTask adjust_pointers_task;
602   workers-&gt;run_task(&amp;adjust_pointers_task);
603 }
604 
605 class ShenandoahCompactObjectsClosure : public ObjectClosure {
606 private:
607   ShenandoahHeap* const _heap;
608   uint            const _worker_id;
609 
610 public:
611   ShenandoahCompactObjectsClosure(uint worker_id) :
612     _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}
613 
614   void do_object(oop p) {
615     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
616     size_t size = (size_t)p-&gt;size();
<span class="line-modified">617     HeapWord* compact_to = ShenandoahBrooksPointer::get_raw(p);</span>
<span class="line-modified">618     HeapWord* compact_from = (HeapWord*) p;</span>
<span class="line-modified">619     if (compact_from != compact_to) {</span>
620       Copy::aligned_conjoint_words(compact_from, compact_to, size);


621     }
<span class="line-removed">622     oop new_obj = oop(compact_to);</span>
<span class="line-removed">623     ShenandoahBrooksPointer::initialize(new_obj);</span>
624   }
625 };
626 
627 class ShenandoahCompactObjectsTask : public AbstractGangTask {
628 private:
629   ShenandoahHeap* const _heap;
630   ShenandoahHeapRegionSet** const _worker_slices;
631 
632 public:
633   ShenandoahCompactObjectsTask(ShenandoahHeapRegionSet** worker_slices) :
634     AbstractGangTask(&quot;Shenandoah Compact Objects Task&quot;),
635     _heap(ShenandoahHeap::heap()),
636     _worker_slices(worker_slices) {
637   }
638 
639   void work(uint worker_id) {
640     ShenandoahHeapRegionSetIterator slice(_worker_slices[worker_id]);
641 
642     ShenandoahCompactObjectsClosure cl(worker_id);
643     ShenandoahHeapRegion* r = slice.next();
</pre>
<hr />
<pre>
694 
695     r-&gt;set_live_data(live);
696     r-&gt;reset_alloc_metadata_to_shared();
697     _live += live;
698   }
699 
700   size_t get_live() {
701     return _live;
702   }
703 };
704 
705 void ShenandoahMarkCompact::compact_humongous_objects() {
706   // Compact humongous regions, based on their fwdptr objects.
707   //
708   // This code is serial, because doing the in-slice parallel sliding is tricky. In most cases,
709   // humongous regions are already compacted, and do not require further moves, which alleviates
710   // sliding costs. We may consider doing this in parallel in future.
711 
712   ShenandoahHeap* heap = ShenandoahHeap::heap();
713 
<span class="line-modified">714   for (size_t c = heap-&gt;num_regions() - 1; c &gt; 0; c--) {</span>
<span class="line-modified">715     ShenandoahHeapRegion* r = heap-&gt;get_region(c);</span>
716     if (r-&gt;is_humongous_start()) {
<span class="line-modified">717       oop old_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">718       size_t words_size = old_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>




719       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
720 
721       size_t old_start = r-&gt;region_number();
722       size_t old_end   = old_start + num_regions - 1;
<span class="line-modified">723       size_t new_start = heap-&gt;heap_region_index_containing(ShenandoahBrooksPointer::get_raw(old_obj));</span>
724       size_t new_end   = new_start + num_regions - 1;
<span class="line-modified">725 </span>
<span class="line-modified">726       if (old_start == new_start) {</span>
<span class="line-removed">727         // No need to move the object, it stays at the same slot</span>
<span class="line-removed">728         continue;</span>
<span class="line-removed">729       }</span>
<span class="line-removed">730 </span>
<span class="line-removed">731       assert (r-&gt;is_move_allowed(), &quot;should be movable&quot;);</span>
732 
733       Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
734                                    heap-&gt;get_region(new_start)-&gt;bottom(),
735                                    ShenandoahHeapRegion::region_size_words()*num_regions);
736 
<span class="line-modified">737       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">738       ShenandoahBrooksPointer::initialize(new_obj);</span>
739 
740       {
741         for (size_t c = old_start; c &lt;= old_end; c++) {
742           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
743           r-&gt;make_regular_bypass();
744           r-&gt;set_top(r-&gt;bottom());
745         }
746 
747         for (size_t c = new_start; c &lt;= new_end; c++) {
748           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
749           if (c == new_start) {
750             r-&gt;make_humongous_start_bypass();
751           } else {
752             r-&gt;make_humongous_cont_bypass();
753           }
754 
755           // Trailing region may be non-full, record the remainder there
756           size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
757           if ((c == new_end) &amp;&amp; (remainder != 0)) {
758             r-&gt;set_top(r-&gt;bottom() + remainder);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;code/codeCache.hpp&quot;
 28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-modified"> 29 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
 31 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
<span class="line-added"> 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
 33 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-modified"> 41 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
 42 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 44 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 45 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
 46 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
 47 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
 48 #include &quot;memory/metaspace.hpp&quot;
<span class="line-added"> 49 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 50 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
 51 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added"> 52 #include &quot;runtime/biasedLocking.hpp&quot;</span>
<span class="line-added"> 53 #include &quot;runtime/orderAccess.hpp&quot;</span>
 54 #include &quot;runtime/thread.hpp&quot;
 55 #include &quot;utilities/copy.hpp&quot;
 56 #include &quot;utilities/growableArray.hpp&quot;
 57 #include &quot;gc/shared/workgroup.hpp&quot;
 58 
<span class="line-added"> 59 ShenandoahMarkCompact::ShenandoahMarkCompact() :</span>
<span class="line-added"> 60   _gc_timer(NULL),</span>
<span class="line-added"> 61   _preserved_marks(new PreservedMarksSet(true)) {}</span>
<span class="line-added"> 62 </span>
 63 void ShenandoahMarkCompact::initialize(GCTimer* gc_timer) {
 64   _gc_timer = gc_timer;
 65 }
 66 
 67 void ShenandoahMarkCompact::do_it(GCCause::Cause gc_cause) {
 68   ShenandoahHeap* heap = ShenandoahHeap::heap();
 69 
 70   if (ShenandoahVerify) {
 71     heap-&gt;verifier()-&gt;verify_before_fullgc();
 72   }
 73 
 74   if (VerifyBeforeGC) {
 75     Universe::verify();
 76   }
 77 
<span class="line-added"> 78   // Degenerated GC may carry concurrent_root_in_progress flag when upgrading to</span>
<span class="line-added"> 79   // full GC. We need to reset it before mutators resume.</span>
<span class="line-added"> 80   if (ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {</span>
<span class="line-added"> 81     heap-&gt;set_concurrent_root_in_progress(false);</span>
<span class="line-added"> 82   }</span>
<span class="line-added"> 83 </span>
 84   heap-&gt;set_full_gc_in_progress(true);
 85 
 86   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at a safepoint&quot;);
 87   assert(Thread::current()-&gt;is_VM_thread(), &quot;Do full GC only while world is stopped&quot;);
 88 
 89   {
 90     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 91     heap-&gt;pre_full_gc_dump(_gc_timer);
 92   }
 93 
 94   {
 95     ShenandoahGCPhase prepare_phase(ShenandoahPhaseTimings::full_gc_prepare);
 96     // Full GC is supposed to recover from any GC state:
 97 
 98     // a0. Remember if we have forwarded objects
 99     bool has_forwarded_objects = heap-&gt;has_forwarded_objects();
100 
101     // a1. Cancel evacuation, if in progress
102     if (heap-&gt;is_evacuation_in_progress()) {
103       heap-&gt;set_evacuation_in_progress(false);
104     }
105     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
106 
107     // a2. Cancel update-refs, if in progress
108     if (heap-&gt;is_update_refs_in_progress()) {
109       heap-&gt;set_update_refs_in_progress(false);
110     }
111     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
112 
113     // a3. Cancel concurrent traversal GC, if in progress
114     if (heap-&gt;is_concurrent_traversal_in_progress()) {
115       heap-&gt;traversal_gc()-&gt;reset();
116       heap-&gt;set_concurrent_traversal_in_progress(false);
117     }
118 
119     // b. Cancel concurrent mark, if in progress
120     if (heap-&gt;is_concurrent_mark_in_progress()) {
121       heap-&gt;concurrent_mark()-&gt;cancel();
<span class="line-modified">122       heap-&gt;set_concurrent_mark_in_progress(false);</span>
123     }
124     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
125 
126     // c. Reset the bitmaps for new marking
127     heap-&gt;reset_mark_bitmap();
128     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
129     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
130 
131     // d. Abandon reference discovery and clear all discovered references.
132     ReferenceProcessor* rp = heap-&gt;ref_processor();
133     rp-&gt;disable_discovery();
134     rp-&gt;abandon_partial_discovery();
135     rp-&gt;verify_no_references_recorded();
136 
137     // e. Set back forwarded objects bit back, in case some steps above dropped it.
138     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
<span class="line-added">139 </span>
<span class="line-added">140     // f. Sync pinned region status from the CP marks</span>
<span class="line-added">141     heap-&gt;sync_pinned_region_status();</span>
<span class="line-added">142 </span>
<span class="line-added">143     // The rest of prologue:</span>
<span class="line-added">144     BiasedLocking::preserve_marks();</span>
<span class="line-added">145     _preserved_marks-&gt;init(heap-&gt;workers()-&gt;active_workers());</span>
146   }
147 
148   heap-&gt;make_parsable(true);
149 
150   OrderAccess::fence();
151 
152   phase1_mark_heap();
153 
154   // Once marking is done, which may have fixed up forwarded objects, we can drop it.
155   // Coming out of Full GC, we would not have any forwarded objects.
<span class="line-modified">156   // This also prevents resolves with fwdptr from kicking in while adjusting pointers in phase3.</span>
157   heap-&gt;set_has_forwarded_objects(false);
158 
159   heap-&gt;set_full_gc_move_in_progress(true);
160 
161   // Setup workers for the rest
162   OrderAccess::fence();
163 
164   // Initialize worker slices
165   ShenandoahHeapRegionSet** worker_slices = NEW_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, heap-&gt;max_workers(), mtGC);
166   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
167     worker_slices[i] = new ShenandoahHeapRegionSet();
168   }
169 
170   {
171     // The rest of code performs region moves, where region status is undefined
172     // until all phases run together.
173     ShenandoahHeapLocker lock(heap-&gt;lock());
174 
175     phase2_calculate_target_addresses(worker_slices);
176 
177     OrderAccess::fence();
178 
179     phase3_update_references();
180 
181     phase4_compact_objects(worker_slices);
182   }
183 
<span class="line-added">184   {</span>
<span class="line-added">185     // Epilogue</span>
<span class="line-added">186     _preserved_marks-&gt;restore(heap-&gt;workers());</span>
<span class="line-added">187     BiasedLocking::restore_marks();</span>
<span class="line-added">188     _preserved_marks-&gt;reclaim();</span>
<span class="line-added">189   }</span>
<span class="line-added">190 </span>
191   // Resize metaspace
192   MetaspaceGC::compute_new_size();
193 
194   // Free worker slices
195   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
196     delete worker_slices[i];
197   }
198   FREE_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, worker_slices);
199 


200   heap-&gt;set_full_gc_move_in_progress(false);
201   heap-&gt;set_full_gc_in_progress(false);
202 
203   if (ShenandoahVerify) {
204     heap-&gt;verifier()-&gt;verify_after_fullgc();
205   }
206 
207   if (VerifyAfterGC) {
208     Universe::verify();
209   }
210 
211   {
212     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
213     heap-&gt;post_full_gc_dump(_gc_timer);
214   }
215 }
216 
217 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
218 private:
219   ShenandoahMarkingContext* const _ctx;
</pre>
<hr />
<pre>
234 
235   ShenandoahHeap* heap = ShenandoahHeap::heap();
236 
237   ShenandoahPrepareForMarkClosure cl;
238   heap-&gt;heap_region_iterate(&amp;cl);
239 
240   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
241 
242   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
243   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
244 
245   ReferenceProcessor* rp = heap-&gt;ref_processor();
246   // enable (&quot;weak&quot;) refs discovery
247   rp-&gt;enable_discovery(true /*verify_no_refs*/);
248   rp-&gt;setup_policy(true); // forcefully purge all soft references
249   rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
250 
251   cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_roots);
252   cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_roots);
253   cm-&gt;finish_mark_from_roots(/* full_gc = */ true);

254   heap-&gt;mark_complete_marking_context();
<span class="line-added">255   heap-&gt;parallel_cleaning(true /* full_gc */);</span>
256 }
257 
258 class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
259 private:
<span class="line-added">260   PreservedMarks*          const _preserved_marks;</span>
261   ShenandoahHeap*          const _heap;
262   GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
263   int _empty_regions_pos;
264   ShenandoahHeapRegion*          _to_region;
265   ShenandoahHeapRegion*          _from_region;
266   HeapWord* _compact_point;
267 
268 public:
<span class="line-modified">269   ShenandoahPrepareForCompactionObjectClosure(PreservedMarks* preserved_marks,</span>
<span class="line-added">270                                               GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions,</span>
<span class="line-added">271                                               ShenandoahHeapRegion* to_region) :</span>
<span class="line-added">272     _preserved_marks(preserved_marks),</span>
273     _heap(ShenandoahHeap::heap()),
274     _empty_regions(empty_regions),
275     _empty_regions_pos(0),
276     _to_region(to_region),
277     _from_region(NULL),
278     _compact_point(to_region-&gt;bottom()) {}
279 
280   void set_from_region(ShenandoahHeapRegion* from_region) {
281     _from_region = from_region;
282   }
283 
284   void finish_region() {
285     assert(_to_region != NULL, &quot;should not happen&quot;);
286     _to_region-&gt;set_new_top(_compact_point);
287   }
288 
289   bool is_compact_same_region() {
290     return _from_region == _to_region;
291   }
292 
293   int empty_regions_pos() {
294     return _empty_regions_pos;
295   }
296 
297   void do_object(oop p) {
298     assert(_from_region != NULL, &quot;must set before work&quot;);
299     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-modified">300     assert(!_heap-&gt;complete_marking_context()-&gt;allocated_after_mark_start(p), &quot;must be truly marked&quot;);</span>
301 
<span class="line-modified">302     size_t obj_size = p-&gt;size();</span>
303     if (_compact_point + obj_size &gt; _to_region-&gt;end()) {
304       finish_region();
305 
306       // Object doesn&#39;t fit. Pick next empty region and start compacting there.
307       ShenandoahHeapRegion* new_to_region;
308       if (_empty_regions_pos &lt; _empty_regions.length()) {
309         new_to_region = _empty_regions.at(_empty_regions_pos);
310         _empty_regions_pos++;
311       } else {
312         // Out of empty region? Compact within the same region.
313         new_to_region = _from_region;
314       }
315 
316       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
317       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
318       _to_region = new_to_region;
319       _compact_point = _to_region-&gt;bottom();
320     }
321 
322     // Object fits into current region, record new location:
323     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
324     shenandoah_assert_not_forwarded(NULL, p);
<span class="line-modified">325     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());</span>
<span class="line-added">326     p-&gt;forward_to(oop(_compact_point));</span>
327     _compact_point += obj_size;
328   }
329 };
330 
331 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
332 private:
<span class="line-added">333   PreservedMarksSet*        const _preserved_marks;</span>
334   ShenandoahHeap*           const _heap;
335   ShenandoahHeapRegionSet** const _worker_slices;
336   ShenandoahRegionIterator        _heap_regions;
337 
338   ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {
339     ShenandoahHeapRegion* from_region = _heap_regions.next();
340 
<span class="line-modified">341     // Look for next candidate for this slice:</span>
<span class="line-added">342     while (from_region != NULL) {</span>
<span class="line-added">343       // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-added">344       // We could have skipped this without violating correctness, but we really</span>
<span class="line-added">345       // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-added">346       // means moving them into the fully empty regions.</span>
<span class="line-added">347       if (from_region-&gt;is_empty()) break;</span>
<span class="line-added">348 </span>
<span class="line-added">349       // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-added">350       // moves are special cased here, because their moves are handled separately.</span>
<span class="line-added">351       if (from_region-&gt;is_stw_move_allowed() &amp;&amp; !from_region-&gt;is_humongous()) break;</span>
<span class="line-added">352 </span>
353       from_region = _heap_regions.next();
354     }
355 
356     if (from_region != NULL) {
357       assert(slice != NULL, &quot;sanity&quot;);
358       assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);
<span class="line-modified">359       assert(from_region-&gt;is_empty() || from_region-&gt;is_stw_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
360       slice-&gt;add_region(from_region);
361     }
362 
363     return from_region;
364   }
365 
366 public:
<span class="line-modified">367   ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet** worker_slices) :</span>
368     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
<span class="line-added">369     _preserved_marks(preserved_marks),</span>
370     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
371   }
372 
373   void work(uint worker_id) {
374     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
375     ShenandoahHeapRegion* from_region = next_from_region(slice);
376     // No work?
377     if (from_region == NULL) {
378       return;
379     }
380 
381     // Sliding compaction. Walk all regions in the slice, and compact them.
382     // Remember empty regions and reuse them as needed.
383     ResourceMark rm;
384     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-modified">385     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);</span>
386     while (from_region != NULL) {
387       cl.set_from_region(from_region);
388       if (from_region-&gt;has_live()) {
389         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
390       }
391 
392       // Compacted the region to somewhere else? From-region is empty then.
393       if (!cl.is_compact_same_region()) {
394         empty_regions.append(from_region);
395       }
396       from_region = next_from_region(slice);
397     }
398     cl.finish_region();
399 
400     // Mark all remaining regions as empty
401     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
402       ShenandoahHeapRegion* r = empty_regions.at(pos);
403       r-&gt;set_new_top(r-&gt;bottom());
404     }
405   }
406 };
407 
408 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
409   ShenandoahHeap* heap = ShenandoahHeap::heap();
410 
411   // Compute the new addresses for humongous objects. We need to do this after addresses
412   // for regular objects are calculated, and we know what regions in heap suffix are
413   // available for humongous moves.
414   //
415   // Scan the heap backwards, because we are compacting humongous regions towards the end.
416   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
417   // humongous start there.
418   //
419   // The complication is potential non-movable regions during the scan. If such region is
420   // detected, then sliding restarts towards that non-movable region.
421 
422   size_t to_begin = heap-&gt;num_regions();
423   size_t to_end = heap-&gt;num_regions();
424 
<span class="line-modified">425   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {</span>
<span class="line-modified">426     ShenandoahHeapRegion *r = heap-&gt;get_region(c - 1);</span>
427     if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
428       // To-region candidate: record this, and continue scan
429       to_begin = r-&gt;region_number();
430       continue;
431     }
432 
<span class="line-modified">433     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_stw_move_allowed()) {</span>
434       // From-region candidate: movable humongous region
<span class="line-modified">435       oop old_obj = oop(r-&gt;bottom());</span>
<span class="line-modified">436       size_t words_size = old_obj-&gt;size();</span>
437       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
438 
439       size_t start = to_end - num_regions;
440 
441       if (start &gt;= to_begin &amp;&amp; start != r-&gt;region_number()) {
442         // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
<span class="line-modified">443         _preserved_marks-&gt;get(0)-&gt;push_if_necessary(old_obj, old_obj-&gt;mark_raw());</span>
<span class="line-added">444         old_obj-&gt;forward_to(oop(heap-&gt;get_region(start)-&gt;bottom()));</span>
445         to_end = start;
446         continue;
447       }
448     }
449 
450     // Failed to fit. Scan starting from current region.
451     to_begin = r-&gt;region_number();
452     to_end = r-&gt;region_number();
453   }
454 }
455 
456 class ShenandoahEnsureHeapActiveClosure: public ShenandoahHeapRegionClosure {
457 private:
458   ShenandoahHeap* const _heap;
459 
460 public:
461   ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}
462   void heap_region_do(ShenandoahHeapRegion* r) {
463     if (r-&gt;is_trash()) {
464       r-&gt;recycle();
</pre>
<hr />
<pre>
472     assert (r-&gt;is_committed(), &quot;only committed regions in heap now, see region &quot; SIZE_FORMAT, r-&gt;region_number());
473 
474     // Record current region occupancy: this communicates empty regions are free
475     // to the rest of Full GC code.
476     r-&gt;set_new_top(r-&gt;top());
477   }
478 };
479 
480 class ShenandoahTrashImmediateGarbageClosure: public ShenandoahHeapRegionClosure {
481 private:
482   ShenandoahHeap* const _heap;
483   ShenandoahMarkingContext* const _ctx;
484 
485 public:
486   ShenandoahTrashImmediateGarbageClosure() :
487     _heap(ShenandoahHeap::heap()),
488     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
489 
490   void heap_region_do(ShenandoahHeapRegion* r) {
491     if (r-&gt;is_humongous_start()) {
<span class="line-modified">492       oop humongous_obj = oop(r-&gt;bottom());</span>
493       if (!_ctx-&gt;is_marked(humongous_obj)) {
494         assert(!r-&gt;has_live(),
495                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
496         _heap-&gt;trash_humongous_region_at(r);
497       } else {
498         assert(r-&gt;has_live(),
499                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
500       }
501     } else if (r-&gt;is_humongous_continuation()) {
502       // If we hit continuation, the non-live humongous starts should have been trashed already
503       assert(r-&gt;humongous_start_region()-&gt;has_live(),
504              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());
505     } else if (r-&gt;is_regular()) {
506       if (!r-&gt;has_live()) {
507         r-&gt;make_trash_immediate();
508       }
509     }
510   }
511 };
512 
513 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
514   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
515   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
516 
517   ShenandoahHeap* heap = ShenandoahHeap::heap();
518 
<span class="line-added">519   // About to figure out which regions can be compacted, make sure pinning status</span>
<span class="line-added">520   // had been updated in GC prologue.</span>
<span class="line-added">521   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">522 </span>
523   {
524     // Trash the immediately collectible regions before computing addresses
525     ShenandoahTrashImmediateGarbageClosure tigcl;
526     heap-&gt;heap_region_iterate(&amp;tigcl);
527 
528     // Make sure regions are in good state: committed, active, clean.
529     // This is needed because we are potentially sliding the data through them.
530     ShenandoahEnsureHeapActiveClosure ecl;
531     heap-&gt;heap_region_iterate(&amp;ecl);
532   }
533 
534   // Compute the new addresses for regular objects
535   {
536     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified">537     ShenandoahPrepareForCompactionTask prepare_task(_preserved_marks, worker_slices);</span>
538     heap-&gt;workers()-&gt;run_task(&amp;prepare_task);
539   }
540 
541   // Compute the new addresses for humongous objects
542   {
543     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
544     calculate_target_humongous_objects();
545   }
546 }
547 
548 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
549 private:
550   ShenandoahHeap* const _heap;
551   ShenandoahMarkingContext* const _ctx;
552 
553   template &lt;class T&gt;
554   inline void do_oop_work(T* p) {
555     T o = RawAccess&lt;&gt;::oop_load(p);
556     if (!CompressedOops::is_null(o)) {
557       oop obj = CompressedOops::decode_not_null(o);
558       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
<span class="line-modified">559       if (obj-&gt;is_forwarded()) {</span>
<span class="line-modified">560         oop forw = obj-&gt;forwardee();</span>
<span class="line-added">561         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);</span>
<span class="line-added">562       }</span>
563     }
564   }
565 
566 public:
567   ShenandoahAdjustPointersClosure() :
568     _heap(ShenandoahHeap::heap()),
569     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
570 
571   void do_oop(oop* p)       { do_oop_work(p); }
572   void do_oop(narrowOop* p) { do_oop_work(p); }
573 };
574 
575 class ShenandoahAdjustPointersObjectClosure : public ObjectClosure {
576 private:
577   ShenandoahHeap* const _heap;
578   ShenandoahAdjustPointersClosure _cl;
579 
580 public:
581   ShenandoahAdjustPointersObjectClosure() :
582     _heap(ShenandoahHeap::heap()) {
583   }
584   void do_object(oop p) {
585     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);

586     p-&gt;oop_iterate(&amp;_cl);
587   }
588 };
589 
590 class ShenandoahAdjustPointersTask : public AbstractGangTask {
591 private:
592   ShenandoahHeap*          const _heap;
593   ShenandoahRegionIterator       _regions;
594 
595 public:
596   ShenandoahAdjustPointersTask() :
597     AbstractGangTask(&quot;Shenandoah Adjust Pointers Task&quot;),
598     _heap(ShenandoahHeap::heap()) {
599   }
600 
601   void work(uint worker_id) {
602     ShenandoahAdjustPointersObjectClosure obj_cl;
603     ShenandoahHeapRegion* r = _regions.next();
604     while (r != NULL) {
605       if (!r-&gt;is_humongous_continuation() &amp;&amp; r-&gt;has_live()) {
606         _heap-&gt;marked_object_iterate(r, &amp;obj_cl);
607       }
608       r = _regions.next();
609     }
610   }
611 };
612 
613 class ShenandoahAdjustRootPointersTask : public AbstractGangTask {
614 private:
<span class="line-modified">615   ShenandoahRootAdjuster* _rp;</span>
<span class="line-modified">616   PreservedMarksSet* _preserved_marks;</span>
617 public:
<span class="line-modified">618   ShenandoahAdjustRootPointersTask(ShenandoahRootAdjuster* rp, PreservedMarksSet* preserved_marks) :</span>
619     AbstractGangTask(&quot;Shenandoah Adjust Root Pointers Task&quot;),
<span class="line-modified">620     _rp(rp),</span>
<span class="line-added">621     _preserved_marks(preserved_marks) {}</span>
622 
623   void work(uint worker_id) {
624     ShenandoahAdjustPointersClosure cl;
<span class="line-modified">625     _rp-&gt;roots_do(worker_id, &amp;cl);</span>
<span class="line-modified">626     _preserved_marks-&gt;get(worker_id)-&gt;adjust_during_full_gc();</span>





627   }
628 };
629 
630 void ShenandoahMarkCompact::phase3_update_references() {
631   GCTraceTime(Info, gc, phases) time(&quot;Phase 3: Adjust pointers&quot;, _gc_timer);
632   ShenandoahGCPhase adjust_pointer_phase(ShenandoahPhaseTimings::full_gc_adjust_pointers);
633 
634   ShenandoahHeap* heap = ShenandoahHeap::heap();
635 
636   WorkGang* workers = heap-&gt;workers();
637   uint nworkers = workers-&gt;active_workers();
638   {
639 #if COMPILER2_OR_JVMCI
640     DerivedPointerTable::clear();
641 #endif
<span class="line-modified">642     ShenandoahRootAdjuster rp(nworkers, ShenandoahPhaseTimings::full_gc_roots);</span>
<span class="line-modified">643     ShenandoahAdjustRootPointersTask task(&amp;rp, _preserved_marks);</span>
644     workers-&gt;run_task(&amp;task);
645 #if COMPILER2_OR_JVMCI
646     DerivedPointerTable::update_pointers();
647 #endif
648   }
649 
650   ShenandoahAdjustPointersTask adjust_pointers_task;
651   workers-&gt;run_task(&amp;adjust_pointers_task);
652 }
653 
654 class ShenandoahCompactObjectsClosure : public ObjectClosure {
655 private:
656   ShenandoahHeap* const _heap;
657   uint            const _worker_id;
658 
659 public:
660   ShenandoahCompactObjectsClosure(uint worker_id) :
661     _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}
662 
663   void do_object(oop p) {
664     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
665     size_t size = (size_t)p-&gt;size();
<span class="line-modified">666     if (p-&gt;is_forwarded()) {</span>
<span class="line-modified">667       HeapWord* compact_from = cast_from_oop&lt;HeapWord*&gt;(p);</span>
<span class="line-modified">668       HeapWord* compact_to = cast_from_oop&lt;HeapWord*&gt;(p-&gt;forwardee());</span>
669       Copy::aligned_conjoint_words(compact_from, compact_to, size);
<span class="line-added">670       oop new_obj = oop(compact_to);</span>
<span class="line-added">671       new_obj-&gt;init_mark_raw();</span>
672     }


673   }
674 };
675 
676 class ShenandoahCompactObjectsTask : public AbstractGangTask {
677 private:
678   ShenandoahHeap* const _heap;
679   ShenandoahHeapRegionSet** const _worker_slices;
680 
681 public:
682   ShenandoahCompactObjectsTask(ShenandoahHeapRegionSet** worker_slices) :
683     AbstractGangTask(&quot;Shenandoah Compact Objects Task&quot;),
684     _heap(ShenandoahHeap::heap()),
685     _worker_slices(worker_slices) {
686   }
687 
688   void work(uint worker_id) {
689     ShenandoahHeapRegionSetIterator slice(_worker_slices[worker_id]);
690 
691     ShenandoahCompactObjectsClosure cl(worker_id);
692     ShenandoahHeapRegion* r = slice.next();
</pre>
<hr />
<pre>
743 
744     r-&gt;set_live_data(live);
745     r-&gt;reset_alloc_metadata_to_shared();
746     _live += live;
747   }
748 
749   size_t get_live() {
750     return _live;
751   }
752 };
753 
754 void ShenandoahMarkCompact::compact_humongous_objects() {
755   // Compact humongous regions, based on their fwdptr objects.
756   //
757   // This code is serial, because doing the in-slice parallel sliding is tricky. In most cases,
758   // humongous regions are already compacted, and do not require further moves, which alleviates
759   // sliding costs. We may consider doing this in parallel in future.
760 
761   ShenandoahHeap* heap = ShenandoahHeap::heap();
762 
<span class="line-modified">763   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {</span>
<span class="line-modified">764     ShenandoahHeapRegion* r = heap-&gt;get_region(c - 1);</span>
765     if (r-&gt;is_humongous_start()) {
<span class="line-modified">766       oop old_obj = oop(r-&gt;bottom());</span>
<span class="line-modified">767       if (!old_obj-&gt;is_forwarded()) {</span>
<span class="line-added">768         // No need to move the object, it stays at the same slot</span>
<span class="line-added">769         continue;</span>
<span class="line-added">770       }</span>
<span class="line-added">771       size_t words_size = old_obj-&gt;size();</span>
772       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
773 
774       size_t old_start = r-&gt;region_number();
775       size_t old_end   = old_start + num_regions - 1;
<span class="line-modified">776       size_t new_start = heap-&gt;heap_region_index_containing(old_obj-&gt;forwardee());</span>
777       size_t new_end   = new_start + num_regions - 1;
<span class="line-modified">778       assert(old_start != new_start, &quot;must be real move&quot;);</span>
<span class="line-modified">779       assert(r-&gt;is_stw_move_allowed(), &quot;Region &quot; SIZE_FORMAT &quot; should be movable&quot;, r-&gt;region_number());</span>





780 
781       Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
782                                    heap-&gt;get_region(new_start)-&gt;bottom(),
783                                    ShenandoahHeapRegion::region_size_words()*num_regions);
784 
<span class="line-modified">785       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom());</span>
<span class="line-modified">786       new_obj-&gt;init_mark_raw();</span>
787 
788       {
789         for (size_t c = old_start; c &lt;= old_end; c++) {
790           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
791           r-&gt;make_regular_bypass();
792           r-&gt;set_top(r-&gt;bottom());
793         }
794 
795         for (size_t c = new_start; c &lt;= new_end; c++) {
796           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
797           if (c == new_start) {
798             r-&gt;make_humongous_start_bypass();
799           } else {
800             r-&gt;make_humongous_cont_bypass();
801           }
802 
803           // Trailing region may be non-full, record the remainder there
804           size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
805           if ((c == new_end) &amp;&amp; (remainder != 0)) {
806             r-&gt;set_top(r-&gt;bottom() + remainder);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeuristics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
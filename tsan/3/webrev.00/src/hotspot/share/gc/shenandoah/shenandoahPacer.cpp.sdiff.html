<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;

 29 
 30 /*
 31  * In normal concurrent cycle, we have to pace the application to let GC finish.
 32  *
 33  * Here, we do not know how large would be the collection set, and what are the
 34  * relative performances of the each stage in the concurrent cycle, and so we have to
 35  * make some assumptions.
 36  *
 37  * For concurrent mark, there is no clear notion of progress. The moderately accurate
 38  * and easy to get metric is the amount of live objects the mark had encountered. But,
 39  * that does directly correlate with the used heap, because the heap might be fully
 40  * dead or fully alive. We cannot assume either of the extremes: we would either allow
 41  * application to run out of memory if we assume heap is fully dead but it is not, and,
 42  * conversely, we would pacify application excessively if we assume heap is fully alive
 43  * but it is not. So we need to guesstimate the particular expected value for heap liveness.
 44  * The best way to do this is apparently recording the past history.
 45  *
 46  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
 47  * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
 48  * and use the global heap-used as the baseline.
</pre>
<hr />
<pre>
 53  * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would
 54  * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay
 55  * 3*90 / 10 MBs. In the end, we would pay back the entire budget.
 56  */
 57 
 58 void ShenandoahPacer::setup_for_mark() {
 59   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 60 
 61   size_t live = update_and_get_progress_history();
 62   size_t free = _heap-&gt;free_set()-&gt;available();
 63 
 64   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 65   size_t taxable = free - non_taxable;
 66 
 67   double tax = 1.0 * live / taxable; // base tax for available free space
 68   tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
 69   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 70 
 71   restart_with(non_taxable, tax);
 72 
<span class="line-modified"> 73   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified"> 74                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified"> 75                      live / M, free / M, non_taxable / M, tax);</span>



 76 }
 77 
 78 void ShenandoahPacer::setup_for_evac() {
 79   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 80 
 81   size_t used = _heap-&gt;collection_set()-&gt;used();
 82   size_t free = _heap-&gt;free_set()-&gt;available();
 83 
 84   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 85   size_t taxable = free - non_taxable;
 86 
 87   double tax = 1.0 * used / taxable; // base tax for available free space
 88   tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free
 89   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
 90   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 91 
 92   restart_with(non_taxable, tax);
 93 
<span class="line-modified"> 94   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified"> 95                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified"> 96                      used / M, free / M, non_taxable / M, tax);</span>



 97 }
 98 
 99 void ShenandoahPacer::setup_for_updaterefs() {
100   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
101 
102   size_t used = _heap-&gt;used();
103   size_t free = _heap-&gt;free_set()-&gt;available();
104 
105   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
106   size_t taxable = free - non_taxable;
107 
108   double tax = 1.0 * used / taxable; // base tax for available free space
109   tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free
110   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
111   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
112 
113   restart_with(non_taxable, tax);
114 
<span class="line-modified">115   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">116                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">117                      used / M, free / M, non_taxable / M, tax);</span>



118 }
119 
120 /*
121  * Traversal walks the entire heap once, and therefore we have to make assumptions about its
122  * liveness, like concurrent mark does.
123  */
124 
125 void ShenandoahPacer::setup_for_traversal() {
126   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
127 
128   size_t live = update_and_get_progress_history();
129   size_t free = _heap-&gt;free_set()-&gt;available();
130 
131   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
132   size_t taxable = free - non_taxable;
133 
134   double tax = 1.0 * live / taxable; // base tax for available free space
135   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
136 
137   restart_with(non_taxable, tax);
138 
<span class="line-modified">139   log_info(gc, ergo)(&quot;Pacer for Traversal. Expected Live: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">140                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">141                      live / M, free / M, non_taxable / M, tax);</span>



142 }
143 
144 /*
145  * In idle phase, we have to pace the application to let control thread react with GC start.
146  *
147  * Here, we have rendezvous with concurrent thread that adds up the budget as it acknowledges
148  * it had seen recent allocations. It will naturally pace the allocations if control thread is
149  * not catching up. To bootstrap this feedback cycle, we need to start with some initial budget
150  * for applications to allocate at.
151  */
152 
153 void ShenandoahPacer::setup_for_idle() {
154   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
155 
<span class="line-modified">156   size_t initial = _heap-&gt;capacity() * ShenandoahPacingIdleSlack / 100;</span>
157   double tax = 1;
158 
159   restart_with(initial, tax);
160 
<span class="line-modified">161   log_info(gc, ergo)(&quot;Pacer for Idle. Initial: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">162                      initial / M, tax);</span>

163 }
164 
165 size_t ShenandoahPacer::update_and_get_progress_history() {
166   if (_progress == -1) {
167     // First initialization, report some prior
<span class="line-modified">168     Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &amp;_progress);</span>
<span class="line-modified">169     return (size_t) (_heap-&gt;capacity() * 0.1);</span>
170   } else {
171     // Record history, and reply historical data
172     _progress_history-&gt;add(_progress);
<span class="line-modified">173     Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &amp;_progress);</span>
174     return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
175   }
176 }
177 
178 void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
179   size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
180   STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
<span class="line-modified">181   Atomic::xchg((intptr_t)initial, &amp;_budget);</span>
<span class="line-modified">182   Atomic::store(tax_rate, &amp;_tax_rate);</span>
183   Atomic::inc(&amp;_epoch);
184 }
185 
186 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
187   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
188 
189   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
190 
191   intptr_t cur = 0;
192   intptr_t new_val = 0;
193   do {
194     cur = Atomic::load(&amp;_budget);
195     if (cur &lt; tax &amp;&amp; !force) {
196       // Progress depleted, alas.
197       return false;
198     }
199     new_val = cur - tax;
<span class="line-modified">200   } while (Atomic::cmpxchg(new_val, &amp;_budget, cur) != cur);</span>
201   return true;
202 }
203 
204 void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
205   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
206 
207   if (_epoch != epoch) {
208     // Stale ticket, no need to unpace.
209     return;
210   }
211 
212   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
<span class="line-modified">213   Atomic::add(tax, &amp;_budget);</span>
214 }
215 
216 intptr_t ShenandoahPacer::epoch() {
217   return Atomic::load(&amp;_epoch);
218 }
219 
220 void ShenandoahPacer::pace_for_alloc(size_t words) {
221   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
222 
223   // Fast path: try to allocate right away
224   if (claim_for_alloc(words, false)) {
225     return;
226   }
227 









228   size_t max = ShenandoahPacingMaxDelay;
229   double start = os::elapsedTime();
230 
231   size_t total = 0;
232   size_t cur = 0;
233 
234   while (true) {
235     // We could instead assist GC, but this would suffice for now.
236     // This code should also participate in safepointing.
237     // Perform the exponential backoff, limited by max.
238 
239     cur = cur * 2;
240     if (total + cur &gt; max) {
241       cur = (max &gt; total) ? (max - total) : 0;
242     }
243     cur = MAX2&lt;size_t&gt;(1, cur);
244 
<span class="line-modified">245     os::sleep(Thread::current(), cur, true);</span>
246 
247     double end = os::elapsedTime();
248     total = (size_t)((end - start) * 1000);
249 
250     if (total &gt; max) {
251       // Spent local time budget to wait for enough GC progress.
252       // Breaking out and allocating anyway, which may mean we outpace GC,
253       // and start Degenerated GC cycle.
254       _delays.add(total);
255 
256       // Forcefully claim the budget: it may go negative at this point, and
257       // GC should replenish for this and subsequent allocations
258       claim_for_alloc(words, true);
259       break;
260     }
261 
262     if (claim_for_alloc(words, false)) {
263       // Acquired enough permit, nice. Can allocate now.
264       _delays.add(total);
265       break;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
<span class="line-added"> 30 #include &quot;runtime/atomic.hpp&quot;</span>
 31 
 32 /*
 33  * In normal concurrent cycle, we have to pace the application to let GC finish.
 34  *
 35  * Here, we do not know how large would be the collection set, and what are the
 36  * relative performances of the each stage in the concurrent cycle, and so we have to
 37  * make some assumptions.
 38  *
 39  * For concurrent mark, there is no clear notion of progress. The moderately accurate
 40  * and easy to get metric is the amount of live objects the mark had encountered. But,
 41  * that does directly correlate with the used heap, because the heap might be fully
 42  * dead or fully alive. We cannot assume either of the extremes: we would either allow
 43  * application to run out of memory if we assume heap is fully dead but it is not, and,
 44  * conversely, we would pacify application excessively if we assume heap is fully alive
 45  * but it is not. So we need to guesstimate the particular expected value for heap liveness.
 46  * The best way to do this is apparently recording the past history.
 47  *
 48  * For concurrent evac and update-refs, we are walking the heap per-region, and so the
 49  * notion of progress is clear: we get reported the &quot;used&quot; size from the processed regions
 50  * and use the global heap-used as the baseline.
</pre>
<hr />
<pre>
 55  * we need to multiply the tax by 3. Example: for 10 MB free and 90 MB used, GC would
 56  * come back with 3*90 MB budget, and thus for each 1 MB of allocation, we have to pay
 57  * 3*90 / 10 MBs. In the end, we would pay back the entire budget.
 58  */
 59 
 60 void ShenandoahPacer::setup_for_mark() {
 61   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 62 
 63   size_t live = update_and_get_progress_history();
 64   size_t free = _heap-&gt;free_set()-&gt;available();
 65 
 66   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 67   size_t taxable = free - non_taxable;
 68 
 69   double tax = 1.0 * live / taxable; // base tax for available free space
 70   tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
 71   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 72 
 73   restart_with(non_taxable, tax);
 74 
<span class="line-modified"> 75   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified"> 76                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified"> 77                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),</span>
<span class="line-added"> 78                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added"> 79                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added"> 80                      tax);</span>
 81 }
 82 
 83 void ShenandoahPacer::setup_for_evac() {
 84   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
 85 
 86   size_t used = _heap-&gt;collection_set()-&gt;used();
 87   size_t free = _heap-&gt;free_set()-&gt;available();
 88 
 89   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
 90   size_t taxable = free - non_taxable;
 91 
 92   double tax = 1.0 * used / taxable; // base tax for available free space
 93   tax *= 2;                          // evac is phase 2 of 3, claim 1/2 of remaining free
 94   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
 95   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
 96 
 97   restart_with(non_taxable, tax);
 98 
<span class="line-modified"> 99   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">100                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">101                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),</span>
<span class="line-added">102                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">103                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">104                      tax);</span>
105 }
106 
107 void ShenandoahPacer::setup_for_updaterefs() {
108   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
109 
110   size_t used = _heap-&gt;used();
111   size_t free = _heap-&gt;free_set()-&gt;available();
112 
113   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
114   size_t taxable = free - non_taxable;
115 
116   double tax = 1.0 * used / taxable; // base tax for available free space
117   tax *= 1;                          // update-refs is phase 3 of 3, claim the remaining free
118   tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
119   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
120 
121   restart_with(non_taxable, tax);
122 
<span class="line-modified">123   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">124                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">125                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),</span>
<span class="line-added">126                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">127                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">128                      tax);</span>
129 }
130 
131 /*
132  * Traversal walks the entire heap once, and therefore we have to make assumptions about its
133  * liveness, like concurrent mark does.
134  */
135 
136 void ShenandoahPacer::setup_for_traversal() {
137   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
138 
139   size_t live = update_and_get_progress_history();
140   size_t free = _heap-&gt;free_set()-&gt;available();
141 
142   size_t non_taxable = free * ShenandoahPacingCycleSlack / 100;
143   size_t taxable = free - non_taxable;
144 
145   double tax = 1.0 * live / taxable; // base tax for available free space
146   tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
147 
148   restart_with(non_taxable, tax);
149 
<span class="line-modified">150   log_info(gc, ergo)(&quot;Pacer for Traversal. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">151                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">152                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),</span>
<span class="line-added">153                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">154                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">155                      tax);</span>
156 }
157 
158 /*
159  * In idle phase, we have to pace the application to let control thread react with GC start.
160  *
161  * Here, we have rendezvous with concurrent thread that adds up the budget as it acknowledges
162  * it had seen recent allocations. It will naturally pace the allocations if control thread is
163  * not catching up. To bootstrap this feedback cycle, we need to start with some initial budget
164  * for applications to allocate at.
165  */
166 
167 void ShenandoahPacer::setup_for_idle() {
168   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
169 
<span class="line-modified">170   size_t initial = _heap-&gt;max_capacity() / 100 * ShenandoahPacingIdleSlack;</span>
171   double tax = 1;
172 
173   restart_with(initial, tax);
174 
<span class="line-modified">175   log_info(gc, ergo)(&quot;Pacer for Idle. Initial: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">176                      byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial),</span>
<span class="line-added">177                      tax);</span>
178 }
179 
180 size_t ShenandoahPacer::update_and_get_progress_history() {
181   if (_progress == -1) {
182     // First initialization, report some prior
<span class="line-modified">183     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);</span>
<span class="line-modified">184     return (size_t) (_heap-&gt;max_capacity() * 0.1);</span>
185   } else {
186     // Record history, and reply historical data
187     _progress_history-&gt;add(_progress);
<span class="line-modified">188     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);</span>
189     return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
190   }
191 }
192 
193 void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
194   size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
195   STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
<span class="line-modified">196   Atomic::xchg(&amp;_budget, (intptr_t)initial);</span>
<span class="line-modified">197   Atomic::store(&amp;_tax_rate, tax_rate);</span>
198   Atomic::inc(&amp;_epoch);
199 }
200 
201 bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
202   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
203 
204   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
205 
206   intptr_t cur = 0;
207   intptr_t new_val = 0;
208   do {
209     cur = Atomic::load(&amp;_budget);
210     if (cur &lt; tax &amp;&amp; !force) {
211       // Progress depleted, alas.
212       return false;
213     }
214     new_val = cur - tax;
<span class="line-modified">215   } while (Atomic::cmpxchg(&amp;_budget, cur, new_val) != cur);</span>
216   return true;
217 }
218 
219 void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
220   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
221 
222   if (_epoch != epoch) {
223     // Stale ticket, no need to unpace.
224     return;
225   }
226 
227   intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
<span class="line-modified">228   Atomic::add(&amp;_budget, tax);</span>
229 }
230 
231 intptr_t ShenandoahPacer::epoch() {
232   return Atomic::load(&amp;_epoch);
233 }
234 
235 void ShenandoahPacer::pace_for_alloc(size_t words) {
236   assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
237 
238   // Fast path: try to allocate right away
239   if (claim_for_alloc(words, false)) {
240     return;
241   }
242 
<span class="line-added">243   // Threads that are attaching should not block at all: they are not</span>
<span class="line-added">244   // fully initialized yet. Calling sleep() on them would be awkward.</span>
<span class="line-added">245   // This is probably the path that allocates the thread oop itself.</span>
<span class="line-added">246   // Forcefully claim without waiting.</span>
<span class="line-added">247   if (JavaThread::current()-&gt;is_attaching_via_jni()) {</span>
<span class="line-added">248     claim_for_alloc(words, true);</span>
<span class="line-added">249     return;</span>
<span class="line-added">250   }</span>
<span class="line-added">251 </span>
252   size_t max = ShenandoahPacingMaxDelay;
253   double start = os::elapsedTime();
254 
255   size_t total = 0;
256   size_t cur = 0;
257 
258   while (true) {
259     // We could instead assist GC, but this would suffice for now.
260     // This code should also participate in safepointing.
261     // Perform the exponential backoff, limited by max.
262 
263     cur = cur * 2;
264     if (total + cur &gt; max) {
265       cur = (max &gt; total) ? (max - total) : 0;
266     }
267     cur = MAX2&lt;size_t&gt;(1, cur);
268 
<span class="line-modified">269     JavaThread::current()-&gt;sleep(cur);</span>
270 
271     double end = os::elapsedTime();
272     total = (size_t)((end - start) * 1000);
273 
274     if (total &gt; max) {
275       // Spent local time budget to wait for enough GC progress.
276       // Breaking out and allocating anyway, which may mean we outpace GC,
277       // and start Degenerated GC cycle.
278       _delays.add(total);
279 
280       // Forcefully claim the budget: it may go negative at this point, and
281       // GC should replenish for this and subsequent allocations
282       claim_for_alloc(words, true);
283       break;
284     }
285 
286     if (claim_for_alloc(words, false)) {
287       // Acquired enough permit, nice. Can allocate now.
288       _delays.add(total);
289       break;
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
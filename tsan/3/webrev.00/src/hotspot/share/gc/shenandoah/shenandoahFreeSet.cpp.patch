diff a/src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp b/src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -27,10 +28,11 @@
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahHeapRegionSet.hpp"
 #include "gc/shenandoah/shenandoahMarkingContext.inline.hpp"
 #include "gc/shenandoah/shenandoahTraversalGC.hpp"
 #include "logging/logStream.hpp"
+#include "runtime/orderAccess.hpp"
 
 ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :
   _heap(heap),
   _mutator_free_bitmap(max_regions, mtGC),
   _collector_free_bitmap(max_regions, mtGC),
@@ -112,11 +114,11 @@
       // Try to steal the empty region from the mutator view
       for (size_t c = _mutator_rightmost + 1; c > _mutator_leftmost; c--) {
         size_t idx = c - 1;
         if (is_mutator_free(idx)) {
           ShenandoahHeapRegion* r = _heap->get_region(idx);
-          if (is_empty_or_trash(r)) {
+          if (can_allocate_from(r)) {
             flip_to_gc(r);
             HeapWord *result = try_allocate_in(r, req, in_new_region);
             if (result != NULL) {
               return result;
             }
@@ -146,10 +148,15 @@
 }
 
 HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest& req, bool& in_new_region) {
   assert (!has_no_alloc_capacity(r), "Performance: should avoid full regions on this path: " SIZE_FORMAT, r->region_number());
 
+  if (_heap->is_concurrent_root_in_progress() &&
+      r->is_trash()) {
+    return NULL;
+  }
+
   try_recycle_trashed(r);
 
   in_new_region = r->is_empty();
 
   HeapWord* result = NULL;
@@ -271,11 +278,11 @@
       return NULL;
     }
 
     // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
     // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
-    if (!is_mutator_free(end) || !is_empty_or_trash(_heap->get_region(end))) {
+    if (!is_mutator_free(end) || !can_allocate_from(_heap->get_region(end))) {
       end++;
       beg = end;
       continue;
     }
 
@@ -334,12 +341,12 @@
 
   req.set_actual_size(words_size);
   return _heap->get_region(beg)->bottom();
 }
 
-bool ShenandoahFreeSet::is_empty_or_trash(ShenandoahHeapRegion *r) {
-  return r->is_empty() || r->is_trash();
+bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {
+  return r->is_empty() || (r->is_trash() && !_heap->is_concurrent_root_in_progress());
 }
 
 size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {
   if (r->is_trash()) {
     // This would be recycled on allocation path
@@ -376,11 +383,11 @@
 
 void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {
   size_t idx = r->region_number();
 
   assert(_mutator_free_bitmap.at(idx), "Should be in mutator view");
-  assert(is_empty_or_trash(r), "Should not be allocated");
+  assert(can_allocate_from(r), "Should not be allocated");
 
   _mutator_free_bitmap.clear_bit(idx);
   _collector_free_bitmap.set_bit(idx);
   _collector_leftmost = MIN2(idx, _collector_leftmost);
   _collector_rightmost = MAX2(idx, _collector_rightmost);
@@ -428,18 +435,18 @@
       _mutator_free_bitmap.set_bit(idx);
     }
   }
 
   // Evac reserve: reserve trailing space for evacuations
-  size_t to_reserve = ShenandoahEvacReserve * _heap->capacity() / 100;
+  size_t to_reserve = _heap->max_capacity() / 100 * ShenandoahEvacReserve;
   size_t reserved = 0;
 
   for (size_t idx = _heap->num_regions() - 1; idx > 0; idx--) {
     if (reserved >= to_reserve) break;
 
     ShenandoahHeapRegion* region = _heap->get_region(idx);
-    if (_mutator_free_bitmap.at(idx) && is_empty_or_trash(region)) {
+    if (_mutator_free_bitmap.at(idx) && can_allocate_from(region)) {
       _mutator_free_bitmap.clear_bit(idx);
       _collector_free_bitmap.set_bit(idx);
       size_t ac = alloc_capacity(region);
       _capacity -= ac;
       reserved += ac;
@@ -489,12 +496,16 @@
       }
 
       size_t max_humongous = max_contig * ShenandoahHeapRegion::region_size_bytes();
       size_t free = capacity() - used();
 
-      ls.print("Free: " SIZE_FORMAT "M (" SIZE_FORMAT " regions), Max regular: " SIZE_FORMAT "K, Max humongous: " SIZE_FORMAT "K, ",
-               total_free / M, mutator_count(), max / K, max_humongous / K);
+      ls.print("Free: " SIZE_FORMAT "%s (" SIZE_FORMAT " regions), Max regular: " SIZE_FORMAT "%s, Max humongous: " SIZE_FORMAT "%s, ",
+               byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),
+               mutator_count(),
+               byte_size_in_proper_unit(max),           proper_unit_for_byte_size(max),
+               byte_size_in_proper_unit(max_humongous), proper_unit_for_byte_size(max_humongous)
+      );
 
       size_t frag_ext;
       if (free > 0) {
         frag_ext = 100 - (100 * max_humongous / free);
       } else {
@@ -523,12 +534,14 @@
           max = MAX2(max, free);
           total_free += free;
         }
       }
 
-      ls.print_cr("Evacuation Reserve: " SIZE_FORMAT "M (" SIZE_FORMAT " regions), Max regular: " SIZE_FORMAT "K",
-                  total_free / M, collector_count(), max / K);
+      ls.print_cr("Evacuation Reserve: " SIZE_FORMAT "%s (" SIZE_FORMAT " regions), Max regular: " SIZE_FORMAT "%s",
+                  byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),
+                  collector_count(),
+                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));
     }
   }
 }
 
 HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest& req, bool& in_new_region) {

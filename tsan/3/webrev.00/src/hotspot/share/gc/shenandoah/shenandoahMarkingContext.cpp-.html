<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shenandoah/shenandoahMarkingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/markBitMap.inline.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahMarkingContext.hpp&quot;
 29 
 30 ShenandoahMarkingContext::ShenandoahMarkingContext(MemRegion heap_region, MemRegion bitmap_region, size_t num_regions) :
 31   _top_bitmaps(NEW_C_HEAP_ARRAY(HeapWord*, num_regions, mtGC)),
 32   _top_at_mark_starts_base(NEW_C_HEAP_ARRAY(HeapWord*, num_regions, mtGC)),
 33   _top_at_mark_starts(_top_at_mark_starts_base -
 34                       ((uintx) heap_region.start() &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift())) {
 35   _mark_bit_map.initialize(heap_region, bitmap_region);
 36 }
 37 
 38 bool ShenandoahMarkingContext::is_bitmap_clear() const {
 39   ShenandoahHeap* heap = ShenandoahHeap::heap();
 40   size_t num_regions = heap-&gt;num_regions();
 41   for (size_t idx = 0; idx &lt; num_regions; idx++) {
 42     ShenandoahHeapRegion* r = heap-&gt;get_region(idx);
 43     if (heap-&gt;is_bitmap_slice_committed(r) &amp;&amp; !is_bitmap_clear_range(r-&gt;bottom(), r-&gt;end())) {
 44       return false;
 45     }
 46   }
 47   return true;
 48 }
 49 
 50 bool ShenandoahMarkingContext::is_bitmap_clear_range(HeapWord* start, HeapWord* end) const {
 51   return _mark_bit_map.get_next_marked_addr(start, end) == end;
 52 }
 53 
 54 void ShenandoahMarkingContext::initialize_top_at_mark_start(ShenandoahHeapRegion* r) {
 55   size_t idx = r-&gt;region_number();
 56   HeapWord *bottom = r-&gt;bottom();
 57   _top_at_mark_starts_base[idx] = bottom;
 58   _top_bitmaps[idx] = bottom;
 59 }
 60 
 61 void ShenandoahMarkingContext::capture_top_at_mark_start(ShenandoahHeapRegion *r) {
 62   size_t region_number = r-&gt;region_number();
 63   HeapWord* old_tams = _top_at_mark_starts_base[region_number];
 64   HeapWord* new_tams = r-&gt;top();
 65 
 66   assert(new_tams &gt;= old_tams,
 67          &quot;Region &quot; SIZE_FORMAT&quot;, TAMS updates should be monotonic: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,
 68          region_number, p2i(old_tams), p2i(new_tams));
 69   assert(is_bitmap_clear_range(old_tams, new_tams),
 70          &quot;Region &quot; SIZE_FORMAT &quot;, bitmap should be clear while adjusting TAMS: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,
 71          region_number, p2i(old_tams), p2i(new_tams));
 72 
 73   _top_at_mark_starts_base[region_number] = new_tams;
 74   _top_bitmaps[region_number] = new_tams;
 75 }
 76 
 77 void ShenandoahMarkingContext::reset_top_at_mark_start(ShenandoahHeapRegion* r) {
 78   _top_at_mark_starts_base[r-&gt;region_number()] = r-&gt;bottom();
 79 }
 80 
 81 HeapWord* ShenandoahMarkingContext::top_at_mark_start(ShenandoahHeapRegion* r) const {
 82   return _top_at_mark_starts_base[r-&gt;region_number()];
 83 }
 84 
 85 void ShenandoahMarkingContext::reset_top_bitmap(ShenandoahHeapRegion* r) {
 86   assert(is_bitmap_clear_range(r-&gt;bottom(), r-&gt;end()),
 87          &quot;Region &quot; SIZE_FORMAT &quot; should have no marks in bitmap&quot;, r-&gt;region_number());
 88   _top_bitmaps[r-&gt;region_number()] = r-&gt;bottom();
 89 }
 90 
 91 void ShenandoahMarkingContext::clear_bitmap(ShenandoahHeapRegion* r) {
 92   HeapWord* bottom = r-&gt;bottom();
 93   HeapWord* top_bitmap = _top_bitmaps[r-&gt;region_number()];
 94   if (top_bitmap &gt; bottom) {
 95     _mark_bit_map.clear_range_large(MemRegion(bottom, top_bitmap));
 96     _top_bitmaps[r-&gt;region_number()] = bottom;
 97   }
 98   assert(is_bitmap_clear_range(bottom, r-&gt;end()),
 99          &quot;Region &quot; SIZE_FORMAT &quot; should have no marks in bitmap&quot;, r-&gt;region_number());
100 }
101 
102 bool ShenandoahMarkingContext::is_complete() {
103   return _is_complete.is_set();
104 }
105 
106 void ShenandoahMarkingContext::mark_complete() {
107   _is_complete.set();
108 }
109 
110 void ShenandoahMarkingContext::mark_incomplete() {
111   _is_complete.unset();
112 }
    </pre>
  </body>
</html>
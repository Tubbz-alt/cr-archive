<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  27 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">  29 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  30 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  34 #include &quot;opto/arraycopynode.hpp&quot;
  35 #include &quot;opto/block.hpp&quot;
  36 #include &quot;opto/callnode.hpp&quot;
  37 #include &quot;opto/castnode.hpp&quot;
  38 #include &quot;opto/movenode.hpp&quot;
  39 #include &quot;opto/phaseX.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/runtime.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 
<span class="line-modified">  44 Node* ShenandoahBarrierNode::skip_through_barrier(Node* n) {</span>
<span class="line-modified">  45   if (n == NULL) {</span>
<span class="line-modified">  46     return NULL;</span>
<span class="line-modified">  47   }</span>
<span class="line-modified">  48   if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified">  49     n = n-&gt;in(1);</span>
<span class="line-modified">  50   }</span>
<span class="line-modified">  51 </span>
<span class="line-modified">  52   if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-modified">  53     return n-&gt;in(ValueIn);</span>
<span class="line-modified">  54   } else if (n-&gt;is_Phi() &amp;&amp;</span>
<span class="line-modified">  55              n-&gt;req() == 3 &amp;&amp;</span>
<span class="line-modified">  56              n-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  57              n-&gt;in(1)-&gt;is_ShenandoahBarrier() &amp;&amp;</span>
<span class="line-removed">  58              n-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  59              n-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;</span>
<span class="line-removed">  60              n-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">  61              n-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  62              n-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-removed">  63              n-&gt;in(0)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  64              n-&gt;in(0)-&gt;in(2)-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-removed">  65              n-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">  66              n-&gt;in(0)-&gt;in(1)-&gt;in(0) == n-&gt;in(0)-&gt;in(2)-&gt;in(0) &amp;&amp;</span>
<span class="line-removed">  67              n-&gt;in(1)-&gt;in(ValueIn)-&gt;Opcode() == Op_CastPP) {</span>
<span class="line-removed">  68     Node* iff = n-&gt;in(0)-&gt;in(1)-&gt;in(0);</span>
<span class="line-removed">  69     Node* res = n-&gt;in(1)-&gt;in(ValueIn)-&gt;in(1);</span>
<span class="line-removed">  70     if (iff-&gt;is_If() &amp;&amp;</span>
<span class="line-removed">  71         iff-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  72         iff-&gt;in(1)-&gt;is_Bool() &amp;&amp;</span>
<span class="line-removed">  73         iff-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-removed">  74         iff-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  75         iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-removed">  76         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  77         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) == res &amp;&amp;</span>
<span class="line-removed">  78         iff-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  79         iff-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-removed">  80       return res;</span>
<span class="line-removed">  81     }</span>
<span class="line-removed">  82   }</span>
<span class="line-removed">  83   return n;</span>
<span class="line-removed">  84 }</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86 bool ShenandoahBarrierNode::needs_barrier(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace) {</span>
<span class="line-removed">  87   Unique_Node_List visited;</span>
<span class="line-removed">  88   return needs_barrier_impl(phase, orig, n, rb_mem, allow_fromspace, visited);</span>
<span class="line-removed">  89 }</span>
<span class="line-removed">  90 </span>
<span class="line-removed">  91 bool ShenandoahBarrierNode::needs_barrier_impl(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace, Unique_Node_List &amp;visited) {</span>
<span class="line-removed">  92   if (visited.member(n)) {</span>
<span class="line-removed">  93     return false; // Been there.</span>
<span class="line-removed">  94   }</span>
<span class="line-removed">  95   visited.push(n);</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97   if (n-&gt;is_Allocate()) {</span>
<span class="line-removed">  98     return false;</span>
<span class="line-removed">  99   }</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101   if (n-&gt;is_Call()) {</span>
<span class="line-removed"> 102     return true;</span>
<span class="line-removed"> 103   }</span>
<span class="line-removed"> 104 </span>
<span class="line-removed"> 105   const Type* type = phase-&gt;type(n);</span>
<span class="line-removed"> 106   if (type == Type::TOP) {</span>
<span class="line-removed"> 107     return false;</span>
<span class="line-removed"> 108   }</span>
<span class="line-removed"> 109   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-removed"> 110     return false;</span>
<span class="line-removed"> 111   }</span>
<span class="line-removed"> 112   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {</span>
<span class="line-removed"> 113     return false;</span>
<span class="line-removed"> 114   }</span>
<span class="line-removed"> 115 </span>
<span class="line-removed"> 116   if (ShenandoahOptimizeStableFinals) {</span>
<span class="line-removed"> 117     const TypeAryPtr* ary = type-&gt;isa_aryptr();</span>
<span class="line-removed"> 118     if (ary &amp;&amp; ary-&gt;is_stable() &amp;&amp; allow_fromspace) {</span>
<span class="line-removed"> 119       return false;</span>
<span class="line-removed"> 120     }</span>
<span class="line-removed"> 121   }</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123   if (n-&gt;is_CheckCastPP() || n-&gt;is_ConstraintCast() || n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-removed"> 124     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 125   }</span>
<span class="line-removed"> 126   if (n-&gt;is_Parm()) {</span>
<span class="line-removed"> 127     return true;</span>
<span class="line-removed"> 128   }</span>
<span class="line-removed"> 129   if (n-&gt;is_Proj()) {</span>
<span class="line-removed"> 130     return needs_barrier_impl(phase, orig, n-&gt;in(0), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 131   }</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133   if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 134     return needs_barrier_impl(phase, orig, n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 135   }</span>
<span class="line-removed"> 136   if (n-&gt;is_Phi()) {</span>
<span class="line-removed"> 137     bool need_barrier = false;</span>
<span class="line-removed"> 138     for (uint i = 1; i &lt; n-&gt;req() &amp;&amp; ! need_barrier; i++) {</span>
<span class="line-removed"> 139       Node* input = n-&gt;in(i);</span>
<span class="line-removed"> 140       if (input == NULL) {</span>
<span class="line-removed"> 141         need_barrier = true; // Phi not complete yet?</span>
<span class="line-removed"> 142       } else if (needs_barrier_impl(phase, orig, input, rb_mem, allow_fromspace, visited)) {</span>
<span class="line-removed"> 143         need_barrier = true;</span>
<span class="line-removed"> 144       }</span>
<span class="line-removed"> 145     }</span>
<span class="line-removed"> 146     return need_barrier;</span>
<span class="line-removed"> 147   }</span>
<span class="line-removed"> 148   if (n-&gt;is_CMove()) {</span>
<span class="line-removed"> 149     return needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfFalse), rb_mem, allow_fromspace, visited) ||</span>
<span class="line-removed"> 150            needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfTrue ), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 151   }</span>
<span class="line-removed"> 152   if (n-&gt;Opcode() == Op_CreateEx) {</span>
<span class="line-removed"> 153     return true;</span>
<span class="line-removed"> 154   }</span>
<span class="line-removed"> 155   if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 156     return false;</span>
<span class="line-removed"> 157   }</span>
<span class="line-removed"> 158   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {</span>
<span class="line-removed"> 159     if (rb_mem == n-&gt;in(Memory)) {</span>
<span class="line-removed"> 160       return false;</span>
<span class="line-removed"> 161     } else {</span>
<span class="line-removed"> 162       return true;</span>
<span class="line-removed"> 163     }</span>
<span class="line-removed"> 164   }</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166   if (n-&gt;Opcode() == Op_LoadP ||</span>
<span class="line-removed"> 167       n-&gt;Opcode() == Op_LoadN ||</span>
<span class="line-removed"> 168       n-&gt;Opcode() == Op_GetAndSetP ||</span>
<span class="line-removed"> 169       n-&gt;Opcode() == Op_CompareAndExchangeP ||</span>
<span class="line-removed"> 170       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ||</span>
<span class="line-removed"> 171       n-&gt;Opcode() == Op_GetAndSetN ||</span>
<span class="line-removed"> 172       n-&gt;Opcode() == Op_CompareAndExchangeN ||</span>
<span class="line-removed"> 173       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) {</span>
<span class="line-removed"> 174     return true;</span>
<span class="line-removed"> 175   }</span>
<span class="line-removed"> 176   if (n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="line-removed"> 177       n-&gt;Opcode() == Op_EncodeP) {</span>
<span class="line-removed"> 178     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 179   }</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181 #ifdef ASSERT</span>
<span class="line-removed"> 182   tty-&gt;print(&quot;need barrier on?: &quot;); n-&gt;dump();</span>
<span class="line-removed"> 183   ShouldNotReachHere();</span>
<span class="line-removed"> 184 #endif</span>
<span class="line-removed"> 185   return true;</span>
<span class="line-removed"> 186 }</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188 bool ShenandoahReadBarrierNode::dominates_memory_rb_impl(PhaseGVN* phase,</span>
<span class="line-removed"> 189                                                          Node* b1,</span>
<span class="line-removed"> 190                                                          Node* b2,</span>
<span class="line-removed"> 191                                                          Node* current,</span>
<span class="line-removed"> 192                                                          bool linear) {</span>
<span class="line-removed"> 193   ResourceMark rm;</span>
<span class="line-removed"> 194   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 195   Node_Stack phis(0);</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197   for(int i = 0; i &lt; 10; i++) {</span>
<span class="line-removed"> 198     if (current == NULL) {</span>
<span class="line-removed"> 199       return false;</span>
<span class="line-removed"> 200     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="line-removed"> 201       current = NULL;</span>
<span class="line-removed"> 202       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="line-removed"> 203         uint idx = phis.index();</span>
<span class="line-removed"> 204         Node* phi = phis.node();</span>
<span class="line-removed"> 205         if (idx &gt;= phi-&gt;req()) {</span>
<span class="line-removed"> 206           phis.pop();</span>
<span class="line-removed"> 207         } else {</span>
<span class="line-removed"> 208           current = phi-&gt;in(idx);</span>
<span class="line-removed"> 209           phis.set_index(idx+1);</span>
<span class="line-removed"> 210         }</span>
<span class="line-removed"> 211       }</span>
<span class="line-removed"> 212       if (current == NULL) {</span>
<span class="line-removed"> 213         return true;</span>
<span class="line-removed"> 214       }</span>
<span class="line-removed"> 215     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="line-removed"> 216       return false;</span>
<span class="line-removed"> 217     } else if (current-&gt;isa_Phi()) {</span>
<span class="line-removed"> 218       if (!linear) {</span>
<span class="line-removed"> 219         return false;</span>
<span class="line-removed"> 220       }</span>
<span class="line-removed"> 221       phis.push(current, 2);</span>
<span class="line-removed"> 222       current = current-&gt;in(1);</span>
<span class="line-removed"> 223     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 224       const Type* in_type = current-&gt;bottom_type();</span>
<span class="line-removed"> 225       const Type* this_type = b2-&gt;bottom_type();</span>
<span class="line-removed"> 226       if (is_independent(in_type, this_type)) {</span>
<span class="line-removed"> 227         current = current-&gt;in(Memory);</span>
<span class="line-removed"> 228       } else {</span>
 229         return false;
 230       }
<span class="line-removed"> 231     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 232       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 233     } else if (current-&gt;is_Proj()) {</span>
<span class="line-removed"> 234       current = current-&gt;in(0);</span>
<span class="line-removed"> 235     } else if (current-&gt;is_Call()) {</span>
<span class="line-removed"> 236       return false; // TODO: Maybe improve by looking at the call&#39;s memory effects?</span>
<span class="line-removed"> 237     } else if (current-&gt;is_MemBar()) {</span>
<span class="line-removed"> 238       return false; // TODO: Do we need to stop at *any* membar?</span>
<span class="line-removed"> 239     } else if (current-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 240       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="line-removed"> 241       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 242       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 243     } else {</span>
<span class="line-removed"> 244 #ifdef ASSERT</span>
<span class="line-removed"> 245       current-&gt;dump();</span>
<span class="line-removed"> 246 #endif</span>
<span class="line-removed"> 247       ShouldNotReachHere();</span>
<span class="line-removed"> 248       return false;</span>
<span class="line-removed"> 249     }</span>
<span class="line-removed"> 250   }</span>
<span class="line-removed"> 251   return false;</span>
<span class="line-removed"> 252 }</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254 bool ShenandoahReadBarrierNode::is_independent(Node* mem) {</span>
<span class="line-removed"> 255   if (mem-&gt;is_Phi() || mem-&gt;is_Proj() || mem-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 256     return true;</span>
<span class="line-removed"> 257   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 258     return true;</span>
<span class="line-removed"> 259   } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 260     const Type* mem_type = mem-&gt;bottom_type();</span>
<span class="line-removed"> 261     const Type* this_type = bottom_type();</span>
<span class="line-removed"> 262     if (is_independent(mem_type, this_type)) {</span>
<span class="line-removed"> 263       return true;</span>
<span class="line-removed"> 264     } else {</span>
<span class="line-removed"> 265       return false;</span>
<span class="line-removed"> 266     }</span>
<span class="line-removed"> 267   } else if (mem-&gt;is_Call() || mem-&gt;is_MemBar()) {</span>
<span class="line-removed"> 268     return false;</span>
<span class="line-removed"> 269   }</span>
<span class="line-removed"> 270 #ifdef ASSERT</span>
<span class="line-removed"> 271   mem-&gt;dump();</span>
<span class="line-removed"> 272 #endif</span>
<span class="line-removed"> 273   ShouldNotReachHere();</span>
<span class="line-removed"> 274   return true;</span>
<span class="line-removed"> 275 }</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277 bool ShenandoahReadBarrierNode::dominates_memory_rb(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="line-removed"> 278   return dominates_memory_rb_impl(phase, b1-&gt;in(Memory), b2, b2-&gt;in(Memory), linear);</span>
<span class="line-removed"> 279 }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281 bool ShenandoahReadBarrierNode::is_independent(const Type* in_type, const Type* this_type) {</span>
<span class="line-removed"> 282   assert(in_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="line-removed"> 283   assert(this_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="line-removed"> 284 </span>
<span class="line-removed"> 285   ciKlass* in_kls = in_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-removed"> 286   ciKlass* this_kls = this_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-removed"> 287   if (in_kls != NULL &amp;&amp; this_kls != NULL &amp;&amp;</span>
<span class="line-removed"> 288       in_kls-&gt;is_loaded() &amp;&amp; this_kls-&gt;is_loaded() &amp;&amp;</span>
<span class="line-removed"> 289       (!in_kls-&gt;is_subclass_of(this_kls)) &amp;&amp;</span>
<span class="line-removed"> 290       (!this_kls-&gt;is_subclass_of(in_kls))) {</span>
<span class="line-removed"> 291     return true;</span>
<span class="line-removed"> 292   }</span>
<span class="line-removed"> 293   return false;</span>
<span class="line-removed"> 294 }</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296 Node* ShenandoahReadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed"> 297   if (! can_reshape) {</span>
<span class="line-removed"> 298     return NULL;</span>
<span class="line-removed"> 299   }</span>
<span class="line-removed"> 300 </span>
<span class="line-removed"> 301   if (in(Memory) == phase-&gt;C-&gt;immutable_memory()) return NULL;</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303   // If memory input is a MergeMem, take the appropriate slice out of it.</span>
<span class="line-removed"> 304   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 305   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="line-removed"> 306     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="line-removed"> 307     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 308     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 309     set_req(Memory, mem_in);</span>
<span class="line-removed"> 310     return this;</span>
<span class="line-removed"> 311   }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313   Node* input = in(Memory);</span>
<span class="line-removed"> 314   if (input-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 315     ResourceMark rm;</span>
<span class="line-removed"> 316     VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 317     Node* n = in(Memory);</span>
<span class="line-removed"> 318     while (n-&gt;Opcode() == Op_ShenandoahWBMemProj &amp;&amp;</span>
<span class="line-removed"> 319            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier) != NULL &amp;&amp;</span>
<span class="line-removed"> 320            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="line-removed"> 321            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory) != NULL) {</span>
<span class="line-removed"> 322       if (seen.test_set(n-&gt;_idx)) {</span>
<span class="line-removed"> 323         return NULL; // loop</span>
<span class="line-removed"> 324       }</span>
<span class="line-removed"> 325       n = n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory);</span>
<span class="line-removed"> 326     }</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328     Node* wb = input-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 329     const Type* in_type = phase-&gt;type(wb);</span>
<span class="line-removed"> 330     // is_top() test not sufficient here: we can come here after CCP</span>
<span class="line-removed"> 331     // in a dead branch of the graph that has not yet been removed.</span>
<span class="line-removed"> 332     if (in_type == Type::TOP) return NULL; // Dead path.</span>
<span class="line-removed"> 333     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="line-removed"> 334     if (is_independent(in_type, _type)) {</span>
<span class="line-removed"> 335       phase-&gt;igvn_rehash_node_delayed(wb);</span>
<span class="line-removed"> 336       set_req(Memory, wb-&gt;in(Memory));</span>
<span class="line-removed"> 337       if (can_reshape &amp;&amp; input-&gt;outcnt() == 0) {</span>
<span class="line-removed"> 338         phase-&gt;is_IterGVN()-&gt;_worklist.push(input);</span>
<span class="line-removed"> 339       }</span>
<span class="line-removed"> 340       return this;</span>
<span class="line-removed"> 341     }</span>
<span class="line-removed"> 342   }</span>
<span class="line-removed"> 343   return NULL;</span>
<span class="line-removed"> 344 }</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346 ShenandoahWriteBarrierNode::ShenandoahWriteBarrierNode(Compile* C, Node* ctrl, Node* mem, Node* obj)</span>
<span class="line-removed"> 347   : ShenandoahBarrierNode(ctrl, mem, obj, false) {</span>
<span class="line-removed"> 348   assert(UseShenandoahGC &amp;&amp; ShenandoahWriteBarrier, &quot;should be enabled&quot;);</span>
<span class="line-removed"> 349   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_shenandoah_barrier(this);</span>
<span class="line-removed"> 350 }</span>
<span class="line-removed"> 351 </span>
<span class="line-removed"> 352 Node* ShenandoahWriteBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 353   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="line-removed"> 354   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 355   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 356   Node* mem_proj = NULL;</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   if (igvn != NULL) {</span>
<span class="line-removed"> 359     mem_proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed"> 360     if (mem_in == mem_proj) {</span>
<span class="line-removed"> 361       return this;</span>
<span class="line-removed"> 362     }</span>
<span class="line-removed"> 363   }</span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365   Node* replacement = Identity_impl(phase);</span>
<span class="line-removed"> 366   if (igvn != NULL) {</span>
<span class="line-removed"> 367     if (replacement != NULL &amp;&amp; replacement != this &amp;&amp; mem_proj != NULL) {</span>
<span class="line-removed"> 368       igvn-&gt;replace_node(mem_proj, mem_in);</span>
<span class="line-removed"> 369     }</span>
<span class="line-removed"> 370   }</span>
<span class="line-removed"> 371   return replacement;</span>
<span class="line-removed"> 372 }</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374 Node* ShenandoahWriteBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed"> 375   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="line-removed"> 376   if (!can_reshape) {</span>
<span class="line-removed"> 377     return NULL;</span>
<span class="line-removed"> 378   }</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="line-removed"> 383     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="line-removed"> 384     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 385     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 386     set_req(Memory, mem_in);</span>
<span class="line-removed"> 387     return this;</span>
<span class="line-removed"> 388   }</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390   Node* val = in(ValueIn);</span>
<span class="line-removed"> 391   if (val-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed"> 392     set_req(ValueIn, val-&gt;in(ValueIn));</span>
<span class="line-removed"> 393     return this;</span>
<span class="line-removed"> 394   }</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   return NULL;</span>
<span class="line-removed"> 397 }</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399 bool ShenandoahWriteBarrierNode::expand(Compile* C, PhaseIterGVN&amp; igvn) {</span>
<span class="line-removed"> 400   if (UseShenandoahGC) {</span>
<span class="line-removed"> 401     if (ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() &gt; 0 || (!ShenandoahWriteBarrier &amp;&amp; ShenandoahStoreValEnqueueBarrier)) {</span>
<span class="line-removed"> 402       bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;</span>
 403       C-&gt;clear_major_progress();
<span class="line-modified"> 404       PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);</span>
<span class="line-modified"> 405       if (C-&gt;failing()) return false;</span>
<span class="line-modified"> 406       PhaseIdealLoop::verify(igvn);</span>
<span class="line-modified"> 407       DEBUG_ONLY(ShenandoahBarrierNode::verify_raw_mem(C-&gt;root());)</span>
<span class="line-removed"> 408       if (attempt_more_loopopts) {</span>
<span class="line-removed"> 409         C-&gt;set_major_progress();</span>
<span class="line-removed"> 410         if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {</span>
<span class="line-removed"> 411           return false;</span>
<span class="line-removed"> 412         }</span>
<span class="line-removed"> 413         C-&gt;clear_major_progress();</span>
 414       }
 415     }
 416   }
 417   return true;
 418 }
 419 
<span class="line-modified"> 420 bool ShenandoahWriteBarrierNode::is_heap_state_test(Node* iff, int mask) {</span>
 421   if (!UseShenandoahGC) {
 422     return false;
 423   }
 424   assert(iff-&gt;is_If(), &quot;bad input&quot;);
 425   if (iff-&gt;Opcode() != Op_If) {
 426     return false;
 427   }
 428   Node* bol = iff-&gt;in(1);
 429   if (!bol-&gt;is_Bool() || bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne) {
 430     return false;
 431   }
 432   Node* cmp = bol-&gt;in(1);
 433   if (cmp-&gt;Opcode() != Op_CmpI) {
 434     return false;
 435   }
 436   Node* in1 = cmp-&gt;in(1);
 437   Node* in2 = cmp-&gt;in(2);
 438   if (in2-&gt;find_int_con(-1) != 0) {
 439     return false;
 440   }
 441   if (in1-&gt;Opcode() != Op_AndI) {
 442     return false;
 443   }
 444   in2 = in1-&gt;in(2);
 445   if (in2-&gt;find_int_con(-1) != mask) {
 446     return false;
 447   }
 448   in1 = in1-&gt;in(1);
 449 
 450   return is_gc_state_load(in1);
 451 }
 452 
<span class="line-modified"> 453 bool ShenandoahWriteBarrierNode::is_heap_stable_test(Node* iff) {</span>
 454   return is_heap_state_test(iff, ShenandoahHeap::HAS_FORWARDED);
 455 }
 456 
<span class="line-modified"> 457 bool ShenandoahWriteBarrierNode::is_gc_state_load(Node *n) {</span>
 458   if (!UseShenandoahGC) {
 459     return false;
 460   }
 461   if (n-&gt;Opcode() != Op_LoadB &amp;&amp; n-&gt;Opcode() != Op_LoadUB) {
 462     return false;
 463   }
 464   Node* addp = n-&gt;in(MemNode::Address);
 465   if (!addp-&gt;is_AddP()) {
 466     return false;
 467   }
 468   Node* base = addp-&gt;in(AddPNode::Address);
 469   Node* off = addp-&gt;in(AddPNode::Offset);
 470   if (base-&gt;Opcode() != Op_ThreadLocal) {
 471     return false;
 472   }
 473   if (off-&gt;find_intptr_t_con(-1) != in_bytes(ShenandoahThreadLocalData::gc_state_offset())) {
 474     return false;
 475   }
 476   return true;
 477 }
 478 
<span class="line-modified"> 479 bool ShenandoahWriteBarrierNode::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {</span>
 480   assert(phase-&gt;is_dominator(stop, start), &quot;bad inputs&quot;);
 481   ResourceMark rm;
 482   Unique_Node_List wq;
 483   wq.push(start);
 484   for (uint next = 0; next &lt; wq.size(); next++) {
 485     Node *m = wq.at(next);
 486     if (m == stop) {
 487       continue;
 488     }
 489     if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
 490       return true;
 491     }
 492     if (m-&gt;is_Region()) {
 493       for (uint i = 1; i &lt; m-&gt;req(); i++) {
 494         wq.push(m-&gt;in(i));
 495       }
 496     } else {
 497       wq.push(m-&gt;in(0));
 498     }
 499   }
 500   return false;
 501 }
 502 
<span class="line-modified"> 503 bool ShenandoahWriteBarrierNode::try_common_gc_state_load(Node *n, PhaseIdealLoop *phase) {</span>
 504   assert(is_gc_state_load(n), &quot;inconsistent&quot;);
 505   Node* addp = n-&gt;in(MemNode::Address);
 506   Node* dominator = NULL;
 507   for (DUIterator_Fast imax, i = addp-&gt;fast_outs(imax); i &lt; imax; i++) {
 508     Node* u = addp-&gt;fast_out(i);
 509     assert(is_gc_state_load(u), &quot;inconsistent&quot;);
 510     if (u != n &amp;&amp; phase-&gt;is_dominator(u-&gt;in(0), n-&gt;in(0))) {
 511       if (dominator == NULL) {
 512         dominator = u;
 513       } else {
 514         if (phase-&gt;dom_depth(u-&gt;in(0)) &lt; phase-&gt;dom_depth(dominator-&gt;in(0))) {
 515           dominator = u;
 516         }
 517       }
 518     }
 519   }
 520   if (dominator == NULL || has_safepoint_between(n-&gt;in(0), dominator-&gt;in(0), phase)) {
 521     return false;
 522   }
 523   phase-&gt;igvn().replace_node(n, dominator);
 524 
 525   return true;
 526 }
 527 
<span class="line-removed"> 528 bool ShenandoahBarrierNode::dominates_memory_impl(PhaseGVN* phase,</span>
<span class="line-removed"> 529                                                   Node* b1,</span>
<span class="line-removed"> 530                                                   Node* b2,</span>
<span class="line-removed"> 531                                                   Node* current,</span>
<span class="line-removed"> 532                                                   bool linear) {</span>
<span class="line-removed"> 533   ResourceMark rm;</span>
<span class="line-removed"> 534   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 535   Node_Stack phis(0);</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537   for(int i = 0; i &lt; 10; i++) {</span>
<span class="line-removed"> 538     if (current == NULL) {</span>
<span class="line-removed"> 539       return false;</span>
<span class="line-removed"> 540     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="line-removed"> 541       current = NULL;</span>
<span class="line-removed"> 542       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="line-removed"> 543         uint idx = phis.index();</span>
<span class="line-removed"> 544         Node* phi = phis.node();</span>
<span class="line-removed"> 545         if (idx &gt;= phi-&gt;req()) {</span>
<span class="line-removed"> 546           phis.pop();</span>
<span class="line-removed"> 547         } else {</span>
<span class="line-removed"> 548           current = phi-&gt;in(idx);</span>
<span class="line-removed"> 549           phis.set_index(idx+1);</span>
<span class="line-removed"> 550         }</span>
<span class="line-removed"> 551       }</span>
<span class="line-removed"> 552       if (current == NULL) {</span>
<span class="line-removed"> 553         return true;</span>
<span class="line-removed"> 554       }</span>
<span class="line-removed"> 555     } else if (current == b2) {</span>
<span class="line-removed"> 556       return false;</span>
<span class="line-removed"> 557     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="line-removed"> 558       return false;</span>
<span class="line-removed"> 559     } else if (current-&gt;isa_Phi()) {</span>
<span class="line-removed"> 560       if (!linear) {</span>
<span class="line-removed"> 561         return false;</span>
<span class="line-removed"> 562       }</span>
<span class="line-removed"> 563       phis.push(current, 2);</span>
<span class="line-removed"> 564       current = current-&gt;in(1);</span>
<span class="line-removed"> 565     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 566       current = current-&gt;in(Memory);</span>
<span class="line-removed"> 567     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 568       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 569     } else if (current-&gt;is_Proj()) {</span>
<span class="line-removed"> 570       current = current-&gt;in(0);</span>
<span class="line-removed"> 571     } else if (current-&gt;is_Call()) {</span>
<span class="line-removed"> 572       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 573     } else if (current-&gt;is_MemBar()) {</span>
<span class="line-removed"> 574       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 575     } else if (current-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 576       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="line-removed"> 577       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 578       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 579     } else {</span>
<span class="line-removed"> 580 #ifdef ASSERT</span>
<span class="line-removed"> 581       current-&gt;dump();</span>
<span class="line-removed"> 582 #endif</span>
<span class="line-removed"> 583       ShouldNotReachHere();</span>
<span class="line-removed"> 584       return false;</span>
<span class="line-removed"> 585     }</span>
<span class="line-removed"> 586   }</span>
<span class="line-removed"> 587   return false;</span>
<span class="line-removed"> 588 }</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590 /**</span>
<span class="line-removed"> 591  * Determines if b1 dominates b2 through memory inputs. It returns true if:</span>
<span class="line-removed"> 592  * - b1 can be reached by following each branch in b2&#39;s memory input (through phis, etc)</span>
<span class="line-removed"> 593  * - or we get back to b2 (i.e. through a loop) without seeing b1</span>
<span class="line-removed"> 594  * In all other cases, (in particular, if we reach immutable_memory without having seen b1)</span>
<span class="line-removed"> 595  * we return false.</span>
<span class="line-removed"> 596  */</span>
<span class="line-removed"> 597 bool ShenandoahBarrierNode::dominates_memory(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="line-removed"> 598   return dominates_memory_impl(phase, b1, b2, b2-&gt;in(Memory), linear);</span>
<span class="line-removed"> 599 }</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601 Node* ShenandoahBarrierNode::Identity_impl(PhaseGVN* phase) {</span>
<span class="line-removed"> 602   Node* n = in(ValueIn);</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604   Node* rb_mem = Opcode() == Op_ShenandoahReadBarrier ? in(Memory) : NULL;</span>
<span class="line-removed"> 605   if (! needs_barrier(phase, this, n, rb_mem, _allow_fromspace)) {</span>
<span class="line-removed"> 606     return n;</span>
<span class="line-removed"> 607   }</span>
<span class="line-removed"> 608 </span>
<span class="line-removed"> 609   // Try to find a write barrier sibling with identical inputs that we can fold into.</span>
<span class="line-removed"> 610   for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-removed"> 611     Node* sibling = n-&gt;out(i);</span>
<span class="line-removed"> 612     if (sibling == this) {</span>
<span class="line-removed"> 613       continue;</span>
<span class="line-removed"> 614     }</span>
<span class="line-removed"> 615     if (sibling-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 616       continue;</span>
<span class="line-removed"> 617     }</span>
<span class="line-removed"> 618 </span>
<span class="line-removed"> 619     assert(sibling-&gt;in(ValueIn) == in(ValueIn), &quot;sanity&quot;);</span>
<span class="line-removed"> 620     assert(sibling-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;sanity&quot;);</span>
<span class="line-removed"> 621 </span>
<span class="line-removed"> 622     if (dominates_memory(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="line-removed"> 623       return sibling;</span>
<span class="line-removed"> 624     }</span>
<span class="line-removed"> 625   }</span>
<span class="line-removed"> 626   return this;</span>
<span class="line-removed"> 627 }</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629 #ifndef PRODUCT</span>
<span class="line-removed"> 630 void ShenandoahBarrierNode::dump_spec(outputStream *st) const {</span>
<span class="line-removed"> 631   const TypePtr* adr = adr_type();</span>
<span class="line-removed"> 632   if (adr == NULL) {</span>
<span class="line-removed"> 633     return;</span>
<span class="line-removed"> 634   }</span>
<span class="line-removed"> 635   st-&gt;print(&quot; @&quot;);</span>
<span class="line-removed"> 636   adr-&gt;dump_on(st);</span>
<span class="line-removed"> 637   st-&gt;print(&quot; (&quot;);</span>
<span class="line-removed"> 638   Compile::current()-&gt;alias_type(adr)-&gt;adr_type()-&gt;dump_on(st);</span>
<span class="line-removed"> 639   st-&gt;print(&quot;) &quot;);</span>
<span class="line-removed"> 640 }</span>
<span class="line-removed"> 641 #endif</span>
<span class="line-removed"> 642 </span>
<span class="line-removed"> 643 Node* ShenandoahReadBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 644   Node* id = Identity_impl(phase);</span>
<span class="line-removed"> 645 </span>
<span class="line-removed"> 646   if (id == this &amp;&amp; phase-&gt;is_IterGVN()) {</span>
<span class="line-removed"> 647     Node* n = in(ValueIn);</span>
<span class="line-removed"> 648     // No success in super call. Try to combine identical read barriers.</span>
<span class="line-removed"> 649     for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-removed"> 650       Node* sibling = n-&gt;out(i);</span>
<span class="line-removed"> 651       if (sibling == this || sibling-&gt;Opcode() != Op_ShenandoahReadBarrier) {</span>
<span class="line-removed"> 652         continue;</span>
<span class="line-removed"> 653       }</span>
<span class="line-removed"> 654       assert(sibling-&gt;in(ValueIn)  == in(ValueIn), &quot;sanity&quot;);</span>
<span class="line-removed"> 655       if (phase-&gt;is_IterGVN()-&gt;hash_find(sibling) &amp;&amp;</span>
<span class="line-removed"> 656           sibling-&gt;bottom_type() == bottom_type() &amp;&amp;</span>
<span class="line-removed"> 657           sibling-&gt;in(Control) == in(Control) &amp;&amp;</span>
<span class="line-removed"> 658           dominates_memory_rb(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="line-removed"> 659         return sibling;</span>
<span class="line-removed"> 660       }</span>
<span class="line-removed"> 661     }</span>
<span class="line-removed"> 662   }</span>
<span class="line-removed"> 663   return id;</span>
<span class="line-removed"> 664 }</span>
<span class="line-removed"> 665 </span>
<span class="line-removed"> 666 const Type* ShenandoahBarrierNode::Value(PhaseGVN* phase) const {</span>
<span class="line-removed"> 667   // Either input is TOP ==&gt; the result is TOP</span>
<span class="line-removed"> 668   const Type *t1 = phase-&gt;type(in(Memory));</span>
<span class="line-removed"> 669   if (t1 == Type::TOP) return Type::TOP;</span>
<span class="line-removed"> 670   const Type *t2 = phase-&gt;type(in(ValueIn));</span>
<span class="line-removed"> 671   if( t2 == Type::TOP ) return Type::TOP;</span>
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673   if (t2 == TypePtr::NULL_PTR) {</span>
<span class="line-removed"> 674     return _type;</span>
<span class="line-removed"> 675   }</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677   const Type* type = t2-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="line-removed"> 678   return type;</span>
<span class="line-removed"> 679 }</span>
<span class="line-removed"> 680 </span>
<span class="line-removed"> 681 uint ShenandoahBarrierNode::hash() const {</span>
<span class="line-removed"> 682   return TypeNode::hash() + _allow_fromspace;</span>
<span class="line-removed"> 683 }</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685 uint ShenandoahBarrierNode::cmp(const Node&amp; n) const {</span>
<span class="line-removed"> 686   return _allow_fromspace == ((ShenandoahBarrierNode&amp;) n)._allow_fromspace</span>
<span class="line-removed"> 687     &amp;&amp; TypeNode::cmp(n);</span>
<span class="line-removed"> 688 }</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690 uint ShenandoahBarrierNode::size_of() const {</span>
<span class="line-removed"> 691   return sizeof(*this);</span>
<span class="line-removed"> 692 }</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694 Node* ShenandoahWBMemProjNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 695   Node* wb = in(WriteBarrier);</span>
<span class="line-removed"> 696   if (wb-&gt;is_top()) return phase-&gt;C-&gt;top(); // Dead path.</span>
<span class="line-removed"> 697 </span>
<span class="line-removed"> 698   assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="line-removed"> 699   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 700   // We can&#39;t do the below unless the graph is fully constructed.</span>
<span class="line-removed"> 701   if (igvn == NULL) {</span>
<span class="line-removed"> 702     return this;</span>
<span class="line-removed"> 703   }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705   // If the mem projection has no barrier users, it&#39;s not needed anymore.</span>
<span class="line-removed"> 706   if (wb-&gt;outcnt() == 1) {</span>
<span class="line-removed"> 707     return wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed"> 708   }</span>
<span class="line-removed"> 709 </span>
<span class="line-removed"> 710   return this;</span>
<span class="line-removed"> 711 }</span>
<span class="line-removed"> 712 </span>
 713 #ifdef ASSERT
<span class="line-modified"> 714 bool ShenandoahBarrierNode::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {</span>
 715   assert(phis.size() == 0, &quot;&quot;);
 716 
 717   while (true) {
 718     if (in-&gt;bottom_type() == TypePtr::NULL_PTR) {
 719       if (trace) {tty-&gt;print_cr(&quot;NULL&quot;);}
 720     } else if (!in-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 721       if (trace) {tty-&gt;print_cr(&quot;Non oop&quot;);}
<span class="line-removed"> 722     } else if (t == ShenandoahLoad &amp;&amp; ShenandoahOptimizeStableFinals &amp;&amp;</span>
<span class="line-removed"> 723                in-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_aryptr() &amp;&amp;</span>
<span class="line-removed"> 724                in-&gt;bottom_type()-&gt;make_ptr()-&gt;is_aryptr()-&gt;is_stable()) {</span>
<span class="line-removed"> 725       if (trace) {tty-&gt;print_cr(&quot;Stable array load&quot;);}</span>
 726     } else {
 727       if (in-&gt;is_ConstraintCast()) {
 728         in = in-&gt;in(1);
 729         continue;
 730       } else if (in-&gt;is_AddP()) {
 731         assert(!in-&gt;in(AddPNode::Address)-&gt;is_top(), &quot;no raw memory access&quot;);
 732         in = in-&gt;in(AddPNode::Address);
 733         continue;
 734       } else if (in-&gt;is_Con()) {
<span class="line-modified"> 735         if (trace) {tty-&gt;print(&quot;Found constant&quot;); in-&gt;dump();}</span>
<span class="line-modified"> 736       } else if (in-&gt;is_ShenandoahBarrier()) {</span>















 737         if (t == ShenandoahOopStore) {
<span class="line-removed"> 738           if (in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 739             return false;</span>
<span class="line-removed"> 740           }</span>
 741           uint i = 0;
 742           for (; i &lt; phis.size(); i++) {
 743             Node* n = phis.node_at(i);
 744             if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 745               break;
 746             }
 747           }
 748           if (i == phis.size()) {
 749             return false;
 750           }
<span class="line-removed"> 751         } else if (t == ShenandoahStore &amp;&amp; in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 752           return false;</span>
 753         }
 754         barriers_used.push(in);
 755         if (trace) {tty-&gt;print(&quot;Found barrier&quot;); in-&gt;dump();}
 756       } else if (in-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 757         if (t != ShenandoahOopStore) {
 758           in = in-&gt;in(1);
 759           continue;
 760         }
 761         if (trace) {tty-&gt;print(&quot;Found enqueue barrier&quot;); in-&gt;dump();}
 762         phis.push(in, in-&gt;req());
 763         in = in-&gt;in(1);
 764         continue;
 765       } else if (in-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;is_Allocate()) {
<span class="line-modified"> 766         if (trace) {tty-&gt;print(&quot;Found alloc&quot;); in-&gt;in(0)-&gt;dump();}</span>







 767       } else if (in-&gt;is_Phi()) {
 768         if (!visited.test_set(in-&gt;_idx)) {
 769           if (trace) {tty-&gt;print(&quot;Pushed phi:&quot;); in-&gt;dump();}
 770           phis.push(in, 2);
 771           in = in-&gt;in(1);
 772           continue;
 773         }
 774         if (trace) {tty-&gt;print(&quot;Already seen phi:&quot;); in-&gt;dump();}
 775       } else if (in-&gt;Opcode() == Op_CMoveP || in-&gt;Opcode() == Op_CMoveN) {
 776         if (!visited.test_set(in-&gt;_idx)) {
 777           if (trace) {tty-&gt;print(&quot;Pushed cmovep:&quot;); in-&gt;dump();}
 778           phis.push(in, CMoveNode::IfTrue);
 779           in = in-&gt;in(CMoveNode::IfFalse);
 780           continue;
 781         }
 782         if (trace) {tty-&gt;print(&quot;Already seen cmovep:&quot;); in-&gt;dump();}
 783       } else if (in-&gt;Opcode() == Op_EncodeP || in-&gt;Opcode() == Op_DecodeN) {
 784         in = in-&gt;in(1);
 785         continue;
 786       } else {
</pre>
<hr />
<pre>
 792       uint idx = phis.index();
 793       Node* phi = phis.node();
 794       if (idx &gt;= phi-&gt;req()) {
 795         if (trace) {tty-&gt;print(&quot;Popped phi:&quot;); phi-&gt;dump();}
 796         phis.pop();
 797         continue;
 798       }
 799       if (trace) {tty-&gt;print(&quot;Next entry(%d) for phi:&quot;, idx); phi-&gt;dump();}
 800       in = phi-&gt;in(idx);
 801       phis.set_index(idx+1);
 802       cont = true;
 803       break;
 804     }
 805     if (!cont) {
 806       break;
 807     }
 808   }
 809   return true;
 810 }
 811 
<span class="line-modified"> 812 void ShenandoahBarrierNode::report_verify_failure(const char *msg, Node *n1, Node *n2) {</span>
 813   if (n1 != NULL) {
 814     n1-&gt;dump(+10);
 815   }
 816   if (n2 != NULL) {
 817     n2-&gt;dump(+10);
 818   }
 819   fatal(&quot;%s&quot;, msg);
 820 }
 821 
<span class="line-modified"> 822 void ShenandoahBarrierNode::verify(RootNode* root) {</span>
 823   ResourceMark rm;
 824   Unique_Node_List wq;
 825   GrowableArray&lt;Node*&gt; barriers;
 826   Unique_Node_List barriers_used;
 827   Node_Stack phis(0);
 828   VectorSet visited(Thread::current()-&gt;resource_area());
 829   const bool trace = false;
 830   const bool verify_no_useless_barrier = false;
 831 
 832   wq.push(root);
 833   for (uint next = 0; next &lt; wq.size(); next++) {
 834     Node *n = wq.at(next);
 835     if (n-&gt;is_Load()) {
 836       const bool trace = false;
 837       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 838       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 839         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 840       } else {
 841         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 842 
 843         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 844           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 845         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 846                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 847                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {
 848           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
<span class="line-modified"> 849         } else {</span>
<span class="line-modified"> 850           bool verify = true;</span>
<span class="line-removed"> 851           if (adr_type-&gt;isa_instptr()) {</span>
<span class="line-removed"> 852             const TypeInstPtr* tinst = adr_type-&gt;is_instptr();</span>
<span class="line-removed"> 853             ciKlass* k = tinst-&gt;klass();</span>
<span class="line-removed"> 854             assert(k-&gt;is_instance_klass(), &quot;&quot;);</span>
<span class="line-removed"> 855             ciInstanceKlass* ik = (ciInstanceKlass*)k;</span>
<span class="line-removed"> 856             int offset = adr_type-&gt;offset();</span>
<span class="line-removed"> 857 </span>
<span class="line-removed"> 858             if ((ik-&gt;debug_final_field_at(offset) &amp;&amp; ShenandoahOptimizeInstanceFinals) ||</span>
<span class="line-removed"> 859                 (ik-&gt;debug_stable_field_at(offset) &amp;&amp; ShenandoahOptimizeStableFinals)) {</span>
<span class="line-removed"> 860               if (trace) {tty-&gt;print_cr(&quot;Final/stable&quot;);}</span>
<span class="line-removed"> 861               verify = false;</span>
<span class="line-removed"> 862             } else if (k == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-removed"> 863                        tinst-&gt;const_oop() != NULL &amp;&amp;</span>
<span class="line-removed"> 864                        tinst-&gt;offset() &gt;= (ik-&gt;size_helper() * wordSize)) {</span>
<span class="line-removed"> 865               ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-removed"> 866               ciField* field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);</span>
<span class="line-removed"> 867               if ((ShenandoahOptimizeStaticFinals &amp;&amp; field-&gt;is_final()) ||</span>
<span class="line-removed"> 868                   (ShenandoahOptimizeStableFinals &amp;&amp; field-&gt;is_stable())) {</span>
<span class="line-removed"> 869                 verify = false;</span>
<span class="line-removed"> 870               }</span>
<span class="line-removed"> 871             }</span>
<span class="line-removed"> 872           }</span>
<span class="line-removed"> 873 </span>
<span class="line-removed"> 874           if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="line-removed"> 875             report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);</span>
<span class="line-removed"> 876           }</span>
 877         }
 878       }
 879     } else if (n-&gt;is_Store()) {
 880       const bool trace = false;
 881 
 882       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 883       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 884         Node* adr = n-&gt;in(MemNode::Address);
 885         bool verify = true;
 886 
 887         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 888           adr = adr-&gt;in(AddPNode::Address);
 889           if (adr-&gt;is_AddP()) {
 890             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 891             adr = adr-&gt;in(AddPNode::Address);
 892             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 893                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
 894                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_ThreadLocal &amp;&amp;
 895                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Offset)-&gt;find_intptr_t_con(-1) == in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset())) {
 896               if (trace) {tty-&gt;print_cr(&quot;SATB prebarrier&quot;);}
 897               verify = false;
 898             }
 899           }
 900         }
 901 
<span class="line-modified"> 902         if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 903           report_verify_failure(&quot;Shenandoah verification: Store should have barriers&quot;, n);
 904         }
 905       }
<span class="line-modified"> 906       if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 907         report_verify_failure(&quot;Shenandoah verification: Store (address) should have barriers&quot;, n);
 908       }
 909     } else if (n-&gt;Opcode() == Op_CmpP) {
 910       const bool trace = false;
 911 
 912       Node* in1 = n-&gt;in(1);
 913       Node* in2 = n-&gt;in(2);
 914       if (in1-&gt;bottom_type()-&gt;isa_oopptr()) {
 915         if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 916 
 917         bool mark_inputs = false;
 918         if (in1-&gt;bottom_type() == TypePtr::NULL_PTR || in2-&gt;bottom_type() == TypePtr::NULL_PTR ||
 919             (in1-&gt;is_Con() || in2-&gt;is_Con())) {
 920           if (trace) {tty-&gt;print_cr(&quot;Comparison against a constant&quot;);}
 921           mark_inputs = true;
 922         } else if ((in1-&gt;is_CheckCastPP() &amp;&amp; in1-&gt;in(1)-&gt;is_Proj() &amp;&amp; in1-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) ||
 923                    (in2-&gt;is_CheckCastPP() &amp;&amp; in2-&gt;in(1)-&gt;is_Proj() &amp;&amp; in2-&gt;in(1)-&gt;in(0)-&gt;is_Allocate())) {
 924           if (trace) {tty-&gt;print_cr(&quot;Comparison with newly alloc&#39;ed object&quot;);}
 925           mark_inputs = true;
 926         } else {
 927           assert(in2-&gt;bottom_type()-&gt;isa_oopptr(), &quot;&quot;);
 928 
<span class="line-modified"> 929           if (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||</span>
<span class="line-modified"> 930               !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 931             report_verify_failure(&quot;Shenandoah verification: Cmp should have barriers&quot;, n);
 932           }
 933         }
 934         if (verify_no_useless_barrier &amp;&amp;
 935             mark_inputs &amp;&amp;
<span class="line-modified"> 936             (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||</span>
<span class="line-modified"> 937              !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {</span>
 938           phis.clear();
<span class="line-modified"> 939           visited.Reset();</span>
 940         }
 941       }
 942     } else if (n-&gt;is_LoadStore()) {
 943       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
<span class="line-modified"> 944           !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 945         report_verify_failure(&quot;Shenandoah verification: LoadStore (value) should have barriers&quot;, n);
 946       }
 947 
<span class="line-modified"> 948       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 949         report_verify_failure(&quot;Shenandoah verification: LoadStore (address) should have barriers&quot;, n);
 950       }
 951     } else if (n-&gt;Opcode() == Op_CallLeafNoFP || n-&gt;Opcode() == Op_CallLeaf) {
 952       CallNode* call = n-&gt;as_Call();
 953 
 954       static struct {
 955         const char* name;
 956         struct {
 957           int pos;
 958           verify_type t;
 959         } args[6];
 960       } calls[] = {
 961         &quot;aescrypt_encryptBlock&quot;,
 962         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 963           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 964         &quot;aescrypt_decryptBlock&quot;,
 965         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 966           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 967         &quot;multiplyToLen&quot;,
 968         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { TypeFunc::Parms+4, ShenandoahStore },
</pre>
<hr />
<pre>
1024         &quot;sha512_implCompressMB&quot;,
1025         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1026           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1027         &quot;encodeBlock&quot;,
1028         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
1029           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1030       };
1031 
1032       if (call-&gt;is_call_to_arraycopystub()) {
1033         Node* dest = NULL;
1034         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain();
1035         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
1036           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
1037             j++;
1038             if (j == 2) {
1039               dest = n-&gt;in(i);
1040               break;
1041             }
1042           }
1043         }
<span class="line-modified">1044         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||</span>
<span class="line-modified">1045             !ShenandoahBarrierNode::verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
1046           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
1047         }
1048       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
1049                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
<span class="line-modified">1050         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
1051           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
1052         }
1053       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
1054         // skip
1055       } else {
1056         const int calls_len = sizeof(calls) / sizeof(calls[0]);
1057         int i = 0;
1058         for (; i &lt; calls_len; i++) {
1059           if (!strcmp(calls[i].name, call-&gt;_name)) {
1060             break;
1061           }
1062         }
1063         if (i != calls_len) {
1064           const uint args_len = sizeof(calls[0].args) / sizeof(calls[0].args[0]);
1065           for (uint j = 0; j &lt; args_len; j++) {
1066             int pos = calls[i].args[j].pos;
1067             if (pos == -1) {
1068               break;
1069             }
<span class="line-modified">1070             if (!ShenandoahBarrierNode::verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {</span>
1071               report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
1072             }
1073           }
1074           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
1075             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1076                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
1077               uint k = 0;
1078               for (; k &lt; args_len &amp;&amp; calls[i].args[k].pos != (int)j; k++);
1079               if (k == args_len) {
1080                 fatal(&quot;arg %d for call %s not covered&quot;, j, call-&gt;_name);
1081               }
1082             }
1083           }
1084         } else {
1085           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
1086             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1087                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
1088               fatal(&quot;%s not covered&quot;, call-&gt;_name);
1089             }
1090           }
1091         }
1092       }
<span class="line-modified">1093     } else if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1094       assert(!barriers.contains(n), &quot;&quot;);</span>
<span class="line-removed">1095       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;find_out_with(Op_ShenandoahWBMemProj) != NULL, &quot;bad shenandoah write barrier&quot;);</span>
<span class="line-removed">1096       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;outcnt() &gt; 1, &quot;bad shenandoah write barrier&quot;);</span>
<span class="line-removed">1097       barriers.push(n);</span>
<span class="line-removed">1098     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
1099       // skip
<span class="line-removed">1100     } else if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1101       assert(n-&gt;in(0) == NULL &amp;&amp; n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;strange ShenandoahWBMemProj&quot;);</span>
1102     } else if (n-&gt;is_AddP()
1103                || n-&gt;is_Phi()
1104                || n-&gt;is_ConstraintCast()
1105                || n-&gt;Opcode() == Op_Return
1106                || n-&gt;Opcode() == Op_CMoveP
1107                || n-&gt;Opcode() == Op_CMoveN
1108                || n-&gt;Opcode() == Op_Rethrow
1109                || n-&gt;is_MemBar()
1110                || n-&gt;Opcode() == Op_Conv2B
1111                || n-&gt;Opcode() == Op_SafePoint
1112                || n-&gt;is_CallJava()
1113                || n-&gt;Opcode() == Op_Unlock
1114                || n-&gt;Opcode() == Op_EncodeP
1115                || n-&gt;Opcode() == Op_DecodeN) {
1116       // nothing to do
1117     } else {
1118       static struct {
1119         int opcode;
1120         struct {
1121           int pos;
</pre>
<hr />
<pre>
1148         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
1149         Op_StrIndexOfChar,
1150         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
1151       };
1152 
1153       const int others_len = sizeof(others) / sizeof(others[0]);
1154       int i = 0;
1155       for (; i &lt; others_len; i++) {
1156         if (others[i].opcode == n-&gt;Opcode()) {
1157           break;
1158         }
1159       }
1160       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain()-&gt;cnt() : n-&gt;req();
1161       if (i != others_len) {
1162         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
1163         for (uint j = 0; j &lt; inputs_len; j++) {
1164           int pos = others[i].inputs[j].pos;
1165           if (pos == -1) {
1166             break;
1167           }
<span class="line-modified">1168           if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {</span>
1169             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
1170           }
1171         }
1172         for (uint j = 1; j &lt; stop; j++) {
1173           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1174               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
1175             uint k = 0;
1176             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
1177             if (k == inputs_len) {
1178               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
1179             }
1180           }
1181         }
1182       } else {
1183         for (uint j = 1; j &lt; stop; j++) {
1184           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1185               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
1186             fatal(&quot;%s not covered&quot;, n-&gt;Name());
1187           }
1188         }
1189       }
1190     }
1191 
1192     if (n-&gt;is_SafePoint()) {
1193       SafePointNode* sfpt = n-&gt;as_SafePoint();
1194       if (verify_no_useless_barrier &amp;&amp; sfpt-&gt;jvms() != NULL) {
1195         for (uint i = sfpt-&gt;jvms()-&gt;scloff(); i &lt; sfpt-&gt;jvms()-&gt;endoff(); i++) {
<span class="line-modified">1196           if (!ShenandoahBarrierNode::verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
1197             phis.clear();
<span class="line-modified">1198             visited.Reset();</span>
1199           }
1200         }
1201       }
1202     }
<span class="line-modified">1203     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {</span>
<span class="line-removed">1204       Node *m = n-&gt;in(i);</span>
<span class="line-removed">1205       if (m == NULL) continue;</span>
<span class="line-removed">1206 </span>
<span class="line-removed">1207       // In most cases, inputs should be known to be non null. If it&#39;s</span>
<span class="line-removed">1208       // not the case, it could be a missing cast_not_null() in an</span>
<span class="line-removed">1209       // intrinsic or support might be needed in AddPNode::Ideal() to</span>
<span class="line-removed">1210       // avoid a NULL+offset input.</span>
<span class="line-removed">1211       if (!(n-&gt;is_Phi() ||</span>
<span class="line-removed">1212             (n-&gt;is_SafePoint() &amp;&amp; (!n-&gt;is_CallRuntime() || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;shenandoah_wb_pre&quot;) || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;unsafe_arraycopy&quot;))) ||</span>
<span class="line-removed">1213             n-&gt;Opcode() == Op_CmpP ||</span>
<span class="line-removed">1214             n-&gt;Opcode() == Op_CmpN ||</span>
<span class="line-removed">1215             (n-&gt;Opcode() == Op_StoreP &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="line-removed">1216             (n-&gt;Opcode() == Op_StoreN &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="line-removed">1217             n-&gt;is_ConstraintCast() ||</span>
<span class="line-removed">1218             n-&gt;Opcode() == Op_Return ||</span>
<span class="line-removed">1219             n-&gt;Opcode() == Op_Conv2B ||</span>
<span class="line-removed">1220             n-&gt;is_AddP() ||</span>
<span class="line-removed">1221             n-&gt;Opcode() == Op_CMoveP ||</span>
<span class="line-removed">1222             n-&gt;Opcode() == Op_CMoveN ||</span>
<span class="line-removed">1223             n-&gt;Opcode() == Op_Rethrow ||</span>
<span class="line-removed">1224             n-&gt;is_MemBar() ||</span>
<span class="line-removed">1225             n-&gt;is_Mem() ||</span>
<span class="line-removed">1226             n-&gt;Opcode() == Op_AryEq ||</span>
<span class="line-removed">1227             n-&gt;Opcode() == Op_SCMemProj ||</span>
<span class="line-removed">1228             n-&gt;Opcode() == Op_EncodeP ||</span>
<span class="line-removed">1229             n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="line-removed">1230             n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="line-removed">1231             n-&gt;Opcode() == Op_ShenandoahWBMemProj ||</span>
<span class="line-removed">1232             n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier)) {</span>
<span class="line-removed">1233         if (m-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; m-&gt;bottom_type()-&gt;make_oopptr()-&gt;meet(TypePtr::NULL_PTR) == m-&gt;bottom_type()) {</span>
<span class="line-removed">1234           report_verify_failure(&quot;Shenandoah verification: null input&quot;, n, m);</span>
<span class="line-removed">1235         }</span>
<span class="line-removed">1236       }</span>
<span class="line-removed">1237 </span>
<span class="line-removed">1238       wq.push(m);</span>
<span class="line-removed">1239     }</span>
<span class="line-removed">1240   }</span>
1241 
1242   if (verify_no_useless_barrier) {
1243     for (int i = 0; i &lt; barriers.length(); i++) {
1244       Node* n = barriers.at(i);
1245       if (!barriers_used.member(n)) {
1246         tty-&gt;print(&quot;XXX useless barrier&quot;); n-&gt;dump(-2);
1247         ShouldNotReachHere();
1248       }
1249     }
1250   }
1251 }
1252 #endif
1253 
<span class="line-modified">1254 bool ShenandoahBarrierNode::is_dominator_same_ctrl(Node*c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
1255   // That both nodes have the same control is not sufficient to prove
1256   // domination, verify that there&#39;s no path from d to n
1257   ResourceMark rm;
1258   Unique_Node_List wq;
1259   wq.push(d);
1260   for (uint next = 0; next &lt; wq.size(); next++) {
1261     Node *m = wq.at(next);
1262     if (m == n) {
1263       return false;
1264     }
1265     if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0)-&gt;is_Loop()) {
1266       assert(phase-&gt;ctrl_or_self(m-&gt;in(LoopNode::EntryControl)) != c, &quot;following loop entry should lead to new control&quot;);
1267     } else {











1268       for (uint i = 0; i &lt; m-&gt;req(); i++) {
1269         if (m-&gt;in(i) != NULL &amp;&amp; phase-&gt;ctrl_or_self(m-&gt;in(i)) == c) {
1270           wq.push(m-&gt;in(i));
1271         }
1272       }
1273     }
1274   }
1275   return true;
1276 }
1277 
<span class="line-modified">1278 bool ShenandoahBarrierNode::is_dominator(Node *d_c, Node *n_c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
1279   if (d_c != n_c) {
1280     return phase-&gt;is_dominator(d_c, n_c);
1281   }
1282   return is_dominator_same_ctrl(d_c, d, n, phase);
1283 }
1284 
1285 Node* next_mem(Node* mem, int alias) {
1286   Node* res = NULL;
1287   if (mem-&gt;is_Proj()) {
1288     res = mem-&gt;in(0);
1289   } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
1290     res = mem-&gt;in(TypeFunc::Memory);
1291   } else if (mem-&gt;is_Phi()) {
1292     res = mem-&gt;in(1);
<span class="line-removed">1293   } else if (mem-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1294     res = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
1295   } else if (mem-&gt;is_MergeMem()) {
1296     res = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
1297   } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
1298     assert(alias = Compile::AliasIdxRaw, &quot;following raw memory can&#39;t lead to a barrier&quot;);
1299     res = mem-&gt;in(MemNode::Memory);
<span class="line-removed">1300   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1301     res = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
1302   } else {
1303 #ifdef ASSERT
1304     mem-&gt;dump();
1305 #endif
1306     ShouldNotReachHere();
1307   }
1308   return res;
1309 }
1310 
<span class="line-modified">1311 Node* ShenandoahBarrierNode::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {</span>
1312   Node* iffproj = NULL;
1313   while (c != dom) {
1314     Node* next = phase-&gt;idom(c);
1315     assert(next-&gt;unique_ctrl_out() == c || c-&gt;is_Proj() || c-&gt;is_Region(), &quot;multiple control flow out but no proj or region?&quot;);
1316     if (c-&gt;is_Region()) {
1317       ResourceMark rm;
1318       Unique_Node_List wq;
1319       wq.push(c);
1320       for (uint i = 0; i &lt; wq.size(); i++) {
1321         Node *n = wq.at(i);
1322         if (n == next) {
1323           continue;
1324         }
1325         if (n-&gt;is_Region()) {
1326           for (uint j = 1; j &lt; n-&gt;req(); j++) {
1327             wq.push(n-&gt;in(j));
1328           }
1329         } else {
1330           wq.push(n-&gt;in(0));
1331         }
</pre>
<hr />
<pre>
1356             iffproj = c;
1357           } else {
1358             return NodeSentinel;
1359           }
1360         }
1361       } else if (c-&gt;Opcode() == Op_JumpProj) {
1362         return NodeSentinel; // unsupported
1363       } else if (c-&gt;Opcode() == Op_CatchProj) {
1364         return NodeSentinel; // unsupported
1365       } else if (c-&gt;Opcode() == Op_CProj &amp;&amp; next-&gt;Opcode() == Op_NeverBranch) {
1366         return NodeSentinel; // unsupported
1367       } else {
1368         assert(next-&gt;unique_ctrl_out() == c, &quot;unsupported branch pattern&quot;);
1369       }
1370     }
1371     c = next;
1372   }
1373   return iffproj;
1374 }
1375 
<span class="line-modified">1376 bool ShenandoahBarrierNode::build_loop_late_post(PhaseIdealLoop* phase, Node* n) {</span>
<span class="line-removed">1377   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier ||</span>
<span class="line-removed">1378       n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="line-removed">1379       n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1380 </span>
<span class="line-removed">1381     phase-&gt;build_loop_late_post_work(n, false);</span>
<span class="line-removed">1382 </span>
<span class="line-removed">1383     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1384       // The write barrier and its memory proj must have the same</span>
<span class="line-removed">1385       // control otherwise some loop opts could put nodes (Phis) between</span>
<span class="line-removed">1386       // them</span>
<span class="line-removed">1387       Node* proj = n-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1388       if (proj != NULL) {</span>
<span class="line-removed">1389         phase-&gt;set_ctrl_and_loop(proj, phase-&gt;get_ctrl(n));</span>
<span class="line-removed">1390       }</span>
<span class="line-removed">1391     }</span>
<span class="line-removed">1392     return true;</span>
<span class="line-removed">1393   }</span>
<span class="line-removed">1394   return false;</span>
<span class="line-removed">1395 }</span>
<span class="line-removed">1396 </span>
<span class="line-removed">1397 bool ShenandoahBarrierNode::sink_node(PhaseIdealLoop* phase, Node* ctrl, Node* n_ctrl) {</span>
<span class="line-removed">1398   ctrl = phase-&gt;find_non_split_ctrl(ctrl);</span>
<span class="line-removed">1399   assert(phase-&gt;dom_depth(n_ctrl) &lt;= phase-&gt;dom_depth(ctrl), &quot;n is later than its clone&quot;);</span>
<span class="line-removed">1400   set_req(0, ctrl);</span>
<span class="line-removed">1401   phase-&gt;register_new_node(this, ctrl);</span>
<span class="line-removed">1402   return true;</span>
<span class="line-removed">1403 }</span>
<span class="line-removed">1404 </span>
<span class="line-removed">1405 #ifdef ASSERT</span>
<span class="line-removed">1406 void ShenandoahWriteBarrierNode::memory_dominates_all_paths_helper(Node* c, Node* rep_ctrl, Unique_Node_List&amp; controls, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1407   const bool trace = false;</span>
<span class="line-removed">1408   if (trace) { tty-&gt;print(&quot;X control is&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1409 </span>
<span class="line-removed">1410   uint start = controls.size();</span>
<span class="line-removed">1411   controls.push(c);</span>
<span class="line-removed">1412   for (uint i = start; i &lt; controls.size(); i++) {</span>
<span class="line-removed">1413     Node *n = controls.at(i);</span>
<span class="line-removed">1414 </span>
<span class="line-removed">1415     if (trace) { tty-&gt;print(&quot;X from&quot;); n-&gt;dump(); }</span>
<span class="line-removed">1416 </span>
<span class="line-removed">1417     if (n == rep_ctrl) {</span>
<span class="line-removed">1418       continue;</span>
<span class="line-removed">1419     }</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421     if (n-&gt;is_Proj()) {</span>
<span class="line-removed">1422       Node* n_dom = n-&gt;in(0);</span>
<span class="line-removed">1423       IdealLoopTree* n_dom_loop = phase-&gt;get_loop(n_dom);</span>
<span class="line-removed">1424       if (n-&gt;is_IfProj() &amp;&amp; n_dom-&gt;outcnt() == 2) {</span>
<span class="line-removed">1425         n_dom_loop = phase-&gt;get_loop(n_dom-&gt;as_If()-&gt;proj_out(n-&gt;as_Proj()-&gt;_con == 0 ? 1 : 0));</span>
<span class="line-removed">1426       }</span>
<span class="line-removed">1427       if (n_dom_loop != phase-&gt;ltree_root()) {</span>
<span class="line-removed">1428         Node* tail = n_dom_loop-&gt;tail();</span>
<span class="line-removed">1429         if (tail-&gt;is_Region()) {</span>
<span class="line-removed">1430           for (uint j = 1; j &lt; tail-&gt;req(); j++) {</span>
<span class="line-removed">1431             if (phase-&gt;is_dominator(n_dom, tail-&gt;in(j)) &amp;&amp; !phase-&gt;is_dominator(n, tail-&gt;in(j))) {</span>
<span class="line-removed">1432               assert(phase-&gt;is_dominator(rep_ctrl, tail-&gt;in(j)), &quot;why are we here?&quot;);</span>
<span class="line-removed">1433               // entering loop from below, mark backedge</span>
<span class="line-removed">1434               if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;in(j)-&gt;dump(); }</span>
<span class="line-removed">1435               controls.push(tail-&gt;in(j));</span>
<span class="line-removed">1436               //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="line-removed">1437             }</span>
<span class="line-removed">1438           }</span>
<span class="line-removed">1439         } else if (phase-&gt;get_loop(n) != n_dom_loop &amp;&amp; phase-&gt;is_dominator(n_dom, tail)) {</span>
<span class="line-removed">1440           // entering loop from below, mark backedge</span>
<span class="line-removed">1441           if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;dump(); }</span>
<span class="line-removed">1442           controls.push(tail);</span>
<span class="line-removed">1443           //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="line-removed">1444         }</span>
<span class="line-removed">1445       }</span>
<span class="line-removed">1446     }</span>
<span class="line-removed">1447 </span>
<span class="line-removed">1448     if (n-&gt;is_Loop()) {</span>
<span class="line-removed">1449       Node* c = n-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">1450       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1451       controls.push(c);</span>
<span class="line-removed">1452     } else if (n-&gt;is_Region()) {</span>
<span class="line-removed">1453       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed">1454         Node* c = n-&gt;in(i);</span>
<span class="line-removed">1455         if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1456         controls.push(c);</span>
<span class="line-removed">1457       }</span>
<span class="line-removed">1458     } else {</span>
<span class="line-removed">1459       Node* c = n-&gt;in(0);</span>
<span class="line-removed">1460       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1461       controls.push(c);</span>
<span class="line-removed">1462     }</span>
<span class="line-removed">1463   }</span>
<span class="line-removed">1464 }</span>
<span class="line-removed">1465 </span>
<span class="line-removed">1466 bool ShenandoahWriteBarrierNode::memory_dominates_all_paths(Node* mem, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1467   const bool trace = false;</span>
<span class="line-removed">1468   if (trace) {</span>
<span class="line-removed">1469     tty-&gt;print(&quot;XXX mem is&quot;); mem-&gt;dump();</span>
<span class="line-removed">1470     tty-&gt;print(&quot;XXX rep ctrl is&quot;); rep_ctrl-&gt;dump();</span>
<span class="line-removed">1471     tty-&gt;print_cr(&quot;XXX alias is %d&quot;, alias);</span>
<span class="line-removed">1472   }</span>
<span class="line-removed">1473   ResourceMark rm;</span>
<span class="line-removed">1474   Unique_Node_List wq;</span>
<span class="line-removed">1475   Unique_Node_List controls;</span>
<span class="line-removed">1476   wq.push(mem);</span>
<span class="line-removed">1477   for (uint next = 0; next &lt; wq.size(); next++) {</span>
<span class="line-removed">1478     Node *nn = wq.at(next);</span>
<span class="line-removed">1479     if (trace) { tty-&gt;print(&quot;XX from mem&quot;); nn-&gt;dump(); }</span>
<span class="line-removed">1480     assert(nn-&gt;bottom_type() == Type::MEMORY, &quot;memory only&quot;);</span>
<span class="line-removed">1481 </span>
<span class="line-removed">1482     if (nn-&gt;is_Phi()) {</span>
<span class="line-removed">1483       Node* r = nn-&gt;in(0);</span>
<span class="line-removed">1484       for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1485         Node* u = r-&gt;fast_out(j);</span>
<span class="line-removed">1486         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u != nn &amp;&amp;</span>
<span class="line-removed">1487             (u-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1488           if (trace) { tty-&gt;print(&quot;XX Next mem (other phi)&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1489           wq.push(u);</span>
<span class="line-removed">1490         }</span>
<span class="line-removed">1491       }</span>
<span class="line-removed">1492     }</span>
<span class="line-removed">1493 </span>
<span class="line-removed">1494     for (DUIterator_Fast imax, i = nn-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1495       Node* use = nn-&gt;fast_out(i);</span>
<span class="line-removed">1496 </span>
<span class="line-removed">1497       if (trace) { tty-&gt;print(&quot;XX use %p&quot;, use-&gt;adr_type()); use-&gt;dump(); }</span>
<span class="line-removed">1498       if (use-&gt;is_CFG() &amp;&amp; use-&gt;in(TypeFunc::Memory) == nn) {</span>
<span class="line-removed">1499         Node* c = use-&gt;in(0);</span>
<span class="line-removed">1500         if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="line-removed">1501           memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="line-removed">1502         } else if (use-&gt;is_CallStaticJava() &amp;&amp; use-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0 &amp;&amp; c-&gt;is_Region()) {</span>
<span class="line-removed">1503           Node* region = c;</span>
<span class="line-removed">1504           if (trace) { tty-&gt;print(&quot;XX unc region&quot;); region-&gt;dump(); }</span>
<span class="line-removed">1505           for (uint j = 1; j &lt; region-&gt;req(); j++) {</span>
<span class="line-removed">1506             if (phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {</span>
<span class="line-removed">1507               if (trace) { tty-&gt;print(&quot;XX unc follows&quot;); region-&gt;in(j)-&gt;dump(); }</span>
<span class="line-removed">1508               memory_dominates_all_paths_helper(region-&gt;in(j), rep_ctrl, controls, phase);</span>
<span class="line-removed">1509             }</span>
<span class="line-removed">1510           }</span>
<span class="line-removed">1511         }</span>
<span class="line-removed">1512         //continue;</span>
<span class="line-removed">1513       } else if (use-&gt;is_Phi()) {</span>
<span class="line-removed">1514         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="line-removed">1515         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="line-removed">1516             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1517           for (uint j = 1; j &lt; use-&gt;req(); j++) {</span>
<span class="line-removed">1518             if (use-&gt;in(j) == nn) {</span>
<span class="line-removed">1519               Node* c = use-&gt;in(0)-&gt;in(j);</span>
<span class="line-removed">1520               if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="line-removed">1521                 memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="line-removed">1522               }</span>
<span class="line-removed">1523             }</span>
<span class="line-removed">1524           }</span>
<span class="line-removed">1525         }</span>
<span class="line-removed">1526         //        continue;</span>
<span class="line-removed">1527       }</span>
<span class="line-removed">1528 </span>
<span class="line-removed">1529       if (use-&gt;is_MergeMem()) {</span>
<span class="line-removed">1530         if (use-&gt;as_MergeMem()-&gt;memory_at(alias) == nn) {</span>
<span class="line-removed">1531           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1532           // follow the memory edges</span>
<span class="line-removed">1533           wq.push(use);</span>
<span class="line-removed">1534         }</span>
<span class="line-removed">1535       } else if (use-&gt;is_Phi()) {</span>
<span class="line-removed">1536         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="line-removed">1537         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="line-removed">1538             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1539           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1540           // follow the memory edges</span>
<span class="line-removed">1541           wq.push(use);</span>
<span class="line-removed">1542         }</span>
<span class="line-removed">1543       } else if (use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">1544                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1545         if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1546         // follow the memory edges</span>
<span class="line-removed">1547         wq.push(use);</span>
<span class="line-removed">1548       } else if ((use-&gt;is_SafePoint() || use-&gt;is_MemBar()) &amp;&amp;</span>
<span class="line-removed">1549                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1550         for (DUIterator_Fast jmax, j = use-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1551           Node* u = use-&gt;fast_out(j);</span>
<span class="line-removed">1552           if (u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">1553             if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1554             // follow the memory edges</span>
<span class="line-removed">1555             wq.push(u);</span>
<span class="line-removed">1556           }</span>
<span class="line-removed">1557         }</span>
<span class="line-removed">1558       } else if (use-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1559         Node* m = use-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1560         if (m != NULL) {</span>
<span class="line-removed">1561           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); m-&gt;dump(); }</span>
<span class="line-removed">1562           // follow the memory edges</span>
<span class="line-removed">1563           wq.push(m);</span>
<span class="line-removed">1564         }</span>
<span class="line-removed">1565       }</span>
<span class="line-removed">1566     }</span>
<span class="line-removed">1567   }</span>
<span class="line-removed">1568 </span>
<span class="line-removed">1569   if (controls.size() == 0) {</span>
<span class="line-removed">1570     return false;</span>
<span class="line-removed">1571   }</span>
<span class="line-removed">1572 </span>
<span class="line-removed">1573   for (uint i = 0; i &lt; controls.size(); i++) {</span>
<span class="line-removed">1574     Node *n = controls.at(i);</span>
<span class="line-removed">1575 </span>
<span class="line-removed">1576     if (trace) { tty-&gt;print(&quot;X checking&quot;); n-&gt;dump(); }</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578     if (n-&gt;unique_ctrl_out() != NULL) {</span>
<span class="line-removed">1579       continue;</span>
<span class="line-removed">1580     }</span>
<span class="line-removed">1581 </span>
<span class="line-removed">1582     if (n-&gt;Opcode() == Op_NeverBranch) {</span>
<span class="line-removed">1583       Node* taken = n-&gt;as_Multi()-&gt;proj_out(0);</span>
<span class="line-removed">1584       if (!controls.member(taken)) {</span>
<span class="line-removed">1585         if (trace) { tty-&gt;print(&quot;X not seen&quot;); taken-&gt;dump(); }</span>
<span class="line-removed">1586         return false;</span>
<span class="line-removed">1587       }</span>
<span class="line-removed">1588       continue;</span>
<span class="line-removed">1589     }</span>
<span class="line-removed">1590 </span>
<span class="line-removed">1591     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1592       Node* u = n-&gt;fast_out(j);</span>
<span class="line-removed">1593 </span>
<span class="line-removed">1594       if (u-&gt;is_CFG()) {</span>
<span class="line-removed">1595         if (!controls.member(u)) {</span>
<span class="line-removed">1596           if (u-&gt;is_Proj() &amp;&amp; u-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {</span>
<span class="line-removed">1597             if (trace) { tty-&gt;print(&quot;X not seen but unc&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1598           } else {</span>
<span class="line-removed">1599             Node* c = u;</span>
<span class="line-removed">1600             do {</span>
<span class="line-removed">1601               c = c-&gt;unique_ctrl_out();</span>
<span class="line-removed">1602             } while (c != NULL &amp;&amp; c-&gt;is_Region());</span>
<span class="line-removed">1603             if (c != NULL &amp;&amp; c-&gt;Opcode() == Op_Halt) {</span>
<span class="line-removed">1604               if (trace) { tty-&gt;print(&quot;X not seen but halt&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1605             } else {</span>
<span class="line-removed">1606               if (trace) { tty-&gt;print(&quot;X not seen&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1607               return false;</span>
<span class="line-removed">1608             }</span>
<span class="line-removed">1609           }</span>
<span class="line-removed">1610         } else {</span>
<span class="line-removed">1611           if (trace) { tty-&gt;print(&quot;X seen&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1612         }</span>
<span class="line-removed">1613       }</span>
<span class="line-removed">1614     }</span>
<span class="line-removed">1615   }</span>
<span class="line-removed">1616   return true;</span>
<span class="line-removed">1617 }</span>
<span class="line-removed">1618 #endif</span>
<span class="line-removed">1619 </span>
<span class="line-removed">1620 Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node*&amp; mem_ctrl, Node* n, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1621   ResourceMark rm;</span>
<span class="line-removed">1622   VectorSet wq(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">1623   wq.set(mem-&gt;_idx);</span>
<span class="line-removed">1624   mem_ctrl = phase-&gt;get_ctrl(mem);</span>
<span class="line-removed">1625   while (!is_dominator(mem_ctrl, rep_ctrl, mem, n, phase)) {</span>
<span class="line-removed">1626     mem = next_mem(mem, alias);</span>
<span class="line-removed">1627     if (wq.test_set(mem-&gt;_idx)) {</span>
<span class="line-removed">1628       return NULL; // hit an unexpected loop</span>
<span class="line-removed">1629     }</span>
<span class="line-removed">1630     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="line-removed">1631   }</span>
<span class="line-removed">1632   if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed">1633     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="line-removed">1634     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="line-removed">1635   }</span>
<span class="line-removed">1636   return mem;</span>
<span class="line-removed">1637 }</span>
<span class="line-removed">1638 </span>
<span class="line-removed">1639 Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {</span>
1640   ResourceMark rm;
1641   VectorSet wq(Thread::current()-&gt;resource_area());
1642   wq.set(mem-&gt;_idx);
1643   mem_ctrl = phase-&gt;ctrl_or_self(mem);
1644   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
1645     mem = next_mem(mem, alias);
1646     if (wq.test_set(mem-&gt;_idx)) {
1647       return NULL;
1648     }
1649     mem_ctrl = phase-&gt;ctrl_or_self(mem);
1650   }
1651   if (mem-&gt;is_MergeMem()) {
1652     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
1653     mem_ctrl = phase-&gt;ctrl_or_self(mem);
1654   }
1655   return mem;
1656 }
1657 
<span class="line-modified">1658 static void disconnect_barrier_mem(Node* wb, PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified">1659   Node* mem_in = wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-modified">1660   Node* proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-modified">1661 </span>
<span class="line-modified">1662   for (DUIterator_Last imin, i = proj-&gt;last_outs(imin); i &gt;= imin; ) {</span>
<span class="line-modified">1663     Node* u = proj-&gt;last_out(i);</span>
<span class="line-modified">1664     igvn.rehash_node_delayed(u);</span>
<span class="line-modified">1665     int nb = u-&gt;replace_edge(proj, mem_in);</span>
<span class="line-modified">1666     assert(nb &gt; 0, &quot;no replacement?&quot;);</span>
<span class="line-modified">1667     i -= nb;</span>
<span class="line-modified">1668   }</span>
<span class="line-modified">1669 }</span>
<span class="line-modified">1670 </span>
<span class="line-modified">1671 Node* ShenandoahWriteBarrierNode::move_above_predicates(LoopNode* cl, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified">1672   Node* entry = cl-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl);</span>
<span class="line-modified">1673   Node* above_pred = phase-&gt;skip_all_loop_predicates(entry);</span>
<span class="line-modified">1674   Node* ctrl = entry;</span>
<span class="line-modified">1675   while (ctrl != above_pred) {</span>
<span class="line-modified">1676     Node* next = ctrl-&gt;in(0);</span>
<span class="line-modified">1677     if (!phase-&gt;is_dominator(val_ctrl, next)) {</span>
<span class="line-modified">1678       break;</span>






























1679     }
<span class="line-modified">1680     ctrl = next;</span>
<span class="line-modified">1681   }</span>
<span class="line-modified">1682   return ctrl;</span>
1683 }
1684 
<span class="line-modified">1685 static MemoryGraphFixer* find_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias) {</span>
<span class="line-modified">1686   for (int i = 0; i &lt; memory_graph_fixers.length(); i++) {</span>
<span class="line-modified">1687     if (memory_graph_fixers.at(i)-&gt;alias() == alias) {</span>
<span class="line-modified">1688       return memory_graph_fixers.at(i);</span>

1689     }
1690   }
<span class="line-removed">1691   return NULL;</span>
1692 }
1693 
<span class="line-modified">1694 static MemoryGraphFixer* create_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias, PhaseIdealLoop* phase, bool include_lsm) {</span>
<span class="line-modified">1695   assert(find_fixer(memory_graph_fixers, alias) == NULL, &quot;none should exist yet&quot;);</span>
<span class="line-modified">1696   MemoryGraphFixer* fixer = new MemoryGraphFixer(alias, include_lsm, phase);</span>
<span class="line-modified">1697   memory_graph_fixers.push(fixer);</span>
<span class="line-modified">1698   return fixer;</span>




1699 }
1700 
<span class="line-modified">1701 void ShenandoahWriteBarrierNode::try_move_before_loop_helper(LoopNode* cl, Node* val_ctrl, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="line-modified">1702   assert(cl-&gt;is_Loop(), &quot;bad control&quot;);</span>
<span class="line-modified">1703   Node* ctrl = move_above_predicates(cl, val_ctrl, phase);</span>
<span class="line-modified">1704   Node* mem_ctrl = NULL;</span>
<span class="line-modified">1705   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-modified">1706 </span>
<span class="line-modified">1707   MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="line-modified">1708   if (fixer == NULL) {</span>
<span class="line-modified">1709     fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="line-modified">1710   }</span>
<span class="line-modified">1711 </span>
<span class="line-modified">1712   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714   fixer-&gt;remove(proj);</span>
<span class="line-removed">1715   Node* mem = fixer-&gt;find_mem(ctrl, NULL);</span>
<span class="line-removed">1716 </span>
<span class="line-removed">1717   assert(!ShenandoahVerifyOptoBarriers || memory_dominates_all_paths(mem, ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="line-removed">1718 </span>
<span class="line-removed">1719   phase-&gt;set_ctrl_and_loop(this, ctrl);</span>
<span class="line-removed">1720   phase-&gt;igvn().replace_input_of(this, Control, ctrl);</span>
1721 
<span class="line-modified">1722   disconnect_barrier_mem(this, phase-&gt;igvn());</span>









1723 
<span class="line-modified">1724   phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="line-modified">1725   phase-&gt;set_ctrl_and_loop(proj, ctrl);</span>


1726 
<span class="line-modified">1727   fixer-&gt;fix_mem(ctrl, ctrl, mem, mem, proj, uses);</span>
<span class="line-removed">1728   assert(proj-&gt;outcnt() &gt; 0, &quot;disconnected write barrier&quot;);</span>
1729 }
1730 
<span class="line-modified">1731 LoopNode* ShenandoahWriteBarrierNode::try_move_before_pre_loop(Node* c, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified">1732   // A write barrier between a pre and main loop can get in the way of</span>
<span class="line-modified">1733   // vectorization. Move it above the pre loop if possible</span>
<span class="line-modified">1734   CountedLoopNode* cl = NULL;</span>
<span class="line-modified">1735   if (c-&gt;is_IfFalse() &amp;&amp;</span>
<span class="line-modified">1736       c-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="line-modified">1737     cl = c-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">1738   } else if (c-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-modified">1739              c-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-modified">1740              c-&gt;in(0)-&gt;in(0)-&gt;is_IfFalse() &amp;&amp;</span>
<span class="line-modified">1741              c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="line-modified">1742     cl = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">1743   }</span>
<span class="line-modified">1744   if (cl != NULL &amp;&amp;</span>
<span class="line-removed">1745       cl-&gt;is_pre_loop() &amp;&amp;</span>
<span class="line-removed">1746       val_ctrl != cl &amp;&amp;</span>
<span class="line-removed">1747       phase-&gt;is_dominator(val_ctrl, cl)) {</span>
<span class="line-removed">1748     return cl;</span>
1749   }
<span class="line-removed">1750   return NULL;</span>
1751 }
1752 
<span class="line-modified">1753 void ShenandoahWriteBarrierNode::try_move_before_loop(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="line-modified">1754   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-modified">1755   IdealLoopTree *n_loop = phase-&gt;get_loop(n_ctrl);</span>
<span class="line-modified">1756   Node* val = in(ValueIn);</span>
<span class="line-modified">1757   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-modified">1758   if (n_loop != phase-&gt;ltree_root() &amp;&amp; !n_loop-&gt;_irreducible) {</span>
<span class="line-modified">1759     IdealLoopTree *val_loop = phase-&gt;get_loop(val_ctrl);</span>
<span class="line-modified">1760     Node* mem = in(Memory);</span>
<span class="line-modified">1761     IdealLoopTree *mem_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(mem));</span>
<span class="line-modified">1762     if (!n_loop-&gt;is_member(val_loop) &amp;&amp;</span>
<span class="line-modified">1763         n_loop-&gt;is_member(mem_loop)) {</span>
<span class="line-modified">1764       Node* n_loop_head = n_loop-&gt;_head;</span>
<span class="line-modified">1765 </span>
<span class="line-modified">1766       if (n_loop_head-&gt;is_Loop()) {</span>
<span class="line-modified">1767         LoopNode* loop = n_loop_head-&gt;as_Loop();</span>
<span class="line-modified">1768         if (n_loop_head-&gt;is_CountedLoop() &amp;&amp; n_loop_head-&gt;as_CountedLoop()-&gt;is_main_loop()) {</span>
<span class="line-modified">1769           LoopNode* res = try_move_before_pre_loop(n_loop_head-&gt;in(LoopNode::EntryControl), val_ctrl, phase);</span>
<span class="line-modified">1770           if (res != NULL) {</span>
<span class="line-modified">1771             loop = res;</span>
<span class="line-modified">1772           }</span>
<span class="line-removed">1773         }</span>
1774 
<span class="line-modified">1775         try_move_before_loop_helper(loop, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1776       }</span>
<span class="line-removed">1777     }</span>
<span class="line-removed">1778   }</span>
<span class="line-removed">1779   LoopNode* ctrl = try_move_before_pre_loop(in(0), val_ctrl, phase);</span>
<span class="line-removed">1780   if (ctrl != NULL) {</span>
<span class="line-removed">1781     try_move_before_loop_helper(ctrl, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1782   }</span>
<span class="line-removed">1783 }</span>
<span class="line-removed">1784 </span>
<span class="line-removed">1785 Node* ShenandoahWriteBarrierNode::would_subsume(ShenandoahBarrierNode* other, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1786   Node* val = in(ValueIn);</span>
<span class="line-removed">1787   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-removed">1788   Node* other_mem = other-&gt;in(Memory);</span>
<span class="line-removed">1789   Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="line-removed">1790   Node* this_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">1791   IdealLoopTree* this_loop = phase-&gt;get_loop(this_ctrl);</span>
<span class="line-removed">1792   IdealLoopTree* other_loop = phase-&gt;get_loop(other_ctrl);</span>
<span class="line-removed">1793 </span>
<span class="line-removed">1794   Node* ctrl = phase-&gt;dom_lca(other_ctrl, this_ctrl);</span>
<span class="line-removed">1795 </span>
<span class="line-removed">1796   if (ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">1797       ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="line-removed">1798       ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="line-removed">1799       ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch &amp;&amp;</span>
<span class="line-removed">1800       !phase-&gt;is_dominator(val_ctrl, ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="line-removed">1801     return NULL;</span>
<span class="line-removed">1802   }</span>
<span class="line-removed">1803 </span>
<span class="line-removed">1804   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">1805 </span>
<span class="line-removed">1806   // We don&#39;t want to move a write barrier in a loop</span>
<span class="line-removed">1807   // If the LCA is in a inner loop, try a control out of loop if possible</span>
<span class="line-removed">1808   while (!loop-&gt;is_member(this_loop) &amp;&amp; (other-&gt;Opcode() != Op_ShenandoahWriteBarrier || !loop-&gt;is_member(other_loop))) {</span>
<span class="line-removed">1809     ctrl = phase-&gt;idom(ctrl);</span>
<span class="line-removed">1810     if (ctrl-&gt;is_MultiBranch()) {</span>
<span class="line-removed">1811       ctrl = ctrl-&gt;in(0);</span>
<span class="line-removed">1812     }</span>
<span class="line-removed">1813     if (ctrl != val_ctrl &amp;&amp; phase-&gt;is_dominator(ctrl, val_ctrl)) {</span>
<span class="line-removed">1814       return NULL;</span>
<span class="line-removed">1815     }</span>
<span class="line-removed">1816     loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">1817   }</span>
<span class="line-removed">1818 </span>
<span class="line-removed">1819   if (ShenandoahDontIncreaseWBFreq) {</span>
<span class="line-removed">1820     Node* this_iffproj = no_branches(this_ctrl, ctrl, true, phase);</span>
<span class="line-removed">1821     if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1822       Node* other_iffproj = no_branches(other_ctrl, ctrl, true, phase);</span>
<span class="line-removed">1823       if (other_iffproj == NULL || this_iffproj == NULL) {</span>
<span class="line-removed">1824         return ctrl;</span>
<span class="line-removed">1825       } else if (other_iffproj != NodeSentinel &amp;&amp; this_iffproj != NodeSentinel &amp;&amp;</span>
<span class="line-removed">1826                  other_iffproj-&gt;in(0) == this_iffproj-&gt;in(0)) {</span>
<span class="line-removed">1827         return ctrl;</span>
<span class="line-removed">1828       }</span>
<span class="line-removed">1829     } else if (this_iffproj == NULL) {</span>
<span class="line-removed">1830       return ctrl;</span>
<span class="line-removed">1831     }</span>
<span class="line-removed">1832     return NULL;</span>
<span class="line-removed">1833   }</span>
<span class="line-removed">1834 </span>
<span class="line-removed">1835   return ctrl;</span>
<span class="line-removed">1836 }</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838 void ShenandoahWriteBarrierNode::optimize_before_expansion(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers, bool include_lsm) {</span>
<span class="line-removed">1839   bool progress = false;</span>
<span class="line-removed">1840   Unique_Node_List uses;</span>
<span class="line-removed">1841   do {</span>
<span class="line-removed">1842     progress = false;</span>
<span class="line-removed">1843     for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="line-removed">1844       ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="line-removed">1845 </span>
<span class="line-removed">1846       wb-&gt;try_move_before_loop(memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1847 </span>
<span class="line-removed">1848       Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-removed">1849 </span>
<span class="line-removed">1850       for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1851         Node* u = val-&gt;fast_out(j);</span>
<span class="line-removed">1852         if (u != wb &amp;&amp; u-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1853           Node* rep_ctrl = wb-&gt;would_subsume(u-&gt;as_ShenandoahBarrier(), phase);</span>
<span class="line-removed">1854 </span>
<span class="line-removed">1855           if (rep_ctrl != NULL) {</span>
<span class="line-removed">1856             Node* other = u;</span>
<span class="line-removed">1857             Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-removed">1858             if (rep_ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">1859                 rep_ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="line-removed">1860                 rep_ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="line-removed">1861                 rep_ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch) {</span>
<span class="line-removed">1862               rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">1863 </span>
<span class="line-removed">1864               assert(phase-&gt;is_dominator(val_ctrl, rep_ctrl), &quot;bad control&quot;);</span>
<span class="line-removed">1865             } else {</span>
<span class="line-removed">1866               LoopNode* c = ShenandoahWriteBarrierNode::try_move_before_pre_loop(rep_ctrl, val_ctrl, phase);</span>
<span class="line-removed">1867               if (c != NULL) {</span>
<span class="line-removed">1868                 rep_ctrl = ShenandoahWriteBarrierNode::move_above_predicates(c, val_ctrl, phase);</span>
<span class="line-removed">1869               } else {</span>
<span class="line-removed">1870                 while (rep_ctrl-&gt;is_IfProj()) {</span>
<span class="line-removed">1871                   CallStaticJavaNode* unc = rep_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-removed">1872                   if (unc != NULL) {</span>
<span class="line-removed">1873                     int req = unc-&gt;uncommon_trap_request();</span>
<span class="line-removed">1874                     Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);</span>
<span class="line-removed">1875                     if ((trap_reason == Deoptimization::Reason_loop_limit_check ||</span>
<span class="line-removed">1876                          trap_reason == Deoptimization::Reason_predicate ||</span>
<span class="line-removed">1877                          trap_reason == Deoptimization::Reason_profile_predicate) &amp;&amp;</span>
<span class="line-removed">1878                         phase-&gt;is_dominator(val_ctrl, rep_ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="line-removed">1879                       rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">1880                       continue;</span>
<span class="line-removed">1881                     }</span>
<span class="line-removed">1882                   }</span>
<span class="line-removed">1883                   break;</span>
<span class="line-removed">1884                 }</span>
<span class="line-removed">1885               }</span>
<span class="line-removed">1886             }</span>
<span class="line-removed">1887 </span>
<span class="line-removed">1888             Node* wb_ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="line-removed">1889             Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="line-removed">1890             int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="line-removed">1891             MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);;</span>
<span class="line-removed">1892             if (!is_dominator(wb_ctrl, other_ctrl, wb, other, phase)) {</span>
<span class="line-removed">1893               if (fixer == NULL) {</span>
<span class="line-removed">1894                 fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="line-removed">1895               }</span>
<span class="line-removed">1896               Node* mem = fixer-&gt;find_mem(rep_ctrl, phase-&gt;get_ctrl(other) == rep_ctrl ? other : NULL);</span>
<span class="line-removed">1897 </span>
<span class="line-removed">1898               if (mem-&gt;has_out_with(Op_Lock) || mem-&gt;has_out_with(Op_Unlock)) {</span>
<span class="line-removed">1899                 continue;</span>
<span class="line-removed">1900               }</span>
<span class="line-removed">1901 </span>
<span class="line-removed">1902               Node* wb_proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1903               fixer-&gt;remove(wb_proj);</span>
<span class="line-removed">1904               Node* mem_for_ctrl = fixer-&gt;find_mem(rep_ctrl, NULL);</span>
<span class="line-removed">1905 </span>
<span class="line-removed">1906               if (wb-&gt;in(Memory) != mem) {</span>
<span class="line-removed">1907                 disconnect_barrier_mem(wb, phase-&gt;igvn());</span>
<span class="line-removed">1908                 phase-&gt;igvn().replace_input_of(wb, Memory, mem);</span>
<span class="line-removed">1909               }</span>
<span class="line-removed">1910               if (rep_ctrl != wb_ctrl) {</span>
<span class="line-removed">1911                 phase-&gt;set_ctrl_and_loop(wb, rep_ctrl);</span>
<span class="line-removed">1912                 phase-&gt;igvn().replace_input_of(wb, Control, rep_ctrl);</span>
<span class="line-removed">1913                 phase-&gt;set_ctrl_and_loop(wb_proj, rep_ctrl);</span>
<span class="line-removed">1914                 progress = true;</span>
<span class="line-removed">1915               }</span>
<span class="line-removed">1916 </span>
<span class="line-removed">1917               fixer-&gt;fix_mem(rep_ctrl, rep_ctrl, mem, mem_for_ctrl, wb_proj, uses);</span>
<span class="line-removed">1918 </span>
<span class="line-removed">1919               assert(!ShenandoahVerifyOptoBarriers || ShenandoahWriteBarrierNode::memory_dominates_all_paths(mem, rep_ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="line-removed">1920             }</span>
<span class="line-removed">1921 </span>
<span class="line-removed">1922             if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1923               Node* other_proj = other-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1924               if (fixer != NULL) {</span>
<span class="line-removed">1925                 fixer-&gt;remove(other_proj);</span>
<span class="line-removed">1926               }</span>
<span class="line-removed">1927               phase-&gt;igvn().replace_node(other_proj, other-&gt;in(Memory));</span>
<span class="line-removed">1928             }</span>
<span class="line-removed">1929             phase-&gt;igvn().replace_node(other, wb);</span>
<span class="line-removed">1930             --j; --jmax;</span>
<span class="line-removed">1931           }</span>
<span class="line-removed">1932         }</span>
<span class="line-removed">1933       }</span>
<span class="line-removed">1934     }</span>
<span class="line-removed">1935   } while(progress);</span>
<span class="line-removed">1936 }</span>
<span class="line-removed">1937 </span>
<span class="line-removed">1938 // Some code duplication with PhaseIdealLoop::split_if_with_blocks_pre()</span>
<span class="line-removed">1939 Node* ShenandoahWriteBarrierNode::try_split_thru_phi(PhaseIdealLoop* phase) {</span>
<span class="line-removed">1940   Node *ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">1941   if (ctrl == NULL) {</span>
<span class="line-removed">1942     return this;</span>
<span class="line-removed">1943   }</span>
<span class="line-removed">1944   Node *blk = phase-&gt;has_local_phi_input(this);</span>
<span class="line-removed">1945   if (blk == NULL) {</span>
<span class="line-removed">1946     return this;</span>
<span class="line-removed">1947   }</span>
<span class="line-removed">1948 </span>
<span class="line-removed">1949   if (in(0) != blk) {</span>
<span class="line-removed">1950     return this;</span>
<span class="line-removed">1951   }</span>
<span class="line-removed">1952 </span>
<span class="line-removed">1953   int policy = blk-&gt;req() &gt;&gt; 2;</span>
<span class="line-removed">1954 </span>
<span class="line-removed">1955   if (blk-&gt;is_CountedLoop()) {</span>
<span class="line-removed">1956     IdealLoopTree *lp = phase-&gt;get_loop(blk);</span>
<span class="line-removed">1957     if (lp &amp;&amp; lp-&gt;_rce_candidate) {</span>
<span class="line-removed">1958       return this;</span>
<span class="line-removed">1959     }</span>
<span class="line-removed">1960   }</span>
<span class="line-removed">1961 </span>
<span class="line-removed">1962   if (phase-&gt;C-&gt;live_nodes() &gt; 35000) {</span>
<span class="line-removed">1963     return this;</span>
<span class="line-removed">1964   }</span>
<span class="line-removed">1965 </span>
<span class="line-removed">1966   uint unique = phase-&gt;C-&gt;unique();</span>
<span class="line-removed">1967   Node *phi = phase-&gt;split_thru_phi(this, blk, policy);</span>
<span class="line-removed">1968   if (phi == NULL) {</span>
<span class="line-removed">1969     return this;</span>
<span class="line-removed">1970   }</span>
<span class="line-removed">1971 </span>
<span class="line-removed">1972   Node* mem_phi = new PhiNode(blk, Type::MEMORY, phase-&gt;C-&gt;alias_type(adr_type())-&gt;adr_type());</span>
<span class="line-removed">1973   for (uint i = 1; i &lt; blk-&gt;req(); i++) {</span>
<span class="line-removed">1974     Node* n = phi-&gt;in(i);</span>
<span class="line-removed">1975     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="line-removed">1976         n-&gt;_idx &gt;= unique) {</span>
<span class="line-removed">1977       Node* proj = new ShenandoahWBMemProjNode(n);</span>
<span class="line-removed">1978       phase-&gt;register_new_node(proj, phase-&gt;get_ctrl(n));</span>
<span class="line-removed">1979       mem_phi-&gt;init_req(i, proj);</span>
<span class="line-removed">1980     } else {</span>
<span class="line-removed">1981       Node* mem = in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed">1982       if (mem-&gt;is_Phi() &amp;&amp; mem-&gt;in(0) == blk) {</span>
<span class="line-removed">1983         mem = mem-&gt;in(i);</span>
<span class="line-removed">1984       }</span>
<span class="line-removed">1985       mem_phi-&gt;init_req(i, mem);</span>
<span class="line-removed">1986     }</span>
<span class="line-removed">1987   }</span>
<span class="line-removed">1988   phase-&gt;register_new_node(mem_phi, blk);</span>
<span class="line-removed">1989 </span>
<span class="line-removed">1990 </span>
<span class="line-removed">1991   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1992   phase-&gt;igvn().replace_node(proj, mem_phi);</span>
<span class="line-removed">1993   phase-&gt;igvn().replace_node(this, phi);</span>
<span class="line-removed">1994 </span>
<span class="line-removed">1995   return phi;</span>
<span class="line-removed">1996 }</span>
<span class="line-removed">1997 </span>
<span class="line-removed">1998 void ShenandoahReadBarrierNode::try_move(PhaseIdealLoop* phase) {</span>
<span class="line-removed">1999   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2000   if (n_ctrl == NULL) {</span>
<span class="line-removed">2001     return;</span>
<span class="line-removed">2002   }</span>
<span class="line-removed">2003   Node* mem = in(MemNode::Memory);</span>
<span class="line-removed">2004   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-removed">2005   const bool trace = false;</span>
<span class="line-removed">2006 </span>
<span class="line-removed">2007 #ifdef ASSERT</span>
<span class="line-removed">2008   if (trace) { tty-&gt;print(&quot;Trying to move mem of&quot;); dump(); }</span>
<span class="line-removed">2009 #endif</span>
<span class="line-removed">2010 </span>
<span class="line-removed">2011   Node* new_mem = mem;</span>
<span class="line-removed">2012 </span>
<span class="line-removed">2013   ResourceMark rm;</span>
<span class="line-removed">2014   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">2015   Node_List phis;</span>
<span class="line-removed">2016 </span>
<span class="line-removed">2017   for (;;) {</span>
<span class="line-removed">2018 #ifdef ASSERT</span>
<span class="line-removed">2019     if (trace) { tty-&gt;print(&quot;Looking for dominator from&quot;); mem-&gt;dump(); }</span>
<span class="line-removed">2020 #endif</span>
<span class="line-removed">2021     if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Start()) {</span>
<span class="line-removed">2022       if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2023 #ifdef ASSERT</span>
<span class="line-removed">2024         if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2025 #endif</span>
<span class="line-removed">2026         phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2027       }</span>
<span class="line-removed">2028       return;</span>
<span class="line-removed">2029     }</span>
<span class="line-removed">2030 </span>
<span class="line-removed">2031     Node* candidate = mem;</span>
<span class="line-removed">2032     do {</span>
<span class="line-removed">2033       if (!is_independent(mem)) {</span>
<span class="line-removed">2034         if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="line-removed">2035         if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2036 #ifdef ASSERT</span>
<span class="line-removed">2037           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2038 #endif</span>
<span class="line-removed">2039           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2040         }</span>
<span class="line-removed">2041         return;</span>
<span class="line-removed">2042       }</span>
<span class="line-removed">2043       if (seen.test_set(mem-&gt;_idx)) {</span>
<span class="line-removed">2044         if (trace) { tty-&gt;print_cr(&quot;Already seen&quot;); }</span>
<span class="line-removed">2045         ShouldNotReachHere();</span>
<span class="line-removed">2046         // Strange graph</span>
<span class="line-removed">2047         if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2048 #ifdef ASSERT</span>
<span class="line-removed">2049           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2050 #endif</span>
<span class="line-removed">2051           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2052         }</span>
<span class="line-removed">2053         return;</span>
<span class="line-removed">2054       }</span>
<span class="line-removed">2055       if (mem-&gt;is_Phi()) {</span>
<span class="line-removed">2056         phis.push(mem);</span>
<span class="line-removed">2057       }</span>
<span class="line-removed">2058       mem = next_mem(mem, alias);</span>
<span class="line-removed">2059       if (mem-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">2060         candidate = mem;</span>
<span class="line-removed">2061       }</span>
<span class="line-removed">2062       assert(is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl, mem, this, phase) == phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl), &quot;strange dominator&quot;);</span>
<span class="line-removed">2063 #ifdef ASSERT</span>
<span class="line-removed">2064       if (trace) { tty-&gt;print(&quot;Next mem is&quot;); mem-&gt;dump(); }</span>
<span class="line-removed">2065 #endif</span>
<span class="line-removed">2066     } while (mem-&gt;bottom_type() != Type::MEMORY || !phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl));</span>
<span class="line-removed">2067 </span>
<span class="line-removed">2068     assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;bad mem&quot;);</span>
<span class="line-removed">2069 </span>
<span class="line-removed">2070     bool not_dom = false;</span>
<span class="line-removed">2071     for (uint i = 0; i &lt; phis.size() &amp;&amp; !not_dom; i++) {</span>
<span class="line-removed">2072       Node* nn = phis.at(i);</span>
<span class="line-removed">2073 </span>
<span class="line-removed">2074 #ifdef ASSERT</span>
<span class="line-removed">2075       if (trace) { tty-&gt;print(&quot;Looking from phi&quot;); nn-&gt;dump(); }</span>
<span class="line-removed">2076 #endif</span>
<span class="line-removed">2077       assert(nn-&gt;is_Phi(), &quot;phis only&quot;);</span>
<span class="line-removed">2078       for (uint j = 2; j &lt; nn-&gt;req() &amp;&amp; !not_dom; j++) {</span>
<span class="line-removed">2079         Node* m = nn-&gt;in(j);</span>
<span class="line-removed">2080 #ifdef ASSERT</span>
<span class="line-removed">2081         if (trace) { tty-&gt;print(&quot;Input %d is&quot;, j); m-&gt;dump(); }</span>
<span class="line-removed">2082 #endif</span>
<span class="line-removed">2083         while (m != mem &amp;&amp; !seen.test_set(m-&gt;_idx)) {</span>
<span class="line-removed">2084           if (is_dominator(phase-&gt;ctrl_or_self(m), phase-&gt;ctrl_or_self(mem), m, mem, phase)) {</span>
<span class="line-removed">2085             not_dom = true;</span>
<span class="line-removed">2086             // Scheduling anomaly</span>
<span class="line-removed">2087 #ifdef ASSERT</span>
<span class="line-removed">2088             if (trace) { tty-&gt;print(&quot;Giving up&quot;); m-&gt;dump(); }</span>
<span class="line-removed">2089 #endif</span>
<span class="line-removed">2090             break;</span>
<span class="line-removed">2091           }</span>
<span class="line-removed">2092           if (!is_independent(m)) {</span>
<span class="line-removed">2093             if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="line-removed">2094             if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2095 #ifdef ASSERT</span>
<span class="line-removed">2096               if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2097 #endif</span>
<span class="line-removed">2098               phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2099             }</span>
<span class="line-removed">2100             return;</span>
<span class="line-removed">2101           }</span>
<span class="line-removed">2102           if (m-&gt;is_Phi()) {</span>
<span class="line-removed">2103             phis.push(m);</span>
<span class="line-removed">2104           }</span>
<span class="line-removed">2105           m = next_mem(m, alias);</span>
<span class="line-removed">2106 #ifdef ASSERT</span>
<span class="line-removed">2107           if (trace) { tty-&gt;print(&quot;Next mem is&quot;); m-&gt;dump(); }</span>
<span class="line-removed">2108 #endif</span>
<span class="line-removed">2109         }</span>
<span class="line-removed">2110       }</span>
<span class="line-removed">2111     }</span>
<span class="line-removed">2112     if (!not_dom) {</span>
<span class="line-removed">2113       new_mem = mem;</span>
<span class="line-removed">2114       phis.clear();</span>
<span class="line-removed">2115     } else {</span>
<span class="line-removed">2116       seen.Clear();</span>
<span class="line-removed">2117     }</span>
<span class="line-removed">2118   }</span>
<span class="line-removed">2119 }</span>
<span class="line-removed">2120 </span>
<span class="line-removed">2121 CallStaticJavaNode* ShenandoahWriteBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="line-removed">2122   Node* val = in(ValueIn);</span>
<span class="line-removed">2123 </span>
<span class="line-removed">2124   const Type* val_t = igvn.type(val);</span>
<span class="line-removed">2125 </span>
<span class="line-removed">2126   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="line-removed">2127       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-removed">2128       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">2129       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-removed">2130       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-removed">2131       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-removed">2132       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-removed">2133       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-removed">2134       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-removed">2135       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="line-removed">2136       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-removed">2137     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="line-removed">2138     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-removed">2139     return unc;</span>
<span class="line-removed">2140   }</span>
<span class="line-removed">2141   return NULL;</span>
<span class="line-removed">2142 }</span>
<span class="line-removed">2143 </span>
<span class="line-removed">2144 void ShenandoahWriteBarrierNode::pin_and_expand_move_barrier(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, Unique_Node_List&amp; uses) {</span>
<span class="line-removed">2145   Node* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2146   Node* val = in(ValueIn);</span>
<span class="line-removed">2147 </span>
<span class="line-removed">2148   if (unc != NULL) {</span>
<span class="line-removed">2149     Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2150     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2151 </span>
<span class="line-removed">2152     // Don&#39;t move write barrier in a loop</span>
<span class="line-removed">2153     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2154     IdealLoopTree* unc_loop = phase-&gt;get_loop(unc_ctrl);</span>
<span class="line-removed">2155 </span>
<span class="line-removed">2156     if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="line-removed">2157       return;</span>
<span class="line-removed">2158     }</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160     Node* branch = no_branches(ctrl, unc_ctrl, false, phase);</span>
<span class="line-removed">2161     assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="line-removed">2162     if (branch == NodeSentinel) {</span>
<span class="line-removed">2163       return;</span>
<span class="line-removed">2164     }</span>
<span class="line-removed">2165 </span>
<span class="line-removed">2166     RegionNode* r = new RegionNode(3);</span>
<span class="line-removed">2167     IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">2168 </span>
<span class="line-removed">2169     Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="line-removed">2170     Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="line-removed">2171     phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="line-removed">2172     Node* c = unc_ctrl_clone;</span>
<span class="line-removed">2173     Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="line-removed">2174     r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="line-removed">2175 </span>
<span class="line-removed">2176     phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="line-removed">2177     phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="line-removed">2178     phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="line-removed">2179     c = NULL;;</span>
<span class="line-removed">2180     phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="line-removed">2181     phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="line-removed">2182 </span>
<span class="line-removed">2183     IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">2184     fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="line-removed">2185     Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="line-removed">2186     r-&gt;init_req(2, iff_proj);</span>
<span class="line-removed">2187     phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="line-removed">2188 </span>
<span class="line-removed">2189     Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">2190     Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">2191     assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="line-removed">2192     assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="line-removed">2193     new_bol-&gt;set_req(1, new_cmp);</span>
<span class="line-removed">2194     new_cmp-&gt;set_req(1, this);</span>
<span class="line-removed">2195     phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="line-removed">2196     phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="line-removed">2197     phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="line-removed">2198     phase-&gt;igvn().replace_input_of(new_cast, 1, this);</span>
<span class="line-removed">2199 </span>
<span class="line-removed">2200     for (DUIterator_Fast imax, i = this-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2201       Node* u = this-&gt;fast_out(i);</span>
<span class="line-removed">2202       if (u == new_cast || u-&gt;Opcode() == Op_ShenandoahWBMemProj || u == new_cmp) {</span>
<span class="line-removed">2203         continue;</span>
<span class="line-removed">2204       }</span>
<span class="line-removed">2205       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2206       int nb = u-&gt;replace_edge(this, new_cast);</span>
<span class="line-removed">2207       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2208       --i; imax -= nb;</span>
<span class="line-removed">2209     }</span>
<span class="line-removed">2210 </span>
<span class="line-removed">2211     for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2212       Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">2213       if (u == this) {</span>
<span class="line-removed">2214         continue;</span>
<span class="line-removed">2215       }</span>
<span class="line-removed">2216       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2217       int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="line-removed">2218       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2219       --i; imax -= nb;</span>
<span class="line-removed">2220     }</span>
<span class="line-removed">2221 </span>
<span class="line-removed">2222     Node* new_ctrl = unc_ctrl_clone;</span>
<span class="line-removed">2223 </span>
<span class="line-removed">2224     int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-removed">2225     MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="line-removed">2226     if (fixer == NULL) {</span>
<span class="line-removed">2227       fixer = create_fixer(memory_graph_fixers, alias, phase, true);</span>
<span class="line-removed">2228     }</span>
<span class="line-removed">2229 </span>
<span class="line-removed">2230     Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">2231     fixer-&gt;remove(proj);</span>
<span class="line-removed">2232     Node* mem = fixer-&gt;find_mem(new_ctrl, NULL);</span>
<span class="line-removed">2233 </span>
<span class="line-removed">2234     if (in(Memory) != mem) {</span>
<span class="line-removed">2235       disconnect_barrier_mem(this, phase-&gt;igvn());</span>
<span class="line-removed">2236       phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="line-removed">2237     }</span>
<span class="line-removed">2238 </span>
<span class="line-removed">2239     phase-&gt;set_ctrl_and_loop(this, new_ctrl);</span>
<span class="line-removed">2240     phase-&gt;igvn().replace_input_of(this, Control, new_ctrl);</span>
<span class="line-removed">2241     phase-&gt;set_ctrl_and_loop(proj, new_ctrl);</span>
<span class="line-removed">2242 </span>
<span class="line-removed">2243     fixer-&gt;fix_mem(new_ctrl, new_ctrl, mem, mem, proj, uses);</span>
<span class="line-removed">2244   }</span>
<span class="line-removed">2245 }</span>
<span class="line-removed">2246 </span>
<span class="line-removed">2247 void ShenandoahWriteBarrierNode::pin_and_expand_helper(PhaseIdealLoop* phase) {</span>
<span class="line-removed">2248   Node* val = in(ValueIn);</span>
<span class="line-removed">2249   CallStaticJavaNode* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2250   Node* rep = this;</span>
<span class="line-removed">2251   Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2252   if (unc != NULL &amp;&amp; val-&gt;in(0) == ctrl) {</span>
<span class="line-removed">2253     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2254     IfNode* other_iff = unc_ctrl-&gt;unique_ctrl_out()-&gt;as_If();</span>
<span class="line-removed">2255     ProjNode* other_unc_ctrl = other_iff-&gt;proj_out(1);</span>
<span class="line-removed">2256     Node* cast = NULL;</span>
<span class="line-removed">2257     for (DUIterator_Fast imax, i = other_unc_ctrl-&gt;fast_outs(imax); i &lt; imax &amp;&amp; cast == NULL; i++) {</span>
<span class="line-removed">2258       Node* u = other_unc_ctrl-&gt;fast_out(i);</span>
<span class="line-removed">2259       if (u-&gt;Opcode() == Op_CastPP &amp;&amp; u-&gt;in(1) == this) {</span>
<span class="line-removed">2260         cast = u;</span>
<span class="line-removed">2261       }</span>
<span class="line-removed">2262     }</span>
<span class="line-removed">2263     assert(other_unc_ctrl-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) == unc, &quot;broken&quot;);</span>
<span class="line-removed">2264     rep = cast;</span>
<span class="line-removed">2265   }</span>
<span class="line-removed">2266 </span>
<span class="line-removed">2267   // Replace all uses of barrier&#39;s input that are dominated by ctrl</span>
<span class="line-removed">2268   // with the value returned by the barrier: no need to keep both</span>
<span class="line-removed">2269   // live.</span>
<span class="line-removed">2270   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2271     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">2272     if (u != this) {</span>
<span class="line-removed">2273       if (u-&gt;is_Phi()) {</span>
<span class="line-removed">2274         int nb = 0;</span>
<span class="line-removed">2275         for (uint j = 1; j &lt; u-&gt;req(); j++) {</span>
<span class="line-removed">2276           if (u-&gt;in(j) == val) {</span>
<span class="line-removed">2277             Node* c = u-&gt;in(0)-&gt;in(j);</span>
<span class="line-removed">2278             if (phase-&gt;is_dominator(ctrl, c)) {</span>
<span class="line-removed">2279               phase-&gt;igvn().replace_input_of(u, j, rep);</span>
<span class="line-removed">2280               nb++;</span>
<span class="line-removed">2281             }</span>
<span class="line-removed">2282           }</span>
<span class="line-removed">2283         }</span>
<span class="line-removed">2284         if (nb &gt; 0) {</span>
<span class="line-removed">2285           imax -= nb;</span>
<span class="line-removed">2286           --i;</span>
<span class="line-removed">2287         }</span>
<span class="line-removed">2288       } else {</span>
<span class="line-removed">2289         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-removed">2290         if (is_dominator(ctrl, c, this, u, phase)) {</span>
<span class="line-removed">2291           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2292           int nb = u-&gt;replace_edge(val, rep);</span>
<span class="line-removed">2293           assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2294           --i, imax -= nb;</span>
<span class="line-removed">2295         }</span>
<span class="line-removed">2296       }</span>
<span class="line-removed">2297     }</span>
<span class="line-removed">2298   }</span>
<span class="line-removed">2299 }</span>
<span class="line-removed">2300 </span>
<span class="line-removed">2301 Node* ShenandoahWriteBarrierNode::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2302   Node* mem = NULL;</span>
<span class="line-removed">2303   Node* c = ctrl;</span>
<span class="line-removed">2304   do {</span>
<span class="line-removed">2305     if (c-&gt;is_Region()) {</span>
<span class="line-removed">2306       Node* phi_bottom = NULL;</span>
<span class="line-removed">2307       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-removed">2308         Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">2309         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">2310           if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2311             mem = u;</span>
<span class="line-removed">2312           }</span>
<span class="line-removed">2313         }</span>
<span class="line-removed">2314       }</span>
<span class="line-removed">2315     } else {</span>
<span class="line-removed">2316       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {</span>
<span class="line-removed">2317         CallProjections projs;</span>
<span class="line-removed">2318         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="line-removed">2319         if (projs.fallthrough_memproj != NULL) {</span>
<span class="line-removed">2320           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2321             if (projs.catchall_memproj == NULL) {</span>
<span class="line-removed">2322               mem = projs.fallthrough_memproj;</span>
<span class="line-removed">2323             } else {</span>
<span class="line-removed">2324               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="line-removed">2325                 mem = projs.fallthrough_memproj;</span>
<span class="line-removed">2326               } else {</span>
<span class="line-removed">2327                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="line-removed">2328                 mem = projs.catchall_memproj;</span>
<span class="line-removed">2329               }</span>
<span class="line-removed">2330             }</span>
<span class="line-removed">2331           }</span>
<span class="line-removed">2332         } else {</span>
<span class="line-removed">2333           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);</span>
<span class="line-removed">2334           if (proj != NULL &amp;&amp;</span>
<span class="line-removed">2335               proj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2336             mem = proj;</span>
<span class="line-removed">2337           }</span>
<span class="line-removed">2338         }</span>
<span class="line-removed">2339       } else {</span>
<span class="line-removed">2340         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2341           Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">2342           if (u-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">2343               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">2344               u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2345               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);</span>
<span class="line-removed">2346               assert(mem == NULL, &quot;only one proj&quot;);</span>
<span class="line-removed">2347               mem = u;</span>
<span class="line-removed">2348           }</span>
<span class="line-removed">2349         }</span>
<span class="line-removed">2350         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);</span>
<span class="line-removed">2351       }</span>
<span class="line-removed">2352     }</span>
<span class="line-removed">2353     c = phase-&gt;idom(c);</span>
<span class="line-removed">2354   } while (mem == NULL);</span>
<span class="line-removed">2355   return mem;</span>
<span class="line-removed">2356 }</span>
<span class="line-removed">2357 </span>
<span class="line-removed">2358 void ShenandoahWriteBarrierNode::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2359   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2360     Node* u = n-&gt;fast_out(i);</span>
<span class="line-removed">2361     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {</span>
<span class="line-removed">2362       uses.push(u);</span>
<span class="line-removed">2363     }</span>
<span class="line-removed">2364   }</span>
<span class="line-removed">2365 }</span>
<span class="line-removed">2366 </span>
<span class="line-removed">2367 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2368   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();</span>
<span class="line-removed">2369   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));</span>
<span class="line-removed">2370   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));</span>
<span class="line-removed">2371   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);</span>
<span class="line-removed">2372   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));</span>
<span class="line-removed">2373   phase-&gt;lazy_replace(outer, new_outer);</span>
<span class="line-removed">2374   phase-&gt;lazy_replace(le, new_le);</span>
<span class="line-removed">2375   inner-&gt;clear_strip_mined();</span>
<span class="line-removed">2376 }</span>
<span class="line-removed">2377 </span>
<span class="line-removed">2378 void ShenandoahWriteBarrierNode::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="line-removed">2379                                                   PhaseIdealLoop* phase) {</span>
<span class="line-removed">2380   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2381   Node* thread = new ThreadLocalNode();</span>
<span class="line-removed">2382   phase-&gt;register_new_node(thread, ctrl);</span>
<span class="line-removed">2383   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-removed">2384   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());</span>
<span class="line-removed">2385   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);</span>
<span class="line-removed">2386   phase-&gt;register_new_node(gc_state_addr, ctrl);</span>
<span class="line-removed">2387   uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="line-removed">2388   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="line-removed">2389   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
<span class="line-removed">2390 </span>
<span class="line-removed">2391   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);</span>
<span class="line-removed">2392   phase-&gt;register_new_node(gc_state, ctrl);</span>
<span class="line-removed">2393   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
<span class="line-removed">2394   phase-&gt;register_new_node(heap_stable_and, ctrl);</span>
<span class="line-removed">2395   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));</span>
<span class="line-removed">2396   phase-&gt;register_new_node(heap_stable_cmp, ctrl);</span>
<span class="line-removed">2397   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);</span>
<span class="line-removed">2398   phase-&gt;register_new_node(heap_stable_test, ctrl);</span>
<span class="line-removed">2399   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2400   phase-&gt;register_control(heap_stable_iff, loop, ctrl);</span>
<span class="line-removed">2401 </span>
<span class="line-removed">2402   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);</span>
<span class="line-removed">2403   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);</span>
<span class="line-removed">2404   ctrl = new IfTrueNode(heap_stable_iff);</span>
<span class="line-removed">2405   phase-&gt;register_control(ctrl, loop, heap_stable_iff);</span>
<span class="line-removed">2406 </span>
<span class="line-removed">2407   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>
<span class="line-removed">2408 }</span>
<span class="line-removed">2409 </span>
<span class="line-removed">2410 void ShenandoahWriteBarrierNode::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2411   const Type* val_t = phase-&gt;igvn().type(val);</span>
<span class="line-removed">2412   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {</span>
<span class="line-removed">2413     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2414     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));</span>
<span class="line-removed">2415     phase-&gt;register_new_node(null_cmp, ctrl);</span>
<span class="line-removed">2416     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);</span>
<span class="line-removed">2417     phase-&gt;register_new_node(null_test, ctrl);</span>
<span class="line-removed">2418     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2419     phase-&gt;register_control(null_iff, loop, ctrl);</span>
<span class="line-removed">2420     ctrl = new IfTrueNode(null_iff);</span>
<span class="line-removed">2421     phase-&gt;register_control(ctrl, loop, null_iff);</span>
<span class="line-removed">2422     null_ctrl = new IfFalseNode(null_iff);</span>
<span class="line-removed">2423     phase-&gt;register_control(null_ctrl, loop, null_iff);</span>
<span class="line-removed">2424   }</span>
<span class="line-removed">2425 }</span>
<span class="line-removed">2426 </span>
<span class="line-removed">2427 Node* ShenandoahWriteBarrierNode::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2428   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="line-removed">2429   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="line-removed">2430   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="line-removed">2431   Node* new_iff = iff-&gt;clone();</span>
<span class="line-removed">2432   new_iff-&gt;set_req(0, c);</span>
<span class="line-removed">2433   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="line-removed">2434   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="line-removed">2435   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="line-removed">2436   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="line-removed">2437   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="line-removed">2438   c = iftrue;</span>
<span class="line-removed">2439   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="line-removed">2440   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="line-removed">2441   Node* uncasted_val = val-&gt;in(1);</span>
<span class="line-removed">2442   val = new CastPPNode(uncasted_val, t);</span>
<span class="line-removed">2443   val-&gt;init_req(0, c);</span>
<span class="line-removed">2444   phase-&gt;register_new_node(val, c);</span>
<span class="line-removed">2445   return val;</span>
<span class="line-removed">2446 }</span>
<span class="line-removed">2447 </span>
<span class="line-removed">2448 void ShenandoahWriteBarrierNode::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
2449                                                 Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
2450   IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();
2451   Node* proj = iff-&gt;proj_out(0);
2452   assert(proj != unc_ctrl, &quot;bad projection&quot;);
2453   Node* use = proj-&gt;unique_ctrl_out();
2454 
2455   assert(use == unc || use-&gt;is_Region(), &quot;what else?&quot;);
2456 
2457   uses.clear();
2458   if (use == unc) {
2459     phase-&gt;set_idom(use, new_unc_ctrl, phase-&gt;dom_depth(use));
2460     for (uint i = 1; i &lt; unc-&gt;req(); i++) {
2461       Node* n = unc-&gt;in(i);
2462       if (phase-&gt;has_ctrl(n) &amp;&amp; phase-&gt;get_ctrl(n) == proj) {
2463         uses.push(n);
2464       }
2465     }
2466   } else {
2467     assert(use-&gt;is_Region(), &quot;what else?&quot;);
2468     uint idx = 1;
</pre>
<hr />
<pre>
2477   for(uint next = 0; next &lt; uses.size(); next++ ) {
2478     Node *n = uses.at(next);
2479     assert(phase-&gt;get_ctrl(n) == proj, &quot;bad control&quot;);
2480     phase-&gt;set_ctrl_and_loop(n, new_unc_ctrl);
2481     if (n-&gt;in(0) == proj) {
2482       phase-&gt;igvn().replace_input_of(n, 0, new_unc_ctrl);
2483     }
2484     for (uint i = 0; i &lt; n-&gt;req(); i++) {
2485       Node* m = n-&gt;in(i);
2486       if (m != NULL &amp;&amp; phase-&gt;has_ctrl(m) &amp;&amp; phase-&gt;get_ctrl(m) == proj) {
2487         uses.push(m);
2488       }
2489     }
2490   }
2491 
2492   phase-&gt;igvn().rehash_node_delayed(use);
2493   int nb = use-&gt;replace_edge(proj, new_unc_ctrl);
2494   assert(nb == 1, &quot;only use expected&quot;);
2495 }
2496 
<span class="line-modified">2497 void ShenandoahWriteBarrierNode::in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {</span>
2498   IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
2499   Node* raw_rbtrue = new CastP2XNode(ctrl, val);
2500   phase-&gt;register_new_node(raw_rbtrue, ctrl);
2501   Node* cset_offset = new URShiftXNode(raw_rbtrue, phase-&gt;igvn().intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
2502   phase-&gt;register_new_node(cset_offset, ctrl);
2503   Node* in_cset_fast_test_base_addr = phase-&gt;igvn().makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
2504   phase-&gt;set_ctrl(in_cset_fast_test_base_addr, phase-&gt;C-&gt;root());
2505   Node* in_cset_fast_test_adr = new AddPNode(phase-&gt;C-&gt;top(), in_cset_fast_test_base_addr, cset_offset);
2506   phase-&gt;register_new_node(in_cset_fast_test_adr, ctrl);
2507   uint in_cset_fast_test_idx = Compile::AliasIdxRaw;
2508   const TypePtr* in_cset_fast_test_adr_type = NULL; // debug-mode-only argument
2509   debug_only(in_cset_fast_test_adr_type = phase-&gt;C-&gt;get_adr_type(in_cset_fast_test_idx));
2510   Node* in_cset_fast_test_load = new LoadBNode(ctrl, raw_mem, in_cset_fast_test_adr, in_cset_fast_test_adr_type, TypeInt::BYTE, MemNode::unordered);
2511   phase-&gt;register_new_node(in_cset_fast_test_load, ctrl);
2512   Node* in_cset_fast_test_cmp = new CmpINode(in_cset_fast_test_load, phase-&gt;igvn().zerocon(T_INT));
2513   phase-&gt;register_new_node(in_cset_fast_test_cmp, ctrl);
2514   Node* in_cset_fast_test_test = new BoolNode(in_cset_fast_test_cmp, BoolTest::eq);
2515   phase-&gt;register_new_node(in_cset_fast_test_test, ctrl);
2516   IfNode* in_cset_fast_test_iff = new IfNode(ctrl, in_cset_fast_test_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
2517   phase-&gt;register_control(in_cset_fast_test_iff, loop, ctrl);
2518 
2519   not_cset_ctrl = new IfTrueNode(in_cset_fast_test_iff);
2520   phase-&gt;register_control(not_cset_ctrl, loop, in_cset_fast_test_iff);
2521 
2522   ctrl = new IfFalseNode(in_cset_fast_test_iff);
2523   phase-&gt;register_control(ctrl, loop, in_cset_fast_test_iff);
2524 }
2525 
<span class="line-modified">2526 void ShenandoahWriteBarrierNode::call_wb_stub(Node*&amp; ctrl, Node*&amp; val, Node*&amp; result_mem,</span>
<span class="line-removed">2527                                               Node* raw_mem, Node* wb_mem,</span>
<span class="line-removed">2528                                               int alias,</span>
<span class="line-removed">2529                                               PhaseIdealLoop* phase) {</span>
2530   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
<span class="line-modified">2531   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
2532 
2533   // The slow path stub consumes and produces raw memory in addition
2534   // to the existing memory edges
2535   Node* base = find_bottom_mem(ctrl, phase);
<span class="line-removed">2536 </span>
2537   MergeMemNode* mm = MergeMemNode::make(base);
<span class="line-removed">2538   mm-&gt;set_memory_at(alias, wb_mem);</span>
2539   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
2540   phase-&gt;register_new_node(mm, ctrl);
2541 
<span class="line-modified">2542   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_write_barrier_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), &quot;shenandoah_write_barrier&quot;, TypeRawPtr::BOTTOM);</span>








2543   call-&gt;init_req(TypeFunc::Control, ctrl);
2544   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
2545   call-&gt;init_req(TypeFunc::Memory, mm);
2546   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
2547   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
2548   call-&gt;init_req(TypeFunc::Parms, val);

2549   phase-&gt;register_control(call, loop, ctrl);
2550   ctrl = new ProjNode(call, TypeFunc::Control);
2551   phase-&gt;register_control(ctrl, loop, call);
2552   result_mem = new ProjNode(call, TypeFunc::Memory);
2553   phase-&gt;register_new_node(result_mem, call);
2554   val = new ProjNode(call, TypeFunc::Parms);
2555   phase-&gt;register_new_node(val, call);
2556   val = new CheckCastPPNode(ctrl, val, obj_type);
2557   phase-&gt;register_new_node(val, ctrl);
2558 }
2559 
<span class="line-modified">2560 void ShenandoahWriteBarrierNode::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {</span>
2561   Node* ctrl = phase-&gt;get_ctrl(barrier);
2562   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
2563 
2564   // Update the control of all nodes that should be after the
2565   // barrier control flow
2566   uses.clear();
2567   // Every node that is control dependent on the barrier&#39;s input
2568   // control will be after the expanded barrier. The raw memory (if
2569   // its memory is control dependent on the barrier&#39;s input control)
2570   // must stay above the barrier.
2571   uses_to_ignore.clear();
2572   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
2573     uses_to_ignore.push(init_raw_mem);
2574   }
2575   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
2576     Node *n = uses_to_ignore.at(next);
2577     for (uint i = 0; i &lt; n-&gt;req(); i++) {
2578       Node* in = n-&gt;in(i);
2579       if (in != NULL &amp;&amp; phase-&gt;has_ctrl(in) &amp;&amp; phase-&gt;get_ctrl(in) == ctrl) {
2580         uses_to_ignore.push(in);
</pre>
<hr />
<pre>
2593       if (c != ctrl ||
2594           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
2595           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
2596         phase-&gt;igvn().rehash_node_delayed(u);
2597         int nb = u-&gt;replace_edge(ctrl, region);
2598         if (u-&gt;is_CFG()) {
2599           if (phase-&gt;idom(u) == ctrl) {
2600             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
2601           }
2602         } else if (phase-&gt;get_ctrl(u) == ctrl) {
2603           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
2604           uses.push(u);
2605         }
2606         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
2607         --i, imax -= nb;
2608       }
2609     }
2610   }
2611 }
2612 
<span class="line-modified">2613 void ShenandoahWriteBarrierNode::pin_and_expand(PhaseIdealLoop* phase) {</span>
<span class="line-modified">2614   Node_List enqueue_barriers;</span>
<span class="line-modified">2615   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="line-modified">2616     Unique_Node_List wq;</span>
<span class="line-modified">2617     wq.push(phase-&gt;C-&gt;root());</span>
<span class="line-modified">2618     for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-modified">2619       Node* n = wq.at(i);</span>
<span class="line-modified">2620       if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified">2621         enqueue_barriers.push(n);</span>
<span class="line-modified">2622       }</span>
<span class="line-modified">2623       for (uint i = 0; i &lt; n-&gt;req(); i++) {</span>
<span class="line-modified">2624         Node* in = n-&gt;in(i);</span>
<span class="line-modified">2625         if (in != NULL) {</span>
<span class="line-modified">2626           wq.push(in);</span>
<span class="line-modified">2627         }</span>
<span class="line-modified">2628       }</span>


2629     }
2630   }



2631 
<span class="line-modified">2632   const bool trace = false;</span>





















































2633 
<span class="line-modified">2634   // Collect raw memory state at CFG points in the entire graph and</span>
<span class="line-modified">2635   // record it in memory_nodes. Optimize the raw memory graph in the</span>
<span class="line-modified">2636   // process. Optimizing the memory graph also makes the memory graph</span>
<span class="line-modified">2637   // simpler.</span>
<span class="line-modified">2638   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;</span>
















2639 
<span class="line-modified">2640   // Let&#39;s try to common write barriers again</span>
<span class="line-modified">2641   optimize_before_expansion(phase, memory_graph_fixers, true);</span>










































2642 
<span class="line-modified">2643   Unique_Node_List uses;</span>
<span class="line-modified">2644   for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="line-modified">2645     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="line-modified">2646     Node* ctrl = phase-&gt;get_ctrl(wb);</span>






2647 
<span class="line-modified">2648     Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-modified">2649     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {</span>
<span class="line-modified">2650       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0)-&gt;in(0), val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);</span>
<span class="line-modified">2651       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0)-&gt;in(0));</span>
<span class="line-modified">2652     } else if (ctrl-&gt;is_CallRuntime()) {</span>
<span class="line-removed">2653       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0), val, ctrl, phase), &quot;can&#39;t move&quot;);</span>
<span class="line-removed">2654       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0));</span>
2655     }




































2656 
<span class="line-modified">2657     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;only for write barriers&quot;);</span>
<span class="line-modified">2658     // Look for a null check that dominates this barrier and move the</span>
<span class="line-modified">2659     // barrier right after the null check to enable implicit null</span>
<span class="line-removed">2660     // checks</span>
<span class="line-removed">2661     wb-&gt;pin_and_expand_move_barrier(phase, memory_graph_fixers, uses);</span>
2662 
<span class="line-modified">2663     wb-&gt;pin_and_expand_helper(phase);</span>
<span class="line-modified">2664   }</span>
2665 
<span class="line-modified">2666   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="line-modified">2667     Node* barrier = enqueue_barriers.at(i);</span>
<span class="line-modified">2668     Node* ctrl = phase-&gt;get_ctrl(barrier);</span>
<span class="line-modified">2669     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-modified">2670     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {</span>
<span class="line-modified">2671       // Expanding a barrier here will break loop strip mining</span>
<span class="line-modified">2672       // verification. Transform the loop so the loop nest doesn&#39;t</span>
<span class="line-modified">2673       // appear as strip mined.</span>
<span class="line-modified">2674       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();</span>
<span class="line-modified">2675       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);</span>






















































2676     }
2677   }
2678 
<span class="line-modified">2679   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="line-modified">2680     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="line-modified">2681     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="line-modified">2682     Node* ctrl = phase-&gt;get_ctrl(wb);</span>


2683     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
2684     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
2685       // Expanding a barrier here will break loop strip mining
2686       // verification. Transform the loop so the loop nest doesn&#39;t
2687       // appear as strip mined.
2688       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
2689       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
2690     }
2691   }
2692 

2693   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
2694   Unique_Node_List uses_to_ignore;
<span class="line-modified">2695   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="line-modified">2696     Node* barrier = enqueue_barriers.at(i);</span>

















































































































































































2697     Node* pre_val = barrier-&gt;in(1);
2698 
2699     if (phase-&gt;igvn().type(pre_val)-&gt;higher_equal(TypePtr::NULL_PTR)) {
2700       ShouldNotReachHere();
2701       continue;
2702     }
2703 
2704     Node* ctrl = phase-&gt;get_ctrl(barrier);
2705 
2706     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {
2707       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0)-&gt;in(0), pre_val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);
2708       ctrl = ctrl-&gt;in(0)-&gt;in(0);
2709       phase-&gt;set_ctrl(barrier, ctrl);
2710     } else if (ctrl-&gt;is_CallRuntime()) {
2711       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0), pre_val, ctrl, phase), &quot;can&#39;t move&quot;);
2712       ctrl = ctrl-&gt;in(0);
2713       phase-&gt;set_ctrl(barrier, ctrl);
2714     }
2715 
2716     Node* init_ctrl = ctrl;
</pre>
<hr />
<pre>
2768     IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
2769     if (reg2_ctrl == NULL) reg2_ctrl = queue_full_iff;
2770     phase-&gt;register_control(queue_full_iff, loop, ctrl);
2771     Node* not_full = new IfTrueNode(queue_full_iff);
2772     phase-&gt;register_control(not_full, loop, queue_full_iff);
2773     Node* full = new IfFalseNode(queue_full_iff);
2774     phase-&gt;register_control(full, loop, queue_full_iff);
2775 
2776     ctrl = not_full;
2777 
2778     Node* next_index = new SubXNode(index, phase-&gt;igvn().MakeConX(sizeof(intptr_t)));
2779     phase-&gt;register_new_node(next_index, ctrl);
2780 
2781     Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);
2782     phase-&gt;register_new_node(buffer, ctrl);
2783     Node *log_addr = new AddPNode(phase-&gt;C-&gt;top(), buffer, next_index);
2784     phase-&gt;register_new_node(log_addr, ctrl);
2785     Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);
2786     phase-&gt;register_new_node(log_store, ctrl);
2787     // update the index
<span class="line-modified">2788     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);</span>
<span class="line-modified">2789     phase-&gt;register_new_node(index_update, ctrl);</span>
<span class="line-removed">2790 </span>
<span class="line-removed">2791     // Fast-path case</span>
<span class="line-removed">2792     region2-&gt;init_req(_fast_path, ctrl);</span>
<span class="line-removed">2793     phi2-&gt;init_req(_fast_path, index_update);</span>
<span class="line-removed">2794 </span>
<span class="line-removed">2795     ctrl = full;</span>
<span class="line-removed">2796 </span>
<span class="line-removed">2797     Node* base = find_bottom_mem(ctrl, phase);</span>
<span class="line-removed">2798 </span>
<span class="line-removed">2799     MergeMemNode* mm = MergeMemNode::make(base);</span>
<span class="line-removed">2800     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);</span>
<span class="line-removed">2801     phase-&gt;register_new_node(mm, ctrl);</span>
<span class="line-removed">2802 </span>
<span class="line-removed">2803     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);</span>
<span class="line-removed">2804     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-removed">2805     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2806     call-&gt;init_req(TypeFunc::Memory, mm);</span>
<span class="line-removed">2807     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2808     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2809     call-&gt;init_req(TypeFunc::Parms, pre_val);</span>
<span class="line-removed">2810     call-&gt;init_req(TypeFunc::Parms+1, thread);</span>
<span class="line-removed">2811     phase-&gt;register_control(call, loop, ctrl);</span>
<span class="line-removed">2812 </span>
<span class="line-removed">2813     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);</span>
<span class="line-removed">2814     phase-&gt;register_control(ctrl_proj, loop, call);</span>
<span class="line-removed">2815     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);</span>
<span class="line-removed">2816     phase-&gt;register_new_node(mem_proj, call);</span>
<span class="line-removed">2817 </span>
<span class="line-removed">2818     // Slow-path case</span>
<span class="line-removed">2819     region2-&gt;init_req(_slow_path, ctrl_proj);</span>
<span class="line-removed">2820     phi2-&gt;init_req(_slow_path, mem_proj);</span>
<span class="line-removed">2821 </span>
<span class="line-removed">2822     phase-&gt;register_control(region2, loop, reg2_ctrl);</span>
<span class="line-removed">2823     phase-&gt;register_new_node(phi2, region2);</span>
<span class="line-removed">2824 </span>
<span class="line-removed">2825     region-&gt;init_req(_heap_unstable, region2);</span>
<span class="line-removed">2826     phi-&gt;init_req(_heap_unstable, phi2);</span>
<span class="line-removed">2827 </span>
<span class="line-removed">2828     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));</span>
<span class="line-removed">2829     phase-&gt;register_new_node(phi, region);</span>
<span class="line-removed">2830 </span>
<span class="line-removed">2831     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="line-removed">2832     for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="line-removed">2833       Node *n = uses.at(next);</span>
<span class="line-removed">2834       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);</span>
<span class="line-removed">2835       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);</span>
<span class="line-removed">2836       phase-&gt;set_ctrl(n, region);</span>
<span class="line-removed">2837       follow_barrier_uses(n, init_ctrl, uses, phase);</span>
<span class="line-removed">2838     }</span>
<span class="line-removed">2839     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);</span>
<span class="line-removed">2840 </span>
<span class="line-removed">2841     phase-&gt;igvn().replace_node(barrier, pre_val);</span>
<span class="line-removed">2842   }</span>
<span class="line-removed">2843 </span>
<span class="line-removed">2844   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="line-removed">2845     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="line-removed">2846     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="line-removed">2847 </span>
<span class="line-removed">2848     uint last = phase-&gt;C-&gt;unique();</span>
<span class="line-removed">2849     Node* ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="line-removed">2850     Node* orig_ctrl = ctrl;</span>
<span class="line-removed">2851 </span>
<span class="line-removed">2852     Node* raw_mem = fixer.find_mem(ctrl, wb);</span>
<span class="line-removed">2853     Node* init_raw_mem = raw_mem;</span>
<span class="line-removed">2854     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);</span>
<span class="line-removed">2855     int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="line-removed">2856     Node* wb_mem =  wb-&gt;in(Memory);</span>
<span class="line-removed">2857     Node* init_wb_mem = wb_mem;</span>
<span class="line-removed">2858 </span>
<span class="line-removed">2859     Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-removed">2860     Node* wbproj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">2861     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2862 </span>
<span class="line-removed">2863     assert(val-&gt;Opcode() != Op_ShenandoahWriteBarrier, &quot;No chain of write barriers&quot;);</span>
<span class="line-removed">2864 </span>
<span class="line-removed">2865     CallStaticJavaNode* unc = wb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2866     Node* unc_ctrl = NULL;</span>
<span class="line-removed">2867     if (unc != NULL) {</span>
<span class="line-removed">2868       if (val-&gt;in(0) != ctrl) {</span>
<span class="line-removed">2869         unc = NULL;</span>
<span class="line-removed">2870       } else {</span>
<span class="line-removed">2871         unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2872       }</span>
<span class="line-removed">2873     }</span>
<span class="line-removed">2874 </span>
<span class="line-removed">2875     Node* uncasted_val = val;</span>
<span class="line-removed">2876     if (unc != NULL) {</span>
<span class="line-removed">2877       uncasted_val = val-&gt;in(1);</span>
<span class="line-removed">2878     }</span>
<span class="line-removed">2879 </span>
<span class="line-removed">2880     Node* heap_stable_ctrl = NULL;</span>
<span class="line-removed">2881     Node* null_ctrl = NULL;</span>
<span class="line-removed">2882 </span>
<span class="line-removed">2883     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);</span>
<span class="line-removed">2884     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);</span>
<span class="line-removed">2885 </span>
<span class="line-removed">2886     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };</span>
<span class="line-removed">2887     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="line-removed">2888     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="line-removed">2889     Node* mem_phi = PhiNode::make(region, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="line-removed">2890     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
2891 
<span class="line-modified">2892     enum { _not_cset = 1, _not_equal, _evac_path, _null_path, PATH_LIMIT2 };</span>
<span class="line-modified">2893     Node* region2 = new RegionNode(PATH_LIMIT2);</span>
<span class="line-modified">2894     Node* val_phi2 = new PhiNode(region2, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="line-removed">2895     Node* mem_phi2 = PhiNode::make(region2, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="line-removed">2896     Node* raw_mem_phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
2897 
<span class="line-modified">2898       // Stable path.</span>
<span class="line-removed">2899     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
<span class="line-removed">2900     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();</span>
2901 
<span class="line-modified">2902     // Heap stable case</span>
<span class="line-removed">2903     region-&gt;init_req(_heap_stable, heap_stable_ctrl);</span>
<span class="line-removed">2904     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
<span class="line-removed">2905     mem_phi-&gt;init_req(_heap_stable, wb_mem);</span>
<span class="line-removed">2906     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);</span>
2907 
<span class="line-modified">2908     Node* reg2_ctrl = NULL;</span>
<span class="line-modified">2909     // Null case</span>
<span class="line-modified">2910     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="line-removed">2911     if (null_ctrl != NULL) {</span>
<span class="line-removed">2912       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="line-removed">2913       region2-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-removed">2914       val_phi2-&gt;init_req(_null_path, uncasted_val);</span>
<span class="line-removed">2915       mem_phi2-&gt;init_req(_null_path, wb_mem);</span>
<span class="line-removed">2916       raw_mem_phi2-&gt;init_req(_null_path, raw_mem);</span>
<span class="line-removed">2917     } else {</span>
<span class="line-removed">2918       region2-&gt;del_req(_null_path);</span>
<span class="line-removed">2919       val_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2920       mem_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2921       raw_mem_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2922     }</span>
2923 
<span class="line-modified">2924     // Test for in-cset.</span>
<span class="line-modified">2925     // Wires !in_cset(obj) to slot 2 of region and phis</span>
<span class="line-modified">2926     Node* not_cset_ctrl = NULL;</span>
<span class="line-modified">2927     in_cset_fast_test(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
<span class="line-modified">2928     if (not_cset_ctrl != NULL) {</span>
<span class="line-modified">2929       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="line-modified">2930       region2-&gt;init_req(_not_cset, not_cset_ctrl);</span>
<span class="line-modified">2931       val_phi2-&gt;init_req(_not_cset, uncasted_val);</span>
<span class="line-modified">2932       mem_phi2-&gt;init_req(_not_cset, wb_mem);</span>
<span class="line-removed">2933       raw_mem_phi2-&gt;init_req(_not_cset, raw_mem);</span>
<span class="line-removed">2934     }</span>
2935 
<span class="line-modified">2936     // Resolve object when orig-value is in cset.</span>
<span class="line-modified">2937     // Make the unconditional resolve for fwdptr, not the read barrier.</span>
<span class="line-modified">2938     Node* new_val = uncasted_val;</span>
<span class="line-modified">2939     if (unc_ctrl != NULL) {</span>
<span class="line-removed">2940       // Clone the null check in this branch to allow implicit null check</span>
<span class="line-removed">2941       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="line-removed">2942       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
2943 
<span class="line-modified">2944       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-modified">2945       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="line-modified">2946     }</span>
<span class="line-removed">2947     Node* addr = new AddPNode(new_val, uncasted_val, phase-&gt;igvn().MakeConX(ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-removed">2948     phase-&gt;register_new_node(addr, ctrl);</span>
<span class="line-removed">2949     assert(val-&gt;bottom_type()-&gt;isa_oopptr(), &quot;what else?&quot;);</span>
<span class="line-removed">2950     const TypePtr* obj_type =  val-&gt;bottom_type()-&gt;is_oopptr();</span>
<span class="line-removed">2951     const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="line-removed">2952     Node* fwd = new LoadPNode(ctrl, wb_mem, addr, adr_type, obj_type, MemNode::unordered);</span>
<span class="line-removed">2953     phase-&gt;register_new_node(fwd, ctrl);</span>
<span class="line-removed">2954 </span>
<span class="line-removed">2955     // Only branch to WB stub if object is not forwarded; otherwise reply with fwd ptr</span>
<span class="line-removed">2956     Node* cmp = new CmpPNode(fwd, new_val);</span>
<span class="line-removed">2957     phase-&gt;register_new_node(cmp, ctrl);</span>
<span class="line-removed">2958     Node* bol = new BoolNode(cmp, BoolTest::eq);</span>
<span class="line-removed">2959     phase-&gt;register_new_node(bol, ctrl);</span>
<span class="line-removed">2960 </span>
<span class="line-removed">2961     IfNode* iff = new IfNode(ctrl, bol, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2962     if (reg2_ctrl == NULL) reg2_ctrl = iff;</span>
<span class="line-removed">2963     phase-&gt;register_control(iff, loop, ctrl);</span>
<span class="line-removed">2964     Node* if_not_eq = new IfFalseNode(iff);</span>
<span class="line-removed">2965     phase-&gt;register_control(if_not_eq, loop, iff);</span>
<span class="line-removed">2966     Node* if_eq = new IfTrueNode(iff);</span>
<span class="line-removed">2967     phase-&gt;register_control(if_eq, loop, iff);</span>
<span class="line-removed">2968 </span>
<span class="line-removed">2969     // Wire up not-equal-path in slots 3.</span>
<span class="line-removed">2970     region2-&gt;init_req(_not_equal, if_not_eq);</span>
<span class="line-removed">2971     val_phi2-&gt;init_req(_not_equal, fwd);</span>
<span class="line-removed">2972     mem_phi2-&gt;init_req(_not_equal, wb_mem);</span>
<span class="line-removed">2973     raw_mem_phi2-&gt;init_req(_not_equal, raw_mem);</span>
<span class="line-removed">2974 </span>
<span class="line-removed">2975     // Call wb-stub and wire up that path in slots 4</span>
<span class="line-removed">2976     Node* result_mem = NULL;</span>
<span class="line-removed">2977     ctrl = if_eq;</span>
<span class="line-removed">2978     call_wb_stub(ctrl, new_val, result_mem,</span>
<span class="line-removed">2979                  raw_mem, wb_mem,</span>
<span class="line-removed">2980                  alias, phase);</span>
<span class="line-removed">2981     region2-&gt;init_req(_evac_path, ctrl);</span>
<span class="line-removed">2982     val_phi2-&gt;init_req(_evac_path, new_val);</span>
<span class="line-removed">2983     mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
<span class="line-removed">2984     raw_mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
2985 
2986     phase-&gt;register_control(region2, loop, reg2_ctrl);
<span class="line-modified">2987     phase-&gt;register_new_node(val_phi2, region2);</span>
<span class="line-removed">2988     phase-&gt;register_new_node(mem_phi2, region2);</span>
<span class="line-removed">2989     phase-&gt;register_new_node(raw_mem_phi2, region2);</span>
2990 
2991     region-&gt;init_req(_heap_unstable, region2);
<span class="line-modified">2992     val_phi-&gt;init_req(_heap_unstable, val_phi2);</span>
<span class="line-removed">2993     mem_phi-&gt;init_req(_heap_unstable, mem_phi2);</span>
<span class="line-removed">2994     raw_mem_phi-&gt;init_req(_heap_unstable, raw_mem_phi2);</span>
<span class="line-removed">2995 </span>
<span class="line-removed">2996     phase-&gt;register_control(region, loop, heap_stable_iff);</span>
<span class="line-removed">2997     Node* out_val = val_phi;</span>
<span class="line-removed">2998     phase-&gt;register_new_node(val_phi, region);</span>
<span class="line-removed">2999     phase-&gt;register_new_node(mem_phi, region);</span>
<span class="line-removed">3000     phase-&gt;register_new_node(raw_mem_phi, region);</span>
<span class="line-removed">3001 </span>
<span class="line-removed">3002     fix_ctrl(wb, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="line-removed">3003 </span>
<span class="line-removed">3004     ctrl = orig_ctrl;</span>
<span class="line-removed">3005 </span>
<span class="line-removed">3006     phase-&gt;igvn().replace_input_of(wbproj, ShenandoahWBMemProjNode::WriteBarrier, phase-&gt;C-&gt;top());</span>
<span class="line-removed">3007     phase-&gt;igvn().replace_node(wbproj, mem_phi);</span>
<span class="line-removed">3008     if (unc != NULL) {</span>
<span class="line-removed">3009       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">3010         Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">3011         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-removed">3012         if (u != wb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, wb, u, phase))) {</span>
<span class="line-removed">3013           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">3014           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="line-removed">3015           --i, imax -= nb;</span>
<span class="line-removed">3016         }</span>
<span class="line-removed">3017       }</span>
<span class="line-removed">3018       if (val-&gt;outcnt() == 0) {</span>
<span class="line-removed">3019         phase-&gt;igvn()._worklist.push(val);</span>
<span class="line-removed">3020       }</span>
<span class="line-removed">3021     }</span>
<span class="line-removed">3022     phase-&gt;igvn().replace_node(wb, out_val);</span>
3023 
<span class="line-modified">3024     follow_barrier_uses(mem_phi, ctrl, uses, phase);</span>
<span class="line-modified">3025     follow_barrier_uses(out_val, ctrl, uses, phase);</span>
3026 

3027     for(uint next = 0; next &lt; uses.size(); next++ ) {
3028       Node *n = uses.at(next);
<span class="line-modified">3029       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);</span>
3030       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
3031       phase-&gt;set_ctrl(n, region);
<span class="line-modified">3032       follow_barrier_uses(n, ctrl, uses, phase);</span>
3033     }

3034 
<span class="line-modified">3035     // The slow path call produces memory: hook the raw memory phi</span>
<span class="line-modified">3036     // from the expanded write barrier with the rest of the graph</span>
<span class="line-modified">3037     // which may require adding memory phis at every post dominated</span>
<span class="line-modified">3038     // region and at enclosing loop heads. Use the memory state</span>
<span class="line-modified">3039     // collected in memory_nodes to fix the memory graph. Update that</span>
<span class="line-modified">3040     // memory state as we go.</span>
<span class="line-modified">3041     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);</span>
<span class="line-modified">3042     assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == cnt - 1, &quot;not replaced&quot;);</span>































































3043   }
3044 
<span class="line-removed">3045   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == 0, &quot;all write barrier nodes should have been replaced&quot;);</span>
3046 }
3047 
<span class="line-modified">3048 void ShenandoahWriteBarrierNode::move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {</span>
3049   IdealLoopTree *loop = phase-&gt;get_loop(iff);
3050   Node* loop_head = loop-&gt;_head;
3051   Node* entry_c = loop_head-&gt;in(LoopNode::EntryControl);
3052 
3053   Node* bol = iff-&gt;in(1);
3054   Node* cmp = bol-&gt;in(1);
3055   Node* andi = cmp-&gt;in(1);
3056   Node* load = andi-&gt;in(1);
3057 
3058   assert(is_gc_state_load(load), &quot;broken&quot;);
3059   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
3060     Node* mem_ctrl = NULL;
3061     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
3062     load = load-&gt;clone();
3063     load-&gt;set_req(MemNode::Memory, mem);
3064     load-&gt;set_req(0, entry_c);
3065     phase-&gt;register_new_node(load, entry_c);
3066     andi = andi-&gt;clone();
3067     andi-&gt;set_req(1, load);
3068     phase-&gt;register_new_node(andi, entry_c);
3069     cmp = cmp-&gt;clone();
3070     cmp-&gt;set_req(1, andi);
3071     phase-&gt;register_new_node(cmp, entry_c);
3072     bol = bol-&gt;clone();
3073     bol-&gt;set_req(1, cmp);
3074     phase-&gt;register_new_node(bol, entry_c);
3075 
3076     Node* old_bol =iff-&gt;in(1);
3077     phase-&gt;igvn().replace_input_of(iff, 1, bol);
3078   }
3079 }
3080 
<span class="line-modified">3081 bool ShenandoahWriteBarrierNode::identical_backtoback_ifs(Node *n, PhaseIdealLoop* phase) {</span>
3082   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
3083     return false;
3084   }
3085   Node* region = n-&gt;in(0);
3086 
3087   if (!region-&gt;is_Region()) {
3088     return false;
3089   }
3090   Node* dom = phase-&gt;idom(region);
3091   if (!dom-&gt;is_If()) {
3092     return false;
3093   }
3094 
3095   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
3096     return false;
3097   }
3098 
3099   IfNode* dom_if = dom-&gt;as_If();
3100   Node* proj_true = dom_if-&gt;proj_out(1);
3101   Node* proj_false = dom_if-&gt;proj_out(0);
3102 
3103   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3104     if (phase-&gt;is_dominator(proj_true, region-&gt;in(i))) {
3105       continue;
3106     }
3107     if (phase-&gt;is_dominator(proj_false, region-&gt;in(i))) {
3108       continue;
3109     }
3110     return false;
3111   }
3112 
3113   return true;
3114 }
3115 
<span class="line-modified">3116 void ShenandoahWriteBarrierNode::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {</span>
3117   assert(is_heap_stable_test(n), &quot;no other tests&quot;);
3118   if (identical_backtoback_ifs(n, phase)) {
3119     Node* n_ctrl = n-&gt;in(0);
3120     if (phase-&gt;can_split_if(n_ctrl)) {
3121       IfNode* dom_if = phase-&gt;idom(n_ctrl)-&gt;as_If();
3122       if (is_heap_stable_test(n)) {
3123         Node* gc_state_load = n-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
3124         assert(is_gc_state_load(gc_state_load), &quot;broken&quot;);
3125         Node* dom_gc_state_load = dom_if-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
3126         assert(is_gc_state_load(dom_gc_state_load), &quot;broken&quot;);
3127         if (gc_state_load != dom_gc_state_load) {
3128           phase-&gt;igvn().replace_node(gc_state_load, dom_gc_state_load);
3129         }
3130       }
3131       PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
3132       Node* proj_true = dom_if-&gt;proj_out(1);
3133       Node* proj_false = dom_if-&gt;proj_out(0);
3134       Node* con_true = phase-&gt;igvn().makecon(TypeInt::ONE);
3135       Node* con_false = phase-&gt;igvn().makecon(TypeInt::ZERO);
3136 
3137       for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
3138         if (phase-&gt;is_dominator(proj_true, n_ctrl-&gt;in(i))) {
3139           bolphi-&gt;init_req(i, con_true);
3140         } else {
3141           assert(phase-&gt;is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
3142           bolphi-&gt;init_req(i, con_false);
3143         }
3144       }
3145       phase-&gt;register_new_node(bolphi, n_ctrl);
3146       phase-&gt;igvn().replace_input_of(n, 1, bolphi);
3147       phase-&gt;do_split_if(n);
3148     }
3149   }
3150 }
3151 
<span class="line-modified">3152 IfNode* ShenandoahWriteBarrierNode::find_unswitching_candidate(const IdealLoopTree *loop, PhaseIdealLoop* phase) {</span>
3153   // Find first invariant test that doesn&#39;t exit the loop
3154   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
3155   IfNode* unswitch_iff = NULL;
3156   Node* n = head-&gt;in(LoopNode::LoopBackControl);
3157   int loop_has_sfpts = -1;
3158   while (n != head) {
3159     Node* n_dom = phase-&gt;idom(n);
3160     if (n-&gt;is_Region()) {
3161       if (n_dom-&gt;is_If()) {
3162         IfNode* iff = n_dom-&gt;as_If();
3163         if (iff-&gt;in(1)-&gt;is_Bool()) {
3164           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
3165           if (bol-&gt;in(1)-&gt;is_Cmp()) {
3166             // If condition is invariant and not a loop exit,
3167             // then found reason to unswitch.
3168             if (is_heap_stable_test(iff) &amp;&amp;
3169                 (loop_has_sfpts == -1 || loop_has_sfpts == 0)) {
3170               assert(!loop-&gt;is_loop_exit(iff), &quot;both branches should be in the loop&quot;);
3171               if (loop_has_sfpts == -1) {
3172                 for(uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
</pre>
<hr />
<pre>
3177                   }
3178                 }
3179                 if (loop_has_sfpts == -1) {
3180                   loop_has_sfpts = 0;
3181                 }
3182               }
3183               if (!loop_has_sfpts) {
3184                 unswitch_iff = iff;
3185               }
3186             }
3187           }
3188         }
3189       }
3190     }
3191     n = n_dom;
3192   }
3193   return unswitch_iff;
3194 }
3195 
3196 
<span class="line-modified">3197 void ShenandoahWriteBarrierNode::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {</span>
3198   Node_List heap_stable_tests;
3199   Node_List gc_state_loads;
<span class="line-removed">3200 </span>
3201   stack.push(phase-&gt;C-&gt;start(), 0);
3202   do {
3203     Node* n = stack.node();
3204     uint i = stack.index();
3205 
3206     if (i &lt; n-&gt;outcnt()) {
3207       Node* u = n-&gt;raw_out(i);
3208       stack.set_index(i+1);
3209       if (!visited.test_set(u-&gt;_idx)) {
3210         stack.push(u, 0);
3211       }
3212     } else {
3213       stack.pop();
3214       if (ShenandoahCommonGCStateLoads &amp;&amp; is_gc_state_load(n)) {
3215         gc_state_loads.push(n);
3216       }
3217       if (n-&gt;is_If() &amp;&amp; is_heap_stable_test(n)) {
3218         heap_stable_tests.push(n);
3219       }
3220     }
</pre>
<hr />
<pre>
3228       if (n-&gt;outcnt() != 0) {
3229         progress |= try_common_gc_state_load(n, phase);
3230       }
3231     }
3232   } while (progress);
3233 
3234   for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
3235     Node* n = heap_stable_tests.at(i);
3236     assert(is_heap_stable_test(n), &quot;only evacuation test&quot;);
3237     merge_back_to_back_tests(n, phase);
3238   }
3239 
3240   if (!phase-&gt;C-&gt;major_progress()) {
3241     VectorSet seen(Thread::current()-&gt;resource_area());
3242     for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
3243       Node* n = heap_stable_tests.at(i);
3244       IdealLoopTree* loop = phase-&gt;get_loop(n);
3245       if (loop != phase-&gt;ltree_root() &amp;&amp;
3246           loop-&gt;_child == NULL &amp;&amp;
3247           !loop-&gt;_irreducible) {
<span class="line-modified">3248         LoopNode* head = loop-&gt;_head-&gt;as_Loop();</span>
<span class="line-modified">3249         if ((!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;</span>

3250             !seen.test_set(head-&gt;_idx)) {
3251           IfNode* iff = find_unswitching_candidate(loop, phase);
3252           if (iff != NULL) {
3253             Node* bol = iff-&gt;in(1);
<span class="line-modified">3254             if (head-&gt;is_strip_mined()) {</span>
<span class="line-modified">3255               head-&gt;verify_strip_mined(0);</span>
3256             }
3257             move_heap_stable_test_out_of_loop(iff, phase);



3258             if (loop-&gt;policy_unswitching(phase)) {
<span class="line-modified">3259               if (head-&gt;is_strip_mined()) {</span>
3260                 OuterStripMinedLoopNode* outer = head-&gt;as_CountedLoop()-&gt;outer_loop();
3261                 hide_strip_mined_loop(outer, head-&gt;as_CountedLoop(), phase);
3262               }
3263               phase-&gt;do_unswitching(loop, old_new);
3264             } else {
3265               // Not proceeding with unswitching. Move load back in
3266               // the loop.
3267               phase-&gt;igvn().replace_input_of(iff, 1, bol);
3268             }
3269           }
3270         }
3271       }
3272     }
3273   }
3274 }
3275 
3276 #ifdef ASSERT
<span class="line-modified">3277 void ShenandoahBarrierNode::verify_raw_mem(RootNode* root) {</span>
3278   const bool trace = false;
3279   ResourceMark rm;
3280   Unique_Node_List nodes;
3281   Unique_Node_List controls;
3282   Unique_Node_List memories;
3283 
3284   nodes.push(root);
3285   for (uint next = 0; next &lt; nodes.size(); next++) {
3286     Node *n  = nodes.at(next);
<span class="line-modified">3287     if (ShenandoahBarrierSetC2::is_shenandoah_wb_call(n)) {</span>
3288       controls.push(n);
3289       if (trace) { tty-&gt;print(&quot;XXXXXX verifying&quot;); n-&gt;dump(); }
3290       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
3291         Node *m = controls.at(next2);
3292         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3293           Node* u = m-&gt;fast_out(i);
3294           if (u-&gt;is_CFG() &amp;&amp; !u-&gt;is_Root() &amp;&amp;
3295               !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1) &amp;&amp;
3296               !(u-&gt;is_Region() &amp;&amp; u-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Halt)) {
3297             if (trace) { tty-&gt;print(&quot;XXXXXX pushing control&quot;); u-&gt;dump(); }
3298             controls.push(u);
3299           }
3300         }
3301       }
3302       memories.push(n-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory));
3303       for (uint next2 = 0; next2 &lt; memories.size(); next2++) {
3304         Node *m = memories.at(next2);
3305         assert(m-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3306         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3307           Node* u = m-&gt;fast_out(i);
</pre>
<hr />
<pre>
3355                 }
3356               }
3357             }
3358           }
3359           assert(found_phi || all_in, &quot;&quot;);
3360         }
3361       }
3362       controls.clear();
3363       memories.clear();
3364     }
3365     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {
3366       Node *m = n-&gt;in(i);
3367       if (m != NULL) {
3368         nodes.push(m);
3369       }
3370     }
3371   }
3372 }
3373 #endif
3374 




3375 const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {
3376   if (in(1) == NULL || in(1)-&gt;is_top()) {
3377     return Type::TOP;
3378   }
3379   const Type* t = in(1)-&gt;bottom_type();
3380   if (t == TypePtr::NULL_PTR) {
3381     return t;
3382   }
<span class="line-modified">3383   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
3384 }
3385 
3386 const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {
3387   if (in(1) == NULL) {
3388     return Type::TOP;
3389   }
3390   const Type* t = phase-&gt;type(in(1));
3391   if (t == Type::TOP) {
3392     return Type::TOP;
3393   }
3394   if (t == TypePtr::NULL_PTR) {
3395     return t;
3396   }
<span class="line-modified">3397   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
3398 }
3399 
3400 int ShenandoahEnqueueBarrierNode::needed(Node* n) {
3401   if (n == NULL ||
3402       n-&gt;is_Allocate() ||

3403       n-&gt;bottom_type() == TypePtr::NULL_PTR ||
3404       (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL)) {
3405     return NotNeeded;
3406   }
3407   if (n-&gt;is_Phi() ||
3408       n-&gt;is_CMove()) {
3409     return MaybeNeeded;
3410   }
3411   return Needed;
3412 }
3413 
3414 Node* ShenandoahEnqueueBarrierNode::next(Node* n) {
3415   for (;;) {
3416     if (n == NULL) {
3417       return n;
3418     } else if (n-&gt;bottom_type() == TypePtr::NULL_PTR) {
3419       return n;
3420     } else if (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL) {
3421       return n;
3422     } else if (n-&gt;is_ConstraintCast() ||
</pre>
<hr />
<pre>
3502 void MemoryGraphFixer::collect_memory_nodes() {
3503   Node_Stack stack(0);
3504   VectorSet visited(Thread::current()-&gt;resource_area());
3505   Node_List regions;
3506 
3507   // Walk the raw memory graph and create a mapping from CFG node to
3508   // memory node. Exclude phis for now.
3509   stack.push(_phase-&gt;C-&gt;root(), 1);
3510   do {
3511     Node* n = stack.node();
3512     int opc = n-&gt;Opcode();
3513     uint i = stack.index();
3514     if (i &lt; n-&gt;req()) {
3515       Node* mem = NULL;
3516       if (opc == Op_Root) {
3517         Node* in = n-&gt;in(i);
3518         int in_opc = in-&gt;Opcode();
3519         if (in_opc == Op_Return || in_opc == Op_Rethrow) {
3520           mem = in-&gt;in(TypeFunc::Memory);
3521         } else if (in_opc == Op_Halt) {
<span class="line-modified">3522           if (!in-&gt;in(0)-&gt;is_Region()) {</span>





3523             Node* proj = in-&gt;in(0);
3524             assert(proj-&gt;is_Proj(), &quot;&quot;);
3525             Node* in = proj-&gt;in(0);
3526             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
3527             if (in-&gt;is_CallStaticJava()) {
3528               mem = in-&gt;in(TypeFunc::Memory);
3529             } else if (in-&gt;Opcode() == Op_Catch) {
3530               Node* call = in-&gt;in(0)-&gt;in(0);
3531               assert(call-&gt;is_Call(), &quot;&quot;);
3532               mem = call-&gt;in(TypeFunc::Memory);
































3533             }
3534           }
3535         } else {
3536 #ifdef ASSERT
3537           n-&gt;dump();
3538           in-&gt;dump();
3539 #endif
3540           ShouldNotReachHere();
3541         }
3542       } else {
3543         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3544         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
3545         mem = n-&gt;in(i);
3546       }
3547       i++;
3548       stack.set_index(i);
3549       if (mem == NULL) {
3550         continue;
3551       }
3552       for (;;) {
3553         if (visited.test_set(mem-&gt;_idx) || mem-&gt;is_Start()) {
3554           break;
3555         }
3556         if (mem-&gt;is_Phi()) {
3557           stack.push(mem, 2);
3558           mem = mem-&gt;in(1);
3559         } else if (mem-&gt;is_Proj()) {
3560           stack.push(mem, mem-&gt;req());
3561           mem = mem-&gt;in(0);
3562         } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
3563           mem = mem-&gt;in(TypeFunc::Memory);
3564         } else if (mem-&gt;is_MergeMem()) {
3565           MergeMemNode* mm = mem-&gt;as_MergeMem();
3566           mem = mm-&gt;memory_at(_alias);
3567         } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
3568           assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3569           stack.push(mem, mem-&gt;req());
3570           mem = mem-&gt;in(MemNode::Memory);
<span class="line-removed">3571         } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">3572           assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3573           mem = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed">3574         } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">3575           stack.push(mem, mem-&gt;req());</span>
<span class="line-removed">3576           mem = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
3577         } else {
3578 #ifdef ASSERT
3579           mem-&gt;dump();
3580 #endif
3581           ShouldNotReachHere();
3582         }
3583       }
3584     } else {
3585       if (n-&gt;is_Phi()) {
3586         // Nothing
3587       } else if (!n-&gt;is_Root()) {
3588         Node* c = get_ctrl(n);
3589         _memory_nodes.map(c-&gt;_idx, n);
3590       }
3591       stack.pop();
3592     }
3593   } while(stack.is_nonempty());
3594 
3595   // Iterate over CFG nodes in rpo and propagate memory state to
3596   // compute memory state at regions, creating new phis if needed.
3597   Node_List rpo_list;
<span class="line-modified">3598   visited.Clear();</span>
3599   _phase-&gt;rpo(_phase-&gt;C-&gt;root(), stack, visited, rpo_list);
3600   Node* root = rpo_list.pop();
3601   assert(root == _phase-&gt;C-&gt;root(), &quot;&quot;);
3602 
3603   const bool trace = false;
3604 #ifdef ASSERT
3605   if (trace) {
3606     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3607       Node* c = rpo_list.at(i);
3608       if (_memory_nodes[c-&gt;_idx] != NULL) {
3609         tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump();
3610       }
3611     }
3612   }
3613 #endif
3614   uint last = _phase-&gt;C-&gt;unique();
3615 
3616 #ifdef ASSERT
3617   uint8_t max_depth = 0;
3618   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
3619     IdealLoopTree* lpt = iter.current();
3620     max_depth = MAX2(max_depth, lpt-&gt;_nest);
3621   }
3622 #endif
3623 
3624   bool progress = true;
3625   int iteration = 0;
3626   Node_List dead_phis;
3627   while (progress) {
3628     progress = false;
3629     iteration++;
<span class="line-modified">3630     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);</span>
3631     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
3632     IdealLoopTree* last_updated_ilt = NULL;
3633     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3634       Node* c = rpo_list.at(i);
3635 
3636       Node* prev_mem = _memory_nodes[c-&gt;_idx];
3637       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
3638         Node* prev_region = regions[c-&gt;_idx];
3639         Node* unique = NULL;
3640         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
3641           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
3642           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
3643           if (m != NULL) {
3644             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
3645               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);
3646               // continue
3647             } else if (unique == NULL) {
3648               unique = m;
3649             } else if (m == unique) {
3650               // continue
</pre>
<hr />
<pre>
3778   else {
3779     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
3780     return n;
3781   }
3782 }
3783 
3784 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
3785   return m != NULL &amp;&amp; get_ctrl(m) == c;
3786 }
3787 
3788 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
3789   assert(n == NULL || _phase-&gt;ctrl_or_self(n) == ctrl, &quot;&quot;);
3790   Node* mem = _memory_nodes[ctrl-&gt;_idx];
3791   Node* c = ctrl;
3792   while (!mem_is_valid(mem, c) &amp;&amp;
3793          (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem))) {
3794     c = _phase-&gt;idom(c);
3795     mem = _memory_nodes[c-&gt;_idx];
3796   }
3797   if (n != NULL &amp;&amp; mem_is_valid(mem, c)) {
<span class="line-modified">3798     while (!ShenandoahWriteBarrierNode::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {</span>
3799       mem = next_mem(mem, _alias);
3800     }
3801     if (mem-&gt;is_MergeMem()) {
3802       mem = mem-&gt;as_MergeMem()-&gt;memory_at(_alias);
3803     }
3804     if (!mem_is_valid(mem, c)) {
3805       do {
3806         c = _phase-&gt;idom(c);
3807         mem = _memory_nodes[c-&gt;_idx];
3808       } while (!mem_is_valid(mem, c) &amp;&amp;
3809                (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem)));
3810     }
3811   }
3812   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3813   return mem;
3814 }
3815 
3816 bool MemoryGraphFixer::has_mem_phi(Node* region) const {
3817   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
3818     Node* use = region-&gt;fast_out(i);
</pre>
<hr />
<pre>
3824   return false;
3825 }
3826 
3827 void MemoryGraphFixer::fix_mem(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl, Node* new_mem, Unique_Node_List&amp; uses) {
3828   assert(_phase-&gt;ctrl_or_self(new_mem) == new_ctrl, &quot;&quot;);
3829   const bool trace = false;
3830   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ control is&quot;); ctrl-&gt;dump(); });
3831   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ mem is&quot;); mem-&gt;dump(); });
3832   GrowableArray&lt;Node*&gt; phis;
3833   if (mem_for_ctrl != mem) {
3834     Node* old = mem_for_ctrl;
3835     Node* prev = NULL;
3836     while (old != mem) {
3837       prev = old;
3838       if (old-&gt;is_Store() || old-&gt;is_ClearArray() || old-&gt;is_LoadStore()) {
3839         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3840         old = old-&gt;in(MemNode::Memory);
3841       } else if (old-&gt;Opcode() == Op_SCMemProj) {
3842         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3843         old = old-&gt;in(0);
<span class="line-removed">3844       } else if (old-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">3845         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3846         old = old-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed">3847       } else if (old-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">3848         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3849         old = old-&gt;in(ShenandoahBarrierNode::Memory);</span>
3850       } else {
3851         ShouldNotReachHere();
3852       }
3853     }
3854     assert(prev != NULL, &quot;&quot;);
3855     if (new_ctrl != ctrl) {
3856       _memory_nodes.map(ctrl-&gt;_idx, mem);
3857       _memory_nodes.map(new_ctrl-&gt;_idx, mem_for_ctrl);
3858     }
<span class="line-modified">3859     uint input = prev-&gt;Opcode() == Op_ShenandoahWriteBarrier ? (uint)ShenandoahBarrierNode::Memory : (uint)MemNode::Memory;</span>
3860     _phase-&gt;igvn().replace_input_of(prev, input, new_mem);
3861   } else {
3862     uses.clear();
3863     _memory_nodes.map(new_ctrl-&gt;_idx, new_mem);
3864     uses.push(new_ctrl);
3865     for(uint next = 0; next &lt; uses.size(); next++ ) {
3866       Node *n = uses.at(next);
3867       assert(n-&gt;is_CFG(), &quot;&quot;);
3868       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
3869       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3870         Node* u = n-&gt;fast_out(i);
3871         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
3872           Node* m = _memory_nodes[u-&gt;_idx];
3873           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
3874               !has_mem_phi(u) &amp;&amp;
3875               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
3876             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
3877             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
3878 
3879             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
3880               bool push = true;
3881               bool create_phi = true;
3882               if (_phase-&gt;is_dominator(new_ctrl, u)) {
3883                 create_phi = false;
3884               } else if (!_phase-&gt;C-&gt;has_irreducible_loop()) {
3885                 IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);
3886                 bool do_check = true;
3887                 IdealLoopTree* l = loop;
3888                 create_phi = false;
3889                 while (l != _phase-&gt;ltree_root()) {
<span class="line-modified">3890                   if (_phase-&gt;is_dominator(l-&gt;_head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), l-&gt;_head)) {</span>




3891                     create_phi = true;
3892                     do_check = false;
3893                     break;
3894                   }
3895                   l = l-&gt;_parent;
3896                 }
3897 
3898                 if (do_check) {
3899                   assert(!create_phi, &quot;&quot;);
3900                   IdealLoopTree* u_loop = _phase-&gt;get_loop(u);
3901                   if (u_loop != _phase-&gt;ltree_root() &amp;&amp; u_loop-&gt;is_member(loop)) {
3902                     Node* c = ctrl;
3903                     while (!_phase-&gt;is_dominator(c, u_loop-&gt;tail())) {
3904                       c = _phase-&gt;idom(c);
3905                     }
3906                     if (!_phase-&gt;is_dominator(c, u)) {
3907                       do_check = false;
3908                     }
3909                   }
3910                 }
3911 
3912                 if (do_check &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), new_ctrl)) {
3913                   create_phi = true;
3914                 }
3915               }
3916               if (create_phi) {
3917                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
3918                 _phase-&gt;register_new_node(phi, u);
3919                 phis.push(phi);
3920                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
3921                 if (!mem_is_valid(m, u)) {
3922                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
3923                   _memory_nodes.map(u-&gt;_idx, phi);
3924                 } else {
3925                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
3926                   for (;;) {
<span class="line-modified">3927                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier || m-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
3928                     Node* next = NULL;
3929                     if (m-&gt;is_Proj()) {
3930                       next = m-&gt;in(0);
<span class="line-modified">3931                     } else if (m-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-modified">3932                       next = m-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed">3933                     } else if (m-&gt;is_Mem() || m-&gt;is_LoadStore()) {</span>
3934                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3935                       next = m-&gt;in(MemNode::Memory);
<span class="line-removed">3936                     } else {</span>
<span class="line-removed">3937                       assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3938                       assert (m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="line-removed">3939                       next = m-&gt;in(ShenandoahBarrierNode::Memory);</span>
3940                     }
3941                     if (_phase-&gt;get_ctrl(next) != u) {
3942                       break;
3943                     }
3944                     if (next-&gt;is_MergeMem()) {
3945                       assert(_phase-&gt;get_ctrl(next-&gt;as_MergeMem()-&gt;memory_at(_alias)) != u, &quot;&quot;);
3946                       break;
3947                     }
3948                     if (next-&gt;is_Phi()) {
3949                       assert(next-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; next-&gt;in(0) == u, &quot;&quot;);
3950                       break;
3951                     }
3952                     m = next;
3953                   }
3954 
3955                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting to phi&quot;); m-&gt;dump(); });
<span class="line-modified">3956                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="line-modified">3957                   uint input = (m-&gt;is_Mem() || m-&gt;is_LoadStore()) ? (uint)MemNode::Memory : (uint)ShenandoahBarrierNode::Memory;</span>
3958                   _phase-&gt;igvn().replace_input_of(m, input, phi);
3959                   push = false;
3960                 }
3961               } else {
3962                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ skipping region&quot;); u-&gt;dump(); });
3963               }
3964               if (push) {
3965                 uses.push(u);
3966               }
3967             }
3968           } else if (!mem_is_valid(m, u) &amp;&amp;
3969                      !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1)) {
3970             uses.push(u);
3971           }
3972         }
3973       }
3974     }
3975     for (int i = 0; i &lt; phis.length(); i++) {
3976       Node* n = phis.at(i);
3977       Node* r = n-&gt;in(0);
3978       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi&quot;); n-&gt;dump(); });
3979       for (uint j = 1; j &lt; n-&gt;req(); j++) {
3980         Node* m = find_mem(r-&gt;in(j), NULL);
3981         _phase-&gt;igvn().replace_input_of(n, j, m);
3982         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi: %d&quot;, j); m-&gt;dump(); });
3983       }
3984     }
3985   }
3986   uint last = _phase-&gt;C-&gt;unique();
3987   MergeMemNode* mm = NULL;
3988   int alias = _alias;
3989   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ raw mem is&quot;); mem-&gt;dump(); });














3990   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
3991     Node* u = mem-&gt;out(i);
3992     if (u-&gt;_idx &lt; last) {
3993       if (u-&gt;is_Mem()) {
3994         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
3995           Node* m = find_mem(_phase-&gt;get_ctrl(u), u);
3996           if (m != mem) {
3997             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
3998             _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);
3999             --i;
4000           }
4001         }
4002       } else if (u-&gt;is_MergeMem()) {
4003         MergeMemNode* u_mm = u-&gt;as_MergeMem();
4004         if (u_mm-&gt;memory_at(alias) == mem) {
4005           MergeMemNode* newmm = NULL;
4006           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4007             Node* uu = u-&gt;fast_out(j);
4008             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
4009             if (uu-&gt;is_Phi()) {
</pre>
<hr />
<pre>
4163   if (phi-&gt;adr_type() == TypePtr::BOTTOM) {
4164     Node* region = phi-&gt;in(0);
4165     for (DUIterator_Fast jmax, j = region-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4166       Node* uu = region-&gt;fast_out(j);
4167       if (uu-&gt;is_Phi() &amp;&amp; uu != phi &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY &amp;&amp; _phase-&gt;C-&gt;get_alias_index(uu-&gt;adr_type()) == _alias) {
4168         return false;
4169       }
4170     }
4171     return true;
4172   }
4173   return _phase-&gt;C-&gt;get_alias_index(phi-&gt;adr_type()) == _alias;
4174 }
4175 
4176 void MemoryGraphFixer::fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const {
4177   uint last = _phase-&gt; C-&gt;unique();
4178   MergeMemNode* mm = NULL;
4179   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
4180   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
4181     Node* u = mem-&gt;out(i);
4182     if (u != replacement &amp;&amp; u-&gt;_idx &lt; last) {
<span class="line-modified">4183       if (u-&gt;is_ShenandoahBarrier() &amp;&amp; _alias != Compile::AliasIdxRaw) {</span>
<span class="line-removed">4184         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="line-removed">4185           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="line-removed">4186           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="line-removed">4187           --i;</span>
<span class="line-removed">4188         }</span>
<span class="line-removed">4189       } else if (u-&gt;is_Mem()) {</span>
<span class="line-removed">4190         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="line-removed">4191           assert(_alias == Compile::AliasIdxRaw , &quot;only raw memory can lead to a memory operation&quot;);</span>
<span class="line-removed">4192           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="line-removed">4193           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="line-removed">4194           --i;</span>
<span class="line-removed">4195         }</span>
<span class="line-removed">4196       } else if (u-&gt;is_MergeMem()) {</span>
4197         MergeMemNode* u_mm = u-&gt;as_MergeMem();
4198         if (u_mm-&gt;memory_at(_alias) == mem) {
4199           MergeMemNode* newmm = NULL;
4200           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4201             Node* uu = u-&gt;fast_out(j);
4202             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
4203             if (uu-&gt;is_Phi()) {
4204               if (should_process_phi(uu)) {
4205                 Node* region = uu-&gt;in(0);
4206                 int nb = 0;
4207                 for (uint k = 1; k &lt; uu-&gt;req(); k++) {
4208                   if (uu-&gt;in(k) == u &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(k))) {
4209                     if (newmm == NULL) {
4210                       newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
4211                     }
4212                     if (newmm != u) {
4213                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
4214                       nb++;
4215                       --jmax;
4216                     }
4217                   }
4218                 }
4219                 if (nb &gt; 0) {
4220                   --j;
4221                 }
4222               }
4223             } else {
<span class="line-modified">4224               if (rep_ctrl != uu &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {</span>
4225                 if (newmm == NULL) {
4226                   newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
4227                 }
4228                 if (newmm != u) {
4229                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
4230                   --j, --jmax;
4231                 }
4232               }
4233             }
4234           }
4235         }
4236       } else if (u-&gt;is_Phi()) {
4237         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
4238         Node* region = u-&gt;in(0);
4239         if (should_process_phi(u)) {
4240           bool replaced = false;
4241           for (uint j = 1; j &lt; u-&gt;req(); j++) {
4242             if (u-&gt;in(j) == mem &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {
4243               Node* nnew = rep_proj;
4244               if (u-&gt;adr_type() == TypePtr::BOTTOM) {
4245                 if (mm == NULL) {
4246                   mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
4247                 }
4248                 nnew = mm;
4249               }
4250               _phase-&gt;igvn().replace_input_of(u, j, nnew);
4251               replaced = true;
4252             }
4253           }
4254           if (replaced) {
4255             --i;
4256           }
4257 
4258         }
4259       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
4260                  u-&gt;adr_type() == NULL) {
4261         assert(u-&gt;adr_type() != NULL ||
4262                u-&gt;Opcode() == Op_Rethrow ||
4263                u-&gt;Opcode() == Op_Return ||
4264                u-&gt;Opcode() == Op_SafePoint ||


4265                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
4266                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
<span class="line-modified">4267                u-&gt;Opcode() == Op_CallLeaf, &quot;&quot;);</span>
<span class="line-modified">4268         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
4269           if (mm == NULL) {
4270             mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
4271           }
4272           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
4273           --i;
4274         }
4275       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
<span class="line-modified">4276         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
4277           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);
4278           --i;
4279         }
4280       }
4281     }
4282   }
4283 }
4284 
<span class="line-modified">4285 void MemoryGraphFixer::remove(Node* n) {</span>
<span class="line-modified">4286   assert(n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
<span class="line-modified">4287   Node* c = _phase-&gt;get_ctrl(n);</span>
<span class="line-modified">4288   Node* mem = find_mem(c, NULL);</span>
<span class="line-modified">4289   if (mem == n) {</span>
<span class="line-modified">4290     _memory_nodes.map(c-&gt;_idx, mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(ShenandoahBarrierNode::Memory));</span>




























































































































































































































































































































4291   }

4292 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  28 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<span class="line-modified">  30 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
  31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/block.hpp&quot;
  37 #include &quot;opto/callnode.hpp&quot;
  38 #include &quot;opto/castnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/phaseX.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/runtime.hpp&quot;
  43 #include &quot;opto/subnode.hpp&quot;
  44 
<span class="line-modified">  45 bool ShenandoahBarrierC2Support::expand(Compile* C, PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified">  46   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();</span>
<span class="line-modified">  47   if ((state-&gt;enqueue_barriers_count() +</span>
<span class="line-modified">  48        state-&gt;load_reference_barriers_count()) &gt; 0) {</span>
<span class="line-modified">  49     bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;</span>
<span class="line-modified">  50     C-&gt;clear_major_progress();</span>
<span class="line-modified">  51     PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);</span>
<span class="line-modified">  52     if (C-&gt;failing()) return false;</span>
<span class="line-modified">  53     PhaseIdealLoop::verify(igvn);</span>
<span class="line-modified">  54     DEBUG_ONLY(verify_raw_mem(C-&gt;root());)</span>
<span class="line-modified">  55     if (attempt_more_loopopts) {</span>
<span class="line-modified">  56       C-&gt;set_major_progress();</span>
<span class="line-modified">  57       if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {</span>












































































































































































  58         return false;
  59       }












































































































































































  60       C-&gt;clear_major_progress();
<span class="line-modified">  61       if (C-&gt;range_check_cast_count() &gt; 0) {</span>
<span class="line-modified">  62         // No more loop optimizations. Remove all range check dependent CastIINodes.</span>
<span class="line-modified">  63         C-&gt;remove_range_check_casts(igvn);</span>
<span class="line-modified">  64         igvn.optimize();</span>






  65       }
  66     }
  67   }
  68   return true;
  69 }
  70 
<span class="line-modified">  71 bool ShenandoahBarrierC2Support::is_heap_state_test(Node* iff, int mask) {</span>
  72   if (!UseShenandoahGC) {
  73     return false;
  74   }
  75   assert(iff-&gt;is_If(), &quot;bad input&quot;);
  76   if (iff-&gt;Opcode() != Op_If) {
  77     return false;
  78   }
  79   Node* bol = iff-&gt;in(1);
  80   if (!bol-&gt;is_Bool() || bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne) {
  81     return false;
  82   }
  83   Node* cmp = bol-&gt;in(1);
  84   if (cmp-&gt;Opcode() != Op_CmpI) {
  85     return false;
  86   }
  87   Node* in1 = cmp-&gt;in(1);
  88   Node* in2 = cmp-&gt;in(2);
  89   if (in2-&gt;find_int_con(-1) != 0) {
  90     return false;
  91   }
  92   if (in1-&gt;Opcode() != Op_AndI) {
  93     return false;
  94   }
  95   in2 = in1-&gt;in(2);
  96   if (in2-&gt;find_int_con(-1) != mask) {
  97     return false;
  98   }
  99   in1 = in1-&gt;in(1);
 100 
 101   return is_gc_state_load(in1);
 102 }
 103 
<span class="line-modified"> 104 bool ShenandoahBarrierC2Support::is_heap_stable_test(Node* iff) {</span>
 105   return is_heap_state_test(iff, ShenandoahHeap::HAS_FORWARDED);
 106 }
 107 
<span class="line-modified"> 108 bool ShenandoahBarrierC2Support::is_gc_state_load(Node *n) {</span>
 109   if (!UseShenandoahGC) {
 110     return false;
 111   }
 112   if (n-&gt;Opcode() != Op_LoadB &amp;&amp; n-&gt;Opcode() != Op_LoadUB) {
 113     return false;
 114   }
 115   Node* addp = n-&gt;in(MemNode::Address);
 116   if (!addp-&gt;is_AddP()) {
 117     return false;
 118   }
 119   Node* base = addp-&gt;in(AddPNode::Address);
 120   Node* off = addp-&gt;in(AddPNode::Offset);
 121   if (base-&gt;Opcode() != Op_ThreadLocal) {
 122     return false;
 123   }
 124   if (off-&gt;find_intptr_t_con(-1) != in_bytes(ShenandoahThreadLocalData::gc_state_offset())) {
 125     return false;
 126   }
 127   return true;
 128 }
 129 
<span class="line-modified"> 130 bool ShenandoahBarrierC2Support::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {</span>
 131   assert(phase-&gt;is_dominator(stop, start), &quot;bad inputs&quot;);
 132   ResourceMark rm;
 133   Unique_Node_List wq;
 134   wq.push(start);
 135   for (uint next = 0; next &lt; wq.size(); next++) {
 136     Node *m = wq.at(next);
 137     if (m == stop) {
 138       continue;
 139     }
 140     if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
 141       return true;
 142     }
 143     if (m-&gt;is_Region()) {
 144       for (uint i = 1; i &lt; m-&gt;req(); i++) {
 145         wq.push(m-&gt;in(i));
 146       }
 147     } else {
 148       wq.push(m-&gt;in(0));
 149     }
 150   }
 151   return false;
 152 }
 153 
<span class="line-modified"> 154 bool ShenandoahBarrierC2Support::try_common_gc_state_load(Node *n, PhaseIdealLoop *phase) {</span>
 155   assert(is_gc_state_load(n), &quot;inconsistent&quot;);
 156   Node* addp = n-&gt;in(MemNode::Address);
 157   Node* dominator = NULL;
 158   for (DUIterator_Fast imax, i = addp-&gt;fast_outs(imax); i &lt; imax; i++) {
 159     Node* u = addp-&gt;fast_out(i);
 160     assert(is_gc_state_load(u), &quot;inconsistent&quot;);
 161     if (u != n &amp;&amp; phase-&gt;is_dominator(u-&gt;in(0), n-&gt;in(0))) {
 162       if (dominator == NULL) {
 163         dominator = u;
 164       } else {
 165         if (phase-&gt;dom_depth(u-&gt;in(0)) &lt; phase-&gt;dom_depth(dominator-&gt;in(0))) {
 166           dominator = u;
 167         }
 168       }
 169     }
 170   }
 171   if (dominator == NULL || has_safepoint_between(n-&gt;in(0), dominator-&gt;in(0), phase)) {
 172     return false;
 173   }
 174   phase-&gt;igvn().replace_node(n, dominator);
 175 
 176   return true;
 177 }
 178 

























































































































































































 179 #ifdef ASSERT
<span class="line-modified"> 180 bool ShenandoahBarrierC2Support::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {</span>
 181   assert(phis.size() == 0, &quot;&quot;);
 182 
 183   while (true) {
 184     if (in-&gt;bottom_type() == TypePtr::NULL_PTR) {
 185       if (trace) {tty-&gt;print_cr(&quot;NULL&quot;);}
 186     } else if (!in-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 187       if (trace) {tty-&gt;print_cr(&quot;Non oop&quot;);}




 188     } else {
 189       if (in-&gt;is_ConstraintCast()) {
 190         in = in-&gt;in(1);
 191         continue;
 192       } else if (in-&gt;is_AddP()) {
 193         assert(!in-&gt;in(AddPNode::Address)-&gt;is_top(), &quot;no raw memory access&quot;);
 194         in = in-&gt;in(AddPNode::Address);
 195         continue;
 196       } else if (in-&gt;is_Con()) {
<span class="line-modified"> 197         if (trace) {</span>
<span class="line-modified"> 198           tty-&gt;print(&quot;Found constant&quot;);</span>
<span class="line-added"> 199           in-&gt;dump();</span>
<span class="line-added"> 200         }</span>
<span class="line-added"> 201       } else if (in-&gt;Opcode() == Op_Parm) {</span>
<span class="line-added"> 202         if (trace) {</span>
<span class="line-added"> 203           tty-&gt;print(&quot;Found argument&quot;);</span>
<span class="line-added"> 204         }</span>
<span class="line-added"> 205       } else if (in-&gt;Opcode() == Op_CreateEx) {</span>
<span class="line-added"> 206         if (trace) {</span>
<span class="line-added"> 207           tty-&gt;print(&quot;Found create-exception&quot;);</span>
<span class="line-added"> 208         }</span>
<span class="line-added"> 209       } else if (in-&gt;Opcode() == Op_LoadP &amp;&amp; in-&gt;adr_type() == TypeRawPtr::BOTTOM) {</span>
<span class="line-added"> 210         if (trace) {</span>
<span class="line-added"> 211           tty-&gt;print(&quot;Found raw LoadP (OSR argument?)&quot;);</span>
<span class="line-added"> 212         }</span>
<span class="line-added"> 213       } else if (in-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
 214         if (t == ShenandoahOopStore) {



 215           uint i = 0;
 216           for (; i &lt; phis.size(); i++) {
 217             Node* n = phis.node_at(i);
 218             if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 219               break;
 220             }
 221           }
 222           if (i == phis.size()) {
 223             return false;
 224           }


 225         }
 226         barriers_used.push(in);
 227         if (trace) {tty-&gt;print(&quot;Found barrier&quot;); in-&gt;dump();}
 228       } else if (in-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 229         if (t != ShenandoahOopStore) {
 230           in = in-&gt;in(1);
 231           continue;
 232         }
 233         if (trace) {tty-&gt;print(&quot;Found enqueue barrier&quot;); in-&gt;dump();}
 234         phis.push(in, in-&gt;req());
 235         in = in-&gt;in(1);
 236         continue;
 237       } else if (in-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;is_Allocate()) {
<span class="line-modified"> 238         if (trace) {</span>
<span class="line-added"> 239           tty-&gt;print(&quot;Found alloc&quot;);</span>
<span class="line-added"> 240           in-&gt;in(0)-&gt;dump();</span>
<span class="line-added"> 241         }</span>
<span class="line-added"> 242       } else if (in-&gt;is_Proj() &amp;&amp; (in-&gt;in(0)-&gt;Opcode() == Op_CallStaticJava || in-&gt;in(0)-&gt;Opcode() == Op_CallDynamicJava)) {</span>
<span class="line-added"> 243         if (trace) {</span>
<span class="line-added"> 244           tty-&gt;print(&quot;Found Java call&quot;);</span>
<span class="line-added"> 245         }</span>
 246       } else if (in-&gt;is_Phi()) {
 247         if (!visited.test_set(in-&gt;_idx)) {
 248           if (trace) {tty-&gt;print(&quot;Pushed phi:&quot;); in-&gt;dump();}
 249           phis.push(in, 2);
 250           in = in-&gt;in(1);
 251           continue;
 252         }
 253         if (trace) {tty-&gt;print(&quot;Already seen phi:&quot;); in-&gt;dump();}
 254       } else if (in-&gt;Opcode() == Op_CMoveP || in-&gt;Opcode() == Op_CMoveN) {
 255         if (!visited.test_set(in-&gt;_idx)) {
 256           if (trace) {tty-&gt;print(&quot;Pushed cmovep:&quot;); in-&gt;dump();}
 257           phis.push(in, CMoveNode::IfTrue);
 258           in = in-&gt;in(CMoveNode::IfFalse);
 259           continue;
 260         }
 261         if (trace) {tty-&gt;print(&quot;Already seen cmovep:&quot;); in-&gt;dump();}
 262       } else if (in-&gt;Opcode() == Op_EncodeP || in-&gt;Opcode() == Op_DecodeN) {
 263         in = in-&gt;in(1);
 264         continue;
 265       } else {
</pre>
<hr />
<pre>
 271       uint idx = phis.index();
 272       Node* phi = phis.node();
 273       if (idx &gt;= phi-&gt;req()) {
 274         if (trace) {tty-&gt;print(&quot;Popped phi:&quot;); phi-&gt;dump();}
 275         phis.pop();
 276         continue;
 277       }
 278       if (trace) {tty-&gt;print(&quot;Next entry(%d) for phi:&quot;, idx); phi-&gt;dump();}
 279       in = phi-&gt;in(idx);
 280       phis.set_index(idx+1);
 281       cont = true;
 282       break;
 283     }
 284     if (!cont) {
 285       break;
 286     }
 287   }
 288   return true;
 289 }
 290 
<span class="line-modified"> 291 void ShenandoahBarrierC2Support::report_verify_failure(const char* msg, Node* n1, Node* n2) {</span>
 292   if (n1 != NULL) {
 293     n1-&gt;dump(+10);
 294   }
 295   if (n2 != NULL) {
 296     n2-&gt;dump(+10);
 297   }
 298   fatal(&quot;%s&quot;, msg);
 299 }
 300 
<span class="line-modified"> 301 void ShenandoahBarrierC2Support::verify(RootNode* root) {</span>
 302   ResourceMark rm;
 303   Unique_Node_List wq;
 304   GrowableArray&lt;Node*&gt; barriers;
 305   Unique_Node_List barriers_used;
 306   Node_Stack phis(0);
 307   VectorSet visited(Thread::current()-&gt;resource_area());
 308   const bool trace = false;
 309   const bool verify_no_useless_barrier = false;
 310 
 311   wq.push(root);
 312   for (uint next = 0; next &lt; wq.size(); next++) {
 313     Node *n = wq.at(next);
 314     if (n-&gt;is_Load()) {
 315       const bool trace = false;
 316       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 317       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 318         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 319       } else {
 320         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 321 
 322         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 323           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 324         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 325                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 326                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {
 327           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
<span class="line-modified"> 328         } else if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="line-modified"> 329           report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);</span>


























 330         }
 331       }
 332     } else if (n-&gt;is_Store()) {
 333       const bool trace = false;
 334 
 335       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 336       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 337         Node* adr = n-&gt;in(MemNode::Address);
 338         bool verify = true;
 339 
 340         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 341           adr = adr-&gt;in(AddPNode::Address);
 342           if (adr-&gt;is_AddP()) {
 343             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 344             adr = adr-&gt;in(AddPNode::Address);
 345             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 346                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
 347                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_ThreadLocal &amp;&amp;
 348                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Offset)-&gt;find_intptr_t_con(-1) == in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset())) {
 349               if (trace) {tty-&gt;print_cr(&quot;SATB prebarrier&quot;);}
 350               verify = false;
 351             }
 352           }
 353         }
 354 
<span class="line-modified"> 355         if (verify &amp;&amp; !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 356           report_verify_failure(&quot;Shenandoah verification: Store should have barriers&quot;, n);
 357         }
 358       }
<span class="line-modified"> 359       if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 360         report_verify_failure(&quot;Shenandoah verification: Store (address) should have barriers&quot;, n);
 361       }
 362     } else if (n-&gt;Opcode() == Op_CmpP) {
 363       const bool trace = false;
 364 
 365       Node* in1 = n-&gt;in(1);
 366       Node* in2 = n-&gt;in(2);
 367       if (in1-&gt;bottom_type()-&gt;isa_oopptr()) {
 368         if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 369 
 370         bool mark_inputs = false;
 371         if (in1-&gt;bottom_type() == TypePtr::NULL_PTR || in2-&gt;bottom_type() == TypePtr::NULL_PTR ||
 372             (in1-&gt;is_Con() || in2-&gt;is_Con())) {
 373           if (trace) {tty-&gt;print_cr(&quot;Comparison against a constant&quot;);}
 374           mark_inputs = true;
 375         } else if ((in1-&gt;is_CheckCastPP() &amp;&amp; in1-&gt;in(1)-&gt;is_Proj() &amp;&amp; in1-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) ||
 376                    (in2-&gt;is_CheckCastPP() &amp;&amp; in2-&gt;in(1)-&gt;is_Proj() &amp;&amp; in2-&gt;in(1)-&gt;in(0)-&gt;is_Allocate())) {
 377           if (trace) {tty-&gt;print_cr(&quot;Comparison with newly alloc&#39;ed object&quot;);}
 378           mark_inputs = true;
 379         } else {
 380           assert(in2-&gt;bottom_type()-&gt;isa_oopptr(), &quot;&quot;);
 381 
<span class="line-modified"> 382           if (!verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||</span>
<span class="line-modified"> 383               !verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 384             report_verify_failure(&quot;Shenandoah verification: Cmp should have barriers&quot;, n);
 385           }
 386         }
 387         if (verify_no_useless_barrier &amp;&amp;
 388             mark_inputs &amp;&amp;
<span class="line-modified"> 389             (!verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||</span>
<span class="line-modified"> 390              !verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {</span>
 391           phis.clear();
<span class="line-modified"> 392           visited.reset();</span>
 393         }
 394       }
 395     } else if (n-&gt;is_LoadStore()) {
 396       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
<span class="line-modified"> 397           !verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 398         report_verify_failure(&quot;Shenandoah verification: LoadStore (value) should have barriers&quot;, n);
 399       }
 400 
<span class="line-modified"> 401       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 402         report_verify_failure(&quot;Shenandoah verification: LoadStore (address) should have barriers&quot;, n);
 403       }
 404     } else if (n-&gt;Opcode() == Op_CallLeafNoFP || n-&gt;Opcode() == Op_CallLeaf) {
 405       CallNode* call = n-&gt;as_Call();
 406 
 407       static struct {
 408         const char* name;
 409         struct {
 410           int pos;
 411           verify_type t;
 412         } args[6];
 413       } calls[] = {
 414         &quot;aescrypt_encryptBlock&quot;,
 415         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 416           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 417         &quot;aescrypt_decryptBlock&quot;,
 418         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 419           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 420         &quot;multiplyToLen&quot;,
 421         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { TypeFunc::Parms+4, ShenandoahStore },
</pre>
<hr />
<pre>
 477         &quot;sha512_implCompressMB&quot;,
 478         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
 479           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 480         &quot;encodeBlock&quot;,
 481         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
 482           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 483       };
 484 
 485       if (call-&gt;is_call_to_arraycopystub()) {
 486         Node* dest = NULL;
 487         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain();
 488         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 489           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 490             j++;
 491             if (j == 2) {
 492               dest = n-&gt;in(i);
 493               break;
 494             }
 495           }
 496         }
<span class="line-modified"> 497         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||</span>
<span class="line-modified"> 498             !verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 499           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
 500         }
 501       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
 502                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
<span class="line-modified"> 503         if (!verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 504           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
 505         }
 506       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
 507         // skip
 508       } else {
 509         const int calls_len = sizeof(calls) / sizeof(calls[0]);
 510         int i = 0;
 511         for (; i &lt; calls_len; i++) {
 512           if (!strcmp(calls[i].name, call-&gt;_name)) {
 513             break;
 514           }
 515         }
 516         if (i != calls_len) {
 517           const uint args_len = sizeof(calls[0].args) / sizeof(calls[0].args[0]);
 518           for (uint j = 0; j &lt; args_len; j++) {
 519             int pos = calls[i].args[j].pos;
 520             if (pos == -1) {
 521               break;
 522             }
<span class="line-modified"> 523             if (!verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {</span>
 524               report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 525             }
 526           }
 527           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
 528             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 529                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
 530               uint k = 0;
 531               for (; k &lt; args_len &amp;&amp; calls[i].args[k].pos != (int)j; k++);
 532               if (k == args_len) {
 533                 fatal(&quot;arg %d for call %s not covered&quot;, j, call-&gt;_name);
 534               }
 535             }
 536           }
 537         } else {
 538           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
 539             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 540                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
 541               fatal(&quot;%s not covered&quot;, call-&gt;_name);
 542             }
 543           }
 544         }
 545       }
<span class="line-modified"> 546     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier || n-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>





 547       // skip


 548     } else if (n-&gt;is_AddP()
 549                || n-&gt;is_Phi()
 550                || n-&gt;is_ConstraintCast()
 551                || n-&gt;Opcode() == Op_Return
 552                || n-&gt;Opcode() == Op_CMoveP
 553                || n-&gt;Opcode() == Op_CMoveN
 554                || n-&gt;Opcode() == Op_Rethrow
 555                || n-&gt;is_MemBar()
 556                || n-&gt;Opcode() == Op_Conv2B
 557                || n-&gt;Opcode() == Op_SafePoint
 558                || n-&gt;is_CallJava()
 559                || n-&gt;Opcode() == Op_Unlock
 560                || n-&gt;Opcode() == Op_EncodeP
 561                || n-&gt;Opcode() == Op_DecodeN) {
 562       // nothing to do
 563     } else {
 564       static struct {
 565         int opcode;
 566         struct {
 567           int pos;
</pre>
<hr />
<pre>
 594         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
 595         Op_StrIndexOfChar,
 596         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
 597       };
 598 
 599       const int others_len = sizeof(others) / sizeof(others[0]);
 600       int i = 0;
 601       for (; i &lt; others_len; i++) {
 602         if (others[i].opcode == n-&gt;Opcode()) {
 603           break;
 604         }
 605       }
 606       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain()-&gt;cnt() : n-&gt;req();
 607       if (i != others_len) {
 608         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
 609         for (uint j = 0; j &lt; inputs_len; j++) {
 610           int pos = others[i].inputs[j].pos;
 611           if (pos == -1) {
 612             break;
 613           }
<span class="line-modified"> 614           if (!verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {</span>
 615             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
 616           }
 617         }
 618         for (uint j = 1; j &lt; stop; j++) {
 619           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 620               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 621             uint k = 0;
 622             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
 623             if (k == inputs_len) {
 624               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
 625             }
 626           }
 627         }
 628       } else {
 629         for (uint j = 1; j &lt; stop; j++) {
 630           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
 631               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 632             fatal(&quot;%s not covered&quot;, n-&gt;Name());
 633           }
 634         }
 635       }
 636     }
 637 
 638     if (n-&gt;is_SafePoint()) {
 639       SafePointNode* sfpt = n-&gt;as_SafePoint();
 640       if (verify_no_useless_barrier &amp;&amp; sfpt-&gt;jvms() != NULL) {
 641         for (uint i = sfpt-&gt;jvms()-&gt;scloff(); i &lt; sfpt-&gt;jvms()-&gt;endoff(); i++) {
<span class="line-modified"> 642           if (!verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
 643             phis.clear();
<span class="line-modified"> 644             visited.reset();</span>
 645           }
 646         }
 647       }
 648     }
<span class="line-modified"> 649   }</span>





































 650 
 651   if (verify_no_useless_barrier) {
 652     for (int i = 0; i &lt; barriers.length(); i++) {
 653       Node* n = barriers.at(i);
 654       if (!barriers_used.member(n)) {
 655         tty-&gt;print(&quot;XXX useless barrier&quot;); n-&gt;dump(-2);
 656         ShouldNotReachHere();
 657       }
 658     }
 659   }
 660 }
 661 #endif
 662 
<span class="line-modified"> 663 bool ShenandoahBarrierC2Support::is_dominator_same_ctrl(Node* c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
 664   // That both nodes have the same control is not sufficient to prove
 665   // domination, verify that there&#39;s no path from d to n
 666   ResourceMark rm;
 667   Unique_Node_List wq;
 668   wq.push(d);
 669   for (uint next = 0; next &lt; wq.size(); next++) {
 670     Node *m = wq.at(next);
 671     if (m == n) {
 672       return false;
 673     }
 674     if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0)-&gt;is_Loop()) {
 675       assert(phase-&gt;ctrl_or_self(m-&gt;in(LoopNode::EntryControl)) != c, &quot;following loop entry should lead to new control&quot;);
 676     } else {
<span class="line-added"> 677       if (m-&gt;is_Store() || m-&gt;is_LoadStore()) {</span>
<span class="line-added"> 678         // Take anti-dependencies into account</span>
<span class="line-added"> 679         Node* mem = m-&gt;in(MemNode::Memory);</span>
<span class="line-added"> 680         for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added"> 681           Node* u = mem-&gt;fast_out(i);</span>
<span class="line-added"> 682           if (u-&gt;is_Load() &amp;&amp; phase-&gt;C-&gt;can_alias(m-&gt;adr_type(), phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type())) &amp;&amp;</span>
<span class="line-added"> 683               phase-&gt;ctrl_or_self(u) == c) {</span>
<span class="line-added"> 684             wq.push(u);</span>
<span class="line-added"> 685           }</span>
<span class="line-added"> 686         }</span>
<span class="line-added"> 687       }</span>
 688       for (uint i = 0; i &lt; m-&gt;req(); i++) {
 689         if (m-&gt;in(i) != NULL &amp;&amp; phase-&gt;ctrl_or_self(m-&gt;in(i)) == c) {
 690           wq.push(m-&gt;in(i));
 691         }
 692       }
 693     }
 694   }
 695   return true;
 696 }
 697 
<span class="line-modified"> 698 bool ShenandoahBarrierC2Support::is_dominator(Node* d_c, Node* n_c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
 699   if (d_c != n_c) {
 700     return phase-&gt;is_dominator(d_c, n_c);
 701   }
 702   return is_dominator_same_ctrl(d_c, d, n, phase);
 703 }
 704 
 705 Node* next_mem(Node* mem, int alias) {
 706   Node* res = NULL;
 707   if (mem-&gt;is_Proj()) {
 708     res = mem-&gt;in(0);
 709   } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
 710     res = mem-&gt;in(TypeFunc::Memory);
 711   } else if (mem-&gt;is_Phi()) {
 712     res = mem-&gt;in(1);


 713   } else if (mem-&gt;is_MergeMem()) {
 714     res = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 715   } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
 716     assert(alias = Compile::AliasIdxRaw, &quot;following raw memory can&#39;t lead to a barrier&quot;);
 717     res = mem-&gt;in(MemNode::Memory);


 718   } else {
 719 #ifdef ASSERT
 720     mem-&gt;dump();
 721 #endif
 722     ShouldNotReachHere();
 723   }
 724   return res;
 725 }
 726 
<span class="line-modified"> 727 Node* ShenandoahBarrierC2Support::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {</span>
 728   Node* iffproj = NULL;
 729   while (c != dom) {
 730     Node* next = phase-&gt;idom(c);
 731     assert(next-&gt;unique_ctrl_out() == c || c-&gt;is_Proj() || c-&gt;is_Region(), &quot;multiple control flow out but no proj or region?&quot;);
 732     if (c-&gt;is_Region()) {
 733       ResourceMark rm;
 734       Unique_Node_List wq;
 735       wq.push(c);
 736       for (uint i = 0; i &lt; wq.size(); i++) {
 737         Node *n = wq.at(i);
 738         if (n == next) {
 739           continue;
 740         }
 741         if (n-&gt;is_Region()) {
 742           for (uint j = 1; j &lt; n-&gt;req(); j++) {
 743             wq.push(n-&gt;in(j));
 744           }
 745         } else {
 746           wq.push(n-&gt;in(0));
 747         }
</pre>
<hr />
<pre>
 772             iffproj = c;
 773           } else {
 774             return NodeSentinel;
 775           }
 776         }
 777       } else if (c-&gt;Opcode() == Op_JumpProj) {
 778         return NodeSentinel; // unsupported
 779       } else if (c-&gt;Opcode() == Op_CatchProj) {
 780         return NodeSentinel; // unsupported
 781       } else if (c-&gt;Opcode() == Op_CProj &amp;&amp; next-&gt;Opcode() == Op_NeverBranch) {
 782         return NodeSentinel; // unsupported
 783       } else {
 784         assert(next-&gt;unique_ctrl_out() == c, &quot;unsupported branch pattern&quot;);
 785       }
 786     }
 787     c = next;
 788   }
 789   return iffproj;
 790 }
 791 
<span class="line-modified"> 792 Node* ShenandoahBarrierC2Support::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {</span>







































































































































































































































































 793   ResourceMark rm;
 794   VectorSet wq(Thread::current()-&gt;resource_area());
 795   wq.set(mem-&gt;_idx);
 796   mem_ctrl = phase-&gt;ctrl_or_self(mem);
 797   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
 798     mem = next_mem(mem, alias);
 799     if (wq.test_set(mem-&gt;_idx)) {
 800       return NULL;
 801     }
 802     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 803   }
 804   if (mem-&gt;is_MergeMem()) {
 805     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
 806     mem_ctrl = phase-&gt;ctrl_or_self(mem);
 807   }
 808   return mem;
 809 }
 810 
<span class="line-modified"> 811 Node* ShenandoahBarrierC2Support::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 812   Node* mem = NULL;</span>
<span class="line-modified"> 813   Node* c = ctrl;</span>
<span class="line-modified"> 814   do {</span>
<span class="line-modified"> 815     if (c-&gt;is_Region()) {</span>
<span class="line-modified"> 816       Node* phi_bottom = NULL;</span>
<span class="line-modified"> 817       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-modified"> 818         Node* u = c-&gt;fast_out(i);</span>
<span class="line-modified"> 819         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-modified"> 820           if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-modified"> 821             mem = u;</span>
<span class="line-modified"> 822           }</span>
<span class="line-modified"> 823         }</span>
<span class="line-modified"> 824       }</span>
<span class="line-modified"> 825     } else {</span>
<span class="line-modified"> 826       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {</span>
<span class="line-modified"> 827         CallProjections projs;</span>
<span class="line-modified"> 828         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="line-modified"> 829         if (projs.fallthrough_memproj != NULL) {</span>
<span class="line-modified"> 830           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-modified"> 831             if (projs.catchall_memproj == NULL) {</span>
<span class="line-added"> 832               mem = projs.fallthrough_memproj;</span>
<span class="line-added"> 833             } else {</span>
<span class="line-added"> 834               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="line-added"> 835                 mem = projs.fallthrough_memproj;</span>
<span class="line-added"> 836               } else {</span>
<span class="line-added"> 837                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="line-added"> 838                 mem = projs.catchall_memproj;</span>
<span class="line-added"> 839               }</span>
<span class="line-added"> 840             }</span>
<span class="line-added"> 841           }</span>
<span class="line-added"> 842         } else {</span>
<span class="line-added"> 843           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);</span>
<span class="line-added"> 844           if (proj != NULL &amp;&amp;</span>
<span class="line-added"> 845               proj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added"> 846             mem = proj;</span>
<span class="line-added"> 847           }</span>
<span class="line-added"> 848         }</span>
<span class="line-added"> 849       } else {</span>
<span class="line-added"> 850         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added"> 851           Node* u = c-&gt;fast_out(i);</span>
<span class="line-added"> 852           if (u-&gt;is_Proj() &amp;&amp;</span>
<span class="line-added"> 853               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-added"> 854               u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added"> 855               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);</span>
<span class="line-added"> 856               assert(mem == NULL, &quot;only one proj&quot;);</span>
<span class="line-added"> 857               mem = u;</span>
<span class="line-added"> 858           }</span>
<span class="line-added"> 859         }</span>
<span class="line-added"> 860         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);</span>
<span class="line-added"> 861       }</span>
 862     }
<span class="line-modified"> 863     c = phase-&gt;idom(c);</span>
<span class="line-modified"> 864   } while (mem == NULL);</span>
<span class="line-modified"> 865   return mem;</span>
 866 }
 867 
<span class="line-modified"> 868 void ShenandoahBarrierC2Support::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 869   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified"> 870     Node* u = n-&gt;fast_out(i);</span>
<span class="line-modified"> 871     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {</span>
<span class="line-added"> 872       uses.push(u);</span>
 873     }
 874   }

 875 }
 876 
<span class="line-modified"> 877 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 878   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();</span>
<span class="line-modified"> 879   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));</span>
<span class="line-modified"> 880   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));</span>
<span class="line-modified"> 881   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);</span>
<span class="line-added"> 882   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));</span>
<span class="line-added"> 883   phase-&gt;lazy_replace(outer, new_outer);</span>
<span class="line-added"> 884   phase-&gt;lazy_replace(le, new_le);</span>
<span class="line-added"> 885   inner-&gt;clear_strip_mined();</span>
 886 }
 887 
<span class="line-modified"> 888 void ShenandoahBarrierC2Support::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="line-modified"> 889                                                   PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 890   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-modified"> 891   Node* thread = new ThreadLocalNode();</span>
<span class="line-modified"> 892   phase-&gt;register_new_node(thread, ctrl);</span>
<span class="line-modified"> 893   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 894   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());</span>
<span class="line-modified"> 895   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);</span>
<span class="line-modified"> 896   phase-&gt;register_new_node(gc_state_addr, ctrl);</span>
<span class="line-modified"> 897   uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="line-modified"> 898   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="line-modified"> 899   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>








 900 
<span class="line-modified"> 901   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);</span>
<span class="line-added"> 902   phase-&gt;register_new_node(gc_state, ctrl);</span>
<span class="line-added"> 903   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
<span class="line-added"> 904   phase-&gt;register_new_node(heap_stable_and, ctrl);</span>
<span class="line-added"> 905   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));</span>
<span class="line-added"> 906   phase-&gt;register_new_node(heap_stable_cmp, ctrl);</span>
<span class="line-added"> 907   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);</span>
<span class="line-added"> 908   phase-&gt;register_new_node(heap_stable_test, ctrl);</span>
<span class="line-added"> 909   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-added"> 910   phase-&gt;register_control(heap_stable_iff, loop, ctrl);</span>
 911 
<span class="line-modified"> 912   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);</span>
<span class="line-modified"> 913   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);</span>
<span class="line-added"> 914   ctrl = new IfTrueNode(heap_stable_iff);</span>
<span class="line-added"> 915   phase-&gt;register_control(ctrl, loop, heap_stable_iff);</span>
 916 
<span class="line-modified"> 917   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>

 918 }
 919 
<span class="line-modified"> 920 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 921   const Type* val_t = phase-&gt;igvn().type(val);</span>
<span class="line-modified"> 922   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {</span>
<span class="line-modified"> 923     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-modified"> 924     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));</span>
<span class="line-modified"> 925     phase-&gt;register_new_node(null_cmp, ctrl);</span>
<span class="line-modified"> 926     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);</span>
<span class="line-modified"> 927     phase-&gt;register_new_node(null_test, ctrl);</span>
<span class="line-modified"> 928     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-modified"> 929     phase-&gt;register_control(null_iff, loop, ctrl);</span>
<span class="line-modified"> 930     ctrl = new IfTrueNode(null_iff);</span>
<span class="line-modified"> 931     phase-&gt;register_control(ctrl, loop, null_iff);</span>
<span class="line-modified"> 932     null_ctrl = new IfFalseNode(null_iff);</span>
<span class="line-modified"> 933     phase-&gt;register_control(null_ctrl, loop, null_iff);</span>




 934   }

 935 }
 936 
<span class="line-modified"> 937 Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified"> 938   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="line-modified"> 939   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="line-modified"> 940   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="line-modified"> 941   Node* new_iff = iff-&gt;clone();</span>
<span class="line-modified"> 942   new_iff-&gt;set_req(0, c);</span>
<span class="line-modified"> 943   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="line-modified"> 944   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="line-modified"> 945   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="line-modified"> 946   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="line-modified"> 947   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="line-modified"> 948   c = iftrue;</span>
<span class="line-modified"> 949   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="line-modified"> 950   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="line-modified"> 951   Node* uncasted_val = val-&gt;in(1);</span>
<span class="line-modified"> 952   val = new CastPPNode(uncasted_val, t);</span>
<span class="line-modified"> 953   val-&gt;init_req(0, c);</span>
<span class="line-modified"> 954   phase-&gt;register_new_node(val, c);</span>
<span class="line-modified"> 955   return val;</span>
<span class="line-modified"> 956 }</span>

 957 
<span class="line-modified"> 958 void ShenandoahBarrierC2Support::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>

































































































































































































































































































































































































































































































































































































































































































 959                                                 Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
 960   IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();
 961   Node* proj = iff-&gt;proj_out(0);
 962   assert(proj != unc_ctrl, &quot;bad projection&quot;);
 963   Node* use = proj-&gt;unique_ctrl_out();
 964 
 965   assert(use == unc || use-&gt;is_Region(), &quot;what else?&quot;);
 966 
 967   uses.clear();
 968   if (use == unc) {
 969     phase-&gt;set_idom(use, new_unc_ctrl, phase-&gt;dom_depth(use));
 970     for (uint i = 1; i &lt; unc-&gt;req(); i++) {
 971       Node* n = unc-&gt;in(i);
 972       if (phase-&gt;has_ctrl(n) &amp;&amp; phase-&gt;get_ctrl(n) == proj) {
 973         uses.push(n);
 974       }
 975     }
 976   } else {
 977     assert(use-&gt;is_Region(), &quot;what else?&quot;);
 978     uint idx = 1;
</pre>
<hr />
<pre>
 987   for(uint next = 0; next &lt; uses.size(); next++ ) {
 988     Node *n = uses.at(next);
 989     assert(phase-&gt;get_ctrl(n) == proj, &quot;bad control&quot;);
 990     phase-&gt;set_ctrl_and_loop(n, new_unc_ctrl);
 991     if (n-&gt;in(0) == proj) {
 992       phase-&gt;igvn().replace_input_of(n, 0, new_unc_ctrl);
 993     }
 994     for (uint i = 0; i &lt; n-&gt;req(); i++) {
 995       Node* m = n-&gt;in(i);
 996       if (m != NULL &amp;&amp; phase-&gt;has_ctrl(m) &amp;&amp; phase-&gt;get_ctrl(m) == proj) {
 997         uses.push(m);
 998       }
 999     }
1000   }
1001 
1002   phase-&gt;igvn().rehash_node_delayed(use);
1003   int nb = use-&gt;replace_edge(proj, new_unc_ctrl);
1004   assert(nb == 1, &quot;only use expected&quot;);
1005 }
1006 
<span class="line-modified">1007 void ShenandoahBarrierC2Support::in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {</span>
1008   IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1009   Node* raw_rbtrue = new CastP2XNode(ctrl, val);
1010   phase-&gt;register_new_node(raw_rbtrue, ctrl);
1011   Node* cset_offset = new URShiftXNode(raw_rbtrue, phase-&gt;igvn().intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
1012   phase-&gt;register_new_node(cset_offset, ctrl);
1013   Node* in_cset_fast_test_base_addr = phase-&gt;igvn().makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
1014   phase-&gt;set_ctrl(in_cset_fast_test_base_addr, phase-&gt;C-&gt;root());
1015   Node* in_cset_fast_test_adr = new AddPNode(phase-&gt;C-&gt;top(), in_cset_fast_test_base_addr, cset_offset);
1016   phase-&gt;register_new_node(in_cset_fast_test_adr, ctrl);
1017   uint in_cset_fast_test_idx = Compile::AliasIdxRaw;
1018   const TypePtr* in_cset_fast_test_adr_type = NULL; // debug-mode-only argument
1019   debug_only(in_cset_fast_test_adr_type = phase-&gt;C-&gt;get_adr_type(in_cset_fast_test_idx));
1020   Node* in_cset_fast_test_load = new LoadBNode(ctrl, raw_mem, in_cset_fast_test_adr, in_cset_fast_test_adr_type, TypeInt::BYTE, MemNode::unordered);
1021   phase-&gt;register_new_node(in_cset_fast_test_load, ctrl);
1022   Node* in_cset_fast_test_cmp = new CmpINode(in_cset_fast_test_load, phase-&gt;igvn().zerocon(T_INT));
1023   phase-&gt;register_new_node(in_cset_fast_test_cmp, ctrl);
1024   Node* in_cset_fast_test_test = new BoolNode(in_cset_fast_test_cmp, BoolTest::eq);
1025   phase-&gt;register_new_node(in_cset_fast_test_test, ctrl);
1026   IfNode* in_cset_fast_test_iff = new IfNode(ctrl, in_cset_fast_test_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
1027   phase-&gt;register_control(in_cset_fast_test_iff, loop, ctrl);
1028 
1029   not_cset_ctrl = new IfTrueNode(in_cset_fast_test_iff);
1030   phase-&gt;register_control(not_cset_ctrl, loop, in_cset_fast_test_iff);
1031 
1032   ctrl = new IfFalseNode(in_cset_fast_test_iff);
1033   phase-&gt;register_control(ctrl, loop, in_cset_fast_test_iff);
1034 }
1035 
<span class="line-modified">1036 void ShenandoahBarrierC2Support::call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {</span>



1037   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
<span class="line-modified">1038   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr();</span>
1039 
1040   // The slow path stub consumes and produces raw memory in addition
1041   // to the existing memory edges
1042   Node* base = find_bottom_mem(ctrl, phase);

1043   MergeMemNode* mm = MergeMemNode::make(base);

1044   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
1045   phase-&gt;register_new_node(mm, ctrl);
1046 
<span class="line-modified">1047   address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?</span>
<span class="line-added">1048           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :</span>
<span class="line-added">1049           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);</span>
<span class="line-added">1050 </span>
<span class="line-added">1051   address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)</span>
<span class="line-added">1052                                : target;</span>
<span class="line-added">1053   const char* name = is_native ? &quot;load_reference_barrier_native&quot; : &quot;load_reference_barrier&quot;;</span>
<span class="line-added">1054   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);</span>
<span class="line-added">1055 </span>
1056   call-&gt;init_req(TypeFunc::Control, ctrl);
1057   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
1058   call-&gt;init_req(TypeFunc::Memory, mm);
1059   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
1060   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
1061   call-&gt;init_req(TypeFunc::Parms, val);
<span class="line-added">1062   call-&gt;init_req(TypeFunc::Parms+1, load_addr);</span>
1063   phase-&gt;register_control(call, loop, ctrl);
1064   ctrl = new ProjNode(call, TypeFunc::Control);
1065   phase-&gt;register_control(ctrl, loop, call);
1066   result_mem = new ProjNode(call, TypeFunc::Memory);
1067   phase-&gt;register_new_node(result_mem, call);
1068   val = new ProjNode(call, TypeFunc::Parms);
1069   phase-&gt;register_new_node(val, call);
1070   val = new CheckCastPPNode(ctrl, val, obj_type);
1071   phase-&gt;register_new_node(val, ctrl);
1072 }
1073 
<span class="line-modified">1074 void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {</span>
1075   Node* ctrl = phase-&gt;get_ctrl(barrier);
1076   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
1077 
1078   // Update the control of all nodes that should be after the
1079   // barrier control flow
1080   uses.clear();
1081   // Every node that is control dependent on the barrier&#39;s input
1082   // control will be after the expanded barrier. The raw memory (if
1083   // its memory is control dependent on the barrier&#39;s input control)
1084   // must stay above the barrier.
1085   uses_to_ignore.clear();
1086   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
1087     uses_to_ignore.push(init_raw_mem);
1088   }
1089   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
1090     Node *n = uses_to_ignore.at(next);
1091     for (uint i = 0; i &lt; n-&gt;req(); i++) {
1092       Node* in = n-&gt;in(i);
1093       if (in != NULL &amp;&amp; phase-&gt;has_ctrl(in) &amp;&amp; phase-&gt;get_ctrl(in) == ctrl) {
1094         uses_to_ignore.push(in);
</pre>
<hr />
<pre>
1107       if (c != ctrl ||
1108           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
1109           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
1110         phase-&gt;igvn().rehash_node_delayed(u);
1111         int nb = u-&gt;replace_edge(ctrl, region);
1112         if (u-&gt;is_CFG()) {
1113           if (phase-&gt;idom(u) == ctrl) {
1114             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
1115           }
1116         } else if (phase-&gt;get_ctrl(u) == ctrl) {
1117           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1118           uses.push(u);
1119         }
1120         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
1121         --i, imax -= nb;
1122       }
1123     }
1124   }
1125 }
1126 
<span class="line-modified">1127 static Node* create_phis_on_call_return(Node* ctrl, Node* c, Node* n, Node* n_clone, const CallProjections&amp; projs, PhaseIdealLoop* phase) {</span>
<span class="line-modified">1128   Node* region = NULL;</span>
<span class="line-modified">1129   while (c != ctrl) {</span>
<span class="line-modified">1130     if (c-&gt;is_Region()) {</span>
<span class="line-modified">1131       region = c;</span>
<span class="line-modified">1132     }</span>
<span class="line-modified">1133     c = phase-&gt;idom(c);</span>
<span class="line-modified">1134   }</span>
<span class="line-modified">1135   assert(region != NULL, &quot;&quot;);</span>
<span class="line-modified">1136   Node* phi = new PhiNode(region, n-&gt;bottom_type());</span>
<span class="line-modified">1137   for (uint j = 1; j &lt; region-&gt;req(); j++) {</span>
<span class="line-modified">1138     Node* in = region-&gt;in(j);</span>
<span class="line-modified">1139     if (phase-&gt;is_dominator(projs.fallthrough_catchproj, in)) {</span>
<span class="line-modified">1140       phi-&gt;init_req(j, n);</span>
<span class="line-modified">1141     } else if (phase-&gt;is_dominator(projs.catchall_catchproj, in)) {</span>
<span class="line-modified">1142       phi-&gt;init_req(j, n_clone);</span>
<span class="line-added">1143     } else {</span>
<span class="line-added">1144       phi-&gt;init_req(j, create_phis_on_call_return(ctrl, in, n, n_clone, projs, phase));</span>
1145     }
1146   }
<span class="line-added">1147   phase-&gt;register_new_node(phi, region);</span>
<span class="line-added">1148   return phi;</span>
<span class="line-added">1149 }</span>
1150 
<span class="line-modified">1151 void ShenandoahBarrierC2Support::pin_and_expand(PhaseIdealLoop* phase) {</span>
<span class="line-added">1152   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();</span>
<span class="line-added">1153 </span>
<span class="line-added">1154   Unique_Node_List uses;</span>
<span class="line-added">1155   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {</span>
<span class="line-added">1156     Node* barrier = state-&gt;enqueue_barrier(i);</span>
<span class="line-added">1157     Node* ctrl = phase-&gt;get_ctrl(barrier);</span>
<span class="line-added">1158     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-added">1159     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {</span>
<span class="line-added">1160       // Expanding a barrier here will break loop strip mining</span>
<span class="line-added">1161       // verification. Transform the loop so the loop nest doesn&#39;t</span>
<span class="line-added">1162       // appear as strip mined.</span>
<span class="line-added">1163       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();</span>
<span class="line-added">1164       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);</span>
<span class="line-added">1165     }</span>
<span class="line-added">1166   }</span>
<span class="line-added">1167 </span>
<span class="line-added">1168   Node_Stack stack(0);</span>
<span class="line-added">1169   Node_List clones;</span>
<span class="line-added">1170   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="line-added">1171     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="line-added">1172     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="line-added">1173       continue;</span>
<span class="line-added">1174     }</span>
<span class="line-added">1175 </span>
<span class="line-added">1176     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
<span class="line-added">1177     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="line-added">1178 </span>
<span class="line-added">1179     CallStaticJavaNode* unc = NULL;</span>
<span class="line-added">1180     Node* unc_ctrl = NULL;</span>
<span class="line-added">1181     Node* uncasted_val = val;</span>
<span class="line-added">1182 </span>
<span class="line-added">1183     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1184       Node* u = lrb-&gt;fast_out(i);</span>
<span class="line-added">1185       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-added">1186           u-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-added">1187           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {</span>
<span class="line-added">1188         const Type* u_t = phase-&gt;igvn().type(u);</span>
<span class="line-added">1189 </span>
<span class="line-added">1190         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;</span>
<span class="line-added">1191             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-added">1192             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-added">1193             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-added">1194             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-added">1195             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-added">1196             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-added">1197             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;</span>
<span class="line-added">1198             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">1199           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-added">1200           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));</span>
<span class="line-added">1201 </span>
<span class="line-added">1202           if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="line-added">1203             continue;</span>
<span class="line-added">1204           }</span>
1205 
<span class="line-modified">1206           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);</span>
<span class="line-modified">1207           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="line-modified">1208           if (branch == NodeSentinel) {</span>
<span class="line-modified">1209             continue;</span>
<span class="line-modified">1210           }</span>
<span class="line-added">1211 </span>
<span class="line-added">1212           phase-&gt;igvn().replace_input_of(u, 1, val);</span>
<span class="line-added">1213           phase-&gt;igvn().replace_input_of(lrb, ShenandoahLoadReferenceBarrierNode::ValueIn, u);</span>
<span class="line-added">1214           phase-&gt;set_ctrl(u, u-&gt;in(0));</span>
<span class="line-added">1215           phase-&gt;set_ctrl(lrb, u-&gt;in(0));</span>
<span class="line-added">1216           unc = u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-added">1217           unc_ctrl = u-&gt;in(0);</span>
<span class="line-added">1218           val = u;</span>
<span class="line-added">1219 </span>
<span class="line-added">1220           for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added">1221             Node* u = val-&gt;fast_out(j);</span>
<span class="line-added">1222             if (u == lrb) continue;</span>
<span class="line-added">1223             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1224             int nb = u-&gt;replace_edge(val, lrb);</span>
<span class="line-added">1225             --j; jmax -= nb;</span>
<span class="line-added">1226           }</span>
1227 
<span class="line-modified">1228           RegionNode* r = new RegionNode(3);</span>
<span class="line-modified">1229           IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1230 </span>
<span class="line-added">1231           Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="line-added">1232           Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="line-added">1233           phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="line-added">1234           Node* c = unc_ctrl_clone;</span>
<span class="line-added">1235           Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="line-added">1236           r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="line-added">1237 </span>
<span class="line-added">1238           phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="line-added">1239           phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="line-added">1240           phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="line-added">1241           c = NULL;;</span>
<span class="line-added">1242           phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="line-added">1243           phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="line-added">1244 </span>
<span class="line-added">1245           IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1246           fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="line-added">1247           Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="line-added">1248           r-&gt;init_req(2, iff_proj);</span>
<span class="line-added">1249           phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="line-added">1250 </span>
<span class="line-added">1251           Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="line-added">1252           Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="line-added">1253           assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="line-added">1254           assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="line-added">1255           new_bol-&gt;set_req(1, new_cmp);</span>
<span class="line-added">1256           new_cmp-&gt;set_req(1, lrb);</span>
<span class="line-added">1257           phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="line-added">1258           phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="line-added">1259           phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="line-added">1260           phase-&gt;igvn().replace_input_of(new_cast, 1, lrb);</span>
<span class="line-added">1261 </span>
<span class="line-added">1262           for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1263             Node* u = lrb-&gt;fast_out(i);</span>
<span class="line-added">1264             if (u == new_cast || u == new_cmp) {</span>
<span class="line-added">1265               continue;</span>
<span class="line-added">1266             }</span>
<span class="line-added">1267             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1268             int nb = u-&gt;replace_edge(lrb, new_cast);</span>
<span class="line-added">1269             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-added">1270             --i; imax -= nb;</span>
<span class="line-added">1271           }</span>
1272 
<span class="line-modified">1273           for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-modified">1274             Node* u = val-&gt;fast_out(i);</span>
<span class="line-modified">1275             if (u == lrb) {</span>
<span class="line-modified">1276               continue;</span>
<span class="line-added">1277             }</span>
<span class="line-added">1278             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1279             int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="line-added">1280             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-added">1281             --i; imax -= nb;</span>
<span class="line-added">1282           }</span>
1283 
<span class="line-modified">1284           ctrl = unc_ctrl_clone;</span>
<span class="line-modified">1285           phase-&gt;set_ctrl_and_loop(lrb, ctrl);</span>
<span class="line-modified">1286           break;</span>
<span class="line-modified">1287         }</span>
<span class="line-modified">1288       }</span>


1289     }
<span class="line-added">1290     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {</span>
<span class="line-added">1291       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();</span>
<span class="line-added">1292       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {</span>
<span class="line-added">1293         // The rethrow call may have too many projections to be</span>
<span class="line-added">1294         // properly handled here. Given there&#39;s no reason for a</span>
<span class="line-added">1295         // barrier to depend on the call, move it above the call</span>
<span class="line-added">1296         stack.push(lrb, 0);</span>
<span class="line-added">1297         do {</span>
<span class="line-added">1298           Node* n = stack.node();</span>
<span class="line-added">1299           uint idx = stack.index();</span>
<span class="line-added">1300           if (idx &lt; n-&gt;req()) {</span>
<span class="line-added">1301             Node* in = n-&gt;in(idx);</span>
<span class="line-added">1302             stack.set_index(idx+1);</span>
<span class="line-added">1303             if (in != NULL) {</span>
<span class="line-added">1304               if (phase-&gt;has_ctrl(in)) {</span>
<span class="line-added">1305                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {</span>
<span class="line-added">1306 #ifdef ASSERT</span>
<span class="line-added">1307                   for (uint i = 0; i &lt; stack.size(); i++) {</span>
<span class="line-added">1308                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);</span>
<span class="line-added">1309                   }</span>
<span class="line-added">1310 #endif</span>
<span class="line-added">1311                   stack.push(in, 0);</span>
<span class="line-added">1312                 }</span>
<span class="line-added">1313               } else {</span>
<span class="line-added">1314                 assert(phase-&gt;is_dominator(in, call-&gt;in(0)), &quot;no dependency on the call&quot;);</span>
<span class="line-added">1315               }</span>
<span class="line-added">1316             }</span>
<span class="line-added">1317           } else {</span>
<span class="line-added">1318             phase-&gt;set_ctrl(n, call-&gt;in(0));</span>
<span class="line-added">1319             stack.pop();</span>
<span class="line-added">1320           }</span>
<span class="line-added">1321         } while(stack.size() &gt; 0);</span>
<span class="line-added">1322         continue;</span>
<span class="line-added">1323       }</span>
<span class="line-added">1324       CallProjections projs;</span>
<span class="line-added">1325       call-&gt;extract_projections(&amp;projs, false, false);</span>
1326 
<span class="line-modified">1327       Node* lrb_clone = lrb-&gt;clone();</span>
<span class="line-modified">1328       phase-&gt;register_new_node(lrb_clone, projs.catchall_catchproj);</span>
<span class="line-modified">1329       phase-&gt;set_ctrl(lrb, projs.fallthrough_catchproj);</span>


1330 
<span class="line-modified">1331       stack.push(lrb, 0);</span>
<span class="line-modified">1332       clones.push(lrb_clone);</span>
1333 
<span class="line-modified">1334       do {</span>
<span class="line-modified">1335         assert(stack.size() == clones.size(), &quot;&quot;);</span>
<span class="line-modified">1336         Node* n = stack.node();</span>
<span class="line-modified">1337 #ifdef ASSERT</span>
<span class="line-modified">1338         if (n-&gt;is_Load()) {</span>
<span class="line-modified">1339           Node* mem = n-&gt;in(MemNode::Memory);</span>
<span class="line-modified">1340           for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-modified">1341             Node* u = mem-&gt;fast_out(j);</span>
<span class="line-modified">1342             assert(!u-&gt;is_Store() || !u-&gt;is_LoadStore() || phase-&gt;get_ctrl(u) != ctrl, &quot;anti dependent store?&quot;);</span>
<span class="line-modified">1343           }</span>
<span class="line-added">1344         }</span>
<span class="line-added">1345 #endif</span>
<span class="line-added">1346         uint idx = stack.index();</span>
<span class="line-added">1347         Node* n_clone = clones.at(clones.size()-1);</span>
<span class="line-added">1348         if (idx &lt; n-&gt;outcnt()) {</span>
<span class="line-added">1349           Node* u = n-&gt;raw_out(idx);</span>
<span class="line-added">1350           Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-added">1351           if (phase-&gt;is_dominator(call, c) &amp;&amp; phase-&gt;is_dominator(c, projs.fallthrough_proj)) {</span>
<span class="line-added">1352             stack.set_index(idx+1);</span>
<span class="line-added">1353             assert(!u-&gt;is_CFG(), &quot;&quot;);</span>
<span class="line-added">1354             stack.push(u, 0);</span>
<span class="line-added">1355             Node* u_clone = u-&gt;clone();</span>
<span class="line-added">1356             int nb = u_clone-&gt;replace_edge(n, n_clone);</span>
<span class="line-added">1357             assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="line-added">1358             phase-&gt;register_new_node(u_clone, projs.catchall_catchproj);</span>
<span class="line-added">1359             clones.push(u_clone);</span>
<span class="line-added">1360             phase-&gt;set_ctrl(u, projs.fallthrough_catchproj);</span>
<span class="line-added">1361           } else {</span>
<span class="line-added">1362             bool replaced = false;</span>
<span class="line-added">1363             if (u-&gt;is_Phi()) {</span>
<span class="line-added">1364               for (uint k = 1; k &lt; u-&gt;req(); k++) {</span>
<span class="line-added">1365                 if (u-&gt;in(k) == n) {</span>
<span class="line-added">1366                   if (phase-&gt;is_dominator(projs.catchall_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
<span class="line-added">1367                     phase-&gt;igvn().replace_input_of(u, k, n_clone);</span>
<span class="line-added">1368                     replaced = true;</span>
<span class="line-added">1369                   } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, u-&gt;in(0)-&gt;in(k))) {</span>
<span class="line-added">1370                     phase-&gt;igvn().replace_input_of(u, k, create_phis_on_call_return(ctrl, u-&gt;in(0)-&gt;in(k), n, n_clone, projs, phase));</span>
<span class="line-added">1371                     replaced = true;</span>
<span class="line-added">1372                   }</span>
<span class="line-added">1373                 }</span>
<span class="line-added">1374               }</span>
<span class="line-added">1375             } else {</span>
<span class="line-added">1376               if (phase-&gt;is_dominator(projs.catchall_catchproj, c)) {</span>
<span class="line-added">1377                 phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1378                 int nb = u-&gt;replace_edge(n, n_clone);</span>
<span class="line-added">1379                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="line-added">1380                 replaced = true;</span>
<span class="line-added">1381               } else if (!phase-&gt;is_dominator(projs.fallthrough_catchproj, c)) {</span>
<span class="line-added">1382                 phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1383                 int nb = u-&gt;replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));</span>
<span class="line-added">1384                 assert(nb &gt; 0, &quot;should have replaced some uses&quot;);</span>
<span class="line-added">1385                 replaced = true;</span>
<span class="line-added">1386               }</span>
<span class="line-added">1387             }</span>
<span class="line-added">1388             if (!replaced) {</span>
<span class="line-added">1389               stack.set_index(idx+1);</span>
<span class="line-added">1390             }</span>
<span class="line-added">1391           }</span>
<span class="line-added">1392         } else {</span>
<span class="line-added">1393           stack.pop();</span>
<span class="line-added">1394           clones.pop();</span>
<span class="line-added">1395         }</span>
<span class="line-added">1396       } while (stack.size() &gt; 0);</span>
<span class="line-added">1397       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);</span>
1398     }
1399   }
1400 
<span class="line-modified">1401   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {</span>
<span class="line-modified">1402     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="line-modified">1403     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="line-modified">1404       continue;</span>
<span class="line-added">1405     }</span>
<span class="line-added">1406     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
1407     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1408     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1409       // Expanding a barrier here will break loop strip mining
1410       // verification. Transform the loop so the loop nest doesn&#39;t
1411       // appear as strip mined.
1412       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1413       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1414     }
1415   }
1416 
<span class="line-added">1417   // Expand load-reference-barriers</span>
1418   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1419   Unique_Node_List uses_to_ignore;
<span class="line-modified">1420   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="line-modified">1421     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);</span>
<span class="line-added">1422     if (lrb-&gt;get_barrier_strength() == ShenandoahLoadReferenceBarrierNode::NONE) {</span>
<span class="line-added">1423       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="line-added">1424       continue;</span>
<span class="line-added">1425     }</span>
<span class="line-added">1426     uint last = phase-&gt;C-&gt;unique();</span>
<span class="line-added">1427     Node* ctrl = phase-&gt;get_ctrl(lrb);</span>
<span class="line-added">1428     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="line-added">1429 </span>
<span class="line-added">1430 </span>
<span class="line-added">1431     Node* orig_ctrl = ctrl;</span>
<span class="line-added">1432 </span>
<span class="line-added">1433     Node* raw_mem = fixer.find_mem(ctrl, lrb);</span>
<span class="line-added">1434     Node* init_raw_mem = raw_mem;</span>
<span class="line-added">1435     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);</span>
<span class="line-added">1436 </span>
<span class="line-added">1437     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-added">1438     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-added">1439     Node* unc_ctrl = NULL;</span>
<span class="line-added">1440     if (unc != NULL) {</span>
<span class="line-added">1441       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {</span>
<span class="line-added">1442         unc = NULL;</span>
<span class="line-added">1443       } else {</span>
<span class="line-added">1444         unc_ctrl = val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control);</span>
<span class="line-added">1445       }</span>
<span class="line-added">1446     }</span>
<span class="line-added">1447 </span>
<span class="line-added">1448     Node* uncasted_val = val;</span>
<span class="line-added">1449     if (unc != NULL) {</span>
<span class="line-added">1450       uncasted_val = val-&gt;in(1);</span>
<span class="line-added">1451     }</span>
<span class="line-added">1452 </span>
<span class="line-added">1453     Node* heap_stable_ctrl = NULL;</span>
<span class="line-added">1454     Node* null_ctrl = NULL;</span>
<span class="line-added">1455 </span>
<span class="line-added">1456     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);</span>
<span class="line-added">1457     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);</span>
<span class="line-added">1458 </span>
<span class="line-added">1459     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };</span>
<span class="line-added">1460     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="line-added">1461     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="line-added">1462     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="line-added">1463 </span>
<span class="line-added">1464     // Stable path.</span>
<span class="line-added">1465     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
<span class="line-added">1466     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1467 </span>
<span class="line-added">1468     // Heap stable case</span>
<span class="line-added">1469     region-&gt;init_req(_heap_stable, heap_stable_ctrl);</span>
<span class="line-added">1470     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
<span class="line-added">1471     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);</span>
<span class="line-added">1472 </span>
<span class="line-added">1473     Node* reg2_ctrl = NULL;</span>
<span class="line-added">1474     // Null case</span>
<span class="line-added">1475     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="line-added">1476     if (null_ctrl != NULL) {</span>
<span class="line-added">1477       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="line-added">1478       region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-added">1479       val_phi-&gt;init_req(_null_path, uncasted_val);</span>
<span class="line-added">1480       raw_mem_phi-&gt;init_req(_null_path, raw_mem);</span>
<span class="line-added">1481     } else {</span>
<span class="line-added">1482       region-&gt;del_req(_null_path);</span>
<span class="line-added">1483       val_phi-&gt;del_req(_null_path);</span>
<span class="line-added">1484       raw_mem_phi-&gt;del_req(_null_path);</span>
<span class="line-added">1485     }</span>
<span class="line-added">1486 </span>
<span class="line-added">1487     // Test for in-cset.</span>
<span class="line-added">1488     // Wires !in_cset(obj) to slot 2 of region and phis</span>
<span class="line-added">1489     Node* not_cset_ctrl = NULL;</span>
<span class="line-added">1490     in_cset_fast_test(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
<span class="line-added">1491     if (not_cset_ctrl != NULL) {</span>
<span class="line-added">1492       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="line-added">1493       region-&gt;init_req(_not_cset, not_cset_ctrl);</span>
<span class="line-added">1494       val_phi-&gt;init_req(_not_cset, uncasted_val);</span>
<span class="line-added">1495       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);</span>
<span class="line-added">1496     }</span>
<span class="line-added">1497 </span>
<span class="line-added">1498     // Resolve object when orig-value is in cset.</span>
<span class="line-added">1499     // Make the unconditional resolve for fwdptr.</span>
<span class="line-added">1500     Node* new_val = uncasted_val;</span>
<span class="line-added">1501     if (unc_ctrl != NULL) {</span>
<span class="line-added">1502       // Clone the null check in this branch to allow implicit null check</span>
<span class="line-added">1503       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="line-added">1504       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
<span class="line-added">1505 </span>
<span class="line-added">1506       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1507       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="line-added">1508     }</span>
<span class="line-added">1509 </span>
<span class="line-added">1510     // Call lrb-stub and wire up that path in slots 4</span>
<span class="line-added">1511     Node* result_mem = NULL;</span>
<span class="line-added">1512 </span>
<span class="line-added">1513     Node* fwd = new_val;</span>
<span class="line-added">1514     Node* addr;</span>
<span class="line-added">1515     if (ShenandoahSelfFixing) {</span>
<span class="line-added">1516       VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-added">1517       addr = get_load_addr(phase, visited, lrb);</span>
<span class="line-added">1518     } else {</span>
<span class="line-added">1519       addr = phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="line-added">1520     }</span>
<span class="line-added">1521     if (addr-&gt;Opcode() == Op_AddP) {</span>
<span class="line-added">1522       Node* orig_base = addr-&gt;in(AddPNode::Base);</span>
<span class="line-added">1523       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);</span>
<span class="line-added">1524       phase-&gt;register_new_node(base, ctrl);</span>
<span class="line-added">1525       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {</span>
<span class="line-added">1526         // Field access</span>
<span class="line-added">1527         addr = addr-&gt;clone();</span>
<span class="line-added">1528         addr-&gt;set_req(AddPNode::Base, base);</span>
<span class="line-added">1529         addr-&gt;set_req(AddPNode::Address, base);</span>
<span class="line-added">1530         phase-&gt;register_new_node(addr, ctrl);</span>
<span class="line-added">1531       } else {</span>
<span class="line-added">1532         Node* addr2 = addr-&gt;in(AddPNode::Address);</span>
<span class="line-added">1533         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;</span>
<span class="line-added">1534               addr2-&gt;in(AddPNode::Base) == orig_base) {</span>
<span class="line-added">1535           addr2 = addr2-&gt;clone();</span>
<span class="line-added">1536           addr2-&gt;set_req(AddPNode::Base, base);</span>
<span class="line-added">1537           addr2-&gt;set_req(AddPNode::Address, base);</span>
<span class="line-added">1538           phase-&gt;register_new_node(addr2, ctrl);</span>
<span class="line-added">1539           addr = addr-&gt;clone();</span>
<span class="line-added">1540           addr-&gt;set_req(AddPNode::Base, base);</span>
<span class="line-added">1541           addr-&gt;set_req(AddPNode::Address, addr2);</span>
<span class="line-added">1542           phase-&gt;register_new_node(addr, ctrl);</span>
<span class="line-added">1543         }</span>
<span class="line-added">1544       }</span>
<span class="line-added">1545     }</span>
<span class="line-added">1546     call_lrb_stub(ctrl, fwd, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
<span class="line-added">1547     region-&gt;init_req(_evac_path, ctrl);</span>
<span class="line-added">1548     val_phi-&gt;init_req(_evac_path, fwd);</span>
<span class="line-added">1549     raw_mem_phi-&gt;init_req(_evac_path, result_mem);</span>
<span class="line-added">1550 </span>
<span class="line-added">1551     phase-&gt;register_control(region, loop, heap_stable_iff);</span>
<span class="line-added">1552     Node* out_val = val_phi;</span>
<span class="line-added">1553     phase-&gt;register_new_node(val_phi, region);</span>
<span class="line-added">1554     phase-&gt;register_new_node(raw_mem_phi, region);</span>
<span class="line-added">1555 </span>
<span class="line-added">1556     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="line-added">1557 </span>
<span class="line-added">1558     ctrl = orig_ctrl;</span>
<span class="line-added">1559 </span>
<span class="line-added">1560     if (unc != NULL) {</span>
<span class="line-added">1561       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1562         Node* u = val-&gt;fast_out(i);</span>
<span class="line-added">1563         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-added">1564         if (u != lrb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, lrb, u, phase))) {</span>
<span class="line-added">1565           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1566           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="line-added">1567           --i, imax -= nb;</span>
<span class="line-added">1568         }</span>
<span class="line-added">1569       }</span>
<span class="line-added">1570       if (val-&gt;outcnt() == 0) {</span>
<span class="line-added">1571         phase-&gt;igvn()._worklist.push(val);</span>
<span class="line-added">1572       }</span>
<span class="line-added">1573     }</span>
<span class="line-added">1574     phase-&gt;igvn().replace_node(lrb, out_val);</span>
<span class="line-added">1575 </span>
<span class="line-added">1576     follow_barrier_uses(out_val, ctrl, uses, phase);</span>
<span class="line-added">1577 </span>
<span class="line-added">1578     for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="line-added">1579       Node *n = uses.at(next);</span>
<span class="line-added">1580       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);</span>
<span class="line-added">1581       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);</span>
<span class="line-added">1582       phase-&gt;set_ctrl(n, region);</span>
<span class="line-added">1583       follow_barrier_uses(n, ctrl, uses, phase);</span>
<span class="line-added">1584     }</span>
<span class="line-added">1585 </span>
<span class="line-added">1586     // The slow path call produces memory: hook the raw memory phi</span>
<span class="line-added">1587     // from the expanded load reference barrier with the rest of the graph</span>
<span class="line-added">1588     // which may require adding memory phis at every post dominated</span>
<span class="line-added">1589     // region and at enclosing loop heads. Use the memory state</span>
<span class="line-added">1590     // collected in memory_nodes to fix the memory graph. Update that</span>
<span class="line-added">1591     // memory state as we go.</span>
<span class="line-added">1592     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);</span>
<span class="line-added">1593   }</span>
<span class="line-added">1594   // Done expanding load-reference-barriers.</span>
<span class="line-added">1595   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;load_reference_barriers_count() == 0, &quot;all load reference barrier nodes should have been replaced&quot;);</span>
<span class="line-added">1596 </span>
<span class="line-added">1597   for (int i = state-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="line-added">1598     Node* barrier = state-&gt;enqueue_barrier(i);</span>
1599     Node* pre_val = barrier-&gt;in(1);
1600 
1601     if (phase-&gt;igvn().type(pre_val)-&gt;higher_equal(TypePtr::NULL_PTR)) {
1602       ShouldNotReachHere();
1603       continue;
1604     }
1605 
1606     Node* ctrl = phase-&gt;get_ctrl(barrier);
1607 
1608     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {
1609       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0)-&gt;in(0), pre_val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);
1610       ctrl = ctrl-&gt;in(0)-&gt;in(0);
1611       phase-&gt;set_ctrl(barrier, ctrl);
1612     } else if (ctrl-&gt;is_CallRuntime()) {
1613       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0), pre_val, ctrl, phase), &quot;can&#39;t move&quot;);
1614       ctrl = ctrl-&gt;in(0);
1615       phase-&gt;set_ctrl(barrier, ctrl);
1616     }
1617 
1618     Node* init_ctrl = ctrl;
</pre>
<hr />
<pre>
1670     IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
1671     if (reg2_ctrl == NULL) reg2_ctrl = queue_full_iff;
1672     phase-&gt;register_control(queue_full_iff, loop, ctrl);
1673     Node* not_full = new IfTrueNode(queue_full_iff);
1674     phase-&gt;register_control(not_full, loop, queue_full_iff);
1675     Node* full = new IfFalseNode(queue_full_iff);
1676     phase-&gt;register_control(full, loop, queue_full_iff);
1677 
1678     ctrl = not_full;
1679 
1680     Node* next_index = new SubXNode(index, phase-&gt;igvn().MakeConX(sizeof(intptr_t)));
1681     phase-&gt;register_new_node(next_index, ctrl);
1682 
1683     Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);
1684     phase-&gt;register_new_node(buffer, ctrl);
1685     Node *log_addr = new AddPNode(phase-&gt;C-&gt;top(), buffer, next_index);
1686     phase-&gt;register_new_node(log_addr, ctrl);
1687     Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);
1688     phase-&gt;register_new_node(log_store, ctrl);
1689     // update the index
<span class="line-modified">1690     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);</span>
<span class="line-modified">1691     phase-&gt;register_new_node(index_update, ctrl);</span>





































































































1692 
<span class="line-modified">1693     // Fast-path case</span>
<span class="line-modified">1694     region2-&gt;init_req(_fast_path, ctrl);</span>
<span class="line-modified">1695     phi2-&gt;init_req(_fast_path, index_update);</span>


1696 
<span class="line-modified">1697     ctrl = full;</span>


1698 
<span class="line-modified">1699     Node* base = find_bottom_mem(ctrl, phase);</span>




1700 
<span class="line-modified">1701     MergeMemNode* mm = MergeMemNode::make(base);</span>
<span class="line-modified">1702     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);</span>
<span class="line-modified">1703     phase-&gt;register_new_node(mm, ctrl);</span>












1704 
<span class="line-modified">1705     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);</span>
<span class="line-modified">1706     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-modified">1707     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());</span>
<span class="line-modified">1708     call-&gt;init_req(TypeFunc::Memory, mm);</span>
<span class="line-modified">1709     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());</span>
<span class="line-modified">1710     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());</span>
<span class="line-modified">1711     call-&gt;init_req(TypeFunc::Parms, pre_val);</span>
<span class="line-modified">1712     call-&gt;init_req(TypeFunc::Parms+1, thread);</span>
<span class="line-modified">1713     phase-&gt;register_control(call, loop, ctrl);</span>


1714 
<span class="line-modified">1715     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);</span>
<span class="line-modified">1716     phase-&gt;register_control(ctrl_proj, loop, call);</span>
<span class="line-modified">1717     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);</span>
<span class="line-modified">1718     phase-&gt;register_new_node(mem_proj, call);</span>



1719 
<span class="line-modified">1720     // Slow-path case</span>
<span class="line-modified">1721     region2-&gt;init_req(_slow_path, ctrl_proj);</span>
<span class="line-modified">1722     phi2-&gt;init_req(_slow_path, mem_proj);</span>






































1723 
1724     phase-&gt;register_control(region2, loop, reg2_ctrl);
<span class="line-modified">1725     phase-&gt;register_new_node(phi2, region2);</span>


1726 
1727     region-&gt;init_req(_heap_unstable, region2);
<span class="line-modified">1728     phi-&gt;init_req(_heap_unstable, phi2);</span>






























1729 
<span class="line-modified">1730     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));</span>
<span class="line-modified">1731     phase-&gt;register_new_node(phi, region);</span>
1732 
<span class="line-added">1733     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);</span>
1734     for(uint next = 0; next &lt; uses.size(); next++ ) {
1735       Node *n = uses.at(next);
<span class="line-modified">1736       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);</span>
1737       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1738       phase-&gt;set_ctrl(n, region);
<span class="line-modified">1739       follow_barrier_uses(n, init_ctrl, uses, phase);</span>
1740     }
<span class="line-added">1741     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);</span>
1742 
<span class="line-modified">1743     phase-&gt;igvn().replace_node(barrier, pre_val);</span>
<span class="line-modified">1744   }</span>
<span class="line-modified">1745   assert(state-&gt;enqueue_barriers_count() == 0, &quot;all enqueue barrier nodes should have been replaced&quot;);</span>
<span class="line-modified">1746 </span>
<span class="line-modified">1747 }</span>
<span class="line-modified">1748 </span>
<span class="line-modified">1749 Node* ShenandoahBarrierC2Support::get_load_addr(PhaseIdealLoop* phase, VectorSet&amp; visited, Node* in) {</span>
<span class="line-modified">1750   if (visited.test_set(in-&gt;_idx)) {</span>
<span class="line-added">1751     return NULL;</span>
<span class="line-added">1752   }</span>
<span class="line-added">1753   switch (in-&gt;Opcode()) {</span>
<span class="line-added">1754     case Op_Proj:</span>
<span class="line-added">1755       return get_load_addr(phase, visited, in-&gt;in(0));</span>
<span class="line-added">1756     case Op_CastPP:</span>
<span class="line-added">1757     case Op_CheckCastPP:</span>
<span class="line-added">1758     case Op_DecodeN:</span>
<span class="line-added">1759     case Op_EncodeP:</span>
<span class="line-added">1760       return get_load_addr(phase, visited, in-&gt;in(1));</span>
<span class="line-added">1761     case Op_LoadN:</span>
<span class="line-added">1762     case Op_LoadP:</span>
<span class="line-added">1763       return in-&gt;in(MemNode::Address);</span>
<span class="line-added">1764     case Op_CompareAndExchangeN:</span>
<span class="line-added">1765     case Op_CompareAndExchangeP:</span>
<span class="line-added">1766     case Op_GetAndSetN:</span>
<span class="line-added">1767     case Op_GetAndSetP:</span>
<span class="line-added">1768     case Op_ShenandoahCompareAndExchangeP:</span>
<span class="line-added">1769     case Op_ShenandoahCompareAndExchangeN:</span>
<span class="line-added">1770       // Those instructions would just have stored a different</span>
<span class="line-added">1771       // value into the field. No use to attempt to fix it at this point.</span>
<span class="line-added">1772       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="line-added">1773     case Op_CMoveP:</span>
<span class="line-added">1774     case Op_CMoveN: {</span>
<span class="line-added">1775       Node* t = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfTrue));</span>
<span class="line-added">1776       Node* f = get_load_addr(phase, visited, in-&gt;in(CMoveNode::IfFalse));</span>
<span class="line-added">1777       // Handle unambiguous cases: single address reported on both branches.</span>
<span class="line-added">1778       if (t != NULL &amp;&amp; f == NULL) return t;</span>
<span class="line-added">1779       if (t == NULL &amp;&amp; f != NULL) return f;</span>
<span class="line-added">1780       if (t != NULL &amp;&amp; t == f)    return t;</span>
<span class="line-added">1781       // Ambiguity.</span>
<span class="line-added">1782       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="line-added">1783     }</span>
<span class="line-added">1784     case Op_Phi: {</span>
<span class="line-added">1785       Node* addr = NULL;</span>
<span class="line-added">1786       for (uint i = 1; i &lt; in-&gt;req(); i++) {</span>
<span class="line-added">1787         Node* addr1 = get_load_addr(phase, visited, in-&gt;in(i));</span>
<span class="line-added">1788         if (addr == NULL) {</span>
<span class="line-added">1789           addr = addr1;</span>
<span class="line-added">1790         }</span>
<span class="line-added">1791         if (addr != addr1) {</span>
<span class="line-added">1792           return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="line-added">1793         }</span>
<span class="line-added">1794       }</span>
<span class="line-added">1795       return addr;</span>
<span class="line-added">1796     }</span>
<span class="line-added">1797     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-added">1798       return get_load_addr(phase, visited, in-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="line-added">1799     case Op_ShenandoahEnqueueBarrier:</span>
<span class="line-added">1800       return get_load_addr(phase, visited, in-&gt;in(1));</span>
<span class="line-added">1801     case Op_CallDynamicJava:</span>
<span class="line-added">1802     case Op_CallLeaf:</span>
<span class="line-added">1803     case Op_CallStaticJava:</span>
<span class="line-added">1804     case Op_ConN:</span>
<span class="line-added">1805     case Op_ConP:</span>
<span class="line-added">1806     case Op_Parm:</span>
<span class="line-added">1807     case Op_CreateEx:</span>
<span class="line-added">1808       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
<span class="line-added">1809     default:</span>
<span class="line-added">1810 #ifdef ASSERT</span>
<span class="line-added">1811       fatal(&quot;Unknown node in get_load_addr: %s&quot;, NodeClassNames[in-&gt;Opcode()]);</span>
<span class="line-added">1812 #endif</span>
<span class="line-added">1813       return phase-&gt;igvn().zerocon(T_OBJECT);</span>
1814   }
1815 

1816 }
1817 
<span class="line-modified">1818 void ShenandoahBarrierC2Support::move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {</span>
1819   IdealLoopTree *loop = phase-&gt;get_loop(iff);
1820   Node* loop_head = loop-&gt;_head;
1821   Node* entry_c = loop_head-&gt;in(LoopNode::EntryControl);
1822 
1823   Node* bol = iff-&gt;in(1);
1824   Node* cmp = bol-&gt;in(1);
1825   Node* andi = cmp-&gt;in(1);
1826   Node* load = andi-&gt;in(1);
1827 
1828   assert(is_gc_state_load(load), &quot;broken&quot;);
1829   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
1830     Node* mem_ctrl = NULL;
1831     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
1832     load = load-&gt;clone();
1833     load-&gt;set_req(MemNode::Memory, mem);
1834     load-&gt;set_req(0, entry_c);
1835     phase-&gt;register_new_node(load, entry_c);
1836     andi = andi-&gt;clone();
1837     andi-&gt;set_req(1, load);
1838     phase-&gt;register_new_node(andi, entry_c);
1839     cmp = cmp-&gt;clone();
1840     cmp-&gt;set_req(1, andi);
1841     phase-&gt;register_new_node(cmp, entry_c);
1842     bol = bol-&gt;clone();
1843     bol-&gt;set_req(1, cmp);
1844     phase-&gt;register_new_node(bol, entry_c);
1845 
1846     Node* old_bol =iff-&gt;in(1);
1847     phase-&gt;igvn().replace_input_of(iff, 1, bol);
1848   }
1849 }
1850 
<span class="line-modified">1851 bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {</span>
1852   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
1853     return false;
1854   }
1855   Node* region = n-&gt;in(0);
1856 
1857   if (!region-&gt;is_Region()) {
1858     return false;
1859   }
1860   Node* dom = phase-&gt;idom(region);
1861   if (!dom-&gt;is_If()) {
1862     return false;
1863   }
1864 
1865   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
1866     return false;
1867   }
1868 
1869   IfNode* dom_if = dom-&gt;as_If();
1870   Node* proj_true = dom_if-&gt;proj_out(1);
1871   Node* proj_false = dom_if-&gt;proj_out(0);
1872 
1873   for (uint i = 1; i &lt; region-&gt;req(); i++) {
1874     if (phase-&gt;is_dominator(proj_true, region-&gt;in(i))) {
1875       continue;
1876     }
1877     if (phase-&gt;is_dominator(proj_false, region-&gt;in(i))) {
1878       continue;
1879     }
1880     return false;
1881   }
1882 
1883   return true;
1884 }
1885 
<span class="line-modified">1886 void ShenandoahBarrierC2Support::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {</span>
1887   assert(is_heap_stable_test(n), &quot;no other tests&quot;);
1888   if (identical_backtoback_ifs(n, phase)) {
1889     Node* n_ctrl = n-&gt;in(0);
1890     if (phase-&gt;can_split_if(n_ctrl)) {
1891       IfNode* dom_if = phase-&gt;idom(n_ctrl)-&gt;as_If();
1892       if (is_heap_stable_test(n)) {
1893         Node* gc_state_load = n-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1894         assert(is_gc_state_load(gc_state_load), &quot;broken&quot;);
1895         Node* dom_gc_state_load = dom_if-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
1896         assert(is_gc_state_load(dom_gc_state_load), &quot;broken&quot;);
1897         if (gc_state_load != dom_gc_state_load) {
1898           phase-&gt;igvn().replace_node(gc_state_load, dom_gc_state_load);
1899         }
1900       }
1901       PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
1902       Node* proj_true = dom_if-&gt;proj_out(1);
1903       Node* proj_false = dom_if-&gt;proj_out(0);
1904       Node* con_true = phase-&gt;igvn().makecon(TypeInt::ONE);
1905       Node* con_false = phase-&gt;igvn().makecon(TypeInt::ZERO);
1906 
1907       for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
1908         if (phase-&gt;is_dominator(proj_true, n_ctrl-&gt;in(i))) {
1909           bolphi-&gt;init_req(i, con_true);
1910         } else {
1911           assert(phase-&gt;is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
1912           bolphi-&gt;init_req(i, con_false);
1913         }
1914       }
1915       phase-&gt;register_new_node(bolphi, n_ctrl);
1916       phase-&gt;igvn().replace_input_of(n, 1, bolphi);
1917       phase-&gt;do_split_if(n);
1918     }
1919   }
1920 }
1921 
<span class="line-modified">1922 IfNode* ShenandoahBarrierC2Support::find_unswitching_candidate(const IdealLoopTree* loop, PhaseIdealLoop* phase) {</span>
1923   // Find first invariant test that doesn&#39;t exit the loop
1924   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
1925   IfNode* unswitch_iff = NULL;
1926   Node* n = head-&gt;in(LoopNode::LoopBackControl);
1927   int loop_has_sfpts = -1;
1928   while (n != head) {
1929     Node* n_dom = phase-&gt;idom(n);
1930     if (n-&gt;is_Region()) {
1931       if (n_dom-&gt;is_If()) {
1932         IfNode* iff = n_dom-&gt;as_If();
1933         if (iff-&gt;in(1)-&gt;is_Bool()) {
1934           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
1935           if (bol-&gt;in(1)-&gt;is_Cmp()) {
1936             // If condition is invariant and not a loop exit,
1937             // then found reason to unswitch.
1938             if (is_heap_stable_test(iff) &amp;&amp;
1939                 (loop_has_sfpts == -1 || loop_has_sfpts == 0)) {
1940               assert(!loop-&gt;is_loop_exit(iff), &quot;both branches should be in the loop&quot;);
1941               if (loop_has_sfpts == -1) {
1942                 for(uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
</pre>
<hr />
<pre>
1947                   }
1948                 }
1949                 if (loop_has_sfpts == -1) {
1950                   loop_has_sfpts = 0;
1951                 }
1952               }
1953               if (!loop_has_sfpts) {
1954                 unswitch_iff = iff;
1955               }
1956             }
1957           }
1958         }
1959       }
1960     }
1961     n = n_dom;
1962   }
1963   return unswitch_iff;
1964 }
1965 
1966 
<span class="line-modified">1967 void ShenandoahBarrierC2Support::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {</span>
1968   Node_List heap_stable_tests;
1969   Node_List gc_state_loads;

1970   stack.push(phase-&gt;C-&gt;start(), 0);
1971   do {
1972     Node* n = stack.node();
1973     uint i = stack.index();
1974 
1975     if (i &lt; n-&gt;outcnt()) {
1976       Node* u = n-&gt;raw_out(i);
1977       stack.set_index(i+1);
1978       if (!visited.test_set(u-&gt;_idx)) {
1979         stack.push(u, 0);
1980       }
1981     } else {
1982       stack.pop();
1983       if (ShenandoahCommonGCStateLoads &amp;&amp; is_gc_state_load(n)) {
1984         gc_state_loads.push(n);
1985       }
1986       if (n-&gt;is_If() &amp;&amp; is_heap_stable_test(n)) {
1987         heap_stable_tests.push(n);
1988       }
1989     }
</pre>
<hr />
<pre>
1997       if (n-&gt;outcnt() != 0) {
1998         progress |= try_common_gc_state_load(n, phase);
1999       }
2000     }
2001   } while (progress);
2002 
2003   for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
2004     Node* n = heap_stable_tests.at(i);
2005     assert(is_heap_stable_test(n), &quot;only evacuation test&quot;);
2006     merge_back_to_back_tests(n, phase);
2007   }
2008 
2009   if (!phase-&gt;C-&gt;major_progress()) {
2010     VectorSet seen(Thread::current()-&gt;resource_area());
2011     for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
2012       Node* n = heap_stable_tests.at(i);
2013       IdealLoopTree* loop = phase-&gt;get_loop(n);
2014       if (loop != phase-&gt;ltree_root() &amp;&amp;
2015           loop-&gt;_child == NULL &amp;&amp;
2016           !loop-&gt;_irreducible) {
<span class="line-modified">2017         Node* head = loop-&gt;_head;</span>
<span class="line-modified">2018         if (head-&gt;is_Loop() &amp;&amp;</span>
<span class="line-added">2019             (!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;</span>
2020             !seen.test_set(head-&gt;_idx)) {
2021           IfNode* iff = find_unswitching_candidate(loop, phase);
2022           if (iff != NULL) {
2023             Node* bol = iff-&gt;in(1);
<span class="line-modified">2024             if (head-&gt;as_Loop()-&gt;is_strip_mined()) {</span>
<span class="line-modified">2025               head-&gt;as_Loop()-&gt;verify_strip_mined(0);</span>
2026             }
2027             move_heap_stable_test_out_of_loop(iff, phase);
<span class="line-added">2028 </span>
<span class="line-added">2029             AutoNodeBudget node_budget(phase);</span>
<span class="line-added">2030 </span>
2031             if (loop-&gt;policy_unswitching(phase)) {
<span class="line-modified">2032               if (head-&gt;as_Loop()-&gt;is_strip_mined()) {</span>
2033                 OuterStripMinedLoopNode* outer = head-&gt;as_CountedLoop()-&gt;outer_loop();
2034                 hide_strip_mined_loop(outer, head-&gt;as_CountedLoop(), phase);
2035               }
2036               phase-&gt;do_unswitching(loop, old_new);
2037             } else {
2038               // Not proceeding with unswitching. Move load back in
2039               // the loop.
2040               phase-&gt;igvn().replace_input_of(iff, 1, bol);
2041             }
2042           }
2043         }
2044       }
2045     }
2046   }
2047 }
2048 
2049 #ifdef ASSERT
<span class="line-modified">2050 void ShenandoahBarrierC2Support::verify_raw_mem(RootNode* root) {</span>
2051   const bool trace = false;
2052   ResourceMark rm;
2053   Unique_Node_List nodes;
2054   Unique_Node_List controls;
2055   Unique_Node_List memories;
2056 
2057   nodes.push(root);
2058   for (uint next = 0; next &lt; nodes.size(); next++) {
2059     Node *n  = nodes.at(next);
<span class="line-modified">2060     if (ShenandoahBarrierSetC2::is_shenandoah_lrb_call(n)) {</span>
2061       controls.push(n);
2062       if (trace) { tty-&gt;print(&quot;XXXXXX verifying&quot;); n-&gt;dump(); }
2063       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
2064         Node *m = controls.at(next2);
2065         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
2066           Node* u = m-&gt;fast_out(i);
2067           if (u-&gt;is_CFG() &amp;&amp; !u-&gt;is_Root() &amp;&amp;
2068               !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1) &amp;&amp;
2069               !(u-&gt;is_Region() &amp;&amp; u-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Halt)) {
2070             if (trace) { tty-&gt;print(&quot;XXXXXX pushing control&quot;); u-&gt;dump(); }
2071             controls.push(u);
2072           }
2073         }
2074       }
2075       memories.push(n-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory));
2076       for (uint next2 = 0; next2 &lt; memories.size(); next2++) {
2077         Node *m = memories.at(next2);
2078         assert(m-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2079         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
2080           Node* u = m-&gt;fast_out(i);
</pre>
<hr />
<pre>
2128                 }
2129               }
2130             }
2131           }
2132           assert(found_phi || all_in, &quot;&quot;);
2133         }
2134       }
2135       controls.clear();
2136       memories.clear();
2137     }
2138     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {
2139       Node *m = n-&gt;in(i);
2140       if (m != NULL) {
2141         nodes.push(m);
2142       }
2143     }
2144   }
2145 }
2146 #endif
2147 
<span class="line-added">2148 ShenandoahEnqueueBarrierNode::ShenandoahEnqueueBarrierNode(Node* val) : Node(NULL, val) {</span>
<span class="line-added">2149   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_enqueue_barrier(this);</span>
<span class="line-added">2150 }</span>
<span class="line-added">2151 </span>
2152 const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {
2153   if (in(1) == NULL || in(1)-&gt;is_top()) {
2154     return Type::TOP;
2155   }
2156   const Type* t = in(1)-&gt;bottom_type();
2157   if (t == TypePtr::NULL_PTR) {
2158     return t;
2159   }
<span class="line-modified">2160   return t-&gt;is_oopptr();</span>
2161 }
2162 
2163 const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {
2164   if (in(1) == NULL) {
2165     return Type::TOP;
2166   }
2167   const Type* t = phase-&gt;type(in(1));
2168   if (t == Type::TOP) {
2169     return Type::TOP;
2170   }
2171   if (t == TypePtr::NULL_PTR) {
2172     return t;
2173   }
<span class="line-modified">2174   return t-&gt;is_oopptr();</span>
2175 }
2176 
2177 int ShenandoahEnqueueBarrierNode::needed(Node* n) {
2178   if (n == NULL ||
2179       n-&gt;is_Allocate() ||
<span class="line-added">2180       n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier ||</span>
2181       n-&gt;bottom_type() == TypePtr::NULL_PTR ||
2182       (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL)) {
2183     return NotNeeded;
2184   }
2185   if (n-&gt;is_Phi() ||
2186       n-&gt;is_CMove()) {
2187     return MaybeNeeded;
2188   }
2189   return Needed;
2190 }
2191 
2192 Node* ShenandoahEnqueueBarrierNode::next(Node* n) {
2193   for (;;) {
2194     if (n == NULL) {
2195       return n;
2196     } else if (n-&gt;bottom_type() == TypePtr::NULL_PTR) {
2197       return n;
2198     } else if (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL) {
2199       return n;
2200     } else if (n-&gt;is_ConstraintCast() ||
</pre>
<hr />
<pre>
2280 void MemoryGraphFixer::collect_memory_nodes() {
2281   Node_Stack stack(0);
2282   VectorSet visited(Thread::current()-&gt;resource_area());
2283   Node_List regions;
2284 
2285   // Walk the raw memory graph and create a mapping from CFG node to
2286   // memory node. Exclude phis for now.
2287   stack.push(_phase-&gt;C-&gt;root(), 1);
2288   do {
2289     Node* n = stack.node();
2290     int opc = n-&gt;Opcode();
2291     uint i = stack.index();
2292     if (i &lt; n-&gt;req()) {
2293       Node* mem = NULL;
2294       if (opc == Op_Root) {
2295         Node* in = n-&gt;in(i);
2296         int in_opc = in-&gt;Opcode();
2297         if (in_opc == Op_Return || in_opc == Op_Rethrow) {
2298           mem = in-&gt;in(TypeFunc::Memory);
2299         } else if (in_opc == Op_Halt) {
<span class="line-modified">2300           if (in-&gt;in(0)-&gt;is_Region()) {</span>
<span class="line-added">2301             Node* r = in-&gt;in(0);</span>
<span class="line-added">2302             for (uint j = 1; j &lt; r-&gt;req(); j++) {</span>
<span class="line-added">2303               assert(r-&gt;in(j)-&gt;Opcode() != Op_NeverBranch, &quot;&quot;);</span>
<span class="line-added">2304             }</span>
<span class="line-added">2305           } else {</span>
2306             Node* proj = in-&gt;in(0);
2307             assert(proj-&gt;is_Proj(), &quot;&quot;);
2308             Node* in = proj-&gt;in(0);
2309             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
2310             if (in-&gt;is_CallStaticJava()) {
2311               mem = in-&gt;in(TypeFunc::Memory);
2312             } else if (in-&gt;Opcode() == Op_Catch) {
2313               Node* call = in-&gt;in(0)-&gt;in(0);
2314               assert(call-&gt;is_Call(), &quot;&quot;);
2315               mem = call-&gt;in(TypeFunc::Memory);
<span class="line-added">2316             } else if (in-&gt;Opcode() == Op_NeverBranch) {</span>
<span class="line-added">2317               Node* head = in-&gt;in(0);</span>
<span class="line-added">2318               assert(head-&gt;is_Region() &amp;&amp; head-&gt;req() == 3, &quot;unexpected infinite loop graph shape&quot;);</span>
<span class="line-added">2319               assert(_phase-&gt;is_dominator(head, head-&gt;in(1)) || _phase-&gt;is_dominator(head, head-&gt;in(2)), &quot;no back branch?&quot;);</span>
<span class="line-added">2320               Node* tail = _phase-&gt;is_dominator(head, head-&gt;in(1)) ? head-&gt;in(1) : head-&gt;in(2);</span>
<span class="line-added">2321               Node* c = tail;</span>
<span class="line-added">2322               while (c != head) {</span>
<span class="line-added">2323                 if (c-&gt;is_SafePoint() &amp;&amp; !c-&gt;is_CallLeaf()) {</span>
<span class="line-added">2324                   mem = c-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">2325                 }</span>
<span class="line-added">2326                 c = _phase-&gt;idom(c);</span>
<span class="line-added">2327               }</span>
<span class="line-added">2328               assert(mem != NULL, &quot;should have found safepoint&quot;);</span>
<span class="line-added">2329 </span>
<span class="line-added">2330               Node* phi_mem = NULL;</span>
<span class="line-added">2331               for (DUIterator_Fast jmax, j = head-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added">2332                 Node* u = head-&gt;fast_out(j);</span>
<span class="line-added">2333                 if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-added">2334                   if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {</span>
<span class="line-added">2335                     assert(phi_mem == NULL || phi_mem-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);</span>
<span class="line-added">2336                     phi_mem = u;</span>
<span class="line-added">2337                   } else if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added">2338                     assert(phi_mem == NULL || _phase-&gt;C-&gt;get_alias_index(phi_mem-&gt;adr_type()) == _alias, &quot;&quot;);</span>
<span class="line-added">2339                     if (phi_mem == NULL) {</span>
<span class="line-added">2340                       phi_mem = u;</span>
<span class="line-added">2341                     }</span>
<span class="line-added">2342                   }</span>
<span class="line-added">2343                 }</span>
<span class="line-added">2344               }</span>
<span class="line-added">2345               if (phi_mem != NULL) {</span>
<span class="line-added">2346                 mem = phi_mem;</span>
<span class="line-added">2347               }</span>
2348             }
2349           }
2350         } else {
2351 #ifdef ASSERT
2352           n-&gt;dump();
2353           in-&gt;dump();
2354 #endif
2355           ShouldNotReachHere();
2356         }
2357       } else {
2358         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2359         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
2360         mem = n-&gt;in(i);
2361       }
2362       i++;
2363       stack.set_index(i);
2364       if (mem == NULL) {
2365         continue;
2366       }
2367       for (;;) {
2368         if (visited.test_set(mem-&gt;_idx) || mem-&gt;is_Start()) {
2369           break;
2370         }
2371         if (mem-&gt;is_Phi()) {
2372           stack.push(mem, 2);
2373           mem = mem-&gt;in(1);
2374         } else if (mem-&gt;is_Proj()) {
2375           stack.push(mem, mem-&gt;req());
2376           mem = mem-&gt;in(0);
2377         } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
2378           mem = mem-&gt;in(TypeFunc::Memory);
2379         } else if (mem-&gt;is_MergeMem()) {
2380           MergeMemNode* mm = mem-&gt;as_MergeMem();
2381           mem = mm-&gt;memory_at(_alias);
2382         } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
2383           assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2384           stack.push(mem, mem-&gt;req());
2385           mem = mem-&gt;in(MemNode::Memory);






2386         } else {
2387 #ifdef ASSERT
2388           mem-&gt;dump();
2389 #endif
2390           ShouldNotReachHere();
2391         }
2392       }
2393     } else {
2394       if (n-&gt;is_Phi()) {
2395         // Nothing
2396       } else if (!n-&gt;is_Root()) {
2397         Node* c = get_ctrl(n);
2398         _memory_nodes.map(c-&gt;_idx, n);
2399       }
2400       stack.pop();
2401     }
2402   } while(stack.is_nonempty());
2403 
2404   // Iterate over CFG nodes in rpo and propagate memory state to
2405   // compute memory state at regions, creating new phis if needed.
2406   Node_List rpo_list;
<span class="line-modified">2407   visited.clear();</span>
2408   _phase-&gt;rpo(_phase-&gt;C-&gt;root(), stack, visited, rpo_list);
2409   Node* root = rpo_list.pop();
2410   assert(root == _phase-&gt;C-&gt;root(), &quot;&quot;);
2411 
2412   const bool trace = false;
2413 #ifdef ASSERT
2414   if (trace) {
2415     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2416       Node* c = rpo_list.at(i);
2417       if (_memory_nodes[c-&gt;_idx] != NULL) {
2418         tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump();
2419       }
2420     }
2421   }
2422 #endif
2423   uint last = _phase-&gt;C-&gt;unique();
2424 
2425 #ifdef ASSERT
2426   uint8_t max_depth = 0;
2427   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
2428     IdealLoopTree* lpt = iter.current();
2429     max_depth = MAX2(max_depth, lpt-&gt;_nest);
2430   }
2431 #endif
2432 
2433   bool progress = true;
2434   int iteration = 0;
2435   Node_List dead_phis;
2436   while (progress) {
2437     progress = false;
2438     iteration++;
<span class="line-modified">2439     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;&quot;);</span>
2440     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
2441     IdealLoopTree* last_updated_ilt = NULL;
2442     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
2443       Node* c = rpo_list.at(i);
2444 
2445       Node* prev_mem = _memory_nodes[c-&gt;_idx];
2446       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
2447         Node* prev_region = regions[c-&gt;_idx];
2448         Node* unique = NULL;
2449         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
2450           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
2451           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
2452           if (m != NULL) {
2453             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
2454               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);
2455               // continue
2456             } else if (unique == NULL) {
2457               unique = m;
2458             } else if (m == unique) {
2459               // continue
</pre>
<hr />
<pre>
2587   else {
2588     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
2589     return n;
2590   }
2591 }
2592 
2593 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
2594   return m != NULL &amp;&amp; get_ctrl(m) == c;
2595 }
2596 
2597 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
2598   assert(n == NULL || _phase-&gt;ctrl_or_self(n) == ctrl, &quot;&quot;);
2599   Node* mem = _memory_nodes[ctrl-&gt;_idx];
2600   Node* c = ctrl;
2601   while (!mem_is_valid(mem, c) &amp;&amp;
2602          (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem))) {
2603     c = _phase-&gt;idom(c);
2604     mem = _memory_nodes[c-&gt;_idx];
2605   }
2606   if (n != NULL &amp;&amp; mem_is_valid(mem, c)) {
<span class="line-modified">2607     while (!ShenandoahBarrierC2Support::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {</span>
2608       mem = next_mem(mem, _alias);
2609     }
2610     if (mem-&gt;is_MergeMem()) {
2611       mem = mem-&gt;as_MergeMem()-&gt;memory_at(_alias);
2612     }
2613     if (!mem_is_valid(mem, c)) {
2614       do {
2615         c = _phase-&gt;idom(c);
2616         mem = _memory_nodes[c-&gt;_idx];
2617       } while (!mem_is_valid(mem, c) &amp;&amp;
2618                (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem)));
2619     }
2620   }
2621   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2622   return mem;
2623 }
2624 
2625 bool MemoryGraphFixer::has_mem_phi(Node* region) const {
2626   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
2627     Node* use = region-&gt;fast_out(i);
</pre>
<hr />
<pre>
2633   return false;
2634 }
2635 
2636 void MemoryGraphFixer::fix_mem(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl, Node* new_mem, Unique_Node_List&amp; uses) {
2637   assert(_phase-&gt;ctrl_or_self(new_mem) == new_ctrl, &quot;&quot;);
2638   const bool trace = false;
2639   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ control is&quot;); ctrl-&gt;dump(); });
2640   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ mem is&quot;); mem-&gt;dump(); });
2641   GrowableArray&lt;Node*&gt; phis;
2642   if (mem_for_ctrl != mem) {
2643     Node* old = mem_for_ctrl;
2644     Node* prev = NULL;
2645     while (old != mem) {
2646       prev = old;
2647       if (old-&gt;is_Store() || old-&gt;is_ClearArray() || old-&gt;is_LoadStore()) {
2648         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2649         old = old-&gt;in(MemNode::Memory);
2650       } else if (old-&gt;Opcode() == Op_SCMemProj) {
2651         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2652         old = old-&gt;in(0);






2653       } else {
2654         ShouldNotReachHere();
2655       }
2656     }
2657     assert(prev != NULL, &quot;&quot;);
2658     if (new_ctrl != ctrl) {
2659       _memory_nodes.map(ctrl-&gt;_idx, mem);
2660       _memory_nodes.map(new_ctrl-&gt;_idx, mem_for_ctrl);
2661     }
<span class="line-modified">2662     uint input = (uint)MemNode::Memory;</span>
2663     _phase-&gt;igvn().replace_input_of(prev, input, new_mem);
2664   } else {
2665     uses.clear();
2666     _memory_nodes.map(new_ctrl-&gt;_idx, new_mem);
2667     uses.push(new_ctrl);
2668     for(uint next = 0; next &lt; uses.size(); next++ ) {
2669       Node *n = uses.at(next);
2670       assert(n-&gt;is_CFG(), &quot;&quot;);
2671       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
2672       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2673         Node* u = n-&gt;fast_out(i);
2674         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
2675           Node* m = _memory_nodes[u-&gt;_idx];
2676           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
2677               !has_mem_phi(u) &amp;&amp;
2678               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
2679             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
2680             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
2681 
2682             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
2683               bool push = true;
2684               bool create_phi = true;
2685               if (_phase-&gt;is_dominator(new_ctrl, u)) {
2686                 create_phi = false;
2687               } else if (!_phase-&gt;C-&gt;has_irreducible_loop()) {
2688                 IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);
2689                 bool do_check = true;
2690                 IdealLoopTree* l = loop;
2691                 create_phi = false;
2692                 while (l != _phase-&gt;ltree_root()) {
<span class="line-modified">2693                   Node* head = l-&gt;_head;</span>
<span class="line-added">2694                   if (head-&gt;in(0) == NULL) {</span>
<span class="line-added">2695                     head = _phase-&gt;get_ctrl(head);</span>
<span class="line-added">2696                   }</span>
<span class="line-added">2697                   if (_phase-&gt;is_dominator(head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), head)) {</span>
2698                     create_phi = true;
2699                     do_check = false;
2700                     break;
2701                   }
2702                   l = l-&gt;_parent;
2703                 }
2704 
2705                 if (do_check) {
2706                   assert(!create_phi, &quot;&quot;);
2707                   IdealLoopTree* u_loop = _phase-&gt;get_loop(u);
2708                   if (u_loop != _phase-&gt;ltree_root() &amp;&amp; u_loop-&gt;is_member(loop)) {
2709                     Node* c = ctrl;
2710                     while (!_phase-&gt;is_dominator(c, u_loop-&gt;tail())) {
2711                       c = _phase-&gt;idom(c);
2712                     }
2713                     if (!_phase-&gt;is_dominator(c, u)) {
2714                       do_check = false;
2715                     }
2716                   }
2717                 }
2718 
2719                 if (do_check &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), new_ctrl)) {
2720                   create_phi = true;
2721                 }
2722               }
2723               if (create_phi) {
2724                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
2725                 _phase-&gt;register_new_node(phi, u);
2726                 phis.push(phi);
2727                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
2728                 if (!mem_is_valid(m, u)) {
2729                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
2730                   _memory_nodes.map(u-&gt;_idx, phi);
2731                 } else {
2732                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
2733                   for (;;) {
<span class="line-modified">2734                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj(), &quot;&quot;);</span>
2735                     Node* next = NULL;
2736                     if (m-&gt;is_Proj()) {
2737                       next = m-&gt;in(0);
<span class="line-modified">2738                     } else {</span>
<span class="line-modified">2739                       assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);</span>

2740                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
2741                       next = m-&gt;in(MemNode::Memory);




2742                     }
2743                     if (_phase-&gt;get_ctrl(next) != u) {
2744                       break;
2745                     }
2746                     if (next-&gt;is_MergeMem()) {
2747                       assert(_phase-&gt;get_ctrl(next-&gt;as_MergeMem()-&gt;memory_at(_alias)) != u, &quot;&quot;);
2748                       break;
2749                     }
2750                     if (next-&gt;is_Phi()) {
2751                       assert(next-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; next-&gt;in(0) == u, &quot;&quot;);
2752                       break;
2753                     }
2754                     m = next;
2755                   }
2756 
2757                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting to phi&quot;); m-&gt;dump(); });
<span class="line-modified">2758                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore(), &quot;&quot;);</span>
<span class="line-modified">2759                   uint input = (uint)MemNode::Memory;</span>
2760                   _phase-&gt;igvn().replace_input_of(m, input, phi);
2761                   push = false;
2762                 }
2763               } else {
2764                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ skipping region&quot;); u-&gt;dump(); });
2765               }
2766               if (push) {
2767                 uses.push(u);
2768               }
2769             }
2770           } else if (!mem_is_valid(m, u) &amp;&amp;
2771                      !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1)) {
2772             uses.push(u);
2773           }
2774         }
2775       }
2776     }
2777     for (int i = 0; i &lt; phis.length(); i++) {
2778       Node* n = phis.at(i);
2779       Node* r = n-&gt;in(0);
2780       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi&quot;); n-&gt;dump(); });
2781       for (uint j = 1; j &lt; n-&gt;req(); j++) {
2782         Node* m = find_mem(r-&gt;in(j), NULL);
2783         _phase-&gt;igvn().replace_input_of(n, j, m);
2784         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi: %d&quot;, j); m-&gt;dump(); });
2785       }
2786     }
2787   }
2788   uint last = _phase-&gt;C-&gt;unique();
2789   MergeMemNode* mm = NULL;
2790   int alias = _alias;
2791   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ raw mem is&quot;); mem-&gt;dump(); });
<span class="line-added">2792   // Process loads first to not miss an anti-dependency: if the memory</span>
<span class="line-added">2793   // edge of a store is updated before a load is processed then an</span>
<span class="line-added">2794   // anti-dependency may be missed.</span>
<span class="line-added">2795   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {</span>
<span class="line-added">2796     Node* u = mem-&gt;out(i);</span>
<span class="line-added">2797     if (u-&gt;_idx &lt; last &amp;&amp; u-&gt;is_Load() &amp;&amp; _phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {</span>
<span class="line-added">2798       Node* m = find_mem(_phase-&gt;get_ctrl(u), u);</span>
<span class="line-added">2799       if (m != mem) {</span>
<span class="line-added">2800         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });</span>
<span class="line-added">2801         _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);</span>
<span class="line-added">2802         --i;</span>
<span class="line-added">2803       }</span>
<span class="line-added">2804     }</span>
<span class="line-added">2805   }</span>
2806   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
2807     Node* u = mem-&gt;out(i);
2808     if (u-&gt;_idx &lt; last) {
2809       if (u-&gt;is_Mem()) {
2810         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
2811           Node* m = find_mem(_phase-&gt;get_ctrl(u), u);
2812           if (m != mem) {
2813             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
2814             _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);
2815             --i;
2816           }
2817         }
2818       } else if (u-&gt;is_MergeMem()) {
2819         MergeMemNode* u_mm = u-&gt;as_MergeMem();
2820         if (u_mm-&gt;memory_at(alias) == mem) {
2821           MergeMemNode* newmm = NULL;
2822           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2823             Node* uu = u-&gt;fast_out(j);
2824             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
2825             if (uu-&gt;is_Phi()) {
</pre>
<hr />
<pre>
2979   if (phi-&gt;adr_type() == TypePtr::BOTTOM) {
2980     Node* region = phi-&gt;in(0);
2981     for (DUIterator_Fast jmax, j = region-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2982       Node* uu = region-&gt;fast_out(j);
2983       if (uu-&gt;is_Phi() &amp;&amp; uu != phi &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY &amp;&amp; _phase-&gt;C-&gt;get_alias_index(uu-&gt;adr_type()) == _alias) {
2984         return false;
2985       }
2986     }
2987     return true;
2988   }
2989   return _phase-&gt;C-&gt;get_alias_index(phi-&gt;adr_type()) == _alias;
2990 }
2991 
2992 void MemoryGraphFixer::fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const {
2993   uint last = _phase-&gt; C-&gt;unique();
2994   MergeMemNode* mm = NULL;
2995   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
2996   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
2997     Node* u = mem-&gt;out(i);
2998     if (u != replacement &amp;&amp; u-&gt;_idx &lt; last) {
<span class="line-modified">2999       if (u-&gt;is_MergeMem()) {</span>













3000         MergeMemNode* u_mm = u-&gt;as_MergeMem();
3001         if (u_mm-&gt;memory_at(_alias) == mem) {
3002           MergeMemNode* newmm = NULL;
3003           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3004             Node* uu = u-&gt;fast_out(j);
3005             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
3006             if (uu-&gt;is_Phi()) {
3007               if (should_process_phi(uu)) {
3008                 Node* region = uu-&gt;in(0);
3009                 int nb = 0;
3010                 for (uint k = 1; k &lt; uu-&gt;req(); k++) {
3011                   if (uu-&gt;in(k) == u &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(k))) {
3012                     if (newmm == NULL) {
3013                       newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
3014                     }
3015                     if (newmm != u) {
3016                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
3017                       nb++;
3018                       --jmax;
3019                     }
3020                   }
3021                 }
3022                 if (nb &gt; 0) {
3023                   --j;
3024                 }
3025               }
3026             } else {
<span class="line-modified">3027               if (rep_ctrl != uu &amp;&amp; ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {</span>
3028                 if (newmm == NULL) {
3029                   newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
3030                 }
3031                 if (newmm != u) {
3032                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
3033                   --j, --jmax;
3034                 }
3035               }
3036             }
3037           }
3038         }
3039       } else if (u-&gt;is_Phi()) {
3040         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
3041         Node* region = u-&gt;in(0);
3042         if (should_process_phi(u)) {
3043           bool replaced = false;
3044           for (uint j = 1; j &lt; u-&gt;req(); j++) {
3045             if (u-&gt;in(j) == mem &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {
3046               Node* nnew = rep_proj;
3047               if (u-&gt;adr_type() == TypePtr::BOTTOM) {
3048                 if (mm == NULL) {
3049                   mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
3050                 }
3051                 nnew = mm;
3052               }
3053               _phase-&gt;igvn().replace_input_of(u, j, nnew);
3054               replaced = true;
3055             }
3056           }
3057           if (replaced) {
3058             --i;
3059           }
3060 
3061         }
3062       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
3063                  u-&gt;adr_type() == NULL) {
3064         assert(u-&gt;adr_type() != NULL ||
3065                u-&gt;Opcode() == Op_Rethrow ||
3066                u-&gt;Opcode() == Op_Return ||
3067                u-&gt;Opcode() == Op_SafePoint ||
<span class="line-added">3068                u-&gt;Opcode() == Op_StoreIConditional ||</span>
<span class="line-added">3069                u-&gt;Opcode() == Op_StoreLConditional ||</span>
3070                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
3071                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
<span class="line-modified">3072                u-&gt;Opcode() == Op_CallLeaf, &quot;%s&quot;, u-&gt;Name());</span>
<span class="line-modified">3073         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
3074           if (mm == NULL) {
3075             mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
3076           }
3077           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
3078           --i;
3079         }
3080       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
<span class="line-modified">3081         if (ShenandoahBarrierC2Support::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
3082           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);
3083           --i;
3084         }
3085       }
3086     }
3087   }
3088 }
3089 
<span class="line-modified">3090 ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool native)</span>
<span class="line-modified">3091 : Node(ctrl, obj), _native(native) {</span>
<span class="line-modified">3092   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_load_reference_barrier(this);</span>
<span class="line-modified">3093 }</span>
<span class="line-modified">3094 </span>
<span class="line-modified">3095 bool ShenandoahLoadReferenceBarrierNode::is_native() const {</span>
<span class="line-added">3096   return _native;</span>
<span class="line-added">3097 }</span>
<span class="line-added">3098 </span>
<span class="line-added">3099 uint ShenandoahLoadReferenceBarrierNode::size_of() const {</span>
<span class="line-added">3100   return sizeof(*this);</span>
<span class="line-added">3101 }</span>
<span class="line-added">3102 </span>
<span class="line-added">3103 uint ShenandoahLoadReferenceBarrierNode::hash() const {</span>
<span class="line-added">3104   return Node::hash() + (_native ? 1 : 0);</span>
<span class="line-added">3105 }</span>
<span class="line-added">3106 </span>
<span class="line-added">3107 bool ShenandoahLoadReferenceBarrierNode::cmp( const Node &amp;n ) const {</span>
<span class="line-added">3108   return Node::cmp(n) &amp;&amp; n.Opcode() == Op_ShenandoahLoadReferenceBarrier &amp;&amp;</span>
<span class="line-added">3109          _native == ((const ShenandoahLoadReferenceBarrierNode&amp;)n)._native;</span>
<span class="line-added">3110 }</span>
<span class="line-added">3111 </span>
<span class="line-added">3112 const Type* ShenandoahLoadReferenceBarrierNode::bottom_type() const {</span>
<span class="line-added">3113   if (in(ValueIn) == NULL || in(ValueIn)-&gt;is_top()) {</span>
<span class="line-added">3114     return Type::TOP;</span>
<span class="line-added">3115   }</span>
<span class="line-added">3116   const Type* t = in(ValueIn)-&gt;bottom_type();</span>
<span class="line-added">3117   if (t == TypePtr::NULL_PTR) {</span>
<span class="line-added">3118     return t;</span>
<span class="line-added">3119   }</span>
<span class="line-added">3120   return t-&gt;is_oopptr();</span>
<span class="line-added">3121 }</span>
<span class="line-added">3122 </span>
<span class="line-added">3123 const Type* ShenandoahLoadReferenceBarrierNode::Value(PhaseGVN* phase) const {</span>
<span class="line-added">3124   // Either input is TOP ==&gt; the result is TOP</span>
<span class="line-added">3125   const Type *t2 = phase-&gt;type(in(ValueIn));</span>
<span class="line-added">3126   if( t2 == Type::TOP ) return Type::TOP;</span>
<span class="line-added">3127 </span>
<span class="line-added">3128   if (t2 == TypePtr::NULL_PTR) {</span>
<span class="line-added">3129     return t2;</span>
<span class="line-added">3130   }</span>
<span class="line-added">3131 </span>
<span class="line-added">3132   const Type* type = t2-&gt;is_oopptr();</span>
<span class="line-added">3133   return type;</span>
<span class="line-added">3134 }</span>
<span class="line-added">3135 </span>
<span class="line-added">3136 Node* ShenandoahLoadReferenceBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="line-added">3137   Node* value = in(ValueIn);</span>
<span class="line-added">3138   if (!needs_barrier(phase, value)) {</span>
<span class="line-added">3139     return value;</span>
<span class="line-added">3140   }</span>
<span class="line-added">3141   return this;</span>
<span class="line-added">3142 }</span>
<span class="line-added">3143 </span>
<span class="line-added">3144 bool ShenandoahLoadReferenceBarrierNode::needs_barrier(PhaseGVN* phase, Node* n) {</span>
<span class="line-added">3145   Unique_Node_List visited;</span>
<span class="line-added">3146   return needs_barrier_impl(phase, n, visited);</span>
<span class="line-added">3147 }</span>
<span class="line-added">3148 </span>
<span class="line-added">3149 bool ShenandoahLoadReferenceBarrierNode::needs_barrier_impl(PhaseGVN* phase, Node* n, Unique_Node_List &amp;visited) {</span>
<span class="line-added">3150   if (n == NULL) return false;</span>
<span class="line-added">3151   if (visited.member(n)) {</span>
<span class="line-added">3152     return false; // Been there.</span>
<span class="line-added">3153   }</span>
<span class="line-added">3154   visited.push(n);</span>
<span class="line-added">3155 </span>
<span class="line-added">3156   if (n-&gt;is_Allocate()) {</span>
<span class="line-added">3157     // tty-&gt;print_cr(&quot;optimize barrier on alloc&quot;);</span>
<span class="line-added">3158     return false;</span>
<span class="line-added">3159   }</span>
<span class="line-added">3160   if (n-&gt;is_Call()) {</span>
<span class="line-added">3161     // tty-&gt;print_cr(&quot;optimize barrier on call&quot;);</span>
<span class="line-added">3162     return false;</span>
<span class="line-added">3163   }</span>
<span class="line-added">3164 </span>
<span class="line-added">3165   const Type* type = phase-&gt;type(n);</span>
<span class="line-added">3166   if (type == Type::TOP) {</span>
<span class="line-added">3167     return false;</span>
<span class="line-added">3168   }</span>
<span class="line-added">3169   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-added">3170     // tty-&gt;print_cr(&quot;optimize barrier on null&quot;);</span>
<span class="line-added">3171     return false;</span>
<span class="line-added">3172   }</span>
<span class="line-added">3173   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {</span>
<span class="line-added">3174     // tty-&gt;print_cr(&quot;optimize barrier on constant&quot;);</span>
<span class="line-added">3175     return false;</span>
<span class="line-added">3176   }</span>
<span class="line-added">3177 </span>
<span class="line-added">3178   switch (n-&gt;Opcode()) {</span>
<span class="line-added">3179     case Op_AddP:</span>
<span class="line-added">3180       return true; // TODO: Can refine?</span>
<span class="line-added">3181     case Op_LoadP:</span>
<span class="line-added">3182     case Op_ShenandoahCompareAndExchangeN:</span>
<span class="line-added">3183     case Op_ShenandoahCompareAndExchangeP:</span>
<span class="line-added">3184     case Op_CompareAndExchangeN:</span>
<span class="line-added">3185     case Op_CompareAndExchangeP:</span>
<span class="line-added">3186     case Op_GetAndSetN:</span>
<span class="line-added">3187     case Op_GetAndSetP:</span>
<span class="line-added">3188       return true;</span>
<span class="line-added">3189     case Op_Phi: {</span>
<span class="line-added">3190       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added">3191         if (needs_barrier_impl(phase, n-&gt;in(i), visited)) return true;</span>
<span class="line-added">3192       }</span>
<span class="line-added">3193       return false;</span>
<span class="line-added">3194     }</span>
<span class="line-added">3195     case Op_CheckCastPP:</span>
<span class="line-added">3196     case Op_CastPP:</span>
<span class="line-added">3197       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="line-added">3198     case Op_Proj:</span>
<span class="line-added">3199       return needs_barrier_impl(phase, n-&gt;in(0), visited);</span>
<span class="line-added">3200     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-added">3201       // tty-&gt;print_cr(&quot;optimize barrier on barrier&quot;);</span>
<span class="line-added">3202       return false;</span>
<span class="line-added">3203     case Op_Parm:</span>
<span class="line-added">3204       // tty-&gt;print_cr(&quot;optimize barrier on input arg&quot;);</span>
<span class="line-added">3205       return false;</span>
<span class="line-added">3206     case Op_DecodeN:</span>
<span class="line-added">3207     case Op_EncodeP:</span>
<span class="line-added">3208       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="line-added">3209     case Op_LoadN:</span>
<span class="line-added">3210       return true;</span>
<span class="line-added">3211     case Op_CMoveN:</span>
<span class="line-added">3212     case Op_CMoveP:</span>
<span class="line-added">3213       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||</span>
<span class="line-added">3214              needs_barrier_impl(phase, n-&gt;in(3), visited);</span>
<span class="line-added">3215     case Op_ShenandoahEnqueueBarrier:</span>
<span class="line-added">3216       return needs_barrier_impl(phase, n-&gt;in(1), visited);</span>
<span class="line-added">3217     case Op_CreateEx:</span>
<span class="line-added">3218       return false;</span>
<span class="line-added">3219     default:</span>
<span class="line-added">3220       break;</span>
<span class="line-added">3221   }</span>
<span class="line-added">3222 #ifdef ASSERT</span>
<span class="line-added">3223   tty-&gt;print(&quot;need barrier on?: &quot;);</span>
<span class="line-added">3224   tty-&gt;print_cr(&quot;ins:&quot;);</span>
<span class="line-added">3225   n-&gt;dump(2);</span>
<span class="line-added">3226   tty-&gt;print_cr(&quot;outs:&quot;);</span>
<span class="line-added">3227   n-&gt;dump(-2);</span>
<span class="line-added">3228   ShouldNotReachHere();</span>
<span class="line-added">3229 #endif</span>
<span class="line-added">3230   return true;</span>
<span class="line-added">3231 }</span>
<span class="line-added">3232 </span>
<span class="line-added">3233 ShenandoahLoadReferenceBarrierNode::Strength ShenandoahLoadReferenceBarrierNode::get_barrier_strength() {</span>
<span class="line-added">3234   Unique_Node_List visited;</span>
<span class="line-added">3235   Node_Stack stack(0);</span>
<span class="line-added">3236   stack.push(this, 0);</span>
<span class="line-added">3237 </span>
<span class="line-added">3238   // Look for strongest strength: go over nodes looking for STRONG ones.</span>
<span class="line-added">3239   // Stop once we encountered STRONG. Otherwise, walk until we ran out of nodes,</span>
<span class="line-added">3240   // and then the overall strength is NONE.</span>
<span class="line-added">3241   Strength strength = NONE;</span>
<span class="line-added">3242   while (strength != STRONG &amp;&amp; stack.size() &gt; 0) {</span>
<span class="line-added">3243     Node* n = stack.node();</span>
<span class="line-added">3244     if (visited.member(n)) {</span>
<span class="line-added">3245       stack.pop();</span>
<span class="line-added">3246       continue;</span>
<span class="line-added">3247     }</span>
<span class="line-added">3248     visited.push(n);</span>
<span class="line-added">3249     bool visit_users = false;</span>
<span class="line-added">3250     switch (n-&gt;Opcode()) {</span>
<span class="line-added">3251       case Op_CallStaticJava:</span>
<span class="line-added">3252       case Op_CallDynamicJava:</span>
<span class="line-added">3253       case Op_CallLeaf:</span>
<span class="line-added">3254       case Op_CallLeafNoFP:</span>
<span class="line-added">3255       case Op_CompareAndSwapL:</span>
<span class="line-added">3256       case Op_CompareAndSwapI:</span>
<span class="line-added">3257       case Op_CompareAndSwapB:</span>
<span class="line-added">3258       case Op_CompareAndSwapS:</span>
<span class="line-added">3259       case Op_CompareAndSwapN:</span>
<span class="line-added">3260       case Op_CompareAndSwapP:</span>
<span class="line-added">3261       case Op_CompareAndExchangeL:</span>
<span class="line-added">3262       case Op_CompareAndExchangeI:</span>
<span class="line-added">3263       case Op_CompareAndExchangeB:</span>
<span class="line-added">3264       case Op_CompareAndExchangeS:</span>
<span class="line-added">3265       case Op_CompareAndExchangeN:</span>
<span class="line-added">3266       case Op_CompareAndExchangeP:</span>
<span class="line-added">3267       case Op_WeakCompareAndSwapL:</span>
<span class="line-added">3268       case Op_WeakCompareAndSwapI:</span>
<span class="line-added">3269       case Op_WeakCompareAndSwapB:</span>
<span class="line-added">3270       case Op_WeakCompareAndSwapS:</span>
<span class="line-added">3271       case Op_WeakCompareAndSwapN:</span>
<span class="line-added">3272       case Op_WeakCompareAndSwapP:</span>
<span class="line-added">3273       case Op_ShenandoahCompareAndSwapN:</span>
<span class="line-added">3274       case Op_ShenandoahCompareAndSwapP:</span>
<span class="line-added">3275       case Op_ShenandoahWeakCompareAndSwapN:</span>
<span class="line-added">3276       case Op_ShenandoahWeakCompareAndSwapP:</span>
<span class="line-added">3277       case Op_ShenandoahCompareAndExchangeN:</span>
<span class="line-added">3278       case Op_ShenandoahCompareAndExchangeP:</span>
<span class="line-added">3279       case Op_GetAndSetL:</span>
<span class="line-added">3280       case Op_GetAndSetI:</span>
<span class="line-added">3281       case Op_GetAndSetB:</span>
<span class="line-added">3282       case Op_GetAndSetS:</span>
<span class="line-added">3283       case Op_GetAndSetP:</span>
<span class="line-added">3284       case Op_GetAndSetN:</span>
<span class="line-added">3285       case Op_GetAndAddL:</span>
<span class="line-added">3286       case Op_GetAndAddI:</span>
<span class="line-added">3287       case Op_GetAndAddB:</span>
<span class="line-added">3288       case Op_GetAndAddS:</span>
<span class="line-added">3289       case Op_ShenandoahEnqueueBarrier:</span>
<span class="line-added">3290       case Op_FastLock:</span>
<span class="line-added">3291       case Op_FastUnlock:</span>
<span class="line-added">3292       case Op_Rethrow:</span>
<span class="line-added">3293       case Op_Return:</span>
<span class="line-added">3294       case Op_StoreB:</span>
<span class="line-added">3295       case Op_StoreC:</span>
<span class="line-added">3296       case Op_StoreD:</span>
<span class="line-added">3297       case Op_StoreF:</span>
<span class="line-added">3298       case Op_StoreL:</span>
<span class="line-added">3299       case Op_StoreLConditional:</span>
<span class="line-added">3300       case Op_StoreI:</span>
<span class="line-added">3301       case Op_StoreIConditional:</span>
<span class="line-added">3302       case Op_StoreN:</span>
<span class="line-added">3303       case Op_StoreP:</span>
<span class="line-added">3304       case Op_StoreVector:</span>
<span class="line-added">3305       case Op_StrInflatedCopy:</span>
<span class="line-added">3306       case Op_StrCompressedCopy:</span>
<span class="line-added">3307       case Op_EncodeP:</span>
<span class="line-added">3308       case Op_CastP2X:</span>
<span class="line-added">3309       case Op_SafePoint:</span>
<span class="line-added">3310       case Op_EncodeISOArray:</span>
<span class="line-added">3311       case Op_AryEq:</span>
<span class="line-added">3312       case Op_StrEquals:</span>
<span class="line-added">3313       case Op_StrComp:</span>
<span class="line-added">3314       case Op_StrIndexOf:</span>
<span class="line-added">3315       case Op_StrIndexOfChar:</span>
<span class="line-added">3316       case Op_HasNegatives:</span>
<span class="line-added">3317         // Known to require barriers</span>
<span class="line-added">3318         strength = STRONG;</span>
<span class="line-added">3319         break;</span>
<span class="line-added">3320       case Op_CmpP: {</span>
<span class="line-added">3321         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||</span>
<span class="line-added">3322             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-added">3323           // One of the sides is known null, no need for barrier.</span>
<span class="line-added">3324         } else {</span>
<span class="line-added">3325           strength = STRONG;</span>
<span class="line-added">3326         }</span>
<span class="line-added">3327         break;</span>
<span class="line-added">3328       }</span>
<span class="line-added">3329       case Op_LoadB:</span>
<span class="line-added">3330       case Op_LoadUB:</span>
<span class="line-added">3331       case Op_LoadUS:</span>
<span class="line-added">3332       case Op_LoadD:</span>
<span class="line-added">3333       case Op_LoadF:</span>
<span class="line-added">3334       case Op_LoadL:</span>
<span class="line-added">3335       case Op_LoadI:</span>
<span class="line-added">3336       case Op_LoadS:</span>
<span class="line-added">3337       case Op_LoadN:</span>
<span class="line-added">3338       case Op_LoadP:</span>
<span class="line-added">3339       case Op_LoadVector: {</span>
<span class="line-added">3340         const TypePtr* adr_type = n-&gt;adr_type();</span>
<span class="line-added">3341         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);</span>
<span class="line-added">3342         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);</span>
<span class="line-added">3343         ciField* field = alias_type-&gt;field();</span>
<span class="line-added">3344         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();</span>
<span class="line-added">3345         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();</span>
<span class="line-added">3346 </span>
<span class="line-added">3347         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {</span>
<span class="line-added">3348           // Loading the constant does not require barriers: it should be handled</span>
<span class="line-added">3349           // as part of GC roots already.</span>
<span class="line-added">3350         } else {</span>
<span class="line-added">3351           strength = STRONG;</span>
<span class="line-added">3352         }</span>
<span class="line-added">3353         break;</span>
<span class="line-added">3354       }</span>
<span class="line-added">3355       case Op_Conv2B:</span>
<span class="line-added">3356       case Op_LoadRange:</span>
<span class="line-added">3357       case Op_LoadKlass:</span>
<span class="line-added">3358       case Op_LoadNKlass:</span>
<span class="line-added">3359         // Do not require barriers</span>
<span class="line-added">3360         break;</span>
<span class="line-added">3361       case Op_AddP:</span>
<span class="line-added">3362       case Op_CheckCastPP:</span>
<span class="line-added">3363       case Op_CastPP:</span>
<span class="line-added">3364       case Op_CMoveP:</span>
<span class="line-added">3365       case Op_Phi:</span>
<span class="line-added">3366       case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-added">3367         // Whether or not these need the barriers depends on their users</span>
<span class="line-added">3368         visit_users = true;</span>
<span class="line-added">3369         break;</span>
<span class="line-added">3370       default: {</span>
<span class="line-added">3371 #ifdef ASSERT</span>
<span class="line-added">3372         fatal(&quot;Unknown node in get_barrier_strength: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
<span class="line-added">3373 #else</span>
<span class="line-added">3374         // Default to strong: better to have excess barriers, rather than miss some.</span>
<span class="line-added">3375         strength = STRONG;</span>
<span class="line-added">3376 #endif</span>
<span class="line-added">3377       }</span>
<span class="line-added">3378     }</span>
<span class="line-added">3379 </span>
<span class="line-added">3380     stack.pop();</span>
<span class="line-added">3381     if (visit_users) {</span>
<span class="line-added">3382       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">3383         Node* user = n-&gt;fast_out(i);</span>
<span class="line-added">3384         if (user != NULL) {</span>
<span class="line-added">3385           stack.push(user, 0);</span>
<span class="line-added">3386         }</span>
<span class="line-added">3387       }</span>
<span class="line-added">3388     }</span>
<span class="line-added">3389   }</span>
<span class="line-added">3390   return strength;</span>
<span class="line-added">3391 }</span>
<span class="line-added">3392 </span>
<span class="line-added">3393 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="line-added">3394   Node* val = in(ValueIn);</span>
<span class="line-added">3395 </span>
<span class="line-added">3396   const Type* val_t = igvn.type(val);</span>
<span class="line-added">3397 </span>
<span class="line-added">3398   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="line-added">3399       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-added">3400       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-added">3401       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-added">3402       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-added">3403       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-added">3404       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-added">3405       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-added">3406       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-added">3407       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="line-added">3408       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">3409     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="line-added">3410     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-added">3411     return unc;</span>
3412   }
<span class="line-added">3413   return NULL;</span>
3414 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,23 ***</span>
  #include &quot;gc/shared/markBitMap.hpp&quot;
  #include &quot;gc/shared/softRefPolicy.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahHeapLock.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
  #include &quot;services/memoryManager.hpp&quot;
  
  class ConcurrentGCTimer;
  class ReferenceProcessor;
  class ShenandoahAllocTracker;
  class ShenandoahCollectorPolicy;
  class ShenandoahControlThread;
  class ShenandoahGCSession;
  class ShenandoahHeuristics;
  class ShenandoahMarkingContext;
  class ShenandoahPhaseTimings;
  class ShenandoahHeap;
  class ShenandoahHeapRegion;
  class ShenandoahHeapRegionClosure;
  class ShenandoahCollectionSet;
<span class="line-new-header">--- 28,28 ---</span>
  #include &quot;gc/shared/markBitMap.hpp&quot;
  #include &quot;gc/shared/softRefPolicy.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;</span>
  #include &quot;services/memoryManager.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  class ConcurrentGCTimer;
  class ReferenceProcessor;
  class ShenandoahAllocTracker;
  class ShenandoahCollectorPolicy;
  class ShenandoahControlThread;
  class ShenandoahGCSession;
<span class="line-added">+ class ShenandoahGCStateResetter;</span>
  class ShenandoahHeuristics;
  class ShenandoahMarkingContext;
<span class="line-added">+ class ShenandoahMarkCompact;</span>
<span class="line-added">+ class ShenandoahMode;</span>
  class ShenandoahPhaseTimings;
  class ShenandoahHeap;
  class ShenandoahHeapRegion;
  class ShenandoahHeapRegionClosure;
  class ShenandoahCollectionSet;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,12 ***</span>
    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
    volatile size_t _index;
    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
  
    // No implicit copying: iterators should be passed by reference to capture the state
<span class="line-modified">!   ShenandoahRegionIterator(const ShenandoahRegionIterator&amp; that);</span>
<span class="line-removed">-   ShenandoahRegionIterator&amp; operator=(const ShenandoahRegionIterator&amp; o);</span>
  
  public:
    ShenandoahRegionIterator();
    ShenandoahRegionIterator(ShenandoahHeap* heap);
  
<span class="line-new-header">--- 70,11 ---</span>
    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
    volatile size_t _index;
    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
  
    // No implicit copying: iterators should be passed by reference to capture the state
<span class="line-modified">!   NONCOPYABLE(ShenandoahRegionIterator);</span>
  
  public:
    ShenandoahRegionIterator();
    ShenandoahRegionIterator(ShenandoahHeap* heap);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,23 ***</span>
  public:
    virtual void heap_region_do(ShenandoahHeapRegion* r) = 0;
    virtual bool is_thread_safe() { return false; }
  };
  
<span class="line-removed">- class ShenandoahUpdateRefsClosure: public OopClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahHeap* _heap;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   template &lt;class T&gt;</span>
<span class="line-removed">-   inline void do_oop_work(T* p);</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahUpdateRefsClosure();</span>
<span class="line-removed">-   inline void do_oop(oop* p);</span>
<span class="line-removed">-   inline void do_oop(narrowOop* p);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  #ifdef ASSERT
  class ShenandoahAssertToSpaceClosure : public OopClosure {
  private:
    template &lt;class T&gt;
    void do_oop_work(T* p);
<span class="line-new-header">--- 94,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,47 ***</span>
    void do_oop(narrowOop* p);
    void do_oop(oop* p);
  };
  #endif
  
<span class="line-modified">! class ShenandoahAlwaysTrueClosure : public BoolObjectClosure {</span>
<span class="line-modified">! public:</span>
<span class="line-removed">-   bool do_object_b(oop p) { return true; }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ShenandoahForwardedIsAliveClosure: public BoolObjectClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahForwardedIsAliveClosure();</span>
<span class="line-removed">-   bool do_object_b(oop obj);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ShenandoahIsAliveClosure: public BoolObjectClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahIsAliveClosure();</span>
<span class="line-removed">-   bool do_object_b(oop obj);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ShenandoahIsAliveSelector : public StackObj {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahIsAliveClosure _alive_cl;</span>
<span class="line-removed">-   ShenandoahForwardedIsAliveClosure _fwd_alive_cl;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   BoolObjectClosure* is_alive_closure();</span>
<span class="line-removed">- };</span>
  
  // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
  // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
  // See ShenandoahControlThread for GC cycle structure.
  //
  class ShenandoahHeap : public CollectedHeap {
    friend class ShenandoahAsserts;
    friend class VMStructs;
    friend class ShenandoahGCSession;
  
  // ---------- Locks that guard important data structures in Heap
  //
  private:
    ShenandoahHeapLock _lock;
<span class="line-new-header">--- 105,22 ---</span>
    void do_oop(narrowOop* p);
    void do_oop(oop* p);
  };
  #endif
  
<span class="line-modified">! typedef ShenandoahLock    ShenandoahHeapLock;</span>
<span class="line-modified">! typedef ShenandoahLocker  ShenandoahHeapLocker;</span>
  
  // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
  // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
  // See ShenandoahControlThread for GC cycle structure.
  //
  class ShenandoahHeap : public CollectedHeap {
    friend class ShenandoahAsserts;
    friend class VMStructs;
    friend class ShenandoahGCSession;
<span class="line-added">+   friend class ShenandoahGCStateResetter;</span>
  
  // ---------- Locks that guard important data structures in Heap
  //
  private:
    ShenandoahHeapLock _lock;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,10 ***</span>
<span class="line-new-header">--- 163,11 ---</span>
  
  // ---------- Heap counters and metrics
  //
  private:
             size_t _initial_size;
<span class="line-added">+            size_t _minimum_size;</span>
    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
    volatile size_t _used;
    volatile size_t _committed;
    volatile size_t _bytes_allocated_since_gc_start;
    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,10 ***</span>
<span class="line-new-header">--- 182,11 ---</span>
    void increase_allocated(size_t bytes);
  
    size_t bytes_allocated_since_gc_start();
    void reset_bytes_allocated_since_gc_start();
  
<span class="line-added">+   size_t min_capacity()     const;</span>
    size_t max_capacity()     const;
    size_t initial_capacity() const;
    size_t capacity()         const;
    size_t used()             const;
    size_t committed()        const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,10 ***</span>
<span class="line-new-header">--- 215,13 ---</span>
    size_t    _num_regions;
    ShenandoahHeapRegion** _regions;
    ShenandoahRegionIterator _update_refs_iterator;
  
  public:
<span class="line-added">+ </span>
<span class="line-added">+   inline HeapWord* base() const { return _heap_region.start(); }</span>
<span class="line-added">+ </span>
    inline size_t num_regions() const { return _num_regions; }
    inline bool is_heap_region_special() { return _heap_region_special; }
  
    inline ShenandoahHeapRegion* const heap_region_containing(const void* addr) const;
    inline size_t heap_region_index_containing(const void* addr) const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,41 ***</span>
  // Important invariant: when GC state is zero, the heap is stable, and no barriers
  // are required.
  //
  public:
    enum GCStateBitPos {
<span class="line-modified">!     // Heap has forwarded objects: need RB, ACMP, CAS barriers.</span>
      HAS_FORWARDED_BITPOS   = 0,
  
      // Heap is under marking: needs SATB barriers.
      MARKING_BITPOS    = 1,
  
<span class="line-modified">!     // Heap is under evacuation: needs WB barriers. (Set together with UNSTABLE)</span>
      EVACUATION_BITPOS = 2,
  
<span class="line-modified">!     // Heap is under updating: needs SVRB/SVWB barriers.</span>
      UPDATEREFS_BITPOS = 3,
  
      // Heap is under traversal collection
<span class="line-modified">!     TRAVERSAL_BITPOS  = 4,</span>
    };
  
    enum GCState {
      STABLE        = 0,
      HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
      MARKING       = 1 &lt;&lt; MARKING_BITPOS,
      EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
      UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
<span class="line-modified">!     TRAVERSAL     = 1 &lt;&lt; TRAVERSAL_BITPOS,</span>
    };
  
  private:
    ShenandoahSharedBitmap _gc_state;
    ShenandoahSharedFlag   _degenerated_gc_in_progress;
    ShenandoahSharedFlag   _full_gc_in_progress;
    ShenandoahSharedFlag   _full_gc_move_in_progress;
    ShenandoahSharedFlag   _progress_last_gc;
  
    void set_gc_state_all_threads(char state);
    void set_gc_state_mask(uint mask, bool value);
  
  public:
<span class="line-new-header">--- 240,42 ---</span>
  // Important invariant: when GC state is zero, the heap is stable, and no barriers
  // are required.
  //
  public:
    enum GCStateBitPos {
<span class="line-modified">!     // Heap has forwarded objects: needs LRB barriers.</span>
      HAS_FORWARDED_BITPOS   = 0,
  
      // Heap is under marking: needs SATB barriers.
      MARKING_BITPOS    = 1,
  
<span class="line-modified">!     // Heap is under evacuation: needs LRB barriers. (Set together with HAS_FORWARDED)</span>
      EVACUATION_BITPOS = 2,
  
<span class="line-modified">!     // Heap is under updating: needs no additional barriers.</span>
      UPDATEREFS_BITPOS = 3,
  
      // Heap is under traversal collection
<span class="line-modified">!     TRAVERSAL_BITPOS  = 4</span>
    };
  
    enum GCState {
      STABLE        = 0,
      HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
      MARKING       = 1 &lt;&lt; MARKING_BITPOS,
      EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
      UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
<span class="line-modified">!     TRAVERSAL     = 1 &lt;&lt; TRAVERSAL_BITPOS</span>
    };
  
  private:
    ShenandoahSharedBitmap _gc_state;
    ShenandoahSharedFlag   _degenerated_gc_in_progress;
    ShenandoahSharedFlag   _full_gc_in_progress;
    ShenandoahSharedFlag   _full_gc_move_in_progress;
    ShenandoahSharedFlag   _progress_last_gc;
<span class="line-added">+   ShenandoahSharedFlag   _concurrent_root_in_progress;</span>
  
    void set_gc_state_all_threads(char state);
    void set_gc_state_mask(uint mask, bool value);
  
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,10 ***</span>
<span class="line-new-header">--- 288,11 ---</span>
    void set_degenerated_gc_in_progress(bool in_progress);
    void set_full_gc_in_progress(bool in_progress);
    void set_full_gc_move_in_progress(bool in_progress);
    void set_concurrent_traversal_in_progress(bool in_progress);
    void set_has_forwarded_objects(bool cond);
<span class="line-added">+   void set_concurrent_root_in_progress(bool cond);</span>
  
    inline bool is_stable() const;
    inline bool is_idle() const;
    inline bool is_concurrent_mark_in_progress() const;
    inline bool is_update_refs_in_progress() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,10 ***</span>
<span class="line-new-header">--- 301,12 ---</span>
    inline bool is_full_gc_in_progress() const;
    inline bool is_full_gc_move_in_progress() const;
    inline bool is_concurrent_traversal_in_progress() const;
    inline bool has_forwarded_objects() const;
    inline bool is_gc_in_progress_mask(uint mask) const;
<span class="line-added">+   inline bool is_stw_gc_in_progress() const;</span>
<span class="line-added">+   inline bool is_concurrent_root_in_progress() const;</span>
  
  // ---------- GC cancellation and degeneration machinery
  //
  // Cancelled GC flag is used to notify concurrent phases that they should terminate.
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,11 ***</span>
      _degenerated_traversal,
      _degenerated_outside_cycle,
      _degenerated_mark,
      _degenerated_evac,
      _degenerated_updaterefs,
<span class="line-modified">!     _DEGENERATED_LIMIT,</span>
    };
  
    static const char* degen_point_to_string(ShenandoahDegenPoint point) {
      switch (point) {
        case _degenerated_unset:
<span class="line-new-header">--- 316,11 ---</span>
      _degenerated_traversal,
      _degenerated_outside_cycle,
      _degenerated_mark,
      _degenerated_evac,
      _degenerated_updaterefs,
<span class="line-modified">!     _DEGENERATED_LIMIT</span>
    };
  
    static const char* degen_point_to_string(ShenandoahDegenPoint point) {
      switch (point) {
        case _degenerated_unset:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,10 ***</span>
<span class="line-new-header">--- 400,11 ---</span>
    // Entry methods to normally concurrent GC operations. These set up logging, monitoring
    // for concurrent operation.
    void entry_reset();
    void entry_mark();
    void entry_preclean();
<span class="line-added">+   void entry_roots();</span>
    void entry_cleanup();
    void entry_evac();
    void entry_updaterefs();
    void entry_traversal();
    void entry_uncommit(double shrink_before);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,10 ***</span>
<span class="line-new-header">--- 424,11 ---</span>
    void op_degenerated_futile();
  
    void op_reset();
    void op_mark();
    void op_preclean();
<span class="line-added">+   void op_roots();</span>
    void op_cleanup();
    void op_conc_evac();
    void op_stw_evac();
    void op_updaterefs();
    void op_traversal();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,17 ***</span>
<span class="line-new-header">--- 437,21 ---</span>
    // Messages for GC trace events, they have to be immortal for
    // passing around the logging/tracing systems
    const char* init_mark_event_message() const;
    const char* final_mark_event_message() const;
    const char* conc_mark_event_message() const;
<span class="line-added">+   const char* init_traversal_event_message() const;</span>
<span class="line-added">+   const char* final_traversal_event_message() const;</span>
<span class="line-added">+   const char* conc_traversal_event_message() const;</span>
    const char* degen_event_message(ShenandoahDegenPoint point) const;
  
  // ---------- GC subsystems
  //
  private:
    ShenandoahControlThread*   _control_thread;
    ShenandoahCollectorPolicy* _shenandoah_policy;
<span class="line-added">+   ShenandoahMode*            _gc_mode;</span>
    ShenandoahHeuristics*      _heuristics;
    ShenandoahFreeSet*         _free_set;
    ShenandoahConcurrentMark*  _scm;
    ShenandoahTraversalGC*     _traversal_gc;
    ShenandoahMarkCompact*     _full_gc;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,11 ***</span>
  public:
    ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
    ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
    ShenandoahFreeSet*         free_set()          const { return _free_set;          }
    ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
<span class="line-modified">!   ShenandoahTraversalGC*     traversal_gc()            { return _traversal_gc;      }</span>
    ShenandoahPacer*           pacer()             const { return _pacer;             }
  
    ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
    ShenandoahAllocTracker*    alloc_tracker()     const { return _alloc_tracker;     }
  
<span class="line-new-header">--- 467,12 ---</span>
  public:
    ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
    ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
    ShenandoahFreeSet*         free_set()          const { return _free_set;          }
    ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
<span class="line-modified">!   ShenandoahTraversalGC*     traversal_gc()      const { return _traversal_gc;      }</span>
<span class="line-added">+   bool                       is_traversal_mode() const { return _traversal_gc != NULL; }</span>
    ShenandoahPacer*           pacer()             const { return _pacer;             }
  
    ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
    ShenandoahAllocTracker*    alloc_tracker()     const { return _alloc_tracker;     }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,10 ***</span>
<span class="line-new-header">--- 486,12 ---</span>
    GCMemoryManager              _stw_memory_manager;
    GCMemoryManager              _cycle_memory_manager;
    ConcurrentGCTimer*           _gc_timer;
    SoftRefPolicy                _soft_ref_policy;
  
<span class="line-added">+   // For exporting to SA</span>
<span class="line-added">+   int                          _log_min_obj_alignment_in_bytes;</span>
  public:
    ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
    GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
    GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
    SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,11 ***</span>
    GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
    GrowableArray&lt;MemoryPool*&gt; memory_pools();
    MemoryUsage memory_usage();
    GCTracer* tracer();
    GCTimer* gc_timer() const;
<span class="line-removed">-   CollectorPolicy* collector_policy() const;</span>
  
  // ---------- Reference processing
  //
  private:
    AlwaysTrueClosure    _subject_to_discovery;
<span class="line-new-header">--- 499,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,18 ***</span>
  
  // ---------- Class Unloading
  //
  private:
    ShenandoahSharedFlag _unload_classes;
  
  public:
    void set_unload_classes(bool uc);
    bool unload_classes() const;
  
<span class="line-modified">!   // Delete entries for dead interned string and clean up unreferenced symbols</span>
<span class="line-modified">!   // in symbol table, possibly in parallel.</span>
<span class="line-modified">!   void unload_classes_and_cleanup_tables(bool full_gc);</span>
  
  // ---------- Generic interface hooks
  // Minor things that super-interface expects us to implement to play nice with
  // the rest of runtime. Some of the things here are not required to be implemented,
  // and can be stubbed out.
<span class="line-new-header">--- 518,28 ---</span>
  
  // ---------- Class Unloading
  //
  private:
    ShenandoahSharedFlag _unload_classes;
<span class="line-added">+   ShenandoahUnload     _unloader;</span>
  
  public:
    void set_unload_classes(bool uc);
    bool unload_classes() const;
  
<span class="line-modified">!   // Perform STW class unloading and weak root cleaning</span>
<span class="line-modified">!   void parallel_cleaning(bool full_gc);</span>
<span class="line-modified">! </span>
<span class="line-added">+ private:</span>
<span class="line-added">+   void stw_unload_classes(bool full_gc);</span>
<span class="line-added">+   void stw_process_weak_roots(bool full_gc);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Prepare concurrent root processing</span>
<span class="line-added">+   void prepare_concurrent_roots();</span>
<span class="line-added">+   // Prepare and finish concurrent unloading</span>
<span class="line-added">+   void prepare_concurrent_unloading();</span>
<span class="line-added">+   void finish_concurrent_unloading();</span>
  
  // ---------- Generic interface hooks
  // Minor things that super-interface expects us to implement to play nice with
  // the rest of runtime. Some of the things here are not required to be implemented,
  // and can be stubbed out.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,23 ***</span>
    AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);
    bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);
  
    bool is_in(const void* p) const;
  
<span class="line-modified">!   size_t obj_size(oop obj) const;</span>
<span class="line-modified">!   virtual ptrdiff_t cell_header_size() const;</span>
  
    void collect(GCCause::Cause cause);
    void do_full_collection(bool clear_all_soft_refs);
  
    // Used for parsing heap during error printing
    HeapWord* block_start(const void* addr) const;
    bool block_is_obj(const HeapWord* addr) const;
  
    // Used for native heap walkers: heap dumpers, mostly
    void object_iterate(ObjectClosure* cl);
<span class="line-modified">!   void safe_object_iterate(ObjectClosure* cl);</span>
  
    // Used by RMI
    jlong millis_since_last_gc();
  
  // ---------- Safepoint interface hooks
<span class="line-new-header">--- 548,26 ---</span>
    AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);
    bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);
  
    bool is_in(const void* p) const;
  
<span class="line-modified">!   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-modified">!   bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }</span>
  
    void collect(GCCause::Cause cause);
    void do_full_collection(bool clear_all_soft_refs);
  
    // Used for parsing heap during error printing
    HeapWord* block_start(const void* addr) const;
    bool block_is_obj(const HeapWord* addr) const;
<span class="line-added">+   bool print_location(outputStream* st, void* addr) const;</span>
  
    // Used for native heap walkers: heap dumpers, mostly
    void object_iterate(ObjectClosure* cl);
<span class="line-modified">! </span>
<span class="line-added">+   // Keep alive an object that was loaded with AS_NO_KEEPALIVE.</span>
<span class="line-added">+   void keep_alive(oop obj);</span>
  
    // Used by RMI
    jlong millis_since_last_gc();
  
  // ---------- Safepoint interface hooks
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,20 ***</span>
<span class="line-new-header">--- 579,25 ---</span>
  // ---------- Code roots handling hooks
  //
  public:
    void register_nmethod(nmethod* nm);
    void unregister_nmethod(nmethod* nm);
<span class="line-added">+   void flush_nmethod(nmethod* nm);</span>
<span class="line-added">+   void verify_nmethod(nmethod* nm) {}</span>
  
  // ---------- Pinning hooks
  //
  public:
    // Shenandoah supports per-object (per-region) pinning
    bool supports_object_pinning() const { return true; }
  
    oop pin_object(JavaThread* thread, oop obj);
    void unpin_object(JavaThread* thread, oop obj);
  
<span class="line-added">+   void sync_pinned_region_status();</span>
<span class="line-added">+   void assert_pinned_region_status() NOT_DEBUG_RETURN;</span>
<span class="line-added">+ </span>
  // ---------- Allocation support
  //
  private:
    HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest&amp; request, bool&amp; in_new_region);
    inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,14 ***</span>
    HeapWord* mem_allocate(size_t size, bool* what);
    MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
                                                 size_t size,
                                                 Metaspace::MetadataType mdtype);
  
<span class="line-removed">-   oop obj_allocate(Klass* klass, int size, TRAPS);</span>
<span class="line-removed">-   oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);</span>
<span class="line-removed">-   oop class_allocate(Klass* klass, int size, TRAPS);</span>
<span class="line-removed">- </span>
    void notify_mutator_alloc_words(size_t words, bool waste);
  
    // Shenandoah supports TLAB allocation
    bool supports_tlab_allocation() const { return true; }
  
<span class="line-new-header">--- 610,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,14 ***</span>
    size_t tlab_capacity(Thread *thr) const;
    size_t unsafe_max_tlab_alloc(Thread *thread) const;
    size_t max_tlab_size() const;
    size_t tlab_used(Thread* ignored) const;
  
<span class="line-removed">-   HeapWord* tlab_post_allocation_setup(HeapWord* obj);</span>
<span class="line-removed">-   void fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap);</span>
<span class="line-removed">-   size_t min_dummy_object_size() const;</span>
<span class="line-removed">- </span>
    void resize_tlabs();
  
    void ensure_parsability(bool retire_tlabs);
    void make_parsable(bool retire_tlabs);
  
<span class="line-new-header">--- 621,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,15 ***</span>
  public:
    static address in_cset_fast_test_addr();
  
    ShenandoahCollectionSet* collection_set() const { return _collection_set; }
  
<span class="line-modified">!   template &lt;class T&gt;</span>
<span class="line-modified">!   inline bool in_collection_set(T obj) const;</span>
  
<span class="line-modified">!   // Avoid accidentally calling the method above with ShenandoahHeapRegion*, which would be *wrong*.</span>
<span class="line-modified">!   inline bool in_collection_set(ShenandoahHeapRegion* r) shenandoah_not_implemented_return(false);</span>
  
    // Evacuates object src. Returns the evacuated object, either evacuated
    // by this thread, or by some other thread.
    inline oop evacuate_object(oop src, Thread* thread);
  
<span class="line-new-header">--- 696,15 ---</span>
  public:
    static address in_cset_fast_test_addr();
  
    ShenandoahCollectionSet* collection_set() const { return _collection_set; }
  
<span class="line-modified">!   // Checks if object is in the collection set.</span>
<span class="line-modified">!   inline bool in_collection_set(oop obj) const;</span>
  
<span class="line-modified">!   // Checks if location is in the collection set. Can be interior pointer, not the oop itself.</span>
<span class="line-modified">!   inline bool in_collection_set_loc(void* loc) const;</span>
  
    // Evacuates object src. Returns the evacuated object, either evacuated
    // by this thread, or by some other thread.
    inline oop evacuate_object(oop src, Thread* thread);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,21 ***</span>
    inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);
  
    template &lt;class T&gt;
    inline oop update_with_forwarded_not_null(T* p, oop obj);
  
<span class="line-modified">!   inline oop atomic_compare_exchange_oop(oop n, narrowOop* addr, oop c);</span>
<span class="line-modified">!   inline oop atomic_compare_exchange_oop(oop n, oop* addr, oop c);</span>
  
    void trash_humongous_region_at(ShenandoahHeapRegion *r);
  
    void deduplicate_string(oop str);
  
<span class="line-removed">-   void stop_concurrent_marking();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void roots_iterate(OopClosure* cl);</span>
<span class="line-removed">- </span>
  private:
    void trash_cset_regions();
    void update_heap_references(bool concurrent);
  
  // ---------- Testing helpers functions
<span class="line-new-header">--- 725,18 ---</span>
    inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);
  
    template &lt;class T&gt;
    inline oop update_with_forwarded_not_null(T* p, oop obj);
  
<span class="line-modified">!   static inline oop cas_oop(oop n, narrowOop* addr, oop c);</span>
<span class="line-modified">!   static inline oop cas_oop(oop n, oop* addr, oop c);</span>
<span class="line-added">+   static inline oop cas_oop(oop n, narrowOop* addr, narrowOop c);</span>
  
    void trash_humongous_region_at(ShenandoahHeapRegion *r);
  
    void deduplicate_string(oop str);
  
  private:
    void trash_cset_regions();
    void update_heap_references(bool concurrent);
  
  // ---------- Testing helpers functions
</pre>
<center><a href="shenandoahHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
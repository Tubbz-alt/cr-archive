<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;memory/allocation.hpp&quot;
<a name="2" id="anc2"></a>
  26 
<a name="3" id="anc3"></a>
  27 #include &quot;gc/shared/gcTimer.hpp&quot;
  28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<a name="4" id="anc4"></a>
  29 #include &quot;gc/shared/memAllocator.hpp&quot;
<a name="5" id="anc5"></a><span class="line-modified">  30 #include &quot;gc/shared/parallelCleaning.hpp&quot;</span>
  31 #include &quot;gc/shared/plab.hpp&quot;
  32 
  33 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<a name="6" id="anc6"></a><span class="line-modified">  35 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  36 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
<a name="7" id="anc7"></a>
  39 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
<a name="8" id="anc8"></a>
  50 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<a name="9" id="anc9"></a><span class="line-modified">  52 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>


  53 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
<a name="10" id="anc10"></a>

  54 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  58 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
<a name="11" id="anc11"></a><span class="line-modified">  60 #include &quot;gc/shenandoah/heuristics/shenandoahAdaptiveHeuristics.hpp&quot;</span>
<span class="line-modified">  61 #include &quot;gc/shenandoah/heuristics/shenandoahAggressiveHeuristics.hpp&quot;</span>
<span class="line-modified">  62 #include &quot;gc/shenandoah/heuristics/shenandoahCompactHeuristics.hpp&quot;</span>
<span class="line-removed">  63 #include &quot;gc/shenandoah/heuristics/shenandoahPassiveHeuristics.hpp&quot;</span>
<span class="line-removed">  64 #include &quot;gc/shenandoah/heuristics/shenandoahStaticHeuristics.hpp&quot;</span>
<span class="line-removed">  65 #include &quot;gc/shenandoah/heuristics/shenandoahTraversalHeuristics.hpp&quot;</span>
  66 
  67 #include &quot;memory/metaspace.hpp&quot;
<a name="12" id="anc12"></a>


  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<a name="13" id="anc13"></a>
  69 #include &quot;runtime/safepointMechanism.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;services/mallocTracker.hpp&quot;
<a name="14" id="anc14"></a><span class="line-modified">  72 </span>
<span class="line-removed">  73 ShenandoahUpdateRefsClosure::ShenandoahUpdateRefsClosure() : _heap(ShenandoahHeap::heap()) {}</span>
  74 
  75 #ifdef ASSERT
  76 template &lt;class T&gt;
  77 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  78   T o = RawAccess&lt;&gt;::oop_load(p);
  79   if (! CompressedOops::is_null(o)) {
  80     oop obj = CompressedOops::decode_not_null(o);
  81     shenandoah_assert_not_forwarded(p, obj);
  82   }
  83 }
  84 
  85 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  86 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  87 #endif
  88 
  89 class ShenandoahPretouchHeapTask : public AbstractGangTask {
  90 private:
  91   ShenandoahRegionIterator _regions;
  92   const size_t _page_size;
  93 public:
  94   ShenandoahPretouchHeapTask(size_t page_size) :
  95     AbstractGangTask(&quot;Shenandoah Pretouch Heap&quot;),
  96     _page_size(page_size) {}
  97 
  98   virtual void work(uint worker_id) {
  99     ShenandoahHeapRegion* r = _regions.next();
 100     while (r != NULL) {
 101       os::pretouch_memory(r-&gt;bottom(), r-&gt;end(), _page_size);
 102       r = _regions.next();
 103     }
 104   }
 105 };
 106 
 107 class ShenandoahPretouchBitmapTask : public AbstractGangTask {
 108 private:
 109   ShenandoahRegionIterator _regions;
 110   char* _bitmap_base;
 111   const size_t _bitmap_size;
 112   const size_t _page_size;
 113 public:
 114   ShenandoahPretouchBitmapTask(char* bitmap_base, size_t bitmap_size, size_t page_size) :
 115     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 116     _bitmap_base(bitmap_base),
 117     _bitmap_size(bitmap_size),
 118     _page_size(page_size) {}
 119 
 120   virtual void work(uint worker_id) {
 121     ShenandoahHeapRegion* r = _regions.next();
 122     while (r != NULL) {
 123       size_t start = r-&gt;region_number()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 124       size_t end   = (r-&gt;region_number() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 125       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 126 
 127       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 128 
 129       r = _regions.next();
 130     }
 131   }
 132 };
 133 
 134 jint ShenandoahHeap::initialize() {
<a name="15" id="anc15"></a><span class="line-removed"> 135   ShenandoahBrooksPointer::initial_checks();</span>
<span class="line-removed"> 136 </span>
 137   initialize_heuristics();
 138 
 139   //
 140   // Figure out heap sizing
 141   //
 142 
<a name="16" id="anc16"></a><span class="line-modified"> 143   size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size();</span>
<span class="line-modified"> 144   size_t max_byte_size  = collector_policy()-&gt;max_heap_byte_size();</span>
<span class="line-modified"> 145   size_t heap_alignment = collector_policy()-&gt;heap_alignment();</span>

 146 
 147   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 148 
 149   if (ShenandoahAlwaysPreTouch) {
 150     // Enabled pre-touch means the entire heap is committed right away.
 151     init_byte_size = max_byte_size;
 152   }
 153 
 154   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 155   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 156 
 157   _num_regions = ShenandoahHeapRegion::region_count();
 158 
 159   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 160   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 161   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
<a name="17" id="anc17"></a><span class="line-removed"> 162 </span>
 163   _initial_size = num_committed_regions * reg_size_bytes;
<a name="18" id="anc18"></a>





 164   _committed = _initial_size;
 165 
 166   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 167   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 168 
 169   //
 170   // Reserve and commit memory for heap
 171   //
 172 
<a name="19" id="anc19"></a><span class="line-modified"> 173   ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);</span>
<span class="line-modified"> 174   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*) (heap_rs.base() + heap_rs.size()));</span>
 175   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 176   _heap_region_special = heap_rs.special();
 177 
 178   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 179          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 180 
<a name="20" id="anc20"></a>











 181   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 182   if (!_heap_region_special) {
 183     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 184                               &quot;Cannot commit heap memory&quot;);
 185   }
 186 
 187   //
 188   // Reserve and commit memory for bitmap(s)
 189   //
 190 
 191   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 192   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 193 
 194   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 195 
 196   guarantee(bitmap_bytes_per_region != 0,
 197             &quot;Bitmap bytes per region should not be zero&quot;);
 198   guarantee(is_power_of_2(bitmap_bytes_per_region),
 199             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 200 
 201   if (bitmap_page_size &gt; bitmap_bytes_per_region) {
 202     _bitmap_regions_per_slice = bitmap_page_size / bitmap_bytes_per_region;
 203     _bitmap_bytes_per_slice = bitmap_page_size;
 204   } else {
 205     _bitmap_regions_per_slice = 1;
 206     _bitmap_bytes_per_slice = bitmap_bytes_per_region;
 207   }
 208 
 209   guarantee(_bitmap_regions_per_slice &gt;= 1,
 210             &quot;Should have at least one region per slice: &quot; SIZE_FORMAT,
 211             _bitmap_regions_per_slice);
 212 
 213   guarantee(((_bitmap_bytes_per_slice) % bitmap_page_size) == 0,
 214             &quot;Bitmap slices should be page-granular: bps = &quot; SIZE_FORMAT &quot;, page size = &quot; SIZE_FORMAT,
 215             _bitmap_bytes_per_slice, bitmap_page_size);
 216 
 217   ReservedSpace bitmap(_bitmap_size, bitmap_page_size);
 218   MemTracker::record_virtual_memory_type(bitmap.base(), mtGC);
 219   _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() / HeapWordSize);
 220   _bitmap_region_special = bitmap.special();
 221 
 222   size_t bitmap_init_commit = _bitmap_bytes_per_slice *
 223                               align_up(num_committed_regions, _bitmap_regions_per_slice) / _bitmap_regions_per_slice;
 224   bitmap_init_commit = MIN2(_bitmap_size, bitmap_init_commit);
 225   if (!_bitmap_region_special) {
 226     os::commit_memory_or_exit((char *) _bitmap_region.start(), bitmap_init_commit, bitmap_page_size, false,
 227                               &quot;Cannot commit bitmap memory&quot;);
 228   }
 229 
 230   _marking_context = new ShenandoahMarkingContext(_heap_region, _bitmap_region, _num_regions);
 231 
 232   if (ShenandoahVerify) {
 233     ReservedSpace verify_bitmap(_bitmap_size, bitmap_page_size);
 234     if (!verify_bitmap.special()) {
 235       os::commit_memory_or_exit(verify_bitmap.base(), verify_bitmap.size(), bitmap_page_size, false,
 236                                 &quot;Cannot commit verification bitmap memory&quot;);
 237     }
 238     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 239     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 240     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 241     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 242   }
 243 
 244   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 245   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 246   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 247   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 248   _aux_bitmap_region_special = aux_bitmap.special();
 249   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 250 
 251   //
 252   // Create regions and region sets
 253   //
 254 
 255   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 256   _free_set = new ShenandoahFreeSet(this, _num_regions);
<a name="21" id="anc21"></a><span class="line-modified"> 257   _collection_set = new ShenandoahCollectionSet(this, (HeapWord*)sh_rs.base());</span>
 258 
 259   {
 260     ShenandoahHeapLocker locker(lock());
 261 
 262     size_t size_words = ShenandoahHeapRegion::region_size_words();
 263 
 264     for (size_t i = 0; i &lt; _num_regions; i++) {
 265       HeapWord* start = (HeapWord*)sh_rs.base() + size_words * i;
 266       bool is_committed = i &lt; num_committed_regions;
 267       ShenandoahHeapRegion* r = new ShenandoahHeapRegion(this, start, size_words, i, is_committed);
 268 
 269       _marking_context-&gt;initialize_top_at_mark_start(r);
 270       _regions[i] = r;
 271       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 272     }
 273 
 274     // Initialize to complete
 275     _marking_context-&gt;mark_complete();
 276 
 277     _free_set-&gt;rebuild();
 278   }
 279 
 280   if (ShenandoahAlwaysPreTouch) {
 281     assert(!AlwaysPreTouch, &quot;Should have been overridden&quot;);
 282 
 283     // For NUMA, it is important to pre-touch the storage under bitmaps with worker threads,
 284     // before initialize() below zeroes it with initializing thread. For any given region,
 285     // we touch the region and the corresponding bitmaps from the same thread.
 286     ShenandoahPushWorkerScope scope(workers(), _max_workers, false);
 287 
 288     size_t pretouch_heap_page_size = heap_page_size;
 289     size_t pretouch_bitmap_page_size = bitmap_page_size;
 290 
 291 #ifdef LINUX
 292     // UseTransparentHugePages would madvise that backing memory can be coalesced into huge
 293     // pages. But, the kernel needs to know that every small page is used, in order to coalesce
 294     // them into huge one. Therefore, we need to pretouch with smaller pages.
 295     if (UseTransparentHugePages) {
 296       pretouch_heap_page_size = (size_t)os::vm_page_size();
 297       pretouch_bitmap_page_size = (size_t)os::vm_page_size();
 298     }
 299 #endif
 300 
 301     // OS memory managers may want to coalesce back-to-back pages. Make their jobs
 302     // simpler by pre-touching continuous spaces (heap and bitmap) separately.
 303 
 304     log_info(gc, init)(&quot;Pretouch bitmap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 305                        _num_regions, pretouch_bitmap_page_size);
 306     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 307     _workers-&gt;run_task(&amp;bcl);
 308 
 309     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 310                        _num_regions, pretouch_heap_page_size);
 311     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 312     _workers-&gt;run_task(&amp;hcl);
 313   }
 314 
 315   //
 316   // Initialize the rest of GC subsystems
 317   //
 318 
 319   _liveness_cache = NEW_C_HEAP_ARRAY(jushort*, _max_workers, mtGC);
 320   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 321     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
 322     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
 323   }
 324 
<a name="22" id="anc22"></a><span class="line-modified"> 325   // The call below uses stuff (the SATB* things) that are in G1, but probably</span>
<span class="line-modified"> 326   // belong into a shared location.</span>
<span class="line-modified"> 327   ShenandoahBarrierSet::satb_mark_queue_set().initialize(this,</span>
<span class="line-modified"> 328                                                          SATB_Q_CBL_mon,</span>
<span class="line-modified"> 329                                                          20 /* G1SATBProcessCompletedThreshold */,</span>
<span class="line-modified"> 330                                                          60 /* G1SATBBufferEnqueueingThresholdPercent */);</span>

 331 
 332   _monitoring_support = new ShenandoahMonitoringSupport(this);
 333   _phase_timings = new ShenandoahPhaseTimings();
 334   ShenandoahStringDedup::initialize();
 335   ShenandoahCodeRoots::initialize();
 336 
 337   if (ShenandoahAllocationTrace) {
 338     _alloc_tracker = new ShenandoahAllocTracker();
 339   }
 340 
 341   if (ShenandoahPacing) {
 342     _pacer = new ShenandoahPacer(this);
 343     _pacer-&gt;setup_for_idle();
 344   } else {
 345     _pacer = NULL;
 346   }
 347 
<a name="23" id="anc23"></a><span class="line-modified"> 348   _traversal_gc = heuristics()-&gt;can_do_traversal_gc() ?</span>
 349                   new ShenandoahTraversalGC(this, _num_regions) :
 350                   NULL;
 351 
 352   _control_thread = new ShenandoahControlThread();
 353 
<a name="24" id="anc24"></a><span class="line-modified"> 354   log_info(gc, init)(&quot;Initialize Shenandoah heap with initial size &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified"> 355                      byte_size_in_proper_unit(_initial_size), proper_unit_for_byte_size(_initial_size));</span>



 356 
 357   log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
 358                      SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
 359                      (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
 360 
 361   return JNI_OK;
 362 }
 363 
 364 void ShenandoahHeap::initialize_heuristics() {
<a name="25" id="anc25"></a><span class="line-modified"> 365   if (ShenandoahGCHeuristics != NULL) {</span>
<span class="line-modified"> 366     if (strcmp(ShenandoahGCHeuristics, &quot;aggressive&quot;) == 0) {</span>
<span class="line-modified"> 367       _heuristics = new ShenandoahAggressiveHeuristics();</span>
<span class="line-modified"> 368     } else if (strcmp(ShenandoahGCHeuristics, &quot;static&quot;) == 0) {</span>
<span class="line-modified"> 369       _heuristics = new ShenandoahStaticHeuristics();</span>
<span class="line-modified"> 370     } else if (strcmp(ShenandoahGCHeuristics, &quot;adaptive&quot;) == 0) {</span>
<span class="line-modified"> 371       _heuristics = new ShenandoahAdaptiveHeuristics();</span>
<span class="line-removed"> 372     } else if (strcmp(ShenandoahGCHeuristics, &quot;passive&quot;) == 0) {</span>
<span class="line-removed"> 373       _heuristics = new ShenandoahPassiveHeuristics();</span>
<span class="line-removed"> 374     } else if (strcmp(ShenandoahGCHeuristics, &quot;compact&quot;) == 0) {</span>
<span class="line-removed"> 375       _heuristics = new ShenandoahCompactHeuristics();</span>
<span class="line-removed"> 376     } else if (strcmp(ShenandoahGCHeuristics, &quot;traversal&quot;) == 0) {</span>
<span class="line-removed"> 377       _heuristics = new ShenandoahTraversalHeuristics();</span>
 378     } else {
<a name="26" id="anc26"></a><span class="line-modified"> 379       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCHeuristics option&quot;);</span>
 380     }
<a name="27" id="anc27"></a><span class="line-removed"> 381 </span>
<span class="line-removed"> 382     if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {</span>
<span class="line-removed"> 383       vm_exit_during_initialization(</span>
<span class="line-removed"> 384               err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,</span>
<span class="line-removed"> 385                       _heuristics-&gt;name()));</span>
<span class="line-removed"> 386     }</span>
<span class="line-removed"> 387     if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {</span>
<span class="line-removed"> 388       vm_exit_during_initialization(</span>
<span class="line-removed"> 389               err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,</span>
<span class="line-removed"> 390                       _heuristics-&gt;name()));</span>
<span class="line-removed"> 391     }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393     if (ShenandoahStoreValEnqueueBarrier &amp;&amp; ShenandoahStoreValReadBarrier) {</span>
<span class="line-removed"> 394       vm_exit_during_initialization(&quot;Cannot use both ShenandoahStoreValEnqueueBarrier and ShenandoahStoreValReadBarrier&quot;);</span>
<span class="line-removed"> 395     }</span>
<span class="line-removed"> 396     log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,</span>
<span class="line-removed"> 397                        _heuristics-&gt;name());</span>
 398   } else {
<a name="28" id="anc28"></a><span class="line-modified"> 399       ShouldNotReachHere();</span>
 400   }
<a name="29" id="anc29"></a>

 401 
<a name="30" id="anc30"></a>











 402 }
 403 
 404 #ifdef _MSC_VER
 405 #pragma warning( push )
 406 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 407 #endif
 408 
 409 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 410   CollectedHeap(),
 411   _initial_size(0),
 412   _used(0),
 413   _committed(0),
 414   _bytes_allocated_since_gc_start(0),
 415   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 416   _workers(NULL),
 417   _safepoint_workers(NULL),
 418   _heap_region_special(false),
 419   _num_regions(0),
 420   _regions(NULL),
 421   _update_refs_iterator(this),
 422   _control_thread(NULL),
 423   _shenandoah_policy(policy),
 424   _heuristics(NULL),
 425   _free_set(NULL),
 426   _scm(new ShenandoahConcurrentMark()),
 427   _traversal_gc(NULL),
 428   _full_gc(new ShenandoahMarkCompact()),
 429   _pacer(NULL),
 430   _verifier(NULL),
 431   _alloc_tracker(NULL),
 432   _phase_timings(NULL),
 433   _monitoring_support(NULL),
 434   _memory_pool(NULL),
 435   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 436   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 437   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 438   _soft_ref_policy(),
<a name="31" id="anc31"></a>
 439   _ref_processor(NULL),
 440   _marking_context(NULL),
 441   _bitmap_size(0),
 442   _bitmap_regions_per_slice(0),
 443   _bitmap_bytes_per_slice(0),
 444   _bitmap_region_special(false),
 445   _aux_bitmap_region_special(false),
 446   _liveness_cache(NULL),
 447   _collection_set(NULL)
 448 {
 449   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 450   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 451 
 452   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 453 
 454   _max_workers = MAX2(_max_workers, 1U);
 455   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
<a name="32" id="anc32"></a><span class="line-modified"> 456                             /* are_GC_task_threads */true,</span>
<span class="line-modified"> 457                             /* are_ConcurrentGC_threads */false);</span>
 458   if (_workers == NULL) {
 459     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 460   } else {
 461     _workers-&gt;initialize_workers();
 462   }
 463 
 464   if (ShenandoahParallelSafepointThreads &gt; 1) {
 465     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 466                                                 ShenandoahParallelSafepointThreads,
<a name="33" id="anc33"></a><span class="line-modified"> 467                                                 false, false);</span>

 468     _safepoint_workers-&gt;initialize_workers();
 469   }
 470 }
 471 
 472 #ifdef _MSC_VER
 473 #pragma warning( pop )
 474 #endif
 475 
 476 class ShenandoahResetBitmapTask : public AbstractGangTask {
 477 private:
 478   ShenandoahRegionIterator _regions;
 479 
 480 public:
 481   ShenandoahResetBitmapTask() :
 482     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 483 
 484   void work(uint worker_id) {
 485     ShenandoahHeapRegion* region = _regions.next();
 486     ShenandoahHeap* heap = ShenandoahHeap::heap();
 487     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 488     while (region != NULL) {
 489       if (heap-&gt;is_bitmap_slice_committed(region)) {
 490         ctx-&gt;clear_bitmap(region);
 491       }
 492       region = _regions.next();
 493     }
 494   }
 495 };
 496 
 497 void ShenandoahHeap::reset_mark_bitmap() {
 498   assert_gc_workers(_workers-&gt;active_workers());
 499   mark_incomplete_marking_context();
 500 
 501   ShenandoahResetBitmapTask task;
 502   _workers-&gt;run_task(&amp;task);
 503 }
 504 
 505 void ShenandoahHeap::print_on(outputStream* st) const {
 506   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
<a name="34" id="anc34"></a><span class="line-modified"> 507   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;K total, &quot; SIZE_FORMAT &quot;K committed, &quot; SIZE_FORMAT &quot;K used&quot;,</span>
<span class="line-modified"> 508                capacity() / K, committed() / K, used() / K);</span>
<span class="line-modified"> 509   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;K regions&quot;,</span>
<span class="line-modified"> 510                num_regions(), ShenandoahHeapRegion::region_size_bytes() / K);</span>




 511 
 512   st-&gt;print(&quot;Status: &quot;);
 513   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 514   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 515   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 516   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
 517   if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
 518   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 519   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 520   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
<a name="35" id="anc35"></a>
 521 
 522   if (cancelled_gc()) {
 523     st-&gt;print(&quot;cancelled&quot;);
 524   } else {
 525     st-&gt;print(&quot;not cancelled&quot;);
 526   }
 527   st-&gt;cr();
 528 
 529   st-&gt;print_cr(&quot;Reserved region:&quot;);
 530   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 531                p2i(reserved_region().start()),
 532                p2i(reserved_region().end()));
 533 
<a name="36" id="anc36"></a>








 534   st-&gt;cr();
 535   MetaspaceUtils::print_on(st);
 536 
 537   if (Verbose) {
 538     print_heap_regions_on(st);
 539   }
 540 }
 541 
 542 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 543 public:
 544   void do_thread(Thread* thread) {
 545     assert(thread != NULL, &quot;Sanity&quot;);
 546     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 547     ShenandoahThreadLocalData::initialize_gclab(thread);
 548   }
 549 };
 550 
 551 void ShenandoahHeap::post_initialize() {
 552   CollectedHeap::post_initialize();
 553   MutexLocker ml(Threads_lock);
 554 
 555   ShenandoahInitWorkerGCLABClosure init_gclabs;
 556   _workers-&gt;threads_do(&amp;init_gclabs);
 557 
 558   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 559   // Now, we will let WorkGang to initialize gclab when new worker is created.
 560   _workers-&gt;set_initialize_gclab();
 561 
 562   _scm-&gt;initialize(_max_workers);
 563   _full_gc-&gt;initialize(_gc_timer);
 564 
 565   ref_processing_init();
 566 
 567   _heuristics-&gt;initialize();
<a name="37" id="anc37"></a>

 568 }
 569 
 570 size_t ShenandoahHeap::used() const {
<a name="38" id="anc38"></a><span class="line-modified"> 571   return OrderAccess::load_acquire(&amp;_used);</span>
 572 }
 573 
 574 size_t ShenandoahHeap::committed() const {
 575   OrderAccess::acquire();
 576   return _committed;
 577 }
 578 
 579 void ShenandoahHeap::increase_committed(size_t bytes) {
 580   assert_heaplock_or_safepoint();
 581   _committed += bytes;
 582 }
 583 
 584 void ShenandoahHeap::decrease_committed(size_t bytes) {
 585   assert_heaplock_or_safepoint();
 586   _committed -= bytes;
 587 }
 588 
 589 void ShenandoahHeap::increase_used(size_t bytes) {
<a name="39" id="anc39"></a><span class="line-modified"> 590   Atomic::add(bytes, &amp;_used);</span>
 591 }
 592 
 593 void ShenandoahHeap::set_used(size_t bytes) {
<a name="40" id="anc40"></a><span class="line-modified"> 594   OrderAccess::release_store_fence(&amp;_used, bytes);</span>
 595 }
 596 
 597 void ShenandoahHeap::decrease_used(size_t bytes) {
 598   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
<a name="41" id="anc41"></a><span class="line-modified"> 599   Atomic::sub(bytes, &amp;_used);</span>
 600 }
 601 
 602 void ShenandoahHeap::increase_allocated(size_t bytes) {
<a name="42" id="anc42"></a><span class="line-modified"> 603   Atomic::add(bytes, &amp;_bytes_allocated_since_gc_start);</span>
 604 }
 605 
 606 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 607   size_t bytes = words * HeapWordSize;
 608   if (!waste) {
 609     increase_used(bytes);
 610   }
 611   increase_allocated(bytes);
 612   if (ShenandoahPacing) {
 613     control_thread()-&gt;pacing_notify_alloc(words);
 614     if (waste) {
 615       pacer()-&gt;claim_for_alloc(words, true);
 616     }
 617   }
 618 }
 619 
 620 size_t ShenandoahHeap::capacity() const {
<a name="43" id="anc43"></a><span class="line-modified"> 621   return num_regions() * ShenandoahHeapRegion::region_size_bytes();</span>
 622 }
 623 
 624 size_t ShenandoahHeap::max_capacity() const {
 625   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 626 }
 627 
<a name="44" id="anc44"></a>



 628 size_t ShenandoahHeap::initial_capacity() const {
 629   return _initial_size;
 630 }
 631 
 632 bool ShenandoahHeap::is_in(const void* p) const {
 633   HeapWord* heap_base = (HeapWord*) base();
 634   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 635   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 636 }
 637 
 638 void ShenandoahHeap::op_uncommit(double shrink_before) {
 639   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 640 
<a name="45" id="anc45"></a>




 641   size_t count = 0;
<a name="46" id="anc46"></a><span class="line-modified"> 642   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-modified"> 643     ShenandoahHeapRegion* r = get_region(i);</span>
 644     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 645       ShenandoahHeapLocker locker(lock());
 646       if (r-&gt;is_empty_committed()) {
<a name="47" id="anc47"></a>




 647         r-&gt;make_uncommitted();
 648         count++;
 649       }
 650     }
 651     SpinPause(); // allow allocators to take the lock
 652   }
 653 
 654   if (count &gt; 0) {
<a name="48" id="anc48"></a><span class="line-removed"> 655     log_info(gc)(&quot;Uncommitted &quot; SIZE_FORMAT &quot;M. Heap: &quot; SIZE_FORMAT &quot;M reserved, &quot; SIZE_FORMAT &quot;M committed, &quot; SIZE_FORMAT &quot;M used&quot;,</span>
<span class="line-removed"> 656                  count * ShenandoahHeapRegion::region_size_bytes() / M, capacity() / M, committed() / M, used() / M);</span>
 657     control_thread()-&gt;notify_heap_changed();
 658   }
 659 }
 660 
 661 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 662   // New object should fit the GCLAB size
 663   size_t min_size = MAX2(size, PLAB::min_size());
 664 
 665   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 666   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 667   new_size = MIN2(new_size, PLAB::max_size());
 668   new_size = MAX2(new_size, PLAB::min_size());
 669 
 670   // Record new heuristic value even if we take any shortcut. This captures
 671   // the case when moderately-sized objects always take a shortcut. At some point,
 672   // heuristics should catch up with them.
 673   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 674 
 675   if (new_size &lt; size) {
 676     // New size still does not fit the object. Fall back to shared allocation.
 677     // This avoids retiring perfectly good GCLABs, when we encounter a large object.
 678     return NULL;
 679   }
 680 
 681   // Retire current GCLAB, and allocate a new one.
 682   PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
 683   gclab-&gt;retire();
 684 
 685   size_t actual_size = 0;
 686   HeapWord* gclab_buf = allocate_new_gclab(min_size, new_size, &amp;actual_size);
 687   if (gclab_buf == NULL) {
 688     return NULL;
 689   }
 690 
 691   assert (size &lt;= actual_size, &quot;allocation should fit&quot;);
 692 
 693   if (ZeroTLAB) {
 694     // ..and clear it.
 695     Copy::zero_to_words(gclab_buf, actual_size);
 696   } else {
 697     // ...and zap just allocated object.
 698 #ifdef ASSERT
 699     // Skip mangling the space corresponding to the object header to
 700     // ensure that the returned space is not considered parsable by
 701     // any concurrent GC thread.
 702     size_t hdr_size = oopDesc::header_size();
 703     Copy::fill_to_words(gclab_buf + hdr_size, actual_size - hdr_size, badHeapWordVal);
 704 #endif // ASSERT
 705   }
 706   gclab-&gt;set_buf(gclab_buf, actual_size);
 707   return gclab-&gt;allocate(size);
 708 }
 709 
 710 HeapWord* ShenandoahHeap::allocate_new_tlab(size_t min_size,
 711                                             size_t requested_size,
 712                                             size_t* actual_size) {
 713   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_tlab(min_size, requested_size);
 714   HeapWord* res = allocate_memory(req);
 715   if (res != NULL) {
 716     *actual_size = req.actual_size();
 717   } else {
 718     *actual_size = 0;
 719   }
 720   return res;
 721 }
 722 
 723 HeapWord* ShenandoahHeap::allocate_new_gclab(size_t min_size,
 724                                              size_t word_size,
 725                                              size_t* actual_size) {
 726   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_gclab(min_size, word_size);
 727   HeapWord* res = allocate_memory(req);
 728   if (res != NULL) {
 729     *actual_size = req.actual_size();
 730   } else {
 731     *actual_size = 0;
 732   }
 733   return res;
 734 }
 735 
 736 ShenandoahHeap* ShenandoahHeap::heap() {
 737   CollectedHeap* heap = Universe::heap();
 738   assert(heap != NULL, &quot;Unitialized access to ShenandoahHeap::heap()&quot;);
 739   assert(heap-&gt;kind() == CollectedHeap::Shenandoah, &quot;not a shenandoah heap&quot;);
 740   return (ShenandoahHeap*) heap;
 741 }
 742 
 743 ShenandoahHeap* ShenandoahHeap::heap_no_check() {
 744   CollectedHeap* heap = Universe::heap();
 745   return (ShenandoahHeap*) heap;
 746 }
 747 
 748 HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest&amp; req) {
 749   ShenandoahAllocTrace trace_alloc(req.size(), req.type());
 750 
 751   intptr_t pacer_epoch = 0;
 752   bool in_new_region = false;
 753   HeapWord* result = NULL;
 754 
 755   if (req.is_mutator_alloc()) {
 756     if (ShenandoahPacing) {
 757       pacer()-&gt;pace_for_alloc(req.size());
 758       pacer_epoch = pacer()-&gt;epoch();
 759     }
 760 
 761     if (!ShenandoahAllocFailureALot || !should_inject_alloc_failure()) {
 762       result = allocate_memory_under_lock(req, in_new_region);
 763     }
 764 
 765     // Allocation failed, block until control thread reacted, then retry allocation.
 766     //
 767     // It might happen that one of the threads requesting allocation would unblock
 768     // way later after GC happened, only to fail the second allocation, because
 769     // other threads have already depleted the free storage. In this case, a better
 770     // strategy is to try again, as long as GC makes progress.
 771     //
 772     // Then, we need to make sure the allocation was retried after at least one
 773     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 774 
 775     size_t tries = 0;
 776 
 777     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 778       tries++;
 779       control_thread()-&gt;handle_alloc_failure(req.size());
 780       result = allocate_memory_under_lock(req, in_new_region);
 781     }
 782 
 783     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 784       tries++;
 785       control_thread()-&gt;handle_alloc_failure(req.size());
 786       result = allocate_memory_under_lock(req, in_new_region);
 787     }
 788 
 789   } else {
 790     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 791     result = allocate_memory_under_lock(req, in_new_region);
 792     // Do not call handle_alloc_failure() here, because we cannot block.
<a name="49" id="anc49"></a><span class="line-modified"> 793     // The allocation failure would be handled by the WB slowpath with handle_alloc_failure_evac().</span>
 794   }
 795 
 796   if (in_new_region) {
 797     control_thread()-&gt;notify_heap_changed();
 798   }
 799 
 800   if (result != NULL) {
 801     size_t requested = req.size();
 802     size_t actual = req.actual_size();
 803 
 804     assert (req.is_lab_alloc() || (requested == actual),
 805             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 806             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 807 
 808     if (req.is_mutator_alloc()) {
 809       notify_mutator_alloc_words(actual, false);
 810 
 811       // If we requested more than we were granted, give the rest back to pacer.
 812       // This only matters if we are in the same pacing epoch: do not try to unpace
 813       // over the budget for the other phase.
 814       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 815         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 816       }
 817     } else {
 818       increase_used(actual*HeapWordSize);
 819     }
 820   }
 821 
 822   return result;
 823 }
 824 
 825 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 826   ShenandoahHeapLocker locker(lock());
 827   return _free_set-&gt;allocate(req, in_new_region);
 828 }
 829 
<a name="50" id="anc50"></a><span class="line-removed"> 830 class ShenandoahMemAllocator : public MemAllocator {</span>
<span class="line-removed"> 831 private:</span>
<span class="line-removed"> 832   MemAllocator&amp; _initializer;</span>
<span class="line-removed"> 833 public:</span>
<span class="line-removed"> 834   ShenandoahMemAllocator(MemAllocator&amp; initializer, Klass* klass, size_t word_size, Thread* thread) :</span>
<span class="line-removed"> 835   MemAllocator(klass, word_size + ShenandoahBrooksPointer::word_size(), thread),</span>
<span class="line-removed"> 836     _initializer(initializer) {}</span>
<span class="line-removed"> 837 </span>
<span class="line-removed"> 838 protected:</span>
<span class="line-removed"> 839   virtual HeapWord* mem_allocate(Allocation&amp; allocation) const {</span>
<span class="line-removed"> 840     HeapWord* result = MemAllocator::mem_allocate(allocation);</span>
<span class="line-removed"> 841     // Initialize brooks-pointer</span>
<span class="line-removed"> 842     if (result != NULL) {</span>
<span class="line-removed"> 843       result += ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed"> 844       ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-removed"> 845       assert(! ShenandoahHeap::heap()-&gt;in_collection_set(result), &quot;never allocate in targetted region&quot;);</span>
<span class="line-removed"> 846     }</span>
<span class="line-removed"> 847     return result;</span>
<span class="line-removed"> 848   }</span>
<span class="line-removed"> 849 </span>
<span class="line-removed"> 850   virtual oop initialize(HeapWord* mem) const {</span>
<span class="line-removed"> 851      return _initializer.initialize(mem);</span>
<span class="line-removed"> 852   }</span>
<span class="line-removed"> 853 };</span>
<span class="line-removed"> 854 </span>
<span class="line-removed"> 855 oop ShenandoahHeap::obj_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed"> 856   ObjAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed"> 857   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 858   return allocator.allocate();</span>
<span class="line-removed"> 859 }</span>
<span class="line-removed"> 860 </span>
<span class="line-removed"> 861 oop ShenandoahHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {</span>
<span class="line-removed"> 862   ObjArrayAllocator initializer(klass, size, length, do_zero, THREAD);</span>
<span class="line-removed"> 863   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 864   return allocator.allocate();</span>
<span class="line-removed"> 865 }</span>
<span class="line-removed"> 866 </span>
<span class="line-removed"> 867 oop ShenandoahHeap::class_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed"> 868   ClassAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed"> 869   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 870   return allocator.allocate();</span>
<span class="line-removed"> 871 }</span>
<span class="line-removed"> 872 </span>
 873 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 874                                         bool*  gc_overhead_limit_was_exceeded) {
 875   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 876   return allocate_memory(req);
 877 }
 878 
 879 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 880                                                              size_t size,
 881                                                              Metaspace::MetadataType mdtype) {
 882   MetaWord* result;
 883 
 884   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 885   if (heuristics()-&gt;can_unload_classes()) {
 886     ShenandoahHeuristics* h = heuristics();
 887     h-&gt;record_metaspace_oom();
 888   }
 889 
 890   // Expand and retry allocation
 891   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 892   if (result != NULL) {
 893     return result;
 894   }
 895 
 896   // Start full GC
 897   collect(GCCause::_metadata_GC_clear_soft_refs);
 898 
 899   // Retry allocation
 900   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 901   if (result != NULL) {
 902     return result;
 903   }
 904 
 905   // Expand and retry allocation
 906   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 907   if (result != NULL) {
 908     return result;
 909   }
 910 
 911   // Out of memory
 912   return NULL;
 913 }
 914 
<a name="51" id="anc51"></a><span class="line-removed"> 915 void ShenandoahHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {</span>
<span class="line-removed"> 916   HeapWord* obj = tlab_post_allocation_setup(start);</span>
<span class="line-removed"> 917   CollectedHeap::fill_with_object(obj, end);</span>
<span class="line-removed"> 918 }</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920 size_t ShenandoahHeap::min_dummy_object_size() const {</span>
<span class="line-removed"> 921   return CollectedHeap::min_dummy_object_size() + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed"> 922 }</span>
<span class="line-removed"> 923 </span>
<span class="line-removed"> 924 class ShenandoahEvacuateUpdateRootsClosure: public BasicOopIterateClosure {</span>
<span class="line-removed"> 925 private:</span>
<span class="line-removed"> 926   ShenandoahHeap* _heap;</span>
<span class="line-removed"> 927   Thread* _thread;</span>
<span class="line-removed"> 928 public:</span>
<span class="line-removed"> 929   ShenandoahEvacuateUpdateRootsClosure() :</span>
<span class="line-removed"> 930     _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {</span>
<span class="line-removed"> 931   }</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933 private:</span>
<span class="line-removed"> 934   template &lt;class T&gt;</span>
<span class="line-removed"> 935   void do_oop_work(T* p) {</span>
<span class="line-removed"> 936     assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);</span>
<span class="line-removed"> 937 </span>
<span class="line-removed"> 938     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 939     if (! CompressedOops::is_null(o)) {</span>
<span class="line-removed"> 940       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed"> 941       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="line-removed"> 942         shenandoah_assert_marked(p, obj);</span>
<span class="line-removed"> 943         oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed"> 944         if (oopDesc::equals_raw(resolved, obj)) {</span>
<span class="line-removed"> 945           resolved = _heap-&gt;evacuate_object(obj, _thread);</span>
<span class="line-removed"> 946         }</span>
<span class="line-removed"> 947         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, resolved);</span>
<span class="line-removed"> 948       }</span>
<span class="line-removed"> 949     }</span>
<span class="line-removed"> 950   }</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952 public:</span>
<span class="line-removed"> 953   void do_oop(oop* p) {</span>
<span class="line-removed"> 954     do_oop_work(p);</span>
<span class="line-removed"> 955   }</span>
<span class="line-removed"> 956   void do_oop(narrowOop* p) {</span>
<span class="line-removed"> 957     do_oop_work(p);</span>
<span class="line-removed"> 958   }</span>
<span class="line-removed"> 959 };</span>
<span class="line-removed"> 960 </span>
 961 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 962 private:
 963   ShenandoahHeap* const _heap;
 964   Thread* const _thread;
 965 public:
 966   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 967     _heap(heap), _thread(Thread::current()) {}
 968 
 969   void do_object(oop p) {
 970     shenandoah_assert_marked(NULL, p);
<a name="52" id="anc52"></a><span class="line-modified"> 971     if (oopDesc::equals_raw(p, ShenandoahBarrierSet::resolve_forwarded_not_null(p))) {</span>
 972       _heap-&gt;evacuate_object(p, _thread);
 973     }
 974   }
 975 };
 976 
 977 class ShenandoahEvacuationTask : public AbstractGangTask {
 978 private:
 979   ShenandoahHeap* const _sh;
 980   ShenandoahCollectionSet* const _cs;
 981   bool _concurrent;
 982 public:
 983   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 984                            ShenandoahCollectionSet* cs,
 985                            bool concurrent) :
 986     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 987     _sh(sh),
 988     _cs(cs),
 989     _concurrent(concurrent)
 990   {}
 991 
 992   void work(uint worker_id) {
 993     if (_concurrent) {
 994       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 995       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 996       ShenandoahEvacOOMScope oom_evac_scope;
 997       do_work();
 998     } else {
 999       ShenandoahParallelWorkerSession worker_session(worker_id);
1000       ShenandoahEvacOOMScope oom_evac_scope;
1001       do_work();
1002     }
1003   }
1004 
1005 private:
1006   void do_work() {
1007     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
1008     ShenandoahHeapRegion* r;
1009     while ((r =_cs-&gt;claim_next()) != NULL) {
<a name="53" id="anc53"></a><span class="line-modified">1010       assert(r-&gt;has_live(), &quot;all-garbage regions are reclaimed early&quot;);</span>
1011       _sh-&gt;marked_object_iterate(r, &amp;cl);
1012 
1013       if (ShenandoahPacing) {
1014         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
1015       }
1016 
1017       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
1018         break;
1019       }
1020     }
1021   }
1022 };
1023 
1024 void ShenandoahHeap::trash_cset_regions() {
1025   ShenandoahHeapLocker locker(lock());
1026 
1027   ShenandoahCollectionSet* set = collection_set();
1028   ShenandoahHeapRegion* r;
1029   set-&gt;clear_current_index();
1030   while ((r = set-&gt;next()) != NULL) {
1031     r-&gt;make_trash();
1032   }
1033   collection_set()-&gt;clear();
1034 }
1035 
1036 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
1037   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1038   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1039   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
1040   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start (previous, next)&quot;);
1041   st-&gt;print_cr(&quot;SN=alloc sequence numbers (first mutator, last mutator, first gc, last gc)&quot;);
1042 
1043   for (size_t i = 0; i &lt; num_regions(); i++) {
1044     get_region(i)-&gt;print_on(st);
1045   }
1046 }
1047 
1048 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1049   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1050 
<a name="54" id="anc54"></a><span class="line-modified">1051   oop humongous_obj = oop(start-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">1052   size_t size = humongous_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
1053   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1054   size_t index = start-&gt;region_number() + required_regions - 1;
1055 
1056   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1057 
1058   for(size_t i = 0; i &lt; required_regions; i++) {
1059     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1060     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1061     ShenandoahHeapRegion* region = get_region(index --);
1062 
1063     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1064     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1065 
1066     region-&gt;make_trash_immediate();
1067   }
1068 }
1069 
1070 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1071 public:
1072   void do_thread(Thread* thread) {
1073     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1074     assert(gclab != NULL, &quot;GCLAB should be initialized for %s&quot;, thread-&gt;name());
1075     gclab-&gt;retire();
1076   }
1077 };
1078 
1079 void ShenandoahHeap::make_parsable(bool retire_tlabs) {
1080   if (UseTLAB) {
1081     CollectedHeap::ensure_parsability(retire_tlabs);
1082   }
1083   ShenandoahRetireGCLABClosure cl;
1084   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1085     cl.do_thread(t);
1086   }
1087   workers()-&gt;threads_do(&amp;cl);
1088 }
1089 
1090 void ShenandoahHeap::resize_tlabs() {
1091   CollectedHeap::resize_all_tlabs();
1092 }
1093 
1094 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1095 private:
1096   ShenandoahRootEvacuator* _rp;
1097 
1098 public:
1099   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1100     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1101     _rp(rp) {}
1102 
1103   void work(uint worker_id) {
1104     ShenandoahParallelWorkerSession worker_session(worker_id);
1105     ShenandoahEvacOOMScope oom_evac_scope;
<a name="55" id="anc55"></a><span class="line-modified">1106     ShenandoahEvacuateUpdateRootsClosure cl;</span>
<span class="line-removed">1107 </span>
1108     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
<a name="56" id="anc56"></a><span class="line-modified">1109     _rp-&gt;process_evacuate_roots(&amp;cl, &amp;blobsCl, worker_id);</span>
1110   }
1111 };
1112 
1113 void ShenandoahHeap::evacuate_and_update_roots() {
<a name="57" id="anc57"></a><span class="line-modified">1114 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
1115   DerivedPointerTable::clear();
1116 #endif
1117   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
<a name="58" id="anc58"></a><span class="line-removed">1118 </span>
1119   {
<a name="59" id="anc59"></a><span class="line-modified">1120     ShenandoahRootEvacuator rp(this, workers()-&gt;active_workers(), ShenandoahPhaseTimings::init_evac);</span>




1121     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1122     workers()-&gt;run_task(&amp;roots_task);
1123   }
1124 
<a name="60" id="anc60"></a><span class="line-modified">1125 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
1126   DerivedPointerTable::update_pointers();
1127 #endif
1128 }
1129 
<a name="61" id="anc61"></a><span class="line-removed">1130 void ShenandoahHeap::roots_iterate(OopClosure* cl) {</span>
<span class="line-removed">1131   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);</span>
<span class="line-removed">1132 </span>
<span class="line-removed">1133   CodeBlobToOopClosure blobsCl(cl, false);</span>
<span class="line-removed">1134   CLDToOopClosure cldCl(cl, ClassLoaderData::_claim_strong);</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
<span class="line-removed">1137   rp.process_all_roots(cl, NULL, &amp;cldCl, &amp;blobsCl, NULL, 0);</span>
<span class="line-removed">1138 }</span>
<span class="line-removed">1139 </span>
1140 // Returns size in bytes
1141 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1142   if (ShenandoahElasticTLAB) {
1143     // With Elastic TLABs, return the max allowed size, and let the allocation path
1144     // figure out the safe size for current allocation.
1145     return ShenandoahHeapRegion::max_tlab_size_bytes();
1146   } else {
1147     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1148   }
1149 }
1150 
1151 size_t ShenandoahHeap::max_tlab_size() const {
1152   // Returns size in words
1153   return ShenandoahHeapRegion::max_tlab_size_words();
1154 }
1155 
1156 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1157 public:
1158   void do_thread(Thread* thread) {
1159     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
1160     gclab-&gt;retire();
1161     if (ShenandoahThreadLocalData::gclab_size(thread) &gt; 0) {
1162       ShenandoahThreadLocalData::set_gclab_size(thread, 0);
1163     }
1164   }
1165 };
1166 
1167 void ShenandoahHeap::retire_and_reset_gclabs() {
1168   ShenandoahRetireAndResetGCLABClosure cl;
1169   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1170     cl.do_thread(t);
1171   }
1172   workers()-&gt;threads_do(&amp;cl);
1173 }
1174 
1175 void ShenandoahHeap::collect(GCCause::Cause cause) {
1176   control_thread()-&gt;request_gc(cause);
1177 }
1178 
1179 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1180   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1181 }
1182 
<a name="62" id="anc62"></a><span class="line-removed">1183 CollectorPolicy* ShenandoahHeap::collector_policy() const {</span>
<span class="line-removed">1184   return _shenandoah_policy;</span>
<span class="line-removed">1185 }</span>
<span class="line-removed">1186 </span>
1187 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
1188   Space* sp = heap_region_containing(addr);
1189   if (sp != NULL) {
1190     return sp-&gt;block_start(addr);
1191   }
1192   return NULL;
1193 }
1194 
1195 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
1196   Space* sp = heap_region_containing(addr);
1197   return sp-&gt;block_is_obj(addr);
1198 }
1199 
<a name="63" id="anc63"></a>



1200 jlong ShenandoahHeap::millis_since_last_gc() {
1201   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1202   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1203   return (jlong)v;
1204 }
1205 
1206 void ShenandoahHeap::prepare_for_verify() {
1207   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1208     make_parsable(false);
1209   }
1210 }
1211 
1212 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1213   workers()-&gt;print_worker_threads_on(st);
1214   if (ShenandoahStringDedup::is_enabled()) {
1215     ShenandoahStringDedup::print_worker_threads_on(st);
1216   }
1217 }
1218 
1219 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1220   workers()-&gt;threads_do(tcl);
<a name="64" id="anc64"></a><span class="line-modified">1221   _safepoint_workers-&gt;threads_do(tcl);</span>


1222   if (ShenandoahStringDedup::is_enabled()) {
1223     ShenandoahStringDedup::threads_do(tcl);
1224   }
1225 }
1226 
1227 void ShenandoahHeap::print_tracing_info() const {
1228   LogTarget(Info, gc, stats) lt;
1229   if (lt.is_enabled()) {
1230     ResourceMark rm;
1231     LogStream ls(lt);
1232 
1233     phase_timings()-&gt;print_on(&amp;ls);
1234 
1235     ls.cr();
1236     ls.cr();
1237 
1238     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1239 
1240     ls.cr();
1241     ls.cr();
1242 
1243     if (ShenandoahPacing) {
1244       pacer()-&gt;print_on(&amp;ls);
1245     }
1246 
1247     ls.cr();
1248     ls.cr();
1249 
1250     if (ShenandoahAllocationTrace) {
1251       assert(alloc_tracker() != NULL, &quot;Must be&quot;);
1252       alloc_tracker()-&gt;print_on(&amp;ls);
1253     } else {
1254       ls.print_cr(&quot;  Allocation tracing is disabled, use -XX:+ShenandoahAllocationTrace to enable.&quot;);
1255     }
1256   }
1257 }
1258 
1259 void ShenandoahHeap::verify(VerifyOption vo) {
1260   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
1261     if (ShenandoahVerify) {
1262       verifier()-&gt;verify_generic(vo);
1263     } else {
1264       // TODO: Consider allocating verification bitmaps on demand,
1265       // and turn this on unconditionally.
1266     }
1267   }
1268 }
1269 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1270   return _free_set-&gt;capacity();
1271 }
1272 
1273 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1274 private:
1275   MarkBitMap* _bitmap;
1276   Stack&lt;oop,mtGC&gt;* _oop_stack;
1277 
1278   template &lt;class T&gt;
1279   void do_oop_work(T* p) {
1280     T o = RawAccess&lt;&gt;::oop_load(p);
1281     if (!CompressedOops::is_null(o)) {
1282       oop obj = CompressedOops::decode_not_null(o);
<a name="65" id="anc65"></a><span class="line-modified">1283       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>















1284       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<a name="66" id="anc66"></a><span class="line-modified">1285       if (!_bitmap-&gt;is_marked((HeapWord*) obj)) {</span>
<span class="line-modified">1286         _bitmap-&gt;mark((HeapWord*) obj);</span>
1287         _oop_stack-&gt;push(obj);
1288       }
1289     }
1290   }
1291 public:
1292   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1293     _bitmap(bitmap), _oop_stack(oop_stack) {}
1294   void do_oop(oop* p)       { do_oop_work(p); }
1295   void do_oop(narrowOop* p) { do_oop_work(p); }
1296 };
1297 
1298 /*
1299  * This is public API, used in preparation of object_iterate().
1300  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1301  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1302  * control, we call SH::make_tlabs_parsable().
1303  */
1304 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1305   // No-op.
1306 }
1307 
1308 /*
1309  * Iterates objects in the heap. This is public API, used for, e.g., heap dumping.
1310  *
1311  * We cannot safely iterate objects by doing a linear scan at random points in time. Linear
1312  * scanning needs to deal with dead objects, which may have dead Klass* pointers (e.g.
1313  * calling oopDesc::size() would crash) or dangling reference fields (crashes) etc. Linear
1314  * scanning therefore depends on having a valid marking bitmap to support it. However, we only
1315  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1316  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1317  * wiped the bitmap in preparation for next marking).
1318  *
1319  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1320  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1321  * is allowed to report dead objects, but is not required to do so.
1322  */
1323 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1324   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1325   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1326     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1327     return;
1328   }
1329 
1330   // Reset bitmap
1331   _aux_bit_map.clear();
1332 
1333   Stack&lt;oop,mtGC&gt; oop_stack;
1334 
<a name="67" id="anc67"></a><span class="line-modified">1335   // First, we process all GC roots. This populates the work stack with initial objects.</span>
<span class="line-modified">1336   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
1337   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
<a name="68" id="anc68"></a><span class="line-modified">1338   CLDToOopClosure clds(&amp;oops, ClassLoaderData::_claim_none);</span>
<span class="line-modified">1339   CodeBlobToOopClosure blobs(&amp;oops, false);</span>
<span class="line-modified">1340   rp.process_all_roots(&amp;oops, &amp;oops, &amp;clds, &amp;blobs, NULL, 0);</span>





1341 
1342   // Work through the oop stack to traverse heap.
1343   while (! oop_stack.is_empty()) {
1344     oop obj = oop_stack.pop();
1345     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1346     cl-&gt;do_object(obj);
1347     obj-&gt;oop_iterate(&amp;oops);
1348   }
1349 
1350   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1351 
1352   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1353     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1354   }
1355 }
1356 
<a name="69" id="anc69"></a><span class="line-modified">1357 void ShenandoahHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-modified">1358   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);</span>
<span class="line-modified">1359   object_iterate(cl);</span>


1360 }
1361 
1362 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1363   for (size_t i = 0; i &lt; num_regions(); i++) {
1364     ShenandoahHeapRegion* current = get_region(i);
1365     blk-&gt;heap_region_do(current);
1366   }
1367 }
1368 
1369 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1370 private:
1371   ShenandoahHeap* const _heap;
1372   ShenandoahHeapRegionClosure* const _blk;
1373 
1374   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
1375   volatile size_t _index;
1376   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
1377 
1378 public:
1379   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1380           AbstractGangTask(&quot;Parallel Region Task&quot;),
1381           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1382 
1383   void work(uint worker_id) {
1384     size_t stride = ShenandoahParallelRegionStride;
1385 
1386     size_t max = _heap-&gt;num_regions();
1387     while (_index &lt; max) {
<a name="70" id="anc70"></a><span class="line-modified">1388       size_t cur = Atomic::add(stride, &amp;_index) - stride;</span>
1389       size_t start = cur;
1390       size_t end = MIN2(cur + stride, max);
1391       if (start &gt;= max) break;
1392 
1393       for (size_t i = cur; i &lt; end; i++) {
1394         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1395         _blk-&gt;heap_region_do(current);
1396       }
1397     }
1398   }
1399 };
1400 
1401 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1402   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1403   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1404     ShenandoahParallelHeapRegionTask task(blk);
1405     workers()-&gt;run_task(&amp;task);
1406   } else {
1407     heap_region_iterate(blk);
1408   }
1409 }
1410 
1411 class ShenandoahClearLivenessClosure : public ShenandoahHeapRegionClosure {
1412 private:
1413   ShenandoahMarkingContext* const _ctx;
1414 public:
1415   ShenandoahClearLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
1416 
1417   void heap_region_do(ShenandoahHeapRegion* r) {
1418     if (r-&gt;is_active()) {
1419       r-&gt;clear_live_data();
1420       _ctx-&gt;capture_top_at_mark_start(r);
1421     } else {
1422       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1423       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1424              &quot;Region &quot; SIZE_FORMAT &quot; should already have correct TAMS&quot;, r-&gt;region_number());
1425     }
1426   }
1427 
1428   bool is_thread_safe() { return true; }
1429 };
1430 
1431 void ShenandoahHeap::op_init_mark() {
1432   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1433   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
1434 
1435   assert(marking_context()-&gt;is_bitmap_clear(), &quot;need clear marking bitmap&quot;);
1436   assert(!marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
1437 
1438   if (ShenandoahVerify) {
1439     verifier()-&gt;verify_before_concmark();
1440   }
1441 
1442   if (VerifyBeforeGC) {
1443     Universe::verify();
1444   }
1445 
1446   set_concurrent_mark_in_progress(true);
1447   // We need to reset all TLABs because we&#39;d lose marks on all objects allocated in them.
1448   {
1449     ShenandoahGCPhase phase(ShenandoahPhaseTimings::make_parsable);
1450     make_parsable(true);
1451   }
1452 
1453   {
1454     ShenandoahGCPhase phase(ShenandoahPhaseTimings::clear_liveness);
1455     ShenandoahClearLivenessClosure clc;
1456     parallel_heap_region_iterate(&amp;clc);
1457   }
1458 
1459   // Make above changes visible to worker threads
1460   OrderAccess::fence();
1461 
1462   concurrent_mark()-&gt;mark_roots(ShenandoahPhaseTimings::scan_roots);
1463 
1464   if (UseTLAB) {
1465     ShenandoahGCPhase phase(ShenandoahPhaseTimings::resize_tlabs);
1466     resize_tlabs();
1467   }
1468 
1469   if (ShenandoahPacing) {
1470     pacer()-&gt;setup_for_mark();
1471   }
1472 }
1473 
1474 void ShenandoahHeap::op_mark() {
1475   concurrent_mark()-&gt;mark_from_roots();
1476 }
1477 
1478 class ShenandoahCompleteLivenessClosure : public ShenandoahHeapRegionClosure {
1479 private:
1480   ShenandoahMarkingContext* const _ctx;
1481 public:
1482   ShenandoahCompleteLivenessClosure() : _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
1483 
1484   void heap_region_do(ShenandoahHeapRegion* r) {
1485     if (r-&gt;is_active()) {
1486       HeapWord *tams = _ctx-&gt;top_at_mark_start(r);
1487       HeapWord *top = r-&gt;top();
1488       if (top &gt; tams) {
1489         r-&gt;increase_live_data_alloc_words(pointer_delta(top, tams));
1490       }
1491     } else {
1492       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1493       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1494              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1495     }
1496   }
1497 
1498   bool is_thread_safe() { return true; }
1499 };
1500 
1501 void ShenandoahHeap::op_final_mark() {
1502   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1503 
1504   // It is critical that we
1505   // evacuate roots right after finishing marking, so that we don&#39;t
1506   // get unmarked objects in the roots.
1507 
1508   if (!cancelled_gc()) {
1509     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1510 
<a name="71" id="anc71"></a><span class="line-modified">1511     if (has_forwarded_objects()) {</span>
<span class="line-modified">1512       concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-modified">1513     }</span>
1514 
<a name="72" id="anc72"></a><span class="line-modified">1515     stop_concurrent_marking();</span>
1516 
<a name="73" id="anc73"></a>














1517     {
1518       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
<a name="74" id="anc74"></a><span class="line-removed">1519 </span>
<span class="line-removed">1520       // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-removed">1521       // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
1522       ShenandoahCompleteLivenessClosure cl;
1523       parallel_heap_region_iterate(&amp;cl);
1524     }
1525 
<a name="75" id="anc75"></a>
1526     {
<a name="76" id="anc76"></a><span class="line-modified">1527       ShenandoahGCPhase prepare_evac(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-removed">1528 </span>
1529       make_parsable(true);
<a name="77" id="anc77"></a>
1530 
<a name="78" id="anc78"></a>










1531       trash_cset_regions();
<a name="79" id="anc79"></a>
1532 
<a name="80" id="anc80"></a><span class="line-modified">1533       {</span>
<span class="line-modified">1534         ShenandoahHeapLocker locker(lock());</span>
<span class="line-modified">1535         _collection_set-&gt;clear();</span>
<span class="line-modified">1536         _free_set-&gt;clear();</span>


1537 
<a name="81" id="anc81"></a><span class="line-modified">1538         heuristics()-&gt;choose_collection_set(_collection_set);</span>
1539 
<a name="82" id="anc82"></a><span class="line-modified">1540         _free_set-&gt;rebuild();</span>
<span class="line-modified">1541       }</span>




1542     }
1543 
1544     // If collection set has candidates, start evacuation.
1545     // Otherwise, bypass the rest of the cycle.
1546     if (!collection_set()-&gt;is_empty()) {
1547       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1548 
1549       if (ShenandoahVerify) {
1550         verifier()-&gt;verify_before_evacuation();
1551       }
1552 
1553       set_evacuation_in_progress(true);
1554       // From here on, we need to update references.
1555       set_has_forwarded_objects(true);
1556 
<a name="83" id="anc83"></a><span class="line-modified">1557       evacuate_and_update_roots();</span>





1558 
1559       if (ShenandoahPacing) {
1560         pacer()-&gt;setup_for_evac();
1561       }
<a name="84" id="anc84"></a>














1562     } else {
1563       if (ShenandoahVerify) {
1564         verifier()-&gt;verify_after_concmark();
1565       }
1566 
1567       if (VerifyAfterGC) {
1568         Universe::verify();
1569       }
1570     }
1571 
1572   } else {
<a name="85" id="anc85"></a>

1573     concurrent_mark()-&gt;cancel();
<a name="86" id="anc86"></a><span class="line-modified">1574     stop_concurrent_marking();</span>
1575 
1576     if (process_references()) {
1577       // Abandon reference processing right away: pre-cleaning must have failed.
1578       ReferenceProcessor *rp = ref_processor();
1579       rp-&gt;disable_discovery();
1580       rp-&gt;abandon_partial_discovery();
1581       rp-&gt;verify_no_references_recorded();
1582     }
1583   }
1584 }
1585 
1586 void ShenandoahHeap::op_final_evac() {
1587   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1588 
1589   set_evacuation_in_progress(false);
1590 
<a name="87" id="anc87"></a><span class="line-modified">1591   retire_and_reset_gclabs();</span>



1592 
1593   if (ShenandoahVerify) {
1594     verifier()-&gt;verify_after_evacuation();
1595   }
1596 
1597   if (VerifyAfterGC) {
1598     Universe::verify();
1599   }
1600 }
1601 
1602 void ShenandoahHeap::op_conc_evac() {
1603   ShenandoahEvacuationTask task(this, _collection_set, true);
1604   workers()-&gt;run_task(&amp;task);
1605 }
1606 
1607 void ShenandoahHeap::op_stw_evac() {
1608   ShenandoahEvacuationTask task(this, _collection_set, false);
1609   workers()-&gt;run_task(&amp;task);
1610 }
1611 
1612 void ShenandoahHeap::op_updaterefs() {
1613   update_heap_references(true);
1614 }
1615 
1616 void ShenandoahHeap::op_cleanup() {
1617   free_set()-&gt;recycle_trash();
1618 }
1619 
<a name="88" id="anc88"></a>

































































































































































1620 void ShenandoahHeap::op_reset() {
1621   reset_mark_bitmap();
1622 }
1623 
1624 void ShenandoahHeap::op_preclean() {
1625   concurrent_mark()-&gt;preclean_weak_refs();
1626 }
1627 
1628 void ShenandoahHeap::op_init_traversal() {
1629   traversal_gc()-&gt;init_traversal_collection();
1630 }
1631 
1632 void ShenandoahHeap::op_traversal() {
1633   traversal_gc()-&gt;concurrent_traversal_collection();
1634 }
1635 
1636 void ShenandoahHeap::op_final_traversal() {
1637   traversal_gc()-&gt;final_traversal_collection();
1638 }
1639 
1640 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1641   ShenandoahMetricsSnapshot metrics;
1642   metrics.snap_before();
1643 
1644   full_gc()-&gt;do_it(cause);
1645   if (UseTLAB) {
1646     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1647     resize_all_tlabs();
1648   }
1649 
1650   metrics.snap_after();
<a name="89" id="anc89"></a><span class="line-removed">1651   metrics.print();</span>
1652 
<a name="90" id="anc90"></a><span class="line-modified">1653   if (metrics.is_good_progress(&quot;Full GC&quot;)) {</span>
1654     _progress_last_gc.set();
1655   } else {
1656     // Nothing to do. Tell the allocation path that we have failed to make
1657     // progress, and it can finally fail.
1658     _progress_last_gc.unset();
1659   }
1660 }
1661 
1662 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1663   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1664   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1665   // some phase, we have to upgrade the Degenerate GC to Full GC.
1666 
1667   clear_cancelled_gc();
1668 
1669   ShenandoahMetricsSnapshot metrics;
1670   metrics.snap_before();
1671 
1672   switch (point) {
1673     case _degenerated_traversal:
1674       {
1675         // Drop the collection set. Note: this leaves some already forwarded objects
1676         // behind, which may be problematic, see comments for ShenandoahEvacAssist
1677         // workarounds in ShenandoahTraversalHeuristics.
1678 
1679         ShenandoahHeapLocker locker(lock());
1680         collection_set()-&gt;clear_current_index();
1681         for (size_t i = 0; i &lt; collection_set()-&gt;count(); i++) {
1682           ShenandoahHeapRegion* r = collection_set()-&gt;next();
1683           r-&gt;make_regular_bypass();
1684         }
1685         collection_set()-&gt;clear();
1686       }
1687       op_final_traversal();
1688       op_cleanup();
1689       return;
1690 
1691     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1692     // but enters it at different points, depending on which concurrent phase had
1693     // degenerated.
1694 
1695     case _degenerated_outside_cycle:
1696       // We have degenerated from outside the cycle, which means something is bad with
1697       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1698       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1699       // we can do the most aggressive degen cycle, which includes processing references and
1700       // class unloading, unless those features are explicitly disabled.
1701       //
1702       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1703       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1704       set_process_references(heuristics()-&gt;can_process_references());
1705       set_unload_classes(heuristics()-&gt;can_unload_classes());
1706 
<a name="91" id="anc91"></a><span class="line-modified">1707       if (heuristics()-&gt;can_do_traversal_gc()) {</span>
1708         // Not possible to degenerate from here, upgrade to Full GC right away.
1709         cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1710         op_degenerated_fail();
1711         return;
1712       }
1713 
1714       op_reset();
1715 
1716       op_init_mark();
1717       if (cancelled_gc()) {
1718         op_degenerated_fail();
1719         return;
1720       }
1721 
1722     case _degenerated_mark:
1723       op_final_mark();
1724       if (cancelled_gc()) {
1725         op_degenerated_fail();
1726         return;
1727       }
1728 
1729       op_cleanup();
1730 
1731     case _degenerated_evac:
1732       // If heuristics thinks we should do the cycle, this flag would be set,
1733       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1734       if (is_evacuation_in_progress()) {
1735 
1736         // Degeneration under oom-evac protocol might have left some objects in
1737         // collection set un-evacuated. Restart evacuation from the beginning to
1738         // capture all objects. For all the objects that are already evacuated,
1739         // it would be a simple check, which is supposed to be fast. This is also
1740         // safe to do even without degeneration, as CSet iterator is at beginning
1741         // in preparation for evacuation anyway.
<a name="92" id="anc92"></a><span class="line-modified">1742         collection_set()-&gt;clear_current_index();</span>






















1743 
1744         op_stw_evac();
1745         if (cancelled_gc()) {
1746           op_degenerated_fail();
1747           return;
1748         }
1749       }
1750 
1751       // If heuristics thinks we should do the cycle, this flag would be set,
1752       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1753       if (has_forwarded_objects()) {
1754         op_init_updaterefs();
1755         if (cancelled_gc()) {
1756           op_degenerated_fail();
1757           return;
1758         }
1759       }
1760 
1761     case _degenerated_updaterefs:
1762       if (has_forwarded_objects()) {
1763         op_final_updaterefs();
1764         if (cancelled_gc()) {
1765           op_degenerated_fail();
1766           return;
1767         }
1768       }
1769 
1770       op_cleanup();
1771       break;
1772 
1773     default:
1774       ShouldNotReachHere();
1775   }
1776 
1777   if (ShenandoahVerify) {
1778     verifier()-&gt;verify_after_degenerated();
1779   }
1780 
1781   if (VerifyAfterGC) {
1782     Universe::verify();
1783   }
1784 
1785   metrics.snap_after();
<a name="93" id="anc93"></a><span class="line-removed">1786   metrics.print();</span>
1787 
1788   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
1789   // because that probably means the heap is overloaded and/or fragmented.
<a name="94" id="anc94"></a><span class="line-modified">1790   if (!metrics.is_good_progress(&quot;Degenerated GC&quot;)) {</span>
1791     _progress_last_gc.unset();
1792     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1793     op_degenerated_futile();
1794   } else {
1795     _progress_last_gc.set();
1796   }
1797 }
1798 
1799 void ShenandoahHeap::op_degenerated_fail() {
1800   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
1801   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1802   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1803 }
1804 
1805 void ShenandoahHeap::op_degenerated_futile() {
1806   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1807   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1808 }
1809 
<a name="95" id="anc95"></a><span class="line-removed">1810 void ShenandoahHeap::stop_concurrent_marking() {</span>
<span class="line-removed">1811   assert(is_concurrent_mark_in_progress(), &quot;How else could we get here?&quot;);</span>
<span class="line-removed">1812   if (!cancelled_gc()) {</span>
<span class="line-removed">1813     // If we needed to update refs, and concurrent marking has been cancelled,</span>
<span class="line-removed">1814     // we need to finish updating references.</span>
<span class="line-removed">1815     set_has_forwarded_objects(false);</span>
<span class="line-removed">1816     mark_complete_marking_context();</span>
<span class="line-removed">1817   }</span>
<span class="line-removed">1818   set_concurrent_mark_in_progress(false);</span>
<span class="line-removed">1819 }</span>
<span class="line-removed">1820 </span>
1821 void ShenandoahHeap::force_satb_flush_all_threads() {
1822   if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {
1823     // No need to flush SATBs
1824     return;
1825   }
1826 
1827   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1828     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
1829   }
1830   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
1831   // hurt to &quot;release&quot; the updates here anyway.
1832   OrderAccess::fence();
1833 }
1834 
1835 void ShenandoahHeap::set_gc_state_all_threads(char state) {
1836   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1837     ShenandoahThreadLocalData::set_gc_state(t, state);
1838   }
1839 }
1840 
1841 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
1842   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
1843   _gc_state.set_cond(mask, value);
1844   set_gc_state_all_threads(_gc_state.raw_value());
1845 }
1846 
1847 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
<a name="96" id="anc96"></a><span class="line-modified">1848   set_gc_state_mask(MARKING, in_progress);</span>




1849   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
1850 }
1851 
1852 void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
<a name="97" id="anc97"></a><span class="line-modified">1853    set_gc_state_mask(TRAVERSAL | HAS_FORWARDED, in_progress);</span>
1854    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
1855 }
1856 
1857 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
1858   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
1859   set_gc_state_mask(EVACUATION, in_progress);
1860 }
1861 
<a name="98" id="anc98"></a><span class="line-modified">1862 HeapWord* ShenandoahHeap::tlab_post_allocation_setup(HeapWord* obj) {</span>
<span class="line-modified">1863   // Initialize Brooks pointer for the next object</span>
<span class="line-modified">1864   HeapWord* result = obj + ShenandoahBrooksPointer::word_size();</span>
<span class="line-modified">1865   ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-modified">1866   return result;</span>
<span class="line-modified">1867 }</span>
<span class="line-removed">1868 </span>
<span class="line-removed">1869 ShenandoahForwardedIsAliveClosure::ShenandoahForwardedIsAliveClosure() :</span>
<span class="line-removed">1870   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">1871 }</span>
<span class="line-removed">1872 </span>
<span class="line-removed">1873 ShenandoahIsAliveClosure::ShenandoahIsAliveClosure() :</span>
<span class="line-removed">1874   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">1875 }</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877 bool ShenandoahForwardedIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">1878   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">1879     return false;</span>
<span class="line-removed">1880   }</span>
<span class="line-removed">1881   obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">1882   shenandoah_assert_not_forwarded_if(NULL, obj, ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress() || ShenandoahHeap::heap()-&gt;is_concurrent_traversal_in_progress());</span>
<span class="line-removed">1883   return _mark_context-&gt;is_marked(obj);</span>
<span class="line-removed">1884 }</span>
<span class="line-removed">1885 </span>
<span class="line-removed">1886 bool ShenandoahIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">1887   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">1888     return false;</span>
1889   }
<a name="99" id="anc99"></a><span class="line-removed">1890   shenandoah_assert_not_forwarded(NULL, obj);</span>
<span class="line-removed">1891   return _mark_context-&gt;is_marked(obj);</span>
1892 }
1893 
1894 void ShenandoahHeap::ref_processing_init() {
1895   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
1896 
1897   _ref_processor =
1898     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
1899                            ParallelRefProcEnabled,  // MT processing
1900                            _max_workers,            // Degree of MT processing
1901                            true,                    // MT discovery
1902                            _max_workers,            // Degree of MT discovery
1903                            false,                   // Reference discovery is not atomic
1904                            NULL,                    // No closure, should be installed before use
1905                            true);                   // Scale worker threads
1906 
1907   shenandoah_assert_rp_isalive_not_installed();
1908 }
1909 
1910 GCTracer* ShenandoahHeap::tracer() {
1911   return shenandoah_policy()-&gt;tracer();
1912 }
1913 
1914 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
1915   return _free_set-&gt;used();
1916 }
1917 
1918 bool ShenandoahHeap::try_cancel_gc() {
1919   while (true) {
1920     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
1921     if (prev == CANCELLABLE) return true;
1922     else if (prev == CANCELLED) return false;
1923     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
1924     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
<a name="100" id="anc100"></a><span class="line-modified">1925     {</span>
1926       // We need to provide a safepoint here, otherwise we might
1927       // spin forever if a SP is pending.
1928       ThreadBlockInVM sp(JavaThread::current());
1929       SpinPause();
1930     }
1931   }
1932 }
1933 
1934 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
1935   if (try_cancel_gc()) {
1936     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
1937     log_info(gc)(&quot;%s&quot;, msg.buffer());
1938     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
1939   }
1940 }
1941 
1942 uint ShenandoahHeap::max_workers() {
1943   return _max_workers;
1944 }
1945 
1946 void ShenandoahHeap::stop() {
1947   // The shutdown sequence should be able to terminate when GC is running.
1948 
1949   // Step 0. Notify policy to disable event recording.
1950   _shenandoah_policy-&gt;record_shutdown();
1951 
1952   // Step 1. Notify control thread that we are in shutdown.
1953   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
1954   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
1955   control_thread()-&gt;prepare_for_graceful_shutdown();
1956 
1957   // Step 2. Notify GC workers that we are cancelling GC.
1958   cancel_gc(GCCause::_shenandoah_stop_vm);
1959 
1960   // Step 3. Wait until GC worker exits normally.
1961   control_thread()-&gt;stop();
1962 
1963   // Step 4. Stop String Dedup thread if it is active
1964   if (ShenandoahStringDedup::is_enabled()) {
1965     ShenandoahStringDedup::stop();
1966   }
1967 }
1968 
<a name="101" id="anc101"></a><span class="line-modified">1969 void ShenandoahHeap::unload_classes_and_cleanup_tables(bool full_gc) {</span>
<span class="line-modified">1970   assert(heuristics()-&gt;can_unload_classes(), &quot;Class unloading should be enabled&quot;);</span>
<span class="line-removed">1971 </span>
<span class="line-removed">1972   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-removed">1973                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-removed">1974                                ShenandoahPhaseTimings::purge);</span>
<span class="line-removed">1975 </span>
<span class="line-removed">1976   ShenandoahIsAliveSelector alive;</span>
<span class="line-removed">1977   BoolObjectClosure* is_alive = alive.is_alive_closure();</span>
<span class="line-removed">1978 </span>
1979   bool purged_class;
1980 
1981   // Unload classes and purge SystemDictionary.
1982   {
1983     ShenandoahGCPhase phase(full_gc ?
1984                             ShenandoahPhaseTimings::full_gc_purge_class_unload :
1985                             ShenandoahPhaseTimings::purge_class_unload);
1986     purged_class = SystemDictionary::do_unloading(gc_timer());
1987   }
1988 
1989   {
1990     ShenandoahGCPhase phase(full_gc ?
1991                             ShenandoahPhaseTimings::full_gc_purge_par :
1992                             ShenandoahPhaseTimings::purge_par);
<a name="102" id="anc102"></a><span class="line-modified">1993     uint active = _workers-&gt;active_workers();</span>
<span class="line-modified">1994     ParallelCleaningTask unlink_task(is_alive, active, purged_class, true);</span>

1995     _workers-&gt;run_task(&amp;unlink_task);
1996   }
1997 
1998   {
1999     ShenandoahGCPhase phase(full_gc ?
<a name="103" id="anc103"></a><span class="line-modified">2000                       ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">2001                       ShenandoahPhaseTimings::purge_cldg);</span>
2002     ClassLoaderDataGraph::purge();
2003   }
<a name="104" id="anc104"></a>






















































2004 }
2005 
2006 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<a name="105" id="anc105"></a><span class="line-modified">2007   set_gc_state_mask(HAS_FORWARDED, cond);</span>





2008 }
2009 
2010 void ShenandoahHeap::set_process_references(bool pr) {
2011   _process_references.set_cond(pr);
2012 }
2013 
2014 void ShenandoahHeap::set_unload_classes(bool uc) {
2015   _unload_classes.set_cond(uc);
2016 }
2017 
2018 bool ShenandoahHeap::process_references() const {
2019   return _process_references.is_set();
2020 }
2021 
2022 bool ShenandoahHeap::unload_classes() const {
2023   return _unload_classes.is_set();
2024 }
2025 
2026 address ShenandoahHeap::in_cset_fast_test_addr() {
2027   ShenandoahHeap* heap = ShenandoahHeap::heap();
2028   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2029   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2030 }
2031 
2032 address ShenandoahHeap::cancelled_gc_addr() {
2033   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2034 }
2035 
2036 address ShenandoahHeap::gc_state_addr() {
2037   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2038 }
2039 
2040 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
<a name="106" id="anc106"></a><span class="line-modified">2041   return OrderAccess::load_acquire(&amp;_bytes_allocated_since_gc_start);</span>
2042 }
2043 
2044 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
<a name="107" id="anc107"></a><span class="line-modified">2045   OrderAccess::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);</span>
2046 }
2047 
2048 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2049   _degenerated_gc_in_progress.set_cond(in_progress);
2050 }
2051 
2052 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2053   _full_gc_in_progress.set_cond(in_progress);
2054 }
2055 
2056 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2057   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2058   _full_gc_move_in_progress.set_cond(in_progress);
2059 }
2060 
2061 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2062   set_gc_state_mask(UPDATEREFS, in_progress);
2063 }
2064 
2065 void ShenandoahHeap::register_nmethod(nmethod* nm) {
<a name="108" id="anc108"></a><span class="line-modified">2066   ShenandoahCodeRoots::add_nmethod(nm);</span>
2067 }
2068 
2069 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
<a name="109" id="anc109"></a><span class="line-modified">2070   ShenandoahCodeRoots::remove_nmethod(nm);</span>




2071 }
2072 
2073 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
<a name="110" id="anc110"></a><span class="line-modified">2074   o = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(o);</span>
<span class="line-removed">2075   ShenandoahHeapLocker locker(lock());</span>
<span class="line-removed">2076   heap_region_containing(o)-&gt;make_pinned();</span>
2077   return o;
2078 }
2079 
2080 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
<a name="111" id="anc111"></a><span class="line-modified">2081   o = ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(o);</span>



2082   ShenandoahHeapLocker locker(lock());
<a name="112" id="anc112"></a><span class="line-modified">2083   heap_region_containing(o)-&gt;make_unpinned();</span>
















2084 }
2085 
<a name="113" id="anc113"></a>









2086 GCTimer* ShenandoahHeap::gc_timer() const {
2087   return _gc_timer;
2088 }
2089 
<a name="114" id="anc114"></a>




















2090 #ifdef ASSERT
2091 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2092   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2093 
2094   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
2095     if (UseDynamicNumberOfGCThreads ||
2096         (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2097       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2098     } else {
2099       // Use ParallelGCThreads inside safepoints
2100       assert(nworkers == ParallelGCThreads, &quot;Use ParalleGCThreads within safepoints&quot;);
2101     }
2102   } else {
2103     if (UseDynamicNumberOfGCThreads ||
2104         (FLAG_IS_DEFAULT(ConcGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2105       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2106     } else {
2107       // Use ConcGCThreads outside safepoints
2108       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2109     }
2110   }
2111 }
2112 #endif
2113 
2114 ShenandoahVerifier* ShenandoahHeap::verifier() {
2115   guarantee(ShenandoahVerify, &quot;Should be enabled&quot;);
2116   assert (_verifier != NULL, &quot;sanity&quot;);
2117   return _verifier;
2118 }
2119 
2120 template&lt;class T&gt;
2121 class ShenandoahUpdateHeapRefsTask : public AbstractGangTask {
2122 private:
2123   T cl;
2124   ShenandoahHeap* _heap;
2125   ShenandoahRegionIterator* _regions;
2126   bool _concurrent;
2127 public:
2128   ShenandoahUpdateHeapRefsTask(ShenandoahRegionIterator* regions, bool concurrent) :
2129     AbstractGangTask(&quot;Concurrent Update References Task&quot;),
2130     cl(T()),
2131     _heap(ShenandoahHeap::heap()),
2132     _regions(regions),
2133     _concurrent(concurrent) {
2134   }
2135 
2136   void work(uint worker_id) {
2137     if (_concurrent) {
2138       ShenandoahConcurrentWorkerSession worker_session(worker_id);
2139       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
2140       do_work();
2141     } else {
2142       ShenandoahParallelWorkerSession worker_session(worker_id);
2143       do_work();
2144     }
2145   }
2146 
2147 private:
2148   void do_work() {
2149     ShenandoahHeapRegion* r = _regions-&gt;next();
2150     ShenandoahMarkingContext* const ctx = _heap-&gt;complete_marking_context();
2151     while (r != NULL) {
2152       HeapWord* top_at_start_ur = r-&gt;concurrent_iteration_safe_limit();
2153       assert (top_at_start_ur &gt;= r-&gt;bottom(), &quot;sanity&quot;);
2154       if (r-&gt;is_active() &amp;&amp; !r-&gt;is_cset()) {
2155         _heap-&gt;marked_object_oop_iterate(r, &amp;cl, top_at_start_ur);
2156       }
2157       if (ShenandoahPacing) {
2158         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));
2159       }
2160       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2161         return;
2162       }
2163       r = _regions-&gt;next();
2164     }
2165   }
2166 };
2167 
2168 void ShenandoahHeap::update_heap_references(bool concurrent) {
2169   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2170   workers()-&gt;run_task(&amp;task);
2171 }
2172 
2173 void ShenandoahHeap::op_init_updaterefs() {
2174   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2175 
2176   set_evacuation_in_progress(false);
2177 
<a name="115" id="anc115"></a><span class="line-modified">2178   retire_and_reset_gclabs();</span>



2179 
2180   if (ShenandoahVerify) {
<a name="116" id="anc116"></a>


2181     verifier()-&gt;verify_before_updaterefs();
2182   }
2183 
2184   set_update_refs_in_progress(true);
<a name="117" id="anc117"></a><span class="line-removed">2185   make_parsable(true);</span>
<span class="line-removed">2186   for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">2187     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">2188     r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">2189   }</span>
2190 
<a name="118" id="anc118"></a><span class="line-modified">2191   // Reset iterator.</span>
<span class="line-modified">2192   _update_refs_iterator.reset();</span>










2193 
2194   if (ShenandoahPacing) {
2195     pacer()-&gt;setup_for_updaterefs();
2196   }
2197 }
2198 
2199 void ShenandoahHeap::op_final_updaterefs() {
2200   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2201 
<a name="119" id="anc119"></a>

2202   // Check if there is left-over work, and finish it
2203   if (_update_refs_iterator.has_next()) {
<a name="120" id="anc120"></a><span class="line-modified">2204     ShenandoahGCPhase final_work(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
2205 
2206     // Finish updating references where we left off.
2207     clear_cancelled_gc();
2208     update_heap_references(false);
2209   }
2210 
2211   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2212   // everything. On degenerated paths, cancelled gc would not be set anyway.
2213   if (cancelled_gc()) {
2214     clear_cancelled_gc();
2215   }
2216   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2217 
<a name="121" id="anc121"></a><span class="line-modified">2218   concurrent_mark()-&gt;update_roots(is_degenerated_gc_in_progress() ?</span>
<span class="line-modified">2219                                  ShenandoahPhaseTimings::degen_gc_update_roots:</span>
<span class="line-modified">2220                                  ShenandoahPhaseTimings::final_update_refs_roots);</span>


















2221 
<a name="122" id="anc122"></a><span class="line-modified">2222   ShenandoahGCPhase final_update_refs(ShenandoahPhaseTimings::final_update_refs_recycle);</span>



2223 
<a name="123" id="anc123"></a><span class="line-removed">2224   trash_cset_regions();</span>
2225   set_has_forwarded_objects(false);
2226   set_update_refs_in_progress(false);
2227 
2228   if (ShenandoahVerify) {
2229     verifier()-&gt;verify_after_updaterefs();
2230   }
2231 
2232   if (VerifyAfterGC) {
2233     Universe::verify();
2234   }
2235 
2236   {
2237     ShenandoahHeapLocker locker(lock());
2238     _free_set-&gt;rebuild();
2239   }
2240 }
2241 
2242 #ifdef ASSERT
2243 void ShenandoahHeap::assert_heaplock_owned_by_current_thread() {
2244   _lock.assert_owned_by_current_thread();
2245 }
2246 
2247 void ShenandoahHeap::assert_heaplock_not_owned_by_current_thread() {
2248   _lock.assert_not_owned_by_current_thread();
2249 }
2250 
2251 void ShenandoahHeap::assert_heaplock_or_safepoint() {
2252   _lock.assert_owned_by_current_thread_or_safepoint();
2253 }
2254 #endif
2255 
2256 void ShenandoahHeap::print_extended_on(outputStream *st) const {
2257   print_on(st);
2258   print_heap_regions_on(st);
2259 }
2260 
2261 bool ShenandoahHeap::is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self) {
2262   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2263 
2264   size_t regions_from = _bitmap_regions_per_slice * slice;
2265   size_t regions_to   = MIN2(num_regions(), _bitmap_regions_per_slice * (slice + 1));
2266   for (size_t g = regions_from; g &lt; regions_to; g++) {
2267     assert (g / _bitmap_regions_per_slice == slice, &quot;same slice&quot;);
2268     if (skip_self &amp;&amp; g == r-&gt;region_number()) continue;
2269     if (get_region(g)-&gt;is_committed()) {
2270       return true;
2271     }
2272   }
2273   return false;
2274 }
2275 
2276 bool ShenandoahHeap::commit_bitmap_slice(ShenandoahHeapRegion* r) {
2277   assert_heaplock_owned_by_current_thread();
2278 
2279   // Bitmaps in special regions do not need commits
2280   if (_bitmap_region_special) {
2281     return true;
2282   }
2283 
2284   if (is_bitmap_slice_committed(r, true)) {
2285     // Some other region from the group is already committed, meaning the bitmap
2286     // slice is already committed, we exit right away.
2287     return true;
2288   }
2289 
2290   // Commit the bitmap slice:
2291   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2292   size_t off = _bitmap_bytes_per_slice * slice;
2293   size_t len = _bitmap_bytes_per_slice;
2294   if (!os::commit_memory((char*)_bitmap_region.start() + off, len, false)) {
2295     return false;
2296   }
2297   return true;
2298 }
2299 
2300 bool ShenandoahHeap::uncommit_bitmap_slice(ShenandoahHeapRegion *r) {
2301   assert_heaplock_owned_by_current_thread();
2302 
2303   // Bitmaps in special regions do not need uncommits
2304   if (_bitmap_region_special) {
2305     return true;
2306   }
2307 
2308   if (is_bitmap_slice_committed(r, true)) {
2309     // Some other region from the group is still committed, meaning the bitmap
2310     // slice is should stay committed, exit right away.
2311     return true;
2312   }
2313 
2314   // Uncommit the bitmap slice:
2315   size_t slice = r-&gt;region_number() / _bitmap_regions_per_slice;
2316   size_t off = _bitmap_bytes_per_slice * slice;
2317   size_t len = _bitmap_bytes_per_slice;
2318   if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
2319     return false;
2320   }
2321   return true;
2322 }
2323 
2324 void ShenandoahHeap::safepoint_synchronize_begin() {
2325   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2326     SuspendibleThreadSet::synchronize();
2327   }
2328 }
2329 
2330 void ShenandoahHeap::safepoint_synchronize_end() {
2331   if (ShenandoahSuspendibleWorkers || UseStringDeduplication) {
2332     SuspendibleThreadSet::desynchronize();
2333   }
2334 }
2335 
2336 void ShenandoahHeap::vmop_entry_init_mark() {
2337   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2338   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2339   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark_gross);
2340 
2341   try_inject_alloc_failure();
2342   VM_ShenandoahInitMark op;
2343   VMThread::execute(&amp;op); // jump to entry_init_mark() under safepoint
2344 }
2345 
2346 void ShenandoahHeap::vmop_entry_final_mark() {
2347   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2348   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2349   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark_gross);
2350 
2351   try_inject_alloc_failure();
2352   VM_ShenandoahFinalMarkStartEvac op;
2353   VMThread::execute(&amp;op); // jump to entry_final_mark under safepoint
2354 }
2355 
2356 void ShenandoahHeap::vmop_entry_final_evac() {
2357   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2358   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2359   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_gross);
2360 
2361   VM_ShenandoahFinalEvac op;
2362   VMThread::execute(&amp;op); // jump to entry_final_evac under safepoint
2363 }
2364 
2365 void ShenandoahHeap::vmop_entry_init_updaterefs() {
2366   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2367   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2368   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_gross);
2369 
2370   try_inject_alloc_failure();
2371   VM_ShenandoahInitUpdateRefs op;
2372   VMThread::execute(&amp;op);
2373 }
2374 
2375 void ShenandoahHeap::vmop_entry_final_updaterefs() {
2376   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2377   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2378   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_gross);
2379 
2380   try_inject_alloc_failure();
2381   VM_ShenandoahFinalUpdateRefs op;
2382   VMThread::execute(&amp;op);
2383 }
2384 
2385 void ShenandoahHeap::vmop_entry_init_traversal() {
2386   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2387   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2388   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc_gross);
2389 
2390   try_inject_alloc_failure();
2391   VM_ShenandoahInitTraversalGC op;
2392   VMThread::execute(&amp;op);
2393 }
2394 
2395 void ShenandoahHeap::vmop_entry_final_traversal() {
2396   TraceCollectorStats tcs(monitoring_support()-&gt;stw_collection_counters());
2397   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2398   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc_gross);
2399 
2400   try_inject_alloc_failure();
2401   VM_ShenandoahFinalTraversalGC op;
2402   VMThread::execute(&amp;op);
2403 }
2404 
2405 void ShenandoahHeap::vmop_entry_full(GCCause::Cause cause) {
2406   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2407   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2408   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_gross);
2409 
2410   try_inject_alloc_failure();
2411   VM_ShenandoahFullGC op(cause);
2412   VMThread::execute(&amp;op);
2413 }
2414 
2415 void ShenandoahHeap::vmop_degenerated(ShenandoahDegenPoint point) {
2416   TraceCollectorStats tcs(monitoring_support()-&gt;full_stw_collection_counters());
2417   ShenandoahGCPhase total(ShenandoahPhaseTimings::total_pause_gross);
2418   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_gross);
2419 
2420   VM_ShenandoahDegeneratedGC degenerated_gc((int)point);
2421   VMThread::execute(&amp;degenerated_gc);
2422 }
2423 
2424 void ShenandoahHeap::entry_init_mark() {
2425   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2426   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_mark);
2427   const char* msg = init_mark_event_message();
2428   GCTraceTime(Info, gc) time(msg, gc_timer());
2429   EventMark em(&quot;%s&quot;, msg);
2430 
2431   ShenandoahWorkerScope scope(workers(),
2432                               ShenandoahWorkerPolicy::calc_workers_for_init_marking(),
2433                               &quot;init marking&quot;);
2434 
2435   op_init_mark();
2436 }
2437 
2438 void ShenandoahHeap::entry_final_mark() {
2439   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2440   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_mark);
2441   const char* msg = final_mark_event_message();
2442   GCTraceTime(Info, gc) time(msg, gc_timer());
2443   EventMark em(&quot;%s&quot;, msg);
2444 
2445   ShenandoahWorkerScope scope(workers(),
2446                               ShenandoahWorkerPolicy::calc_workers_for_final_marking(),
2447                               &quot;final marking&quot;);
2448 
2449   op_final_mark();
2450 }
2451 
2452 void ShenandoahHeap::entry_final_evac() {
2453   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2454   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac);
2455   static const char* msg = &quot;Pause Final Evac&quot;;
2456   GCTraceTime(Info, gc) time(msg, gc_timer());
2457   EventMark em(&quot;%s&quot;, msg);
2458 
2459   op_final_evac();
2460 }
2461 
2462 void ShenandoahHeap::entry_init_updaterefs() {
2463   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2464   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs);
2465 
2466   static const char* msg = &quot;Pause Init Update Refs&quot;;
2467   GCTraceTime(Info, gc) time(msg, gc_timer());
2468   EventMark em(&quot;%s&quot;, msg);
2469 
2470   // No workers used in this phase, no setup required
2471 
2472   op_init_updaterefs();
2473 }
2474 
2475 void ShenandoahHeap::entry_final_updaterefs() {
2476   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2477   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2478 
2479   static const char* msg = &quot;Pause Final Update Refs&quot;;
2480   GCTraceTime(Info, gc) time(msg, gc_timer());
2481   EventMark em(&quot;%s&quot;, msg);
2482 
2483   ShenandoahWorkerScope scope(workers(),
2484                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2485                               &quot;final reference update&quot;);
2486 
2487   op_final_updaterefs();
2488 }
2489 
2490 void ShenandoahHeap::entry_init_traversal() {
2491   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2492   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
2493 
<a name="124" id="anc124"></a><span class="line-modified">2494   static const char* msg = &quot;Pause Init Traversal&quot;;</span>
2495   GCTraceTime(Info, gc) time(msg, gc_timer());
2496   EventMark em(&quot;%s&quot;, msg);
2497 
2498   ShenandoahWorkerScope scope(workers(),
2499                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2500                               &quot;init traversal&quot;);
2501 
2502   op_init_traversal();
2503 }
2504 
2505 void ShenandoahHeap::entry_final_traversal() {
2506   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2507   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
2508 
<a name="125" id="anc125"></a><span class="line-modified">2509   static const char* msg = &quot;Pause Final Traversal&quot;;</span>
2510   GCTraceTime(Info, gc) time(msg, gc_timer());
2511   EventMark em(&quot;%s&quot;, msg);
2512 
2513   ShenandoahWorkerScope scope(workers(),
2514                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2515                               &quot;final traversal&quot;);
2516 
2517   op_final_traversal();
2518 }
2519 
2520 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2521   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2522   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2523 
2524   static const char* msg = &quot;Pause Full&quot;;
2525   GCTraceTime(Info, gc) time(msg, gc_timer(), cause, true);
2526   EventMark em(&quot;%s&quot;, msg);
2527 
2528   ShenandoahWorkerScope scope(workers(),
2529                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
2530                               &quot;full gc&quot;);
2531 
2532   op_full(cause);
2533 }
2534 
2535 void ShenandoahHeap::entry_degenerated(int point) {
2536   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2537   ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc);
2538 
2539   ShenandoahDegenPoint dpoint = (ShenandoahDegenPoint)point;
2540   const char* msg = degen_event_message(dpoint);
2541   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2542   EventMark em(&quot;%s&quot;, msg);
2543 
2544   ShenandoahWorkerScope scope(workers(),
2545                               ShenandoahWorkerPolicy::calc_workers_for_stw_degenerated(),
2546                               &quot;stw degenerated gc&quot;);
2547 
2548   set_degenerated_gc_in_progress(true);
2549   op_degenerated(dpoint);
2550   set_degenerated_gc_in_progress(false);
2551 }
2552 
2553 void ShenandoahHeap::entry_mark() {
2554   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2555 
2556   const char* msg = conc_mark_event_message();
2557   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2558   EventMark em(&quot;%s&quot;, msg);
2559 
2560   ShenandoahWorkerScope scope(workers(),
2561                               ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),
2562                               &quot;concurrent marking&quot;);
2563 
2564   try_inject_alloc_failure();
2565   op_mark();
2566 }
2567 
2568 void ShenandoahHeap::entry_evac() {
2569   ShenandoahGCPhase conc_evac_phase(ShenandoahPhaseTimings::conc_evac);
2570   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2571 
2572   static const char* msg = &quot;Concurrent evacuation&quot;;
2573   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2574   EventMark em(&quot;%s&quot;, msg);
2575 
2576   ShenandoahWorkerScope scope(workers(),
2577                               ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),
2578                               &quot;concurrent evacuation&quot;);
2579 
2580   try_inject_alloc_failure();
2581   op_conc_evac();
2582 }
2583 
2584 void ShenandoahHeap::entry_updaterefs() {
2585   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2586 
2587   static const char* msg = &quot;Concurrent update references&quot;;
2588   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2589   EventMark em(&quot;%s&quot;, msg);
2590 
2591   ShenandoahWorkerScope scope(workers(),
2592                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2593                               &quot;concurrent reference update&quot;);
2594 
2595   try_inject_alloc_failure();
2596   op_updaterefs();
2597 }
<a name="126" id="anc126"></a>















2598 void ShenandoahHeap::entry_cleanup() {
2599   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);
2600 
2601   static const char* msg = &quot;Concurrent cleanup&quot;;
2602   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2603   EventMark em(&quot;%s&quot;, msg);
2604 
2605   // This phase does not use workers, no need for setup
2606 
2607   try_inject_alloc_failure();
2608   op_cleanup();
2609 }
2610 
2611 void ShenandoahHeap::entry_reset() {
2612   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_reset);
2613 
2614   static const char* msg = &quot;Concurrent reset&quot;;
2615   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2616   EventMark em(&quot;%s&quot;, msg);
2617 
2618   ShenandoahWorkerScope scope(workers(),
2619                               ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),
2620                               &quot;concurrent reset&quot;);
2621 
2622   try_inject_alloc_failure();
2623   op_reset();
2624 }
2625 
2626 void ShenandoahHeap::entry_preclean() {
2627   if (ShenandoahPreclean &amp;&amp; process_references()) {
2628     static const char* msg = &quot;Concurrent precleaning&quot;;
2629     GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2630     EventMark em(&quot;%s&quot;, msg);
2631 
2632     ShenandoahGCPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);
2633 
2634     ShenandoahWorkerScope scope(workers(),
2635                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2636                                 &quot;concurrent preclean&quot;,
2637                                 /* check_workers = */ false);
2638 
2639     try_inject_alloc_failure();
2640     op_preclean();
2641   }
2642 }
2643 
2644 void ShenandoahHeap::entry_traversal() {
<a name="127" id="anc127"></a><span class="line-modified">2645   static const char* msg = &quot;Concurrent traversal&quot;;</span>
2646   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2647   EventMark em(&quot;%s&quot;, msg);
2648 
2649   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2650 
2651   ShenandoahWorkerScope scope(workers(),
2652                               ShenandoahWorkerPolicy::calc_workers_for_conc_traversal(),
2653                               &quot;concurrent traversal&quot;);
2654 
2655   try_inject_alloc_failure();
2656   op_traversal();
2657 }
2658 
2659 void ShenandoahHeap::entry_uncommit(double shrink_before) {
2660   static const char *msg = &quot;Concurrent uncommit&quot;;
2661   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2662   EventMark em(&quot;%s&quot;, msg);
2663 
2664   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_uncommit);
2665 
2666   op_uncommit(shrink_before);
2667 }
2668 
2669 void ShenandoahHeap::try_inject_alloc_failure() {
2670   if (ShenandoahAllocFailureALot &amp;&amp; !cancelled_gc() &amp;&amp; ((os::random() % 1000) &gt; 950)) {
2671     _inject_alloc_failure.set();
2672     os::naked_short_sleep(1);
2673     if (cancelled_gc()) {
2674       log_info(gc)(&quot;Allocation failure was successfully injected&quot;);
2675     }
2676   }
2677 }
2678 
2679 bool ShenandoahHeap::should_inject_alloc_failure() {
2680   return _inject_alloc_failure.is_set() &amp;&amp; _inject_alloc_failure.try_unset();
2681 }
2682 
2683 void ShenandoahHeap::initialize_serviceability() {
2684   _memory_pool = new ShenandoahMemoryPool(this);
2685   _cycle_memory_manager.add_pool(_memory_pool);
2686   _stw_memory_manager.add_pool(_memory_pool);
2687 }
2688 
2689 GrowableArray&lt;GCMemoryManager*&gt; ShenandoahHeap::memory_managers() {
2690   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
2691   memory_managers.append(&amp;_cycle_memory_manager);
2692   memory_managers.append(&amp;_stw_memory_manager);
2693   return memory_managers;
2694 }
2695 
2696 GrowableArray&lt;MemoryPool*&gt; ShenandoahHeap::memory_pools() {
2697   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
2698   memory_pools.append(_memory_pool);
2699   return memory_pools;
2700 }
2701 
2702 MemoryUsage ShenandoahHeap::memory_usage() {
2703   return _memory_pool-&gt;get_memory_usage();
2704 }
2705 
2706 void ShenandoahHeap::enter_evacuation() {
2707   _oom_evac_handler.enter_evacuation();
2708 }
2709 
2710 void ShenandoahHeap::leave_evacuation() {
2711   _oom_evac_handler.leave_evacuation();
2712 }
2713 
2714 ShenandoahRegionIterator::ShenandoahRegionIterator() :
2715   _heap(ShenandoahHeap::heap()),
2716   _index(0) {}
2717 
2718 ShenandoahRegionIterator::ShenandoahRegionIterator(ShenandoahHeap* heap) :
2719   _heap(heap),
2720   _index(0) {}
2721 
2722 void ShenandoahRegionIterator::reset() {
2723   _index = 0;
2724 }
2725 
2726 bool ShenandoahRegionIterator::has_next() const {
2727   return _index &lt; _heap-&gt;num_regions();
2728 }
2729 
2730 char ShenandoahHeap::gc_state() const {
2731   return _gc_state.raw_value();
2732 }
2733 
2734 void ShenandoahHeap::deduplicate_string(oop str) {
2735   assert(java_lang_String::is_instance(str), &quot;invariant&quot;);
2736 
2737   if (ShenandoahStringDedup::is_enabled()) {
2738     ShenandoahStringDedup::deduplicate(str);
2739   }
2740 }
2741 
2742 const char* ShenandoahHeap::init_mark_event_message() const {
2743   bool update_refs = has_forwarded_objects();
2744   bool proc_refs = process_references();
2745   bool unload_cls = unload_classes();
2746 
2747   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {
2748     return &quot;Pause Init Mark (update refs) (process weakrefs) (unload classes)&quot;;
2749   } else if (update_refs &amp;&amp; proc_refs) {
2750     return &quot;Pause Init Mark (update refs) (process weakrefs)&quot;;
2751   } else if (update_refs &amp;&amp; unload_cls) {
2752     return &quot;Pause Init Mark (update refs) (unload classes)&quot;;
2753   } else if (proc_refs &amp;&amp; unload_cls) {
2754     return &quot;Pause Init Mark (process weakrefs) (unload classes)&quot;;
2755   } else if (update_refs) {
2756     return &quot;Pause Init Mark (update refs)&quot;;
2757   } else if (proc_refs) {
2758     return &quot;Pause Init Mark (process weakrefs)&quot;;
2759   } else if (unload_cls) {
2760     return &quot;Pause Init Mark (unload classes)&quot;;
2761   } else {
2762     return &quot;Pause Init Mark&quot;;
2763   }
2764 }
2765 
2766 const char* ShenandoahHeap::final_mark_event_message() const {
2767   bool update_refs = has_forwarded_objects();
2768   bool proc_refs = process_references();
2769   bool unload_cls = unload_classes();
2770 
2771   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {
2772     return &quot;Pause Final Mark (update refs) (process weakrefs) (unload classes)&quot;;
2773   } else if (update_refs &amp;&amp; proc_refs) {
2774     return &quot;Pause Final Mark (update refs) (process weakrefs)&quot;;
2775   } else if (update_refs &amp;&amp; unload_cls) {
2776     return &quot;Pause Final Mark (update refs) (unload classes)&quot;;
2777   } else if (proc_refs &amp;&amp; unload_cls) {
2778     return &quot;Pause Final Mark (process weakrefs) (unload classes)&quot;;
2779   } else if (update_refs) {
2780     return &quot;Pause Final Mark (update refs)&quot;;
2781   } else if (proc_refs) {
2782     return &quot;Pause Final Mark (process weakrefs)&quot;;
2783   } else if (unload_cls) {
2784     return &quot;Pause Final Mark (unload classes)&quot;;
2785   } else {
2786     return &quot;Pause Final Mark&quot;;
2787   }
2788 }
2789 
2790 const char* ShenandoahHeap::conc_mark_event_message() const {
2791   bool update_refs = has_forwarded_objects();
2792   bool proc_refs = process_references();
2793   bool unload_cls = unload_classes();
2794 
2795   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {
2796     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;
2797   } else if (update_refs &amp;&amp; proc_refs) {
2798     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;
2799   } else if (update_refs &amp;&amp; unload_cls) {
2800     return &quot;Concurrent marking (update refs) (unload classes)&quot;;
2801   } else if (proc_refs &amp;&amp; unload_cls) {
2802     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
2803   } else if (update_refs) {
2804     return &quot;Concurrent marking (update refs)&quot;;
2805   } else if (proc_refs) {
2806     return &quot;Concurrent marking (process weakrefs)&quot;;
2807   } else if (unload_cls) {
2808     return &quot;Concurrent marking (unload classes)&quot;;
2809   } else {
2810     return &quot;Concurrent marking&quot;;
2811   }
2812 }
2813 
<a name="128" id="anc128"></a>












































2814 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
2815   switch (point) {
2816     case _degenerated_unset:
2817       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
2818     case _degenerated_traversal:
2819       return &quot;Pause Degenerated GC (Traversal)&quot;;
2820     case _degenerated_outside_cycle:
2821       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
2822     case _degenerated_mark:
2823       return &quot;Pause Degenerated GC (Mark)&quot;;
2824     case _degenerated_evac:
2825       return &quot;Pause Degenerated GC (Evacuation)&quot;;
2826     case _degenerated_updaterefs:
2827       return &quot;Pause Degenerated GC (Update Refs)&quot;;
2828     default:
2829       ShouldNotReachHere();
2830       return &quot;ERROR&quot;;
2831   }
2832 }
2833 
2834 jushort* ShenandoahHeap::get_liveness_cache(uint worker_id) {
2835 #ifdef ASSERT
2836   assert(_liveness_cache != NULL, &quot;sanity&quot;);
2837   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
2838   for (uint i = 0; i &lt; num_regions(); i++) {
2839     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
2840   }
2841 #endif
2842   return _liveness_cache[worker_id];
2843 }
2844 
2845 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
2846   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
2847   assert(_liveness_cache != NULL, &quot;sanity&quot;);
2848   jushort* ld = _liveness_cache[worker_id];
2849   for (uint i = 0; i &lt; num_regions(); i++) {
2850     ShenandoahHeapRegion* r = get_region(i);
2851     jushort live = ld[i];
2852     if (live &gt; 0) {
2853       r-&gt;increase_live_data_gc_words(live);
2854       ld[i] = 0;
2855     }
2856   }
2857 }
<a name="129" id="anc129"></a><span class="line-removed">2858 </span>
<span class="line-removed">2859 size_t ShenandoahHeap::obj_size(oop obj) const {</span>
<span class="line-removed">2860   return CollectedHeap::obj_size(obj) + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">2861 }</span>
<span class="line-removed">2862 </span>
<span class="line-removed">2863 ptrdiff_t ShenandoahHeap::cell_header_size() const {</span>
<span class="line-removed">2864   return ShenandoahBrooksPointer::byte_size();</span>
<span class="line-removed">2865 }</span>
<span class="line-removed">2866 </span>
<span class="line-removed">2867 BoolObjectClosure* ShenandoahIsAliveSelector::is_alive_closure() {</span>
<span class="line-removed">2868   return ShenandoahHeap::heap()-&gt;has_forwarded_objects() ? reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_fwd_alive_cl)</span>
<span class="line-removed">2869                                                          : reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_alive_cl);</span>
<span class="line-removed">2870 }</span>
<a name="130" id="anc130"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="130" type="hidden" />
</body>
</html>
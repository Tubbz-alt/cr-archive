<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahConcurrentMark.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  
  ShenandoahControlThread::ShenandoahControlThread() :
    ConcurrentGCThread(),
    _alloc_failure_waiters_lock(Mutex::leaf, &quot;ShenandoahAllocFailureGC_lock&quot;, true, Monitor::_safepoint_check_always),
    _gc_waiters_lock(Mutex::leaf, &quot;ShenandoahRequestedGC_lock&quot;, true, Monitor::_safepoint_check_always),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,10 ***</span>
<span class="line-new-header">--- 68,14 ---</span>
  }
  
  void ShenandoahControlThread::run_service() {
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-added">+   GCMode default_mode = heap-&gt;is_traversal_mode() ?</span>
<span class="line-added">+                            concurrent_traversal : concurrent_normal;</span>
<span class="line-added">+   GCCause::Cause default_cause = heap-&gt;is_traversal_mode() ?</span>
<span class="line-added">+                            GCCause::_shenandoah_traversal_gc : GCCause::_shenandoah_concurrent_gc;</span>
    int sleep = ShenandoahControlIntervalMin;
  
    double last_shrink_time = os::elapsedTime();
    double last_sleep_adjust_time = os::elapsedTime();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,11 ***</span>
      bool alloc_failure_pending = _alloc_failure_gc.is_set();
      bool explicit_gc_requested = _gc_requested.is_set() &amp;&amp;  is_explicit_gc(_requested_gc_cause);
      bool implicit_gc_requested = _gc_requested.is_set() &amp;&amp; !is_explicit_gc(_requested_gc_cause);
  
      // This control loop iteration have seen this much allocations.
<span class="line-modified">!     size_t allocs_seen = Atomic::xchg&lt;size_t&gt;(0, &amp;_allocs_seen);</span>
  
      // Choose which GC mode to run in. The block below should select a single mode.
      GCMode mode = none;
      GCCause::Cause cause = GCCause::_last_gc_cause;
      ShenandoahHeap::ShenandoahDegenPoint degen_point = ShenandoahHeap::_degenerated_unset;
<span class="line-new-header">--- 92,11 ---</span>
      bool alloc_failure_pending = _alloc_failure_gc.is_set();
      bool explicit_gc_requested = _gc_requested.is_set() &amp;&amp;  is_explicit_gc(_requested_gc_cause);
      bool implicit_gc_requested = _gc_requested.is_set() &amp;&amp; !is_explicit_gc(_requested_gc_cause);
  
      // This control loop iteration have seen this much allocations.
<span class="line-modified">!     size_t allocs_seen = Atomic::xchg(&amp;_allocs_seen, (size_t)0);</span>
  
      // Choose which GC mode to run in. The block below should select a single mode.
      GCMode mode = none;
      GCCause::Cause cause = GCCause::_last_gc_cause;
      ShenandoahHeap::ShenandoahDegenPoint degen_point = ShenandoahHeap::_degenerated_unset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,15 ***</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ExplicitGCInvokesConcurrent) {
          policy-&gt;record_explicit_to_concurrent();
<span class="line-modified">!         if (heuristics-&gt;can_do_traversal_gc()) {</span>
<span class="line-removed">-           mode = concurrent_traversal;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           mode = concurrent_normal;</span>
<span class="line-removed">-         }</span>
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_explicit_to_full();
<span class="line-new-header">--- 127,11 ---</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ExplicitGCInvokesConcurrent) {
          policy-&gt;record_explicit_to_concurrent();
<span class="line-modified">!         mode = default_mode;</span>
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_explicit_to_full();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,31 ***</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ShenandoahImplicitGCInvokesConcurrent) {
          policy-&gt;record_implicit_to_concurrent();
<span class="line-modified">!         if (heuristics-&gt;can_do_traversal_gc()) {</span>
<span class="line-removed">-           mode = concurrent_traversal;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           mode = concurrent_normal;</span>
<span class="line-removed">-         }</span>
  
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_implicit_to_full();
          mode = stw_full;
        }
      } else {
        // Potential normal cycle: ask heuristics if it wants to act
<span class="line-modified">!       if (heuristics-&gt;should_start_traversal_gc()) {</span>
<span class="line-modified">!         mode = concurrent_traversal;</span>
<span class="line-modified">!         cause = GCCause::_shenandoah_traversal_gc;</span>
<span class="line-removed">-       } else if (heuristics-&gt;should_start_normal_gc()) {</span>
<span class="line-removed">-         mode = concurrent_normal;</span>
<span class="line-removed">-         cause = GCCause::_shenandoah_concurrent_gc;</span>
        }
  
        // Ask policy if this cycle wants to process references or unload classes
        heap-&gt;set_process_references(heuristics-&gt;should_process_references());
        heap-&gt;set_unload_classes(heuristics-&gt;should_unload_classes());
<span class="line-new-header">--- 143,24 ---</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ShenandoahImplicitGCInvokesConcurrent) {
          policy-&gt;record_implicit_to_concurrent();
<span class="line-modified">!         mode = default_mode;</span>
  
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_implicit_to_full();
          mode = stw_full;
        }
      } else {
        // Potential normal cycle: ask heuristics if it wants to act
<span class="line-modified">!       if (heuristics-&gt;should_start_gc()) {</span>
<span class="line-modified">!         mode = default_mode;</span>
<span class="line-modified">!         cause = default_cause;</span>
        }
  
        // Ask policy if this cycle wants to process references or unload classes
        heap-&gt;set_process_references(heuristics-&gt;should_process_references());
        heap-&gt;set_unload_classes(heuristics-&gt;should_unload_classes());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,10 ***</span>
<span class="line-new-header">--- 370,13 ---</span>
    heap-&gt;entry_preclean();
  
    // Complete marking under STW, and start evacuation
    heap-&gt;vmop_entry_final_mark();
  
<span class="line-added">+   // Evacuate concurrent roots</span>
<span class="line-added">+   heap-&gt;entry_roots();</span>
<span class="line-added">+ </span>
    // Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim
    // the space. This would be the last action if there is nothing to evacuate.
    heap-&gt;entry_cleanup();
  
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,13 ***</span>
  }
  
  void ShenandoahControlThread::service_uncommit(double shrink_before) {
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-modified">!   // Scan through the heap and determine if there is work to do. This avoids taking</span>
<span class="line-modified">!   // heap lock if there is no work available, avoids spamming logs with superfluous</span>
<span class="line-modified">!   // logging messages, and minimises the amount of work while locks are taken.</span>
  
    bool has_work = false;
    for (size_t i = 0; i &lt; heap-&gt;num_regions(); i++) {
      ShenandoahHeapRegion *r = heap-&gt;get_region(i);
      if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
<span class="line-new-header">--- 458,15 ---</span>
  }
  
  void ShenandoahControlThread::service_uncommit(double shrink_before) {
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-modified">!   // Determine if there is work to do. This avoids taking heap lock if there is</span>
<span class="line-modified">!   // no work available, avoids spamming logs with superfluous logging messages,</span>
<span class="line-modified">!   // and minimises the amount of work while locks are taken.</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (heap-&gt;committed() &lt;= heap-&gt;min_capacity()) return;</span>
  
    bool has_work = false;
    for (size_t i = 0; i &lt; heap-&gt;num_regions(); i++) {
      ShenandoahHeapRegion *r = heap-&gt;get_region(i);
      if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,11 ***</span>
  }
  
  void ShenandoahControlThread::handle_requested_gc(GCCause::Cause cause) {
    _requested_gc_cause = cause;
    _gc_requested.set();
<span class="line-modified">!   MonitorLockerEx ml(&amp;_gc_waiters_lock);</span>
    while (_gc_requested.is_set()) {
      ml.wait();
    }
  }
  
<span class="line-new-header">--- 504,11 ---</span>
  }
  
  void ShenandoahControlThread::handle_requested_gc(GCCause::Cause cause) {
    _requested_gc_cause = cause;
    _gc_requested.set();
<span class="line-modified">!   MonitorLocker ml(&amp;_gc_waiters_lock);</span>
    while (_gc_requested.is_set()) {
      ml.wait();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,11 ***</span>
  
      // Now that alloc failure GC is scheduled, we can abort everything else
      heap-&gt;cancel_gc(GCCause::_allocation_failure);
    }
  
<span class="line-modified">!   MonitorLockerEx ml(&amp;_alloc_failure_waiters_lock);</span>
    while (is_alloc_failure_gc()) {
      ml.wait();
    }
  }
  
<span class="line-new-header">--- 524,11 ---</span>
  
      // Now that alloc failure GC is scheduled, we can abort everything else
      heap-&gt;cancel_gc(GCCause::_allocation_failure);
    }
  
<span class="line-modified">!   MonitorLocker ml(&amp;_alloc_failure_waiters_lock);</span>
    while (is_alloc_failure_gc()) {
      ml.wait();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,11 ***</span>
    heap-&gt;cancel_gc(GCCause::_shenandoah_allocation_failure_evac);
  }
  
  void ShenandoahControlThread::notify_alloc_failure_waiters() {
    _alloc_failure_gc.unset();
<span class="line-modified">!   MonitorLockerEx ml(&amp;_alloc_failure_waiters_lock);</span>
    ml.notify_all();
  }
  
  bool ShenandoahControlThread::try_set_alloc_failure_gc() {
    return _alloc_failure_gc.try_set();
<span class="line-new-header">--- 545,11 ---</span>
    heap-&gt;cancel_gc(GCCause::_shenandoah_allocation_failure_evac);
  }
  
  void ShenandoahControlThread::notify_alloc_failure_waiters() {
    _alloc_failure_gc.unset();
<span class="line-modified">!   MonitorLocker ml(&amp;_alloc_failure_waiters_lock);</span>
    ml.notify_all();
  }
  
  bool ShenandoahControlThread::try_set_alloc_failure_gc() {
    return _alloc_failure_gc.try_set();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,11 ***</span>
    return _alloc_failure_gc.is_set();
  }
  
  void ShenandoahControlThread::notify_gc_waiters() {
    _gc_requested.unset();
<span class="line-modified">!   MonitorLockerEx ml(&amp;_gc_waiters_lock);</span>
    ml.notify_all();
  }
  
  void ShenandoahControlThread::handle_counters_update() {
    if (_do_counters_update.is_set()) {
<span class="line-new-header">--- 559,11 ---</span>
    return _alloc_failure_gc.is_set();
  }
  
  void ShenandoahControlThread::notify_gc_waiters() {
    _gc_requested.unset();
<span class="line-modified">!   MonitorLocker ml(&amp;_gc_waiters_lock);</span>
    ml.notify_all();
  }
  
  void ShenandoahControlThread::handle_counters_update() {
    if (_do_counters_update.is_set()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,11 ***</span>
    }
  }
  
  void ShenandoahControlThread::pacing_notify_alloc(size_t words) {
    assert(ShenandoahPacing, &quot;should only call when pacing is enabled&quot;);
<span class="line-modified">!   Atomic::add(words, &amp;_allocs_seen);</span>
  }
  
  void ShenandoahControlThread::set_forced_counters_update(bool value) {
    _force_counters_update.set_cond(value);
  }
<span class="line-new-header">--- 593,11 ---</span>
    }
  }
  
  void ShenandoahControlThread::pacing_notify_alloc(size_t words) {
    assert(ShenandoahPacing, &quot;should only call when pacing is enabled&quot;);
<span class="line-modified">!   Atomic::add(&amp;_allocs_seen, words);</span>
  }
  
  void ShenandoahControlThread::set_forced_counters_update(bool value) {
    _force_counters_update.set_cond(value);
  }
</pre>
<center><a href="shenandoahConcurrentMark.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahEvacOOMHandler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,12 ***</span>
  
  /**
   * Provides safe handling of out-of-memory situations during evacuation.
   *
   * When a Java thread encounters out-of-memory while evacuating an object in a
<span class="line-modified">!  * write-barrier (i.e. it cannot copy the object to to-space), it does not necessarily</span>
<span class="line-modified">!  * follow we can return immediately from the WB (and store to from-space).</span>
   *
   * In very basic case, on such failure we may wait until the the evacuation is over,
   * and then resolve the forwarded copy, and to the store there. This is possible
   * because other threads might still have space in their GCLABs, and successfully
   * evacuate the object.
<span class="line-new-header">--- 30,12 ---</span>
  
  /**
   * Provides safe handling of out-of-memory situations during evacuation.
   *
   * When a Java thread encounters out-of-memory while evacuating an object in a
<span class="line-modified">!  * load-reference-barrier (i.e. it cannot copy the object to to-space), it does not</span>
<span class="line-modified">!  * necessarily follow we can return immediately from the LRB (and store to from-space).</span>
   *
   * In very basic case, on such failure we may wait until the the evacuation is over,
   * and then resolve the forwarded copy, and to the store there. This is possible
   * because other threads might still have space in their GCLABs, and successfully
   * evacuate the object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,21 ***</span>
   * using a CAS. Depending on the result of the CAS:
   * - success: carry on with evac
   * - failure:
   *   - if offending value is a valid counter, then try again
   *   - if offending value is OOM-during-evac special value: loop until
<span class="line-modified">!  *     counter drops to 0, then exit with read-barrier</span>
   *
   * Upon exit, exiting thread will decrease the counter using atomic dec.
   *
   * Upon OOM-during-evac, any thread will attempt to CAS OOM-during-evac
   * special value into the counter. Depending on result:
<span class="line-modified">!  *   - success: busy-loop until counter drops to zero, then exit with RB</span>
   *   - failure:
   *     - offender is valid counter update: try again
   *     - offender is OOM-during-evac: busy loop until counter drops to
<span class="line-modified">!  *       zero, then exit with RB</span>
   */
  class ShenandoahEvacOOMHandler {
  private:
    static const jint OOM_MARKER_MASK;
  
<span class="line-new-header">--- 63,21 ---</span>
   * using a CAS. Depending on the result of the CAS:
   * - success: carry on with evac
   * - failure:
   *   - if offending value is a valid counter, then try again
   *   - if offending value is OOM-during-evac special value: loop until
<span class="line-modified">!  *     counter drops to 0, then exit with resolving the ptr</span>
   *
   * Upon exit, exiting thread will decrease the counter using atomic dec.
   *
   * Upon OOM-during-evac, any thread will attempt to CAS OOM-during-evac
   * special value into the counter. Depending on result:
<span class="line-modified">!  *   - success: busy-loop until counter drops to zero, then exit with resolve</span>
   *   - failure:
   *     - offender is valid counter update: try again
   *     - offender is OOM-during-evac: busy loop until counter drops to
<span class="line-modified">!  *       zero, then exit with resolve</span>
   */
  class ShenandoahEvacOOMHandler {
  private:
    static const jint OOM_MARKER_MASK;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
    /**
     * Attempt to enter the protected evacuation path.
     *
     * When this returns true, it is safe to continue with normal evacuation.
     * When this method returns false, evacuation must not be entered, and caller
<span class="line-modified">!    * may safely continue with a read-barrier (if Java thread).</span>
     */
    void enter_evacuation();
  
    /**
     * Leave evacuation path.
<span class="line-new-header">--- 93,11 ---</span>
    /**
     * Attempt to enter the protected evacuation path.
     *
     * When this returns true, it is safe to continue with normal evacuation.
     * When this method returns false, evacuation must not be entered, and caller
<span class="line-modified">!    * may safely continue with a simple resolve (if Java thread).</span>
     */
    void enter_evacuation();
  
    /**
     * Leave evacuation path.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,11 ***</span>
    void leave_evacuation();
  
    /**
     * Signal out-of-memory during evacuation. It will prevent any other threads
     * from entering the evacuation path, then wait until all threads have left the
<span class="line-modified">!    * evacuation path, and then return. It is then safe to continue with a read-barrier.</span>
     */
    void handle_out_of_memory_during_evacuation();
  
    void clear();
  };
<span class="line-new-header">--- 105,11 ---</span>
    void leave_evacuation();
  
    /**
     * Signal out-of-memory during evacuation. It will prevent any other threads
     * from entering the evacuation path, then wait until all threads have left the
<span class="line-modified">!    * evacuation path, and then return. It is then safe to continue with a simple resolve.</span>
     */
    void handle_out_of_memory_during_evacuation();
  
    void clear();
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,12 ***</span>
  public:
    ShenandoahEvacOOMScope();
    ~ShenandoahEvacOOMScope();
  };
  
<span class="line-removed">- class ShenandoahEvacOOMScopeLeaver : public StackObj {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahEvacOOMScopeLeaver();</span>
<span class="line-removed">-   ~ShenandoahEvacOOMScopeLeaver();</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHEVACOOMHANDLER_HPP
<span class="line-new-header">--- 118,6 ---</span>
</pre>
<center><a href="shenandoahEvacOOMHandler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
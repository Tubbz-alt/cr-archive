<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 26 
 27 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-removed"> 28 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 29 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahConcurrentMark.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahStringDedup.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;

 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/prefetch.inline.hpp&quot;
 37 
 38 template &lt;class T&gt;
 39 void ShenandoahConcurrentMark::do_task(ShenandoahObjToScanQueue* q, T* cl, jushort* live_data, ShenandoahMarkTask* task) {
 40   oop obj = task-&gt;obj();
 41 
 42   shenandoah_assert_not_forwarded_except(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress() &amp;&amp; _heap-&gt;cancelled_gc());
 43   shenandoah_assert_marked(NULL, obj);
 44   shenandoah_assert_not_in_cset_except(NULL, obj, _heap-&gt;cancelled_gc());
 45 
 46   if (task-&gt;is_not_chunked()) {
 47     if (obj-&gt;is_instance()) {
 48       // Case 1: Normal oop, process as usual.
 49       obj-&gt;oop_iterate(cl);
 50     } else if (obj-&gt;is_objArray()) {
 51       // Case 2: Object array instance and no chunk is set. Must be the first
 52       // time we visit it, start the chunked processing.
 53       do_chunked_array_start&lt;T&gt;(q, cl, obj);
 54     } else {
 55       // Case 3: Primitive array. Do nothing, no oops there. We use the same
 56       // performance tweak TypeArrayKlass::oop_oop_iterate_impl is using:
 57       // We skip iterating over the klass pointer since we know that
 58       // Universe::TypeArrayKlass never moves.
 59       assert (obj-&gt;is_typeArray(), &quot;should be type array&quot;);
 60     }
 61     // Count liveness the last: push the outstanding work to the queues first
 62     count_liveness(live_data, obj);
 63   } else {
 64     // Case 4: Array chunk, has sensible chunk id. Process it.
 65     do_chunked_array&lt;T&gt;(q, cl, obj, task-&gt;chunk(), task-&gt;pow());
 66   }
 67 }
 68 
 69 inline void ShenandoahConcurrentMark::count_liveness(jushort* live_data, oop obj) {
 70   size_t region_idx = _heap-&gt;heap_region_index_containing(obj);
 71   ShenandoahHeapRegion* region = _heap-&gt;get_region(region_idx);
<span class="line-modified"> 72   size_t size = obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
 73 
 74   if (!region-&gt;is_humongous_start()) {
 75     assert(!region-&gt;is_humongous(), &quot;Cannot have continuations here&quot;);
 76     size_t max = (1 &lt;&lt; (sizeof(jushort) * 8)) - 1;
 77     if (size &gt;= max) {
 78       // too big, add to region data directly
 79       region-&gt;increase_live_data_gc_words(size);
 80     } else {
 81       jushort cur = live_data[region_idx];
 82       size_t new_val = cur + size;
 83       if (new_val &gt;= max) {
 84         // overflow, flush to region data
 85         region-&gt;increase_live_data_gc_words(new_val);
 86         live_data[region_idx] = 0;
 87       } else {
 88         // still good, remember in locals
 89         live_data[region_idx] = (jushort) new_val;
 90       }
 91     }
 92   } else {
</pre>
<hr />
<pre>
236   T o = RawAccess&lt;&gt;::oop_load(p);
237   if (!CompressedOops::is_null(o)) {
238     oop obj = CompressedOops::decode_not_null(o);
239     switch (UPDATE_REFS) {
240     case NONE:
241       break;
242     case RESOLVE:
243       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
244       break;
245     case SIMPLE:
246       // We piggy-back reference updating to the marking tasks.
247       obj = heap-&gt;update_with_forwarded_not_null(p, obj);
248       break;
249     case CONCURRENT:
250       obj = heap-&gt;maybe_update_with_forwarded_not_null(p, obj);
251       break;
252     default:
253       ShouldNotReachHere();
254     }
255 
<span class="line-modified">256     // Note: Only when concurrently updating references can obj become NULL here.</span>
<span class="line-modified">257     // It happens when a mutator thread beats us by writing another value. In that</span>
<span class="line-modified">258     // case we don&#39;t need to do anything else.</span>



259     if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {
260       shenandoah_assert_not_forwarded(p, obj);
261       shenandoah_assert_not_in_cset_except(p, obj, heap-&gt;cancelled_gc());
262 
263       if (mark_context-&gt;mark(obj)) {
264         bool pushed = q-&gt;push(ShenandoahMarkTask(obj));
265         assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
266 
267         if ((STRING_DEDUP == ENQUEUE_DEDUP) &amp;&amp; ShenandoahStringDedup::is_candidate(obj)) {
268           assert(ShenandoahStringDedup::is_enabled(), &quot;Must be enabled&quot;);
269           ShenandoahStringDedup::enqueue_candidate(obj);
270         }
271       }
272 
273       shenandoah_assert_marked(p, obj);
274     }
275   }
276 }
277 
278 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 27 
 28 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;

 29 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahConcurrentMark.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahStringDedup.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
<span class="line-added"> 35 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;runtime/prefetch.inline.hpp&quot;
 38 
 39 template &lt;class T&gt;
 40 void ShenandoahConcurrentMark::do_task(ShenandoahObjToScanQueue* q, T* cl, jushort* live_data, ShenandoahMarkTask* task) {
 41   oop obj = task-&gt;obj();
 42 
 43   shenandoah_assert_not_forwarded_except(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress() &amp;&amp; _heap-&gt;cancelled_gc());
 44   shenandoah_assert_marked(NULL, obj);
 45   shenandoah_assert_not_in_cset_except(NULL, obj, _heap-&gt;cancelled_gc());
 46 
 47   if (task-&gt;is_not_chunked()) {
 48     if (obj-&gt;is_instance()) {
 49       // Case 1: Normal oop, process as usual.
 50       obj-&gt;oop_iterate(cl);
 51     } else if (obj-&gt;is_objArray()) {
 52       // Case 2: Object array instance and no chunk is set. Must be the first
 53       // time we visit it, start the chunked processing.
 54       do_chunked_array_start&lt;T&gt;(q, cl, obj);
 55     } else {
 56       // Case 3: Primitive array. Do nothing, no oops there. We use the same
 57       // performance tweak TypeArrayKlass::oop_oop_iterate_impl is using:
 58       // We skip iterating over the klass pointer since we know that
 59       // Universe::TypeArrayKlass never moves.
 60       assert (obj-&gt;is_typeArray(), &quot;should be type array&quot;);
 61     }
 62     // Count liveness the last: push the outstanding work to the queues first
 63     count_liveness(live_data, obj);
 64   } else {
 65     // Case 4: Array chunk, has sensible chunk id. Process it.
 66     do_chunked_array&lt;T&gt;(q, cl, obj, task-&gt;chunk(), task-&gt;pow());
 67   }
 68 }
 69 
 70 inline void ShenandoahConcurrentMark::count_liveness(jushort* live_data, oop obj) {
 71   size_t region_idx = _heap-&gt;heap_region_index_containing(obj);
 72   ShenandoahHeapRegion* region = _heap-&gt;get_region(region_idx);
<span class="line-modified"> 73   size_t size = obj-&gt;size();</span>
 74 
 75   if (!region-&gt;is_humongous_start()) {
 76     assert(!region-&gt;is_humongous(), &quot;Cannot have continuations here&quot;);
 77     size_t max = (1 &lt;&lt; (sizeof(jushort) * 8)) - 1;
 78     if (size &gt;= max) {
 79       // too big, add to region data directly
 80       region-&gt;increase_live_data_gc_words(size);
 81     } else {
 82       jushort cur = live_data[region_idx];
 83       size_t new_val = cur + size;
 84       if (new_val &gt;= max) {
 85         // overflow, flush to region data
 86         region-&gt;increase_live_data_gc_words(new_val);
 87         live_data[region_idx] = 0;
 88       } else {
 89         // still good, remember in locals
 90         live_data[region_idx] = (jushort) new_val;
 91       }
 92     }
 93   } else {
</pre>
<hr />
<pre>
237   T o = RawAccess&lt;&gt;::oop_load(p);
238   if (!CompressedOops::is_null(o)) {
239     oop obj = CompressedOops::decode_not_null(o);
240     switch (UPDATE_REFS) {
241     case NONE:
242       break;
243     case RESOLVE:
244       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
245       break;
246     case SIMPLE:
247       // We piggy-back reference updating to the marking tasks.
248       obj = heap-&gt;update_with_forwarded_not_null(p, obj);
249       break;
250     case CONCURRENT:
251       obj = heap-&gt;maybe_update_with_forwarded_not_null(p, obj);
252       break;
253     default:
254       ShouldNotReachHere();
255     }
256 
<span class="line-modified">257     // Note: Only when concurrently updating references can obj be different</span>
<span class="line-modified">258     // (that is, really different, not just different from-/to-space copies of the same)</span>
<span class="line-modified">259     // from the one we originally loaded. Mutator thread can beat us by writing something</span>
<span class="line-added">260     // else into the location. In that case, we would mark through that updated value,</span>
<span class="line-added">261     // on the off-chance it is not handled by other means (e.g. via SATB). However,</span>
<span class="line-added">262     // if that write was NULL, we don&#39;t need to do anything else.</span>
263     if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {
264       shenandoah_assert_not_forwarded(p, obj);
265       shenandoah_assert_not_in_cset_except(p, obj, heap-&gt;cancelled_gc());
266 
267       if (mark_context-&gt;mark(obj)) {
268         bool pushed = q-&gt;push(ShenandoahMarkTask(obj));
269         assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
270 
271         if ((STRING_DEDUP == ENQUEUE_DEDUP) &amp;&amp; ShenandoahStringDedup::is_candidate(obj)) {
272           assert(ShenandoahStringDedup::is_enabled(), &quot;Must be enabled&quot;);
273           ShenandoahStringDedup::enqueue_candidate(obj);
274         }
275       }
276 
277       shenandoah_assert_marked(p, obj);
278     }
279   }
280 }
281 
282 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
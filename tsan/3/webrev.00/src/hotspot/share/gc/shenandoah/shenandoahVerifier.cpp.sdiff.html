<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahVMOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahVerifier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified">  27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>

  28 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  34 #include &quot;memory/allocation.hpp&quot;
  35 #include &quot;memory/iterator.inline.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;




  37 
  38 // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
  39 #ifdef verify_oop
  40 #undef verify_oop
  41 #endif
  42 
  43 class ShenandoahVerifyOopClosure : public BasicOopIterateClosure {
  44 private:
  45   const char* _phase;
  46   ShenandoahVerifier::VerifyOptions _options;
  47   ShenandoahVerifierStack* _stack;
  48   ShenandoahHeap* _heap;
  49   MarkBitMap* _map;
  50   ShenandoahLivenessData* _ld;
  51   void* _interior_loc;
  52   oop _loc;
  53 
  54 public:
  55   ShenandoahVerifyOopClosure(ShenandoahVerifierStack* stack, MarkBitMap* map, ShenandoahLivenessData* ld,
  56                              const char* phase, ShenandoahVerifier::VerifyOptions options) :
</pre>
<hr />
<pre>
  65 
  66 private:
  67   void check(ShenandoahAsserts::SafeLevel level, oop obj, bool test, const char* label) {
  68     if (!test) {
  69       ShenandoahAsserts::print_failure(level, obj, _interior_loc, _loc, _phase, label, __FILE__, __LINE__);
  70     }
  71   }
  72 
  73   template &lt;class T&gt;
  74   void do_oop_work(T* p) {
  75     T o = RawAccess&lt;&gt;::oop_load(p);
  76     if (!CompressedOops::is_null(o)) {
  77       oop obj = CompressedOops::decode_not_null(o);
  78 
  79       // Single threaded verification can use faster non-atomic stack and bitmap
  80       // methods.
  81       //
  82       // For performance reasons, only fully verify non-marked field values.
  83       // We are here when the host object for *p is already marked.
  84 
<span class="line-modified">  85       HeapWord* addr = (HeapWord*) obj;</span>
<span class="line-removed">  86       if (_map-&gt;par_mark(addr)) {</span>
  87         verify_oop_at(p, obj);
  88         _stack-&gt;push(ShenandoahVerifierTask(obj));
  89       }
  90     }
  91   }
  92 
  93   void verify_oop(oop obj) {
  94     // Perform consistency checks with gradually decreasing safety level. This guarantees
  95     // that failure report would not try to touch something that was not yet verified to be
  96     // safe to process.
  97 
  98     check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
  99               &quot;oop must be in heap&quot;);
<span class="line-modified"> 100     check(ShenandoahAsserts::_safe_unknown, obj, check_obj_alignment(obj),</span>
 101               &quot;oop must be aligned&quot;);
 102 
 103     ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
 104     Klass* obj_klass = obj-&gt;klass_or_null();
 105 
 106     // Verify that obj is not in dead space:
 107     {
 108       // Do this before touching obj-&gt;size()
 109       check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
 110              &quot;Object klass pointer should not be NULL&quot;);
 111       check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
 112              &quot;Object klass pointer must go to metaspace&quot;);
 113 
<span class="line-modified"> 114       HeapWord *obj_addr = (HeapWord *) obj;</span>
 115       check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
 116              &quot;Object start should be within the region&quot;);
 117 
 118       if (!obj_reg-&gt;is_humongous()) {
 119         check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
 120                &quot;Object end should be within the region&quot;);
 121       } else {
 122         size_t humongous_start = obj_reg-&gt;region_number();
 123         size_t humongous_end = humongous_start + (obj-&gt;size() &gt;&gt; ShenandoahHeapRegion::region_size_words_shift());
 124         for (size_t idx = humongous_start + 1; idx &lt; humongous_end; idx++) {
 125           check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;get_region(idx)-&gt;is_humongous_continuation(),
 126                  &quot;Humongous object is in continuation that fits it&quot;);
 127         }
 128       }
 129 
 130       // ------------ obj is safe at this point --------------
 131 
 132       check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;is_active(),
 133             &quot;Object should be in active region&quot;);
 134 
 135       switch (_options._verify_liveness) {
 136         case ShenandoahVerifier::_verify_liveness_disable:
 137           // skip
 138           break;
 139         case ShenandoahVerifier::_verify_liveness_complete:
<span class="line-modified"> 140           Atomic::add(obj-&gt;size() + ShenandoahBrooksPointer::word_size(), &amp;_ld[obj_reg-&gt;region_number()]);</span>
 141           // fallthrough for fast failure for un-live regions:
 142         case ShenandoahVerifier::_verify_liveness_conservative:
 143           check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
 144                    &quot;Object must belong to region with live data&quot;);
 145           break;
 146         default:
 147           assert(false, &quot;Unhandled liveness verification&quot;);
 148       }
 149     }
 150 
<span class="line-modified"> 151     oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);</span>
 152 
 153     ShenandoahHeapRegion* fwd_reg = NULL;
 154 
<span class="line-modified"> 155     if (!oopDesc::equals_raw(obj, fwd)) {</span>
 156       check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
 157              &quot;Forwardee must be in heap&quot;);
 158       check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
 159              &quot;Forwardee is set&quot;);
<span class="line-modified"> 160       check(ShenandoahAsserts::_safe_oop, obj, check_obj_alignment(fwd),</span>
 161              &quot;Forwardee must be aligned&quot;);
 162 
 163       // Do this before touching fwd-&gt;size()
 164       Klass* fwd_klass = fwd-&gt;klass_or_null();
 165       check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
 166              &quot;Forwardee klass pointer should not be NULL&quot;);
 167       check(ShenandoahAsserts::_safe_oop, obj, Metaspace::contains(fwd_klass),
 168              &quot;Forwardee klass pointer must go to metaspace&quot;);
 169       check(ShenandoahAsserts::_safe_oop, obj, obj_klass == fwd_klass,
 170              &quot;Forwardee klass pointer must go to metaspace&quot;);
 171 
 172       fwd_reg = _heap-&gt;heap_region_containing(fwd);
 173 
 174       // Verify that forwardee is not in the dead space:
 175       check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
 176              &quot;Should have no humongous forwardees&quot;);
 177 
<span class="line-modified"> 178       HeapWord *fwd_addr = (HeapWord *) fwd;</span>
 179       check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
 180              &quot;Forwardee start should be within the region&quot;);
 181       check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
 182              &quot;Forwardee end should be within the region&quot;);
 183 
<span class="line-modified"> 184       oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);</span>
<span class="line-modified"> 185       check(ShenandoahAsserts::_safe_oop, obj, oopDesc::equals_raw(fwd, fwd2),</span>
 186              &quot;Double forwarding&quot;);
 187     } else {
 188       fwd_reg = obj_reg;
 189     }
 190 
 191     // ------------ obj and fwd are safe at this point --------------
 192 
 193     switch (_options._verify_marked) {
 194       case ShenandoahVerifier::_verify_marked_disable:
 195         // skip
 196         break;
 197       case ShenandoahVerifier::_verify_marked_incomplete:
 198         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;marking_context()-&gt;is_marked(obj),
 199                &quot;Must be marked in incomplete bitmap&quot;);
 200         break;
 201       case ShenandoahVerifier::_verify_marked_complete:
 202         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;complete_marking_context()-&gt;is_marked(obj),
 203                &quot;Must be marked in complete bitmap&quot;);
 204         break;
 205       default:
 206         assert(false, &quot;Unhandled mark verification&quot;);
 207     }
 208 
 209     switch (_options._verify_forwarded) {
 210       case ShenandoahVerifier::_verify_forwarded_disable:
 211         // skip
 212         break;
 213       case ShenandoahVerifier::_verify_forwarded_none: {
<span class="line-modified"> 214         check(ShenandoahAsserts::_safe_all, obj, oopDesc::equals_raw(obj, fwd),</span>
 215                &quot;Should not be forwarded&quot;);
 216         break;
 217       }
 218       case ShenandoahVerifier::_verify_forwarded_allow: {
<span class="line-modified"> 219         if (!oopDesc::equals_raw(obj, fwd)) {</span>
 220           check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
 221                  &quot;Forwardee should be in another region&quot;);
 222         }
 223         break;
 224       }
 225       default:
 226         assert(false, &quot;Unhandled forwarding verification&quot;);
 227     }
 228 
 229     switch (_options._verify_cset) {
 230       case ShenandoahVerifier::_verify_cset_disable:
 231         // skip
 232         break;
 233       case ShenandoahVerifier::_verify_cset_none:
 234         check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
 235                &quot;Should not have references to collection set&quot;);
 236         break;
 237       case ShenandoahVerifier::_verify_cset_forwarded:
 238         if (_heap-&gt;in_collection_set(obj)) {
<span class="line-modified"> 239           check(ShenandoahAsserts::_safe_all, obj, !oopDesc::equals_raw(obj, fwd),</span>
 240                  &quot;Object in collection set, should have forwardee&quot;);
 241         }
 242         break;
 243       default:
 244         assert(false, &quot;Unhandled cset verification&quot;);
 245     }
 246 
 247   }
 248 
 249 public:
 250   /**
 251    * Verify object with known interior reference.
 252    * @param p interior reference where the object is referenced from; can be off-heap
 253    * @param obj verified object
 254    */
 255   template &lt;class T&gt;
 256   void verify_oop_at(T* p, oop obj) {
 257     _interior_loc = p;
 258     verify_oop(obj);
 259     _interior_loc = NULL;
</pre>
<hr />
<pre>
 401     verify(r, r-&gt;is_empty() || r-&gt;seqnum_last_alloc() != 0,
 402            &quot;Non-empty regions should have last seqnum set&quot;);
 403 
 404     verify(r, r-&gt;is_empty() || (r-&gt;seqnum_last_alloc_mutator() != 0 || r-&gt;seqnum_last_alloc_gc() != 0),
 405            &quot;Non-empty regions should have last seqnum set to either GC or mutator&quot;);
 406 
 407     verify(r, r-&gt;seqnum_first_alloc() &lt;= r-&gt;seqnum_last_alloc(),
 408            &quot;First seqnum should not be greater than last timestamp&quot;);
 409 
 410     verify(r, r-&gt;seqnum_first_alloc_mutator() &lt;= r-&gt;seqnum_last_alloc_mutator(),
 411            &quot;First mutator seqnum should not be greater than last seqnum&quot;);
 412 
 413     verify(r, r-&gt;seqnum_first_alloc_gc() &lt;= r-&gt;seqnum_last_alloc_gc(),
 414            &quot;First GC seqnum should not be greater than last seqnum&quot;);
 415   }
 416 };
 417 
 418 class ShenandoahVerifierReachableTask : public AbstractGangTask {
 419 private:
 420   const char* _label;
<span class="line-modified"> 421   ShenandoahRootProcessor* _rp;</span>
 422   ShenandoahVerifier::VerifyOptions _options;
 423   ShenandoahHeap* _heap;
 424   ShenandoahLivenessData* _ld;
 425   MarkBitMap* _bitmap;
 426   volatile size_t _processed;
 427 
 428 public:
 429   ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
 430                                   ShenandoahLivenessData* ld,
<span class="line-modified"> 431                                   ShenandoahRootProcessor* rp,</span>
 432                                   const char* label,
 433                                   ShenandoahVerifier::VerifyOptions options) :
 434     AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
 435     _label(label),
<span class="line-modified"> 436     _rp(rp),</span>
 437     _options(options),
 438     _heap(ShenandoahHeap::heap()),
 439     _ld(ld),
 440     _bitmap(bitmap),
 441     _processed(0) {};
 442 
 443   size_t processed() {
 444     return _processed;
 445   }
 446 
 447   virtual void work(uint worker_id) {
 448     ResourceMark rm;
 449     ShenandoahVerifierStack stack;
 450 
 451     // On level 2, we need to only check the roots once.
 452     // On level 3, we want to check the roots, and seed the local stack.
 453     // It is a lesser evil to accept multiple root scans at level 3, because
 454     // extended parallelism would buy us out.
 455     if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
 456         || (ShenandoahVerifyLevel &gt;= 3)) {
 457         ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 458                                       ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
 459                                       _options);
<span class="line-modified"> 460         _rp-&gt;process_all_roots_slow(&amp;cl);</span>




 461     }
 462 
 463     size_t processed = 0;
 464 
 465     if (ShenandoahVerifyLevel &gt;= 3) {
 466       ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 467                                     ShenandoahMessageBuffer(&quot;%s, Reachable&quot;, _label),
 468                                     _options);
 469       while (!stack.is_empty()) {
 470         processed++;
 471         ShenandoahVerifierTask task = stack.pop();
 472         cl.verify_oops_from(task.obj());
 473       }
 474     }
 475 
<span class="line-modified"> 476     Atomic::add(processed, &amp;_processed);</span>
 477   }
 478 };
 479 
 480 class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
 481 private:
 482   const char* _label;
 483   ShenandoahVerifier::VerifyOptions _options;
 484   ShenandoahHeap *_heap;
 485   MarkBitMap* _bitmap;
 486   ShenandoahLivenessData* _ld;
 487   volatile size_t _claimed;
 488   volatile size_t _processed;
 489 
 490 public:
 491   ShenandoahVerifierMarkedRegionTask(MarkBitMap* bitmap,
 492                                      ShenandoahLivenessData* ld,
 493                                      const char* label,
 494                                      ShenandoahVerifier::VerifyOptions options) :
 495           AbstractGangTask(&quot;Shenandoah Parallel Verifier Marked Region&quot;),
 496           _label(label),
 497           _options(options),
 498           _heap(ShenandoahHeap::heap()),
 499           _bitmap(bitmap),
 500           _ld(ld),
 501           _claimed(0),
 502           _processed(0) {};
 503 
 504   size_t processed() {
 505     return _processed;
 506   }
 507 
 508   virtual void work(uint worker_id) {
 509     ShenandoahVerifierStack stack;
 510     ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 511                                   ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
 512                                   _options);
 513 
 514     while (true) {
<span class="line-modified"> 515       size_t v = Atomic::add(1u, &amp;_claimed) - 1;</span>
 516       if (v &lt; _heap-&gt;num_regions()) {
 517         ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
 518         if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
 519           work_regular(r, stack, cl);
 520         } else if (r-&gt;is_humongous_start()) {
 521           work_humongous(r, stack, cl);
 522         }
 523       } else {
 524         break;
 525       }
 526     }
 527   }
 528 
 529   virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
 530     size_t processed = 0;
<span class="line-modified"> 531     HeapWord* obj = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
 532     if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
 533       verify_and_follow(obj, stack, cl, &amp;processed);
 534     }
<span class="line-modified"> 535     Atomic::add(processed, &amp;_processed);</span>
 536   }
 537 
 538   virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
 539     size_t processed = 0;
 540     MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
 541     HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
 542 
 543     // Bitmaps, before TAMS
 544     if (tams &gt; r-&gt;bottom()) {
<span class="line-modified"> 545       HeapWord* start = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
 546       HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
 547 
 548       while (addr &lt; tams) {
 549         verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified"> 550         addr += ShenandoahBrooksPointer::word_size();</span>
 551         if (addr &lt; tams) {
 552           addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
 553         }
 554       }
 555     }
 556 
 557     // Size-based, after TAMS
 558     {
 559       HeapWord* limit = r-&gt;top();
<span class="line-modified"> 560       HeapWord* addr = tams + ShenandoahBrooksPointer::word_size();</span>
 561 
 562       while (addr &lt; limit) {
 563         verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified"> 564         addr += oop(addr)-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
 565       }
 566     }
 567 
<span class="line-modified"> 568     Atomic::add(processed, &amp;_processed);</span>
 569   }
 570 
 571   void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
 572     if (!_bitmap-&gt;par_mark(addr)) return;
 573 
 574     // Verify the object itself:
 575     oop obj = oop(addr);
 576     cl.verify_oop_standalone(obj);
 577 
 578     // Verify everything reachable from that object too, hopefully realizing
 579     // everything was already marked, and never touching further:
 580     cl.verify_oops_from(obj);
 581     (*processed)++;
 582 
 583     while (!stack.is_empty()) {
 584       ShenandoahVerifierTask task = stack.pop();
 585       cl.verify_oops_from(task.obj());
 586       (*processed)++;
 587     }
 588   }
 589 };
 590 
 591 class VerifyThreadGCState : public ThreadClosure {
 592 private:
 593   const char* _label;
 594   char _expected;
 595 
 596 public:
 597   VerifyThreadGCState(const char* label, char expected) : _expected(expected) {}
 598   void do_thread(Thread* t) {
 599     char actual = ShenandoahThreadLocalData::gc_state(t);
 600     if (actual != _expected) {
 601       fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
 602     }
 603   }
 604 };
 605 

















 606 void ShenandoahVerifier::verify_at_safepoint(const char *label,
 607                                              VerifyForwarded forwarded, VerifyMarked marked,
 608                                              VerifyCollectionSet cset,
 609                                              VerifyLiveness liveness, VerifyRegions regions,
<span class="line-modified"> 610                                              VerifyGCState gcstate) {</span>

 611   guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
 612   guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
 613 
 614   // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
 615   ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
 616 
 617   log_info(gc,start)(&quot;Verify %s, Level &quot; INTX_FORMAT, label, ShenandoahVerifyLevel);
 618 
 619   // GC state checks
 620   {
 621     char expected = -1;
 622     bool enabled;
 623     switch (gcstate) {
 624       case _verify_gcstate_disable:
 625         enabled = false;
 626         break;
 627       case _verify_gcstate_forwarded:
 628         enabled = true;
 629         expected = ShenandoahHeap::HAS_FORWARDED;
 630         break;




 631       case _verify_gcstate_stable:
 632         enabled = true;
 633         expected = ShenandoahHeap::STABLE;
 634         break;
 635       default:
 636         enabled = false;
 637         assert(false, &quot;Unhandled gc-state verification&quot;);
 638     }
 639 
 640     if (enabled) {
 641       char actual = _heap-&gt;gc_state();
 642       if (actual != expected) {
 643         fatal(&quot;%s: Global gc-state: expected %d, actual %d&quot;, label, expected, actual);
 644       }
 645 
 646       VerifyThreadGCState vtgcs(label, expected);
 647       Threads::java_threads_do(&amp;vtgcs);
 648     }
 649   }
 650 



 651   // Heap size checks
 652   {
 653     ShenandoahHeapLocker lock(_heap-&gt;lock());
 654 
 655     ShenandoahCalculateRegionStatsClosure cl;
 656     _heap-&gt;heap_region_iterate(&amp;cl);
 657     size_t heap_used = _heap-&gt;used();
 658     guarantee(cl.used() == heap_used,
<span class="line-modified"> 659               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;K, regions-used = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified"> 660               label, heap_used/K, cl.used()/K);</span>


 661 
 662     size_t heap_committed = _heap-&gt;committed();
 663     guarantee(cl.committed() == heap_committed,
<span class="line-modified"> 664               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;K, regions-committed = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified"> 665               label, heap_committed/K, cl.committed()/K);</span>


 666   }
 667 
 668   // Internal heap region checks
 669   if (ShenandoahVerifyLevel &gt;= 1) {
 670     ShenandoahVerifyHeapRegionClosure cl(label, regions);
 671     _heap-&gt;heap_region_iterate(&amp;cl);
 672   }
 673 
 674   OrderAccess::fence();
 675   _heap-&gt;make_parsable(false);
 676 
 677   // Allocate temporary bitmap for storing marking wavefront:
 678   _verification_bit_map-&gt;clear();
 679 
 680   // Allocate temporary array for storing liveness data
 681   ShenandoahLivenessData* ld = NEW_C_HEAP_ARRAY(ShenandoahLivenessData, _heap-&gt;num_regions(), mtGC);
 682   Copy::fill_to_bytes((void*)ld, _heap-&gt;num_regions()*sizeof(ShenandoahLivenessData), 0);
 683 
 684   const VerifyOptions&amp; options = ShenandoahVerifier::VerifyOptions(forwarded, marked, cset, liveness, regions, gcstate);
 685 
 686   // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
 687   // This verifies what application can see, since it only cares about reachable objects.
 688   size_t count_reachable = 0;
 689   if (ShenandoahVerifyLevel &gt;= 2) {
<span class="line-modified"> 690     ShenandoahRootProcessor rp(_heap, _heap-&gt;workers()-&gt;active_workers(),</span>
<span class="line-modified"> 691                                ShenandoahPhaseTimings::_num_phases); // no need for stats</span>











 692 
<span class="line-modified"> 693     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;rp, label, options);</span>
 694     _heap-&gt;workers()-&gt;run_task(&amp;task);
 695     count_reachable = task.processed();
 696   }
 697 
 698   // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
 699   // not the application, can see during the region scans. There is no reason to process the objects
 700   // that were already verified, e.g. those marked in verification bitmap. There is interaction with TAMS:
 701   // before TAMS, we verify the bitmaps, if available; after TAMS, we walk until the top(). It mimics
 702   // what marked_object_iterate is doing, without calling into that optimized (and possibly incorrect)
 703   // version
 704 
 705   size_t count_marked = 0;
 706   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete) {
 707     guarantee(_heap-&gt;marking_context()-&gt;is_complete(), &quot;Marking context should be complete&quot;);
 708     ShenandoahVerifierMarkedRegionTask task(_verification_bit_map, ld, label, options);
 709     _heap-&gt;workers()-&gt;run_task(&amp;task);
 710     count_marked = task.processed();
 711   } else {
 712     guarantee(ShenandoahVerifyLevel &lt; 4 || marked == _verify_marked_incomplete || marked == _verify_marked_disable, &quot;Should be&quot;);
 713   }
 714 
 715   // Step 4. Verify accumulated liveness data, if needed. Only reliable if verification level includes
 716   // marked objects.
 717 
 718   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete &amp;&amp; liveness == _verify_liveness_complete) {
 719     for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
 720       ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
 721 
 722       juint verf_live = 0;
 723       if (r-&gt;is_humongous()) {
 724         // For humongous objects, test if start region is marked live, and if so,
 725         // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<span class="line-modified"> 726         juint start_live = OrderAccess::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;region_number()]);</span>
 727         if (start_live &gt; 0) {
 728           verf_live = (juint)(r-&gt;used() / HeapWordSize);
 729         }
 730       } else {
<span class="line-modified"> 731         verf_live = OrderAccess::load_acquire(&amp;ld[r-&gt;region_number()]);</span>
 732       }
 733 
 734       size_t reg_live = r-&gt;get_live_data_words();
 735       if (reg_live != verf_live) {
 736         ResourceMark rm;
 737         stringStream ss;
 738         r-&gt;print_on(&amp;ss);
 739         fatal(&quot;%s: Live data should match: region-live = &quot; SIZE_FORMAT &quot;, verifier-live = &quot; UINT32_FORMAT &quot;\n%s&quot;,
 740               label, reg_live, verf_live, ss.as_string());
 741       }
 742     }
 743   }
 744 
 745   log_info(gc)(&quot;Verify %s, Level &quot; INTX_FORMAT &quot; (&quot; SIZE_FORMAT &quot; reachable, &quot; SIZE_FORMAT &quot; marked)&quot;,
 746                label, ShenandoahVerifyLevel, count_reachable, count_marked);
 747 
 748   FREE_C_HEAP_ARRAY(ShenandoahLivenessData, ld);
 749 }
 750 
 751 void ShenandoahVerifier::verify_generic(VerifyOption vo) {
 752   verify_at_safepoint(
 753           &quot;Generic Verification&quot;,
 754           _verify_forwarded_allow,     // conservatively allow forwarded
 755           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 756           _verify_cset_disable,        // cset may be inconsistent
 757           _verify_liveness_disable,    // no reliable liveness data
 758           _verify_regions_disable,     // no reliable region data
<span class="line-modified"> 759           _verify_gcstate_disable      // no data about gcstate</span>

 760   );
 761 }
 762 
 763 void ShenandoahVerifier::verify_before_concmark() {
 764   if (_heap-&gt;has_forwarded_objects()) {
 765     verify_at_safepoint(
 766             &quot;Before Mark&quot;,
 767             _verify_forwarded_allow,     // may have forwarded references
 768             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 769             _verify_cset_forwarded,      // allow forwarded references to cset
 770             _verify_liveness_disable,    // no reliable liveness data
 771             _verify_regions_notrash,     // no trash regions
<span class="line-modified"> 772             _verify_gcstate_forwarded    // there are forwarded objects</span>

 773     );
 774   } else {
 775     verify_at_safepoint(
 776             &quot;Before Mark&quot;,
 777             _verify_forwarded_none,      // UR should have fixed up
 778             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 779             _verify_cset_none,           // UR should have fixed this
 780             _verify_liveness_disable,    // no reliable liveness data
 781             _verify_regions_notrash,     // no trash regions
<span class="line-modified"> 782             _verify_gcstate_stable       // there are no forwarded objects</span>

 783     );
 784   }
 785 }
 786 
 787 void ShenandoahVerifier::verify_after_concmark() {
 788   verify_at_safepoint(
 789           &quot;After Mark&quot;,
 790           _verify_forwarded_none,      // no forwarded references
 791           _verify_marked_complete,     // bitmaps as precise as we can get
 792           _verify_cset_none,           // no references to cset anymore
 793           _verify_liveness_complete,   // liveness data must be complete here
 794           _verify_regions_disable,     // trash regions not yet recycled
<span class="line-modified"> 795           _verify_gcstate_stable       // mark should have stabilized the heap</span>

 796   );
 797 }
 798 
 799 void ShenandoahVerifier::verify_before_evacuation() {





 800   verify_at_safepoint(
 801           &quot;Before Evacuation&quot;,
 802           _verify_forwarded_none,    // no forwarded references
 803           _verify_marked_complete,   // walk over marked objects too
 804           _verify_cset_disable,      // non-forwarded references to cset expected
 805           _verify_liveness_complete, // liveness data must be complete here
 806           _verify_regions_disable,   // trash regions not yet recycled
<span class="line-modified"> 807           _verify_gcstate_stable     // mark should have stabilized the heap</span>



















 808   );
 809 }
 810 
 811 void ShenandoahVerifier::verify_after_evacuation() {
 812   verify_at_safepoint(
 813           &quot;After Evacuation&quot;,
 814           _verify_forwarded_allow,     // objects are still forwarded
 815           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 816           _verify_cset_forwarded,      // all cset refs are fully forwarded
 817           _verify_liveness_disable,    // no reliable liveness data anymore
 818           _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified"> 819           _verify_gcstate_forwarded    // evacuation produced some forwarded objects</span>

 820   );
 821 }
 822 
 823 void ShenandoahVerifier::verify_before_updaterefs() {
 824   verify_at_safepoint(
 825           &quot;Before Updating References&quot;,
 826           _verify_forwarded_allow,     // forwarded references allowed
 827           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 828           _verify_cset_forwarded,      // all cset refs are fully forwarded
 829           _verify_liveness_disable,    // no reliable liveness data anymore
 830           _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified"> 831           _verify_gcstate_forwarded    // evacuation should have produced some forwarded objects</span>

 832   );
 833 }
 834 
 835 void ShenandoahVerifier::verify_after_updaterefs() {
 836   verify_at_safepoint(
 837           &quot;After Updating References&quot;,
 838           _verify_forwarded_none,      // no forwarded references
 839           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 840           _verify_cset_none,           // no cset references, all updated
 841           _verify_liveness_disable,    // no reliable liveness data anymore
 842           _verify_regions_nocset,      // no cset regions, trash regions have appeared
<span class="line-modified"> 843           _verify_gcstate_stable       // update refs had cleaned up forwarded objects</span>

 844   );
 845 }
 846 
 847 void ShenandoahVerifier::verify_after_degenerated() {
 848   verify_at_safepoint(
 849           &quot;After Degenerated GC&quot;,
 850           _verify_forwarded_none,      // all objects are non-forwarded
 851           _verify_marked_complete,     // all objects are marked in complete bitmap
 852           _verify_cset_none,           // no cset references
 853           _verify_liveness_disable,    // no reliable liveness data anymore
 854           _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified"> 855           _verify_gcstate_stable       // degenerated refs had cleaned up forwarded objects</span>

 856   );
 857 }
 858 
 859 void ShenandoahVerifier::verify_before_traversal() {
 860   verify_at_safepoint(
 861           &quot;Before Traversal&quot;,
 862           _verify_forwarded_none,      // cannot have forwarded objects
 863           _verify_marked_disable,      // bitmaps are not relevant before traversal
 864           _verify_cset_none,           // no cset references before traversal
 865           _verify_liveness_disable,    // no reliable liveness data anymore
 866           _verify_regions_notrash_nocset, // no trash and no cset regions
<span class="line-modified"> 867           _verify_gcstate_stable       // nothing forwarded before traversal</span>

 868   );
 869 }
 870 
 871 void ShenandoahVerifier::verify_after_traversal() {
 872   verify_at_safepoint(
 873           &quot;After Traversal&quot;,
 874           _verify_forwarded_none,      // cannot have forwarded objects
 875           _verify_marked_complete,     // should have complete marking after traversal
 876           _verify_cset_none,           // no cset references left after traversal
 877           _verify_liveness_disable,    // liveness data is not collected for new allocations
 878           _verify_regions_nocset,      // no cset regions, trash regions allowed
<span class="line-modified"> 879           _verify_gcstate_stable       // nothing forwarded after traversal</span>

 880   );
 881 }
 882 
 883 void ShenandoahVerifier::verify_before_fullgc() {
 884   verify_at_safepoint(
 885           &quot;Before Full GC&quot;,
 886           _verify_forwarded_allow,     // can have forwarded objects
 887           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 888           _verify_cset_disable,        // cset might be foobared
 889           _verify_liveness_disable,    // no reliable liveness data anymore
 890           _verify_regions_disable,     // no reliable region data here
<span class="line-modified"> 891           _verify_gcstate_disable      // no reliable gcstate data</span>

 892   );
 893 }
 894 
 895 void ShenandoahVerifier::verify_after_fullgc() {
 896   verify_at_safepoint(
 897           &quot;After Full GC&quot;,
 898           _verify_forwarded_none,      // all objects are non-forwarded
 899           _verify_marked_complete,     // all objects are marked in complete bitmap
 900           _verify_cset_none,           // no cset references
 901           _verify_liveness_disable,    // no reliable liveness data anymore
 902           _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified"> 903           _verify_gcstate_stable       // full gc cleaned up everything</span>

 904   );
 905 }














































































</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified">  28 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
<span class="line-added">  29 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
  30 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  36 #include &quot;memory/allocation.hpp&quot;
  37 #include &quot;memory/iterator.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  39 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
<span class="line-added">  40 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  41 #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-added">  42 #include &quot;utilities/align.hpp&quot;</span>
  43 
  44 // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
  45 #ifdef verify_oop
  46 #undef verify_oop
  47 #endif
  48 
  49 class ShenandoahVerifyOopClosure : public BasicOopIterateClosure {
  50 private:
  51   const char* _phase;
  52   ShenandoahVerifier::VerifyOptions _options;
  53   ShenandoahVerifierStack* _stack;
  54   ShenandoahHeap* _heap;
  55   MarkBitMap* _map;
  56   ShenandoahLivenessData* _ld;
  57   void* _interior_loc;
  58   oop _loc;
  59 
  60 public:
  61   ShenandoahVerifyOopClosure(ShenandoahVerifierStack* stack, MarkBitMap* map, ShenandoahLivenessData* ld,
  62                              const char* phase, ShenandoahVerifier::VerifyOptions options) :
</pre>
<hr />
<pre>
  71 
  72 private:
  73   void check(ShenandoahAsserts::SafeLevel level, oop obj, bool test, const char* label) {
  74     if (!test) {
  75       ShenandoahAsserts::print_failure(level, obj, _interior_loc, _loc, _phase, label, __FILE__, __LINE__);
  76     }
  77   }
  78 
  79   template &lt;class T&gt;
  80   void do_oop_work(T* p) {
  81     T o = RawAccess&lt;&gt;::oop_load(p);
  82     if (!CompressedOops::is_null(o)) {
  83       oop obj = CompressedOops::decode_not_null(o);
  84 
  85       // Single threaded verification can use faster non-atomic stack and bitmap
  86       // methods.
  87       //
  88       // For performance reasons, only fully verify non-marked field values.
  89       // We are here when the host object for *p is already marked.
  90 
<span class="line-modified">  91       if (_map-&gt;par_mark(obj)) {</span>

  92         verify_oop_at(p, obj);
  93         _stack-&gt;push(ShenandoahVerifierTask(obj));
  94       }
  95     }
  96   }
  97 
  98   void verify_oop(oop obj) {
  99     // Perform consistency checks with gradually decreasing safety level. This guarantees
 100     // that failure report would not try to touch something that was not yet verified to be
 101     // safe to process.
 102 
 103     check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
 104               &quot;oop must be in heap&quot;);
<span class="line-modified"> 105     check(ShenandoahAsserts::_safe_unknown, obj, is_object_aligned(obj),</span>
 106               &quot;oop must be aligned&quot;);
 107 
 108     ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
 109     Klass* obj_klass = obj-&gt;klass_or_null();
 110 
 111     // Verify that obj is not in dead space:
 112     {
 113       // Do this before touching obj-&gt;size()
 114       check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
 115              &quot;Object klass pointer should not be NULL&quot;);
 116       check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
 117              &quot;Object klass pointer must go to metaspace&quot;);
 118 
<span class="line-modified"> 119       HeapWord *obj_addr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
 120       check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
 121              &quot;Object start should be within the region&quot;);
 122 
 123       if (!obj_reg-&gt;is_humongous()) {
 124         check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
 125                &quot;Object end should be within the region&quot;);
 126       } else {
 127         size_t humongous_start = obj_reg-&gt;region_number();
 128         size_t humongous_end = humongous_start + (obj-&gt;size() &gt;&gt; ShenandoahHeapRegion::region_size_words_shift());
 129         for (size_t idx = humongous_start + 1; idx &lt; humongous_end; idx++) {
 130           check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;get_region(idx)-&gt;is_humongous_continuation(),
 131                  &quot;Humongous object is in continuation that fits it&quot;);
 132         }
 133       }
 134 
 135       // ------------ obj is safe at this point --------------
 136 
 137       check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;is_active(),
 138             &quot;Object should be in active region&quot;);
 139 
 140       switch (_options._verify_liveness) {
 141         case ShenandoahVerifier::_verify_liveness_disable:
 142           // skip
 143           break;
 144         case ShenandoahVerifier::_verify_liveness_complete:
<span class="line-modified"> 145           Atomic::add(&amp;_ld[obj_reg-&gt;region_number()], (uint) obj-&gt;size());</span>
 146           // fallthrough for fast failure for un-live regions:
 147         case ShenandoahVerifier::_verify_liveness_conservative:
 148           check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
 149                    &quot;Object must belong to region with live data&quot;);
 150           break;
 151         default:
 152           assert(false, &quot;Unhandled liveness verification&quot;);
 153       }
 154     }
 155 
<span class="line-modified"> 156     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
 157 
 158     ShenandoahHeapRegion* fwd_reg = NULL;
 159 
<span class="line-modified"> 160     if (obj != fwd) {</span>
 161       check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
 162              &quot;Forwardee must be in heap&quot;);
 163       check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
 164              &quot;Forwardee is set&quot;);
<span class="line-modified"> 165       check(ShenandoahAsserts::_safe_oop, obj, is_object_aligned(fwd),</span>
 166              &quot;Forwardee must be aligned&quot;);
 167 
 168       // Do this before touching fwd-&gt;size()
 169       Klass* fwd_klass = fwd-&gt;klass_or_null();
 170       check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
 171              &quot;Forwardee klass pointer should not be NULL&quot;);
 172       check(ShenandoahAsserts::_safe_oop, obj, Metaspace::contains(fwd_klass),
 173              &quot;Forwardee klass pointer must go to metaspace&quot;);
 174       check(ShenandoahAsserts::_safe_oop, obj, obj_klass == fwd_klass,
 175              &quot;Forwardee klass pointer must go to metaspace&quot;);
 176 
 177       fwd_reg = _heap-&gt;heap_region_containing(fwd);
 178 
 179       // Verify that forwardee is not in the dead space:
 180       check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
 181              &quot;Should have no humongous forwardees&quot;);
 182 
<span class="line-modified"> 183       HeapWord *fwd_addr = cast_from_oop&lt;HeapWord *&gt;(fwd);</span>
 184       check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
 185              &quot;Forwardee start should be within the region&quot;);
 186       check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
 187              &quot;Forwardee end should be within the region&quot;);
 188 
<span class="line-modified"> 189       oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);</span>
<span class="line-modified"> 190       check(ShenandoahAsserts::_safe_oop, obj, (fwd == fwd2),</span>
 191              &quot;Double forwarding&quot;);
 192     } else {
 193       fwd_reg = obj_reg;
 194     }
 195 
 196     // ------------ obj and fwd are safe at this point --------------
 197 
 198     switch (_options._verify_marked) {
 199       case ShenandoahVerifier::_verify_marked_disable:
 200         // skip
 201         break;
 202       case ShenandoahVerifier::_verify_marked_incomplete:
 203         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;marking_context()-&gt;is_marked(obj),
 204                &quot;Must be marked in incomplete bitmap&quot;);
 205         break;
 206       case ShenandoahVerifier::_verify_marked_complete:
 207         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;complete_marking_context()-&gt;is_marked(obj),
 208                &quot;Must be marked in complete bitmap&quot;);
 209         break;
 210       default:
 211         assert(false, &quot;Unhandled mark verification&quot;);
 212     }
 213 
 214     switch (_options._verify_forwarded) {
 215       case ShenandoahVerifier::_verify_forwarded_disable:
 216         // skip
 217         break;
 218       case ShenandoahVerifier::_verify_forwarded_none: {
<span class="line-modified"> 219         check(ShenandoahAsserts::_safe_all, obj, (obj == fwd),</span>
 220                &quot;Should not be forwarded&quot;);
 221         break;
 222       }
 223       case ShenandoahVerifier::_verify_forwarded_allow: {
<span class="line-modified"> 224         if (obj != fwd) {</span>
 225           check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
 226                  &quot;Forwardee should be in another region&quot;);
 227         }
 228         break;
 229       }
 230       default:
 231         assert(false, &quot;Unhandled forwarding verification&quot;);
 232     }
 233 
 234     switch (_options._verify_cset) {
 235       case ShenandoahVerifier::_verify_cset_disable:
 236         // skip
 237         break;
 238       case ShenandoahVerifier::_verify_cset_none:
 239         check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
 240                &quot;Should not have references to collection set&quot;);
 241         break;
 242       case ShenandoahVerifier::_verify_cset_forwarded:
 243         if (_heap-&gt;in_collection_set(obj)) {
<span class="line-modified"> 244           check(ShenandoahAsserts::_safe_all, obj, (obj != fwd),</span>
 245                  &quot;Object in collection set, should have forwardee&quot;);
 246         }
 247         break;
 248       default:
 249         assert(false, &quot;Unhandled cset verification&quot;);
 250     }
 251 
 252   }
 253 
 254 public:
 255   /**
 256    * Verify object with known interior reference.
 257    * @param p interior reference where the object is referenced from; can be off-heap
 258    * @param obj verified object
 259    */
 260   template &lt;class T&gt;
 261   void verify_oop_at(T* p, oop obj) {
 262     _interior_loc = p;
 263     verify_oop(obj);
 264     _interior_loc = NULL;
</pre>
<hr />
<pre>
 406     verify(r, r-&gt;is_empty() || r-&gt;seqnum_last_alloc() != 0,
 407            &quot;Non-empty regions should have last seqnum set&quot;);
 408 
 409     verify(r, r-&gt;is_empty() || (r-&gt;seqnum_last_alloc_mutator() != 0 || r-&gt;seqnum_last_alloc_gc() != 0),
 410            &quot;Non-empty regions should have last seqnum set to either GC or mutator&quot;);
 411 
 412     verify(r, r-&gt;seqnum_first_alloc() &lt;= r-&gt;seqnum_last_alloc(),
 413            &quot;First seqnum should not be greater than last timestamp&quot;);
 414 
 415     verify(r, r-&gt;seqnum_first_alloc_mutator() &lt;= r-&gt;seqnum_last_alloc_mutator(),
 416            &quot;First mutator seqnum should not be greater than last seqnum&quot;);
 417 
 418     verify(r, r-&gt;seqnum_first_alloc_gc() &lt;= r-&gt;seqnum_last_alloc_gc(),
 419            &quot;First GC seqnum should not be greater than last seqnum&quot;);
 420   }
 421 };
 422 
 423 class ShenandoahVerifierReachableTask : public AbstractGangTask {
 424 private:
 425   const char* _label;
<span class="line-modified"> 426   ShenandoahRootVerifier* _verifier;</span>
 427   ShenandoahVerifier::VerifyOptions _options;
 428   ShenandoahHeap* _heap;
 429   ShenandoahLivenessData* _ld;
 430   MarkBitMap* _bitmap;
 431   volatile size_t _processed;
 432 
 433 public:
 434   ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
 435                                   ShenandoahLivenessData* ld,
<span class="line-modified"> 436                                   ShenandoahRootVerifier* verifier,</span>
 437                                   const char* label,
 438                                   ShenandoahVerifier::VerifyOptions options) :
 439     AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
 440     _label(label),
<span class="line-modified"> 441     _verifier(verifier),</span>
 442     _options(options),
 443     _heap(ShenandoahHeap::heap()),
 444     _ld(ld),
 445     _bitmap(bitmap),
 446     _processed(0) {};
 447 
 448   size_t processed() {
 449     return _processed;
 450   }
 451 
 452   virtual void work(uint worker_id) {
 453     ResourceMark rm;
 454     ShenandoahVerifierStack stack;
 455 
 456     // On level 2, we need to only check the roots once.
 457     // On level 3, we want to check the roots, and seed the local stack.
 458     // It is a lesser evil to accept multiple root scans at level 3, because
 459     // extended parallelism would buy us out.
 460     if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
 461         || (ShenandoahVerifyLevel &gt;= 3)) {
 462         ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 463                                       ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
 464                                       _options);
<span class="line-modified"> 465         if (_heap-&gt;unload_classes()) {</span>
<span class="line-added"> 466           _verifier-&gt;strong_roots_do(&amp;cl);</span>
<span class="line-added"> 467         } else {</span>
<span class="line-added"> 468           _verifier-&gt;roots_do(&amp;cl);</span>
<span class="line-added"> 469         }</span>
 470     }
 471 
 472     size_t processed = 0;
 473 
 474     if (ShenandoahVerifyLevel &gt;= 3) {
 475       ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 476                                     ShenandoahMessageBuffer(&quot;%s, Reachable&quot;, _label),
 477                                     _options);
 478       while (!stack.is_empty()) {
 479         processed++;
 480         ShenandoahVerifierTask task = stack.pop();
 481         cl.verify_oops_from(task.obj());
 482       }
 483     }
 484 
<span class="line-modified"> 485     Atomic::add(&amp;_processed, processed);</span>
 486   }
 487 };
 488 
 489 class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
 490 private:
 491   const char* _label;
 492   ShenandoahVerifier::VerifyOptions _options;
 493   ShenandoahHeap *_heap;
 494   MarkBitMap* _bitmap;
 495   ShenandoahLivenessData* _ld;
 496   volatile size_t _claimed;
 497   volatile size_t _processed;
 498 
 499 public:
 500   ShenandoahVerifierMarkedRegionTask(MarkBitMap* bitmap,
 501                                      ShenandoahLivenessData* ld,
 502                                      const char* label,
 503                                      ShenandoahVerifier::VerifyOptions options) :
 504           AbstractGangTask(&quot;Shenandoah Parallel Verifier Marked Region&quot;),
 505           _label(label),
 506           _options(options),
 507           _heap(ShenandoahHeap::heap()),
 508           _bitmap(bitmap),
 509           _ld(ld),
 510           _claimed(0),
 511           _processed(0) {};
 512 
 513   size_t processed() {
 514     return _processed;
 515   }
 516 
 517   virtual void work(uint worker_id) {
 518     ShenandoahVerifierStack stack;
 519     ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
 520                                   ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
 521                                   _options);
 522 
 523     while (true) {
<span class="line-modified"> 524       size_t v = Atomic::fetch_and_add(&amp;_claimed, 1u);</span>
 525       if (v &lt; _heap-&gt;num_regions()) {
 526         ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
 527         if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
 528           work_regular(r, stack, cl);
 529         } else if (r-&gt;is_humongous_start()) {
 530           work_humongous(r, stack, cl);
 531         }
 532       } else {
 533         break;
 534       }
 535     }
 536   }
 537 
 538   virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
 539     size_t processed = 0;
<span class="line-modified"> 540     HeapWord* obj = r-&gt;bottom();</span>
 541     if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
 542       verify_and_follow(obj, stack, cl, &amp;processed);
 543     }
<span class="line-modified"> 544     Atomic::add(&amp;_processed, processed);</span>
 545   }
 546 
 547   virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
 548     size_t processed = 0;
 549     MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
 550     HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
 551 
 552     // Bitmaps, before TAMS
 553     if (tams &gt; r-&gt;bottom()) {
<span class="line-modified"> 554       HeapWord* start = r-&gt;bottom();</span>
 555       HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
 556 
 557       while (addr &lt; tams) {
 558         verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified"> 559         addr += 1;</span>
 560         if (addr &lt; tams) {
 561           addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
 562         }
 563       }
 564     }
 565 
 566     // Size-based, after TAMS
 567     {
 568       HeapWord* limit = r-&gt;top();
<span class="line-modified"> 569       HeapWord* addr = tams;</span>
 570 
 571       while (addr &lt; limit) {
 572         verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified"> 573         addr += oop(addr)-&gt;size();</span>
 574       }
 575     }
 576 
<span class="line-modified"> 577     Atomic::add(&amp;_processed, processed);</span>
 578   }
 579 
 580   void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
 581     if (!_bitmap-&gt;par_mark(addr)) return;
 582 
 583     // Verify the object itself:
 584     oop obj = oop(addr);
 585     cl.verify_oop_standalone(obj);
 586 
 587     // Verify everything reachable from that object too, hopefully realizing
 588     // everything was already marked, and never touching further:
 589     cl.verify_oops_from(obj);
 590     (*processed)++;
 591 
 592     while (!stack.is_empty()) {
 593       ShenandoahVerifierTask task = stack.pop();
 594       cl.verify_oops_from(task.obj());
 595       (*processed)++;
 596     }
 597   }
 598 };
 599 
 600 class VerifyThreadGCState : public ThreadClosure {
 601 private:
 602   const char* _label;
 603   char _expected;
 604 
 605 public:
 606   VerifyThreadGCState(const char* label, char expected) : _expected(expected) {}
 607   void do_thread(Thread* t) {
 608     char actual = ShenandoahThreadLocalData::gc_state(t);
 609     if (actual != _expected) {
 610       fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
 611     }
 612   }
 613 };
 614 
<span class="line-added"> 615 class ShenandoahGCStateResetter : public StackObj {</span>
<span class="line-added"> 616 private:</span>
<span class="line-added"> 617   ShenandoahHeap* const _heap;</span>
<span class="line-added"> 618   char _gc_state;</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620 public:</span>
<span class="line-added"> 621   ShenandoahGCStateResetter() : _heap(ShenandoahHeap::heap()) {</span>
<span class="line-added"> 622     _gc_state = _heap-&gt;gc_state();</span>
<span class="line-added"> 623     _heap-&gt;_gc_state.clear();</span>
<span class="line-added"> 624   }</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626   ~ShenandoahGCStateResetter() {</span>
<span class="line-added"> 627     _heap-&gt;_gc_state.set(_gc_state);</span>
<span class="line-added"> 628     assert(_heap-&gt;gc_state() == _gc_state, &quot;Should be restored&quot;);</span>
<span class="line-added"> 629   }</span>
<span class="line-added"> 630 };</span>
<span class="line-added"> 631 </span>
 632 void ShenandoahVerifier::verify_at_safepoint(const char *label,
 633                                              VerifyForwarded forwarded, VerifyMarked marked,
 634                                              VerifyCollectionSet cset,
 635                                              VerifyLiveness liveness, VerifyRegions regions,
<span class="line-modified"> 636                                              VerifyGCState gcstate,</span>
<span class="line-added"> 637                                              VerifyWeakRoots weak_roots) {</span>
 638   guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
 639   guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
 640 
 641   // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
 642   ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
 643 
 644   log_info(gc,start)(&quot;Verify %s, Level &quot; INTX_FORMAT, label, ShenandoahVerifyLevel);
 645 
 646   // GC state checks
 647   {
 648     char expected = -1;
 649     bool enabled;
 650     switch (gcstate) {
 651       case _verify_gcstate_disable:
 652         enabled = false;
 653         break;
 654       case _verify_gcstate_forwarded:
 655         enabled = true;
 656         expected = ShenandoahHeap::HAS_FORWARDED;
 657         break;
<span class="line-added"> 658       case _verify_gcstate_evacuation:</span>
<span class="line-added"> 659         enabled = true;</span>
<span class="line-added"> 660         expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION;</span>
<span class="line-added"> 661         break;</span>
 662       case _verify_gcstate_stable:
 663         enabled = true;
 664         expected = ShenandoahHeap::STABLE;
 665         break;
 666       default:
 667         enabled = false;
 668         assert(false, &quot;Unhandled gc-state verification&quot;);
 669     }
 670 
 671     if (enabled) {
 672       char actual = _heap-&gt;gc_state();
 673       if (actual != expected) {
 674         fatal(&quot;%s: Global gc-state: expected %d, actual %d&quot;, label, expected, actual);
 675       }
 676 
 677       VerifyThreadGCState vtgcs(label, expected);
 678       Threads::java_threads_do(&amp;vtgcs);
 679     }
 680   }
 681 
<span class="line-added"> 682   // Deactivate barriers temporarily: Verifier wants plain heap accesses</span>
<span class="line-added"> 683   ShenandoahGCStateResetter resetter;</span>
<span class="line-added"> 684 </span>
 685   // Heap size checks
 686   {
 687     ShenandoahHeapLocker lock(_heap-&gt;lock());
 688 
 689     ShenandoahCalculateRegionStatsClosure cl;
 690     _heap-&gt;heap_region_iterate(&amp;cl);
 691     size_t heap_used = _heap-&gt;used();
 692     guarantee(cl.used() == heap_used,
<span class="line-modified"> 693               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;%s, regions-used = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified"> 694               label,</span>
<span class="line-added"> 695               byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),</span>
<span class="line-added"> 696               byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));</span>
 697 
 698     size_t heap_committed = _heap-&gt;committed();
 699     guarantee(cl.committed() == heap_committed,
<span class="line-modified"> 700               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;%s, regions-committed = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified"> 701               label,</span>
<span class="line-added"> 702               byte_size_in_proper_unit(heap_committed), proper_unit_for_byte_size(heap_committed),</span>
<span class="line-added"> 703               byte_size_in_proper_unit(cl.committed()), proper_unit_for_byte_size(cl.committed()));</span>
 704   }
 705 
 706   // Internal heap region checks
 707   if (ShenandoahVerifyLevel &gt;= 1) {
 708     ShenandoahVerifyHeapRegionClosure cl(label, regions);
 709     _heap-&gt;heap_region_iterate(&amp;cl);
 710   }
 711 
 712   OrderAccess::fence();
 713   _heap-&gt;make_parsable(false);
 714 
 715   // Allocate temporary bitmap for storing marking wavefront:
 716   _verification_bit_map-&gt;clear();
 717 
 718   // Allocate temporary array for storing liveness data
 719   ShenandoahLivenessData* ld = NEW_C_HEAP_ARRAY(ShenandoahLivenessData, _heap-&gt;num_regions(), mtGC);
 720   Copy::fill_to_bytes((void*)ld, _heap-&gt;num_regions()*sizeof(ShenandoahLivenessData), 0);
 721 
 722   const VerifyOptions&amp; options = ShenandoahVerifier::VerifyOptions(forwarded, marked, cset, liveness, regions, gcstate);
 723 
 724   // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
 725   // This verifies what application can see, since it only cares about reachable objects.
 726   size_t count_reachable = 0;
 727   if (ShenandoahVerifyLevel &gt;= 2) {
<span class="line-modified"> 728     ShenandoahRootVerifier verifier;</span>
<span class="line-modified"> 729     switch (weak_roots) {</span>
<span class="line-added"> 730       case _verify_serial_weak_roots:</span>
<span class="line-added"> 731         verifier.excludes(ShenandoahRootVerifier::ConcurrentWeakRoots);</span>
<span class="line-added"> 732         break;</span>
<span class="line-added"> 733       case _verify_concurrent_weak_roots:</span>
<span class="line-added"> 734         verifier.excludes(ShenandoahRootVerifier::SerialWeakRoots);</span>
<span class="line-added"> 735         break;</span>
<span class="line-added"> 736       case _verify_all_weak_roots:</span>
<span class="line-added"> 737         break;</span>
<span class="line-added"> 738       default:</span>
<span class="line-added"> 739         ShouldNotReachHere();</span>
<span class="line-added"> 740     }</span>
 741 
<span class="line-modified"> 742     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;verifier, label, options);</span>
 743     _heap-&gt;workers()-&gt;run_task(&amp;task);
 744     count_reachable = task.processed();
 745   }
 746 
 747   // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
 748   // not the application, can see during the region scans. There is no reason to process the objects
 749   // that were already verified, e.g. those marked in verification bitmap. There is interaction with TAMS:
 750   // before TAMS, we verify the bitmaps, if available; after TAMS, we walk until the top(). It mimics
 751   // what marked_object_iterate is doing, without calling into that optimized (and possibly incorrect)
 752   // version
 753 
 754   size_t count_marked = 0;
 755   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete) {
 756     guarantee(_heap-&gt;marking_context()-&gt;is_complete(), &quot;Marking context should be complete&quot;);
 757     ShenandoahVerifierMarkedRegionTask task(_verification_bit_map, ld, label, options);
 758     _heap-&gt;workers()-&gt;run_task(&amp;task);
 759     count_marked = task.processed();
 760   } else {
 761     guarantee(ShenandoahVerifyLevel &lt; 4 || marked == _verify_marked_incomplete || marked == _verify_marked_disable, &quot;Should be&quot;);
 762   }
 763 
 764   // Step 4. Verify accumulated liveness data, if needed. Only reliable if verification level includes
 765   // marked objects.
 766 
 767   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete &amp;&amp; liveness == _verify_liveness_complete) {
 768     for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
 769       ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
 770 
 771       juint verf_live = 0;
 772       if (r-&gt;is_humongous()) {
 773         // For humongous objects, test if start region is marked live, and if so,
 774         // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<span class="line-modified"> 775         juint start_live = Atomic::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;region_number()]);</span>
 776         if (start_live &gt; 0) {
 777           verf_live = (juint)(r-&gt;used() / HeapWordSize);
 778         }
 779       } else {
<span class="line-modified"> 780         verf_live = Atomic::load_acquire(&amp;ld[r-&gt;region_number()]);</span>
 781       }
 782 
 783       size_t reg_live = r-&gt;get_live_data_words();
 784       if (reg_live != verf_live) {
 785         ResourceMark rm;
 786         stringStream ss;
 787         r-&gt;print_on(&amp;ss);
 788         fatal(&quot;%s: Live data should match: region-live = &quot; SIZE_FORMAT &quot;, verifier-live = &quot; UINT32_FORMAT &quot;\n%s&quot;,
 789               label, reg_live, verf_live, ss.as_string());
 790       }
 791     }
 792   }
 793 
 794   log_info(gc)(&quot;Verify %s, Level &quot; INTX_FORMAT &quot; (&quot; SIZE_FORMAT &quot; reachable, &quot; SIZE_FORMAT &quot; marked)&quot;,
 795                label, ShenandoahVerifyLevel, count_reachable, count_marked);
 796 
 797   FREE_C_HEAP_ARRAY(ShenandoahLivenessData, ld);
 798 }
 799 
 800 void ShenandoahVerifier::verify_generic(VerifyOption vo) {
 801   verify_at_safepoint(
 802           &quot;Generic Verification&quot;,
 803           _verify_forwarded_allow,     // conservatively allow forwarded
 804           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 805           _verify_cset_disable,        // cset may be inconsistent
 806           _verify_liveness_disable,    // no reliable liveness data
 807           _verify_regions_disable,     // no reliable region data
<span class="line-modified"> 808           _verify_gcstate_disable,     // no data about gcstate</span>
<span class="line-added"> 809           _verify_all_weak_roots</span>
 810   );
 811 }
 812 
 813 void ShenandoahVerifier::verify_before_concmark() {
 814   if (_heap-&gt;has_forwarded_objects()) {
 815     verify_at_safepoint(
 816             &quot;Before Mark&quot;,
 817             _verify_forwarded_allow,     // may have forwarded references
 818             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 819             _verify_cset_forwarded,      // allow forwarded references to cset
 820             _verify_liveness_disable,    // no reliable liveness data
 821             _verify_regions_notrash,     // no trash regions
<span class="line-modified"> 822             _verify_gcstate_forwarded,   // there are forwarded objects</span>
<span class="line-added"> 823             _verify_all_weak_roots</span>
 824     );
 825   } else {
 826     verify_at_safepoint(
 827             &quot;Before Mark&quot;,
 828             _verify_forwarded_none,      // UR should have fixed up
 829             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 830             _verify_cset_none,           // UR should have fixed this
 831             _verify_liveness_disable,    // no reliable liveness data
 832             _verify_regions_notrash,     // no trash regions
<span class="line-modified"> 833             _verify_gcstate_stable,      // there are no forwarded objects</span>
<span class="line-added"> 834             _verify_all_weak_roots</span>
 835     );
 836   }
 837 }
 838 
 839 void ShenandoahVerifier::verify_after_concmark() {
 840   verify_at_safepoint(
 841           &quot;After Mark&quot;,
 842           _verify_forwarded_none,      // no forwarded references
 843           _verify_marked_complete,     // bitmaps as precise as we can get
 844           _verify_cset_none,           // no references to cset anymore
 845           _verify_liveness_complete,   // liveness data must be complete here
 846           _verify_regions_disable,     // trash regions not yet recycled
<span class="line-modified"> 847           _verify_gcstate_stable,       // mark should have stabilized the heap</span>
<span class="line-added"> 848           _verify_all_weak_roots</span>
 849   );
 850 }
 851 
 852 void ShenandoahVerifier::verify_before_evacuation() {
<span class="line-added"> 853   // Concurrent weak roots are evacuated during concurrent phase</span>
<span class="line-added"> 854   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?</span>
<span class="line-added"> 855                                       _verify_serial_weak_roots :</span>
<span class="line-added"> 856                                       _verify_all_weak_roots;</span>
<span class="line-added"> 857 </span>
 858   verify_at_safepoint(
 859           &quot;Before Evacuation&quot;,
 860           _verify_forwarded_none,    // no forwarded references
 861           _verify_marked_complete,   // walk over marked objects too
 862           _verify_cset_disable,      // non-forwarded references to cset expected
 863           _verify_liveness_complete, // liveness data must be complete here
 864           _verify_regions_disable,   // trash regions not yet recycled
<span class="line-modified"> 865           _verify_gcstate_stable,    // mark should have stabilized the heap</span>
<span class="line-added"> 866           verify_weak_roots</span>
<span class="line-added"> 867   );</span>
<span class="line-added"> 868 }</span>
<span class="line-added"> 869 </span>
<span class="line-added"> 870 void ShenandoahVerifier::verify_during_evacuation() {</span>
<span class="line-added"> 871   // Concurrent weak roots are evacuated during concurrent phase</span>
<span class="line-added"> 872   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?</span>
<span class="line-added"> 873                                       _verify_serial_weak_roots :</span>
<span class="line-added"> 874                                       _verify_all_weak_roots;</span>
<span class="line-added"> 875 </span>
<span class="line-added"> 876   verify_at_safepoint(</span>
<span class="line-added"> 877           &quot;During Evacuation&quot;,</span>
<span class="line-added"> 878           _verify_forwarded_allow,    // some forwarded references are allowed</span>
<span class="line-added"> 879           _verify_marked_disable,     // walk only roots</span>
<span class="line-added"> 880           _verify_cset_disable,       // some cset references are not forwarded yet</span>
<span class="line-added"> 881           _verify_liveness_disable,   // liveness data might be already stale after pre-evacs</span>
<span class="line-added"> 882           _verify_regions_disable,    // trash regions not yet recycled</span>
<span class="line-added"> 883           _verify_gcstate_evacuation, // evacuation is in progress</span>
<span class="line-added"> 884           verify_weak_roots</span>
 885   );
 886 }
 887 
 888 void ShenandoahVerifier::verify_after_evacuation() {
 889   verify_at_safepoint(
 890           &quot;After Evacuation&quot;,
 891           _verify_forwarded_allow,     // objects are still forwarded
 892           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 893           _verify_cset_forwarded,      // all cset refs are fully forwarded
 894           _verify_liveness_disable,    // no reliable liveness data anymore
 895           _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified"> 896           _verify_gcstate_forwarded,   // evacuation produced some forwarded objects</span>
<span class="line-added"> 897           _verify_all_weak_roots</span>
 898   );
 899 }
 900 
 901 void ShenandoahVerifier::verify_before_updaterefs() {
 902   verify_at_safepoint(
 903           &quot;Before Updating References&quot;,
 904           _verify_forwarded_allow,     // forwarded references allowed
 905           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 906           _verify_cset_forwarded,      // all cset refs are fully forwarded
 907           _verify_liveness_disable,    // no reliable liveness data anymore
 908           _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified"> 909           _verify_gcstate_forwarded,   // evacuation should have produced some forwarded objects</span>
<span class="line-added"> 910           _verify_all_weak_roots</span>
 911   );
 912 }
 913 
 914 void ShenandoahVerifier::verify_after_updaterefs() {
 915   verify_at_safepoint(
 916           &quot;After Updating References&quot;,
 917           _verify_forwarded_none,      // no forwarded references
 918           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
 919           _verify_cset_none,           // no cset references, all updated
 920           _verify_liveness_disable,    // no reliable liveness data anymore
 921           _verify_regions_nocset,      // no cset regions, trash regions have appeared
<span class="line-modified"> 922           _verify_gcstate_stable,      // update refs had cleaned up forwarded objects</span>
<span class="line-added"> 923           _verify_all_weak_roots</span>
 924   );
 925 }
 926 
 927 void ShenandoahVerifier::verify_after_degenerated() {
 928   verify_at_safepoint(
 929           &quot;After Degenerated GC&quot;,
 930           _verify_forwarded_none,      // all objects are non-forwarded
 931           _verify_marked_complete,     // all objects are marked in complete bitmap
 932           _verify_cset_none,           // no cset references
 933           _verify_liveness_disable,    // no reliable liveness data anymore
 934           _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified"> 935           _verify_gcstate_stable,       // degenerated refs had cleaned up forwarded objects</span>
<span class="line-added"> 936           _verify_all_weak_roots</span>
 937   );
 938 }
 939 
 940 void ShenandoahVerifier::verify_before_traversal() {
 941   verify_at_safepoint(
 942           &quot;Before Traversal&quot;,
 943           _verify_forwarded_none,      // cannot have forwarded objects
 944           _verify_marked_disable,      // bitmaps are not relevant before traversal
 945           _verify_cset_none,           // no cset references before traversal
 946           _verify_liveness_disable,    // no reliable liveness data anymore
 947           _verify_regions_notrash_nocset, // no trash and no cset regions
<span class="line-modified"> 948           _verify_gcstate_stable,      // nothing forwarded before traversal</span>
<span class="line-added"> 949           _verify_all_weak_roots</span>
 950   );
 951 }
 952 
 953 void ShenandoahVerifier::verify_after_traversal() {
 954   verify_at_safepoint(
 955           &quot;After Traversal&quot;,
 956           _verify_forwarded_none,      // cannot have forwarded objects
 957           _verify_marked_complete,     // should have complete marking after traversal
 958           _verify_cset_none,           // no cset references left after traversal
 959           _verify_liveness_disable,    // liveness data is not collected for new allocations
 960           _verify_regions_nocset,      // no cset regions, trash regions allowed
<span class="line-modified"> 961           _verify_gcstate_stable,      // nothing forwarded after traversal</span>
<span class="line-added"> 962           _verify_all_weak_roots</span>
 963   );
 964 }
 965 
 966 void ShenandoahVerifier::verify_before_fullgc() {
 967   verify_at_safepoint(
 968           &quot;Before Full GC&quot;,
 969           _verify_forwarded_allow,     // can have forwarded objects
 970           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
 971           _verify_cset_disable,        // cset might be foobared
 972           _verify_liveness_disable,    // no reliable liveness data anymore
 973           _verify_regions_disable,     // no reliable region data here
<span class="line-modified"> 974           _verify_gcstate_disable,     // no reliable gcstate data</span>
<span class="line-added"> 975           _verify_all_weak_roots</span>
 976   );
 977 }
 978 
 979 void ShenandoahVerifier::verify_after_fullgc() {
 980   verify_at_safepoint(
 981           &quot;After Full GC&quot;,
 982           _verify_forwarded_none,      // all objects are non-forwarded
 983           _verify_marked_complete,     // all objects are marked in complete bitmap
 984           _verify_cset_none,           // no cset references
 985           _verify_liveness_disable,    // no reliable liveness data anymore
 986           _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified"> 987           _verify_gcstate_stable,       // full gc cleaned up everything</span>
<span class="line-added"> 988           _verify_all_weak_roots</span>
 989   );
 990 }
<span class="line-added"> 991 </span>
<span class="line-added"> 992 class ShenandoahVerifyNoForwared : public OopClosure {</span>
<span class="line-added"> 993 private:</span>
<span class="line-added"> 994   template &lt;class T&gt;</span>
<span class="line-added"> 995   void do_oop_work(T* p) {</span>
<span class="line-added"> 996     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added"> 997     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added"> 998       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added"> 999       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">1000       if (obj != fwd) {</span>
<span class="line-added">1001         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">1002                                          &quot;Verify Roots&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);</span>
<span class="line-added">1003       }</span>
<span class="line-added">1004     }</span>
<span class="line-added">1005   }</span>
<span class="line-added">1006 </span>
<span class="line-added">1007 public:</span>
<span class="line-added">1008   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added">1009   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added">1010 };</span>
<span class="line-added">1011 </span>
<span class="line-added">1012 class ShenandoahVerifyInToSpaceClosure : public OopClosure {</span>
<span class="line-added">1013 private:</span>
<span class="line-added">1014   template &lt;class T&gt;</span>
<span class="line-added">1015   void do_oop_work(T* p) {</span>
<span class="line-added">1016     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">1017     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">1018       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">1019       ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
<span class="line-added">1020 </span>
<span class="line-added">1021       if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {</span>
<span class="line-added">1022         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">1023                 &quot;Verify Roots In To-Space&quot;, &quot;Should be marked&quot;, __FILE__, __LINE__);</span>
<span class="line-added">1024       }</span>
<span class="line-added">1025 </span>
<span class="line-added">1026       if (heap-&gt;in_collection_set(obj)) {</span>
<span class="line-added">1027         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">1028                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be in collection set&quot;, __FILE__, __LINE__);</span>
<span class="line-added">1029       }</span>
<span class="line-added">1030 </span>
<span class="line-added">1031       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">1032       if (obj != fwd) {</span>
<span class="line-added">1033         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">1034                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);</span>
<span class="line-added">1035       }</span>
<span class="line-added">1036     }</span>
<span class="line-added">1037   }</span>
<span class="line-added">1038 </span>
<span class="line-added">1039 public:</span>
<span class="line-added">1040   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added">1041   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added">1042 };</span>
<span class="line-added">1043 </span>
<span class="line-added">1044 void ShenandoahVerifier::verify_roots_in_to_space() {</span>
<span class="line-added">1045   ShenandoahRootVerifier verifier;</span>
<span class="line-added">1046   ShenandoahVerifyInToSpaceClosure cl;</span>
<span class="line-added">1047   verifier.oops_do(&amp;cl);</span>
<span class="line-added">1048 }</span>
<span class="line-added">1049 </span>
<span class="line-added">1050 void ShenandoahVerifier::verify_roots_in_to_space_except(ShenandoahRootVerifier::RootTypes types) {</span>
<span class="line-added">1051   ShenandoahRootVerifier verifier;</span>
<span class="line-added">1052   verifier.excludes(types);</span>
<span class="line-added">1053   ShenandoahVerifyInToSpaceClosure cl;</span>
<span class="line-added">1054   verifier.oops_do(&amp;cl);</span>
<span class="line-added">1055 }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057 void ShenandoahVerifier::verify_roots_no_forwarded() {</span>
<span class="line-added">1058   ShenandoahRootVerifier verifier;</span>
<span class="line-added">1059   ShenandoahVerifyNoForwared cl;</span>
<span class="line-added">1060   verifier.oops_do(&amp;cl);</span>
<span class="line-added">1061 }</span>
<span class="line-added">1062 </span>
<span class="line-added">1063 void ShenandoahVerifier::verify_roots_no_forwarded_except(ShenandoahRootVerifier::RootTypes types) {</span>
<span class="line-added">1064   ShenandoahRootVerifier verifier;</span>
<span class="line-added">1065   verifier.excludes(types);</span>
<span class="line-added">1066   ShenandoahVerifyNoForwared cl;</span>
<span class="line-added">1067   verifier.oops_do(&amp;cl);</span>
<span class="line-added">1068 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahVMOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahVerifier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
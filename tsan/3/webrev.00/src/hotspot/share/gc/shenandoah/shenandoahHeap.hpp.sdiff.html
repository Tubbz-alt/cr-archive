<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 
 27 #include &quot;gc/shared/markBitMap.hpp&quot;
 28 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
<span class="line-modified"> 32 #include &quot;gc/shenandoah/shenandoahHeapLock.hpp&quot;</span>
 33 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;

 35 #include &quot;services/memoryManager.hpp&quot;

 36 
 37 class ConcurrentGCTimer;
 38 class ReferenceProcessor;
 39 class ShenandoahAllocTracker;
 40 class ShenandoahCollectorPolicy;
 41 class ShenandoahControlThread;
 42 class ShenandoahGCSession;

 43 class ShenandoahHeuristics;
 44 class ShenandoahMarkingContext;


 45 class ShenandoahPhaseTimings;
 46 class ShenandoahHeap;
 47 class ShenandoahHeapRegion;
 48 class ShenandoahHeapRegionClosure;
 49 class ShenandoahCollectionSet;
 50 class ShenandoahFreeSet;
 51 class ShenandoahConcurrentMark;
 52 class ShenandoahMarkCompact;
 53 class ShenandoahMonitoringSupport;
 54 class ShenandoahPacer;
 55 class ShenandoahTraversalGC;
 56 class ShenandoahVerifier;
 57 class ShenandoahWorkGang;
 58 class VMStructs;
 59 
 60 class ShenandoahRegionIterator : public StackObj {
 61 private:
 62   ShenandoahHeap* _heap;
 63 
 64   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
 65   volatile size_t _index;
 66   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
 67 
 68   // No implicit copying: iterators should be passed by reference to capture the state
<span class="line-modified"> 69   ShenandoahRegionIterator(const ShenandoahRegionIterator&amp; that);</span>
<span class="line-removed"> 70   ShenandoahRegionIterator&amp; operator=(const ShenandoahRegionIterator&amp; o);</span>
 71 
 72 public:
 73   ShenandoahRegionIterator();
 74   ShenandoahRegionIterator(ShenandoahHeap* heap);
 75 
 76   // Reset iterator to default state
 77   void reset();
 78 
 79   // Returns next region, or NULL if there are no more regions.
 80   // This is multi-thread-safe.
 81   inline ShenandoahHeapRegion* next();
 82 
 83   // This is *not* MT safe. However, in the absence of multithreaded access, it
 84   // can be used to determine if there is more work to do.
 85   bool has_next() const;
 86 };
 87 
 88 class ShenandoahHeapRegionClosure : public StackObj {
 89 public:
 90   virtual void heap_region_do(ShenandoahHeapRegion* r) = 0;
 91   virtual bool is_thread_safe() { return false; }
 92 };
 93 
<span class="line-removed"> 94 class ShenandoahUpdateRefsClosure: public OopClosure {</span>
<span class="line-removed"> 95 private:</span>
<span class="line-removed"> 96   ShenandoahHeap* _heap;</span>
<span class="line-removed"> 97 </span>
<span class="line-removed"> 98   template &lt;class T&gt;</span>
<span class="line-removed"> 99   inline void do_oop_work(T* p);</span>
<span class="line-removed">100 </span>
<span class="line-removed">101 public:</span>
<span class="line-removed">102   ShenandoahUpdateRefsClosure();</span>
<span class="line-removed">103   inline void do_oop(oop* p);</span>
<span class="line-removed">104   inline void do_oop(narrowOop* p);</span>
<span class="line-removed">105 };</span>
<span class="line-removed">106 </span>
107 #ifdef ASSERT
108 class ShenandoahAssertToSpaceClosure : public OopClosure {
109 private:
110   template &lt;class T&gt;
111   void do_oop_work(T* p);
112 public:
113   void do_oop(narrowOop* p);
114   void do_oop(oop* p);
115 };
116 #endif
117 
<span class="line-modified">118 class ShenandoahAlwaysTrueClosure : public BoolObjectClosure {</span>
<span class="line-modified">119 public:</span>
<span class="line-removed">120   bool do_object_b(oop p) { return true; }</span>
<span class="line-removed">121 };</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 class ShenandoahForwardedIsAliveClosure: public BoolObjectClosure {</span>
<span class="line-removed">124 private:</span>
<span class="line-removed">125   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">126 public:</span>
<span class="line-removed">127   ShenandoahForwardedIsAliveClosure();</span>
<span class="line-removed">128   bool do_object_b(oop obj);</span>
<span class="line-removed">129 };</span>
<span class="line-removed">130 </span>
<span class="line-removed">131 class ShenandoahIsAliveClosure: public BoolObjectClosure {</span>
<span class="line-removed">132 private:</span>
<span class="line-removed">133   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">134 public:</span>
<span class="line-removed">135   ShenandoahIsAliveClosure();</span>
<span class="line-removed">136   bool do_object_b(oop obj);</span>
<span class="line-removed">137 };</span>
<span class="line-removed">138 </span>
<span class="line-removed">139 class ShenandoahIsAliveSelector : public StackObj {</span>
<span class="line-removed">140 private:</span>
<span class="line-removed">141   ShenandoahIsAliveClosure _alive_cl;</span>
<span class="line-removed">142   ShenandoahForwardedIsAliveClosure _fwd_alive_cl;</span>
<span class="line-removed">143 public:</span>
<span class="line-removed">144   BoolObjectClosure* is_alive_closure();</span>
<span class="line-removed">145 };</span>
146 
147 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
148 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
149 // See ShenandoahControlThread for GC cycle structure.
150 //
151 class ShenandoahHeap : public CollectedHeap {
152   friend class ShenandoahAsserts;
153   friend class VMStructs;
154   friend class ShenandoahGCSession;

155 
156 // ---------- Locks that guard important data structures in Heap
157 //
158 private:
159   ShenandoahHeapLock _lock;
160 
161 public:
162   ShenandoahHeapLock* lock() {
163     return &amp;_lock;
164   }
165 
166   void assert_heaplock_owned_by_current_thread()     NOT_DEBUG_RETURN;
167   void assert_heaplock_not_owned_by_current_thread() NOT_DEBUG_RETURN;
168   void assert_heaplock_or_safepoint()                NOT_DEBUG_RETURN;
169 
170 // ---------- Initialization, termination, identification, printing routines
171 //
172 public:
173   static ShenandoahHeap* heap();
174   static ShenandoahHeap* heap_no_check();
</pre>
<hr />
<pre>
181   void post_initialize();
182   void initialize_heuristics();
183 
184   void initialize_serviceability();
185 
186   void print_on(outputStream* st)              const;
187   void print_extended_on(outputStream *st)     const;
188   void print_tracing_info()                    const;
189   void print_gc_threads_on(outputStream* st)   const;
190   void print_heap_regions_on(outputStream* st) const;
191 
192   void stop();
193 
194   void prepare_for_verify();
195   void verify(VerifyOption vo);
196 
197 // ---------- Heap counters and metrics
198 //
199 private:
200            size_t _initial_size;

201   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
202   volatile size_t _used;
203   volatile size_t _committed;
204   volatile size_t _bytes_allocated_since_gc_start;
205   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
206 
207 public:
208   void increase_used(size_t bytes);
209   void decrease_used(size_t bytes);
210   void set_used(size_t bytes);
211 
212   void increase_committed(size_t bytes);
213   void decrease_committed(size_t bytes);
214   void increase_allocated(size_t bytes);
215 
216   size_t bytes_allocated_since_gc_start();
217   void reset_bytes_allocated_since_gc_start();
218 

219   size_t max_capacity()     const;
220   size_t initial_capacity() const;
221   size_t capacity()         const;
222   size_t used()             const;
223   size_t committed()        const;
224 
225 // ---------- Workers handling
226 //
227 private:
228   uint _max_workers;
229   ShenandoahWorkGang* _workers;
230   ShenandoahWorkGang* _safepoint_workers;
231 
232 public:
233   uint max_workers();
234   void assert_gc_workers(uint nworker) NOT_DEBUG_RETURN;
235 
236   WorkGang* workers() const;
237   WorkGang* get_safepoint_workers();
238 
239   void gc_threads_do(ThreadClosure* tcl) const;
240 
241 // ---------- Heap regions handling machinery
242 //
243 private:
244   MemRegion _heap_region;
245   bool      _heap_region_special;
246   size_t    _num_regions;
247   ShenandoahHeapRegion** _regions;
248   ShenandoahRegionIterator _update_refs_iterator;
249 
250 public:



251   inline size_t num_regions() const { return _num_regions; }
252   inline bool is_heap_region_special() { return _heap_region_special; }
253 
254   inline ShenandoahHeapRegion* const heap_region_containing(const void* addr) const;
255   inline size_t heap_region_index_containing(const void* addr) const;
256 
257   inline ShenandoahHeapRegion* const get_region(size_t region_idx) const;
258 
259   void heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
260   void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
261 
262 // ---------- GC state machinery
263 //
264 // GC state describes the important parts of collector state, that may be
265 // used to make barrier selection decisions in the native and generated code.
266 // Multiple bits can be set at once.
267 //
268 // Important invariant: when GC state is zero, the heap is stable, and no barriers
269 // are required.
270 //
271 public:
272   enum GCStateBitPos {
<span class="line-modified">273     // Heap has forwarded objects: need RB, ACMP, CAS barriers.</span>
274     HAS_FORWARDED_BITPOS   = 0,
275 
276     // Heap is under marking: needs SATB barriers.
277     MARKING_BITPOS    = 1,
278 
<span class="line-modified">279     // Heap is under evacuation: needs WB barriers. (Set together with UNSTABLE)</span>
280     EVACUATION_BITPOS = 2,
281 
<span class="line-modified">282     // Heap is under updating: needs SVRB/SVWB barriers.</span>
283     UPDATEREFS_BITPOS = 3,
284 
285     // Heap is under traversal collection
<span class="line-modified">286     TRAVERSAL_BITPOS  = 4,</span>
287   };
288 
289   enum GCState {
290     STABLE        = 0,
291     HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
292     MARKING       = 1 &lt;&lt; MARKING_BITPOS,
293     EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
294     UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
<span class="line-modified">295     TRAVERSAL     = 1 &lt;&lt; TRAVERSAL_BITPOS,</span>
296   };
297 
298 private:
299   ShenandoahSharedBitmap _gc_state;
300   ShenandoahSharedFlag   _degenerated_gc_in_progress;
301   ShenandoahSharedFlag   _full_gc_in_progress;
302   ShenandoahSharedFlag   _full_gc_move_in_progress;
303   ShenandoahSharedFlag   _progress_last_gc;

304 
305   void set_gc_state_all_threads(char state);
306   void set_gc_state_mask(uint mask, bool value);
307 
308 public:
309   char gc_state() const;
310   static address gc_state_addr();
311 
312   void set_concurrent_mark_in_progress(bool in_progress);
313   void set_evacuation_in_progress(bool in_progress);
314   void set_update_refs_in_progress(bool in_progress);
315   void set_degenerated_gc_in_progress(bool in_progress);
316   void set_full_gc_in_progress(bool in_progress);
317   void set_full_gc_move_in_progress(bool in_progress);
318   void set_concurrent_traversal_in_progress(bool in_progress);
319   void set_has_forwarded_objects(bool cond);

320 
321   inline bool is_stable() const;
322   inline bool is_idle() const;
323   inline bool is_concurrent_mark_in_progress() const;
324   inline bool is_update_refs_in_progress() const;
325   inline bool is_evacuation_in_progress() const;
326   inline bool is_degenerated_gc_in_progress() const;
327   inline bool is_full_gc_in_progress() const;
328   inline bool is_full_gc_move_in_progress() const;
329   inline bool is_concurrent_traversal_in_progress() const;
330   inline bool has_forwarded_objects() const;
331   inline bool is_gc_in_progress_mask(uint mask) const;


332 
333 // ---------- GC cancellation and degeneration machinery
334 //
335 // Cancelled GC flag is used to notify concurrent phases that they should terminate.
336 //
337 public:
338   enum ShenandoahDegenPoint {
339     _degenerated_unset,
340     _degenerated_traversal,
341     _degenerated_outside_cycle,
342     _degenerated_mark,
343     _degenerated_evac,
344     _degenerated_updaterefs,
<span class="line-modified">345     _DEGENERATED_LIMIT,</span>
346   };
347 
348   static const char* degen_point_to_string(ShenandoahDegenPoint point) {
349     switch (point) {
350       case _degenerated_unset:
351         return &quot;&lt;UNSET&gt;&quot;;
352       case _degenerated_traversal:
353         return &quot;Traversal&quot;;
354       case _degenerated_outside_cycle:
355         return &quot;Outside of Cycle&quot;;
356       case _degenerated_mark:
357         return &quot;Mark&quot;;
358       case _degenerated_evac:
359         return &quot;Evacuation&quot;;
360       case _degenerated_updaterefs:
361         return &quot;Update Refs&quot;;
362       default:
363         ShouldNotReachHere();
364         return &quot;ERROR&quot;;
365     }
</pre>
<hr />
<pre>
409   void vmop_entry_full(GCCause::Cause cause);
410   void vmop_degenerated(ShenandoahDegenPoint point);
411 
412   // Entry methods to normally STW GC operations. These set up logging, monitoring
413   // and workers for net VM operation
414   void entry_init_mark();
415   void entry_final_mark();
416   void entry_final_evac();
417   void entry_init_updaterefs();
418   void entry_final_updaterefs();
419   void entry_init_traversal();
420   void entry_final_traversal();
421   void entry_full(GCCause::Cause cause);
422   void entry_degenerated(int point);
423 
424   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
425   // for concurrent operation.
426   void entry_reset();
427   void entry_mark();
428   void entry_preclean();

429   void entry_cleanup();
430   void entry_evac();
431   void entry_updaterefs();
432   void entry_traversal();
433   void entry_uncommit(double shrink_before);
434 
435 private:
436   // Actual work for the phases
437   void op_init_mark();
438   void op_final_mark();
439   void op_final_evac();
440   void op_init_updaterefs();
441   void op_final_updaterefs();
442   void op_init_traversal();
443   void op_final_traversal();
444   void op_full(GCCause::Cause cause);
445   void op_degenerated(ShenandoahDegenPoint point);
446   void op_degenerated_fail();
447   void op_degenerated_futile();
448 
449   void op_reset();
450   void op_mark();
451   void op_preclean();

452   void op_cleanup();
453   void op_conc_evac();
454   void op_stw_evac();
455   void op_updaterefs();
456   void op_traversal();
457   void op_uncommit(double shrink_before);
458 
459   // Messages for GC trace events, they have to be immortal for
460   // passing around the logging/tracing systems
461   const char* init_mark_event_message() const;
462   const char* final_mark_event_message() const;
463   const char* conc_mark_event_message() const;



464   const char* degen_event_message(ShenandoahDegenPoint point) const;
465 
466 // ---------- GC subsystems
467 //
468 private:
469   ShenandoahControlThread*   _control_thread;
470   ShenandoahCollectorPolicy* _shenandoah_policy;

471   ShenandoahHeuristics*      _heuristics;
472   ShenandoahFreeSet*         _free_set;
473   ShenandoahConcurrentMark*  _scm;
474   ShenandoahTraversalGC*     _traversal_gc;
475   ShenandoahMarkCompact*     _full_gc;
476   ShenandoahPacer*           _pacer;
477   ShenandoahVerifier*        _verifier;
478 
479   ShenandoahAllocTracker*    _alloc_tracker;
480   ShenandoahPhaseTimings*    _phase_timings;
481 
482   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
483   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
484 
485 public:
486   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
487   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
488   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
489   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
<span class="line-modified">490   ShenandoahTraversalGC*     traversal_gc()            { return _traversal_gc;      }</span>

491   ShenandoahPacer*           pacer()             const { return _pacer;             }
492 
493   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
494   ShenandoahAllocTracker*    alloc_tracker()     const { return _alloc_tracker;     }
495 
496   ShenandoahVerifier*        verifier();
497 
498 // ---------- VM subsystem bindings
499 //
500 private:
501   ShenandoahMonitoringSupport* _monitoring_support;
502   MemoryPool*                  _memory_pool;
503   GCMemoryManager              _stw_memory_manager;
504   GCMemoryManager              _cycle_memory_manager;
505   ConcurrentGCTimer*           _gc_timer;
506   SoftRefPolicy                _soft_ref_policy;
507 


508 public:
509   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
510   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
511   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
512   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
513 
514   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
515   GrowableArray&lt;MemoryPool*&gt; memory_pools();
516   MemoryUsage memory_usage();
517   GCTracer* tracer();
518   GCTimer* gc_timer() const;
<span class="line-removed">519   CollectorPolicy* collector_policy() const;</span>
520 
521 // ---------- Reference processing
522 //
523 private:
524   AlwaysTrueClosure    _subject_to_discovery;
525   ReferenceProcessor*  _ref_processor;
526   ShenandoahSharedFlag _process_references;
527 
528   void ref_processing_init();
529 
530 public:
531   ReferenceProcessor* ref_processor() { return _ref_processor; }
532   void set_process_references(bool pr);
533   bool process_references() const;
534 
535 // ---------- Class Unloading
536 //
537 private:
538   ShenandoahSharedFlag _unload_classes;

539 
540 public:
541   void set_unload_classes(bool uc);
542   bool unload_classes() const;
543 
<span class="line-modified">544   // Delete entries for dead interned string and clean up unreferenced symbols</span>
<span class="line-modified">545   // in symbol table, possibly in parallel.</span>
<span class="line-modified">546   void unload_classes_and_cleanup_tables(bool full_gc);</span>









547 
548 // ---------- Generic interface hooks
549 // Minor things that super-interface expects us to implement to play nice with
550 // the rest of runtime. Some of the things here are not required to be implemented,
551 // and can be stubbed out.
552 //
553 public:
554   AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);
555   bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);
556 
557   bool is_in(const void* p) const;
558 
<span class="line-modified">559   size_t obj_size(oop obj) const;</span>
<span class="line-modified">560   virtual ptrdiff_t cell_header_size() const;</span>
561 
562   void collect(GCCause::Cause cause);
563   void do_full_collection(bool clear_all_soft_refs);
564 
565   // Used for parsing heap during error printing
566   HeapWord* block_start(const void* addr) const;
567   bool block_is_obj(const HeapWord* addr) const;

568 
569   // Used for native heap walkers: heap dumpers, mostly
570   void object_iterate(ObjectClosure* cl);
<span class="line-modified">571   void safe_object_iterate(ObjectClosure* cl);</span>


572 
573   // Used by RMI
574   jlong millis_since_last_gc();
575 
576 // ---------- Safepoint interface hooks
577 //
578 public:
579   void safepoint_synchronize_begin();
580   void safepoint_synchronize_end();
581 
582 // ---------- Code roots handling hooks
583 //
584 public:
585   void register_nmethod(nmethod* nm);
586   void unregister_nmethod(nmethod* nm);


587 
588 // ---------- Pinning hooks
589 //
590 public:
591   // Shenandoah supports per-object (per-region) pinning
592   bool supports_object_pinning() const { return true; }
593 
594   oop pin_object(JavaThread* thread, oop obj);
595   void unpin_object(JavaThread* thread, oop obj);
596 



597 // ---------- Allocation support
598 //
599 private:
600   HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest&amp; request, bool&amp; in_new_region);
601   inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);
602   HeapWord* allocate_from_gclab_slow(Thread* thread, size_t size);
603   HeapWord* allocate_new_gclab(size_t min_size, size_t word_size, size_t* actual_size);
604   void retire_and_reset_gclabs();
605 
606 public:
607   HeapWord* allocate_memory(ShenandoahAllocRequest&amp; request);
608   HeapWord* mem_allocate(size_t size, bool* what);
609   MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
610                                                size_t size,
611                                                Metaspace::MetadataType mdtype);
612 
<span class="line-removed">613   oop obj_allocate(Klass* klass, int size, TRAPS);</span>
<span class="line-removed">614   oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);</span>
<span class="line-removed">615   oop class_allocate(Klass* klass, int size, TRAPS);</span>
<span class="line-removed">616 </span>
617   void notify_mutator_alloc_words(size_t words, bool waste);
618 
619   // Shenandoah supports TLAB allocation
620   bool supports_tlab_allocation() const { return true; }
621 
622   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
623   size_t tlab_capacity(Thread *thr) const;
624   size_t unsafe_max_tlab_alloc(Thread *thread) const;
625   size_t max_tlab_size() const;
626   size_t tlab_used(Thread* ignored) const;
627 
<span class="line-removed">628   HeapWord* tlab_post_allocation_setup(HeapWord* obj);</span>
<span class="line-removed">629   void fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap);</span>
<span class="line-removed">630   size_t min_dummy_object_size() const;</span>
<span class="line-removed">631 </span>
632   void resize_tlabs();
633 
634   void ensure_parsability(bool retire_tlabs);
635   void make_parsable(bool retire_tlabs);
636 
637 // ---------- Marking support
638 //
639 private:
640   ShenandoahMarkingContext* _marking_context;
641   MemRegion  _bitmap_region;
642   MemRegion  _aux_bitmap_region;
643   MarkBitMap _verification_bit_map;
644   MarkBitMap _aux_bit_map;
645 
646   size_t _bitmap_size;
647   size_t _bitmap_regions_per_slice;
648   size_t _bitmap_bytes_per_slice;
649 
650   bool _bitmap_region_special;
651   bool _aux_bitmap_region_special;
</pre>
<hr />
<pre>
687   bool uncommit_bitmap_slice(ShenandoahHeapRegion *r);
688   bool is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self = false);
689 
690   // Liveness caching support
691   jushort* get_liveness_cache(uint worker_id);
692   void flush_liveness_cache(uint worker_id);
693 
694 // ---------- Evacuation support
695 //
696 private:
697   ShenandoahCollectionSet* _collection_set;
698   ShenandoahEvacOOMHandler _oom_evac_handler;
699 
700   void evacuate_and_update_roots();
701 
702 public:
703   static address in_cset_fast_test_addr();
704 
705   ShenandoahCollectionSet* collection_set() const { return _collection_set; }
706 
<span class="line-modified">707   template &lt;class T&gt;</span>
<span class="line-modified">708   inline bool in_collection_set(T obj) const;</span>
709 
<span class="line-modified">710   // Avoid accidentally calling the method above with ShenandoahHeapRegion*, which would be *wrong*.</span>
<span class="line-modified">711   inline bool in_collection_set(ShenandoahHeapRegion* r) shenandoah_not_implemented_return(false);</span>
712 
713   // Evacuates object src. Returns the evacuated object, either evacuated
714   // by this thread, or by some other thread.
715   inline oop evacuate_object(oop src, Thread* thread);
716 
717   // Call before/after evacuation.
718   void enter_evacuation();
719   void leave_evacuation();
720 
721 // ---------- Helper functions
722 //
723 public:
724   template &lt;class T&gt;
725   inline oop evac_update_with_forwarded(T* p);
726 
727   template &lt;class T&gt;
728   inline oop maybe_update_with_forwarded(T* p);
729 
730   template &lt;class T&gt;
731   inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);
732 
733   template &lt;class T&gt;
734   inline oop update_with_forwarded_not_null(T* p, oop obj);
735 
<span class="line-modified">736   inline oop atomic_compare_exchange_oop(oop n, narrowOop* addr, oop c);</span>
<span class="line-modified">737   inline oop atomic_compare_exchange_oop(oop n, oop* addr, oop c);</span>

738 
739   void trash_humongous_region_at(ShenandoahHeapRegion *r);
740 
741   void deduplicate_string(oop str);
742 
<span class="line-removed">743   void stop_concurrent_marking();</span>
<span class="line-removed">744 </span>
<span class="line-removed">745   void roots_iterate(OopClosure* cl);</span>
<span class="line-removed">746 </span>
747 private:
748   void trash_cset_regions();
749   void update_heap_references(bool concurrent);
750 
751 // ---------- Testing helpers functions
752 //
753 private:
754   ShenandoahSharedFlag _inject_alloc_failure;
755 
756   void try_inject_alloc_failure();
757   bool should_inject_alloc_failure();
758 };
759 
760 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
 27 
 28 #include &quot;gc/shared/markBitMap.hpp&quot;
 29 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;</span>
 34 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
<span class="line-added"> 36 #include &quot;gc/shenandoah/shenandoahUnload.hpp&quot;</span>
 37 #include &quot;services/memoryManager.hpp&quot;
<span class="line-added"> 38 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 39 
 40 class ConcurrentGCTimer;
 41 class ReferenceProcessor;
 42 class ShenandoahAllocTracker;
 43 class ShenandoahCollectorPolicy;
 44 class ShenandoahControlThread;
 45 class ShenandoahGCSession;
<span class="line-added"> 46 class ShenandoahGCStateResetter;</span>
 47 class ShenandoahHeuristics;
 48 class ShenandoahMarkingContext;
<span class="line-added"> 49 class ShenandoahMarkCompact;</span>
<span class="line-added"> 50 class ShenandoahMode;</span>
 51 class ShenandoahPhaseTimings;
 52 class ShenandoahHeap;
 53 class ShenandoahHeapRegion;
 54 class ShenandoahHeapRegionClosure;
 55 class ShenandoahCollectionSet;
 56 class ShenandoahFreeSet;
 57 class ShenandoahConcurrentMark;
 58 class ShenandoahMarkCompact;
 59 class ShenandoahMonitoringSupport;
 60 class ShenandoahPacer;
 61 class ShenandoahTraversalGC;
 62 class ShenandoahVerifier;
 63 class ShenandoahWorkGang;
 64 class VMStructs;
 65 
 66 class ShenandoahRegionIterator : public StackObj {
 67 private:
 68   ShenandoahHeap* _heap;
 69 
 70   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
 71   volatile size_t _index;
 72   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
 73 
 74   // No implicit copying: iterators should be passed by reference to capture the state
<span class="line-modified"> 75   NONCOPYABLE(ShenandoahRegionIterator);</span>

 76 
 77 public:
 78   ShenandoahRegionIterator();
 79   ShenandoahRegionIterator(ShenandoahHeap* heap);
 80 
 81   // Reset iterator to default state
 82   void reset();
 83 
 84   // Returns next region, or NULL if there are no more regions.
 85   // This is multi-thread-safe.
 86   inline ShenandoahHeapRegion* next();
 87 
 88   // This is *not* MT safe. However, in the absence of multithreaded access, it
 89   // can be used to determine if there is more work to do.
 90   bool has_next() const;
 91 };
 92 
 93 class ShenandoahHeapRegionClosure : public StackObj {
 94 public:
 95   virtual void heap_region_do(ShenandoahHeapRegion* r) = 0;
 96   virtual bool is_thread_safe() { return false; }
 97 };
 98 













 99 #ifdef ASSERT
100 class ShenandoahAssertToSpaceClosure : public OopClosure {
101 private:
102   template &lt;class T&gt;
103   void do_oop_work(T* p);
104 public:
105   void do_oop(narrowOop* p);
106   void do_oop(oop* p);
107 };
108 #endif
109 
<span class="line-modified">110 typedef ShenandoahLock    ShenandoahHeapLock;</span>
<span class="line-modified">111 typedef ShenandoahLocker  ShenandoahHeapLocker;</span>


























112 
113 // Shenandoah GC is low-pause concurrent GC that uses Brooks forwarding pointers
114 // to encode forwarding data. See BrooksPointer for details on forwarding data encoding.
115 // See ShenandoahControlThread for GC cycle structure.
116 //
117 class ShenandoahHeap : public CollectedHeap {
118   friend class ShenandoahAsserts;
119   friend class VMStructs;
120   friend class ShenandoahGCSession;
<span class="line-added">121   friend class ShenandoahGCStateResetter;</span>
122 
123 // ---------- Locks that guard important data structures in Heap
124 //
125 private:
126   ShenandoahHeapLock _lock;
127 
128 public:
129   ShenandoahHeapLock* lock() {
130     return &amp;_lock;
131   }
132 
133   void assert_heaplock_owned_by_current_thread()     NOT_DEBUG_RETURN;
134   void assert_heaplock_not_owned_by_current_thread() NOT_DEBUG_RETURN;
135   void assert_heaplock_or_safepoint()                NOT_DEBUG_RETURN;
136 
137 // ---------- Initialization, termination, identification, printing routines
138 //
139 public:
140   static ShenandoahHeap* heap();
141   static ShenandoahHeap* heap_no_check();
</pre>
<hr />
<pre>
148   void post_initialize();
149   void initialize_heuristics();
150 
151   void initialize_serviceability();
152 
153   void print_on(outputStream* st)              const;
154   void print_extended_on(outputStream *st)     const;
155   void print_tracing_info()                    const;
156   void print_gc_threads_on(outputStream* st)   const;
157   void print_heap_regions_on(outputStream* st) const;
158 
159   void stop();
160 
161   void prepare_for_verify();
162   void verify(VerifyOption vo);
163 
164 // ---------- Heap counters and metrics
165 //
166 private:
167            size_t _initial_size;
<span class="line-added">168            size_t _minimum_size;</span>
169   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
170   volatile size_t _used;
171   volatile size_t _committed;
172   volatile size_t _bytes_allocated_since_gc_start;
173   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
174 
175 public:
176   void increase_used(size_t bytes);
177   void decrease_used(size_t bytes);
178   void set_used(size_t bytes);
179 
180   void increase_committed(size_t bytes);
181   void decrease_committed(size_t bytes);
182   void increase_allocated(size_t bytes);
183 
184   size_t bytes_allocated_since_gc_start();
185   void reset_bytes_allocated_since_gc_start();
186 
<span class="line-added">187   size_t min_capacity()     const;</span>
188   size_t max_capacity()     const;
189   size_t initial_capacity() const;
190   size_t capacity()         const;
191   size_t used()             const;
192   size_t committed()        const;
193 
194 // ---------- Workers handling
195 //
196 private:
197   uint _max_workers;
198   ShenandoahWorkGang* _workers;
199   ShenandoahWorkGang* _safepoint_workers;
200 
201 public:
202   uint max_workers();
203   void assert_gc_workers(uint nworker) NOT_DEBUG_RETURN;
204 
205   WorkGang* workers() const;
206   WorkGang* get_safepoint_workers();
207 
208   void gc_threads_do(ThreadClosure* tcl) const;
209 
210 // ---------- Heap regions handling machinery
211 //
212 private:
213   MemRegion _heap_region;
214   bool      _heap_region_special;
215   size_t    _num_regions;
216   ShenandoahHeapRegion** _regions;
217   ShenandoahRegionIterator _update_refs_iterator;
218 
219 public:
<span class="line-added">220 </span>
<span class="line-added">221   inline HeapWord* base() const { return _heap_region.start(); }</span>
<span class="line-added">222 </span>
223   inline size_t num_regions() const { return _num_regions; }
224   inline bool is_heap_region_special() { return _heap_region_special; }
225 
226   inline ShenandoahHeapRegion* const heap_region_containing(const void* addr) const;
227   inline size_t heap_region_index_containing(const void* addr) const;
228 
229   inline ShenandoahHeapRegion* const get_region(size_t region_idx) const;
230 
231   void heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
232   void parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const;
233 
234 // ---------- GC state machinery
235 //
236 // GC state describes the important parts of collector state, that may be
237 // used to make barrier selection decisions in the native and generated code.
238 // Multiple bits can be set at once.
239 //
240 // Important invariant: when GC state is zero, the heap is stable, and no barriers
241 // are required.
242 //
243 public:
244   enum GCStateBitPos {
<span class="line-modified">245     // Heap has forwarded objects: needs LRB barriers.</span>
246     HAS_FORWARDED_BITPOS   = 0,
247 
248     // Heap is under marking: needs SATB barriers.
249     MARKING_BITPOS    = 1,
250 
<span class="line-modified">251     // Heap is under evacuation: needs LRB barriers. (Set together with HAS_FORWARDED)</span>
252     EVACUATION_BITPOS = 2,
253 
<span class="line-modified">254     // Heap is under updating: needs no additional barriers.</span>
255     UPDATEREFS_BITPOS = 3,
256 
257     // Heap is under traversal collection
<span class="line-modified">258     TRAVERSAL_BITPOS  = 4</span>
259   };
260 
261   enum GCState {
262     STABLE        = 0,
263     HAS_FORWARDED = 1 &lt;&lt; HAS_FORWARDED_BITPOS,
264     MARKING       = 1 &lt;&lt; MARKING_BITPOS,
265     EVACUATION    = 1 &lt;&lt; EVACUATION_BITPOS,
266     UPDATEREFS    = 1 &lt;&lt; UPDATEREFS_BITPOS,
<span class="line-modified">267     TRAVERSAL     = 1 &lt;&lt; TRAVERSAL_BITPOS</span>
268   };
269 
270 private:
271   ShenandoahSharedBitmap _gc_state;
272   ShenandoahSharedFlag   _degenerated_gc_in_progress;
273   ShenandoahSharedFlag   _full_gc_in_progress;
274   ShenandoahSharedFlag   _full_gc_move_in_progress;
275   ShenandoahSharedFlag   _progress_last_gc;
<span class="line-added">276   ShenandoahSharedFlag   _concurrent_root_in_progress;</span>
277 
278   void set_gc_state_all_threads(char state);
279   void set_gc_state_mask(uint mask, bool value);
280 
281 public:
282   char gc_state() const;
283   static address gc_state_addr();
284 
285   void set_concurrent_mark_in_progress(bool in_progress);
286   void set_evacuation_in_progress(bool in_progress);
287   void set_update_refs_in_progress(bool in_progress);
288   void set_degenerated_gc_in_progress(bool in_progress);
289   void set_full_gc_in_progress(bool in_progress);
290   void set_full_gc_move_in_progress(bool in_progress);
291   void set_concurrent_traversal_in_progress(bool in_progress);
292   void set_has_forwarded_objects(bool cond);
<span class="line-added">293   void set_concurrent_root_in_progress(bool cond);</span>
294 
295   inline bool is_stable() const;
296   inline bool is_idle() const;
297   inline bool is_concurrent_mark_in_progress() const;
298   inline bool is_update_refs_in_progress() const;
299   inline bool is_evacuation_in_progress() const;
300   inline bool is_degenerated_gc_in_progress() const;
301   inline bool is_full_gc_in_progress() const;
302   inline bool is_full_gc_move_in_progress() const;
303   inline bool is_concurrent_traversal_in_progress() const;
304   inline bool has_forwarded_objects() const;
305   inline bool is_gc_in_progress_mask(uint mask) const;
<span class="line-added">306   inline bool is_stw_gc_in_progress() const;</span>
<span class="line-added">307   inline bool is_concurrent_root_in_progress() const;</span>
308 
309 // ---------- GC cancellation and degeneration machinery
310 //
311 // Cancelled GC flag is used to notify concurrent phases that they should terminate.
312 //
313 public:
314   enum ShenandoahDegenPoint {
315     _degenerated_unset,
316     _degenerated_traversal,
317     _degenerated_outside_cycle,
318     _degenerated_mark,
319     _degenerated_evac,
320     _degenerated_updaterefs,
<span class="line-modified">321     _DEGENERATED_LIMIT</span>
322   };
323 
324   static const char* degen_point_to_string(ShenandoahDegenPoint point) {
325     switch (point) {
326       case _degenerated_unset:
327         return &quot;&lt;UNSET&gt;&quot;;
328       case _degenerated_traversal:
329         return &quot;Traversal&quot;;
330       case _degenerated_outside_cycle:
331         return &quot;Outside of Cycle&quot;;
332       case _degenerated_mark:
333         return &quot;Mark&quot;;
334       case _degenerated_evac:
335         return &quot;Evacuation&quot;;
336       case _degenerated_updaterefs:
337         return &quot;Update Refs&quot;;
338       default:
339         ShouldNotReachHere();
340         return &quot;ERROR&quot;;
341     }
</pre>
<hr />
<pre>
385   void vmop_entry_full(GCCause::Cause cause);
386   void vmop_degenerated(ShenandoahDegenPoint point);
387 
388   // Entry methods to normally STW GC operations. These set up logging, monitoring
389   // and workers for net VM operation
390   void entry_init_mark();
391   void entry_final_mark();
392   void entry_final_evac();
393   void entry_init_updaterefs();
394   void entry_final_updaterefs();
395   void entry_init_traversal();
396   void entry_final_traversal();
397   void entry_full(GCCause::Cause cause);
398   void entry_degenerated(int point);
399 
400   // Entry methods to normally concurrent GC operations. These set up logging, monitoring
401   // for concurrent operation.
402   void entry_reset();
403   void entry_mark();
404   void entry_preclean();
<span class="line-added">405   void entry_roots();</span>
406   void entry_cleanup();
407   void entry_evac();
408   void entry_updaterefs();
409   void entry_traversal();
410   void entry_uncommit(double shrink_before);
411 
412 private:
413   // Actual work for the phases
414   void op_init_mark();
415   void op_final_mark();
416   void op_final_evac();
417   void op_init_updaterefs();
418   void op_final_updaterefs();
419   void op_init_traversal();
420   void op_final_traversal();
421   void op_full(GCCause::Cause cause);
422   void op_degenerated(ShenandoahDegenPoint point);
423   void op_degenerated_fail();
424   void op_degenerated_futile();
425 
426   void op_reset();
427   void op_mark();
428   void op_preclean();
<span class="line-added">429   void op_roots();</span>
430   void op_cleanup();
431   void op_conc_evac();
432   void op_stw_evac();
433   void op_updaterefs();
434   void op_traversal();
435   void op_uncommit(double shrink_before);
436 
437   // Messages for GC trace events, they have to be immortal for
438   // passing around the logging/tracing systems
439   const char* init_mark_event_message() const;
440   const char* final_mark_event_message() const;
441   const char* conc_mark_event_message() const;
<span class="line-added">442   const char* init_traversal_event_message() const;</span>
<span class="line-added">443   const char* final_traversal_event_message() const;</span>
<span class="line-added">444   const char* conc_traversal_event_message() const;</span>
445   const char* degen_event_message(ShenandoahDegenPoint point) const;
446 
447 // ---------- GC subsystems
448 //
449 private:
450   ShenandoahControlThread*   _control_thread;
451   ShenandoahCollectorPolicy* _shenandoah_policy;
<span class="line-added">452   ShenandoahMode*            _gc_mode;</span>
453   ShenandoahHeuristics*      _heuristics;
454   ShenandoahFreeSet*         _free_set;
455   ShenandoahConcurrentMark*  _scm;
456   ShenandoahTraversalGC*     _traversal_gc;
457   ShenandoahMarkCompact*     _full_gc;
458   ShenandoahPacer*           _pacer;
459   ShenandoahVerifier*        _verifier;
460 
461   ShenandoahAllocTracker*    _alloc_tracker;
462   ShenandoahPhaseTimings*    _phase_timings;
463 
464   ShenandoahControlThread*   control_thread()          { return _control_thread;    }
465   ShenandoahMarkCompact*     full_gc()                 { return _full_gc;           }
466 
467 public:
468   ShenandoahCollectorPolicy* shenandoah_policy() const { return _shenandoah_policy; }
469   ShenandoahHeuristics*      heuristics()        const { return _heuristics;        }
470   ShenandoahFreeSet*         free_set()          const { return _free_set;          }
471   ShenandoahConcurrentMark*  concurrent_mark()         { return _scm;               }
<span class="line-modified">472   ShenandoahTraversalGC*     traversal_gc()      const { return _traversal_gc;      }</span>
<span class="line-added">473   bool                       is_traversal_mode() const { return _traversal_gc != NULL; }</span>
474   ShenandoahPacer*           pacer()             const { return _pacer;             }
475 
476   ShenandoahPhaseTimings*    phase_timings()     const { return _phase_timings;     }
477   ShenandoahAllocTracker*    alloc_tracker()     const { return _alloc_tracker;     }
478 
479   ShenandoahVerifier*        verifier();
480 
481 // ---------- VM subsystem bindings
482 //
483 private:
484   ShenandoahMonitoringSupport* _monitoring_support;
485   MemoryPool*                  _memory_pool;
486   GCMemoryManager              _stw_memory_manager;
487   GCMemoryManager              _cycle_memory_manager;
488   ConcurrentGCTimer*           _gc_timer;
489   SoftRefPolicy                _soft_ref_policy;
490 
<span class="line-added">491   // For exporting to SA</span>
<span class="line-added">492   int                          _log_min_obj_alignment_in_bytes;</span>
493 public:
494   ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }
495   GCMemoryManager* cycle_memory_manager()           { return &amp;_cycle_memory_manager; }
496   GCMemoryManager* stw_memory_manager()             { return &amp;_stw_memory_manager;   }
497   SoftRefPolicy* soft_ref_policy()                  { return &amp;_soft_ref_policy;      }
498 
499   GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
500   GrowableArray&lt;MemoryPool*&gt; memory_pools();
501   MemoryUsage memory_usage();
502   GCTracer* tracer();
503   GCTimer* gc_timer() const;

504 
505 // ---------- Reference processing
506 //
507 private:
508   AlwaysTrueClosure    _subject_to_discovery;
509   ReferenceProcessor*  _ref_processor;
510   ShenandoahSharedFlag _process_references;
511 
512   void ref_processing_init();
513 
514 public:
515   ReferenceProcessor* ref_processor() { return _ref_processor; }
516   void set_process_references(bool pr);
517   bool process_references() const;
518 
519 // ---------- Class Unloading
520 //
521 private:
522   ShenandoahSharedFlag _unload_classes;
<span class="line-added">523   ShenandoahUnload     _unloader;</span>
524 
525 public:
526   void set_unload_classes(bool uc);
527   bool unload_classes() const;
528 
<span class="line-modified">529   // Perform STW class unloading and weak root cleaning</span>
<span class="line-modified">530   void parallel_cleaning(bool full_gc);</span>
<span class="line-modified">531 </span>
<span class="line-added">532 private:</span>
<span class="line-added">533   void stw_unload_classes(bool full_gc);</span>
<span class="line-added">534   void stw_process_weak_roots(bool full_gc);</span>
<span class="line-added">535 </span>
<span class="line-added">536   // Prepare concurrent root processing</span>
<span class="line-added">537   void prepare_concurrent_roots();</span>
<span class="line-added">538   // Prepare and finish concurrent unloading</span>
<span class="line-added">539   void prepare_concurrent_unloading();</span>
<span class="line-added">540   void finish_concurrent_unloading();</span>
541 
542 // ---------- Generic interface hooks
543 // Minor things that super-interface expects us to implement to play nice with
544 // the rest of runtime. Some of the things here are not required to be implemented,
545 // and can be stubbed out.
546 //
547 public:
548   AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);
549   bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);
550 
551   bool is_in(const void* p) const;
552 
<span class="line-modified">553   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-modified">554   bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }</span>
555 
556   void collect(GCCause::Cause cause);
557   void do_full_collection(bool clear_all_soft_refs);
558 
559   // Used for parsing heap during error printing
560   HeapWord* block_start(const void* addr) const;
561   bool block_is_obj(const HeapWord* addr) const;
<span class="line-added">562   bool print_location(outputStream* st, void* addr) const;</span>
563 
564   // Used for native heap walkers: heap dumpers, mostly
565   void object_iterate(ObjectClosure* cl);
<span class="line-modified">566 </span>
<span class="line-added">567   // Keep alive an object that was loaded with AS_NO_KEEPALIVE.</span>
<span class="line-added">568   void keep_alive(oop obj);</span>
569 
570   // Used by RMI
571   jlong millis_since_last_gc();
572 
573 // ---------- Safepoint interface hooks
574 //
575 public:
576   void safepoint_synchronize_begin();
577   void safepoint_synchronize_end();
578 
579 // ---------- Code roots handling hooks
580 //
581 public:
582   void register_nmethod(nmethod* nm);
583   void unregister_nmethod(nmethod* nm);
<span class="line-added">584   void flush_nmethod(nmethod* nm);</span>
<span class="line-added">585   void verify_nmethod(nmethod* nm) {}</span>
586 
587 // ---------- Pinning hooks
588 //
589 public:
590   // Shenandoah supports per-object (per-region) pinning
591   bool supports_object_pinning() const { return true; }
592 
593   oop pin_object(JavaThread* thread, oop obj);
594   void unpin_object(JavaThread* thread, oop obj);
595 
<span class="line-added">596   void sync_pinned_region_status();</span>
<span class="line-added">597   void assert_pinned_region_status() NOT_DEBUG_RETURN;</span>
<span class="line-added">598 </span>
599 // ---------- Allocation support
600 //
601 private:
602   HeapWord* allocate_memory_under_lock(ShenandoahAllocRequest&amp; request, bool&amp; in_new_region);
603   inline HeapWord* allocate_from_gclab(Thread* thread, size_t size);
604   HeapWord* allocate_from_gclab_slow(Thread* thread, size_t size);
605   HeapWord* allocate_new_gclab(size_t min_size, size_t word_size, size_t* actual_size);
606   void retire_and_reset_gclabs();
607 
608 public:
609   HeapWord* allocate_memory(ShenandoahAllocRequest&amp; request);
610   HeapWord* mem_allocate(size_t size, bool* what);
611   MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
612                                                size_t size,
613                                                Metaspace::MetadataType mdtype);
614 




615   void notify_mutator_alloc_words(size_t words, bool waste);
616 
617   // Shenandoah supports TLAB allocation
618   bool supports_tlab_allocation() const { return true; }
619 
620   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
621   size_t tlab_capacity(Thread *thr) const;
622   size_t unsafe_max_tlab_alloc(Thread *thread) const;
623   size_t max_tlab_size() const;
624   size_t tlab_used(Thread* ignored) const;
625 




626   void resize_tlabs();
627 
628   void ensure_parsability(bool retire_tlabs);
629   void make_parsable(bool retire_tlabs);
630 
631 // ---------- Marking support
632 //
633 private:
634   ShenandoahMarkingContext* _marking_context;
635   MemRegion  _bitmap_region;
636   MemRegion  _aux_bitmap_region;
637   MarkBitMap _verification_bit_map;
638   MarkBitMap _aux_bit_map;
639 
640   size_t _bitmap_size;
641   size_t _bitmap_regions_per_slice;
642   size_t _bitmap_bytes_per_slice;
643 
644   bool _bitmap_region_special;
645   bool _aux_bitmap_region_special;
</pre>
<hr />
<pre>
681   bool uncommit_bitmap_slice(ShenandoahHeapRegion *r);
682   bool is_bitmap_slice_committed(ShenandoahHeapRegion* r, bool skip_self = false);
683 
684   // Liveness caching support
685   jushort* get_liveness_cache(uint worker_id);
686   void flush_liveness_cache(uint worker_id);
687 
688 // ---------- Evacuation support
689 //
690 private:
691   ShenandoahCollectionSet* _collection_set;
692   ShenandoahEvacOOMHandler _oom_evac_handler;
693 
694   void evacuate_and_update_roots();
695 
696 public:
697   static address in_cset_fast_test_addr();
698 
699   ShenandoahCollectionSet* collection_set() const { return _collection_set; }
700 
<span class="line-modified">701   // Checks if object is in the collection set.</span>
<span class="line-modified">702   inline bool in_collection_set(oop obj) const;</span>
703 
<span class="line-modified">704   // Checks if location is in the collection set. Can be interior pointer, not the oop itself.</span>
<span class="line-modified">705   inline bool in_collection_set_loc(void* loc) const;</span>
706 
707   // Evacuates object src. Returns the evacuated object, either evacuated
708   // by this thread, or by some other thread.
709   inline oop evacuate_object(oop src, Thread* thread);
710 
711   // Call before/after evacuation.
712   void enter_evacuation();
713   void leave_evacuation();
714 
715 // ---------- Helper functions
716 //
717 public:
718   template &lt;class T&gt;
719   inline oop evac_update_with_forwarded(T* p);
720 
721   template &lt;class T&gt;
722   inline oop maybe_update_with_forwarded(T* p);
723 
724   template &lt;class T&gt;
725   inline oop maybe_update_with_forwarded_not_null(T* p, oop obj);
726 
727   template &lt;class T&gt;
728   inline oop update_with_forwarded_not_null(T* p, oop obj);
729 
<span class="line-modified">730   static inline oop cas_oop(oop n, narrowOop* addr, oop c);</span>
<span class="line-modified">731   static inline oop cas_oop(oop n, oop* addr, oop c);</span>
<span class="line-added">732   static inline oop cas_oop(oop n, narrowOop* addr, narrowOop c);</span>
733 
734   void trash_humongous_region_at(ShenandoahHeapRegion *r);
735 
736   void deduplicate_string(oop str);
737 




738 private:
739   void trash_cset_regions();
740   void update_heap_references(bool concurrent);
741 
742 // ---------- Testing helpers functions
743 //
744 private:
745   ShenandoahSharedFlag _inject_alloc_failure;
746 
747   void try_inject_alloc_failure();
748   bool should_inject_alloc_failure();
749 };
750 
751 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
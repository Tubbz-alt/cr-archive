<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahAllocTracker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahArguments.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahArguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -21,73 +21,94 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/gcArguments.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  #include &quot;gc/shared/workerPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahArguments.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;</span>
  #include &quot;utilities/defaultStream.hpp&quot;
  
  void ShenandoahArguments::initialize() {
  #if !(defined AARCH64 || defined AMD64 || defined IA32)
    vm_exit_during_initialization(&quot;Shenandoah GC is not supported on this platform.&quot;);
  #endif
  
<span class="udiff-line-modified-removed">- #ifdef IA32</span>
<span class="udiff-line-modified-added">+ #if 0 // leave this block as stepping stone for future platforms</span>
    log_warning(gc)(&quot;Shenandoah GC is not fully supported on this platform:&quot;);
    log_warning(gc)(&quot;  concurrent modes are not supported, only STW cycles are enabled;&quot;);
    log_warning(gc)(&quot;  arch-specific barrier code is not implemented, disabling barriers;&quot;);
  
    FLAG_SET_DEFAULT(ShenandoahGCHeuristics,           &quot;passive&quot;);
  
    FLAG_SET_DEFAULT(ShenandoahSATBBarrier,            false);
<span class="udiff-line-added">+   FLAG_SET_DEFAULT(ShenandoahLoadRefBarrier,         false);</span>
    FLAG_SET_DEFAULT(ShenandoahKeepAliveBarrier,       false);
<span class="udiff-line-removed">-   FLAG_SET_DEFAULT(ShenandoahWriteBarrier,           false);</span>
<span class="udiff-line-removed">-   FLAG_SET_DEFAULT(ShenandoahReadBarrier,            false);</span>
    FLAG_SET_DEFAULT(ShenandoahStoreValEnqueueBarrier, false);
<span class="udiff-line-removed">-   FLAG_SET_DEFAULT(ShenandoahStoreValReadBarrier,    false);</span>
    FLAG_SET_DEFAULT(ShenandoahCASBarrier,             false);
<span class="udiff-line-removed">-   FLAG_SET_DEFAULT(ShenandoahAcmpBarrier,            false);</span>
    FLAG_SET_DEFAULT(ShenandoahCloneBarrier,           false);
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-modified-removed">- #ifdef _LP64</span>
<span class="udiff-line-removed">-   // The optimized ObjArrayChunkedTask takes some bits away from the full 64 addressable</span>
<span class="udiff-line-removed">-   // bits, fail if we ever attempt to address more than we can. Only valid on 64bit.</span>
<span class="udiff-line-removed">-   if (MaxHeapSize &gt;= ObjArrayChunkedTask::max_addressable()) {</span>
<span class="udiff-line-removed">-     jio_fprintf(defaultStream::error_stream(),</span>
<span class="udiff-line-removed">-                 &quot;Shenandoah GC cannot address more than &quot; SIZE_FORMAT &quot; bytes, and &quot; SIZE_FORMAT &quot; bytes heap requested.&quot;,</span>
<span class="udiff-line-removed">-                 ObjArrayChunkedTask::max_addressable(), MaxHeapSize);</span>
<span class="udiff-line-removed">-     vm_exit(1);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   FLAG_SET_DEFAULT(ShenandoahVerifyOptoBarriers,     false);</span>
  #endif
  
    if (UseLargePages &amp;&amp; (MaxHeapSize / os::large_page_size()) &lt; ShenandoahHeapRegion::MIN_NUM_REGIONS) {
      warning(&quot;Large pages size (&quot; SIZE_FORMAT &quot;K) is too large to afford page-sized regions, disabling uncommit&quot;,
              os::large_page_size() / K);
      FLAG_SET_DEFAULT(ShenandoahUncommit, false);
    }
  
    // Enable NUMA by default. While Shenandoah is not NUMA-aware, enabling NUMA makes
<span class="udiff-line-modified-removed">-   // storage allocation code NUMA-aware, and NUMA interleaving makes the storage</span>
<span class="udiff-line-removed">-   // allocated in consistent manner (interleaving) to minimize run-to-run variance.</span>
<span class="udiff-line-modified-added">+   // storage allocation code NUMA-aware.</span>
    if (FLAG_IS_DEFAULT(UseNUMA)) {
      FLAG_SET_DEFAULT(UseNUMA, true);
<span class="udiff-line-removed">-     FLAG_SET_DEFAULT(UseNUMAInterleaving, true);</span>
    }
  
<span class="udiff-line-modified-removed">-   FLAG_SET_DEFAULT(ParallelGCThreads,</span>
<span class="udiff-line-modified-removed">-                    WorkerPolicy::parallel_worker_threads());</span>
<span class="udiff-line-modified-added">+   // Set up default number of concurrent threads. We want to have cycles complete fast</span>
<span class="udiff-line-modified-added">+   // enough, but we also do not want to steal too much CPU from the concurrently running</span>
<span class="udiff-line-added">+   // application. Using 1/4 of available threads for concurrent GC seems a good</span>
<span class="udiff-line-added">+   // compromise here.</span>
<span class="udiff-line-added">+   bool ergo_conc = FLAG_IS_DEFAULT(ConcGCThreads);</span>
<span class="udiff-line-added">+   if (ergo_conc) {</span>
<span class="udiff-line-added">+     FLAG_SET_DEFAULT(ConcGCThreads, MAX2(1, os::initial_active_processor_count() / 4));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (ConcGCThreads == 0) {</span>
<span class="udiff-line-added">+     vm_exit_during_initialization(&quot;Shenandoah expects ConcGCThreads &gt; 0, check -XX:ConcGCThreads=#&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Set up default number of parallel threads. We want to have decent pauses performance</span>
<span class="udiff-line-added">+   // which would use parallel threads, but we also do not want to do too many threads</span>
<span class="udiff-line-added">+   // that will overwhelm the OS scheduler. Using 1/2 of available threads seems to be a fair</span>
<span class="udiff-line-added">+   // compromise here. Due to implementation constraints, it should not be lower than</span>
<span class="udiff-line-added">+   // the number of concurrent threads.</span>
<span class="udiff-line-added">+   bool ergo_parallel = FLAG_IS_DEFAULT(ParallelGCThreads);</span>
<span class="udiff-line-added">+   if (ergo_parallel) {</span>
<span class="udiff-line-added">+     FLAG_SET_DEFAULT(ParallelGCThreads, MAX2(1, os::initial_active_processor_count() / 2));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (ParallelGCThreads == 0) {</span>
<span class="udiff-line-added">+     vm_exit_during_initialization(&quot;Shenandoah expects ParallelGCThreads &gt; 0, check -XX:ParallelGCThreads=#&quot;);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   if (FLAG_IS_DEFAULT(ConcGCThreads)) {</span>
<span class="udiff-line-modified-removed">-     uint conc_threads = MAX2((uint) 1, ParallelGCThreads);</span>
<span class="udiff-line-modified-removed">-     FLAG_SET_DEFAULT(ConcGCThreads, conc_threads);</span>
<span class="udiff-line-modified-added">+   // Make sure ergonomic decisions do not break the thread count invariants.</span>
<span class="udiff-line-modified-added">+   // This may happen when user overrides one of the flags, but not the other.</span>
<span class="udiff-line-modified-added">+   // When that happens, we want to adjust the setting that was set ergonomically.</span>
<span class="udiff-line-added">+   if (ParallelGCThreads &lt; ConcGCThreads) {</span>
<span class="udiff-line-added">+     if (ergo_conc &amp;&amp; !ergo_parallel) {</span>
<span class="udiff-line-added">+       FLAG_SET_DEFAULT(ConcGCThreads, ParallelGCThreads);</span>
<span class="udiff-line-added">+     } else if (!ergo_conc &amp;&amp; ergo_parallel) {</span>
<span class="udiff-line-added">+       FLAG_SET_DEFAULT(ParallelGCThreads, ConcGCThreads);</span>
<span class="udiff-line-added">+     } else if (ergo_conc &amp;&amp; ergo_parallel) {</span>
<span class="udiff-line-added">+       // Should not happen, check the ergonomic computation above. Fail with relevant error.</span>
<span class="udiff-line-added">+       vm_exit_during_initialization(&quot;Shenandoah thread count ergonomic error&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // User settings error, report and ask user to rectify.</span>
<span class="udiff-line-added">+       vm_exit_during_initialization(&quot;Shenandoah expects ConcGCThreads &lt;= ParallelGCThreads, check -XX:ParallelGCThreads, -XX:ConcGCThreads&quot;);</span>
<span class="udiff-line-added">+     }</span>
    }
  
    if (FLAG_IS_DEFAULT(ParallelRefProcEnabled)) {
      FLAG_SET_DEFAULT(ParallelRefProcEnabled, true);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,17 +129,14 @@</span>
    }
  #ifdef ASSERT
    // C2 barrier verification is only reliable when all default barriers are enabled
    if (ShenandoahVerifyOptoBarriers &amp;&amp;
            (!FLAG_IS_DEFAULT(ShenandoahSATBBarrier)            ||
<span class="udiff-line-added">+            !FLAG_IS_DEFAULT(ShenandoahLoadRefBarrier)         ||</span>
             !FLAG_IS_DEFAULT(ShenandoahKeepAliveBarrier)       ||
<span class="udiff-line-removed">-            !FLAG_IS_DEFAULT(ShenandoahWriteBarrier)           ||</span>
<span class="udiff-line-removed">-            !FLAG_IS_DEFAULT(ShenandoahReadBarrier)            ||</span>
             !FLAG_IS_DEFAULT(ShenandoahStoreValEnqueueBarrier) ||
<span class="udiff-line-removed">-            !FLAG_IS_DEFAULT(ShenandoahStoreValReadBarrier)    ||</span>
             !FLAG_IS_DEFAULT(ShenandoahCASBarrier)             ||
<span class="udiff-line-removed">-            !FLAG_IS_DEFAULT(ShenandoahAcmpBarrier)            ||</span>
             !FLAG_IS_DEFAULT(ShenandoahCloneBarrier)
            )) {
      warning(&quot;Unusual barrier configuration, disabling C2 barrier verification&quot;);
      FLAG_SET_DEFAULT(ShenandoahVerifyOptoBarriers, false);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133,22 +151,10 @@</span>
      // a chance to do it on its own.
      FLAG_SET_DEFAULT(AlwaysPreTouch, false);
      FLAG_SET_DEFAULT(ShenandoahAlwaysPreTouch, true);
    }
  
<span class="udiff-line-removed">-   // Shenandoah C2 optimizations apparently dislike the shape of thread-local handshakes.</span>
<span class="udiff-line-removed">-   // Disable it by default, unless we enable it specifically for debugging.</span>
<span class="udiff-line-removed">-   if (FLAG_IS_DEFAULT(ThreadLocalHandshakes)) {</span>
<span class="udiff-line-removed">-     if (ThreadLocalHandshakes) {</span>
<span class="udiff-line-removed">-       FLAG_SET_DEFAULT(ThreadLocalHandshakes, false);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (ThreadLocalHandshakes) {</span>
<span class="udiff-line-removed">-       warning(&quot;Thread-local handshakes are not working correctly with Shenandoah at the moment. Enable at your own risk.&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // Record more information about previous cycles for improved debugging pleasure
    if (FLAG_IS_DEFAULT(LogEventsBufferEntries)) {
      FLAG_SET_DEFAULT(LogEventsBufferEntries, 250);
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,16 +163,17 @@</span>
        warning(&quot;AlwaysPreTouch is enabled, disabling ShenandoahUncommit&quot;);
      }
      FLAG_SET_DEFAULT(ShenandoahUncommit, false);
    }
  
<span class="udiff-line-added">+   if ((InitialHeapSize == MaxHeapSize) &amp;&amp; ShenandoahUncommit) {</span>
<span class="udiff-line-added">+     log_info(gc)(&quot;Min heap equals to max heap, disabling ShenandoahUncommit&quot;);</span>
<span class="udiff-line-added">+     FLAG_SET_DEFAULT(ShenandoahUncommit, false);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // If class unloading is disabled, no unloading for concurrent cycles as well.
<span class="udiff-line-modified-removed">-   // If class unloading is enabled, users should opt-in for unloading during</span>
<span class="udiff-line-removed">-   // concurrent cycles.</span>
<span class="udiff-line-removed">-   if (!ClassUnloading || !FLAG_IS_CMDLINE(ClassUnloadingWithConcurrentMark)) {</span>
<span class="udiff-line-removed">-     log_info(gc)(&quot;Consider -XX:+ClassUnloadingWithConcurrentMark if large pause times &quot;</span>
<span class="udiff-line-removed">-                  &quot;are observed on class-unloading sensitive workloads&quot;);</span>
<span class="udiff-line-modified-added">+   if (!ClassUnloading) {</span>
      FLAG_SET_DEFAULT(ClassUnloadingWithConcurrentMark, false);
    }
  
    // AOT is not supported yet
    if (UseAOT) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174,17 +181,10 @@</span>
        warning(&quot;Shenandoah does not support AOT at this moment, disabling UseAOT&quot;);
      }
      FLAG_SET_DEFAULT(UseAOT, false);
    }
  
<span class="udiff-line-removed">-   // JNI fast get field stuff is not currently supported by Shenandoah.</span>
<span class="udiff-line-removed">-   // It would introduce another heap memory access for reading the forwarding</span>
<span class="udiff-line-removed">-   // pointer, which would have to be guarded by the signal handler machinery.</span>
<span class="udiff-line-removed">-   // See:</span>
<span class="udiff-line-removed">-   // http://mail.openjdk.java.net/pipermail/hotspot-dev/2018-June/032763.html</span>
<span class="udiff-line-removed">-   FLAG_SET_DEFAULT(UseFastJNIAccessors, false);</span>
<span class="udiff-line-removed">- </span>
    // TLAB sizing policy makes resizing decisions before each GC cycle. It averages
    // historical data, assigning more recent data the weight according to TLABAllocationWeight.
    // Current default is good for generational collectors that run frequent young GCs.
    // With Shenandoah, GC cycles are much less frequent, so we need we need sizing policy
    // to converge faster over smaller number of resizing decisions.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -218,8 +218,21 @@</span>
      align = MAX2(align, os::large_page_size());
    }
    return align;
  }
  
<span class="udiff-line-added">+ void ShenandoahArguments::initialize_alignments() {</span>
<span class="udiff-line-added">+   // Need to setup sizes early to get correct alignments.</span>
<span class="udiff-line-added">+   ShenandoahHeapRegion::setup_sizes(MaxHeapSize);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // This is expected by our algorithm for ShenandoahHeap::heap_region_containing().</span>
<span class="udiff-line-added">+   size_t align = ShenandoahHeapRegion::region_size_bytes();</span>
<span class="udiff-line-added">+   if (UseLargePages) {</span>
<span class="udiff-line-added">+     align = MAX2(align, os::large_page_size());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   SpaceAlignment = align;</span>
<span class="udiff-line-added">+   HeapAlignment = align;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  CollectedHeap* ShenandoahArguments::create_heap() {
<span class="udiff-line-modified-removed">-   return create_heap_with_policy&lt;ShenandoahHeap, ShenandoahCollectorPolicy&gt;();</span>
<span class="udiff-line-modified-added">+   return new ShenandoahHeap(new ShenandoahCollectorPolicy());</span>
  }
</pre>
<center><a href="shenandoahAllocTracker.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahArguments.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
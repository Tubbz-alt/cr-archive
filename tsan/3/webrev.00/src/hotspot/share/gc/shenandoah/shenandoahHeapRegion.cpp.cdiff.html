<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,21 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-removed">- #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
<span class="line-new-header">--- 22,22 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-added">+ #include &quot;jfr/jfrEvents.hpp&quot;</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,21 ***</span>
                                             size_t size_words, size_t index, bool committed) :
    _heap(heap),
    _reserved(MemRegion(start, size_words)),
    _region_number(index),
    _new_top(NULL),
<span class="line-removed">-   _critical_pins(0),</span>
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
    _tlab_allocs(0),
    _gclab_allocs(0),
    _shared_allocs(0),
    _seqnum_first_alloc_mutator(0),
    _seqnum_first_alloc_gc(0),
    _seqnum_last_alloc_mutator(0),
    _seqnum_last_alloc_gc(0),
<span class="line-modified">!   _live_data(0) {</span>
  
    ContiguousSpace::initialize(_reserved, true, committed);
  }
  
  size_t ShenandoahHeapRegion::region_number() const {
<span class="line-new-header">--- 59,21 ---</span>
                                             size_t size_words, size_t index, bool committed) :
    _heap(heap),
    _reserved(MemRegion(start, size_words)),
    _region_number(index),
    _new_top(NULL),
    _empty_time(os::elapsedTime()),
    _state(committed ? _empty_committed : _empty_uncommitted),
    _tlab_allocs(0),
    _gclab_allocs(0),
    _shared_allocs(0),
    _seqnum_first_alloc_mutator(0),
    _seqnum_first_alloc_gc(0),
    _seqnum_last_alloc_mutator(0),
    _seqnum_last_alloc_gc(0),
<span class="line-modified">!   _live_data(0),</span>
<span class="line-added">+   _critical_pins(0) {</span>
  
    ContiguousSpace::initialize(_reserved, true, committed);
  }
  
  size_t ShenandoahHeapRegion::region_number() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,11 ***</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!       _state = _regular;</span>
      case _regular:
      case _pinned:
        return;
      default:
        report_illegal_transition(&quot;regular allocation&quot;);
<span class="line-new-header">--- 93,11 ---</span>
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!       set_state(_regular);</span>
      case _regular:
      case _pinned:
        return;
      default:
        report_illegal_transition(&quot;regular allocation&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,14 ***</span>
        do_commit();
      case _empty_committed:
      case _cset:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       _state = _regular;</span>
        return;
      case _pinned_cset:
<span class="line-modified">!       _state = _pinned;</span>
        return;
      case _regular:
      case _pinned:
        return;
      default:
<span class="line-new-header">--- 114,14 ---</span>
        do_commit();
      case _empty_committed:
      case _cset:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       set_state(_regular);</span>
        return;
      case _pinned_cset:
<span class="line-modified">!       set_state(_pinned);</span>
        return;
      case _regular:
      case _pinned:
        return;
      default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,11 ***</span>
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!       _state = _humongous_start;</span>
        return;
      default:
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
<span class="line-new-header">--- 133,11 ---</span>
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!       set_state(_humongous_start);</span>
        return;
      default:
        report_illegal_transition(&quot;humongous start allocation&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,11 ***</span>
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       _state = _humongous_start;</span>
        return;
      default:
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
<span class="line-new-header">--- 149,11 ---</span>
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       set_state(_humongous_start);</span>
        return;
      default:
        report_illegal_transition(&quot;humongous start bypass&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,11 ***</span>
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!       _state = _humongous_cont;</span>
        return;
      default:
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
<span class="line-new-header">--- 162,11 ---</span>
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
      case _empty_committed:
<span class="line-modified">!      set_state(_humongous_cont);</span>
        return;
      default:
        report_illegal_transition(&quot;humongous continuation allocation&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,83 ***</span>
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       _state = _humongous_cont;</span>
        return;
      default:
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _regular:
<span class="line-modified">!       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
<span class="line-removed">-       _state = _pinned;</span>
      case _pinned_cset:
      case _pinned:
<span class="line-removed">-       _critical_pins++;</span>
        return;
      case _humongous_start:
<span class="line-modified">!       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
<span class="line-removed">-       _state = _pinned_humongous_start;</span>
      case _pinned_humongous_start:
<span class="line-removed">-       _critical_pins++;</span>
        return;
      case _cset:
<span class="line-removed">-       guarantee(_heap-&gt;cancelled_gc(), &quot;only valid when evac has been cancelled&quot;);</span>
<span class="line-removed">-       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
        _state = _pinned_cset;
<span class="line-removed">-       _critical_pins++;</span>
        return;
      default:
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _pinned:
<span class="line-modified">!       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">-       _critical_pins--;</span>
<span class="line-removed">-       if (_critical_pins == 0) {</span>
<span class="line-removed">-         _state = _regular;</span>
<span class="line-removed">-       }</span>
        return;
      case _regular:
      case _humongous_start:
<span class="line-removed">-       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
        return;
      case _pinned_cset:
<span class="line-modified">!       guarantee(_heap-&gt;cancelled_gc(), &quot;only valid when evac has been cancelled&quot;);</span>
<span class="line-removed">-       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">-       _critical_pins--;</span>
<span class="line-removed">-       if (_critical_pins == 0) {</span>
<span class="line-removed">-         _state = _cset;</span>
<span class="line-removed">-       }</span>
        return;
      case _pinned_humongous_start:
<span class="line-modified">!       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">-       _critical_pins--;</span>
<span class="line-removed">-       if (_critical_pins == 0) {</span>
<span class="line-removed">-         _state = _humongous_start;</span>
<span class="line-removed">-       }</span>
        return;
      default:
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _regular:
<span class="line-modified">!       _state = _cset;</span>
      case _cset:
        return;
      default:
        report_illegal_transition(&quot;cset&quot;);
    }
<span class="line-new-header">--- 178,66 ---</span>
    switch (_state) {
      case _empty_committed:
      case _regular:
      case _humongous_start:
      case _humongous_cont:
<span class="line-modified">!       set_state(_humongous_cont);</span>
        return;
      default:
        report_illegal_transition(&quot;humongous continuation bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_pinned() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
<span class="line-added">+   assert(pin_count() &gt; 0, &quot;Should have pins: &quot; SIZE_FORMAT, pin_count());</span>
<span class="line-added">+ </span>
    switch (_state) {
      case _regular:
<span class="line-modified">!       set_state(_pinned);</span>
      case _pinned_cset:
      case _pinned:
        return;
      case _humongous_start:
<span class="line-modified">!       set_state(_pinned_humongous_start);</span>
      case _pinned_humongous_start:
        return;
      case _cset:
        _state = _pinned_cset;
        return;
      default:
        report_illegal_transition(&quot;pinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_unpinned() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
<span class="line-added">+   assert(pin_count() == 0, &quot;Should not have pins: &quot; SIZE_FORMAT, pin_count());</span>
<span class="line-added">+ </span>
    switch (_state) {
      case _pinned:
<span class="line-modified">!       set_state(_regular);</span>
        return;
      case _regular:
      case _humongous_start:
        return;
      case _pinned_cset:
<span class="line-modified">!       set_state(_cset);</span>
        return;
      case _pinned_humongous_start:
<span class="line-modified">!       set_state(_humongous_start);</span>
        return;
      default:
        report_illegal_transition(&quot;unpinning&quot;);
    }
  }
  
  void ShenandoahHeapRegion::make_cset() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _regular:
<span class="line-modified">!       set_state(_cset);</span>
      case _cset:
        return;
      default:
        report_illegal_transition(&quot;cset&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,11 ***</span>
      case _humongous_start:
      case _humongous_cont:
        // Reclaiming humongous regions
      case _regular:
        // Immediate region reclaim
<span class="line-modified">!       _state = _trash;</span>
        return;
      default:
        report_illegal_transition(&quot;trashing&quot;);
    }
  }
<span class="line-new-header">--- 251,11 ---</span>
      case _humongous_start:
      case _humongous_cont:
        // Reclaiming humongous regions
      case _regular:
        // Immediate region reclaim
<span class="line-modified">!       set_state(_trash);</span>
        return;
      default:
        report_illegal_transition(&quot;trashing&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,11 ***</span>
  
  void ShenandoahHeapRegion::make_empty() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _trash:
<span class="line-modified">!       _state = _empty_committed;</span>
        _empty_time = os::elapsedTime();
        return;
      default:
        report_illegal_transition(&quot;emptying&quot;);
    }
<span class="line-new-header">--- 270,11 ---</span>
  
  void ShenandoahHeapRegion::make_empty() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _trash:
<span class="line-modified">!       set_state(_empty_committed);</span>
        _empty_time = os::elapsedTime();
        return;
      default:
        report_illegal_transition(&quot;emptying&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,11 ***</span>
  void ShenandoahHeapRegion::make_uncommitted() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_committed:
        do_uncommit();
<span class="line-modified">!       _state = _empty_uncommitted;</span>
        return;
      default:
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
<span class="line-new-header">--- 283,11 ---</span>
  void ShenandoahHeapRegion::make_uncommitted() {
    _heap-&gt;assert_heaplock_owned_by_current_thread();
    switch (_state) {
      case _empty_committed:
        do_uncommit();
<span class="line-modified">!       set_state(_empty_uncommitted);</span>
        return;
      default:
        report_illegal_transition(&quot;uncommiting&quot;);
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,19 ***</span>
    assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
<span class="line-modified">!       _state = _empty_committed;</span>
        return;
      default:
        report_illegal_transition(&quot;commit bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::clear_live_data() {
<span class="line-modified">!   OrderAccess::release_store_fence&lt;size_t&gt;(&amp;_live_data, 0);</span>
  }
  
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
<span class="line-new-header">--- 297,19 ---</span>
    assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);
  
    switch (_state) {
      case _empty_uncommitted:
        do_commit();
<span class="line-modified">!       set_state(_empty_committed);</span>
        return;
      default:
        report_illegal_transition(&quot;commit bypass&quot;);
    }
  }
  
  void ShenandoahHeapRegion::clear_live_data() {
<span class="line-modified">!   Atomic::release_store_fence(&amp;_live_data, (size_t)0);</span>
  }
  
  void ShenandoahHeapRegion::reset_alloc_metadata() {
    _tlab_allocs = 0;
    _gclab_allocs = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,11 ***</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
    _live_data = (s &gt;&gt; LogHeapWordSize);
  }
  
  size_t ShenandoahHeapRegion::get_live_data_words() const {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_live_data);</span>
  }
  
  size_t ShenandoahHeapRegion::get_live_data_bytes() const {
    return get_live_data_words() * HeapWordSize;
  }
<span class="line-new-header">--- 351,11 ---</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
    _live_data = (s &gt;&gt; LogHeapWordSize);
  }
  
  size_t ShenandoahHeapRegion::get_live_data_words() const {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_live_data);</span>
  }
  
  size_t ShenandoahHeapRegion::get_live_data_bytes() const {
    return get_live_data_words() * HeapWordSize;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,11 ***</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
<span class="line-modified">!   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), _critical_pins);</span>
    st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),
              seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),
              seqnum_first_alloc_gc(), seqnum_last_alloc_gc());
    st-&gt;cr();
  }
<span class="line-new-header">--- 417,11 ---</span>
    st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
    st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
    st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
    st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
    st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
<span class="line-modified">!   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), pin_count());</span>
    st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),
              seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),
              seqnum_first_alloc_gc(), seqnum_last_alloc_gc());
    st-&gt;cr();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,25 ***</span>
    }
  }
  
  void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
    assert(! is_humongous(), &quot;no humongous region here&quot;);
<span class="line-modified">!   HeapWord* obj_addr = bottom() + ShenandoahBrooksPointer::word_size();</span>
    HeapWord* t = top();
    // Could call objects iterate, but this is easier.
    while (obj_addr &lt; t) {
      oop obj = oop(obj_addr);
<span class="line-modified">!     obj_addr += obj-&gt;oop_iterate_size(blk) + ShenandoahBrooksPointer::word_size();</span>
    }
  }
  
  void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
    assert(is_humongous(), &quot;only humongous region here&quot;);
    // Find head.
    ShenandoahHeapRegion* r = humongous_start_region();
    assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
<span class="line-modified">!   oop obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
<span class="line-new-header">--- 435,25 ---</span>
    }
  }
  
  void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
    assert(! is_humongous(), &quot;no humongous region here&quot;);
<span class="line-modified">!   HeapWord* obj_addr = bottom();</span>
    HeapWord* t = top();
    // Could call objects iterate, but this is easier.
    while (obj_addr &lt; t) {
      oop obj = oop(obj_addr);
<span class="line-modified">!     obj_addr += obj-&gt;oop_iterate_size(blk);</span>
    }
  }
  
  void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
    assert(is_humongous(), &quot;only humongous region here&quot;);
    // Find head.
    ShenandoahHeapRegion* r = humongous_start_region();
    assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
<span class="line-modified">!   oop obj = oop(r-&gt;bottom());</span>
    obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
  }
  
  ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
    assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 503,55 ***</span>
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
    } else {
<span class="line-modified">!     HeapWord* last = bottom() + ShenandoahBrooksPointer::word_size();</span>
      HeapWord* cur = last;
      while (cur &lt;= p) {
        last = cur;
<span class="line-modified">!       cur += oop(cur)-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
      }
      shenandoah_assert_correct(NULL, oop(last));
      return last;
    }
  }
  
<span class="line-modified">! void ShenandoahHeapRegion::setup_sizes(size_t initial_heap_size, size_t max_heap_size) {</span>
    // Absolute minimums we should not ever break.
    static const size_t MIN_REGION_SIZE = 256*K;
  
    if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
      FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
    }
  
    size_t region_size;
    if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
<span class="line-modified">!     if (ShenandoahMinRegionSize &gt; initial_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">!       err_msg message(&quot;Initial heap size (&quot; SIZE_FORMAT &quot;K) is too low to afford the minimum number &quot;</span>
<span class="line-modified">!                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       initial_heap_size/K, MIN_NUM_REGIONS, ShenandoahMinRegionSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahMinRegionSize/K,  MIN_REGION_SIZE/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &lt; MinTLABSize) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahMinRegionSize/K,  MinTLABSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMaxRegionSize &lt; MIN_REGION_SIZE) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than min region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahMaxRegionSize/K,  MIN_REGION_SIZE/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;K) should be larger than maximum (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahMinRegionSize/K, ShenandoahMaxRegionSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
      }
  
      // We rapidly expand to max_heap_size in most scenarios, so that is the measure
      // for usual heap sizes. Do not depend on initial_heap_size here.
<span class="line-new-header">--- 488,61 ---</span>
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
    if (p &gt;= top()) {
      return top();
    } else {
<span class="line-modified">!     HeapWord* last = bottom();</span>
      HeapWord* cur = last;
      while (cur &lt;= p) {
        last = cur;
<span class="line-modified">!       cur += oop(cur)-&gt;size();</span>
      }
      shenandoah_assert_correct(NULL, oop(last));
      return last;
    }
  }
  
<span class="line-modified">! void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {</span>
    // Absolute minimums we should not ever break.
    static const size_t MIN_REGION_SIZE = 256*K;
  
    if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
      FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
    }
  
    size_t region_size;
    if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
<span class="line-modified">!     if (ShenandoahMinRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">!       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;</span>
<span class="line-modified">!                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),</span>
<span class="line-added">+                       MIN_NUM_REGIONS,</span>
<span class="line-added">+                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &lt; MinTLABSize) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(MinTLABSize),             proper_unit_for_byte_size(MinTLABSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
      }
      if (ShenandoahMaxRegionSize &lt; MIN_REGION_SIZE) {
<span class="line-modified">!       err_msg message(&quot;&quot; SIZE_FORMAT &quot;%s should not be lower than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(MIN_REGION_SIZE),         proper_unit_for_byte_size(MIN_REGION_SIZE));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
      }
      if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;%s) should be larger than maximum (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahMinRegionSize), proper_unit_for_byte_size(ShenandoahMinRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(ShenandoahMaxRegionSize), proper_unit_for_byte_size(ShenandoahMaxRegionSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
      }
  
      // We rapidly expand to max_heap_size in most scenarios, so that is the measure
      // for usual heap sizes. Do not depend on initial_heap_size here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,24 ***</span>
      // Now make sure that we don&#39;t go over or under our limits.
      region_size = MAX2(ShenandoahMinRegionSize, region_size);
      region_size = MIN2(ShenandoahMaxRegionSize, region_size);
  
    } else {
<span class="line-modified">!     if (ShenandoahHeapRegionSize &gt; initial_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">!       err_msg message(&quot;Initial heap size (&quot; SIZE_FORMAT &quot;K) is too low to afford the minimum number &quot;</span>
<span class="line-modified">!                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       initial_heap_size/K, MIN_NUM_REGIONS, ShenandoahHeapRegionSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;K) should be larger than min region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahHeapRegionSize/K, ShenandoahMinRegionSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;K) should be lower than max region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">!                       ShenandoahHeapRegionSize/K, ShenandoahMaxRegionSize/K);</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      region_size = ShenandoahHeapRegionSize;
    }
  
<span class="line-new-header">--- 551,28 ---</span>
      // Now make sure that we don&#39;t go over or under our limits.
      region_size = MAX2(ShenandoahMinRegionSize, region_size);
      region_size = MIN2(ShenandoahMaxRegionSize, region_size);
  
    } else {
<span class="line-modified">!     if (ShenandoahHeapRegionSize &gt; max_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">!       err_msg message(&quot;Max heap size (&quot; SIZE_FORMAT &quot;%s) is too low to afford the minimum number &quot;</span>
<span class="line-modified">!                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),</span>
<span class="line-added">+                       MIN_NUM_REGIONS,</span>
<span class="line-added">+                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be larger than min region size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {
<span class="line-modified">!       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;%s) should be lower than max region size (&quot; SIZE_FORMAT &quot;%s).&quot;,</span>
<span class="line-modified">!                       byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),</span>
<span class="line-added">+                       byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));</span>
        vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
      }
      region_size = ShenandoahHeapRegionSize;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 617,10 ***</span>
<span class="line-new-header">--- 612,11 ---</span>
    RegionCount = max_heap_size / RegionSizeBytes;
    guarantee(RegionCount &gt;= MIN_NUM_REGIONS, &quot;Should have at least minimum regions&quot;);
  
    guarantee(HumongousThresholdWords == 0, &quot;we should only set it once&quot;);
    HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold / 100;
<span class="line-added">+   HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);</span>
    assert (HumongousThresholdWords &lt;= RegionSizeWords, &quot;sanity&quot;);
  
    guarantee(HumongousThresholdBytes == 0, &quot;we should only set it once&quot;);
    HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;
    assert (HumongousThresholdBytes &lt;= RegionSizeBytes, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,17 ***</span>
    // &quot;used&quot; - &quot;live&quot; for cset selection. Otherwise, we can get the fragmented region
    // below the garbage threshold that would never be considered for collection.
    //
    // The whole thing is mitigated if Elastic TLABs are enabled.
    //
    guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
<span class="line-modified">!   MaxTLABSizeBytes = MIN2(ShenandoahElasticTLAB ? RegionSizeBytes : (RegionSizeBytes / 8), HumongousThresholdBytes);</span>
    assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
  
<span class="line-removed">-   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);</span>
<span class="line-removed">-   MaxTLABSizeWords = MaxTLABSizeBytes / HeapWordSize;</span>
<span class="line-removed">- </span>
    log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
                       RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
    log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
<span class="line-new-header">--- 637,18 ---</span>
    // &quot;used&quot; - &quot;live&quot; for cset selection. Otherwise, we can get the fragmented region
    // below the garbage threshold that would never be considered for collection.
    //
    // The whole thing is mitigated if Elastic TLABs are enabled.
    //
<span class="line-added">+   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);</span>
<span class="line-added">+   MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);</span>
<span class="line-added">+   MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);</span>
<span class="line-added">+ </span>
    guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
<span class="line-modified">!   MaxTLABSizeBytes = MaxTLABSizeWords * HeapWordSize;</span>
    assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
  
    log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
                       RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
    log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
                       byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
    log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,5 ***</span>
<span class="line-new-header">--- 672,31 ---</span>
    if (!_heap-&gt;uncommit_bitmap_slice(this)) {
      report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
    }
    _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());
  }
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeapRegion::set_state(RegionState to) {</span>
<span class="line-added">+   EventShenandoahHeapRegionStateChange evt;</span>
<span class="line-added">+   if (evt.should_commit()){</span>
<span class="line-added">+     evt.set_index((unsigned)region_number());</span>
<span class="line-added">+     evt.set_start((uintptr_t)bottom());</span>
<span class="line-added">+     evt.set_used(used());</span>
<span class="line-added">+     evt.set_from(_state);</span>
<span class="line-added">+     evt.set_to(to);</span>
<span class="line-added">+     evt.commit();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _state = to;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeapRegion::record_pin() {</span>
<span class="line-added">+   Atomic::add(&amp;_critical_pins, (size_t)1);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeapRegion::record_unpin() {</span>
<span class="line-added">+   assert(pin_count() &gt; 0, &quot;Region &quot; SIZE_FORMAT &quot; should have non-zero pins&quot;, region_number());</span>
<span class="line-added">+   Atomic::sub(&amp;_critical_pins, (size_t)1);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ShenandoahHeapRegion::pin_count() const {</span>
<span class="line-added">+   return Atomic::load(&amp;_critical_pins);</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="shenandoahHeap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
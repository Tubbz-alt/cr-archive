<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;gc/shared/barrierSet.hpp&quot;
  26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  30 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  31 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  32 #include &quot;opto/arraycopynode.hpp&quot;
  33 #include &quot;opto/escape.hpp&quot;
  34 #include &quot;opto/graphKit.hpp&quot;
  35 #include &quot;opto/idealKit.hpp&quot;
  36 #include &quot;opto/macro.hpp&quot;
  37 #include &quot;opto/movenode.hpp&quot;
  38 #include &quot;opto/narrowptrnode.hpp&quot;
  39 #include &quot;opto/rootnode.hpp&quot;
  40 
  41 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  42   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  43 }
  44 
  45 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
  46   : _shenandoah_barriers(new (comp_arena) GrowableArray&lt;ShenandoahWriteBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {
  47 }
  48 
  49 int ShenandoahBarrierSetC2State::shenandoah_barriers_count() const {
  50   return _shenandoah_barriers-&gt;length();
  51 }
  52 
  53 ShenandoahWriteBarrierNode* ShenandoahBarrierSetC2State::shenandoah_barrier(int idx) const {
  54   return _shenandoah_barriers-&gt;at(idx);
  55 }
  56 
  57 void ShenandoahBarrierSetC2State::add_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {
  58   assert(!_shenandoah_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);
  59   _shenandoah_barriers-&gt;append(n);
  60 }
  61 
  62 void ShenandoahBarrierSetC2State::remove_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {
  63   if (_shenandoah_barriers-&gt;contains(n)) {
  64     _shenandoah_barriers-&gt;remove(n);
  65   }
  66 }
  67 
  68 #define __ kit-&gt;
  69 
  70 Node* ShenandoahBarrierSetC2::shenandoah_read_barrier(GraphKit* kit, Node* obj) const {
  71   if (ShenandoahReadBarrier) {
  72     obj = shenandoah_read_barrier_impl(kit, obj, false, true, true);
  73   }
  74   return obj;
  75 }
  76 
  77 Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {
  78   if (ShenandoahStoreValEnqueueBarrier) {
  79     obj = shenandoah_write_barrier(kit, obj);
  80     obj = shenandoah_enqueue_barrier(kit, obj);
  81   }
  82   if (ShenandoahStoreValReadBarrier) {
  83     obj = shenandoah_read_barrier_impl(kit, obj, true, false, false);
  84   }
  85   return obj;
  86 }
  87 
  88 Node* ShenandoahBarrierSetC2::shenandoah_read_barrier_impl(GraphKit* kit, Node* obj, bool use_ctrl, bool use_mem, bool allow_fromspace) const {
  89   const Type* obj_type = obj-&gt;bottom_type();
  90   if (obj_type-&gt;higher_equal(TypePtr::NULL_PTR)) {
  91     return obj;
  92   }
  93   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);
  94   Node* mem = use_mem ? __ memory(adr_type) : __ immutable_memory();
  95 
  96   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, mem, allow_fromspace)) {
  97     // We know it is null, no barrier needed.
  98     return obj;
  99   }
 100 
 101   if (obj_type-&gt;meet(TypePtr::NULL_PTR) == obj_type-&gt;remove_speculative()) {
 102 
 103     // We don&#39;t know if it&#39;s null or not. Need null-check.
 104     enum { _not_null_path = 1, _null_path, PATH_LIMIT };
 105     RegionNode* region = new RegionNode(PATH_LIMIT);
 106     Node*       phi    = new PhiNode(region, obj_type);
 107     Node* null_ctrl = __ top();
 108     Node* not_null_obj = __ null_check_oop(obj, &amp;null_ctrl);
 109 
 110     region-&gt;init_req(_null_path, null_ctrl);
 111     phi   -&gt;init_req(_null_path, __ zerocon(T_OBJECT));
 112 
 113     Node* ctrl = use_ctrl ? __ control() : NULL;
 114     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, not_null_obj, allow_fromspace);
 115     Node* n = __ gvn().transform(rb);
 116 
 117     region-&gt;init_req(_not_null_path, __ control());
 118     phi   -&gt;init_req(_not_null_path, n);
 119 
 120     __ set_control(__ gvn().transform(region));
 121     __ record_for_igvn(region);
 122     return __ gvn().transform(phi);
 123 
 124   } else {
 125     // We know it is not null. Simple barrier is sufficient.
 126     Node* ctrl = use_ctrl ? __ control() : NULL;
 127     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, obj, allow_fromspace);
 128     Node* n = __ gvn().transform(rb);
 129     __ record_for_igvn(n);
 130     return n;
 131   }
 132 }
 133 
 134 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_helper(GraphKit* kit, Node* obj, const TypePtr* adr_type) const {
 135   ShenandoahWriteBarrierNode* wb = new ShenandoahWriteBarrierNode(kit-&gt;C, kit-&gt;control(), kit-&gt;memory(adr_type), obj);
 136   Node* n = __ gvn().transform(wb);
 137   if (n == wb) { // New barrier needs memory projection.
 138     Node* proj = __ gvn().transform(new ShenandoahWBMemProjNode(n));
 139     __ set_memory(proj, adr_type);
 140   }
 141   return n;
 142 }
 143 
 144 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier(GraphKit* kit, Node* obj) const {
 145   if (ShenandoahWriteBarrier) {
 146     obj = shenandoah_write_barrier_impl(kit, obj);
 147   }
 148   return obj;
 149 }
 150 
 151 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_impl(GraphKit* kit, Node* obj) const {
 152   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, NULL, true)) {
 153     return obj;
 154   }
 155   const Type* obj_type = obj-&gt;bottom_type();
 156   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);
 157   Node* n = shenandoah_write_barrier_helper(kit, obj, adr_type);
 158   __ record_for_igvn(n);
 159   return n;
 160 }
 161 
 162 bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
 163                                                          BasicType bt, uint adr_idx) const {
 164   intptr_t offset = 0;
 165   Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 166   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);
 167 
 168   if (offset == Type::OffsetBot) {
 169     return false; // cannot unalias unless there are precise offsets
 170   }
 171 
 172   if (alloc == NULL) {
 173     return false; // No allocation found
 174   }
 175 
 176   intptr_t size_in_bytes = type2aelembytes(bt);
 177 
 178   Node* mem = __ memory(adr_idx); // start searching here...
 179 
 180   for (int cnt = 0; cnt &lt; 50; cnt++) {
 181 
 182     if (mem-&gt;is_Store()) {
 183 
 184       Node* st_adr = mem-&gt;in(MemNode::Address);
 185       intptr_t st_offset = 0;
 186       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 187 
 188       if (st_base == NULL) {
 189         break; // inscrutable pointer
 190       }
 191 
 192       // Break we have found a store with same base and offset as ours so break
 193       if (st_base == base &amp;&amp; st_offset == offset) {
 194         break;
 195       }
 196 
 197       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 198         const int MAX_STORE = BytesPerLong;
 199         if (st_offset &gt;= offset + size_in_bytes ||
 200             st_offset &lt;= offset - MAX_STORE ||
 201             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 202           // Success:  The offsets are provably independent.
 203           // (You may ask, why not just test st_offset != offset and be done?
 204           // The answer is that stores of different sizes can co-exist
 205           // in the same sequence of RawMem effects.  We sometimes initialize
 206           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 207           mem = mem-&gt;in(MemNode::Memory);
 208           continue; // advance through independent store memory
 209         }
 210       }
 211 
 212       if (st_base != base
 213           &amp;&amp; MemNode::detect_ptr_independence(base, alloc, st_base,
 214                                               AllocateNode::Ideal_allocation(st_base, phase),
 215                                               phase)) {
 216         // Success:  The bases are provably independent.
 217         mem = mem-&gt;in(MemNode::Memory);
 218         continue; // advance through independent store memory
 219       }
 220     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 221 
 222       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 223       AllocateNode* st_alloc = st_init-&gt;allocation();
 224 
 225       // Make sure that we are looking at the same allocation site.
 226       // The alloc variable is guaranteed to not be null here from earlier check.
 227       if (alloc == st_alloc) {
 228         // Check that the initialization is storing NULL so that no previous store
 229         // has been moved up and directly write a reference
 230         Node* captured_store = st_init-&gt;find_captured_store(offset,
 231                                                             type2aelembytes(T_OBJECT),
 232                                                             phase);
 233         if (captured_store == NULL || captured_store == st_init-&gt;zero_memory()) {
 234           return true;
 235         }
 236       }
 237     }
 238 
 239     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 240     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 241     break;
 242   }
 243 
 244   return false;
 245 }
 246 
 247 #undef __
 248 #define __ ideal.
 249 
 250 void ShenandoahBarrierSetC2::satb_write_barrier_pre(GraphKit* kit,
 251                                                     bool do_load,
 252                                                     Node* obj,
 253                                                     Node* adr,
 254                                                     uint alias_idx,
 255                                                     Node* val,
 256                                                     const TypeOopPtr* val_type,
 257                                                     Node* pre_val,
 258                                                     BasicType bt) const {
 259   // Some sanity checks
 260   // Note: val is unused in this routine.
 261 
 262   if (do_load) {
 263     // We need to generate the load of the previous value
 264     assert(obj != NULL, &quot;must have a base&quot;);
 265     assert(adr != NULL, &quot;where are loading from?&quot;);
 266     assert(pre_val == NULL, &quot;loaded already?&quot;);
 267     assert(val_type != NULL, &quot;need a type&quot;);
 268 
 269     if (ReduceInitialCardMarks
 270         &amp;&amp; satb_can_remove_pre_barrier(kit, &amp;kit-&gt;gvn(), adr, bt, alias_idx)) {
 271       return;
 272     }
 273 
 274   } else {
 275     // In this case both val_type and alias_idx are unused.
 276     assert(pre_val != NULL, &quot;must be loaded already&quot;);
 277     // Nothing to be done if pre_val is null.
 278     if (pre_val-&gt;bottom_type() == TypePtr::NULL_PTR) return;
 279     assert(pre_val-&gt;bottom_type()-&gt;basic_type() == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 280   }
 281   assert(bt == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 282 
 283   IdealKit ideal(kit, true);
 284 
 285   Node* tls = __ thread(); // ThreadLocalStorage
 286 
 287   Node* no_base = __ top();
 288   Node* zero  = __ ConI(0);
 289   Node* zeroX = __ ConX(0);
 290 
 291   float likely  = PROB_LIKELY(0.999);
 292   float unlikely  = PROB_UNLIKELY(0.999);
 293 
 294   // Offsets into the thread
 295   const int index_offset   = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
 296   const int buffer_offset  = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
 297 
 298   // Now the actual pointers into the thread
 299   Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));
 300   Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));
 301 
 302   // Now some of the values
 303   Node* marking;
 304   Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
 305   Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
 306   marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
 307   assert(ShenandoahWriteBarrierNode::is_gc_state_load(ld), &quot;Should match the shape&quot;);
 308 
 309   // if (!marking)
 310   __ if_then(marking, BoolTest::ne, zero, unlikely); {
 311     BasicType index_bt = TypeX_X-&gt;basic_type();
 312     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
 313     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
 314 
 315     if (do_load) {
 316       // load original value
 317       // alias_idx correct??
 318       pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
 319     }
 320 
 321     // if (pre_val != NULL)
 322     __ if_then(pre_val, BoolTest::ne, kit-&gt;null()); {
 323       Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);
 324 
 325       // is the queue for this thread full?
 326       __ if_then(index, BoolTest::ne, zeroX, likely); {
 327 
 328         // decrement the index
 329         Node* next_index = kit-&gt;gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));
 330 
 331         // Now get the buffer location we will log the previous value into and store it
 332         Node *log_addr = __ AddP(no_base, buffer, next_index);
 333         __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);
 334         // update the index
 335         __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);
 336 
 337       } __ else_(); {
 338 
 339         // logging buffer is full, call the runtime
 340         const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();
 341         __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, pre_val, tls);
 342       } __ end_if();  // (!index)
 343     } __ end_if();  // (pre_val != NULL)
 344   } __ end_if();  // (!marking)
 345 
 346   // Final sync IdealKit and GraphKit.
 347   kit-&gt;final_sync(ideal);
 348 
 349   if (ShenandoahSATBBarrier &amp;&amp; adr != NULL) {
 350     Node* c = kit-&gt;control();
 351     Node* call = c-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(0);
 352     assert(is_shenandoah_wb_pre_call(call), &quot;shenandoah_wb_pre call expected&quot;);
 353     call-&gt;add_req(adr);
 354   }
 355 }
 356 
 357 bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
 358   return call-&gt;is_CallLeaf() &amp;&amp;
 359          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
 360 }
 361 
 362 bool ShenandoahBarrierSetC2::is_shenandoah_wb_call(Node* call) {
 363   return call-&gt;is_CallLeaf() &amp;&amp;
 364          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT);
 365 }
 366 
 367 bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
 368   if (n-&gt;Opcode() != Op_If) {
 369     return false;
 370   }
 371 
 372   Node* bol = n-&gt;in(1);
 373   assert(bol-&gt;is_Bool(), &quot;&quot;);
 374   Node* cmpx = bol-&gt;in(1);
 375   if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 376       cmpx-&gt;is_Cmp() &amp;&amp; cmpx-&gt;in(2) == phase-&gt;intcon(0) &amp;&amp;
 377       is_shenandoah_state_load(cmpx-&gt;in(1)-&gt;in(1)) &amp;&amp;
 378       cmpx-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp;
 379       cmpx-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(ShenandoahHeap::MARKING)) {
 380     return true;
 381   }
 382 
 383   return false;
 384 }
 385 
 386 bool ShenandoahBarrierSetC2::is_shenandoah_state_load(Node* n) {
 387   if (!n-&gt;is_Load()) return false;
 388   const int state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());
 389   return n-&gt;in(2)-&gt;is_AddP() &amp;&amp; n-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
 390          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;is_Con()
 391          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == state_offset;
 392 }
 393 
 394 void ShenandoahBarrierSetC2::shenandoah_write_barrier_pre(GraphKit* kit,
 395                                                           bool do_load,
 396                                                           Node* obj,
 397                                                           Node* adr,
 398                                                           uint alias_idx,
 399                                                           Node* val,
 400                                                           const TypeOopPtr* val_type,
 401                                                           Node* pre_val,
 402                                                           BasicType bt) const {
 403   if (ShenandoahSATBBarrier) {
 404     IdealKit ideal(kit);
 405     kit-&gt;sync_kit(ideal);
 406 
 407     satb_write_barrier_pre(kit, do_load, obj, adr, alias_idx, val, val_type, pre_val, bt);
 408 
 409     ideal.sync_kit(kit);
 410     kit-&gt;final_sync(ideal);
 411   }
 412 }
 413 
 414 Node* ShenandoahBarrierSetC2::shenandoah_enqueue_barrier(GraphKit* kit, Node* pre_val) const {
 415   return kit-&gt;gvn().transform(new ShenandoahEnqueueBarrierNode(pre_val));
 416 }
 417 
 418 // Helper that guards and inserts a pre-barrier.
 419 void ShenandoahBarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,
 420                                                 Node* pre_val, bool need_mem_bar) const {
 421   // We could be accessing the referent field of a reference object. If so, when G1
 422   // is enabled, we need to log the value in the referent field in an SATB buffer.
 423   // This routine performs some compile time filters and generates suitable
 424   // runtime filters that guard the pre-barrier code.
 425   // Also add memory barrier for non volatile load from the referent field
 426   // to prevent commoning of loads across safepoint.
 427 
 428   // Some compile time checks.
 429 
 430   // If offset is a constant, is it java_lang_ref_Reference::_reference_offset?
 431   const TypeX* otype = offset-&gt;find_intptr_t_type();
 432   if (otype != NULL &amp;&amp; otype-&gt;is_con() &amp;&amp;
 433       otype-&gt;get_con() != java_lang_ref_Reference::referent_offset) {
 434     // Constant offset but not the reference_offset so just return
 435     return;
 436   }
 437 
 438   // We only need to generate the runtime guards for instances.
 439   const TypeOopPtr* btype = base_oop-&gt;bottom_type()-&gt;isa_oopptr();
 440   if (btype != NULL) {
 441     if (btype-&gt;isa_aryptr()) {
 442       // Array type so nothing to do
 443       return;
 444     }
 445 
 446     const TypeInstPtr* itype = btype-&gt;isa_instptr();
 447     if (itype != NULL) {
 448       // Can the klass of base_oop be statically determined to be
 449       // _not_ a sub-class of Reference and _not_ Object?
 450       ciKlass* klass = itype-&gt;klass();
 451       if ( klass-&gt;is_loaded() &amp;&amp;
 452           !klass-&gt;is_subtype_of(kit-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 453           !kit-&gt;env()-&gt;Object_klass()-&gt;is_subtype_of(klass)) {
 454         return;
 455       }
 456     }
 457   }
 458 
 459   // The compile time filters did not reject base_oop/offset so
 460   // we need to generate the following runtime filters
 461   //
 462   // if (offset == java_lang_ref_Reference::_reference_offset) {
 463   //   if (instance_of(base, java.lang.ref.Reference)) {
 464   //     pre_barrier(_, pre_val, ...);
 465   //   }
 466   // }
 467 
 468   float likely   = PROB_LIKELY(  0.999);
 469   float unlikely = PROB_UNLIKELY(0.999);
 470 
 471   IdealKit ideal(kit);
 472 
 473   Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset);
 474 
 475   __ if_then(offset, BoolTest::eq, referent_off, unlikely); {
 476       // Update graphKit memory and control from IdealKit.
 477       kit-&gt;sync_kit(ideal);
 478 
 479       Node* ref_klass_con = kit-&gt;makecon(TypeKlassPtr::make(kit-&gt;env()-&gt;Reference_klass()));
 480       Node* is_instof = kit-&gt;gen_instanceof(base_oop, ref_klass_con);
 481 
 482       // Update IdealKit memory and control from graphKit.
 483       __ sync_kit(kit);
 484 
 485       Node* one = __ ConI(1);
 486       // is_instof == 0 if base_oop == NULL
 487       __ if_then(is_instof, BoolTest::eq, one, unlikely); {
 488 
 489         // Update graphKit from IdeakKit.
 490         kit-&gt;sync_kit(ideal);
 491 
 492         // Use the pre-barrier to record the value in the referent field
 493         satb_write_barrier_pre(kit, false /* do_load */,
 494                                NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 495                                pre_val /* pre_val */,
 496                                T_OBJECT);
 497         if (need_mem_bar) {
 498           // Add memory barrier to prevent commoning reads from this field
 499           // across safepoint since GC can change its value.
 500           kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 501         }
 502         // Update IdealKit from graphKit.
 503         __ sync_kit(kit);
 504 
 505       } __ end_if(); // _ref_type != ref_none
 506   } __ end_if(); // offset == referent_offset
 507 
 508   // Final sync IdealKit and GraphKit.
 509   kit-&gt;final_sync(ideal);
 510 }
 511 
 512 #undef __
 513 
 514 const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {
 515   const Type **fields = TypeTuple::fields(2);
 516   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 517   fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
 518   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 519 
 520   // create result type (range)
 521   fields = TypeTuple::fields(0);
 522   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 523 
 524   return TypeFunc::make(domain, range);
 525 }
 526 
 527 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 528   const Type **fields = TypeTuple::fields(1);
 529   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 530   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 531 
 532   // create result type (range)
 533   fields = TypeTuple::fields(0);
 534   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 535 
 536   return TypeFunc::make(domain, range);
 537 }
 538 
 539 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_write_barrier_Type() {
 540   const Type **fields = TypeTuple::fields(1);
 541   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 542   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 543 
 544   // create result type (range)
 545   fields = TypeTuple::fields(1);
 546   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
 547   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 548 
 549   return TypeFunc::make(domain, range);
 550 }
 551 
 552 void ShenandoahBarrierSetC2::resolve_address(C2Access&amp; access) const {
 553   const TypePtr* adr_type = access.addr().type();
 554 
 555   if ((access.decorators() &amp; IN_NATIVE) == 0 &amp;&amp; (adr_type-&gt;isa_instptr() || adr_type-&gt;isa_aryptr())) {
 556     int off = adr_type-&gt;is_ptr()-&gt;offset();
 557     int base_off = adr_type-&gt;isa_instptr() ? instanceOopDesc::base_offset_in_bytes() :
 558       arrayOopDesc::base_offset_in_bytes(adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type());
 559     assert(off != Type::OffsetTop, &quot;unexpected offset&quot;);
 560     if (off == Type::OffsetBot || off &gt;= base_off) {
 561       DecoratorSet decorators = access.decorators();
 562       bool is_write = (decorators &amp; C2_WRITE_ACCESS) != 0;
 563       GraphKit* kit = NULL;
 564       if (access.is_parse_access()) {
 565         C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 566         kit = parse_access.kit();
 567       }
 568       Node* adr = access.addr().node();
 569       assert(adr-&gt;is_AddP(), &quot;unexpected address shape&quot;);
 570       Node* base = adr-&gt;in(AddPNode::Base);
 571 
 572       if (is_write) {
 573         if (kit != NULL) {
 574           base = shenandoah_write_barrier(kit, base);
 575         } else {
 576           assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
 577           assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for clone&quot;);
 578         }
 579       } else {
 580         if (adr_type-&gt;isa_instptr()) {
 581           Compile* C = access.gvn().C;
 582           ciField* field = C-&gt;alias_type(adr_type)-&gt;field();
 583 
 584           // Insert read barrier for Shenandoah.
 585           if (field != NULL &amp;&amp;
 586               ((ShenandoahOptimizeStaticFinals   &amp;&amp; field-&gt;is_static()  &amp;&amp; field-&gt;is_final()) ||
 587                (ShenandoahOptimizeInstanceFinals &amp;&amp; !field-&gt;is_static() &amp;&amp; field-&gt;is_final()) ||
 588                (ShenandoahOptimizeStableFinals   &amp;&amp; field-&gt;is_stable()))) {
 589             // Skip the barrier for special fields
 590           } else {
 591             if (kit != NULL) {
 592               base = shenandoah_read_barrier(kit, base);
 593             } else {
 594               assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
 595               assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);
 596             }
 597           }
 598         } else {
 599           if (kit != NULL) {
 600             base = shenandoah_read_barrier(kit, base);
 601           } else {
 602             assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
 603             assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);
 604           }
 605         }
 606       }
 607       if (base != adr-&gt;in(AddPNode::Base)) {
 608         assert(kit != NULL, &quot;no barrier should have been added&quot;);
 609 
 610         Node* address = adr-&gt;in(AddPNode::Address);
 611 
 612         if (address-&gt;is_AddP()) {
 613           assert(address-&gt;in(AddPNode::Base) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);
 614           assert(!address-&gt;in(AddPNode::Address)-&gt;is_AddP(), &quot;unexpected address shape&quot;);
 615           assert(address-&gt;in(AddPNode::Address) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);
 616           address = address-&gt;clone();
 617           address-&gt;set_req(AddPNode::Base, base);
 618           address-&gt;set_req(AddPNode::Address, base);
 619           address = kit-&gt;gvn().transform(address);
 620         } else {
 621           assert(address == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);
 622           address = base;
 623         }
 624         adr = adr-&gt;clone();
 625         adr-&gt;set_req(AddPNode::Base, base);
 626         adr-&gt;set_req(AddPNode::Address, address);
 627         adr = kit-&gt;gvn().transform(adr);
 628         access.addr().set_node(adr);
 629       }
 630     }
 631   }
 632 }
 633 
 634 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 635   DecoratorSet decorators = access.decorators();
 636 
 637   const TypePtr* adr_type = access.addr().type();
 638   Node* adr = access.addr().node();
 639 
 640   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 641   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 642 
 643   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 644     return BarrierSetC2::store_at_resolved(access, val);
 645   }
 646 
 647   if (access.is_parse_access()) {
 648     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 649     GraphKit* kit = parse_access.kit();
 650 
 651     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 652     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 653     Node* value = val.node();
 654     value = shenandoah_storeval_barrier(kit, value);
 655     val.set_node(value);
 656     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 657                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 658   } else {
 659     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 660     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 661     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 662     PhaseGVN&amp; gvn =  opt_access.gvn();
 663     MergeMemNode* mm = opt_access.mem();
 664 
 665     if (ShenandoahStoreValReadBarrier) {
 666       RegionNode* region = new RegionNode(3);
 667       const Type* v_t = gvn.type(val.node());
 668       Node* phi = new PhiNode(region, v_t-&gt;isa_oopptr() ? v_t-&gt;is_oopptr()-&gt;cast_to_nonconst() : v_t);
 669       Node* cmp = gvn.transform(new CmpPNode(val.node(), gvn.zerocon(T_OBJECT)));
 670       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::ne));
 671       IfNode* iff = new IfNode(opt_access.ctl(), bol, PROB_LIKELY_MAG(3), COUNT_UNKNOWN);
 672 
 673       gvn.transform(iff);
 674       if (gvn.is_IterGVN()) {
 675         gvn.is_IterGVN()-&gt;_worklist.push(iff);
 676       } else {
 677         gvn.record_for_igvn(iff);
 678       }
 679 
 680       Node* null_true = gvn.transform(new IfFalseNode(iff));
 681       Node* null_false = gvn.transform(new IfTrueNode(iff));
 682       region-&gt;init_req(1, null_true);
 683       region-&gt;init_req(2, null_false);
 684       phi-&gt;init_req(1, gvn.zerocon(T_OBJECT));
 685       Node* cast = new CastPPNode(val.node(), gvn.type(val.node())-&gt;join_speculative(TypePtr::NOTNULL));
 686       cast-&gt;set_req(0, null_false);
 687       cast = gvn.transform(cast);
 688       Node* rb = gvn.transform(new ShenandoahReadBarrierNode(null_false, gvn.C-&gt;immutable_memory(), cast, false));
 689       phi-&gt;init_req(2, rb);
 690       opt_access.set_ctl(gvn.transform(region));
 691       val.set_node(gvn.transform(phi));
 692     }
 693     if (ShenandoahStoreValEnqueueBarrier) {
 694       const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(gvn.type(val.node()));
 695       int alias = gvn.C-&gt;get_alias_index(adr_type);
 696       Node* wb = new ShenandoahWriteBarrierNode(gvn.C, opt_access.ctl(), mm-&gt;memory_at(alias), val.node());
 697       Node* wb_transformed = gvn.transform(wb);
 698       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(wb_transformed));
 699       if (wb_transformed == wb) {
 700         Node* proj = gvn.transform(new ShenandoahWBMemProjNode(wb));
 701         mm-&gt;set_memory_at(alias, proj);
 702       }
 703       val.set_node(enqueue);
 704     }
 705   }
 706   return BarrierSetC2::store_at_resolved(access, val);
 707 }
 708 
 709 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
 710   DecoratorSet decorators = access.decorators();
 711 
 712   Node* adr = access.addr().node();
 713   Node* obj = access.base();
 714 
 715   bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
 716   bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 717   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 718   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;
 719   bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;
 720   bool need_cpu_mem_bar = !is_unordered || mismatched || !on_heap;
 721 
 722   Node* top = Compile::current()-&gt;top();
 723 
 724   Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;
 725   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
 726 
 727   // If we are reading the value of the referent field of a Reference
 728   // object (either by using Unsafe directly or through reflection)
 729   // then, if SATB is enabled, we need to record the referent in an
 730   // SATB log buffer using the pre-barrier mechanism.
 731   // Also we need to add memory barrier to prevent commoning reads
 732   // from this field across safepoint since GC can change its value.
 733   bool need_read_barrier = ShenandoahKeepAliveBarrier &amp;&amp;
 734     (on_heap &amp;&amp; (on_weak || (unknown &amp;&amp; offset != top &amp;&amp; obj != top)));
 735 
 736   if (!access.is_oop() || !need_read_barrier) {
 737     return load;
 738   }
 739 
 740   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);
 741   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 742   GraphKit* kit = parse_access.kit();
 743 
 744   if (on_weak) {
 745     // Use the pre-barrier to record the value in the referent field
 746     satb_write_barrier_pre(kit, false /* do_load */,
 747                            NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 748                            load /* pre_val */, T_OBJECT);
 749     // Add memory barrier to prevent commoning reads from this field
 750     // across safepoint since GC can change its value.
 751     kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 752   } else if (unknown) {
 753     // We do not require a mem bar inside pre_barrier if need_mem_bar
 754     // is set: the barriers would be emitted by us.
 755     insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);
 756   }
 757 
 758   return load;
 759 }
 760 
 761 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 762                                                    Node* new_val, const Type* value_type) const {
 763   GraphKit* kit = access.kit();
 764   if (access.is_oop()) {
 765     new_val = shenandoah_storeval_barrier(kit, new_val);
 766     shenandoah_write_barrier_pre(kit, false /* do_load */,
 767                                  NULL, NULL, max_juint, NULL, NULL,
 768                                  expected_val /* pre_val */, T_OBJECT);
 769 
 770     MemNode::MemOrd mo = access.mem_node_mo();
 771     Node* mem = access.memory();
 772     Node* adr = access.addr().node();
 773     const TypePtr* adr_type = access.addr().type();
 774     Node* load_store = NULL;
 775 
 776 #ifdef _LP64
 777     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 778       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 779       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 780       if (ShenandoahCASBarrier) {
 781         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 782       } else {
 783         load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 784       }
 785     } else
 786 #endif
 787     {
 788       if (ShenandoahCASBarrier) {
 789         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 790       } else {
 791         load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 792       }
 793     }
 794 
 795     access.set_raw_access(load_store);
 796     pin_atomic_op(access);
 797 
 798 #ifdef _LP64
 799     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 800       return kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));
 801     }
 802 #endif
 803     return load_store;
 804   }
 805   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
 806 }
 807 
 808 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 809                                                               Node* new_val, const Type* value_type) const {
 810   GraphKit* kit = access.kit();
 811   if (access.is_oop()) {
 812     new_val = shenandoah_storeval_barrier(kit, new_val);
 813     shenandoah_write_barrier_pre(kit, false /* do_load */,
 814                                  NULL, NULL, max_juint, NULL, NULL,
 815                                  expected_val /* pre_val */, T_OBJECT);
 816     DecoratorSet decorators = access.decorators();
 817     MemNode::MemOrd mo = access.mem_node_mo();
 818     Node* mem = access.memory();
 819     bool is_weak_cas = (decorators &amp; C2_WEAK_CMPXCHG) != 0;
 820     Node* load_store = NULL;
 821     Node* adr = access.addr().node();
 822 #ifdef _LP64
 823     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 824       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 825       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 826       if (ShenandoahCASBarrier) {
 827         if (is_weak_cas) {
 828           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 829         } else {
 830           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 831         }
 832       } else {
 833         if (is_weak_cas) {
 834           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 835         } else {
 836           load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 837         }
 838       }
 839     } else
 840 #endif
 841     {
 842       if (ShenandoahCASBarrier) {
 843         if (is_weak_cas) {
 844           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 845         } else {
 846           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 847         }
 848       } else {
 849         if (is_weak_cas) {
 850           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 851         } else {
 852           load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 853         }
 854       }
 855     }
 856     access.set_raw_access(load_store);
 857     pin_atomic_op(access);
 858     return load_store;
 859   }
 860   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 861 }
 862 
 863 Node* ShenandoahBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* val, const Type* value_type) const {
 864   GraphKit* kit = access.kit();
 865   if (access.is_oop()) {
 866     val = shenandoah_storeval_barrier(kit, val);
 867   }
 868   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
 869   if (access.is_oop()) {
 870     shenandoah_write_barrier_pre(kit, false /* do_load */,
 871                                  NULL, NULL, max_juint, NULL, NULL,
 872                                  result /* pre_val */, T_OBJECT);
 873   }
 874   return result;
 875 }
 876 
 877 void ShenandoahBarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {
 878   assert(!src-&gt;is_AddP(), &quot;unexpected input&quot;);
 879   src = shenandoah_read_barrier(kit, src);
 880   BarrierSetC2::clone(kit, src, dst, size, is_array);
 881 }
 882 
 883 Node* ShenandoahBarrierSetC2::resolve(GraphKit* kit, Node* n, DecoratorSet decorators) const {
 884   bool is_write = decorators &amp; ACCESS_WRITE;
 885   if (is_write) {
 886     return shenandoah_write_barrier(kit, n);
 887   } else {
 888   return shenandoah_read_barrier(kit, n);
 889   }
 890 }
 891 
 892 Node* ShenandoahBarrierSetC2::obj_allocate(PhaseMacroExpand* macro, Node* ctrl, Node* mem, Node* toobig_false, Node* size_in_bytes,
 893                                            Node*&amp; i_o, Node*&amp; needgc_ctrl,
 894                                            Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem,
 895                                            intx prefetch_lines) const {
 896   PhaseIterGVN&amp; igvn = macro-&gt;igvn();
 897 
 898   // Allocate several words more for the Shenandoah brooks pointer.
 899   size_in_bytes = new AddXNode(size_in_bytes, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));
 900   macro-&gt;transform_later(size_in_bytes);
 901 
 902   Node* fast_oop = BarrierSetC2::obj_allocate(macro, ctrl, mem, toobig_false, size_in_bytes,
 903                                               i_o, needgc_ctrl, fast_oop_ctrl, fast_oop_rawmem,
 904                                               prefetch_lines);
 905 
 906   // Bump up object for Shenandoah brooks pointer.
 907   fast_oop = new AddPNode(macro-&gt;top(), fast_oop, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));
 908   macro-&gt;transform_later(fast_oop);
 909 
 910   // Initialize Shenandoah brooks pointer to point to the object itself.
 911   fast_oop_rawmem = macro-&gt;make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, ShenandoahBrooksPointer::byte_offset(), fast_oop, T_OBJECT);
 912 
 913   return fast_oop;
 914 }
 915 
 916 // Support for GC barriers emitted during parsing
 917 bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
 918   if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
 919     return false;
 920   }
 921   CallLeafNode *call = node-&gt;as_CallLeaf();
 922   if (call-&gt;_name == NULL) {
 923     return false;
 924   }
 925 
 926   return strcmp(call-&gt;_name, &quot;shenandoah_clone_barrier&quot;) == 0 ||
 927          strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
 928          strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
 929 }
 930 
 931 Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
 932   return ShenandoahBarrierNode::skip_through_barrier(c);
 933 }
 934 
 935 bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
 936   return !ShenandoahWriteBarrierNode::expand(C, igvn);
 937 }
 938 
 939 bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
 940   if (mode == LoopOptsShenandoahExpand) {
 941     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 942     ShenandoahWriteBarrierNode::pin_and_expand(phase);
 943     return true;
 944   } else if (mode == LoopOptsShenandoahPostExpand) {
 945     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
 946     visited.Clear();
 947     ShenandoahWriteBarrierNode::optimize_after_expansion(visited, nstack, worklist, phase);
 948     return true;
 949   }
 950   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;
 951   ShenandoahWriteBarrierNode::optimize_before_expansion(phase, memory_graph_fixers, false);
 952   return false;
 953 }
 954 
 955 bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
 956   bool is_oop = type == T_OBJECT || type == T_ARRAY;
 957   if (!is_oop) {
 958     return false;
 959   }
 960 
 961   if (tightly_coupled_alloc) {
 962     if (phase == Optimization) {
 963       return false;
 964     }
 965     return !is_clone;
 966   }
 967   if (phase == Optimization) {
 968     return !ShenandoahStoreValEnqueueBarrier;
 969   }
 970   return true;
 971 }
 972 
 973 bool ShenandoahBarrierSetC2::clone_needs_postbarrier(ArrayCopyNode *ac, PhaseIterGVN&amp; igvn) {
 974   Node* src = ac-&gt;in(ArrayCopyNode::Src);
 975   const TypeOopPtr* src_type = igvn.type(src)-&gt;is_oopptr();
 976   if (src_type-&gt;isa_instptr() != NULL) {
 977     ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
 978     if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
 979       if (ik-&gt;has_object_fields()) {
 980         return true;
 981       } else {
 982         if (!src_type-&gt;klass_is_exact()) {
 983           igvn.C-&gt;dependencies()-&gt;assert_leaf_type(ik);
 984         }
 985       }
 986     } else {
 987       return true;
 988     }
 989   } else if (src_type-&gt;isa_aryptr()) {
 990     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 991     if (src_elem == T_OBJECT || src_elem == T_ARRAY) {
 992       return true;
 993     }
 994   } else {
 995     return true;
 996   }
 997   return false;
 998 }
 999 
1000 void ShenandoahBarrierSetC2::clone_barrier_at_expansion(ArrayCopyNode* ac, Node* call, PhaseIterGVN&amp; igvn) const {
1001   assert(ac-&gt;is_clonebasic(), &quot;no other kind of arraycopy here&quot;);
1002 
1003   if (!clone_needs_postbarrier(ac, igvn)) {
1004     BarrierSetC2::clone_barrier_at_expansion(ac, call, igvn);
1005     return;
1006   }
1007 
1008   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
1009   Node* c = new ProjNode(call,TypeFunc::Control);
1010   c = igvn.transform(c);
1011   Node* m = new ProjNode(call, TypeFunc::Memory);
1012   m = igvn.transform(m);
1013 
1014   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
1015   assert(dest-&gt;is_AddP(), &quot;bad input&quot;);
1016   Node* barrier_call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),
1017                                         CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),
1018                                         &quot;shenandoah_clone_barrier&quot;, raw_adr_type);
1019   barrier_call-&gt;init_req(TypeFunc::Control, c);
1020   barrier_call-&gt;init_req(TypeFunc::I_O    , igvn.C-&gt;top());
1021   barrier_call-&gt;init_req(TypeFunc::Memory , m);
1022   barrier_call-&gt;init_req(TypeFunc::ReturnAdr, igvn.C-&gt;top());
1023   barrier_call-&gt;init_req(TypeFunc::FramePtr, igvn.C-&gt;top());
1024   barrier_call-&gt;init_req(TypeFunc::Parms+0, dest-&gt;in(AddPNode::Base));
1025 
1026   barrier_call = igvn.transform(barrier_call);
1027   c = new ProjNode(barrier_call,TypeFunc::Control);
1028   c = igvn.transform(c);
1029   m = new ProjNode(barrier_call, TypeFunc::Memory);
1030   m = igvn.transform(m);
1031 
1032   Node* out_c = ac-&gt;proj_out(TypeFunc::Control);
1033   Node* out_m = ac-&gt;proj_out(TypeFunc::Memory);
1034   igvn.replace_node(out_c, c);
1035   igvn.replace_node(out_m, m);
1036 }
1037 
1038 
1039 // Support for macro expanded GC barriers
1040 void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
1041   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {
1042     state()-&gt;add_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);
1043   }
1044 }
1045 
1046 void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
1047   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {
1048     state()-&gt;remove_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);
1049   }
1050 }
1051 
1052 void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
1053   if (is_shenandoah_wb_pre_call(n)) {
1054     shenandoah_eliminate_wb_pre(n, &amp;macro-&gt;igvn());
1055   }
1056 }
1057 
1058 void ShenandoahBarrierSetC2::shenandoah_eliminate_wb_pre(Node* call, PhaseIterGVN* igvn) const {
1059   assert(UseShenandoahGC &amp;&amp; is_shenandoah_wb_pre_call(call), &quot;&quot;);
1060   Node* c = call-&gt;as_Call()-&gt;proj_out(TypeFunc::Control);
1061   c = c-&gt;unique_ctrl_out();
1062   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1063   c = c-&gt;unique_ctrl_out();
1064   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1065   Node* iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
1066   assert(iff-&gt;is_If(), &quot;expect test&quot;);
1067   if (!is_shenandoah_marking_if(igvn, iff)) {
1068     c = c-&gt;unique_ctrl_out();
1069     assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1070     iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
1071     assert(is_shenandoah_marking_if(igvn, iff), &quot;expect marking test&quot;);
1072   }
1073   Node* cmpx = iff-&gt;in(1)-&gt;in(1);
1074   igvn-&gt;replace_node(cmpx, igvn-&gt;makecon(TypeInt::CC_EQ));
1075   igvn-&gt;rehash_node_delayed(call);
1076   call-&gt;del_req(call-&gt;req()-1);
1077 }
1078 
1079 void ShenandoahBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
1080   if (node-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(node)) {
1081     igvn-&gt;add_users_to_worklist(node);
1082   }
1083 }
1084 
1085 void ShenandoahBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
1086   for (uint i = 0; i &lt; useful.size(); i++) {
1087     Node* n = useful.at(i);
1088     if (n-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(n)) {
1089       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1090         C-&gt;record_for_igvn(n-&gt;fast_out(i));
1091       }
1092     }
1093   }
1094   for (int i = state()-&gt;shenandoah_barriers_count()-1; i &gt;= 0; i--) {
1095     ShenandoahWriteBarrierNode* n = state()-&gt;shenandoah_barrier(i);
1096     if (!useful.member(n)) {
1097       state()-&gt;remove_shenandoah_barrier(n);
1098     }
1099   }
1100 
1101 }
1102 
1103 bool ShenandoahBarrierSetC2::has_special_unique_user(const Node* node) const {
1104   assert(node-&gt;outcnt() == 1, &quot;match only for unique out&quot;);
1105   Node* n = node-&gt;unique_out();
1106   return node-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; n-&gt;Opcode() == Op_ShenandoahWBMemProj;
1107 }
1108 
1109 void ShenandoahBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {}
1110 
1111 void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
1112   return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
1113 }
1114 
1115 ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
1116   return reinterpret_cast&lt;ShenandoahBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
1117 }
1118 
1119 // If the BarrierSetC2 state has kept macro nodes in its compilation unit state to be
1120 // expanded later, then now is the time to do so.
1121 bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
1122 
1123 #ifdef ASSERT
1124 void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
1125   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeExpand) {
1126     ShenandoahBarrierNode::verify(Compile::current()-&gt;root());
1127   } else if (phase == BarrierSetC2::BeforeCodeGen) {
1128     // Verify G1 pre-barriers
1129     const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
1130 
1131     ResourceArea *area = Thread::current()-&gt;resource_area();
1132     Unique_Node_List visited(area);
1133     Node_List worklist(area);
1134     // We&#39;re going to walk control flow backwards starting from the Root
1135     worklist.push(compile-&gt;root());
1136     while (worklist.size() &gt; 0) {
1137       Node *x = worklist.pop();
1138       if (x == NULL || x == compile-&gt;top()) continue;
1139       if (visited.member(x)) {
1140         continue;
1141       } else {
1142         visited.push(x);
1143       }
1144 
1145       if (x-&gt;is_Region()) {
1146         for (uint i = 1; i &lt; x-&gt;req(); i++) {
1147           worklist.push(x-&gt;in(i));
1148         }
1149       } else {
1150         worklist.push(x-&gt;in(0));
1151         // We are looking for the pattern:
1152         //                            /-&gt;ThreadLocal
1153         // If-&gt;Bool-&gt;CmpI-&gt;LoadB-&gt;AddP-&gt;ConL(marking_offset)
1154         //              \-&gt;ConI(0)
1155         // We want to verify that the If and the LoadB have the same control
1156         // See GraphKit::g1_write_barrier_pre()
1157         if (x-&gt;is_If()) {
1158           IfNode *iff = x-&gt;as_If();
1159           if (iff-&gt;in(1)-&gt;is_Bool() &amp;&amp; iff-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1160             CmpNode *cmp = iff-&gt;in(1)-&gt;in(1)-&gt;as_Cmp();
1161             if (cmp-&gt;Opcode() == Op_CmpI &amp;&amp; cmp-&gt;in(2)-&gt;is_Con() &amp;&amp; cmp-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0
1162                 &amp;&amp; cmp-&gt;in(1)-&gt;is_Load()) {
1163               LoadNode *load = cmp-&gt;in(1)-&gt;as_Load();
1164               if (load-&gt;Opcode() == Op_LoadB &amp;&amp; load-&gt;in(2)-&gt;is_AddP() &amp;&amp; load-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
1165                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;is_Con()
1166                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == marking_offset) {
1167 
1168                 Node *if_ctrl = iff-&gt;in(0);
1169                 Node *load_ctrl = load-&gt;in(0);
1170 
1171                 if (if_ctrl != load_ctrl) {
1172                   // Skip possible CProj-&gt;NeverBranch in infinite loops
1173                   if ((if_ctrl-&gt;is_Proj() &amp;&amp; if_ctrl-&gt;Opcode() == Op_CProj)
1174                       &amp;&amp; (if_ctrl-&gt;in(0)-&gt;is_MultiBranch() &amp;&amp; if_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch)) {
1175                     if_ctrl = if_ctrl-&gt;in(0)-&gt;in(0);
1176                   }
1177                 }
1178                 assert(load_ctrl != NULL &amp;&amp; if_ctrl == load_ctrl, &quot;controls must match&quot;);
1179               }
1180             }
1181           }
1182         }
1183       }
1184     }
1185   }
1186 }
1187 #endif
1188 
1189 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1190   if (is_shenandoah_wb_pre_call(n)) {
1191     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1192     if (n-&gt;req() &gt; cnt) {
1193       Node* addp = n-&gt;in(cnt);
1194       if (has_only_shenandoah_wb_pre_uses(addp)) {
1195         n-&gt;del_req(cnt);
1196         if (can_reshape) {
1197           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1198         }
1199         return n;
1200       }
1201     }
1202   }
1203   if (n-&gt;Opcode() == Op_CmpP) {
1204     Node* in1 = n-&gt;in(1);
1205     Node* in2 = n-&gt;in(2);
1206     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {
1207       in2 = step_over_gc_barrier(in2);
1208     }
1209     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {
1210       in1 = step_over_gc_barrier(in1);
1211     }
1212     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1213     if (in1 != n-&gt;in(1)) {
1214       if (igvn != NULL) {
1215         n-&gt;set_req_X(1, in1, igvn);
1216       } else {
1217         n-&gt;set_req(1, in1);
1218       }
1219       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);
1220       return n;
1221     }
1222     if (in2 != n-&gt;in(2)) {
1223       if (igvn != NULL) {
1224         n-&gt;set_req_X(2, in2, igvn);
1225       } else {
1226         n-&gt;set_req(2, in2);
1227       }
1228       return n;
1229     }
1230   } else if (can_reshape &amp;&amp;
1231              n-&gt;Opcode() == Op_If &amp;&amp;
1232              ShenandoahWriteBarrierNode::is_heap_stable_test(n) &amp;&amp;
1233              n-&gt;in(0) != NULL) {
1234     Node* dom = n-&gt;in(0);
1235     Node* prev_dom = n;
1236     int op = n-&gt;Opcode();
1237     int dist = 16;
1238     // Search up the dominator tree for another heap stable test
1239     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1240            !ShenandoahWriteBarrierNode::is_heap_stable_test(dom) ||  // Not same input 1?
1241            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1242       if (dist &lt; 0) return NULL;
1243 
1244       dist--;
1245       prev_dom = dom;
1246       dom = IfNode::up_one_dom(dom);
1247       if (!dom) return NULL;
1248     }
1249 
1250     // Check that we did not follow a loop back to ourselves
1251     if (n == dom) {
1252       return NULL;
1253     }
1254 
1255     return n-&gt;as_If()-&gt;dominated_by(prev_dom, phase-&gt;is_IterGVN());
1256   }
1257 
1258   return NULL;
1259 }
1260 
1261 Node* ShenandoahBarrierSetC2::identity_node(PhaseGVN* phase, Node* n) const {
1262   if (n-&gt;is_Load()) {
1263     Node *mem = n-&gt;in(MemNode::Memory);
1264     Node *value = n-&gt;as_Load()-&gt;can_see_stored_value(mem, phase);
1265     if (value) {
1266       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1267       if (igvn != NULL &amp;&amp;
1268           value-&gt;is_Phi() &amp;&amp;
1269           value-&gt;req() &gt; 2 &amp;&amp;
1270           value-&gt;in(1) != NULL &amp;&amp;
1271           value-&gt;in(1)-&gt;is_ShenandoahBarrier()) {
1272         if (igvn-&gt;_worklist.member(value) ||
1273             igvn-&gt;_worklist.member(value-&gt;in(0)) ||
1274             (value-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;
1275              value-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;
1276              (igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)) ||
1277               (value-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;
1278                igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)-&gt;in(0)))))) {
1279           igvn-&gt;_worklist.push(n);
1280           return n;
1281         }
1282       }
1283       // (This works even when value is a Con, but LoadNode::Value
1284       // usually runs first, producing the singleton type of the Con.)
1285       Node *value_no_barrier = step_over_gc_barrier(value-&gt;Opcode() == Op_EncodeP ? value-&gt;in(1) : value);
1286       if (value-&gt;Opcode() == Op_EncodeP) {
1287         if (value_no_barrier != value-&gt;in(1)) {
1288           Node *encode = value-&gt;clone();
1289           encode-&gt;set_req(1, value_no_barrier);
1290           encode = phase-&gt;transform(encode);
1291           return encode;
1292         }
1293       } else {
1294         return value_no_barrier;
1295       }
1296     }
1297   }
1298   return n;
1299 }
1300 
1301 bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
1302   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1303     Node* u = n-&gt;fast_out(i);
1304     if (!is_shenandoah_wb_pre_call(u)) {
1305       return false;
1306     }
1307   }
1308   return n-&gt;outcnt() &gt; 0;
1309 }
1310 
1311 bool ShenandoahBarrierSetC2::flatten_gc_alias_type(const TypePtr*&amp; adr_type) const {
1312   int offset = adr_type-&gt;offset();
1313   if (offset == ShenandoahBrooksPointer::byte_offset()) {
1314     if (adr_type-&gt;isa_aryptr()) {
1315       adr_type = TypeAryPtr::make(adr_type-&gt;ptr(), adr_type-&gt;isa_aryptr()-&gt;ary(), adr_type-&gt;isa_aryptr()-&gt;klass(), false, offset);
1316     } else if (adr_type-&gt;isa_instptr()) {
1317       adr_type = TypeInstPtr::make(adr_type-&gt;ptr(), ciEnv::current()-&gt;Object_klass(), false, NULL, offset);
1318     }
1319     return true;
1320   } else {
1321     return false;
1322   }
1323 }
1324 
1325 bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1326   switch (opcode) {
1327     case Op_CallLeaf:
1328     case Op_CallLeafNoFP: {
1329       assert (n-&gt;is_Call(), &quot;&quot;);
1330       CallNode *call = n-&gt;as_Call();
1331       if (ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(call)) {
1332         uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1333         if (call-&gt;req() &gt; cnt) {
1334           assert(call-&gt;req() == cnt + 1, &quot;only one extra input&quot;);
1335           Node *addp = call-&gt;in(cnt);
1336           assert(!ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(addp), &quot;useless address computation?&quot;);
1337           call-&gt;del_req(cnt);
1338         }
1339       }
1340       return false;
1341     }
1342     case Op_ShenandoahCompareAndSwapP:
1343     case Op_ShenandoahCompareAndSwapN:
1344     case Op_ShenandoahWeakCompareAndSwapN:
1345     case Op_ShenandoahWeakCompareAndSwapP:
1346     case Op_ShenandoahCompareAndExchangeP:
1347     case Op_ShenandoahCompareAndExchangeN:
1348 #ifdef ASSERT
1349       if( VerifyOptoOopOffsets ) {
1350         MemNode* mem  = n-&gt;as_Mem();
1351         // Check to see if address types have grounded out somehow.
1352         const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1353         ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
1354         bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1355         assert( !tp || oop_offset_is_sane, &quot;&quot; );
1356       }
1357 #endif
1358       return true;
1359     case Op_ShenandoahReadBarrier:
1360       return true;
1361     case Op_ShenandoahWriteBarrier:
1362       assert(false, &quot;should have been expanded already&quot;);
1363       return true;
1364     default:
1365       return false;
1366   }
1367 }
1368 
1369 #ifdef ASSERT
1370 bool ShenandoahBarrierSetC2::verify_gc_alias_type(const TypePtr* adr_type, int offset) const {
1371   if (offset == ShenandoahBrooksPointer::byte_offset() &amp;&amp;
1372       (adr_type-&gt;base() == Type::AryPtr || adr_type-&gt;base() == Type::OopPtr)) {
1373     return true;
1374   } else {
1375     return false;
1376   }
1377 }
1378 #endif
1379 
1380 bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1381   switch (opcode) {
1382     case Op_ShenandoahCompareAndExchangeP:
1383     case Op_ShenandoahCompareAndExchangeN:
1384       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1385       // fallthrough
1386     case Op_ShenandoahWeakCompareAndSwapP:
1387     case Op_ShenandoahWeakCompareAndSwapN:
1388     case Op_ShenandoahCompareAndSwapP:
1389     case Op_ShenandoahCompareAndSwapN:
1390       conn_graph-&gt;add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
1391       return true;
1392     case Op_StoreP: {
1393       Node* adr = n-&gt;in(MemNode::Address);
1394       const Type* adr_type = gvn-&gt;type(adr);
1395       // Pointer stores in G1 barriers looks like unsafe access.
1396       // Ignore such stores to be able scalar replace non-escaping
1397       // allocations.
1398       if (adr_type-&gt;isa_rawptr() &amp;&amp; adr-&gt;is_AddP()) {
1399         Node* base = conn_graph-&gt;get_addp_base(adr);
1400         if (base-&gt;Opcode() == Op_LoadP &amp;&amp;
1401           base-&gt;in(MemNode::Address)-&gt;is_AddP()) {
1402           adr = base-&gt;in(MemNode::Address);
1403           Node* tls = conn_graph-&gt;get_addp_base(adr);
1404           if (tls-&gt;Opcode() == Op_ThreadLocal) {
1405              int offs = (int) gvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
1406              const int buf_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1407              if (offs == buf_offset) {
1408                return true; // Pre barrier previous oop value store.
1409              }
1410           }
1411         }
1412       }
1413       return false;
1414     }
1415     case Op_ShenandoahReadBarrier:
1416     case Op_ShenandoahWriteBarrier:
1417       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.
1418       // It doesn&#39;t escape.
1419       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), delayed_worklist);
1420       break;
1421     case Op_ShenandoahEnqueueBarrier:
1422       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
1423       break;
1424     default:
1425       // Nothing
1426       break;
1427   }
1428   return false;
1429 }
1430 
1431 bool ShenandoahBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1432   switch (opcode) {
1433     case Op_ShenandoahCompareAndExchangeP:
1434     case Op_ShenandoahCompareAndExchangeN: {
1435       Node *adr = n-&gt;in(MemNode::Address);
1436       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
1437       // fallthrough
1438     }
1439     case Op_ShenandoahCompareAndSwapP:
1440     case Op_ShenandoahCompareAndSwapN:
1441     case Op_ShenandoahWeakCompareAndSwapP:
1442     case Op_ShenandoahWeakCompareAndSwapN:
1443       return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
1444     case Op_ShenandoahReadBarrier:
1445     case Op_ShenandoahWriteBarrier:
1446       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.
1447       // It doesn&#39;t escape.
1448       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), NULL);
1449       return true;
1450     case Op_ShenandoahEnqueueBarrier:
1451       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
1452       return true;
1453     default:
1454       // Nothing
1455       break;
1456   }
1457   return false;
1458 }
1459 
1460 bool ShenandoahBarrierSetC2::escape_has_out_with_unsafe_object(Node* n) const {
1461   return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
1462          n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
1463 
1464 }
1465 
1466 bool ShenandoahBarrierSetC2::escape_is_barrier_node(Node* n) const {
1467   return n-&gt;is_ShenandoahBarrier();
1468 }
1469 
1470 bool ShenandoahBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {
1471   switch (opcode) {
1472     case Op_ShenandoahReadBarrier:
1473       if (n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;is_DecodeNarrowPtr()) {
1474         matcher-&gt;set_shared(n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;in(1));
1475       }
1476       matcher-&gt;set_shared(n);
1477       return true;
1478     default:
1479       break;
1480   }
1481   return false;
1482 }
1483 
1484 bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
1485   switch (opcode) {
1486     case Op_ShenandoahCompareAndExchangeP:
1487     case Op_ShenandoahCompareAndExchangeN:
1488     case Op_ShenandoahWeakCompareAndSwapP:
1489     case Op_ShenandoahWeakCompareAndSwapN:
1490     case Op_ShenandoahCompareAndSwapP:
1491     case Op_ShenandoahCompareAndSwapN: {   // Convert trinary to binary-tree
1492       Node* newval = n-&gt;in(MemNode::ValueIn);
1493       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
1494       Node* pair = new BinaryNode(oldval, newval);
1495       n-&gt;set_req(MemNode::ValueIn,pair);
1496       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
1497       return true;
1498     }
1499     default:
1500       break;
1501   }
1502   return false;
1503 }
1504 
1505 bool ShenandoahBarrierSetC2::matcher_is_store_load_barrier(Node* x, uint xop) const {
1506   return xop == Op_ShenandoahCompareAndExchangeP ||
1507          xop == Op_ShenandoahCompareAndExchangeN ||
1508          xop == Op_ShenandoahWeakCompareAndSwapP ||
1509          xop == Op_ShenandoahWeakCompareAndSwapN ||
1510          xop == Op_ShenandoahCompareAndSwapN ||
1511          xop == Op_ShenandoahCompareAndSwapP;
1512 }
1513 
1514 void ShenandoahBarrierSetC2::igvn_add_users_to_worklist(PhaseIterGVN* igvn, Node* use) const {
1515   if (use-&gt;is_ShenandoahBarrier()) {
1516     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1517       Node* u = use-&gt;fast_out(i2);
1518       Node* cmp = use-&gt;find_out_with(Op_CmpP);
1519       if (u-&gt;Opcode() == Op_CmpP) {
1520         igvn-&gt;_worklist.push(cmp);
1521       }
1522     }
1523   }
1524 }
1525 
1526 void ShenandoahBarrierSetC2::ccp_analyze(PhaseCCP* ccp, Unique_Node_List&amp; worklist, Node* use) const {
1527   if (use-&gt;is_ShenandoahBarrier()) {
1528     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {
1529       Node* p = use-&gt;fast_out(i2);
1530       if (p-&gt;Opcode() == Op_AddP) {
1531         for (DUIterator_Fast i3max, i3 = p-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {
1532           Node* q = p-&gt;fast_out(i3);
1533           if (q-&gt;is_Load()) {
1534             if(q-&gt;bottom_type() != ccp-&gt;type(q)) {
1535               worklist.push(q);
1536             }
1537           }
1538         }
1539       }
1540     }
1541   }
1542 }
1543 
1544 Node* ShenandoahBarrierSetC2::split_if_pre(PhaseIdealLoop* phase, Node* n) const {
1545   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {
1546     ((ShenandoahReadBarrierNode*)n)-&gt;try_move(phase);
1547   } else if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {
1548     return ((ShenandoahWriteBarrierNode*)n)-&gt;try_split_thru_phi(phase);
1549   }
1550 
1551   return NULL;
1552 }
1553 
1554 bool ShenandoahBarrierSetC2::build_loop_late_post(PhaseIdealLoop* phase, Node* n) const {
1555   return ShenandoahBarrierNode::build_loop_late_post(phase, n);
1556 }
1557 
1558 bool ShenandoahBarrierSetC2::sink_node(PhaseIdealLoop* phase, Node* n, Node* x, Node* x_ctrl, Node* n_ctrl) const {
1559   if (n-&gt;is_ShenandoahBarrier()) {
1560     return x-&gt;as_ShenandoahBarrier()-&gt;sink_node(phase, x_ctrl, n_ctrl);
1561   }
1562   if (n-&gt;is_MergeMem()) {
1563     // PhaseIdealLoop::split_if_with_blocks_post() would:
1564     // _igvn._worklist.yank(x);
1565     // which sometimes causes chains of MergeMem which some of
1566     // shenandoah specific code doesn&#39;t support
1567     phase-&gt;register_new_node(x, x_ctrl);
1568     return true;
1569   }
1570   return false;
1571 }
    </pre>
  </body>
</html>
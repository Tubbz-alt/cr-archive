<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahFreeSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,23 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/memAllocator.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/parallelCleaning.hpp&quot;</span>
  #include &quot;gc/shared/plab.hpp&quot;
  
  #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
<span class="line-new-header">--- 22,27 ---</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  
<span class="line-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  #include &quot;gc/shared/gcTimer.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
  #include &quot;gc/shared/memAllocator.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;gc/shared/plab.hpp&quot;
  
  #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,34 ***</span>
  #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/heuristics/shenandoahAdaptiveHeuristics.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/shenandoah/heuristics/shenandoahAggressiveHeuristics.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/shenandoah/heuristics/shenandoahCompactHeuristics.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shenandoah/heuristics/shenandoahPassiveHeuristics.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shenandoah/heuristics/shenandoahStaticHeuristics.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shenandoah/heuristics/shenandoahTraversalHeuristics.hpp&quot;</span>
  
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;services/mallocTracker.hpp&quot;
<span class="line-modified">! </span>
<span class="line-removed">- ShenandoahUpdateRefsClosure::ShenandoahUpdateRefsClosure() : _heap(ShenandoahHeap::heap()) {}</span>
  
  #ifdef ASSERT
  template &lt;class T&gt;
  void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
    T o = RawAccess&lt;&gt;::oop_load(p);
<span class="line-new-header">--- 50,39 ---</span>
  #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahPassiveMode.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahTraversalMode.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
<span class="line-modified">! #if INCLUDE_JFR</span>
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;</span>
<span class="line-modified">! #endif</span>
  
  #include &quot;memory/metaspace.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;services/mallocTracker.hpp&quot;
<span class="line-modified">! #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #ifdef ASSERT
  template &lt;class T&gt;
  void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
    T o = RawAccess&lt;&gt;::oop_load(p);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,21 ***</span>
      }
    }
  };
  
  jint ShenandoahHeap::initialize() {
<span class="line-removed">-   ShenandoahBrooksPointer::initial_checks();</span>
<span class="line-removed">- </span>
    initialize_heuristics();
  
    //
    // Figure out heap sizing
    //
  
<span class="line-modified">!   size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size();</span>
<span class="line-modified">!   size_t max_byte_size  = collector_policy()-&gt;max_heap_byte_size();</span>
<span class="line-modified">!   size_t heap_alignment = collector_policy()-&gt;heap_alignment();</span>
  
    size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
  
    if (ShenandoahAlwaysPreTouch) {
      // Enabled pre-touch means the entire heap is committed right away.
<span class="line-new-header">--- 140,20 ---</span>
      }
    }
  };
  
  jint ShenandoahHeap::initialize() {
    initialize_heuristics();
  
    //
    // Figure out heap sizing
    //
  
<span class="line-modified">!   size_t init_byte_size = InitialHeapSize;</span>
<span class="line-modified">!   size_t min_byte_size  = MinHeapSize;</span>
<span class="line-modified">!   size_t max_byte_size  = MaxHeapSize;</span>
<span class="line-added">+   size_t heap_alignment = HeapAlignment;</span>
  
    size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
  
    if (ShenandoahAlwaysPreTouch) {
      // Enabled pre-touch means the entire heap is committed right away.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,29 ***</span>
    _num_regions = ShenandoahHeapRegion::region_count();
  
    size_t num_committed_regions = init_byte_size / reg_size_bytes;
    num_committed_regions = MIN2(num_committed_regions, _num_regions);
    assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
<span class="line-removed">- </span>
    _initial_size = num_committed_regions * reg_size_bytes;
    _committed = _initial_size;
  
    size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
    size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
  
    //
    // Reserve and commit memory for heap
    //
  
<span class="line-modified">!   ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);</span>
<span class="line-modified">!   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*) (heap_rs.base() + heap_rs.size()));</span>
    _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
    _heap_region_special = heap_rs.special();
  
    assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
           &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
  
    ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
    if (!_heap_region_special) {
      os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
                                &quot;Cannot commit heap memory&quot;);
    }
<span class="line-new-header">--- 166,46 ---</span>
    _num_regions = ShenandoahHeapRegion::region_count();
  
    size_t num_committed_regions = init_byte_size / reg_size_bytes;
    num_committed_regions = MIN2(num_committed_regions, _num_regions);
    assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
    _initial_size = num_committed_regions * reg_size_bytes;
<span class="line-added">+ </span>
<span class="line-added">+   size_t num_min_regions = min_byte_size / reg_size_bytes;</span>
<span class="line-added">+   num_min_regions = MIN2(num_min_regions, _num_regions);</span>
<span class="line-added">+   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);</span>
<span class="line-added">+   _minimum_size = num_min_regions * reg_size_bytes;</span>
<span class="line-added">+ </span>
    _committed = _initial_size;
  
    size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
    size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
  
    //
    // Reserve and commit memory for heap
    //
  
<span class="line-modified">!   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);</span>
<span class="line-modified">!   initialize_reserved_region(heap_rs);</span>
    _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
    _heap_region_special = heap_rs.special();
  
    assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
           &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
  
<span class="line-added">+ #if SHENANDOAH_OPTIMIZED_OBJTASK</span>
<span class="line-added">+   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.</span>
<span class="line-added">+   // Fail if we ever attempt to address more than we can.</span>
<span class="line-added">+   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {</span>
<span class="line-added">+     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;</span>
<span class="line-added">+                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;</span>
<span class="line-added">+                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,</span>
<span class="line-added">+                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
    if (!_heap_region_special) {
      os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
                                &quot;Cannot commit heap memory&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,11 ***</span>
    // Create regions and region sets
    //
  
    _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
    _free_set = new ShenandoahFreeSet(this, _num_regions);
<span class="line-modified">!   _collection_set = new ShenandoahCollectionSet(this, (HeapWord*)sh_rs.base());</span>
  
    {
      ShenandoahHeapLocker locker(lock());
  
      size_t size_words = ShenandoahHeapRegion::region_size_words();
<span class="line-new-header">--- 278,11 ---</span>
    // Create regions and region sets
    //
  
    _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
    _free_set = new ShenandoahFreeSet(this, _num_regions);
<span class="line-modified">!   _collection_set = new ShenandoahCollectionSet(this, sh_rs.base(), sh_rs.size());</span>
  
    {
      ShenandoahHeapLocker locker(lock());
  
      size_t size_words = ShenandoahHeapRegion::region_size_words();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,16 ***</span>
    for (uint worker = 0; worker &lt; _max_workers; worker++) {
      _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
      Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
    }
  
<span class="line-modified">!   // The call below uses stuff (the SATB* things) that are in G1, but probably</span>
<span class="line-modified">!   // belong into a shared location.</span>
<span class="line-modified">!   ShenandoahBarrierSet::satb_mark_queue_set().initialize(this,</span>
<span class="line-modified">!                                                          SATB_Q_CBL_mon,</span>
<span class="line-modified">!                                                          20 /* G1SATBProcessCompletedThreshold */,</span>
<span class="line-modified">!                                                          60 /* G1SATBBufferEnqueueingThresholdPercent */);</span>
  
    _monitoring_support = new ShenandoahMonitoringSupport(this);
    _phase_timings = new ShenandoahPhaseTimings();
    ShenandoahStringDedup::initialize();
    ShenandoahCodeRoots::initialize();
<span class="line-new-header">--- 346,17 ---</span>
    for (uint worker = 0; worker &lt; _max_workers; worker++) {
      _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
      Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
    }
  
<span class="line-modified">!   // There should probably be Shenandoah-specific options for these,</span>
<span class="line-modified">!   // just as there are G1-specific options.</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();</span>
<span class="line-modified">!     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold</span>
<span class="line-modified">!     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent</span>
<span class="line-added">+   }</span>
  
    _monitoring_support = new ShenandoahMonitoringSupport(this);
    _phase_timings = new ShenandoahPhaseTimings();
    ShenandoahStringDedup::initialize();
    ShenandoahCodeRoots::initialize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,64 ***</span>
      _pacer-&gt;setup_for_idle();
    } else {
      _pacer = NULL;
    }
  
<span class="line-modified">!   _traversal_gc = heuristics()-&gt;can_do_traversal_gc() ?</span>
                    new ShenandoahTraversalGC(this, _num_regions) :
                    NULL;
  
    _control_thread = new ShenandoahControlThread();
  
<span class="line-modified">!   log_info(gc, init)(&quot;Initialize Shenandoah heap with initial size &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(_initial_size), proper_unit_for_byte_size(_initial_size));</span>
  
    log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
                       SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
                       (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
  
    return JNI_OK;
  }
  
  void ShenandoahHeap::initialize_heuristics() {
<span class="line-modified">!   if (ShenandoahGCHeuristics != NULL) {</span>
<span class="line-modified">!     if (strcmp(ShenandoahGCHeuristics, &quot;aggressive&quot;) == 0) {</span>
<span class="line-modified">!       _heuristics = new ShenandoahAggressiveHeuristics();</span>
<span class="line-modified">!     } else if (strcmp(ShenandoahGCHeuristics, &quot;static&quot;) == 0) {</span>
<span class="line-modified">!       _heuristics = new ShenandoahStaticHeuristics();</span>
<span class="line-modified">!     } else if (strcmp(ShenandoahGCHeuristics, &quot;adaptive&quot;) == 0) {</span>
<span class="line-modified">!       _heuristics = new ShenandoahAdaptiveHeuristics();</span>
<span class="line-removed">-     } else if (strcmp(ShenandoahGCHeuristics, &quot;passive&quot;) == 0) {</span>
<span class="line-removed">-       _heuristics = new ShenandoahPassiveHeuristics();</span>
<span class="line-removed">-     } else if (strcmp(ShenandoahGCHeuristics, &quot;compact&quot;) == 0) {</span>
<span class="line-removed">-       _heuristics = new ShenandoahCompactHeuristics();</span>
<span class="line-removed">-     } else if (strcmp(ShenandoahGCHeuristics, &quot;traversal&quot;) == 0) {</span>
<span class="line-removed">-       _heuristics = new ShenandoahTraversalHeuristics();</span>
      } else {
<span class="line-modified">!       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCHeuristics option&quot;);</span>
      }
<span class="line-removed">- </span>
<span class="line-removed">-     if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {</span>
<span class="line-removed">-       vm_exit_during_initialization(</span>
<span class="line-removed">-               err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,</span>
<span class="line-removed">-                       _heuristics-&gt;name()));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {</span>
<span class="line-removed">-       vm_exit_during_initialization(</span>
<span class="line-removed">-               err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,</span>
<span class="line-removed">-                       _heuristics-&gt;name()));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ShenandoahStoreValEnqueueBarrier &amp;&amp; ShenandoahStoreValReadBarrier) {</span>
<span class="line-removed">-       vm_exit_during_initialization(&quot;Cannot use both ShenandoahStoreValEnqueueBarrier and ShenandoahStoreValReadBarrier&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,</span>
<span class="line-removed">-                        _heuristics-&gt;name());</span>
    } else {
<span class="line-modified">!       ShouldNotReachHere();</span>
    }
  
  }
  
  #ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
<span class="line-new-header">--- 370,58 ---</span>
      _pacer-&gt;setup_for_idle();
    } else {
      _pacer = NULL;
    }
  
<span class="line-modified">!   _traversal_gc = strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0 ?</span>
                    new ShenandoahTraversalGC(this, _num_regions) :
                    NULL;
  
    _control_thread = new ShenandoahControlThread();
  
<span class="line-modified">!   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),</span>
<span class="line-added">+                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),</span>
<span class="line-added">+                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())</span>
<span class="line-added">+   );</span>
  
    log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
                       SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
                       (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
  
    return JNI_OK;
  }
  
  void ShenandoahHeap::initialize_heuristics() {
<span class="line-modified">!   if (ShenandoahGCMode != NULL) {</span>
<span class="line-modified">!     if (strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0) {</span>
<span class="line-modified">!       _gc_mode = new ShenandoahTraversalMode();</span>
<span class="line-modified">!     } else if (strcmp(ShenandoahGCMode, &quot;normal&quot;) == 0) {</span>
<span class="line-modified">!       _gc_mode = new ShenandoahNormalMode();</span>
<span class="line-modified">!     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {</span>
<span class="line-modified">!       _gc_mode = new ShenandoahPassiveMode();</span>
      } else {
<span class="line-modified">!       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);</span>
      }
    } else {
<span class="line-modified">!     ShouldNotReachHere();</span>
    }
<span class="line-added">+   _gc_mode-&gt;initialize_flags();</span>
<span class="line-added">+   _heuristics = _gc_mode-&gt;initialize_heuristics();</span>
  
<span class="line-added">+   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {</span>
<span class="line-added">+     vm_exit_during_initialization(</span>
<span class="line-added">+             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,</span>
<span class="line-added">+                     _heuristics-&gt;name()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {</span>
<span class="line-added">+     vm_exit_during_initialization(</span>
<span class="line-added">+             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,</span>
<span class="line-added">+                     _heuristics-&gt;name()));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,</span>
<span class="line-added">+                      _heuristics-&gt;name());</span>
  }
  
  #ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,10 ***</span>
<span class="line-new-header">--- 455,11 ---</span>
    _memory_pool(NULL),
    _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
    _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
    _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
    _soft_ref_policy(),
<span class="line-added">+   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),</span>
    _ref_processor(NULL),
    _marking_context(NULL),
    _bitmap_size(0),
    _bitmap_regions_per_slice(0),
    _bitmap_bytes_per_slice(0),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,22 ***</span>
  
    BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
  
    _max_workers = MAX2(_max_workers, 1U);
    _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
<span class="line-modified">!                             /* are_GC_task_threads */true,</span>
<span class="line-modified">!                             /* are_ConcurrentGC_threads */false);</span>
    if (_workers == NULL) {
      vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
    } else {
      _workers-&gt;initialize_workers();
    }
  
    if (ShenandoahParallelSafepointThreads &gt; 1) {
      _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
                                                  ShenandoahParallelSafepointThreads,
<span class="line-modified">!                                                 false, false);</span>
      _safepoint_workers-&gt;initialize_workers();
    }
  }
  
  #ifdef _MSC_VER
<span class="line-new-header">--- 473,23 ---</span>
  
    BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
  
    _max_workers = MAX2(_max_workers, 1U);
    _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
<span class="line-modified">!                             /* are_GC_task_threads */ true,</span>
<span class="line-modified">!                             /* are_ConcurrentGC_threads */ true);</span>
    if (_workers == NULL) {
      vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
    } else {
      _workers-&gt;initialize_workers();
    }
  
    if (ShenandoahParallelSafepointThreads &gt; 1) {
      _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
                                                  ShenandoahParallelSafepointThreads,
<span class="line-modified">!                       /* are_GC_task_threads */ false,</span>
<span class="line-added">+                  /* are_ConcurrentGC_threads */ false);</span>
      _safepoint_workers-&gt;initialize_workers();
    }
  }
  
  #ifdef _MSC_VER
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,24 ***</span>
    _workers-&gt;run_task(&amp;task);
  }
  
  void ShenandoahHeap::print_on(outputStream* st) const {
    st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
<span class="line-modified">!   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;K total, &quot; SIZE_FORMAT &quot;K committed, &quot; SIZE_FORMAT &quot;K used&quot;,</span>
<span class="line-modified">!                capacity() / K, committed() / K, used() / K);</span>
<span class="line-modified">!   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;K regions&quot;,</span>
<span class="line-modified">!                num_regions(), ShenandoahHeapRegion::region_size_bytes() / K);</span>
  
    st-&gt;print(&quot;Status: &quot;);
    if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
    if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
    if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
    if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
    if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
    if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
    if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
    if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
  
    if (cancelled_gc()) {
      st-&gt;print(&quot;cancelled&quot;);
    } else {
      st-&gt;print(&quot;not cancelled&quot;);
<span class="line-new-header">--- 525,29 ---</span>
    _workers-&gt;run_task(&amp;task);
  }
  
  void ShenandoahHeap::print_on(outputStream* st) const {
    st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
<span class="line-modified">!   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,</span>
<span class="line-modified">!                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),</span>
<span class="line-modified">!                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),</span>
<span class="line-modified">!                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));</span>
<span class="line-added">+   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,</span>
<span class="line-added">+                num_regions(),</span>
<span class="line-added">+                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),</span>
<span class="line-added">+                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));</span>
  
    st-&gt;print(&quot;Status: &quot;);
    if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
    if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
    if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
    if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
    if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
    if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
    if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
    if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
<span class="line-added">+   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);</span>
  
    if (cancelled_gc()) {
      st-&gt;print(&quot;cancelled&quot;);
    } else {
      st-&gt;print(&quot;not cancelled&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,10 ***</span>
<span class="line-new-header">--- 557,19 ---</span>
    st-&gt;print_cr(&quot;Reserved region:&quot;);
    st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
                 p2i(reserved_region().start()),
                 p2i(reserved_region().end()));
  
<span class="line-added">+   ShenandoahCollectionSet* cset = collection_set();</span>
<span class="line-added">+   st-&gt;print_cr(&quot;Collection set:&quot;);</span>
<span class="line-added">+   if (cset != NULL) {</span>
<span class="line-added">+     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));</span>
<span class="line-added">+     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     st-&gt;print_cr(&quot; (NULL)&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    st-&gt;cr();
    MetaspaceUtils::print_on(st);
  
    if (Verbose) {
      print_heap_regions_on(st);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,14 ***</span>
    _full_gc-&gt;initialize(_gc_timer);
  
    ref_processing_init();
  
    _heuristics-&gt;initialize();
  }
  
  size_t ShenandoahHeap::used() const {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_used);</span>
  }
  
  size_t ShenandoahHeap::committed() const {
    OrderAccess::acquire();
    return _committed;
<span class="line-new-header">--- 600,16 ---</span>
    _full_gc-&gt;initialize(_gc_timer);
  
    ref_processing_init();
  
    _heuristics-&gt;initialize();
<span class="line-added">+ </span>
<span class="line-added">+   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());</span>
  }
  
  size_t ShenandoahHeap::used() const {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_used);</span>
  }
  
  size_t ShenandoahHeap::committed() const {
    OrderAccess::acquire();
    return _committed;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,24 ***</span>
    assert_heaplock_or_safepoint();
    _committed -= bytes;
  }
  
  void ShenandoahHeap::increase_used(size_t bytes) {
<span class="line-modified">!   Atomic::add(bytes, &amp;_used);</span>
  }
  
  void ShenandoahHeap::set_used(size_t bytes) {
<span class="line-modified">!   OrderAccess::release_store_fence(&amp;_used, bytes);</span>
  }
  
  void ShenandoahHeap::decrease_used(size_t bytes) {
    assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
<span class="line-modified">!   Atomic::sub(bytes, &amp;_used);</span>
  }
  
  void ShenandoahHeap::increase_allocated(size_t bytes) {
<span class="line-modified">!   Atomic::add(bytes, &amp;_bytes_allocated_since_gc_start);</span>
  }
  
  void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
    size_t bytes = words * HeapWordSize;
    if (!waste) {
<span class="line-new-header">--- 624,24 ---</span>
    assert_heaplock_or_safepoint();
    _committed -= bytes;
  }
  
  void ShenandoahHeap::increase_used(size_t bytes) {
<span class="line-modified">!   Atomic::add(&amp;_used, bytes);</span>
  }
  
  void ShenandoahHeap::set_used(size_t bytes) {
<span class="line-modified">!   Atomic::release_store_fence(&amp;_used, bytes);</span>
  }
  
  void ShenandoahHeap::decrease_used(size_t bytes) {
    assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
<span class="line-modified">!   Atomic::sub(&amp;_used, bytes);</span>
  }
  
  void ShenandoahHeap::increase_allocated(size_t bytes) {
<span class="line-modified">!   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);</span>
  }
  
  void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
    size_t bytes = words * HeapWordSize;
    if (!waste) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 616,17 ***</span>
      }
    }
  }
  
  size_t ShenandoahHeap::capacity() const {
<span class="line-modified">!   return num_regions() * ShenandoahHeapRegion::region_size_bytes();</span>
  }
  
  size_t ShenandoahHeap::max_capacity() const {
    return _num_regions * ShenandoahHeapRegion::region_size_bytes();
  }
  
  size_t ShenandoahHeap::initial_capacity() const {
    return _initial_size;
  }
  
  bool ShenandoahHeap::is_in(const void* p) const {
<span class="line-new-header">--- 655,21 ---</span>
      }
    }
  }
  
  size_t ShenandoahHeap::capacity() const {
<span class="line-modified">!   return committed();</span>
  }
  
  size_t ShenandoahHeap::max_capacity() const {
    return _num_regions * ShenandoahHeapRegion::region_size_bytes();
  }
  
<span class="line-added">+ size_t ShenandoahHeap::min_capacity() const {</span>
<span class="line-added">+   return _minimum_size;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  size_t ShenandoahHeap::initial_capacity() const {
    return _initial_size;
  }
  
  bool ShenandoahHeap::is_in(const void* p) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 636,26 ***</span>
  }
  
  void ShenandoahHeap::op_uncommit(double shrink_before) {
    assert (ShenandoahUncommit, &quot;should be enabled&quot;);
  
    size_t count = 0;
<span class="line-modified">!   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-modified">!     ShenandoahHeapRegion* r = get_region(i);</span>
      if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
        ShenandoahHeapLocker locker(lock());
        if (r-&gt;is_empty_committed()) {
          r-&gt;make_uncommitted();
          count++;
        }
      }
      SpinPause(); // allow allocators to take the lock
    }
  
    if (count &gt; 0) {
<span class="line-removed">-     log_info(gc)(&quot;Uncommitted &quot; SIZE_FORMAT &quot;M. Heap: &quot; SIZE_FORMAT &quot;M reserved, &quot; SIZE_FORMAT &quot;M committed, &quot; SIZE_FORMAT &quot;M used&quot;,</span>
<span class="line-removed">-                  count * ShenandoahHeapRegion::region_size_bytes() / M, capacity() / M, committed() / M, used() / M);</span>
      control_thread()-&gt;notify_heap_changed();
    }
  }
  
  HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
<span class="line-new-header">--- 679,34 ---</span>
  }
  
  void ShenandoahHeap::op_uncommit(double shrink_before) {
    assert (ShenandoahUncommit, &quot;should be enabled&quot;);
  
<span class="line-added">+   // Application allocates from the beginning of the heap, and GC allocates at</span>
<span class="line-added">+   // the end of it. It is more efficient to uncommit from the end, so that applications</span>
<span class="line-added">+   // could enjoy the near committed regions. GC allocations are much less frequent,</span>
<span class="line-added">+   // and therefore can accept the committing costs.</span>
<span class="line-added">+ </span>
    size_t count = 0;
<span class="line-modified">!   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow</span>
<span class="line-modified">!     ShenandoahHeapRegion* r = get_region(i - 1);</span>
      if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
        ShenandoahHeapLocker locker(lock());
        if (r-&gt;is_empty_committed()) {
<span class="line-added">+         // Do not uncommit below minimal capacity</span>
<span class="line-added">+         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          r-&gt;make_uncommitted();
          count++;
        }
      }
      SpinPause(); // allow allocators to take the lock
    }
  
    if (count &gt; 0) {
      control_thread()-&gt;notify_heap_changed();
    }
  }
  
  HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,11 ***</span>
  
    } else {
      assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
      result = allocate_memory_under_lock(req, in_new_region);
      // Do not call handle_alloc_failure() here, because we cannot block.
<span class="line-modified">!     // The allocation failure would be handled by the WB slowpath with handle_alloc_failure_evac().</span>
    }
  
    if (in_new_region) {
      control_thread()-&gt;notify_heap_changed();
    }
<span class="line-new-header">--- 839,11 ---</span>
  
    } else {
      assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
      result = allocate_memory_under_lock(req, in_new_region);
      // Do not call handle_alloc_failure() here, because we cannot block.
<span class="line-modified">!     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().</span>
    }
  
    if (in_new_region) {
      control_thread()-&gt;notify_heap_changed();
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 825,53 ***</span>
  HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
    ShenandoahHeapLocker locker(lock());
    return _free_set-&gt;allocate(req, in_new_region);
  }
  
<span class="line-removed">- class ShenandoahMemAllocator : public MemAllocator {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   MemAllocator&amp; _initializer;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahMemAllocator(MemAllocator&amp; initializer, Klass* klass, size_t word_size, Thread* thread) :</span>
<span class="line-removed">-   MemAllocator(klass, word_size + ShenandoahBrooksPointer::word_size(), thread),</span>
<span class="line-removed">-     _initializer(initializer) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">- protected:</span>
<span class="line-removed">-   virtual HeapWord* mem_allocate(Allocation&amp; allocation) const {</span>
<span class="line-removed">-     HeapWord* result = MemAllocator::mem_allocate(allocation);</span>
<span class="line-removed">-     // Initialize brooks-pointer</span>
<span class="line-removed">-     if (result != NULL) {</span>
<span class="line-removed">-       result += ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">-       ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-removed">-       assert(! ShenandoahHeap::heap()-&gt;in_collection_set(result), &quot;never allocate in targetted region&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual oop initialize(HeapWord* mem) const {</span>
<span class="line-removed">-      return _initializer.initialize(mem);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- oop ShenandoahHeap::obj_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed">-   ObjAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed">-   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed">-   return allocator.allocate();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- oop ShenandoahHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {</span>
<span class="line-removed">-   ObjArrayAllocator initializer(klass, size, length, do_zero, THREAD);</span>
<span class="line-removed">-   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed">-   return allocator.allocate();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- oop ShenandoahHeap::class_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed">-   ClassAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed">-   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed">-   return allocator.allocate();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  HeapWord* ShenandoahHeap::mem_allocate(size_t size,
                                          bool*  gc_overhead_limit_was_exceeded) {
    ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
    return allocate_memory(req);
  }
<span class="line-new-header">--- 876,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,67 ***</span>
  
    // Out of memory
    return NULL;
  }
  
<span class="line-removed">- void ShenandoahHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {</span>
<span class="line-removed">-   HeapWord* obj = tlab_post_allocation_setup(start);</span>
<span class="line-removed">-   CollectedHeap::fill_with_object(obj, end);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- size_t ShenandoahHeap::min_dummy_object_size() const {</span>
<span class="line-removed">-   return CollectedHeap::min_dummy_object_size() + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ShenandoahEvacuateUpdateRootsClosure: public BasicOopIterateClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ShenandoahHeap* _heap;</span>
<span class="line-removed">-   Thread* _thread;</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahEvacuateUpdateRootsClosure() :</span>
<span class="line-removed">-     _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   template &lt;class T&gt;</span>
<span class="line-removed">-   void do_oop_work(T* p) {</span>
<span class="line-removed">-     assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed">-     if (! CompressedOops::is_null(o)) {</span>
<span class="line-removed">-       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed">-       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="line-removed">-         shenandoah_assert_marked(p, obj);</span>
<span class="line-removed">-         oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">-         if (oopDesc::equals_raw(resolved, obj)) {</span>
<span class="line-removed">-           resolved = _heap-&gt;evacuate_object(obj, _thread);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, resolved);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   void do_oop(oop* p) {</span>
<span class="line-removed">-     do_oop_work(p);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   void do_oop(narrowOop* p) {</span>
<span class="line-removed">-     do_oop_work(p);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
  private:
    ShenandoahHeap* const _heap;
    Thread* const _thread;
  public:
    ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
      _heap(heap), _thread(Thread::current()) {}
  
    void do_object(oop p) {
      shenandoah_assert_marked(NULL, p);
<span class="line-modified">!     if (oopDesc::equals_raw(p, ShenandoahBarrierSet::resolve_forwarded_not_null(p))) {</span>
        _heap-&gt;evacuate_object(p, _thread);
      }
    }
  };
  
<span class="line-new-header">--- 918,21 ---</span>
  
    // Out of memory
    return NULL;
  }
  
  class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
  private:
    ShenandoahHeap* const _heap;
    Thread* const _thread;
  public:
    ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
      _heap(heap), _thread(Thread::current()) {}
  
    void do_object(oop p) {
      shenandoah_assert_marked(NULL, p);
<span class="line-modified">!     if (!p-&gt;is_forwarded()) {</span>
        _heap-&gt;evacuate_object(p, _thread);
      }
    }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1005,11 ***</span>
  private:
    void do_work() {
      ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
      ShenandoahHeapRegion* r;
      while ((r =_cs-&gt;claim_next()) != NULL) {
<span class="line-modified">!       assert(r-&gt;has_live(), &quot;all-garbage regions are reclaimed early&quot;);</span>
        _sh-&gt;marked_object_iterate(r, &amp;cl);
  
        if (ShenandoahPacing) {
          _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
        }
<span class="line-new-header">--- 967,11 ---</span>
  private:
    void do_work() {
      ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
      ShenandoahHeapRegion* r;
      while ((r =_cs-&gt;claim_next()) != NULL) {
<span class="line-modified">!       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;region_number());</span>
        _sh-&gt;marked_object_iterate(r, &amp;cl);
  
        if (ShenandoahPacing) {
          _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1046,12 ***</span>
  }
  
  void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
    assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
  
<span class="line-modified">!   oop humongous_obj = oop(start-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">!   size_t size = humongous_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
    size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
    size_t index = start-&gt;region_number() + required_regions - 1;
  
    assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
  
<span class="line-new-header">--- 1008,12 ---</span>
  }
  
  void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
    assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
  
<span class="line-modified">!   oop humongous_obj = oop(start-&gt;bottom());</span>
<span class="line-modified">!   size_t size = humongous_obj-&gt;size();</span>
    size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
    size_t index = start-&gt;region_number() + required_regions - 1;
  
    assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1101,44 ***</span>
      _rp(rp) {}
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
      ShenandoahEvacOOMScope oom_evac_scope;
<span class="line-modified">!     ShenandoahEvacuateUpdateRootsClosure cl;</span>
<span class="line-removed">- </span>
      MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
<span class="line-modified">!     _rp-&gt;process_evacuate_roots(&amp;cl, &amp;blobsCl, worker_id);</span>
    }
  };
  
  void ShenandoahHeap::evacuate_and_update_roots() {
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
    DerivedPointerTable::clear();
  #endif
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
<span class="line-removed">- </span>
    {
<span class="line-modified">!     ShenandoahRootEvacuator rp(this, workers()-&gt;active_workers(), ShenandoahPhaseTimings::init_evac);</span>
      ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
      workers()-&gt;run_task(&amp;roots_task);
    }
  
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
    DerivedPointerTable::update_pointers();
  #endif
  }
  
<span class="line-removed">- void ShenandoahHeap::roots_iterate(OopClosure* cl) {</span>
<span class="line-removed">-   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   CodeBlobToOopClosure blobsCl(cl, false);</span>
<span class="line-removed">-   CLDToOopClosure cldCl(cl, ClassLoaderData::_claim_strong);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
<span class="line-removed">-   rp.process_all_roots(cl, NULL, &amp;cldCl, &amp;blobsCl, NULL, 0);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Returns size in bytes
  size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
    if (ShenandoahElasticTLAB) {
      // With Elastic TLABs, return the max allowed size, and let the allocation path
      // figure out the safe size for current allocation.
<span class="line-new-header">--- 1063,36 ---</span>
      _rp(rp) {}
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
      ShenandoahEvacOOMScope oom_evac_scope;
<span class="line-modified">!     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
      MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
<span class="line-modified">!     _rp-&gt;roots_do(worker_id, &amp;cl);</span>
    }
  };
  
  void ShenandoahHeap::evacuate_and_update_roots() {
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
    DerivedPointerTable::clear();
  #endif
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
    {
<span class="line-modified">!     // Include concurrent roots if current cycle can not process those roots concurrently</span>
<span class="line-added">+     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),</span>
<span class="line-added">+                                ShenandoahPhaseTimings::init_evac,</span>
<span class="line-added">+                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),</span>
<span class="line-added">+                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
      ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
      workers()-&gt;run_task(&amp;roots_task);
    }
  
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
    DerivedPointerTable::update_pointers();
  #endif
  }
  
  // Returns size in bytes
  size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
    if (ShenandoahElasticTLAB) {
      // With Elastic TLABs, return the max allowed size, and let the allocation path
      // figure out the safe size for current allocation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,14 ***</span>
  
  void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
    //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
  }
  
<span class="line-removed">- CollectorPolicy* ShenandoahHeap::collector_policy() const {</span>
<span class="line-removed">-   return _shenandoah_policy;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  HeapWord* ShenandoahHeap::block_start(const void* addr) const {
    Space* sp = heap_region_containing(addr);
    if (sp != NULL) {
      return sp-&gt;block_start(addr);
    }
<span class="line-new-header">--- 1132,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1195,10 ***</span>
<span class="line-new-header">--- 1145,14 ---</span>
  bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
    Space* sp = heap_region_containing(addr);
    return sp-&gt;block_is_obj(addr);
  }
  
<span class="line-added">+ bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">+   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  jlong ShenandoahHeap::millis_since_last_gc() {
    double v = heuristics()-&gt;time_since_last_gc() * 1000;
    assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
    return (jlong)v;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1216,11 ***</span>
    }
  }
  
  void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
    workers()-&gt;threads_do(tcl);
<span class="line-modified">!   _safepoint_workers-&gt;threads_do(tcl);</span>
    if (ShenandoahStringDedup::is_enabled()) {
      ShenandoahStringDedup::threads_do(tcl);
    }
  }
  
<span class="line-new-header">--- 1170,13 ---</span>
    }
  }
  
  void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
    workers()-&gt;threads_do(tcl);
<span class="line-modified">!   if (_safepoint_workers != NULL) {</span>
<span class="line-added">+     _safepoint_workers-&gt;threads_do(tcl);</span>
<span class="line-added">+   }</span>
    if (ShenandoahStringDedup::is_enabled()) {
      ShenandoahStringDedup::threads_do(tcl);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1278,14 ***</span>
    template &lt;class T&gt;
    void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
<span class="line-modified">!       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
        assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<span class="line-modified">!       if (!_bitmap-&gt;is_marked((HeapWord*) obj)) {</span>
<span class="line-modified">!         _bitmap-&gt;mark((HeapWord*) obj);</span>
          _oop_stack-&gt;push(obj);
        }
      }
    }
  public:
<span class="line-new-header">--- 1234,29 ---</span>
    template &lt;class T&gt;
    void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
<span class="line-modified">!       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">+       if (fwd == NULL) {</span>
<span class="line-added">+         // There is an odd interaction with VM_HeapWalkOperation, see jvmtiTagMap.cpp.</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // That operation walks the reachable objects on its own, storing the marking</span>
<span class="line-added">+         // wavefront in the object marks. When it is done, it calls the CollectedHeap</span>
<span class="line-added">+         // to iterate over all objects to clean up the mess. When it reaches here,</span>
<span class="line-added">+         // the Shenandoah fwdptr resolution code encounters the marked objects with</span>
<span class="line-added">+         // NULL forwardee. Trying to act on that would crash the VM. Or fail the</span>
<span class="line-added">+         // asserts, should we go for resolve_forwarded_pointer(obj).</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // Therefore, we have to dodge it by doing the raw access to forwardee, and</span>
<span class="line-added">+         // assuming the object had no forwardee, if that thing is NULL.</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         obj = fwd;</span>
<span class="line-added">+       }</span>
        assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<span class="line-modified">!       if (!_bitmap-&gt;is_marked(obj)) {</span>
<span class="line-modified">!         _bitmap-&gt;mark(obj);</span>
          _oop_stack-&gt;push(obj);
        }
      }
    }
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,16 ***</span>
    // Reset bitmap
    _aux_bit_map.clear();
  
    Stack&lt;oop,mtGC&gt; oop_stack;
  
<span class="line-modified">!   // First, we process all GC roots. This populates the work stack with initial objects.</span>
<span class="line-modified">!   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
    ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
<span class="line-modified">!   CLDToOopClosure clds(&amp;oops, ClassLoaderData::_claim_none);</span>
<span class="line-modified">!   CodeBlobToOopClosure blobs(&amp;oops, false);</span>
<span class="line-modified">!   rp.process_all_roots(&amp;oops, &amp;oops, &amp;clds, &amp;blobs, NULL, 0);</span>
  
    // Work through the oop stack to traverse heap.
    while (! oop_stack.is_empty()) {
      oop obj = oop_stack.pop();
      assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<span class="line-new-header">--- 1301,21 ---</span>
    // Reset bitmap
    _aux_bit_map.clear();
  
    Stack&lt;oop,mtGC&gt; oop_stack;
  
<span class="line-modified">!   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.</span>
<span class="line-modified">!   ShenandoahHeapIterationRootScanner rp;</span>
    ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
<span class="line-modified">! </span>
<span class="line-modified">!   // When concurrent root is in progress, weak roots may contain dead oops, they should not be used</span>
<span class="line-modified">!   // for root scanning.</span>
<span class="line-added">+   if (is_concurrent_root_in_progress()) {</span>
<span class="line-added">+     rp.strong_roots_do(&amp;oops);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     rp.roots_do(&amp;oops);</span>
<span class="line-added">+   }</span>
  
    // Work through the oop stack to traverse heap.
    while (! oop_stack.is_empty()) {
      oop obj = oop_stack.pop();
      assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1352,13 ***</span>
    if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
      log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
    }
  }
  
<span class="line-modified">! void ShenandoahHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-modified">!   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);</span>
<span class="line-modified">!   object_iterate(cl);</span>
  }
  
  void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
    for (size_t i = 0; i &lt; num_regions(); i++) {
      ShenandoahHeapRegion* current = get_region(i);
<span class="line-new-header">--- 1328,15 ---</span>
    if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
      log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
    }
  }
  
<span class="line-modified">! // Keep alive an object that was loaded with AS_NO_KEEPALIVE.</span>
<span class="line-modified">! void ShenandoahHeap::keep_alive(oop obj) {</span>
<span class="line-modified">!   if (is_concurrent_mark_in_progress()) {</span>
<span class="line-added">+     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);</span>
<span class="line-added">+   }</span>
  }
  
  void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
    for (size_t i = 0; i &lt; num_regions(); i++) {
      ShenandoahHeapRegion* current = get_region(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1383,11 ***</span>
    void work(uint worker_id) {
      size_t stride = ShenandoahParallelRegionStride;
  
      size_t max = _heap-&gt;num_regions();
      while (_index &lt; max) {
<span class="line-modified">!       size_t cur = Atomic::add(stride, &amp;_index) - stride;</span>
        size_t start = cur;
        size_t end = MIN2(cur + stride, max);
        if (start &gt;= max) break;
  
        for (size_t i = cur; i &lt; end; i++) {
<span class="line-new-header">--- 1361,11 ---</span>
    void work(uint worker_id) {
      size_t stride = ShenandoahParallelRegionStride;
  
      size_t max = _heap-&gt;num_regions();
      while (_index &lt; max) {
<span class="line-modified">!       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);</span>
        size_t start = cur;
        size_t end = MIN2(cur + stride, max);
        if (start &gt;= max) break;
  
        for (size_t i = cur; i &lt; end; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1506,41 ***</span>
    // get unmarked objects in the roots.
  
    if (!cancelled_gc()) {
      concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
  
<span class="line-modified">!     if (has_forwarded_objects()) {</span>
<span class="line-modified">!       concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     stop_concurrent_marking();</span>
  
      {
        ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
<span class="line-removed">- </span>
<span class="line-removed">-       // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-removed">-       // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
        ShenandoahCompleteLivenessClosure cl;
        parallel_heap_region_iterate(&amp;cl);
      }
  
      {
<span class="line-modified">!       ShenandoahGCPhase prepare_evac(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-removed">- </span>
        make_parsable(true);
  
        trash_cset_regions();
  
<span class="line-modified">!       {</span>
<span class="line-modified">!         ShenandoahHeapLocker locker(lock());</span>
<span class="line-modified">!         _collection_set-&gt;clear();</span>
<span class="line-modified">!         _free_set-&gt;clear();</span>
  
<span class="line-modified">!         heuristics()-&gt;choose_collection_set(_collection_set);</span>
  
<span class="line-modified">!         _free_set-&gt;rebuild();</span>
<span class="line-modified">!       }</span>
      }
  
      // If collection set has candidates, start evacuation.
      // Otherwise, bypass the rest of the cycle.
      if (!collection_set()-&gt;is_empty()) {
<span class="line-new-header">--- 1484,72 ---</span>
    // get unmarked objects in the roots.
  
    if (!cancelled_gc()) {
      concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
  
<span class="line-modified">!     // Marking is completed, deactivate SATB barrier</span>
<span class="line-modified">!     set_concurrent_mark_in_progress(false);</span>
<span class="line-modified">!     mark_complete_marking_context();</span>
  
<span class="line-modified">!     parallel_cleaning(false /* full gc*/);</span>
  
<span class="line-added">+     if (has_forwarded_objects()) {</span>
<span class="line-added">+       // Degen may be caused by failed evacuation of roots</span>
<span class="line-added">+       if (is_degenerated_gc_in_progress()) {</span>
<span class="line-added">+         concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       set_has_forwarded_objects(false);</span>
<span class="line-added">+    }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (ShenandoahVerify) {</span>
<span class="line-added">+       verifier()-&gt;verify_roots_no_forwarded();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-added">+     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
      {
        ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
        ShenandoahCompleteLivenessClosure cl;
        parallel_heap_region_iterate(&amp;cl);
      }
  
<span class="line-added">+     // Force the threads to reacquire their TLABs outside the collection set.</span>
      {
<span class="line-modified">!       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);</span>
        make_parsable(true);
<span class="line-added">+     }</span>
  
<span class="line-added">+     // We are about to select the collection set, make sure it knows about</span>
<span class="line-added">+     // current pinning status. Also, this allows trashing more regions that</span>
<span class="line-added">+     // now have their pinning status dropped.</span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahGCPhase phase(ShenandoahPhaseTimings::sync_pinned);</span>
<span class="line-added">+       sync_pinned_region_status();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Trash the collection set left over from previous cycle, if any.</span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahGCPhase phase(ShenandoahPhaseTimings::trash_cset);</span>
        trash_cset_regions();
<span class="line-added">+     }</span>
  
<span class="line-modified">!     {</span>
<span class="line-modified">!       ShenandoahGCPhase phase(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       ShenandoahHeapLocker locker(lock());</span>
<span class="line-added">+       _collection_set-&gt;clear();</span>
<span class="line-added">+       _free_set-&gt;clear();</span>
  
<span class="line-modified">!       heuristics()-&gt;choose_collection_set(_collection_set);</span>
  
<span class="line-modified">!       _free_set-&gt;rebuild();</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">+       prepare_concurrent_roots();</span>
<span class="line-added">+       prepare_concurrent_unloading();</span>
      }
  
      // If collection set has candidates, start evacuation.
      // Otherwise, bypass the rest of the cycle.
      if (!collection_set()-&gt;is_empty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1552,15 ***</span>
  
        set_evacuation_in_progress(true);
        // From here on, we need to update references.
        set_has_forwarded_objects(true);
  
<span class="line-modified">!       evacuate_and_update_roots();</span>
  
        if (ShenandoahPacing) {
          pacer()-&gt;setup_for_evac();
        }
      } else {
        if (ShenandoahVerify) {
          verifier()-&gt;verify_after_concmark();
        }
  
<span class="line-new-header">--- 1561,35 ---</span>
  
        set_evacuation_in_progress(true);
        // From here on, we need to update references.
        set_has_forwarded_objects(true);
  
<span class="line-modified">!       if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">+         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+           ShenandoahCodeRoots::arm_nmethods();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         evacuate_and_update_roots();</span>
<span class="line-added">+       }</span>
  
        if (ShenandoahPacing) {
          pacer()-&gt;setup_for_evac();
        }
<span class="line-added">+ </span>
<span class="line-added">+       if (ShenandoahVerify) {</span>
<span class="line-added">+         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;</span>
<span class="line-added">+         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">+           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);</span>
<span class="line-added">+           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);</span>
<span class="line-added">+           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         verifier()-&gt;verify_roots_no_forwarded_except(types);</span>
<span class="line-added">+         verifier()-&gt;verify_during_evacuation();</span>
<span class="line-added">+       }</span>
      } else {
        if (ShenandoahVerify) {
          verifier()-&gt;verify_after_concmark();
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,12 ***</span>
          Universe::verify();
        }
      }
  
    } else {
      concurrent_mark()-&gt;cancel();
<span class="line-modified">!     stop_concurrent_marking();</span>
  
      if (process_references()) {
        // Abandon reference processing right away: pre-cleaning must have failed.
        ReferenceProcessor *rp = ref_processor();
        rp-&gt;disable_discovery();
<span class="line-new-header">--- 1597,14 ---</span>
          Universe::verify();
        }
      }
  
    } else {
<span class="line-added">+     // If this cycle was updating references, we need to keep the has_forwarded_objects</span>
<span class="line-added">+     // flag on, for subsequent phases to deal with it.</span>
      concurrent_mark()-&gt;cancel();
<span class="line-modified">!     set_concurrent_mark_in_progress(false);</span>
  
      if (process_references()) {
        // Abandon reference processing right away: pre-cleaning must have failed.
        ReferenceProcessor *rp = ref_processor();
        rp-&gt;disable_discovery();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,11 ***</span>
  void ShenandoahHeap::op_final_evac() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
  
    set_evacuation_in_progress(false);
  
<span class="line-modified">!   retire_and_reset_gclabs();</span>
  
    if (ShenandoahVerify) {
      verifier()-&gt;verify_after_evacuation();
    }
  
<span class="line-new-header">--- 1617,14 ---</span>
  void ShenandoahHeap::op_final_evac() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
  
    set_evacuation_in_progress(false);
  
<span class="line-modified">!   {</span>
<span class="line-added">+     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_retire_gclabs);</span>
<span class="line-added">+     retire_and_reset_gclabs();</span>
<span class="line-added">+   }</span>
  
    if (ShenandoahVerify) {
      verifier()-&gt;verify_after_evacuation();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1615,10 ***</span>
<span class="line-new-header">--- 1649,172 ---</span>
  
  void ShenandoahHeap::op_cleanup() {
    free_set()-&gt;recycle_trash();
  }
  
<span class="line-added">+ class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;</span>
<span class="line-added">+   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;</span>
<span class="line-added">+   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;</span>
<span class="line-added">+   ShenandoahConcurrentStringDedupRoots          _dedup_roots;</span>
<span class="line-added">+   bool                                          _include_weak_roots;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :</span>
<span class="line-added">+     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),</span>
<span class="line-added">+     _include_weak_roots(include_weak_roots) {</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void work(uint worker_id) {</span>
<span class="line-added">+     ShenandoahEvacOOMScope oom;</span>
<span class="line-added">+     {</span>
<span class="line-added">+       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration</span>
<span class="line-added">+       // may race against OopStorage::release() calls.</span>
<span class="line-added">+       ShenandoahEvacUpdateOopStorageRootsClosure cl;</span>
<span class="line-added">+       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (_include_weak_roots) {</span>
<span class="line-added">+         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-added">+       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added">+       _cld_roots.cld_do(&amp;clds);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">+       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;</span>
<span class="line-added">+       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahHeap* const _heap;</span>
<span class="line-added">+   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-added">+   bool  _evac_in_progress;</span>
<span class="line-added">+   Thread* const _thread;</span>
<span class="line-added">+   size_t  _dead_counter;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();</span>
<span class="line-added">+   void do_oop(oop* p);</span>
<span class="line-added">+   void do_oop(narrowOop* p);</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t dead_counter() const;</span>
<span class="line-added">+   void reset_dead_counter();</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :</span>
<span class="line-added">+   _heap(ShenandoahHeap::heap()),</span>
<span class="line-added">+   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),</span>
<span class="line-added">+   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),</span>
<span class="line-added">+   _thread(Thread::current()),</span>
<span class="line-added">+   _dead_counter(0) {</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {</span>
<span class="line-added">+   const oop obj = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+   if (!CompressedOops::is_null(obj)) {</span>
<span class="line-added">+     if (!_mark_context-&gt;is_marked(obj)) {</span>
<span class="line-added">+       shenandoah_assert_correct(p, obj);</span>
<span class="line-added">+       oop old = Atomic::cmpxchg(p, obj, oop(NULL));</span>
<span class="line-added">+       if (obj == old) {</span>
<span class="line-added">+         _dead_counter ++;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {</span>
<span class="line-added">+       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-added">+       if (resolved == obj) {</span>
<span class="line-added">+         resolved = _heap-&gt;evacuate_object(obj, _thread);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       Atomic::cmpxchg(p, obj, resolved);</span>
<span class="line-added">+       assert(_heap-&gt;cancelled_gc() ||</span>
<span class="line-added">+              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),</span>
<span class="line-added">+              &quot;Sanity&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {</span>
<span class="line-added">+   ShouldNotReachHere();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {</span>
<span class="line-added">+   return _dead_counter;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {</span>
<span class="line-added">+   _dead_counter = 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;</span>
<span class="line-added">+ // dead weak roots.</span>
<span class="line-added">+ class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;</span>
<span class="line-added">+   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;</span>
<span class="line-added">+   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;</span>
<span class="line-added">+   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahConcurrentWeakRootsEvacUpdateTask() :</span>
<span class="line-added">+     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),</span>
<span class="line-added">+     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),</span>
<span class="line-added">+     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),</span>
<span class="line-added">+     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),</span>
<span class="line-added">+     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots) {</span>
<span class="line-added">+     StringTable::reset_dead_counter();</span>
<span class="line-added">+     ResolvedMethodTable::reset_dead_counter();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {</span>
<span class="line-added">+     StringTable::finish_dead_counter();</span>
<span class="line-added">+     ResolvedMethodTable::finish_dead_counter();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void work(uint worker_id) {</span>
<span class="line-added">+     ShenandoahEvacOOMScope oom;</span>
<span class="line-added">+     // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration</span>
<span class="line-added">+     // may race against OopStorage::release() calls.</span>
<span class="line-added">+     ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;</span>
<span class="line-added">+     _jni_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">+     _vm_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">+ </span>
<span class="line-added">+     cl.reset_dead_counter();</span>
<span class="line-added">+     _string_table_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">+     StringTable::inc_dead_counter(cl.dead_counter());</span>
<span class="line-added">+ </span>
<span class="line-added">+     cl.reset_dead_counter();</span>
<span class="line-added">+     _resolved_method_table_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">+     ResolvedMethodTable::inc_dead_counter(cl.dead_counter());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::op_roots() {</span>
<span class="line-added">+   if (is_concurrent_root_in_progress()) {</span>
<span class="line-added">+     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+       // Concurrent weak root processing</span>
<span class="line-added">+       ShenandoahConcurrentWeakRootsEvacUpdateTask task;</span>
<span class="line-added">+       workers()-&gt;run_task(&amp;task);</span>
<span class="line-added">+ </span>
<span class="line-added">+       _unloader.unload();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">+       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">+       workers()-&gt;run_task(&amp;task);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   set_concurrent_root_in_progress(false);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ShenandoahHeap::op_reset() {
    reset_mark_bitmap();
  }
  
  void ShenandoahHeap::op_preclean() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1646,13 ***</span>
      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
      resize_all_tlabs();
    }
  
    metrics.snap_after();
<span class="line-removed">-   metrics.print();</span>
  
<span class="line-modified">!   if (metrics.is_good_progress(&quot;Full GC&quot;)) {</span>
      _progress_last_gc.set();
    } else {
      // Nothing to do. Tell the allocation path that we have failed to make
      // progress, and it can finally fail.
      _progress_last_gc.unset();
<span class="line-new-header">--- 1842,12 ---</span>
      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
      resize_all_tlabs();
    }
  
    metrics.snap_after();
  
<span class="line-modified">!   if (metrics.is_good_progress()) {</span>
      _progress_last_gc.set();
    } else {
      // Nothing to do. Tell the allocation path that we have failed to make
      // progress, and it can finally fail.
      _progress_last_gc.unset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,11 ***</span>
        // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
        // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
        set_process_references(heuristics()-&gt;can_process_references());
        set_unload_classes(heuristics()-&gt;can_unload_classes());
  
<span class="line-modified">!       if (heuristics()-&gt;can_do_traversal_gc()) {</span>
          // Not possible to degenerate from here, upgrade to Full GC right away.
          cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
          op_degenerated_fail();
          return;
        }
<span class="line-new-header">--- 1897,11 ---</span>
        // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
        // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
        set_process_references(heuristics()-&gt;can_process_references());
        set_unload_classes(heuristics()-&gt;can_unload_classes());
  
<span class="line-modified">!       if (is_traversal_mode()) {</span>
          // Not possible to degenerate from here, upgrade to Full GC right away.
          cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
          op_degenerated_fail();
          return;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1737,11 ***</span>
          // collection set un-evacuated. Restart evacuation from the beginning to
          // capture all objects. For all the objects that are already evacuated,
          // it would be a simple check, which is supposed to be fast. This is also
          // safe to do even without degeneration, as CSet iterator is at beginning
          // in preparation for evacuation anyway.
<span class="line-modified">!         collection_set()-&gt;clear_current_index();</span>
  
          op_stw_evac();
          if (cancelled_gc()) {
            op_degenerated_fail();
            return;
<span class="line-new-header">--- 1932,33 ---</span>
          // collection set un-evacuated. Restart evacuation from the beginning to
          // capture all objects. For all the objects that are already evacuated,
          // it would be a simple check, which is supposed to be fast. This is also
          // safe to do even without degeneration, as CSet iterator is at beginning
          // in preparation for evacuation anyway.
<span class="line-modified">!         //</span>
<span class="line-added">+         // Before doing that, we need to make sure we never had any cset-pinned</span>
<span class="line-added">+         // regions. This may happen if allocation failure happened when evacuating</span>
<span class="line-added">+         // the about-to-be-pinned object, oom-evac protocol left the object in</span>
<span class="line-added">+         // the collection set, and then the pin reached the cset region. If we continue</span>
<span class="line-added">+         // the cycle here, we would trash the cset and alive objects in it. To avoid</span>
<span class="line-added">+         // it, we fail degeneration right away and slide into Full GC to recover.</span>
<span class="line-added">+ </span>
<span class="line-added">+         {</span>
<span class="line-added">+           sync_pinned_region_status();</span>
<span class="line-added">+           collection_set()-&gt;clear_current_index();</span>
<span class="line-added">+ </span>
<span class="line-added">+           ShenandoahHeapRegion* r;</span>
<span class="line-added">+           while ((r = collection_set()-&gt;next()) != NULL) {</span>
<span class="line-added">+             if (r-&gt;is_pinned()) {</span>
<span class="line-added">+               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);</span>
<span class="line-added">+               op_degenerated_fail();</span>
<span class="line-added">+               return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           collection_set()-&gt;clear_current_index();</span>
<span class="line-added">+         }</span>
  
          op_stw_evac();
          if (cancelled_gc()) {
            op_degenerated_fail();
            return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1781,15 ***</span>
    if (VerifyAfterGC) {
      Universe::verify();
    }
  
    metrics.snap_after();
<span class="line-removed">-   metrics.print();</span>
  
    // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
    // because that probably means the heap is overloaded and/or fragmented.
<span class="line-modified">!   if (!metrics.is_good_progress(&quot;Degenerated GC&quot;)) {</span>
      _progress_last_gc.unset();
      cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
      op_degenerated_futile();
    } else {
      _progress_last_gc.set();
<span class="line-new-header">--- 1998,14 ---</span>
    if (VerifyAfterGC) {
      Universe::verify();
    }
  
    metrics.snap_after();
  
    // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
    // because that probably means the heap is overloaded and/or fragmented.
<span class="line-modified">!   if (!metrics.is_good_progress()) {</span>
      _progress_last_gc.unset();
      cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
      op_degenerated_futile();
    } else {
      _progress_last_gc.set();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1805,21 ***</span>
  void ShenandoahHeap::op_degenerated_futile() {
    shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
    op_full(GCCause::_shenandoah_upgrade_to_full_gc);
  }
  
<span class="line-removed">- void ShenandoahHeap::stop_concurrent_marking() {</span>
<span class="line-removed">-   assert(is_concurrent_mark_in_progress(), &quot;How else could we get here?&quot;);</span>
<span class="line-removed">-   if (!cancelled_gc()) {</span>
<span class="line-removed">-     // If we needed to update refs, and concurrent marking has been cancelled,</span>
<span class="line-removed">-     // we need to finish updating references.</span>
<span class="line-removed">-     set_has_forwarded_objects(false);</span>
<span class="line-removed">-     mark_complete_marking_context();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   set_concurrent_mark_in_progress(false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ShenandoahHeap::force_satb_flush_all_threads() {
    if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {
      // No need to flush SATBs
      return;
    }
<span class="line-new-header">--- 2021,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1843,54 ***</span>
    _gc_state.set_cond(mask, value);
    set_gc_state_all_threads(_gc_state.raw_value());
  }
  
  void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
<span class="line-modified">!   set_gc_state_mask(MARKING, in_progress);</span>
    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
  }
  
  void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
<span class="line-modified">!    set_gc_state_mask(TRAVERSAL | HAS_FORWARDED, in_progress);</span>
     ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
  }
  
  void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
    set_gc_state_mask(EVACUATION, in_progress);
  }
  
<span class="line-modified">! HeapWord* ShenandoahHeap::tlab_post_allocation_setup(HeapWord* obj) {</span>
<span class="line-modified">!   // Initialize Brooks pointer for the next object</span>
<span class="line-modified">!   HeapWord* result = obj + ShenandoahBrooksPointer::word_size();</span>
<span class="line-modified">!   ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-modified">!   return result;</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ShenandoahForwardedIsAliveClosure::ShenandoahForwardedIsAliveClosure() :</span>
<span class="line-removed">-   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ShenandoahIsAliveClosure::ShenandoahIsAliveClosure() :</span>
<span class="line-removed">-   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahForwardedIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">-   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">-   shenandoah_assert_not_forwarded_if(NULL, obj, ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress() || ShenandoahHeap::heap()-&gt;is_concurrent_traversal_in_progress());</span>
<span class="line-removed">-   return _mark_context-&gt;is_marked(obj);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">-   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">-     return false;</span>
    }
<span class="line-removed">-   shenandoah_assert_not_forwarded(NULL, obj);</span>
<span class="line-removed">-   return _mark_context-&gt;is_marked(obj);</span>
  }
  
  void ShenandoahHeap::ref_processing_init() {
    assert(_max_workers &gt; 0, &quot;Sanity&quot;);
  
<span class="line-new-header">--- 2048,35 ---</span>
    _gc_state.set_cond(mask, value);
    set_gc_state_all_threads(_gc_state.raw_value());
  }
  
  void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
<span class="line-modified">!   if (has_forwarded_objects()) {</span>
<span class="line-added">+     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     set_gc_state_mask(MARKING, in_progress);</span>
<span class="line-added">+   }</span>
    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
  }
  
  void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
<span class="line-modified">!    set_gc_state_mask(TRAVERSAL, in_progress);</span>
     ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
  }
  
  void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
    set_gc_state_mask(EVACUATION, in_progress);
  }
  
<span class="line-modified">! void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {</span>
<span class="line-modified">!   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);</span>
<span class="line-modified">!   if (in_progress) {</span>
<span class="line-modified">!     _concurrent_root_in_progress.set();</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     _concurrent_root_in_progress.unset();</span>
    }
  }
  
  void ShenandoahHeap::ref_processing_init() {
    assert(_max_workers &gt; 0, &quot;Sanity&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1920,11 ***</span>
      jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
      if (prev == CANCELLABLE) return true;
      else if (prev == CANCELLED) return false;
      assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
      assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
<span class="line-modified">!     {</span>
        // We need to provide a safepoint here, otherwise we might
        // spin forever if a SP is pending.
        ThreadBlockInVM sp(JavaThread::current());
        SpinPause();
      }
<span class="line-new-header">--- 2106,11 ---</span>
      jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
      if (prev == CANCELLABLE) return true;
      else if (prev == CANCELLED) return false;
      assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
      assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
<span class="line-modified">!     if (Thread::current()-&gt;is_Java_thread()) {</span>
        // We need to provide a safepoint here, otherwise we might
        // spin forever if a SP is pending.
        ThreadBlockInVM sp(JavaThread::current());
        SpinPause();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1964,20 ***</span>
    if (ShenandoahStringDedup::is_enabled()) {
      ShenandoahStringDedup::stop();
    }
  }
  
<span class="line-modified">! void ShenandoahHeap::unload_classes_and_cleanup_tables(bool full_gc) {</span>
<span class="line-modified">!   assert(heuristics()-&gt;can_unload_classes(), &quot;Class unloading should be enabled&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-removed">-                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-removed">-                                ShenandoahPhaseTimings::purge);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ShenandoahIsAliveSelector alive;</span>
<span class="line-removed">-   BoolObjectClosure* is_alive = alive.is_alive_closure();</span>
<span class="line-removed">- </span>
    bool purged_class;
  
    // Unload classes and purge SystemDictionary.
    {
      ShenandoahGCPhase phase(full_gc ?
<span class="line-new-header">--- 2150,12 ---</span>
    if (ShenandoahStringDedup::is_enabled()) {
      ShenandoahStringDedup::stop();
    }
  }
  
<span class="line-modified">! void ShenandoahHeap::stw_unload_classes(bool full_gc) {</span>
<span class="line-modified">!   if (!unload_classes()) return;</span>
    bool purged_class;
  
    // Unload classes and purge SystemDictionary.
    {
      ShenandoahGCPhase phase(full_gc ?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1988,25 ***</span>
  
    {
      ShenandoahGCPhase phase(full_gc ?
                              ShenandoahPhaseTimings::full_gc_purge_par :
                              ShenandoahPhaseTimings::purge_par);
<span class="line-modified">!     uint active = _workers-&gt;active_workers();</span>
<span class="line-modified">!     ParallelCleaningTask unlink_task(is_alive, active, purged_class, true);</span>
      _workers-&gt;run_task(&amp;unlink_task);
    }
  
    {
      ShenandoahGCPhase phase(full_gc ?
<span class="line-modified">!                       ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">!                       ShenandoahPhaseTimings::purge_cldg);</span>
      ClassLoaderDataGraph::purge();
    }
  }
  
  void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<span class="line-modified">!   set_gc_state_mask(HAS_FORWARDED, cond);</span>
  }
  
  void ShenandoahHeap::set_process_references(bool pr) {
    _process_references.set_cond(pr);
  }
<span class="line-new-header">--- 2166,86 ---</span>
  
    {
      ShenandoahGCPhase phase(full_gc ?
                              ShenandoahPhaseTimings::full_gc_purge_par :
                              ShenandoahPhaseTimings::purge_par);
<span class="line-modified">!     ShenandoahIsAliveSelector is_alive;</span>
<span class="line-modified">!     uint num_workers = _workers-&gt;active_workers();</span>
<span class="line-added">+     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);</span>
      _workers-&gt;run_task(&amp;unlink_task);
    }
  
    {
      ShenandoahGCPhase phase(full_gc ?
<span class="line-modified">!                             ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">!                             ShenandoahPhaseTimings::purge_cldg);</span>
      ClassLoaderDataGraph::purge();
    }
<span class="line-added">+   // Resize and verify metaspace</span>
<span class="line-added">+   MetaspaceGC::compute_new_size();</span>
<span class="line-added">+   MetaspaceUtils::verify_metrics();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),</span>
<span class="line-added">+ // so they should not have forwarded oops.</span>
<span class="line-added">+ // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done</span>
<span class="line-added">+ // in concurrent cycles.</span>
<span class="line-added">+ void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {</span>
<span class="line-added">+   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-added">+                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-added">+                                ShenandoahPhaseTimings::purge);</span>
<span class="line-added">+   uint num_workers = _workers-&gt;active_workers();</span>
<span class="line-added">+   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?</span>
<span class="line-added">+                                                ShenandoahPhaseTimings::full_gc_purge_par :</span>
<span class="line-added">+                                                ShenandoahPhaseTimings::purge_par;</span>
<span class="line-added">+   // Cleanup weak roots</span>
<span class="line-added">+   ShenandoahGCPhase phase(timing_phase);</span>
<span class="line-added">+   phase_timings()-&gt;record_workers_start(timing_phase);</span>
<span class="line-added">+   if (has_forwarded_objects()) {</span>
<span class="line-added">+     if (is_traversal_mode()) {</span>
<span class="line-added">+       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">+       ShenandoahTraversalUpdateRefsClosure keep_alive;</span>
<span class="line-added">+       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahTraversalUpdateRefsClosure&gt;</span>
<span class="line-added">+         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">+       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">+       ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-added">+       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-added">+         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">+       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+     ShenandoahAssertNotForwardedClosure verify_cl;</span>
<span class="line-added">+     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;</span>
<span class="line-added">+       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;</span>
<span class="line-added">+       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   phase_timings()-&gt;record_workers_end(timing_phase);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::parallel_cleaning(bool full_gc) {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+   stw_process_weak_roots(full_gc);</span>
<span class="line-added">+   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+     stw_unload_classes(full_gc);</span>
<span class="line-added">+   }</span>
  }
  
  void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<span class="line-modified">!   if (is_traversal_mode()) {</span>
<span class="line-added">+     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     set_gc_state_mask(HAS_FORWARDED, cond);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  }
  
  void ShenandoahHeap::set_process_references(bool pr) {
    _process_references.set_cond(pr);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2036,15 ***</span>
  address ShenandoahHeap::gc_state_addr() {
    return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
  }
  
  size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
<span class="line-modified">!   return OrderAccess::load_acquire(&amp;_bytes_allocated_since_gc_start);</span>
  }
  
  void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
<span class="line-modified">!   OrderAccess::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);</span>
  }
  
  void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
    _degenerated_gc_in_progress.set_cond(in_progress);
  }
<span class="line-new-header">--- 2275,15 ---</span>
  address ShenandoahHeap::gc_state_addr() {
    return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
  }
  
  size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
<span class="line-modified">!   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);</span>
  }
  
  void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
<span class="line-modified">!   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);</span>
  }
  
  void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
    _degenerated_gc_in_progress.set_cond(in_progress);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2061,34 ***</span>
  void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
    set_gc_state_mask(UPDATEREFS, in_progress);
  }
  
  void ShenandoahHeap::register_nmethod(nmethod* nm) {
<span class="line-modified">!   ShenandoahCodeRoots::add_nmethod(nm);</span>
  }
  
  void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
<span class="line-modified">!   ShenandoahCodeRoots::remove_nmethod(nm);</span>
  }
  
  oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
<span class="line-modified">!   o = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(o);</span>
<span class="line-removed">-   ShenandoahHeapLocker locker(lock());</span>
<span class="line-removed">-   heap_region_containing(o)-&gt;make_pinned();</span>
    return o;
  }
  
  void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
<span class="line-modified">!   o = ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(o);</span>
    ShenandoahHeapLocker locker(lock());
<span class="line-modified">!   heap_region_containing(o)-&gt;make_unpinned();</span>
  }
  
  GCTimer* ShenandoahHeap::gc_timer() const {
    return _gc_timer;
  }
  
  #ifdef ASSERT
  void ShenandoahHeap::assert_gc_workers(uint nworkers) {
    assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
  
    if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
<span class="line-new-header">--- 2300,86 ---</span>
  void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
    set_gc_state_mask(UPDATEREFS, in_progress);
  }
  
  void ShenandoahHeap::register_nmethod(nmethod* nm) {
<span class="line-modified">!   ShenandoahCodeRoots::register_nmethod(nm);</span>
  }
  
  void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
<span class="line-modified">!   ShenandoahCodeRoots::unregister_nmethod(nm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::flush_nmethod(nmethod* nm) {</span>
<span class="line-added">+   ShenandoahCodeRoots::flush_nmethod(nm);</span>
  }
  
  oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
<span class="line-modified">!   heap_region_containing(o)-&gt;record_pin();</span>
    return o;
  }
  
  void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
<span class="line-modified">!   heap_region_containing(o)-&gt;record_unpin();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::sync_pinned_region_status() {</span>
    ShenandoahHeapLocker locker(lock());
<span class="line-modified">! </span>
<span class="line-added">+   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">+     ShenandoahHeapRegion *r = get_region(i);</span>
<span class="line-added">+     if (r-&gt;is_active()) {</span>
<span class="line-added">+       if (r-&gt;is_pinned()) {</span>
<span class="line-added">+         if (r-&gt;pin_count() == 0) {</span>
<span class="line-added">+           r-&gt;make_unpinned();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         if (r-&gt;pin_count() &gt; 0) {</span>
<span class="line-added">+           r-&gt;make_pinned();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert_pinned_region_status();</span>
  }
  
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ void ShenandoahHeap::assert_pinned_region_status() {</span>
<span class="line-added">+   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">+     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-added">+     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),</span>
<span class="line-added">+            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  GCTimer* ShenandoahHeap::gc_timer() const {
    return _gc_timer;
  }
  
<span class="line-added">+ void ShenandoahHeap::prepare_concurrent_roots() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">+     set_concurrent_root_in_progress(true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::prepare_concurrent_unloading() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+     _unloader.prepare();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::finish_concurrent_unloading() {</span>
<span class="line-added">+   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">+   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">+     _unloader.finish();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifdef ASSERT
  void ShenandoahHeap::assert_gc_workers(uint nworkers) {
    assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
  
    if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2173,37 ***</span>
  void ShenandoahHeap::op_init_updaterefs() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
  
    set_evacuation_in_progress(false);
  
<span class="line-modified">!   retire_and_reset_gclabs();</span>
  
    if (ShenandoahVerify) {
      verifier()-&gt;verify_before_updaterefs();
    }
  
    set_update_refs_in_progress(true);
<span class="line-removed">-   make_parsable(true);</span>
<span class="line-removed">-   for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">-     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">-     r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   // Reset iterator.</span>
<span class="line-modified">!   _update_refs_iterator.reset();</span>
  
    if (ShenandoahPacing) {
      pacer()-&gt;setup_for_updaterefs();
    }
  }
  
  void ShenandoahHeap::op_final_updaterefs() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
  
    // Check if there is left-over work, and finish it
    if (_update_refs_iterator.has_next()) {
<span class="line-modified">!     ShenandoahGCPhase final_work(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
  
      // Finish updating references where we left off.
      clear_cancelled_gc();
      update_heap_references(false);
    }
<span class="line-new-header">--- 2464,50 ---</span>
  void ShenandoahHeap::op_init_updaterefs() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
  
    set_evacuation_in_progress(false);
  
<span class="line-modified">!   {</span>
<span class="line-added">+     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);</span>
<span class="line-added">+     retire_and_reset_gclabs();</span>
<span class="line-added">+   }</span>
  
    if (ShenandoahVerify) {
<span class="line-added">+     if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">+       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);</span>
<span class="line-added">+     }</span>
      verifier()-&gt;verify_before_updaterefs();
    }
  
    set_update_refs_in_progress(true);
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);</span>
<span class="line-added">+ </span>
<span class="line-added">+     make_parsable(true);</span>
<span class="line-added">+     for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">+       ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-added">+       r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Reset iterator.</span>
<span class="line-added">+     _update_refs_iterator.reset();</span>
<span class="line-added">+   }</span>
  
    if (ShenandoahPacing) {
      pacer()-&gt;setup_for_updaterefs();
    }
  }
  
  void ShenandoahHeap::op_final_updaterefs() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
  
<span class="line-added">+   finish_concurrent_unloading();</span>
<span class="line-added">+ </span>
    // Check if there is left-over work, and finish it
    if (_update_refs_iterator.has_next()) {
<span class="line-modified">!     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
  
      // Finish updating references where we left off.
      clear_cancelled_gc();
      update_heap_references(false);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2213,17 ***</span>
    if (cancelled_gc()) {
      clear_cancelled_gc();
    }
    assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
  
<span class="line-modified">!   concurrent_mark()-&gt;update_roots(is_degenerated_gc_in_progress() ?</span>
<span class="line-modified">!                                  ShenandoahPhaseTimings::degen_gc_update_roots:</span>
<span class="line-modified">!                                  ShenandoahPhaseTimings::final_update_refs_roots);</span>
  
<span class="line-modified">!   ShenandoahGCPhase final_update_refs(ShenandoahPhaseTimings::final_update_refs_recycle);</span>
  
<span class="line-removed">-   trash_cset_regions();</span>
    set_has_forwarded_objects(false);
    set_update_refs_in_progress(false);
  
    if (ShenandoahVerify) {
      verifier()-&gt;verify_after_updaterefs();
<span class="line-new-header">--- 2517,37 ---</span>
    if (cancelled_gc()) {
      clear_cancelled_gc();
    }
    assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
  
<span class="line-modified">!   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {</span>
<span class="line-modified">!     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);</span>
<span class="line-modified">!   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (is_degenerated_gc_in_progress()) {</span>
<span class="line-added">+     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Has to be done before cset is clear</span>
<span class="line-added">+   if (ShenandoahVerify) {</span>
<span class="line-added">+     verifier()-&gt;verify_roots_in_to_space();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks</span>
<span class="line-added">+   // anymore, as this would allow trashing them below.</span>
<span class="line-added">+   {</span>
<span class="line-added">+     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_sync_pinned);</span>
<span class="line-added">+     sync_pinned_region_status();</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   {</span>
<span class="line-added">+     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);</span>
<span class="line-added">+     trash_cset_regions();</span>
<span class="line-added">+   }</span>
  
    set_has_forwarded_objects(false);
    set_update_refs_in_progress(false);
  
    if (ShenandoahVerify) {
      verifier()-&gt;verify_after_updaterefs();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2489,11 ***</span>
  
  void ShenandoahHeap::entry_init_traversal() {
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
  
<span class="line-modified">!   static const char* msg = &quot;Pause Init Traversal&quot;;</span>
    GCTraceTime(Info, gc) time(msg, gc_timer());
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahWorkerScope scope(workers(),
                                ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
<span class="line-new-header">--- 2813,11 ---</span>
  
  void ShenandoahHeap::entry_init_traversal() {
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
  
<span class="line-modified">!   static const char* msg = init_traversal_event_message();</span>
    GCTraceTime(Info, gc) time(msg, gc_timer());
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahWorkerScope scope(workers(),
                                ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2504,11 ***</span>
  
  void ShenandoahHeap::entry_final_traversal() {
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
  
<span class="line-modified">!   static const char* msg = &quot;Pause Final Traversal&quot;;</span>
    GCTraceTime(Info, gc) time(msg, gc_timer());
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahWorkerScope scope(workers(),
                                ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
<span class="line-new-header">--- 2828,11 ---</span>
  
  void ShenandoahHeap::entry_final_traversal() {
    ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
  
<span class="line-modified">!   static const char* msg = final_traversal_event_message();</span>
    GCTraceTime(Info, gc) time(msg, gc_timer());
    EventMark em(&quot;%s&quot;, msg);
  
    ShenandoahWorkerScope scope(workers(),
                                ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2593,10 ***</span>
<span class="line-new-header">--- 2917,26 ---</span>
                                &quot;concurrent reference update&quot;);
  
    try_inject_alloc_failure();
    op_updaterefs();
  }
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahHeap::entry_roots() {</span>
<span class="line-added">+   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);</span>
<span class="line-added">+ </span>
<span class="line-added">+   static const char* msg = &quot;Concurrent roots processing&quot;;</span>
<span class="line-added">+   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
<span class="line-added">+   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ShenandoahWorkerScope scope(workers(),</span>
<span class="line-added">+                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),</span>
<span class="line-added">+                               &quot;concurrent root processing&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   try_inject_alloc_failure();</span>
<span class="line-added">+   op_roots();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ShenandoahHeap::entry_cleanup() {
    ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);
  
    static const char* msg = &quot;Concurrent cleanup&quot;;
    GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2640,11 ***</span>
      op_preclean();
    }
  }
  
  void ShenandoahHeap::entry_traversal() {
<span class="line-modified">!   static const char* msg = &quot;Concurrent traversal&quot;;</span>
    GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
    EventMark em(&quot;%s&quot;, msg);
  
    TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
  
<span class="line-new-header">--- 2980,11 ---</span>
      op_preclean();
    }
  }
  
  void ShenandoahHeap::entry_traversal() {
<span class="line-modified">!   static const char* msg = conc_traversal_event_message();</span>
    GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
    EventMark em(&quot;%s&quot;, msg);
  
    TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2809,10 ***</span>
<span class="line-new-header">--- 3149,55 ---</span>
    } else {
      return &quot;Concurrent marking&quot;;
    }
  }
  
<span class="line-added">+ const char* ShenandoahHeap::init_traversal_event_message() const {</span>
<span class="line-added">+   bool proc_refs = process_references();</span>
<span class="line-added">+   bool unload_cls = unload_classes();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">+     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">+   } else if (proc_refs) {</span>
<span class="line-added">+     return &quot;Pause Init Traversal (process weakrefs)&quot;;</span>
<span class="line-added">+   } else if (unload_cls) {</span>
<span class="line-added">+     return &quot;Pause Init Traversal (unload classes)&quot;;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return &quot;Pause Init Traversal&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* ShenandoahHeap::final_traversal_event_message() const {</span>
<span class="line-added">+   bool proc_refs = process_references();</span>
<span class="line-added">+   bool unload_cls = unload_classes();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">+     return &quot;Pause Final Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">+   } else if (proc_refs) {</span>
<span class="line-added">+     return &quot;Pause Final Traversal (process weakrefs)&quot;;</span>
<span class="line-added">+   } else if (unload_cls) {</span>
<span class="line-added">+     return &quot;Pause Final Traversal (unload classes)&quot;;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return &quot;Pause Final Traversal&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const char* ShenandoahHeap::conc_traversal_event_message() const {</span>
<span class="line-added">+   bool proc_refs = process_references();</span>
<span class="line-added">+   bool unload_cls = unload_classes();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">+     return &quot;Concurrent Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">+   } else if (proc_refs) {</span>
<span class="line-added">+     return &quot;Concurrent Traversal (process weakrefs)&quot;;</span>
<span class="line-added">+   } else if (unload_cls) {</span>
<span class="line-added">+     return &quot;Concurrent Traversal (unload classes)&quot;;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return &quot;Concurrent Traversal&quot;;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
    switch (point) {
      case _degenerated_unset:
        return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
      case _degenerated_traversal:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2853,18 ***</span>
        r-&gt;increase_live_data_gc_words(live);
        ld[i] = 0;
      }
    }
  }
<span class="line-removed">- </span>
<span class="line-removed">- size_t ShenandoahHeap::obj_size(oop obj) const {</span>
<span class="line-removed">-   return CollectedHeap::obj_size(obj) + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ptrdiff_t ShenandoahHeap::cell_header_size() const {</span>
<span class="line-removed">-   return ShenandoahBrooksPointer::byte_size();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- BoolObjectClosure* ShenandoahIsAliveSelector::is_alive_closure() {</span>
<span class="line-removed">-   return ShenandoahHeap::heap()-&gt;has_forwarded_objects() ? reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_fwd_alive_cl)</span>
<span class="line-removed">-                                                          : reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_alive_cl);</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 3238,5 ---</span>
</pre>
<center><a href="shenandoahFreeSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp b/src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -22,11 +23,11 @@
  */
 
 #include "precompiled.hpp"
 
 #include "gc/shenandoah/shenandoahAsserts.hpp"
-#include "gc/shenandoah/shenandoahBrooksPointer.hpp"
+#include "gc/shenandoah/shenandoahForwarding.hpp"
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahHeapRegionSet.inline.hpp"
 #include "gc/shenandoah/shenandoahMarkingContext.inline.hpp"
 #include "gc/shenandoah/shenandoahTraversalGC.hpp"
 #include "gc/shenandoah/shenandoahUtils.hpp"
@@ -58,19 +59,23 @@
 
   ResourceMark rm;
   stringStream ss;
   r->print_on(&ss);
 
+  stringStream mw_ss;
+  obj->mark().print_on(&mw_ss);
+
   ShenandoahMarkingContext* const ctx = heap->marking_context();
 
   msg.append("  " PTR_FORMAT " - klass " PTR_FORMAT " %s\n", p2i(obj), p2i(obj->klass()), obj->klass()->external_name());
-  msg.append("    %3s allocated after mark start\n", ctx->allocated_after_mark_start((HeapWord *) obj) ? "" : "not");
+  msg.append("    %3s allocated after mark start\n", ctx->allocated_after_mark_start(obj) ? "" : "not");
   msg.append("    %3s marked \n",                    ctx->is_marked(obj) ? "" : "not");
   msg.append("    %3s in collection set\n",          heap->in_collection_set(obj) ? "" : "not");
   if (heap->traversal_gc() != NULL) {
-    msg.append("    %3s in traversal set\n",         heap->traversal_gc()->traversal_set()->is_in((HeapWord*) obj) ? "" : "not");
+    msg.append("    %3s in traversal set\n",         heap->traversal_gc()->traversal_set()->is_in(obj) ? "" : "not");
   }
+  msg.append("  mark:%s\n", mw_ss.as_string());
   msg.append("  region: %s", ss.as_string());
 }
 
 void ShenandoahAsserts::print_non_obj(ShenandoahMessageBuffer& msg, void* loc) {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
@@ -78,11 +83,11 @@
     msg.append("  inside Java heap\n");
     ShenandoahHeapRegion *r = heap->heap_region_containing(loc);
     stringStream ss;
     r->print_on(&ss);
 
-    msg.append("    %3s in collection set\n",    heap->in_collection_set(loc) ? "" : "not");
+    msg.append("    %3s in collection set\n",    heap->in_collection_set_loc(loc) ? "" : "not");
     msg.append("  region: %s", ss.as_string());
   } else {
     msg.append("  outside of Java heap\n");
     stringStream ss;
     os::print_location(&ss, (intptr_t) loc, false);
@@ -134,13 +139,13 @@
     print_obj_safe(msg, obj);
   }
   msg.append("\n");
 
   if (level >= _safe_oop) {
-    oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);
+    oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
     msg.append("Forwardee:\n");
-    if (!oopDesc::equals_raw(obj, fwd)) {
+    if (obj != fwd) {
       if (level >= _safe_oop_fwd) {
         print_obj(msg, fwd);
       } else {
         print_obj_safe(msg, fwd);
       }
@@ -149,13 +154,13 @@
     }
     msg.append("\n");
   }
 
   if (level >= _safe_oop_fwd) {
-    oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);
-    oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);
-    if (!oopDesc::equals_raw(fwd, fwd2)) {
+    oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
+    oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);
+    if (fwd != fwd2) {
       msg.append("Second forwardee:\n");
       print_obj_safe(msg, fwd2);
       msg.append("\n");
     }
   }
@@ -195,13 +200,13 @@
     print_failure(_safe_unknown, obj, interior_loc, NULL, "Shenandoah assert_correct failed",
                   "Object klass pointer must go to metaspace",
                   file,line);
   }
 
-  oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));
+  oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));
 
-  if (!oopDesc::equals_raw(obj, fwd)) {
+  if (obj != fwd) {
     // When Full GC moves the objects, we cannot trust fwdptrs. If we got here, it means something
     // tries fwdptr manipulation when Full GC is running. The only exception is using the fwdptr
     // that still points to the object itself.
     if (heap->is_full_gc_move_in_progress()) {
       print_failure(_safe_oop, obj, interior_loc, NULL, "Shenandoah assert_correct failed",
@@ -228,12 +233,12 @@
                     "Non-trivial forwardee should in another region",
                     file, line);
     }
 
     // Step 4. Check for multiple forwardings
-    oop fwd2 = oop(ShenandoahBrooksPointer::get_raw_unchecked(fwd));
-    if (!oopDesc::equals_raw(fwd, fwd2)) {
+    oop fwd2 = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(fwd));
+    if (fwd != fwd2) {
       print_failure(_safe_all, obj, interior_loc, NULL, "Shenandoah assert_correct failed",
                     "Multiple forwardings",
                     file, line);
     }
   }
@@ -248,11 +253,11 @@
     print_failure(_safe_unknown, obj, interior_loc, NULL, "Shenandoah assert_in_correct_region failed",
                   "Object must reside in active region",
                   file, line);
   }
 
-  size_t alloc_size = obj->size() + ShenandoahBrooksPointer::word_size();
+  size_t alloc_size = obj->size();
   if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {
     size_t idx = r->region_number();
     size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);
     for (size_t i = idx; i < idx + num_regions; i++) {
       ShenandoahHeapRegion* chain_reg = heap->get_region(i);
@@ -270,24 +275,24 @@
   }
 }
 
 void ShenandoahAsserts::assert_forwarded(void* interior_loc, oop obj, const char* file, int line) {
   assert_correct(interior_loc, obj, file, line);
-  oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));
+  oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));
 
-  if (oopDesc::equals_raw(obj, fwd)) {
+  if (obj == fwd) {
     print_failure(_safe_all, obj, interior_loc, NULL, "Shenandoah assert_forwarded failed",
                   "Object should be forwarded",
                   file, line);
   }
 }
 
 void ShenandoahAsserts::assert_not_forwarded(void* interior_loc, oop obj, const char* file, int line) {
   assert_correct(interior_loc, obj, file, line);
-  oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));
+  oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));
 
-  if (!oopDesc::equals_raw(obj, fwd)) {
+  if (obj != fwd) {
     print_failure(_safe_all, obj, interior_loc, NULL, "Shenandoah assert_not_forwarded failed",
                   "Object should not be forwarded",
                   file, line);
   }
 }
@@ -325,11 +330,11 @@
   }
 }
 
 void ShenandoahAsserts::assert_not_in_cset_loc(void* interior_loc, const char* file, int line) {
   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
-  if (heap->in_collection_set(interior_loc)) {
+  if (heap->in_collection_set_loc(interior_loc)) {
     print_failure(_safe_unknown, NULL, interior_loc, NULL, "Shenandoah assert_not_in_cset_loc failed",
                   "Interior location should not be in collection set",
                   file, line);
   }
 }
@@ -356,5 +361,18 @@
   if (rp->is_alive_non_header() == NULL) {
     print_rp_failure("Shenandoah assert_rp_isalive_installed failed", rp->is_alive_non_header(),
                      file, line);
   }
 }
+
+void ShenandoahAsserts::assert_locked_or_shenandoah_safepoint(Mutex* lock, const char* file, int line) {
+  if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
+    return;
+  }
+
+  if (lock->owned_by_self()) {
+    return;
+  }
+
+  ShenandoahMessageBuffer msg("Must ba at a Shenandoah safepoint or held %s lock", lock->name());
+  report_vm_error(file, line, msg.buffer());
+}

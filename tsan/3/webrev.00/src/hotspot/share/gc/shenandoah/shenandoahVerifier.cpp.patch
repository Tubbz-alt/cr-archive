diff a/src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp b/src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -22,20 +23,25 @@
  */
 
 #include "precompiled.hpp"
 
 #include "gc/shenandoah/shenandoahAsserts.hpp"
-#include "gc/shenandoah/shenandoahBrooksPointer.hpp"
+#include "gc/shenandoah/shenandoahConcurrentRoots.hpp"
+#include "gc/shenandoah/shenandoahForwarding.inline.hpp"
 #include "gc/shenandoah/shenandoahPhaseTimings.hpp"
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahRootProcessor.hpp"
 #include "gc/shenandoah/shenandoahTaskqueue.inline.hpp"
 #include "gc/shenandoah/shenandoahUtils.hpp"
 #include "gc/shenandoah/shenandoahVerifier.hpp"
 #include "memory/allocation.hpp"
 #include "memory/iterator.inline.hpp"
 #include "memory/resourceArea.hpp"
+#include "oops/compressedOops.inline.hpp"
+#include "runtime/atomic.hpp"
+#include "runtime/orderAccess.hpp"
+#include "utilities/align.hpp"
 
 // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
 #ifdef verify_oop
 #undef verify_oop
 #endif
@@ -80,12 +86,11 @@
       // methods.
       //
       // For performance reasons, only fully verify non-marked field values.
       // We are here when the host object for *p is already marked.
 
-      HeapWord* addr = (HeapWord*) obj;
-      if (_map->par_mark(addr)) {
+      if (_map->par_mark(obj)) {
         verify_oop_at(p, obj);
         _stack->push(ShenandoahVerifierTask(obj));
       }
     }
   }
@@ -95,11 +100,11 @@
     // that failure report would not try to touch something that was not yet verified to be
     // safe to process.
 
     check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),
               "oop must be in heap");
-    check(ShenandoahAsserts::_safe_unknown, obj, check_obj_alignment(obj),
+    check(ShenandoahAsserts::_safe_unknown, obj, is_object_aligned(obj),
               "oop must be aligned");
 
     ShenandoahHeapRegion *obj_reg = _heap->heap_region_containing(obj);
     Klass* obj_klass = obj->klass_or_null();
 
@@ -109,11 +114,11 @@
       check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
              "Object klass pointer should not be NULL");
       check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
              "Object klass pointer must go to metaspace");
 
-      HeapWord *obj_addr = (HeapWord *) obj;
+      HeapWord *obj_addr = cast_from_oop<HeapWord*>(obj);
       check(ShenandoahAsserts::_safe_unknown, obj, obj_addr < obj_reg->top(),
              "Object start should be within the region");
 
       if (!obj_reg->is_humongous()) {
         check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->size()) <= obj_reg->top(),
@@ -135,31 +140,31 @@
       switch (_options._verify_liveness) {
         case ShenandoahVerifier::_verify_liveness_disable:
           // skip
           break;
         case ShenandoahVerifier::_verify_liveness_complete:
-          Atomic::add(obj->size() + ShenandoahBrooksPointer::word_size(), &_ld[obj_reg->region_number()]);
+          Atomic::add(&_ld[obj_reg->region_number()], (uint) obj->size());
           // fallthrough for fast failure for un-live regions:
         case ShenandoahVerifier::_verify_liveness_conservative:
           check(ShenandoahAsserts::_safe_oop, obj, obj_reg->has_live(),
                    "Object must belong to region with live data");
           break;
         default:
           assert(false, "Unhandled liveness verification");
       }
     }
 
-    oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);
+    oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
 
     ShenandoahHeapRegion* fwd_reg = NULL;
 
-    if (!oopDesc::equals_raw(obj, fwd)) {
+    if (obj != fwd) {
       check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),
              "Forwardee must be in heap");
       check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
              "Forwardee is set");
-      check(ShenandoahAsserts::_safe_oop, obj, check_obj_alignment(fwd),
+      check(ShenandoahAsserts::_safe_oop, obj, is_object_aligned(fwd),
              "Forwardee must be aligned");
 
       // Do this before touching fwd->size()
       Klass* fwd_klass = fwd->klass_or_null();
       check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
@@ -173,18 +178,18 @@
 
       // Verify that forwardee is not in the dead space:
       check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg->is_humongous(),
              "Should have no humongous forwardees");
 
-      HeapWord *fwd_addr = (HeapWord *) fwd;
+      HeapWord *fwd_addr = cast_from_oop<HeapWord *>(fwd);
       check(ShenandoahAsserts::_safe_oop, obj, fwd_addr < fwd_reg->top(),
              "Forwardee start should be within the region");
       check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->size()) <= fwd_reg->top(),
              "Forwardee end should be within the region");
 
-      oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);
-      check(ShenandoahAsserts::_safe_oop, obj, oopDesc::equals_raw(fwd, fwd2),
+      oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);
+      check(ShenandoahAsserts::_safe_oop, obj, (fwd == fwd2),
              "Double forwarding");
     } else {
       fwd_reg = obj_reg;
     }
 
@@ -209,16 +214,16 @@
     switch (_options._verify_forwarded) {
       case ShenandoahVerifier::_verify_forwarded_disable:
         // skip
         break;
       case ShenandoahVerifier::_verify_forwarded_none: {
-        check(ShenandoahAsserts::_safe_all, obj, oopDesc::equals_raw(obj, fwd),
+        check(ShenandoahAsserts::_safe_all, obj, (obj == fwd),
                "Should not be forwarded");
         break;
       }
       case ShenandoahVerifier::_verify_forwarded_allow: {
-        if (!oopDesc::equals_raw(obj, fwd)) {
+        if (obj != fwd) {
           check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
                  "Forwardee should be in another region");
         }
         break;
       }
@@ -234,11 +239,11 @@
         check(ShenandoahAsserts::_safe_all, obj, !_heap->in_collection_set(obj),
                "Should not have references to collection set");
         break;
       case ShenandoahVerifier::_verify_cset_forwarded:
         if (_heap->in_collection_set(obj)) {
-          check(ShenandoahAsserts::_safe_all, obj, !oopDesc::equals_raw(obj, fwd),
+          check(ShenandoahAsserts::_safe_all, obj, (obj != fwd),
                  "Object in collection set, should have forwardee");
         }
         break;
       default:
         assert(false, "Unhandled cset verification");
@@ -416,26 +421,26 @@
 };
 
 class ShenandoahVerifierReachableTask : public AbstractGangTask {
 private:
   const char* _label;
-  ShenandoahRootProcessor* _rp;
+  ShenandoahRootVerifier* _verifier;
   ShenandoahVerifier::VerifyOptions _options;
   ShenandoahHeap* _heap;
   ShenandoahLivenessData* _ld;
   MarkBitMap* _bitmap;
   volatile size_t _processed;
 
 public:
   ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
                                   ShenandoahLivenessData* ld,
-                                  ShenandoahRootProcessor* rp,
+                                  ShenandoahRootVerifier* verifier,
                                   const char* label,
                                   ShenandoahVerifier::VerifyOptions options) :
     AbstractGangTask("Shenandoah Parallel Verifier Reachable Task"),
     _label(label),
-    _rp(rp),
+    _verifier(verifier),
     _options(options),
     _heap(ShenandoahHeap::heap()),
     _ld(ld),
     _bitmap(bitmap),
     _processed(0) {};
@@ -455,11 +460,15 @@
     if (((ShenandoahVerifyLevel == 2) && (worker_id == 0))
         || (ShenandoahVerifyLevel >= 3)) {
         ShenandoahVerifyOopClosure cl(&stack, _bitmap, _ld,
                                       ShenandoahMessageBuffer("%s, Roots", _label),
                                       _options);
-        _rp->process_all_roots_slow(&cl);
+        if (_heap->unload_classes()) {
+          _verifier->strong_roots_do(&cl);
+        } else {
+          _verifier->roots_do(&cl);
+        }
     }
 
     size_t processed = 0;
 
     if (ShenandoahVerifyLevel >= 3) {
@@ -471,11 +480,11 @@
         ShenandoahVerifierTask task = stack.pop();
         cl.verify_oops_from(task.obj());
       }
     }
 
-    Atomic::add(processed, &_processed);
+    Atomic::add(&_processed, processed);
   }
 };
 
 class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
 private:
@@ -510,11 +519,11 @@
     ShenandoahVerifyOopClosure cl(&stack, _bitmap, _ld,
                                   ShenandoahMessageBuffer("%s, Marked", _label),
                                   _options);
 
     while (true) {
-      size_t v = Atomic::add(1u, &_claimed) - 1;
+      size_t v = Atomic::fetch_and_add(&_claimed, 1u);
       if (v < _heap->num_regions()) {
         ShenandoahHeapRegion* r = _heap->get_region(v);
         if (!r->is_humongous() && !r->is_trash()) {
           work_regular(r, stack, cl);
         } else if (r->is_humongous_start()) {
@@ -526,48 +535,48 @@
     }
   }
 
   virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack& stack, ShenandoahVerifyOopClosure& cl) {
     size_t processed = 0;
-    HeapWord* obj = r->bottom() + ShenandoahBrooksPointer::word_size();
+    HeapWord* obj = r->bottom();
     if (_heap->complete_marking_context()->is_marked((oop)obj)) {
       verify_and_follow(obj, stack, cl, &processed);
     }
-    Atomic::add(processed, &_processed);
+    Atomic::add(&_processed, processed);
   }
 
   virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl) {
     size_t processed = 0;
     MarkBitMap* mark_bit_map = _heap->complete_marking_context()->mark_bit_map();
     HeapWord* tams = _heap->complete_marking_context()->top_at_mark_start(r);
 
     // Bitmaps, before TAMS
     if (tams > r->bottom()) {
-      HeapWord* start = r->bottom() + ShenandoahBrooksPointer::word_size();
+      HeapWord* start = r->bottom();
       HeapWord* addr = mark_bit_map->get_next_marked_addr(start, tams);
 
       while (addr < tams) {
         verify_and_follow(addr, stack, cl, &processed);
-        addr += ShenandoahBrooksPointer::word_size();
+        addr += 1;
         if (addr < tams) {
           addr = mark_bit_map->get_next_marked_addr(addr, tams);
         }
       }
     }
 
     // Size-based, after TAMS
     {
       HeapWord* limit = r->top();
-      HeapWord* addr = tams + ShenandoahBrooksPointer::word_size();
+      HeapWord* addr = tams;
 
       while (addr < limit) {
         verify_and_follow(addr, stack, cl, &processed);
-        addr += oop(addr)->size() + ShenandoahBrooksPointer::word_size();
+        addr += oop(addr)->size();
       }
     }
 
-    Atomic::add(processed, &_processed);
+    Atomic::add(&_processed, processed);
   }
 
   void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &stack, ShenandoahVerifyOopClosure &cl, size_t *processed) {
     if (!_bitmap->par_mark(addr)) return;
 
@@ -601,15 +610,33 @@
       fatal("%s: Thread %s: expected gc-state %d, actual %d", _label, t->name(), _expected, actual);
     }
   }
 };
 
+class ShenandoahGCStateResetter : public StackObj {
+private:
+  ShenandoahHeap* const _heap;
+  char _gc_state;
+
+public:
+  ShenandoahGCStateResetter() : _heap(ShenandoahHeap::heap()) {
+    _gc_state = _heap->gc_state();
+    _heap->_gc_state.clear();
+  }
+
+  ~ShenandoahGCStateResetter() {
+    _heap->_gc_state.set(_gc_state);
+    assert(_heap->gc_state() == _gc_state, "Should be restored");
+  }
+};
+
 void ShenandoahVerifier::verify_at_safepoint(const char *label,
                                              VerifyForwarded forwarded, VerifyMarked marked,
                                              VerifyCollectionSet cset,
                                              VerifyLiveness liveness, VerifyRegions regions,
-                                             VerifyGCState gcstate) {
+                                             VerifyGCState gcstate,
+                                             VerifyWeakRoots weak_roots) {
   guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), "only when nothing else happens");
   guarantee(ShenandoahVerify, "only when enabled, and bitmap is initialized in ShenandoahHeap::initialize");
 
   // Avoid side-effect of changing workers' active thread count, but bypass concurrent/parallel protocol check
   ShenandoahPushWorkerScope verify_worker_scope(_heap->workers(), _heap->max_workers(), false /*bypass check*/);
@@ -626,10 +653,14 @@
         break;
       case _verify_gcstate_forwarded:
         enabled = true;
         expected = ShenandoahHeap::HAS_FORWARDED;
         break;
+      case _verify_gcstate_evacuation:
+        enabled = true;
+        expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION;
+        break;
       case _verify_gcstate_stable:
         enabled = true;
         expected = ShenandoahHeap::STABLE;
         break;
       default:
@@ -646,25 +677,32 @@
       VerifyThreadGCState vtgcs(label, expected);
       Threads::java_threads_do(&vtgcs);
     }
   }
 
+  // Deactivate barriers temporarily: Verifier wants plain heap accesses
+  ShenandoahGCStateResetter resetter;
+
   // Heap size checks
   {
     ShenandoahHeapLocker lock(_heap->lock());
 
     ShenandoahCalculateRegionStatsClosure cl;
     _heap->heap_region_iterate(&cl);
     size_t heap_used = _heap->used();
     guarantee(cl.used() == heap_used,
-              "%s: heap used size must be consistent: heap-used = " SIZE_FORMAT "K, regions-used = " SIZE_FORMAT "K",
-              label, heap_used/K, cl.used()/K);
+              "%s: heap used size must be consistent: heap-used = " SIZE_FORMAT "%s, regions-used = " SIZE_FORMAT "%s",
+              label,
+              byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),
+              byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));
 
     size_t heap_committed = _heap->committed();
     guarantee(cl.committed() == heap_committed,
-              "%s: heap committed size must be consistent: heap-committed = " SIZE_FORMAT "K, regions-committed = " SIZE_FORMAT "K",
-              label, heap_committed/K, cl.committed()/K);
+              "%s: heap committed size must be consistent: heap-committed = " SIZE_FORMAT "%s, regions-committed = " SIZE_FORMAT "%s",
+              label,
+              byte_size_in_proper_unit(heap_committed), proper_unit_for_byte_size(heap_committed),
+              byte_size_in_proper_unit(cl.committed()), proper_unit_for_byte_size(cl.committed()));
   }
 
   // Internal heap region checks
   if (ShenandoahVerifyLevel >= 1) {
     ShenandoahVerifyHeapRegionClosure cl(label, regions);
@@ -685,14 +723,25 @@
 
   // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
   // This verifies what application can see, since it only cares about reachable objects.
   size_t count_reachable = 0;
   if (ShenandoahVerifyLevel >= 2) {
-    ShenandoahRootProcessor rp(_heap, _heap->workers()->active_workers(),
-                               ShenandoahPhaseTimings::_num_phases); // no need for stats
+    ShenandoahRootVerifier verifier;
+    switch (weak_roots) {
+      case _verify_serial_weak_roots:
+        verifier.excludes(ShenandoahRootVerifier::ConcurrentWeakRoots);
+        break;
+      case _verify_concurrent_weak_roots:
+        verifier.excludes(ShenandoahRootVerifier::SerialWeakRoots);
+        break;
+      case _verify_all_weak_roots:
+        break;
+      default:
+        ShouldNotReachHere();
+    }
 
-    ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &rp, label, options);
+    ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &verifier, label, options);
     _heap->workers()->run_task(&task);
     count_reachable = task.processed();
   }
 
   // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
@@ -721,16 +770,16 @@
 
       juint verf_live = 0;
       if (r->is_humongous()) {
         // For humongous objects, test if start region is marked live, and if so,
         // all humongous regions in that chain have live data equal to their "used".
-        juint start_live = OrderAccess::load_acquire(&ld[r->humongous_start_region()->region_number()]);
+        juint start_live = Atomic::load_acquire(&ld[r->humongous_start_region()->region_number()]);
         if (start_live > 0) {
           verf_live = (juint)(r->used() / HeapWordSize);
         }
       } else {
-        verf_live = OrderAccess::load_acquire(&ld[r->region_number()]);
+        verf_live = Atomic::load_acquire(&ld[r->region_number()]);
       }
 
       size_t reg_live = r->get_live_data_words();
       if (reg_live != verf_live) {
         ResourceMark rm;
@@ -754,11 +803,12 @@
           _verify_forwarded_allow,     // conservatively allow forwarded
           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
           _verify_cset_disable,        // cset may be inconsistent
           _verify_liveness_disable,    // no reliable liveness data
           _verify_regions_disable,     // no reliable region data
-          _verify_gcstate_disable      // no data about gcstate
+          _verify_gcstate_disable,     // no data about gcstate
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_before_concmark() {
   if (_heap->has_forwarded_objects()) {
@@ -767,21 +817,23 @@
             _verify_forwarded_allow,     // may have forwarded references
             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
             _verify_cset_forwarded,      // allow forwarded references to cset
             _verify_liveness_disable,    // no reliable liveness data
             _verify_regions_notrash,     // no trash regions
-            _verify_gcstate_forwarded    // there are forwarded objects
+            _verify_gcstate_forwarded,   // there are forwarded objects
+            _verify_all_weak_roots
     );
   } else {
     verify_at_safepoint(
             "Before Mark",
             _verify_forwarded_none,      // UR should have fixed up
             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
             _verify_cset_none,           // UR should have fixed this
             _verify_liveness_disable,    // no reliable liveness data
             _verify_regions_notrash,     // no trash regions
-            _verify_gcstate_stable       // there are no forwarded objects
+            _verify_gcstate_stable,      // there are no forwarded objects
+            _verify_all_weak_roots
     );
   }
 }
 
 void ShenandoahVerifier::verify_after_concmark() {
@@ -790,23 +842,48 @@
           _verify_forwarded_none,      // no forwarded references
           _verify_marked_complete,     // bitmaps as precise as we can get
           _verify_cset_none,           // no references to cset anymore
           _verify_liveness_complete,   // liveness data must be complete here
           _verify_regions_disable,     // trash regions not yet recycled
-          _verify_gcstate_stable       // mark should have stabilized the heap
+          _verify_gcstate_stable,       // mark should have stabilized the heap
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_before_evacuation() {
+  // Concurrent weak roots are evacuated during concurrent phase
+  VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?
+                                      _verify_serial_weak_roots :
+                                      _verify_all_weak_roots;
+
   verify_at_safepoint(
           "Before Evacuation",
           _verify_forwarded_none,    // no forwarded references
           _verify_marked_complete,   // walk over marked objects too
           _verify_cset_disable,      // non-forwarded references to cset expected
           _verify_liveness_complete, // liveness data must be complete here
           _verify_regions_disable,   // trash regions not yet recycled
-          _verify_gcstate_stable     // mark should have stabilized the heap
+          _verify_gcstate_stable,    // mark should have stabilized the heap
+          verify_weak_roots
+  );
+}
+
+void ShenandoahVerifier::verify_during_evacuation() {
+  // Concurrent weak roots are evacuated during concurrent phase
+  VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?
+                                      _verify_serial_weak_roots :
+                                      _verify_all_weak_roots;
+
+  verify_at_safepoint(
+          "During Evacuation",
+          _verify_forwarded_allow,    // some forwarded references are allowed
+          _verify_marked_disable,     // walk only roots
+          _verify_cset_disable,       // some cset references are not forwarded yet
+          _verify_liveness_disable,   // liveness data might be already stale after pre-evacs
+          _verify_regions_disable,    // trash regions not yet recycled
+          _verify_gcstate_evacuation, // evacuation is in progress
+          verify_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_after_evacuation() {
   verify_at_safepoint(
@@ -814,11 +891,12 @@
           _verify_forwarded_allow,     // objects are still forwarded
           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
           _verify_cset_forwarded,      // all cset refs are fully forwarded
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_notrash,     // trash regions have been recycled already
-          _verify_gcstate_forwarded    // evacuation produced some forwarded objects
+          _verify_gcstate_forwarded,   // evacuation produced some forwarded objects
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_before_updaterefs() {
   verify_at_safepoint(
@@ -826,11 +904,12 @@
           _verify_forwarded_allow,     // forwarded references allowed
           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
           _verify_cset_forwarded,      // all cset refs are fully forwarded
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_notrash,     // trash regions have been recycled already
-          _verify_gcstate_forwarded    // evacuation should have produced some forwarded objects
+          _verify_gcstate_forwarded,   // evacuation should have produced some forwarded objects
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_after_updaterefs() {
   verify_at_safepoint(
@@ -838,11 +917,12 @@
           _verify_forwarded_none,      // no forwarded references
           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
           _verify_cset_none,           // no cset references, all updated
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_nocset,      // no cset regions, trash regions have appeared
-          _verify_gcstate_stable       // update refs had cleaned up forwarded objects
+          _verify_gcstate_stable,      // update refs had cleaned up forwarded objects
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_after_degenerated() {
   verify_at_safepoint(
@@ -850,11 +930,12 @@
           _verify_forwarded_none,      // all objects are non-forwarded
           _verify_marked_complete,     // all objects are marked in complete bitmap
           _verify_cset_none,           // no cset references
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_notrash_nocset, // no trash, no cset
-          _verify_gcstate_stable       // degenerated refs had cleaned up forwarded objects
+          _verify_gcstate_stable,       // degenerated refs had cleaned up forwarded objects
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_before_traversal() {
   verify_at_safepoint(
@@ -862,11 +943,12 @@
           _verify_forwarded_none,      // cannot have forwarded objects
           _verify_marked_disable,      // bitmaps are not relevant before traversal
           _verify_cset_none,           // no cset references before traversal
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_notrash_nocset, // no trash and no cset regions
-          _verify_gcstate_stable       // nothing forwarded before traversal
+          _verify_gcstate_stable,      // nothing forwarded before traversal
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_after_traversal() {
   verify_at_safepoint(
@@ -874,11 +956,12 @@
           _verify_forwarded_none,      // cannot have forwarded objects
           _verify_marked_complete,     // should have complete marking after traversal
           _verify_cset_none,           // no cset references left after traversal
           _verify_liveness_disable,    // liveness data is not collected for new allocations
           _verify_regions_nocset,      // no cset regions, trash regions allowed
-          _verify_gcstate_stable       // nothing forwarded after traversal
+          _verify_gcstate_stable,      // nothing forwarded after traversal
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_before_fullgc() {
   verify_at_safepoint(
@@ -886,11 +969,12 @@
           _verify_forwarded_allow,     // can have forwarded objects
           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
           _verify_cset_disable,        // cset might be foobared
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_disable,     // no reliable region data here
-          _verify_gcstate_disable      // no reliable gcstate data
+          _verify_gcstate_disable,     // no reliable gcstate data
+          _verify_all_weak_roots
   );
 }
 
 void ShenandoahVerifier::verify_after_fullgc() {
   verify_at_safepoint(
@@ -898,8 +982,87 @@
           _verify_forwarded_none,      // all objects are non-forwarded
           _verify_marked_complete,     // all objects are marked in complete bitmap
           _verify_cset_none,           // no cset references
           _verify_liveness_disable,    // no reliable liveness data anymore
           _verify_regions_notrash_nocset, // no trash, no cset
-          _verify_gcstate_stable       // full gc cleaned up everything
+          _verify_gcstate_stable,       // full gc cleaned up everything
+          _verify_all_weak_roots
   );
 }
+
+class ShenandoahVerifyNoForwared : public OopClosure {
+private:
+  template <class T>
+  void do_oop_work(T* p) {
+    T o = RawAccess<>::oop_load(p);
+    if (!CompressedOops::is_null(o)) {
+      oop obj = CompressedOops::decode_not_null(o);
+      oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
+      if (obj != fwd) {
+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
+                                         "Verify Roots", "Should not be forwarded", __FILE__, __LINE__);
+      }
+    }
+  }
+
+public:
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+  void do_oop(oop* p)       { do_oop_work(p); }
+};
+
+class ShenandoahVerifyInToSpaceClosure : public OopClosure {
+private:
+  template <class T>
+  void do_oop_work(T* p) {
+    T o = RawAccess<>::oop_load(p);
+    if (!CompressedOops::is_null(o)) {
+      oop obj = CompressedOops::decode_not_null(o);
+      ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
+
+      if (!heap->marking_context()->is_marked(obj)) {
+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
+                "Verify Roots In To-Space", "Should be marked", __FILE__, __LINE__);
+      }
+
+      if (heap->in_collection_set(obj)) {
+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
+                "Verify Roots In To-Space", "Should not be in collection set", __FILE__, __LINE__);
+      }
+
+      oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);
+      if (obj != fwd) {
+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,
+                "Verify Roots In To-Space", "Should not be forwarded", __FILE__, __LINE__);
+      }
+    }
+  }
+
+public:
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+  void do_oop(oop* p)       { do_oop_work(p); }
+};
+
+void ShenandoahVerifier::verify_roots_in_to_space() {
+  ShenandoahRootVerifier verifier;
+  ShenandoahVerifyInToSpaceClosure cl;
+  verifier.oops_do(&cl);
+}
+
+void ShenandoahVerifier::verify_roots_in_to_space_except(ShenandoahRootVerifier::RootTypes types) {
+  ShenandoahRootVerifier verifier;
+  verifier.excludes(types);
+  ShenandoahVerifyInToSpaceClosure cl;
+  verifier.oops_do(&cl);
+}
+
+void ShenandoahVerifier::verify_roots_no_forwarded() {
+  ShenandoahRootVerifier verifier;
+  ShenandoahVerifyNoForwared cl;
+  verifier.oops_do(&cl);
+}
+
+void ShenandoahVerifier::verify_roots_no_forwarded_except(ShenandoahRootVerifier::RootTypes types) {
+  ShenandoahRootVerifier verifier;
+  verifier.excludes(types);
+  ShenandoahVerifyNoForwared cl;
+  verifier.oops_do(&cl);
+}

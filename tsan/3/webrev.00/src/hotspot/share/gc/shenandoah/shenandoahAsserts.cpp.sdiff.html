<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahArguments.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahAsserts.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahAsserts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified"> 27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 
 35 void print_raw_memory(ShenandoahMessageBuffer &amp;msg, void* loc) {
 36   // Be extra safe. Only access data that is guaranteed to be safe:
 37   // should be in heap, in known committed region, within that region.
 38 
 39   ShenandoahHeap* heap = ShenandoahHeap::heap();
 40   if (!heap-&gt;is_in(loc)) return;
 41 
 42   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(loc);
 43   if (r != NULL &amp;&amp; r-&gt;is_committed()) {
 44     address start = MAX2((address) r-&gt;bottom(), (address) loc - 32);
 45     address end   = MIN2((address) r-&gt;end(),    (address) loc + 128);
 46     if (start &gt;= end) return;
 47 
 48     stringStream ss;
 49     os::print_hex_dump(&amp;ss, start, end, 4);
 50     msg.append(&quot;\n&quot;);
 51     msg.append(&quot;Raw heap memory:\n%s&quot;, ss.as_string());
 52   }
 53 }
 54 
 55 void ShenandoahAsserts::print_obj(ShenandoahMessageBuffer&amp; msg, oop obj) {
 56   ShenandoahHeap* heap = ShenandoahHeap::heap();
 57   ShenandoahHeapRegion *r = heap-&gt;heap_region_containing(obj);
 58 
 59   ResourceMark rm;
 60   stringStream ss;
 61   r-&gt;print_on(&amp;ss);
 62 



 63   ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 64 
 65   msg.append(&quot;  &quot; PTR_FORMAT &quot; - klass &quot; PTR_FORMAT &quot; %s\n&quot;, p2i(obj), p2i(obj-&gt;klass()), obj-&gt;klass()-&gt;external_name());
<span class="line-modified"> 66   msg.append(&quot;    %3s allocated after mark start\n&quot;, ctx-&gt;allocated_after_mark_start((HeapWord *) obj) ? &quot;&quot; : &quot;not&quot;);</span>
 67   msg.append(&quot;    %3s marked \n&quot;,                    ctx-&gt;is_marked(obj) ? &quot;&quot; : &quot;not&quot;);
 68   msg.append(&quot;    %3s in collection set\n&quot;,          heap-&gt;in_collection_set(obj) ? &quot;&quot; : &quot;not&quot;);
 69   if (heap-&gt;traversal_gc() != NULL) {
<span class="line-modified"> 70     msg.append(&quot;    %3s in traversal set\n&quot;,         heap-&gt;traversal_gc()-&gt;traversal_set()-&gt;is_in((HeapWord*) obj) ? &quot;&quot; : &quot;not&quot;);</span>
 71   }

 72   msg.append(&quot;  region: %s&quot;, ss.as_string());
 73 }
 74 
 75 void ShenandoahAsserts::print_non_obj(ShenandoahMessageBuffer&amp; msg, void* loc) {
 76   ShenandoahHeap* heap = ShenandoahHeap::heap();
 77   if (heap-&gt;is_in(loc)) {
 78     msg.append(&quot;  inside Java heap\n&quot;);
 79     ShenandoahHeapRegion *r = heap-&gt;heap_region_containing(loc);
 80     stringStream ss;
 81     r-&gt;print_on(&amp;ss);
 82 
<span class="line-modified"> 83     msg.append(&quot;    %3s in collection set\n&quot;,    heap-&gt;in_collection_set(loc) ? &quot;&quot; : &quot;not&quot;);</span>
 84     msg.append(&quot;  region: %s&quot;, ss.as_string());
 85   } else {
 86     msg.append(&quot;  outside of Java heap\n&quot;);
 87     stringStream ss;
 88     os::print_location(&amp;ss, (intptr_t) loc, false);
 89     msg.append(&quot;  %s&quot;, ss.as_string());
 90   }
 91 }
 92 
 93 void ShenandoahAsserts::print_obj_safe(ShenandoahMessageBuffer&amp; msg, void* loc) {
 94   ShenandoahHeap* heap = ShenandoahHeap::heap();
 95   msg.append(&quot;  &quot; PTR_FORMAT &quot; - safe print, no details\n&quot;, p2i(loc));
 96   if (heap-&gt;is_in(loc)) {
 97     ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(loc);
 98     if (r != NULL) {
 99       stringStream ss;
100       r-&gt;print_on(&amp;ss);
101       msg.append(&quot;  region: %s&quot;, ss.as_string());
102       print_raw_memory(msg, loc);
103     }
</pre>
<hr />
<pre>
119     msg.append(&quot;  interior location: &quot; PTR_FORMAT &quot;\n&quot;, p2i(interior_loc));
120     if (loc_in_heap) {
121       print_obj(msg, loc);
122     } else {
123       print_non_obj(msg, interior_loc);
124     }
125   } else {
126     msg.append(&quot;  no interior location recorded (probably a plain heap scan, or detached oop)\n&quot;);
127   }
128   msg.append(&quot;\n&quot;);
129 
130   msg.append(&quot;Object:\n&quot;);
131   if (level &gt;= _safe_oop) {
132     print_obj(msg, obj);
133   } else {
134     print_obj_safe(msg, obj);
135   }
136   msg.append(&quot;\n&quot;);
137 
138   if (level &gt;= _safe_oop) {
<span class="line-modified">139     oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);</span>
140     msg.append(&quot;Forwardee:\n&quot;);
<span class="line-modified">141     if (!oopDesc::equals_raw(obj, fwd)) {</span>
142       if (level &gt;= _safe_oop_fwd) {
143         print_obj(msg, fwd);
144       } else {
145         print_obj_safe(msg, fwd);
146       }
147     } else {
148       msg.append(&quot;  (the object itself)&quot;);
149     }
150     msg.append(&quot;\n&quot;);
151   }
152 
153   if (level &gt;= _safe_oop_fwd) {
<span class="line-modified">154     oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);</span>
<span class="line-modified">155     oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);</span>
<span class="line-modified">156     if (!oopDesc::equals_raw(fwd, fwd2)) {</span>
157       msg.append(&quot;Second forwardee:\n&quot;);
158       print_obj_safe(msg, fwd2);
159       msg.append(&quot;\n&quot;);
160     }
161   }
162 
163   report_vm_error(file, line, msg.buffer());
164 }
165 
166 void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {
167   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
168 
169   if (!heap-&gt;is_in(obj)) {
170     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_heap failed&quot;,
171                   &quot;oop must point to a heap address&quot;,
172                   file, line);
173   }
174 }
175 
176 void ShenandoahAsserts::assert_correct(void* interior_loc, oop obj, const char* file, int line) {
</pre>
<hr />
<pre>
180   // After this step, it is safe to call heap_region_containing().
181   if (!heap-&gt;is_in(obj)) {
182     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
183                   &quot;oop must point to a heap address&quot;,
184                   file, line);
185   }
186 
187   Klass* obj_klass = obj-&gt;klass_or_null();
188   if (obj_klass == NULL) {
189     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
190                   &quot;Object klass pointer should not be NULL&quot;,
191                   file,line);
192   }
193 
194   if (!Metaspace::contains(obj_klass)) {
195     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
196                   &quot;Object klass pointer must go to metaspace&quot;,
197                   file,line);
198   }
199 
<span class="line-modified">200   oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));</span>
201 
<span class="line-modified">202   if (!oopDesc::equals_raw(obj, fwd)) {</span>
203     // When Full GC moves the objects, we cannot trust fwdptrs. If we got here, it means something
204     // tries fwdptr manipulation when Full GC is running. The only exception is using the fwdptr
205     // that still points to the object itself.
206     if (heap-&gt;is_full_gc_move_in_progress()) {
207       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
208                     &quot;Non-trivial forwarding pointer during Full GC moves, probable bug.&quot;,
209                     file, line);
210     }
211 
212     // Step 2. Check that forwardee is correct
213     if (!heap-&gt;is_in(fwd)) {
214       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
215                     &quot;Forwardee must point to a heap address&quot;,
216                     file, line);
217     }
218 
219     if (obj_klass != fwd-&gt;klass()) {
220       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
221                     &quot;Forwardee klass disagrees with object class&quot;,
222                     file, line);
223     }
224 
225     // Step 3. Check that forwardee points to correct region
226     if (heap-&gt;heap_region_index_containing(fwd) == heap-&gt;heap_region_index_containing(obj)) {
227       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
228                     &quot;Non-trivial forwardee should in another region&quot;,
229                     file, line);
230     }
231 
232     // Step 4. Check for multiple forwardings
<span class="line-modified">233     oop fwd2 = oop(ShenandoahBrooksPointer::get_raw_unchecked(fwd));</span>
<span class="line-modified">234     if (!oopDesc::equals_raw(fwd, fwd2)) {</span>
235       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
236                     &quot;Multiple forwardings&quot;,
237                     file, line);
238     }
239   }
240 }
241 
242 void ShenandoahAsserts::assert_in_correct_region(void* interior_loc, oop obj, const char* file, int line) {
243   assert_correct(interior_loc, obj, file, line);
244 
245   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
246   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(obj);
247   if (!r-&gt;is_active()) {
248     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
249                   &quot;Object must reside in active region&quot;,
250                   file, line);
251   }
252 
<span class="line-modified">253   size_t alloc_size = obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
254   if (alloc_size &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
255     size_t idx = r-&gt;region_number();
256     size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);
257     for (size_t i = idx; i &lt; idx + num_regions; i++) {
258       ShenandoahHeapRegion* chain_reg = heap-&gt;get_region(i);
259       if (i == idx &amp;&amp; !chain_reg-&gt;is_humongous_start()) {
260         print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
261                       &quot;Object must reside in humongous start&quot;,
262                       file, line);
263       }
264       if (i != idx &amp;&amp; !chain_reg-&gt;is_humongous_continuation()) {
265         print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
266                       &quot;Humongous continuation should be of proper size&quot;,
267                       file, line);
268       }
269     }
270   }
271 }
272 
273 void ShenandoahAsserts::assert_forwarded(void* interior_loc, oop obj, const char* file, int line) {
274   assert_correct(interior_loc, obj, file, line);
<span class="line-modified">275   oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));</span>
276 
<span class="line-modified">277   if (oopDesc::equals_raw(obj, fwd)) {</span>
278     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_forwarded failed&quot;,
279                   &quot;Object should be forwarded&quot;,
280                   file, line);
281   }
282 }
283 
284 void ShenandoahAsserts::assert_not_forwarded(void* interior_loc, oop obj, const char* file, int line) {
285   assert_correct(interior_loc, obj, file, line);
<span class="line-modified">286   oop fwd = oop(ShenandoahBrooksPointer::get_raw_unchecked(obj));</span>
287 
<span class="line-modified">288   if (!oopDesc::equals_raw(obj, fwd)) {</span>
289     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_forwarded failed&quot;,
290                   &quot;Object should not be forwarded&quot;,
291                   file, line);
292   }
293 }
294 
295 void ShenandoahAsserts::assert_marked(void *interior_loc, oop obj, const char *file, int line) {
296   assert_correct(interior_loc, obj, file, line);
297 
298   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
299   if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {
300     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_marked failed&quot;,
301                   &quot;Object should be marked&quot;,
302                   file, line);
303   }
304 }
305 
306 void ShenandoahAsserts::assert_in_cset(void* interior_loc, oop obj, const char* file, int line) {
307   assert_correct(interior_loc, obj, file, line);
308 
</pre>
<hr />
<pre>
310   if (!heap-&gt;in_collection_set(obj)) {
311     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_in_cset failed&quot;,
312                   &quot;Object should be in collection set&quot;,
313                   file, line);
314   }
315 }
316 
317 void ShenandoahAsserts::assert_not_in_cset(void* interior_loc, oop obj, const char* file, int line) {
318   assert_correct(interior_loc, obj, file, line);
319 
320   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
321   if (heap-&gt;in_collection_set(obj)) {
322     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset failed&quot;,
323                   &quot;Object should not be in collection set&quot;,
324                   file, line);
325   }
326 }
327 
328 void ShenandoahAsserts::assert_not_in_cset_loc(void* interior_loc, const char* file, int line) {
329   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
<span class="line-modified">330   if (heap-&gt;in_collection_set(interior_loc)) {</span>
331     print_failure(_safe_unknown, NULL, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset_loc failed&quot;,
332                   &quot;Interior location should not be in collection set&quot;,
333                   file, line);
334   }
335 }
336 
337 void ShenandoahAsserts::print_rp_failure(const char *label, BoolObjectClosure* actual,
338                                          const char *file, int line) {
339   ShenandoahMessageBuffer msg(&quot;%s\n&quot;, label);
340   msg.append(&quot; Actual:                  &quot; PTR_FORMAT &quot;\n&quot;, p2i(actual));
341   report_vm_error(file, line, msg.buffer());
342 }
343 
344 void ShenandoahAsserts::assert_rp_isalive_not_installed(const char *file, int line) {
345   ShenandoahHeap* heap = ShenandoahHeap::heap();
346   ReferenceProcessor* rp = heap-&gt;ref_processor();
347   if (rp-&gt;is_alive_non_header() != NULL) {
348     print_rp_failure(&quot;Shenandoah assert_rp_isalive_not_installed failed&quot;, rp-&gt;is_alive_non_header(),
349                      file, line);
350   }
351 }
352 
353 void ShenandoahAsserts::assert_rp_isalive_installed(const char *file, int line) {
354   ShenandoahHeap* heap = ShenandoahHeap::heap();
355   ReferenceProcessor* rp = heap-&gt;ref_processor();
356   if (rp-&gt;is_alive_non_header() == NULL) {
357     print_rp_failure(&quot;Shenandoah assert_rp_isalive_installed failed&quot;, rp-&gt;is_alive_non_header(),
358                      file, line);
359   }
360 }













</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
 29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 
 36 void print_raw_memory(ShenandoahMessageBuffer &amp;msg, void* loc) {
 37   // Be extra safe. Only access data that is guaranteed to be safe:
 38   // should be in heap, in known committed region, within that region.
 39 
 40   ShenandoahHeap* heap = ShenandoahHeap::heap();
 41   if (!heap-&gt;is_in(loc)) return;
 42 
 43   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(loc);
 44   if (r != NULL &amp;&amp; r-&gt;is_committed()) {
 45     address start = MAX2((address) r-&gt;bottom(), (address) loc - 32);
 46     address end   = MIN2((address) r-&gt;end(),    (address) loc + 128);
 47     if (start &gt;= end) return;
 48 
 49     stringStream ss;
 50     os::print_hex_dump(&amp;ss, start, end, 4);
 51     msg.append(&quot;\n&quot;);
 52     msg.append(&quot;Raw heap memory:\n%s&quot;, ss.as_string());
 53   }
 54 }
 55 
 56 void ShenandoahAsserts::print_obj(ShenandoahMessageBuffer&amp; msg, oop obj) {
 57   ShenandoahHeap* heap = ShenandoahHeap::heap();
 58   ShenandoahHeapRegion *r = heap-&gt;heap_region_containing(obj);
 59 
 60   ResourceMark rm;
 61   stringStream ss;
 62   r-&gt;print_on(&amp;ss);
 63 
<span class="line-added"> 64   stringStream mw_ss;</span>
<span class="line-added"> 65   obj-&gt;mark().print_on(&amp;mw_ss);</span>
<span class="line-added"> 66 </span>
 67   ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 68 
 69   msg.append(&quot;  &quot; PTR_FORMAT &quot; - klass &quot; PTR_FORMAT &quot; %s\n&quot;, p2i(obj), p2i(obj-&gt;klass()), obj-&gt;klass()-&gt;external_name());
<span class="line-modified"> 70   msg.append(&quot;    %3s allocated after mark start\n&quot;, ctx-&gt;allocated_after_mark_start(obj) ? &quot;&quot; : &quot;not&quot;);</span>
 71   msg.append(&quot;    %3s marked \n&quot;,                    ctx-&gt;is_marked(obj) ? &quot;&quot; : &quot;not&quot;);
 72   msg.append(&quot;    %3s in collection set\n&quot;,          heap-&gt;in_collection_set(obj) ? &quot;&quot; : &quot;not&quot;);
 73   if (heap-&gt;traversal_gc() != NULL) {
<span class="line-modified"> 74     msg.append(&quot;    %3s in traversal set\n&quot;,         heap-&gt;traversal_gc()-&gt;traversal_set()-&gt;is_in(obj) ? &quot;&quot; : &quot;not&quot;);</span>
 75   }
<span class="line-added"> 76   msg.append(&quot;  mark:%s\n&quot;, mw_ss.as_string());</span>
 77   msg.append(&quot;  region: %s&quot;, ss.as_string());
 78 }
 79 
 80 void ShenandoahAsserts::print_non_obj(ShenandoahMessageBuffer&amp; msg, void* loc) {
 81   ShenandoahHeap* heap = ShenandoahHeap::heap();
 82   if (heap-&gt;is_in(loc)) {
 83     msg.append(&quot;  inside Java heap\n&quot;);
 84     ShenandoahHeapRegion *r = heap-&gt;heap_region_containing(loc);
 85     stringStream ss;
 86     r-&gt;print_on(&amp;ss);
 87 
<span class="line-modified"> 88     msg.append(&quot;    %3s in collection set\n&quot;,    heap-&gt;in_collection_set_loc(loc) ? &quot;&quot; : &quot;not&quot;);</span>
 89     msg.append(&quot;  region: %s&quot;, ss.as_string());
 90   } else {
 91     msg.append(&quot;  outside of Java heap\n&quot;);
 92     stringStream ss;
 93     os::print_location(&amp;ss, (intptr_t) loc, false);
 94     msg.append(&quot;  %s&quot;, ss.as_string());
 95   }
 96 }
 97 
 98 void ShenandoahAsserts::print_obj_safe(ShenandoahMessageBuffer&amp; msg, void* loc) {
 99   ShenandoahHeap* heap = ShenandoahHeap::heap();
100   msg.append(&quot;  &quot; PTR_FORMAT &quot; - safe print, no details\n&quot;, p2i(loc));
101   if (heap-&gt;is_in(loc)) {
102     ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(loc);
103     if (r != NULL) {
104       stringStream ss;
105       r-&gt;print_on(&amp;ss);
106       msg.append(&quot;  region: %s&quot;, ss.as_string());
107       print_raw_memory(msg, loc);
108     }
</pre>
<hr />
<pre>
124     msg.append(&quot;  interior location: &quot; PTR_FORMAT &quot;\n&quot;, p2i(interior_loc));
125     if (loc_in_heap) {
126       print_obj(msg, loc);
127     } else {
128       print_non_obj(msg, interior_loc);
129     }
130   } else {
131     msg.append(&quot;  no interior location recorded (probably a plain heap scan, or detached oop)\n&quot;);
132   }
133   msg.append(&quot;\n&quot;);
134 
135   msg.append(&quot;Object:\n&quot;);
136   if (level &gt;= _safe_oop) {
137     print_obj(msg, obj);
138   } else {
139     print_obj_safe(msg, obj);
140   }
141   msg.append(&quot;\n&quot;);
142 
143   if (level &gt;= _safe_oop) {
<span class="line-modified">144     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
145     msg.append(&quot;Forwardee:\n&quot;);
<span class="line-modified">146     if (obj != fwd) {</span>
147       if (level &gt;= _safe_oop_fwd) {
148         print_obj(msg, fwd);
149       } else {
150         print_obj_safe(msg, fwd);
151       }
152     } else {
153       msg.append(&quot;  (the object itself)&quot;);
154     }
155     msg.append(&quot;\n&quot;);
156   }
157 
158   if (level &gt;= _safe_oop_fwd) {
<span class="line-modified">159     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-modified">160     oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);</span>
<span class="line-modified">161     if (fwd != fwd2) {</span>
162       msg.append(&quot;Second forwardee:\n&quot;);
163       print_obj_safe(msg, fwd2);
164       msg.append(&quot;\n&quot;);
165     }
166   }
167 
168   report_vm_error(file, line, msg.buffer());
169 }
170 
171 void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {
172   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
173 
174   if (!heap-&gt;is_in(obj)) {
175     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_heap failed&quot;,
176                   &quot;oop must point to a heap address&quot;,
177                   file, line);
178   }
179 }
180 
181 void ShenandoahAsserts::assert_correct(void* interior_loc, oop obj, const char* file, int line) {
</pre>
<hr />
<pre>
185   // After this step, it is safe to call heap_region_containing().
186   if (!heap-&gt;is_in(obj)) {
187     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
188                   &quot;oop must point to a heap address&quot;,
189                   file, line);
190   }
191 
192   Klass* obj_klass = obj-&gt;klass_or_null();
193   if (obj_klass == NULL) {
194     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
195                   &quot;Object klass pointer should not be NULL&quot;,
196                   file,line);
197   }
198 
199   if (!Metaspace::contains(obj_klass)) {
200     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
201                   &quot;Object klass pointer must go to metaspace&quot;,
202                   file,line);
203   }
204 
<span class="line-modified">205   oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));</span>
206 
<span class="line-modified">207   if (obj != fwd) {</span>
208     // When Full GC moves the objects, we cannot trust fwdptrs. If we got here, it means something
209     // tries fwdptr manipulation when Full GC is running. The only exception is using the fwdptr
210     // that still points to the object itself.
211     if (heap-&gt;is_full_gc_move_in_progress()) {
212       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
213                     &quot;Non-trivial forwarding pointer during Full GC moves, probable bug.&quot;,
214                     file, line);
215     }
216 
217     // Step 2. Check that forwardee is correct
218     if (!heap-&gt;is_in(fwd)) {
219       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
220                     &quot;Forwardee must point to a heap address&quot;,
221                     file, line);
222     }
223 
224     if (obj_klass != fwd-&gt;klass()) {
225       print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
226                     &quot;Forwardee klass disagrees with object class&quot;,
227                     file, line);
228     }
229 
230     // Step 3. Check that forwardee points to correct region
231     if (heap-&gt;heap_region_index_containing(fwd) == heap-&gt;heap_region_index_containing(obj)) {
232       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
233                     &quot;Non-trivial forwardee should in another region&quot;,
234                     file, line);
235     }
236 
237     // Step 4. Check for multiple forwardings
<span class="line-modified">238     oop fwd2 = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(fwd));</span>
<span class="line-modified">239     if (fwd != fwd2) {</span>
240       print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_correct failed&quot;,
241                     &quot;Multiple forwardings&quot;,
242                     file, line);
243     }
244   }
245 }
246 
247 void ShenandoahAsserts::assert_in_correct_region(void* interior_loc, oop obj, const char* file, int line) {
248   assert_correct(interior_loc, obj, file, line);
249 
250   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
251   ShenandoahHeapRegion* r = heap-&gt;heap_region_containing(obj);
252   if (!r-&gt;is_active()) {
253     print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
254                   &quot;Object must reside in active region&quot;,
255                   file, line);
256   }
257 
<span class="line-modified">258   size_t alloc_size = obj-&gt;size();</span>
259   if (alloc_size &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
260     size_t idx = r-&gt;region_number();
261     size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);
262     for (size_t i = idx; i &lt; idx + num_regions; i++) {
263       ShenandoahHeapRegion* chain_reg = heap-&gt;get_region(i);
264       if (i == idx &amp;&amp; !chain_reg-&gt;is_humongous_start()) {
265         print_failure(_safe_unknown, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
266                       &quot;Object must reside in humongous start&quot;,
267                       file, line);
268       }
269       if (i != idx &amp;&amp; !chain_reg-&gt;is_humongous_continuation()) {
270         print_failure(_safe_oop, obj, interior_loc, NULL, &quot;Shenandoah assert_in_correct_region failed&quot;,
271                       &quot;Humongous continuation should be of proper size&quot;,
272                       file, line);
273       }
274     }
275   }
276 }
277 
278 void ShenandoahAsserts::assert_forwarded(void* interior_loc, oop obj, const char* file, int line) {
279   assert_correct(interior_loc, obj, file, line);
<span class="line-modified">280   oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));</span>
281 
<span class="line-modified">282   if (obj == fwd) {</span>
283     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_forwarded failed&quot;,
284                   &quot;Object should be forwarded&quot;,
285                   file, line);
286   }
287 }
288 
289 void ShenandoahAsserts::assert_not_forwarded(void* interior_loc, oop obj, const char* file, int line) {
290   assert_correct(interior_loc, obj, file, line);
<span class="line-modified">291   oop fwd = oop(ShenandoahForwarding::get_forwardee_raw_unchecked(obj));</span>
292 
<span class="line-modified">293   if (obj != fwd) {</span>
294     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_forwarded failed&quot;,
295                   &quot;Object should not be forwarded&quot;,
296                   file, line);
297   }
298 }
299 
300 void ShenandoahAsserts::assert_marked(void *interior_loc, oop obj, const char *file, int line) {
301   assert_correct(interior_loc, obj, file, line);
302 
303   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
304   if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {
305     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_marked failed&quot;,
306                   &quot;Object should be marked&quot;,
307                   file, line);
308   }
309 }
310 
311 void ShenandoahAsserts::assert_in_cset(void* interior_loc, oop obj, const char* file, int line) {
312   assert_correct(interior_loc, obj, file, line);
313 
</pre>
<hr />
<pre>
315   if (!heap-&gt;in_collection_set(obj)) {
316     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_in_cset failed&quot;,
317                   &quot;Object should be in collection set&quot;,
318                   file, line);
319   }
320 }
321 
322 void ShenandoahAsserts::assert_not_in_cset(void* interior_loc, oop obj, const char* file, int line) {
323   assert_correct(interior_loc, obj, file, line);
324 
325   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
326   if (heap-&gt;in_collection_set(obj)) {
327     print_failure(_safe_all, obj, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset failed&quot;,
328                   &quot;Object should not be in collection set&quot;,
329                   file, line);
330   }
331 }
332 
333 void ShenandoahAsserts::assert_not_in_cset_loc(void* interior_loc, const char* file, int line) {
334   ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();
<span class="line-modified">335   if (heap-&gt;in_collection_set_loc(interior_loc)) {</span>
336     print_failure(_safe_unknown, NULL, interior_loc, NULL, &quot;Shenandoah assert_not_in_cset_loc failed&quot;,
337                   &quot;Interior location should not be in collection set&quot;,
338                   file, line);
339   }
340 }
341 
342 void ShenandoahAsserts::print_rp_failure(const char *label, BoolObjectClosure* actual,
343                                          const char *file, int line) {
344   ShenandoahMessageBuffer msg(&quot;%s\n&quot;, label);
345   msg.append(&quot; Actual:                  &quot; PTR_FORMAT &quot;\n&quot;, p2i(actual));
346   report_vm_error(file, line, msg.buffer());
347 }
348 
349 void ShenandoahAsserts::assert_rp_isalive_not_installed(const char *file, int line) {
350   ShenandoahHeap* heap = ShenandoahHeap::heap();
351   ReferenceProcessor* rp = heap-&gt;ref_processor();
352   if (rp-&gt;is_alive_non_header() != NULL) {
353     print_rp_failure(&quot;Shenandoah assert_rp_isalive_not_installed failed&quot;, rp-&gt;is_alive_non_header(),
354                      file, line);
355   }
356 }
357 
358 void ShenandoahAsserts::assert_rp_isalive_installed(const char *file, int line) {
359   ShenandoahHeap* heap = ShenandoahHeap::heap();
360   ReferenceProcessor* rp = heap-&gt;ref_processor();
361   if (rp-&gt;is_alive_non_header() == NULL) {
362     print_rp_failure(&quot;Shenandoah assert_rp_isalive_installed failed&quot;, rp-&gt;is_alive_non_header(),
363                      file, line);
364   }
365 }
<span class="line-added">366 </span>
<span class="line-added">367 void ShenandoahAsserts::assert_locked_or_shenandoah_safepoint(Mutex* lock, const char* file, int line) {</span>
<span class="line-added">368   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {</span>
<span class="line-added">369     return;</span>
<span class="line-added">370   }</span>
<span class="line-added">371 </span>
<span class="line-added">372   if (lock-&gt;owned_by_self()) {</span>
<span class="line-added">373     return;</span>
<span class="line-added">374   }</span>
<span class="line-added">375 </span>
<span class="line-added">376   ShenandoahMessageBuffer msg(&quot;Must ba at a Shenandoah safepoint or held %s lock&quot;, lock-&gt;name());</span>
<span class="line-added">377   report_vm_error(file, line, msg.buffer());</span>
<span class="line-added">378 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahArguments.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahAsserts.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahVMOperations.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahVerifier.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,20 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  
  // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
  #ifdef verify_oop
  #undef verify_oop
  #endif
<span class="line-new-header">--- 23,25 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  
  // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
  #ifdef verify_oop
  #undef verify_oop
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,12 ***</span>
        // methods.
        //
        // For performance reasons, only fully verify non-marked field values.
        // We are here when the host object for *p is already marked.
  
<span class="line-modified">!       HeapWord* addr = (HeapWord*) obj;</span>
<span class="line-removed">-       if (_map-&gt;par_mark(addr)) {</span>
          verify_oop_at(p, obj);
          _stack-&gt;push(ShenandoahVerifierTask(obj));
        }
      }
    }
<span class="line-new-header">--- 86,11 ---</span>
        // methods.
        //
        // For performance reasons, only fully verify non-marked field values.
        // We are here when the host object for *p is already marked.
  
<span class="line-modified">!       if (_map-&gt;par_mark(obj)) {</span>
          verify_oop_at(p, obj);
          _stack-&gt;push(ShenandoahVerifierTask(obj));
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,11 ***</span>
      // that failure report would not try to touch something that was not yet verified to be
      // safe to process.
  
      check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
                &quot;oop must be in heap&quot;);
<span class="line-modified">!     check(ShenandoahAsserts::_safe_unknown, obj, check_obj_alignment(obj),</span>
                &quot;oop must be aligned&quot;);
  
      ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
      Klass* obj_klass = obj-&gt;klass_or_null();
  
<span class="line-new-header">--- 100,11 ---</span>
      // that failure report would not try to touch something that was not yet verified to be
      // safe to process.
  
      check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
                &quot;oop must be in heap&quot;);
<span class="line-modified">!     check(ShenandoahAsserts::_safe_unknown, obj, is_object_aligned(obj),</span>
                &quot;oop must be aligned&quot;);
  
      ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
      Klass* obj_klass = obj-&gt;klass_or_null();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,11 ***</span>
        check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
               &quot;Object klass pointer should not be NULL&quot;);
        check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
               &quot;Object klass pointer must go to metaspace&quot;);
  
<span class="line-modified">!       HeapWord *obj_addr = (HeapWord *) obj;</span>
        check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
               &quot;Object start should be within the region&quot;);
  
        if (!obj_reg-&gt;is_humongous()) {
          check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
<span class="line-new-header">--- 114,11 ---</span>
        check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
               &quot;Object klass pointer should not be NULL&quot;);
        check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
               &quot;Object klass pointer must go to metaspace&quot;);
  
<span class="line-modified">!       HeapWord *obj_addr = cast_from_oop&lt;HeapWord*&gt;(obj);</span>
        check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
               &quot;Object start should be within the region&quot;);
  
        if (!obj_reg-&gt;is_humongous()) {
          check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,31 ***</span>
        switch (_options._verify_liveness) {
          case ShenandoahVerifier::_verify_liveness_disable:
            // skip
            break;
          case ShenandoahVerifier::_verify_liveness_complete:
<span class="line-modified">!           Atomic::add(obj-&gt;size() + ShenandoahBrooksPointer::word_size(), &amp;_ld[obj_reg-&gt;region_number()]);</span>
            // fallthrough for fast failure for un-live regions:
          case ShenandoahVerifier::_verify_liveness_conservative:
            check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
                     &quot;Object must belong to region with live data&quot;);
            break;
          default:
            assert(false, &quot;Unhandled liveness verification&quot;);
        }
      }
  
<span class="line-modified">!     oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);</span>
  
      ShenandoahHeapRegion* fwd_reg = NULL;
  
<span class="line-modified">!     if (!oopDesc::equals_raw(obj, fwd)) {</span>
        check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
               &quot;Forwardee must be in heap&quot;);
        check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
               &quot;Forwardee is set&quot;);
<span class="line-modified">!       check(ShenandoahAsserts::_safe_oop, obj, check_obj_alignment(fwd),</span>
               &quot;Forwardee must be aligned&quot;);
  
        // Do this before touching fwd-&gt;size()
        Klass* fwd_klass = fwd-&gt;klass_or_null();
        check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
<span class="line-new-header">--- 140,31 ---</span>
        switch (_options._verify_liveness) {
          case ShenandoahVerifier::_verify_liveness_disable:
            // skip
            break;
          case ShenandoahVerifier::_verify_liveness_complete:
<span class="line-modified">!           Atomic::add(&amp;_ld[obj_reg-&gt;region_number()], (uint) obj-&gt;size());</span>
            // fallthrough for fast failure for un-live regions:
          case ShenandoahVerifier::_verify_liveness_conservative:
            check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
                     &quot;Object must belong to region with live data&quot;);
            break;
          default:
            assert(false, &quot;Unhandled liveness verification&quot;);
        }
      }
  
<span class="line-modified">!     oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
  
      ShenandoahHeapRegion* fwd_reg = NULL;
  
<span class="line-modified">!     if (obj != fwd) {</span>
        check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
               &quot;Forwardee must be in heap&quot;);
        check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
               &quot;Forwardee is set&quot;);
<span class="line-modified">!       check(ShenandoahAsserts::_safe_oop, obj, is_object_aligned(fwd),</span>
               &quot;Forwardee must be aligned&quot;);
  
        // Do this before touching fwd-&gt;size()
        Klass* fwd_klass = fwd-&gt;klass_or_null();
        check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,18 ***</span>
  
        // Verify that forwardee is not in the dead space:
        check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
               &quot;Should have no humongous forwardees&quot;);
  
<span class="line-modified">!       HeapWord *fwd_addr = (HeapWord *) fwd;</span>
        check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
               &quot;Forwardee start should be within the region&quot;);
        check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
               &quot;Forwardee end should be within the region&quot;);
  
<span class="line-modified">!       oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);</span>
<span class="line-modified">!       check(ShenandoahAsserts::_safe_oop, obj, oopDesc::equals_raw(fwd, fwd2),</span>
               &quot;Double forwarding&quot;);
      } else {
        fwd_reg = obj_reg;
      }
  
<span class="line-new-header">--- 178,18 ---</span>
  
        // Verify that forwardee is not in the dead space:
        check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
               &quot;Should have no humongous forwardees&quot;);
  
<span class="line-modified">!       HeapWord *fwd_addr = cast_from_oop&lt;HeapWord *&gt;(fwd);</span>
        check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
               &quot;Forwardee start should be within the region&quot;);
        check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
               &quot;Forwardee end should be within the region&quot;);
  
<span class="line-modified">!       oop fwd2 = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);</span>
<span class="line-modified">!       check(ShenandoahAsserts::_safe_oop, obj, (fwd == fwd2),</span>
               &quot;Double forwarding&quot;);
      } else {
        fwd_reg = obj_reg;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,16 ***</span>
      switch (_options._verify_forwarded) {
        case ShenandoahVerifier::_verify_forwarded_disable:
          // skip
          break;
        case ShenandoahVerifier::_verify_forwarded_none: {
<span class="line-modified">!         check(ShenandoahAsserts::_safe_all, obj, oopDesc::equals_raw(obj, fwd),</span>
                 &quot;Should not be forwarded&quot;);
          break;
        }
        case ShenandoahVerifier::_verify_forwarded_allow: {
<span class="line-modified">!         if (!oopDesc::equals_raw(obj, fwd)) {</span>
            check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
                   &quot;Forwardee should be in another region&quot;);
          }
          break;
        }
<span class="line-new-header">--- 214,16 ---</span>
      switch (_options._verify_forwarded) {
        case ShenandoahVerifier::_verify_forwarded_disable:
          // skip
          break;
        case ShenandoahVerifier::_verify_forwarded_none: {
<span class="line-modified">!         check(ShenandoahAsserts::_safe_all, obj, (obj == fwd),</span>
                 &quot;Should not be forwarded&quot;);
          break;
        }
        case ShenandoahVerifier::_verify_forwarded_allow: {
<span class="line-modified">!         if (obj != fwd) {</span>
            check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
                   &quot;Forwardee should be in another region&quot;);
          }
          break;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,11 ***</span>
          check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
                 &quot;Should not have references to collection set&quot;);
          break;
        case ShenandoahVerifier::_verify_cset_forwarded:
          if (_heap-&gt;in_collection_set(obj)) {
<span class="line-modified">!           check(ShenandoahAsserts::_safe_all, obj, !oopDesc::equals_raw(obj, fwd),</span>
                   &quot;Object in collection set, should have forwardee&quot;);
          }
          break;
        default:
          assert(false, &quot;Unhandled cset verification&quot;);
<span class="line-new-header">--- 239,11 ---</span>
          check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
                 &quot;Should not have references to collection set&quot;);
          break;
        case ShenandoahVerifier::_verify_cset_forwarded:
          if (_heap-&gt;in_collection_set(obj)) {
<span class="line-modified">!           check(ShenandoahAsserts::_safe_all, obj, (obj != fwd),</span>
                   &quot;Object in collection set, should have forwardee&quot;);
          }
          break;
        default:
          assert(false, &quot;Unhandled cset verification&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,26 ***</span>
  };
  
  class ShenandoahVerifierReachableTask : public AbstractGangTask {
  private:
    const char* _label;
<span class="line-modified">!   ShenandoahRootProcessor* _rp;</span>
    ShenandoahVerifier::VerifyOptions _options;
    ShenandoahHeap* _heap;
    ShenandoahLivenessData* _ld;
    MarkBitMap* _bitmap;
    volatile size_t _processed;
  
  public:
    ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
                                    ShenandoahLivenessData* ld,
<span class="line-modified">!                                   ShenandoahRootProcessor* rp,</span>
                                    const char* label,
                                    ShenandoahVerifier::VerifyOptions options) :
      AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
      _label(label),
<span class="line-modified">!     _rp(rp),</span>
      _options(options),
      _heap(ShenandoahHeap::heap()),
      _ld(ld),
      _bitmap(bitmap),
      _processed(0) {};
<span class="line-new-header">--- 421,26 ---</span>
  };
  
  class ShenandoahVerifierReachableTask : public AbstractGangTask {
  private:
    const char* _label;
<span class="line-modified">!   ShenandoahRootVerifier* _verifier;</span>
    ShenandoahVerifier::VerifyOptions _options;
    ShenandoahHeap* _heap;
    ShenandoahLivenessData* _ld;
    MarkBitMap* _bitmap;
    volatile size_t _processed;
  
  public:
    ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
                                    ShenandoahLivenessData* ld,
<span class="line-modified">!                                   ShenandoahRootVerifier* verifier,</span>
                                    const char* label,
                                    ShenandoahVerifier::VerifyOptions options) :
      AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
      _label(label),
<span class="line-modified">!     _verifier(verifier),</span>
      _options(options),
      _heap(ShenandoahHeap::heap()),
      _ld(ld),
      _bitmap(bitmap),
      _processed(0) {};
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
      if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
          || (ShenandoahVerifyLevel &gt;= 3)) {
          ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
                                        ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
                                        _options);
<span class="line-modified">!         _rp-&gt;process_all_roots_slow(&amp;cl);</span>
      }
  
      size_t processed = 0;
  
      if (ShenandoahVerifyLevel &gt;= 3) {
<span class="line-new-header">--- 460,15 ---</span>
      if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
          || (ShenandoahVerifyLevel &gt;= 3)) {
          ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
                                        ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
                                        _options);
<span class="line-modified">!         if (_heap-&gt;unload_classes()) {</span>
<span class="line-added">+           _verifier-&gt;strong_roots_do(&amp;cl);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           _verifier-&gt;roots_do(&amp;cl);</span>
<span class="line-added">+         }</span>
      }
  
      size_t processed = 0;
  
      if (ShenandoahVerifyLevel &gt;= 3) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,11 ***</span>
          ShenandoahVerifierTask task = stack.pop();
          cl.verify_oops_from(task.obj());
        }
      }
  
<span class="line-modified">!     Atomic::add(processed, &amp;_processed);</span>
    }
  };
  
  class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
  private:
<span class="line-new-header">--- 480,11 ---</span>
          ShenandoahVerifierTask task = stack.pop();
          cl.verify_oops_from(task.obj());
        }
      }
  
<span class="line-modified">!     Atomic::add(&amp;_processed, processed);</span>
    }
  };
  
  class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 510,11 ***</span>
      ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
                                    ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
                                    _options);
  
      while (true) {
<span class="line-modified">!       size_t v = Atomic::add(1u, &amp;_claimed) - 1;</span>
        if (v &lt; _heap-&gt;num_regions()) {
          ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
          if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
            work_regular(r, stack, cl);
          } else if (r-&gt;is_humongous_start()) {
<span class="line-new-header">--- 519,11 ---</span>
      ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
                                    ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
                                    _options);
  
      while (true) {
<span class="line-modified">!       size_t v = Atomic::fetch_and_add(&amp;_claimed, 1u);</span>
        if (v &lt; _heap-&gt;num_regions()) {
          ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
          if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
            work_regular(r, stack, cl);
          } else if (r-&gt;is_humongous_start()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,48 ***</span>
      }
    }
  
    virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
      size_t processed = 0;
<span class="line-modified">!     HeapWord* obj = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
      if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
        verify_and_follow(obj, stack, cl, &amp;processed);
      }
<span class="line-modified">!     Atomic::add(processed, &amp;_processed);</span>
    }
  
    virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
      size_t processed = 0;
      MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
      HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
  
      // Bitmaps, before TAMS
      if (tams &gt; r-&gt;bottom()) {
<span class="line-modified">!       HeapWord* start = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
        HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
  
        while (addr &lt; tams) {
          verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified">!         addr += ShenandoahBrooksPointer::word_size();</span>
          if (addr &lt; tams) {
            addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
          }
        }
      }
  
      // Size-based, after TAMS
      {
        HeapWord* limit = r-&gt;top();
<span class="line-modified">!       HeapWord* addr = tams + ShenandoahBrooksPointer::word_size();</span>
  
        while (addr &lt; limit) {
          verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified">!         addr += oop(addr)-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
        }
      }
  
<span class="line-modified">!     Atomic::add(processed, &amp;_processed);</span>
    }
  
    void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
      if (!_bitmap-&gt;par_mark(addr)) return;
  
<span class="line-new-header">--- 535,48 ---</span>
      }
    }
  
    virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
      size_t processed = 0;
<span class="line-modified">!     HeapWord* obj = r-&gt;bottom();</span>
      if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
        verify_and_follow(obj, stack, cl, &amp;processed);
      }
<span class="line-modified">!     Atomic::add(&amp;_processed, processed);</span>
    }
  
    virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
      size_t processed = 0;
      MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
      HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
  
      // Bitmaps, before TAMS
      if (tams &gt; r-&gt;bottom()) {
<span class="line-modified">!       HeapWord* start = r-&gt;bottom();</span>
        HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
  
        while (addr &lt; tams) {
          verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified">!         addr += 1;</span>
          if (addr &lt; tams) {
            addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
          }
        }
      }
  
      // Size-based, after TAMS
      {
        HeapWord* limit = r-&gt;top();
<span class="line-modified">!       HeapWord* addr = tams;</span>
  
        while (addr &lt; limit) {
          verify_and_follow(addr, stack, cl, &amp;processed);
<span class="line-modified">!         addr += oop(addr)-&gt;size();</span>
        }
      }
  
<span class="line-modified">!     Atomic::add(&amp;_processed, processed);</span>
    }
  
    void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
      if (!_bitmap-&gt;par_mark(addr)) return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 601,15 ***</span>
        fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
      }
    }
  };
  
  void ShenandoahVerifier::verify_at_safepoint(const char *label,
                                               VerifyForwarded forwarded, VerifyMarked marked,
                                               VerifyCollectionSet cset,
                                               VerifyLiveness liveness, VerifyRegions regions,
<span class="line-modified">!                                              VerifyGCState gcstate) {</span>
    guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
    guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
  
    // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
    ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
<span class="line-new-header">--- 610,33 ---</span>
        fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
      }
    }
  };
  
<span class="line-added">+ class ShenandoahGCStateResetter : public StackObj {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahHeap* const _heap;</span>
<span class="line-added">+   char _gc_state;</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahGCStateResetter() : _heap(ShenandoahHeap::heap()) {</span>
<span class="line-added">+     _gc_state = _heap-&gt;gc_state();</span>
<span class="line-added">+     _heap-&gt;_gc_state.clear();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~ShenandoahGCStateResetter() {</span>
<span class="line-added">+     _heap-&gt;_gc_state.set(_gc_state);</span>
<span class="line-added">+     assert(_heap-&gt;gc_state() == _gc_state, &quot;Should be restored&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  void ShenandoahVerifier::verify_at_safepoint(const char *label,
                                               VerifyForwarded forwarded, VerifyMarked marked,
                                               VerifyCollectionSet cset,
                                               VerifyLiveness liveness, VerifyRegions regions,
<span class="line-modified">!                                              VerifyGCState gcstate,</span>
<span class="line-added">+                                              VerifyWeakRoots weak_roots) {</span>
    guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
    guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
  
    // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
    ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,10 ***</span>
<span class="line-new-header">--- 653,14 ---</span>
          break;
        case _verify_gcstate_forwarded:
          enabled = true;
          expected = ShenandoahHeap::HAS_FORWARDED;
          break;
<span class="line-added">+       case _verify_gcstate_evacuation:</span>
<span class="line-added">+         enabled = true;</span>
<span class="line-added">+         expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION;</span>
<span class="line-added">+         break;</span>
        case _verify_gcstate_stable:
          enabled = true;
          expected = ShenandoahHeap::STABLE;
          break;
        default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,25 ***</span>
        VerifyThreadGCState vtgcs(label, expected);
        Threads::java_threads_do(&amp;vtgcs);
      }
    }
  
    // Heap size checks
    {
      ShenandoahHeapLocker lock(_heap-&gt;lock());
  
      ShenandoahCalculateRegionStatsClosure cl;
      _heap-&gt;heap_region_iterate(&amp;cl);
      size_t heap_used = _heap-&gt;used();
      guarantee(cl.used() == heap_used,
<span class="line-modified">!               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;K, regions-used = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">!               label, heap_used/K, cl.used()/K);</span>
  
      size_t heap_committed = _heap-&gt;committed();
      guarantee(cl.committed() == heap_committed,
<span class="line-modified">!               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;K, regions-committed = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">!               label, heap_committed/K, cl.committed()/K);</span>
    }
  
    // Internal heap region checks
    if (ShenandoahVerifyLevel &gt;= 1) {
      ShenandoahVerifyHeapRegionClosure cl(label, regions);
<span class="line-new-header">--- 677,32 ---</span>
        VerifyThreadGCState vtgcs(label, expected);
        Threads::java_threads_do(&amp;vtgcs);
      }
    }
  
<span class="line-added">+   // Deactivate barriers temporarily: Verifier wants plain heap accesses</span>
<span class="line-added">+   ShenandoahGCStateResetter resetter;</span>
<span class="line-added">+ </span>
    // Heap size checks
    {
      ShenandoahHeapLocker lock(_heap-&gt;lock());
  
      ShenandoahCalculateRegionStatsClosure cl;
      _heap-&gt;heap_region_iterate(&amp;cl);
      size_t heap_used = _heap-&gt;used();
      guarantee(cl.used() == heap_used,
<span class="line-modified">!               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;%s, regions-used = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!               label,</span>
<span class="line-added">+               byte_size_in_proper_unit(heap_used), proper_unit_for_byte_size(heap_used),</span>
<span class="line-added">+               byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));</span>
  
      size_t heap_committed = _heap-&gt;committed();
      guarantee(cl.committed() == heap_committed,
<span class="line-modified">!               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;%s, regions-committed = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!               label,</span>
<span class="line-added">+               byte_size_in_proper_unit(heap_committed), proper_unit_for_byte_size(heap_committed),</span>
<span class="line-added">+               byte_size_in_proper_unit(cl.committed()), proper_unit_for_byte_size(cl.committed()));</span>
    }
  
    // Internal heap region checks
    if (ShenandoahVerifyLevel &gt;= 1) {
      ShenandoahVerifyHeapRegionClosure cl(label, regions);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 685,14 ***</span>
  
    // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
    // This verifies what application can see, since it only cares about reachable objects.
    size_t count_reachable = 0;
    if (ShenandoahVerifyLevel &gt;= 2) {
<span class="line-modified">!     ShenandoahRootProcessor rp(_heap, _heap-&gt;workers()-&gt;active_workers(),</span>
<span class="line-modified">!                                ShenandoahPhaseTimings::_num_phases); // no need for stats</span>
  
<span class="line-modified">!     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;rp, label, options);</span>
      _heap-&gt;workers()-&gt;run_task(&amp;task);
      count_reachable = task.processed();
    }
  
    // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
<span class="line-new-header">--- 723,25 ---</span>
  
    // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
    // This verifies what application can see, since it only cares about reachable objects.
    size_t count_reachable = 0;
    if (ShenandoahVerifyLevel &gt;= 2) {
<span class="line-modified">!     ShenandoahRootVerifier verifier;</span>
<span class="line-modified">!     switch (weak_roots) {</span>
<span class="line-added">+       case _verify_serial_weak_roots:</span>
<span class="line-added">+         verifier.excludes(ShenandoahRootVerifier::ConcurrentWeakRoots);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case _verify_concurrent_weak_roots:</span>
<span class="line-added">+         verifier.excludes(ShenandoahRootVerifier::SerialWeakRoots);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       case _verify_all_weak_roots:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       default:</span>
<span class="line-added">+         ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;verifier, label, options);</span>
      _heap-&gt;workers()-&gt;run_task(&amp;task);
      count_reachable = task.processed();
    }
  
    // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,16 ***</span>
  
        juint verf_live = 0;
        if (r-&gt;is_humongous()) {
          // For humongous objects, test if start region is marked live, and if so,
          // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<span class="line-modified">!         juint start_live = OrderAccess::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;region_number()]);</span>
          if (start_live &gt; 0) {
            verf_live = (juint)(r-&gt;used() / HeapWordSize);
          }
        } else {
<span class="line-modified">!         verf_live = OrderAccess::load_acquire(&amp;ld[r-&gt;region_number()]);</span>
        }
  
        size_t reg_live = r-&gt;get_live_data_words();
        if (reg_live != verf_live) {
          ResourceMark rm;
<span class="line-new-header">--- 770,16 ---</span>
  
        juint verf_live = 0;
        if (r-&gt;is_humongous()) {
          // For humongous objects, test if start region is marked live, and if so,
          // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<span class="line-modified">!         juint start_live = Atomic::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;region_number()]);</span>
          if (start_live &gt; 0) {
            verf_live = (juint)(r-&gt;used() / HeapWordSize);
          }
        } else {
<span class="line-modified">!         verf_live = Atomic::load_acquire(&amp;ld[r-&gt;region_number()]);</span>
        }
  
        size_t reg_live = r-&gt;get_live_data_words();
        if (reg_live != verf_live) {
          ResourceMark rm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,11 ***</span>
            _verify_forwarded_allow,     // conservatively allow forwarded
            _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
            _verify_cset_disable,        // cset may be inconsistent
            _verify_liveness_disable,    // no reliable liveness data
            _verify_regions_disable,     // no reliable region data
<span class="line-modified">!           _verify_gcstate_disable      // no data about gcstate</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_concmark() {
    if (_heap-&gt;has_forwarded_objects()) {
<span class="line-new-header">--- 803,12 ---</span>
            _verify_forwarded_allow,     // conservatively allow forwarded
            _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
            _verify_cset_disable,        // cset may be inconsistent
            _verify_liveness_disable,    // no reliable liveness data
            _verify_regions_disable,     // no reliable region data
<span class="line-modified">!           _verify_gcstate_disable,     // no data about gcstate</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_concmark() {
    if (_heap-&gt;has_forwarded_objects()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,21 ***</span>
              _verify_forwarded_allow,     // may have forwarded references
              _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
              _verify_cset_forwarded,      // allow forwarded references to cset
              _verify_liveness_disable,    // no reliable liveness data
              _verify_regions_notrash,     // no trash regions
<span class="line-modified">!             _verify_gcstate_forwarded    // there are forwarded objects</span>
      );
    } else {
      verify_at_safepoint(
              &quot;Before Mark&quot;,
              _verify_forwarded_none,      // UR should have fixed up
              _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
              _verify_cset_none,           // UR should have fixed this
              _verify_liveness_disable,    // no reliable liveness data
              _verify_regions_notrash,     // no trash regions
<span class="line-modified">!             _verify_gcstate_stable       // there are no forwarded objects</span>
      );
    }
  }
  
  void ShenandoahVerifier::verify_after_concmark() {
<span class="line-new-header">--- 817,23 ---</span>
              _verify_forwarded_allow,     // may have forwarded references
              _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
              _verify_cset_forwarded,      // allow forwarded references to cset
              _verify_liveness_disable,    // no reliable liveness data
              _verify_regions_notrash,     // no trash regions
<span class="line-modified">!             _verify_gcstate_forwarded,   // there are forwarded objects</span>
<span class="line-added">+             _verify_all_weak_roots</span>
      );
    } else {
      verify_at_safepoint(
              &quot;Before Mark&quot;,
              _verify_forwarded_none,      // UR should have fixed up
              _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
              _verify_cset_none,           // UR should have fixed this
              _verify_liveness_disable,    // no reliable liveness data
              _verify_regions_notrash,     // no trash regions
<span class="line-modified">!             _verify_gcstate_stable,      // there are no forwarded objects</span>
<span class="line-added">+             _verify_all_weak_roots</span>
      );
    }
  }
  
  void ShenandoahVerifier::verify_after_concmark() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 790,23 ***</span>
            _verify_forwarded_none,      // no forwarded references
            _verify_marked_complete,     // bitmaps as precise as we can get
            _verify_cset_none,           // no references to cset anymore
            _verify_liveness_complete,   // liveness data must be complete here
            _verify_regions_disable,     // trash regions not yet recycled
<span class="line-modified">!           _verify_gcstate_stable       // mark should have stabilized the heap</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_evacuation() {
    verify_at_safepoint(
            &quot;Before Evacuation&quot;,
            _verify_forwarded_none,    // no forwarded references
            _verify_marked_complete,   // walk over marked objects too
            _verify_cset_disable,      // non-forwarded references to cset expected
            _verify_liveness_complete, // liveness data must be complete here
            _verify_regions_disable,   // trash regions not yet recycled
<span class="line-modified">!           _verify_gcstate_stable     // mark should have stabilized the heap</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_evacuation() {
    verify_at_safepoint(
<span class="line-new-header">--- 842,48 ---</span>
            _verify_forwarded_none,      // no forwarded references
            _verify_marked_complete,     // bitmaps as precise as we can get
            _verify_cset_none,           // no references to cset anymore
            _verify_liveness_complete,   // liveness data must be complete here
            _verify_regions_disable,     // trash regions not yet recycled
<span class="line-modified">!           _verify_gcstate_stable,       // mark should have stabilized the heap</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_evacuation() {
<span class="line-added">+   // Concurrent weak roots are evacuated during concurrent phase</span>
<span class="line-added">+   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?</span>
<span class="line-added">+                                       _verify_serial_weak_roots :</span>
<span class="line-added">+                                       _verify_all_weak_roots;</span>
<span class="line-added">+ </span>
    verify_at_safepoint(
            &quot;Before Evacuation&quot;,
            _verify_forwarded_none,    // no forwarded references
            _verify_marked_complete,   // walk over marked objects too
            _verify_cset_disable,      // non-forwarded references to cset expected
            _verify_liveness_complete, // liveness data must be complete here
            _verify_regions_disable,   // trash regions not yet recycled
<span class="line-modified">!           _verify_gcstate_stable,    // mark should have stabilized the heap</span>
<span class="line-added">+           verify_weak_roots</span>
<span class="line-added">+   );</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahVerifier::verify_during_evacuation() {</span>
<span class="line-added">+   // Concurrent weak roots are evacuated during concurrent phase</span>
<span class="line-added">+   VerifyWeakRoots verify_weak_roots = ShenandoahConcurrentRoots::should_do_concurrent_class_unloading() ?</span>
<span class="line-added">+                                       _verify_serial_weak_roots :</span>
<span class="line-added">+                                       _verify_all_weak_roots;</span>
<span class="line-added">+ </span>
<span class="line-added">+   verify_at_safepoint(</span>
<span class="line-added">+           &quot;During Evacuation&quot;,</span>
<span class="line-added">+           _verify_forwarded_allow,    // some forwarded references are allowed</span>
<span class="line-added">+           _verify_marked_disable,     // walk only roots</span>
<span class="line-added">+           _verify_cset_disable,       // some cset references are not forwarded yet</span>
<span class="line-added">+           _verify_liveness_disable,   // liveness data might be already stale after pre-evacs</span>
<span class="line-added">+           _verify_regions_disable,    // trash regions not yet recycled</span>
<span class="line-added">+           _verify_gcstate_evacuation, // evacuation is in progress</span>
<span class="line-added">+           verify_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_evacuation() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 814,11 ***</span>
            _verify_forwarded_allow,     // objects are still forwarded
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_forwarded,      // all cset refs are fully forwarded
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified">!           _verify_gcstate_forwarded    // evacuation produced some forwarded objects</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_updaterefs() {
    verify_at_safepoint(
<span class="line-new-header">--- 891,12 ---</span>
            _verify_forwarded_allow,     // objects are still forwarded
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_forwarded,      // all cset refs are fully forwarded
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified">!           _verify_gcstate_forwarded,   // evacuation produced some forwarded objects</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_updaterefs() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
            _verify_forwarded_allow,     // forwarded references allowed
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_forwarded,      // all cset refs are fully forwarded
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified">!           _verify_gcstate_forwarded    // evacuation should have produced some forwarded objects</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_updaterefs() {
    verify_at_safepoint(
<span class="line-new-header">--- 904,12 ---</span>
            _verify_forwarded_allow,     // forwarded references allowed
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_forwarded,      // all cset refs are fully forwarded
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash,     // trash regions have been recycled already
<span class="line-modified">!           _verify_gcstate_forwarded,   // evacuation should have produced some forwarded objects</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_updaterefs() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 838,11 ***</span>
            _verify_forwarded_none,      // no forwarded references
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_none,           // no cset references, all updated
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_nocset,      // no cset regions, trash regions have appeared
<span class="line-modified">!           _verify_gcstate_stable       // update refs had cleaned up forwarded objects</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_degenerated() {
    verify_at_safepoint(
<span class="line-new-header">--- 917,12 ---</span>
            _verify_forwarded_none,      // no forwarded references
            _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
            _verify_cset_none,           // no cset references, all updated
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_nocset,      // no cset regions, trash regions have appeared
<span class="line-modified">!           _verify_gcstate_stable,      // update refs had cleaned up forwarded objects</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_degenerated() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 850,11 ***</span>
            _verify_forwarded_none,      // all objects are non-forwarded
            _verify_marked_complete,     // all objects are marked in complete bitmap
            _verify_cset_none,           // no cset references
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified">!           _verify_gcstate_stable       // degenerated refs had cleaned up forwarded objects</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_traversal() {
    verify_at_safepoint(
<span class="line-new-header">--- 930,12 ---</span>
            _verify_forwarded_none,      // all objects are non-forwarded
            _verify_marked_complete,     // all objects are marked in complete bitmap
            _verify_cset_none,           // no cset references
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified">!           _verify_gcstate_stable,       // degenerated refs had cleaned up forwarded objects</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_traversal() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 862,11 ***</span>
            _verify_forwarded_none,      // cannot have forwarded objects
            _verify_marked_disable,      // bitmaps are not relevant before traversal
            _verify_cset_none,           // no cset references before traversal
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash and no cset regions
<span class="line-modified">!           _verify_gcstate_stable       // nothing forwarded before traversal</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_traversal() {
    verify_at_safepoint(
<span class="line-new-header">--- 943,12 ---</span>
            _verify_forwarded_none,      // cannot have forwarded objects
            _verify_marked_disable,      // bitmaps are not relevant before traversal
            _verify_cset_none,           // no cset references before traversal
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash and no cset regions
<span class="line-modified">!           _verify_gcstate_stable,      // nothing forwarded before traversal</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_traversal() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 874,11 ***</span>
            _verify_forwarded_none,      // cannot have forwarded objects
            _verify_marked_complete,     // should have complete marking after traversal
            _verify_cset_none,           // no cset references left after traversal
            _verify_liveness_disable,    // liveness data is not collected for new allocations
            _verify_regions_nocset,      // no cset regions, trash regions allowed
<span class="line-modified">!           _verify_gcstate_stable       // nothing forwarded after traversal</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_fullgc() {
    verify_at_safepoint(
<span class="line-new-header">--- 956,12 ---</span>
            _verify_forwarded_none,      // cannot have forwarded objects
            _verify_marked_complete,     // should have complete marking after traversal
            _verify_cset_none,           // no cset references left after traversal
            _verify_liveness_disable,    // liveness data is not collected for new allocations
            _verify_regions_nocset,      // no cset regions, trash regions allowed
<span class="line-modified">!           _verify_gcstate_stable,      // nothing forwarded after traversal</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_before_fullgc() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 886,11 ***</span>
            _verify_forwarded_allow,     // can have forwarded objects
            _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
            _verify_cset_disable,        // cset might be foobared
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_disable,     // no reliable region data here
<span class="line-modified">!           _verify_gcstate_disable      // no reliable gcstate data</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_fullgc() {
    verify_at_safepoint(
<span class="line-new-header">--- 969,12 ---</span>
            _verify_forwarded_allow,     // can have forwarded objects
            _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
            _verify_cset_disable,        // cset might be foobared
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_disable,     // no reliable region data here
<span class="line-modified">!           _verify_gcstate_disable,     // no reliable gcstate data</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
  
  void ShenandoahVerifier::verify_after_fullgc() {
    verify_at_safepoint(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 898,8 ***</span>
            _verify_forwarded_none,      // all objects are non-forwarded
            _verify_marked_complete,     // all objects are marked in complete bitmap
            _verify_cset_none,           // no cset references
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified">!           _verify_gcstate_stable       // full gc cleaned up everything</span>
    );
  }
<span class="line-new-header">--- 982,87 ---</span>
            _verify_forwarded_none,      // all objects are non-forwarded
            _verify_marked_complete,     // all objects are marked in complete bitmap
            _verify_cset_none,           // no cset references
            _verify_liveness_disable,    // no reliable liveness data anymore
            _verify_regions_notrash_nocset, // no trash, no cset
<span class="line-modified">!           _verify_gcstate_stable,       // full gc cleaned up everything</span>
<span class="line-added">+           _verify_all_weak_roots</span>
    );
  }
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahVerifyNoForwared : public OopClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   template &lt;class T&gt;</span>
<span class="line-added">+   void do_oop_work(T* p) {</span>
<span class="line-added">+     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">+       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">+       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">+       if (obj != fwd) {</span>
<span class="line-added">+         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">+                                          &quot;Verify Roots&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added">+   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ShenandoahVerifyInToSpaceClosure : public OopClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   template &lt;class T&gt;</span>
<span class="line-added">+   void do_oop_work(T* p) {</span>
<span class="line-added">+     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">+       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">+       ShenandoahHeap* heap = ShenandoahHeap::heap_no_check();</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (!heap-&gt;marking_context()-&gt;is_marked(obj)) {</span>
<span class="line-added">+         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">+                 &quot;Verify Roots In To-Space&quot;, &quot;Should be marked&quot;, __FILE__, __LINE__);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (heap-&gt;in_collection_set(obj)) {</span>
<span class="line-added">+         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">+                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be in collection set&quot;, __FILE__, __LINE__);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">+       if (obj != fwd) {</span>
<span class="line-added">+         ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, NULL,</span>
<span class="line-added">+                 &quot;Verify Roots In To-Space&quot;, &quot;Should not be forwarded&quot;, __FILE__, __LINE__);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added">+   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahVerifier::verify_roots_in_to_space() {</span>
<span class="line-added">+   ShenandoahRootVerifier verifier;</span>
<span class="line-added">+   ShenandoahVerifyInToSpaceClosure cl;</span>
<span class="line-added">+   verifier.oops_do(&amp;cl);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahVerifier::verify_roots_in_to_space_except(ShenandoahRootVerifier::RootTypes types) {</span>
<span class="line-added">+   ShenandoahRootVerifier verifier;</span>
<span class="line-added">+   verifier.excludes(types);</span>
<span class="line-added">+   ShenandoahVerifyInToSpaceClosure cl;</span>
<span class="line-added">+   verifier.oops_do(&amp;cl);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahVerifier::verify_roots_no_forwarded() {</span>
<span class="line-added">+   ShenandoahRootVerifier verifier;</span>
<span class="line-added">+   ShenandoahVerifyNoForwared cl;</span>
<span class="line-added">+   verifier.oops_do(&amp;cl);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahVerifier::verify_roots_no_forwarded_except(ShenandoahRootVerifier::RootTypes types) {</span>
<span class="line-added">+   ShenandoahRootVerifier verifier;</span>
<span class="line-added">+   verifier.excludes(types);</span>
<span class="line-added">+   ShenandoahVerifyNoForwared cl;</span>
<span class="line-added">+   verifier.oops_do(&amp;cl);</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="shenandoahVMOperations.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahVerifier.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
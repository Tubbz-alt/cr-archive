<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/allocation.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 26 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 27 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 32 #include &quot;gc/shared/space.inline.hpp&quot;
<a name="3" id="anc3"></a>
 33 #include &quot;memory/iterator.inline.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
<a name="4" id="anc4"></a>
 37 #include &quot;runtime/java.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/safepoint.hpp&quot;
 41 
 42 size_t ShenandoahHeapRegion::RegionCount = 0;
 43 size_t ShenandoahHeapRegion::RegionSizeBytes = 0;
 44 size_t ShenandoahHeapRegion::RegionSizeWords = 0;
 45 size_t ShenandoahHeapRegion::RegionSizeBytesShift = 0;
 46 size_t ShenandoahHeapRegion::RegionSizeWordsShift = 0;
 47 size_t ShenandoahHeapRegion::RegionSizeBytesMask = 0;
 48 size_t ShenandoahHeapRegion::RegionSizeWordsMask = 0;
 49 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 50 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 51 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 52 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 53 
 54 ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
 55 
 56 ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,
 57                                            size_t size_words, size_t index, bool committed) :
 58   _heap(heap),
 59   _reserved(MemRegion(start, size_words)),
 60   _region_number(index),
 61   _new_top(NULL),
<a name="5" id="anc5"></a><span class="line-removed"> 62   _critical_pins(0),</span>
 63   _empty_time(os::elapsedTime()),
 64   _state(committed ? _empty_committed : _empty_uncommitted),
 65   _tlab_allocs(0),
 66   _gclab_allocs(0),
 67   _shared_allocs(0),
 68   _seqnum_first_alloc_mutator(0),
 69   _seqnum_first_alloc_gc(0),
 70   _seqnum_last_alloc_mutator(0),
 71   _seqnum_last_alloc_gc(0),
<a name="6" id="anc6"></a><span class="line-modified"> 72   _live_data(0) {</span>

 73 
 74   ContiguousSpace::initialize(_reserved, true, committed);
 75 }
 76 
 77 size_t ShenandoahHeapRegion::region_number() const {
 78   return _region_number;
 79 }
 80 
 81 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
 82   ResourceMark rm;
 83   stringStream ss;
 84   ss.print(&quot;Illegal region state transition from \&quot;%s\&quot;, at %s\n  &quot;, region_state_to_string(_state), method);
 85   print_on(&amp;ss);
 86   fatal(&quot;%s&quot;, ss.as_string());
 87 }
 88 
 89 void ShenandoahHeapRegion::make_regular_allocation() {
 90   _heap-&gt;assert_heaplock_owned_by_current_thread();
 91 
 92   switch (_state) {
 93     case _empty_uncommitted:
 94       do_commit();
 95     case _empty_committed:
<a name="7" id="anc7"></a><span class="line-modified"> 96       _state = _regular;</span>
 97     case _regular:
 98     case _pinned:
 99       return;
100     default:
101       report_illegal_transition(&quot;regular allocation&quot;);
102   }
103 }
104 
105 void ShenandoahHeapRegion::make_regular_bypass() {
106   _heap-&gt;assert_heaplock_owned_by_current_thread();
107   assert (_heap-&gt;is_full_gc_in_progress() || _heap-&gt;is_degenerated_gc_in_progress(),
108           &quot;only for full or degen GC&quot;);
109 
110   switch (_state) {
111     case _empty_uncommitted:
112       do_commit();
113     case _empty_committed:
114     case _cset:
115     case _humongous_start:
116     case _humongous_cont:
<a name="8" id="anc8"></a><span class="line-modified">117       _state = _regular;</span>
118       return;
119     case _pinned_cset:
<a name="9" id="anc9"></a><span class="line-modified">120       _state = _pinned;</span>
121       return;
122     case _regular:
123     case _pinned:
124       return;
125     default:
126       report_illegal_transition(&quot;regular bypass&quot;);
127   }
128 }
129 
130 void ShenandoahHeapRegion::make_humongous_start() {
131   _heap-&gt;assert_heaplock_owned_by_current_thread();
132   switch (_state) {
133     case _empty_uncommitted:
134       do_commit();
135     case _empty_committed:
<a name="10" id="anc10"></a><span class="line-modified">136       _state = _humongous_start;</span>
137       return;
138     default:
139       report_illegal_transition(&quot;humongous start allocation&quot;);
140   }
141 }
142 
143 void ShenandoahHeapRegion::make_humongous_start_bypass() {
144   _heap-&gt;assert_heaplock_owned_by_current_thread();
145   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);
146 
147   switch (_state) {
148     case _empty_committed:
149     case _regular:
150     case _humongous_start:
151     case _humongous_cont:
<a name="11" id="anc11"></a><span class="line-modified">152       _state = _humongous_start;</span>
153       return;
154     default:
155       report_illegal_transition(&quot;humongous start bypass&quot;);
156   }
157 }
158 
159 void ShenandoahHeapRegion::make_humongous_cont() {
160   _heap-&gt;assert_heaplock_owned_by_current_thread();
161   switch (_state) {
162     case _empty_uncommitted:
163       do_commit();
164     case _empty_committed:
<a name="12" id="anc12"></a><span class="line-modified">165       _state = _humongous_cont;</span>
166       return;
167     default:
168       report_illegal_transition(&quot;humongous continuation allocation&quot;);
169   }
170 }
171 
172 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
173   _heap-&gt;assert_heaplock_owned_by_current_thread();
174   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);
175 
176   switch (_state) {
177     case _empty_committed:
178     case _regular:
179     case _humongous_start:
180     case _humongous_cont:
<a name="13" id="anc13"></a><span class="line-modified">181       _state = _humongous_cont;</span>
182       return;
183     default:
184       report_illegal_transition(&quot;humongous continuation bypass&quot;);
185   }
186 }
187 
188 void ShenandoahHeapRegion::make_pinned() {
189   _heap-&gt;assert_heaplock_owned_by_current_thread();
<a name="14" id="anc14"></a>

190   switch (_state) {
191     case _regular:
<a name="15" id="anc15"></a><span class="line-modified">192       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
<span class="line-removed">193       _state = _pinned;</span>
194     case _pinned_cset:
195     case _pinned:
<a name="16" id="anc16"></a><span class="line-removed">196       _critical_pins++;</span>
197       return;
198     case _humongous_start:
<a name="17" id="anc17"></a><span class="line-modified">199       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
<span class="line-removed">200       _state = _pinned_humongous_start;</span>
201     case _pinned_humongous_start:
<a name="18" id="anc18"></a><span class="line-removed">202       _critical_pins++;</span>
203       return;
204     case _cset:
<a name="19" id="anc19"></a><span class="line-removed">205       guarantee(_heap-&gt;cancelled_gc(), &quot;only valid when evac has been cancelled&quot;);</span>
<span class="line-removed">206       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
207       _state = _pinned_cset;
<a name="20" id="anc20"></a><span class="line-removed">208       _critical_pins++;</span>
209       return;
210     default:
211       report_illegal_transition(&quot;pinning&quot;);
212   }
213 }
214 
215 void ShenandoahHeapRegion::make_unpinned() {
216   _heap-&gt;assert_heaplock_owned_by_current_thread();
<a name="21" id="anc21"></a>

217   switch (_state) {
218     case _pinned:
<a name="22" id="anc22"></a><span class="line-modified">219       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">220       _critical_pins--;</span>
<span class="line-removed">221       if (_critical_pins == 0) {</span>
<span class="line-removed">222         _state = _regular;</span>
<span class="line-removed">223       }</span>
224       return;
225     case _regular:
226     case _humongous_start:
<a name="23" id="anc23"></a><span class="line-removed">227       assert (_critical_pins == 0, &quot;sanity&quot;);</span>
228       return;
229     case _pinned_cset:
<a name="24" id="anc24"></a><span class="line-modified">230       guarantee(_heap-&gt;cancelled_gc(), &quot;only valid when evac has been cancelled&quot;);</span>
<span class="line-removed">231       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">232       _critical_pins--;</span>
<span class="line-removed">233       if (_critical_pins == 0) {</span>
<span class="line-removed">234         _state = _cset;</span>
<span class="line-removed">235       }</span>
236       return;
237     case _pinned_humongous_start:
<a name="25" id="anc25"></a><span class="line-modified">238       assert (_critical_pins &gt; 0, &quot;sanity&quot;);</span>
<span class="line-removed">239       _critical_pins--;</span>
<span class="line-removed">240       if (_critical_pins == 0) {</span>
<span class="line-removed">241         _state = _humongous_start;</span>
<span class="line-removed">242       }</span>
243       return;
244     default:
245       report_illegal_transition(&quot;unpinning&quot;);
246   }
247 }
248 
249 void ShenandoahHeapRegion::make_cset() {
250   _heap-&gt;assert_heaplock_owned_by_current_thread();
251   switch (_state) {
252     case _regular:
<a name="26" id="anc26"></a><span class="line-modified">253       _state = _cset;</span>
254     case _cset:
255       return;
256     default:
257       report_illegal_transition(&quot;cset&quot;);
258   }
259 }
260 
261 void ShenandoahHeapRegion::make_trash() {
262   _heap-&gt;assert_heaplock_owned_by_current_thread();
263   switch (_state) {
264     case _cset:
265       // Reclaiming cset regions
266     case _humongous_start:
267     case _humongous_cont:
268       // Reclaiming humongous regions
269     case _regular:
270       // Immediate region reclaim
<a name="27" id="anc27"></a><span class="line-modified">271       _state = _trash;</span>
272       return;
273     default:
274       report_illegal_transition(&quot;trashing&quot;);
275   }
276 }
277 
278 void ShenandoahHeapRegion::make_trash_immediate() {
279   make_trash();
280 
281   // On this path, we know there are no marked objects in the region,
282   // tell marking context about it to bypass bitmap resets.
283   _heap-&gt;complete_marking_context()-&gt;reset_top_bitmap(this);
284 }
285 
286 void ShenandoahHeapRegion::make_empty() {
287   _heap-&gt;assert_heaplock_owned_by_current_thread();
288   switch (_state) {
289     case _trash:
<a name="28" id="anc28"></a><span class="line-modified">290       _state = _empty_committed;</span>
291       _empty_time = os::elapsedTime();
292       return;
293     default:
294       report_illegal_transition(&quot;emptying&quot;);
295   }
296 }
297 
298 void ShenandoahHeapRegion::make_uncommitted() {
299   _heap-&gt;assert_heaplock_owned_by_current_thread();
300   switch (_state) {
301     case _empty_committed:
302       do_uncommit();
<a name="29" id="anc29"></a><span class="line-modified">303       _state = _empty_uncommitted;</span>
304       return;
305     default:
306       report_illegal_transition(&quot;uncommiting&quot;);
307   }
308 }
309 
310 void ShenandoahHeapRegion::make_committed_bypass() {
311   _heap-&gt;assert_heaplock_owned_by_current_thread();
312   assert (_heap-&gt;is_full_gc_in_progress(), &quot;only for full GC&quot;);
313 
314   switch (_state) {
315     case _empty_uncommitted:
316       do_commit();
<a name="30" id="anc30"></a><span class="line-modified">317       _state = _empty_committed;</span>
318       return;
319     default:
320       report_illegal_transition(&quot;commit bypass&quot;);
321   }
322 }
323 
324 void ShenandoahHeapRegion::clear_live_data() {
<a name="31" id="anc31"></a><span class="line-modified">325   OrderAccess::release_store_fence&lt;size_t&gt;(&amp;_live_data, 0);</span>
326 }
327 
328 void ShenandoahHeapRegion::reset_alloc_metadata() {
329   _tlab_allocs = 0;
330   _gclab_allocs = 0;
331   _shared_allocs = 0;
332   _seqnum_first_alloc_mutator = 0;
333   _seqnum_last_alloc_mutator = 0;
334   _seqnum_first_alloc_gc = 0;
335   _seqnum_last_alloc_gc = 0;
336 }
337 
338 void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
339   if (used() &gt; 0) {
340     _tlab_allocs = 0;
341     _gclab_allocs = 0;
342     _shared_allocs = used() &gt;&gt; LogHeapWordSize;
343     uint64_t next = _alloc_seq_num.value++;
344     _seqnum_first_alloc_mutator = next;
345     _seqnum_last_alloc_mutator = next;
346     _seqnum_first_alloc_gc = 0;
347     _seqnum_last_alloc_gc = 0;
348   } else {
349     reset_alloc_metadata();
350   }
351 }
352 
353 size_t ShenandoahHeapRegion::get_shared_allocs() const {
354   return _shared_allocs * HeapWordSize;
355 }
356 
357 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
358   return _tlab_allocs * HeapWordSize;
359 }
360 
361 size_t ShenandoahHeapRegion::get_gclab_allocs() const {
362   return _gclab_allocs * HeapWordSize;
363 }
364 
365 void ShenandoahHeapRegion::set_live_data(size_t s) {
366   assert(Thread::current()-&gt;is_VM_thread(), &quot;by VM thread&quot;);
367   _live_data = (s &gt;&gt; LogHeapWordSize);
368 }
369 
370 size_t ShenandoahHeapRegion::get_live_data_words() const {
<a name="32" id="anc32"></a><span class="line-modified">371   return OrderAccess::load_acquire(&amp;_live_data);</span>
372 }
373 
374 size_t ShenandoahHeapRegion::get_live_data_bytes() const {
375   return get_live_data_words() * HeapWordSize;
376 }
377 
378 bool ShenandoahHeapRegion::has_live() const {
379   return get_live_data_words() != 0;
380 }
381 
382 size_t ShenandoahHeapRegion::garbage() const {
383   assert(used() &gt;= get_live_data_bytes(), &quot;Live Data must be a subset of used() live: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT,
384          get_live_data_bytes(), used());
385 
386   size_t result = used() - get_live_data_bytes();
387   return result;
388 }
389 
390 void ShenandoahHeapRegion::print_on(outputStream* st) const {
391   st-&gt;print(&quot;|&quot;);
392   st-&gt;print(SIZE_FORMAT_W(5), this-&gt;_region_number);
393 
394   switch (_state) {
395     case _empty_uncommitted:
396       st-&gt;print(&quot;|EU &quot;);
397       break;
398     case _empty_committed:
399       st-&gt;print(&quot;|EC &quot;);
400       break;
401     case _regular:
402       st-&gt;print(&quot;|R  &quot;);
403       break;
404     case _humongous_start:
405       st-&gt;print(&quot;|H  &quot;);
406       break;
407     case _pinned_humongous_start:
408       st-&gt;print(&quot;|HP &quot;);
409       break;
410     case _humongous_cont:
411       st-&gt;print(&quot;|HC &quot;);
412       break;
413     case _cset:
414       st-&gt;print(&quot;|CS &quot;);
415       break;
416     case _trash:
417       st-&gt;print(&quot;|T  &quot;);
418       break;
419     case _pinned:
420       st-&gt;print(&quot;|P  &quot;);
421       break;
422     case _pinned_cset:
423       st-&gt;print(&quot;|CSP&quot;);
424       break;
425     default:
426       ShouldNotReachHere();
427   }
428   st-&gt;print(&quot;|BTE &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12) &quot;, &quot; INTPTR_FORMAT_W(12),
429             p2i(bottom()), p2i(top()), p2i(end()));
430   st-&gt;print(&quot;|TAMS &quot; INTPTR_FORMAT_W(12),
431             p2i(_heap-&gt;marking_context()-&gt;top_at_mark_start(const_cast&lt;ShenandoahHeapRegion*&gt;(this))));
432   st-&gt;print(&quot;|U &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
433   st-&gt;print(&quot;|T &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
434   st-&gt;print(&quot;|G &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
435   st-&gt;print(&quot;|S &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
436   st-&gt;print(&quot;|L &quot; SIZE_FORMAT_W(5) &quot;%1s&quot;, byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
<a name="33" id="anc33"></a><span class="line-modified">437   st-&gt;print(&quot;|CP &quot; SIZE_FORMAT_W(3), _critical_pins);</span>
438   st-&gt;print(&quot;|SN &quot; UINT64_FORMAT_X_W(12) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8) &quot;, &quot; UINT64_FORMAT_X_W(8),
439             seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),
440             seqnum_first_alloc_gc(), seqnum_last_alloc_gc());
441   st-&gt;cr();
442 }
443 
444 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
445   if (!is_active()) return;
446   if (is_humongous()) {
447     oop_iterate_humongous(blk);
448   } else {
449     oop_iterate_objects(blk);
450   }
451 }
452 
453 void ShenandoahHeapRegion::oop_iterate_objects(OopIterateClosure* blk) {
454   assert(! is_humongous(), &quot;no humongous region here&quot;);
<a name="34" id="anc34"></a><span class="line-modified">455   HeapWord* obj_addr = bottom() + ShenandoahBrooksPointer::word_size();</span>
456   HeapWord* t = top();
457   // Could call objects iterate, but this is easier.
458   while (obj_addr &lt; t) {
459     oop obj = oop(obj_addr);
<a name="35" id="anc35"></a><span class="line-modified">460     obj_addr += obj-&gt;oop_iterate_size(blk) + ShenandoahBrooksPointer::word_size();</span>
461   }
462 }
463 
464 void ShenandoahHeapRegion::oop_iterate_humongous(OopIterateClosure* blk) {
465   assert(is_humongous(), &quot;only humongous region here&quot;);
466   // Find head.
467   ShenandoahHeapRegion* r = humongous_start_region();
468   assert(r-&gt;is_humongous_start(), &quot;need humongous head here&quot;);
<a name="36" id="anc36"></a><span class="line-modified">469   oop obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
470   obj-&gt;oop_iterate(blk, MemRegion(bottom(), top()));
471 }
472 
473 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
474   assert(is_humongous(), &quot;Must be a part of the humongous region&quot;);
475   size_t reg_num = region_number();
476   ShenandoahHeapRegion* r = const_cast&lt;ShenandoahHeapRegion*&gt;(this);
477   while (!r-&gt;is_humongous_start()) {
478     assert(reg_num &gt; 0, &quot;Sanity&quot;);
479     reg_num --;
480     r = _heap-&gt;get_region(reg_num);
481     assert(r-&gt;is_humongous(), &quot;Must be a part of the humongous region&quot;);
482   }
483   assert(r-&gt;is_humongous_start(), &quot;Must be&quot;);
484   return r;
485 }
486 
487 void ShenandoahHeapRegion::recycle() {
488   ContiguousSpace::clear(false);
489   if (ZapUnusedHeapArea) {
490     ContiguousSpace::mangle_unused_area_complete();
491   }
492   clear_live_data();
493 
494   reset_alloc_metadata();
495 
496   _heap-&gt;marking_context()-&gt;reset_top_at_mark_start(this);
497 
498   make_empty();
499 }
500 
501 HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {
502   assert(MemRegion(bottom(), end()).contains(p),
503          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
504          p2i(p), p2i(bottom()), p2i(end()));
505   if (p &gt;= top()) {
506     return top();
507   } else {
<a name="37" id="anc37"></a><span class="line-modified">508     HeapWord* last = bottom() + ShenandoahBrooksPointer::word_size();</span>
509     HeapWord* cur = last;
510     while (cur &lt;= p) {
511       last = cur;
<a name="38" id="anc38"></a><span class="line-modified">512       cur += oop(cur)-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
513     }
514     shenandoah_assert_correct(NULL, oop(last));
515     return last;
516   }
517 }
518 
<a name="39" id="anc39"></a><span class="line-modified">519 void ShenandoahHeapRegion::setup_sizes(size_t initial_heap_size, size_t max_heap_size) {</span>
520   // Absolute minimums we should not ever break.
521   static const size_t MIN_REGION_SIZE = 256*K;
522 
523   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
524     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
525   }
526 
527   size_t region_size;
528   if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
<a name="40" id="anc40"></a><span class="line-modified">529     if (ShenandoahMinRegionSize &gt; initial_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">530       err_msg message(&quot;Initial heap size (&quot; SIZE_FORMAT &quot;K) is too low to afford the minimum number &quot;</span>
<span class="line-modified">531                       &quot;of regions (&quot; SIZE_FORMAT &quot;) of minimum region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">532                       initial_heap_size/K, MIN_NUM_REGIONS, ShenandoahMinRegionSize/K);</span>


533       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
534     }
535     if (ShenandoahMinRegionSize &lt; MIN_REGION_SIZE) {
<a name="41" id="anc41"></a><span class="line-modified">536       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than minimum region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">537                       ShenandoahMinRegionSize/K,  MIN_REGION_SIZE/K);</span>

538       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
539     }
540     if (ShenandoahMinRegionSize &lt; MinTLABSize) {
<a name="42" id="anc42"></a><span class="line-modified">541       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than TLAB size size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">542                       ShenandoahMinRegionSize/K,  MinTLABSize/K);</span>

543       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize option&quot;, message);
544     }
545     if (ShenandoahMaxRegionSize &lt; MIN_REGION_SIZE) {
<a name="43" id="anc43"></a><span class="line-modified">546       err_msg message(&quot;&quot; SIZE_FORMAT &quot;K should not be lower than min region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">547                       ShenandoahMaxRegionSize/K,  MIN_REGION_SIZE/K);</span>

548       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMaxRegionSize option&quot;, message);
549     }
550     if (ShenandoahMinRegionSize &gt; ShenandoahMaxRegionSize) {
<a name="44" id="anc44"></a><span class="line-modified">551       err_msg message(&quot;Minimum (&quot; SIZE_FORMAT &quot;K) should be larger than maximum (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">552                       ShenandoahMinRegionSize/K, ShenandoahMaxRegionSize/K);</span>

553       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahMinRegionSize or -XX:ShenandoahMaxRegionSize&quot;, message);
554     }
555 
556     // We rapidly expand to max_heap_size in most scenarios, so that is the measure
557     // for usual heap sizes. Do not depend on initial_heap_size here.
558     region_size = max_heap_size / ShenandoahTargetNumRegions;
559 
560     // Now make sure that we don&#39;t go over or under our limits.
561     region_size = MAX2(ShenandoahMinRegionSize, region_size);
562     region_size = MIN2(ShenandoahMaxRegionSize, region_size);
563 
564   } else {
<a name="45" id="anc45"></a><span class="line-modified">565     if (ShenandoahHeapRegionSize &gt; initial_heap_size / MIN_NUM_REGIONS) {</span>
<span class="line-modified">566       err_msg message(&quot;Initial heap size (&quot; SIZE_FORMAT &quot;K) is too low to afford the minimum number &quot;</span>
<span class="line-modified">567                               &quot;of regions (&quot; SIZE_FORMAT &quot;) of requested size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">568                       initial_heap_size/K, MIN_NUM_REGIONS, ShenandoahHeapRegionSize/K);</span>


569       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
570     }
571     if (ShenandoahHeapRegionSize &lt; ShenandoahMinRegionSize) {
<a name="46" id="anc46"></a><span class="line-modified">572       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;K) should be larger than min region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">573                       ShenandoahHeapRegionSize/K, ShenandoahMinRegionSize/K);</span>

574       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
575     }
576     if (ShenandoahHeapRegionSize &gt; ShenandoahMaxRegionSize) {
<a name="47" id="anc47"></a><span class="line-modified">577       err_msg message(&quot;Heap region size (&quot; SIZE_FORMAT &quot;K) should be lower than max region size (&quot; SIZE_FORMAT &quot;K).&quot;,</span>
<span class="line-modified">578                       ShenandoahHeapRegionSize/K, ShenandoahMaxRegionSize/K);</span>

579       vm_exit_during_initialization(&quot;Invalid -XX:ShenandoahHeapRegionSize option&quot;, message);
580     }
581     region_size = ShenandoahHeapRegionSize;
582   }
583 
584   // Make sure region size is at least one large page, if enabled.
585   // Otherwise, uncommitting one region may falsely uncommit the adjacent
586   // regions too.
587   // Also see shenandoahArguments.cpp, where it handles UseLargePages.
588   if (UseLargePages &amp;&amp; ShenandoahUncommit) {
589     region_size = MAX2(region_size, os::large_page_size());
590   }
591 
592   int region_size_log = log2_long((jlong) region_size);
593   // Recalculate the region size to make sure it&#39;s a power of
594   // 2. This means that region_size is the largest power of 2 that&#39;s
595   // &lt;= what we&#39;ve calculated so far.
596   region_size = size_t(1) &lt;&lt; region_size_log;
597 
598   // Now, set up the globals.
599   guarantee(RegionSizeBytesShift == 0, &quot;we should only set it once&quot;);
600   RegionSizeBytesShift = (size_t)region_size_log;
601 
602   guarantee(RegionSizeWordsShift == 0, &quot;we should only set it once&quot;);
603   RegionSizeWordsShift = RegionSizeBytesShift - LogHeapWordSize;
604 
605   guarantee(RegionSizeBytes == 0, &quot;we should only set it once&quot;);
606   RegionSizeBytes = region_size;
607   RegionSizeWords = RegionSizeBytes &gt;&gt; LogHeapWordSize;
608   assert (RegionSizeWords*HeapWordSize == RegionSizeBytes, &quot;sanity&quot;);
609 
610   guarantee(RegionSizeWordsMask == 0, &quot;we should only set it once&quot;);
611   RegionSizeWordsMask = RegionSizeWords - 1;
612 
613   guarantee(RegionSizeBytesMask == 0, &quot;we should only set it once&quot;);
614   RegionSizeBytesMask = RegionSizeBytes - 1;
615 
616   guarantee(RegionCount == 0, &quot;we should only set it once&quot;);
617   RegionCount = max_heap_size / RegionSizeBytes;
618   guarantee(RegionCount &gt;= MIN_NUM_REGIONS, &quot;Should have at least minimum regions&quot;);
619 
620   guarantee(HumongousThresholdWords == 0, &quot;we should only set it once&quot;);
621   HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold / 100;
<a name="48" id="anc48"></a>
622   assert (HumongousThresholdWords &lt;= RegionSizeWords, &quot;sanity&quot;);
623 
624   guarantee(HumongousThresholdBytes == 0, &quot;we should only set it once&quot;);
625   HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;
626   assert (HumongousThresholdBytes &lt;= RegionSizeBytes, &quot;sanity&quot;);
627 
628   // The rationale for trimming the TLAB sizes has to do with the raciness in
629   // TLAB allocation machinery. It may happen that TLAB sizing policy polls Shenandoah
630   // about next free size, gets the answer for region #N, goes away for a while, then
631   // tries to allocate in region #N, and fail because some other thread have claimed part
632   // of the region #N, and then the freeset allocation code has to retire the region #N,
633   // before moving the allocation to region #N+1.
634   //
635   // The worst case realizes when &quot;answer&quot; is &quot;region size&quot;, which means it could
636   // prematurely retire an entire region. Having smaller TLABs does not fix that
637   // completely, but reduces the probability of too wasteful region retirement.
638   // With current divisor, we will waste no more than 1/8 of region size in the worst
639   // case. This also has a secondary effect on collection set selection: even under
640   // the race, the regions would be at least 7/8 used, which allows relying on
641   // &quot;used&quot; - &quot;live&quot; for cset selection. Otherwise, we can get the fragmented region
642   // below the garbage threshold that would never be considered for collection.
643   //
644   // The whole thing is mitigated if Elastic TLABs are enabled.
645   //
<a name="49" id="anc49"></a>



646   guarantee(MaxTLABSizeBytes == 0, &quot;we should only set it once&quot;);
<a name="50" id="anc50"></a><span class="line-modified">647   MaxTLABSizeBytes = MIN2(ShenandoahElasticTLAB ? RegionSizeBytes : (RegionSizeBytes / 8), HumongousThresholdBytes);</span>
648   assert (MaxTLABSizeBytes &gt; MinTLABSize, &quot;should be larger&quot;);
649 
<a name="51" id="anc51"></a><span class="line-removed">650   guarantee(MaxTLABSizeWords == 0, &quot;we should only set it once&quot;);</span>
<span class="line-removed">651   MaxTLABSizeWords = MaxTLABSizeBytes / HeapWordSize;</span>
<span class="line-removed">652 </span>
653   log_info(gc, init)(&quot;Regions: &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT &quot;%s&quot;,
654                      RegionCount, byte_size_in_proper_unit(RegionSizeBytes), proper_unit_for_byte_size(RegionSizeBytes));
655   log_info(gc, init)(&quot;Humongous object threshold: &quot; SIZE_FORMAT &quot;%s&quot;,
656                      byte_size_in_proper_unit(HumongousThresholdBytes), proper_unit_for_byte_size(HumongousThresholdBytes));
657   log_info(gc, init)(&quot;Max TLAB size: &quot; SIZE_FORMAT &quot;%s&quot;,
658                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
659 }
660 
661 void ShenandoahHeapRegion::do_commit() {
662   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {
663     report_java_out_of_memory(&quot;Unable to commit region&quot;);
664   }
665   if (!_heap-&gt;commit_bitmap_slice(this)) {
666     report_java_out_of_memory(&quot;Unable to commit bitmaps for region&quot;);
667   }
668   _heap-&gt;increase_committed(ShenandoahHeapRegion::region_size_bytes());
669 }
670 
671 void ShenandoahHeapRegion::do_uncommit() {
672   if (!_heap-&gt;is_heap_region_special() &amp;&amp; !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {
673     report_java_out_of_memory(&quot;Unable to uncommit region&quot;);
674   }
675   if (!_heap-&gt;uncommit_bitmap_slice(this)) {
676     report_java_out_of_memory(&quot;Unable to uncommit bitmaps for region&quot;);
677   }
678   _heap-&gt;decrease_committed(ShenandoahHeapRegion::region_size_bytes());
679 }
<a name="52" id="anc52"></a>

























<a name="53" id="anc53"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="53" type="hidden" />
</body>
</html>
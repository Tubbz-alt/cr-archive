diff a/src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp b/src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -21,13 +22,15 @@
  *
  */
 
 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
 #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
-#include "gc/shared/owstTaskTerminator.hpp"
+
+#include "gc/shared/taskTerminator.hpp"
 #include "gc/shared/taskqueue.hpp"
 #include "memory/allocation.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/mutex.hpp"
 #include "runtime/thread.hpp"
 
 template<class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE>
 class BufferedOverflowTaskQueue: public OverflowTaskQueue<E, F, N>
@@ -107,47 +110,50 @@
 // In future, these might be rebalanced to favor one degree of freedom against another. For example,
 // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
 // some bits back if chunks are counted in ObjArrayMarkingStride units.
 //
 // There is also a fallback version that uses plain fields, when we don't have enough space to steal the
-// bits from the native pointer. It is useful to debug the _LP64 version.
+// bits from the native pointer. It is useful to debug the optimized version.
 //
 
 #ifdef _MSC_VER
 #pragma warning(push)
 // warning C4522: multiple assignment operators specified
 #pragma warning( disable:4522 )
 #endif
 
 #ifdef _LP64
+#define SHENANDOAH_OPTIMIZED_OBJTASK 1
+#else
+#define SHENANDOAH_OPTIMIZED_OBJTASK 0
+#endif
+
+#if SHENANDOAH_OPTIMIZED_OBJTASK
 class ObjArrayChunkedTask
 {
 public:
   enum {
     chunk_bits   = 10,
     pow_bits     = 5,
-    oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits,
+    oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits
   };
   enum {
     oop_shift    = 0,
     pow_shift    = oop_shift + oop_bits,
-    chunk_shift  = pow_shift + pow_bits,
+    chunk_shift  = pow_shift + pow_bits
   };
 
 public:
   ObjArrayChunkedTask(oop o = NULL) {
-    _obj = ((uintptr_t)(void*) o) << oop_shift;
+    assert(decode_oop(encode_oop(o)) ==  o, "oop can be encoded: " PTR_FORMAT, p2i(o));
+    _obj = encode_oop(o);
   }
-  ObjArrayChunkedTask(oop o, int chunk, int mult) {
-    assert(0 <= chunk && chunk < nth_bit(chunk_bits), "chunk is sane: %d", chunk);
-    assert(0 <= mult && mult < nth_bit(pow_bits), "pow is sane: %d", mult);
-    uintptr_t t_b = ((uintptr_t) chunk) << chunk_shift;
-    uintptr_t t_m = ((uintptr_t) mult) << pow_shift;
-    uintptr_t obj = (uintptr_t)(void*)o;
-    assert(obj < nth_bit(oop_bits), "obj ref is sane: " PTR_FORMAT, obj);
-    intptr_t t_o = obj << oop_shift;
-    _obj = t_o | t_m | t_b;
+  ObjArrayChunkedTask(oop o, int chunk, int pow) {
+    assert(decode_oop(encode_oop(o)) == o, "oop can be encoded: " PTR_FORMAT, p2i(o));
+    assert(decode_chunk(encode_chunk(chunk)) == chunk, "chunk can be encoded: %d", chunk);
+    assert(decode_pow(encode_pow(pow)) == pow, "pow can be encoded: %d", pow);
+    _obj = encode_oop(o) | encode_chunk(chunk) | encode_pow(pow);
   }
   ObjArrayChunkedTask(const ObjArrayChunkedTask& t): _obj(t._obj) { }
 
   ObjArrayChunkedTask& operator =(const ObjArrayChunkedTask& t) {
     _obj = t._obj;
@@ -157,18 +163,42 @@
   operator =(const volatile ObjArrayChunkedTask& t) volatile {
     (void)const_cast<uintptr_t&>(_obj = t._obj);
     return *this;
   }
 
-  inline oop obj()   const { return (oop) reinterpret_cast<void*>((_obj >> oop_shift) & right_n_bits(oop_bits)); }
-  inline int chunk() const { return (int) (_obj >> chunk_shift) & right_n_bits(chunk_bits); }
-  inline int pow()   const { return (int) ((_obj >> pow_shift) & right_n_bits(pow_bits)); }
+  inline oop decode_oop(uintptr_t val) const {
+    return (oop) reinterpret_cast<void*>((val >> oop_shift) & right_n_bits(oop_bits));
+  }
+
+  inline int decode_chunk(uintptr_t val) const {
+    return (int) ((val >> chunk_shift) & right_n_bits(chunk_bits));
+  }
+
+  inline int decode_pow(uintptr_t val) const {
+    return (int) ((val >> pow_shift) & right_n_bits(pow_bits));
+  }
+
+  inline uintptr_t encode_oop(oop obj) const {
+    return ((uintptr_t)(void*) obj) << oop_shift;
+  }
+
+  inline uintptr_t encode_chunk(int chunk) const {
+    return ((uintptr_t) chunk) << chunk_shift;
+  }
+
+  inline uintptr_t encode_pow(int pow) const {
+    return ((uintptr_t) pow) << pow_shift;
+  }
+
+  inline oop obj()   const { return decode_oop(_obj);   }
+  inline int chunk() const { return decode_chunk(_obj); }
+  inline int pow()   const { return decode_pow(_obj);   }
   inline bool is_not_chunked() const { return (_obj & ~right_n_bits(oop_bits + pow_bits)) == 0; }
 
   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
 
-  static size_t max_addressable() {
+  static uintptr_t max_addressable() {
     return nth_bit(oop_bits);
   }
 
   static int chunk_size() {
     return nth_bit(chunk_bits);
@@ -227,11 +257,11 @@
 private:
   oop _obj;
   int _chunk;
   int _pow;
 };
-#endif
+#endif // SHENANDOAH_OPTIMIZED_OBJTASK
 
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
@@ -275,11 +305,11 @@
 
   if (_claimed_index >= size) {
     return NULL;
   }
 
-  jint index = Atomic::add(1, &_claimed_index);
+  jint index = Atomic::add(&_claimed_index, 1);
 
   if (index <= size) {
     return GenericTaskQueueSet<T, F>::queue((uint)index - 1);
   } else {
     return NULL;
@@ -307,21 +337,6 @@
   ShenandoahTerminatorTerminator(ShenandoahHeap* const heap) : _heap(heap) { }
   // return true, terminates immediately, even if there's remaining work left
   virtual bool should_exit_termination() { return _heap->cancelled_gc(); }
 };
 
-class ShenandoahTaskTerminator : public StackObj {
-private:
-  OWSTTaskTerminator* const   _terminator;
-public:
-  ShenandoahTaskTerminator(uint n_threads, TaskQueueSetSuper* queue_set);
-  ~ShenandoahTaskTerminator();
-
-  bool offer_termination(ShenandoahTerminatorTerminator* terminator) {
-    return _terminator->offer_termination(terminator);
-  }
-
-  void reset_for_reuse() { _terminator->reset_for_reuse(); }
-  bool offer_termination() { return offer_termination((ShenandoahTerminatorTerminator*)NULL); }
-};
-
 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP

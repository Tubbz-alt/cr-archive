diff a/src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp b/src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp
@@ -1,7 +1,8 @@
 /*
  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -30,18 +31,20 @@
 #include "gc/shenandoah/shenandoahSATBMarkQueueSet.hpp"
 
 class ShenandoahBarrierSetAssembler;
 
 class ShenandoahBarrierSet: public BarrierSet {
-private:
+public:
   enum ArrayCopyStoreValMode {
     NONE,
-    READ_BARRIER,
-    WRITE_BARRIER
+    RESOLVE_BARRIER,
+    EVAC_BARRIER
   };
+private:
 
   ShenandoahHeap* _heap;
+  BufferNode::Allocator _satb_mark_queue_buffer_allocator;
   ShenandoahSATBMarkQueueSet _satb_mark_queue_set;
 
 public:
   ShenandoahBarrierSet(ShenandoahHeap* heap);
 
@@ -53,209 +56,100 @@
 
   static ShenandoahSATBMarkQueueSet& satb_mark_queue_set() {
     return barrier_set()->_satb_mark_queue_set;
   }
 
+  static bool need_load_reference_barrier(DecoratorSet decorators, BasicType type);
+  static bool use_load_reference_barrier_native(DecoratorSet decorators, BasicType type);
+  static bool need_keep_alive_barrier(DecoratorSet decorators, BasicType type);
+
   void print_on(outputStream* st) const;
 
   bool is_a(BarrierSet::Name bsn);
 
   bool is_aligned(HeapWord* hw);
 
-  void write_ref_array(HeapWord* start, size_t count);
-
   template <class T> void
-  write_ref_array_pre_work(T* dst, size_t count);
-
-  void write_ref_array_pre(oop* dst, size_t count, bool dest_uninitialized);
+  write_ref_array_pre_work(T* src, T* dst, size_t count, bool dest_uninitialized);
 
-  void write_ref_array_pre(narrowOop* dst, size_t count, bool dest_uninitialized);
-
-  // We export this to make it available in cases where the static
-  // type of the barrier set is known.  Note that it is non-virtual.
-  template <class T> inline void inline_write_ref_field_pre(T* field, oop new_val);
-
-  // These are the more general virtual versions.
-  void write_ref_field_pre_work(oop* field, oop new_val);
-  void write_ref_field_pre_work(narrowOop* field, oop new_val);
-  void write_ref_field_pre_work(void* field, oop new_val);
-
-  void write_ref_field_work(void* v, oop o, bool release = false);
-  void write_region(MemRegion mr);
+  inline void arraycopy_pre(oop* src, oop* dst, size_t count);
+  inline void arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count);
+  inline void arraycopy_update(oop* src, size_t count);
+  inline void arraycopy_update(narrowOop* src, size_t count);
+  inline void clone_barrier(oop src);
+  void clone_barrier_runtime(oop src);
 
   virtual void on_thread_create(Thread* thread);
   virtual void on_thread_destroy(Thread* thread);
   virtual void on_thread_attach(Thread* thread);
   virtual void on_thread_detach(Thread* thread);
 
-  virtual oop read_barrier(oop src);
-
   static inline oop resolve_forwarded_not_null(oop p);
   static inline oop resolve_forwarded(oop p);
 
-  virtual oop write_barrier(oop obj);
+  template <DecoratorSet decorators, typename T>
+  inline void satb_barrier(T* field);
+  inline void satb_enqueue(oop value);
+  inline void storeval_barrier(oop obj);
 
-  oop write_barrier_mutator(oop obj);
+  template <DecoratorSet decorators>
+  inline void keep_alive_if_weak(oop value);
+  inline void keep_alive_if_weak(DecoratorSet decorators, oop value);
+  inline void keep_alive_barrier(oop value);
 
-  virtual oop storeval_barrier(oop obj);
+  inline void enqueue(oop obj);
 
-  virtual void keep_alive_barrier(oop obj);
+  oop load_reference_barrier(oop obj);
+  oop load_reference_barrier_not_null(oop obj);
 
-  bool obj_equals(oop obj1, oop obj2);
+  oop load_reference_barrier_mutator(oop obj, oop* load_addr);
+  oop load_reference_barrier_mutator(oop obj, narrowOop* load_addr);
 
-#ifdef CHECK_UNHANDLED_OOPS
-  bool oop_equals_operator_allowed() { return !ShenandoahVerifyObjectEquals; }
-#endif
+  template <class T>
+  oop load_reference_barrier_mutator_work(oop obj, T* load_addr);
 
-  void enqueue(oop obj);
+  oop load_reference_barrier_native(oop obj, oop* load_addr);
+  oop load_reference_barrier_native(oop obj, narrowOop* load_addr);
 
 private:
-  inline bool need_update_refs_barrier();
-
-  template <class T, bool STOREVAL_WRITE_BARRIER>
-  void write_ref_array_loop(HeapWord* start, size_t count);
+  template <class T>
+  inline void arraycopy_pre_work(T* src, T* dst, size_t count);
+  template <class T, bool HAS_FWD, bool EVAC, bool ENQUEUE>
+  inline void arraycopy_work(T* src, size_t count);
+  template <class T>
+  inline void arraycopy_update_impl(T* src, size_t count);
 
-  oop write_barrier_impl(oop obj);
+  oop load_reference_barrier_impl(oop obj);
 
-  static void keep_alive_if_weak(DecoratorSet decorators, oop value) {
-    assert((decorators & ON_UNKNOWN_OOP_REF) == 0, "Reference strength must be known");
-    const bool on_strong_oop_ref = (decorators & ON_STRONG_OOP_REF) != 0;
-    const bool peek              = (decorators & AS_NO_KEEPALIVE) != 0;
-    if (!peek && !on_strong_oop_ref && value != NULL) {
-      ShenandoahBarrierSet::barrier_set()->keep_alive_barrier(value);
-    }
-  }
-
-  template <typename T>
-  bool arraycopy_loop_1(T* src, T* dst, size_t length, Klass* bound,
-                        bool checkcast, bool satb, bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);
-
-  template <typename T, bool CHECKCAST>
-  bool arraycopy_loop_2(T* src, T* dst, size_t length, Klass* bound,
-                        bool satb, bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);
-
-  template <typename T, bool CHECKCAST, bool SATB>
-  bool arraycopy_loop_3(T* src, T* dst, size_t length, Klass* bound,
-                        bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);
-
-  template <typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE>
-  bool arraycopy_loop(T* src, T* dst, size_t length, Klass* bound, bool disjoint);
-
-  template <typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE>
-  bool arraycopy_element(T* cur_src, T* cur_dst, Klass* bound, Thread* thread);
+  template <class T>
+  oop load_reference_barrier_native_impl(oop obj, T* load_addr);
 
 public:
   // Callbacks for runtime accesses.
   template <DecoratorSet decorators, typename BarrierSetT = ShenandoahBarrierSet>
   class AccessBarrier: public BarrierSet::AccessBarrier<decorators, BarrierSetT> {
     typedef BarrierSet::AccessBarrier<decorators, BarrierSetT> Raw;
 
   public:
-    // Primitive heap accesses. These accessors get resolved when
-    // IN_HEAP is set (e.g. when using the HeapAccess API), it is
-    // not an oop_* overload, and the barrier strength is AS_NORMAL.
-    template <typename T>
-    static T load_in_heap(T* addr) {
-      ShouldNotReachHere();
-      return Raw::template load<T>(addr);
-    }
-
-    template <typename T>
-    static T load_in_heap_at(oop base, ptrdiff_t offset) {
-      base = ShenandoahBarrierSet::resolve_forwarded(base);
-      return Raw::template load_at<T>(base, offset);
-    }
-
-    template <typename T>
-    static void store_in_heap(T* addr, T value) {
-      ShouldNotReachHere();
-      Raw::store(addr, value);
-    }
-
-    template <typename T>
-    static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      Raw::store_at(base, offset, value);
-    }
-
-    template <typename T>
-    static T atomic_cmpxchg_in_heap(T new_value, T* addr, T compare_value) {
-      ShouldNotReachHere();
-      return Raw::atomic_cmpxchg(new_value, addr, compare_value);
-    }
-
-    template <typename T>
-    static T atomic_cmpxchg_in_heap_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      return Raw::atomic_cmpxchg_at(new_value, base, offset, compare_value);
-    }
-
-    template <typename T>
-    static T atomic_xchg_in_heap(T new_value, T* addr) {
-      ShouldNotReachHere();
-      return Raw::atomic_xchg(new_value, addr);
-    }
-
-    template <typename T>
-    static T atomic_xchg_in_heap_at(T new_value, oop base, ptrdiff_t offset) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      return Raw::atomic_xchg_at(new_value, base, offset);
-    }
-
-    template <typename T>
-    static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
-                                  arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
-                                  size_t length);
-
     // Heap oop accesses. These accessors get resolved when
     // IN_HEAP is set (e.g. when using the HeapAccess API), it is
     // an oop_* overload, and the barrier strength is AS_NORMAL.
     template <typename T>
-    static oop oop_load_in_heap(T* addr) {
-      // ShouldNotReachHere();
-      oop value = Raw::template oop_load<oop>(addr);
-      keep_alive_if_weak(decorators, value);
-      return value;
-    }
-
-    static oop oop_load_in_heap_at(oop base, ptrdiff_t offset) {
-      base = ShenandoahBarrierSet::resolve_forwarded(base);
-      oop value = Raw::template oop_load_at<oop>(base, offset);
-      keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset), value);
-      return value;
-    }
+    static oop oop_load_in_heap(T* addr);
+    static oop oop_load_in_heap_at(oop base, ptrdiff_t offset);
 
     template <typename T>
-    static void oop_store_in_heap(T* addr, oop value) {
-      ShenandoahBarrierSet::barrier_set()->write_ref_field_pre_work(addr, value);
-      Raw::oop_store(addr, value);
-    }
-
-    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      value = ShenandoahBarrierSet::barrier_set()->storeval_barrier(value);
-
-      oop_store_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), value);
-    }
+    static void oop_store_in_heap(T* addr, oop value);
+    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value);
 
     template <typename T>
-    static oop oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value);
-
-    static oop oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      new_value = ShenandoahBarrierSet::barrier_set()->storeval_barrier(new_value);
-      return oop_atomic_cmpxchg_in_heap(new_value, AccessInternal::oop_field_addr<decorators>(base, offset), compare_value);
-    }
+    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);
+    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value);
 
     template <typename T>
-    static oop oop_atomic_xchg_in_heap(oop new_value, T* addr);
-
-    static oop oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {
-      base = ShenandoahBarrierSet::barrier_set()->write_barrier(base);
-      new_value = ShenandoahBarrierSet::barrier_set()->storeval_barrier(new_value);
-      return oop_atomic_xchg_in_heap(new_value, AccessInternal::oop_field_addr<decorators>(base, offset));
-    }
+    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);
+    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value);
 
     template <typename T>
     static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                       size_t length);
@@ -263,23 +157,21 @@
     // Clone barrier support
     static void clone_in_heap(oop src, oop dst, size_t size);
 
     // Needed for loads on non-heap weak references
     template <typename T>
-    static oop oop_load_not_in_heap(T* addr) {
-      oop value = Raw::oop_load_not_in_heap(addr);
-      keep_alive_if_weak(decorators, value);
-      return value;
-    }
-
-    static oop resolve(oop obj) {
-      return ShenandoahBarrierSet::barrier_set()->write_barrier(obj);
-    }
-
-    static bool equals(oop o1, oop o2) {
-      return ShenandoahBarrierSet::barrier_set()->obj_equals(o1, o2);
-    }
+    static oop oop_load_not_in_heap(T* addr);
+
+    // Used for catching bad stores
+    template <typename T>
+    static void oop_store_not_in_heap(T* addr, oop value);
+
+    template <typename T>
+    static oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value);
+
+    template <typename T>
+    static oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value);
 
   };
 
 };
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;classfile/stringTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
<span class="line-modified"> 30 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>


 31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
<span class="line-removed"> 35 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;</span>
 36 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
<span class="line-modified"> 37 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;</span>
<span class="line-removed"> 38 #include &quot;memory/allocation.inline.hpp&quot;</span>
 39 #include &quot;memory/iterator.hpp&quot;
 40 #include &quot;memory/resourceArea.hpp&quot;

 41 #include &quot;runtime/thread.hpp&quot;
 42 #include &quot;services/management.hpp&quot;

 43 
<span class="line-modified"> 44 struct PhaseMap {</span>
<span class="line-modified"> 45   WeakProcessorPhases::Phase            _weak_processor_phase;</span>
<span class="line-modified"> 46   ShenandoahPhaseTimings::GCParPhases   _shenandoah_phase;</span>
<span class="line-removed"> 47 };</span>
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49 static const struct PhaseMap phase_mapping[] = {</span>
<span class="line-removed"> 50 #if INCLUDE_JVMTI</span>
<span class="line-removed"> 51   {WeakProcessorPhases::jvmti,       ShenandoahPhaseTimings::JVMTIWeakRoots},</span>
<span class="line-removed"> 52 #endif</span>
<span class="line-removed"> 53 #if INCLUDE_JFR</span>
<span class="line-removed"> 54   {WeakProcessorPhases::jfr,         ShenandoahPhaseTimings::JFRWeakRoots},</span>
<span class="line-removed"> 55 #endif</span>
<span class="line-removed"> 56 #if INCLUDE_TSAN</span>
<span class="line-removed"> 57   {WeakProcessorPhases::tsan,        ShenandoahPhaseTimings::TSANWeakRoots},</span>
<span class="line-removed"> 58 #endif</span>
<span class="line-removed"> 59   {WeakProcessorPhases::jni,         ShenandoahPhaseTimings::JNIWeakRoots},</span>
<span class="line-removed"> 60   {WeakProcessorPhases::stringtable, ShenandoahPhaseTimings::StringTableRoots},</span>
<span class="line-removed"> 61   {WeakProcessorPhases::vm,          ShenandoahPhaseTimings::VMWeakRoots}</span>
<span class="line-removed"> 62 };</span>
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64 STATIC_ASSERT(sizeof(phase_mapping) / sizeof(PhaseMap) == WeakProcessorPhases::phase_count);</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66 ShenandoahRootProcessor::ShenandoahRootProcessor(ShenandoahHeap* heap, uint n_workers,</span>
<span class="line-removed"> 67                                                  ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-removed"> 68   _process_strong_tasks(new SubTasksDone(SHENANDOAH_RP_PS_NumElements)),</span>
<span class="line-removed"> 69   _srs(n_workers),</span>
<span class="line-removed"> 70   _par_state_string(StringTable::weak_storage()),</span>
<span class="line-removed"> 71   _phase(phase),</span>
<span class="line-removed"> 72   _coderoots_all_iterator(ShenandoahCodeRoots::iterator()),</span>
<span class="line-removed"> 73   _weak_processor_timings(n_workers),</span>
<span class="line-removed"> 74   _weak_processor_task(&amp;_weak_processor_timings, n_workers),</span>
<span class="line-removed"> 75   _processed_weak_roots(false) {</span>
<span class="line-removed"> 76   heap-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
 77 
<span class="line-modified"> 78   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified"> 79     StringDedup::gc_prologue(false);</span>



 80   }
 81 }
 82 
<span class="line-modified"> 83 ShenandoahRootProcessor::~ShenandoahRootProcessor() {</span>
<span class="line-modified"> 84   delete _process_strong_tasks;</span>
<span class="line-modified"> 85   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified"> 86     StringDedup::gc_epilogue();</span>
<span class="line-removed"> 87   }</span>
 88 
<span class="line-modified"> 89   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>






 90 
<span class="line-modified"> 91   if (_processed_weak_roots) {</span>
<span class="line-modified"> 92     assert(_weak_processor_timings.max_threads() == n_workers(), &quot;Must match&quot;);</span>
<span class="line-modified"> 93     for (uint index = 0; index &lt; WeakProcessorPhases::phase_count; index ++) {</span>
<span class="line-modified"> 94       weak_processor_timing_to_shenandoah_timing(phase_mapping[index]._weak_processor_phase,</span>
<span class="line-modified"> 95                                                  phase_mapping[index]._shenandoah_phase,</span>
<span class="line-modified"> 96                                                  worker_times);</span>
<span class="line-modified"> 97     }</span>
<span class="line-removed"> 98   }</span>
 99 
<span class="line-modified">100   ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>

101 }
102 
<span class="line-modified">103 void ShenandoahRootProcessor::weak_processor_timing_to_shenandoah_timing(const WeakProcessorPhases::Phase wpp,</span>
<span class="line-modified">104                                                                          const ShenandoahPhaseTimings::GCParPhases spp,</span>
<span class="line-modified">105                                                                          ShenandoahWorkerTimings* worker_times) const {</span>
<span class="line-modified">106   if (WeakProcessorPhases::is_serial(wpp)) {</span>
<span class="line-modified">107     worker_times-&gt;record_time_secs(spp, 0, _weak_processor_timings.phase_time_sec(wpp));</span>
<span class="line-removed">108   } else {</span>
<span class="line-removed">109     for (uint index = 0; index &lt; _weak_processor_timings.max_threads(); index ++) {</span>
<span class="line-removed">110       worker_times-&gt;record_time_secs(spp, index, _weak_processor_timings.worker_time_sec(index, wpp));</span>
<span class="line-removed">111     }</span>
112   }
113 }
114 
<span class="line-modified">115 void ShenandoahRootProcessor::process_all_roots_slow(OopClosure* oops) {</span>
<span class="line-modified">116   CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);</span>
<span class="line-modified">117   CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">118 </span>
<span class="line-modified">119   CodeCache::blobs_do(&amp;blobs);</span>
<span class="line-removed">120   ClassLoaderDataGraph::cld_do(&amp;clds);</span>
<span class="line-removed">121   Universe::oops_do(oops);</span>
<span class="line-removed">122   Management::oops_do(oops);</span>
<span class="line-removed">123   JvmtiExport::oops_do(oops);</span>
<span class="line-removed">124   JNIHandles::oops_do(oops);</span>
<span class="line-removed">125   WeakProcessor::oops_do(oops);</span>
<span class="line-removed">126   ObjectSynchronizer::oops_do(oops);</span>
<span class="line-removed">127   SystemDictionary::oops_do(oops);</span>
<span class="line-removed">128 </span>
<span class="line-removed">129   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-removed">130     ShenandoahStringDedup::oops_do_slow(oops);</span>
<span class="line-removed">131   }</span>
132 
<span class="line-modified">133   // Do thread roots the last. This allows verification code to find</span>
<span class="line-modified">134   // any broken objects from those special roots first, not the accidental</span>
<span class="line-modified">135   // dangling reference from the thread root.</span>
<span class="line-removed">136   Threads::possibly_parallel_oops_do(false, oops, &amp;blobs);</span>
137 }

138 
<span class="line-modified">139 void ShenandoahRootProcessor::process_strong_roots(OopClosure* oops,</span>
<span class="line-modified">140                                                    OopClosure* weak_oops,</span>
<span class="line-modified">141                                                    CLDClosure* clds,</span>
<span class="line-modified">142                                                    CLDClosure* weak_clds,</span>
<span class="line-modified">143                                                    CodeBlobClosure* blobs,</span>
<span class="line-removed">144                                                    ThreadClosure* thread_cl,</span>
<span class="line-removed">145                                                    uint worker_id) {</span>
146 
<span class="line-modified">147   process_java_roots(oops, clds, weak_clds, blobs, thread_cl, worker_id);</span>
<span class="line-modified">148   process_vm_roots(oops, NULL, weak_oops, worker_id);</span>



149 
<span class="line-modified">150   _process_strong_tasks-&gt;all_tasks_completed(n_workers());</span>


151 }
152 
<span class="line-modified">153 void ShenandoahRootProcessor::process_all_roots(OopClosure* oops,</span>
<span class="line-modified">154                                                 OopClosure* weak_oops,</span>
<span class="line-modified">155                                                 CLDClosure* clds,</span>
<span class="line-removed">156                                                 CodeBlobClosure* blobs,</span>
<span class="line-removed">157                                                 ThreadClosure* thread_cl,</span>
<span class="line-removed">158                                                 uint worker_id) {</span>
159 

160   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
<span class="line-modified">161   process_java_roots(oops, clds, clds, blobs, thread_cl, worker_id);</span>
<span class="line-modified">162   process_vm_roots(oops, oops, weak_oops, worker_id);</span>


163 
<span class="line-modified">164   if (blobs != NULL) {</span>
<span class="line-modified">165     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);</span>
<span class="line-modified">166     _coderoots_all_iterator.possibly_parallel_blobs_do(blobs);</span>
<span class="line-modified">167   }</span>


168 
<span class="line-modified">169   _process_strong_tasks-&gt;all_tasks_completed(n_workers());</span>

170 }
171 
<span class="line-modified">172 class ShenandoahParallelOopsDoThreadClosure : public ThreadClosure {</span>
<span class="line-modified">173 private:</span>
<span class="line-modified">174   OopClosure* _f;</span>
<span class="line-removed">175   CodeBlobClosure* _cf;</span>
<span class="line-removed">176   ThreadClosure* _thread_cl;</span>
<span class="line-removed">177 public:</span>
<span class="line-removed">178   ShenandoahParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf, ThreadClosure* thread_cl) :</span>
<span class="line-removed">179     _f(f), _cf(cf), _thread_cl(thread_cl) {}</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   void do_thread(Thread* t) {</span>
<span class="line-removed">182     if (_thread_cl != NULL) {</span>
<span class="line-removed">183       _thread_cl-&gt;do_thread(t);</span>
<span class="line-removed">184     }</span>
<span class="line-removed">185     t-&gt;oops_do(_f, _cf);</span>
<span class="line-removed">186   }</span>
<span class="line-removed">187 };</span>
<span class="line-removed">188 </span>
<span class="line-removed">189 void ShenandoahRootProcessor::process_java_roots(OopClosure* strong_roots,</span>
<span class="line-removed">190                                                  CLDClosure* strong_clds,</span>
<span class="line-removed">191                                                  CLDClosure* weak_clds,</span>
<span class="line-removed">192                                                  CodeBlobClosure* strong_code,</span>
<span class="line-removed">193                                                  ThreadClosure* thread_cl,</span>
<span class="line-removed">194                                                  uint worker_id)</span>
<span class="line-removed">195 {</span>
<span class="line-removed">196   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-removed">197   // Iterating over the CLDG and the Threads are done early to allow us to</span>
<span class="line-removed">198   // first process the strong CLDs and nmethods and then, after a barrier,</span>
<span class="line-removed">199   // let the thread process the weak CLDs and nmethods.</span>
<span class="line-removed">200   {</span>
<span class="line-removed">201     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CLDGRoots, worker_id);</span>
<span class="line-removed">202     _cld_iterator.root_cld_do(strong_clds, weak_clds);</span>
203   }

204 
<span class="line-modified">205   {</span>
<span class="line-modified">206     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);</span>
<span class="line-modified">207     bool is_par = n_workers() &gt; 1;</span>
<span class="line-removed">208     ResourceMark rm;</span>
<span class="line-removed">209     ShenandoahParallelOopsDoThreadClosure cl(strong_roots, strong_code, thread_cl);</span>
<span class="line-removed">210     Threads::possibly_parallel_threads_do(is_par, &amp;cl);</span>
211   }
212 }
213 
<span class="line-modified">214 void ShenandoahRootProcessor::process_vm_roots(OopClosure* strong_roots,</span>
<span class="line-modified">215                                                OopClosure* weak_roots,</span>
<span class="line-modified">216                                                OopClosure* jni_weak_roots,</span>
<span class="line-removed">217                                                uint worker_id)</span>
<span class="line-removed">218 {</span>
<span class="line-removed">219   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-removed">220   if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_Universe_oops_do)) {</span>
<span class="line-removed">221     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::UniverseRoots, worker_id);</span>
<span class="line-removed">222     Universe::oops_do(strong_roots);</span>
223   }

224 
<span class="line-modified">225   if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_JNIHandles_oops_do)) {</span>
<span class="line-modified">226     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JNIRoots, worker_id);</span>
<span class="line-modified">227     JNIHandles::oops_do(strong_roots);</span>
<span class="line-modified">228   }</span>
<span class="line-modified">229   if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_Management_oops_do)) {</span>
<span class="line-removed">230     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ManagementRoots, worker_id);</span>
<span class="line-removed">231     Management::oops_do(strong_roots);</span>
<span class="line-removed">232   }</span>
<span class="line-removed">233   if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_jvmti_oops_do)) {</span>
<span class="line-removed">234     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JVMTIRoots, worker_id);</span>
<span class="line-removed">235     JvmtiExport::oops_do(strong_roots);</span>
<span class="line-removed">236   }</span>
<span class="line-removed">237   if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_SystemDictionary_oops_do)) {</span>
<span class="line-removed">238     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::SystemDictionaryRoots, worker_id);</span>
<span class="line-removed">239     SystemDictionary::oops_do(strong_roots);</span>
<span class="line-removed">240   }</span>
<span class="line-removed">241   if (jni_weak_roots != NULL) {</span>
<span class="line-removed">242     AlwaysTrueClosure always_true;</span>
<span class="line-removed">243     _weak_processor_task.work&lt;AlwaysTrueClosure, OopClosure&gt;(worker_id, &amp;always_true, jni_weak_roots);</span>
<span class="line-removed">244     _processed_weak_roots = true;</span>
245   }

246 
<span class="line-modified">247   if (ShenandoahStringDedup::is_enabled() &amp;&amp; weak_roots != NULL) {</span>
<span class="line-modified">248     ShenandoahStringDedup::parallel_oops_do(weak_roots, worker_id);</span>



249   }






250 
<span class="line-modified">251   {</span>
<span class="line-modified">252     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ObjectSynchronizerRoots, worker_id);</span>
<span class="line-modified">253     if (_process_strong_tasks-&gt;try_claim_task(SHENANDOAH_RP_PS_ObjectSynchronizer_oops_do)) {</span>
<span class="line-removed">254       ObjectSynchronizer::oops_do(strong_roots);</span>
<span class="line-removed">255     }</span>
256   }
257 }
258 
<span class="line-modified">259 uint ShenandoahRootProcessor::n_workers() const {</span>
<span class="line-modified">260   return _srs.n_threads();</span>



261 }
262 
<span class="line-modified">263 ShenandoahRootEvacuator::ShenandoahRootEvacuator(ShenandoahHeap* heap, uint n_workers, ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-modified">264   _evacuation_tasks(new SubTasksDone(SHENANDOAH_EVAC_NumElements)),</span>
<span class="line-modified">265   _srs(n_workers),</span>
<span class="line-removed">266   _phase(phase),</span>
<span class="line-removed">267   _coderoots_cset_iterator(ShenandoahCodeRoots::cset_iterator())</span>
<span class="line-removed">268 {</span>
<span class="line-removed">269   heap-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
270 }
271 
<span class="line-modified">272 ShenandoahRootEvacuator::~ShenandoahRootEvacuator() {</span>
<span class="line-modified">273   delete _evacuation_tasks;</span>
<span class="line-modified">274   ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>





275 }
276 
<span class="line-modified">277 void ShenandoahRootEvacuator::process_evacuate_roots(OopClosure* oops,</span>
<span class="line-modified">278                                                      CodeBlobClosure* blobs,</span>
<span class="line-modified">279                                                      uint worker_id) {</span>
<span class="line-modified">280 </span>
<span class="line-modified">281   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-modified">282   {</span>
<span class="line-modified">283     bool is_par = n_workers() &gt; 1;</span>
<span class="line-modified">284     ResourceMark rm;</span>
<span class="line-modified">285     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);</span>
<span class="line-modified">286 </span>
<span class="line-modified">287     Threads::possibly_parallel_oops_do(is_par, oops, NULL);</span>
<span class="line-modified">288   }</span>
<span class="line-modified">289 </span>
<span class="line-modified">290   if (blobs != NULL) {</span>
<span class="line-modified">291     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);</span>
<span class="line-modified">292     _coderoots_cset_iterator.possibly_parallel_blobs_do(blobs);</span>
293   }
294 
<span class="line-modified">295   if (_evacuation_tasks-&gt;try_claim_task(SHENANDOAH_EVAC_jvmti_oops_do)) {</span>
<span class="line-modified">296     ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">297     ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JVMTIRoots, worker_id);</span>
<span class="line-modified">298     JvmtiExport::weak_oops_do(&amp;is_alive, oops);</span>

299   }
300 }
301 
<span class="line-modified">302 uint ShenandoahRootEvacuator::n_workers() const {</span>
<span class="line-modified">303   return _srs.n_threads();</span>

304 }
305 
<span class="line-modified">306 // Implemenation of ParallelCLDRootIterator</span>
<span class="line-modified">307 ParallelCLDRootIterator::ParallelCLDRootIterator() {</span>
<span class="line-modified">308   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must at safepoint&quot;);</span>
<span class="line-modified">309   ClassLoaderDataGraph::clear_claimed_marks();</span>
310 }
311 
<span class="line-modified">312 void ParallelCLDRootIterator::root_cld_do(CLDClosure* strong, CLDClosure* weak) {</span>
<span class="line-modified">313     ClassLoaderDataGraph::roots_cld_do(strong, weak);</span>

















314 }







































</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
 34 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;

 38 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
<span class="line-modified"> 39 #include &quot;jfr/jfr.hpp&quot;</span>

 40 #include &quot;memory/iterator.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 42 #include &quot;memory/universe.hpp&quot;</span>
 43 #include &quot;runtime/thread.hpp&quot;
 44 #include &quot;services/management.hpp&quot;
<span class="line-added"> 45 #include &quot;tsan/tsanOopMap.hpp&quot;</span>
 46 
<span class="line-modified"> 47 ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases phase) :</span>
<span class="line-modified"> 48   _oops_do(oops_do), _phase(phase) {</span>
<span class="line-modified"> 49 }</span>






























 50 
<span class="line-modified"> 51 void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {</span>
<span class="line-modified"> 52   if (_claimed.try_set()) {</span>
<span class="line-added"> 53     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-added"> 54     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);</span>
<span class="line-added"> 55     _oops_do(cl);</span>
 56   }
 57 }
 58 
<span class="line-modified"> 59 // Overwrite the second argument for SD::oops_do, don&#39;t include vm global oop storage.</span>
<span class="line-modified"> 60 static void system_dictionary_oops_do(OopClosure* cl) {</span>
<span class="line-modified"> 61   SystemDictionary::oops_do(cl, false);</span>
<span class="line-modified"> 62 }</span>

 63 
<span class="line-modified"> 64 ShenandoahSerialRoots::ShenandoahSerialRoots() :</span>
<span class="line-added"> 65   _universe_root(&amp;Universe::oops_do, ShenandoahPhaseTimings::UniverseRoots),</span>
<span class="line-added"> 66   _object_synchronizer_root(&amp;ObjectSynchronizer::oops_do, ShenandoahPhaseTimings::ObjectSynchronizerRoots),</span>
<span class="line-added"> 67   _management_root(&amp;Management::oops_do, ShenandoahPhaseTimings::ManagementRoots),</span>
<span class="line-added"> 68   _system_dictionary_root(&amp;system_dictionary_oops_do, ShenandoahPhaseTimings::SystemDictionaryRoots),</span>
<span class="line-added"> 69   _jvmti_root(&amp;JvmtiExport::oops_do, ShenandoahPhaseTimings::JVMTIRoots) {</span>
<span class="line-added"> 70 }</span>
 71 
<span class="line-modified"> 72 void ShenandoahSerialRoots::oops_do(OopClosure* cl, uint worker_id) {</span>
<span class="line-modified"> 73   _universe_root.oops_do(cl, worker_id);</span>
<span class="line-modified"> 74   _object_synchronizer_root.oops_do(cl, worker_id);</span>
<span class="line-modified"> 75   _management_root.oops_do(cl, worker_id);</span>
<span class="line-modified"> 76   _system_dictionary_root.oops_do(cl, worker_id);</span>
<span class="line-modified"> 77   _jvmti_root.oops_do(cl, worker_id);</span>
<span class="line-modified"> 78 }</span>

 79 
<span class="line-modified"> 80 ShenandoahWeakSerialRoot::ShenandoahWeakSerialRoot(ShenandoahWeakSerialRoot::WeakOopsDo weak_oops_do, ShenandoahPhaseTimings::GCParPhases phase) :</span>
<span class="line-added"> 81   _weak_oops_do(weak_oops_do), _phase(phase) {</span>
 82 }
 83 
<span class="line-modified"> 84 void ShenandoahWeakSerialRoot::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {</span>
<span class="line-modified"> 85   if (_claimed.try_set()) {</span>
<span class="line-modified"> 86     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-modified"> 87     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);</span>
<span class="line-modified"> 88     _weak_oops_do(is_alive, keep_alive);</span>




 89   }
 90 }
 91 
<span class="line-modified"> 92 #if INCLUDE_JVMTI</span>
<span class="line-modified"> 93 ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot() :</span>
<span class="line-modified"> 94   ShenandoahWeakSerialRoot(&amp;JvmtiExport::weak_oops_do, ShenandoahPhaseTimings::JVMTIWeakRoots) {</span>
<span class="line-modified"> 95 }</span>
<span class="line-modified"> 96 #endif // INCLUDE_JVMTI</span>












 97 
<span class="line-modified"> 98 #if INCLUDE_JFR</span>
<span class="line-modified"> 99 ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot() :</span>
<span class="line-modified">100   ShenandoahWeakSerialRoot(&amp;Jfr::weak_oops_do, ShenandoahPhaseTimings::JFRWeakRoots) {</span>

101 }
<span class="line-added">102 #endif // INCLUDE_JFR</span>
103 
<span class="line-modified">104 #if INCLUDE_TSAN</span>
<span class="line-modified">105 ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot() :</span>
<span class="line-modified">106   ShenandoahWeakSerialRoot(&amp;TsanOopMap::weak_oops_do, ShenandoahPhaseTimings::TSANWeakRoots) {</span>
<span class="line-modified">107 }</span>
<span class="line-modified">108 #endif // INCLUDE_TSAN</span>


109 
<span class="line-modified">110 void ShenandoahSerialWeakRoots::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {</span>
<span class="line-modified">111   JVMTI_ONLY(_jvmti_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)</span>
<span class="line-added">112   JFR_ONLY(_jfr_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)</span>
<span class="line-added">113   TSAN_ONLY(_tsan_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)</span>
<span class="line-added">114 }</span>
115 
<span class="line-modified">116 void ShenandoahSerialWeakRoots::weak_oops_do(OopClosure* cl, uint worker_id) {</span>
<span class="line-added">117   AlwaysTrueClosure always_true;</span>
<span class="line-added">118   weak_oops_do(&amp;always_true, cl, worker_id);</span>
119 }
120 
<span class="line-modified">121 ShenandoahThreadRoots::ShenandoahThreadRoots(bool is_par) : _is_par(is_par) {</span>
<span class="line-modified">122   Threads::change_thread_claim_token();</span>
<span class="line-modified">123 }</span>



124 
<span class="line-added">125 void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {</span>
126   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
<span class="line-modified">127   ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);</span>
<span class="line-modified">128   ResourceMark rm;</span>
<span class="line-added">129   Threads::possibly_parallel_oops_do(_is_par, oops_cl, code_cl);</span>
<span class="line-added">130 }</span>
131 
<span class="line-modified">132 void ShenandoahThreadRoots::threads_do(ThreadClosure* tc, uint worker_id) {</span>
<span class="line-modified">133   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-modified">134   ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);</span>
<span class="line-modified">135   ResourceMark rm;</span>
<span class="line-added">136   Threads::possibly_parallel_threads_do(_is_par, tc);</span>
<span class="line-added">137 }</span>
138 
<span class="line-modified">139 ShenandoahThreadRoots::~ShenandoahThreadRoots() {</span>
<span class="line-added">140   Threads::assert_all_threads_claimed();</span>
141 }
142 
<span class="line-modified">143 ShenandoahStringDedupRoots::ShenandoahStringDedupRoots() {</span>
<span class="line-modified">144   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified">145     StringDedup::gc_prologue(false);</span>




























146   }
<span class="line-added">147 }</span>
148 
<span class="line-modified">149 ShenandoahStringDedupRoots::~ShenandoahStringDedupRoots() {</span>
<span class="line-modified">150   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified">151     StringDedup::gc_epilogue();</span>



152   }
153 }
154 
<span class="line-modified">155 void ShenandoahStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {</span>
<span class="line-modified">156   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified">157     ShenandoahStringDedup::parallel_oops_do(is_alive, keep_alive, worker_id);</span>






158   }
<span class="line-added">159 }</span>
160 
<span class="line-modified">161 ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots() {</span>
<span class="line-modified">162   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified">163     StringDedupTable_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">164     StringDedupQueue_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-modified">165     StringDedup::gc_prologue(true);</span>















166   }
<span class="line-added">167 }</span>
168 
<span class="line-modified">169 ShenandoahConcurrentStringDedupRoots::~ShenandoahConcurrentStringDedupRoots() {</span>
<span class="line-modified">170   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-added">171     StringDedup::gc_epilogue();</span>
<span class="line-added">172     StringDedupQueue_lock-&gt;unlock();</span>
<span class="line-added">173     StringDedupTable_lock-&gt;unlock();</span>
174   }
<span class="line-added">175 }</span>
<span class="line-added">176 </span>
<span class="line-added">177 void ShenandoahConcurrentStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {</span>
<span class="line-added">178   if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-added">179     assert_locked_or_safepoint_weak(StringDedupQueue_lock);</span>
<span class="line-added">180     assert_locked_or_safepoint_weak(StringDedupTable_lock);</span>
181 
<span class="line-modified">182     StringDedupUnlinkOrOopsDoClosure sd_cl(is_alive, keep_alive);</span>
<span class="line-modified">183     StringDedupQueue::unlink_or_oops_do(&amp;sd_cl);</span>
<span class="line-modified">184     StringDedupTable::unlink_or_oops_do(&amp;sd_cl, worker_id);</span>


185   }
186 }
187 
<span class="line-modified">188 ShenandoahRootProcessor::ShenandoahRootProcessor(ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-modified">189   _heap(ShenandoahHeap::heap()),</span>
<span class="line-added">190   _phase(phase) {</span>
<span class="line-added">191   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must at safepoint&quot;);</span>
<span class="line-added">192   _heap-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
193 }
194 
<span class="line-modified">195 ShenandoahRootProcessor::~ShenandoahRootProcessor() {</span>
<span class="line-modified">196   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must at safepoint&quot;);</span>
<span class="line-modified">197   _heap-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>




198 }
199 
<span class="line-modified">200 ShenandoahRootEvacuator::ShenandoahRootEvacuator(uint n_workers,</span>
<span class="line-modified">201                                                  ShenandoahPhaseTimings::Phase phase,</span>
<span class="line-modified">202                                                  bool include_concurrent_roots,</span>
<span class="line-added">203                                                  bool include_concurrent_code_roots) :</span>
<span class="line-added">204   ShenandoahRootProcessor(phase),</span>
<span class="line-added">205   _thread_roots(n_workers &gt; 1),</span>
<span class="line-added">206   _include_concurrent_roots(include_concurrent_roots),</span>
<span class="line-added">207   _include_concurrent_code_roots(include_concurrent_code_roots) {</span>
208 }
209 
<span class="line-modified">210 void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {</span>
<span class="line-modified">211   MarkingCodeBlobClosure blobsCl(oops, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">212   ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);</span>
<span class="line-modified">213   CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?</span>
<span class="line-modified">214                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :</span>
<span class="line-modified">215                                    static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobsCl);</span>
<span class="line-modified">216   AlwaysTrueClosure always_true;</span>
<span class="line-modified">217 </span>
<span class="line-modified">218   _serial_roots.oops_do(oops, worker_id);</span>
<span class="line-modified">219   _serial_weak_roots.weak_oops_do(oops, worker_id);</span>
<span class="line-modified">220   if (_include_concurrent_roots) {</span>
<span class="line-modified">221     CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);</span>
<span class="line-modified">222     _vm_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);</span>
<span class="line-modified">223     _cld_roots.cld_do(&amp;clds, worker_id);</span>
<span class="line-modified">224     _weak_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);</span>
<span class="line-modified">225     _dedup_roots.oops_do(&amp;always_true, oops, worker_id);</span>
226   }
227 
<span class="line-modified">228   if (_include_concurrent_code_roots) {</span>
<span class="line-modified">229     _code_roots.code_blobs_do(codes_cl, worker_id);</span>
<span class="line-modified">230     _thread_roots.oops_do(oops, NULL, worker_id);</span>
<span class="line-modified">231   } else {</span>
<span class="line-added">232     _thread_roots.oops_do(oops, codes_cl, worker_id);</span>
233   }
234 }
235 
<span class="line-modified">236 ShenandoahRootUpdater::ShenandoahRootUpdater(uint n_workers, ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-modified">237   ShenandoahRootProcessor(phase),</span>
<span class="line-added">238   _thread_roots(n_workers &gt; 1) {</span>
239 }
240 
<span class="line-modified">241 ShenandoahRootAdjuster::ShenandoahRootAdjuster(uint n_workers, ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-modified">242   ShenandoahRootProcessor(phase),</span>
<span class="line-modified">243   _thread_roots(n_workers &gt; 1) {</span>
<span class="line-modified">244   assert(ShenandoahHeap::heap()-&gt;is_full_gc_in_progress(), &quot;Full GC only&quot;);</span>
245 }
246 
<span class="line-modified">247 void ShenandoahRootAdjuster::roots_do(uint worker_id, OopClosure* oops) {</span>
<span class="line-modified">248   CodeBlobToOopClosure code_blob_cl(oops, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">249   ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);</span>
<span class="line-added">250   CodeBlobToOopClosure* adjust_code_closure = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?</span>
<span class="line-added">251                                               static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;blobs_and_disarm_Cl) :</span>
<span class="line-added">252                                               static_cast&lt;CodeBlobToOopClosure*&gt;(&amp;code_blob_cl);</span>
<span class="line-added">253   CLDToOopClosure adjust_cld_closure(oops, ClassLoaderData::_claim_strong);</span>
<span class="line-added">254   AlwaysTrueClosure always_true;</span>
<span class="line-added">255 </span>
<span class="line-added">256   _serial_roots.oops_do(oops, worker_id);</span>
<span class="line-added">257   _vm_roots.oops_do(oops, worker_id);</span>
<span class="line-added">258 </span>
<span class="line-added">259   _thread_roots.oops_do(oops, NULL, worker_id);</span>
<span class="line-added">260   _cld_roots.cld_do(&amp;adjust_cld_closure, worker_id);</span>
<span class="line-added">261   _code_roots.code_blobs_do(adjust_code_closure, worker_id);</span>
<span class="line-added">262 </span>
<span class="line-added">263   _serial_weak_roots.weak_oops_do(oops, worker_id);</span>
<span class="line-added">264   _weak_roots.oops_do&lt;OopClosure&gt;(oops, worker_id);</span>
<span class="line-added">265   _dedup_roots.oops_do(&amp;always_true, oops, worker_id);</span>
266 }
<span class="line-added">267 </span>
<span class="line-added">268  ShenandoahHeapIterationRootScanner::ShenandoahHeapIterationRootScanner() :</span>
<span class="line-added">269    ShenandoahRootProcessor(ShenandoahPhaseTimings::_num_phases),</span>
<span class="line-added">270    _thread_roots(false /*is par*/) {</span>
<span class="line-added">271  }</span>
<span class="line-added">272 </span>
<span class="line-added">273  void ShenandoahHeapIterationRootScanner::roots_do(OopClosure* oops) {</span>
<span class="line-added">274    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only by VM thread&quot;);</span>
<span class="line-added">275    // Must use _claim_none to avoid interfering with concurrent CLDG iteration</span>
<span class="line-added">276    CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);</span>
<span class="line-added">277    MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">278    ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &amp;code, NULL);</span>
<span class="line-added">279    AlwaysTrueClosure always_true;</span>
<span class="line-added">280    ResourceMark rm;</span>
<span class="line-added">281 </span>
<span class="line-added">282    _serial_roots.oops_do(oops, 0);</span>
<span class="line-added">283    _vm_roots.oops_do(oops, 0);</span>
<span class="line-added">284    _cld_roots.cld_do(&amp;clds, 0);</span>
<span class="line-added">285    _thread_roots.threads_do(&amp;tc_cl, 0);</span>
<span class="line-added">286    _code_roots.code_blobs_do(&amp;code, 0);</span>
<span class="line-added">287 </span>
<span class="line-added">288    _serial_weak_roots.weak_oops_do(oops, 0);</span>
<span class="line-added">289    _weak_roots.oops_do&lt;OopClosure&gt;(oops, 0);</span>
<span class="line-added">290    _dedup_roots.oops_do(&amp;always_true, oops, 0);</span>
<span class="line-added">291  }</span>
<span class="line-added">292 </span>
<span class="line-added">293  void ShenandoahHeapIterationRootScanner::strong_roots_do(OopClosure* oops) {</span>
<span class="line-added">294    assert(Thread::current()-&gt;is_VM_thread(), &quot;Only by VM thread&quot;);</span>
<span class="line-added">295    // Must use _claim_none to avoid interfering with concurrent CLDG iteration</span>
<span class="line-added">296    CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);</span>
<span class="line-added">297    MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">298    ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &amp;code, NULL);</span>
<span class="line-added">299    ResourceMark rm;</span>
<span class="line-added">300 </span>
<span class="line-added">301    _serial_roots.oops_do(oops, 0);</span>
<span class="line-added">302    _vm_roots.oops_do(oops, 0);</span>
<span class="line-added">303    _cld_roots.always_strong_cld_do(&amp;clds, 0);</span>
<span class="line-added">304    _thread_roots.threads_do(&amp;tc_cl, 0);</span>
<span class="line-added">305  }</span>
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
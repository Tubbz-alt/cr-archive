<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahWorkerPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_shenandoah.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.</span>


  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
 26 
 27 #define GC_SHENANDOAH_FLAGS(develop,                                        \
 28                             develop_pd,                                     \
 29                             product,                                        \
 30                             product_pd,                                     \
 31                             diagnostic,                                     \
 32                             diagnostic_pd,                                  \
 33                             experimental,                                   \
 34                             notproduct,                                     \
 35                             manageable,                                     \
 36                             product_rw,                                     \
 37                             lp64_product,                                   \
 38                             range,                                          \
<span class="line-modified"> 39                             constraint,                                     \</span>
<span class="line-removed"> 40                             writeable)                                      \</span>
 41                                                                             \
 42   experimental(size_t, ShenandoahHeapRegionSize, 0,                         \
 43           &quot;Size of the Shenandoah regions. Set to zero to detect &quot;          \
 44           &quot;automatically.&quot;)                                                 \
 45                                                                             \
 46   experimental(size_t, ShenandoahTargetNumRegions, 2048,                    \
 47           &quot;Target number of regions. We try to get around that many &quot;       \
 48           &quot;regions, based on Shenandoah{Min,Max}RegionSize.&quot;)               \
 49                                                                             \
 50   experimental(size_t, ShenandoahMinRegionSize, 256 * K,                    \
 51           &quot;Minimum Shenandoah heap region size.&quot;)                           \
 52                                                                             \
 53   experimental(size_t, ShenandoahMaxRegionSize, 32 * M,                     \
 54           &quot;Maximum Shenandoah heap region size.&quot;)                           \
 55                                                                             \
 56   experimental(intx, ShenandoahHumongousThreshold, 100,                     \
 57           &quot;How large should the object be to get allocated in humongous &quot;   \
 58           &quot;region, in percents of heap region size. This also caps the &quot;    \
 59           &quot;maximum TLAB size.&quot;)                                             \
 60           range(1, 100)                                                     \
 61                                                                             \
 62   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \
 63           &quot;The heuristics to use in Shenandoah GC. Possible values:&quot;        \
 64           &quot; *) adaptive - adapt to maintain the given amount of free heap;&quot; \
 65           &quot; *) static  -  start concurrent GC when static free heap &quot;       \
 66           &quot;               threshold and static allocation threshold are &quot;   \
 67           &quot;               tripped;&quot;                                         \
<span class="line-removed"> 68           &quot; *) passive -  do not start concurrent GC, wait for Full GC; &quot;   \</span>
 69           &quot; *) aggressive - run concurrent GC continuously, evacuate &quot;      \
 70           &quot;               everything;&quot;                                      \
 71           &quot; *) compact - run GC with lower footprint target, may end up &quot;   \
 72           &quot;               doing continuous GC, evacuate lots of live &quot;      \
 73           &quot;               objects, uncommit heap aggressively;&quot;)            \
 74                                                                             \






 75   experimental(ccstr, ShenandoahUpdateRefsEarly, &quot;adaptive&quot;,                \
 76           &quot;Run a separate concurrent reference updating phase after&quot;        \
 77           &quot;concurrent evacuation. Possible values: &#39;on&#39;, &#39;off&#39;, &#39;adaptive&#39;&quot;)\
 78                                                                             \
 79   experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
 80           &quot;How often should (weak, soft, etc) references be processed. &quot;    \
 81           &quot;References get processed at every Nth GC cycle. Set to zero &quot;    \
 82           &quot;to disable reference processing.&quot;)                               \
 83                                                                             \
<span class="line-modified"> 84   experimental(uintx, ShenandoahUnloadClassesFrequency, 5,                  \</span>
 85           &quot;How often should classes get unloaded. &quot;                         \
 86           &quot;Class unloading is performed at every Nth GC cycle. &quot;            \
 87           &quot;Set to zero to disable class unloading during concurrent GC.&quot;)   \
 88                                                                             \
 89   experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
 90           &quot;Sets the percentage of garbage a region need to contain before &quot; \
 91           &quot;it can be marked for collection. Does not apply to all &quot;         \
 92           &quot;heuristics.&quot;)                                                    \
 93           range(0,100)                                                      \
 94                                                                             \
<span class="line-removed"> 95   experimental(uintx, ShenandoahFreeThreshold, 10,                          \</span>
<span class="line-removed"> 96           &quot;Set the percentage of free heap at which a GC cycle is started. &quot;\</span>
<span class="line-removed"> 97           &quot;Does not apply to all heuristics.&quot;)                              \</span>
<span class="line-removed"> 98           range(0,100)                                                      \</span>
<span class="line-removed"> 99                                                                             \</span>
100   experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
101           &quot;Initial remaining free heap threshold for learning steps in &quot;    \
102           &quot;heuristics. In percents of total heap size. Does not apply to &quot;  \
103           &quot;all heuristics.&quot;)                                                \
104           range(0,100)                                                      \
105                                                                             \
106   experimental(uintx, ShenandoahMinFreeThreshold, 10,                       \
107           &quot;Minimum remaining free space threshold, after which collection &quot; \
108           &quot;definitely triggers. Does not apply to all heuristics.&quot;)         \
109           range(0,100)                                                      \
110                                                                             \
111   experimental(uintx, ShenandoahAllocationThreshold, 0,                     \
112           &quot;Set percentage of memory allocated since last GC cycle before &quot;  \
113           &quot;a new GC cycle can be started. Set to zero to effectively &quot;      \
114           &quot;disable.&quot;)                                                       \
115           range(0,100)                                                      \
116                                                                             \
117   experimental(uintx, ShenandoahLearningSteps, 5,                           \
118           &quot;Number of GC cycles to run in order to learn application &quot;       \
119           &quot;and GC performance for adaptive heuristics.&quot;)                    \
</pre>
<hr />
<pre>
123           &quot;If mark identifies more than this much immediate garbage &quot;       \
124           &quot;regions, it shall recycle them, and shall not continue the &quot;     \
125           &quot;rest of the GC cycle. The value is in percents of total &quot;        \
126           &quot;number of candidate regions for collection set. Setting this &quot;   \
127           &quot;threshold to 100% effectively disables this shortcut.&quot;)          \
128           range(0,100)                                                      \
129                                                                             \
130   experimental(uintx, ShenandoahMergeUpdateRefsMinGap, 100,                 \
131           &quot;If GC is currently running in separate update-refs mode &quot;        \
132           &quot;this numbers gives the threshold when to switch to &quot;             \
133           &quot;merged update-refs mode. Number is percentage relative to&quot;       \
134           &quot;duration(marking)+duration(update-refs).&quot;)                       \
135                                                                             \
136   experimental(uintx, ShenandoahMergeUpdateRefsMaxGap, 200,                 \
137           &quot;If GC is currently running in merged update-refs mode &quot;          \
138           &quot;this numbers gives the threshold when to switch to &quot;             \
139           &quot;separate update-refs mode. Number is percentage relative &quot;       \
140           &quot;to duration(marking)+duration(update-refs).&quot;)                    \
141                                                                             \
142   experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
<span class="line-modified">143           &quot;Adaptive and dynamic heuristics would guarantee a GC cycle &quot;     \</span>
<span class="line-modified">144           &quot;at least with this interval. This is useful when large idle&quot;     \</span>
<span class="line-modified">145           &quot; intervals are present, where GC can run without stealing &quot;      \</span>
<span class="line-modified">146           &quot;time from active application. Time is in milliseconds.&quot;)         \</span>

147                                                                             \
148   experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
149           &quot;Clear soft references always, instead of using any smart &quot;       \
150           &quot;cleanup policy. This minimizes footprint at expense of more &quot;    \
151           &quot;softref churn in applications.&quot;)                                 \
152                                                                             \
153   experimental(bool, ShenandoahUncommit, true,                              \
154           &quot;Allow Shenandoah to uncommit unused memory.&quot;)                    \
155                                                                             \
156   experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \
157           &quot;Shenandoah would start to uncommit memory for regions that were&quot; \
158           &quot; not used for more than this time. First use after that would &quot;  \
159           &quot;incur allocation stalls. Actively used regions would never be &quot;  \
160           &quot;uncommitted, because they never decay. Time is in milliseconds.&quot; \
161           &quot;Setting this delay to 0 effectively makes Shenandoah to &quot;        \
162           &quot;uncommit the regions almost immediately.&quot;)                       \
163                                                                             \
164   experimental(bool, ShenandoahRegionSampling, false,                       \
165           &quot;Turns on heap region sampling via JVMStat&quot;)                      \
166                                                                             \
</pre>
<hr />
<pre>
227           &quot;on each cycle.&quot;)                                                 \
228           range(1.0,100.0)                                                  \
229                                                                             \
230   experimental(bool, ShenandoahEvacReserveOverflow, true,                   \
231           &quot;Allow evacuations to overflow the reserved space. &quot;              \
232           &quot;Enabling it will make evacuations more resilient when &quot;          \
233           &quot;evacuation reserve/waste is incorrect, at the risk that &quot;        \
234           &quot;application allocations run out of memory too early.&quot;)           \
235                                                                             \
236   diagnostic(bool, ShenandoahAllocationTrace, false,                        \
237           &quot;Trace allocation latencies and stalls. Can be expensive when &quot;   \
238           &quot;lots of allocations happen, and may introduce scalability &quot;      \
239           &quot;bottlenecks.&quot;)                                                   \
240                                                                             \
241   diagnostic(intx, ShenandoahAllocationStallThreshold, 10000,               \
242           &quot;When allocation tracing is enabled, the allocation stalls &quot;      \
243           &quot;larger than this threshold would be reported as warnings. &quot;      \
244           &quot;Time is in microseconds.&quot;)                                       \
245                                                                             \
246   experimental(uintx, ShenandoahEvacAssist, 10,                             \
<span class="line-modified">247           &quot;How many objects to evacuate on WB assist path. &quot;                \</span>
248           &quot;Use zero to disable.&quot;)                                           \
249                                                                             \
250   experimental(bool, ShenandoahPacing, true,                                \
251           &quot;Pace application allocations to give GC chance to start &quot;        \
252           &quot;and complete before allocation failure is reached.&quot;)             \
253                                                                             \
254   experimental(uintx, ShenandoahPacingMaxDelay, 10,                         \
255           &quot;Max delay for pacing application allocations. &quot;                  \
256           &quot;Time is in milliseconds.&quot;)                                       \
257                                                                             \
258   experimental(uintx, ShenandoahPacingIdleSlack, 2,                         \
259           &quot;Percent of heap counted as non-taxable allocations during idle. &quot;\
260           &quot;Larger value makes the pacing milder during idle phases, &quot;       \
261           &quot;requiring less rendezvous with control thread. Lower value &quot;     \
262           &quot;makes the pacing control less responsive to out-of-cycle allocs.&quot;)\
263           range(0, 100)                                                     \
264                                                                             \
265   experimental(uintx, ShenandoahPacingCycleSlack, 10,                       \
266           &quot;Percent of free space taken as non-taxable allocations during &quot;  \
267           &quot;the GC cycle. Larger value makes the pacing milder at the &quot;      \
</pre>
<hr />
<pre>
277           range(1.0, 100.0)                                                 \
278                                                                             \
279   experimental(uintx, ShenandoahCriticalFreeThreshold, 1,                   \
280           &quot;Percent of heap that needs to be free after recovery cycles, &quot;   \
281           &quot;either Degenerated or Full GC. If this much space is not &quot;       \
282           &quot;available, next recovery step would triggered.&quot;)                 \
283           range(0, 100)                                                     \
284                                                                             \
285   diagnostic(bool, ShenandoahDegeneratedGC, true,                           \
286           &quot;Use Degenerated GC as the graceful degradation step. Disabling &quot; \
287           &quot;this leads to degradation to Full GC&quot;)                           \
288                                                                             \
289   experimental(uintx, ShenandoahFullGCThreshold, 3,                         \
290           &quot;How many back-to-back Degenerated GCs to do before triggering &quot;  \
291           &quot;a Full GC.&quot;)                                                     \
292                                                                             \
293   experimental(bool, ShenandoahImplicitGCInvokesConcurrent, false,          \
294           &quot;Should internally-caused GCs invoke concurrent cycles, or go to&quot; \
295           &quot;stop-the-world (degenerated/full)?&quot;)                             \
296                                                                             \
<span class="line-modified">297   experimental(bool, ShenandoahHumongousMoves, true,                        \</span>
298           &quot;Allow moving humongous regions. This makes GC more resistant &quot;   \
299           &quot;to external fragmentation that may otherwise fail other &quot;        \
300           &quot;humongous allocations, at the expense of higher GC copying &quot;     \
<span class="line-modified">301           &quot;costs.&quot;)                                                         \</span>
302                                                                             \
303   diagnostic(bool, ShenandoahOOMDuringEvacALot, false,                      \
304           &quot;Simulate OOM during evacuation frequently.&quot;)                     \
305                                                                             \
306   diagnostic(bool, ShenandoahAllocFailureALot, false,                       \
307           &quot;Make lots of artificial allocation failures.&quot;)                   \
308                                                                             \
309   diagnostic(bool, ShenandoahTerminationTrace, false,                       \
310           &quot;Tracing task termination timings&quot;)                               \
311                                                                             \
<span class="line-removed">312   develop(bool, ShenandoahVerifyObjectEquals, false,                        \</span>
<span class="line-removed">313           &quot;Verify that == and != are not used on oops. Only in fastdebug&quot;)  \</span>
<span class="line-removed">314                                                                             \</span>
315   diagnostic(bool, ShenandoahAlwaysPreTouch, false,                         \
316           &quot;Pre-touch heap memory, overrides global AlwaysPreTouch&quot;)         \
317                                                                             \
318   experimental(intx, ShenandoahMarkScanPrefetch, 32,                        \
319           &quot;How many objects to prefetch ahead when traversing mark bitmaps.&quot;\
320           &quot;Set to 0 to disable prefetching.&quot;)                               \
321           range(0, 256)                                                     \
322                                                                             \
323   experimental(uintx, ShenandoahMarkLoopStride, 1000,                       \
324           &quot;How many items are processed during one marking step&quot;)           \
325                                                                             \
326   experimental(uintx, ShenandoahParallelRegionStride, 1024,                 \
327           &quot;How many regions are processed in one stride during parallel &quot;   \
328           &quot;iteration.&quot;)                                                     \
329                                                                             \
330   experimental(size_t, ShenandoahSATBBufferSize, 1 * K,                     \
331           &quot;Number of entries in an SATB log buffer.&quot;)                       \
332           range(1, max_uintx)                                               \
333                                                                             \
334   experimental(uintx, ShenandoahSATBBufferFlushInterval, 100,               \
335           &quot;Forcefully flush non-empty SATB buffers at this interval. &quot;      \
336           &quot;Time is in milliseconds.&quot;)                                       \
337                                                                             \
338   experimental(uint, ShenandoahParallelSafepointThreads, 4,                 \
339           &quot;Number of parallel threads used for safepoint prolog/epilog&quot;)    \
340                                                                             \
341   experimental(bool, ShenandoahPreclean, true,                              \
342           &quot;Do concurrent preclean phase before final mark: process &quot;        \
343           &quot;definitely alive references to avoid dealing with them during &quot;  \
344           &quot;pause.&quot;)                                                         \
345                                                                             \
346   experimental(bool, ShenandoahSuspendibleWorkers, false,                   \
347           &quot;Suspend concurrent GC worker threads at safepoints&quot;)             \
348                                                                             \
349   diagnostic(bool, ShenandoahSATBBarrier, true,                             \
350           &quot;Turn on/off SATB barriers in Shenandoah&quot;)                        \
351                                                                             \
352   diagnostic(bool, ShenandoahKeepAliveBarrier, true,                        \
353           &quot;Turn on/off keep alive barriers in Shenandoah&quot;)                  \
354                                                                             \
<span class="line-removed">355   diagnostic(bool, ShenandoahWriteBarrier, true,                            \</span>
<span class="line-removed">356           &quot;Turn on/off write barriers in Shenandoah&quot;)                       \</span>
<span class="line-removed">357                                                                             \</span>
<span class="line-removed">358   diagnostic(bool, ShenandoahReadBarrier, true,                             \</span>
<span class="line-removed">359           &quot;Turn on/off read barriers in Shenandoah&quot;)                        \</span>
<span class="line-removed">360                                                                             \</span>
361   diagnostic(bool, ShenandoahStoreValEnqueueBarrier, false,                 \
362           &quot;Turn on/off enqueuing of oops for storeval barriers&quot;)            \
363                                                                             \
<span class="line-removed">364   diagnostic(bool, ShenandoahStoreValReadBarrier, true,                     \</span>
<span class="line-removed">365           &quot;Turn on/off store val read barriers in Shenandoah&quot;)              \</span>
<span class="line-removed">366                                                                             \</span>
367   diagnostic(bool, ShenandoahCASBarrier, true,                              \
368           &quot;Turn on/off CAS barriers in Shenandoah&quot;)                         \
369                                                                             \
<span class="line-removed">370   diagnostic(bool, ShenandoahAcmpBarrier, true,                             \</span>
<span class="line-removed">371           &quot;Turn on/off acmp barriers in Shenandoah&quot;)                        \</span>
<span class="line-removed">372                                                                             \</span>
373   diagnostic(bool, ShenandoahCloneBarrier, true,                            \
374           &quot;Turn on/off clone barriers in Shenandoah&quot;)                       \
375                                                                             \
<span class="line-modified">376   diagnostic(bool, ShenandoahStoreCheck, false,                             \</span>
<span class="line-modified">377           &quot;Emit additional code that checks objects are written to only&quot;    \</span>
<span class="line-removed">378           &quot; in to-space&quot;)                                                   \</span>
379                                                                             \
380   experimental(bool, ShenandoahConcurrentScanCodeRoots, true,               \
381           &quot;Scan code roots concurrently, instead of during a pause&quot;)        \
382                                                                             \
383   experimental(uintx, ShenandoahCodeRootsStyle, 2,                          \
384           &quot;Use this style to scan code cache:&quot;                              \
385           &quot; 0 - sequential iterator;&quot;                                       \
386           &quot; 1 - parallel iterator;&quot;                                         \
387           &quot; 2 - parallel iterator with cset filters;&quot;)                      \
388                                                                             \
<span class="line-modified">389   experimental(bool, ShenandoahOptimizeStaticFinals, true,                  \</span>
390           &quot;Optimize barriers on static final fields. &quot;                      \
391           &quot;Turn it off for maximum compatibility with reflection or JNI &quot;   \
392           &quot;code that manipulates final fields.&quot;)                            \
393                                                                             \
<span class="line-removed">394   experimental(bool, ShenandoahOptimizeInstanceFinals, false,               \</span>
<span class="line-removed">395           &quot;Optimize barriers on final instance fields.&quot;                     \</span>
<span class="line-removed">396           &quot;Turn it off for maximum compatibility with reflection or JNI &quot;   \</span>
<span class="line-removed">397           &quot;code that manipulates final fields.&quot;)                            \</span>
<span class="line-removed">398                                                                             \</span>
<span class="line-removed">399   experimental(bool, ShenandoahOptimizeStableFinals, false,                 \</span>
<span class="line-removed">400           &quot;Optimize barriers on stable fields.&quot;                             \</span>
<span class="line-removed">401           &quot;Turn it off for maximum compatibility with reflection or JNI &quot;   \</span>
<span class="line-removed">402           &quot;code that manipulates final fields.&quot;)                            \</span>
<span class="line-removed">403                                                                             \</span>
<span class="line-removed">404   diagnostic(bool, ShenandoahDecreaseRegisterPressure, false,               \</span>
<span class="line-removed">405           &quot;Try to reuse after-barrier values to reduce register pressure&quot;)  \</span>
<span class="line-removed">406                                                                             \</span>
407   experimental(bool, ShenandoahCommonGCStateLoads, false,                   \
408          &quot;Enable commonming for GC state loads in generated code.&quot;)         \
409                                                                             \
410   develop(bool, ShenandoahVerifyOptoBarriers, false,                        \
411           &quot;Verify no missing barriers in C2&quot;)                               \
412                                                                             \
<span class="line-removed">413   experimental(bool, ShenandoahDontIncreaseWBFreq, true,                    \</span>
<span class="line-removed">414           &quot;Common 2 WriteBarriers or WriteBarrier and a ReadBarrier only &quot;  \</span>
<span class="line-removed">415           &quot;if the resulting WriteBarrier isn&#39;t executed more frequently&quot;)   \</span>
<span class="line-removed">416                                                                             \</span>
417   experimental(bool, ShenandoahLoopOptsAfterExpansion, true,                \
<span class="line-modified">418           &quot;Attempt more loop opts after write barrier expansion&quot;)           \</span>





419 
420 #endif // SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-added">  3  * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
 27 #define SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
 28 
 29 #define GC_SHENANDOAH_FLAGS(develop,                                        \
 30                             develop_pd,                                     \
 31                             product,                                        \
 32                             product_pd,                                     \
 33                             diagnostic,                                     \
 34                             diagnostic_pd,                                  \
 35                             experimental,                                   \
 36                             notproduct,                                     \
 37                             manageable,                                     \
 38                             product_rw,                                     \
 39                             lp64_product,                                   \
 40                             range,                                          \
<span class="line-modified"> 41                             constraint)                                     \</span>

 42                                                                             \
 43   experimental(size_t, ShenandoahHeapRegionSize, 0,                         \
 44           &quot;Size of the Shenandoah regions. Set to zero to detect &quot;          \
 45           &quot;automatically.&quot;)                                                 \
 46                                                                             \
 47   experimental(size_t, ShenandoahTargetNumRegions, 2048,                    \
 48           &quot;Target number of regions. We try to get around that many &quot;       \
 49           &quot;regions, based on Shenandoah{Min,Max}RegionSize.&quot;)               \
 50                                                                             \
 51   experimental(size_t, ShenandoahMinRegionSize, 256 * K,                    \
 52           &quot;Minimum Shenandoah heap region size.&quot;)                           \
 53                                                                             \
 54   experimental(size_t, ShenandoahMaxRegionSize, 32 * M,                     \
 55           &quot;Maximum Shenandoah heap region size.&quot;)                           \
 56                                                                             \
 57   experimental(intx, ShenandoahHumongousThreshold, 100,                     \
 58           &quot;How large should the object be to get allocated in humongous &quot;   \
 59           &quot;region, in percents of heap region size. This also caps the &quot;    \
 60           &quot;maximum TLAB size.&quot;)                                             \
 61           range(1, 100)                                                     \
 62                                                                             \
 63   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \
 64           &quot;The heuristics to use in Shenandoah GC. Possible values:&quot;        \
 65           &quot; *) adaptive - adapt to maintain the given amount of free heap;&quot; \
 66           &quot; *) static  -  start concurrent GC when static free heap &quot;       \
 67           &quot;               threshold and static allocation threshold are &quot;   \
 68           &quot;               tripped;&quot;                                         \

 69           &quot; *) aggressive - run concurrent GC continuously, evacuate &quot;      \
 70           &quot;               everything;&quot;                                      \
 71           &quot; *) compact - run GC with lower footprint target, may end up &quot;   \
 72           &quot;               doing continuous GC, evacuate lots of live &quot;      \
 73           &quot;               objects, uncommit heap aggressively;&quot;)            \
 74                                                                             \
<span class="line-added"> 75   experimental(ccstr, ShenandoahGCMode, &quot;normal&quot;,                           \</span>
<span class="line-added"> 76           &quot;The GC mode to use in Shenandoah GC. Possible values&quot;            \</span>
<span class="line-added"> 77           &quot; *) normal    - normal GC (mark-evac-update)&quot;                    \</span>
<span class="line-added"> 78           &quot; *) traversal - traversal GC (single-pass)&quot;                      \</span>
<span class="line-added"> 79           &quot; *) passive   - disable concurrent GC, do stop-the-world GC&quot;)    \</span>
<span class="line-added"> 80                                                                             \</span>
 81   experimental(ccstr, ShenandoahUpdateRefsEarly, &quot;adaptive&quot;,                \
 82           &quot;Run a separate concurrent reference updating phase after&quot;        \
 83           &quot;concurrent evacuation. Possible values: &#39;on&#39;, &#39;off&#39;, &#39;adaptive&#39;&quot;)\
 84                                                                             \
 85   experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
 86           &quot;How often should (weak, soft, etc) references be processed. &quot;    \
 87           &quot;References get processed at every Nth GC cycle. Set to zero &quot;    \
 88           &quot;to disable reference processing.&quot;)                               \
 89                                                                             \
<span class="line-modified"> 90   experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \</span>
 91           &quot;How often should classes get unloaded. &quot;                         \
 92           &quot;Class unloading is performed at every Nth GC cycle. &quot;            \
 93           &quot;Set to zero to disable class unloading during concurrent GC.&quot;)   \
 94                                                                             \
 95   experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
 96           &quot;Sets the percentage of garbage a region need to contain before &quot; \
 97           &quot;it can be marked for collection. Does not apply to all &quot;         \
 98           &quot;heuristics.&quot;)                                                    \
 99           range(0,100)                                                      \
100                                                                             \





101   experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
102           &quot;Initial remaining free heap threshold for learning steps in &quot;    \
103           &quot;heuristics. In percents of total heap size. Does not apply to &quot;  \
104           &quot;all heuristics.&quot;)                                                \
105           range(0,100)                                                      \
106                                                                             \
107   experimental(uintx, ShenandoahMinFreeThreshold, 10,                       \
108           &quot;Minimum remaining free space threshold, after which collection &quot; \
109           &quot;definitely triggers. Does not apply to all heuristics.&quot;)         \
110           range(0,100)                                                      \
111                                                                             \
112   experimental(uintx, ShenandoahAllocationThreshold, 0,                     \
113           &quot;Set percentage of memory allocated since last GC cycle before &quot;  \
114           &quot;a new GC cycle can be started. Set to zero to effectively &quot;      \
115           &quot;disable.&quot;)                                                       \
116           range(0,100)                                                      \
117                                                                             \
118   experimental(uintx, ShenandoahLearningSteps, 5,                           \
119           &quot;Number of GC cycles to run in order to learn application &quot;       \
120           &quot;and GC performance for adaptive heuristics.&quot;)                    \
</pre>
<hr />
<pre>
124           &quot;If mark identifies more than this much immediate garbage &quot;       \
125           &quot;regions, it shall recycle them, and shall not continue the &quot;     \
126           &quot;rest of the GC cycle. The value is in percents of total &quot;        \
127           &quot;number of candidate regions for collection set. Setting this &quot;   \
128           &quot;threshold to 100% effectively disables this shortcut.&quot;)          \
129           range(0,100)                                                      \
130                                                                             \
131   experimental(uintx, ShenandoahMergeUpdateRefsMinGap, 100,                 \
132           &quot;If GC is currently running in separate update-refs mode &quot;        \
133           &quot;this numbers gives the threshold when to switch to &quot;             \
134           &quot;merged update-refs mode. Number is percentage relative to&quot;       \
135           &quot;duration(marking)+duration(update-refs).&quot;)                       \
136                                                                             \
137   experimental(uintx, ShenandoahMergeUpdateRefsMaxGap, 200,                 \
138           &quot;If GC is currently running in merged update-refs mode &quot;          \
139           &quot;this numbers gives the threshold when to switch to &quot;             \
140           &quot;separate update-refs mode. Number is percentage relative &quot;       \
141           &quot;to duration(marking)+duration(update-refs).&quot;)                    \
142                                                                             \
143   experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
<span class="line-modified">144           &quot;Most heuristics would guarantee a concurrent GC cycle at &quot;       \</span>
<span class="line-modified">145           &quot;least with this interval. This is useful when large idle &quot;       \</span>
<span class="line-modified">146           &quot;intervals are present, where GC can run without stealing &quot;       \</span>
<span class="line-modified">147           &quot;time from active application. Time is in milliseconds. &quot;         \</span>
<span class="line-added">148           &quot;(Setting this interval to 0 disables this feature).&quot;)            \</span>
149                                                                             \
150   experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
151           &quot;Clear soft references always, instead of using any smart &quot;       \
152           &quot;cleanup policy. This minimizes footprint at expense of more &quot;    \
153           &quot;softref churn in applications.&quot;)                                 \
154                                                                             \
155   experimental(bool, ShenandoahUncommit, true,                              \
156           &quot;Allow Shenandoah to uncommit unused memory.&quot;)                    \
157                                                                             \
158   experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \
159           &quot;Shenandoah would start to uncommit memory for regions that were&quot; \
160           &quot; not used for more than this time. First use after that would &quot;  \
161           &quot;incur allocation stalls. Actively used regions would never be &quot;  \
162           &quot;uncommitted, because they never decay. Time is in milliseconds.&quot; \
163           &quot;Setting this delay to 0 effectively makes Shenandoah to &quot;        \
164           &quot;uncommit the regions almost immediately.&quot;)                       \
165                                                                             \
166   experimental(bool, ShenandoahRegionSampling, false,                       \
167           &quot;Turns on heap region sampling via JVMStat&quot;)                      \
168                                                                             \
</pre>
<hr />
<pre>
229           &quot;on each cycle.&quot;)                                                 \
230           range(1.0,100.0)                                                  \
231                                                                             \
232   experimental(bool, ShenandoahEvacReserveOverflow, true,                   \
233           &quot;Allow evacuations to overflow the reserved space. &quot;              \
234           &quot;Enabling it will make evacuations more resilient when &quot;          \
235           &quot;evacuation reserve/waste is incorrect, at the risk that &quot;        \
236           &quot;application allocations run out of memory too early.&quot;)           \
237                                                                             \
238   diagnostic(bool, ShenandoahAllocationTrace, false,                        \
239           &quot;Trace allocation latencies and stalls. Can be expensive when &quot;   \
240           &quot;lots of allocations happen, and may introduce scalability &quot;      \
241           &quot;bottlenecks.&quot;)                                                   \
242                                                                             \
243   diagnostic(intx, ShenandoahAllocationStallThreshold, 10000,               \
244           &quot;When allocation tracing is enabled, the allocation stalls &quot;      \
245           &quot;larger than this threshold would be reported as warnings. &quot;      \
246           &quot;Time is in microseconds.&quot;)                                       \
247                                                                             \
248   experimental(uintx, ShenandoahEvacAssist, 10,                             \
<span class="line-modified">249           &quot;How many objects to evacuate on LRB assist path. &quot;               \</span>
250           &quot;Use zero to disable.&quot;)                                           \
251                                                                             \
252   experimental(bool, ShenandoahPacing, true,                                \
253           &quot;Pace application allocations to give GC chance to start &quot;        \
254           &quot;and complete before allocation failure is reached.&quot;)             \
255                                                                             \
256   experimental(uintx, ShenandoahPacingMaxDelay, 10,                         \
257           &quot;Max delay for pacing application allocations. &quot;                  \
258           &quot;Time is in milliseconds.&quot;)                                       \
259                                                                             \
260   experimental(uintx, ShenandoahPacingIdleSlack, 2,                         \
261           &quot;Percent of heap counted as non-taxable allocations during idle. &quot;\
262           &quot;Larger value makes the pacing milder during idle phases, &quot;       \
263           &quot;requiring less rendezvous with control thread. Lower value &quot;     \
264           &quot;makes the pacing control less responsive to out-of-cycle allocs.&quot;)\
265           range(0, 100)                                                     \
266                                                                             \
267   experimental(uintx, ShenandoahPacingCycleSlack, 10,                       \
268           &quot;Percent of free space taken as non-taxable allocations during &quot;  \
269           &quot;the GC cycle. Larger value makes the pacing milder at the &quot;      \
</pre>
<hr />
<pre>
279           range(1.0, 100.0)                                                 \
280                                                                             \
281   experimental(uintx, ShenandoahCriticalFreeThreshold, 1,                   \
282           &quot;Percent of heap that needs to be free after recovery cycles, &quot;   \
283           &quot;either Degenerated or Full GC. If this much space is not &quot;       \
284           &quot;available, next recovery step would triggered.&quot;)                 \
285           range(0, 100)                                                     \
286                                                                             \
287   diagnostic(bool, ShenandoahDegeneratedGC, true,                           \
288           &quot;Use Degenerated GC as the graceful degradation step. Disabling &quot; \
289           &quot;this leads to degradation to Full GC&quot;)                           \
290                                                                             \
291   experimental(uintx, ShenandoahFullGCThreshold, 3,                         \
292           &quot;How many back-to-back Degenerated GCs to do before triggering &quot;  \
293           &quot;a Full GC.&quot;)                                                     \
294                                                                             \
295   experimental(bool, ShenandoahImplicitGCInvokesConcurrent, false,          \
296           &quot;Should internally-caused GCs invoke concurrent cycles, or go to&quot; \
297           &quot;stop-the-world (degenerated/full)?&quot;)                             \
298                                                                             \
<span class="line-modified">299   diagnostic(bool, ShenandoahHumongousMoves, true,                          \</span>
300           &quot;Allow moving humongous regions. This makes GC more resistant &quot;   \
301           &quot;to external fragmentation that may otherwise fail other &quot;        \
302           &quot;humongous allocations, at the expense of higher GC copying &quot;     \
<span class="line-modified">303           &quot;costs. Currently affects stop-the-world (full) cycle only.&quot;)     \</span>
304                                                                             \
305   diagnostic(bool, ShenandoahOOMDuringEvacALot, false,                      \
306           &quot;Simulate OOM during evacuation frequently.&quot;)                     \
307                                                                             \
308   diagnostic(bool, ShenandoahAllocFailureALot, false,                       \
309           &quot;Make lots of artificial allocation failures.&quot;)                   \
310                                                                             \
311   diagnostic(bool, ShenandoahTerminationTrace, false,                       \
312           &quot;Tracing task termination timings&quot;)                               \
313                                                                             \



314   diagnostic(bool, ShenandoahAlwaysPreTouch, false,                         \
315           &quot;Pre-touch heap memory, overrides global AlwaysPreTouch&quot;)         \
316                                                                             \
317   experimental(intx, ShenandoahMarkScanPrefetch, 32,                        \
318           &quot;How many objects to prefetch ahead when traversing mark bitmaps.&quot;\
319           &quot;Set to 0 to disable prefetching.&quot;)                               \
320           range(0, 256)                                                     \
321                                                                             \
322   experimental(uintx, ShenandoahMarkLoopStride, 1000,                       \
323           &quot;How many items are processed during one marking step&quot;)           \
324                                                                             \
325   experimental(uintx, ShenandoahParallelRegionStride, 1024,                 \
326           &quot;How many regions are processed in one stride during parallel &quot;   \
327           &quot;iteration.&quot;)                                                     \
328                                                                             \
329   experimental(size_t, ShenandoahSATBBufferSize, 1 * K,                     \
330           &quot;Number of entries in an SATB log buffer.&quot;)                       \
331           range(1, max_uintx)                                               \
332                                                                             \
333   experimental(uintx, ShenandoahSATBBufferFlushInterval, 100,               \
334           &quot;Forcefully flush non-empty SATB buffers at this interval. &quot;      \
335           &quot;Time is in milliseconds.&quot;)                                       \
336                                                                             \
337   experimental(uint, ShenandoahParallelSafepointThreads, 4,                 \
338           &quot;Number of parallel threads used for safepoint prolog/epilog&quot;)    \
339                                                                             \
340   experimental(bool, ShenandoahPreclean, true,                              \
341           &quot;Do concurrent preclean phase before final mark: process &quot;        \
342           &quot;definitely alive references to avoid dealing with them during &quot;  \
343           &quot;pause.&quot;)                                                         \
344                                                                             \
345   experimental(bool, ShenandoahSuspendibleWorkers, false,                   \
346           &quot;Suspend concurrent GC worker threads at safepoints&quot;)             \
347                                                                             \
348   diagnostic(bool, ShenandoahSATBBarrier, true,                             \
349           &quot;Turn on/off SATB barriers in Shenandoah&quot;)                        \
350                                                                             \
351   diagnostic(bool, ShenandoahKeepAliveBarrier, true,                        \
352           &quot;Turn on/off keep alive barriers in Shenandoah&quot;)                  \
353                                                                             \






354   diagnostic(bool, ShenandoahStoreValEnqueueBarrier, false,                 \
355           &quot;Turn on/off enqueuing of oops for storeval barriers&quot;)            \
356                                                                             \



357   diagnostic(bool, ShenandoahCASBarrier, true,                              \
358           &quot;Turn on/off CAS barriers in Shenandoah&quot;)                         \
359                                                                             \



360   diagnostic(bool, ShenandoahCloneBarrier, true,                            \
361           &quot;Turn on/off clone barriers in Shenandoah&quot;)                       \
362                                                                             \
<span class="line-modified">363   diagnostic(bool, ShenandoahLoadRefBarrier, true,                          \</span>
<span class="line-modified">364           &quot;Turn on/off load-reference barriers in Shenandoah&quot;)              \</span>

365                                                                             \
366   experimental(bool, ShenandoahConcurrentScanCodeRoots, true,               \
367           &quot;Scan code roots concurrently, instead of during a pause&quot;)        \
368                                                                             \
369   experimental(uintx, ShenandoahCodeRootsStyle, 2,                          \
370           &quot;Use this style to scan code cache:&quot;                              \
371           &quot; 0 - sequential iterator;&quot;                                       \
372           &quot; 1 - parallel iterator;&quot;                                         \
373           &quot; 2 - parallel iterator with cset filters;&quot;)                      \
374                                                                             \
<span class="line-modified">375   diagnostic(bool, ShenandoahOptimizeStaticFinals, true,                    \</span>
376           &quot;Optimize barriers on static final fields. &quot;                      \
377           &quot;Turn it off for maximum compatibility with reflection or JNI &quot;   \
378           &quot;code that manipulates final fields.&quot;)                            \
379                                                                             \













380   experimental(bool, ShenandoahCommonGCStateLoads, false,                   \
381          &quot;Enable commonming for GC state loads in generated code.&quot;)         \
382                                                                             \
383   develop(bool, ShenandoahVerifyOptoBarriers, false,                        \
384           &quot;Verify no missing barriers in C2&quot;)                               \
385                                                                             \




386   experimental(bool, ShenandoahLoopOptsAfterExpansion, true,                \
<span class="line-modified">387           &quot;Attempt more loop opts after barrier expansion&quot;)                 \</span>
<span class="line-added">388                                                                             \</span>
<span class="line-added">389   diagnostic(bool, ShenandoahSelfFixing, true,                              \</span>
<span class="line-added">390           &quot;Fix references with load reference barrier. Disabling this &quot;     \</span>
<span class="line-added">391           &quot;might degrade performance.&quot;)                                     \</span>
<span class="line-added">392 </span>
393 
394 #endif // SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahWorkerPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="vmStructs_shenandoah.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahHeapRegionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 #include &quot;utilities/copy.hpp&quot;
 31 
 32 ShenandoahHeapRegionSetIterator::ShenandoahHeapRegionSetIterator(const ShenandoahHeapRegionSet* const set) :
 33         _set(set), _heap(ShenandoahHeap::heap()), _current_index(0) {}
 34 
 35 void ShenandoahHeapRegionSetIterator::reset(const ShenandoahHeapRegionSet* const set) {
 36   _set = set;
 37   _current_index = 0;
 38 }
 39 
 40 ShenandoahHeapRegionSet::ShenandoahHeapRegionSet() :
 41   _heap(ShenandoahHeap::heap()),
 42   _map_size(_heap-&gt;num_regions()),
 43   _region_size_bytes_shift(ShenandoahHeapRegion::region_size_bytes_shift()),
 44   _set_map(NEW_C_HEAP_ARRAY(jbyte, _map_size, mtGC)),
 45   _biased_set_map(_set_map - ((uintx)_heap-&gt;base() &gt;&gt; _region_size_bytes_shift)),
 46   _region_count(0)
 47 {
 48   // Use 1-byte data type
 49   STATIC_ASSERT(sizeof(jbyte) == 1);
 50 
 51   // Initialize cset map
 52   Copy::zero_to_bytes(_set_map, _map_size);
 53 }
 54 
 55 ShenandoahHeapRegionSet::~ShenandoahHeapRegionSet() {
 56   FREE_C_HEAP_ARRAY(jbyte, _set_map);
 57 }
 58 
 59 void ShenandoahHeapRegionSet::add_region(ShenandoahHeapRegion* r) {
 60   assert(!is_in(r), &quot;Already in collection set&quot;);
 61   _set_map[r-&gt;region_number()] = 1;
 62   _region_count++;
 63 }
 64 
 65 bool ShenandoahHeapRegionSet::add_region_check_for_duplicates(ShenandoahHeapRegion* r) {
 66   if (!is_in(r)) {
 67     add_region(r);
 68     return true;
 69   } else {
 70     return false;
 71   }
 72 }
 73 
 74 void ShenandoahHeapRegionSet::remove_region(ShenandoahHeapRegion* r) {
 75   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 76   assert(Thread::current()-&gt;is_VM_thread(), &quot;Must be VMThread&quot;);
 77   assert(is_in(r), &quot;Not in region set&quot;);
 78   _set_map[r-&gt;region_number()] = 0;
 79   _region_count --;
 80 }
 81 
 82 void ShenandoahHeapRegionSet::clear() {
 83   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 84   Copy::zero_to_bytes(_set_map, _map_size);
 85 
 86   _region_count = 0;
 87 }
 88 
 89 ShenandoahHeapRegion* ShenandoahHeapRegionSetIterator::claim_next() {
 90   size_t num_regions = _heap-&gt;num_regions();
 91   if (_current_index &gt;= (jint)num_regions) {
 92     return NULL;
 93   }
 94 
 95   jint saved_current = _current_index;
 96   size_t index = (size_t)saved_current;
 97 
 98   while(index &lt; num_regions) {
 99     if (_set-&gt;is_in(index)) {
<a name="2" id="anc2"></a><span class="line-modified">100       jint cur = Atomic::cmpxchg((jint)(index + 1), &amp;_current_index, saved_current);</span>
101       assert(cur &gt;= (jint)saved_current, &quot;Must move forward&quot;);
102       if (cur == saved_current) {
103         assert(_set-&gt;is_in(index), &quot;Invariant&quot;);
104         return _heap-&gt;get_region(index);
105       } else {
106         index = (size_t)cur;
107         saved_current = cur;
108       }
109     } else {
110       index ++;
111     }
112   }
113   return NULL;
114 }
115 
116 ShenandoahHeapRegion* ShenandoahHeapRegionSetIterator::next() {
117   size_t num_regions = _heap-&gt;num_regions();
118   for (size_t index = (size_t)_current_index; index &lt; num_regions; index ++) {
119     if (_set-&gt;is_in(index)) {
120       _current_index = (jint)(index + 1);
121       return _heap-&gt;get_region(index);
122     }
123   }
124 
125   return NULL;
126 }
127 
128 void ShenandoahHeapRegionSet::print_on(outputStream* out) const {
129   out-&gt;print_cr(&quot;Region Set : &quot; SIZE_FORMAT &quot;&quot;, count());
130 
131   debug_only(size_t regions = 0;)
132   for (size_t index = 0; index &lt; _heap-&gt;num_regions(); index ++) {
133     if (is_in(index)) {
134       _heap-&gt;get_region(index)-&gt;print_on(out);
135       debug_only(regions ++;)
136     }
137   }
138   assert(regions == count(), &quot;Must match&quot;);
139 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
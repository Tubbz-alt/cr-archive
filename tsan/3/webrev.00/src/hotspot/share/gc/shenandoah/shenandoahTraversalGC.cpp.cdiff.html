<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTracer.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,33 ***</span>
  #include &quot;classfile/classLoaderData.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;gc/shared/referenceProcessor.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/weakProcessor.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  
  /**
   * NOTE: We are using the SATB buffer in thread.hpp and satbMarkQueue.hpp, however, it is not an SATB algorithm.
   * We&#39;re using the buffer as generic oop buffer to enqueue new values in concurrent oop stores, IOW, the algorithm
   * is incremental-update-based.
<span class="line-new-header">--- 27,34 ---</span>
  #include &quot;classfile/classLoaderData.hpp&quot;
  #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  #include &quot;gc/shared/referenceProcessor.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  
  /**
   * NOTE: We are using the SATB buffer in thread.hpp and satbMarkQueue.hpp, however, it is not an SATB algorithm.
   * We&#39;re using the buffer as generic oop buffer to enqueue new values in concurrent oop stores, IOW, the algorithm
   * is incremental-update-based.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
  private:
    OopClosure* _cl;
  public:
    ShenandoahMarkCLDClosure(OopClosure* cl) : _cl(cl) {}
    void do_cld(ClassLoaderData* cld) {
<span class="line-modified">!     cld-&gt;oops_do(_cl, true, true);</span>
    }
  };
  
  // Like CLDToOopClosure, but only process modified CLDs
  class ShenandoahRemarkCLDClosure : public CLDClosure {
<span class="line-new-header">--- 139,11 ---</span>
  private:
    OopClosure* _cl;
  public:
    ShenandoahMarkCLDClosure(OopClosure* cl) : _cl(cl) {}
    void do_cld(ClassLoaderData* cld) {
<span class="line-modified">!     cld-&gt;oops_do(_cl, ClassLoaderData::_claim_strong, true);</span>
    }
  };
  
  // Like CLDToOopClosure, but only process modified CLDs
  class ShenandoahRemarkCLDClosure : public CLDClosure {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,31 ***</span>
    OopClosure* _cl;
  public:
    ShenandoahRemarkCLDClosure(OopClosure* cl) : _cl(cl) {}
    void do_cld(ClassLoaderData* cld) {
      if (cld-&gt;has_modified_oops()) {
<span class="line-modified">!       cld-&gt;oops_do(_cl, true, true);</span>
      }
    }
  };
  
  class ShenandoahInitTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootProcessor* _rp;</span>
    ShenandoahHeap* _heap;
    ShenandoahCsetCodeRootsIterator* _cset_coderoots;
  public:
<span class="line-modified">!   ShenandoahInitTraversalCollectionTask(ShenandoahRootProcessor* rp, ShenandoahCsetCodeRootsIterator* cset_coderoots) :</span>
      AbstractGangTask(&quot;Shenandoah Init Traversal Collection&quot;),
      _rp(rp),
<span class="line-modified">!     _heap(ShenandoahHeap::heap()),</span>
<span class="line-removed">-     _cset_coderoots(cset_coderoots) {}</span>
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
  
<span class="line-removed">-     ShenandoahEvacOOMScope oom_evac_scope;</span>
      ShenandoahObjToScanQueueSet* queues = _heap-&gt;traversal_gc()-&gt;task_queues();
      ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
  
      bool process_refs = _heap-&gt;process_references();
      bool unload_classes = _heap-&gt;unload_classes();
<span class="line-new-header">--- 151,31 ---</span>
    OopClosure* _cl;
  public:
    ShenandoahRemarkCLDClosure(OopClosure* cl) : _cl(cl) {}
    void do_cld(ClassLoaderData* cld) {
      if (cld-&gt;has_modified_oops()) {
<span class="line-modified">!       cld-&gt;oops_do(_cl, ClassLoaderData::_claim_strong, true);</span>
      }
    }
  };
  
  class ShenandoahInitTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahCSetRootScanner* _rp;</span>
    ShenandoahHeap* _heap;
    ShenandoahCsetCodeRootsIterator* _cset_coderoots;
<span class="line-added">+   ShenandoahStringDedupRoots       _dedup_roots;</span>
<span class="line-added">+ </span>
  public:
<span class="line-modified">!   ShenandoahInitTraversalCollectionTask(ShenandoahCSetRootScanner* rp) :</span>
      AbstractGangTask(&quot;Shenandoah Init Traversal Collection&quot;),
      _rp(rp),
<span class="line-modified">!     _heap(ShenandoahHeap::heap()) {}</span>
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
  
      ShenandoahObjToScanQueueSet* queues = _heap-&gt;traversal_gc()-&gt;task_queues();
      ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
  
      bool process_refs = _heap-&gt;process_references();
      bool unload_classes = _heap-&gt;unload_classes();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,63 ***</span>
        rp = _heap-&gt;ref_processor();
      }
  
      // Step 1: Process ordinary GC roots.
      {
<span class="line-modified">!       ShenandoahTraversalClosure roots_cl(q, rp);</span>
        ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
        MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
        if (unload_classes) {
<span class="line-modified">!         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, NULL, NULL, worker_id);</span>
<span class="line-removed">-         // Need to pre-evac code roots here. Otherwise we might see from-space constants.</span>
<span class="line-removed">-         ShenandoahWorkerTimings* worker_times = _heap-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-removed">-         ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);</span>
<span class="line-removed">-         _cset_coderoots-&gt;possibly_parallel_blobs_do(&amp;code_cl);</span>
        } else {
<span class="line-modified">!         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;code_cl, NULL, worker_id);</span>
        }
      }
    }
  };
  
  class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahTaskTerminator* _terminator;</span>
    ShenandoahHeap* _heap;
  public:
<span class="line-modified">!   ShenandoahConcurrentTraversalCollectionTask(ShenandoahTaskTerminator* terminator) :</span>
      AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
      _terminator(terminator),
      _heap(ShenandoahHeap::heap()) {}
  
    void work(uint worker_id) {
      ShenandoahConcurrentWorkerSession worker_session(worker_id);
      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
<span class="line-removed">-     ShenandoahEvacOOMScope oom_evac_scope;</span>
      ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
  
      // Drain all outstanding work in queues.
      traversal_gc-&gt;main_loop(worker_id, _terminator, true);
    }
  };
  
  class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootProcessor* _rp;</span>
<span class="line-modified">!   ShenandoahTaskTerminator* _terminator;</span>
    ShenandoahHeap* _heap;
  public:
<span class="line-modified">!   ShenandoahFinalTraversalCollectionTask(ShenandoahRootProcessor* rp, ShenandoahTaskTerminator* terminator) :</span>
      AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
      _rp(rp),
      _terminator(terminator),
      _heap(ShenandoahHeap::heap()) {}
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
  
<span class="line-removed">-     ShenandoahEvacOOMScope oom_evac_scope;</span>
      ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
  
      ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
      ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
  
<span class="line-new-header">--- 184,57 ---</span>
        rp = _heap-&gt;ref_processor();
      }
  
      // Step 1: Process ordinary GC roots.
      {
<span class="line-modified">!       ShenandoahTraversalRootsClosure roots_cl(q, rp);</span>
        ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
        MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
        if (unload_classes) {
<span class="line-modified">!         _rp-&gt;roots_do(worker_id, &amp;roots_cl, NULL, &amp;code_cl);</span>
        } else {
<span class="line-modified">!         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, &amp;code_cl);</span>
        }
      }
    }
  };
  
  class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   TaskTerminator* _terminator;</span>
    ShenandoahHeap* _heap;
  public:
<span class="line-modified">!   ShenandoahConcurrentTraversalCollectionTask(TaskTerminator* terminator) :</span>
      AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
      _terminator(terminator),
      _heap(ShenandoahHeap::heap()) {}
  
    void work(uint worker_id) {
      ShenandoahConcurrentWorkerSession worker_session(worker_id);
      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
      ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
  
      // Drain all outstanding work in queues.
      traversal_gc-&gt;main_loop(worker_id, _terminator, true);
    }
  };
  
  class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahAllRootScanner* _rp;</span>
<span class="line-modified">!   TaskTerminator*           _terminator;</span>
    ShenandoahHeap* _heap;
  public:
<span class="line-modified">!   ShenandoahFinalTraversalCollectionTask(ShenandoahAllRootScanner* rp, TaskTerminator* terminator) :</span>
      AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
      _rp(rp),
      _terminator(terminator),
      _heap(ShenandoahHeap::heap()) {}
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
  
      ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
  
      ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
      ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,28 ***</span>
      // For oops in code roots, they are marked, evacuated, enqueued for further traversal,
      // and the references to the oops are updated during init pause. New nmethods are handled
      // in similar way during nmethod-register process. Therefore, we don&#39;t need to rescan code
      // roots here.
      if (!_heap-&gt;is_degenerated_gc_in_progress()) {
<span class="line-modified">!       ShenandoahTraversalClosure roots_cl(q, rp);</span>
<span class="line-removed">-       CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
        ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
        if (unload_classes) {
<span class="line-modified">!         ShenandoahRemarkCLDClosure weak_cld_cl(&amp;roots_cl);</span>
<span class="line-modified">!         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;weak_cld_cl, NULL, &amp;tc, worker_id);</span>
        } else {
<span class="line-modified">!         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc, worker_id);</span>
        }
      } else {
        ShenandoahTraversalDegenClosure roots_cl(q, rp);
<span class="line-removed">-       CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
        ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
        if (unload_classes) {
<span class="line-modified">!         ShenandoahRemarkCLDClosure weak_cld_cl(&amp;roots_cl);</span>
<span class="line-modified">!         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;weak_cld_cl, NULL, &amp;tc, worker_id);</span>
        } else {
<span class="line-modified">!         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc, worker_id);</span>
        }
      }
  
      {
        ShenandoahWorkerTimings *worker_times = _heap-&gt;phase_timings()-&gt;worker_times();
<span class="line-new-header">--- 259,28 ---</span>
      // For oops in code roots, they are marked, evacuated, enqueued for further traversal,
      // and the references to the oops are updated during init pause. New nmethods are handled
      // in similar way during nmethod-register process. Therefore, we don&#39;t need to rescan code
      // roots here.
      if (!_heap-&gt;is_degenerated_gc_in_progress()) {
<span class="line-modified">!       ShenandoahTraversalRootsClosure roots_cl(q, rp);</span>
        ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
        if (unload_classes) {
<span class="line-modified">!         ShenandoahRemarkCLDClosure remark_cld_cl(&amp;roots_cl);</span>
<span class="line-modified">!         _rp-&gt;strong_roots_do(worker_id, &amp;roots_cl, &amp;remark_cld_cl, NULL, &amp;tc);</span>
        } else {
<span class="line-modified">!         CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added">+         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc);</span>
        }
      } else {
        ShenandoahTraversalDegenClosure roots_cl(q, rp);
        ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
        if (unload_classes) {
<span class="line-modified">!         ShenandoahRemarkCLDClosure remark_cld_cl(&amp;roots_cl);</span>
<span class="line-modified">!         _rp-&gt;strong_roots_do(worker_id, &amp;roots_cl, &amp;remark_cld_cl, NULL, &amp;tc);</span>
        } else {
<span class="line-modified">!         CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added">+         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc);</span>
        }
      }
  
      {
        ShenandoahWorkerTimings *worker_times = _heap-&gt;phase_timings()-&gt;worker_times();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,10 ***</span>
<span class="line-new-header">--- 296,13 ---</span>
  ShenandoahTraversalGC::ShenandoahTraversalGC(ShenandoahHeap* heap, size_t num_regions) :
    _heap(heap),
    _task_queues(new ShenandoahObjToScanQueueSet(heap-&gt;max_workers())),
    _traversal_set(ShenandoahHeapRegionSet()) {
  
<span class="line-added">+   // Traversal does not support concurrent code root scanning</span>
<span class="line-added">+   FLAG_SET_DEFAULT(ShenandoahConcurrentScanCodeRoots, false);</span>
<span class="line-added">+ </span>
    uint num_queues = heap-&gt;max_workers();
    for (uint i = 0; i &lt; num_queues; ++i) {
      ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
      task_queue-&gt;initialize();
      _task_queues-&gt;register_queue(i, task_queue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,13 ***</span>
      }
    }
  }
  
  void ShenandoahTraversalGC::prepare() {
<span class="line-removed">-   _heap-&gt;collection_set()-&gt;clear();</span>
<span class="line-removed">-   assert(_heap-&gt;collection_set()-&gt;count() == 0, &quot;collection set not clear&quot;);</span>
<span class="line-removed">- </span>
    {
      ShenandoahGCPhase phase(ShenandoahPhaseTimings::traversal_gc_make_parsable);
      _heap-&gt;make_parsable(true);
    }
  
<span class="line-new-header">--- 333,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,22 ***</span>
    }
  
    assert(_heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;need clean mark bitmap&quot;);
    assert(!_heap-&gt;marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
  
<span class="line-modified">!   ShenandoahFreeSet* free_set = _heap-&gt;free_set();</span>
    ShenandoahCollectionSet* collection_set = _heap-&gt;collection_set();
  
<span class="line-modified">!   // Find collection set</span>
<span class="line-modified">!   _heap-&gt;heuristics()-&gt;choose_collection_set(collection_set);</span>
<span class="line-removed">-   prepare_regions();</span>
  
<span class="line-modified">!   // Rebuild free set</span>
<span class="line-modified">!   free_set-&gt;rebuild();</span>
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;M, &quot; SIZE_FORMAT &quot;M CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">!                      collection_set-&gt;garbage() / M, collection_set-&gt;live_data() / M, collection_set-&gt;count());</span>
  }
  
  void ShenandoahTraversalGC::init_traversal_collection() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;STW traversal GC&quot;);
  
<span class="line-new-header">--- 346,35 ---</span>
    }
  
    assert(_heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;need clean mark bitmap&quot;);
    assert(!_heap-&gt;marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
  
<span class="line-modified">!   // About to choose the collection set, make sure we know which regions are pinned.</span>
<span class="line-added">+   {</span>
<span class="line-added">+     ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_prepare_sync_pinned);</span>
<span class="line-added">+     _heap-&gt;sync_pinned_region_status();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    ShenandoahCollectionSet* collection_set = _heap-&gt;collection_set();
<span class="line-added">+   {</span>
<span class="line-added">+     ShenandoahHeapLocker lock(_heap-&gt;lock());</span>
  
<span class="line-modified">!     collection_set-&gt;clear();</span>
<span class="line-modified">!     assert(collection_set-&gt;count() == 0, &quot;collection set not clear&quot;);</span>
  
<span class="line-modified">!     // Find collection set</span>
<span class="line-modified">!     _heap-&gt;heuristics()-&gt;choose_collection_set(collection_set);</span>
<span class="line-added">+     prepare_regions();</span>
  
<span class="line-modified">!     // Rebuild free set</span>
<span class="line-modified">!     _heap-&gt;free_set()-&gt;rebuild();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;%s, &quot; SIZE_FORMAT &quot;%s CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-added">+                      byte_size_in_proper_unit(collection_set-&gt;garbage()),   proper_unit_for_byte_size(collection_set-&gt;garbage()),</span>
<span class="line-added">+                      byte_size_in_proper_unit(collection_set-&gt;live_data()), proper_unit_for_byte_size(collection_set-&gt;live_data()),</span>
<span class="line-added">+                      collection_set-&gt;count());</span>
  }
  
  void ShenandoahTraversalGC::init_traversal_collection() {
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;STW traversal GC&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,15 ***</span>
      Universe::verify();
    }
  
    {
      ShenandoahGCPhase phase_prepare(ShenandoahPhaseTimings::traversal_gc_prepare);
<span class="line-removed">-     ShenandoahHeapLocker lock(_heap-&gt;lock());</span>
      prepare();
    }
  
    _heap-&gt;set_concurrent_traversal_in_progress(true);
  
    bool process_refs = _heap-&gt;process_references();
    if (process_refs) {
      ReferenceProcessor* rp = _heap-&gt;ref_processor();
      rp-&gt;enable_discovery(true /*verify_no_refs*/);
<span class="line-new-header">--- 386,15 ---</span>
      Universe::verify();
    }
  
    {
      ShenandoahGCPhase phase_prepare(ShenandoahPhaseTimings::traversal_gc_prepare);
      prepare();
    }
  
    _heap-&gt;set_concurrent_traversal_in_progress(true);
<span class="line-added">+   _heap-&gt;set_has_forwarded_objects(true);</span>
  
    bool process_refs = _heap-&gt;process_references();
    if (process_refs) {
      ReferenceProcessor* rp = _heap-&gt;ref_processor();
      rp-&gt;enable_discovery(true /*verify_no_refs*/);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,36 ***</span>
    {
      ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::init_traversal_gc_work);
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty before traversal GC&quot;);
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
  
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
      DerivedPointerTable::clear();
  #endif
  
      {
        uint nworkers = _heap-&gt;workers()-&gt;active_workers();
        task_queues()-&gt;reserve(nworkers);
<span class="line-modified">!       ShenandoahRootProcessor rp(_heap, nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);</span>
<span class="line-modified">! </span>
<span class="line-removed">-       ShenandoahCsetCodeRootsIterator cset_coderoots = ShenandoahCodeRoots::cset_iterator();</span>
<span class="line-removed">- </span>
<span class="line-removed">-       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp, &amp;cset_coderoots);</span>
        _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
      }
  
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
      DerivedPointerTable::update_pointers();
  #endif
    }
  
    if (ShenandoahPacing) {
      _heap-&gt;pacer()-&gt;setup_for_traversal();
    }
  }
  
<span class="line-modified">! void ShenandoahTraversalGC::main_loop(uint w, ShenandoahTaskTerminator* t, bool sts_yield) {</span>
    ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
  
    // Initialize live data.
    jushort* ld = _heap-&gt;get_liveness_cache(w);
  
<span class="line-new-header">--- 404,33 ---</span>
    {
      ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::init_traversal_gc_work);
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty before traversal GC&quot;);
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
  
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
      DerivedPointerTable::clear();
  #endif
  
      {
        uint nworkers = _heap-&gt;workers()-&gt;active_workers();
        task_queues()-&gt;reserve(nworkers);
<span class="line-modified">!       ShenandoahCSetRootScanner rp(nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);</span>
<span class="line-modified">!       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp);</span>
        _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
      }
  
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
      DerivedPointerTable::update_pointers();
  #endif
    }
  
    if (ShenandoahPacing) {
      _heap-&gt;pacer()-&gt;setup_for_traversal();
    }
  }
  
<span class="line-modified">! void ShenandoahTraversalGC::main_loop(uint w, TaskTerminator* t, bool sts_yield) {</span>
    ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
  
    // Initialize live data.
    jushort* ld = _heap-&gt;get_liveness_cache(w);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,11 ***</span>
  
    _heap-&gt;flush_liveness_cache(w);
  }
  
  template &lt;class T&gt;
<span class="line-modified">! void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
    ShenandoahObjToScanQueueSet* queues = task_queues();
    ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
    ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
  
    uintx stride = ShenandoahMarkLoopStride;
<span class="line-new-header">--- 480,11 ---</span>
  
    _heap-&gt;flush_liveness_cache(w);
  }
  
  template &lt;class T&gt;
<span class="line-modified">! void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, TaskTerminator* terminator, bool sts_yield) {</span>
    ShenandoahObjToScanQueueSet* queues = task_queues();
    ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
    ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
  
    uintx stride = ShenandoahMarkLoopStride;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,37 ***</span>
        }
      }
  
      if (work == 0) {
        // No more work, try to terminate
<span class="line-removed">-       ShenandoahEvacOOMScopeLeaver oom_scope_leaver;</span>
        ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
        ShenandoahTerminationTimingsTracker term_tracker(worker_id);
        ShenandoahTerminatorTerminator tt(_heap);
  
        if (terminator-&gt;offer_termination(&amp;tt)) return;
      }
    }
  }
  
<span class="line-modified">! bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
    if (_heap-&gt;cancelled_gc()) {
      return true;
    }
    return false;
  }
  
  void ShenandoahTraversalGC::concurrent_traversal_collection() {
<span class="line-removed">-   ClassLoaderDataGraph::clear_claimed_marks();</span>
<span class="line-removed">- </span>
    ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
    if (!_heap-&gt;cancelled_gc()) {
      uint nworkers = _heap-&gt;workers()-&gt;active_workers();
      task_queues()-&gt;reserve(nworkers);
      ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
  
<span class="line-modified">!     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
      ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
      _heap-&gt;workers()-&gt;run_task(&amp;task);
    }
  
    if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
<span class="line-new-header">--- 535,34 ---</span>
        }
      }
  
      if (work == 0) {
        // No more work, try to terminate
        ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
        ShenandoahTerminationTimingsTracker term_tracker(worker_id);
        ShenandoahTerminatorTerminator tt(_heap);
  
        if (terminator-&gt;offer_termination(&amp;tt)) return;
      }
    }
  }
  
<span class="line-modified">! bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(TaskTerminator* terminator, bool sts_yield) {</span>
    if (_heap-&gt;cancelled_gc()) {
      return true;
    }
    return false;
  }
  
  void ShenandoahTraversalGC::concurrent_traversal_collection() {
    ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
    if (!_heap-&gt;cancelled_gc()) {
      uint nworkers = _heap-&gt;workers()-&gt;active_workers();
      task_queues()-&gt;reserve(nworkers);
      ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
  
<span class="line-modified">!     TaskTerminator terminator(nworkers, task_queues());</span>
      ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
      _heap-&gt;workers()-&gt;run_task(&amp;task);
    }
  
    if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,49 ***</span>
  
  void ShenandoahTraversalGC::final_traversal_collection() {
    _heap-&gt;make_parsable(true);
  
    if (!_heap-&gt;cancelled_gc()) {
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
      DerivedPointerTable::clear();
  #endif
      ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
      uint nworkers = _heap-&gt;workers()-&gt;active_workers();
      task_queues()-&gt;reserve(nworkers);
  
      // Finish traversal
<span class="line-modified">!     ShenandoahRootProcessor rp(_heap, nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);</span>
      ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
  
<span class="line-modified">!     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
      ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
      _heap-&gt;workers()-&gt;run_task(&amp;task);
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
      DerivedPointerTable::update_pointers();
  #endif
    }
  
    if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
      weak_refs_work();
    }
  
<span class="line-removed">-   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;unload_classes()) {</span>
<span class="line-removed">-     _heap-&gt;unload_classes_and_cleanup_tables(false);</span>
<span class="line-removed">-     fixup_roots();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    if (!_heap-&gt;cancelled_gc()) {
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
  
      // No more marking expected
      _heap-&gt;mark_complete_marking_context();
  
      // Resize metaspace
      MetaspaceGC::compute_new_size();
  
      // Still good? We can now trash the cset, and make final verification
      {
        ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_cleanup);
        ShenandoahHeapLocker lock(_heap-&gt;lock());
  
<span class="line-new-header">--- 572,57 ---</span>
  
  void ShenandoahTraversalGC::final_traversal_collection() {
    _heap-&gt;make_parsable(true);
  
    if (!_heap-&gt;cancelled_gc()) {
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
      DerivedPointerTable::clear();
  #endif
      ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
      uint nworkers = _heap-&gt;workers()-&gt;active_workers();
      task_queues()-&gt;reserve(nworkers);
  
      // Finish traversal
<span class="line-modified">!     ShenandoahAllRootScanner rp(nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);</span>
      ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
  
<span class="line-modified">!     TaskTerminator terminator(nworkers, task_queues());</span>
      ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
      _heap-&gt;workers()-&gt;run_task(&amp;task);
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
      DerivedPointerTable::update_pointers();
  #endif
    }
  
    if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
      weak_refs_work();
    }
  
    if (!_heap-&gt;cancelled_gc()) {
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
      TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
  
      // No more marking expected
<span class="line-added">+     _heap-&gt;set_concurrent_traversal_in_progress(false);</span>
      _heap-&gt;mark_complete_marking_context();
  
<span class="line-added">+     _heap-&gt;parallel_cleaning(false);</span>
<span class="line-added">+     fixup_roots();</span>
<span class="line-added">+ </span>
<span class="line-added">+     _heap-&gt;set_has_forwarded_objects(false);</span>
<span class="line-added">+ </span>
      // Resize metaspace
      MetaspaceGC::compute_new_size();
  
<span class="line-added">+     // Need to see that pinned region status is updated: newly pinned regions must not</span>
<span class="line-added">+     // be trashed. New unpinned regions should be trashed.</span>
<span class="line-added">+     {</span>
<span class="line-added">+       ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_sync_pinned);</span>
<span class="line-added">+       _heap-&gt;sync_pinned_region_status();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Still good? We can now trash the cset, and make final verification
      {
        ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_cleanup);
        ShenandoahHeapLocker lock(_heap-&gt;lock());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 628,11 ***</span>
          bool not_allocated = ctx-&gt;top_at_mark_start(r) == r-&gt;top();
  
          bool candidate = traversal_regions-&gt;is_in(r) &amp;&amp; !r-&gt;has_live() &amp;&amp; not_allocated;
          if (r-&gt;is_humongous_start() &amp;&amp; candidate) {
            // Trash humongous.
<span class="line-modified">!           HeapWord* humongous_obj = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
            assert(!ctx-&gt;is_marked(oop(humongous_obj)), &quot;must not be marked&quot;);
            r-&gt;make_trash_immediate();
            while (i + 1 &lt; num_regions &amp;&amp; _heap-&gt;get_region(i + 1)-&gt;is_humongous_continuation()) {
              i++;
              r = _heap-&gt;get_region(i);
<span class="line-new-header">--- 639,11 ---</span>
          bool not_allocated = ctx-&gt;top_at_mark_start(r) == r-&gt;top();
  
          bool candidate = traversal_regions-&gt;is_in(r) &amp;&amp; !r-&gt;has_live() &amp;&amp; not_allocated;
          if (r-&gt;is_humongous_start() &amp;&amp; candidate) {
            // Trash humongous.
<span class="line-modified">!           HeapWord* humongous_obj = r-&gt;bottom();</span>
            assert(!ctx-&gt;is_marked(oop(humongous_obj)), &quot;must not be marked&quot;);
            r-&gt;make_trash_immediate();
            while (i + 1 &lt; num_regions &amp;&amp; _heap-&gt;get_region(i + 1)-&gt;is_humongous_continuation()) {
              i++;
              r = _heap-&gt;get_region(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,32 ***</span>
        _heap-&gt;free_set()-&gt;rebuild();
        reset();
      }
  
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
<span class="line-removed">-     _heap-&gt;set_concurrent_traversal_in_progress(false);</span>
      assert(!_heap-&gt;cancelled_gc(), &quot;must not be cancelled when getting out here&quot;);
  
      if (ShenandoahVerify) {
        _heap-&gt;verifier()-&gt;verify_after_traversal();
      }
  
      if (VerifyAfterGC) {
        Universe::verify();
      }
    }
  }
  
  class ShenandoahTraversalFixRootsClosure : public OopClosure {
  private:
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
        oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified">!       if (!oopDesc::equals_raw(obj, forw)) {</span>
          RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);
        }
      }
    }
  
<span class="line-new-header">--- 661,60 ---</span>
        _heap-&gt;free_set()-&gt;rebuild();
        reset();
      }
  
      assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
      assert(!_heap-&gt;cancelled_gc(), &quot;must not be cancelled when getting out here&quot;);
  
      if (ShenandoahVerify) {
        _heap-&gt;verifier()-&gt;verify_after_traversal();
      }
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+     else {</span>
<span class="line-added">+       verify_roots_after_gc();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
  
      if (VerifyAfterGC) {
        Universe::verify();
      }
    }
  }
  
<span class="line-added">+ class ShenandoahVerifyAfterGC : public OopClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   template &lt;class T&gt;</span>
<span class="line-added">+   void do_oop_work(T* p) {</span>
<span class="line-added">+     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">+       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">+       shenandoah_assert_correct(p, obj);</span>
<span class="line-added">+       shenandoah_assert_not_in_cset_except(p, obj, ShenandoahHeap::heap()-&gt;cancelled_gc());</span>
<span class="line-added">+       shenandoah_assert_not_forwarded(p, obj);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ public:</span>
<span class="line-added">+   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added">+   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ShenandoahTraversalGC::verify_roots_after_gc() {</span>
<span class="line-added">+   ShenandoahRootVerifier verifier;</span>
<span class="line-added">+   ShenandoahVerifyAfterGC cl;</span>
<span class="line-added">+   verifier.oops_do(&amp;cl);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class ShenandoahTraversalFixRootsClosure : public OopClosure {
  private:
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
        oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified">!       if (obj != forw) {</span>
          RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);
        }
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,34 ***</span>
    inline void do_oop(narrowOop* p) { do_oop_work(p); }
  };
  
  class ShenandoahTraversalFixRootsTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootProcessor* _rp;</span>
  
  public:
<span class="line-modified">!   ShenandoahTraversalFixRootsTask(ShenandoahRootProcessor* rp) :</span>
      AbstractGangTask(&quot;Shenandoah traversal fix roots&quot;),
<span class="line-modified">!     _rp(rp) {}</span>
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
      ShenandoahTraversalFixRootsClosure cl;
<span class="line-modified">!     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">!     CLDToOopClosure cldCl(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-removed">-     _rp-&gt;process_all_roots(&amp;cl, &amp;cl, &amp;cldCl, &amp;blobsCl, NULL, worker_id);</span>
    }
  };
  
  void ShenandoahTraversalGC::fixup_roots() {
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
    DerivedPointerTable::clear();
  #endif
<span class="line-modified">!   ShenandoahRootProcessor rp(_heap, _heap-&gt;workers()-&gt;active_workers(), ShenandoahPhaseTimings::final_traversal_update_roots);</span>
    ShenandoahTraversalFixRootsTask update_roots_task(&amp;rp);
    _heap-&gt;workers()-&gt;run_task(&amp;update_roots_task);
<span class="line-modified">! #if defined(COMPILER2) || INCLUDE_JVMCI</span>
    DerivedPointerTable::update_pointers();
  #endif
  }
  
  void ShenandoahTraversalGC::reset() {
<span class="line-new-header">--- 723,35 ---</span>
    inline void do_oop(narrowOop* p) { do_oop_work(p); }
  };
  
  class ShenandoahTraversalFixRootsTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootUpdater* _rp;</span>
  
  public:
<span class="line-modified">!   ShenandoahTraversalFixRootsTask(ShenandoahRootUpdater* rp) :</span>
      AbstractGangTask(&quot;Shenandoah traversal fix roots&quot;),
<span class="line-modified">!     _rp(rp) {</span>
<span class="line-added">+     assert(ShenandoahHeap::heap()-&gt;has_forwarded_objects(), &quot;Must be&quot;);</span>
<span class="line-added">+   }</span>
  
    void work(uint worker_id) {
      ShenandoahParallelWorkerSession worker_session(worker_id);
      ShenandoahTraversalFixRootsClosure cl;
<span class="line-modified">!     ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">!     _rp-&gt;roots_do(worker_id, &amp;is_alive, &amp;cl);</span>
    }
  };
  
  void ShenandoahTraversalGC::fixup_roots() {
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
    DerivedPointerTable::clear();
  #endif
<span class="line-modified">!   ShenandoahRootUpdater rp(_heap-&gt;workers()-&gt;active_workers(), ShenandoahPhaseTimings::final_traversal_update_roots);</span>
    ShenandoahTraversalFixRootsTask update_roots_task(&amp;rp);
    _heap-&gt;workers()-&gt;run_task(&amp;update_roots_task);
<span class="line-modified">! #if COMPILER2_OR_JVMCI</span>
    DerivedPointerTable::update_pointers();
  #endif
  }
  
  void ShenandoahTraversalGC::reset() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,11 ***</span>
  public:
    void do_void() {
      ShenandoahHeap* sh = ShenandoahHeap::heap();
      ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
      assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified">!     ShenandoahTaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
      shenandoah_assert_rp_isalive_installed();
      traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
    }
  };
  
<span class="line-new-header">--- 774,11 ---</span>
  public:
    void do_void() {
      ShenandoahHeap* sh = ShenandoahHeap::heap();
      ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
      assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified">!     TaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
      shenandoah_assert_rp_isalive_installed();
      traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
    }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 749,11 ***</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
      _queue(q), _thread(Thread::current()),
<span class="line-new-header">--- 789,11 ---</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
      _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,43 ***</span>
  
    void do_oop(narrowOop* p) { do_oop_work(p); }
    void do_oop(oop* p)       { do_oop_work(p); }
  };
  
<span class="line-removed">- class ShenandoahTraversalWeakUpdateClosure : public OopClosure {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   template &lt;class T&gt;</span>
<span class="line-removed">-   inline void do_oop_work(T* p) {</span>
<span class="line-removed">-     // Cannot call maybe_update_with_forwarded, because on traversal-degen</span>
<span class="line-removed">-     // path the collection set is already dropped. Instead, do the unguarded store.</span>
<span class="line-removed">-     // TODO: This can be fixed after degen-traversal stops dropping cset.</span>
<span class="line-removed">-     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed">-     if (!CompressedOops::is_null(o)) {</span>
<span class="line-removed">-       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed">-       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">-       shenandoah_assert_marked(p, obj);</span>
<span class="line-removed">-       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahTraversalWeakUpdateClosure() {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed">-   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class ShenandoahTraversalKeepAliveUpdateDegenClosure : public OopClosure {
  private:
    ShenandoahObjToScanQueue* _queue;
    Thread* _thread;
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
<span class="line-new-header">--- 802,20 ---</span>
  
    void do_oop(narrowOop* p) { do_oop_work(p); }
    void do_oop(oop* p)       { do_oop_work(p); }
  };
  
  class ShenandoahTraversalKeepAliveUpdateDegenClosure : public OopClosure {
  private:
    ShenandoahObjToScanQueue* _queue;
    Thread* _thread;
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */, false /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 816,12 ***</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-removed">-     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalSingleThreadKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
<span class="line-new-header">--- 833,11 ---</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalSingleThreadKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,12 ***</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-removed">-     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
<span class="line-new-header">--- 855,11 ---</span>
    ShenandoahTraversalGC* _traversal_gc;
    ShenandoahMarkingContext* const _mark_context;
  
    template &lt;class T&gt;
    inline void do_oop_work(T* p) {
<span class="line-modified">!     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */, false /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
    }
  
  public:
    ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
            _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,11 ***</span>
  
    void work(uint worker_id) {
      assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
      ShenandoahParallelWorkerSession worker_session(worker_id);
      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
<span class="line-removed">-     ShenandoahEvacOOMScope oom_evac_scope;</span>
  
      ShenandoahHeap* sh = ShenandoahHeap::heap();
  
      ShenandoahObjToScanQueue* q = sh-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id);
  
<span class="line-new-header">--- 881,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,15 ***</span>
  }
  
  // Weak Reference Closures
  class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
    uint _worker_id;
<span class="line-modified">!   ShenandoahTaskTerminator* _terminator;</span>
    bool _reset_terminator;
  
  public:
<span class="line-modified">!   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
      _worker_id(worker_id),
      _terminator(t),
      _reset_terminator(reset_terminator) {
    }
  
<span class="line-new-header">--- 941,15 ---</span>
  }
  
  // Weak Reference Closures
  class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
    uint _worker_id;
<span class="line-modified">!   TaskTerminator* _terminator;</span>
    bool _reset_terminator;
  
  public:
<span class="line-modified">!   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
      _worker_id(worker_id),
      _terminator(t),
      _reset_terminator(reset_terminator) {
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 955,15 ***</span>
    }
  };
  
  class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
    uint _worker_id;
<span class="line-modified">!   ShenandoahTaskTerminator* _terminator;</span>
    bool _reset_terminator;
  
  public:
<span class="line-modified">!   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
            _worker_id(worker_id),
            _terminator(t),
            _reset_terminator(reset_terminator) {
    }
  
<span class="line-new-header">--- 969,15 ---</span>
    }
  };
  
  class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
    uint _worker_id;
<span class="line-modified">!   TaskTerminator* _terminator;</span>
    bool _reset_terminator;
  
  public:
<span class="line-modified">!   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
            _worker_id(worker_id),
            _terminator(t),
            _reset_terminator(reset_terminator) {
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,11 ***</span>
      ShenandoahHeap* sh = ShenandoahHeap::heap();
      ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
      assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
      shenandoah_assert_rp_isalive_installed();
  
<span class="line-removed">-     ShenandoahEvacOOMScope evac_scope;</span>
      traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
  
      if (_reset_terminator) {
        _terminator-&gt;reset_for_reuse();
      }
<span class="line-new-header">--- 987,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1004,22 ***</span>
  }
  
  class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
  private:
    AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">!   ShenandoahTaskTerminator* _terminator;</span>
  
  public:
    ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">!                                       ShenandoahTaskTerminator* t) :</span>
      AbstractGangTask(&quot;Process reference objects in parallel&quot;),
      _proc_task(proc_task),
      _terminator(t) {
    }
  
    void work(uint worker_id) {
<span class="line-removed">-     ShenandoahEvacOOMScope oom_evac_scope;</span>
      assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
      ShenandoahHeap* heap = ShenandoahHeap::heap();
      ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
  
      ShenandoahForwardedIsAliveClosure is_alive;
<span class="line-new-header">--- 1017,21 ---</span>
  }
  
  class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
  private:
    AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">!   TaskTerminator* _terminator;</span>
  
  public:
    ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">!                                       TaskTerminator* t) :</span>
      AbstractGangTask(&quot;Process reference objects in parallel&quot;),
      _proc_task(proc_task),
      _terminator(t) {
    }
  
    void work(uint worker_id) {
      assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
      ShenandoahHeap* heap = ShenandoahHeap::heap();
      ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
  
      ShenandoahForwardedIsAliveClosure is_alive;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,11 ***</span>
                                            traversal_gc-&gt;task_queues(),
                                            ergo_workers,
                                            /* do_check = */ false);
      uint nworkers = _workers-&gt;active_workers();
      traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">!     ShenandoahTaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
      ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
      _workers-&gt;run_task(&amp;proc_task_proxy);
    }
  };
  
<span class="line-new-header">--- 1062,11 ---</span>
                                            traversal_gc-&gt;task_queues(),
                                            ergo_workers,
                                            /* do_check = */ false);
      uint nworkers = _workers-&gt;active_workers();
      traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">!     TaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
      ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
      _workers-&gt;run_task(&amp;proc_task_proxy);
    }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1078,11 ***</span>
    // complete_gc and keep_alive closures instantiated here are only needed for
    // single-threaded path in RP. They share the queue 0 for tracking work, which
    // simplifies implementation. Since RP may decide to call complete_gc several
    // times, we need to be able to reuse the terminator.
    uint serial_worker_id = 0;
<span class="line-modified">!   ShenandoahTaskTerminator terminator(1, task_queues());</span>
    ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
    ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
  
    ShenandoahTraversalRefProcTaskExecutor executor(workers);
  
<span class="line-new-header">--- 1090,11 ---</span>
    // complete_gc and keep_alive closures instantiated here are only needed for
    // single-threaded path in RP. They share the queue 0 for tracking work, which
    // simplifies implementation. Since RP may decide to call complete_gc several
    // times, we need to be able to reuse the terminator.
    uint serial_worker_id = 0;
<span class="line-modified">!   TaskTerminator terminator(1, task_queues());</span>
    ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
    ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
  
    ShenandoahTraversalRefProcTaskExecutor executor(workers);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1097,18 ***</span>
      rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
                                        &amp;complete_gc, &amp;executor,
                                        &amp;pt);
    }
  
<span class="line-modified">!   {</span>
<span class="line-modified">!     ShenandoahGCPhase phase(phase_process);</span>
<span class="line-removed">-     ShenandoahTerminationTracker termination(ShenandoahPhaseTimings::weakrefs_termination);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Process leftover weak oops (using parallel version)</span>
<span class="line-removed">-     ShenandoahTraversalWeakUpdateClosure cl;</span>
<span class="line-removed">-     WeakProcessor::weak_oops_do(workers, &amp;is_alive, &amp;cl, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     pt.print_all_references();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);</span>
<span class="line-removed">-   }</span>
  }
<span class="line-new-header">--- 1109,8 ---</span>
      rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
                                        &amp;complete_gc, &amp;executor,
                                        &amp;pt);
    }
  
<span class="line-modified">!   pt.print_all_references();</span>
<span class="line-modified">!   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);</span>
  }
</pre>
<center><a href="shenandoahTracer.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahFreeSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;memory/allocation.hpp&quot;

  26 

  27 #include &quot;gc/shared/gcTimer.hpp&quot;
  28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;

  29 #include &quot;gc/shared/memAllocator.hpp&quot;
<span class="line-modified">  30 #include &quot;gc/shared/parallelCleaning.hpp&quot;</span>
  31 #include &quot;gc/shared/plab.hpp&quot;
  32 
  33 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified">  35 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  36 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;

  39 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;

  50 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<span class="line-modified">  52 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>


  53 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;


  54 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  55 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  56 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  58 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  59 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
<span class="line-modified">  60 #include &quot;gc/shenandoah/heuristics/shenandoahAdaptiveHeuristics.hpp&quot;</span>
<span class="line-modified">  61 #include &quot;gc/shenandoah/heuristics/shenandoahAggressiveHeuristics.hpp&quot;</span>
<span class="line-modified">  62 #include &quot;gc/shenandoah/heuristics/shenandoahCompactHeuristics.hpp&quot;</span>
<span class="line-removed">  63 #include &quot;gc/shenandoah/heuristics/shenandoahPassiveHeuristics.hpp&quot;</span>
<span class="line-removed">  64 #include &quot;gc/shenandoah/heuristics/shenandoahStaticHeuristics.hpp&quot;</span>
<span class="line-removed">  65 #include &quot;gc/shenandoah/heuristics/shenandoahTraversalHeuristics.hpp&quot;</span>
  66 
  67 #include &quot;memory/metaspace.hpp&quot;



  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;

  69 #include &quot;runtime/safepointMechanism.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;services/mallocTracker.hpp&quot;
<span class="line-modified">  72 </span>
<span class="line-removed">  73 ShenandoahUpdateRefsClosure::ShenandoahUpdateRefsClosure() : _heap(ShenandoahHeap::heap()) {}</span>
  74 
  75 #ifdef ASSERT
  76 template &lt;class T&gt;
  77 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  78   T o = RawAccess&lt;&gt;::oop_load(p);
  79   if (! CompressedOops::is_null(o)) {
  80     oop obj = CompressedOops::decode_not_null(o);
  81     shenandoah_assert_not_forwarded(p, obj);
  82   }
  83 }
  84 
  85 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  86 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  87 #endif
  88 
  89 class ShenandoahPretouchHeapTask : public AbstractGangTask {
  90 private:
  91   ShenandoahRegionIterator _regions;
  92   const size_t _page_size;
  93 public:
</pre>
<hr />
<pre>
 115     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 116     _bitmap_base(bitmap_base),
 117     _bitmap_size(bitmap_size),
 118     _page_size(page_size) {}
 119 
 120   virtual void work(uint worker_id) {
 121     ShenandoahHeapRegion* r = _regions.next();
 122     while (r != NULL) {
 123       size_t start = r-&gt;region_number()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 124       size_t end   = (r-&gt;region_number() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 125       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 126 
 127       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 128 
 129       r = _regions.next();
 130     }
 131   }
 132 };
 133 
 134 jint ShenandoahHeap::initialize() {
<span class="line-removed"> 135   ShenandoahBrooksPointer::initial_checks();</span>
<span class="line-removed"> 136 </span>
 137   initialize_heuristics();
 138 
 139   //
 140   // Figure out heap sizing
 141   //
 142 
<span class="line-modified"> 143   size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size();</span>
<span class="line-modified"> 144   size_t max_byte_size  = collector_policy()-&gt;max_heap_byte_size();</span>
<span class="line-modified"> 145   size_t heap_alignment = collector_policy()-&gt;heap_alignment();</span>

 146 
 147   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 148 
 149   if (ShenandoahAlwaysPreTouch) {
 150     // Enabled pre-touch means the entire heap is committed right away.
 151     init_byte_size = max_byte_size;
 152   }
 153 
 154   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 155   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 156 
 157   _num_regions = ShenandoahHeapRegion::region_count();
 158 
 159   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 160   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 161   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);
<span class="line-removed"> 162 </span>
 163   _initial_size = num_committed_regions * reg_size_bytes;






 164   _committed = _initial_size;
 165 
 166   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 167   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 168 
 169   //
 170   // Reserve and commit memory for heap
 171   //
 172 
<span class="line-modified"> 173   ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);</span>
<span class="line-modified"> 174   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*) (heap_rs.base() + heap_rs.size()));</span>
 175   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 176   _heap_region_special = heap_rs.special();
 177 
 178   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 179          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 180 












 181   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 182   if (!_heap_region_special) {
 183     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 184                               &quot;Cannot commit heap memory&quot;);
 185   }
 186 
 187   //
 188   // Reserve and commit memory for bitmap(s)
 189   //
 190 
 191   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 192   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 193 
 194   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 195 
 196   guarantee(bitmap_bytes_per_region != 0,
 197             &quot;Bitmap bytes per region should not be zero&quot;);
 198   guarantee(is_power_of_2(bitmap_bytes_per_region),
 199             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 200 
</pre>
<hr />
<pre>
 237     }
 238     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 239     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 240     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 241     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 242   }
 243 
 244   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 245   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 246   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 247   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 248   _aux_bitmap_region_special = aux_bitmap.special();
 249   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 250 
 251   //
 252   // Create regions and region sets
 253   //
 254 
 255   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 256   _free_set = new ShenandoahFreeSet(this, _num_regions);
<span class="line-modified"> 257   _collection_set = new ShenandoahCollectionSet(this, (HeapWord*)sh_rs.base());</span>
 258 
 259   {
 260     ShenandoahHeapLocker locker(lock());
 261 
 262     size_t size_words = ShenandoahHeapRegion::region_size_words();
 263 
 264     for (size_t i = 0; i &lt; _num_regions; i++) {
 265       HeapWord* start = (HeapWord*)sh_rs.base() + size_words * i;
 266       bool is_committed = i &lt; num_committed_regions;
 267       ShenandoahHeapRegion* r = new ShenandoahHeapRegion(this, start, size_words, i, is_committed);
 268 
 269       _marking_context-&gt;initialize_top_at_mark_start(r);
 270       _regions[i] = r;
 271       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 272     }
 273 
 274     // Initialize to complete
 275     _marking_context-&gt;mark_complete();
 276 
 277     _free_set-&gt;rebuild();
</pre>
<hr />
<pre>
 305                        _num_regions, pretouch_bitmap_page_size);
 306     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 307     _workers-&gt;run_task(&amp;bcl);
 308 
 309     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 310                        _num_regions, pretouch_heap_page_size);
 311     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 312     _workers-&gt;run_task(&amp;hcl);
 313   }
 314 
 315   //
 316   // Initialize the rest of GC subsystems
 317   //
 318 
 319   _liveness_cache = NEW_C_HEAP_ARRAY(jushort*, _max_workers, mtGC);
 320   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 321     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
 322     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
 323   }
 324 
<span class="line-modified"> 325   // The call below uses stuff (the SATB* things) that are in G1, but probably</span>
<span class="line-modified"> 326   // belong into a shared location.</span>
<span class="line-modified"> 327   ShenandoahBarrierSet::satb_mark_queue_set().initialize(this,</span>
<span class="line-modified"> 328                                                          SATB_Q_CBL_mon,</span>
<span class="line-modified"> 329                                                          20 /* G1SATBProcessCompletedThreshold */,</span>
<span class="line-modified"> 330                                                          60 /* G1SATBBufferEnqueueingThresholdPercent */);</span>

 331 
 332   _monitoring_support = new ShenandoahMonitoringSupport(this);
 333   _phase_timings = new ShenandoahPhaseTimings();
 334   ShenandoahStringDedup::initialize();
 335   ShenandoahCodeRoots::initialize();
 336 
 337   if (ShenandoahAllocationTrace) {
 338     _alloc_tracker = new ShenandoahAllocTracker();
 339   }
 340 
 341   if (ShenandoahPacing) {
 342     _pacer = new ShenandoahPacer(this);
 343     _pacer-&gt;setup_for_idle();
 344   } else {
 345     _pacer = NULL;
 346   }
 347 
<span class="line-modified"> 348   _traversal_gc = heuristics()-&gt;can_do_traversal_gc() ?</span>
 349                   new ShenandoahTraversalGC(this, _num_regions) :
 350                   NULL;
 351 
 352   _control_thread = new ShenandoahControlThread();
 353 
<span class="line-modified"> 354   log_info(gc, init)(&quot;Initialize Shenandoah heap with initial size &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified"> 355                      byte_size_in_proper_unit(_initial_size), proper_unit_for_byte_size(_initial_size));</span>



 356 
 357   log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
 358                      SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
 359                      (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
 360 
 361   return JNI_OK;
 362 }
 363 
 364 void ShenandoahHeap::initialize_heuristics() {
<span class="line-modified"> 365   if (ShenandoahGCHeuristics != NULL) {</span>
<span class="line-modified"> 366     if (strcmp(ShenandoahGCHeuristics, &quot;aggressive&quot;) == 0) {</span>
<span class="line-modified"> 367       _heuristics = new ShenandoahAggressiveHeuristics();</span>
<span class="line-modified"> 368     } else if (strcmp(ShenandoahGCHeuristics, &quot;static&quot;) == 0) {</span>
<span class="line-modified"> 369       _heuristics = new ShenandoahStaticHeuristics();</span>
<span class="line-modified"> 370     } else if (strcmp(ShenandoahGCHeuristics, &quot;adaptive&quot;) == 0) {</span>
<span class="line-modified"> 371       _heuristics = new ShenandoahAdaptiveHeuristics();</span>
<span class="line-removed"> 372     } else if (strcmp(ShenandoahGCHeuristics, &quot;passive&quot;) == 0) {</span>
<span class="line-removed"> 373       _heuristics = new ShenandoahPassiveHeuristics();</span>
<span class="line-removed"> 374     } else if (strcmp(ShenandoahGCHeuristics, &quot;compact&quot;) == 0) {</span>
<span class="line-removed"> 375       _heuristics = new ShenandoahCompactHeuristics();</span>
<span class="line-removed"> 376     } else if (strcmp(ShenandoahGCHeuristics, &quot;traversal&quot;) == 0) {</span>
<span class="line-removed"> 377       _heuristics = new ShenandoahTraversalHeuristics();</span>
 378     } else {
<span class="line-modified"> 379       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCHeuristics option&quot;);</span>
 380     }
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382     if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {</span>
<span class="line-removed"> 383       vm_exit_during_initialization(</span>
<span class="line-removed"> 384               err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,</span>
<span class="line-removed"> 385                       _heuristics-&gt;name()));</span>
<span class="line-removed"> 386     }</span>
<span class="line-removed"> 387     if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {</span>
<span class="line-removed"> 388       vm_exit_during_initialization(</span>
<span class="line-removed"> 389               err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,</span>
<span class="line-removed"> 390                       _heuristics-&gt;name()));</span>
<span class="line-removed"> 391     }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393     if (ShenandoahStoreValEnqueueBarrier &amp;&amp; ShenandoahStoreValReadBarrier) {</span>
<span class="line-removed"> 394       vm_exit_during_initialization(&quot;Cannot use both ShenandoahStoreValEnqueueBarrier and ShenandoahStoreValReadBarrier&quot;);</span>
<span class="line-removed"> 395     }</span>
<span class="line-removed"> 396     log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,</span>
<span class="line-removed"> 397                        _heuristics-&gt;name());</span>
 398   } else {
<span class="line-modified"> 399       ShouldNotReachHere();</span>
 400   }


 401 












 402 }
 403 
 404 #ifdef _MSC_VER
 405 #pragma warning( push )
 406 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 407 #endif
 408 
 409 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 410   CollectedHeap(),
 411   _initial_size(0),
 412   _used(0),
 413   _committed(0),
 414   _bytes_allocated_since_gc_start(0),
 415   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 416   _workers(NULL),
 417   _safepoint_workers(NULL),
 418   _heap_region_special(false),
 419   _num_regions(0),
 420   _regions(NULL),
 421   _update_refs_iterator(this),
 422   _control_thread(NULL),
 423   _shenandoah_policy(policy),
 424   _heuristics(NULL),
 425   _free_set(NULL),
 426   _scm(new ShenandoahConcurrentMark()),
 427   _traversal_gc(NULL),
 428   _full_gc(new ShenandoahMarkCompact()),
 429   _pacer(NULL),
 430   _verifier(NULL),
 431   _alloc_tracker(NULL),
 432   _phase_timings(NULL),
 433   _monitoring_support(NULL),
 434   _memory_pool(NULL),
 435   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 436   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 437   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 438   _soft_ref_policy(),

 439   _ref_processor(NULL),
 440   _marking_context(NULL),
 441   _bitmap_size(0),
 442   _bitmap_regions_per_slice(0),
 443   _bitmap_bytes_per_slice(0),
 444   _bitmap_region_special(false),
 445   _aux_bitmap_region_special(false),
 446   _liveness_cache(NULL),
 447   _collection_set(NULL)
 448 {
 449   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 450   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 451 
 452   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 453 
 454   _max_workers = MAX2(_max_workers, 1U);
 455   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
<span class="line-modified"> 456                             /* are_GC_task_threads */true,</span>
<span class="line-modified"> 457                             /* are_ConcurrentGC_threads */false);</span>
 458   if (_workers == NULL) {
 459     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 460   } else {
 461     _workers-&gt;initialize_workers();
 462   }
 463 
 464   if (ShenandoahParallelSafepointThreads &gt; 1) {
 465     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 466                                                 ShenandoahParallelSafepointThreads,
<span class="line-modified"> 467                                                 false, false);</span>

 468     _safepoint_workers-&gt;initialize_workers();
 469   }
 470 }
 471 
 472 #ifdef _MSC_VER
 473 #pragma warning( pop )
 474 #endif
 475 
 476 class ShenandoahResetBitmapTask : public AbstractGangTask {
 477 private:
 478   ShenandoahRegionIterator _regions;
 479 
 480 public:
 481   ShenandoahResetBitmapTask() :
 482     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 483 
 484   void work(uint worker_id) {
 485     ShenandoahHeapRegion* region = _regions.next();
 486     ShenandoahHeap* heap = ShenandoahHeap::heap();
 487     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 488     while (region != NULL) {
 489       if (heap-&gt;is_bitmap_slice_committed(region)) {
 490         ctx-&gt;clear_bitmap(region);
 491       }
 492       region = _regions.next();
 493     }
 494   }
 495 };
 496 
 497 void ShenandoahHeap::reset_mark_bitmap() {
 498   assert_gc_workers(_workers-&gt;active_workers());
 499   mark_incomplete_marking_context();
 500 
 501   ShenandoahResetBitmapTask task;
 502   _workers-&gt;run_task(&amp;task);
 503 }
 504 
 505 void ShenandoahHeap::print_on(outputStream* st) const {
 506   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
<span class="line-modified"> 507   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;K total, &quot; SIZE_FORMAT &quot;K committed, &quot; SIZE_FORMAT &quot;K used&quot;,</span>
<span class="line-modified"> 508                capacity() / K, committed() / K, used() / K);</span>
<span class="line-modified"> 509   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;K regions&quot;,</span>
<span class="line-modified"> 510                num_regions(), ShenandoahHeapRegion::region_size_bytes() / K);</span>




 511 
 512   st-&gt;print(&quot;Status: &quot;);
 513   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 514   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 515   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 516   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
 517   if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
 518   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 519   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 520   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);

 521 
 522   if (cancelled_gc()) {
 523     st-&gt;print(&quot;cancelled&quot;);
 524   } else {
 525     st-&gt;print(&quot;not cancelled&quot;);
 526   }
 527   st-&gt;cr();
 528 
 529   st-&gt;print_cr(&quot;Reserved region:&quot;);
 530   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 531                p2i(reserved_region().start()),
 532                p2i(reserved_region().end()));
 533 









 534   st-&gt;cr();
 535   MetaspaceUtils::print_on(st);
 536 
 537   if (Verbose) {
 538     print_heap_regions_on(st);
 539   }
 540 }
 541 
 542 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 543 public:
 544   void do_thread(Thread* thread) {
 545     assert(thread != NULL, &quot;Sanity&quot;);
 546     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 547     ShenandoahThreadLocalData::initialize_gclab(thread);
 548   }
 549 };
 550 
 551 void ShenandoahHeap::post_initialize() {
 552   CollectedHeap::post_initialize();
 553   MutexLocker ml(Threads_lock);
 554 
 555   ShenandoahInitWorkerGCLABClosure init_gclabs;
 556   _workers-&gt;threads_do(&amp;init_gclabs);
 557 
 558   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 559   // Now, we will let WorkGang to initialize gclab when new worker is created.
 560   _workers-&gt;set_initialize_gclab();
 561 
 562   _scm-&gt;initialize(_max_workers);
 563   _full_gc-&gt;initialize(_gc_timer);
 564 
 565   ref_processing_init();
 566 
 567   _heuristics-&gt;initialize();


 568 }
 569 
 570 size_t ShenandoahHeap::used() const {
<span class="line-modified"> 571   return OrderAccess::load_acquire(&amp;_used);</span>
 572 }
 573 
 574 size_t ShenandoahHeap::committed() const {
 575   OrderAccess::acquire();
 576   return _committed;
 577 }
 578 
 579 void ShenandoahHeap::increase_committed(size_t bytes) {
 580   assert_heaplock_or_safepoint();
 581   _committed += bytes;
 582 }
 583 
 584 void ShenandoahHeap::decrease_committed(size_t bytes) {
 585   assert_heaplock_or_safepoint();
 586   _committed -= bytes;
 587 }
 588 
 589 void ShenandoahHeap::increase_used(size_t bytes) {
<span class="line-modified"> 590   Atomic::add(bytes, &amp;_used);</span>
 591 }
 592 
 593 void ShenandoahHeap::set_used(size_t bytes) {
<span class="line-modified"> 594   OrderAccess::release_store_fence(&amp;_used, bytes);</span>
 595 }
 596 
 597 void ShenandoahHeap::decrease_used(size_t bytes) {
 598   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
<span class="line-modified"> 599   Atomic::sub(bytes, &amp;_used);</span>
 600 }
 601 
 602 void ShenandoahHeap::increase_allocated(size_t bytes) {
<span class="line-modified"> 603   Atomic::add(bytes, &amp;_bytes_allocated_since_gc_start);</span>
 604 }
 605 
 606 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 607   size_t bytes = words * HeapWordSize;
 608   if (!waste) {
 609     increase_used(bytes);
 610   }
 611   increase_allocated(bytes);
 612   if (ShenandoahPacing) {
 613     control_thread()-&gt;pacing_notify_alloc(words);
 614     if (waste) {
 615       pacer()-&gt;claim_for_alloc(words, true);
 616     }
 617   }
 618 }
 619 
 620 size_t ShenandoahHeap::capacity() const {
<span class="line-modified"> 621   return num_regions() * ShenandoahHeapRegion::region_size_bytes();</span>
 622 }
 623 
 624 size_t ShenandoahHeap::max_capacity() const {
 625   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 626 }
 627 




 628 size_t ShenandoahHeap::initial_capacity() const {
 629   return _initial_size;
 630 }
 631 
 632 bool ShenandoahHeap::is_in(const void* p) const {
 633   HeapWord* heap_base = (HeapWord*) base();
 634   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 635   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 636 }
 637 
 638 void ShenandoahHeap::op_uncommit(double shrink_before) {
 639   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 640 





 641   size_t count = 0;
<span class="line-modified"> 642   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-modified"> 643     ShenandoahHeapRegion* r = get_region(i);</span>
 644     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 645       ShenandoahHeapLocker locker(lock());
 646       if (r-&gt;is_empty_committed()) {





 647         r-&gt;make_uncommitted();
 648         count++;
 649       }
 650     }
 651     SpinPause(); // allow allocators to take the lock
 652   }
 653 
 654   if (count &gt; 0) {
<span class="line-removed"> 655     log_info(gc)(&quot;Uncommitted &quot; SIZE_FORMAT &quot;M. Heap: &quot; SIZE_FORMAT &quot;M reserved, &quot; SIZE_FORMAT &quot;M committed, &quot; SIZE_FORMAT &quot;M used&quot;,</span>
<span class="line-removed"> 656                  count * ShenandoahHeapRegion::region_size_bytes() / M, capacity() / M, committed() / M, used() / M);</span>
 657     control_thread()-&gt;notify_heap_changed();
 658   }
 659 }
 660 
 661 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 662   // New object should fit the GCLAB size
 663   size_t min_size = MAX2(size, PLAB::min_size());
 664 
 665   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 666   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 667   new_size = MIN2(new_size, PLAB::max_size());
 668   new_size = MAX2(new_size, PLAB::min_size());
 669 
 670   // Record new heuristic value even if we take any shortcut. This captures
 671   // the case when moderately-sized objects always take a shortcut. At some point,
 672   // heuristics should catch up with them.
 673   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 674 
 675   if (new_size &lt; size) {
 676     // New size still does not fit the object. Fall back to shared allocation.
</pre>
<hr />
<pre>
 773     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 774 
 775     size_t tries = 0;
 776 
 777     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 778       tries++;
 779       control_thread()-&gt;handle_alloc_failure(req.size());
 780       result = allocate_memory_under_lock(req, in_new_region);
 781     }
 782 
 783     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 784       tries++;
 785       control_thread()-&gt;handle_alloc_failure(req.size());
 786       result = allocate_memory_under_lock(req, in_new_region);
 787     }
 788 
 789   } else {
 790     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 791     result = allocate_memory_under_lock(req, in_new_region);
 792     // Do not call handle_alloc_failure() here, because we cannot block.
<span class="line-modified"> 793     // The allocation failure would be handled by the WB slowpath with handle_alloc_failure_evac().</span>
 794   }
 795 
 796   if (in_new_region) {
 797     control_thread()-&gt;notify_heap_changed();
 798   }
 799 
 800   if (result != NULL) {
 801     size_t requested = req.size();
 802     size_t actual = req.actual_size();
 803 
 804     assert (req.is_lab_alloc() || (requested == actual),
 805             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 806             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 807 
 808     if (req.is_mutator_alloc()) {
 809       notify_mutator_alloc_words(actual, false);
 810 
 811       // If we requested more than we were granted, give the rest back to pacer.
 812       // This only matters if we are in the same pacing epoch: do not try to unpace
 813       // over the budget for the other phase.
 814       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 815         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 816       }
 817     } else {
 818       increase_used(actual*HeapWordSize);
 819     }
 820   }
 821 
 822   return result;
 823 }
 824 
 825 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 826   ShenandoahHeapLocker locker(lock());
 827   return _free_set-&gt;allocate(req, in_new_region);
 828 }
 829 
<span class="line-removed"> 830 class ShenandoahMemAllocator : public MemAllocator {</span>
<span class="line-removed"> 831 private:</span>
<span class="line-removed"> 832   MemAllocator&amp; _initializer;</span>
<span class="line-removed"> 833 public:</span>
<span class="line-removed"> 834   ShenandoahMemAllocator(MemAllocator&amp; initializer, Klass* klass, size_t word_size, Thread* thread) :</span>
<span class="line-removed"> 835   MemAllocator(klass, word_size + ShenandoahBrooksPointer::word_size(), thread),</span>
<span class="line-removed"> 836     _initializer(initializer) {}</span>
<span class="line-removed"> 837 </span>
<span class="line-removed"> 838 protected:</span>
<span class="line-removed"> 839   virtual HeapWord* mem_allocate(Allocation&amp; allocation) const {</span>
<span class="line-removed"> 840     HeapWord* result = MemAllocator::mem_allocate(allocation);</span>
<span class="line-removed"> 841     // Initialize brooks-pointer</span>
<span class="line-removed"> 842     if (result != NULL) {</span>
<span class="line-removed"> 843       result += ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed"> 844       ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-removed"> 845       assert(! ShenandoahHeap::heap()-&gt;in_collection_set(result), &quot;never allocate in targetted region&quot;);</span>
<span class="line-removed"> 846     }</span>
<span class="line-removed"> 847     return result;</span>
<span class="line-removed"> 848   }</span>
<span class="line-removed"> 849 </span>
<span class="line-removed"> 850   virtual oop initialize(HeapWord* mem) const {</span>
<span class="line-removed"> 851      return _initializer.initialize(mem);</span>
<span class="line-removed"> 852   }</span>
<span class="line-removed"> 853 };</span>
<span class="line-removed"> 854 </span>
<span class="line-removed"> 855 oop ShenandoahHeap::obj_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed"> 856   ObjAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed"> 857   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 858   return allocator.allocate();</span>
<span class="line-removed"> 859 }</span>
<span class="line-removed"> 860 </span>
<span class="line-removed"> 861 oop ShenandoahHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {</span>
<span class="line-removed"> 862   ObjArrayAllocator initializer(klass, size, length, do_zero, THREAD);</span>
<span class="line-removed"> 863   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 864   return allocator.allocate();</span>
<span class="line-removed"> 865 }</span>
<span class="line-removed"> 866 </span>
<span class="line-removed"> 867 oop ShenandoahHeap::class_allocate(Klass* klass, int size, TRAPS) {</span>
<span class="line-removed"> 868   ClassAllocator initializer(klass, size, THREAD);</span>
<span class="line-removed"> 869   ShenandoahMemAllocator allocator(initializer, klass, size, THREAD);</span>
<span class="line-removed"> 870   return allocator.allocate();</span>
<span class="line-removed"> 871 }</span>
<span class="line-removed"> 872 </span>
 873 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 874                                         bool*  gc_overhead_limit_was_exceeded) {
 875   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 876   return allocate_memory(req);
 877 }
 878 
 879 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 880                                                              size_t size,
 881                                                              Metaspace::MetadataType mdtype) {
 882   MetaWord* result;
 883 
 884   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 885   if (heuristics()-&gt;can_unload_classes()) {
 886     ShenandoahHeuristics* h = heuristics();
 887     h-&gt;record_metaspace_oom();
 888   }
 889 
 890   // Expand and retry allocation
 891   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 892   if (result != NULL) {
</pre>
<hr />
<pre>
 895 
 896   // Start full GC
 897   collect(GCCause::_metadata_GC_clear_soft_refs);
 898 
 899   // Retry allocation
 900   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 901   if (result != NULL) {
 902     return result;
 903   }
 904 
 905   // Expand and retry allocation
 906   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 907   if (result != NULL) {
 908     return result;
 909   }
 910 
 911   // Out of memory
 912   return NULL;
 913 }
 914 
<span class="line-removed"> 915 void ShenandoahHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {</span>
<span class="line-removed"> 916   HeapWord* obj = tlab_post_allocation_setup(start);</span>
<span class="line-removed"> 917   CollectedHeap::fill_with_object(obj, end);</span>
<span class="line-removed"> 918 }</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920 size_t ShenandoahHeap::min_dummy_object_size() const {</span>
<span class="line-removed"> 921   return CollectedHeap::min_dummy_object_size() + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed"> 922 }</span>
<span class="line-removed"> 923 </span>
<span class="line-removed"> 924 class ShenandoahEvacuateUpdateRootsClosure: public BasicOopIterateClosure {</span>
<span class="line-removed"> 925 private:</span>
<span class="line-removed"> 926   ShenandoahHeap* _heap;</span>
<span class="line-removed"> 927   Thread* _thread;</span>
<span class="line-removed"> 928 public:</span>
<span class="line-removed"> 929   ShenandoahEvacuateUpdateRootsClosure() :</span>
<span class="line-removed"> 930     _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {</span>
<span class="line-removed"> 931   }</span>
<span class="line-removed"> 932 </span>
<span class="line-removed"> 933 private:</span>
<span class="line-removed"> 934   template &lt;class T&gt;</span>
<span class="line-removed"> 935   void do_oop_work(T* p) {</span>
<span class="line-removed"> 936     assert(_heap-&gt;is_evacuation_in_progress(), &quot;Only do this when evacuation is in progress&quot;);</span>
<span class="line-removed"> 937 </span>
<span class="line-removed"> 938     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 939     if (! CompressedOops::is_null(o)) {</span>
<span class="line-removed"> 940       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed"> 941       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="line-removed"> 942         shenandoah_assert_marked(p, obj);</span>
<span class="line-removed"> 943         oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed"> 944         if (oopDesc::equals_raw(resolved, obj)) {</span>
<span class="line-removed"> 945           resolved = _heap-&gt;evacuate_object(obj, _thread);</span>
<span class="line-removed"> 946         }</span>
<span class="line-removed"> 947         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, resolved);</span>
<span class="line-removed"> 948       }</span>
<span class="line-removed"> 949     }</span>
<span class="line-removed"> 950   }</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952 public:</span>
<span class="line-removed"> 953   void do_oop(oop* p) {</span>
<span class="line-removed"> 954     do_oop_work(p);</span>
<span class="line-removed"> 955   }</span>
<span class="line-removed"> 956   void do_oop(narrowOop* p) {</span>
<span class="line-removed"> 957     do_oop_work(p);</span>
<span class="line-removed"> 958   }</span>
<span class="line-removed"> 959 };</span>
<span class="line-removed"> 960 </span>
 961 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 962 private:
 963   ShenandoahHeap* const _heap;
 964   Thread* const _thread;
 965 public:
 966   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 967     _heap(heap), _thread(Thread::current()) {}
 968 
 969   void do_object(oop p) {
 970     shenandoah_assert_marked(NULL, p);
<span class="line-modified"> 971     if (oopDesc::equals_raw(p, ShenandoahBarrierSet::resolve_forwarded_not_null(p))) {</span>
 972       _heap-&gt;evacuate_object(p, _thread);
 973     }
 974   }
 975 };
 976 
 977 class ShenandoahEvacuationTask : public AbstractGangTask {
 978 private:
 979   ShenandoahHeap* const _sh;
 980   ShenandoahCollectionSet* const _cs;
 981   bool _concurrent;
 982 public:
 983   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 984                            ShenandoahCollectionSet* cs,
 985                            bool concurrent) :
 986     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 987     _sh(sh),
 988     _cs(cs),
 989     _concurrent(concurrent)
 990   {}
 991 
 992   void work(uint worker_id) {
 993     if (_concurrent) {
 994       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 995       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 996       ShenandoahEvacOOMScope oom_evac_scope;
 997       do_work();
 998     } else {
 999       ShenandoahParallelWorkerSession worker_session(worker_id);
1000       ShenandoahEvacOOMScope oom_evac_scope;
1001       do_work();
1002     }
1003   }
1004 
1005 private:
1006   void do_work() {
1007     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
1008     ShenandoahHeapRegion* r;
1009     while ((r =_cs-&gt;claim_next()) != NULL) {
<span class="line-modified">1010       assert(r-&gt;has_live(), &quot;all-garbage regions are reclaimed early&quot;);</span>
1011       _sh-&gt;marked_object_iterate(r, &amp;cl);
1012 
1013       if (ShenandoahPacing) {
1014         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
1015       }
1016 
1017       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
1018         break;
1019       }
1020     }
1021   }
1022 };
1023 
1024 void ShenandoahHeap::trash_cset_regions() {
1025   ShenandoahHeapLocker locker(lock());
1026 
1027   ShenandoahCollectionSet* set = collection_set();
1028   ShenandoahHeapRegion* r;
1029   set-&gt;clear_current_index();
1030   while ((r = set-&gt;next()) != NULL) {
1031     r-&gt;make_trash();
1032   }
1033   collection_set()-&gt;clear();
1034 }
1035 
1036 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
1037   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1038   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1039   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
1040   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start (previous, next)&quot;);
1041   st-&gt;print_cr(&quot;SN=alloc sequence numbers (first mutator, last mutator, first gc, last gc)&quot;);
1042 
1043   for (size_t i = 0; i &lt; num_regions(); i++) {
1044     get_region(i)-&gt;print_on(st);
1045   }
1046 }
1047 
1048 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1049   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1050 
<span class="line-modified">1051   oop humongous_obj = oop(start-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">1052   size_t size = humongous_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
1053   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1054   size_t index = start-&gt;region_number() + required_regions - 1;
1055 
1056   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1057 
1058   for(size_t i = 0; i &lt; required_regions; i++) {
1059     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1060     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1061     ShenandoahHeapRegion* region = get_region(index --);
1062 
1063     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1064     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1065 
1066     region-&gt;make_trash_immediate();
1067   }
1068 }
1069 
1070 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1071 public:
1072   void do_thread(Thread* thread) {
</pre>
<hr />
<pre>
1086   }
1087   workers()-&gt;threads_do(&amp;cl);
1088 }
1089 
1090 void ShenandoahHeap::resize_tlabs() {
1091   CollectedHeap::resize_all_tlabs();
1092 }
1093 
1094 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1095 private:
1096   ShenandoahRootEvacuator* _rp;
1097 
1098 public:
1099   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1100     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1101     _rp(rp) {}
1102 
1103   void work(uint worker_id) {
1104     ShenandoahParallelWorkerSession worker_session(worker_id);
1105     ShenandoahEvacOOMScope oom_evac_scope;
<span class="line-modified">1106     ShenandoahEvacuateUpdateRootsClosure cl;</span>
<span class="line-removed">1107 </span>
1108     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
<span class="line-modified">1109     _rp-&gt;process_evacuate_roots(&amp;cl, &amp;blobsCl, worker_id);</span>
1110   }
1111 };
1112 
1113 void ShenandoahHeap::evacuate_and_update_roots() {
<span class="line-modified">1114 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
1115   DerivedPointerTable::clear();
1116 #endif
1117   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);
<span class="line-removed">1118 </span>
1119   {
<span class="line-modified">1120     ShenandoahRootEvacuator rp(this, workers()-&gt;active_workers(), ShenandoahPhaseTimings::init_evac);</span>




1121     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1122     workers()-&gt;run_task(&amp;roots_task);
1123   }
1124 
<span class="line-modified">1125 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
1126   DerivedPointerTable::update_pointers();
1127 #endif
1128 }
1129 
<span class="line-removed">1130 void ShenandoahHeap::roots_iterate(OopClosure* cl) {</span>
<span class="line-removed">1131   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);</span>
<span class="line-removed">1132 </span>
<span class="line-removed">1133   CodeBlobToOopClosure blobsCl(cl, false);</span>
<span class="line-removed">1134   CLDToOopClosure cldCl(cl, ClassLoaderData::_claim_strong);</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
<span class="line-removed">1137   rp.process_all_roots(cl, NULL, &amp;cldCl, &amp;blobsCl, NULL, 0);</span>
<span class="line-removed">1138 }</span>
<span class="line-removed">1139 </span>
1140 // Returns size in bytes
1141 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1142   if (ShenandoahElasticTLAB) {
1143     // With Elastic TLABs, return the max allowed size, and let the allocation path
1144     // figure out the safe size for current allocation.
1145     return ShenandoahHeapRegion::max_tlab_size_bytes();
1146   } else {
1147     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1148   }
1149 }
1150 
1151 size_t ShenandoahHeap::max_tlab_size() const {
1152   // Returns size in words
1153   return ShenandoahHeapRegion::max_tlab_size_words();
1154 }
1155 
1156 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1157 public:
1158   void do_thread(Thread* thread) {
1159     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
</pre>
<hr />
<pre>
1163     }
1164   }
1165 };
1166 
1167 void ShenandoahHeap::retire_and_reset_gclabs() {
1168   ShenandoahRetireAndResetGCLABClosure cl;
1169   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1170     cl.do_thread(t);
1171   }
1172   workers()-&gt;threads_do(&amp;cl);
1173 }
1174 
1175 void ShenandoahHeap::collect(GCCause::Cause cause) {
1176   control_thread()-&gt;request_gc(cause);
1177 }
1178 
1179 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1180   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1181 }
1182 
<span class="line-removed">1183 CollectorPolicy* ShenandoahHeap::collector_policy() const {</span>
<span class="line-removed">1184   return _shenandoah_policy;</span>
<span class="line-removed">1185 }</span>
<span class="line-removed">1186 </span>
1187 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
1188   Space* sp = heap_region_containing(addr);
1189   if (sp != NULL) {
1190     return sp-&gt;block_start(addr);
1191   }
1192   return NULL;
1193 }
1194 
1195 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
1196   Space* sp = heap_region_containing(addr);
1197   return sp-&gt;block_is_obj(addr);
1198 }
1199 




1200 jlong ShenandoahHeap::millis_since_last_gc() {
1201   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1202   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1203   return (jlong)v;
1204 }
1205 
1206 void ShenandoahHeap::prepare_for_verify() {
1207   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1208     make_parsable(false);
1209   }
1210 }
1211 
1212 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1213   workers()-&gt;print_worker_threads_on(st);
1214   if (ShenandoahStringDedup::is_enabled()) {
1215     ShenandoahStringDedup::print_worker_threads_on(st);
1216   }
1217 }
1218 
1219 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1220   workers()-&gt;threads_do(tcl);
<span class="line-modified">1221   _safepoint_workers-&gt;threads_do(tcl);</span>


1222   if (ShenandoahStringDedup::is_enabled()) {
1223     ShenandoahStringDedup::threads_do(tcl);
1224   }
1225 }
1226 
1227 void ShenandoahHeap::print_tracing_info() const {
1228   LogTarget(Info, gc, stats) lt;
1229   if (lt.is_enabled()) {
1230     ResourceMark rm;
1231     LogStream ls(lt);
1232 
1233     phase_timings()-&gt;print_on(&amp;ls);
1234 
1235     ls.cr();
1236     ls.cr();
1237 
1238     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1239 
1240     ls.cr();
1241     ls.cr();
</pre>
<hr />
<pre>
1263     } else {
1264       // TODO: Consider allocating verification bitmaps on demand,
1265       // and turn this on unconditionally.
1266     }
1267   }
1268 }
1269 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1270   return _free_set-&gt;capacity();
1271 }
1272 
1273 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1274 private:
1275   MarkBitMap* _bitmap;
1276   Stack&lt;oop,mtGC&gt;* _oop_stack;
1277 
1278   template &lt;class T&gt;
1279   void do_oop_work(T* p) {
1280     T o = RawAccess&lt;&gt;::oop_load(p);
1281     if (!CompressedOops::is_null(o)) {
1282       oop obj = CompressedOops::decode_not_null(o);
<span class="line-modified">1283       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>















1284       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<span class="line-modified">1285       if (!_bitmap-&gt;is_marked((HeapWord*) obj)) {</span>
<span class="line-modified">1286         _bitmap-&gt;mark((HeapWord*) obj);</span>
1287         _oop_stack-&gt;push(obj);
1288       }
1289     }
1290   }
1291 public:
1292   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1293     _bitmap(bitmap), _oop_stack(oop_stack) {}
1294   void do_oop(oop* p)       { do_oop_work(p); }
1295   void do_oop(narrowOop* p) { do_oop_work(p); }
1296 };
1297 
1298 /*
1299  * This is public API, used in preparation of object_iterate().
1300  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1301  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1302  * control, we call SH::make_tlabs_parsable().
1303  */
1304 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1305   // No-op.
1306 }
</pre>
<hr />
<pre>
1315  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1316  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1317  * wiped the bitmap in preparation for next marking).
1318  *
1319  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1320  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1321  * is allowed to report dead objects, but is not required to do so.
1322  */
1323 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1324   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1325   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1326     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1327     return;
1328   }
1329 
1330   // Reset bitmap
1331   _aux_bit_map.clear();
1332 
1333   Stack&lt;oop,mtGC&gt; oop_stack;
1334 
<span class="line-modified">1335   // First, we process all GC roots. This populates the work stack with initial objects.</span>
<span class="line-modified">1336   ShenandoahRootProcessor rp(this, 1, ShenandoahPhaseTimings::_num_phases);</span>
1337   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
<span class="line-modified">1338   CLDToOopClosure clds(&amp;oops, ClassLoaderData::_claim_none);</span>
<span class="line-modified">1339   CodeBlobToOopClosure blobs(&amp;oops, false);</span>
<span class="line-modified">1340   rp.process_all_roots(&amp;oops, &amp;oops, &amp;clds, &amp;blobs, NULL, 0);</span>





1341 
1342   // Work through the oop stack to traverse heap.
1343   while (! oop_stack.is_empty()) {
1344     oop obj = oop_stack.pop();
1345     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1346     cl-&gt;do_object(obj);
1347     obj-&gt;oop_iterate(&amp;oops);
1348   }
1349 
1350   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1351 
1352   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1353     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1354   }
1355 }
1356 
<span class="line-modified">1357 void ShenandoahHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-modified">1358   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);</span>
<span class="line-modified">1359   object_iterate(cl);</span>


1360 }
1361 
1362 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1363   for (size_t i = 0; i &lt; num_regions(); i++) {
1364     ShenandoahHeapRegion* current = get_region(i);
1365     blk-&gt;heap_region_do(current);
1366   }
1367 }
1368 
1369 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1370 private:
1371   ShenandoahHeap* const _heap;
1372   ShenandoahHeapRegionClosure* const _blk;
1373 
1374   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
1375   volatile size_t _index;
1376   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
1377 
1378 public:
1379   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1380           AbstractGangTask(&quot;Parallel Region Task&quot;),
1381           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1382 
1383   void work(uint worker_id) {
1384     size_t stride = ShenandoahParallelRegionStride;
1385 
1386     size_t max = _heap-&gt;num_regions();
1387     while (_index &lt; max) {
<span class="line-modified">1388       size_t cur = Atomic::add(stride, &amp;_index) - stride;</span>
1389       size_t start = cur;
1390       size_t end = MIN2(cur + stride, max);
1391       if (start &gt;= max) break;
1392 
1393       for (size_t i = cur; i &lt; end; i++) {
1394         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1395         _blk-&gt;heap_region_do(current);
1396       }
1397     }
1398   }
1399 };
1400 
1401 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1402   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1403   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1404     ShenandoahParallelHeapRegionTask task(blk);
1405     workers()-&gt;run_task(&amp;task);
1406   } else {
1407     heap_region_iterate(blk);
1408   }
</pre>
<hr />
<pre>
1491     } else {
1492       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1493       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1494              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1495     }
1496   }
1497 
1498   bool is_thread_safe() { return true; }
1499 };
1500 
1501 void ShenandoahHeap::op_final_mark() {
1502   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1503 
1504   // It is critical that we
1505   // evacuate roots right after finishing marking, so that we don&#39;t
1506   // get unmarked objects in the roots.
1507 
1508   if (!cancelled_gc()) {
1509     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1510 
<span class="line-modified">1511     if (has_forwarded_objects()) {</span>
<span class="line-modified">1512       concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-modified">1513     }</span>
1514 
<span class="line-modified">1515     stop_concurrent_marking();</span>
1516 















1517     {
1518       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);
<span class="line-removed">1519 </span>
<span class="line-removed">1520       // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-removed">1521       // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
1522       ShenandoahCompleteLivenessClosure cl;
1523       parallel_heap_region_iterate(&amp;cl);
1524     }
1525 

1526     {
<span class="line-modified">1527       ShenandoahGCPhase prepare_evac(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-removed">1528 </span>
1529       make_parsable(true);

1530 











1531       trash_cset_regions();

1532 
<span class="line-modified">1533       {</span>
<span class="line-modified">1534         ShenandoahHeapLocker locker(lock());</span>
<span class="line-modified">1535         _collection_set-&gt;clear();</span>
<span class="line-modified">1536         _free_set-&gt;clear();</span>


1537 
<span class="line-modified">1538         heuristics()-&gt;choose_collection_set(_collection_set);</span>
1539 
<span class="line-modified">1540         _free_set-&gt;rebuild();</span>
<span class="line-modified">1541       }</span>




1542     }
1543 
1544     // If collection set has candidates, start evacuation.
1545     // Otherwise, bypass the rest of the cycle.
1546     if (!collection_set()-&gt;is_empty()) {
1547       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1548 
1549       if (ShenandoahVerify) {
1550         verifier()-&gt;verify_before_evacuation();
1551       }
1552 
1553       set_evacuation_in_progress(true);
1554       // From here on, we need to update references.
1555       set_has_forwarded_objects(true);
1556 
<span class="line-modified">1557       evacuate_and_update_roots();</span>





1558 
1559       if (ShenandoahPacing) {
1560         pacer()-&gt;setup_for_evac();
1561       }















1562     } else {
1563       if (ShenandoahVerify) {
1564         verifier()-&gt;verify_after_concmark();
1565       }
1566 
1567       if (VerifyAfterGC) {
1568         Universe::verify();
1569       }
1570     }
1571 
1572   } else {


1573     concurrent_mark()-&gt;cancel();
<span class="line-modified">1574     stop_concurrent_marking();</span>
1575 
1576     if (process_references()) {
1577       // Abandon reference processing right away: pre-cleaning must have failed.
1578       ReferenceProcessor *rp = ref_processor();
1579       rp-&gt;disable_discovery();
1580       rp-&gt;abandon_partial_discovery();
1581       rp-&gt;verify_no_references_recorded();
1582     }
1583   }
1584 }
1585 
1586 void ShenandoahHeap::op_final_evac() {
1587   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1588 
1589   set_evacuation_in_progress(false);
1590 
<span class="line-modified">1591   retire_and_reset_gclabs();</span>



1592 
1593   if (ShenandoahVerify) {
1594     verifier()-&gt;verify_after_evacuation();
1595   }
1596 
1597   if (VerifyAfterGC) {
1598     Universe::verify();
1599   }
1600 }
1601 
1602 void ShenandoahHeap::op_conc_evac() {
1603   ShenandoahEvacuationTask task(this, _collection_set, true);
1604   workers()-&gt;run_task(&amp;task);
1605 }
1606 
1607 void ShenandoahHeap::op_stw_evac() {
1608   ShenandoahEvacuationTask task(this, _collection_set, false);
1609   workers()-&gt;run_task(&amp;task);
1610 }
1611 
1612 void ShenandoahHeap::op_updaterefs() {
1613   update_heap_references(true);
1614 }
1615 
1616 void ShenandoahHeap::op_cleanup() {
1617   free_set()-&gt;recycle_trash();
1618 }
1619 


































































































































































1620 void ShenandoahHeap::op_reset() {
1621   reset_mark_bitmap();
1622 }
1623 
1624 void ShenandoahHeap::op_preclean() {
1625   concurrent_mark()-&gt;preclean_weak_refs();
1626 }
1627 
1628 void ShenandoahHeap::op_init_traversal() {
1629   traversal_gc()-&gt;init_traversal_collection();
1630 }
1631 
1632 void ShenandoahHeap::op_traversal() {
1633   traversal_gc()-&gt;concurrent_traversal_collection();
1634 }
1635 
1636 void ShenandoahHeap::op_final_traversal() {
1637   traversal_gc()-&gt;final_traversal_collection();
1638 }
1639 
1640 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1641   ShenandoahMetricsSnapshot metrics;
1642   metrics.snap_before();
1643 
1644   full_gc()-&gt;do_it(cause);
1645   if (UseTLAB) {
1646     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1647     resize_all_tlabs();
1648   }
1649 
1650   metrics.snap_after();
<span class="line-removed">1651   metrics.print();</span>
1652 
<span class="line-modified">1653   if (metrics.is_good_progress(&quot;Full GC&quot;)) {</span>
1654     _progress_last_gc.set();
1655   } else {
1656     // Nothing to do. Tell the allocation path that we have failed to make
1657     // progress, and it can finally fail.
1658     _progress_last_gc.unset();
1659   }
1660 }
1661 
1662 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1663   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1664   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1665   // some phase, we have to upgrade the Degenerate GC to Full GC.
1666 
1667   clear_cancelled_gc();
1668 
1669   ShenandoahMetricsSnapshot metrics;
1670   metrics.snap_before();
1671 
1672   switch (point) {
1673     case _degenerated_traversal:
</pre>
<hr />
<pre>
1687       op_final_traversal();
1688       op_cleanup();
1689       return;
1690 
1691     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1692     // but enters it at different points, depending on which concurrent phase had
1693     // degenerated.
1694 
1695     case _degenerated_outside_cycle:
1696       // We have degenerated from outside the cycle, which means something is bad with
1697       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1698       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1699       // we can do the most aggressive degen cycle, which includes processing references and
1700       // class unloading, unless those features are explicitly disabled.
1701       //
1702       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1703       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1704       set_process_references(heuristics()-&gt;can_process_references());
1705       set_unload_classes(heuristics()-&gt;can_unload_classes());
1706 
<span class="line-modified">1707       if (heuristics()-&gt;can_do_traversal_gc()) {</span>
1708         // Not possible to degenerate from here, upgrade to Full GC right away.
1709         cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1710         op_degenerated_fail();
1711         return;
1712       }
1713 
1714       op_reset();
1715 
1716       op_init_mark();
1717       if (cancelled_gc()) {
1718         op_degenerated_fail();
1719         return;
1720       }
1721 
1722     case _degenerated_mark:
1723       op_final_mark();
1724       if (cancelled_gc()) {
1725         op_degenerated_fail();
1726         return;
1727       }
1728 
1729       op_cleanup();
1730 
1731     case _degenerated_evac:
1732       // If heuristics thinks we should do the cycle, this flag would be set,
1733       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1734       if (is_evacuation_in_progress()) {
1735 
1736         // Degeneration under oom-evac protocol might have left some objects in
1737         // collection set un-evacuated. Restart evacuation from the beginning to
1738         // capture all objects. For all the objects that are already evacuated,
1739         // it would be a simple check, which is supposed to be fast. This is also
1740         // safe to do even without degeneration, as CSet iterator is at beginning
1741         // in preparation for evacuation anyway.
<span class="line-modified">1742         collection_set()-&gt;clear_current_index();</span>






















1743 
1744         op_stw_evac();
1745         if (cancelled_gc()) {
1746           op_degenerated_fail();
1747           return;
1748         }
1749       }
1750 
1751       // If heuristics thinks we should do the cycle, this flag would be set,
1752       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1753       if (has_forwarded_objects()) {
1754         op_init_updaterefs();
1755         if (cancelled_gc()) {
1756           op_degenerated_fail();
1757           return;
1758         }
1759       }
1760 
1761     case _degenerated_updaterefs:
1762       if (has_forwarded_objects()) {
</pre>
<hr />
<pre>
1766           return;
1767         }
1768       }
1769 
1770       op_cleanup();
1771       break;
1772 
1773     default:
1774       ShouldNotReachHere();
1775   }
1776 
1777   if (ShenandoahVerify) {
1778     verifier()-&gt;verify_after_degenerated();
1779   }
1780 
1781   if (VerifyAfterGC) {
1782     Universe::verify();
1783   }
1784 
1785   metrics.snap_after();
<span class="line-removed">1786   metrics.print();</span>
1787 
1788   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
1789   // because that probably means the heap is overloaded and/or fragmented.
<span class="line-modified">1790   if (!metrics.is_good_progress(&quot;Degenerated GC&quot;)) {</span>
1791     _progress_last_gc.unset();
1792     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1793     op_degenerated_futile();
1794   } else {
1795     _progress_last_gc.set();
1796   }
1797 }
1798 
1799 void ShenandoahHeap::op_degenerated_fail() {
1800   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
1801   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1802   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1803 }
1804 
1805 void ShenandoahHeap::op_degenerated_futile() {
1806   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
1807   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
1808 }
1809 
<span class="line-removed">1810 void ShenandoahHeap::stop_concurrent_marking() {</span>
<span class="line-removed">1811   assert(is_concurrent_mark_in_progress(), &quot;How else could we get here?&quot;);</span>
<span class="line-removed">1812   if (!cancelled_gc()) {</span>
<span class="line-removed">1813     // If we needed to update refs, and concurrent marking has been cancelled,</span>
<span class="line-removed">1814     // we need to finish updating references.</span>
<span class="line-removed">1815     set_has_forwarded_objects(false);</span>
<span class="line-removed">1816     mark_complete_marking_context();</span>
<span class="line-removed">1817   }</span>
<span class="line-removed">1818   set_concurrent_mark_in_progress(false);</span>
<span class="line-removed">1819 }</span>
<span class="line-removed">1820 </span>
1821 void ShenandoahHeap::force_satb_flush_all_threads() {
1822   if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {
1823     // No need to flush SATBs
1824     return;
1825   }
1826 
1827   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1828     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
1829   }
1830   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
1831   // hurt to &quot;release&quot; the updates here anyway.
1832   OrderAccess::fence();
1833 }
1834 
1835 void ShenandoahHeap::set_gc_state_all_threads(char state) {
1836   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1837     ShenandoahThreadLocalData::set_gc_state(t, state);
1838   }
1839 }
1840 
1841 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
1842   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
1843   _gc_state.set_cond(mask, value);
1844   set_gc_state_all_threads(_gc_state.raw_value());
1845 }
1846 
1847 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
<span class="line-modified">1848   set_gc_state_mask(MARKING, in_progress);</span>




1849   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
1850 }
1851 
1852 void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
<span class="line-modified">1853    set_gc_state_mask(TRAVERSAL | HAS_FORWARDED, in_progress);</span>
1854    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
1855 }
1856 
1857 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
1858   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
1859   set_gc_state_mask(EVACUATION, in_progress);
1860 }
1861 
<span class="line-modified">1862 HeapWord* ShenandoahHeap::tlab_post_allocation_setup(HeapWord* obj) {</span>
<span class="line-modified">1863   // Initialize Brooks pointer for the next object</span>
<span class="line-modified">1864   HeapWord* result = obj + ShenandoahBrooksPointer::word_size();</span>
<span class="line-modified">1865   ShenandoahBrooksPointer::initialize(oop(result));</span>
<span class="line-modified">1866   return result;</span>
<span class="line-modified">1867 }</span>
<span class="line-removed">1868 </span>
<span class="line-removed">1869 ShenandoahForwardedIsAliveClosure::ShenandoahForwardedIsAliveClosure() :</span>
<span class="line-removed">1870   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">1871 }</span>
<span class="line-removed">1872 </span>
<span class="line-removed">1873 ShenandoahIsAliveClosure::ShenandoahIsAliveClosure() :</span>
<span class="line-removed">1874   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {</span>
<span class="line-removed">1875 }</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877 bool ShenandoahForwardedIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">1878   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">1879     return false;</span>
<span class="line-removed">1880   }</span>
<span class="line-removed">1881   obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed">1882   shenandoah_assert_not_forwarded_if(NULL, obj, ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress() || ShenandoahHeap::heap()-&gt;is_concurrent_traversal_in_progress());</span>
<span class="line-removed">1883   return _mark_context-&gt;is_marked(obj);</span>
<span class="line-removed">1884 }</span>
<span class="line-removed">1885 </span>
<span class="line-removed">1886 bool ShenandoahIsAliveClosure::do_object_b(oop obj) {</span>
<span class="line-removed">1887   if (CompressedOops::is_null(obj)) {</span>
<span class="line-removed">1888     return false;</span>
1889   }
<span class="line-removed">1890   shenandoah_assert_not_forwarded(NULL, obj);</span>
<span class="line-removed">1891   return _mark_context-&gt;is_marked(obj);</span>
1892 }
1893 
1894 void ShenandoahHeap::ref_processing_init() {
1895   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
1896 
1897   _ref_processor =
1898     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
1899                            ParallelRefProcEnabled,  // MT processing
1900                            _max_workers,            // Degree of MT processing
1901                            true,                    // MT discovery
1902                            _max_workers,            // Degree of MT discovery
1903                            false,                   // Reference discovery is not atomic
1904                            NULL,                    // No closure, should be installed before use
1905                            true);                   // Scale worker threads
1906 
1907   shenandoah_assert_rp_isalive_not_installed();
1908 }
1909 
1910 GCTracer* ShenandoahHeap::tracer() {
1911   return shenandoah_policy()-&gt;tracer();
1912 }
1913 
1914 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
1915   return _free_set-&gt;used();
1916 }
1917 
1918 bool ShenandoahHeap::try_cancel_gc() {
1919   while (true) {
1920     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
1921     if (prev == CANCELLABLE) return true;
1922     else if (prev == CANCELLED) return false;
1923     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
1924     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
<span class="line-modified">1925     {</span>
1926       // We need to provide a safepoint here, otherwise we might
1927       // spin forever if a SP is pending.
1928       ThreadBlockInVM sp(JavaThread::current());
1929       SpinPause();
1930     }
1931   }
1932 }
1933 
1934 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
1935   if (try_cancel_gc()) {
1936     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
1937     log_info(gc)(&quot;%s&quot;, msg.buffer());
1938     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
1939   }
1940 }
1941 
1942 uint ShenandoahHeap::max_workers() {
1943   return _max_workers;
1944 }
1945 
</pre>
<hr />
<pre>
1949   // Step 0. Notify policy to disable event recording.
1950   _shenandoah_policy-&gt;record_shutdown();
1951 
1952   // Step 1. Notify control thread that we are in shutdown.
1953   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
1954   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
1955   control_thread()-&gt;prepare_for_graceful_shutdown();
1956 
1957   // Step 2. Notify GC workers that we are cancelling GC.
1958   cancel_gc(GCCause::_shenandoah_stop_vm);
1959 
1960   // Step 3. Wait until GC worker exits normally.
1961   control_thread()-&gt;stop();
1962 
1963   // Step 4. Stop String Dedup thread if it is active
1964   if (ShenandoahStringDedup::is_enabled()) {
1965     ShenandoahStringDedup::stop();
1966   }
1967 }
1968 
<span class="line-modified">1969 void ShenandoahHeap::unload_classes_and_cleanup_tables(bool full_gc) {</span>
<span class="line-modified">1970   assert(heuristics()-&gt;can_unload_classes(), &quot;Class unloading should be enabled&quot;);</span>
<span class="line-removed">1971 </span>
<span class="line-removed">1972   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-removed">1973                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-removed">1974                                ShenandoahPhaseTimings::purge);</span>
<span class="line-removed">1975 </span>
<span class="line-removed">1976   ShenandoahIsAliveSelector alive;</span>
<span class="line-removed">1977   BoolObjectClosure* is_alive = alive.is_alive_closure();</span>
<span class="line-removed">1978 </span>
1979   bool purged_class;
1980 
1981   // Unload classes and purge SystemDictionary.
1982   {
1983     ShenandoahGCPhase phase(full_gc ?
1984                             ShenandoahPhaseTimings::full_gc_purge_class_unload :
1985                             ShenandoahPhaseTimings::purge_class_unload);
1986     purged_class = SystemDictionary::do_unloading(gc_timer());
1987   }
1988 
1989   {
1990     ShenandoahGCPhase phase(full_gc ?
1991                             ShenandoahPhaseTimings::full_gc_purge_par :
1992                             ShenandoahPhaseTimings::purge_par);
<span class="line-modified">1993     uint active = _workers-&gt;active_workers();</span>
<span class="line-modified">1994     ParallelCleaningTask unlink_task(is_alive, active, purged_class, true);</span>

1995     _workers-&gt;run_task(&amp;unlink_task);
1996   }
1997 
1998   {
1999     ShenandoahGCPhase phase(full_gc ?
<span class="line-modified">2000                       ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">2001                       ShenandoahPhaseTimings::purge_cldg);</span>
2002     ClassLoaderDataGraph::purge();
2003   }























































2004 }
2005 
2006 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<span class="line-modified">2007   set_gc_state_mask(HAS_FORWARDED, cond);</span>





2008 }
2009 
2010 void ShenandoahHeap::set_process_references(bool pr) {
2011   _process_references.set_cond(pr);
2012 }
2013 
2014 void ShenandoahHeap::set_unload_classes(bool uc) {
2015   _unload_classes.set_cond(uc);
2016 }
2017 
2018 bool ShenandoahHeap::process_references() const {
2019   return _process_references.is_set();
2020 }
2021 
2022 bool ShenandoahHeap::unload_classes() const {
2023   return _unload_classes.is_set();
2024 }
2025 
2026 address ShenandoahHeap::in_cset_fast_test_addr() {
2027   ShenandoahHeap* heap = ShenandoahHeap::heap();
2028   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2029   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2030 }
2031 
2032 address ShenandoahHeap::cancelled_gc_addr() {
2033   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2034 }
2035 
2036 address ShenandoahHeap::gc_state_addr() {
2037   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2038 }
2039 
2040 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
<span class="line-modified">2041   return OrderAccess::load_acquire(&amp;_bytes_allocated_since_gc_start);</span>
2042 }
2043 
2044 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
<span class="line-modified">2045   OrderAccess::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);</span>
2046 }
2047 
2048 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2049   _degenerated_gc_in_progress.set_cond(in_progress);
2050 }
2051 
2052 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2053   _full_gc_in_progress.set_cond(in_progress);
2054 }
2055 
2056 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2057   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2058   _full_gc_move_in_progress.set_cond(in_progress);
2059 }
2060 
2061 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2062   set_gc_state_mask(UPDATEREFS, in_progress);
2063 }
2064 
2065 void ShenandoahHeap::register_nmethod(nmethod* nm) {
<span class="line-modified">2066   ShenandoahCodeRoots::add_nmethod(nm);</span>
2067 }
2068 
2069 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
<span class="line-modified">2070   ShenandoahCodeRoots::remove_nmethod(nm);</span>




2071 }
2072 
2073 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
<span class="line-modified">2074   o = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(o);</span>
<span class="line-removed">2075   ShenandoahHeapLocker locker(lock());</span>
<span class="line-removed">2076   heap_region_containing(o)-&gt;make_pinned();</span>
2077   return o;
2078 }
2079 
2080 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
<span class="line-modified">2081   o = ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(o);</span>



2082   ShenandoahHeapLocker locker(lock());
<span class="line-modified">2083   heap_region_containing(o)-&gt;make_unpinned();</span>
















2084 }
2085 










2086 GCTimer* ShenandoahHeap::gc_timer() const {
2087   return _gc_timer;
2088 }
2089 





















2090 #ifdef ASSERT
2091 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2092   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2093 
2094   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
2095     if (UseDynamicNumberOfGCThreads ||
2096         (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2097       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2098     } else {
2099       // Use ParallelGCThreads inside safepoints
2100       assert(nworkers == ParallelGCThreads, &quot;Use ParalleGCThreads within safepoints&quot;);
2101     }
2102   } else {
2103     if (UseDynamicNumberOfGCThreads ||
2104         (FLAG_IS_DEFAULT(ConcGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2105       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2106     } else {
2107       // Use ConcGCThreads outside safepoints
2108       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2109     }
</pre>
<hr />
<pre>
2158         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));
2159       }
2160       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2161         return;
2162       }
2163       r = _regions-&gt;next();
2164     }
2165   }
2166 };
2167 
2168 void ShenandoahHeap::update_heap_references(bool concurrent) {
2169   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2170   workers()-&gt;run_task(&amp;task);
2171 }
2172 
2173 void ShenandoahHeap::op_init_updaterefs() {
2174   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2175 
2176   set_evacuation_in_progress(false);
2177 
<span class="line-modified">2178   retire_and_reset_gclabs();</span>



2179 
2180   if (ShenandoahVerify) {



2181     verifier()-&gt;verify_before_updaterefs();
2182   }
2183 
2184   set_update_refs_in_progress(true);
<span class="line-removed">2185   make_parsable(true);</span>
<span class="line-removed">2186   for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-removed">2187     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-removed">2188     r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-removed">2189   }</span>
2190 
<span class="line-modified">2191   // Reset iterator.</span>
<span class="line-modified">2192   _update_refs_iterator.reset();</span>










2193 
2194   if (ShenandoahPacing) {
2195     pacer()-&gt;setup_for_updaterefs();
2196   }
2197 }
2198 
2199 void ShenandoahHeap::op_final_updaterefs() {
2200   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2201 


2202   // Check if there is left-over work, and finish it
2203   if (_update_refs_iterator.has_next()) {
<span class="line-modified">2204     ShenandoahGCPhase final_work(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
2205 
2206     // Finish updating references where we left off.
2207     clear_cancelled_gc();
2208     update_heap_references(false);
2209   }
2210 
2211   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2212   // everything. On degenerated paths, cancelled gc would not be set anyway.
2213   if (cancelled_gc()) {
2214     clear_cancelled_gc();
2215   }
2216   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2217 
<span class="line-modified">2218   concurrent_mark()-&gt;update_roots(is_degenerated_gc_in_progress() ?</span>
<span class="line-modified">2219                                  ShenandoahPhaseTimings::degen_gc_update_roots:</span>
<span class="line-modified">2220                                  ShenandoahPhaseTimings::final_update_refs_roots);</span>


















2221 
<span class="line-modified">2222   ShenandoahGCPhase final_update_refs(ShenandoahPhaseTimings::final_update_refs_recycle);</span>



2223 
<span class="line-removed">2224   trash_cset_regions();</span>
2225   set_has_forwarded_objects(false);
2226   set_update_refs_in_progress(false);
2227 
2228   if (ShenandoahVerify) {
2229     verifier()-&gt;verify_after_updaterefs();
2230   }
2231 
2232   if (VerifyAfterGC) {
2233     Universe::verify();
2234   }
2235 
2236   {
2237     ShenandoahHeapLocker locker(lock());
2238     _free_set-&gt;rebuild();
2239   }
2240 }
2241 
2242 #ifdef ASSERT
2243 void ShenandoahHeap::assert_heaplock_owned_by_current_thread() {
2244   _lock.assert_owned_by_current_thread();
</pre>
<hr />
<pre>
2474 
2475 void ShenandoahHeap::entry_final_updaterefs() {
2476   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2477   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2478 
2479   static const char* msg = &quot;Pause Final Update Refs&quot;;
2480   GCTraceTime(Info, gc) time(msg, gc_timer());
2481   EventMark em(&quot;%s&quot;, msg);
2482 
2483   ShenandoahWorkerScope scope(workers(),
2484                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2485                               &quot;final reference update&quot;);
2486 
2487   op_final_updaterefs();
2488 }
2489 
2490 void ShenandoahHeap::entry_init_traversal() {
2491   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2492   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
2493 
<span class="line-modified">2494   static const char* msg = &quot;Pause Init Traversal&quot;;</span>
2495   GCTraceTime(Info, gc) time(msg, gc_timer());
2496   EventMark em(&quot;%s&quot;, msg);
2497 
2498   ShenandoahWorkerScope scope(workers(),
2499                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2500                               &quot;init traversal&quot;);
2501 
2502   op_init_traversal();
2503 }
2504 
2505 void ShenandoahHeap::entry_final_traversal() {
2506   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2507   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
2508 
<span class="line-modified">2509   static const char* msg = &quot;Pause Final Traversal&quot;;</span>
2510   GCTraceTime(Info, gc) time(msg, gc_timer());
2511   EventMark em(&quot;%s&quot;, msg);
2512 
2513   ShenandoahWorkerScope scope(workers(),
2514                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2515                               &quot;final traversal&quot;);
2516 
2517   op_final_traversal();
2518 }
2519 
2520 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2521   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2522   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2523 
2524   static const char* msg = &quot;Pause Full&quot;;
2525   GCTraceTime(Info, gc) time(msg, gc_timer(), cause, true);
2526   EventMark em(&quot;%s&quot;, msg);
2527 
2528   ShenandoahWorkerScope scope(workers(),
2529                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
</pre>
<hr />
<pre>
2578                               &quot;concurrent evacuation&quot;);
2579 
2580   try_inject_alloc_failure();
2581   op_conc_evac();
2582 }
2583 
2584 void ShenandoahHeap::entry_updaterefs() {
2585   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2586 
2587   static const char* msg = &quot;Concurrent update references&quot;;
2588   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2589   EventMark em(&quot;%s&quot;, msg);
2590 
2591   ShenandoahWorkerScope scope(workers(),
2592                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2593                               &quot;concurrent reference update&quot;);
2594 
2595   try_inject_alloc_failure();
2596   op_updaterefs();
2597 }
















2598 void ShenandoahHeap::entry_cleanup() {
2599   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);
2600 
2601   static const char* msg = &quot;Concurrent cleanup&quot;;
2602   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2603   EventMark em(&quot;%s&quot;, msg);
2604 
2605   // This phase does not use workers, no need for setup
2606 
2607   try_inject_alloc_failure();
2608   op_cleanup();
2609 }
2610 
2611 void ShenandoahHeap::entry_reset() {
2612   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_reset);
2613 
2614   static const char* msg = &quot;Concurrent reset&quot;;
2615   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2616   EventMark em(&quot;%s&quot;, msg);
2617 
</pre>
<hr />
<pre>
2625 
2626 void ShenandoahHeap::entry_preclean() {
2627   if (ShenandoahPreclean &amp;&amp; process_references()) {
2628     static const char* msg = &quot;Concurrent precleaning&quot;;
2629     GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2630     EventMark em(&quot;%s&quot;, msg);
2631 
2632     ShenandoahGCPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);
2633 
2634     ShenandoahWorkerScope scope(workers(),
2635                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2636                                 &quot;concurrent preclean&quot;,
2637                                 /* check_workers = */ false);
2638 
2639     try_inject_alloc_failure();
2640     op_preclean();
2641   }
2642 }
2643 
2644 void ShenandoahHeap::entry_traversal() {
<span class="line-modified">2645   static const char* msg = &quot;Concurrent traversal&quot;;</span>
2646   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2647   EventMark em(&quot;%s&quot;, msg);
2648 
2649   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2650 
2651   ShenandoahWorkerScope scope(workers(),
2652                               ShenandoahWorkerPolicy::calc_workers_for_conc_traversal(),
2653                               &quot;concurrent traversal&quot;);
2654 
2655   try_inject_alloc_failure();
2656   op_traversal();
2657 }
2658 
2659 void ShenandoahHeap::entry_uncommit(double shrink_before) {
2660   static const char *msg = &quot;Concurrent uncommit&quot;;
2661   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2662   EventMark em(&quot;%s&quot;, msg);
2663 
2664   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_uncommit);
2665 
</pre>
<hr />
<pre>
2794 
2795   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {
2796     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;
2797   } else if (update_refs &amp;&amp; proc_refs) {
2798     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;
2799   } else if (update_refs &amp;&amp; unload_cls) {
2800     return &quot;Concurrent marking (update refs) (unload classes)&quot;;
2801   } else if (proc_refs &amp;&amp; unload_cls) {
2802     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
2803   } else if (update_refs) {
2804     return &quot;Concurrent marking (update refs)&quot;;
2805   } else if (proc_refs) {
2806     return &quot;Concurrent marking (process weakrefs)&quot;;
2807   } else if (unload_cls) {
2808     return &quot;Concurrent marking (unload classes)&quot;;
2809   } else {
2810     return &quot;Concurrent marking&quot;;
2811   }
2812 }
2813 













































2814 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
2815   switch (point) {
2816     case _degenerated_unset:
2817       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
2818     case _degenerated_traversal:
2819       return &quot;Pause Degenerated GC (Traversal)&quot;;
2820     case _degenerated_outside_cycle:
2821       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
2822     case _degenerated_mark:
2823       return &quot;Pause Degenerated GC (Mark)&quot;;
2824     case _degenerated_evac:
2825       return &quot;Pause Degenerated GC (Evacuation)&quot;;
2826     case _degenerated_updaterefs:
2827       return &quot;Pause Degenerated GC (Update Refs)&quot;;
2828     default:
2829       ShouldNotReachHere();
2830       return &quot;ERROR&quot;;
2831   }
2832 }
2833 
</pre>
<hr />
<pre>
2838   for (uint i = 0; i &lt; num_regions(); i++) {
2839     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
2840   }
2841 #endif
2842   return _liveness_cache[worker_id];
2843 }
2844 
2845 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
2846   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
2847   assert(_liveness_cache != NULL, &quot;sanity&quot;);
2848   jushort* ld = _liveness_cache[worker_id];
2849   for (uint i = 0; i &lt; num_regions(); i++) {
2850     ShenandoahHeapRegion* r = get_region(i);
2851     jushort live = ld[i];
2852     if (live &gt; 0) {
2853       r-&gt;increase_live_data_gc_words(live);
2854       ld[i] = 0;
2855     }
2856   }
2857 }
<span class="line-removed">2858 </span>
<span class="line-removed">2859 size_t ShenandoahHeap::obj_size(oop obj) const {</span>
<span class="line-removed">2860   return CollectedHeap::obj_size(obj) + ShenandoahBrooksPointer::word_size();</span>
<span class="line-removed">2861 }</span>
<span class="line-removed">2862 </span>
<span class="line-removed">2863 ptrdiff_t ShenandoahHeap::cell_header_size() const {</span>
<span class="line-removed">2864   return ShenandoahBrooksPointer::byte_size();</span>
<span class="line-removed">2865 }</span>
<span class="line-removed">2866 </span>
<span class="line-removed">2867 BoolObjectClosure* ShenandoahIsAliveSelector::is_alive_closure() {</span>
<span class="line-removed">2868   return ShenandoahHeap::heap()-&gt;has_forwarded_objects() ? reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_fwd_alive_cl)</span>
<span class="line-removed">2869                                                          : reinterpret_cast&lt;BoolObjectClosure*&gt;(&amp;_alive_cl);</span>
<span class="line-removed">2870 }</span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.hpp&quot;
<span class="line-added">  27 #include &quot;memory/universe.hpp&quot;</span>
  28 
<span class="line-added">  29 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-added">  32 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
  33 #include &quot;gc/shared/memAllocator.hpp&quot;
<span class="line-modified">  34 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  35 #include &quot;gc/shared/plab.hpp&quot;
  36 
  37 #include &quot;gc/shenandoah/shenandoahAllocTracker.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-modified">  39 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
  40 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
<span class="line-added">  43 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
  44 #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  51 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  52 #include &quot;gc/shenandoah/shenandoahMemoryPool.hpp&quot;
  53 #include &quot;gc/shenandoah/shenandoahMetrics.hpp&quot;
  54 #include &quot;gc/shenandoah/shenandoahMonitoringSupport.hpp&quot;
<span class="line-added">  55 #include &quot;gc/shenandoah/shenandoahNormalMode.hpp&quot;</span>
  56 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
  57 #include &quot;gc/shenandoah/shenandoahPacer.inline.hpp&quot;
<span class="line-modified">  58 #include &quot;gc/shenandoah/shenandoahParallelCleaning.inline.hpp&quot;</span>
<span class="line-added">  59 #include &quot;gc/shenandoah/shenandoahPassiveMode.hpp&quot;</span>
<span class="line-added">  60 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
  61 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
<span class="line-added">  62 #include &quot;gc/shenandoah/shenandoahTaskqueue.hpp&quot;</span>
<span class="line-added">  63 #include &quot;gc/shenandoah/shenandoahTraversalMode.hpp&quot;</span>
  64 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  65 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  66 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  67 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  68 #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  69 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
<span class="line-modified">  70 #if INCLUDE_JFR</span>
<span class="line-modified">  71 #include &quot;gc/shenandoah/shenandoahJfrSupport.hpp&quot;</span>
<span class="line-modified">  72 #endif</span>



  73 
  74 #include &quot;memory/metaspace.hpp&quot;
<span class="line-added">  75 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
<span class="line-added">  76 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  77 #include &quot;runtime/globals.hpp&quot;</span>
  78 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
<span class="line-added">  79 #include &quot;runtime/orderAccess.hpp&quot;</span>
  80 #include &quot;runtime/safepointMechanism.hpp&quot;
  81 #include &quot;runtime/vmThread.hpp&quot;
  82 #include &quot;services/mallocTracker.hpp&quot;
<span class="line-modified">  83 #include &quot;utilities/powerOfTwo.hpp&quot;</span>

  84 
  85 #ifdef ASSERT
  86 template &lt;class T&gt;
  87 void ShenandoahAssertToSpaceClosure::do_oop_work(T* p) {
  88   T o = RawAccess&lt;&gt;::oop_load(p);
  89   if (! CompressedOops::is_null(o)) {
  90     oop obj = CompressedOops::decode_not_null(o);
  91     shenandoah_assert_not_forwarded(p, obj);
  92   }
  93 }
  94 
  95 void ShenandoahAssertToSpaceClosure::do_oop(narrowOop* p) { do_oop_work(p); }
  96 void ShenandoahAssertToSpaceClosure::do_oop(oop* p)       { do_oop_work(p); }
  97 #endif
  98 
  99 class ShenandoahPretouchHeapTask : public AbstractGangTask {
 100 private:
 101   ShenandoahRegionIterator _regions;
 102   const size_t _page_size;
 103 public:
</pre>
<hr />
<pre>
 125     AbstractGangTask(&quot;Shenandoah Pretouch Bitmap&quot;),
 126     _bitmap_base(bitmap_base),
 127     _bitmap_size(bitmap_size),
 128     _page_size(page_size) {}
 129 
 130   virtual void work(uint worker_id) {
 131     ShenandoahHeapRegion* r = _regions.next();
 132     while (r != NULL) {
 133       size_t start = r-&gt;region_number()       * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 134       size_t end   = (r-&gt;region_number() + 1) * ShenandoahHeapRegion::region_size_bytes() / MarkBitMap::heap_map_factor();
 135       assert (end &lt;= _bitmap_size, &quot;end is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT, end, _bitmap_size);
 136 
 137       os::pretouch_memory(_bitmap_base + start, _bitmap_base + end, _page_size);
 138 
 139       r = _regions.next();
 140     }
 141   }
 142 };
 143 
 144 jint ShenandoahHeap::initialize() {


 145   initialize_heuristics();
 146 
 147   //
 148   // Figure out heap sizing
 149   //
 150 
<span class="line-modified"> 151   size_t init_byte_size = InitialHeapSize;</span>
<span class="line-modified"> 152   size_t min_byte_size  = MinHeapSize;</span>
<span class="line-modified"> 153   size_t max_byte_size  = MaxHeapSize;</span>
<span class="line-added"> 154   size_t heap_alignment = HeapAlignment;</span>
 155 
 156   size_t reg_size_bytes = ShenandoahHeapRegion::region_size_bytes();
 157 
 158   if (ShenandoahAlwaysPreTouch) {
 159     // Enabled pre-touch means the entire heap is committed right away.
 160     init_byte_size = max_byte_size;
 161   }
 162 
 163   Universe::check_alignment(max_byte_size,  reg_size_bytes, &quot;Shenandoah heap&quot;);
 164   Universe::check_alignment(init_byte_size, reg_size_bytes, &quot;Shenandoah heap&quot;);
 165 
 166   _num_regions = ShenandoahHeapRegion::region_count();
 167 
 168   size_t num_committed_regions = init_byte_size / reg_size_bytes;
 169   num_committed_regions = MIN2(num_committed_regions, _num_regions);
 170   assert(num_committed_regions &lt;= _num_regions, &quot;sanity&quot;);

 171   _initial_size = num_committed_regions * reg_size_bytes;
<span class="line-added"> 172 </span>
<span class="line-added"> 173   size_t num_min_regions = min_byte_size / reg_size_bytes;</span>
<span class="line-added"> 174   num_min_regions = MIN2(num_min_regions, _num_regions);</span>
<span class="line-added"> 175   assert(num_min_regions &lt;= _num_regions, &quot;sanity&quot;);</span>
<span class="line-added"> 176   _minimum_size = num_min_regions * reg_size_bytes;</span>
<span class="line-added"> 177 </span>
 178   _committed = _initial_size;
 179 
 180   size_t heap_page_size   = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 181   size_t bitmap_page_size = UseLargePages ? (size_t)os::large_page_size() : (size_t)os::vm_page_size();
 182 
 183   //
 184   // Reserve and commit memory for heap
 185   //
 186 
<span class="line-modified"> 187   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment);</span>
<span class="line-modified"> 188   initialize_reserved_region(heap_rs);</span>
 189   _heap_region = MemRegion((HeapWord*)heap_rs.base(), heap_rs.size() / HeapWordSize);
 190   _heap_region_special = heap_rs.special();
 191 
 192   assert((((size_t) base()) &amp; ShenandoahHeapRegion::region_size_bytes_mask()) == 0,
 193          &quot;Misaligned heap: &quot; PTR_FORMAT, p2i(base()));
 194 
<span class="line-added"> 195 #if SHENANDOAH_OPTIMIZED_OBJTASK</span>
<span class="line-added"> 196   // The optimized ObjArrayChunkedTask takes some bits away from the full object bits.</span>
<span class="line-added"> 197   // Fail if we ever attempt to address more than we can.</span>
<span class="line-added"> 198   if ((uintptr_t)heap_rs.end() &gt;= ObjArrayChunkedTask::max_addressable()) {</span>
<span class="line-added"> 199     FormatBuffer&lt;512&gt; buf(&quot;Shenandoah reserved [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT&quot;) for the heap, \n&quot;</span>
<span class="line-added"> 200                           &quot;but max object address is &quot; PTR_FORMAT &quot;. Try to reduce heap size, or try other \n&quot;</span>
<span class="line-added"> 201                           &quot;VM options that allocate heap at lower addresses (HeapBaseMinAddress, AllocateHeapAt, etc).&quot;,</span>
<span class="line-added"> 202                 p2i(heap_rs.base()), p2i(heap_rs.end()), ObjArrayChunkedTask::max_addressable());</span>
<span class="line-added"> 203     vm_exit_during_initialization(&quot;Fatal Error&quot;, buf);</span>
<span class="line-added"> 204   }</span>
<span class="line-added"> 205 #endif</span>
<span class="line-added"> 206 </span>
 207   ReservedSpace sh_rs = heap_rs.first_part(max_byte_size);
 208   if (!_heap_region_special) {
 209     os::commit_memory_or_exit(sh_rs.base(), _initial_size, heap_alignment, false,
 210                               &quot;Cannot commit heap memory&quot;);
 211   }
 212 
 213   //
 214   // Reserve and commit memory for bitmap(s)
 215   //
 216 
 217   _bitmap_size = MarkBitMap::compute_size(heap_rs.size());
 218   _bitmap_size = align_up(_bitmap_size, bitmap_page_size);
 219 
 220   size_t bitmap_bytes_per_region = reg_size_bytes / MarkBitMap::heap_map_factor();
 221 
 222   guarantee(bitmap_bytes_per_region != 0,
 223             &quot;Bitmap bytes per region should not be zero&quot;);
 224   guarantee(is_power_of_2(bitmap_bytes_per_region),
 225             &quot;Bitmap bytes per region should be power of two: &quot; SIZE_FORMAT, bitmap_bytes_per_region);
 226 
</pre>
<hr />
<pre>
 263     }
 264     MemTracker::record_virtual_memory_type(verify_bitmap.base(), mtGC);
 265     MemRegion verify_bitmap_region = MemRegion((HeapWord *) verify_bitmap.base(), verify_bitmap.size() / HeapWordSize);
 266     _verification_bit_map.initialize(_heap_region, verify_bitmap_region);
 267     _verifier = new ShenandoahVerifier(this, &amp;_verification_bit_map);
 268   }
 269 
 270   // Reserve aux bitmap for use in object_iterate(). We don&#39;t commit it here.
 271   ReservedSpace aux_bitmap(_bitmap_size, bitmap_page_size);
 272   MemTracker::record_virtual_memory_type(aux_bitmap.base(), mtGC);
 273   _aux_bitmap_region = MemRegion((HeapWord*) aux_bitmap.base(), aux_bitmap.size() / HeapWordSize);
 274   _aux_bitmap_region_special = aux_bitmap.special();
 275   _aux_bit_map.initialize(_heap_region, _aux_bitmap_region);
 276 
 277   //
 278   // Create regions and region sets
 279   //
 280 
 281   _regions = NEW_C_HEAP_ARRAY(ShenandoahHeapRegion*, _num_regions, mtGC);
 282   _free_set = new ShenandoahFreeSet(this, _num_regions);
<span class="line-modified"> 283   _collection_set = new ShenandoahCollectionSet(this, sh_rs.base(), sh_rs.size());</span>
 284 
 285   {
 286     ShenandoahHeapLocker locker(lock());
 287 
 288     size_t size_words = ShenandoahHeapRegion::region_size_words();
 289 
 290     for (size_t i = 0; i &lt; _num_regions; i++) {
 291       HeapWord* start = (HeapWord*)sh_rs.base() + size_words * i;
 292       bool is_committed = i &lt; num_committed_regions;
 293       ShenandoahHeapRegion* r = new ShenandoahHeapRegion(this, start, size_words, i, is_committed);
 294 
 295       _marking_context-&gt;initialize_top_at_mark_start(r);
 296       _regions[i] = r;
 297       assert(!collection_set()-&gt;is_in(i), &quot;New region should not be in collection set&quot;);
 298     }
 299 
 300     // Initialize to complete
 301     _marking_context-&gt;mark_complete();
 302 
 303     _free_set-&gt;rebuild();
</pre>
<hr />
<pre>
 331                        _num_regions, pretouch_bitmap_page_size);
 332     ShenandoahPretouchBitmapTask bcl(bitmap.base(), _bitmap_size, pretouch_bitmap_page_size);
 333     _workers-&gt;run_task(&amp;bcl);
 334 
 335     log_info(gc, init)(&quot;Pretouch heap: &quot; SIZE_FORMAT &quot; regions, &quot; SIZE_FORMAT &quot; bytes page&quot;,
 336                        _num_regions, pretouch_heap_page_size);
 337     ShenandoahPretouchHeapTask hcl(pretouch_heap_page_size);
 338     _workers-&gt;run_task(&amp;hcl);
 339   }
 340 
 341   //
 342   // Initialize the rest of GC subsystems
 343   //
 344 
 345   _liveness_cache = NEW_C_HEAP_ARRAY(jushort*, _max_workers, mtGC);
 346   for (uint worker = 0; worker &lt; _max_workers; worker++) {
 347     _liveness_cache[worker] = NEW_C_HEAP_ARRAY(jushort, _num_regions, mtGC);
 348     Copy::fill_to_bytes(_liveness_cache[worker], _num_regions * sizeof(jushort));
 349   }
 350 
<span class="line-modified"> 351   // There should probably be Shenandoah-specific options for these,</span>
<span class="line-modified"> 352   // just as there are G1-specific options.</span>
<span class="line-modified"> 353   {</span>
<span class="line-modified"> 354     ShenandoahSATBMarkQueueSet&amp; satbqs = ShenandoahBarrierSet::satb_mark_queue_set();</span>
<span class="line-modified"> 355     satbqs.set_process_completed_buffers_threshold(20); // G1SATBProcessCompletedThreshold</span>
<span class="line-modified"> 356     satbqs.set_buffer_enqueue_threshold_percentage(60); // G1SATBBufferEnqueueingThresholdPercent</span>
<span class="line-added"> 357   }</span>
 358 
 359   _monitoring_support = new ShenandoahMonitoringSupport(this);
 360   _phase_timings = new ShenandoahPhaseTimings();
 361   ShenandoahStringDedup::initialize();
 362   ShenandoahCodeRoots::initialize();
 363 
 364   if (ShenandoahAllocationTrace) {
 365     _alloc_tracker = new ShenandoahAllocTracker();
 366   }
 367 
 368   if (ShenandoahPacing) {
 369     _pacer = new ShenandoahPacer(this);
 370     _pacer-&gt;setup_for_idle();
 371   } else {
 372     _pacer = NULL;
 373   }
 374 
<span class="line-modified"> 375   _traversal_gc = strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0 ?</span>
 376                   new ShenandoahTraversalGC(this, _num_regions) :
 377                   NULL;
 378 
 379   _control_thread = new ShenandoahControlThread();
 380 
<span class="line-modified"> 381   log_info(gc, init)(&quot;Initialize Shenandoah heap: &quot; SIZE_FORMAT &quot;%s initial, &quot; SIZE_FORMAT &quot;%s min, &quot; SIZE_FORMAT &quot;%s max&quot;,</span>
<span class="line-modified"> 382                      byte_size_in_proper_unit(_initial_size),  proper_unit_for_byte_size(_initial_size),</span>
<span class="line-added"> 383                      byte_size_in_proper_unit(_minimum_size),  proper_unit_for_byte_size(_minimum_size),</span>
<span class="line-added"> 384                      byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity())</span>
<span class="line-added"> 385   );</span>
 386 
 387   log_info(gc, init)(&quot;Safepointing mechanism: %s&quot;,
 388                      SafepointMechanism::uses_thread_local_poll() ? &quot;thread-local poll&quot; :
 389                      (SafepointMechanism::uses_global_page_poll() ? &quot;global-page poll&quot; : &quot;unknown&quot;));
 390 
 391   return JNI_OK;
 392 }
 393 
 394 void ShenandoahHeap::initialize_heuristics() {
<span class="line-modified"> 395   if (ShenandoahGCMode != NULL) {</span>
<span class="line-modified"> 396     if (strcmp(ShenandoahGCMode, &quot;traversal&quot;) == 0) {</span>
<span class="line-modified"> 397       _gc_mode = new ShenandoahTraversalMode();</span>
<span class="line-modified"> 398     } else if (strcmp(ShenandoahGCMode, &quot;normal&quot;) == 0) {</span>
<span class="line-modified"> 399       _gc_mode = new ShenandoahNormalMode();</span>
<span class="line-modified"> 400     } else if (strcmp(ShenandoahGCMode, &quot;passive&quot;) == 0) {</span>
<span class="line-modified"> 401       _gc_mode = new ShenandoahPassiveMode();</span>






 402     } else {
<span class="line-modified"> 403       vm_exit_during_initialization(&quot;Unknown -XX:ShenandoahGCMode option&quot;);</span>
 404     }

















 405   } else {
<span class="line-modified"> 406     ShouldNotReachHere();</span>
 407   }
<span class="line-added"> 408   _gc_mode-&gt;initialize_flags();</span>
<span class="line-added"> 409   _heuristics = _gc_mode-&gt;initialize_heuristics();</span>
 410 
<span class="line-added"> 411   if (_heuristics-&gt;is_diagnostic() &amp;&amp; !UnlockDiagnosticVMOptions) {</span>
<span class="line-added"> 412     vm_exit_during_initialization(</span>
<span class="line-added"> 413             err_msg(&quot;Heuristics \&quot;%s\&quot; is diagnostic, and must be enabled via -XX:+UnlockDiagnosticVMOptions.&quot;,</span>
<span class="line-added"> 414                     _heuristics-&gt;name()));</span>
<span class="line-added"> 415   }</span>
<span class="line-added"> 416   if (_heuristics-&gt;is_experimental() &amp;&amp; !UnlockExperimentalVMOptions) {</span>
<span class="line-added"> 417     vm_exit_during_initialization(</span>
<span class="line-added"> 418             err_msg(&quot;Heuristics \&quot;%s\&quot; is experimental, and must be enabled via -XX:+UnlockExperimentalVMOptions.&quot;,</span>
<span class="line-added"> 419                     _heuristics-&gt;name()));</span>
<span class="line-added"> 420   }</span>
<span class="line-added"> 421   log_info(gc, init)(&quot;Shenandoah heuristics: %s&quot;,</span>
<span class="line-added"> 422                      _heuristics-&gt;name());</span>
 423 }
 424 
 425 #ifdef _MSC_VER
 426 #pragma warning( push )
 427 #pragma warning( disable:4355 ) // &#39;this&#39; : used in base member initializer list
 428 #endif
 429 
 430 ShenandoahHeap::ShenandoahHeap(ShenandoahCollectorPolicy* policy) :
 431   CollectedHeap(),
 432   _initial_size(0),
 433   _used(0),
 434   _committed(0),
 435   _bytes_allocated_since_gc_start(0),
 436   _max_workers(MAX2(ConcGCThreads, ParallelGCThreads)),
 437   _workers(NULL),
 438   _safepoint_workers(NULL),
 439   _heap_region_special(false),
 440   _num_regions(0),
 441   _regions(NULL),
 442   _update_refs_iterator(this),
 443   _control_thread(NULL),
 444   _shenandoah_policy(policy),
 445   _heuristics(NULL),
 446   _free_set(NULL),
 447   _scm(new ShenandoahConcurrentMark()),
 448   _traversal_gc(NULL),
 449   _full_gc(new ShenandoahMarkCompact()),
 450   _pacer(NULL),
 451   _verifier(NULL),
 452   _alloc_tracker(NULL),
 453   _phase_timings(NULL),
 454   _monitoring_support(NULL),
 455   _memory_pool(NULL),
 456   _stw_memory_manager(&quot;Shenandoah Pauses&quot;, &quot;end of GC pause&quot;),
 457   _cycle_memory_manager(&quot;Shenandoah Cycles&quot;, &quot;end of GC cycle&quot;),
 458   _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),
 459   _soft_ref_policy(),
<span class="line-added"> 460   _log_min_obj_alignment_in_bytes(LogMinObjAlignmentInBytes),</span>
 461   _ref_processor(NULL),
 462   _marking_context(NULL),
 463   _bitmap_size(0),
 464   _bitmap_regions_per_slice(0),
 465   _bitmap_bytes_per_slice(0),
 466   _bitmap_region_special(false),
 467   _aux_bitmap_region_special(false),
 468   _liveness_cache(NULL),
 469   _collection_set(NULL)
 470 {
 471   log_info(gc, init)(&quot;GC threads: &quot; UINT32_FORMAT &quot; parallel, &quot; UINT32_FORMAT &quot; concurrent&quot;, ParallelGCThreads, ConcGCThreads);
 472   log_info(gc, init)(&quot;Reference processing: %s&quot;, ParallelRefProcEnabled ? &quot;parallel&quot; : &quot;serial&quot;);
 473 
 474   BarrierSet::set_barrier_set(new ShenandoahBarrierSet(this));
 475 
 476   _max_workers = MAX2(_max_workers, 1U);
 477   _workers = new ShenandoahWorkGang(&quot;Shenandoah GC Threads&quot;, _max_workers,
<span class="line-modified"> 478                             /* are_GC_task_threads */ true,</span>
<span class="line-modified"> 479                             /* are_ConcurrentGC_threads */ true);</span>
 480   if (_workers == NULL) {
 481     vm_exit_during_initialization(&quot;Failed necessary allocation.&quot;);
 482   } else {
 483     _workers-&gt;initialize_workers();
 484   }
 485 
 486   if (ShenandoahParallelSafepointThreads &gt; 1) {
 487     _safepoint_workers = new ShenandoahWorkGang(&quot;Safepoint Cleanup Thread&quot;,
 488                                                 ShenandoahParallelSafepointThreads,
<span class="line-modified"> 489                       /* are_GC_task_threads */ false,</span>
<span class="line-added"> 490                  /* are_ConcurrentGC_threads */ false);</span>
 491     _safepoint_workers-&gt;initialize_workers();
 492   }
 493 }
 494 
 495 #ifdef _MSC_VER
 496 #pragma warning( pop )
 497 #endif
 498 
 499 class ShenandoahResetBitmapTask : public AbstractGangTask {
 500 private:
 501   ShenandoahRegionIterator _regions;
 502 
 503 public:
 504   ShenandoahResetBitmapTask() :
 505     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {}
 506 
 507   void work(uint worker_id) {
 508     ShenandoahHeapRegion* region = _regions.next();
 509     ShenandoahHeap* heap = ShenandoahHeap::heap();
 510     ShenandoahMarkingContext* const ctx = heap-&gt;marking_context();
 511     while (region != NULL) {
 512       if (heap-&gt;is_bitmap_slice_committed(region)) {
 513         ctx-&gt;clear_bitmap(region);
 514       }
 515       region = _regions.next();
 516     }
 517   }
 518 };
 519 
 520 void ShenandoahHeap::reset_mark_bitmap() {
 521   assert_gc_workers(_workers-&gt;active_workers());
 522   mark_incomplete_marking_context();
 523 
 524   ShenandoahResetBitmapTask task;
 525   _workers-&gt;run_task(&amp;task);
 526 }
 527 
 528 void ShenandoahHeap::print_on(outputStream* st) const {
 529   st-&gt;print_cr(&quot;Shenandoah Heap&quot;);
<span class="line-modified"> 530   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot;%s total, &quot; SIZE_FORMAT &quot;%s committed, &quot; SIZE_FORMAT &quot;%s used&quot;,</span>
<span class="line-modified"> 531                byte_size_in_proper_unit(max_capacity()), proper_unit_for_byte_size(max_capacity()),</span>
<span class="line-modified"> 532                byte_size_in_proper_unit(committed()),    proper_unit_for_byte_size(committed()),</span>
<span class="line-modified"> 533                byte_size_in_proper_unit(used()),         proper_unit_for_byte_size(used()));</span>
<span class="line-added"> 534   st-&gt;print_cr(&quot; &quot; SIZE_FORMAT &quot; x &quot; SIZE_FORMAT&quot;%s regions&quot;,</span>
<span class="line-added"> 535                num_regions(),</span>
<span class="line-added"> 536                byte_size_in_proper_unit(ShenandoahHeapRegion::region_size_bytes()),</span>
<span class="line-added"> 537                proper_unit_for_byte_size(ShenandoahHeapRegion::region_size_bytes()));</span>
 538 
 539   st-&gt;print(&quot;Status: &quot;);
 540   if (has_forwarded_objects())               st-&gt;print(&quot;has forwarded objects, &quot;);
 541   if (is_concurrent_mark_in_progress())      st-&gt;print(&quot;marking, &quot;);
 542   if (is_evacuation_in_progress())           st-&gt;print(&quot;evacuating, &quot;);
 543   if (is_update_refs_in_progress())          st-&gt;print(&quot;updating refs, &quot;);
 544   if (is_concurrent_traversal_in_progress()) st-&gt;print(&quot;traversal, &quot;);
 545   if (is_degenerated_gc_in_progress())       st-&gt;print(&quot;degenerated gc, &quot;);
 546   if (is_full_gc_in_progress())              st-&gt;print(&quot;full gc, &quot;);
 547   if (is_full_gc_move_in_progress())         st-&gt;print(&quot;full gc move, &quot;);
<span class="line-added"> 548   if (is_concurrent_root_in_progress())      st-&gt;print(&quot;concurrent roots, &quot;);</span>
 549 
 550   if (cancelled_gc()) {
 551     st-&gt;print(&quot;cancelled&quot;);
 552   } else {
 553     st-&gt;print(&quot;not cancelled&quot;);
 554   }
 555   st-&gt;cr();
 556 
 557   st-&gt;print_cr(&quot;Reserved region:&quot;);
 558   st-&gt;print_cr(&quot; - [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;,
 559                p2i(reserved_region().start()),
 560                p2i(reserved_region().end()));
 561 
<span class="line-added"> 562   ShenandoahCollectionSet* cset = collection_set();</span>
<span class="line-added"> 563   st-&gt;print_cr(&quot;Collection set:&quot;);</span>
<span class="line-added"> 564   if (cset != NULL) {</span>
<span class="line-added"> 565     st-&gt;print_cr(&quot; - map (vanilla): &quot; PTR_FORMAT, p2i(cset-&gt;map_address()));</span>
<span class="line-added"> 566     st-&gt;print_cr(&quot; - map (biased):  &quot; PTR_FORMAT, p2i(cset-&gt;biased_map_address()));</span>
<span class="line-added"> 567   } else {</span>
<span class="line-added"> 568     st-&gt;print_cr(&quot; (NULL)&quot;);</span>
<span class="line-added"> 569   }</span>
<span class="line-added"> 570 </span>
 571   st-&gt;cr();
 572   MetaspaceUtils::print_on(st);
 573 
 574   if (Verbose) {
 575     print_heap_regions_on(st);
 576   }
 577 }
 578 
 579 class ShenandoahInitWorkerGCLABClosure : public ThreadClosure {
 580 public:
 581   void do_thread(Thread* thread) {
 582     assert(thread != NULL, &quot;Sanity&quot;);
 583     assert(thread-&gt;is_Worker_thread(), &quot;Only worker thread expected&quot;);
 584     ShenandoahThreadLocalData::initialize_gclab(thread);
 585   }
 586 };
 587 
 588 void ShenandoahHeap::post_initialize() {
 589   CollectedHeap::post_initialize();
 590   MutexLocker ml(Threads_lock);
 591 
 592   ShenandoahInitWorkerGCLABClosure init_gclabs;
 593   _workers-&gt;threads_do(&amp;init_gclabs);
 594 
 595   // gclab can not be initialized early during VM startup, as it can not determinate its max_size.
 596   // Now, we will let WorkGang to initialize gclab when new worker is created.
 597   _workers-&gt;set_initialize_gclab();
 598 
 599   _scm-&gt;initialize(_max_workers);
 600   _full_gc-&gt;initialize(_gc_timer);
 601 
 602   ref_processing_init();
 603 
 604   _heuristics-&gt;initialize();
<span class="line-added"> 605 </span>
<span class="line-added"> 606   JFR_ONLY(ShenandoahJFRSupport::register_jfr_type_serializers());</span>
 607 }
 608 
 609 size_t ShenandoahHeap::used() const {
<span class="line-modified"> 610   return Atomic::load_acquire(&amp;_used);</span>
 611 }
 612 
 613 size_t ShenandoahHeap::committed() const {
 614   OrderAccess::acquire();
 615   return _committed;
 616 }
 617 
 618 void ShenandoahHeap::increase_committed(size_t bytes) {
 619   assert_heaplock_or_safepoint();
 620   _committed += bytes;
 621 }
 622 
 623 void ShenandoahHeap::decrease_committed(size_t bytes) {
 624   assert_heaplock_or_safepoint();
 625   _committed -= bytes;
 626 }
 627 
 628 void ShenandoahHeap::increase_used(size_t bytes) {
<span class="line-modified"> 629   Atomic::add(&amp;_used, bytes);</span>
 630 }
 631 
 632 void ShenandoahHeap::set_used(size_t bytes) {
<span class="line-modified"> 633   Atomic::release_store_fence(&amp;_used, bytes);</span>
 634 }
 635 
 636 void ShenandoahHeap::decrease_used(size_t bytes) {
 637   assert(used() &gt;= bytes, &quot;never decrease heap size by more than we&#39;ve left&quot;);
<span class="line-modified"> 638   Atomic::sub(&amp;_used, bytes);</span>
 639 }
 640 
 641 void ShenandoahHeap::increase_allocated(size_t bytes) {
<span class="line-modified"> 642   Atomic::add(&amp;_bytes_allocated_since_gc_start, bytes);</span>
 643 }
 644 
 645 void ShenandoahHeap::notify_mutator_alloc_words(size_t words, bool waste) {
 646   size_t bytes = words * HeapWordSize;
 647   if (!waste) {
 648     increase_used(bytes);
 649   }
 650   increase_allocated(bytes);
 651   if (ShenandoahPacing) {
 652     control_thread()-&gt;pacing_notify_alloc(words);
 653     if (waste) {
 654       pacer()-&gt;claim_for_alloc(words, true);
 655     }
 656   }
 657 }
 658 
 659 size_t ShenandoahHeap::capacity() const {
<span class="line-modified"> 660   return committed();</span>
 661 }
 662 
 663 size_t ShenandoahHeap::max_capacity() const {
 664   return _num_regions * ShenandoahHeapRegion::region_size_bytes();
 665 }
 666 
<span class="line-added"> 667 size_t ShenandoahHeap::min_capacity() const {</span>
<span class="line-added"> 668   return _minimum_size;</span>
<span class="line-added"> 669 }</span>
<span class="line-added"> 670 </span>
 671 size_t ShenandoahHeap::initial_capacity() const {
 672   return _initial_size;
 673 }
 674 
 675 bool ShenandoahHeap::is_in(const void* p) const {
 676   HeapWord* heap_base = (HeapWord*) base();
 677   HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();
 678   return p &gt;= heap_base &amp;&amp; p &lt; last_region_end;
 679 }
 680 
 681 void ShenandoahHeap::op_uncommit(double shrink_before) {
 682   assert (ShenandoahUncommit, &quot;should be enabled&quot;);
 683 
<span class="line-added"> 684   // Application allocates from the beginning of the heap, and GC allocates at</span>
<span class="line-added"> 685   // the end of it. It is more efficient to uncommit from the end, so that applications</span>
<span class="line-added"> 686   // could enjoy the near committed regions. GC allocations are much less frequent,</span>
<span class="line-added"> 687   // and therefore can accept the committing costs.</span>
<span class="line-added"> 688 </span>
 689   size_t count = 0;
<span class="line-modified"> 690   for (size_t i = num_regions(); i &gt; 0; i--) { // care about size_t underflow</span>
<span class="line-modified"> 691     ShenandoahHeapRegion* r = get_region(i - 1);</span>
 692     if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
 693       ShenandoahHeapLocker locker(lock());
 694       if (r-&gt;is_empty_committed()) {
<span class="line-added"> 695         // Do not uncommit below minimal capacity</span>
<span class="line-added"> 696         if (committed() &lt; min_capacity() + ShenandoahHeapRegion::region_size_bytes()) {</span>
<span class="line-added"> 697           break;</span>
<span class="line-added"> 698         }</span>
<span class="line-added"> 699 </span>
 700         r-&gt;make_uncommitted();
 701         count++;
 702       }
 703     }
 704     SpinPause(); // allow allocators to take the lock
 705   }
 706 
 707   if (count &gt; 0) {


 708     control_thread()-&gt;notify_heap_changed();
 709   }
 710 }
 711 
 712 HeapWord* ShenandoahHeap::allocate_from_gclab_slow(Thread* thread, size_t size) {
 713   // New object should fit the GCLAB size
 714   size_t min_size = MAX2(size, PLAB::min_size());
 715 
 716   // Figure out size of new GCLAB, looking back at heuristics. Expand aggressively.
 717   size_t new_size = ShenandoahThreadLocalData::gclab_size(thread) * 2;
 718   new_size = MIN2(new_size, PLAB::max_size());
 719   new_size = MAX2(new_size, PLAB::min_size());
 720 
 721   // Record new heuristic value even if we take any shortcut. This captures
 722   // the case when moderately-sized objects always take a shortcut. At some point,
 723   // heuristics should catch up with them.
 724   ShenandoahThreadLocalData::set_gclab_size(thread, new_size);
 725 
 726   if (new_size &lt; size) {
 727     // New size still does not fit the object. Fall back to shared allocation.
</pre>
<hr />
<pre>
 824     // Full GC, which means we want to try more than ShenandoahFullGCThreshold times.
 825 
 826     size_t tries = 0;
 827 
 828     while (result == NULL &amp;&amp; _progress_last_gc.is_set()) {
 829       tries++;
 830       control_thread()-&gt;handle_alloc_failure(req.size());
 831       result = allocate_memory_under_lock(req, in_new_region);
 832     }
 833 
 834     while (result == NULL &amp;&amp; tries &lt;= ShenandoahFullGCThreshold) {
 835       tries++;
 836       control_thread()-&gt;handle_alloc_failure(req.size());
 837       result = allocate_memory_under_lock(req, in_new_region);
 838     }
 839 
 840   } else {
 841     assert(req.is_gc_alloc(), &quot;Can only accept GC allocs here&quot;);
 842     result = allocate_memory_under_lock(req, in_new_region);
 843     // Do not call handle_alloc_failure() here, because we cannot block.
<span class="line-modified"> 844     // The allocation failure would be handled by the LRB slowpath with handle_alloc_failure_evac().</span>
 845   }
 846 
 847   if (in_new_region) {
 848     control_thread()-&gt;notify_heap_changed();
 849   }
 850 
 851   if (result != NULL) {
 852     size_t requested = req.size();
 853     size_t actual = req.actual_size();
 854 
 855     assert (req.is_lab_alloc() || (requested == actual),
 856             &quot;Only LAB allocations are elastic: %s, requested = &quot; SIZE_FORMAT &quot;, actual = &quot; SIZE_FORMAT,
 857             ShenandoahAllocRequest::alloc_type_to_string(req.type()), requested, actual);
 858 
 859     if (req.is_mutator_alloc()) {
 860       notify_mutator_alloc_words(actual, false);
 861 
 862       // If we requested more than we were granted, give the rest back to pacer.
 863       // This only matters if we are in the same pacing epoch: do not try to unpace
 864       // over the budget for the other phase.
 865       if (ShenandoahPacing &amp;&amp; (pacer_epoch &gt; 0) &amp;&amp; (requested &gt; actual)) {
 866         pacer()-&gt;unpace_for_alloc(pacer_epoch, requested - actual);
 867       }
 868     } else {
 869       increase_used(actual*HeapWordSize);
 870     }
 871   }
 872 
 873   return result;
 874 }
 875 
 876 HeapWord* ShenandoahHeap::allocate_memory_under_lock(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
 877   ShenandoahHeapLocker locker(lock());
 878   return _free_set-&gt;allocate(req, in_new_region);
 879 }
 880 











































 881 HeapWord* ShenandoahHeap::mem_allocate(size_t size,
 882                                         bool*  gc_overhead_limit_was_exceeded) {
 883   ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);
 884   return allocate_memory(req);
 885 }
 886 
 887 MetaWord* ShenandoahHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
 888                                                              size_t size,
 889                                                              Metaspace::MetadataType mdtype) {
 890   MetaWord* result;
 891 
 892   // Inform metaspace OOM to GC heuristics if class unloading is possible.
 893   if (heuristics()-&gt;can_unload_classes()) {
 894     ShenandoahHeuristics* h = heuristics();
 895     h-&gt;record_metaspace_oom();
 896   }
 897 
 898   // Expand and retry allocation
 899   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 900   if (result != NULL) {
</pre>
<hr />
<pre>
 903 
 904   // Start full GC
 905   collect(GCCause::_metadata_GC_clear_soft_refs);
 906 
 907   // Retry allocation
 908   result = loader_data-&gt;metaspace_non_null()-&gt;allocate(size, mdtype);
 909   if (result != NULL) {
 910     return result;
 911   }
 912 
 913   // Expand and retry allocation
 914   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
 915   if (result != NULL) {
 916     return result;
 917   }
 918 
 919   // Out of memory
 920   return NULL;
 921 }
 922 














































 923 class ShenandoahConcurrentEvacuateRegionObjectClosure : public ObjectClosure {
 924 private:
 925   ShenandoahHeap* const _heap;
 926   Thread* const _thread;
 927 public:
 928   ShenandoahConcurrentEvacuateRegionObjectClosure(ShenandoahHeap* heap) :
 929     _heap(heap), _thread(Thread::current()) {}
 930 
 931   void do_object(oop p) {
 932     shenandoah_assert_marked(NULL, p);
<span class="line-modified"> 933     if (!p-&gt;is_forwarded()) {</span>
 934       _heap-&gt;evacuate_object(p, _thread);
 935     }
 936   }
 937 };
 938 
 939 class ShenandoahEvacuationTask : public AbstractGangTask {
 940 private:
 941   ShenandoahHeap* const _sh;
 942   ShenandoahCollectionSet* const _cs;
 943   bool _concurrent;
 944 public:
 945   ShenandoahEvacuationTask(ShenandoahHeap* sh,
 946                            ShenandoahCollectionSet* cs,
 947                            bool concurrent) :
 948     AbstractGangTask(&quot;Parallel Evacuation Task&quot;),
 949     _sh(sh),
 950     _cs(cs),
 951     _concurrent(concurrent)
 952   {}
 953 
 954   void work(uint worker_id) {
 955     if (_concurrent) {
 956       ShenandoahConcurrentWorkerSession worker_session(worker_id);
 957       ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 958       ShenandoahEvacOOMScope oom_evac_scope;
 959       do_work();
 960     } else {
 961       ShenandoahParallelWorkerSession worker_session(worker_id);
 962       ShenandoahEvacOOMScope oom_evac_scope;
 963       do_work();
 964     }
 965   }
 966 
 967 private:
 968   void do_work() {
 969     ShenandoahConcurrentEvacuateRegionObjectClosure cl(_sh);
 970     ShenandoahHeapRegion* r;
 971     while ((r =_cs-&gt;claim_next()) != NULL) {
<span class="line-modified"> 972       assert(r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have been reclaimed early&quot;, r-&gt;region_number());</span>
 973       _sh-&gt;marked_object_iterate(r, &amp;cl);
 974 
 975       if (ShenandoahPacing) {
 976         _sh-&gt;pacer()-&gt;report_evac(r-&gt;used() &gt;&gt; LogHeapWordSize);
 977       }
 978 
 979       if (_sh-&gt;check_cancelled_gc_and_yield(_concurrent)) {
 980         break;
 981       }
 982     }
 983   }
 984 };
 985 
 986 void ShenandoahHeap::trash_cset_regions() {
 987   ShenandoahHeapLocker locker(lock());
 988 
 989   ShenandoahCollectionSet* set = collection_set();
 990   ShenandoahHeapRegion* r;
 991   set-&gt;clear_current_index();
 992   while ((r = set-&gt;next()) != NULL) {
 993     r-&gt;make_trash();
 994   }
 995   collection_set()-&gt;clear();
 996 }
 997 
 998 void ShenandoahHeap::print_heap_regions_on(outputStream* st) const {
 999   st-&gt;print_cr(&quot;Heap Regions:&quot;);
1000   st-&gt;print_cr(&quot;EU=empty-uncommitted, EC=empty-committed, R=regular, H=humongous start, HC=humongous continuation, CS=collection set, T=trash, P=pinned&quot;);
1001   st-&gt;print_cr(&quot;BTE=bottom/top/end, U=used, T=TLAB allocs, G=GCLAB allocs, S=shared allocs, L=live data&quot;);
1002   st-&gt;print_cr(&quot;R=root, CP=critical pins, TAMS=top-at-mark-start (previous, next)&quot;);
1003   st-&gt;print_cr(&quot;SN=alloc sequence numbers (first mutator, last mutator, first gc, last gc)&quot;);
1004 
1005   for (size_t i = 0; i &lt; num_regions(); i++) {
1006     get_region(i)-&gt;print_on(st);
1007   }
1008 }
1009 
1010 void ShenandoahHeap::trash_humongous_region_at(ShenandoahHeapRegion* start) {
1011   assert(start-&gt;is_humongous_start(), &quot;reclaim regions starting with the first one&quot;);
1012 
<span class="line-modified">1013   oop humongous_obj = oop(start-&gt;bottom());</span>
<span class="line-modified">1014   size_t size = humongous_obj-&gt;size();</span>
1015   size_t required_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
1016   size_t index = start-&gt;region_number() + required_regions - 1;
1017 
1018   assert(!start-&gt;has_live(), &quot;liveness must be zero&quot;);
1019 
1020   for(size_t i = 0; i &lt; required_regions; i++) {
1021     // Reclaim from tail. Otherwise, assertion fails when printing region to trace log,
1022     // as it expects that every region belongs to a humongous region starting with a humongous start region.
1023     ShenandoahHeapRegion* region = get_region(index --);
1024 
1025     assert(region-&gt;is_humongous(), &quot;expect correct humongous start or continuation&quot;);
1026     assert(!region-&gt;is_cset(), &quot;Humongous region should not be in collection set&quot;);
1027 
1028     region-&gt;make_trash_immediate();
1029   }
1030 }
1031 
1032 class ShenandoahRetireGCLABClosure : public ThreadClosure {
1033 public:
1034   void do_thread(Thread* thread) {
</pre>
<hr />
<pre>
1048   }
1049   workers()-&gt;threads_do(&amp;cl);
1050 }
1051 
1052 void ShenandoahHeap::resize_tlabs() {
1053   CollectedHeap::resize_all_tlabs();
1054 }
1055 
1056 class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {
1057 private:
1058   ShenandoahRootEvacuator* _rp;
1059 
1060 public:
1061   ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :
1062     AbstractGangTask(&quot;Shenandoah evacuate and update roots&quot;),
1063     _rp(rp) {}
1064 
1065   void work(uint worker_id) {
1066     ShenandoahParallelWorkerSession worker_session(worker_id);
1067     ShenandoahEvacOOMScope oom_evac_scope;
<span class="line-modified">1068     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>

1069     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);
<span class="line-modified">1070     _rp-&gt;roots_do(worker_id, &amp;cl);</span>
1071   }
1072 };
1073 
1074 void ShenandoahHeap::evacuate_and_update_roots() {
<span class="line-modified">1075 #if COMPILER2_OR_JVMCI</span>
1076   DerivedPointerTable::clear();
1077 #endif
1078   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only iterate roots while world is stopped&quot;);

1079   {
<span class="line-modified">1080     // Include concurrent roots if current cycle can not process those roots concurrently</span>
<span class="line-added">1081     ShenandoahRootEvacuator rp(workers()-&gt;active_workers(),</span>
<span class="line-added">1082                                ShenandoahPhaseTimings::init_evac,</span>
<span class="line-added">1083                                !ShenandoahConcurrentRoots::should_do_concurrent_roots(),</span>
<span class="line-added">1084                                !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
1085     ShenandoahEvacuateUpdateRootsTask roots_task(&amp;rp);
1086     workers()-&gt;run_task(&amp;roots_task);
1087   }
1088 
<span class="line-modified">1089 #if COMPILER2_OR_JVMCI</span>
1090   DerivedPointerTable::update_pointers();
1091 #endif
1092 }
1093 










1094 // Returns size in bytes
1095 size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {
1096   if (ShenandoahElasticTLAB) {
1097     // With Elastic TLABs, return the max allowed size, and let the allocation path
1098     // figure out the safe size for current allocation.
1099     return ShenandoahHeapRegion::max_tlab_size_bytes();
1100   } else {
1101     return MIN2(_free_set-&gt;unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());
1102   }
1103 }
1104 
1105 size_t ShenandoahHeap::max_tlab_size() const {
1106   // Returns size in words
1107   return ShenandoahHeapRegion::max_tlab_size_words();
1108 }
1109 
1110 class ShenandoahRetireAndResetGCLABClosure : public ThreadClosure {
1111 public:
1112   void do_thread(Thread* thread) {
1113     PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);
</pre>
<hr />
<pre>
1117     }
1118   }
1119 };
1120 
1121 void ShenandoahHeap::retire_and_reset_gclabs() {
1122   ShenandoahRetireAndResetGCLABClosure cl;
1123   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
1124     cl.do_thread(t);
1125   }
1126   workers()-&gt;threads_do(&amp;cl);
1127 }
1128 
1129 void ShenandoahHeap::collect(GCCause::Cause cause) {
1130   control_thread()-&gt;request_gc(cause);
1131 }
1132 
1133 void ShenandoahHeap::do_full_collection(bool clear_all_soft_refs) {
1134   //assert(false, &quot;Shouldn&#39;t need to do full collections&quot;);
1135 }
1136 




1137 HeapWord* ShenandoahHeap::block_start(const void* addr) const {
1138   Space* sp = heap_region_containing(addr);
1139   if (sp != NULL) {
1140     return sp-&gt;block_start(addr);
1141   }
1142   return NULL;
1143 }
1144 
1145 bool ShenandoahHeap::block_is_obj(const HeapWord* addr) const {
1146   Space* sp = heap_region_containing(addr);
1147   return sp-&gt;block_is_obj(addr);
1148 }
1149 
<span class="line-added">1150 bool ShenandoahHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">1151   return BlockLocationPrinter&lt;ShenandoahHeap&gt;::print_location(st, addr);</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
1154 jlong ShenandoahHeap::millis_since_last_gc() {
1155   double v = heuristics()-&gt;time_since_last_gc() * 1000;
1156   assert(0 &lt;= v &amp;&amp; v &lt;= max_jlong, &quot;value should fit: %f&quot;, v);
1157   return (jlong)v;
1158 }
1159 
1160 void ShenandoahHeap::prepare_for_verify() {
1161   if (SafepointSynchronize::is_at_safepoint() || ! UseTLAB) {
1162     make_parsable(false);
1163   }
1164 }
1165 
1166 void ShenandoahHeap::print_gc_threads_on(outputStream* st) const {
1167   workers()-&gt;print_worker_threads_on(st);
1168   if (ShenandoahStringDedup::is_enabled()) {
1169     ShenandoahStringDedup::print_worker_threads_on(st);
1170   }
1171 }
1172 
1173 void ShenandoahHeap::gc_threads_do(ThreadClosure* tcl) const {
1174   workers()-&gt;threads_do(tcl);
<span class="line-modified">1175   if (_safepoint_workers != NULL) {</span>
<span class="line-added">1176     _safepoint_workers-&gt;threads_do(tcl);</span>
<span class="line-added">1177   }</span>
1178   if (ShenandoahStringDedup::is_enabled()) {
1179     ShenandoahStringDedup::threads_do(tcl);
1180   }
1181 }
1182 
1183 void ShenandoahHeap::print_tracing_info() const {
1184   LogTarget(Info, gc, stats) lt;
1185   if (lt.is_enabled()) {
1186     ResourceMark rm;
1187     LogStream ls(lt);
1188 
1189     phase_timings()-&gt;print_on(&amp;ls);
1190 
1191     ls.cr();
1192     ls.cr();
1193 
1194     shenandoah_policy()-&gt;print_gc_stats(&amp;ls);
1195 
1196     ls.cr();
1197     ls.cr();
</pre>
<hr />
<pre>
1219     } else {
1220       // TODO: Consider allocating verification bitmaps on demand,
1221       // and turn this on unconditionally.
1222     }
1223   }
1224 }
1225 size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {
1226   return _free_set-&gt;capacity();
1227 }
1228 
1229 class ObjectIterateScanRootClosure : public BasicOopIterateClosure {
1230 private:
1231   MarkBitMap* _bitmap;
1232   Stack&lt;oop,mtGC&gt;* _oop_stack;
1233 
1234   template &lt;class T&gt;
1235   void do_oop_work(T* p) {
1236     T o = RawAccess&lt;&gt;::oop_load(p);
1237     if (!CompressedOops::is_null(o)) {
1238       oop obj = CompressedOops::decode_not_null(o);
<span class="line-modified">1239       oop fwd = (oop) ShenandoahForwarding::get_forwardee_raw_unchecked(obj);</span>
<span class="line-added">1240       if (fwd == NULL) {</span>
<span class="line-added">1241         // There is an odd interaction with VM_HeapWalkOperation, see jvmtiTagMap.cpp.</span>
<span class="line-added">1242         //</span>
<span class="line-added">1243         // That operation walks the reachable objects on its own, storing the marking</span>
<span class="line-added">1244         // wavefront in the object marks. When it is done, it calls the CollectedHeap</span>
<span class="line-added">1245         // to iterate over all objects to clean up the mess. When it reaches here,</span>
<span class="line-added">1246         // the Shenandoah fwdptr resolution code encounters the marked objects with</span>
<span class="line-added">1247         // NULL forwardee. Trying to act on that would crash the VM. Or fail the</span>
<span class="line-added">1248         // asserts, should we go for resolve_forwarded_pointer(obj).</span>
<span class="line-added">1249         //</span>
<span class="line-added">1250         // Therefore, we have to dodge it by doing the raw access to forwardee, and</span>
<span class="line-added">1251         // assuming the object had no forwardee, if that thing is NULL.</span>
<span class="line-added">1252       } else {</span>
<span class="line-added">1253         obj = fwd;</span>
<span class="line-added">1254       }</span>
1255       assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
<span class="line-modified">1256       if (!_bitmap-&gt;is_marked(obj)) {</span>
<span class="line-modified">1257         _bitmap-&gt;mark(obj);</span>
1258         _oop_stack-&gt;push(obj);
1259       }
1260     }
1261   }
1262 public:
1263   ObjectIterateScanRootClosure(MarkBitMap* bitmap, Stack&lt;oop,mtGC&gt;* oop_stack) :
1264     _bitmap(bitmap), _oop_stack(oop_stack) {}
1265   void do_oop(oop* p)       { do_oop_work(p); }
1266   void do_oop(narrowOop* p) { do_oop_work(p); }
1267 };
1268 
1269 /*
1270  * This is public API, used in preparation of object_iterate().
1271  * Since we don&#39;t do linear scan of heap in object_iterate() (see comment below), we don&#39;t
1272  * need to make the heap parsable. For Shenandoah-internal linear heap scans that we can
1273  * control, we call SH::make_tlabs_parsable().
1274  */
1275 void ShenandoahHeap::ensure_parsability(bool retire_tlabs) {
1276   // No-op.
1277 }
</pre>
<hr />
<pre>
1286  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1287  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1288  * wiped the bitmap in preparation for next marking).
1289  *
1290  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1291  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1292  * is allowed to report dead objects, but is not required to do so.
1293  */
1294 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1295   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1296   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1297     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1298     return;
1299   }
1300 
1301   // Reset bitmap
1302   _aux_bit_map.clear();
1303 
1304   Stack&lt;oop,mtGC&gt; oop_stack;
1305 
<span class="line-modified">1306   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.</span>
<span class="line-modified">1307   ShenandoahHeapIterationRootScanner rp;</span>
1308   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
<span class="line-modified">1309 </span>
<span class="line-modified">1310   // When concurrent root is in progress, weak roots may contain dead oops, they should not be used</span>
<span class="line-modified">1311   // for root scanning.</span>
<span class="line-added">1312   if (is_concurrent_root_in_progress()) {</span>
<span class="line-added">1313     rp.strong_roots_do(&amp;oops);</span>
<span class="line-added">1314   } else {</span>
<span class="line-added">1315     rp.roots_do(&amp;oops);</span>
<span class="line-added">1316   }</span>
1317 
1318   // Work through the oop stack to traverse heap.
1319   while (! oop_stack.is_empty()) {
1320     oop obj = oop_stack.pop();
1321     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1322     cl-&gt;do_object(obj);
1323     obj-&gt;oop_iterate(&amp;oops);
1324   }
1325 
1326   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1327 
1328   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1329     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1330   }
1331 }
1332 
<span class="line-modified">1333 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.</span>
<span class="line-modified">1334 void ShenandoahHeap::keep_alive(oop obj) {</span>
<span class="line-modified">1335   if (is_concurrent_mark_in_progress()) {</span>
<span class="line-added">1336     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);</span>
<span class="line-added">1337   }</span>
1338 }
1339 
1340 void ShenandoahHeap::heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1341   for (size_t i = 0; i &lt; num_regions(); i++) {
1342     ShenandoahHeapRegion* current = get_region(i);
1343     blk-&gt;heap_region_do(current);
1344   }
1345 }
1346 
1347 class ShenandoahParallelHeapRegionTask : public AbstractGangTask {
1348 private:
1349   ShenandoahHeap* const _heap;
1350   ShenandoahHeapRegionClosure* const _blk;
1351 
1352   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));
1353   volatile size_t _index;
1354   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
1355 
1356 public:
1357   ShenandoahParallelHeapRegionTask(ShenandoahHeapRegionClosure* blk) :
1358           AbstractGangTask(&quot;Parallel Region Task&quot;),
1359           _heap(ShenandoahHeap::heap()), _blk(blk), _index(0) {}
1360 
1361   void work(uint worker_id) {
1362     size_t stride = ShenandoahParallelRegionStride;
1363 
1364     size_t max = _heap-&gt;num_regions();
1365     while (_index &lt; max) {
<span class="line-modified">1366       size_t cur = Atomic::fetch_and_add(&amp;_index, stride);</span>
1367       size_t start = cur;
1368       size_t end = MIN2(cur + stride, max);
1369       if (start &gt;= max) break;
1370 
1371       for (size_t i = cur; i &lt; end; i++) {
1372         ShenandoahHeapRegion* current = _heap-&gt;get_region(i);
1373         _blk-&gt;heap_region_do(current);
1374       }
1375     }
1376   }
1377 };
1378 
1379 void ShenandoahHeap::parallel_heap_region_iterate(ShenandoahHeapRegionClosure* blk) const {
1380   assert(blk-&gt;is_thread_safe(), &quot;Only thread-safe closures here&quot;);
1381   if (num_regions() &gt; ShenandoahParallelRegionStride) {
1382     ShenandoahParallelHeapRegionTask task(blk);
1383     workers()-&gt;run_task(&amp;task);
1384   } else {
1385     heap_region_iterate(blk);
1386   }
</pre>
<hr />
<pre>
1469     } else {
1470       assert(!r-&gt;has_live(), &quot;Region &quot; SIZE_FORMAT &quot; should have no live data&quot;, r-&gt;region_number());
1471       assert(_ctx-&gt;top_at_mark_start(r) == r-&gt;top(),
1472              &quot;Region &quot; SIZE_FORMAT &quot; should have correct TAMS&quot;, r-&gt;region_number());
1473     }
1474   }
1475 
1476   bool is_thread_safe() { return true; }
1477 };
1478 
1479 void ShenandoahHeap::op_final_mark() {
1480   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1481 
1482   // It is critical that we
1483   // evacuate roots right after finishing marking, so that we don&#39;t
1484   // get unmarked objects in the roots.
1485 
1486   if (!cancelled_gc()) {
1487     concurrent_mark()-&gt;finish_mark_from_roots(/* full_gc = */ false);
1488 
<span class="line-modified">1489     // Marking is completed, deactivate SATB barrier</span>
<span class="line-modified">1490     set_concurrent_mark_in_progress(false);</span>
<span class="line-modified">1491     mark_complete_marking_context();</span>
1492 
<span class="line-modified">1493     parallel_cleaning(false /* full gc*/);</span>
1494 
<span class="line-added">1495     if (has_forwarded_objects()) {</span>
<span class="line-added">1496       // Degen may be caused by failed evacuation of roots</span>
<span class="line-added">1497       if (is_degenerated_gc_in_progress()) {</span>
<span class="line-added">1498         concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-added">1499       } else {</span>
<span class="line-added">1500         concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::update_roots);</span>
<span class="line-added">1501       }</span>
<span class="line-added">1502       set_has_forwarded_objects(false);</span>
<span class="line-added">1503    }</span>
<span class="line-added">1504 </span>
<span class="line-added">1505     if (ShenandoahVerify) {</span>
<span class="line-added">1506       verifier()-&gt;verify_roots_no_forwarded();</span>
<span class="line-added">1507     }</span>
<span class="line-added">1508     // All allocations past TAMS are implicitly live, adjust the region data.</span>
<span class="line-added">1509     // Bitmaps/TAMS are swapped at this point, so we need to poll complete bitmap.</span>
1510     {
1511       ShenandoahGCPhase phase(ShenandoahPhaseTimings::complete_liveness);



1512       ShenandoahCompleteLivenessClosure cl;
1513       parallel_heap_region_iterate(&amp;cl);
1514     }
1515 
<span class="line-added">1516     // Force the threads to reacquire their TLABs outside the collection set.</span>
1517     {
<span class="line-modified">1518       ShenandoahGCPhase phase(ShenandoahPhaseTimings::retire_tlabs);</span>

1519       make_parsable(true);
<span class="line-added">1520     }</span>
1521 
<span class="line-added">1522     // We are about to select the collection set, make sure it knows about</span>
<span class="line-added">1523     // current pinning status. Also, this allows trashing more regions that</span>
<span class="line-added">1524     // now have their pinning status dropped.</span>
<span class="line-added">1525     {</span>
<span class="line-added">1526       ShenandoahGCPhase phase(ShenandoahPhaseTimings::sync_pinned);</span>
<span class="line-added">1527       sync_pinned_region_status();</span>
<span class="line-added">1528     }</span>
<span class="line-added">1529 </span>
<span class="line-added">1530     // Trash the collection set left over from previous cycle, if any.</span>
<span class="line-added">1531     {</span>
<span class="line-added">1532       ShenandoahGCPhase phase(ShenandoahPhaseTimings::trash_cset);</span>
1533       trash_cset_regions();
<span class="line-added">1534     }</span>
1535 
<span class="line-modified">1536     {</span>
<span class="line-modified">1537       ShenandoahGCPhase phase(ShenandoahPhaseTimings::prepare_evac);</span>
<span class="line-modified">1538 </span>
<span class="line-modified">1539       ShenandoahHeapLocker locker(lock());</span>
<span class="line-added">1540       _collection_set-&gt;clear();</span>
<span class="line-added">1541       _free_set-&gt;clear();</span>
1542 
<span class="line-modified">1543       heuristics()-&gt;choose_collection_set(_collection_set);</span>
1544 
<span class="line-modified">1545       _free_set-&gt;rebuild();</span>
<span class="line-modified">1546     }</span>
<span class="line-added">1547 </span>
<span class="line-added">1548     if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">1549       prepare_concurrent_roots();</span>
<span class="line-added">1550       prepare_concurrent_unloading();</span>
1551     }
1552 
1553     // If collection set has candidates, start evacuation.
1554     // Otherwise, bypass the rest of the cycle.
1555     if (!collection_set()-&gt;is_empty()) {
1556       ShenandoahGCPhase init_evac(ShenandoahPhaseTimings::init_evac);
1557 
1558       if (ShenandoahVerify) {
1559         verifier()-&gt;verify_before_evacuation();
1560       }
1561 
1562       set_evacuation_in_progress(true);
1563       // From here on, we need to update references.
1564       set_has_forwarded_objects(true);
1565 
<span class="line-modified">1566       if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">1567         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1568           ShenandoahCodeRoots::arm_nmethods();</span>
<span class="line-added">1569         }</span>
<span class="line-added">1570         evacuate_and_update_roots();</span>
<span class="line-added">1571       }</span>
1572 
1573       if (ShenandoahPacing) {
1574         pacer()-&gt;setup_for_evac();
1575       }
<span class="line-added">1576 </span>
<span class="line-added">1577       if (ShenandoahVerify) {</span>
<span class="line-added">1578         ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::None;</span>
<span class="line-added">1579         if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">1580           types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::JNIHandleRoots, ShenandoahRootVerifier::WeakRoots);</span>
<span class="line-added">1581           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CLDGRoots);</span>
<span class="line-added">1582           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::StringDedupRoots);</span>
<span class="line-added">1583         }</span>
<span class="line-added">1584 </span>
<span class="line-added">1585         if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1586           types = ShenandoahRootVerifier::combine(types, ShenandoahRootVerifier::CodeRoots);</span>
<span class="line-added">1587         }</span>
<span class="line-added">1588         verifier()-&gt;verify_roots_no_forwarded_except(types);</span>
<span class="line-added">1589         verifier()-&gt;verify_during_evacuation();</span>
<span class="line-added">1590       }</span>
1591     } else {
1592       if (ShenandoahVerify) {
1593         verifier()-&gt;verify_after_concmark();
1594       }
1595 
1596       if (VerifyAfterGC) {
1597         Universe::verify();
1598       }
1599     }
1600 
1601   } else {
<span class="line-added">1602     // If this cycle was updating references, we need to keep the has_forwarded_objects</span>
<span class="line-added">1603     // flag on, for subsequent phases to deal with it.</span>
1604     concurrent_mark()-&gt;cancel();
<span class="line-modified">1605     set_concurrent_mark_in_progress(false);</span>
1606 
1607     if (process_references()) {
1608       // Abandon reference processing right away: pre-cleaning must have failed.
1609       ReferenceProcessor *rp = ref_processor();
1610       rp-&gt;disable_discovery();
1611       rp-&gt;abandon_partial_discovery();
1612       rp-&gt;verify_no_references_recorded();
1613     }
1614   }
1615 }
1616 
1617 void ShenandoahHeap::op_final_evac() {
1618   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should be at safepoint&quot;);
1619 
1620   set_evacuation_in_progress(false);
1621 
<span class="line-modified">1622   {</span>
<span class="line-added">1623     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_evac_retire_gclabs);</span>
<span class="line-added">1624     retire_and_reset_gclabs();</span>
<span class="line-added">1625   }</span>
1626 
1627   if (ShenandoahVerify) {
1628     verifier()-&gt;verify_after_evacuation();
1629   }
1630 
1631   if (VerifyAfterGC) {
1632     Universe::verify();
1633   }
1634 }
1635 
1636 void ShenandoahHeap::op_conc_evac() {
1637   ShenandoahEvacuationTask task(this, _collection_set, true);
1638   workers()-&gt;run_task(&amp;task);
1639 }
1640 
1641 void ShenandoahHeap::op_stw_evac() {
1642   ShenandoahEvacuationTask task(this, _collection_set, false);
1643   workers()-&gt;run_task(&amp;task);
1644 }
1645 
1646 void ShenandoahHeap::op_updaterefs() {
1647   update_heap_references(true);
1648 }
1649 
1650 void ShenandoahHeap::op_cleanup() {
1651   free_set()-&gt;recycle_trash();
1652 }
1653 
<span class="line-added">1654 class ShenandoahConcurrentRootsEvacUpdateTask : public AbstractGangTask {</span>
<span class="line-added">1655 private:</span>
<span class="line-added">1656   ShenandoahVMRoots&lt;true /*concurrent*/&gt;        _vm_roots;</span>
<span class="line-added">1657   ShenandoahWeakRoots&lt;true /*concurrent*/&gt;      _weak_roots;</span>
<span class="line-added">1658   ShenandoahClassLoaderDataRoots&lt;true /*concurrent*/, false /*single threaded*/&gt; _cld_roots;</span>
<span class="line-added">1659   ShenandoahConcurrentStringDedupRoots          _dedup_roots;</span>
<span class="line-added">1660   bool                                          _include_weak_roots;</span>
<span class="line-added">1661 </span>
<span class="line-added">1662 public:</span>
<span class="line-added">1663   ShenandoahConcurrentRootsEvacUpdateTask(bool include_weak_roots) :</span>
<span class="line-added">1664     AbstractGangTask(&quot;Shenandoah Evacuate/Update Concurrent Roots Task&quot;),</span>
<span class="line-added">1665     _include_weak_roots(include_weak_roots) {</span>
<span class="line-added">1666   }</span>
<span class="line-added">1667 </span>
<span class="line-added">1668   void work(uint worker_id) {</span>
<span class="line-added">1669     ShenandoahEvacOOMScope oom;</span>
<span class="line-added">1670     {</span>
<span class="line-added">1671       // vm_roots and weak_roots are OopStorage backed roots, concurrent iteration</span>
<span class="line-added">1672       // may race against OopStorage::release() calls.</span>
<span class="line-added">1673       ShenandoahEvacUpdateOopStorageRootsClosure cl;</span>
<span class="line-added">1674       _vm_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);</span>
<span class="line-added">1675 </span>
<span class="line-added">1676       if (_include_weak_roots) {</span>
<span class="line-added">1677         _weak_roots.oops_do&lt;ShenandoahEvacUpdateOopStorageRootsClosure&gt;(&amp;cl);</span>
<span class="line-added">1678       }</span>
<span class="line-added">1679     }</span>
<span class="line-added">1680 </span>
<span class="line-added">1681     {</span>
<span class="line-added">1682       ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-added">1683       CLDToOopClosure clds(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added">1684       _cld_roots.cld_do(&amp;clds);</span>
<span class="line-added">1685     }</span>
<span class="line-added">1686 </span>
<span class="line-added">1687     {</span>
<span class="line-added">1688       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">1689       ShenandoahEvacuateUpdateRootsClosure&lt;MO_RELEASE&gt; keep_alive;</span>
<span class="line-added">1690       _dedup_roots.oops_do(&amp;is_alive, &amp;keep_alive, worker_id);</span>
<span class="line-added">1691     }</span>
<span class="line-added">1692   }</span>
<span class="line-added">1693 };</span>
<span class="line-added">1694 </span>
<span class="line-added">1695 class ShenandoahEvacUpdateCleanupOopStorageRootsClosure : public BasicOopIterateClosure {</span>
<span class="line-added">1696 private:</span>
<span class="line-added">1697   ShenandoahHeap* const _heap;</span>
<span class="line-added">1698   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-added">1699   bool  _evac_in_progress;</span>
<span class="line-added">1700   Thread* const _thread;</span>
<span class="line-added">1701   size_t  _dead_counter;</span>
<span class="line-added">1702 </span>
<span class="line-added">1703 public:</span>
<span class="line-added">1704   ShenandoahEvacUpdateCleanupOopStorageRootsClosure();</span>
<span class="line-added">1705   void do_oop(oop* p);</span>
<span class="line-added">1706   void do_oop(narrowOop* p);</span>
<span class="line-added">1707 </span>
<span class="line-added">1708   size_t dead_counter() const;</span>
<span class="line-added">1709   void reset_dead_counter();</span>
<span class="line-added">1710 };</span>
<span class="line-added">1711 </span>
<span class="line-added">1712 ShenandoahEvacUpdateCleanupOopStorageRootsClosure::ShenandoahEvacUpdateCleanupOopStorageRootsClosure() :</span>
<span class="line-added">1713   _heap(ShenandoahHeap::heap()),</span>
<span class="line-added">1714   _mark_context(ShenandoahHeap::heap()-&gt;marking_context()),</span>
<span class="line-added">1715   _evac_in_progress(ShenandoahHeap::heap()-&gt;is_evacuation_in_progress()),</span>
<span class="line-added">1716   _thread(Thread::current()),</span>
<span class="line-added">1717   _dead_counter(0) {</span>
<span class="line-added">1718 }</span>
<span class="line-added">1719 </span>
<span class="line-added">1720 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(oop* p) {</span>
<span class="line-added">1721   const oop obj = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">1722   if (!CompressedOops::is_null(obj)) {</span>
<span class="line-added">1723     if (!_mark_context-&gt;is_marked(obj)) {</span>
<span class="line-added">1724       shenandoah_assert_correct(p, obj);</span>
<span class="line-added">1725       oop old = Atomic::cmpxchg(p, obj, oop(NULL));</span>
<span class="line-added">1726       if (obj == old) {</span>
<span class="line-added">1727         _dead_counter ++;</span>
<span class="line-added">1728       }</span>
<span class="line-added">1729     } else if (_evac_in_progress &amp;&amp; _heap-&gt;in_collection_set(obj)) {</span>
<span class="line-added">1730       oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-added">1731       if (resolved == obj) {</span>
<span class="line-added">1732         resolved = _heap-&gt;evacuate_object(obj, _thread);</span>
<span class="line-added">1733       }</span>
<span class="line-added">1734       Atomic::cmpxchg(p, obj, resolved);</span>
<span class="line-added">1735       assert(_heap-&gt;cancelled_gc() ||</span>
<span class="line-added">1736              _mark_context-&gt;is_marked(resolved) &amp;&amp; !_heap-&gt;in_collection_set(resolved),</span>
<span class="line-added">1737              &quot;Sanity&quot;);</span>
<span class="line-added">1738     }</span>
<span class="line-added">1739   }</span>
<span class="line-added">1740 }</span>
<span class="line-added">1741 </span>
<span class="line-added">1742 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::do_oop(narrowOop* p) {</span>
<span class="line-added">1743   ShouldNotReachHere();</span>
<span class="line-added">1744 }</span>
<span class="line-added">1745 </span>
<span class="line-added">1746 size_t ShenandoahEvacUpdateCleanupOopStorageRootsClosure::dead_counter() const {</span>
<span class="line-added">1747   return _dead_counter;</span>
<span class="line-added">1748 }</span>
<span class="line-added">1749 </span>
<span class="line-added">1750 void ShenandoahEvacUpdateCleanupOopStorageRootsClosure::reset_dead_counter() {</span>
<span class="line-added">1751   _dead_counter = 0;</span>
<span class="line-added">1752 }</span>
<span class="line-added">1753 </span>
<span class="line-added">1754 // This task not only evacuates/updates marked weak roots, but also &quot;NULL&quot;</span>
<span class="line-added">1755 // dead weak roots.</span>
<span class="line-added">1756 class ShenandoahConcurrentWeakRootsEvacUpdateTask : public AbstractGangTask {</span>
<span class="line-added">1757 private:</span>
<span class="line-added">1758   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _jni_roots;</span>
<span class="line-added">1759   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _string_table_roots;</span>
<span class="line-added">1760   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _resolved_method_table_roots;</span>
<span class="line-added">1761   ShenandoahWeakRoot&lt;true /*concurrent*/&gt;  _vm_roots;</span>
<span class="line-added">1762 </span>
<span class="line-added">1763 public:</span>
<span class="line-added">1764   ShenandoahConcurrentWeakRootsEvacUpdateTask() :</span>
<span class="line-added">1765     AbstractGangTask(&quot;Shenandoah Concurrent Weak Root Task&quot;),</span>
<span class="line-added">1766     _jni_roots(OopStorageSet::jni_weak(), ShenandoahPhaseTimings::JNIWeakRoots),</span>
<span class="line-added">1767     _string_table_roots(OopStorageSet::string_table_weak(), ShenandoahPhaseTimings::StringTableRoots),</span>
<span class="line-added">1768     _resolved_method_table_roots(OopStorageSet::resolved_method_table_weak(), ShenandoahPhaseTimings::ResolvedMethodTableRoots),</span>
<span class="line-added">1769     _vm_roots(OopStorageSet::vm_weak(), ShenandoahPhaseTimings::VMWeakRoots) {</span>
<span class="line-added">1770     StringTable::reset_dead_counter();</span>
<span class="line-added">1771     ResolvedMethodTable::reset_dead_counter();</span>
<span class="line-added">1772   }</span>
<span class="line-added">1773 </span>
<span class="line-added">1774   ~ShenandoahConcurrentWeakRootsEvacUpdateTask() {</span>
<span class="line-added">1775     StringTable::finish_dead_counter();</span>
<span class="line-added">1776     ResolvedMethodTable::finish_dead_counter();</span>
<span class="line-added">1777   }</span>
<span class="line-added">1778 </span>
<span class="line-added">1779   void work(uint worker_id) {</span>
<span class="line-added">1780     ShenandoahEvacOOMScope oom;</span>
<span class="line-added">1781     // jni_roots and weak_roots are OopStorage backed roots, concurrent iteration</span>
<span class="line-added">1782     // may race against OopStorage::release() calls.</span>
<span class="line-added">1783     ShenandoahEvacUpdateCleanupOopStorageRootsClosure cl;</span>
<span class="line-added">1784     _jni_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">1785     _vm_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">1786 </span>
<span class="line-added">1787     cl.reset_dead_counter();</span>
<span class="line-added">1788     _string_table_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">1789     StringTable::inc_dead_counter(cl.dead_counter());</span>
<span class="line-added">1790 </span>
<span class="line-added">1791     cl.reset_dead_counter();</span>
<span class="line-added">1792     _resolved_method_table_roots.oops_do(&amp;cl, worker_id);</span>
<span class="line-added">1793     ResolvedMethodTable::inc_dead_counter(cl.dead_counter());</span>
<span class="line-added">1794   }</span>
<span class="line-added">1795 };</span>
<span class="line-added">1796 </span>
<span class="line-added">1797 void ShenandoahHeap::op_roots() {</span>
<span class="line-added">1798   if (is_concurrent_root_in_progress()) {</span>
<span class="line-added">1799     if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">1800       // Concurrent weak root processing</span>
<span class="line-added">1801       ShenandoahConcurrentWeakRootsEvacUpdateTask task;</span>
<span class="line-added">1802       workers()-&gt;run_task(&amp;task);</span>
<span class="line-added">1803 </span>
<span class="line-added">1804       _unloader.unload();</span>
<span class="line-added">1805     }</span>
<span class="line-added">1806 </span>
<span class="line-added">1807     if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">1808       ShenandoahConcurrentRootsEvacUpdateTask task(!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">1809       workers()-&gt;run_task(&amp;task);</span>
<span class="line-added">1810     }</span>
<span class="line-added">1811   }</span>
<span class="line-added">1812 </span>
<span class="line-added">1813   set_concurrent_root_in_progress(false);</span>
<span class="line-added">1814 }</span>
<span class="line-added">1815 </span>
1816 void ShenandoahHeap::op_reset() {
1817   reset_mark_bitmap();
1818 }
1819 
1820 void ShenandoahHeap::op_preclean() {
1821   concurrent_mark()-&gt;preclean_weak_refs();
1822 }
1823 
1824 void ShenandoahHeap::op_init_traversal() {
1825   traversal_gc()-&gt;init_traversal_collection();
1826 }
1827 
1828 void ShenandoahHeap::op_traversal() {
1829   traversal_gc()-&gt;concurrent_traversal_collection();
1830 }
1831 
1832 void ShenandoahHeap::op_final_traversal() {
1833   traversal_gc()-&gt;final_traversal_collection();
1834 }
1835 
1836 void ShenandoahHeap::op_full(GCCause::Cause cause) {
1837   ShenandoahMetricsSnapshot metrics;
1838   metrics.snap_before();
1839 
1840   full_gc()-&gt;do_it(cause);
1841   if (UseTLAB) {
1842     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_resize_tlabs);
1843     resize_all_tlabs();
1844   }
1845 
1846   metrics.snap_after();

1847 
<span class="line-modified">1848   if (metrics.is_good_progress()) {</span>
1849     _progress_last_gc.set();
1850   } else {
1851     // Nothing to do. Tell the allocation path that we have failed to make
1852     // progress, and it can finally fail.
1853     _progress_last_gc.unset();
1854   }
1855 }
1856 
1857 void ShenandoahHeap::op_degenerated(ShenandoahDegenPoint point) {
1858   // Degenerated GC is STW, but it can also fail. Current mechanics communicates
1859   // GC failure via cancelled_concgc() flag. So, if we detect the failure after
1860   // some phase, we have to upgrade the Degenerate GC to Full GC.
1861 
1862   clear_cancelled_gc();
1863 
1864   ShenandoahMetricsSnapshot metrics;
1865   metrics.snap_before();
1866 
1867   switch (point) {
1868     case _degenerated_traversal:
</pre>
<hr />
<pre>
1882       op_final_traversal();
1883       op_cleanup();
1884       return;
1885 
1886     // The cases below form the Duff&#39;s-like device: it describes the actual GC cycle,
1887     // but enters it at different points, depending on which concurrent phase had
1888     // degenerated.
1889 
1890     case _degenerated_outside_cycle:
1891       // We have degenerated from outside the cycle, which means something is bad with
1892       // the heap, most probably heavy humongous fragmentation, or we are very low on free
1893       // space. It makes little sense to wait for Full GC to reclaim as much as it can, when
1894       // we can do the most aggressive degen cycle, which includes processing references and
1895       // class unloading, unless those features are explicitly disabled.
1896       //
1897       // Note that we can only do this for &quot;outside-cycle&quot; degens, otherwise we would risk
1898       // changing the cycle parameters mid-cycle during concurrent -&gt; degenerated handover.
1899       set_process_references(heuristics()-&gt;can_process_references());
1900       set_unload_classes(heuristics()-&gt;can_unload_classes());
1901 
<span class="line-modified">1902       if (is_traversal_mode()) {</span>
1903         // Not possible to degenerate from here, upgrade to Full GC right away.
1904         cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
1905         op_degenerated_fail();
1906         return;
1907       }
1908 
1909       op_reset();
1910 
1911       op_init_mark();
1912       if (cancelled_gc()) {
1913         op_degenerated_fail();
1914         return;
1915       }
1916 
1917     case _degenerated_mark:
1918       op_final_mark();
1919       if (cancelled_gc()) {
1920         op_degenerated_fail();
1921         return;
1922       }
1923 
1924       op_cleanup();
1925 
1926     case _degenerated_evac:
1927       // If heuristics thinks we should do the cycle, this flag would be set,
1928       // and we can do evacuation. Otherwise, it would be the shortcut cycle.
1929       if (is_evacuation_in_progress()) {
1930 
1931         // Degeneration under oom-evac protocol might have left some objects in
1932         // collection set un-evacuated. Restart evacuation from the beginning to
1933         // capture all objects. For all the objects that are already evacuated,
1934         // it would be a simple check, which is supposed to be fast. This is also
1935         // safe to do even without degeneration, as CSet iterator is at beginning
1936         // in preparation for evacuation anyway.
<span class="line-modified">1937         //</span>
<span class="line-added">1938         // Before doing that, we need to make sure we never had any cset-pinned</span>
<span class="line-added">1939         // regions. This may happen if allocation failure happened when evacuating</span>
<span class="line-added">1940         // the about-to-be-pinned object, oom-evac protocol left the object in</span>
<span class="line-added">1941         // the collection set, and then the pin reached the cset region. If we continue</span>
<span class="line-added">1942         // the cycle here, we would trash the cset and alive objects in it. To avoid</span>
<span class="line-added">1943         // it, we fail degeneration right away and slide into Full GC to recover.</span>
<span class="line-added">1944 </span>
<span class="line-added">1945         {</span>
<span class="line-added">1946           sync_pinned_region_status();</span>
<span class="line-added">1947           collection_set()-&gt;clear_current_index();</span>
<span class="line-added">1948 </span>
<span class="line-added">1949           ShenandoahHeapRegion* r;</span>
<span class="line-added">1950           while ((r = collection_set()-&gt;next()) != NULL) {</span>
<span class="line-added">1951             if (r-&gt;is_pinned()) {</span>
<span class="line-added">1952               cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);</span>
<span class="line-added">1953               op_degenerated_fail();</span>
<span class="line-added">1954               return;</span>
<span class="line-added">1955             }</span>
<span class="line-added">1956           }</span>
<span class="line-added">1957 </span>
<span class="line-added">1958           collection_set()-&gt;clear_current_index();</span>
<span class="line-added">1959         }</span>
1960 
1961         op_stw_evac();
1962         if (cancelled_gc()) {
1963           op_degenerated_fail();
1964           return;
1965         }
1966       }
1967 
1968       // If heuristics thinks we should do the cycle, this flag would be set,
1969       // and we need to do update-refs. Otherwise, it would be the shortcut cycle.
1970       if (has_forwarded_objects()) {
1971         op_init_updaterefs();
1972         if (cancelled_gc()) {
1973           op_degenerated_fail();
1974           return;
1975         }
1976       }
1977 
1978     case _degenerated_updaterefs:
1979       if (has_forwarded_objects()) {
</pre>
<hr />
<pre>
1983           return;
1984         }
1985       }
1986 
1987       op_cleanup();
1988       break;
1989 
1990     default:
1991       ShouldNotReachHere();
1992   }
1993 
1994   if (ShenandoahVerify) {
1995     verifier()-&gt;verify_after_degenerated();
1996   }
1997 
1998   if (VerifyAfterGC) {
1999     Universe::verify();
2000   }
2001 
2002   metrics.snap_after();

2003 
2004   // Check for futility and fail. There is no reason to do several back-to-back Degenerated cycles,
2005   // because that probably means the heap is overloaded and/or fragmented.
<span class="line-modified">2006   if (!metrics.is_good_progress()) {</span>
2007     _progress_last_gc.unset();
2008     cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);
2009     op_degenerated_futile();
2010   } else {
2011     _progress_last_gc.set();
2012   }
2013 }
2014 
2015 void ShenandoahHeap::op_degenerated_fail() {
2016   log_info(gc)(&quot;Cannot finish degeneration, upgrading to Full GC&quot;);
2017   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2018   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2019 }
2020 
2021 void ShenandoahHeap::op_degenerated_futile() {
2022   shenandoah_policy()-&gt;record_degenerated_upgrade_to_full();
2023   op_full(GCCause::_shenandoah_upgrade_to_full_gc);
2024 }
2025 











2026 void ShenandoahHeap::force_satb_flush_all_threads() {
2027   if (!is_concurrent_mark_in_progress() &amp;&amp; !is_concurrent_traversal_in_progress()) {
2028     // No need to flush SATBs
2029     return;
2030   }
2031 
2032   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2033     ShenandoahThreadLocalData::set_force_satb_flush(t, true);
2034   }
2035   // The threads are not &quot;acquiring&quot; their thread-local data, but it does not
2036   // hurt to &quot;release&quot; the updates here anyway.
2037   OrderAccess::fence();
2038 }
2039 
2040 void ShenandoahHeap::set_gc_state_all_threads(char state) {
2041   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
2042     ShenandoahThreadLocalData::set_gc_state(t, state);
2043   }
2044 }
2045 
2046 void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {
2047   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Should really be Shenandoah safepoint&quot;);
2048   _gc_state.set_cond(mask, value);
2049   set_gc_state_all_threads(_gc_state.raw_value());
2050 }
2051 
2052 void ShenandoahHeap::set_concurrent_mark_in_progress(bool in_progress) {
<span class="line-modified">2053   if (has_forwarded_objects()) {</span>
<span class="line-added">2054     set_gc_state_mask(MARKING | UPDATEREFS, in_progress);</span>
<span class="line-added">2055   } else {</span>
<span class="line-added">2056     set_gc_state_mask(MARKING, in_progress);</span>
<span class="line-added">2057   }</span>
2058   ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2059 }
2060 
2061 void ShenandoahHeap::set_concurrent_traversal_in_progress(bool in_progress) {
<span class="line-modified">2062    set_gc_state_mask(TRAVERSAL, in_progress);</span>
2063    ShenandoahBarrierSet::satb_mark_queue_set().set_active_all_threads(in_progress, !in_progress);
2064 }
2065 
2066 void ShenandoahHeap::set_evacuation_in_progress(bool in_progress) {
2067   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Only call this at safepoint&quot;);
2068   set_gc_state_mask(EVACUATION, in_progress);
2069 }
2070 
<span class="line-modified">2071 void ShenandoahHeap::set_concurrent_root_in_progress(bool in_progress) {</span>
<span class="line-modified">2072   assert(ShenandoahConcurrentRoots::can_do_concurrent_roots(), &quot;Why set the flag?&quot;);</span>
<span class="line-modified">2073   if (in_progress) {</span>
<span class="line-modified">2074     _concurrent_root_in_progress.set();</span>
<span class="line-modified">2075   } else {</span>
<span class="line-modified">2076     _concurrent_root_in_progress.unset();</span>





















2077   }


2078 }
2079 
2080 void ShenandoahHeap::ref_processing_init() {
2081   assert(_max_workers &gt; 0, &quot;Sanity&quot;);
2082 
2083   _ref_processor =
2084     new ReferenceProcessor(&amp;_subject_to_discovery,  // is_subject_to_discovery
2085                            ParallelRefProcEnabled,  // MT processing
2086                            _max_workers,            // Degree of MT processing
2087                            true,                    // MT discovery
2088                            _max_workers,            // Degree of MT discovery
2089                            false,                   // Reference discovery is not atomic
2090                            NULL,                    // No closure, should be installed before use
2091                            true);                   // Scale worker threads
2092 
2093   shenandoah_assert_rp_isalive_not_installed();
2094 }
2095 
2096 GCTracer* ShenandoahHeap::tracer() {
2097   return shenandoah_policy()-&gt;tracer();
2098 }
2099 
2100 size_t ShenandoahHeap::tlab_used(Thread* thread) const {
2101   return _free_set-&gt;used();
2102 }
2103 
2104 bool ShenandoahHeap::try_cancel_gc() {
2105   while (true) {
2106     jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);
2107     if (prev == CANCELLABLE) return true;
2108     else if (prev == CANCELLED) return false;
2109     assert(ShenandoahSuspendibleWorkers, &quot;should not get here when not using suspendible workers&quot;);
2110     assert(prev == NOT_CANCELLED, &quot;must be NOT_CANCELLED&quot;);
<span class="line-modified">2111     if (Thread::current()-&gt;is_Java_thread()) {</span>
2112       // We need to provide a safepoint here, otherwise we might
2113       // spin forever if a SP is pending.
2114       ThreadBlockInVM sp(JavaThread::current());
2115       SpinPause();
2116     }
2117   }
2118 }
2119 
2120 void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {
2121   if (try_cancel_gc()) {
2122     FormatBuffer&lt;&gt; msg(&quot;Cancelling GC: %s&quot;, GCCause::to_string(cause));
2123     log_info(gc)(&quot;%s&quot;, msg.buffer());
2124     Events::log(Thread::current(), &quot;%s&quot;, msg.buffer());
2125   }
2126 }
2127 
2128 uint ShenandoahHeap::max_workers() {
2129   return _max_workers;
2130 }
2131 
</pre>
<hr />
<pre>
2135   // Step 0. Notify policy to disable event recording.
2136   _shenandoah_policy-&gt;record_shutdown();
2137 
2138   // Step 1. Notify control thread that we are in shutdown.
2139   // Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.
2140   // Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.
2141   control_thread()-&gt;prepare_for_graceful_shutdown();
2142 
2143   // Step 2. Notify GC workers that we are cancelling GC.
2144   cancel_gc(GCCause::_shenandoah_stop_vm);
2145 
2146   // Step 3. Wait until GC worker exits normally.
2147   control_thread()-&gt;stop();
2148 
2149   // Step 4. Stop String Dedup thread if it is active
2150   if (ShenandoahStringDedup::is_enabled()) {
2151     ShenandoahStringDedup::stop();
2152   }
2153 }
2154 
<span class="line-modified">2155 void ShenandoahHeap::stw_unload_classes(bool full_gc) {</span>
<span class="line-modified">2156   if (!unload_classes()) return;</span>








2157   bool purged_class;
2158 
2159   // Unload classes and purge SystemDictionary.
2160   {
2161     ShenandoahGCPhase phase(full_gc ?
2162                             ShenandoahPhaseTimings::full_gc_purge_class_unload :
2163                             ShenandoahPhaseTimings::purge_class_unload);
2164     purged_class = SystemDictionary::do_unloading(gc_timer());
2165   }
2166 
2167   {
2168     ShenandoahGCPhase phase(full_gc ?
2169                             ShenandoahPhaseTimings::full_gc_purge_par :
2170                             ShenandoahPhaseTimings::purge_par);
<span class="line-modified">2171     ShenandoahIsAliveSelector is_alive;</span>
<span class="line-modified">2172     uint num_workers = _workers-&gt;active_workers();</span>
<span class="line-added">2173     ShenandoahClassUnloadingTask unlink_task(is_alive.is_alive_closure(), num_workers, purged_class);</span>
2174     _workers-&gt;run_task(&amp;unlink_task);
2175   }
2176 
2177   {
2178     ShenandoahGCPhase phase(full_gc ?
<span class="line-modified">2179                             ShenandoahPhaseTimings::full_gc_purge_cldg :</span>
<span class="line-modified">2180                             ShenandoahPhaseTimings::purge_cldg);</span>
2181     ClassLoaderDataGraph::purge();
2182   }
<span class="line-added">2183   // Resize and verify metaspace</span>
<span class="line-added">2184   MetaspaceGC::compute_new_size();</span>
<span class="line-added">2185   MetaspaceUtils::verify_metrics();</span>
<span class="line-added">2186 }</span>
<span class="line-added">2187 </span>
<span class="line-added">2188 // Weak roots are either pre-evacuated (final mark) or updated (final updaterefs),</span>
<span class="line-added">2189 // so they should not have forwarded oops.</span>
<span class="line-added">2190 // However, we do need to &quot;null&quot; dead oops in the roots, if can not be done</span>
<span class="line-added">2191 // in concurrent cycles.</span>
<span class="line-added">2192 void ShenandoahHeap::stw_process_weak_roots(bool full_gc) {</span>
<span class="line-added">2193   ShenandoahGCPhase root_phase(full_gc ?</span>
<span class="line-added">2194                                ShenandoahPhaseTimings::full_gc_purge :</span>
<span class="line-added">2195                                ShenandoahPhaseTimings::purge);</span>
<span class="line-added">2196   uint num_workers = _workers-&gt;active_workers();</span>
<span class="line-added">2197   ShenandoahPhaseTimings::Phase timing_phase = full_gc ?</span>
<span class="line-added">2198                                                ShenandoahPhaseTimings::full_gc_purge_par :</span>
<span class="line-added">2199                                                ShenandoahPhaseTimings::purge_par;</span>
<span class="line-added">2200   // Cleanup weak roots</span>
<span class="line-added">2201   ShenandoahGCPhase phase(timing_phase);</span>
<span class="line-added">2202   phase_timings()-&gt;record_workers_start(timing_phase);</span>
<span class="line-added">2203   if (has_forwarded_objects()) {</span>
<span class="line-added">2204     if (is_traversal_mode()) {</span>
<span class="line-added">2205       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">2206       ShenandoahTraversalUpdateRefsClosure keep_alive;</span>
<span class="line-added">2207       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahTraversalUpdateRefsClosure&gt;</span>
<span class="line-added">2208         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">2209       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">2210     } else {</span>
<span class="line-added">2211       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-added">2212       ShenandoahUpdateRefsClosure keep_alive;</span>
<span class="line-added">2213       ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;</span>
<span class="line-added">2214         cleaning_task(&amp;is_alive, &amp;keep_alive, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">2215       _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">2216     }</span>
<span class="line-added">2217   } else {</span>
<span class="line-added">2218     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-added">2219 #ifdef ASSERT</span>
<span class="line-added">2220     ShenandoahAssertNotForwardedClosure verify_cl;</span>
<span class="line-added">2221     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, ShenandoahAssertNotForwardedClosure&gt;</span>
<span class="line-added">2222       cleaning_task(&amp;is_alive, &amp;verify_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">2223 #else</span>
<span class="line-added">2224     ShenandoahParallelWeakRootsCleaningTask&lt;ShenandoahIsAliveClosure, DoNothingClosure&gt;</span>
<span class="line-added">2225       cleaning_task(&amp;is_alive, &amp;do_nothing_cl, num_workers, !ShenandoahConcurrentRoots::should_do_concurrent_class_unloading());</span>
<span class="line-added">2226 #endif</span>
<span class="line-added">2227     _workers-&gt;run_task(&amp;cleaning_task);</span>
<span class="line-added">2228   }</span>
<span class="line-added">2229   phase_timings()-&gt;record_workers_end(timing_phase);</span>
<span class="line-added">2230 }</span>
<span class="line-added">2231 </span>
<span class="line-added">2232 void ShenandoahHeap::parallel_cleaning(bool full_gc) {</span>
<span class="line-added">2233   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">2234   stw_process_weak_roots(full_gc);</span>
<span class="line-added">2235   if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">2236     stw_unload_classes(full_gc);</span>
<span class="line-added">2237   }</span>
2238 }
2239 
2240 void ShenandoahHeap::set_has_forwarded_objects(bool cond) {
<span class="line-modified">2241   if (is_traversal_mode()) {</span>
<span class="line-added">2242     set_gc_state_mask(HAS_FORWARDED | UPDATEREFS, cond);</span>
<span class="line-added">2243   } else {</span>
<span class="line-added">2244     set_gc_state_mask(HAS_FORWARDED, cond);</span>
<span class="line-added">2245   }</span>
<span class="line-added">2246 </span>
2247 }
2248 
2249 void ShenandoahHeap::set_process_references(bool pr) {
2250   _process_references.set_cond(pr);
2251 }
2252 
2253 void ShenandoahHeap::set_unload_classes(bool uc) {
2254   _unload_classes.set_cond(uc);
2255 }
2256 
2257 bool ShenandoahHeap::process_references() const {
2258   return _process_references.is_set();
2259 }
2260 
2261 bool ShenandoahHeap::unload_classes() const {
2262   return _unload_classes.is_set();
2263 }
2264 
2265 address ShenandoahHeap::in_cset_fast_test_addr() {
2266   ShenandoahHeap* heap = ShenandoahHeap::heap();
2267   assert(heap-&gt;collection_set() != NULL, &quot;Sanity&quot;);
2268   return (address) heap-&gt;collection_set()-&gt;biased_map_address();
2269 }
2270 
2271 address ShenandoahHeap::cancelled_gc_addr() {
2272   return (address) ShenandoahHeap::heap()-&gt;_cancelled_gc.addr_of();
2273 }
2274 
2275 address ShenandoahHeap::gc_state_addr() {
2276   return (address) ShenandoahHeap::heap()-&gt;_gc_state.addr_of();
2277 }
2278 
2279 size_t ShenandoahHeap::bytes_allocated_since_gc_start() {
<span class="line-modified">2280   return Atomic::load_acquire(&amp;_bytes_allocated_since_gc_start);</span>
2281 }
2282 
2283 void ShenandoahHeap::reset_bytes_allocated_since_gc_start() {
<span class="line-modified">2284   Atomic::release_store_fence(&amp;_bytes_allocated_since_gc_start, (size_t)0);</span>
2285 }
2286 
2287 void ShenandoahHeap::set_degenerated_gc_in_progress(bool in_progress) {
2288   _degenerated_gc_in_progress.set_cond(in_progress);
2289 }
2290 
2291 void ShenandoahHeap::set_full_gc_in_progress(bool in_progress) {
2292   _full_gc_in_progress.set_cond(in_progress);
2293 }
2294 
2295 void ShenandoahHeap::set_full_gc_move_in_progress(bool in_progress) {
2296   assert (is_full_gc_in_progress(), &quot;should be&quot;);
2297   _full_gc_move_in_progress.set_cond(in_progress);
2298 }
2299 
2300 void ShenandoahHeap::set_update_refs_in_progress(bool in_progress) {
2301   set_gc_state_mask(UPDATEREFS, in_progress);
2302 }
2303 
2304 void ShenandoahHeap::register_nmethod(nmethod* nm) {
<span class="line-modified">2305   ShenandoahCodeRoots::register_nmethod(nm);</span>
2306 }
2307 
2308 void ShenandoahHeap::unregister_nmethod(nmethod* nm) {
<span class="line-modified">2309   ShenandoahCodeRoots::unregister_nmethod(nm);</span>
<span class="line-added">2310 }</span>
<span class="line-added">2311 </span>
<span class="line-added">2312 void ShenandoahHeap::flush_nmethod(nmethod* nm) {</span>
<span class="line-added">2313   ShenandoahCodeRoots::flush_nmethod(nm);</span>
2314 }
2315 
2316 oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {
<span class="line-modified">2317   heap_region_containing(o)-&gt;record_pin();</span>


2318   return o;
2319 }
2320 
2321 void ShenandoahHeap::unpin_object(JavaThread* thr, oop o) {
<span class="line-modified">2322   heap_region_containing(o)-&gt;record_unpin();</span>
<span class="line-added">2323 }</span>
<span class="line-added">2324 </span>
<span class="line-added">2325 void ShenandoahHeap::sync_pinned_region_status() {</span>
2326   ShenandoahHeapLocker locker(lock());
<span class="line-modified">2327 </span>
<span class="line-added">2328   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">2329     ShenandoahHeapRegion *r = get_region(i);</span>
<span class="line-added">2330     if (r-&gt;is_active()) {</span>
<span class="line-added">2331       if (r-&gt;is_pinned()) {</span>
<span class="line-added">2332         if (r-&gt;pin_count() == 0) {</span>
<span class="line-added">2333           r-&gt;make_unpinned();</span>
<span class="line-added">2334         }</span>
<span class="line-added">2335       } else {</span>
<span class="line-added">2336         if (r-&gt;pin_count() &gt; 0) {</span>
<span class="line-added">2337           r-&gt;make_pinned();</span>
<span class="line-added">2338         }</span>
<span class="line-added">2339       }</span>
<span class="line-added">2340     }</span>
<span class="line-added">2341   }</span>
<span class="line-added">2342 </span>
<span class="line-added">2343   assert_pinned_region_status();</span>
2344 }
2345 
<span class="line-added">2346 #ifdef ASSERT</span>
<span class="line-added">2347 void ShenandoahHeap::assert_pinned_region_status() {</span>
<span class="line-added">2348   for (size_t i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">2349     ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-added">2350     assert((r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() &gt; 0) || (!r-&gt;is_pinned() &amp;&amp; r-&gt;pin_count() == 0),</span>
<span class="line-added">2351            &quot;Region &quot; SIZE_FORMAT &quot; pinning status is inconsistent&quot;, i);</span>
<span class="line-added">2352   }</span>
<span class="line-added">2353 }</span>
<span class="line-added">2354 #endif</span>
<span class="line-added">2355 </span>
2356 GCTimer* ShenandoahHeap::gc_timer() const {
2357   return _gc_timer;
2358 }
2359 
<span class="line-added">2360 void ShenandoahHeap::prepare_concurrent_roots() {</span>
<span class="line-added">2361   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">2362   if (ShenandoahConcurrentRoots::should_do_concurrent_roots()) {</span>
<span class="line-added">2363     set_concurrent_root_in_progress(true);</span>
<span class="line-added">2364   }</span>
<span class="line-added">2365 }</span>
<span class="line-added">2366 </span>
<span class="line-added">2367 void ShenandoahHeap::prepare_concurrent_unloading() {</span>
<span class="line-added">2368   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">2369   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">2370     _unloader.prepare();</span>
<span class="line-added">2371   }</span>
<span class="line-added">2372 }</span>
<span class="line-added">2373 </span>
<span class="line-added">2374 void ShenandoahHeap::finish_concurrent_unloading() {</span>
<span class="line-added">2375   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">2376   if (ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {</span>
<span class="line-added">2377     _unloader.finish();</span>
<span class="line-added">2378   }</span>
<span class="line-added">2379 }</span>
<span class="line-added">2380 </span>
2381 #ifdef ASSERT
2382 void ShenandoahHeap::assert_gc_workers(uint nworkers) {
2383   assert(nworkers &gt; 0 &amp;&amp; nworkers &lt;= max_workers(), &quot;Sanity&quot;);
2384 
2385   if (ShenandoahSafepoint::is_at_shenandoah_safepoint()) {
2386     if (UseDynamicNumberOfGCThreads ||
2387         (FLAG_IS_DEFAULT(ParallelGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2388       assert(nworkers &lt;= ParallelGCThreads, &quot;Cannot use more than it has&quot;);
2389     } else {
2390       // Use ParallelGCThreads inside safepoints
2391       assert(nworkers == ParallelGCThreads, &quot;Use ParalleGCThreads within safepoints&quot;);
2392     }
2393   } else {
2394     if (UseDynamicNumberOfGCThreads ||
2395         (FLAG_IS_DEFAULT(ConcGCThreads) &amp;&amp; ForceDynamicNumberOfGCThreads)) {
2396       assert(nworkers &lt;= ConcGCThreads, &quot;Cannot use more than it has&quot;);
2397     } else {
2398       // Use ConcGCThreads outside safepoints
2399       assert(nworkers == ConcGCThreads, &quot;Use ConcGCThreads outside safepoints&quot;);
2400     }
</pre>
<hr />
<pre>
2449         _heap-&gt;pacer()-&gt;report_updaterefs(pointer_delta(top_at_start_ur, r-&gt;bottom()));
2450       }
2451       if (_heap-&gt;check_cancelled_gc_and_yield(_concurrent)) {
2452         return;
2453       }
2454       r = _regions-&gt;next();
2455     }
2456   }
2457 };
2458 
2459 void ShenandoahHeap::update_heap_references(bool concurrent) {
2460   ShenandoahUpdateHeapRefsTask&lt;ShenandoahUpdateHeapRefsClosure&gt; task(&amp;_update_refs_iterator, concurrent);
2461   workers()-&gt;run_task(&amp;task);
2462 }
2463 
2464 void ShenandoahHeap::op_init_updaterefs() {
2465   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2466 
2467   set_evacuation_in_progress(false);
2468 
<span class="line-modified">2469   {</span>
<span class="line-added">2470     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_retire_gclabs);</span>
<span class="line-added">2471     retire_and_reset_gclabs();</span>
<span class="line-added">2472   }</span>
2473 
2474   if (ShenandoahVerify) {
<span class="line-added">2475     if (!is_degenerated_gc_in_progress()) {</span>
<span class="line-added">2476       verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);</span>
<span class="line-added">2477     }</span>
2478     verifier()-&gt;verify_before_updaterefs();
2479   }
2480 
2481   set_update_refs_in_progress(true);





2482 
<span class="line-modified">2483   {</span>
<span class="line-modified">2484     ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_update_refs_prepare);</span>
<span class="line-added">2485 </span>
<span class="line-added">2486     make_parsable(true);</span>
<span class="line-added">2487     for (uint i = 0; i &lt; num_regions(); i++) {</span>
<span class="line-added">2488       ShenandoahHeapRegion* r = get_region(i);</span>
<span class="line-added">2489       r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
<span class="line-added">2490     }</span>
<span class="line-added">2491 </span>
<span class="line-added">2492     // Reset iterator.</span>
<span class="line-added">2493     _update_refs_iterator.reset();</span>
<span class="line-added">2494   }</span>
2495 
2496   if (ShenandoahPacing) {
2497     pacer()-&gt;setup_for_updaterefs();
2498   }
2499 }
2500 
2501 void ShenandoahHeap::op_final_updaterefs() {
2502   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at safepoint&quot;);
2503 
<span class="line-added">2504   finish_concurrent_unloading();</span>
<span class="line-added">2505 </span>
2506   // Check if there is left-over work, and finish it
2507   if (_update_refs_iterator.has_next()) {
<span class="line-modified">2508     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_finish_work);</span>
2509 
2510     // Finish updating references where we left off.
2511     clear_cancelled_gc();
2512     update_heap_references(false);
2513   }
2514 
2515   // Clear cancelled GC, if set. On cancellation path, the block before would handle
2516   // everything. On degenerated paths, cancelled gc would not be set anyway.
2517   if (cancelled_gc()) {
2518     clear_cancelled_gc();
2519   }
2520   assert(!cancelled_gc(), &quot;Should have been done right before&quot;);
2521 
<span class="line-modified">2522   if (ShenandoahVerify &amp;&amp; !is_degenerated_gc_in_progress()) {</span>
<span class="line-modified">2523     verifier()-&gt;verify_roots_in_to_space_except(ShenandoahRootVerifier::ThreadRoots);</span>
<span class="line-modified">2524   }</span>
<span class="line-added">2525 </span>
<span class="line-added">2526   if (is_degenerated_gc_in_progress()) {</span>
<span class="line-added">2527     concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::degen_gc_update_roots);</span>
<span class="line-added">2528   } else {</span>
<span class="line-added">2529     concurrent_mark()-&gt;update_thread_roots(ShenandoahPhaseTimings::final_update_refs_roots);</span>
<span class="line-added">2530   }</span>
<span class="line-added">2531 </span>
<span class="line-added">2532   // Has to be done before cset is clear</span>
<span class="line-added">2533   if (ShenandoahVerify) {</span>
<span class="line-added">2534     verifier()-&gt;verify_roots_in_to_space();</span>
<span class="line-added">2535   }</span>
<span class="line-added">2536 </span>
<span class="line-added">2537   // Drop unnecessary &quot;pinned&quot; state from regions that does not have CP marks</span>
<span class="line-added">2538   // anymore, as this would allow trashing them below.</span>
<span class="line-added">2539   {</span>
<span class="line-added">2540     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_sync_pinned);</span>
<span class="line-added">2541     sync_pinned_region_status();</span>
<span class="line-added">2542   }</span>
2543 
<span class="line-modified">2544   {</span>
<span class="line-added">2545     ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_trash_cset);</span>
<span class="line-added">2546     trash_cset_regions();</span>
<span class="line-added">2547   }</span>
2548 

2549   set_has_forwarded_objects(false);
2550   set_update_refs_in_progress(false);
2551 
2552   if (ShenandoahVerify) {
2553     verifier()-&gt;verify_after_updaterefs();
2554   }
2555 
2556   if (VerifyAfterGC) {
2557     Universe::verify();
2558   }
2559 
2560   {
2561     ShenandoahHeapLocker locker(lock());
2562     _free_set-&gt;rebuild();
2563   }
2564 }
2565 
2566 #ifdef ASSERT
2567 void ShenandoahHeap::assert_heaplock_owned_by_current_thread() {
2568   _lock.assert_owned_by_current_thread();
</pre>
<hr />
<pre>
2798 
2799 void ShenandoahHeap::entry_final_updaterefs() {
2800   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2801   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs);
2802 
2803   static const char* msg = &quot;Pause Final Update Refs&quot;;
2804   GCTraceTime(Info, gc) time(msg, gc_timer());
2805   EventMark em(&quot;%s&quot;, msg);
2806 
2807   ShenandoahWorkerScope scope(workers(),
2808                               ShenandoahWorkerPolicy::calc_workers_for_final_update_ref(),
2809                               &quot;final reference update&quot;);
2810 
2811   op_final_updaterefs();
2812 }
2813 
2814 void ShenandoahHeap::entry_init_traversal() {
2815   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2816   ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_traversal_gc);
2817 
<span class="line-modified">2818   static const char* msg = init_traversal_event_message();</span>
2819   GCTraceTime(Info, gc) time(msg, gc_timer());
2820   EventMark em(&quot;%s&quot;, msg);
2821 
2822   ShenandoahWorkerScope scope(workers(),
2823                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2824                               &quot;init traversal&quot;);
2825 
2826   op_init_traversal();
2827 }
2828 
2829 void ShenandoahHeap::entry_final_traversal() {
2830   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2831   ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_traversal_gc);
2832 
<span class="line-modified">2833   static const char* msg = final_traversal_event_message();</span>
2834   GCTraceTime(Info, gc) time(msg, gc_timer());
2835   EventMark em(&quot;%s&quot;, msg);
2836 
2837   ShenandoahWorkerScope scope(workers(),
2838                               ShenandoahWorkerPolicy::calc_workers_for_stw_traversal(),
2839                               &quot;final traversal&quot;);
2840 
2841   op_final_traversal();
2842 }
2843 
2844 void ShenandoahHeap::entry_full(GCCause::Cause cause) {
2845   ShenandoahGCPhase total_phase(ShenandoahPhaseTimings::total_pause);
2846   ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc);
2847 
2848   static const char* msg = &quot;Pause Full&quot;;
2849   GCTraceTime(Info, gc) time(msg, gc_timer(), cause, true);
2850   EventMark em(&quot;%s&quot;, msg);
2851 
2852   ShenandoahWorkerScope scope(workers(),
2853                               ShenandoahWorkerPolicy::calc_workers_for_fullgc(),
</pre>
<hr />
<pre>
2902                               &quot;concurrent evacuation&quot;);
2903 
2904   try_inject_alloc_failure();
2905   op_conc_evac();
2906 }
2907 
2908 void ShenandoahHeap::entry_updaterefs() {
2909   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_update_refs);
2910 
2911   static const char* msg = &quot;Concurrent update references&quot;;
2912   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2913   EventMark em(&quot;%s&quot;, msg);
2914 
2915   ShenandoahWorkerScope scope(workers(),
2916                               ShenandoahWorkerPolicy::calc_workers_for_conc_update_ref(),
2917                               &quot;concurrent reference update&quot;);
2918 
2919   try_inject_alloc_failure();
2920   op_updaterefs();
2921 }
<span class="line-added">2922 </span>
<span class="line-added">2923 void ShenandoahHeap::entry_roots() {</span>
<span class="line-added">2924   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_roots);</span>
<span class="line-added">2925 </span>
<span class="line-added">2926   static const char* msg = &quot;Concurrent roots processing&quot;;</span>
<span class="line-added">2927   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);</span>
<span class="line-added">2928   EventMark em(&quot;%s&quot;, msg);</span>
<span class="line-added">2929 </span>
<span class="line-added">2930   ShenandoahWorkerScope scope(workers(),</span>
<span class="line-added">2931                               ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),</span>
<span class="line-added">2932                               &quot;concurrent root processing&quot;);</span>
<span class="line-added">2933 </span>
<span class="line-added">2934   try_inject_alloc_failure();</span>
<span class="line-added">2935   op_roots();</span>
<span class="line-added">2936 }</span>
<span class="line-added">2937 </span>
2938 void ShenandoahHeap::entry_cleanup() {
2939   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_cleanup);
2940 
2941   static const char* msg = &quot;Concurrent cleanup&quot;;
2942   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2943   EventMark em(&quot;%s&quot;, msg);
2944 
2945   // This phase does not use workers, no need for setup
2946 
2947   try_inject_alloc_failure();
2948   op_cleanup();
2949 }
2950 
2951 void ShenandoahHeap::entry_reset() {
2952   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_reset);
2953 
2954   static const char* msg = &quot;Concurrent reset&quot;;
2955   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2956   EventMark em(&quot;%s&quot;, msg);
2957 
</pre>
<hr />
<pre>
2965 
2966 void ShenandoahHeap::entry_preclean() {
2967   if (ShenandoahPreclean &amp;&amp; process_references()) {
2968     static const char* msg = &quot;Concurrent precleaning&quot;;
2969     GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2970     EventMark em(&quot;%s&quot;, msg);
2971 
2972     ShenandoahGCPhase conc_preclean(ShenandoahPhaseTimings::conc_preclean);
2973 
2974     ShenandoahWorkerScope scope(workers(),
2975                                 ShenandoahWorkerPolicy::calc_workers_for_conc_preclean(),
2976                                 &quot;concurrent preclean&quot;,
2977                                 /* check_workers = */ false);
2978 
2979     try_inject_alloc_failure();
2980     op_preclean();
2981   }
2982 }
2983 
2984 void ShenandoahHeap::entry_traversal() {
<span class="line-modified">2985   static const char* msg = conc_traversal_event_message();</span>
2986   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
2987   EventMark em(&quot;%s&quot;, msg);
2988 
2989   TraceCollectorStats tcs(monitoring_support()-&gt;concurrent_collection_counters());
2990 
2991   ShenandoahWorkerScope scope(workers(),
2992                               ShenandoahWorkerPolicy::calc_workers_for_conc_traversal(),
2993                               &quot;concurrent traversal&quot;);
2994 
2995   try_inject_alloc_failure();
2996   op_traversal();
2997 }
2998 
2999 void ShenandoahHeap::entry_uncommit(double shrink_before) {
3000   static const char *msg = &quot;Concurrent uncommit&quot;;
3001   GCTraceTime(Info, gc) time(msg, NULL, GCCause::_no_gc, true);
3002   EventMark em(&quot;%s&quot;, msg);
3003 
3004   ShenandoahGCPhase phase(ShenandoahPhaseTimings::conc_uncommit);
3005 
</pre>
<hr />
<pre>
3134 
3135   if (update_refs &amp;&amp; proc_refs &amp;&amp; unload_cls) {
3136     return &quot;Concurrent marking (update refs) (process weakrefs) (unload classes)&quot;;
3137   } else if (update_refs &amp;&amp; proc_refs) {
3138     return &quot;Concurrent marking (update refs) (process weakrefs)&quot;;
3139   } else if (update_refs &amp;&amp; unload_cls) {
3140     return &quot;Concurrent marking (update refs) (unload classes)&quot;;
3141   } else if (proc_refs &amp;&amp; unload_cls) {
3142     return &quot;Concurrent marking (process weakrefs) (unload classes)&quot;;
3143   } else if (update_refs) {
3144     return &quot;Concurrent marking (update refs)&quot;;
3145   } else if (proc_refs) {
3146     return &quot;Concurrent marking (process weakrefs)&quot;;
3147   } else if (unload_cls) {
3148     return &quot;Concurrent marking (unload classes)&quot;;
3149   } else {
3150     return &quot;Concurrent marking&quot;;
3151   }
3152 }
3153 
<span class="line-added">3154 const char* ShenandoahHeap::init_traversal_event_message() const {</span>
<span class="line-added">3155   bool proc_refs = process_references();</span>
<span class="line-added">3156   bool unload_cls = unload_classes();</span>
<span class="line-added">3157 </span>
<span class="line-added">3158   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">3159     return &quot;Pause Init Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">3160   } else if (proc_refs) {</span>
<span class="line-added">3161     return &quot;Pause Init Traversal (process weakrefs)&quot;;</span>
<span class="line-added">3162   } else if (unload_cls) {</span>
<span class="line-added">3163     return &quot;Pause Init Traversal (unload classes)&quot;;</span>
<span class="line-added">3164   } else {</span>
<span class="line-added">3165     return &quot;Pause Init Traversal&quot;;</span>
<span class="line-added">3166   }</span>
<span class="line-added">3167 }</span>
<span class="line-added">3168 </span>
<span class="line-added">3169 const char* ShenandoahHeap::final_traversal_event_message() const {</span>
<span class="line-added">3170   bool proc_refs = process_references();</span>
<span class="line-added">3171   bool unload_cls = unload_classes();</span>
<span class="line-added">3172 </span>
<span class="line-added">3173   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">3174     return &quot;Pause Final Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">3175   } else if (proc_refs) {</span>
<span class="line-added">3176     return &quot;Pause Final Traversal (process weakrefs)&quot;;</span>
<span class="line-added">3177   } else if (unload_cls) {</span>
<span class="line-added">3178     return &quot;Pause Final Traversal (unload classes)&quot;;</span>
<span class="line-added">3179   } else {</span>
<span class="line-added">3180     return &quot;Pause Final Traversal&quot;;</span>
<span class="line-added">3181   }</span>
<span class="line-added">3182 }</span>
<span class="line-added">3183 </span>
<span class="line-added">3184 const char* ShenandoahHeap::conc_traversal_event_message() const {</span>
<span class="line-added">3185   bool proc_refs = process_references();</span>
<span class="line-added">3186   bool unload_cls = unload_classes();</span>
<span class="line-added">3187 </span>
<span class="line-added">3188   if (proc_refs &amp;&amp; unload_cls) {</span>
<span class="line-added">3189     return &quot;Concurrent Traversal (process weakrefs) (unload classes)&quot;;</span>
<span class="line-added">3190   } else if (proc_refs) {</span>
<span class="line-added">3191     return &quot;Concurrent Traversal (process weakrefs)&quot;;</span>
<span class="line-added">3192   } else if (unload_cls) {</span>
<span class="line-added">3193     return &quot;Concurrent Traversal (unload classes)&quot;;</span>
<span class="line-added">3194   } else {</span>
<span class="line-added">3195     return &quot;Concurrent Traversal&quot;;</span>
<span class="line-added">3196   }</span>
<span class="line-added">3197 }</span>
<span class="line-added">3198 </span>
3199 const char* ShenandoahHeap::degen_event_message(ShenandoahDegenPoint point) const {
3200   switch (point) {
3201     case _degenerated_unset:
3202       return &quot;Pause Degenerated GC (&lt;UNSET&gt;)&quot;;
3203     case _degenerated_traversal:
3204       return &quot;Pause Degenerated GC (Traversal)&quot;;
3205     case _degenerated_outside_cycle:
3206       return &quot;Pause Degenerated GC (Outside of Cycle)&quot;;
3207     case _degenerated_mark:
3208       return &quot;Pause Degenerated GC (Mark)&quot;;
3209     case _degenerated_evac:
3210       return &quot;Pause Degenerated GC (Evacuation)&quot;;
3211     case _degenerated_updaterefs:
3212       return &quot;Pause Degenerated GC (Update Refs)&quot;;
3213     default:
3214       ShouldNotReachHere();
3215       return &quot;ERROR&quot;;
3216   }
3217 }
3218 
</pre>
<hr />
<pre>
3223   for (uint i = 0; i &lt; num_regions(); i++) {
3224     assert(_liveness_cache[worker_id][i] == 0, &quot;liveness cache should be empty&quot;);
3225   }
3226 #endif
3227   return _liveness_cache[worker_id];
3228 }
3229 
3230 void ShenandoahHeap::flush_liveness_cache(uint worker_id) {
3231   assert(worker_id &lt; _max_workers, &quot;sanity&quot;);
3232   assert(_liveness_cache != NULL, &quot;sanity&quot;);
3233   jushort* ld = _liveness_cache[worker_id];
3234   for (uint i = 0; i &lt; num_regions(); i++) {
3235     ShenandoahHeapRegion* r = get_region(i);
3236     jushort live = ld[i];
3237     if (live &gt; 0) {
3238       r-&gt;increase_live_data_gc_words(live);
3239       ld[i] = 0;
3240     }
3241   }
3242 }













</pre>
</td>
</tr>
</table>
<center><a href="shenandoahFreeSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
 26 
 27 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 28 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 29 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahConcurrentMark.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahStringDedup.inline.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
<a name="3" id="anc3"></a>
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/prefetch.inline.hpp&quot;
 37 
 38 template &lt;class T&gt;
 39 void ShenandoahConcurrentMark::do_task(ShenandoahObjToScanQueue* q, T* cl, jushort* live_data, ShenandoahMarkTask* task) {
 40   oop obj = task-&gt;obj();
 41 
 42   shenandoah_assert_not_forwarded_except(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress() &amp;&amp; _heap-&gt;cancelled_gc());
 43   shenandoah_assert_marked(NULL, obj);
 44   shenandoah_assert_not_in_cset_except(NULL, obj, _heap-&gt;cancelled_gc());
 45 
 46   if (task-&gt;is_not_chunked()) {
 47     if (obj-&gt;is_instance()) {
 48       // Case 1: Normal oop, process as usual.
 49       obj-&gt;oop_iterate(cl);
 50     } else if (obj-&gt;is_objArray()) {
 51       // Case 2: Object array instance and no chunk is set. Must be the first
 52       // time we visit it, start the chunked processing.
 53       do_chunked_array_start&lt;T&gt;(q, cl, obj);
 54     } else {
 55       // Case 3: Primitive array. Do nothing, no oops there. We use the same
 56       // performance tweak TypeArrayKlass::oop_oop_iterate_impl is using:
 57       // We skip iterating over the klass pointer since we know that
 58       // Universe::TypeArrayKlass never moves.
 59       assert (obj-&gt;is_typeArray(), &quot;should be type array&quot;);
 60     }
 61     // Count liveness the last: push the outstanding work to the queues first
 62     count_liveness(live_data, obj);
 63   } else {
 64     // Case 4: Array chunk, has sensible chunk id. Process it.
 65     do_chunked_array&lt;T&gt;(q, cl, obj, task-&gt;chunk(), task-&gt;pow());
 66   }
 67 }
 68 
 69 inline void ShenandoahConcurrentMark::count_liveness(jushort* live_data, oop obj) {
 70   size_t region_idx = _heap-&gt;heap_region_index_containing(obj);
 71   ShenandoahHeapRegion* region = _heap-&gt;get_region(region_idx);
<a name="4" id="anc4"></a><span class="line-modified"> 72   size_t size = obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
 73 
 74   if (!region-&gt;is_humongous_start()) {
 75     assert(!region-&gt;is_humongous(), &quot;Cannot have continuations here&quot;);
 76     size_t max = (1 &lt;&lt; (sizeof(jushort) * 8)) - 1;
 77     if (size &gt;= max) {
 78       // too big, add to region data directly
 79       region-&gt;increase_live_data_gc_words(size);
 80     } else {
 81       jushort cur = live_data[region_idx];
 82       size_t new_val = cur + size;
 83       if (new_val &gt;= max) {
 84         // overflow, flush to region data
 85         region-&gt;increase_live_data_gc_words(new_val);
 86         live_data[region_idx] = 0;
 87       } else {
 88         // still good, remember in locals
 89         live_data[region_idx] = (jushort) new_val;
 90       }
 91     }
 92   } else {
 93     shenandoah_assert_in_correct_region(NULL, obj);
 94     size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);
 95 
 96     for (size_t i = region_idx; i &lt; region_idx + num_regions; i++) {
 97       ShenandoahHeapRegion* chain_reg = _heap-&gt;get_region(i);
 98       assert(chain_reg-&gt;is_humongous(), &quot;Expecting a humongous region&quot;);
 99       chain_reg-&gt;increase_live_data_gc_words(chain_reg-&gt;used() &gt;&gt; LogHeapWordSize);
100     }
101   }
102 }
103 
104 template &lt;class T&gt;
105 inline void ShenandoahConcurrentMark::do_chunked_array_start(ShenandoahObjToScanQueue* q, T* cl, oop obj) {
106   assert(obj-&gt;is_objArray(), &quot;expect object array&quot;);
107   objArrayOop array = objArrayOop(obj);
108   int len = array-&gt;length();
109 
110   if (len &lt;= (int) ObjArrayMarkingStride*2) {
111     // A few slices only, process directly
112     array-&gt;oop_iterate_range(cl, 0, len);
113   } else {
114     int bits = log2_long((size_t) len);
115     // Compensate for non-power-of-two arrays, cover the array in excess:
116     if (len != (1 &lt;&lt; bits)) bits++;
117 
118     // Only allow full chunks on the queue. This frees do_chunked_array() from checking from/to
119     // boundaries against array-&gt;length(), touching the array header on every chunk.
120     //
121     // To do this, we cut the prefix in full-sized chunks, and submit them on the queue.
122     // If the array is not divided in chunk sizes, then there would be an irregular tail,
123     // which we will process separately.
124 
125     int last_idx = 0;
126 
127     int chunk = 1;
128     int pow = bits;
129 
130     // Handle overflow
131     if (pow &gt;= 31) {
132       assert (pow == 31, &quot;sanity&quot;);
133       pow--;
134       chunk = 2;
135       last_idx = (1 &lt;&lt; pow);
136       bool pushed = q-&gt;push(ShenandoahMarkTask(array, 1, pow));
137       assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
138     }
139 
140     // Split out tasks, as suggested in ObjArrayChunkedTask docs. Record the last
141     // successful right boundary to figure out the irregular tail.
142     while ((1 &lt;&lt; pow) &gt; (int)ObjArrayMarkingStride &amp;&amp;
143            (chunk*2 &lt; ShenandoahMarkTask::chunk_size())) {
144       pow--;
145       int left_chunk = chunk*2 - 1;
146       int right_chunk = chunk*2;
147       int left_chunk_end = left_chunk * (1 &lt;&lt; pow);
148       if (left_chunk_end &lt; len) {
149         bool pushed = q-&gt;push(ShenandoahMarkTask(array, left_chunk, pow));
150         assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
151         chunk = right_chunk;
152         last_idx = left_chunk_end;
153       } else {
154         chunk = left_chunk;
155       }
156     }
157 
158     // Process the irregular tail, if present
159     int from = last_idx;
160     if (from &lt; len) {
161       array-&gt;oop_iterate_range(cl, from, len);
162     }
163   }
164 }
165 
166 template &lt;class T&gt;
167 inline void ShenandoahConcurrentMark::do_chunked_array(ShenandoahObjToScanQueue* q, T* cl, oop obj, int chunk, int pow) {
168   assert(obj-&gt;is_objArray(), &quot;expect object array&quot;);
169   objArrayOop array = objArrayOop(obj);
170 
171   assert (ObjArrayMarkingStride &gt; 0, &quot;sanity&quot;);
172 
173   // Split out tasks, as suggested in ObjArrayChunkedTask docs. Avoid pushing tasks that
174   // are known to start beyond the array.
175   while ((1 &lt;&lt; pow) &gt; (int)ObjArrayMarkingStride &amp;&amp; (chunk*2 &lt; ShenandoahMarkTask::chunk_size())) {
176     pow--;
177     chunk *= 2;
178     bool pushed = q-&gt;push(ShenandoahMarkTask(array, chunk - 1, pow));
179     assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
180   }
181 
182   int chunk_size = 1 &lt;&lt; pow;
183 
184   int from = (chunk - 1) * chunk_size;
185   int to = chunk * chunk_size;
186 
187 #ifdef ASSERT
188   int len = array-&gt;length();
189   assert (0 &lt;= from &amp;&amp; from &lt; len, &quot;from is sane: %d/%d&quot;, from, len);
190   assert (0 &lt; to &amp;&amp; to &lt;= len, &quot;to is sane: %d/%d&quot;, to, len);
191 #endif
192 
193   array-&gt;oop_iterate_range(cl, from, to);
194 }
195 
196 class ShenandoahSATBBufferClosure : public SATBBufferClosure {
197 private:
198   ShenandoahObjToScanQueue* _queue;
199   ShenandoahHeap* _heap;
200   ShenandoahMarkingContext* const _mark_context;
201 public:
202   ShenandoahSATBBufferClosure(ShenandoahObjToScanQueue* q) :
203     _queue(q),
204     _heap(ShenandoahHeap::heap()),
205     _mark_context(_heap-&gt;marking_context())
206   {
207   }
208 
209   void do_buffer(void **buffer, size_t size) {
210     if (_heap-&gt;has_forwarded_objects()) {
211       if (ShenandoahStringDedup::is_enabled()) {
212         do_buffer_impl&lt;RESOLVE, ENQUEUE_DEDUP&gt;(buffer, size);
213       } else {
214         do_buffer_impl&lt;RESOLVE, NO_DEDUP&gt;(buffer, size);
215       }
216     } else {
217       if (ShenandoahStringDedup::is_enabled()) {
218         do_buffer_impl&lt;NONE, ENQUEUE_DEDUP&gt;(buffer, size);
219       } else {
220         do_buffer_impl&lt;NONE, NO_DEDUP&gt;(buffer, size);
221       }
222     }
223   }
224 
225   template&lt;UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP&gt;
226   void do_buffer_impl(void **buffer, size_t size) {
227     for (size_t i = 0; i &lt; size; ++i) {
228       oop *p = (oop *) &amp;buffer[i];
229       ShenandoahConcurrentMark::mark_through_ref&lt;oop, UPDATE_REFS, STRING_DEDUP&gt;(p, _heap, _queue, _mark_context);
230     }
231   }
232 };
233 
234 template&lt;class T, UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP&gt;
235 inline void ShenandoahConcurrentMark::mark_through_ref(T *p, ShenandoahHeap* heap, ShenandoahObjToScanQueue* q, ShenandoahMarkingContext* const mark_context) {
236   T o = RawAccess&lt;&gt;::oop_load(p);
237   if (!CompressedOops::is_null(o)) {
238     oop obj = CompressedOops::decode_not_null(o);
239     switch (UPDATE_REFS) {
240     case NONE:
241       break;
242     case RESOLVE:
243       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
244       break;
245     case SIMPLE:
246       // We piggy-back reference updating to the marking tasks.
247       obj = heap-&gt;update_with_forwarded_not_null(p, obj);
248       break;
249     case CONCURRENT:
250       obj = heap-&gt;maybe_update_with_forwarded_not_null(p, obj);
251       break;
252     default:
253       ShouldNotReachHere();
254     }
255 
<a name="5" id="anc5"></a><span class="line-modified">256     // Note: Only when concurrently updating references can obj become NULL here.</span>
<span class="line-modified">257     // It happens when a mutator thread beats us by writing another value. In that</span>
<span class="line-modified">258     // case we don&#39;t need to do anything else.</span>



259     if (UPDATE_REFS != CONCURRENT || !CompressedOops::is_null(obj)) {
260       shenandoah_assert_not_forwarded(p, obj);
261       shenandoah_assert_not_in_cset_except(p, obj, heap-&gt;cancelled_gc());
262 
263       if (mark_context-&gt;mark(obj)) {
264         bool pushed = q-&gt;push(ShenandoahMarkTask(obj));
265         assert(pushed, &quot;overflow queue should always succeed pushing&quot;);
266 
267         if ((STRING_DEDUP == ENQUEUE_DEDUP) &amp;&amp; ShenandoahStringDedup::is_candidate(obj)) {
268           assert(ShenandoahStringDedup::is_enabled(), &quot;Must be enabled&quot;);
269           ShenandoahStringDedup::enqueue_candidate(obj);
270         }
271       }
272 
273       shenandoah_assert_marked(p, obj);
274     }
275   }
276 }
277 
278 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHCONCURRENTMARK_INLINE_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
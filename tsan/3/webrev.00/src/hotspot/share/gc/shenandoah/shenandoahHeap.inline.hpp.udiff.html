<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28,40 +29,30 @@</span>
  #include &quot;gc/shared/markBitMap.inline.hpp&quot;
  #include &quot;gc/shared/threadLocalAllocBuffer.inline.hpp&quot;
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shenandoah/shenandoahBrooksPointer.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahWorkGroup.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahControlThread.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
  
<span class="udiff-line-removed">- template &lt;class T&gt;</span>
<span class="udiff-line-removed">- void ShenandoahUpdateRefsClosure::do_oop_work(T* p) {</span>
<span class="udiff-line-removed">-   T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="udiff-line-removed">-   if (!CompressedOops::is_null(o)) {</span>
<span class="udiff-line-removed">-     oop obj = CompressedOops::decode_not_null(o);</span>
<span class="udiff-line-removed">-     _heap-&gt;update_with_forwarded_not_null(p, obj);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahUpdateRefsClosure::do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="udiff-line-removed">- void ShenandoahUpdateRefsClosure::do_oop(narrowOop* p) { do_oop_work(p); }</span>
  
  inline ShenandoahHeapRegion* ShenandoahRegionIterator::next() {
<span class="udiff-line-modified-removed">-   size_t new_index = Atomic::add((size_t) 1, &amp;_index);</span>
<span class="udiff-line-modified-added">+   size_t new_index = Atomic::add(&amp;_index, (size_t) 1);</span>
    // get_region() provides the bounds-check and returns NULL on OOB.
    return _heap-&gt;get_region(new_index - 1);
  }
  
  inline bool ShenandoahHeap::has_forwarded_objects() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,15 +112,15 @@</span>
    T o = RawAccess&lt;&gt;::oop_load(p);
    if (!CompressedOops::is_null(o)) {
      oop heap_oop = CompressedOops::decode_not_null(o);
      if (in_collection_set(heap_oop)) {
        oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="udiff-line-modified-removed">-       if (oopDesc::equals_raw(forwarded_oop, heap_oop)) {</span>
<span class="udiff-line-modified-added">+       if (forwarded_oop == heap_oop) {</span>
          forwarded_oop = evacuate_object(heap_oop, Thread::current());
        }
<span class="udiff-line-modified-removed">-       oop prev = atomic_compare_exchange_oop(forwarded_oop, p, heap_oop);</span>
<span class="udiff-line-modified-removed">-       if (oopDesc::equals_raw(prev, heap_oop)) {</span>
<span class="udiff-line-modified-added">+       oop prev = cas_oop(forwarded_oop, p, heap_oop);</span>
<span class="udiff-line-modified-added">+       if (prev == heap_oop) {</span>
          return forwarded_oop;
        } else {
          return NULL;
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,51 +128,64 @@</span>
    } else {
      return NULL;
    }
  }
  
<span class="udiff-line-modified-removed">- inline oop ShenandoahHeap::atomic_compare_exchange_oop(oop n, oop* addr, oop c) {</span>
<span class="udiff-line-modified-removed">-   return (oop) Atomic::cmpxchg(n, addr, c);</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahHeap::cas_oop(oop n, oop* addr, oop c) {</span>
<span class="udiff-line-modified-added">+   assert(is_aligned(addr, HeapWordSize), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
<span class="udiff-line-added">+   return (oop) Atomic::cmpxchg(addr, c, n);</span>
  }
  
<span class="udiff-line-modified-removed">- inline oop ShenandoahHeap::atomic_compare_exchange_oop(oop n, narrowOop* addr, oop c) {</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, narrowOop c) {</span>
<span class="udiff-line-added">+   assert(is_aligned(addr, sizeof(narrowOop)), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
<span class="udiff-line-added">+   narrowOop val = CompressedOops::encode(n);</span>
<span class="udiff-line-added">+   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, c, val));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, oop c) {</span>
<span class="udiff-line-added">+   assert(is_aligned(addr, sizeof(narrowOop)), &quot;Address should be aligned: &quot; PTR_FORMAT, p2i(addr));</span>
    narrowOop cmp = CompressedOops::encode(c);
    narrowOop val = CompressedOops::encode(n);
<span class="udiff-line-modified-removed">-   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(val, addr, cmp));</span>
<span class="udiff-line-modified-added">+   return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, cmp, val));</span>
  }
  
  template &lt;class T&gt;
  inline oop ShenandoahHeap::maybe_update_with_forwarded_not_null(T* p, oop heap_oop) {
    shenandoah_assert_not_in_cset_loc_except(p, !is_in(p) || is_full_gc_in_progress() || is_degenerated_gc_in_progress());
    shenandoah_assert_correct(p, heap_oop);
  
    if (in_collection_set(heap_oop)) {
      oop forwarded_oop = ShenandoahBarrierSet::resolve_forwarded_not_null(heap_oop);
<span class="udiff-line-modified-removed">-     if (oopDesc::equals_raw(forwarded_oop, heap_oop)) {</span>
<span class="udiff-line-modified-added">+     if (forwarded_oop == heap_oop) {</span>
        // E.g. during evacuation.
        return forwarded_oop;
      }
  
      shenandoah_assert_forwarded_except(p, heap_oop, is_full_gc_in_progress() || is_degenerated_gc_in_progress());
<span class="udiff-line-added">+     shenandoah_assert_not_forwarded(p, forwarded_oop);</span>
      shenandoah_assert_not_in_cset_except(p, forwarded_oop, cancelled_gc());
  
      // If this fails, another thread wrote to p before us, it will be logged in SATB and the
      // reference be updated later.
<span class="udiff-line-modified-removed">-     oop result = atomic_compare_exchange_oop(forwarded_oop, p, heap_oop);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (oopDesc::equals_raw(result, heap_oop)) { // CAS successful.</span>
<span class="udiff-line-modified-removed">-       return forwarded_oop;</span>
<span class="udiff-line-modified-added">+     oop witness = cas_oop(forwarded_oop, p, heap_oop);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (witness != heap_oop) {</span>
<span class="udiff-line-modified-added">+       // CAS failed, someone had beat us to it. Normally, we would return the failure witness,</span>
<span class="udiff-line-added">+       // because that would be the proper write of to-space object, enforced by strong barriers.</span>
<span class="udiff-line-added">+       // However, there is a corner case with arraycopy. It can happen that a Java thread</span>
<span class="udiff-line-added">+       // beats us with an arraycopy, which first copies the array, which potentially contains</span>
<span class="udiff-line-added">+       // from-space refs, and only afterwards updates all from-space refs to to-space refs,</span>
<span class="udiff-line-added">+       // which leaves a short window where the new array elements can be from-space.</span>
<span class="udiff-line-added">+       // In this case, we can just resolve the result again. As we resolve, we need to consider</span>
<span class="udiff-line-added">+       // the contended write might have been NULL.</span>
<span class="udiff-line-added">+       oop result = ShenandoahBarrierSet::resolve_forwarded(witness);</span>
<span class="udiff-line-added">+       shenandoah_assert_not_forwarded_except(p, result, (result == NULL));</span>
<span class="udiff-line-added">+       shenandoah_assert_not_in_cset_except(p, result, (result == NULL) || cancelled_gc());</span>
<span class="udiff-line-added">+       return result;</span>
      } else {
<span class="udiff-line-modified-removed">-       // Note: we used to assert the following here. This doesn&#39;t work because sometimes, during</span>
<span class="udiff-line-modified-removed">-       // marking/updating-refs, it can happen that a Java thread beats us with an arraycopy,</span>
<span class="udiff-line-removed">-       // which first copies the array, which potentially contains from-space refs, and only afterwards</span>
<span class="udiff-line-removed">-       // updates all from-space refs to to-space refs, which leaves a short window where the new array</span>
<span class="udiff-line-removed">-       // elements can be from-space.</span>
<span class="udiff-line-removed">-       // assert(CompressedOops::is_null(result) ||</span>
<span class="udiff-line-removed">-       //        oopDesc::equals_raw(result, ShenandoahBarrierSet::resolve_oop_static_not_null(result)),</span>
<span class="udiff-line-removed">-       //       &quot;expect not forwarded&quot;);</span>
<span class="udiff-line-removed">-       return NULL;</span>
<span class="udiff-line-modified-added">+       // Success! We have updated with known to-space copy. We have already asserted it is sane.</span>
<span class="udiff-line-modified-added">+       return forwarded_oop;</span>
      }
    } else {
      shenandoah_assert_not_forwarded(p, heap_oop);
      return heap_oop;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -243,55 +247,50 @@</span>
      return ShenandoahBarrierSet::resolve_forwarded(p);
    }
  
    assert(ShenandoahThreadLocalData::is_evac_allowed(thread), &quot;must be enclosed in oom-evac scope&quot;);
  
<span class="udiff-line-modified-removed">-   size_t size_no_fwdptr = (size_t) p-&gt;size();</span>
<span class="udiff-line-removed">-   size_t size_with_fwdptr = size_no_fwdptr + ShenandoahBrooksPointer::word_size();</span>
<span class="udiff-line-modified-added">+   size_t size = p-&gt;size();</span>
  
    assert(!heap_region_containing(p)-&gt;is_humongous(), &quot;never evacuate humongous objects&quot;);
  
    bool alloc_from_gclab = true;
<span class="udiff-line-modified-removed">-   HeapWord* filler = NULL;</span>
<span class="udiff-line-modified-added">+   HeapWord* copy = NULL;</span>
  
  #ifdef ASSERT
    if (ShenandoahOOMDuringEvacALot &amp;&amp;
        (os::random() &amp; 1) == 0) { // Simulate OOM every ~2nd slow-path call
<span class="udiff-line-modified-removed">-         filler = NULL;</span>
<span class="udiff-line-modified-added">+         copy = NULL;</span>
    } else {
  #endif
      if (UseTLAB) {
<span class="udiff-line-modified-removed">-       filler = allocate_from_gclab(thread, size_with_fwdptr);</span>
<span class="udiff-line-modified-added">+       copy = allocate_from_gclab(thread, size);</span>
      }
<span class="udiff-line-modified-removed">-     if (filler == NULL) {</span>
<span class="udiff-line-modified-removed">-       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size_with_fwdptr);</span>
<span class="udiff-line-modified-removed">-       filler = allocate_memory(req);</span>
<span class="udiff-line-modified-added">+     if (copy == NULL) {</span>
<span class="udiff-line-modified-added">+       ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);</span>
<span class="udiff-line-modified-added">+       copy = allocate_memory(req);</span>
        alloc_from_gclab = false;
      }
  #ifdef ASSERT
    }
  #endif
  
<span class="udiff-line-modified-removed">-   if (filler == NULL) {</span>
<span class="udiff-line-modified-removed">-     control_thread()-&gt;handle_alloc_failure_evac(size_with_fwdptr);</span>
<span class="udiff-line-modified-added">+   if (copy == NULL) {</span>
<span class="udiff-line-modified-added">+     control_thread()-&gt;handle_alloc_failure_evac(size);</span>
  
      _oom_evac_handler.handle_out_of_memory_during_evacuation();
  
      return ShenandoahBarrierSet::resolve_forwarded(p);
    }
  
<span class="udiff-line-modified-removed">-   // Copy the object and initialize its forwarding ptr:</span>
<span class="udiff-line-modified-removed">-   HeapWord* copy = filler + ShenandoahBrooksPointer::word_size();</span>
<span class="udiff-line-removed">-   oop copy_val = oop(copy);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Copy::aligned_disjoint_words((HeapWord*) p, copy, size_no_fwdptr);</span>
<span class="udiff-line-removed">-   ShenandoahBrooksPointer::initialize(oop(copy));</span>
<span class="udiff-line-modified-added">+   // Copy the object:</span>
<span class="udiff-line-modified-added">+   Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(p), copy, size);</span>
  
    // Try to install the new forwarding pointer.
<span class="udiff-line-modified-removed">-   oop result = ShenandoahBrooksPointer::try_update_forwardee(p, copy_val);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (oopDesc::equals_raw(result, p)) {</span>
<span class="udiff-line-modified-added">+   oop copy_val = oop(copy);</span>
<span class="udiff-line-modified-added">+   oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);</span>
<span class="udiff-line-modified-added">+   if (result == copy_val) {</span>
      // Successfully evacuated. Our copy is now the public one!
      shenandoah_assert_correct(NULL, copy_val);
      return copy_val;
    }  else {
      // Failed to evacuate. We need to deal with the object that is left behind. Since this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -304,15 +303,15 @@</span>
      // object will overwrite this stale copy, or the filler object on LAB retirement will
      // do this. For non-GCLAB allocations, we have no way to retract the allocation, and
      // have to explicitly overwrite the copy with the filler object. With that overwrite,
      // we have to keep the fwdptr initialized and pointing to our (stale) copy.
      if (alloc_from_gclab) {
<span class="udiff-line-modified-removed">-       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(filler, size_with_fwdptr);</span>
<span class="udiff-line-modified-added">+       ShenandoahThreadLocalData::gclab(thread)-&gt;undo_allocation(copy, size);</span>
      } else {
<span class="udiff-line-modified-removed">-       fill_with_object(copy, size_no_fwdptr);</span>
<span class="udiff-line-modified-added">+       fill_with_object(copy, size);</span>
<span class="udiff-line-added">+       shenandoah_assert_correct(NULL, copy_val);</span>
      }
<span class="udiff-line-removed">-     shenandoah_assert_correct(NULL, copy_val);</span>
      shenandoah_assert_correct(NULL, result);
      return result;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -323,17 +322,20 @@</span>
      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
    }
    return !_marking_context-&gt;is_marked(obj);
  }
  
<span class="udiff-line-modified-removed">- template &lt;class T&gt;</span>
<span class="udiff-line-removed">- inline bool ShenandoahHeap::in_collection_set(T p) const {</span>
<span class="udiff-line-removed">-   HeapWord* obj = (HeapWord*) p;</span>
<span class="udiff-line-modified-added">+ inline bool ShenandoahHeap::in_collection_set(oop p) const {</span>
    assert(collection_set() != NULL, &quot;Sanity&quot;);
<span class="udiff-line-modified-removed">-   assert(is_in(obj), &quot;should be in heap&quot;);</span>
<span class="udiff-line-modified-added">+   assert(is_in(p), &quot;should be in heap&quot;);</span>
<span class="udiff-line-added">+   return collection_set()-&gt;is_in(p);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   return collection_set()-&gt;is_in(obj);</span>
<span class="udiff-line-modified-added">+ inline bool ShenandoahHeap::in_collection_set_loc(void* p) const {</span>
<span class="udiff-line-added">+   assert(collection_set() != NULL, &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+   assert(is_in(p), &quot;should be in heap&quot;);</span>
<span class="udiff-line-added">+   return collection_set()-&gt;is_in((HeapWord*)p);</span>
  }
  
  inline bool ShenandoahHeap::is_stable() const {
    return _gc_state.is_clear();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -372,30 +374,36 @@</span>
  
  inline bool ShenandoahHeap::is_update_refs_in_progress() const {
    return _gc_state.is_set(UPDATEREFS);
  }
  
<span class="udiff-line-added">+ inline bool ShenandoahHeap::is_stw_gc_in_progress() const {</span>
<span class="udiff-line-added">+   return is_full_gc_in_progress() || is_degenerated_gc_in_progress();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline bool ShenandoahHeap::is_concurrent_root_in_progress() const {</span>
<span class="udiff-line-added">+   return _concurrent_root_in_progress.is_set();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;class T&gt;
  inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl) {
    marked_object_iterate(region, cl, region-&gt;top());
  }
  
  template&lt;class T&gt;
  inline void ShenandoahHeap::marked_object_iterate(ShenandoahHeapRegion* region, T* cl, HeapWord* limit) {
<span class="udiff-line-removed">-   assert(ShenandoahBrooksPointer::word_offset() &lt; 0, &quot;skip_delta calculation below assumes the forwarding ptr is before obj&quot;);</span>
    assert(! region-&gt;is_humongous_continuation(), &quot;no humongous continuation regions here&quot;);
  
    ShenandoahMarkingContext* const ctx = complete_marking_context();
    assert(ctx-&gt;is_complete(), &quot;sanity&quot;);
  
    MarkBitMap* mark_bit_map = ctx-&gt;mark_bit_map();
    HeapWord* tams = ctx-&gt;top_at_mark_start(region);
  
<span class="udiff-line-modified-removed">-   size_t skip_bitmap_delta = ShenandoahBrooksPointer::word_size() + 1;</span>
<span class="udiff-line-modified-removed">-   size_t skip_objsize_delta = ShenandoahBrooksPointer::word_size() /* + actual obj.size() below */;</span>
<span class="udiff-line-modified-removed">-   HeapWord* start = region-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
<span class="udiff-line-removed">-   HeapWord* end = MIN2(tams + ShenandoahBrooksPointer::word_size(), region-&gt;end());</span>
<span class="udiff-line-modified-added">+   size_t skip_bitmap_delta = 1;</span>
<span class="udiff-line-modified-added">+   HeapWord* start = region-&gt;bottom();</span>
<span class="udiff-line-modified-added">+   HeapWord* end = MIN2(tams, region-&gt;end());</span>
  
    // Step 1. Scan below the TAMS based on bitmap data.
    HeapWord* limit_bitmap = MIN2(limit, tams);
  
    // Try to scan the initial candidate. If the candidate is above the TAMS, it would
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,11 +429,11 @@</span>
  
      int avail;
      do {
        avail = 0;
        for (int c = 0; (c &lt; dist) &amp;&amp; (cb &lt; limit_bitmap); c++) {
<span class="udiff-line-modified-removed">-         Prefetch::read(cb, ShenandoahBrooksPointer::byte_offset());</span>
<span class="udiff-line-modified-added">+         Prefetch::read(cb, oopDesc::mark_offset_in_bytes());</span>
          slots[avail++] = cb;
          cb += skip_bitmap_delta;
          if (cb &lt; limit_bitmap) {
            cb = mark_bit_map-&gt;get_next_marked_addr(cb, limit_bitmap);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,20 +464,20 @@</span>
    }
  
    // Step 2. Accurate size-based traversal, happens past the TAMS.
    // This restarts the scan at TAMS, which makes sure we traverse all objects,
    // regardless of what happened at Step 1.
<span class="udiff-line-modified-removed">-   HeapWord* cs = tams + ShenandoahBrooksPointer::word_size();</span>
<span class="udiff-line-modified-added">+   HeapWord* cs = tams;</span>
    while (cs &lt; limit) {
<span class="udiff-line-modified-removed">-     assert (cs &gt; tams,  &quot;only objects past TAMS here: &quot;   PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(tams));</span>
<span class="udiff-line-modified-added">+     assert (cs &gt;= tams, &quot;only objects past TAMS here: &quot;   PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(tams));</span>
      assert (cs &lt; limit, &quot;only objects below limit here: &quot; PTR_FORMAT &quot; (&quot; PTR_FORMAT &quot;)&quot;, p2i(cs), p2i(limit));
      oop obj = oop(cs);
      assert(oopDesc::is_oop(obj), &quot;sanity&quot;);
      assert(ctx-&gt;is_marked(obj), &quot;object expected to be marked&quot;);
      int size = obj-&gt;size();
      cl-&gt;do_object(obj);
<span class="udiff-line-modified-removed">-     cs += size + skip_objsize_delta;</span>
<span class="udiff-line-modified-added">+     cs += size;</span>
    }
  }
  
  template &lt;class T&gt;
  class ShenandoahObjectToOopClosure : public ObjectClosure {
</pre>
<center><a href="shenandoahHeap.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
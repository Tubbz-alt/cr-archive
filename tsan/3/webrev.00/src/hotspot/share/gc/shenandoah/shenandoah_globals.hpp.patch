diff a/src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp b/src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp
@@ -1,7 +1,9 @@
 /*
- * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -34,12 +36,11 @@
                             notproduct,                                     \
                             manageable,                                     \
                             product_rw,                                     \
                             lp64_product,                                   \
                             range,                                          \
-                            constraint,                                     \
-                            writeable)                                      \
+                            constraint)                                     \
                                                                             \
   experimental(size_t, ShenandoahHeapRegionSize, 0,                         \
           "Size of the Shenandoah regions. Set to zero to detect "          \
           "automatically.")                                                 \
                                                                             \
@@ -63,42 +64,42 @@
           "The heuristics to use in Shenandoah GC. Possible values:"        \
           " *) adaptive - adapt to maintain the given amount of free heap;" \
           " *) static  -  start concurrent GC when static free heap "       \
           "               threshold and static allocation threshold are "   \
           "               tripped;"                                         \
-          " *) passive -  do not start concurrent GC, wait for Full GC; "   \
           " *) aggressive - run concurrent GC continuously, evacuate "      \
           "               everything;"                                      \
           " *) compact - run GC with lower footprint target, may end up "   \
           "               doing continuous GC, evacuate lots of live "      \
           "               objects, uncommit heap aggressively;")            \
                                                                             \
+  experimental(ccstr, ShenandoahGCMode, "normal",                           \
+          "The GC mode to use in Shenandoah GC. Possible values"            \
+          " *) normal    - normal GC (mark-evac-update)"                    \
+          " *) traversal - traversal GC (single-pass)"                      \
+          " *) passive   - disable concurrent GC, do stop-the-world GC")    \
+                                                                            \
   experimental(ccstr, ShenandoahUpdateRefsEarly, "adaptive",                \
           "Run a separate concurrent reference updating phase after"        \
           "concurrent evacuation. Possible values: 'on', 'off', 'adaptive'")\
                                                                             \
   experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
           "How often should (weak, soft, etc) references be processed. "    \
           "References get processed at every Nth GC cycle. Set to zero "    \
           "to disable reference processing.")                               \
                                                                             \
-  experimental(uintx, ShenandoahUnloadClassesFrequency, 5,                  \
+  experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \
           "How often should classes get unloaded. "                         \
           "Class unloading is performed at every Nth GC cycle. "            \
           "Set to zero to disable class unloading during concurrent GC.")   \
                                                                             \
   experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
           "Sets the percentage of garbage a region need to contain before " \
           "it can be marked for collection. Does not apply to all "         \
           "heuristics.")                                                    \
           range(0,100)                                                      \
                                                                             \
-  experimental(uintx, ShenandoahFreeThreshold, 10,                          \
-          "Set the percentage of free heap at which a GC cycle is started. "\
-          "Does not apply to all heuristics.")                              \
-          range(0,100)                                                      \
-                                                                            \
   experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
           "Initial remaining free heap threshold for learning steps in "    \
           "heuristics. In percents of total heap size. Does not apply to "  \
           "all heuristics.")                                                \
           range(0,100)                                                      \
@@ -138,14 +139,15 @@
           "this numbers gives the threshold when to switch to "             \
           "separate update-refs mode. Number is percentage relative "       \
           "to duration(marking)+duration(update-refs).")                    \
                                                                             \
   experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
-          "Adaptive and dynamic heuristics would guarantee a GC cycle "     \
-          "at least with this interval. This is useful when large idle"     \
-          " intervals are present, where GC can run without stealing "      \
-          "time from active application. Time is in milliseconds.")         \
+          "Most heuristics would guarantee a concurrent GC cycle at "       \
+          "least with this interval. This is useful when large idle "       \
+          "intervals are present, where GC can run without stealing "       \
+          "time from active application. Time is in milliseconds. "         \
+          "(Setting this interval to 0 disables this feature).")            \
                                                                             \
   experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
           "Clear soft references always, instead of using any smart "       \
           "cleanup policy. This minimizes footprint at expense of more "    \
           "softref churn in applications.")                                 \
@@ -242,11 +244,11 @@
           "When allocation tracing is enabled, the allocation stalls "      \
           "larger than this threshold would be reported as warnings. "      \
           "Time is in microseconds.")                                       \
                                                                             \
   experimental(uintx, ShenandoahEvacAssist, 10,                             \
-          "How many objects to evacuate on WB assist path. "                \
+          "How many objects to evacuate on LRB assist path. "               \
           "Use zero to disable.")                                           \
                                                                             \
   experimental(bool, ShenandoahPacing, true,                                \
           "Pace application allocations to give GC chance to start "        \
           "and complete before allocation failure is reached.")             \
@@ -292,28 +294,25 @@
                                                                             \
   experimental(bool, ShenandoahImplicitGCInvokesConcurrent, false,          \
           "Should internally-caused GCs invoke concurrent cycles, or go to" \
           "stop-the-world (degenerated/full)?")                             \
                                                                             \
-  experimental(bool, ShenandoahHumongousMoves, true,                        \
+  diagnostic(bool, ShenandoahHumongousMoves, true,                          \
           "Allow moving humongous regions. This makes GC more resistant "   \
           "to external fragmentation that may otherwise fail other "        \
           "humongous allocations, at the expense of higher GC copying "     \
-          "costs.")                                                         \
+          "costs. Currently affects stop-the-world (full) cycle only.")     \
                                                                             \
   diagnostic(bool, ShenandoahOOMDuringEvacALot, false,                      \
           "Simulate OOM during evacuation frequently.")                     \
                                                                             \
   diagnostic(bool, ShenandoahAllocFailureALot, false,                       \
           "Make lots of artificial allocation failures.")                   \
                                                                             \
   diagnostic(bool, ShenandoahTerminationTrace, false,                       \
           "Tracing task termination timings")                               \
                                                                             \
-  develop(bool, ShenandoahVerifyObjectEquals, false,                        \
-          "Verify that == and != are not used on oops. Only in fastdebug")  \
-                                                                            \
   diagnostic(bool, ShenandoahAlwaysPreTouch, false,                         \
           "Pre-touch heap memory, overrides global AlwaysPreTouch")         \
                                                                             \
   experimental(intx, ShenandoahMarkScanPrefetch, 32,                        \
           "How many objects to prefetch ahead when traversing mark bitmaps."\
@@ -350,71 +349,46 @@
           "Turn on/off SATB barriers in Shenandoah")                        \
                                                                             \
   diagnostic(bool, ShenandoahKeepAliveBarrier, true,                        \
           "Turn on/off keep alive barriers in Shenandoah")                  \
                                                                             \
-  diagnostic(bool, ShenandoahWriteBarrier, true,                            \
-          "Turn on/off write barriers in Shenandoah")                       \
-                                                                            \
-  diagnostic(bool, ShenandoahReadBarrier, true,                             \
-          "Turn on/off read barriers in Shenandoah")                        \
-                                                                            \
   diagnostic(bool, ShenandoahStoreValEnqueueBarrier, false,                 \
           "Turn on/off enqueuing of oops for storeval barriers")            \
                                                                             \
-  diagnostic(bool, ShenandoahStoreValReadBarrier, true,                     \
-          "Turn on/off store val read barriers in Shenandoah")              \
-                                                                            \
   diagnostic(bool, ShenandoahCASBarrier, true,                              \
           "Turn on/off CAS barriers in Shenandoah")                         \
                                                                             \
-  diagnostic(bool, ShenandoahAcmpBarrier, true,                             \
-          "Turn on/off acmp barriers in Shenandoah")                        \
-                                                                            \
   diagnostic(bool, ShenandoahCloneBarrier, true,                            \
           "Turn on/off clone barriers in Shenandoah")                       \
                                                                             \
-  diagnostic(bool, ShenandoahStoreCheck, false,                             \
-          "Emit additional code that checks objects are written to only"    \
-          " in to-space")                                                   \
+  diagnostic(bool, ShenandoahLoadRefBarrier, true,                          \
+          "Turn on/off load-reference barriers in Shenandoah")              \
                                                                             \
   experimental(bool, ShenandoahConcurrentScanCodeRoots, true,               \
           "Scan code roots concurrently, instead of during a pause")        \
                                                                             \
   experimental(uintx, ShenandoahCodeRootsStyle, 2,                          \
           "Use this style to scan code cache:"                              \
           " 0 - sequential iterator;"                                       \
           " 1 - parallel iterator;"                                         \
           " 2 - parallel iterator with cset filters;")                      \
                                                                             \
-  experimental(bool, ShenandoahOptimizeStaticFinals, true,                  \
+  diagnostic(bool, ShenandoahOptimizeStaticFinals, true,                    \
           "Optimize barriers on static final fields. "                      \
           "Turn it off for maximum compatibility with reflection or JNI "   \
           "code that manipulates final fields.")                            \
                                                                             \
-  experimental(bool, ShenandoahOptimizeInstanceFinals, false,               \
-          "Optimize barriers on final instance fields."                     \
-          "Turn it off for maximum compatibility with reflection or JNI "   \
-          "code that manipulates final fields.")                            \
-                                                                            \
-  experimental(bool, ShenandoahOptimizeStableFinals, false,                 \
-          "Optimize barriers on stable fields."                             \
-          "Turn it off for maximum compatibility with reflection or JNI "   \
-          "code that manipulates final fields.")                            \
-                                                                            \
-  diagnostic(bool, ShenandoahDecreaseRegisterPressure, false,               \
-          "Try to reuse after-barrier values to reduce register pressure")  \
-                                                                            \
   experimental(bool, ShenandoahCommonGCStateLoads, false,                   \
          "Enable commonming for GC state loads in generated code.")         \
                                                                             \
   develop(bool, ShenandoahVerifyOptoBarriers, false,                        \
           "Verify no missing barriers in C2")                               \
                                                                             \
-  experimental(bool, ShenandoahDontIncreaseWBFreq, true,                    \
-          "Common 2 WriteBarriers or WriteBarrier and a ReadBarrier only "  \
-          "if the resulting WriteBarrier isn't executed more frequently")   \
-                                                                            \
   experimental(bool, ShenandoahLoopOptsAfterExpansion, true,                \
-          "Attempt more loop opts after write barrier expansion")           \
+          "Attempt more loop opts after barrier expansion")                 \
+                                                                            \
+  diagnostic(bool, ShenandoahSelfFixing, true,                              \
+          "Fix references with load reference barrier. Disabling this "     \
+          "might degrade performance.")                                     \
+
 
 #endif // SHARE_GC_SHENANDOAH_SHENANDOAH_GLOBALS_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
<span class="line-added">  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
  29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  33 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  34 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/idealKit.hpp&quot;
  39 #include &quot;opto/macro.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  43 #include &quot;opto/runtime.hpp&quot;</span>
  44 
  45 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  46   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  47 }
  48 
  49 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
<a name="4" id="anc4"></a><span class="line-modified">  50   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),</span>
<span class="line-added">  51     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {</span>
  52 }
  53 
<a name="5" id="anc5"></a><span class="line-modified">  54 int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {</span>
<span class="line-modified">  55   return _enqueue_barriers-&gt;length();</span>
  56 }
  57 
<a name="6" id="anc6"></a><span class="line-modified">  58 ShenandoahEnqueueBarrierNode* ShenandoahBarrierSetC2State::enqueue_barrier(int idx) const {</span>
<span class="line-modified">  59   return _enqueue_barriers-&gt;at(idx);</span>
  60 }
  61 
<a name="7" id="anc7"></a><span class="line-modified">  62 void ShenandoahBarrierSetC2State::add_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {</span>
<span class="line-modified">  63   assert(!_enqueue_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="line-modified">  64   _enqueue_barriers-&gt;append(n);</span>
  65 }
  66 
<a name="8" id="anc8"></a><span class="line-modified">  67 void ShenandoahBarrierSetC2State::remove_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {</span>
<span class="line-modified">  68   if (_enqueue_barriers-&gt;contains(n)) {</span>
<span class="line-modified">  69     _enqueue_barriers-&gt;remove(n);</span>
  70   }
  71 }
  72 
<a name="9" id="anc9"></a><span class="line-modified">  73 int ShenandoahBarrierSetC2State::load_reference_barriers_count() const {</span>
<span class="line-modified">  74   return _load_reference_barriers-&gt;length();</span>





  75 }
  76 
<a name="10" id="anc10"></a><span class="line-modified">  77 ShenandoahLoadReferenceBarrierNode* ShenandoahBarrierSetC2State::load_reference_barrier(int idx) const {</span>
<span class="line-modified">  78   return _load_reference_barriers-&gt;at(idx);</span>







  79 }
  80 
<a name="11" id="anc11"></a><span class="line-modified">  81 void ShenandoahBarrierSetC2State::add_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {</span>
<span class="line-modified">  82   assert(!_load_reference_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="line-modified">  83   _load_reference_barriers-&gt;append(n);</span>









































  84 }
  85 
<a name="12" id="anc12"></a><span class="line-modified">  86 void ShenandoahBarrierSetC2State::remove_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {</span>
<span class="line-modified">  87   if (_load_reference_barriers-&gt;contains(n)) {</span>
<span class="line-modified">  88     _load_reference_barriers-&gt;remove(n);</span>



  89   }
<a name="13" id="anc13"></a>
  90 }
  91 
<a name="14" id="anc14"></a><span class="line-modified">  92 Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="line-modified">  93   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="line-modified">  94     obj = shenandoah_enqueue_barrier(kit, obj);</span>
  95   }
  96   return obj;
  97 }
  98 
<a name="15" id="anc15"></a><span class="line-modified">  99 #define __ kit-&gt;</span>









 100 
 101 bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
 102                                                          BasicType bt, uint adr_idx) const {
 103   intptr_t offset = 0;
 104   Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 105   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);
 106 
 107   if (offset == Type::OffsetBot) {
 108     return false; // cannot unalias unless there are precise offsets
 109   }
 110 
 111   if (alloc == NULL) {
 112     return false; // No allocation found
 113   }
 114 
 115   intptr_t size_in_bytes = type2aelembytes(bt);
 116 
 117   Node* mem = __ memory(adr_idx); // start searching here...
 118 
 119   for (int cnt = 0; cnt &lt; 50; cnt++) {
 120 
 121     if (mem-&gt;is_Store()) {
 122 
 123       Node* st_adr = mem-&gt;in(MemNode::Address);
 124       intptr_t st_offset = 0;
 125       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 126 
 127       if (st_base == NULL) {
 128         break; // inscrutable pointer
 129       }
 130 
 131       // Break we have found a store with same base and offset as ours so break
 132       if (st_base == base &amp;&amp; st_offset == offset) {
 133         break;
 134       }
 135 
 136       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 137         const int MAX_STORE = BytesPerLong;
 138         if (st_offset &gt;= offset + size_in_bytes ||
 139             st_offset &lt;= offset - MAX_STORE ||
 140             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 141           // Success:  The offsets are provably independent.
 142           // (You may ask, why not just test st_offset != offset and be done?
 143           // The answer is that stores of different sizes can co-exist
 144           // in the same sequence of RawMem effects.  We sometimes initialize
 145           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 146           mem = mem-&gt;in(MemNode::Memory);
 147           continue; // advance through independent store memory
 148         }
 149       }
 150 
 151       if (st_base != base
 152           &amp;&amp; MemNode::detect_ptr_independence(base, alloc, st_base,
 153                                               AllocateNode::Ideal_allocation(st_base, phase),
 154                                               phase)) {
 155         // Success:  The bases are provably independent.
 156         mem = mem-&gt;in(MemNode::Memory);
 157         continue; // advance through independent store memory
 158       }
 159     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 160 
 161       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 162       AllocateNode* st_alloc = st_init-&gt;allocation();
 163 
 164       // Make sure that we are looking at the same allocation site.
 165       // The alloc variable is guaranteed to not be null here from earlier check.
 166       if (alloc == st_alloc) {
 167         // Check that the initialization is storing NULL so that no previous store
 168         // has been moved up and directly write a reference
 169         Node* captured_store = st_init-&gt;find_captured_store(offset,
 170                                                             type2aelembytes(T_OBJECT),
 171                                                             phase);
 172         if (captured_store == NULL || captured_store == st_init-&gt;zero_memory()) {
 173           return true;
 174         }
 175       }
 176     }
 177 
 178     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 179     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 180     break;
 181   }
 182 
 183   return false;
 184 }
 185 
 186 #undef __
 187 #define __ ideal.
 188 
 189 void ShenandoahBarrierSetC2::satb_write_barrier_pre(GraphKit* kit,
 190                                                     bool do_load,
 191                                                     Node* obj,
 192                                                     Node* adr,
 193                                                     uint alias_idx,
 194                                                     Node* val,
 195                                                     const TypeOopPtr* val_type,
 196                                                     Node* pre_val,
 197                                                     BasicType bt) const {
 198   // Some sanity checks
 199   // Note: val is unused in this routine.
 200 
 201   if (do_load) {
 202     // We need to generate the load of the previous value
 203     assert(obj != NULL, &quot;must have a base&quot;);
 204     assert(adr != NULL, &quot;where are loading from?&quot;);
 205     assert(pre_val == NULL, &quot;loaded already?&quot;);
 206     assert(val_type != NULL, &quot;need a type&quot;);
 207 
 208     if (ReduceInitialCardMarks
 209         &amp;&amp; satb_can_remove_pre_barrier(kit, &amp;kit-&gt;gvn(), adr, bt, alias_idx)) {
 210       return;
 211     }
 212 
 213   } else {
 214     // In this case both val_type and alias_idx are unused.
 215     assert(pre_val != NULL, &quot;must be loaded already&quot;);
 216     // Nothing to be done if pre_val is null.
 217     if (pre_val-&gt;bottom_type() == TypePtr::NULL_PTR) return;
 218     assert(pre_val-&gt;bottom_type()-&gt;basic_type() == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 219   }
 220   assert(bt == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 221 
 222   IdealKit ideal(kit, true);
 223 
 224   Node* tls = __ thread(); // ThreadLocalStorage
 225 
 226   Node* no_base = __ top();
 227   Node* zero  = __ ConI(0);
 228   Node* zeroX = __ ConX(0);
 229 
 230   float likely  = PROB_LIKELY(0.999);
 231   float unlikely  = PROB_UNLIKELY(0.999);
 232 
 233   // Offsets into the thread
 234   const int index_offset   = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
 235   const int buffer_offset  = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
 236 
 237   // Now the actual pointers into the thread
 238   Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));
 239   Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));
 240 
 241   // Now some of the values
 242   Node* marking;
 243   Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
 244   Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
 245   marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
<a name="16" id="anc16"></a><span class="line-modified"> 246   assert(ShenandoahBarrierC2Support::is_gc_state_load(ld), &quot;Should match the shape&quot;);</span>
 247 
 248   // if (!marking)
 249   __ if_then(marking, BoolTest::ne, zero, unlikely); {
 250     BasicType index_bt = TypeX_X-&gt;basic_type();
 251     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
 252     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
 253 
 254     if (do_load) {
 255       // load original value
 256       // alias_idx correct??
 257       pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
 258     }
 259 
 260     // if (pre_val != NULL)
 261     __ if_then(pre_val, BoolTest::ne, kit-&gt;null()); {
 262       Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);
 263 
 264       // is the queue for this thread full?
 265       __ if_then(index, BoolTest::ne, zeroX, likely); {
 266 
 267         // decrement the index
 268         Node* next_index = kit-&gt;gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));
 269 
 270         // Now get the buffer location we will log the previous value into and store it
 271         Node *log_addr = __ AddP(no_base, buffer, next_index);
 272         __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);
 273         // update the index
 274         __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);
 275 
 276       } __ else_(); {
 277 
 278         // logging buffer is full, call the runtime
 279         const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();
 280         __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, pre_val, tls);
 281       } __ end_if();  // (!index)
 282     } __ end_if();  // (pre_val != NULL)
 283   } __ end_if();  // (!marking)
 284 
 285   // Final sync IdealKit and GraphKit.
 286   kit-&gt;final_sync(ideal);
 287 
 288   if (ShenandoahSATBBarrier &amp;&amp; adr != NULL) {
 289     Node* c = kit-&gt;control();
 290     Node* call = c-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(0);
 291     assert(is_shenandoah_wb_pre_call(call), &quot;shenandoah_wb_pre call expected&quot;);
 292     call-&gt;add_req(adr);
 293   }
 294 }
 295 
 296 bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
 297   return call-&gt;is_CallLeaf() &amp;&amp;
 298          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
 299 }
 300 
<a name="17" id="anc17"></a><span class="line-modified"> 301 bool ShenandoahBarrierSetC2::is_shenandoah_lrb_call(Node* call) {</span>
<span class="line-modified"> 302   if (!call-&gt;is_CallLeaf()) {</span>
<span class="line-modified"> 303     return false;</span>
<span class="line-added"> 304   }</span>
<span class="line-added"> 305 </span>
<span class="line-added"> 306   address entry_point = call-&gt;as_CallLeaf()-&gt;entry_point();</span>
<span class="line-added"> 307   return (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier)) ||</span>
<span class="line-added"> 308          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow)) ||</span>
<span class="line-added"> 309          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
 310 }
 311 
 312 bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
 313   if (n-&gt;Opcode() != Op_If) {
 314     return false;
 315   }
 316 
 317   Node* bol = n-&gt;in(1);
 318   assert(bol-&gt;is_Bool(), &quot;&quot;);
 319   Node* cmpx = bol-&gt;in(1);
 320   if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 321       cmpx-&gt;is_Cmp() &amp;&amp; cmpx-&gt;in(2) == phase-&gt;intcon(0) &amp;&amp;
 322       is_shenandoah_state_load(cmpx-&gt;in(1)-&gt;in(1)) &amp;&amp;
 323       cmpx-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp;
 324       cmpx-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(ShenandoahHeap::MARKING)) {
 325     return true;
 326   }
 327 
 328   return false;
 329 }
 330 
 331 bool ShenandoahBarrierSetC2::is_shenandoah_state_load(Node* n) {
 332   if (!n-&gt;is_Load()) return false;
 333   const int state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());
 334   return n-&gt;in(2)-&gt;is_AddP() &amp;&amp; n-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
 335          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;is_Con()
 336          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == state_offset;
 337 }
 338 
 339 void ShenandoahBarrierSetC2::shenandoah_write_barrier_pre(GraphKit* kit,
 340                                                           bool do_load,
 341                                                           Node* obj,
 342                                                           Node* adr,
 343                                                           uint alias_idx,
 344                                                           Node* val,
 345                                                           const TypeOopPtr* val_type,
 346                                                           Node* pre_val,
 347                                                           BasicType bt) const {
 348   if (ShenandoahSATBBarrier) {
 349     IdealKit ideal(kit);
 350     kit-&gt;sync_kit(ideal);
 351 
 352     satb_write_barrier_pre(kit, do_load, obj, adr, alias_idx, val, val_type, pre_val, bt);
 353 
 354     ideal.sync_kit(kit);
 355     kit-&gt;final_sync(ideal);
 356   }
 357 }
 358 
 359 Node* ShenandoahBarrierSetC2::shenandoah_enqueue_barrier(GraphKit* kit, Node* pre_val) const {
 360   return kit-&gt;gvn().transform(new ShenandoahEnqueueBarrierNode(pre_val));
 361 }
 362 
 363 // Helper that guards and inserts a pre-barrier.
 364 void ShenandoahBarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,
 365                                                 Node* pre_val, bool need_mem_bar) const {
 366   // We could be accessing the referent field of a reference object. If so, when G1
 367   // is enabled, we need to log the value in the referent field in an SATB buffer.
 368   // This routine performs some compile time filters and generates suitable
 369   // runtime filters that guard the pre-barrier code.
 370   // Also add memory barrier for non volatile load from the referent field
 371   // to prevent commoning of loads across safepoint.
 372 
 373   // Some compile time checks.
 374 
 375   // If offset is a constant, is it java_lang_ref_Reference::_reference_offset?
 376   const TypeX* otype = offset-&gt;find_intptr_t_type();
 377   if (otype != NULL &amp;&amp; otype-&gt;is_con() &amp;&amp;
 378       otype-&gt;get_con() != java_lang_ref_Reference::referent_offset) {
 379     // Constant offset but not the reference_offset so just return
 380     return;
 381   }
 382 
 383   // We only need to generate the runtime guards for instances.
 384   const TypeOopPtr* btype = base_oop-&gt;bottom_type()-&gt;isa_oopptr();
 385   if (btype != NULL) {
 386     if (btype-&gt;isa_aryptr()) {
 387       // Array type so nothing to do
 388       return;
 389     }
 390 
 391     const TypeInstPtr* itype = btype-&gt;isa_instptr();
 392     if (itype != NULL) {
 393       // Can the klass of base_oop be statically determined to be
 394       // _not_ a sub-class of Reference and _not_ Object?
 395       ciKlass* klass = itype-&gt;klass();
 396       if ( klass-&gt;is_loaded() &amp;&amp;
 397           !klass-&gt;is_subtype_of(kit-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 398           !kit-&gt;env()-&gt;Object_klass()-&gt;is_subtype_of(klass)) {
 399         return;
 400       }
 401     }
 402   }
 403 
 404   // The compile time filters did not reject base_oop/offset so
 405   // we need to generate the following runtime filters
 406   //
 407   // if (offset == java_lang_ref_Reference::_reference_offset) {
 408   //   if (instance_of(base, java.lang.ref.Reference)) {
 409   //     pre_barrier(_, pre_val, ...);
 410   //   }
 411   // }
 412 
 413   float likely   = PROB_LIKELY(  0.999);
 414   float unlikely = PROB_UNLIKELY(0.999);
 415 
 416   IdealKit ideal(kit);
 417 
 418   Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset);
 419 
 420   __ if_then(offset, BoolTest::eq, referent_off, unlikely); {
 421       // Update graphKit memory and control from IdealKit.
 422       kit-&gt;sync_kit(ideal);
 423 
 424       Node* ref_klass_con = kit-&gt;makecon(TypeKlassPtr::make(kit-&gt;env()-&gt;Reference_klass()));
 425       Node* is_instof = kit-&gt;gen_instanceof(base_oop, ref_klass_con);
 426 
 427       // Update IdealKit memory and control from graphKit.
 428       __ sync_kit(kit);
 429 
 430       Node* one = __ ConI(1);
 431       // is_instof == 0 if base_oop == NULL
 432       __ if_then(is_instof, BoolTest::eq, one, unlikely); {
 433 
 434         // Update graphKit from IdeakKit.
 435         kit-&gt;sync_kit(ideal);
 436 
 437         // Use the pre-barrier to record the value in the referent field
 438         satb_write_barrier_pre(kit, false /* do_load */,
 439                                NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 440                                pre_val /* pre_val */,
 441                                T_OBJECT);
 442         if (need_mem_bar) {
 443           // Add memory barrier to prevent commoning reads from this field
 444           // across safepoint since GC can change its value.
 445           kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 446         }
 447         // Update IdealKit from graphKit.
 448         __ sync_kit(kit);
 449 
 450       } __ end_if(); // _ref_type != ref_none
 451   } __ end_if(); // offset == referent_offset
 452 
 453   // Final sync IdealKit and GraphKit.
 454   kit-&gt;final_sync(ideal);
 455 }
 456 
 457 #undef __
 458 
 459 const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {
 460   const Type **fields = TypeTuple::fields(2);
 461   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 462   fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
 463   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 464 
 465   // create result type (range)
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
<a name="18" id="anc18"></a><span class="line-modified"> 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop</span>
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
<a name="19" id="anc19"></a><span class="line-modified"> 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {</span>
<span class="line-modified"> 485   const Type **fields = TypeTuple::fields(2);</span>
 486   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
<a name="20" id="anc20"></a><span class="line-modified"> 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);</span>
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
 493   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
<a name="21" id="anc21"></a>

















































































 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 514     GraphKit* kit = parse_access.kit();
 515 
 516     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 517     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 518     Node* value = val.node();
 519     value = shenandoah_storeval_barrier(kit, value);
 520     val.set_node(value);
 521     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 522                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 523   } else {
 524     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 525     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 526     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 527     PhaseGVN&amp; gvn =  opt_access.gvn();
 528     MergeMemNode* mm = opt_access.mem();
 529 
<a name="22" id="anc22"></a>



























 530     if (ShenandoahStoreValEnqueueBarrier) {
<a name="23" id="anc23"></a><span class="line-modified"> 531       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));</span>








 532       val.set_node(enqueue);
 533     }
 534   }
 535   return BarrierSetC2::store_at_resolved(access, val);
 536 }
 537 
 538 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<a name="24" id="anc24"></a><span class="line-modified"> 539   // 1: non-reference load, no additional barrier is needed</span>
<span class="line-modified"> 540   if (!access.is_oop()) {</span>
<span class="line-modified"> 541     return BarrierSetC2::load_at_resolved(access, val_type);;</span>
<span class="line-modified"> 542   }</span>









 543 
<a name="25" id="anc25"></a>
 544   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
<a name="26" id="anc26"></a><span class="line-modified"> 545   DecoratorSet decorators = access.decorators();</span>
<span class="line-modified"> 546   BasicType type = access.type();</span>
<span class="line-modified"> 547 </span>
<span class="line-modified"> 548   // 2: apply LRB if needed</span>
<span class="line-modified"> 549   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="line-modified"> 550     load = new ShenandoahLoadReferenceBarrierNode(NULL,</span>
<span class="line-modified"> 551                                                   load,</span>
<span class="line-modified"> 552                                                   ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));</span>
<span class="line-modified"> 553     if (access.is_parse_access()) {</span>
<span class="line-modified"> 554       load = static_cast&lt;C2ParseAccess &amp;&gt;(access).kit()-&gt;gvn().transform(load);</span>
<span class="line-modified"> 555     } else {</span>
<span class="line-modified"> 556       load = static_cast&lt;C2OptAccess &amp;&gt;(access).gvn().transform(load);</span>
<span class="line-added"> 557     }</span>
 558   }
 559 
<a name="27" id="anc27"></a><span class="line-modified"> 560   // 3: apply keep-alive barrier if needed</span>
<span class="line-modified"> 561   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
<span class="line-modified"> 562     Node* top = Compile::current()-&gt;top();</span>
<span class="line-modified"> 563     Node* adr = access.addr().node();</span>
<span class="line-modified"> 564     Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;</span>
<span class="line-modified"> 565     Node* obj = access.base();</span>
<span class="line-modified"> 566 </span>
<span class="line-modified"> 567     bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;</span>
<span class="line-modified"> 568     bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;</span>
<span class="line-modified"> 569     bool is_traversal_mode = ShenandoahHeap::heap()-&gt;is_traversal_mode();</span>
<span class="line-modified"> 570     bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0 || is_traversal_mode;</span>
<span class="line-modified"> 571 </span>
<span class="line-modified"> 572     // If we are reading the value of the referent field of a Reference</span>
<span class="line-modified"> 573     // object (either by using Unsafe directly or through reflection)</span>
<span class="line-modified"> 574     // then, if SATB is enabled, we need to record the referent in an</span>
<span class="line-modified"> 575     // SATB log buffer using the pre-barrier mechanism.</span>
<span class="line-added"> 576     // Also we need to add memory barrier to prevent commoning reads</span>
<span class="line-added"> 577     // from this field across safepoint since GC can change its value.</span>
<span class="line-added"> 578     if (!on_weak_ref || (unknown &amp;&amp; (offset == top || obj == top)) || !keep_alive) {</span>
<span class="line-added"> 579       return load;</span>
<span class="line-added"> 580     }</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582     assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-added"> 583     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-added"> 584     GraphKit* kit = parse_access.kit();</span>
<span class="line-added"> 585     bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;</span>
<span class="line-added"> 586     bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;</span>
<span class="line-added"> 587     bool in_native = (decorators &amp; IN_NATIVE) != 0;</span>
<span class="line-added"> 588     bool need_cpu_mem_bar = !is_unordered || mismatched || in_native;</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590     if (on_weak_ref) {</span>
<span class="line-added"> 591       // Use the pre-barrier to record the value in the referent field</span>
<span class="line-added"> 592       satb_write_barrier_pre(kit, false /* do_load */,</span>
<span class="line-added"> 593                              NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,</span>
<span class="line-added"> 594                              load /* pre_val */, T_OBJECT);</span>
<span class="line-added"> 595       // Add memory barrier to prevent commoning reads from this field</span>
<span class="line-added"> 596       // across safepoint since GC can change its value.</span>
<span class="line-added"> 597       kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-added"> 598     } else if (unknown) {</span>
<span class="line-added"> 599       // We do not require a mem bar inside pre_barrier if need_mem_bar</span>
<span class="line-added"> 600       // is set: the barriers would be emitted by us.</span>
<span class="line-added"> 601       insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);</span>
<span class="line-added"> 602     }</span>
 603   }
 604 
 605   return load;
 606 }
 607 
 608 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 609                                                    Node* new_val, const Type* value_type) const {
 610   GraphKit* kit = access.kit();
 611   if (access.is_oop()) {
 612     new_val = shenandoah_storeval_barrier(kit, new_val);
 613     shenandoah_write_barrier_pre(kit, false /* do_load */,
 614                                  NULL, NULL, max_juint, NULL, NULL,
 615                                  expected_val /* pre_val */, T_OBJECT);
 616 
 617     MemNode::MemOrd mo = access.mem_node_mo();
 618     Node* mem = access.memory();
 619     Node* adr = access.addr().node();
 620     const TypePtr* adr_type = access.addr().type();
 621     Node* load_store = NULL;
 622 
 623 #ifdef _LP64
 624     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 625       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 626       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 627       if (ShenandoahCASBarrier) {
 628         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 629       } else {
 630         load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 631       }
 632     } else
 633 #endif
 634     {
 635       if (ShenandoahCASBarrier) {
 636         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 637       } else {
 638         load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 639       }
 640     }
 641 
 642     access.set_raw_access(load_store);
 643     pin_atomic_op(access);
 644 
 645 #ifdef _LP64
 646     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
<a name="28" id="anc28"></a><span class="line-modified"> 647       load_store = kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));</span>
 648     }
 649 #endif
<a name="29" id="anc29"></a><span class="line-added"> 650     load_store = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, false));</span>
 651     return load_store;
 652   }
 653   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
 654 }
 655 
 656 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 657                                                               Node* new_val, const Type* value_type) const {
 658   GraphKit* kit = access.kit();
 659   if (access.is_oop()) {
 660     new_val = shenandoah_storeval_barrier(kit, new_val);
 661     shenandoah_write_barrier_pre(kit, false /* do_load */,
 662                                  NULL, NULL, max_juint, NULL, NULL,
 663                                  expected_val /* pre_val */, T_OBJECT);
 664     DecoratorSet decorators = access.decorators();
 665     MemNode::MemOrd mo = access.mem_node_mo();
 666     Node* mem = access.memory();
 667     bool is_weak_cas = (decorators &amp; C2_WEAK_CMPXCHG) != 0;
 668     Node* load_store = NULL;
 669     Node* adr = access.addr().node();
 670 #ifdef _LP64
 671     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 672       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 673       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 674       if (ShenandoahCASBarrier) {
 675         if (is_weak_cas) {
 676           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 677         } else {
 678           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 679         }
 680       } else {
 681         if (is_weak_cas) {
 682           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 683         } else {
 684           load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 685         }
 686       }
 687     } else
 688 #endif
 689     {
 690       if (ShenandoahCASBarrier) {
 691         if (is_weak_cas) {
 692           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 693         } else {
 694           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 695         }
 696       } else {
 697         if (is_weak_cas) {
 698           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 699         } else {
 700           load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 701         }
 702       }
 703     }
 704     access.set_raw_access(load_store);
 705     pin_atomic_op(access);
 706     return load_store;
 707   }
 708   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 709 }
 710 
 711 Node* ShenandoahBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* val, const Type* value_type) const {
 712   GraphKit* kit = access.kit();
 713   if (access.is_oop()) {
 714     val = shenandoah_storeval_barrier(kit, val);
 715   }
 716   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
 717   if (access.is_oop()) {
<a name="30" id="anc30"></a><span class="line-added"> 718     result = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, false));</span>
 719     shenandoah_write_barrier_pre(kit, false /* do_load */,
 720                                  NULL, NULL, max_juint, NULL, NULL,
 721                                  result /* pre_val */, T_OBJECT);
 722   }
 723   return result;
 724 }
 725 
<a name="31" id="anc31"></a>






































 726 // Support for GC barriers emitted during parsing
 727 bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
<a name="32" id="anc32"></a><span class="line-added"> 728   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;</span>
 729   if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
 730     return false;
 731   }
 732   CallLeafNode *call = node-&gt;as_CallLeaf();
 733   if (call-&gt;_name == NULL) {
 734     return false;
 735   }
 736 
 737   return strcmp(call-&gt;_name, &quot;shenandoah_clone_barrier&quot;) == 0 ||
 738          strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
 739          strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
 740 }
 741 
 742 Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
<a name="33" id="anc33"></a><span class="line-modified"> 743   if (c == NULL) {</span>
<span class="line-added"> 744     return c;</span>
<span class="line-added"> 745   }</span>
<span class="line-added"> 746   if (c-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="line-added"> 747     return c-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="line-added"> 748   }</span>
<span class="line-added"> 749   if (c-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-added"> 750     c = c-&gt;in(1);</span>
<span class="line-added"> 751   }</span>
<span class="line-added"> 752   return c;</span>
 753 }
 754 
 755 bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
<a name="34" id="anc34"></a><span class="line-modified"> 756   return !ShenandoahBarrierC2Support::expand(C, igvn);</span>
 757 }
 758 
 759 bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
 760   if (mode == LoopOptsShenandoahExpand) {
 761     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<a name="35" id="anc35"></a><span class="line-modified"> 762     ShenandoahBarrierC2Support::pin_and_expand(phase);</span>
 763     return true;
 764   } else if (mode == LoopOptsShenandoahPostExpand) {
 765     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<a name="36" id="anc36"></a><span class="line-modified"> 766     visited.clear();</span>
<span class="line-modified"> 767     ShenandoahBarrierC2Support::optimize_after_expansion(visited, nstack, worklist, phase);</span>
 768     return true;
 769   }
<a name="37" id="anc37"></a>

 770   return false;
 771 }
 772 
 773 bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
<a name="38" id="anc38"></a><span class="line-modified"> 774   bool is_oop = is_reference_type(type);</span>
 775   if (!is_oop) {
 776     return false;
 777   }
<a name="39" id="anc39"></a>
 778   if (tightly_coupled_alloc) {
 779     if (phase == Optimization) {
 780       return false;
 781     }
 782     return !is_clone;
 783   }
 784   if (phase == Optimization) {
 785     return !ShenandoahStoreValEnqueueBarrier;
 786   }
 787   return true;
 788 }
 789 
<a name="40" id="anc40"></a><span class="line-modified"> 790 bool ShenandoahBarrierSetC2::clone_needs_barrier(Node* src, PhaseGVN&amp; gvn) {</span>
<span class="line-modified"> 791   const TypeOopPtr* src_type = gvn.type(src)-&gt;is_oopptr();</span>

 792   if (src_type-&gt;isa_instptr() != NULL) {
 793     ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
 794     if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
 795       if (ik-&gt;has_object_fields()) {
 796         return true;
 797       } else {
 798         if (!src_type-&gt;klass_is_exact()) {
<a name="41" id="anc41"></a><span class="line-modified"> 799           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);</span>
 800         }
 801       }
 802     } else {
 803       return true;
<a name="42" id="anc42"></a><span class="line-modified"> 804         }</span>
 805   } else if (src_type-&gt;isa_aryptr()) {
 806     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<a name="43" id="anc43"></a><span class="line-modified"> 807     if (is_reference_type(src_elem)) {</span>
 808       return true;
 809     }
 810   } else {
 811     return true;
 812   }
 813   return false;
 814 }
 815 
<a name="44" id="anc44"></a><span class="line-modified"> 816 void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {</span>
<span class="line-modified"> 817   Node* ctrl = ac-&gt;in(TypeFunc::Control);</span>
<span class="line-modified"> 818   Node* mem = ac-&gt;in(TypeFunc::Memory);</span>
<span class="line-modified"> 819   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-modified"> 820   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);</span>









 821   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
<a name="45" id="anc45"></a><span class="line-modified"> 822   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="line-modified"> 823   Node* length = ac-&gt;in(ArrayCopyNode::Length);</span>
<span class="line-modified"> 824   assert (src_offset == NULL &amp;&amp; dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
<span class="line-modified"> 825   assert (src-&gt;is_AddP(), &quot;for clone the src should be the interior ptr&quot;);</span>
<span class="line-modified"> 826   assert (dest-&gt;is_AddP(), &quot;for clone the dst should be the interior ptr&quot;);</span>
<span class="line-modified"> 827 </span>
<span class="line-modified"> 828   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {</span>
<span class="line-modified"> 829     // Check if heap is has forwarded objects. If it does, we need to call into the special</span>
<span class="line-modified"> 830     // routine that would fix up source references before we can continue.</span>
<span class="line-modified"> 831 </span>
<span class="line-modified"> 832     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };</span>
<span class="line-modified"> 833     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="line-modified"> 834     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="line-modified"> 835 </span>
<span class="line-modified"> 836     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());</span>
<span class="line-modified"> 837     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-modified"> 838     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));</span>
<span class="line-modified"> 839 </span>
<span class="line-modified"> 840     uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="line-modified"> 841     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="line-modified"> 842     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));</span>
<span class="line-added"> 845     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));</span>
<span class="line-added"> 846     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));</span>
<span class="line-added"> 847     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));</span>
<span class="line-added"> 848 </span>
<span class="line-added"> 849     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="line-added"> 850     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));</span>
<span class="line-added"> 851     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));</span>
<span class="line-added"> 852 </span>
<span class="line-added"> 853     // Heap is stable, no need to do anything additional</span>
<span class="line-added"> 854     region-&gt;init_req(_heap_stable, stable_ctrl);</span>
<span class="line-added"> 855     mem_phi-&gt;init_req(_heap_stable, mem);</span>
<span class="line-added"> 856 </span>
<span class="line-added"> 857     // Heap is unstable, call into clone barrier stub</span>
<span class="line-added"> 858     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,</span>
<span class="line-added"> 859                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),</span>
<span class="line-added"> 860                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),</span>
<span class="line-added"> 861                     &quot;shenandoah_clone&quot;,</span>
<span class="line-added"> 862                     TypeRawPtr::BOTTOM,</span>
<span class="line-added"> 863                     src-&gt;in(AddPNode::Base));</span>
<span class="line-added"> 864     call = phase-&gt;transform_later(call);</span>
<span class="line-added"> 865 </span>
<span class="line-added"> 866     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));</span>
<span class="line-added"> 867     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));</span>
<span class="line-added"> 868     region-&gt;init_req(_heap_unstable, ctrl);</span>
<span class="line-added"> 869     mem_phi-&gt;init_req(_heap_unstable, mem);</span>
<span class="line-added"> 870 </span>
<span class="line-added"> 871     // Wire up the actual arraycopy stub now</span>
<span class="line-added"> 872     ctrl = phase-&gt;transform_later(region);</span>
<span class="line-added"> 873     mem = phase-&gt;transform_later(mem_phi);</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875     const char* name = &quot;arraycopy&quot;;</span>
<span class="line-added"> 876     call = phase-&gt;make_leaf_call(ctrl, mem,</span>
<span class="line-added"> 877                                  OptoRuntime::fast_arraycopy_Type(),</span>
<span class="line-added"> 878                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),</span>
<span class="line-added"> 879                                  name, TypeRawPtr::BOTTOM,</span>
<span class="line-added"> 880                                  src, dest, length</span>
<span class="line-added"> 881                                  LP64_ONLY(COMMA phase-&gt;top()));</span>
<span class="line-added"> 882     call = phase-&gt;transform_later(call);</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884     // Hook up the whole thing into the graph</span>
<span class="line-added"> 885     phase-&gt;igvn().replace_node(ac, call);</span>
<span class="line-added"> 886   } else {</span>
<span class="line-added"> 887     BarrierSetC2::clone_at_expansion(phase, ac);</span>
<span class="line-added"> 888   }</span>
 889 }
 890 
 891 
 892 // Support for macro expanded GC barriers
 893 void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
<a name="46" id="anc46"></a><span class="line-modified"> 894   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified"> 895     state()-&gt;add_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);</span>
<span class="line-added"> 896   }</span>
<span class="line-added"> 897   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="line-added"> 898     state()-&gt;add_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);</span>
 899   }
 900 }
 901 
 902 void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
<a name="47" id="anc47"></a><span class="line-modified"> 903   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified"> 904     state()-&gt;remove_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);</span>
<span class="line-added"> 905   }</span>
<span class="line-added"> 906   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="line-added"> 907     state()-&gt;remove_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);</span>
 908   }
 909 }
 910 
 911 void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
 912   if (is_shenandoah_wb_pre_call(n)) {
 913     shenandoah_eliminate_wb_pre(n, &amp;macro-&gt;igvn());
 914   }
 915 }
 916 
 917 void ShenandoahBarrierSetC2::shenandoah_eliminate_wb_pre(Node* call, PhaseIterGVN* igvn) const {
 918   assert(UseShenandoahGC &amp;&amp; is_shenandoah_wb_pre_call(call), &quot;&quot;);
 919   Node* c = call-&gt;as_Call()-&gt;proj_out(TypeFunc::Control);
 920   c = c-&gt;unique_ctrl_out();
 921   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 922   c = c-&gt;unique_ctrl_out();
 923   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 924   Node* iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 925   assert(iff-&gt;is_If(), &quot;expect test&quot;);
 926   if (!is_shenandoah_marking_if(igvn, iff)) {
 927     c = c-&gt;unique_ctrl_out();
 928     assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
 929     iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
 930     assert(is_shenandoah_marking_if(igvn, iff), &quot;expect marking test&quot;);
 931   }
 932   Node* cmpx = iff-&gt;in(1)-&gt;in(1);
 933   igvn-&gt;replace_node(cmpx, igvn-&gt;makecon(TypeInt::CC_EQ));
 934   igvn-&gt;rehash_node_delayed(call);
 935   call-&gt;del_req(call-&gt;req()-1);
 936 }
 937 
 938 void ShenandoahBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
 939   if (node-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(node)) {
 940     igvn-&gt;add_users_to_worklist(node);
 941   }
 942 }
 943 
 944 void ShenandoahBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
 945   for (uint i = 0; i &lt; useful.size(); i++) {
 946     Node* n = useful.at(i);
 947     if (n-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(n)) {
 948       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 949         C-&gt;record_for_igvn(n-&gt;fast_out(i));
 950       }
 951     }
 952   }
<a name="48" id="anc48"></a><span class="line-modified"> 953   for (int i = state()-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="line-modified"> 954     ShenandoahEnqueueBarrierNode* n = state()-&gt;enqueue_barrier(i);</span>
 955     if (!useful.member(n)) {
<a name="49" id="anc49"></a><span class="line-modified"> 956       state()-&gt;remove_enqueue_barrier(n);</span>
<span class="line-added"> 957     }</span>
<span class="line-added"> 958   }</span>
<span class="line-added"> 959   for (int i = state()-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="line-added"> 960     ShenandoahLoadReferenceBarrierNode* n = state()-&gt;load_reference_barrier(i);</span>
<span class="line-added"> 961     if (!useful.member(n)) {</span>
<span class="line-added"> 962       state()-&gt;remove_load_reference_barrier(n);</span>
 963     }
 964   }
<a name="50" id="anc50"></a>






 965 }
 966 
<a name="51" id="anc51"></a>

 967 void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
 968   return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
 969 }
 970 
 971 ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
 972   return reinterpret_cast&lt;ShenandoahBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
 973 }
 974 
 975 // If the BarrierSetC2 state has kept macro nodes in its compilation unit state to be
 976 // expanded later, then now is the time to do so.
 977 bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
 978 
 979 #ifdef ASSERT
 980 void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
<a name="52" id="anc52"></a><span class="line-modified"> 981   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeMacroExpand) {</span>
<span class="line-modified"> 982     ShenandoahBarrierC2Support::verify(Compile::current()-&gt;root());</span>
 983   } else if (phase == BarrierSetC2::BeforeCodeGen) {
 984     // Verify G1 pre-barriers
 985     const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
 986 
 987     ResourceArea *area = Thread::current()-&gt;resource_area();
 988     Unique_Node_List visited(area);
 989     Node_List worklist(area);
 990     // We&#39;re going to walk control flow backwards starting from the Root
 991     worklist.push(compile-&gt;root());
 992     while (worklist.size() &gt; 0) {
 993       Node *x = worklist.pop();
 994       if (x == NULL || x == compile-&gt;top()) continue;
 995       if (visited.member(x)) {
 996         continue;
 997       } else {
 998         visited.push(x);
 999       }
1000 
1001       if (x-&gt;is_Region()) {
1002         for (uint i = 1; i &lt; x-&gt;req(); i++) {
1003           worklist.push(x-&gt;in(i));
1004         }
1005       } else {
1006         worklist.push(x-&gt;in(0));
1007         // We are looking for the pattern:
1008         //                            /-&gt;ThreadLocal
1009         // If-&gt;Bool-&gt;CmpI-&gt;LoadB-&gt;AddP-&gt;ConL(marking_offset)
1010         //              \-&gt;ConI(0)
1011         // We want to verify that the If and the LoadB have the same control
1012         // See GraphKit::g1_write_barrier_pre()
1013         if (x-&gt;is_If()) {
1014           IfNode *iff = x-&gt;as_If();
1015           if (iff-&gt;in(1)-&gt;is_Bool() &amp;&amp; iff-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1016             CmpNode *cmp = iff-&gt;in(1)-&gt;in(1)-&gt;as_Cmp();
1017             if (cmp-&gt;Opcode() == Op_CmpI &amp;&amp; cmp-&gt;in(2)-&gt;is_Con() &amp;&amp; cmp-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0
1018                 &amp;&amp; cmp-&gt;in(1)-&gt;is_Load()) {
1019               LoadNode *load = cmp-&gt;in(1)-&gt;as_Load();
1020               if (load-&gt;Opcode() == Op_LoadB &amp;&amp; load-&gt;in(2)-&gt;is_AddP() &amp;&amp; load-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
1021                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;is_Con()
1022                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == marking_offset) {
1023 
1024                 Node *if_ctrl = iff-&gt;in(0);
1025                 Node *load_ctrl = load-&gt;in(0);
1026 
1027                 if (if_ctrl != load_ctrl) {
1028                   // Skip possible CProj-&gt;NeverBranch in infinite loops
1029                   if ((if_ctrl-&gt;is_Proj() &amp;&amp; if_ctrl-&gt;Opcode() == Op_CProj)
1030                       &amp;&amp; (if_ctrl-&gt;in(0)-&gt;is_MultiBranch() &amp;&amp; if_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch)) {
1031                     if_ctrl = if_ctrl-&gt;in(0)-&gt;in(0);
1032                   }
1033                 }
1034                 assert(load_ctrl != NULL &amp;&amp; if_ctrl == load_ctrl, &quot;controls must match&quot;);
1035               }
1036             }
1037           }
1038         }
1039       }
1040     }
1041   }
1042 }
1043 #endif
1044 
1045 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1046   if (is_shenandoah_wb_pre_call(n)) {
1047     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1048     if (n-&gt;req() &gt; cnt) {
1049       Node* addp = n-&gt;in(cnt);
1050       if (has_only_shenandoah_wb_pre_uses(addp)) {
1051         n-&gt;del_req(cnt);
1052         if (can_reshape) {
1053           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1054         }
1055         return n;
1056       }
1057     }
1058   }
1059   if (n-&gt;Opcode() == Op_CmpP) {
1060     Node* in1 = n-&gt;in(1);
1061     Node* in2 = n-&gt;in(2);
1062     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {
1063       in2 = step_over_gc_barrier(in2);
1064     }
1065     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {
1066       in1 = step_over_gc_barrier(in1);
1067     }
1068     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1069     if (in1 != n-&gt;in(1)) {
1070       if (igvn != NULL) {
1071         n-&gt;set_req_X(1, in1, igvn);
1072       } else {
1073         n-&gt;set_req(1, in1);
1074       }
1075       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);
1076       return n;
1077     }
1078     if (in2 != n-&gt;in(2)) {
1079       if (igvn != NULL) {
1080         n-&gt;set_req_X(2, in2, igvn);
1081       } else {
1082         n-&gt;set_req(2, in2);
1083       }
1084       return n;
1085     }
1086   } else if (can_reshape &amp;&amp;
1087              n-&gt;Opcode() == Op_If &amp;&amp;
<a name="53" id="anc53"></a><span class="line-modified">1088              ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;</span>
1089              n-&gt;in(0) != NULL) {
1090     Node* dom = n-&gt;in(0);
1091     Node* prev_dom = n;
1092     int op = n-&gt;Opcode();
1093     int dist = 16;
1094     // Search up the dominator tree for another heap stable test
1095     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
<a name="54" id="anc54"></a><span class="line-modified">1096            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?</span>
1097            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1098       if (dist &lt; 0) return NULL;
1099 
1100       dist--;
1101       prev_dom = dom;
1102       dom = IfNode::up_one_dom(dom);
1103       if (!dom) return NULL;
1104     }
1105 
1106     // Check that we did not follow a loop back to ourselves
1107     if (n == dom) {
1108       return NULL;
1109     }
1110 
1111     return n-&gt;as_If()-&gt;dominated_by(prev_dom, phase-&gt;is_IterGVN());
1112   }
1113 
1114   return NULL;
1115 }
1116 
<a name="55" id="anc55"></a>







































1117 bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
1118   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1119     Node* u = n-&gt;fast_out(i);
1120     if (!is_shenandoah_wb_pre_call(u)) {
1121       return false;
1122     }
1123   }
1124   return n-&gt;outcnt() &gt; 0;
1125 }
1126 
<a name="56" id="anc56"></a>













1127 bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1128   switch (opcode) {
1129     case Op_CallLeaf:
1130     case Op_CallLeafNoFP: {
1131       assert (n-&gt;is_Call(), &quot;&quot;);
1132       CallNode *call = n-&gt;as_Call();
1133       if (ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(call)) {
1134         uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1135         if (call-&gt;req() &gt; cnt) {
1136           assert(call-&gt;req() == cnt + 1, &quot;only one extra input&quot;);
1137           Node *addp = call-&gt;in(cnt);
1138           assert(!ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(addp), &quot;useless address computation?&quot;);
1139           call-&gt;del_req(cnt);
1140         }
1141       }
1142       return false;
1143     }
1144     case Op_ShenandoahCompareAndSwapP:
1145     case Op_ShenandoahCompareAndSwapN:
1146     case Op_ShenandoahWeakCompareAndSwapN:
1147     case Op_ShenandoahWeakCompareAndSwapP:
1148     case Op_ShenandoahCompareAndExchangeP:
1149     case Op_ShenandoahCompareAndExchangeN:
1150 #ifdef ASSERT
1151       if( VerifyOptoOopOffsets ) {
1152         MemNode* mem  = n-&gt;as_Mem();
1153         // Check to see if address types have grounded out somehow.
1154         const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1155         ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
1156         bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1157         assert( !tp || oop_offset_is_sane, &quot;&quot; );
1158       }
1159 #endif
1160       return true;
<a name="57" id="anc57"></a><span class="line-modified">1161     case Op_ShenandoahLoadReferenceBarrier:</span>


1162       assert(false, &quot;should have been expanded already&quot;);
1163       return true;
1164     default:
1165       return false;
1166   }
1167 }
1168 
<a name="58" id="anc58"></a>










1169 bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1170   switch (opcode) {
1171     case Op_ShenandoahCompareAndExchangeP:
1172     case Op_ShenandoahCompareAndExchangeN:
1173       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1174       // fallthrough
1175     case Op_ShenandoahWeakCompareAndSwapP:
1176     case Op_ShenandoahWeakCompareAndSwapN:
1177     case Op_ShenandoahCompareAndSwapP:
1178     case Op_ShenandoahCompareAndSwapN:
1179       conn_graph-&gt;add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
1180       return true;
1181     case Op_StoreP: {
1182       Node* adr = n-&gt;in(MemNode::Address);
1183       const Type* adr_type = gvn-&gt;type(adr);
1184       // Pointer stores in G1 barriers looks like unsafe access.
1185       // Ignore such stores to be able scalar replace non-escaping
1186       // allocations.
1187       if (adr_type-&gt;isa_rawptr() &amp;&amp; adr-&gt;is_AddP()) {
1188         Node* base = conn_graph-&gt;get_addp_base(adr);
1189         if (base-&gt;Opcode() == Op_LoadP &amp;&amp;
1190           base-&gt;in(MemNode::Address)-&gt;is_AddP()) {
1191           adr = base-&gt;in(MemNode::Address);
1192           Node* tls = conn_graph-&gt;get_addp_base(adr);
1193           if (tls-&gt;Opcode() == Op_ThreadLocal) {
1194              int offs = (int) gvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
1195              const int buf_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1196              if (offs == buf_offset) {
1197                return true; // Pre barrier previous oop value store.
1198              }
1199           }
1200         }
1201       }
1202       return false;
1203     }
<a name="59" id="anc59"></a>





1204     case Op_ShenandoahEnqueueBarrier:
1205       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
1206       break;
<a name="60" id="anc60"></a><span class="line-added">1207     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-added">1208       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), delayed_worklist);</span>
<span class="line-added">1209       return true;</span>
1210     default:
1211       // Nothing
1212       break;
1213   }
1214   return false;
1215 }
1216 
1217 bool ShenandoahBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1218   switch (opcode) {
1219     case Op_ShenandoahCompareAndExchangeP:
1220     case Op_ShenandoahCompareAndExchangeN: {
1221       Node *adr = n-&gt;in(MemNode::Address);
1222       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
1223       // fallthrough
1224     }
1225     case Op_ShenandoahCompareAndSwapP:
1226     case Op_ShenandoahCompareAndSwapN:
1227     case Op_ShenandoahWeakCompareAndSwapP:
1228     case Op_ShenandoahWeakCompareAndSwapN:
1229       return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
<a name="61" id="anc61"></a>





1230     case Op_ShenandoahEnqueueBarrier:
1231       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
1232       return true;
<a name="62" id="anc62"></a><span class="line-added">1233     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-added">1234       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), NULL);</span>
<span class="line-added">1235       return true;</span>
1236     default:
1237       // Nothing
1238       break;
1239   }
1240   return false;
1241 }
1242 
1243 bool ShenandoahBarrierSetC2::escape_has_out_with_unsafe_object(Node* n) const {
1244   return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
1245          n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
1246 
1247 }
1248 
<a name="63" id="anc63"></a>

















1249 bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
1250   switch (opcode) {
1251     case Op_ShenandoahCompareAndExchangeP:
1252     case Op_ShenandoahCompareAndExchangeN:
1253     case Op_ShenandoahWeakCompareAndSwapP:
1254     case Op_ShenandoahWeakCompareAndSwapN:
1255     case Op_ShenandoahCompareAndSwapP:
1256     case Op_ShenandoahCompareAndSwapN: {   // Convert trinary to binary-tree
1257       Node* newval = n-&gt;in(MemNode::ValueIn);
1258       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
1259       Node* pair = new BinaryNode(oldval, newval);
1260       n-&gt;set_req(MemNode::ValueIn,pair);
1261       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
1262       return true;
1263     }
1264     default:
1265       break;
1266   }
1267   return false;
1268 }
1269 
1270 bool ShenandoahBarrierSetC2::matcher_is_store_load_barrier(Node* x, uint xop) const {
1271   return xop == Op_ShenandoahCompareAndExchangeP ||
1272          xop == Op_ShenandoahCompareAndExchangeN ||
1273          xop == Op_ShenandoahWeakCompareAndSwapP ||
1274          xop == Op_ShenandoahWeakCompareAndSwapN ||
1275          xop == Op_ShenandoahCompareAndSwapN ||
1276          xop == Op_ShenandoahCompareAndSwapP;
1277 }
<a name="64" id="anc64"></a>


























































<a name="65" id="anc65"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="65" type="hidden" />
</body>
</html>
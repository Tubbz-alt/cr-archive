<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahVerifier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>

 28 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
 34 #include &quot;memory/allocation.hpp&quot;
 35 #include &quot;memory/iterator.inline.hpp&quot;
 36 #include &quot;memory/resourceArea.hpp&quot;
<a name="3" id="anc3"></a>



 37 
 38 // Avoid name collision on verify_oop (defined in macroAssembler_arm.hpp)
 39 #ifdef verify_oop
 40 #undef verify_oop
 41 #endif
 42 
 43 class ShenandoahVerifyOopClosure : public BasicOopIterateClosure {
 44 private:
 45   const char* _phase;
 46   ShenandoahVerifier::VerifyOptions _options;
 47   ShenandoahVerifierStack* _stack;
 48   ShenandoahHeap* _heap;
 49   MarkBitMap* _map;
 50   ShenandoahLivenessData* _ld;
 51   void* _interior_loc;
 52   oop _loc;
 53 
 54 public:
 55   ShenandoahVerifyOopClosure(ShenandoahVerifierStack* stack, MarkBitMap* map, ShenandoahLivenessData* ld,
 56                              const char* phase, ShenandoahVerifier::VerifyOptions options) :
 57     _phase(phase),
 58     _options(options),
 59     _stack(stack),
 60     _heap(ShenandoahHeap::heap()),
 61     _map(map),
 62     _ld(ld),
 63     _interior_loc(NULL),
 64     _loc(NULL) { }
 65 
 66 private:
 67   void check(ShenandoahAsserts::SafeLevel level, oop obj, bool test, const char* label) {
 68     if (!test) {
 69       ShenandoahAsserts::print_failure(level, obj, _interior_loc, _loc, _phase, label, __FILE__, __LINE__);
 70     }
 71   }
 72 
 73   template &lt;class T&gt;
 74   void do_oop_work(T* p) {
 75     T o = RawAccess&lt;&gt;::oop_load(p);
 76     if (!CompressedOops::is_null(o)) {
 77       oop obj = CompressedOops::decode_not_null(o);
 78 
 79       // Single threaded verification can use faster non-atomic stack and bitmap
 80       // methods.
 81       //
 82       // For performance reasons, only fully verify non-marked field values.
 83       // We are here when the host object for *p is already marked.
 84 
<a name="4" id="anc4"></a><span class="line-modified"> 85       HeapWord* addr = (HeapWord*) obj;</span>
<span class="line-removed"> 86       if (_map-&gt;par_mark(addr)) {</span>
 87         verify_oop_at(p, obj);
 88         _stack-&gt;push(ShenandoahVerifierTask(obj));
 89       }
 90     }
 91   }
 92 
 93   void verify_oop(oop obj) {
 94     // Perform consistency checks with gradually decreasing safety level. This guarantees
 95     // that failure report would not try to touch something that was not yet verified to be
 96     // safe to process.
 97 
 98     check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;is_in(obj),
 99               &quot;oop must be in heap&quot;);
<a name="5" id="anc5"></a><span class="line-modified">100     check(ShenandoahAsserts::_safe_unknown, obj, check_obj_alignment(obj),</span>
101               &quot;oop must be aligned&quot;);
102 
103     ShenandoahHeapRegion *obj_reg = _heap-&gt;heap_region_containing(obj);
104     Klass* obj_klass = obj-&gt;klass_or_null();
105 
106     // Verify that obj is not in dead space:
107     {
108       // Do this before touching obj-&gt;size()
109       check(ShenandoahAsserts::_safe_unknown, obj, obj_klass != NULL,
110              &quot;Object klass pointer should not be NULL&quot;);
111       check(ShenandoahAsserts::_safe_unknown, obj, Metaspace::contains(obj_klass),
112              &quot;Object klass pointer must go to metaspace&quot;);
113 
<a name="6" id="anc6"></a><span class="line-modified">114       HeapWord *obj_addr = (HeapWord *) obj;</span>
115       check(ShenandoahAsserts::_safe_unknown, obj, obj_addr &lt; obj_reg-&gt;top(),
116              &quot;Object start should be within the region&quot;);
117 
118       if (!obj_reg-&gt;is_humongous()) {
119         check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj-&gt;size()) &lt;= obj_reg-&gt;top(),
120                &quot;Object end should be within the region&quot;);
121       } else {
122         size_t humongous_start = obj_reg-&gt;region_number();
123         size_t humongous_end = humongous_start + (obj-&gt;size() &gt;&gt; ShenandoahHeapRegion::region_size_words_shift());
124         for (size_t idx = humongous_start + 1; idx &lt; humongous_end; idx++) {
125           check(ShenandoahAsserts::_safe_unknown, obj, _heap-&gt;get_region(idx)-&gt;is_humongous_continuation(),
126                  &quot;Humongous object is in continuation that fits it&quot;);
127         }
128       }
129 
130       // ------------ obj is safe at this point --------------
131 
132       check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;is_active(),
133             &quot;Object should be in active region&quot;);
134 
135       switch (_options._verify_liveness) {
136         case ShenandoahVerifier::_verify_liveness_disable:
137           // skip
138           break;
139         case ShenandoahVerifier::_verify_liveness_complete:
<a name="7" id="anc7"></a><span class="line-modified">140           Atomic::add(obj-&gt;size() + ShenandoahBrooksPointer::word_size(), &amp;_ld[obj_reg-&gt;region_number()]);</span>
141           // fallthrough for fast failure for un-live regions:
142         case ShenandoahVerifier::_verify_liveness_conservative:
143           check(ShenandoahAsserts::_safe_oop, obj, obj_reg-&gt;has_live(),
144                    &quot;Object must belong to region with live data&quot;);
145           break;
146         default:
147           assert(false, &quot;Unhandled liveness verification&quot;);
148       }
149     }
150 
<a name="8" id="anc8"></a><span class="line-modified">151     oop fwd = (oop) ShenandoahBrooksPointer::get_raw_unchecked(obj);</span>
152 
153     ShenandoahHeapRegion* fwd_reg = NULL;
154 
<a name="9" id="anc9"></a><span class="line-modified">155     if (!oopDesc::equals_raw(obj, fwd)) {</span>
156       check(ShenandoahAsserts::_safe_oop, obj, _heap-&gt;is_in(fwd),
157              &quot;Forwardee must be in heap&quot;);
158       check(ShenandoahAsserts::_safe_oop, obj, !CompressedOops::is_null(fwd),
159              &quot;Forwardee is set&quot;);
<a name="10" id="anc10"></a><span class="line-modified">160       check(ShenandoahAsserts::_safe_oop, obj, check_obj_alignment(fwd),</span>
161              &quot;Forwardee must be aligned&quot;);
162 
163       // Do this before touching fwd-&gt;size()
164       Klass* fwd_klass = fwd-&gt;klass_or_null();
165       check(ShenandoahAsserts::_safe_oop, obj, fwd_klass != NULL,
166              &quot;Forwardee klass pointer should not be NULL&quot;);
167       check(ShenandoahAsserts::_safe_oop, obj, Metaspace::contains(fwd_klass),
168              &quot;Forwardee klass pointer must go to metaspace&quot;);
169       check(ShenandoahAsserts::_safe_oop, obj, obj_klass == fwd_klass,
170              &quot;Forwardee klass pointer must go to metaspace&quot;);
171 
172       fwd_reg = _heap-&gt;heap_region_containing(fwd);
173 
174       // Verify that forwardee is not in the dead space:
175       check(ShenandoahAsserts::_safe_oop, obj, !fwd_reg-&gt;is_humongous(),
176              &quot;Should have no humongous forwardees&quot;);
177 
<a name="11" id="anc11"></a><span class="line-modified">178       HeapWord *fwd_addr = (HeapWord *) fwd;</span>
179       check(ShenandoahAsserts::_safe_oop, obj, fwd_addr &lt; fwd_reg-&gt;top(),
180              &quot;Forwardee start should be within the region&quot;);
181       check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd-&gt;size()) &lt;= fwd_reg-&gt;top(),
182              &quot;Forwardee end should be within the region&quot;);
183 
<a name="12" id="anc12"></a><span class="line-modified">184       oop fwd2 = (oop) ShenandoahBrooksPointer::get_raw_unchecked(fwd);</span>
<span class="line-modified">185       check(ShenandoahAsserts::_safe_oop, obj, oopDesc::equals_raw(fwd, fwd2),</span>
186              &quot;Double forwarding&quot;);
187     } else {
188       fwd_reg = obj_reg;
189     }
190 
191     // ------------ obj and fwd are safe at this point --------------
192 
193     switch (_options._verify_marked) {
194       case ShenandoahVerifier::_verify_marked_disable:
195         // skip
196         break;
197       case ShenandoahVerifier::_verify_marked_incomplete:
198         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;marking_context()-&gt;is_marked(obj),
199                &quot;Must be marked in incomplete bitmap&quot;);
200         break;
201       case ShenandoahVerifier::_verify_marked_complete:
202         check(ShenandoahAsserts::_safe_all, obj, _heap-&gt;complete_marking_context()-&gt;is_marked(obj),
203                &quot;Must be marked in complete bitmap&quot;);
204         break;
205       default:
206         assert(false, &quot;Unhandled mark verification&quot;);
207     }
208 
209     switch (_options._verify_forwarded) {
210       case ShenandoahVerifier::_verify_forwarded_disable:
211         // skip
212         break;
213       case ShenandoahVerifier::_verify_forwarded_none: {
<a name="13" id="anc13"></a><span class="line-modified">214         check(ShenandoahAsserts::_safe_all, obj, oopDesc::equals_raw(obj, fwd),</span>
215                &quot;Should not be forwarded&quot;);
216         break;
217       }
218       case ShenandoahVerifier::_verify_forwarded_allow: {
<a name="14" id="anc14"></a><span class="line-modified">219         if (!oopDesc::equals_raw(obj, fwd)) {</span>
220           check(ShenandoahAsserts::_safe_all, obj, obj_reg != fwd_reg,
221                  &quot;Forwardee should be in another region&quot;);
222         }
223         break;
224       }
225       default:
226         assert(false, &quot;Unhandled forwarding verification&quot;);
227     }
228 
229     switch (_options._verify_cset) {
230       case ShenandoahVerifier::_verify_cset_disable:
231         // skip
232         break;
233       case ShenandoahVerifier::_verify_cset_none:
234         check(ShenandoahAsserts::_safe_all, obj, !_heap-&gt;in_collection_set(obj),
235                &quot;Should not have references to collection set&quot;);
236         break;
237       case ShenandoahVerifier::_verify_cset_forwarded:
238         if (_heap-&gt;in_collection_set(obj)) {
<a name="15" id="anc15"></a><span class="line-modified">239           check(ShenandoahAsserts::_safe_all, obj, !oopDesc::equals_raw(obj, fwd),</span>
240                  &quot;Object in collection set, should have forwardee&quot;);
241         }
242         break;
243       default:
244         assert(false, &quot;Unhandled cset verification&quot;);
245     }
246 
247   }
248 
249 public:
250   /**
251    * Verify object with known interior reference.
252    * @param p interior reference where the object is referenced from; can be off-heap
253    * @param obj verified object
254    */
255   template &lt;class T&gt;
256   void verify_oop_at(T* p, oop obj) {
257     _interior_loc = p;
258     verify_oop(obj);
259     _interior_loc = NULL;
260   }
261 
262   /**
263    * Verify object without known interior reference.
264    * Useful when picking up the object at known offset in heap,
265    * but without knowing what objects reference it.
266    * @param obj verified object
267    */
268   void verify_oop_standalone(oop obj) {
269     _interior_loc = NULL;
270     verify_oop(obj);
271     _interior_loc = NULL;
272   }
273 
274   /**
275    * Verify oop fields from this object.
276    * @param obj host object for verified fields
277    */
278   void verify_oops_from(oop obj) {
279     _loc = obj;
280     obj-&gt;oop_iterate(this);
281     _loc = NULL;
282   }
283 
284   virtual void do_oop(oop* p) { do_oop_work(p); }
285   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
286 };
287 
288 class ShenandoahCalculateRegionStatsClosure : public ShenandoahHeapRegionClosure {
289 private:
290   size_t _used, _committed, _garbage;
291 public:
292   ShenandoahCalculateRegionStatsClosure() : _used(0), _committed(0), _garbage(0) {};
293 
294   void heap_region_do(ShenandoahHeapRegion* r) {
295     _used += r-&gt;used();
296     _garbage += r-&gt;garbage();
297     _committed += r-&gt;is_committed() ? ShenandoahHeapRegion::region_size_bytes() : 0;
298   }
299 
300   size_t used() { return _used; }
301   size_t committed() { return _committed; }
302   size_t garbage() { return _garbage; }
303 };
304 
305 class ShenandoahVerifyHeapRegionClosure : public ShenandoahHeapRegionClosure {
306 private:
307   ShenandoahHeap* _heap;
308   const char* _phase;
309   ShenandoahVerifier::VerifyRegions _regions;
310 public:
311   ShenandoahVerifyHeapRegionClosure(const char* phase, ShenandoahVerifier::VerifyRegions regions) :
312     _heap(ShenandoahHeap::heap()),
313     _phase(phase),
314     _regions(regions) {};
315 
316   void print_failure(ShenandoahHeapRegion* r, const char* label) {
317     ResourceMark rm;
318 
319     ShenandoahMessageBuffer msg(&quot;Shenandoah verification failed; %s: %s\n\n&quot;, _phase, label);
320 
321     stringStream ss;
322     r-&gt;print_on(&amp;ss);
323     msg.append(&quot;%s&quot;, ss.as_string());
324 
325     report_vm_error(__FILE__, __LINE__, msg.buffer());
326   }
327 
328   void verify(ShenandoahHeapRegion* r, bool test, const char* msg) {
329     if (!test) {
330       print_failure(r, msg);
331     }
332   }
333 
334   void heap_region_do(ShenandoahHeapRegion* r) {
335     switch (_regions) {
336       case ShenandoahVerifier::_verify_regions_disable:
337         break;
338       case ShenandoahVerifier::_verify_regions_notrash:
339         verify(r, !r-&gt;is_trash(),
340                &quot;Should not have trash regions&quot;);
341         break;
342       case ShenandoahVerifier::_verify_regions_nocset:
343         verify(r, !r-&gt;is_cset(),
344                &quot;Should not have cset regions&quot;);
345         break;
346       case ShenandoahVerifier::_verify_regions_notrash_nocset:
347         verify(r, !r-&gt;is_trash(),
348                &quot;Should not have trash regions&quot;);
349         verify(r, !r-&gt;is_cset(),
350                &quot;Should not have cset regions&quot;);
351         break;
352       default:
353         ShouldNotReachHere();
354     }
355 
356     verify(r, r-&gt;capacity() == ShenandoahHeapRegion::region_size_bytes(),
357            &quot;Capacity should match region size&quot;);
358 
359     verify(r, r-&gt;bottom() &lt;= r-&gt;top(),
360            &quot;Region top should not be less than bottom&quot;);
361 
362     verify(r, r-&gt;bottom() &lt;= _heap-&gt;marking_context()-&gt;top_at_mark_start(r),
363            &quot;Region TAMS should not be less than bottom&quot;);
364 
365     verify(r, _heap-&gt;marking_context()-&gt;top_at_mark_start(r) &lt;= r-&gt;top(),
366            &quot;Complete TAMS should not be larger than top&quot;);
367 
368     verify(r, r-&gt;get_live_data_bytes() &lt;= r-&gt;capacity(),
369            &quot;Live data cannot be larger than capacity&quot;);
370 
371     verify(r, r-&gt;garbage() &lt;= r-&gt;capacity(),
372            &quot;Garbage cannot be larger than capacity&quot;);
373 
374     verify(r, r-&gt;used() &lt;= r-&gt;capacity(),
375            &quot;Used cannot be larger than capacity&quot;);
376 
377     verify(r, r-&gt;get_shared_allocs() &lt;= r-&gt;capacity(),
378            &quot;Shared alloc count should not be larger than capacity&quot;);
379 
380     verify(r, r-&gt;get_tlab_allocs() &lt;= r-&gt;capacity(),
381            &quot;TLAB alloc count should not be larger than capacity&quot;);
382 
383     verify(r, r-&gt;get_gclab_allocs() &lt;= r-&gt;capacity(),
384            &quot;GCLAB alloc count should not be larger than capacity&quot;);
385 
386     verify(r, r-&gt;get_shared_allocs() + r-&gt;get_tlab_allocs() + r-&gt;get_gclab_allocs() == r-&gt;used(),
387            &quot;Accurate accounting: shared + TLAB + GCLAB = used&quot;);
388 
389     verify(r, !r-&gt;is_empty() || !r-&gt;has_live(),
390            &quot;Empty regions should not have live data&quot;);
391 
392     verify(r, r-&gt;is_cset() == _heap-&gt;collection_set()-&gt;is_in(r),
393            &quot;Transitional: region flags and collection set agree&quot;);
394 
395     verify(r, r-&gt;is_empty() || r-&gt;seqnum_first_alloc() != 0,
396            &quot;Non-empty regions should have first seqnum set&quot;);
397 
398     verify(r, r-&gt;is_empty() || (r-&gt;seqnum_first_alloc_mutator() != 0 || r-&gt;seqnum_first_alloc_gc() != 0),
399            &quot;Non-empty regions should have first seqnum set to either GC or mutator&quot;);
400 
401     verify(r, r-&gt;is_empty() || r-&gt;seqnum_last_alloc() != 0,
402            &quot;Non-empty regions should have last seqnum set&quot;);
403 
404     verify(r, r-&gt;is_empty() || (r-&gt;seqnum_last_alloc_mutator() != 0 || r-&gt;seqnum_last_alloc_gc() != 0),
405            &quot;Non-empty regions should have last seqnum set to either GC or mutator&quot;);
406 
407     verify(r, r-&gt;seqnum_first_alloc() &lt;= r-&gt;seqnum_last_alloc(),
408            &quot;First seqnum should not be greater than last timestamp&quot;);
409 
410     verify(r, r-&gt;seqnum_first_alloc_mutator() &lt;= r-&gt;seqnum_last_alloc_mutator(),
411            &quot;First mutator seqnum should not be greater than last seqnum&quot;);
412 
413     verify(r, r-&gt;seqnum_first_alloc_gc() &lt;= r-&gt;seqnum_last_alloc_gc(),
414            &quot;First GC seqnum should not be greater than last seqnum&quot;);
415   }
416 };
417 
418 class ShenandoahVerifierReachableTask : public AbstractGangTask {
419 private:
420   const char* _label;
<a name="16" id="anc16"></a><span class="line-modified">421   ShenandoahRootProcessor* _rp;</span>
422   ShenandoahVerifier::VerifyOptions _options;
423   ShenandoahHeap* _heap;
424   ShenandoahLivenessData* _ld;
425   MarkBitMap* _bitmap;
426   volatile size_t _processed;
427 
428 public:
429   ShenandoahVerifierReachableTask(MarkBitMap* bitmap,
430                                   ShenandoahLivenessData* ld,
<a name="17" id="anc17"></a><span class="line-modified">431                                   ShenandoahRootProcessor* rp,</span>
432                                   const char* label,
433                                   ShenandoahVerifier::VerifyOptions options) :
434     AbstractGangTask(&quot;Shenandoah Parallel Verifier Reachable Task&quot;),
435     _label(label),
<a name="18" id="anc18"></a><span class="line-modified">436     _rp(rp),</span>
437     _options(options),
438     _heap(ShenandoahHeap::heap()),
439     _ld(ld),
440     _bitmap(bitmap),
441     _processed(0) {};
442 
443   size_t processed() {
444     return _processed;
445   }
446 
447   virtual void work(uint worker_id) {
448     ResourceMark rm;
449     ShenandoahVerifierStack stack;
450 
451     // On level 2, we need to only check the roots once.
452     // On level 3, we want to check the roots, and seed the local stack.
453     // It is a lesser evil to accept multiple root scans at level 3, because
454     // extended parallelism would buy us out.
455     if (((ShenandoahVerifyLevel == 2) &amp;&amp; (worker_id == 0))
456         || (ShenandoahVerifyLevel &gt;= 3)) {
457         ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
458                                       ShenandoahMessageBuffer(&quot;%s, Roots&quot;, _label),
459                                       _options);
<a name="19" id="anc19"></a><span class="line-modified">460         _rp-&gt;process_all_roots_slow(&amp;cl);</span>




461     }
462 
463     size_t processed = 0;
464 
465     if (ShenandoahVerifyLevel &gt;= 3) {
466       ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
467                                     ShenandoahMessageBuffer(&quot;%s, Reachable&quot;, _label),
468                                     _options);
469       while (!stack.is_empty()) {
470         processed++;
471         ShenandoahVerifierTask task = stack.pop();
472         cl.verify_oops_from(task.obj());
473       }
474     }
475 
<a name="20" id="anc20"></a><span class="line-modified">476     Atomic::add(processed, &amp;_processed);</span>
477   }
478 };
479 
480 class ShenandoahVerifierMarkedRegionTask : public AbstractGangTask {
481 private:
482   const char* _label;
483   ShenandoahVerifier::VerifyOptions _options;
484   ShenandoahHeap *_heap;
485   MarkBitMap* _bitmap;
486   ShenandoahLivenessData* _ld;
487   volatile size_t _claimed;
488   volatile size_t _processed;
489 
490 public:
491   ShenandoahVerifierMarkedRegionTask(MarkBitMap* bitmap,
492                                      ShenandoahLivenessData* ld,
493                                      const char* label,
494                                      ShenandoahVerifier::VerifyOptions options) :
495           AbstractGangTask(&quot;Shenandoah Parallel Verifier Marked Region&quot;),
496           _label(label),
497           _options(options),
498           _heap(ShenandoahHeap::heap()),
499           _bitmap(bitmap),
500           _ld(ld),
501           _claimed(0),
502           _processed(0) {};
503 
504   size_t processed() {
505     return _processed;
506   }
507 
508   virtual void work(uint worker_id) {
509     ShenandoahVerifierStack stack;
510     ShenandoahVerifyOopClosure cl(&amp;stack, _bitmap, _ld,
511                                   ShenandoahMessageBuffer(&quot;%s, Marked&quot;, _label),
512                                   _options);
513 
514     while (true) {
<a name="21" id="anc21"></a><span class="line-modified">515       size_t v = Atomic::add(1u, &amp;_claimed) - 1;</span>
516       if (v &lt; _heap-&gt;num_regions()) {
517         ShenandoahHeapRegion* r = _heap-&gt;get_region(v);
518         if (!r-&gt;is_humongous() &amp;&amp; !r-&gt;is_trash()) {
519           work_regular(r, stack, cl);
520         } else if (r-&gt;is_humongous_start()) {
521           work_humongous(r, stack, cl);
522         }
523       } else {
524         break;
525       }
526     }
527   }
528 
529   virtual void work_humongous(ShenandoahHeapRegion *r, ShenandoahVerifierStack&amp; stack, ShenandoahVerifyOopClosure&amp; cl) {
530     size_t processed = 0;
<a name="22" id="anc22"></a><span class="line-modified">531     HeapWord* obj = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
532     if (_heap-&gt;complete_marking_context()-&gt;is_marked((oop)obj)) {
533       verify_and_follow(obj, stack, cl, &amp;processed);
534     }
<a name="23" id="anc23"></a><span class="line-modified">535     Atomic::add(processed, &amp;_processed);</span>
536   }
537 
538   virtual void work_regular(ShenandoahHeapRegion *r, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl) {
539     size_t processed = 0;
540     MarkBitMap* mark_bit_map = _heap-&gt;complete_marking_context()-&gt;mark_bit_map();
541     HeapWord* tams = _heap-&gt;complete_marking_context()-&gt;top_at_mark_start(r);
542 
543     // Bitmaps, before TAMS
544     if (tams &gt; r-&gt;bottom()) {
<a name="24" id="anc24"></a><span class="line-modified">545       HeapWord* start = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
546       HeapWord* addr = mark_bit_map-&gt;get_next_marked_addr(start, tams);
547 
548       while (addr &lt; tams) {
549         verify_and_follow(addr, stack, cl, &amp;processed);
<a name="25" id="anc25"></a><span class="line-modified">550         addr += ShenandoahBrooksPointer::word_size();</span>
551         if (addr &lt; tams) {
552           addr = mark_bit_map-&gt;get_next_marked_addr(addr, tams);
553         }
554       }
555     }
556 
557     // Size-based, after TAMS
558     {
559       HeapWord* limit = r-&gt;top();
<a name="26" id="anc26"></a><span class="line-modified">560       HeapWord* addr = tams + ShenandoahBrooksPointer::word_size();</span>
561 
562       while (addr &lt; limit) {
563         verify_and_follow(addr, stack, cl, &amp;processed);
<a name="27" id="anc27"></a><span class="line-modified">564         addr += oop(addr)-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
565       }
566     }
567 
<a name="28" id="anc28"></a><span class="line-modified">568     Atomic::add(processed, &amp;_processed);</span>
569   }
570 
571   void verify_and_follow(HeapWord *addr, ShenandoahVerifierStack &amp;stack, ShenandoahVerifyOopClosure &amp;cl, size_t *processed) {
572     if (!_bitmap-&gt;par_mark(addr)) return;
573 
574     // Verify the object itself:
575     oop obj = oop(addr);
576     cl.verify_oop_standalone(obj);
577 
578     // Verify everything reachable from that object too, hopefully realizing
579     // everything was already marked, and never touching further:
580     cl.verify_oops_from(obj);
581     (*processed)++;
582 
583     while (!stack.is_empty()) {
584       ShenandoahVerifierTask task = stack.pop();
585       cl.verify_oops_from(task.obj());
586       (*processed)++;
587     }
588   }
589 };
590 
591 class VerifyThreadGCState : public ThreadClosure {
592 private:
593   const char* _label;
594   char _expected;
595 
596 public:
597   VerifyThreadGCState(const char* label, char expected) : _expected(expected) {}
598   void do_thread(Thread* t) {
599     char actual = ShenandoahThreadLocalData::gc_state(t);
600     if (actual != _expected) {
601       fatal(&quot;%s: Thread %s: expected gc-state %d, actual %d&quot;, _label, t-&gt;name(), _expected, actual);
602     }
603   }
604 };
605 
<a name="29" id="anc29"></a>
















606 void ShenandoahVerifier::verify_at_safepoint(const char *label,
607                                              VerifyForwarded forwarded, VerifyMarked marked,
608                                              VerifyCollectionSet cset,
609                                              VerifyLiveness liveness, VerifyRegions regions,
<a name="30" id="anc30"></a><span class="line-modified">610                                              VerifyGCState gcstate) {</span>

611   guarantee(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;only when nothing else happens&quot;);
612   guarantee(ShenandoahVerify, &quot;only when enabled, and bitmap is initialized in ShenandoahHeap::initialize&quot;);
613 
614   // Avoid side-effect of changing workers&#39; active thread count, but bypass concurrent/parallel protocol check
615   ShenandoahPushWorkerScope verify_worker_scope(_heap-&gt;workers(), _heap-&gt;max_workers(), false /*bypass check*/);
616 
617   log_info(gc,start)(&quot;Verify %s, Level &quot; INTX_FORMAT, label, ShenandoahVerifyLevel);
618 
619   // GC state checks
620   {
621     char expected = -1;
622     bool enabled;
623     switch (gcstate) {
624       case _verify_gcstate_disable:
625         enabled = false;
626         break;
627       case _verify_gcstate_forwarded:
628         enabled = true;
629         expected = ShenandoahHeap::HAS_FORWARDED;
630         break;
<a name="31" id="anc31"></a>



631       case _verify_gcstate_stable:
632         enabled = true;
633         expected = ShenandoahHeap::STABLE;
634         break;
635       default:
636         enabled = false;
637         assert(false, &quot;Unhandled gc-state verification&quot;);
638     }
639 
640     if (enabled) {
641       char actual = _heap-&gt;gc_state();
642       if (actual != expected) {
643         fatal(&quot;%s: Global gc-state: expected %d, actual %d&quot;, label, expected, actual);
644       }
645 
646       VerifyThreadGCState vtgcs(label, expected);
647       Threads::java_threads_do(&amp;vtgcs);
648     }
649   }
650 
<a name="32" id="anc32"></a>


651   // Heap size checks
652   {
653     ShenandoahHeapLocker lock(_heap-&gt;lock());
654 
655     ShenandoahCalculateRegionStatsClosure cl;
656     _heap-&gt;heap_region_iterate(&amp;cl);
657     size_t heap_used = _heap-&gt;used();
658     guarantee(cl.used() == heap_used,
<a name="33" id="anc33"></a><span class="line-modified">659               &quot;%s: heap used size must be consistent: heap-used = &quot; SIZE_FORMAT &quot;K, regions-used = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">660               label, heap_used/K, cl.used()/K);</span>


661 
662     size_t heap_committed = _heap-&gt;committed();
663     guarantee(cl.committed() == heap_committed,
<a name="34" id="anc34"></a><span class="line-modified">664               &quot;%s: heap committed size must be consistent: heap-committed = &quot; SIZE_FORMAT &quot;K, regions-committed = &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">665               label, heap_committed/K, cl.committed()/K);</span>


666   }
667 
668   // Internal heap region checks
669   if (ShenandoahVerifyLevel &gt;= 1) {
670     ShenandoahVerifyHeapRegionClosure cl(label, regions);
671     _heap-&gt;heap_region_iterate(&amp;cl);
672   }
673 
674   OrderAccess::fence();
675   _heap-&gt;make_parsable(false);
676 
677   // Allocate temporary bitmap for storing marking wavefront:
678   _verification_bit_map-&gt;clear();
679 
680   // Allocate temporary array for storing liveness data
681   ShenandoahLivenessData* ld = NEW_C_HEAP_ARRAY(ShenandoahLivenessData, _heap-&gt;num_regions(), mtGC);
682   Copy::fill_to_bytes((void*)ld, _heap-&gt;num_regions()*sizeof(ShenandoahLivenessData), 0);
683 
684   const VerifyOptions&amp; options = ShenandoahVerifier::VerifyOptions(forwarded, marked, cset, liveness, regions, gcstate);
685 
686   // Steps 1-2. Scan root set to get initial reachable set. Finish walking the reachable heap.
687   // This verifies what application can see, since it only cares about reachable objects.
688   size_t count_reachable = 0;
689   if (ShenandoahVerifyLevel &gt;= 2) {
<a name="35" id="anc35"></a><span class="line-modified">690     ShenandoahRootProcessor rp(_heap, _heap-&gt;workers()-&gt;active_workers(),</span>
<span class="line-modified">691                                ShenandoahPhaseTimings::_num_phases); // no need for stats</span>











692 
<a name="36" id="anc36"></a><span class="line-modified">693     ShenandoahVerifierReachableTask task(_verification_bit_map, ld, &amp;rp, label, options);</span>
694     _heap-&gt;workers()-&gt;run_task(&amp;task);
695     count_reachable = task.processed();
696   }
697 
698   // Step 3. Walk marked objects. Marked objects might be unreachable. This verifies what collector,
699   // not the application, can see during the region scans. There is no reason to process the objects
700   // that were already verified, e.g. those marked in verification bitmap. There is interaction with TAMS:
701   // before TAMS, we verify the bitmaps, if available; after TAMS, we walk until the top(). It mimics
702   // what marked_object_iterate is doing, without calling into that optimized (and possibly incorrect)
703   // version
704 
705   size_t count_marked = 0;
706   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete) {
707     guarantee(_heap-&gt;marking_context()-&gt;is_complete(), &quot;Marking context should be complete&quot;);
708     ShenandoahVerifierMarkedRegionTask task(_verification_bit_map, ld, label, options);
709     _heap-&gt;workers()-&gt;run_task(&amp;task);
710     count_marked = task.processed();
711   } else {
712     guarantee(ShenandoahVerifyLevel &lt; 4 || marked == _verify_marked_incomplete || marked == _verify_marked_disable, &quot;Should be&quot;);
713   }
714 
715   // Step 4. Verify accumulated liveness data, if needed. Only reliable if verification level includes
716   // marked objects.
717 
718   if (ShenandoahVerifyLevel &gt;= 4 &amp;&amp; marked == _verify_marked_complete &amp;&amp; liveness == _verify_liveness_complete) {
719     for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
720       ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
721 
722       juint verf_live = 0;
723       if (r-&gt;is_humongous()) {
724         // For humongous objects, test if start region is marked live, and if so,
725         // all humongous regions in that chain have live data equal to their &quot;used&quot;.
<a name="37" id="anc37"></a><span class="line-modified">726         juint start_live = OrderAccess::load_acquire(&amp;ld[r-&gt;humongous_start_region()-&gt;region_number()]);</span>
727         if (start_live &gt; 0) {
728           verf_live = (juint)(r-&gt;used() / HeapWordSize);
729         }
730       } else {
<a name="38" id="anc38"></a><span class="line-modified">731         verf_live = OrderAccess::load_acquire(&amp;ld[r-&gt;region_number()]);</span>
732       }
733 
734       size_t reg_live = r-&gt;get_live_data_words();
735       if (reg_live != verf_live) {
736         ResourceMark rm;
737         stringStream ss;
738         r-&gt;print_on(&amp;ss);
739         fatal(&quot;%s: Live data should match: region-live = &quot; SIZE_FORMAT &quot;, verifier-live = &quot; UINT32_FORMAT &quot;\n%s&quot;,
740               label, reg_live, verf_live, ss.as_string());
741       }
742     }
743   }
744 
745   log_info(gc)(&quot;Verify %s, Level &quot; INTX_FORMAT &quot; (&quot; SIZE_FORMAT &quot; reachable, &quot; SIZE_FORMAT &quot; marked)&quot;,
746                label, ShenandoahVerifyLevel, count_reachable, count_marked);
747 
748   FREE_C_HEAP_ARRAY(ShenandoahLivenessData, ld);
749 }
750 
751 void ShenandoahVerifier::verify_generic(VerifyOption vo) {
752   verify_at_safepoint(
753           &quot;Generic Verification&quot;,
754           _verify_forwarded_allow,     // conservatively allow forwarded
755           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
756           _verify_cset_disable,        // cset may be inconsistent
757           _verify_liveness_disable,    // no reliable liveness data
758           _verify_regions_disable,     // no reliable region data
<a name="39" id="anc39"></a><span class="line-modified">759           _verify_gcstate_disable      // no data about gcstate</span>

760   );
761 }
762 
763 void ShenandoahVerifier::verify_before_concmark() {
764   if (_heap-&gt;has_forwarded_objects()) {
765     verify_at_safepoint(
766             &quot;Before Mark&quot;,
767             _verify_forwarded_allow,     // may have forwarded references
768             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
769             _verify_cset_forwarded,      // allow forwarded references to cset
770             _verify_liveness_disable,    // no reliable liveness data
771             _verify_regions_notrash,     // no trash regions
<a name="40" id="anc40"></a><span class="line-modified">772             _verify_gcstate_forwarded    // there are forwarded objects</span>

773     );
774   } else {
775     verify_at_safepoint(
776             &quot;Before Mark&quot;,
777             _verify_forwarded_none,      // UR should have fixed up
778             _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
779             _verify_cset_none,           // UR should have fixed this
780             _verify_liveness_disable,    // no reliable liveness data
781             _verify_regions_notrash,     // no trash regions
<a name="41" id="anc41"></a><span class="line-modified">782             _verify_gcstate_stable       // there are no forwarded objects</span>

783     );
784   }
785 }
786 
787 void ShenandoahVerifier::verify_after_concmark() {
788   verify_at_safepoint(
789           &quot;After Mark&quot;,
790           _verify_forwarded_none,      // no forwarded references
791           _verify_marked_complete,     // bitmaps as precise as we can get
792           _verify_cset_none,           // no references to cset anymore
793           _verify_liveness_complete,   // liveness data must be complete here
794           _verify_regions_disable,     // trash regions not yet recycled
<a name="42" id="anc42"></a><span class="line-modified">795           _verify_gcstate_stable       // mark should have stabilized the heap</span>

796   );
797 }
798 
799 void ShenandoahVerifier::verify_before_evacuation() {
<a name="43" id="anc43"></a>




800   verify_at_safepoint(
801           &quot;Before Evacuation&quot;,
802           _verify_forwarded_none,    // no forwarded references
803           _verify_marked_complete,   // walk over marked objects too
804           _verify_cset_disable,      // non-forwarded references to cset expected
805           _verify_liveness_complete, // liveness data must be complete here
806           _verify_regions_disable,   // trash regions not yet recycled
<a name="44" id="anc44"></a><span class="line-modified">807           _verify_gcstate_stable     // mark should have stabilized the heap</span>



















808   );
809 }
810 
811 void ShenandoahVerifier::verify_after_evacuation() {
812   verify_at_safepoint(
813           &quot;After Evacuation&quot;,
814           _verify_forwarded_allow,     // objects are still forwarded
815           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
816           _verify_cset_forwarded,      // all cset refs are fully forwarded
817           _verify_liveness_disable,    // no reliable liveness data anymore
818           _verify_regions_notrash,     // trash regions have been recycled already
<a name="45" id="anc45"></a><span class="line-modified">819           _verify_gcstate_forwarded    // evacuation produced some forwarded objects</span>

820   );
821 }
822 
823 void ShenandoahVerifier::verify_before_updaterefs() {
824   verify_at_safepoint(
825           &quot;Before Updating References&quot;,
826           _verify_forwarded_allow,     // forwarded references allowed
827           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
828           _verify_cset_forwarded,      // all cset refs are fully forwarded
829           _verify_liveness_disable,    // no reliable liveness data anymore
830           _verify_regions_notrash,     // trash regions have been recycled already
<a name="46" id="anc46"></a><span class="line-modified">831           _verify_gcstate_forwarded    // evacuation should have produced some forwarded objects</span>

832   );
833 }
834 
835 void ShenandoahVerifier::verify_after_updaterefs() {
836   verify_at_safepoint(
837           &quot;After Updating References&quot;,
838           _verify_forwarded_none,      // no forwarded references
839           _verify_marked_complete,     // bitmaps might be stale, but alloc-after-mark should be well
840           _verify_cset_none,           // no cset references, all updated
841           _verify_liveness_disable,    // no reliable liveness data anymore
842           _verify_regions_nocset,      // no cset regions, trash regions have appeared
<a name="47" id="anc47"></a><span class="line-modified">843           _verify_gcstate_stable       // update refs had cleaned up forwarded objects</span>

844   );
845 }
846 
847 void ShenandoahVerifier::verify_after_degenerated() {
848   verify_at_safepoint(
849           &quot;After Degenerated GC&quot;,
850           _verify_forwarded_none,      // all objects are non-forwarded
851           _verify_marked_complete,     // all objects are marked in complete bitmap
852           _verify_cset_none,           // no cset references
853           _verify_liveness_disable,    // no reliable liveness data anymore
854           _verify_regions_notrash_nocset, // no trash, no cset
<a name="48" id="anc48"></a><span class="line-modified">855           _verify_gcstate_stable       // degenerated refs had cleaned up forwarded objects</span>

856   );
857 }
858 
859 void ShenandoahVerifier::verify_before_traversal() {
860   verify_at_safepoint(
861           &quot;Before Traversal&quot;,
862           _verify_forwarded_none,      // cannot have forwarded objects
863           _verify_marked_disable,      // bitmaps are not relevant before traversal
864           _verify_cset_none,           // no cset references before traversal
865           _verify_liveness_disable,    // no reliable liveness data anymore
866           _verify_regions_notrash_nocset, // no trash and no cset regions
<a name="49" id="anc49"></a><span class="line-modified">867           _verify_gcstate_stable       // nothing forwarded before traversal</span>

868   );
869 }
870 
871 void ShenandoahVerifier::verify_after_traversal() {
872   verify_at_safepoint(
873           &quot;After Traversal&quot;,
874           _verify_forwarded_none,      // cannot have forwarded objects
875           _verify_marked_complete,     // should have complete marking after traversal
876           _verify_cset_none,           // no cset references left after traversal
877           _verify_liveness_disable,    // liveness data is not collected for new allocations
878           _verify_regions_nocset,      // no cset regions, trash regions allowed
<a name="50" id="anc50"></a><span class="line-modified">879           _verify_gcstate_stable       // nothing forwarded after traversal</span>

880   );
881 }
882 
883 void ShenandoahVerifier::verify_before_fullgc() {
884   verify_at_safepoint(
885           &quot;Before Full GC&quot;,
886           _verify_forwarded_allow,     // can have forwarded objects
887           _verify_marked_disable,      // do not verify marked: lots ot time wasted checking dead allocations
888           _verify_cset_disable,        // cset might be foobared
889           _verify_liveness_disable,    // no reliable liveness data anymore
890           _verify_regions_disable,     // no reliable region data here
<a name="51" id="anc51"></a><span class="line-modified">891           _verify_gcstate_disable      // no reliable gcstate data</span>

892   );
893 }
894 
895 void ShenandoahVerifier::verify_after_fullgc() {
896   verify_at_safepoint(
897           &quot;After Full GC&quot;,
898           _verify_forwarded_none,      // all objects are non-forwarded
899           _verify_marked_complete,     // all objects are marked in complete bitmap
900           _verify_cset_none,           // no cset references
901           _verify_liveness_disable,    // no reliable liveness data anymore
902           _verify_regions_notrash_nocset, // no trash, no cset
<a name="52" id="anc52"></a><span class="line-modified">903           _verify_gcstate_stable       // full gc cleaned up everything</span>

904   );
905 }
<a name="53" id="anc53"></a>













































































<a name="54" id="anc54"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="54" type="hidden" />
</body>
</html>
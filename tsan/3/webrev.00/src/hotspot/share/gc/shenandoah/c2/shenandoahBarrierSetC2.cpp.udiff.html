<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../c1/shenandoahBarrierSetC1.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetC2.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
   * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,10 +22,12 @@</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shared/barrierSet.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,131 +38,67 @@</span>
  #include &quot;opto/idealKit.hpp&quot;
  #include &quot;opto/macro.hpp&quot;
  #include &quot;opto/movenode.hpp&quot;
  #include &quot;opto/narrowptrnode.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
<span class="udiff-line-added">+ #include &quot;opto/runtime.hpp&quot;</span>
  
  ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
    return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  }
  
  ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
<span class="udiff-line-modified-removed">-   : _shenandoah_barriers(new (comp_arena) GrowableArray&lt;ShenandoahWriteBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {</span>
<span class="udiff-line-modified-added">+   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),</span>
<span class="udiff-line-added">+     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {</span>
  }
  
<span class="udiff-line-modified-removed">- int ShenandoahBarrierSetC2State::shenandoah_barriers_count() const {</span>
<span class="udiff-line-modified-removed">-   return _shenandoah_barriers-&gt;length();</span>
<span class="udiff-line-modified-added">+ int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {</span>
<span class="udiff-line-modified-added">+   return _enqueue_barriers-&gt;length();</span>
  }
  
<span class="udiff-line-modified-removed">- ShenandoahWriteBarrierNode* ShenandoahBarrierSetC2State::shenandoah_barrier(int idx) const {</span>
<span class="udiff-line-modified-removed">-   return _shenandoah_barriers-&gt;at(idx);</span>
<span class="udiff-line-modified-added">+ ShenandoahEnqueueBarrierNode* ShenandoahBarrierSetC2State::enqueue_barrier(int idx) const {</span>
<span class="udiff-line-modified-added">+   return _enqueue_barriers-&gt;at(idx);</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetC2State::add_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {</span>
<span class="udiff-line-modified-removed">-   assert(!_shenandoah_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="udiff-line-modified-removed">-   _shenandoah_barriers-&gt;append(n);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetC2State::add_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {</span>
<span class="udiff-line-modified-added">+   assert(!_enqueue_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="udiff-line-modified-added">+   _enqueue_barriers-&gt;append(n);</span>
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetC2State::remove_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {</span>
<span class="udiff-line-modified-removed">-   if (_shenandoah_barriers-&gt;contains(n)) {</span>
<span class="udiff-line-modified-removed">-     _shenandoah_barriers-&gt;remove(n);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetC2State::remove_enqueue_barrier(ShenandoahEnqueueBarrierNode * n) {</span>
<span class="udiff-line-modified-added">+   if (_enqueue_barriers-&gt;contains(n)) {</span>
<span class="udiff-line-modified-added">+     _enqueue_barriers-&gt;remove(n);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- #define __ kit-&gt;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierSetC2::shenandoah_read_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="udiff-line-removed">-   if (ShenandoahReadBarrier) {</span>
<span class="udiff-line-removed">-     obj = shenandoah_read_barrier_impl(kit, obj, false, true, true);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return obj;</span>
<span class="udiff-line-modified-added">+ int ShenandoahBarrierSetC2State::load_reference_barriers_count() const {</span>
<span class="udiff-line-modified-added">+   return _load_reference_barriers-&gt;length();</span>
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="udiff-line-removed">-     obj = shenandoah_write_barrier(kit, obj);</span>
<span class="udiff-line-removed">-     obj = shenandoah_enqueue_barrier(kit, obj);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (ShenandoahStoreValReadBarrier) {</span>
<span class="udiff-line-removed">-     obj = shenandoah_read_barrier_impl(kit, obj, true, false, false);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return obj;</span>
<span class="udiff-line-modified-added">+ ShenandoahLoadReferenceBarrierNode* ShenandoahBarrierSetC2State::load_reference_barrier(int idx) const {</span>
<span class="udiff-line-modified-added">+   return _load_reference_barriers-&gt;at(idx);</span>
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierSetC2::shenandoah_read_barrier_impl(GraphKit* kit, Node* obj, bool use_ctrl, bool use_mem, bool allow_fromspace) const {</span>
<span class="udiff-line-modified-removed">-   const Type* obj_type = obj-&gt;bottom_type();</span>
<span class="udiff-line-modified-removed">-   if (obj_type-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="udiff-line-removed">-     return obj;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="udiff-line-removed">-   Node* mem = use_mem ? __ memory(adr_type) : __ immutable_memory();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, mem, allow_fromspace)) {</span>
<span class="udiff-line-removed">-     // We know it is null, no barrier needed.</span>
<span class="udiff-line-removed">-     return obj;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (obj_type-&gt;meet(TypePtr::NULL_PTR) == obj_type-&gt;remove_speculative()) {</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // We don&#39;t know if it&#39;s null or not. Need null-check.</span>
<span class="udiff-line-removed">-     enum { _not_null_path = 1, _null_path, PATH_LIMIT };</span>
<span class="udiff-line-removed">-     RegionNode* region = new RegionNode(PATH_LIMIT);</span>
<span class="udiff-line-removed">-     Node*       phi    = new PhiNode(region, obj_type);</span>
<span class="udiff-line-removed">-     Node* null_ctrl = __ top();</span>
<span class="udiff-line-removed">-     Node* not_null_obj = __ null_check_oop(obj, &amp;null_ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="udiff-line-removed">-     phi   -&gt;init_req(_null_path, __ zerocon(T_OBJECT));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Node* ctrl = use_ctrl ? __ control() : NULL;</span>
<span class="udiff-line-removed">-     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, not_null_obj, allow_fromspace);</span>
<span class="udiff-line-removed">-     Node* n = __ gvn().transform(rb);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     region-&gt;init_req(_not_null_path, __ control());</span>
<span class="udiff-line-removed">-     phi   -&gt;init_req(_not_null_path, n);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ set_control(__ gvn().transform(region));</span>
<span class="udiff-line-removed">-     __ record_for_igvn(region);</span>
<span class="udiff-line-removed">-     return __ gvn().transform(phi);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // We know it is not null. Simple barrier is sufficient.</span>
<span class="udiff-line-removed">-     Node* ctrl = use_ctrl ? __ control() : NULL;</span>
<span class="udiff-line-removed">-     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, obj, allow_fromspace);</span>
<span class="udiff-line-removed">-     Node* n = __ gvn().transform(rb);</span>
<span class="udiff-line-removed">-     __ record_for_igvn(n);</span>
<span class="udiff-line-removed">-     return n;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetC2State::add_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {</span>
<span class="udiff-line-modified-added">+   assert(!_load_reference_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="udiff-line-modified-added">+   _load_reference_barriers-&gt;append(n);</span>
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_helper(GraphKit* kit, Node* obj, const TypePtr* adr_type) const {</span>
<span class="udiff-line-modified-removed">-   ShenandoahWriteBarrierNode* wb = new ShenandoahWriteBarrierNode(kit-&gt;C, kit-&gt;control(), kit-&gt;memory(adr_type), obj);</span>
<span class="udiff-line-modified-removed">-   Node* n = __ gvn().transform(wb);</span>
<span class="udiff-line-removed">-   if (n == wb) { // New barrier needs memory projection.</span>
<span class="udiff-line-removed">-     Node* proj = __ gvn().transform(new ShenandoahWBMemProjNode(n));</span>
<span class="udiff-line-removed">-     __ set_memory(proj, adr_type);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetC2State::remove_load_reference_barrier(ShenandoahLoadReferenceBarrierNode * n) {</span>
<span class="udiff-line-modified-added">+   if (_load_reference_barriers-&gt;contains(n)) {</span>
<span class="udiff-line-modified-added">+     _load_reference_barriers-&gt;remove(n);</span>
    }
<span class="udiff-line-removed">-   return n;</span>
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierSetC2::shenandoah_write_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahWriteBarrier) {</span>
<span class="udiff-line-modified-removed">-     obj = shenandoah_write_barrier_impl(kit, obj);</span>
<span class="udiff-line-modified-added">+ Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="udiff-line-modified-added">+   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+     obj = shenandoah_enqueue_barrier(kit, obj);</span>
    }
    return obj;
  }
  
<span class="udiff-line-modified-removed">- Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_impl(GraphKit* kit, Node* obj) const {</span>
<span class="udiff-line-removed">-   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, NULL, true)) {</span>
<span class="udiff-line-removed">-     return obj;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   const Type* obj_type = obj-&gt;bottom_type();</span>
<span class="udiff-line-removed">-   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="udiff-line-removed">-   Node* n = shenandoah_write_barrier_helper(kit, obj, adr_type);</span>
<span class="udiff-line-removed">-   __ record_for_igvn(n);</span>
<span class="udiff-line-removed">-   return n;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ #define __ kit-&gt;</span>
  
  bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
                                                           BasicType bt, uint adr_idx) const {
    intptr_t offset = 0;
    Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -302,11 +241,11 @@</span>
    // Now some of the values
    Node* marking;
    Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
    Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
    marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
<span class="udiff-line-modified-removed">-   assert(ShenandoahWriteBarrierNode::is_gc_state_load(ld), &quot;Should match the shape&quot;);</span>
<span class="udiff-line-modified-added">+   assert(ShenandoahBarrierC2Support::is_gc_state_load(ld), &quot;Should match the shape&quot;);</span>
  
    // if (!marking)
    __ if_then(marking, BoolTest::ne, zero, unlikely); {
      BasicType index_bt = TypeX_X-&gt;basic_type();
      assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -357,13 +296,19 @@</span>
  bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
    return call-&gt;is_CallLeaf() &amp;&amp;
           call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSetC2::is_shenandoah_wb_call(Node* call) {</span>
<span class="udiff-line-modified-removed">-   return call-&gt;is_CallLeaf() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT);</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierSetC2::is_shenandoah_lrb_call(Node* call) {</span>
<span class="udiff-line-modified-added">+   if (!call-&gt;is_CallLeaf()) {</span>
<span class="udiff-line-modified-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address entry_point = call-&gt;as_CallLeaf()-&gt;entry_point();</span>
<span class="udiff-line-added">+   return (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier)) ||</span>
<span class="udiff-line-added">+          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow)) ||</span>
<span class="udiff-line-added">+          (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));</span>
  }
  
  bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
    if (n-&gt;Opcode() != Op_If) {
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -524,115 +469,35 @@</span>
    return TypeFunc::make(domain, range);
  }
  
  const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
    const Type **fields = TypeTuple::fields(1);
<span class="udiff-line-modified-removed">-   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value</span>
<span class="udiff-line-modified-added">+   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop</span>
    const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
  
    // create result type (range)
    fields = TypeTuple::fields(0);
    const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
  
    return TypeFunc::make(domain, range);
  }
  
<span class="udiff-line-modified-removed">- const TypeFunc* ShenandoahBarrierSetC2::shenandoah_write_barrier_Type() {</span>
<span class="udiff-line-modified-removed">-   const Type **fields = TypeTuple::fields(1);</span>
<span class="udiff-line-modified-added">+ const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {</span>
<span class="udiff-line-modified-added">+   const Type **fields = TypeTuple::fields(2);</span>
    fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
<span class="udiff-line-modified-removed">-   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);</span>
<span class="udiff-line-modified-added">+   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);</span>
  
    // create result type (range)
    fields = TypeTuple::fields(1);
    fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
    const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
  
    return TypeFunc::make(domain, range);
  }
  
<span class="udiff-line-removed">- void ShenandoahBarrierSetC2::resolve_address(C2Access&amp; access) const {</span>
<span class="udiff-line-removed">-   const TypePtr* adr_type = access.addr().type();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if ((access.decorators() &amp; IN_NATIVE) == 0 &amp;&amp; (adr_type-&gt;isa_instptr() || adr_type-&gt;isa_aryptr())) {</span>
<span class="udiff-line-removed">-     int off = adr_type-&gt;is_ptr()-&gt;offset();</span>
<span class="udiff-line-removed">-     int base_off = adr_type-&gt;isa_instptr() ? instanceOopDesc::base_offset_in_bytes() :</span>
<span class="udiff-line-removed">-       arrayOopDesc::base_offset_in_bytes(adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type());</span>
<span class="udiff-line-removed">-     assert(off != Type::OffsetTop, &quot;unexpected offset&quot;);</span>
<span class="udiff-line-removed">-     if (off == Type::OffsetBot || off &gt;= base_off) {</span>
<span class="udiff-line-removed">-       DecoratorSet decorators = access.decorators();</span>
<span class="udiff-line-removed">-       bool is_write = (decorators &amp; C2_WRITE_ACCESS) != 0;</span>
<span class="udiff-line-removed">-       GraphKit* kit = NULL;</span>
<span class="udiff-line-removed">-       if (access.is_parse_access()) {</span>
<span class="udiff-line-removed">-         C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="udiff-line-removed">-         kit = parse_access.kit();</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       Node* adr = access.addr().node();</span>
<span class="udiff-line-removed">-       assert(adr-&gt;is_AddP(), &quot;unexpected address shape&quot;);</span>
<span class="udiff-line-removed">-       Node* base = adr-&gt;in(AddPNode::Base);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (is_write) {</span>
<span class="udiff-line-removed">-         if (kit != NULL) {</span>
<span class="udiff-line-removed">-           base = shenandoah_write_barrier(kit, base);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="udiff-line-removed">-           assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for clone&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         if (adr_type-&gt;isa_instptr()) {</span>
<span class="udiff-line-removed">-           Compile* C = access.gvn().C;</span>
<span class="udiff-line-removed">-           ciField* field = C-&gt;alias_type(adr_type)-&gt;field();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           // Insert read barrier for Shenandoah.</span>
<span class="udiff-line-removed">-           if (field != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-               ((ShenandoahOptimizeStaticFinals   &amp;&amp; field-&gt;is_static()  &amp;&amp; field-&gt;is_final()) ||</span>
<span class="udiff-line-removed">-                (ShenandoahOptimizeInstanceFinals &amp;&amp; !field-&gt;is_static() &amp;&amp; field-&gt;is_final()) ||</span>
<span class="udiff-line-removed">-                (ShenandoahOptimizeStableFinals   &amp;&amp; field-&gt;is_stable()))) {</span>
<span class="udiff-line-removed">-             // Skip the barrier for special fields</span>
<span class="udiff-line-removed">-           } else {</span>
<span class="udiff-line-removed">-             if (kit != NULL) {</span>
<span class="udiff-line-removed">-               base = shenandoah_read_barrier(kit, base);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-               assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="udiff-line-removed">-               assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           if (kit != NULL) {</span>
<span class="udiff-line-removed">-             base = shenandoah_read_barrier(kit, base);</span>
<span class="udiff-line-removed">-           } else {</span>
<span class="udiff-line-removed">-             assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="udiff-line-removed">-             assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (base != adr-&gt;in(AddPNode::Base)) {</span>
<span class="udiff-line-removed">-         assert(kit != NULL, &quot;no barrier should have been added&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         Node* address = adr-&gt;in(AddPNode::Address);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (address-&gt;is_AddP()) {</span>
<span class="udiff-line-removed">-           assert(address-&gt;in(AddPNode::Base) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="udiff-line-removed">-           assert(!address-&gt;in(AddPNode::Address)-&gt;is_AddP(), &quot;unexpected address shape&quot;);</span>
<span class="udiff-line-removed">-           assert(address-&gt;in(AddPNode::Address) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="udiff-line-removed">-           address = address-&gt;clone();</span>
<span class="udiff-line-removed">-           address-&gt;set_req(AddPNode::Base, base);</span>
<span class="udiff-line-removed">-           address-&gt;set_req(AddPNode::Address, base);</span>
<span class="udiff-line-removed">-           address = kit-&gt;gvn().transform(address);</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           assert(address == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="udiff-line-removed">-           address = base;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         adr = adr-&gt;clone();</span>
<span class="udiff-line-removed">-         adr-&gt;set_req(AddPNode::Base, base);</span>
<span class="udiff-line-removed">-         adr-&gt;set_req(AddPNode::Address, address);</span>
<span class="udiff-line-removed">-         adr = kit-&gt;gvn().transform(adr);</span>
<span class="udiff-line-removed">-         access.addr().set_node(adr);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
    DecoratorSet decorators = access.decorators();
  
    const TypePtr* adr_type = access.addr().type();
    Node* adr = access.addr().node();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -660,101 +525,83 @@</span>
      assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
      C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
      PhaseGVN&amp; gvn =  opt_access.gvn();
      MergeMemNode* mm = opt_access.mem();
  
<span class="udiff-line-removed">-     if (ShenandoahStoreValReadBarrier) {</span>
<span class="udiff-line-removed">-       RegionNode* region = new RegionNode(3);</span>
<span class="udiff-line-removed">-       const Type* v_t = gvn.type(val.node());</span>
<span class="udiff-line-removed">-       Node* phi = new PhiNode(region, v_t-&gt;isa_oopptr() ? v_t-&gt;is_oopptr()-&gt;cast_to_nonconst() : v_t);</span>
<span class="udiff-line-removed">-       Node* cmp = gvn.transform(new CmpPNode(val.node(), gvn.zerocon(T_OBJECT)));</span>
<span class="udiff-line-removed">-       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
<span class="udiff-line-removed">-       IfNode* iff = new IfNode(opt_access.ctl(), bol, PROB_LIKELY_MAG(3), COUNT_UNKNOWN);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       gvn.transform(iff);</span>
<span class="udiff-line-removed">-       if (gvn.is_IterGVN()) {</span>
<span class="udiff-line-removed">-         gvn.is_IterGVN()-&gt;_worklist.push(iff);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         gvn.record_for_igvn(iff);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       Node* null_true = gvn.transform(new IfFalseNode(iff));</span>
<span class="udiff-line-removed">-       Node* null_false = gvn.transform(new IfTrueNode(iff));</span>
<span class="udiff-line-removed">-       region-&gt;init_req(1, null_true);</span>
<span class="udiff-line-removed">-       region-&gt;init_req(2, null_false);</span>
<span class="udiff-line-removed">-       phi-&gt;init_req(1, gvn.zerocon(T_OBJECT));</span>
<span class="udiff-line-removed">-       Node* cast = new CastPPNode(val.node(), gvn.type(val.node())-&gt;join_speculative(TypePtr::NOTNULL));</span>
<span class="udiff-line-removed">-       cast-&gt;set_req(0, null_false);</span>
<span class="udiff-line-removed">-       cast = gvn.transform(cast);</span>
<span class="udiff-line-removed">-       Node* rb = gvn.transform(new ShenandoahReadBarrierNode(null_false, gvn.C-&gt;immutable_memory(), cast, false));</span>
<span class="udiff-line-removed">-       phi-&gt;init_req(2, rb);</span>
<span class="udiff-line-removed">-       opt_access.set_ctl(gvn.transform(region));</span>
<span class="udiff-line-removed">-       val.set_node(gvn.transform(phi));</span>
<span class="udiff-line-removed">-     }</span>
      if (ShenandoahStoreValEnqueueBarrier) {
<span class="udiff-line-modified-removed">-       const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(gvn.type(val.node()));</span>
<span class="udiff-line-removed">-       int alias = gvn.C-&gt;get_alias_index(adr_type);</span>
<span class="udiff-line-removed">-       Node* wb = new ShenandoahWriteBarrierNode(gvn.C, opt_access.ctl(), mm-&gt;memory_at(alias), val.node());</span>
<span class="udiff-line-removed">-       Node* wb_transformed = gvn.transform(wb);</span>
<span class="udiff-line-removed">-       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(wb_transformed));</span>
<span class="udiff-line-removed">-       if (wb_transformed == wb) {</span>
<span class="udiff-line-removed">-         Node* proj = gvn.transform(new ShenandoahWBMemProjNode(wb));</span>
<span class="udiff-line-removed">-         mm-&gt;set_memory_at(alias, proj);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(val.node()));</span>
        val.set_node(enqueue);
      }
    }
    return BarrierSetC2::store_at_resolved(access, val);
  }
  
  Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<span class="udiff-line-modified-removed">-   DecoratorSet decorators = access.decorators();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   Node* adr = access.addr().node();</span>
<span class="udiff-line-modified-removed">-   Node* obj = access.base();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;</span>
<span class="udiff-line-removed">-   bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;</span>
<span class="udiff-line-removed">-   bool on_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="udiff-line-removed">-   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="udiff-line-removed">-   bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;</span>
<span class="udiff-line-removed">-   bool need_cpu_mem_bar = !is_unordered || mismatched || !on_heap;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* top = Compile::current()-&gt;top();</span>
<span class="udiff-line-modified-added">+   // 1: non-reference load, no additional barrier is needed</span>
<span class="udiff-line-modified-added">+   if (!access.is_oop()) {</span>
<span class="udiff-line-modified-added">+     return BarrierSetC2::load_at_resolved(access, val_type);;</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-removed">-   Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;</span>
    Node* load = BarrierSetC2::load_at_resolved(access, val_type);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // If we are reading the value of the referent field of a Reference</span>
<span class="udiff-line-modified-removed">-   // object (either by using Unsafe directly or through reflection)</span>
<span class="udiff-line-modified-removed">-   // then, if SATB is enabled, we need to record the referent in an</span>
<span class="udiff-line-modified-removed">-   // SATB log buffer using the pre-barrier mechanism.</span>
<span class="udiff-line-modified-removed">-   // Also we need to add memory barrier to prevent commoning reads</span>
<span class="udiff-line-modified-removed">-   // from this field across safepoint since GC can change its value.</span>
<span class="udiff-line-modified-removed">-   bool need_read_barrier = ShenandoahKeepAliveBarrier &amp;&amp;</span>
<span class="udiff-line-modified-removed">-     (on_heap &amp;&amp; (on_weak || (unknown &amp;&amp; offset != top &amp;&amp; obj != top)));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (!access.is_oop() || !need_read_barrier) {</span>
<span class="udiff-line-modified-removed">-     return load;</span>
<span class="udiff-line-modified-added">+   DecoratorSet decorators = access.decorators();</span>
<span class="udiff-line-modified-added">+   BasicType type = access.type();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // 2: apply LRB if needed</span>
<span class="udiff-line-modified-added">+   if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {</span>
<span class="udiff-line-modified-added">+     load = new ShenandoahLoadReferenceBarrierNode(NULL,</span>
<span class="udiff-line-modified-added">+                                                   load,</span>
<span class="udiff-line-modified-added">+                                                   ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));</span>
<span class="udiff-line-modified-added">+     if (access.is_parse_access()) {</span>
<span class="udiff-line-modified-added">+       load = static_cast&lt;C2ParseAccess &amp;&gt;(access).kit()-&gt;gvn().transform(load);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       load = static_cast&lt;C2OptAccess &amp;&gt;(access).gvn().transform(load);</span>
<span class="udiff-line-added">+     }</span>
    }
  
<span class="udiff-line-modified-removed">-   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="udiff-line-modified-removed">-   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="udiff-line-modified-removed">-   GraphKit* kit = parse_access.kit();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (on_weak) {</span>
<span class="udiff-line-modified-removed">-     // Use the pre-barrier to record the value in the referent field</span>
<span class="udiff-line-modified-removed">-     satb_write_barrier_pre(kit, false /* do_load */,</span>
<span class="udiff-line-modified-removed">-                            NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,</span>
<span class="udiff-line-modified-removed">-                            load /* pre_val */, T_OBJECT);</span>
<span class="udiff-line-modified-removed">-     // Add memory barrier to prevent commoning reads from this field</span>
<span class="udiff-line-modified-removed">-     // across safepoint since GC can change its value.</span>
<span class="udiff-line-modified-removed">-     kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="udiff-line-modified-removed">-   } else if (unknown) {</span>
<span class="udiff-line-modified-removed">-     // We do not require a mem bar inside pre_barrier if need_mem_bar</span>
<span class="udiff-line-modified-removed">-     // is set: the barriers would be emitted by us.</span>
<span class="udiff-line-modified-removed">-     insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);</span>
<span class="udiff-line-modified-added">+   // 3: apply keep-alive barrier if needed</span>
<span class="udiff-line-modified-added">+   if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {</span>
<span class="udiff-line-modified-added">+     Node* top = Compile::current()-&gt;top();</span>
<span class="udiff-line-modified-added">+     Node* adr = access.addr().node();</span>
<span class="udiff-line-modified-added">+     Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;</span>
<span class="udiff-line-modified-added">+     Node* obj = access.base();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;</span>
<span class="udiff-line-modified-added">+     bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;</span>
<span class="udiff-line-modified-added">+     bool is_traversal_mode = ShenandoahHeap::heap()-&gt;is_traversal_mode();</span>
<span class="udiff-line-modified-added">+     bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0 || is_traversal_mode;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // If we are reading the value of the referent field of a Reference</span>
<span class="udiff-line-modified-added">+     // object (either by using Unsafe directly or through reflection)</span>
<span class="udiff-line-modified-added">+     // then, if SATB is enabled, we need to record the referent in an</span>
<span class="udiff-line-modified-added">+     // SATB log buffer using the pre-barrier mechanism.</span>
<span class="udiff-line-added">+     // Also we need to add memory barrier to prevent commoning reads</span>
<span class="udiff-line-added">+     // from this field across safepoint since GC can change its value.</span>
<span class="udiff-line-added">+     if (!on_weak_ref || (unknown &amp;&amp; (offset == top || obj == top)) || !keep_alive) {</span>
<span class="udiff-line-added">+       return load;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="udiff-line-added">+     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="udiff-line-added">+     GraphKit* kit = parse_access.kit();</span>
<span class="udiff-line-added">+     bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;</span>
<span class="udiff-line-added">+     bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;</span>
<span class="udiff-line-added">+     bool in_native = (decorators &amp; IN_NATIVE) != 0;</span>
<span class="udiff-line-added">+     bool need_cpu_mem_bar = !is_unordered || mismatched || in_native;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (on_weak_ref) {</span>
<span class="udiff-line-added">+       // Use the pre-barrier to record the value in the referent field</span>
<span class="udiff-line-added">+       satb_write_barrier_pre(kit, false /* do_load */,</span>
<span class="udiff-line-added">+                              NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,</span>
<span class="udiff-line-added">+                              load /* pre_val */, T_OBJECT);</span>
<span class="udiff-line-added">+       // Add memory barrier to prevent commoning reads from this field</span>
<span class="udiff-line-added">+       // across safepoint since GC can change its value.</span>
<span class="udiff-line-added">+       kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="udiff-line-added">+     } else if (unknown) {</span>
<span class="udiff-line-added">+       // We do not require a mem bar inside pre_barrier if need_mem_bar</span>
<span class="udiff-line-added">+       // is set: the barriers would be emitted by us.</span>
<span class="udiff-line-added">+       insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);</span>
<span class="udiff-line-added">+     }</span>
    }
  
    return load;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -795,13 +642,14 @@</span>
      access.set_raw_access(load_store);
      pin_atomic_op(access);
  
  #ifdef _LP64
      if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
<span class="udiff-line-modified-removed">-       return kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));</span>
<span class="udiff-line-modified-added">+       load_store = kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));</span>
      }
  #endif
<span class="udiff-line-added">+     load_store = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, false));</span>
      return load_store;
    }
    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -865,58 +713,21 @@</span>
    if (access.is_oop()) {
      val = shenandoah_storeval_barrier(kit, val);
    }
    Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
    if (access.is_oop()) {
<span class="udiff-line-added">+     result = kit-&gt;gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, false));</span>
      shenandoah_write_barrier_pre(kit, false /* do_load */,
                                   NULL, NULL, max_juint, NULL, NULL,
                                   result /* pre_val */, T_OBJECT);
    }
    return result;
  }
  
<span class="udiff-line-removed">- void ShenandoahBarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {</span>
<span class="udiff-line-removed">-   assert(!src-&gt;is_AddP(), &quot;unexpected input&quot;);</span>
<span class="udiff-line-removed">-   src = shenandoah_read_barrier(kit, src);</span>
<span class="udiff-line-removed">-   BarrierSetC2::clone(kit, src, dst, size, is_array);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierSetC2::resolve(GraphKit* kit, Node* n, DecoratorSet decorators) const {</span>
<span class="udiff-line-removed">-   bool is_write = decorators &amp; ACCESS_WRITE;</span>
<span class="udiff-line-removed">-   if (is_write) {</span>
<span class="udiff-line-removed">-     return shenandoah_write_barrier(kit, n);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-   return shenandoah_read_barrier(kit, n);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierSetC2::obj_allocate(PhaseMacroExpand* macro, Node* ctrl, Node* mem, Node* toobig_false, Node* size_in_bytes,</span>
<span class="udiff-line-removed">-                                            Node*&amp; i_o, Node*&amp; needgc_ctrl,</span>
<span class="udiff-line-removed">-                                            Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem,</span>
<span class="udiff-line-removed">-                                            intx prefetch_lines) const {</span>
<span class="udiff-line-removed">-   PhaseIterGVN&amp; igvn = macro-&gt;igvn();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Allocate several words more for the Shenandoah brooks pointer.</span>
<span class="udiff-line-removed">-   size_in_bytes = new AddXNode(size_in_bytes, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));</span>
<span class="udiff-line-removed">-   macro-&gt;transform_later(size_in_bytes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   Node* fast_oop = BarrierSetC2::obj_allocate(macro, ctrl, mem, toobig_false, size_in_bytes,</span>
<span class="udiff-line-removed">-                                               i_o, needgc_ctrl, fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="udiff-line-removed">-                                               prefetch_lines);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Bump up object for Shenandoah brooks pointer.</span>
<span class="udiff-line-removed">-   fast_oop = new AddPNode(macro-&gt;top(), fast_oop, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));</span>
<span class="udiff-line-removed">-   macro-&gt;transform_later(fast_oop);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Initialize Shenandoah brooks pointer to point to the object itself.</span>
<span class="udiff-line-removed">-   fast_oop_rawmem = macro-&gt;make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, ShenandoahBrooksPointer::byte_offset(), fast_oop, T_OBJECT);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return fast_oop;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Support for GC barriers emitted during parsing
  bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
<span class="udiff-line-added">+   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;</span>
    if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
      return false;
    }
    CallLeafNode *call = node-&gt;as_CallLeaf();
    if (call-&gt;_name == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -927,39 +738,45 @@</span>
           strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
           strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
  }
  
  Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
<span class="udiff-line-modified-removed">-   return ShenandoahBarrierNode::skip_through_barrier(c);</span>
<span class="udiff-line-modified-added">+   if (c == NULL) {</span>
<span class="udiff-line-added">+     return c;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (c-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="udiff-line-added">+     return c-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (c-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-added">+     c = c-&gt;in(1);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return c;</span>
  }
  
  bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
<span class="udiff-line-modified-removed">-   return !ShenandoahWriteBarrierNode::expand(C, igvn);</span>
<span class="udiff-line-modified-added">+   return !ShenandoahBarrierC2Support::expand(C, igvn);</span>
  }
  
  bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
    if (mode == LoopOptsShenandoahExpand) {
      assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<span class="udiff-line-modified-removed">-     ShenandoahWriteBarrierNode::pin_and_expand(phase);</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierC2Support::pin_and_expand(phase);</span>
      return true;
    } else if (mode == LoopOptsShenandoahPostExpand) {
      assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<span class="udiff-line-modified-removed">-     visited.Clear();</span>
<span class="udiff-line-modified-removed">-     ShenandoahWriteBarrierNode::optimize_after_expansion(visited, nstack, worklist, phase);</span>
<span class="udiff-line-modified-added">+     visited.clear();</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierC2Support::optimize_after_expansion(visited, nstack, worklist, phase);</span>
      return true;
    }
<span class="udiff-line-removed">-   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;</span>
<span class="udiff-line-removed">-   ShenandoahWriteBarrierNode::optimize_before_expansion(phase, memory_graph_fixers, false);</span>
    return false;
  }
  
  bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
<span class="udiff-line-modified-removed">-   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
<span class="udiff-line-modified-added">+   bool is_oop = is_reference_type(type);</span>
    if (!is_oop) {
      return false;
    }
<span class="udiff-line-removed">- </span>
    if (tightly_coupled_alloc) {
      if (phase == Optimization) {
        return false;
      }
      return !is_clone;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -968,86 +785,128 @@</span>
      return !ShenandoahStoreValEnqueueBarrier;
    }
    return true;
  }
  
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSetC2::clone_needs_postbarrier(ArrayCopyNode *ac, PhaseIterGVN&amp; igvn) {</span>
<span class="udiff-line-modified-removed">-   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="udiff-line-removed">-   const TypeOopPtr* src_type = igvn.type(src)-&gt;is_oopptr();</span>
<span class="udiff-line-modified-added">+ bool ShenandoahBarrierSetC2::clone_needs_barrier(Node* src, PhaseGVN&amp; gvn) {</span>
<span class="udiff-line-modified-added">+   const TypeOopPtr* src_type = gvn.type(src)-&gt;is_oopptr();</span>
    if (src_type-&gt;isa_instptr() != NULL) {
      ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
      if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
        if (ik-&gt;has_object_fields()) {
          return true;
        } else {
          if (!src_type-&gt;klass_is_exact()) {
<span class="udiff-line-modified-removed">-           igvn.C-&gt;dependencies()-&gt;assert_leaf_type(ik);</span>
<span class="udiff-line-modified-added">+           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);</span>
          }
        }
      } else {
        return true;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         }</span>
    } else if (src_type-&gt;isa_aryptr()) {
      BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="udiff-line-modified-removed">-     if (src_elem == T_OBJECT || src_elem == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(src_elem)) {</span>
        return true;
      }
    } else {
      return true;
    }
    return false;
  }
  
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSetC2::clone_barrier_at_expansion(ArrayCopyNode* ac, Node* call, PhaseIterGVN&amp; igvn) const {</span>
<span class="udiff-line-modified-removed">-   assert(ac-&gt;is_clonebasic(), &quot;no other kind of arraycopy here&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (!clone_needs_postbarrier(ac, igvn)) {</span>
<span class="udiff-line-modified-removed">-     BarrierSetC2::clone_barrier_at_expansion(ac, call, igvn);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
<span class="udiff-line-removed">-   Node* c = new ProjNode(call,TypeFunc::Control);</span>
<span class="udiff-line-removed">-   c = igvn.transform(c);</span>
<span class="udiff-line-removed">-   Node* m = new ProjNode(call, TypeFunc::Memory);</span>
<span class="udiff-line-removed">-   m = igvn.transform(m);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {</span>
<span class="udiff-line-modified-added">+   Node* ctrl = ac-&gt;in(TypeFunc::Control);</span>
<span class="udiff-line-modified-added">+   Node* mem = ac-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-modified-added">+   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="udiff-line-modified-added">+   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);</span>
    Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
<span class="udiff-line-modified-removed">-   assert(dest-&gt;is_AddP(), &quot;bad input&quot;);</span>
<span class="udiff-line-modified-removed">-   Node* barrier_call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),</span>
<span class="udiff-line-modified-removed">-                                         CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),</span>
<span class="udiff-line-modified-removed">-                                         &quot;shenandoah_clone_barrier&quot;, raw_adr_type);</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::Control, c);</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::I_O    , igvn.C-&gt;top());</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::Memory , m);</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::ReturnAdr, igvn.C-&gt;top());</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::FramePtr, igvn.C-&gt;top());</span>
<span class="udiff-line-modified-removed">-   barrier_call-&gt;init_req(TypeFunc::Parms+0, dest-&gt;in(AddPNode::Base));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   barrier_call = igvn.transform(barrier_call);</span>
<span class="udiff-line-modified-removed">-   c = new ProjNode(barrier_call,TypeFunc::Control);</span>
<span class="udiff-line-modified-removed">-   c = igvn.transform(c);</span>
<span class="udiff-line-modified-removed">-   m = new ProjNode(barrier_call, TypeFunc::Memory);</span>
<span class="udiff-line-modified-removed">-   m = igvn.transform(m);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   Node* out_c = ac-&gt;proj_out(TypeFunc::Control);</span>
<span class="udiff-line-modified-removed">-   Node* out_m = ac-&gt;proj_out(TypeFunc::Memory);</span>
<span class="udiff-line-modified-removed">-   igvn.replace_node(out_c, c);</span>
<span class="udiff-line-modified-removed">-   igvn.replace_node(out_m, m);</span>
<span class="udiff-line-modified-added">+   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="udiff-line-modified-added">+   Node* length = ac-&gt;in(ArrayCopyNode::Length);</span>
<span class="udiff-line-modified-added">+   assert (src_offset == NULL &amp;&amp; dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
<span class="udiff-line-modified-added">+   assert (src-&gt;is_AddP(), &quot;for clone the src should be the interior ptr&quot;);</span>
<span class="udiff-line-modified-added">+   assert (dest-&gt;is_AddP(), &quot;for clone the dst should be the interior ptr&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {</span>
<span class="udiff-line-modified-added">+     // Check if heap is has forwarded objects. If it does, we need to call into the special</span>
<span class="udiff-line-modified-added">+     // routine that would fix up source references before we can continue.</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };</span>
<span class="udiff-line-modified-added">+     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="udiff-line-modified-added">+     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());</span>
<span class="udiff-line-modified-added">+     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="udiff-line-modified-added">+     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="udiff-line-modified-added">+     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="udiff-line-modified-added">+     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));</span>
<span class="udiff-line-added">+     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));</span>
<span class="udiff-line-added">+     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));</span>
<span class="udiff-line-added">+     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();</span>
<span class="udiff-line-added">+     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));</span>
<span class="udiff-line-added">+     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Heap is stable, no need to do anything additional</span>
<span class="udiff-line-added">+     region-&gt;init_req(_heap_stable, stable_ctrl);</span>
<span class="udiff-line-added">+     mem_phi-&gt;init_req(_heap_stable, mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Heap is unstable, call into clone barrier stub</span>
<span class="udiff-line-added">+     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,</span>
<span class="udiff-line-added">+                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),</span>
<span class="udiff-line-added">+                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),</span>
<span class="udiff-line-added">+                     &quot;shenandoah_clone&quot;,</span>
<span class="udiff-line-added">+                     TypeRawPtr::BOTTOM,</span>
<span class="udiff-line-added">+                     src-&gt;in(AddPNode::Base));</span>
<span class="udiff-line-added">+     call = phase-&gt;transform_later(call);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));</span>
<span class="udiff-line-added">+     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));</span>
<span class="udiff-line-added">+     region-&gt;init_req(_heap_unstable, ctrl);</span>
<span class="udiff-line-added">+     mem_phi-&gt;init_req(_heap_unstable, mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Wire up the actual arraycopy stub now</span>
<span class="udiff-line-added">+     ctrl = phase-&gt;transform_later(region);</span>
<span class="udiff-line-added">+     mem = phase-&gt;transform_later(mem_phi);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const char* name = &quot;arraycopy&quot;;</span>
<span class="udiff-line-added">+     call = phase-&gt;make_leaf_call(ctrl, mem,</span>
<span class="udiff-line-added">+                                  OptoRuntime::fast_arraycopy_Type(),</span>
<span class="udiff-line-added">+                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),</span>
<span class="udiff-line-added">+                                  name, TypeRawPtr::BOTTOM,</span>
<span class="udiff-line-added">+                                  src, dest, length</span>
<span class="udiff-line-added">+                                  LP64_ONLY(COMMA phase-&gt;top()));</span>
<span class="udiff-line-added">+     call = phase-&gt;transform_later(call);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Hook up the whole thing into the graph</span>
<span class="udiff-line-added">+     phase-&gt;igvn().replace_node(ac, call);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     BarrierSetC2::clone_at_expansion(phase, ac);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  
  // Support for macro expanded GC barriers
  void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
<span class="udiff-line-modified-removed">-   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-modified-removed">-     state()-&gt;add_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);</span>
<span class="udiff-line-modified-added">+   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+     state()-&gt;add_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="udiff-line-added">+     state()-&gt;add_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);</span>
    }
  }
  
  void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
<span class="udiff-line-modified-removed">-   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-modified-removed">-     state()-&gt;remove_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);</span>
<span class="udiff-line-modified-added">+   if (node-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="udiff-line-modified-added">+     state()-&gt;remove_enqueue_barrier((ShenandoahEnqueueBarrierNode*) node);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (node-&gt;Opcode() == Op_ShenandoahLoadReferenceBarrier) {</span>
<span class="udiff-line-added">+     state()-&gt;remove_load_reference_barrier((ShenandoahLoadReferenceBarrierNode*) node);</span>
    }
  }
  
  void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
    if (is_shenandoah_wb_pre_call(n)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1089,27 +948,24 @@</span>
        for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
          C-&gt;record_for_igvn(n-&gt;fast_out(i));
        }
      }
    }
<span class="udiff-line-modified-removed">-   for (int i = state()-&gt;shenandoah_barriers_count()-1; i &gt;= 0; i--) {</span>
<span class="udiff-line-modified-removed">-     ShenandoahWriteBarrierNode* n = state()-&gt;shenandoah_barrier(i);</span>
<span class="udiff-line-modified-added">+   for (int i = state()-&gt;enqueue_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-modified-added">+     ShenandoahEnqueueBarrierNode* n = state()-&gt;enqueue_barrier(i);</span>
      if (!useful.member(n)) {
<span class="udiff-line-modified-removed">-       state()-&gt;remove_shenandoah_barrier(n);</span>
<span class="udiff-line-modified-added">+       state()-&gt;remove_enqueue_barrier(n);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   for (int i = state()-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-added">+     ShenandoahLoadReferenceBarrierNode* n = state()-&gt;load_reference_barrier(i);</span>
<span class="udiff-line-added">+     if (!useful.member(n)) {</span>
<span class="udiff-line-added">+       state()-&gt;remove_load_reference_barrier(n);</span>
      }
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::has_special_unique_user(const Node* node) const {</span>
<span class="udiff-line-removed">-   assert(node-&gt;outcnt() == 1, &quot;match only for unique out&quot;);</span>
<span class="udiff-line-removed">-   Node* n = node-&gt;unique_out();</span>
<span class="udiff-line-removed">-   return node-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; n-&gt;Opcode() == Op_ShenandoahWBMemProj;</span>
  }
  
<span class="udiff-line-removed">- void ShenandoahBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {}</span>
<span class="udiff-line-removed">- </span>
  void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
    return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
  }
  
  ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1120,12 +976,12 @@</span>
  // expanded later, then now is the time to do so.
  bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
  
  #ifdef ASSERT
  void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
<span class="udiff-line-modified-removed">-   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeExpand) {</span>
<span class="udiff-line-modified-removed">-     ShenandoahBarrierNode::verify(Compile::current()-&gt;root());</span>
<span class="udiff-line-modified-added">+   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeMacroExpand) {</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierC2Support::verify(Compile::current()-&gt;root());</span>
    } else if (phase == BarrierSetC2::BeforeCodeGen) {
      // Verify G1 pre-barriers
      const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
  
      ResourceArea *area = Thread::current()-&gt;resource_area();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1227,19 +1083,19 @@</span>
        }
        return n;
      }
    } else if (can_reshape &amp;&amp;
               n-&gt;Opcode() == Op_If &amp;&amp;
<span class="udiff-line-modified-removed">-              ShenandoahWriteBarrierNode::is_heap_stable_test(n) &amp;&amp;</span>
<span class="udiff-line-modified-added">+              ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;</span>
               n-&gt;in(0) != NULL) {
      Node* dom = n-&gt;in(0);
      Node* prev_dom = n;
      int op = n-&gt;Opcode();
      int dist = 16;
      // Search up the dominator tree for another heap stable test
      while (dom-&gt;Opcode() != op    ||  // Not same opcode?
<span class="udiff-line-modified-removed">-            !ShenandoahWriteBarrierNode::is_heap_stable_test(dom) ||  // Not same input 1?</span>
<span class="udiff-line-modified-added">+            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?</span>
             prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
        if (dist &lt; 0) return NULL;
  
        dist--;
        prev_dom = dom;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1256,74 +1112,20 @@</span>
    }
  
    return NULL;
  }
  
<span class="udiff-line-removed">- Node* ShenandoahBarrierSetC2::identity_node(PhaseGVN* phase, Node* n) const {</span>
<span class="udiff-line-removed">-   if (n-&gt;is_Load()) {</span>
<span class="udiff-line-removed">-     Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="udiff-line-removed">-     Node *value = n-&gt;as_Load()-&gt;can_see_stored_value(mem, phase);</span>
<span class="udiff-line-removed">-     if (value) {</span>
<span class="udiff-line-removed">-       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();</span>
<span class="udiff-line-removed">-       if (igvn != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-           value-&gt;is_Phi() &amp;&amp;</span>
<span class="udiff-line-removed">-           value-&gt;req() &gt; 2 &amp;&amp;</span>
<span class="udiff-line-removed">-           value-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-           value-&gt;in(1)-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-         if (igvn-&gt;_worklist.member(value) ||</span>
<span class="udiff-line-removed">-             igvn-&gt;_worklist.member(value-&gt;in(0)) ||</span>
<span class="udiff-line-removed">-             (value-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-              value-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;</span>
<span class="udiff-line-removed">-              (igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)) ||</span>
<span class="udiff-line-removed">-               (value-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;</span>
<span class="udiff-line-removed">-                igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)-&gt;in(0)))))) {</span>
<span class="udiff-line-removed">-           igvn-&gt;_worklist.push(n);</span>
<span class="udiff-line-removed">-           return n;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       // (This works even when value is a Con, but LoadNode::Value</span>
<span class="udiff-line-removed">-       // usually runs first, producing the singleton type of the Con.)</span>
<span class="udiff-line-removed">-       Node *value_no_barrier = step_over_gc_barrier(value-&gt;Opcode() == Op_EncodeP ? value-&gt;in(1) : value);</span>
<span class="udiff-line-removed">-       if (value-&gt;Opcode() == Op_EncodeP) {</span>
<span class="udiff-line-removed">-         if (value_no_barrier != value-&gt;in(1)) {</span>
<span class="udiff-line-removed">-           Node *encode = value-&gt;clone();</span>
<span class="udiff-line-removed">-           encode-&gt;set_req(1, value_no_barrier);</span>
<span class="udiff-line-removed">-           encode = phase-&gt;transform(encode);</span>
<span class="udiff-line-removed">-           return encode;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         return value_no_barrier;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return n;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
    for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
      Node* u = n-&gt;fast_out(i);
      if (!is_shenandoah_wb_pre_call(u)) {
        return false;
      }
    }
    return n-&gt;outcnt() &gt; 0;
  }
  
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::flatten_gc_alias_type(const TypePtr*&amp; adr_type) const {</span>
<span class="udiff-line-removed">-   int offset = adr_type-&gt;offset();</span>
<span class="udiff-line-removed">-   if (offset == ShenandoahBrooksPointer::byte_offset()) {</span>
<span class="udiff-line-removed">-     if (adr_type-&gt;isa_aryptr()) {</span>
<span class="udiff-line-removed">-       adr_type = TypeAryPtr::make(adr_type-&gt;ptr(), adr_type-&gt;isa_aryptr()-&gt;ary(), adr_type-&gt;isa_aryptr()-&gt;klass(), false, offset);</span>
<span class="udiff-line-removed">-     } else if (adr_type-&gt;isa_instptr()) {</span>
<span class="udiff-line-removed">-       adr_type = TypeInstPtr::make(adr_type-&gt;ptr(), ciEnv::current()-&gt;Object_klass(), false, NULL, offset);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
    switch (opcode) {
      case Op_CallLeaf:
      case Op_CallLeafNoFP: {
        assert (n-&gt;is_Call(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1354,31 +1156,18 @@</span>
          bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
          assert( !tp || oop_offset_is_sane, &quot;&quot; );
        }
  #endif
        return true;
<span class="udiff-line-modified-removed">-     case Op_ShenandoahReadBarrier:</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     case Op_ShenandoahWriteBarrier:</span>
<span class="udiff-line-modified-added">+     case Op_ShenandoahLoadReferenceBarrier:</span>
        assert(false, &quot;should have been expanded already&quot;);
        return true;
      default:
        return false;
    }
  }
  
<span class="udiff-line-removed">- #ifdef ASSERT</span>
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::verify_gc_alias_type(const TypePtr* adr_type, int offset) const {</span>
<span class="udiff-line-removed">-   if (offset == ShenandoahBrooksPointer::byte_offset() &amp;&amp;</span>
<span class="udiff-line-removed">-       (adr_type-&gt;base() == Type::AryPtr || adr_type-&gt;base() == Type::OopPtr)) {</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
    switch (opcode) {
      case Op_ShenandoahCompareAndExchangeP:
      case Op_ShenandoahCompareAndExchangeN:
        conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1410,19 +1199,16 @@</span>
            }
          }
        }
        return false;
      }
<span class="udiff-line-removed">-     case Op_ShenandoahReadBarrier:</span>
<span class="udiff-line-removed">-     case Op_ShenandoahWriteBarrier:</span>
<span class="udiff-line-removed">-       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.</span>
<span class="udiff-line-removed">-       // It doesn&#39;t escape.</span>
<span class="udiff-line-removed">-       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), delayed_worklist);</span>
<span class="udiff-line-removed">-       break;</span>
      case Op_ShenandoahEnqueueBarrier:
        conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
        break;
<span class="udiff-line-added">+     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="udiff-line-added">+       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), delayed_worklist);</span>
<span class="udiff-line-added">+       return true;</span>
      default:
        // Nothing
        break;
    }
    return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1439,19 +1225,16 @@</span>
      case Op_ShenandoahCompareAndSwapP:
      case Op_ShenandoahCompareAndSwapN:
      case Op_ShenandoahWeakCompareAndSwapP:
      case Op_ShenandoahWeakCompareAndSwapN:
        return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
<span class="udiff-line-removed">-     case Op_ShenandoahReadBarrier:</span>
<span class="udiff-line-removed">-     case Op_ShenandoahWriteBarrier:</span>
<span class="udiff-line-removed">-       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.</span>
<span class="udiff-line-removed">-       // It doesn&#39;t escape.</span>
<span class="udiff-line-removed">-       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), NULL);</span>
<span class="udiff-line-removed">-       return true;</span>
      case Op_ShenandoahEnqueueBarrier:
        conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
        return true;
<span class="udiff-line-added">+     case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="udiff-line-added">+       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn), NULL);</span>
<span class="udiff-line-added">+       return true;</span>
      default:
        // Nothing
        break;
    }
    return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1461,28 +1244,10 @@</span>
    return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
           n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
  
  }
  
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::escape_is_barrier_node(Node* n) const {</span>
<span class="udiff-line-removed">-   return n-&gt;is_ShenandoahBarrier();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {</span>
<span class="udiff-line-removed">-   switch (opcode) {</span>
<span class="udiff-line-removed">-     case Op_ShenandoahReadBarrier:</span>
<span class="udiff-line-removed">-       if (n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;is_DecodeNarrowPtr()) {</span>
<span class="udiff-line-removed">-         matcher-&gt;set_shared(n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;in(1));</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       matcher-&gt;set_shared(n);</span>
<span class="udiff-line-removed">-       return true;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
    switch (opcode) {
      case Op_ShenandoahCompareAndExchangeP:
      case Op_ShenandoahCompareAndExchangeN:
      case Op_ShenandoahWeakCompareAndSwapP:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1508,64 +1273,5 @@</span>
           xop == Op_ShenandoahWeakCompareAndSwapP ||
           xop == Op_ShenandoahWeakCompareAndSwapN ||
           xop == Op_ShenandoahCompareAndSwapN ||
           xop == Op_ShenandoahCompareAndSwapP;
  }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetC2::igvn_add_users_to_worklist(PhaseIterGVN* igvn, Node* use) const {</span>
<span class="udiff-line-removed">-   if (use-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {</span>
<span class="udiff-line-removed">-       Node* u = use-&gt;fast_out(i2);</span>
<span class="udiff-line-removed">-       Node* cmp = use-&gt;find_out_with(Op_CmpP);</span>
<span class="udiff-line-removed">-       if (u-&gt;Opcode() == Op_CmpP) {</span>
<span class="udiff-line-removed">-         igvn-&gt;_worklist.push(cmp);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void ShenandoahBarrierSetC2::ccp_analyze(PhaseCCP* ccp, Unique_Node_List&amp; worklist, Node* use) const {</span>
<span class="udiff-line-removed">-   if (use-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {</span>
<span class="udiff-line-removed">-       Node* p = use-&gt;fast_out(i2);</span>
<span class="udiff-line-removed">-       if (p-&gt;Opcode() == Op_AddP) {</span>
<span class="udiff-line-removed">-         for (DUIterator_Fast i3max, i3 = p-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {</span>
<span class="udiff-line-removed">-           Node* q = p-&gt;fast_out(i3);</span>
<span class="udiff-line-removed">-           if (q-&gt;is_Load()) {</span>
<span class="udiff-line-removed">-             if(q-&gt;bottom_type() != ccp-&gt;type(q)) {</span>
<span class="udiff-line-removed">-               worklist.push(q);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- Node* ShenandoahBarrierSetC2::split_if_pre(PhaseIdealLoop* phase, Node* n) const {</span>
<span class="udiff-line-removed">-   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {</span>
<span class="udiff-line-removed">-     ((ShenandoahReadBarrierNode*)n)-&gt;try_move(phase);</span>
<span class="udiff-line-removed">-   } else if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="udiff-line-removed">-     return ((ShenandoahWriteBarrierNode*)n)-&gt;try_split_thru_phi(phase);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::build_loop_late_post(PhaseIdealLoop* phase, Node* n) const {</span>
<span class="udiff-line-removed">-   return ShenandoahBarrierNode::build_loop_late_post(phase, n);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- bool ShenandoahBarrierSetC2::sink_node(PhaseIdealLoop* phase, Node* n, Node* x, Node* x_ctrl, Node* n_ctrl) const {</span>
<span class="udiff-line-removed">-   if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="udiff-line-removed">-     return x-&gt;as_ShenandoahBarrier()-&gt;sink_node(phase, x_ctrl, n_ctrl);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (n-&gt;is_MergeMem()) {</span>
<span class="udiff-line-removed">-     // PhaseIdealLoop::split_if_with_blocks_post() would:</span>
<span class="udiff-line-removed">-     // _igvn._worklist.yank(x);</span>
<span class="udiff-line-removed">-     // which sometimes causes chains of MergeMem which some of</span>
<span class="udiff-line-removed">-     // shenandoah specific code doesn&#39;t support</span>
<span class="udiff-line-removed">-     phase-&gt;register_new_node(x, x_ctrl);</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return false;</span>
<span class="udiff-line-removed">- }</span>
</pre>
<center><a href="../c1/shenandoahBarrierSetC1.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetC2.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
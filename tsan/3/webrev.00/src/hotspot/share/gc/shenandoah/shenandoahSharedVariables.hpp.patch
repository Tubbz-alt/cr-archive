diff a/src/hotspot/share/gc/shenandoah/shenandoahSharedVariables.hpp b/src/hotspot/share/gc/shenandoah/shenandoahSharedVariables.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahSharedVariables.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahSharedVariables.hpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -23,21 +24,21 @@
 
 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSHAREDVARIABLES_HPP
 #define SHARE_GC_SHENANDOAH_SHENANDOAHSHAREDVARIABLES_HPP
 
 #include "memory/allocation.hpp"
-#include "runtime/orderAccess.hpp"
+#include "runtime/atomic.hpp"
 
 typedef jbyte ShenandoahSharedValue;
 
 // Needed for cooperation with generated code.
 STATIC_ASSERT(sizeof(ShenandoahSharedValue) == 1);
 
 typedef struct ShenandoahSharedFlag {
   enum {
     UNSET = 0,
-    SET = 1,
+    SET = 1
   };
 
   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile ShenandoahSharedValue));
   volatile ShenandoahSharedValue value;
   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
@@ -45,46 +46,46 @@
   ShenandoahSharedFlag() {
     unset();
   }
 
   void set() {
-    OrderAccess::release_store_fence(&value, (ShenandoahSharedValue)SET);
+    Atomic::release_store_fence(&value, (ShenandoahSharedValue)SET);
   }
 
   void unset() {
-    OrderAccess::release_store_fence(&value, (ShenandoahSharedValue)UNSET);
+    Atomic::release_store_fence(&value, (ShenandoahSharedValue)UNSET);
   }
 
   bool is_set() const {
-    return OrderAccess::load_acquire(&value) == SET;
+    return Atomic::load_acquire(&value) == SET;
   }
 
   bool is_unset() const {
-    return OrderAccess::load_acquire(&value) == UNSET;
+    return Atomic::load_acquire(&value) == UNSET;
   }
 
-  void set_cond(bool value) {
-    if (value) {
+  void set_cond(bool val) {
+    if (val) {
       set();
     } else {
       unset();
     }
   }
 
   bool try_set() {
     if (is_set()) {
       return false;
     }
-    ShenandoahSharedValue old = Atomic::cmpxchg((ShenandoahSharedValue)SET, &value, (ShenandoahSharedValue)UNSET);
+    ShenandoahSharedValue old = Atomic::cmpxchg(&value, (ShenandoahSharedValue)UNSET, (ShenandoahSharedValue)SET);
     return old == UNSET; // success
   }
 
   bool try_unset() {
     if (!is_set()) {
       return false;
     }
-    ShenandoahSharedValue old = Atomic::cmpxchg((ShenandoahSharedValue)UNSET, &value, (ShenandoahSharedValue)SET);
+    ShenandoahSharedValue old = Atomic::cmpxchg(&value, (ShenandoahSharedValue)SET, (ShenandoahSharedValue)UNSET);
     return old == SET; // success
   }
 
   volatile ShenandoahSharedValue* addr_of() {
     return &value;
@@ -116,61 +117,61 @@
 
   void set(uint mask) {
     assert (mask < (sizeof(ShenandoahSharedValue) * CHAR_MAX), "sanity");
     ShenandoahSharedValue mask_val = (ShenandoahSharedValue) mask;
     while (true) {
-      ShenandoahSharedValue ov = OrderAccess::load_acquire(&value);
+      ShenandoahSharedValue ov = Atomic::load_acquire(&value);
       if ((ov & mask_val) != 0) {
         // already set
         return;
       }
 
       ShenandoahSharedValue nv = ov | mask_val;
-      if (Atomic::cmpxchg(nv, &value, ov) == ov) {
+      if (Atomic::cmpxchg(&value, ov, nv) == ov) {
         // successfully set
         return;
       }
     }
   }
 
   void unset(uint mask) {
     assert (mask < (sizeof(ShenandoahSharedValue) * CHAR_MAX), "sanity");
     ShenandoahSharedValue mask_val = (ShenandoahSharedValue) mask;
     while (true) {
-      ShenandoahSharedValue ov = OrderAccess::load_acquire(&value);
+      ShenandoahSharedValue ov = Atomic::load_acquire(&value);
       if ((ov & mask_val) == 0) {
         // already unset
         return;
       }
 
       ShenandoahSharedValue nv = ov & ~mask_val;
-      if (Atomic::cmpxchg(nv, &value, ov) == ov) {
+      if (Atomic::cmpxchg(&value, ov, nv) == ov) {
         // successfully unset
         return;
       }
     }
   }
 
   void clear() {
-    OrderAccess::release_store_fence(&value, (ShenandoahSharedValue)0);
+    Atomic::release_store_fence(&value, (ShenandoahSharedValue)0);
   }
 
   bool is_set(uint mask) const {
     return !is_unset(mask);
   }
 
   bool is_unset(uint mask) const {
     assert (mask < (sizeof(ShenandoahSharedValue) * CHAR_MAX), "sanity");
-    return (OrderAccess::load_acquire(&value) & (ShenandoahSharedValue) mask) == 0;
+    return (Atomic::load_acquire(&value) & (ShenandoahSharedValue) mask) == 0;
   }
 
   bool is_clear() const {
-    return (OrderAccess::load_acquire(&value)) == 0;
+    return (Atomic::load_acquire(&value)) == 0;
   }
 
-  void set_cond(uint mask, bool value) {
-    if (value) {
+  void set_cond(uint mask, bool val) {
+    if (val) {
       set(mask);
     } else {
       unset(mask);
     }
   }
@@ -209,21 +210,21 @@
   }
 
   void set(T v) {
     assert (v >= 0, "sanity");
     assert (v < (sizeof(ShenandoahSharedValue) * CHAR_MAX), "sanity");
-    OrderAccess::release_store_fence(&value, (ShenandoahSharedValue)v);
+    Atomic::release_store_fence(&value, (ShenandoahSharedValue)v);
   }
 
   T get() const {
-    return (T)OrderAccess::load_acquire(&value);
+    return (T)Atomic::load_acquire(&value);
   }
 
   T cmpxchg(T new_value, T expected) {
     assert (new_value >= 0, "sanity");
     assert (new_value < (sizeof(ShenandoahSharedValue) * CHAR_MAX), "sanity");
-    return (T)Atomic::cmpxchg((ShenandoahSharedValue)new_value, &value, (ShenandoahSharedValue)expected);
+    return (T)Atomic::cmpxchg(&value, (ShenandoahSharedValue)expected, (ShenandoahSharedValue)new_value);
   }
 
   volatile ShenandoahSharedValue* addr_of() {
     return &value;
   }

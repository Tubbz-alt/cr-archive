<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/heuristics/shenandoahTraversalHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahStaticHeuristics.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalHeuristics.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/heuristics/shenandoahTraversalHeuristics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,53 ***</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logTag.hpp&quot;
  #include &quot;utilities/quickSort.hpp&quot;
  
  ShenandoahTraversalHeuristics::ShenandoahTraversalHeuristics() : ShenandoahHeuristics(),
<span class="line-modified">!   _last_cset_select(0)</span>
<span class="line-removed">-  {</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(ShenandoahSATBBarrier,            false);</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(ShenandoahStoreValReadBarrier,    false);</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(ShenandoahStoreValEnqueueBarrier, true);</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(ShenandoahKeepAliveBarrier,       false);</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(ShenandoahAllowMixedAllocs,       false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahRefProcFrequency, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Adjust class unloading settings only if globally enabled.</span>
<span class="line-removed">-   if (ClassUnloadingWithConcurrentMark) {</span>
<span class="line-removed">-     SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 1);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   SHENANDOAH_ERGO_ENABLE_FLAG(ExplicitGCInvokesConcurrent);</span>
<span class="line-removed">-   SHENANDOAH_ERGO_ENABLE_FLAG(ShenandoahImplicitGCInvokesConcurrent);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Final configuration checks</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahReadBarrier);</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahWriteBarrier);</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahStoreValEnqueueBarrier);</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahCASBarrier);</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahAcmpBarrier);</span>
<span class="line-removed">-   SHENANDOAH_CHECK_FLAG_SET(ShenandoahCloneBarrier);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahTraversalHeuristics::should_start_normal_gc() const {</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
  
  bool ShenandoahTraversalHeuristics::is_experimental() {
<span class="line-modified">!   return true;</span>
  }
  
  bool ShenandoahTraversalHeuristics::is_diagnostic() {
    return false;
  }
  
<span class="line-removed">- bool ShenandoahTraversalHeuristics::can_do_traversal_gc() {</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  const char* ShenandoahTraversalHeuristics::name() {
    return &quot;traversal&quot;;
  }
  
  void ShenandoahTraversalHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
<span class="line-new-header">--- 33,20 ---</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logTag.hpp&quot;
  #include &quot;utilities/quickSort.hpp&quot;
  
  ShenandoahTraversalHeuristics::ShenandoahTraversalHeuristics() : ShenandoahHeuristics(),
<span class="line-modified">!   _last_cset_select(0) {}</span>
  
  bool ShenandoahTraversalHeuristics::is_experimental() {
<span class="line-modified">!   return false;</span>
  }
  
  bool ShenandoahTraversalHeuristics::is_diagnostic() {
    return false;
  }
  
  const char* ShenandoahTraversalHeuristics::name() {
    return &quot;traversal&quot;;
  }
  
  void ShenandoahTraversalHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,10 ***</span>
<span class="line-new-header">--- 58,13 ---</span>
    traversal_set-&gt;clear();
  
    RegionData *data = get_region_data_cache(heap-&gt;num_regions());
    size_t cnt = 0;
  
<span class="line-added">+   // About to choose the collection set, make sure we have pinned regions in correct state</span>
<span class="line-added">+   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">+ </span>
    // Step 0. Prepare all regions
  
    for (size_t i = 0; i &lt; heap-&gt;num_regions(); i++) {
      ShenandoahHeapRegion* r = heap-&gt;get_region(i);
      if (r-&gt;used() &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,19 ***</span>
    // ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.
    //
    // The significant complication is that liveness data was collected at the previous cycle, and only
    // for those regions that were allocated before previous cycle started.
  
<span class="line-modified">!   size_t capacity    = heap-&gt;capacity();</span>
    size_t actual_free = heap-&gt;free_set()-&gt;available();
<span class="line-modified">!   size_t free_target = ShenandoahMinFreeThreshold * capacity / 100;</span>
    size_t min_garbage = free_target &gt; actual_free ? (free_target - actual_free) : 0;
<span class="line-modified">!   size_t max_cset    = (size_t)(1.0 * ShenandoahEvacReserve * capacity / 100 / ShenandoahEvacWaste);</span>
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Adaptive CSet Selection. Target Free: &quot; SIZE_FORMAT &quot;M, Actual Free: &quot;</span>
<span class="line-modified">!                      SIZE_FORMAT &quot;M, Max CSet: &quot; SIZE_FORMAT &quot;M, Min Garbage: &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-modified">!                      free_target / M, actual_free / M, max_cset / M, min_garbage / M);</span>
  
    // Better select garbage-first regions, and then older ones
    QuickSort::sort&lt;RegionData&gt;(data, (int) cnt, compare_by_garbage_then_alloc_seq_ascending, false);
  
    size_t cur_cset = 0;
<span class="line-new-header">--- 96,22 ---</span>
    // ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.
    //
    // The significant complication is that liveness data was collected at the previous cycle, and only
    // for those regions that were allocated before previous cycle started.
  
<span class="line-modified">!   size_t capacity    = heap-&gt;max_capacity();</span>
    size_t actual_free = heap-&gt;free_set()-&gt;available();
<span class="line-modified">!   size_t free_target = capacity / 100 * ShenandoahMinFreeThreshold;</span>
    size_t min_garbage = free_target &gt; actual_free ? (free_target - actual_free) : 0;
<span class="line-modified">!   size_t max_cset    = (size_t)((1.0 * capacity / 100 * ShenandoahEvacReserve) / ShenandoahEvacWaste);</span>
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Adaptive CSet Selection. Target Free: &quot; SIZE_FORMAT &quot;%s, Actual Free: &quot;</span>
<span class="line-modified">!                      SIZE_FORMAT &quot;%s, Max CSet: &quot; SIZE_FORMAT &quot;%s, Min Garbage: &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),</span>
<span class="line-added">+                      byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),</span>
<span class="line-added">+                      byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),</span>
<span class="line-added">+                      byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));</span>
  
    // Better select garbage-first regions, and then older ones
    QuickSort::sort&lt;RegionData&gt;(data, (int) cnt, compare_by_garbage_then_alloc_seq_ascending, false);
  
    size_t cur_cset = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,60 ***</span>
    collection_set-&gt;update_region_status();
  
    _last_cset_select = ShenandoahHeapRegion::seqnum_current_alloc();
  }
  
<span class="line-modified">! bool ShenandoahTraversalHeuristics::should_start_traversal_gc() {</span>
    ShenandoahHeap* heap = ShenandoahHeap::heap();
    assert(!heap-&gt;has_forwarded_objects(), &quot;no forwarded objects here&quot;);
  
<span class="line-modified">!   size_t capacity = heap-&gt;capacity();</span>
    size_t available = heap-&gt;free_set()-&gt;available();
  
    // Check if we are falling below the worst limit, time to trigger the GC, regardless of
    // anything else.
<span class="line-modified">!   size_t min_threshold = ShenandoahMinFreeThreshold * heap-&gt;capacity() / 100;</span>
    if (available &lt; min_threshold) {
<span class="line-modified">!     log_info(gc)(&quot;Trigger: Free (&quot; SIZE_FORMAT &quot;M) is below minimum threshold (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="line-modified">!                  available / M, min_threshold / M);</span>
      return true;
    }
  
    // Check if are need to learn a bit about the application
    const size_t max_learn = ShenandoahLearningSteps;
    if (_gc_times_learned &lt; max_learn) {
<span class="line-modified">!     size_t init_threshold = ShenandoahInitFreeThreshold * heap-&gt;capacity() / 100;</span>
      if (available &lt; init_threshold) {
<span class="line-modified">!       log_info(gc)(&quot;Trigger: Learning &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT &quot;. Free (&quot; SIZE_FORMAT &quot;M) is below initial threshold (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="line-modified">!                    _gc_times_learned + 1, max_learn, available / M, init_threshold / M);</span>
        return true;
      }
    }
  
    // Check if allocation headroom is still okay. This also factors in:
    //   1. Some space to absorb allocation spikes
    //   2. Accumulated penalties from Degenerated and Full GC
  
    size_t allocation_headroom = available;
  
<span class="line-modified">!   size_t spike_headroom = ShenandoahAllocSpikeFactor * capacity / 100;</span>
<span class="line-modified">!   size_t penalties      = _gc_time_penalties         * capacity / 100;</span>
  
    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);
    allocation_headroom -= MIN2(allocation_headroom, penalties);
  
    double average_gc = _gc_time_history-&gt;avg();
    double time_since_last = time_since_last_gc();
    double allocation_rate = heap-&gt;bytes_allocated_since_gc_start() / time_since_last;
  
    if (average_gc &gt; allocation_headroom / allocation_rate) {
<span class="line-modified">!     log_info(gc)(&quot;Trigger: Average GC time (%.2f ms) is above the time for allocation rate (%.2f MB/s) to deplete free headroom (&quot; SIZE_FORMAT &quot;M)&quot;,</span>
<span class="line-modified">!                  average_gc * 1000, allocation_rate / M, allocation_headroom / M);</span>
<span class="line-modified">!     log_info(gc, ergo)(&quot;Free headroom: &quot; SIZE_FORMAT &quot;M (free) - &quot; SIZE_FORMAT &quot;M (spike) - &quot; SIZE_FORMAT &quot;M (penalties) = &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-modified">!                        available / M, spike_headroom / M, penalties / M, allocation_headroom / M);</span>
      return true;
<span class="line-modified">!   } else if (ShenandoahHeuristics::should_start_normal_gc()) {</span>
      return true;
    }
  
    return false;
  }
<span class="line-new-header">--- 184,68 ---</span>
    collection_set-&gt;update_region_status();
  
    _last_cset_select = ShenandoahHeapRegion::seqnum_current_alloc();
  }
  
<span class="line-modified">! bool ShenandoahTraversalHeuristics::should_start_gc() const {</span>
    ShenandoahHeap* heap = ShenandoahHeap::heap();
    assert(!heap-&gt;has_forwarded_objects(), &quot;no forwarded objects here&quot;);
  
<span class="line-modified">!   size_t capacity = heap-&gt;max_capacity();</span>
    size_t available = heap-&gt;free_set()-&gt;available();
  
    // Check if we are falling below the worst limit, time to trigger the GC, regardless of
    // anything else.
<span class="line-modified">!   size_t min_threshold = capacity / 100 * ShenandoahMinFreeThreshold;</span>
    if (available &lt; min_threshold) {
<span class="line-modified">!     log_info(gc)(&quot;Trigger: Free (&quot; SIZE_FORMAT &quot;%s) is below minimum threshold (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="line-modified">!                  byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),</span>
<span class="line-added">+                  byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));</span>
      return true;
    }
  
    // Check if are need to learn a bit about the application
    const size_t max_learn = ShenandoahLearningSteps;
    if (_gc_times_learned &lt; max_learn) {
<span class="line-modified">!     size_t init_threshold = capacity / 100 * ShenandoahInitFreeThreshold;</span>
      if (available &lt; init_threshold) {
<span class="line-modified">!       log_info(gc)(&quot;Trigger: Learning &quot; SIZE_FORMAT &quot; of &quot; SIZE_FORMAT &quot;. Free (&quot; SIZE_FORMAT &quot;%s) is below initial threshold (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="line-modified">!                    _gc_times_learned + 1, max_learn,</span>
<span class="line-added">+                    byte_size_in_proper_unit(available),      proper_unit_for_byte_size(available),</span>
<span class="line-added">+                    byte_size_in_proper_unit(init_threshold), proper_unit_for_byte_size(init_threshold));</span>
        return true;
      }
    }
  
    // Check if allocation headroom is still okay. This also factors in:
    //   1. Some space to absorb allocation spikes
    //   2. Accumulated penalties from Degenerated and Full GC
  
    size_t allocation_headroom = available;
  
<span class="line-modified">!   size_t spike_headroom = capacity / 100 * ShenandoahAllocSpikeFactor;</span>
<span class="line-modified">!   size_t penalties      = capacity / 100 * _gc_time_penalties;</span>
  
    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);
    allocation_headroom -= MIN2(allocation_headroom, penalties);
  
    double average_gc = _gc_time_history-&gt;avg();
    double time_since_last = time_since_last_gc();
    double allocation_rate = heap-&gt;bytes_allocated_since_gc_start() / time_since_last;
  
    if (average_gc &gt; allocation_headroom / allocation_rate) {
<span class="line-modified">!     log_info(gc)(&quot;Trigger: Average GC time (%.2f ms) is above the time for allocation rate (%.0f %sB/s) to deplete free headroom (&quot; SIZE_FORMAT &quot;%s)&quot;,</span>
<span class="line-modified">!                  average_gc * 1000,</span>
<span class="line-modified">!                  byte_size_in_proper_unit(allocation_rate),     proper_unit_for_byte_size(allocation_rate),</span>
<span class="line-modified">!                  byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));</span>
<span class="line-added">+     log_info(gc, ergo)(&quot;Free headroom: &quot; SIZE_FORMAT &quot;%s (free) - &quot; SIZE_FORMAT &quot;%s (spike) - &quot; SIZE_FORMAT &quot;%s (penalties) = &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-added">+                  byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),</span>
<span class="line-added">+                  byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),</span>
<span class="line-added">+                  byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),</span>
<span class="line-added">+                  byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));</span>
      return true;
<span class="line-modified">!   } else if (ShenandoahHeuristics::should_start_gc()) {</span>
      return true;
    }
  
    return false;
  }
</pre>
<center><a href="shenandoahStaticHeuristics.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalHeuristics.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
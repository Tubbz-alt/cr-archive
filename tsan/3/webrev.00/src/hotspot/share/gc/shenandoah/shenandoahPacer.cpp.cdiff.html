<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahOopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahPacer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 25,11 ---</span>
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  
  /*
   * In normal concurrent cycle, we have to pace the application to let GC finish.
   *
   * Here, we do not know how large would be the collection set, and what are the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,13 ***</span>
    tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">!                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      live / M, free / M, non_taxable / M, tax);</span>
  }
  
  void ShenandoahPacer::setup_for_evac() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
<span class="line-new-header">--- 70,16 ---</span>
    tax *= 3;                          // mark is phase 1 of 3, claim 1/3 of free for it
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Mark. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">!                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),</span>
<span class="line-added">+                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">+                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">+                      tax);</span>
  }
  
  void ShenandoahPacer::setup_for_evac() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,13 ***</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">!                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      used / M, free / M, non_taxable / M, tax);</span>
  }
  
  void ShenandoahPacer::setup_for_updaterefs() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
<span class="line-new-header">--- 94,16 ---</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Evacuation. Used CSet: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">!                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),</span>
<span class="line-added">+                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">+                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">+                      tax);</span>
  }
  
  void ShenandoahPacer::setup_for_updaterefs() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,13 ***</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">!                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      used / M, free / M, non_taxable / M, tax);</span>
  }
  
  /*
   * Traversal walks the entire heap once, and therefore we have to make assumptions about its
   * liveness, like concurrent mark does.
<span class="line-new-header">--- 118,16 ---</span>
    tax = MAX2&lt;double&gt;(1, tax);        // never allocate more than GC processes during the phase
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Update Refs. Used: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">!                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),</span>
<span class="line-added">+                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">+                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">+                      tax);</span>
  }
  
  /*
   * Traversal walks the entire heap once, and therefore we have to make assumptions about its
   * liveness, like concurrent mark does.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,13 ***</span>
    double tax = 1.0 * live / taxable; // base tax for available free space
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Traversal. Expected Live: &quot; SIZE_FORMAT &quot;M, Free: &quot; SIZE_FORMAT</span>
<span class="line-modified">!                      &quot;M, Non-Taxable: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      live / M, free / M, non_taxable / M, tax);</span>
  }
  
  /*
   * In idle phase, we have to pace the application to let control thread react with GC start.
   *
<span class="line-new-header">--- 145,16 ---</span>
    double tax = 1.0 * live / taxable; // base tax for available free space
    tax *= ShenandoahPacingSurcharge;  // additional surcharge to help unclutter heap
  
    restart_with(non_taxable, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Traversal. Expected Live: &quot; SIZE_FORMAT &quot;%s, Free: &quot; SIZE_FORMAT &quot;%s, &quot;</span>
<span class="line-modified">!                      &quot;Non-Taxable: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),</span>
<span class="line-added">+                      byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),</span>
<span class="line-added">+                      byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),</span>
<span class="line-added">+                      tax);</span>
  }
  
  /*
   * In idle phase, we have to pace the application to let control thread react with GC start.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,37 ***</span>
   */
  
  void ShenandoahPacer::setup_for_idle() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
<span class="line-modified">!   size_t initial = _heap-&gt;capacity() * ShenandoahPacingIdleSlack / 100;</span>
    double tax = 1;
  
    restart_with(initial, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Idle. Initial: &quot; SIZE_FORMAT &quot;M, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      initial / M, tax);</span>
  }
  
  size_t ShenandoahPacer::update_and_get_progress_history() {
    if (_progress == -1) {
      // First initialization, report some prior
<span class="line-modified">!     Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &amp;_progress);</span>
<span class="line-modified">!     return (size_t) (_heap-&gt;capacity() * 0.1);</span>
    } else {
      // Record history, and reply historical data
      _progress_history-&gt;add(_progress);
<span class="line-modified">!     Atomic::store((intptr_t)PACING_PROGRESS_ZERO, &amp;_progress);</span>
      return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
    }
  }
  
  void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
    size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
    STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
<span class="line-modified">!   Atomic::xchg((intptr_t)initial, &amp;_budget);</span>
<span class="line-modified">!   Atomic::store(tax_rate, &amp;_tax_rate);</span>
    Atomic::inc(&amp;_epoch);
  }
  
  bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
<span class="line-new-header">--- 165,38 ---</span>
   */
  
  void ShenandoahPacer::setup_for_idle() {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
  
<span class="line-modified">!   size_t initial = _heap-&gt;max_capacity() / 100 * ShenandoahPacingIdleSlack;</span>
    double tax = 1;
  
    restart_with(initial, tax);
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Pacer for Idle. Initial: &quot; SIZE_FORMAT &quot;%s, Alloc Tax Rate: %.1fx&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial),</span>
<span class="line-added">+                      tax);</span>
  }
  
  size_t ShenandoahPacer::update_and_get_progress_history() {
    if (_progress == -1) {
      // First initialization, report some prior
<span class="line-modified">!     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);</span>
<span class="line-modified">!     return (size_t) (_heap-&gt;max_capacity() * 0.1);</span>
    } else {
      // Record history, and reply historical data
      _progress_history-&gt;add(_progress);
<span class="line-modified">!     Atomic::store(&amp;_progress, (intptr_t)PACING_PROGRESS_ZERO);</span>
      return (size_t) (_progress_history-&gt;avg() * HeapWordSize);
    }
  }
  
  void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {
    size_t initial = (size_t)(non_taxable_bytes * tax_rate) &gt;&gt; LogHeapWordSize;
    STATIC_ASSERT(sizeof(size_t) &lt;= sizeof(intptr_t));
<span class="line-modified">!   Atomic::xchg(&amp;_budget, (intptr_t)initial);</span>
<span class="line-modified">!   Atomic::store(&amp;_tax_rate, tax_rate);</span>
    Atomic::inc(&amp;_epoch);
  }
  
  bool ShenandoahPacer::claim_for_alloc(size_t words, bool force) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,11 ***</span>
      if (cur &lt; tax &amp;&amp; !force) {
        // Progress depleted, alas.
        return false;
      }
      new_val = cur - tax;
<span class="line-modified">!   } while (Atomic::cmpxchg(new_val, &amp;_budget, cur) != cur);</span>
    return true;
  }
  
  void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
<span class="line-new-header">--- 210,11 ---</span>
      if (cur &lt; tax &amp;&amp; !force) {
        // Progress depleted, alas.
        return false;
      }
      new_val = cur - tax;
<span class="line-modified">!   } while (Atomic::cmpxchg(&amp;_budget, cur, new_val) != cur);</span>
    return true;
  }
  
  void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {
    assert(ShenandoahPacing, &quot;Only be here when pacing is enabled&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
      // Stale ticket, no need to unpace.
      return;
    }
  
    intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
<span class="line-modified">!   Atomic::add(tax, &amp;_budget);</span>
  }
  
  intptr_t ShenandoahPacer::epoch() {
    return Atomic::load(&amp;_epoch);
  }
<span class="line-new-header">--- 223,11 ---</span>
      // Stale ticket, no need to unpace.
      return;
    }
  
    intptr_t tax = MAX2&lt;intptr_t&gt;(1, words * Atomic::load(&amp;_tax_rate));
<span class="line-modified">!   Atomic::add(&amp;_budget, tax);</span>
  }
  
  intptr_t ShenandoahPacer::epoch() {
    return Atomic::load(&amp;_epoch);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,10 ***</span>
<span class="line-new-header">--- 238,19 ---</span>
    // Fast path: try to allocate right away
    if (claim_for_alloc(words, false)) {
      return;
    }
  
<span class="line-added">+   // Threads that are attaching should not block at all: they are not</span>
<span class="line-added">+   // fully initialized yet. Calling sleep() on them would be awkward.</span>
<span class="line-added">+   // This is probably the path that allocates the thread oop itself.</span>
<span class="line-added">+   // Forcefully claim without waiting.</span>
<span class="line-added">+   if (JavaThread::current()-&gt;is_attaching_via_jni()) {</span>
<span class="line-added">+     claim_for_alloc(words, true);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    size_t max = ShenandoahPacingMaxDelay;
    double start = os::elapsedTime();
  
    size_t total = 0;
    size_t cur = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,11 ***</span>
      if (total + cur &gt; max) {
        cur = (max &gt; total) ? (max - total) : 0;
      }
      cur = MAX2&lt;size_t&gt;(1, cur);
  
<span class="line-modified">!     os::sleep(Thread::current(), cur, true);</span>
  
      double end = os::elapsedTime();
      total = (size_t)((end - start) * 1000);
  
      if (total &gt; max) {
<span class="line-new-header">--- 264,11 ---</span>
      if (total + cur &gt; max) {
        cur = (max &gt; total) ? (max - total) : 0;
      }
      cur = MAX2&lt;size_t&gt;(1, cur);
  
<span class="line-modified">!     JavaThread::current()-&gt;sleep(cur);</span>
  
      double end = os::elapsedTime();
      total = (size_t)((end - start) * 1000);
  
      if (total &gt; max) {
</pre>
<center><a href="shenandoahOopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
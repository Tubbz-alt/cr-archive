<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCollectorPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 
 30 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 31 #include &quot;gc/shared/gcTimer.hpp&quot;
 32 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;

 34 
 35 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;

 36 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="line-modified"> 39 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
 40 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 44 
 45 #include &quot;memory/iterator.inline.hpp&quot;
 46 #include &quot;memory/metaspace.hpp&quot;
 47 #include &quot;memory/resourceArea.hpp&quot;
 48 #include &quot;oops/oop.inline.hpp&quot;
 49 #include &quot;runtime/handles.inline.hpp&quot;
 50 
<span class="line-modified"> 51 template&lt;UpdateRefsMode UPDATE_REFS, StringDedupMode STRING_DEDUP&gt;</span>
 52 class ShenandoahInitMarkRootsClosure : public OopClosure {
 53 private:
 54   ShenandoahObjToScanQueue* _queue;
 55   ShenandoahHeap* _heap;
 56   ShenandoahMarkingContext* const _mark_context;
 57 
 58   template &lt;class T&gt;
 59   inline void do_oop_work(T* p) {
<span class="line-modified"> 60     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, STRING_DEDUP&gt;(p, _heap, _queue, _mark_context);</span>
 61   }
 62 
 63 public:
 64   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 65     _queue(q),
 66     _heap(ShenandoahHeap::heap()),
 67     _mark_context(_heap-&gt;marking_context()) {};
 68 
 69   void do_oop(narrowOop* p) { do_oop_work(p); }
 70   void do_oop(oop* p)       { do_oop_work(p); }
 71 };
 72 
 73 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 74   MetadataVisitingOopIterateClosure(rp),
 75   _queue(q),
 76   _heap(ShenandoahHeap::heap()),
 77   _mark_context(_heap-&gt;marking_context())
 78 { }
 79 
 80 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 81 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 82 private:
<span class="line-modified"> 83   ShenandoahRootProcessor* _rp;</span>
 84   bool _process_refs;
 85 public:
<span class="line-modified"> 86   ShenandoahInitMarkRootsTask(ShenandoahRootProcessor* rp, bool process_refs) :</span>
 87     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
 88     _rp(rp),
 89     _process_refs(process_refs) {
 90   }
 91 
 92   void work(uint worker_id) {
 93     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 94     ShenandoahParallelWorkerSession worker_session(worker_id);
 95 
 96     ShenandoahHeap* heap = ShenandoahHeap::heap();
 97     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
 98     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
 99 
100     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
101 
<span class="line-modified">102     if (ShenandoahStringDedup::is_enabled()) {</span>
<span class="line-modified">103       ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS, ENQUEUE_DEDUP&gt; mark_cl(q);</span>
<span class="line-removed">104       do_work(heap, &amp;mark_cl, worker_id);</span>
<span class="line-removed">105     } else {</span>
<span class="line-removed">106       ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS, NO_DEDUP&gt; mark_cl(q);</span>
<span class="line-removed">107       do_work(heap, &amp;mark_cl, worker_id);</span>
<span class="line-removed">108     }</span>
109   }
110 
111 private:
112   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
113     // The rationale for selecting the roots to scan is as follows:
114     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
115     //      code cache. This will allow us to identify the dead classes, unload them, *and*
116     //      invalidate the relevant code cache blobs. This could be only done together with
117     //      class unloading.
118     //   b. With unload_classes = false, we have to nominally retain all the references from code
119     //      cache, because there could be the case of embedded class/oop in the generated code,
120     //      which we will never visit during mark. Without code cache invalidation, as in (a),
121     //      we risk executing that code cache blob, and crashing.
<span class="line-removed">122     //   c. With ShenandoahConcurrentScanCodeRoots, we avoid scanning the entire code cache here,</span>
<span class="line-removed">123     //      and instead do that in concurrent phase under the relevant lock. This saves init mark</span>
<span class="line-removed">124     //      pause time.</span>
<span class="line-removed">125 </span>
<span class="line-removed">126     CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);</span>
<span class="line-removed">127     MarkingCodeBlobClosure blobs_cl(oops, ! CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">128     OopClosure* weak_oops = _process_refs ? NULL : oops;</span>
<span class="line-removed">129 </span>
<span class="line-removed">130     ResourceMark m;</span>
131     if (heap-&gt;unload_classes()) {
<span class="line-modified">132       _rp-&gt;process_strong_roots(oops, weak_oops, &amp;clds_cl, NULL, &amp;blobs_cl, NULL, worker_id);</span>
133     } else {
<span class="line-modified">134       if (ShenandoahConcurrentScanCodeRoots) {</span>
<span class="line-removed">135         CodeBlobClosure* code_blobs = NULL;</span>
<span class="line-removed">136 #ifdef ASSERT</span>
<span class="line-removed">137         ShenandoahAssertToSpaceClosure assert_to_space_oops;</span>
<span class="line-removed">138         CodeBlobToOopClosure assert_to_space(&amp;assert_to_space_oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">139         // If conc code cache evac is disabled, code cache should have only to-space ptrs.</span>
<span class="line-removed">140         // Otherwise, it should have to-space ptrs only if mark does not update refs.</span>
<span class="line-removed">141         if (!heap-&gt;has_forwarded_objects()) {</span>
<span class="line-removed">142           code_blobs = &amp;assert_to_space;</span>
<span class="line-removed">143         }</span>
<span class="line-removed">144 #endif</span>
<span class="line-removed">145         _rp-&gt;process_all_roots(oops, weak_oops, &amp;clds_cl, code_blobs, NULL, worker_id);</span>
<span class="line-removed">146       } else {</span>
<span class="line-removed">147         _rp-&gt;process_all_roots(oops, weak_oops, &amp;clds_cl, &amp;blobs_cl, NULL, worker_id);</span>
<span class="line-removed">148       }</span>
149     }
150   }
151 };
152 
153 class ShenandoahUpdateRootsTask : public AbstractGangTask {
154 private:
<span class="line-modified">155   ShenandoahRootProcessor* _rp;</span>
<span class="line-modified">156   const bool _update_code_cache;</span>
157 public:
<span class="line-modified">158   ShenandoahUpdateRootsTask(ShenandoahRootProcessor* rp, bool update_code_cache) :</span>
159     AbstractGangTask(&quot;Shenandoah update roots task&quot;),
<span class="line-modified">160     _rp(rp),</span>
<span class="line-modified">161     _update_code_cache(update_code_cache) {</span>
162   }
163 
164   void work(uint worker_id) {
165     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
166     ShenandoahParallelWorkerSession worker_session(worker_id);
167 
168     ShenandoahHeap* heap = ShenandoahHeap::heap();
169     ShenandoahUpdateRefsClosure cl;
<span class="line-modified">170     CLDToOopClosure cldCl(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-modified">171 </span>
<span class="line-modified">172     CodeBlobClosure* code_blobs;</span>
<span class="line-removed">173     CodeBlobToOopClosure update_blobs(&amp;cl, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">174 #ifdef ASSERT</span>
<span class="line-removed">175     ShenandoahAssertToSpaceClosure assert_to_space_oops;</span>
<span class="line-removed">176     CodeBlobToOopClosure assert_to_space(&amp;assert_to_space_oops, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">177 #endif</span>
<span class="line-removed">178     if (_update_code_cache) {</span>
<span class="line-removed">179       code_blobs = &amp;update_blobs;</span>
180     } else {
<span class="line-modified">181       code_blobs =</span>
<span class="line-modified">182         DEBUG_ONLY(&amp;assert_to_space)</span>
<span class="line-removed">183         NOT_DEBUG(NULL);</span>
184     }
<span class="line-removed">185     _rp-&gt;process_all_roots(&amp;cl, &amp;cl, &amp;cldCl, code_blobs, NULL, worker_id);</span>
186   }
187 };
188 
189 class ShenandoahConcurrentMarkingTask : public AbstractGangTask {
190 private:
191   ShenandoahConcurrentMark* _cm;
<span class="line-modified">192   ShenandoahTaskTerminator* _terminator;</span>
193 
194 public:
<span class="line-modified">195   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, ShenandoahTaskTerminator* terminator) :</span>
196     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
197   }
198 
199   void work(uint worker_id) {
200     ShenandoahHeap* heap = ShenandoahHeap::heap();
201     ShenandoahConcurrentWorkerSession worker_session(worker_id);
202     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
203     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
204     ReferenceProcessor* rp;
205     if (heap-&gt;process_references()) {
206       rp = heap-&gt;ref_processor();
207       shenandoah_assert_rp_isalive_installed();
208     } else {
209       rp = NULL;
210     }
211 
212     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
213     _cm-&gt;mark_loop(worker_id, _terminator, rp,
214                    true, // cancellable
215                    ShenandoahStringDedup::is_enabled()); // perform string dedup
216   }
217 };
218 
219 class ShenandoahSATBThreadsClosure : public ThreadClosure {
220 private:
221   ShenandoahSATBBufferClosure* _satb_cl;
<span class="line-modified">222   int _thread_parity;</span>
223 
224 public:
225   ShenandoahSATBThreadsClosure(ShenandoahSATBBufferClosure* satb_cl) :
226     _satb_cl(satb_cl),
<span class="line-modified">227     _thread_parity(Threads::thread_claim_parity()) {}</span>
228 
229   void do_thread(Thread* thread) {
<span class="line-modified">230     if (thread-&gt;claim_oops_do(true, _thread_parity)) {</span>
231       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
232     }
233   }
234 };
235 
236 class ShenandoahFinalMarkingTask : public AbstractGangTask {
237 private:
238   ShenandoahConcurrentMark* _cm;
<span class="line-modified">239   ShenandoahTaskTerminator* _terminator;</span>
240   bool _dedup_string;
241 
242 public:
<span class="line-modified">243   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, ShenandoahTaskTerminator* terminator, bool dedup_string) :</span>
244     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
245   }
246 
247   void work(uint worker_id) {
248     ShenandoahHeap* heap = ShenandoahHeap::heap();
249 
250     ShenandoahParallelWorkerSession worker_session(worker_id);
251     // First drain remaining SATB buffers.
252     // Notice that this is not strictly necessary for mark-compact. But since
253     // it requires a StrongRootsScope around the task, we need to claim the
254     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
255     // full-gc.
256     {
257       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
258       ShenandoahSATBBufferClosure cl(q);
259       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
260       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
261       ShenandoahSATBThreadsClosure tc(&amp;cl);
262       Threads::threads_do(&amp;tc);
263     }
264 
265     ReferenceProcessor* rp;
266     if (heap-&gt;process_references()) {
267       rp = heap-&gt;ref_processor();
268       shenandoah_assert_rp_isalive_installed();
269     } else {
270       rp = NULL;
271     }
272 
<span class="line-modified">273     // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,</span>
<span class="line-modified">274     // let&#39;s check here.</span>
<span class="line-modified">275     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);</span>



276     _cm-&gt;mark_loop(worker_id, _terminator, rp,
277                    false, // not cancellable
278                    _dedup_string);
279 
280     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
281   }
282 };
283 
284 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
285   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287 
288   ShenandoahHeap* heap = ShenandoahHeap::heap();
289 
290   ShenandoahGCPhase phase(root_phase);
291 
292   WorkGang* workers = heap-&gt;workers();
293   uint nworkers = workers-&gt;active_workers();
294 
295   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
296 
<span class="line-modified">297   ShenandoahRootProcessor root_proc(heap, nworkers, root_phase);</span>
298   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
299   task_queues()-&gt;reserve(nworkers);
300 
301   if (heap-&gt;has_forwarded_objects()) {
302     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());
303     workers-&gt;run_task(&amp;mark_roots);
304   } else {
305     // No need to update references, which means the heap is stable.
306     // Can save time not walking through forwarding pointers.
307     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());
308     workers-&gt;run_task(&amp;mark_roots);
309   }
310 
311   if (ShenandoahConcurrentScanCodeRoots) {
312     clear_claim_codecache();
313   }
314 }
315 
316 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
317   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
<span class="line-modified">318 </span>
<span class="line-modified">319   bool update_code_cache = true; // initialize to safer value</span>
<span class="line-modified">320   switch (root_phase) {</span>
<span class="line-removed">321     case ShenandoahPhaseTimings::update_roots:</span>
<span class="line-removed">322     case ShenandoahPhaseTimings::final_update_refs_roots:</span>
<span class="line-removed">323       update_code_cache = false;</span>
<span class="line-removed">324       break;</span>
<span class="line-removed">325     case ShenandoahPhaseTimings::full_gc_roots:</span>
<span class="line-removed">326     case ShenandoahPhaseTimings::degen_gc_update_roots:</span>
<span class="line-removed">327       update_code_cache = true;</span>
<span class="line-removed">328       break;</span>
<span class="line-removed">329     default:</span>
<span class="line-removed">330       ShouldNotReachHere();</span>
<span class="line-removed">331   }</span>
332 
333   ShenandoahGCPhase phase(root_phase);
334 
<span class="line-modified">335 #if defined(COMPILER2) || INCLUDE_JVMCI</span>


336   DerivedPointerTable::clear();
337 #endif
338 
339   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
340 
<span class="line-modified">341   ShenandoahRootProcessor root_proc(_heap, nworkers, root_phase);</span>
<span class="line-modified">342   ShenandoahUpdateRootsTask update_roots(&amp;root_proc, update_code_cache);</span>
343   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
344 
<span class="line-modified">345 #if defined(COMPILER2) || INCLUDE_JVMCI</span>









































346   DerivedPointerTable::update_pointers();
347 #endif
348 }
349 
350 void ShenandoahConcurrentMark::initialize(uint workers) {
351   _heap = ShenandoahHeap::heap();
352 
353   uint num_queues = MAX2(workers, 1U);
354 
355   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
356 
357   for (uint i = 0; i &lt; num_queues; ++i) {
358     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
359     task_queue-&gt;initialize();
360     _task_queues-&gt;register_queue(i, task_queue);
361   }
362 }
363 
364 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
365   if (ShenandoahConcurrentScanCodeRoots &amp;&amp; claim_codecache()) {
366     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
367     if (!_heap-&gt;unload_classes()) {
<span class="line-modified">368       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
369       // TODO: We can not honor StringDeduplication here, due to lock ranking
370       // inversion. So, we may miss some deduplication candidates.
371       if (_heap-&gt;has_forwarded_objects()) {
372         ShenandoahMarkResolveRefsClosure cl(q, rp);
373         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
374         CodeCache::blobs_do(&amp;blobs);
375       } else {
376         ShenandoahMarkRefsClosure cl(q, rp);
377         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
378         CodeCache::blobs_do(&amp;blobs);
379       }
380     }
381   }
382 }
383 
384 void ShenandoahConcurrentMark::mark_from_roots() {
385   WorkGang* workers = _heap-&gt;workers();
386   uint nworkers = workers-&gt;active_workers();
387 
388   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
389 
390   if (_heap-&gt;process_references()) {
391     ReferenceProcessor* rp = _heap-&gt;ref_processor();
392     rp-&gt;set_active_mt_degree(nworkers);
393 
394     // enable (&quot;weak&quot;) refs discovery
395     rp-&gt;enable_discovery(true /*verify_no_refs*/);
396     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
397   }
398 
399   shenandoah_assert_rp_isalive_not_installed();
400   ShenandoahIsAliveSelector is_alive;
401   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
402 
403   task_queues()-&gt;reserve(nworkers);
404 
405   {
406     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::conc_termination);
<span class="line-modified">407     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
408     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
409     workers-&gt;run_task(&amp;task);
410   }
411 
412   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
413 }
414 
415 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
416   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
417 
418   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
419 
420   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
421   // It does two different things for concurrent vs. mark-compact GC:
422   // - For concurrent GC, it starts with empty task queues, drains the remaining
423   //   SATB buffers, and then completes the marking closure.
424   // - For mark-compact GC, it starts out with the task queues seeded by initial
425   //   root scan, and completes the closure, thus marking through all live objects
426   // The implementation is the same, so it&#39;s shared here.
427   {
428     ShenandoahGCPhase phase(full_gc ?
429                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
430                             ShenandoahPhaseTimings::finish_queues);
431     task_queues()-&gt;reserve(nworkers);
432 
433     shenandoah_assert_rp_isalive_not_installed();
434     ShenandoahIsAliveSelector is_alive;
435     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
436 
437     ShenandoahTerminationTracker termination_tracker(full_gc ?
438                                                      ShenandoahPhaseTimings::full_gc_mark_termination :
439                                                      ShenandoahPhaseTimings::termination);
440 
441     StrongRootsScope scope(nworkers);
<span class="line-modified">442     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
443     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
444     _heap-&gt;workers()-&gt;run_task(&amp;task);
445   }
446 
447   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
448 
449   // When we&#39;re done marking everything, we process weak references.
450   if (_heap-&gt;process_references()) {
451     weak_refs_work(full_gc);
452   }
453 
<span class="line-removed">454   // And finally finish class unloading</span>
<span class="line-removed">455   if (_heap-&gt;unload_classes()) {</span>
<span class="line-removed">456     _heap-&gt;unload_classes_and_cleanup_tables(full_gc);</span>
<span class="line-removed">457   }</span>
<span class="line-removed">458 </span>
459   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
460   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
461   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
<span class="line-removed">462 </span>
<span class="line-removed">463   // Resize Metaspace</span>
<span class="line-removed">464   MetaspaceGC::compute_new_size();</span>
465 }
466 
467 // Weak Reference Closures
468 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
469   uint _worker_id;
<span class="line-modified">470   ShenandoahTaskTerminator* _terminator;</span>
471   bool _reset_terminator;
472 
473 public:
<span class="line-modified">474   ShenandoahCMDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
475     _worker_id(worker_id),
476     _terminator(t),
477     _reset_terminator(reset_terminator) {
478   }
479 
480   void do_void() {
481     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
482 
483     ShenandoahHeap* sh = ShenandoahHeap::heap();
484     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
485     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
486     ReferenceProcessor* rp = sh-&gt;ref_processor();
487 
488     shenandoah_assert_rp_isalive_installed();
489 
490     scm-&gt;mark_loop(_worker_id, _terminator, rp,
491                    false,   // not cancellable
492                    false);  // do not do strdedup
493 
494     if (_reset_terminator) {
</pre>
<hr />
<pre>
539   void do_oop(oop* p)       { do_oop_work(p); }
540 };
541 
542 class ShenandoahWeakUpdateClosure : public OopClosure {
543 private:
544   ShenandoahHeap* const _heap;
545 
546   template &lt;class T&gt;
547   inline void do_oop_work(T* p) {
548     oop o = _heap-&gt;maybe_update_with_forwarded(p);
549     shenandoah_assert_marked_except(p, o, o == NULL);
550   }
551 
552 public:
553   ShenandoahWeakUpdateClosure() : _heap(ShenandoahHeap::heap()) {}
554 
555   void do_oop(narrowOop* p) { do_oop_work(p); }
556   void do_oop(oop* p)       { do_oop_work(p); }
557 };
558 
<span class="line-removed">559 class ShenandoahWeakAssertNotForwardedClosure : public OopClosure {</span>
<span class="line-removed">560 private:</span>
<span class="line-removed">561   template &lt;class T&gt;</span>
<span class="line-removed">562   inline void do_oop_work(T* p) {</span>
<span class="line-removed">563     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed">564     if (!CompressedOops::is_null(o)) {</span>
<span class="line-removed">565       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed">566       shenandoah_assert_not_forwarded(p, obj);</span>
<span class="line-removed">567     }</span>
<span class="line-removed">568   }</span>
<span class="line-removed">569 </span>
<span class="line-removed">570 public:</span>
<span class="line-removed">571   ShenandoahWeakAssertNotForwardedClosure() {}</span>
<span class="line-removed">572 </span>
<span class="line-removed">573   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed">574   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed">575 };</span>
<span class="line-removed">576 </span>
577 class ShenandoahRefProcTaskProxy : public AbstractGangTask {
578 private:
579   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">580   ShenandoahTaskTerminator* _terminator;</span>
581 
582 public:
583   ShenandoahRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">584                              ShenandoahTaskTerminator* t) :</span>
585     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
586     _proc_task(proc_task),
587     _terminator(t) {
588   }
589 
590   void work(uint worker_id) {
591     ResourceMark rm;
592     HandleMark hm;
593     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
594     ShenandoahHeap* heap = ShenandoahHeap::heap();
595     ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);
596     if (heap-&gt;has_forwarded_objects()) {
597       ShenandoahForwardedIsAliveClosure is_alive;
598       ShenandoahCMKeepAliveUpdateClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
599       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
600     } else {
601       ShenandoahIsAliveClosure is_alive;
602       ShenandoahCMKeepAliveClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
603       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
604     }
</pre>
<hr />
<pre>
608 class ShenandoahRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
609 private:
610   WorkGang* _workers;
611 
612 public:
613   ShenandoahRefProcTaskExecutor(WorkGang* workers) :
614     _workers(workers) {
615   }
616 
617   // Executes a task using worker threads.
618   void execute(ProcessTask&amp; task, uint ergo_workers) {
619     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
620 
621     ShenandoahHeap* heap = ShenandoahHeap::heap();
622     ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
623     ShenandoahPushWorkerQueuesScope scope(_workers, cm-&gt;task_queues(),
624                                           ergo_workers,
625                                           /* do_check = */ false);
626     uint nworkers = _workers-&gt;active_workers();
627     cm-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">628     ShenandoahTaskTerminator terminator(nworkers, cm-&gt;task_queues());</span>
629     ShenandoahRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
630     _workers-&gt;run_task(&amp;proc_task_proxy);
631   }
632 };
633 
634 void ShenandoahConcurrentMark::weak_refs_work(bool full_gc) {
635   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
636 
637   ShenandoahPhaseTimings::Phase phase_root =
638           full_gc ?
639           ShenandoahPhaseTimings::full_gc_weakrefs :
640           ShenandoahPhaseTimings::weakrefs;
641 
642   ShenandoahGCPhase phase(phase_root);
643 
644   ReferenceProcessor* rp = _heap-&gt;ref_processor();
645 
646   // NOTE: We cannot shortcut on has_discovered_references() here, because
647   // we will miss marking JNI Weak refs then, see implementation in
648   // ReferenceProcessor::process_discovered_references.
</pre>
<hr />
<pre>
666           ShenandoahPhaseTimings::full_gc_weakrefs_termination :
667           ShenandoahPhaseTimings::weakrefs_termination;
668 
669   shenandoah_assert_rp_isalive_not_installed();
670   ShenandoahIsAliveSelector is_alive;
671   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
672 
673   WorkGang* workers = _heap-&gt;workers();
674   uint nworkers = workers-&gt;active_workers();
675 
676   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
677   rp-&gt;set_active_mt_degree(nworkers);
678 
679   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
680 
681   // complete_gc and keep_alive closures instantiated here are only needed for
682   // single-threaded path in RP. They share the queue 0 for tracking work, which
683   // simplifies implementation. Since RP may decide to call complete_gc several
684   // times, we need to be able to reuse the terminator.
685   uint serial_worker_id = 0;
<span class="line-modified">686   ShenandoahTaskTerminator terminator(1, task_queues());</span>
687   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
688 
689   ShenandoahRefProcTaskExecutor executor(workers);
690 
691   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
692 
693   {
694     ShenandoahGCPhase phase(phase_process);
695     ShenandoahTerminationTracker phase_term(phase_process_termination);
696 
<span class="line-removed">697     // Process leftover weak oops: update them, if needed (using parallel version),</span>
<span class="line-removed">698     // or assert they do not need updating (using serial version) otherwise.</span>
<span class="line-removed">699     // Weak processor API requires us to visit the oops, even if we are not doing</span>
<span class="line-removed">700     // anything to them.</span>
701     if (_heap-&gt;has_forwarded_objects()) {
702       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
703       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
704                                         &amp;complete_gc, &amp;executor,
705                                         &amp;pt);
706 
<span class="line-removed">707       ShenandoahWeakUpdateClosure cl;</span>
<span class="line-removed">708       WeakProcessor::weak_oops_do(workers, is_alive.is_alive_closure(), &amp;cl, 1);</span>
709     } else {
710       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
711       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
712                                         &amp;complete_gc, &amp;executor,
713                                         &amp;pt);
714 
<span class="line-removed">715       ShenandoahWeakAssertNotForwardedClosure cl;</span>
<span class="line-removed">716       WeakProcessor::weak_oops_do(is_alive.is_alive_closure(), &amp;cl);</span>
717     }
718 
719     pt.print_all_references();
720 
721     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
722   }
723 }
724 
725 class ShenandoahCancelledGCYieldClosure : public YieldClosure {
726 private:
727   ShenandoahHeap* const _heap;
728 public:
729   ShenandoahCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
730   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
731 };
732 
733 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
734 public:
735   void do_void() {
736     ShenandoahHeap* sh = ShenandoahHeap::heap();
737     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
738     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified">739     ShenandoahTaskTerminator terminator(1, scm-&gt;task_queues());</span>
740 
741     ReferenceProcessor* rp = sh-&gt;ref_processor();
742     shenandoah_assert_rp_isalive_installed();
743 
744     scm-&gt;mark_loop(0, &amp;terminator, rp,
745                    false, // not cancellable
746                    false); // do not do strdedup
747   }
748 };
749 
750 class ShenandoahPrecleanKeepAliveUpdateClosure : public OopClosure {
751 private:
752   ShenandoahObjToScanQueue* _queue;
753   ShenandoahHeap* _heap;
754   ShenandoahMarkingContext* const _mark_context;
755 
756   template &lt;class T&gt;
757   inline void do_oop_work(T* p) {
758     ShenandoahConcurrentMark::mark_through_ref&lt;T, CONCURRENT, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
759   }
</pre>
<hr />
<pre>
842   workers-&gt;run_task(&amp;task);
843 
844   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
845 }
846 
847 void ShenandoahConcurrentMark::cancel() {
848   // Clean up marking stacks.
849   ShenandoahObjToScanQueueSet* queues = task_queues();
850   queues-&gt;clear();
851 
852   // Cancel SATB buffers.
853   ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();
854 }
855 
856 ShenandoahObjToScanQueue* ShenandoahConcurrentMark::get_queue(uint worker_id) {
857   assert(task_queues()-&gt;get_reserved() &gt; worker_id, &quot;No reserved queue for worker id: %d&quot;, worker_id);
858   return _task_queues-&gt;queue(worker_id);
859 }
860 
861 template &lt;bool CANCELLABLE&gt;
<span class="line-modified">862 void ShenandoahConcurrentMark::mark_loop_prework(uint w, ShenandoahTaskTerminator *t, ReferenceProcessor *rp,</span>
863                                                  bool strdedup) {
864   ShenandoahObjToScanQueue* q = get_queue(w);
865 
866   jushort* ld = _heap-&gt;get_liveness_cache(w);
867 
868   // TODO: We can clean up this if we figure out how to do templated oop closures that
869   // play nice with specialized_oop_iterators.
870   if (_heap-&gt;unload_classes()) {
871     if (_heap-&gt;has_forwarded_objects()) {
872       if (strdedup) {
873         ShenandoahMarkUpdateRefsMetadataDedupClosure cl(q, rp);
874         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
875       } else {
876         ShenandoahMarkUpdateRefsMetadataClosure cl(q, rp);
877         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
878       }
879     } else {
880       if (strdedup) {
881         ShenandoahMarkRefsMetadataDedupClosure cl(q, rp);
882         mark_loop_work&lt;ShenandoahMarkRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
</pre>
<hr />
<pre>
892         mark_loop_work&lt;ShenandoahMarkUpdateRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
893       } else {
894         ShenandoahMarkUpdateRefsClosure cl(q, rp);
895         mark_loop_work&lt;ShenandoahMarkUpdateRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
896       }
897     } else {
898       if (strdedup) {
899         ShenandoahMarkRefsDedupClosure cl(q, rp);
900         mark_loop_work&lt;ShenandoahMarkRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
901       } else {
902         ShenandoahMarkRefsClosure cl(q, rp);
903         mark_loop_work&lt;ShenandoahMarkRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
904       }
905     }
906   }
907 
908   _heap-&gt;flush_liveness_cache(w);
909 }
910 
911 template &lt;class T, bool CANCELLABLE&gt;
<span class="line-modified">912 void ShenandoahConcurrentMark::mark_loop_work(T* cl, jushort* live_data, uint worker_id, ShenandoahTaskTerminator *terminator) {</span>
913   uintx stride = ShenandoahMarkLoopStride;
914 
915   ShenandoahHeap* heap = ShenandoahHeap::heap();
916   ShenandoahObjToScanQueueSet* queues = task_queues();
917   ShenandoahObjToScanQueue* q;
918   ShenandoahMarkTask t;
919 
920   /*
921    * Process outstanding queues, if any.
922    *
923    * There can be more queues than workers. To deal with the imbalance, we claim
924    * extra queues first. Since marking can push new tasks into the queue associated
925    * with this worker id, we come back to process this queue in the normal loop.
926    */
927   assert(queues-&gt;get_reserved() == heap-&gt;workers()-&gt;active_workers(),
928          &quot;Need to reserve proper number of queues: reserved: %u, active: %u&quot;, queues-&gt;get_reserved(), heap-&gt;workers()-&gt;active_workers());
929 
930   q = queues-&gt;claim_next();
931   while (q != NULL) {
932     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;</span>
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
<span class="line-added"> 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="line-modified"> 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
 44 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
 45 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
<span class="line-modified"> 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;</span>
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
<span class="line-modified"> 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);</span>
 64   }
 65 
 66 public:
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
<span class="line-modified"> 86   ShenandoahAllRootScanner* _rp;</span>
 87   bool _process_refs;
 88 public:
<span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp, bool process_refs) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
 91     _rp(rp),
 92     _process_refs(process_refs) {
 93   }
 94 
 95   void work(uint worker_id) {
 96     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 97     ShenandoahParallelWorkerSession worker_session(worker_id);
 98 
 99     ShenandoahHeap* heap = ShenandoahHeap::heap();
100     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
101     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
102 
103     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
104 
<span class="line-modified">105     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);</span>
<span class="line-modified">106     do_work(heap, &amp;mark_cl, worker_id);</span>





107   }
108 
109 private:
110   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
111     // The rationale for selecting the roots to scan is as follows:
112     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
113     //      code cache. This will allow us to identify the dead classes, unload them, *and*
114     //      invalidate the relevant code cache blobs. This could be only done together with
115     //      class unloading.
116     //   b. With unload_classes = false, we have to nominally retain all the references from code
117     //      cache, because there could be the case of embedded class/oop in the generated code,
118     //      which we will never visit during mark. Without code cache invalidation, as in (a),
119     //      we risk executing that code cache blob, and crashing.









120     if (heap-&gt;unload_classes()) {
<span class="line-modified">121       _rp-&gt;strong_roots_do(worker_id, oops);</span>
122     } else {
<span class="line-modified">123       _rp-&gt;roots_do(worker_id, oops);</span>














124     }
125   }
126 };
127 
128 class ShenandoahUpdateRootsTask : public AbstractGangTask {
129 private:
<span class="line-modified">130   ShenandoahRootUpdater*  _root_updater;</span>
<span class="line-modified">131   bool                    _check_alive;</span>
132 public:
<span class="line-modified">133   ShenandoahUpdateRootsTask(ShenandoahRootUpdater* root_updater, bool check_alive) :</span>
134     AbstractGangTask(&quot;Shenandoah update roots task&quot;),
<span class="line-modified">135     _root_updater(root_updater),</span>
<span class="line-modified">136     _check_alive(check_alive){</span>
137   }
138 
139   void work(uint worker_id) {
140     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
141     ShenandoahParallelWorkerSession worker_session(worker_id);
142 
143     ShenandoahHeap* heap = ShenandoahHeap::heap();
144     ShenandoahUpdateRefsClosure cl;
<span class="line-modified">145     if (_check_alive) {</span>
<span class="line-modified">146       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">147       _root_updater-&gt;roots_do&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;is_alive, &amp;cl);</span>







148     } else {
<span class="line-modified">149       AlwaysTrueClosure always_true;;</span>
<span class="line-modified">150       _root_updater-&gt;roots_do&lt;AlwaysTrueClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;always_true, &amp;cl);</span>

151     }

152   }
153 };
154 
155 class ShenandoahConcurrentMarkingTask : public AbstractGangTask {
156 private:
157   ShenandoahConcurrentMark* _cm;
<span class="line-modified">158   TaskTerminator* _terminator;</span>
159 
160 public:
<span class="line-modified">161   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator) :</span>
162     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
163   }
164 
165   void work(uint worker_id) {
166     ShenandoahHeap* heap = ShenandoahHeap::heap();
167     ShenandoahConcurrentWorkerSession worker_session(worker_id);
168     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
169     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
170     ReferenceProcessor* rp;
171     if (heap-&gt;process_references()) {
172       rp = heap-&gt;ref_processor();
173       shenandoah_assert_rp_isalive_installed();
174     } else {
175       rp = NULL;
176     }
177 
178     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
179     _cm-&gt;mark_loop(worker_id, _terminator, rp,
180                    true, // cancellable
181                    ShenandoahStringDedup::is_enabled()); // perform string dedup
182   }
183 };
184 
185 class ShenandoahSATBThreadsClosure : public ThreadClosure {
186 private:
187   ShenandoahSATBBufferClosure* _satb_cl;
<span class="line-modified">188   uintx _claim_token;</span>
189 
190 public:
191   ShenandoahSATBThreadsClosure(ShenandoahSATBBufferClosure* satb_cl) :
192     _satb_cl(satb_cl),
<span class="line-modified">193     _claim_token(Threads::thread_claim_token()) {}</span>
194 
195   void do_thread(Thread* thread) {
<span class="line-modified">196     if (thread-&gt;claim_threads_do(true, _claim_token)) {</span>
197       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
198     }
199   }
200 };
201 
202 class ShenandoahFinalMarkingTask : public AbstractGangTask {
203 private:
204   ShenandoahConcurrentMark* _cm;
<span class="line-modified">205   TaskTerminator*           _terminator;</span>
206   bool _dedup_string;
207 
208 public:
<span class="line-modified">209   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :</span>
210     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
211   }
212 
213   void work(uint worker_id) {
214     ShenandoahHeap* heap = ShenandoahHeap::heap();
215 
216     ShenandoahParallelWorkerSession worker_session(worker_id);
217     // First drain remaining SATB buffers.
218     // Notice that this is not strictly necessary for mark-compact. But since
219     // it requires a StrongRootsScope around the task, we need to claim the
220     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
221     // full-gc.
222     {
223       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
224       ShenandoahSATBBufferClosure cl(q);
225       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
226       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
227       ShenandoahSATBThreadsClosure tc(&amp;cl);
228       Threads::threads_do(&amp;tc);
229     }
230 
231     ReferenceProcessor* rp;
232     if (heap-&gt;process_references()) {
233       rp = heap-&gt;ref_processor();
234       shenandoah_assert_rp_isalive_installed();
235     } else {
236       rp = NULL;
237     }
238 
<span class="line-modified">239     if (heap-&gt;is_degenerated_gc_in_progress()) {</span>
<span class="line-modified">240       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,</span>
<span class="line-modified">241       // let&#39;s check here.</span>
<span class="line-added">242       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);</span>
<span class="line-added">243     }</span>
<span class="line-added">244 </span>
245     _cm-&gt;mark_loop(worker_id, _terminator, rp,
246                    false, // not cancellable
247                    _dedup_string);
248 
249     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
250   }
251 };
252 
253 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
254   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
255   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
256 
257   ShenandoahHeap* heap = ShenandoahHeap::heap();
258 
259   ShenandoahGCPhase phase(root_phase);
260 
261   WorkGang* workers = heap-&gt;workers();
262   uint nworkers = workers-&gt;active_workers();
263 
264   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
265 
<span class="line-modified">266   ShenandoahAllRootScanner root_proc(nworkers, root_phase);</span>
267   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
268   task_queues()-&gt;reserve(nworkers);
269 
270   if (heap-&gt;has_forwarded_objects()) {
271     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());
272     workers-&gt;run_task(&amp;mark_roots);
273   } else {
274     // No need to update references, which means the heap is stable.
275     // Can save time not walking through forwarding pointers.
276     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());
277     workers-&gt;run_task(&amp;mark_roots);
278   }
279 
280   if (ShenandoahConcurrentScanCodeRoots) {
281     clear_claim_codecache();
282   }
283 }
284 
285 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
<span class="line-modified">287   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||</span>
<span class="line-modified">288          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,</span>
<span class="line-modified">289          &quot;Only for these phases&quot;);</span>











290 
291   ShenandoahGCPhase phase(root_phase);
292 
<span class="line-modified">293   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;</span>
<span class="line-added">294 </span>
<span class="line-added">295 #if COMPILER2_OR_JVMCI</span>
296   DerivedPointerTable::clear();
297 #endif
298 
299   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
300 
<span class="line-modified">301   ShenandoahRootUpdater root_updater(nworkers, root_phase);</span>
<span class="line-modified">302   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);</span>
303   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
304 
<span class="line-modified">305 #if COMPILER2_OR_JVMCI</span>
<span class="line-added">306   DerivedPointerTable::update_pointers();</span>
<span class="line-added">307 #endif</span>
<span class="line-added">308 }</span>
<span class="line-added">309 </span>
<span class="line-added">310 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {</span>
<span class="line-added">311 private:</span>
<span class="line-added">312   ShenandoahThreadRoots           _thread_roots;</span>
<span class="line-added">313   ShenandoahPhaseTimings::Phase   _phase;</span>
<span class="line-added">314 public:</span>
<span class="line-added">315   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :</span>
<span class="line-added">316     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),</span>
<span class="line-added">317     _thread_roots(is_par),</span>
<span class="line-added">318     _phase(phase) {</span>
<span class="line-added">319     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
<span class="line-added">320   }</span>
<span class="line-added">321 </span>
<span class="line-added">322   ~ShenandoahUpdateThreadRootsTask() {</span>
<span class="line-added">323     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>
<span class="line-added">324   }</span>
<span class="line-added">325   void work(uint worker_id) {</span>
<span class="line-added">326     ShenandoahUpdateRefsClosure cl;</span>
<span class="line-added">327     _thread_roots.oops_do(&amp;cl, NULL, worker_id);</span>
<span class="line-added">328   }</span>
<span class="line-added">329 };</span>
<span class="line-added">330 </span>
<span class="line-added">331 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {</span>
<span class="line-added">332   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">333 </span>
<span class="line-added">334   ShenandoahGCPhase phase(root_phase);</span>
<span class="line-added">335 </span>
<span class="line-added">336 #if COMPILER2_OR_JVMCI</span>
<span class="line-added">337   DerivedPointerTable::clear();</span>
<span class="line-added">338 #endif</span>
<span class="line-added">339 </span>
<span class="line-added">340   WorkGang* workers = _heap-&gt;workers();</span>
<span class="line-added">341   bool is_par = workers-&gt;active_workers() &gt; 1;</span>
<span class="line-added">342 </span>
<span class="line-added">343   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);</span>
<span class="line-added">344   workers-&gt;run_task(&amp;task);</span>
<span class="line-added">345 </span>
<span class="line-added">346 #if COMPILER2_OR_JVMCI</span>
347   DerivedPointerTable::update_pointers();
348 #endif
349 }
350 
351 void ShenandoahConcurrentMark::initialize(uint workers) {
352   _heap = ShenandoahHeap::heap();
353 
354   uint num_queues = MAX2(workers, 1U);
355 
356   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
357 
358   for (uint i = 0; i &lt; num_queues; ++i) {
359     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
360     task_queue-&gt;initialize();
361     _task_queues-&gt;register_queue(i, task_queue);
362   }
363 }
364 
365 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
366   if (ShenandoahConcurrentScanCodeRoots &amp;&amp; claim_codecache()) {
367     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
368     if (!_heap-&gt;unload_classes()) {
<span class="line-modified">369       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
370       // TODO: We can not honor StringDeduplication here, due to lock ranking
371       // inversion. So, we may miss some deduplication candidates.
372       if (_heap-&gt;has_forwarded_objects()) {
373         ShenandoahMarkResolveRefsClosure cl(q, rp);
374         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
375         CodeCache::blobs_do(&amp;blobs);
376       } else {
377         ShenandoahMarkRefsClosure cl(q, rp);
378         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
379         CodeCache::blobs_do(&amp;blobs);
380       }
381     }
382   }
383 }
384 
385 void ShenandoahConcurrentMark::mark_from_roots() {
386   WorkGang* workers = _heap-&gt;workers();
387   uint nworkers = workers-&gt;active_workers();
388 
389   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
390 
391   if (_heap-&gt;process_references()) {
392     ReferenceProcessor* rp = _heap-&gt;ref_processor();
393     rp-&gt;set_active_mt_degree(nworkers);
394 
395     // enable (&quot;weak&quot;) refs discovery
396     rp-&gt;enable_discovery(true /*verify_no_refs*/);
397     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
398   }
399 
400   shenandoah_assert_rp_isalive_not_installed();
401   ShenandoahIsAliveSelector is_alive;
402   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
403 
404   task_queues()-&gt;reserve(nworkers);
405 
406   {
407     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::conc_termination);
<span class="line-modified">408     TaskTerminator terminator(nworkers, task_queues());</span>
409     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
410     workers-&gt;run_task(&amp;task);
411   }
412 
413   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
414 }
415 
416 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
417   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
418 
419   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
420 
421   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
422   // It does two different things for concurrent vs. mark-compact GC:
423   // - For concurrent GC, it starts with empty task queues, drains the remaining
424   //   SATB buffers, and then completes the marking closure.
425   // - For mark-compact GC, it starts out with the task queues seeded by initial
426   //   root scan, and completes the closure, thus marking through all live objects
427   // The implementation is the same, so it&#39;s shared here.
428   {
429     ShenandoahGCPhase phase(full_gc ?
430                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
431                             ShenandoahPhaseTimings::finish_queues);
432     task_queues()-&gt;reserve(nworkers);
433 
434     shenandoah_assert_rp_isalive_not_installed();
435     ShenandoahIsAliveSelector is_alive;
436     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
437 
438     ShenandoahTerminationTracker termination_tracker(full_gc ?
439                                                      ShenandoahPhaseTimings::full_gc_mark_termination :
440                                                      ShenandoahPhaseTimings::termination);
441 
442     StrongRootsScope scope(nworkers);
<span class="line-modified">443     TaskTerminator terminator(nworkers, task_queues());</span>
444     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
445     _heap-&gt;workers()-&gt;run_task(&amp;task);
446   }
447 
448   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
449 
450   // When we&#39;re done marking everything, we process weak references.
451   if (_heap-&gt;process_references()) {
452     weak_refs_work(full_gc);
453   }
454 





455   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
456   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
457   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());



458 }
459 
460 // Weak Reference Closures
461 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
462   uint _worker_id;
<span class="line-modified">463   TaskTerminator* _terminator;</span>
464   bool _reset_terminator;
465 
466 public:
<span class="line-modified">467   ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
468     _worker_id(worker_id),
469     _terminator(t),
470     _reset_terminator(reset_terminator) {
471   }
472 
473   void do_void() {
474     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
475 
476     ShenandoahHeap* sh = ShenandoahHeap::heap();
477     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
478     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
479     ReferenceProcessor* rp = sh-&gt;ref_processor();
480 
481     shenandoah_assert_rp_isalive_installed();
482 
483     scm-&gt;mark_loop(_worker_id, _terminator, rp,
484                    false,   // not cancellable
485                    false);  // do not do strdedup
486 
487     if (_reset_terminator) {
</pre>
<hr />
<pre>
532   void do_oop(oop* p)       { do_oop_work(p); }
533 };
534 
535 class ShenandoahWeakUpdateClosure : public OopClosure {
536 private:
537   ShenandoahHeap* const _heap;
538 
539   template &lt;class T&gt;
540   inline void do_oop_work(T* p) {
541     oop o = _heap-&gt;maybe_update_with_forwarded(p);
542     shenandoah_assert_marked_except(p, o, o == NULL);
543   }
544 
545 public:
546   ShenandoahWeakUpdateClosure() : _heap(ShenandoahHeap::heap()) {}
547 
548   void do_oop(narrowOop* p) { do_oop_work(p); }
549   void do_oop(oop* p)       { do_oop_work(p); }
550 };
551 


















552 class ShenandoahRefProcTaskProxy : public AbstractGangTask {
553 private:
554   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">555   TaskTerminator* _terminator;</span>
556 
557 public:
558   ShenandoahRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">559                              TaskTerminator* t) :</span>
560     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
561     _proc_task(proc_task),
562     _terminator(t) {
563   }
564 
565   void work(uint worker_id) {
566     ResourceMark rm;
567     HandleMark hm;
568     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
569     ShenandoahHeap* heap = ShenandoahHeap::heap();
570     ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);
571     if (heap-&gt;has_forwarded_objects()) {
572       ShenandoahForwardedIsAliveClosure is_alive;
573       ShenandoahCMKeepAliveUpdateClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
574       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
575     } else {
576       ShenandoahIsAliveClosure is_alive;
577       ShenandoahCMKeepAliveClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
578       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
579     }
</pre>
<hr />
<pre>
583 class ShenandoahRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
584 private:
585   WorkGang* _workers;
586 
587 public:
588   ShenandoahRefProcTaskExecutor(WorkGang* workers) :
589     _workers(workers) {
590   }
591 
592   // Executes a task using worker threads.
593   void execute(ProcessTask&amp; task, uint ergo_workers) {
594     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
595 
596     ShenandoahHeap* heap = ShenandoahHeap::heap();
597     ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
598     ShenandoahPushWorkerQueuesScope scope(_workers, cm-&gt;task_queues(),
599                                           ergo_workers,
600                                           /* do_check = */ false);
601     uint nworkers = _workers-&gt;active_workers();
602     cm-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">603     TaskTerminator terminator(nworkers, cm-&gt;task_queues());</span>
604     ShenandoahRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
605     _workers-&gt;run_task(&amp;proc_task_proxy);
606   }
607 };
608 
609 void ShenandoahConcurrentMark::weak_refs_work(bool full_gc) {
610   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
611 
612   ShenandoahPhaseTimings::Phase phase_root =
613           full_gc ?
614           ShenandoahPhaseTimings::full_gc_weakrefs :
615           ShenandoahPhaseTimings::weakrefs;
616 
617   ShenandoahGCPhase phase(phase_root);
618 
619   ReferenceProcessor* rp = _heap-&gt;ref_processor();
620 
621   // NOTE: We cannot shortcut on has_discovered_references() here, because
622   // we will miss marking JNI Weak refs then, see implementation in
623   // ReferenceProcessor::process_discovered_references.
</pre>
<hr />
<pre>
641           ShenandoahPhaseTimings::full_gc_weakrefs_termination :
642           ShenandoahPhaseTimings::weakrefs_termination;
643 
644   shenandoah_assert_rp_isalive_not_installed();
645   ShenandoahIsAliveSelector is_alive;
646   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
647 
648   WorkGang* workers = _heap-&gt;workers();
649   uint nworkers = workers-&gt;active_workers();
650 
651   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
652   rp-&gt;set_active_mt_degree(nworkers);
653 
654   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
655 
656   // complete_gc and keep_alive closures instantiated here are only needed for
657   // single-threaded path in RP. They share the queue 0 for tracking work, which
658   // simplifies implementation. Since RP may decide to call complete_gc several
659   // times, we need to be able to reuse the terminator.
660   uint serial_worker_id = 0;
<span class="line-modified">661   TaskTerminator terminator(1, task_queues());</span>
662   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
663 
664   ShenandoahRefProcTaskExecutor executor(workers);
665 
666   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
667 
668   {
669     ShenandoahGCPhase phase(phase_process);
670     ShenandoahTerminationTracker phase_term(phase_process_termination);
671 




672     if (_heap-&gt;has_forwarded_objects()) {
673       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
674       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
675                                         &amp;complete_gc, &amp;executor,
676                                         &amp;pt);
677 


678     } else {
679       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
680       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
681                                         &amp;complete_gc, &amp;executor,
682                                         &amp;pt);
683 


684     }
685 
686     pt.print_all_references();
687 
688     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
689   }
690 }
691 
692 class ShenandoahCancelledGCYieldClosure : public YieldClosure {
693 private:
694   ShenandoahHeap* const _heap;
695 public:
696   ShenandoahCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
697   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
698 };
699 
700 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
701 public:
702   void do_void() {
703     ShenandoahHeap* sh = ShenandoahHeap::heap();
704     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
705     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified">706     TaskTerminator terminator(1, scm-&gt;task_queues());</span>
707 
708     ReferenceProcessor* rp = sh-&gt;ref_processor();
709     shenandoah_assert_rp_isalive_installed();
710 
711     scm-&gt;mark_loop(0, &amp;terminator, rp,
712                    false, // not cancellable
713                    false); // do not do strdedup
714   }
715 };
716 
717 class ShenandoahPrecleanKeepAliveUpdateClosure : public OopClosure {
718 private:
719   ShenandoahObjToScanQueue* _queue;
720   ShenandoahHeap* _heap;
721   ShenandoahMarkingContext* const _mark_context;
722 
723   template &lt;class T&gt;
724   inline void do_oop_work(T* p) {
725     ShenandoahConcurrentMark::mark_through_ref&lt;T, CONCURRENT, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
726   }
</pre>
<hr />
<pre>
809   workers-&gt;run_task(&amp;task);
810 
811   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
812 }
813 
814 void ShenandoahConcurrentMark::cancel() {
815   // Clean up marking stacks.
816   ShenandoahObjToScanQueueSet* queues = task_queues();
817   queues-&gt;clear();
818 
819   // Cancel SATB buffers.
820   ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();
821 }
822 
823 ShenandoahObjToScanQueue* ShenandoahConcurrentMark::get_queue(uint worker_id) {
824   assert(task_queues()-&gt;get_reserved() &gt; worker_id, &quot;No reserved queue for worker id: %d&quot;, worker_id);
825   return _task_queues-&gt;queue(worker_id);
826 }
827 
828 template &lt;bool CANCELLABLE&gt;
<span class="line-modified">829 void ShenandoahConcurrentMark::mark_loop_prework(uint w, TaskTerminator *t, ReferenceProcessor *rp,</span>
830                                                  bool strdedup) {
831   ShenandoahObjToScanQueue* q = get_queue(w);
832 
833   jushort* ld = _heap-&gt;get_liveness_cache(w);
834 
835   // TODO: We can clean up this if we figure out how to do templated oop closures that
836   // play nice with specialized_oop_iterators.
837   if (_heap-&gt;unload_classes()) {
838     if (_heap-&gt;has_forwarded_objects()) {
839       if (strdedup) {
840         ShenandoahMarkUpdateRefsMetadataDedupClosure cl(q, rp);
841         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
842       } else {
843         ShenandoahMarkUpdateRefsMetadataClosure cl(q, rp);
844         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
845       }
846     } else {
847       if (strdedup) {
848         ShenandoahMarkRefsMetadataDedupClosure cl(q, rp);
849         mark_loop_work&lt;ShenandoahMarkRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
</pre>
<hr />
<pre>
859         mark_loop_work&lt;ShenandoahMarkUpdateRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
860       } else {
861         ShenandoahMarkUpdateRefsClosure cl(q, rp);
862         mark_loop_work&lt;ShenandoahMarkUpdateRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
863       }
864     } else {
865       if (strdedup) {
866         ShenandoahMarkRefsDedupClosure cl(q, rp);
867         mark_loop_work&lt;ShenandoahMarkRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
868       } else {
869         ShenandoahMarkRefsClosure cl(q, rp);
870         mark_loop_work&lt;ShenandoahMarkRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
871       }
872     }
873   }
874 
875   _heap-&gt;flush_liveness_cache(w);
876 }
877 
878 template &lt;class T, bool CANCELLABLE&gt;
<span class="line-modified">879 void ShenandoahConcurrentMark::mark_loop_work(T* cl, jushort* live_data, uint worker_id, TaskTerminator *terminator) {</span>
880   uintx stride = ShenandoahMarkLoopStride;
881 
882   ShenandoahHeap* heap = ShenandoahHeap::heap();
883   ShenandoahObjToScanQueueSet* queues = task_queues();
884   ShenandoahObjToScanQueue* q;
885   ShenandoahMarkTask t;
886 
887   /*
888    * Process outstanding queues, if any.
889    *
890    * There can be more queues than workers. To deal with the imbalance, we claim
891    * extra queues first. Since marking can push new tasks into the queue associated
892    * with this worker id, we come back to process this queue in the normal loop.
893    */
894   assert(queues-&gt;get_reserved() == heap-&gt;workers()-&gt;active_workers(),
895          &quot;Need to reserve proper number of queues: reserved: %u, active: %u&quot;, queues-&gt;get_reserved(), heap-&gt;workers()-&gt;active_workers());
896 
897   q = queues-&gt;claim_next();
898   while (q != NULL) {
899     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahCollectorPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahConcurrentMark.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
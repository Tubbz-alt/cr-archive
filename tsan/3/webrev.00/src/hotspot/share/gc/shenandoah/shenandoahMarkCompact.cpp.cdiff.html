<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeuristics.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,34 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  
  void ShenandoahMarkCompact::initialize(GCTimer* gc_timer) {
    _gc_timer = gc_timer;
  }
  
  void ShenandoahMarkCompact::do_it(GCCause::Cause gc_cause) {
<span class="line-new-header">--- 24,44 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/preservedMarks.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  #include &quot;memory/metaspace.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/biasedLocking.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  
<span class="line-added">+ ShenandoahMarkCompact::ShenandoahMarkCompact() :</span>
<span class="line-added">+   _gc_timer(NULL),</span>
<span class="line-added">+   _preserved_marks(new PreservedMarksSet(true)) {}</span>
<span class="line-added">+ </span>
  void ShenandoahMarkCompact::initialize(GCTimer* gc_timer) {
    _gc_timer = gc_timer;
  }
  
  void ShenandoahMarkCompact::do_it(GCCause::Cause gc_cause) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,10 ***</span>
<span class="line-new-header">--- 73,16 ---</span>
  
    if (VerifyBeforeGC) {
      Universe::verify();
    }
  
<span class="line-added">+   // Degenerated GC may carry concurrent_root_in_progress flag when upgrading to</span>
<span class="line-added">+   // full GC. We need to reset it before mutators resume.</span>
<span class="line-added">+   if (ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {</span>
<span class="line-added">+     heap-&gt;set_concurrent_root_in_progress(false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    heap-&gt;set_full_gc_in_progress(true);
  
    assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at a safepoint&quot;);
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Do full GC only while world is stopped&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
      }
  
      // b. Cancel concurrent mark, if in progress
      if (heap-&gt;is_concurrent_mark_in_progress()) {
        heap-&gt;concurrent_mark()-&gt;cancel();
<span class="line-modified">!       heap-&gt;stop_concurrent_marking();</span>
      }
      assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
  
      // c. Reset the bitmaps for new marking
      heap-&gt;reset_mark_bitmap();
<span class="line-new-header">--- 117,11 ---</span>
      }
  
      // b. Cancel concurrent mark, if in progress
      if (heap-&gt;is_concurrent_mark_in_progress()) {
        heap-&gt;concurrent_mark()-&gt;cancel();
<span class="line-modified">!       heap-&gt;set_concurrent_mark_in_progress(false);</span>
      }
      assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
  
      // c. Reset the bitmaps for new marking
      heap-&gt;reset_mark_bitmap();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,21 ***</span>
      rp-&gt;abandon_partial_discovery();
      rp-&gt;verify_no_references_recorded();
  
      // e. Set back forwarded objects bit back, in case some steps above dropped it.
      heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
    }
  
    heap-&gt;make_parsable(true);
  
    OrderAccess::fence();
  
    phase1_mark_heap();
  
    // Once marking is done, which may have fixed up forwarded objects, we can drop it.
    // Coming out of Full GC, we would not have any forwarded objects.
<span class="line-modified">!   // This also prevents read barrier from kicking in while adjusting pointers in phase3.</span>
    heap-&gt;set_has_forwarded_objects(false);
  
    heap-&gt;set_full_gc_move_in_progress(true);
  
    // Setup workers for the rest
<span class="line-new-header">--- 134,28 ---</span>
      rp-&gt;abandon_partial_discovery();
      rp-&gt;verify_no_references_recorded();
  
      // e. Set back forwarded objects bit back, in case some steps above dropped it.
      heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
<span class="line-added">+ </span>
<span class="line-added">+     // f. Sync pinned region status from the CP marks</span>
<span class="line-added">+     heap-&gt;sync_pinned_region_status();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The rest of prologue:</span>
<span class="line-added">+     BiasedLocking::preserve_marks();</span>
<span class="line-added">+     _preserved_marks-&gt;init(heap-&gt;workers()-&gt;active_workers());</span>
    }
  
    heap-&gt;make_parsable(true);
  
    OrderAccess::fence();
  
    phase1_mark_heap();
  
    // Once marking is done, which may have fixed up forwarded objects, we can drop it.
    // Coming out of Full GC, we would not have any forwarded objects.
<span class="line-modified">!   // This also prevents resolves with fwdptr from kicking in while adjusting pointers in phase3.</span>
    heap-&gt;set_has_forwarded_objects(false);
  
    heap-&gt;set_full_gc_move_in_progress(true);
  
    // Setup workers for the rest
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,21 ***</span>
      phase3_update_references();
  
      phase4_compact_objects(worker_slices);
    }
  
    // Resize metaspace
    MetaspaceGC::compute_new_size();
  
    // Free worker slices
    for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
      delete worker_slices[i];
    }
    FREE_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, worker_slices);
  
<span class="line-removed">-   JvmtiExport::gc_epilogue();</span>
<span class="line-removed">- </span>
    heap-&gt;set_full_gc_move_in_progress(false);
    heap-&gt;set_full_gc_in_progress(false);
  
    if (ShenandoahVerify) {
      heap-&gt;verifier()-&gt;verify_after_fullgc();
<span class="line-new-header">--- 179,26 ---</span>
      phase3_update_references();
  
      phase4_compact_objects(worker_slices);
    }
  
<span class="line-added">+   {</span>
<span class="line-added">+     // Epilogue</span>
<span class="line-added">+     _preserved_marks-&gt;restore(heap-&gt;workers());</span>
<span class="line-added">+     BiasedLocking::restore_marks();</span>
<span class="line-added">+     _preserved_marks-&gt;reclaim();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Resize metaspace
    MetaspaceGC::compute_new_size();
  
    // Free worker slices
    for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
      delete worker_slices[i];
    }
    FREE_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, worker_slices);
  
    heap-&gt;set_full_gc_move_in_progress(false);
    heap-&gt;set_full_gc_in_progress(false);
  
    if (ShenandoahVerify) {
      heap-&gt;verifier()-&gt;verify_after_fullgc();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,25 ***</span>
    rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
  
    cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_roots);
    cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_roots);
    cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
<span class="line-removed">- </span>
    heap-&gt;mark_complete_marking_context();
  }
  
  class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
  private:
    ShenandoahHeap*          const _heap;
    GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
    int _empty_regions_pos;
    ShenandoahHeapRegion*          _to_region;
    ShenandoahHeapRegion*          _from_region;
    HeapWord* _compact_point;
  
  public:
<span class="line-modified">!   ShenandoahPrepareForCompactionObjectClosure(GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions, ShenandoahHeapRegion* to_region) :</span>
      _heap(ShenandoahHeap::heap()),
      _empty_regions(empty_regions),
      _empty_regions_pos(0),
      _to_region(to_region),
      _from_region(NULL),
<span class="line-new-header">--- 249,29 ---</span>
    rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
  
    cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_roots);
    cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_roots);
    cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
    heap-&gt;mark_complete_marking_context();
<span class="line-added">+   heap-&gt;parallel_cleaning(true /* full_gc */);</span>
  }
  
  class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
  private:
<span class="line-added">+   PreservedMarks*          const _preserved_marks;</span>
    ShenandoahHeap*          const _heap;
    GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
    int _empty_regions_pos;
    ShenandoahHeapRegion*          _to_region;
    ShenandoahHeapRegion*          _from_region;
    HeapWord* _compact_point;
  
  public:
<span class="line-modified">!   ShenandoahPrepareForCompactionObjectClosure(PreservedMarks* preserved_marks,</span>
<span class="line-added">+                                               GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions,</span>
<span class="line-added">+                                               ShenandoahHeapRegion* to_region) :</span>
<span class="line-added">+     _preserved_marks(preserved_marks),</span>
      _heap(ShenandoahHeap::heap()),
      _empty_regions(empty_regions),
      _empty_regions_pos(0),
      _to_region(to_region),
      _from_region(NULL),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,13 ***</span>
    }
  
    void do_object(oop p) {
      assert(_from_region != NULL, &quot;must set before work&quot;);
      assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-modified">!     assert(!_heap-&gt;complete_marking_context()-&gt;allocated_after_mark_start((HeapWord*) p), &quot;must be truly marked&quot;);</span>
  
<span class="line-modified">!     size_t obj_size = p-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
      if (_compact_point + obj_size &gt; _to_region-&gt;end()) {
        finish_region();
  
        // Object doesn&#39;t fit. Pick next empty region and start compacting there.
        ShenandoahHeapRegion* new_to_region;
<span class="line-new-header">--- 295,13 ---</span>
    }
  
    void do_object(oop p) {
      assert(_from_region != NULL, &quot;must set before work&quot;);
      assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-modified">!     assert(!_heap-&gt;complete_marking_context()-&gt;allocated_after_mark_start(p), &quot;must be truly marked&quot;);</span>
  
<span class="line-modified">!     size_t obj_size = p-&gt;size();</span>
      if (_compact_point + obj_size &gt; _to_region-&gt;end()) {
        finish_region();
  
        // Object doesn&#39;t fit. Pick next empty region and start compacting there.
        ShenandoahHeapRegion* new_to_region;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,41 ***</span>
      }
  
      // Object fits into current region, record new location:
      assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
      shenandoah_assert_not_forwarded(NULL, p);
<span class="line-modified">!     ShenandoahBrooksPointer::set_raw(p, _compact_point + ShenandoahBrooksPointer::word_size());</span>
      _compact_point += obj_size;
    }
  };
  
  class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
  private:
    ShenandoahHeap*           const _heap;
    ShenandoahHeapRegionSet** const _worker_slices;
    ShenandoahRegionIterator        _heap_regions;
  
    ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {
      ShenandoahHeapRegion* from_region = _heap_regions.next();
  
<span class="line-modified">!     while (from_region != NULL &amp;&amp; (!from_region-&gt;is_move_allowed() || from_region-&gt;is_humongous())) {</span>
        from_region = _heap_regions.next();
      }
  
      if (from_region != NULL) {
        assert(slice != NULL, &quot;sanity&quot;);
        assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);
<span class="line-modified">!       assert(from_region-&gt;is_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
        slice-&gt;add_region(from_region);
      }
  
      return from_region;
    }
  
  public:
<span class="line-modified">!   ShenandoahPrepareForCompactionTask(ShenandoahHeapRegionSet** worker_slices) :</span>
      AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
      _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
    }
  
    void work(uint worker_id) {
      ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
<span class="line-new-header">--- 320,55 ---</span>
      }
  
      // Object fits into current region, record new location:
      assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
      shenandoah_assert_not_forwarded(NULL, p);
<span class="line-modified">!     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());</span>
<span class="line-added">+     p-&gt;forward_to(oop(_compact_point));</span>
      _compact_point += obj_size;
    }
  };
  
  class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
  private:
<span class="line-added">+   PreservedMarksSet*        const _preserved_marks;</span>
    ShenandoahHeap*           const _heap;
    ShenandoahHeapRegionSet** const _worker_slices;
    ShenandoahRegionIterator        _heap_regions;
  
    ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {
      ShenandoahHeapRegion* from_region = _heap_regions.next();
  
<span class="line-modified">!     // Look for next candidate for this slice:</span>
<span class="line-added">+     while (from_region != NULL) {</span>
<span class="line-added">+       // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-added">+       // We could have skipped this without violating correctness, but we really</span>
<span class="line-added">+       // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-added">+       // means moving them into the fully empty regions.</span>
<span class="line-added">+       if (from_region-&gt;is_empty()) break;</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-added">+       // moves are special cased here, because their moves are handled separately.</span>
<span class="line-added">+       if (from_region-&gt;is_stw_move_allowed() &amp;&amp; !from_region-&gt;is_humongous()) break;</span>
<span class="line-added">+ </span>
        from_region = _heap_regions.next();
      }
  
      if (from_region != NULL) {
        assert(slice != NULL, &quot;sanity&quot;);
        assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);
<span class="line-modified">!       assert(from_region-&gt;is_empty() || from_region-&gt;is_stw_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
        slice-&gt;add_region(from_region);
      }
  
      return from_region;
    }
  
  public:
<span class="line-modified">!   ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet** worker_slices) :</span>
      AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
<span class="line-added">+     _preserved_marks(preserved_marks),</span>
      _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
    }
  
    void work(uint worker_id) {
      ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,11 ***</span>
  
      // Sliding compaction. Walk all regions in the slice, and compact them.
      // Remember empty regions and reuse them as needed.
      ResourceMark rm;
      GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-modified">!     ShenandoahPrepareForCompactionObjectClosure cl(empty_regions, from_region);</span>
      while (from_region != NULL) {
        cl.set_from_region(from_region);
        if (from_region-&gt;has_live()) {
          _heap-&gt;marked_object_iterate(from_region, &amp;cl);
        }
<span class="line-new-header">--- 380,11 ---</span>
  
      // Sliding compaction. Walk all regions in the slice, and compact them.
      // Remember empty regions and reuse them as needed.
      ResourceMark rm;
      GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-modified">!     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);</span>
      while (from_region != NULL) {
        cl.set_from_region(from_region);
        if (from_region-&gt;has_live()) {
          _heap-&gt;marked_object_iterate(from_region, &amp;cl);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,29 ***</span>
    // detected, then sliding restarts towards that non-movable region.
  
    size_t to_begin = heap-&gt;num_regions();
    size_t to_end = heap-&gt;num_regions();
  
<span class="line-modified">!   for (size_t c = heap-&gt;num_regions() - 1; c &gt; 0; c--) {</span>
<span class="line-modified">!     ShenandoahHeapRegion *r = heap-&gt;get_region(c);</span>
      if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
        // To-region candidate: record this, and continue scan
        to_begin = r-&gt;region_number();
        continue;
      }
  
<span class="line-modified">!     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_move_allowed()) {</span>
        // From-region candidate: movable humongous region
<span class="line-modified">!       oop old_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">!       size_t words_size = old_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
        size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
  
        size_t start = to_end - num_regions;
  
        if (start &gt;= to_begin &amp;&amp; start != r-&gt;region_number()) {
          // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
<span class="line-modified">!         ShenandoahBrooksPointer::set_raw(old_obj, heap-&gt;get_region(start)-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
          to_end = start;
          continue;
        }
      }
  
<span class="line-new-header">--- 420,30 ---</span>
    // detected, then sliding restarts towards that non-movable region.
  
    size_t to_begin = heap-&gt;num_regions();
    size_t to_end = heap-&gt;num_regions();
  
<span class="line-modified">!   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {</span>
<span class="line-modified">!     ShenandoahHeapRegion *r = heap-&gt;get_region(c - 1);</span>
      if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
        // To-region candidate: record this, and continue scan
        to_begin = r-&gt;region_number();
        continue;
      }
  
<span class="line-modified">!     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_stw_move_allowed()) {</span>
        // From-region candidate: movable humongous region
<span class="line-modified">!       oop old_obj = oop(r-&gt;bottom());</span>
<span class="line-modified">!       size_t words_size = old_obj-&gt;size();</span>
        size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
  
        size_t start = to_end - num_regions;
  
        if (start &gt;= to_begin &amp;&amp; start != r-&gt;region_number()) {
          // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
<span class="line-modified">!         _preserved_marks-&gt;get(0)-&gt;push_if_necessary(old_obj, old_obj-&gt;mark_raw());</span>
<span class="line-added">+         old_obj-&gt;forward_to(oop(heap-&gt;get_region(start)-&gt;bottom()));</span>
          to_end = start;
          continue;
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 439,11 ***</span>
      _heap(ShenandoahHeap::heap()),
      _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
  
    void heap_region_do(ShenandoahHeapRegion* r) {
      if (r-&gt;is_humongous_start()) {
<span class="line-modified">!       oop humongous_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
        if (!_ctx-&gt;is_marked(humongous_obj)) {
          assert(!r-&gt;has_live(),
                 &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
          _heap-&gt;trash_humongous_region_at(r);
        } else {
<span class="line-new-header">--- 487,11 ---</span>
      _heap(ShenandoahHeap::heap()),
      _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
  
    void heap_region_do(ShenandoahHeapRegion* r) {
      if (r-&gt;is_humongous_start()) {
<span class="line-modified">!       oop humongous_obj = oop(r-&gt;bottom());</span>
        if (!_ctx-&gt;is_marked(humongous_obj)) {
          assert(!r-&gt;has_live(),
                 &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());
          _heap-&gt;trash_humongous_region_at(r);
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,10 ***</span>
<span class="line-new-header">--- 514,14 ---</span>
    GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
    ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
  
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-added">+   // About to figure out which regions can be compacted, make sure pinning status</span>
<span class="line-added">+   // had been updated in GC prologue.</span>
<span class="line-added">+   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">+ </span>
    {
      // Trash the immediately collectible regions before computing addresses
      ShenandoahTrashImmediateGarbageClosure tigcl;
      heap-&gt;heap_region_iterate(&amp;tigcl);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,11 ***</span>
    }
  
    // Compute the new addresses for regular objects
    {
      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified">!     ShenandoahPrepareForCompactionTask prepare_task(worker_slices);</span>
      heap-&gt;workers()-&gt;run_task(&amp;prepare_task);
    }
  
    // Compute the new addresses for humongous objects
    {
<span class="line-new-header">--- 532,11 ---</span>
    }
  
    // Compute the new addresses for regular objects
    {
      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified">!     ShenandoahPrepareForCompactionTask prepare_task(_preserved_marks, worker_slices);</span>
      heap-&gt;workers()-&gt;run_task(&amp;prepare_task);
    }
  
    // Compute the new addresses for humongous objects
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 502,12 ***</span>
    inline void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
        assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
<span class="line-modified">!       oop forw = oop(ShenandoahBrooksPointer::get_raw(obj));</span>
<span class="line-modified">!       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);</span>
      }
    }
  
  public:
    ShenandoahAdjustPointersClosure() :
<span class="line-new-header">--- 554,14 ---</span>
    inline void do_oop_work(T* p) {
      T o = RawAccess&lt;&gt;::oop_load(p);
      if (!CompressedOops::is_null(o)) {
        oop obj = CompressedOops::decode_not_null(o);
        assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
<span class="line-modified">!       if (obj-&gt;is_forwarded()) {</span>
<span class="line-modified">!         oop forw = obj-&gt;forwardee();</span>
<span class="line-added">+         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);</span>
<span class="line-added">+       }</span>
      }
    }
  
  public:
    ShenandoahAdjustPointersClosure() :
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,11 ***</span>
    ShenandoahAdjustPointersObjectClosure() :
      _heap(ShenandoahHeap::heap()) {
    }
    void do_object(oop p) {
      assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
<span class="line-removed">-     HeapWord* forw = ShenandoahBrooksPointer::get_raw(p);</span>
      p-&gt;oop_iterate(&amp;_cl);
    }
  };
  
  class ShenandoahAdjustPointersTask : public AbstractGangTask {
<span class="line-new-header">--- 581,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,26 ***</span>
    }
  };
  
  class ShenandoahAdjustRootPointersTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootProcessor* _rp;</span>
<span class="line-modified">! </span>
  public:
<span class="line-modified">!   ShenandoahAdjustRootPointersTask(ShenandoahRootProcessor* rp) :</span>
      AbstractGangTask(&quot;Shenandoah Adjust Root Pointers Task&quot;),
<span class="line-modified">!     _rp(rp) {}</span>
  
    void work(uint worker_id) {
      ShenandoahAdjustPointersClosure cl;
<span class="line-modified">!     CLDToOopClosure adjust_cld_closure(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-modified">!     MarkingCodeBlobClosure adjust_code_closure(&amp;cl,</span>
<span class="line-removed">-                                              CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     _rp-&gt;process_all_roots(&amp;cl, &amp;cl,</span>
<span class="line-removed">-                            &amp;adjust_cld_closure,</span>
<span class="line-removed">-                            &amp;adjust_code_closure, NULL, worker_id);</span>
    }
  };
  
  void ShenandoahMarkCompact::phase3_update_references() {
    GCTraceTime(Info, gc, phases) time(&quot;Phase 3: Adjust pointers&quot;, _gc_timer);
<span class="line-new-header">--- 610,22 ---</span>
    }
  };
  
  class ShenandoahAdjustRootPointersTask : public AbstractGangTask {
  private:
<span class="line-modified">!   ShenandoahRootAdjuster* _rp;</span>
<span class="line-modified">!   PreservedMarksSet* _preserved_marks;</span>
  public:
<span class="line-modified">!   ShenandoahAdjustRootPointersTask(ShenandoahRootAdjuster* rp, PreservedMarksSet* preserved_marks) :</span>
      AbstractGangTask(&quot;Shenandoah Adjust Root Pointers Task&quot;),
<span class="line-modified">!     _rp(rp),</span>
<span class="line-added">+     _preserved_marks(preserved_marks) {}</span>
  
    void work(uint worker_id) {
      ShenandoahAdjustPointersClosure cl;
<span class="line-modified">!     _rp-&gt;roots_do(worker_id, &amp;cl);</span>
<span class="line-modified">!     _preserved_marks-&gt;get(worker_id)-&gt;adjust_during_full_gc();</span>
    }
  };
  
  void ShenandoahMarkCompact::phase3_update_references() {
    GCTraceTime(Info, gc, phases) time(&quot;Phase 3: Adjust pointers&quot;, _gc_timer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,12 ***</span>
    uint nworkers = workers-&gt;active_workers();
    {
  #if COMPILER2_OR_JVMCI
      DerivedPointerTable::clear();
  #endif
<span class="line-modified">!     ShenandoahRootProcessor rp(heap, nworkers, ShenandoahPhaseTimings::full_gc_roots);</span>
<span class="line-modified">!     ShenandoahAdjustRootPointersTask task(&amp;rp);</span>
      workers-&gt;run_task(&amp;task);
  #if COMPILER2_OR_JVMCI
      DerivedPointerTable::update_pointers();
  #endif
    }
<span class="line-new-header">--- 637,12 ---</span>
    uint nworkers = workers-&gt;active_workers();
    {
  #if COMPILER2_OR_JVMCI
      DerivedPointerTable::clear();
  #endif
<span class="line-modified">!     ShenandoahRootAdjuster rp(nworkers, ShenandoahPhaseTimings::full_gc_roots);</span>
<span class="line-modified">!     ShenandoahAdjustRootPointersTask task(&amp;rp, _preserved_marks);</span>
      workers-&gt;run_task(&amp;task);
  #if COMPILER2_OR_JVMCI
      DerivedPointerTable::update_pointers();
  #endif
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,17 ***</span>
      _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}
  
    void do_object(oop p) {
      assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
      size_t size = (size_t)p-&gt;size();
<span class="line-modified">!     HeapWord* compact_to = ShenandoahBrooksPointer::get_raw(p);</span>
<span class="line-modified">!     HeapWord* compact_from = (HeapWord*) p;</span>
<span class="line-modified">!     if (compact_from != compact_to) {</span>
        Copy::aligned_conjoint_words(compact_from, compact_to, size);
      }
<span class="line-removed">-     oop new_obj = oop(compact_to);</span>
<span class="line-removed">-     ShenandoahBrooksPointer::initialize(new_obj);</span>
    }
  };
  
  class ShenandoahCompactObjectsTask : public AbstractGangTask {
  private:
<span class="line-new-header">--- 661,17 ---</span>
      _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}
  
    void do_object(oop p) {
      assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
      size_t size = (size_t)p-&gt;size();
<span class="line-modified">!     if (p-&gt;is_forwarded()) {</span>
<span class="line-modified">!       HeapWord* compact_from = cast_from_oop&lt;HeapWord*&gt;(p);</span>
<span class="line-modified">!       HeapWord* compact_to = cast_from_oop&lt;HeapWord*&gt;(p-&gt;forwardee());</span>
        Copy::aligned_conjoint_words(compact_from, compact_to, size);
<span class="line-added">+       oop new_obj = oop(compact_to);</span>
<span class="line-added">+       new_obj-&gt;init_mark_raw();</span>
      }
    }
  };
  
  class ShenandoahCompactObjectsTask : public AbstractGangTask {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 709,35 ***</span>
    // humongous regions are already compacted, and do not require further moves, which alleviates
    // sliding costs. We may consider doing this in parallel in future.
  
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-modified">!   for (size_t c = heap-&gt;num_regions() - 1; c &gt; 0; c--) {</span>
<span class="line-modified">!     ShenandoahHeapRegion* r = heap-&gt;get_region(c);</span>
      if (r-&gt;is_humongous_start()) {
<span class="line-modified">!       oop old_obj = oop(r-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">!       size_t words_size = old_obj-&gt;size() + ShenandoahBrooksPointer::word_size();</span>
        size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
  
        size_t old_start = r-&gt;region_number();
        size_t old_end   = old_start + num_regions - 1;
<span class="line-modified">!       size_t new_start = heap-&gt;heap_region_index_containing(ShenandoahBrooksPointer::get_raw(old_obj));</span>
        size_t new_end   = new_start + num_regions - 1;
<span class="line-modified">! </span>
<span class="line-modified">!       if (old_start == new_start) {</span>
<span class="line-removed">-         // No need to move the object, it stays at the same slot</span>
<span class="line-removed">-         continue;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       assert (r-&gt;is_move_allowed(), &quot;should be movable&quot;);</span>
  
        Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
                                     heap-&gt;get_region(new_start)-&gt;bottom(),
                                     ShenandoahHeapRegion::region_size_words()*num_regions);
  
<span class="line-modified">!       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom() + ShenandoahBrooksPointer::word_size());</span>
<span class="line-modified">!       ShenandoahBrooksPointer::initialize(new_obj);</span>
  
        {
          for (size_t c = old_start; c &lt;= old_end; c++) {
            ShenandoahHeapRegion* r = heap-&gt;get_region(c);
            r-&gt;make_regular_bypass();
<span class="line-new-header">--- 758,34 ---</span>
    // humongous regions are already compacted, and do not require further moves, which alleviates
    // sliding costs. We may consider doing this in parallel in future.
  
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-modified">!   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {</span>
<span class="line-modified">!     ShenandoahHeapRegion* r = heap-&gt;get_region(c - 1);</span>
      if (r-&gt;is_humongous_start()) {
<span class="line-modified">!       oop old_obj = oop(r-&gt;bottom());</span>
<span class="line-modified">!       if (!old_obj-&gt;is_forwarded()) {</span>
<span class="line-added">+         // No need to move the object, it stays at the same slot</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       size_t words_size = old_obj-&gt;size();</span>
        size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
  
        size_t old_start = r-&gt;region_number();
        size_t old_end   = old_start + num_regions - 1;
<span class="line-modified">!       size_t new_start = heap-&gt;heap_region_index_containing(old_obj-&gt;forwardee());</span>
        size_t new_end   = new_start + num_regions - 1;
<span class="line-modified">!       assert(old_start != new_start, &quot;must be real move&quot;);</span>
<span class="line-modified">!       assert(r-&gt;is_stw_move_allowed(), &quot;Region &quot; SIZE_FORMAT &quot; should be movable&quot;, r-&gt;region_number());</span>
  
        Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
                                     heap-&gt;get_region(new_start)-&gt;bottom(),
                                     ShenandoahHeapRegion::region_size_words()*num_regions);
  
<span class="line-modified">!       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom());</span>
<span class="line-modified">!       new_obj-&gt;init_mark_raw();</span>
  
        {
          for (size_t c = old_start; c &lt;= old_end; c++) {
            ShenandoahHeapRegion* r = heap-&gt;get_region(c);
            r-&gt;make_regular_bypass();
</pre>
<center><a href="shenandoahHeuristics.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
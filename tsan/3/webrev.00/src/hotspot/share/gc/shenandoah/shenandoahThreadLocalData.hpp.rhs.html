<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahThreadLocalData.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 27 
 28 #include &quot;gc/shared/plab.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 30 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;</span>
 31 #include &quot;gc/shenandoah/shenandoahSATBMarkQueueSet.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/sizes.hpp&quot;
 35 
 36 class ShenandoahThreadLocalData {
 37 public:
 38   static const uint INVALID_WORKER_ID = uint(-1);
 39 
 40 private:
 41   char _gc_state;
 42   char _oom_during_evac;
 43   ShenandoahSATBMarkQueue _satb_mark_queue;
 44   PLAB* _gclab;
 45   size_t _gclab_size;
 46   uint  _worker_id;
 47   bool _force_satb_flush;
<a name="3" id="anc3"></a><span class="line-added"> 48   int  _disarmed_value;</span>
 49 
 50   ShenandoahThreadLocalData() :
 51     _gc_state(0),
 52     _oom_during_evac(0),
 53     _satb_mark_queue(&amp;ShenandoahBarrierSet::satb_mark_queue_set()),
 54     _gclab(NULL),
 55     _gclab_size(0),
 56     _worker_id(INVALID_WORKER_ID),
 57     _force_satb_flush(false) {
 58   }
 59 
 60   ~ShenandoahThreadLocalData() {
 61     if (_gclab != NULL) {
 62       delete _gclab;
 63     }
 64   }
 65 
 66   static ShenandoahThreadLocalData* data(Thread* thread) {
 67     assert(UseShenandoahGC, &quot;Sanity&quot;);
 68     return thread-&gt;gc_data&lt;ShenandoahThreadLocalData&gt;();
 69   }
 70 
 71   static ByteSize satb_mark_queue_offset() {
 72     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _satb_mark_queue);
 73   }
 74 
 75 public:
 76   static void create(Thread* thread) {
 77     new (data(thread)) ShenandoahThreadLocalData();
 78   }
 79 
 80   static void destroy(Thread* thread) {
 81     data(thread)-&gt;~ShenandoahThreadLocalData();
 82   }
 83 
 84   static SATBMarkQueue&amp; satb_mark_queue(Thread* thread) {
 85     return data(thread)-&gt;_satb_mark_queue;
 86   }
 87 
 88   static bool is_oom_during_evac(Thread* thread) {
 89     return (data(thread)-&gt;_oom_during_evac &amp; 1) == 1;
 90   }
 91 
 92   static void set_oom_during_evac(Thread* thread, bool oom) {
 93     if (oom) {
 94       data(thread)-&gt;_oom_during_evac |= 1;
 95     } else {
 96       data(thread)-&gt;_oom_during_evac &amp;= ~1;
 97     }
 98   }
 99 
100   static void set_gc_state(Thread* thread, char gc_state) {
101     data(thread)-&gt;_gc_state = gc_state;
102   }
103 
104   static char gc_state(Thread* thread) {
105     return data(thread)-&gt;_gc_state;
106   }
107 
108   static void set_worker_id(Thread* thread, uint id) {
109     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
110     data(thread)-&gt;_worker_id = id;
111   }
112 
113   static uint worker_id(Thread* thread) {
114     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
115     return data(thread)-&gt;_worker_id;
116   }
117 
118   static void set_force_satb_flush(Thread* thread, bool v) {
119     data(thread)-&gt;_force_satb_flush = v;
120   }
121 
122   static bool is_force_satb_flush(Thread* thread) {
123     return data(thread)-&gt;_force_satb_flush;
124   }
125 
126   static void initialize_gclab(Thread* thread) {
127     assert (thread-&gt;is_Java_thread() || thread-&gt;is_Worker_thread(), &quot;Only Java and GC worker threads are allowed to get GCLABs&quot;);
128     assert(data(thread)-&gt;_gclab == NULL, &quot;Only initialize once&quot;);
129     data(thread)-&gt;_gclab = new PLAB(PLAB::min_size());
130     data(thread)-&gt;_gclab_size = 0;
<a name="4" id="anc4"></a><span class="line-added">131     data(thread)-&gt;_disarmed_value = ShenandoahCodeRoots::disarmed_value();</span>
132   }
133 
134   static PLAB* gclab(Thread* thread) {
135     return data(thread)-&gt;_gclab;
136   }
137 
138   static size_t gclab_size(Thread* thread) {
139     return data(thread)-&gt;_gclab_size;
140   }
141 
142   static void set_gclab_size(Thread* thread, size_t v) {
143     data(thread)-&gt;_gclab_size = v;
144   }
145 
<a name="5" id="anc5"></a><span class="line-added">146   static void set_disarmed_value(Thread* thread, int value) {</span>
<span class="line-added">147     data(thread)-&gt;_disarmed_value = value;</span>
<span class="line-added">148   }</span>
<span class="line-added">149 </span>
150 #ifdef ASSERT
151   static void set_evac_allowed(Thread* thread, bool evac_allowed) {
152     if (evac_allowed) {
153       data(thread)-&gt;_oom_during_evac |= 2;
154     } else {
155       data(thread)-&gt;_oom_during_evac &amp;= ~2;
156     }
157   }
158 
159   static bool is_evac_allowed(Thread* thread) {
160     return (data(thread)-&gt;_oom_during_evac &amp; 2) == 2;
161   }
162 #endif
163 
164   // Offsets
165   static ByteSize satb_mark_queue_active_offset() {
166     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();
167   }
168 
169   static ByteSize satb_mark_queue_index_offset() {
170     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_index();
171   }
172 
173   static ByteSize satb_mark_queue_buffer_offset() {
174     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_buf();
175   }
176 
177   static ByteSize gc_state_offset() {
178     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _gc_state);
179   }
180 
<a name="6" id="anc6"></a><span class="line-added">181   static ByteSize disarmed_value_offset() {</span>
<span class="line-added">182     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _disarmed_value);</span>
<span class="line-added">183   }</span>
184 };
185 
186 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
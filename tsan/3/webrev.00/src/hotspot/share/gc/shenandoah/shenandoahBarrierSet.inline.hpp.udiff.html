<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSet.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,260 +24,309 @@</span>
  
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
  
  #include &quot;gc/shared/barrierSet.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shenandoah/shenandoahBrooksPointer.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::need_update_refs_barrier() {</span>
<span class="udiff-line-modified-removed">-   return _heap-&gt;is_update_refs_in_progress() ||</span>
<span class="udiff-line-modified-removed">-          _heap-&gt;is_concurrent_traversal_in_progress() ||</span>
<span class="udiff-line-modified-removed">-          (_heap-&gt;is_concurrent_mark_in_progress() &amp;&amp; _heap-&gt;has_forwarded_objects());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;memory/iterator.inline.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/oop.inline.hpp&quot;</span>
  
  inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
<span class="udiff-line-modified-removed">-   return ShenandoahBrooksPointer::forwardee(p);</span>
<span class="udiff-line-modified-added">+   return ShenandoahForwarding::get_forwardee(p);</span>
  }
  
  inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
<span class="udiff-line-modified-removed">-   if (((HeapWord*) p) != NULL) {</span>
<span class="udiff-line-modified-added">+   if (p != NULL) {</span>
      return resolve_forwarded_not_null(p);
    } else {
      return p;
    }
  }
  
<span class="udiff-line-modified-removed">- template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-removed">- template &lt;typename T&gt;</span>
<span class="udiff-line-modified-removed">- inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="udiff-line-modified-removed">-   oop res;</span>
<span class="udiff-line-modified-removed">-   oop expected = compare_value;</span>
<span class="udiff-line-modified-removed">-   do {</span>
<span class="udiff-line-modified-removed">-     compare_value = expected;</span>
<span class="udiff-line-modified-removed">-     res = Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
<span class="udiff-line-modified-removed">-     expected = res;</span>
<span class="udiff-line-modified-removed">-   } while ((! oopDesc::equals_raw(compare_value, expected)) &amp;&amp; oopDesc::equals_raw(resolve_forwarded(compare_value), resolve_forwarded(expected)));</span>
<span class="udiff-line-modified-removed">-   if (oopDesc::equals_raw(expected, compare_value)) {</span>
<span class="udiff-line-modified-removed">-     if (ShenandoahSATBBarrier &amp;&amp; !CompressedOops::is_null(compare_value)) {</span>
<span class="udiff-line-modified-removed">-       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(compare_value);</span>
<span class="udiff-line-modified-added">+ inline void ShenandoahBarrierSet::enqueue(oop obj) {</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_not_forwarded_if(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress());</span>
<span class="udiff-line-modified-added">+   assert(_satb_mark_queue_set.is_active(), &quot;only get here when SATB active&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Filter marked objects before hitting the SATB queues. The same predicate would</span>
<span class="udiff-line-modified-added">+   // be used by SATBMQ::filter to eliminate already marked objects downstream, but</span>
<span class="udiff-line-modified-added">+   // filtering here helps to avoid wasteful SATB queueing work to begin with.</span>
<span class="udiff-line-modified-added">+   if (!_heap-&gt;requires_marking&lt;false&gt;(obj)) return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::satb_barrier(T *field) {</span>
<span class="udiff-line-added">+   if (HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value ||</span>
<span class="udiff-line-added">+       HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="udiff-line-added">+     T heap_oop = RawAccess&lt;&gt;::oop_load(field);</span>
<span class="udiff-line-added">+     if (!CompressedOops::is_null(heap_oop)) {</span>
<span class="udiff-line-added">+       enqueue(CompressedOops::decode(heap_oop));</span>
      }
    }
<span class="udiff-line-modified-removed">-   return res;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::satb_enqueue(oop value) {</span>
<span class="udiff-line-added">+   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="udiff-line-added">+   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="udiff-line-added">+     enqueue(value);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::storeval_barrier(oop obj) {</span>
<span class="udiff-line-added">+   if (obj != NULL &amp;&amp; ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="udiff-line-added">+     enqueue(obj);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::keep_alive_barrier(oop value) {</span>
<span class="udiff-line-added">+   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="udiff-line-added">+   if (ShenandoahKeepAliveBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="udiff-line-added">+     enqueue(value);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::keep_alive_if_weak(DecoratorSet decorators, oop value) {</span>
<span class="udiff-line-added">+   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="udiff-line-added">+   const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;</span>
<span class="udiff-line-added">+   const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;</span>
<span class="udiff-line-added">+   if (!peek &amp;&amp; !on_strong_oop_ref) {</span>
<span class="udiff-line-added">+     keep_alive_barrier(value);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+ inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {</span>
<span class="udiff-line-added">+   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="udiff-line-added">+   if (!HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value &amp;&amp;</span>
<span class="udiff-line-added">+       !HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="udiff-line-added">+     keep_alive_barrier(value);</span>
<span class="udiff-line-added">+   }</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
<span class="udiff-line-modified-removed">-   oop previous = Raw::oop_atomic_xchg(new_value, addr);</span>
<span class="udiff-line-modified-removed">-   if (ShenandoahSATBBarrier) {</span>
<span class="udiff-line-modified-removed">-     if (!CompressedOops::is_null(previous)) {</span>
<span class="udiff-line-modified-removed">-       ShenandoahBarrierSet::barrier_set()-&gt;enqueue(previous);</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {</span>
<span class="udiff-line-modified-added">+   oop value = Raw::oop_load_not_in_heap(addr);</span>
<span class="udiff-line-modified-added">+   if (value != NULL) {</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-modified-added">+     value = bs-&gt;load_reference_barrier_native(value, addr);</span>
<span class="udiff-line-added">+     if (value != NULL) {</span>
<span class="udiff-line-added">+       bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
      }
    }
<span class="udiff-line-modified-removed">-   return previous;</span>
<span class="udiff-line-modified-added">+   return value;</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-modified-removed">-                                                                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,</span>
<span class="udiff-line-modified-removed">-                                                                                      size_t length) {</span>
<span class="udiff-line-modified-removed">-   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="udiff-line-modified-removed">-     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {</span>
<span class="udiff-line-modified-added">+   oop value = Raw::oop_load_in_heap(addr);</span>
<span class="udiff-line-modified-added">+   if (value != NULL) {</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-modified-added">+     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="udiff-line-added">+     bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
    }
<span class="udiff-line-modified-removed">-   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="udiff-line-modified-removed">-     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>
<span class="udiff-line-modified-added">+   return value;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap_at(oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-added">+   oop value = Raw::oop_load_in_heap_at(base, offset);</span>
<span class="udiff-line-added">+   if (value != NULL) {</span>
<span class="udiff-line-added">+     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-added">+     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="udiff-line-added">+     bs-&gt;keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset),</span>
<span class="udiff-line-added">+                            value);</span>
    }
<span class="udiff-line-modified-removed">-   Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
<span class="udiff-line-modified-added">+   return value;</span>
  }
  
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
  template &lt;typename T&gt;
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::arraycopy_loop_1(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="udiff-line-modified-removed">-                                             bool checkcast, bool satb, bool disjoint,</span>
<span class="udiff-line-modified-removed">-                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="udiff-line-modified-removed">-   if (checkcast) {</span>
<span class="udiff-line-modified-removed">-     return arraycopy_loop_2&lt;T, true&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-removed">-     return arraycopy_loop_2&lt;T, false&gt;(src, dst, length, bound, satb, disjoint, storeval_mode);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_not_in_heap(T* addr, oop value) {</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_marked_if(NULL, value, !CompressedOops::is_null(value) &amp;&amp; ShenandoahHeap::heap()-&gt;is_evacuation_in_progress());</span>
<span class="udiff-line-modified-added">+   ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-modified-added">+   bs-&gt;storeval_barrier(value);</span>
<span class="udiff-line-modified-added">+   bs-&gt;satb_barrier&lt;decorators&gt;(addr);</span>
<span class="udiff-line-modified-added">+   Raw::oop_store(addr, value);</span>
  }
  
<span class="udiff-line-modified-removed">- template &lt;typename T, bool CHECKCAST&gt;</span>
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::arraycopy_loop_2(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="udiff-line-modified-removed">-                                             bool satb, bool disjoint,</span>
<span class="udiff-line-modified-removed">-                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="udiff-line-modified-removed">-   if (satb) {</span>
<span class="udiff-line-modified-removed">-     return arraycopy_loop_3&lt;T, CHECKCAST, true&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     return arraycopy_loop_3&lt;T, CHECKCAST, false&gt;(src, dst, length, bound, disjoint, storeval_mode);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap(T* addr, oop value) {</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_not_in_cset_loc_except(addr, ShenandoahHeap::heap()-&gt;cancelled_gc());</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_not_forwarded_except  (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="udiff-line-modified-added">+   shenandoah_assert_not_in_cset_except    (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   oop_store_not_in_heap(addr, value);</span>
  }
  
<span class="udiff-line-modified-removed">- template &lt;typename T, bool CHECKCAST, bool SATB&gt;</span>
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::arraycopy_loop_3(T* src, T* dst, size_t length, Klass* bound, bool disjoint,</span>
<span class="udiff-line-modified-removed">-                                             ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode) {</span>
<span class="udiff-line-removed">-   switch (storeval_mode) {</span>
<span class="udiff-line-removed">-     case NONE:</span>
<span class="udiff-line-removed">-       return arraycopy_loop&lt;T, CHECKCAST, SATB, NONE&gt;(src, dst, length, bound, disjoint);</span>
<span class="udiff-line-removed">-     case READ_BARRIER:</span>
<span class="udiff-line-removed">-       return arraycopy_loop&lt;T, CHECKCAST, SATB, READ_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="udiff-line-removed">-     case WRITE_BARRIER:</span>
<span class="udiff-line-removed">-       return arraycopy_loop&lt;T, CHECKCAST, SATB, WRITE_BARRIER&gt;(src, dst, length, bound, disjoint);</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return true; // happy compiler</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {</span>
<span class="udiff-line-modified-added">+   oop_store_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), value);</span>
  }
  
<span class="udiff-line-modified-removed">- template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::arraycopy_loop(T* src, T* dst, size_t length, Klass* bound, bool disjoint) {</span>
<span class="udiff-line-modified-removed">-   Thread* thread = Thread::current();</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="udiff-line-added">+   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-added">+   bs-&gt;storeval_barrier(new_value);</span>
  
<span class="udiff-line-modified-removed">-   ShenandoahEvacOOMScope oom_evac_scope;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // We need to handle four cases:</span>
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // a) src &lt; dst, conjoint, can only copy backward only</span>
<span class="udiff-line-modified-removed">-   //   [...src...]</span>
<span class="udiff-line-modified-removed">-   //         [...dst...]</span>
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // b) src &lt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="udiff-line-modified-removed">-   //   [...src...]</span>
<span class="udiff-line-modified-removed">-   //              [...dst...]</span>
<span class="udiff-line-modified-removed">-   //</span>
<span class="udiff-line-modified-removed">-   // c) src &gt; dst, conjoint, can copy forward only</span>
<span class="udiff-line-removed">-   //         [...src...]</span>
<span class="udiff-line-removed">-   //   [...dst...]</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // d) src &gt; dst, disjoint, can only copy forward, because types may mismatch</span>
<span class="udiff-line-removed">-   //              [...src...]</span>
<span class="udiff-line-removed">-   //   [...dst...]</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   if (src &gt; dst || disjoint) {</span>
<span class="udiff-line-removed">-     // copy forward:</span>
<span class="udiff-line-removed">-     T* cur_src = src;</span>
<span class="udiff-line-removed">-     T* cur_dst = dst;</span>
<span class="udiff-line-removed">-     T* src_end = src + length;</span>
<span class="udiff-line-removed">-     for (; cur_src &lt; src_end; cur_src++, cur_dst++) {</span>
<span class="udiff-line-removed">-       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // copy backward:</span>
<span class="udiff-line-removed">-     T* cur_src = src + length - 1;</span>
<span class="udiff-line-removed">-     T* cur_dst = dst + length - 1;</span>
<span class="udiff-line-removed">-     for (; cur_src &gt;= src; cur_src--, cur_dst--) {</span>
<span class="udiff-line-removed">-       if (!arraycopy_element&lt;T, CHECKCAST, SATB, STOREVAL_MODE&gt;(cur_src, cur_dst, bound, thread)) {</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   oop res;</span>
<span class="udiff-line-modified-added">+   oop expected = compare_value;</span>
<span class="udiff-line-modified-added">+   do {</span>
<span class="udiff-line-modified-added">+     compare_value = expected;</span>
<span class="udiff-line-modified-added">+     res = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
<span class="udiff-line-modified-added">+     expected = res;</span>
<span class="udiff-line-modified-added">+   } while ((compare_value != expected) &amp;&amp; (resolve_forwarded(compare_value) == resolve_forwarded(expected)));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="udiff-line-modified-added">+   // because it must be the previous value.</span>
<span class="udiff-line-modified-added">+   if (res != NULL) {</span>
<span class="udiff-line-modified-added">+     res = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(res);</span>
<span class="udiff-line-modified-added">+     bs-&gt;satb_enqueue(res);</span>
    }
<span class="udiff-line-modified-removed">-   return true;</span>
<span class="udiff-line-modified-added">+   return res;</span>
  }
  
<span class="udiff-line-modified-removed">- template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="udiff-line-modified-removed">- bool ShenandoahBarrierSet::arraycopy_element(T* cur_src, T* cur_dst, Klass* bound, Thread* thread) {</span>
<span class="udiff-line-modified-removed">-   T o = RawAccess&lt;&gt;::oop_load(cur_src);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   if (SATB) {</span>
<span class="udiff-line-removed">-     T prev = RawAccess&lt;&gt;::oop_load(cur_dst);</span>
<span class="udiff-line-removed">-     if (!CompressedOops::is_null(prev)) {</span>
<span class="udiff-line-removed">-       oop prev_obj = CompressedOops::decode_not_null(prev);</span>
<span class="udiff-line-removed">-       enqueue(prev_obj);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="udiff-line-modified-added">+   return oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (!CompressedOops::is_null(o)) {</span>
<span class="udiff-line-modified-removed">-     oop obj = CompressedOops::decode_not_null(o);</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
<span class="udiff-line-added">+   return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), compare_value, new_value);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (CHECKCAST) {</span>
<span class="udiff-line-modified-removed">-       assert(bound != NULL, &quot;need element klass for checkcast&quot;);</span>
<span class="udiff-line-modified-removed">-       if (!oopDesc::is_instanceof_or_null(obj, bound)) {</span>
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-modified-added">+ template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
<span class="udiff-line-modified-added">+   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-modified-added">+   bs-&gt;storeval_barrier(new_value);</span>
  
<span class="udiff-line-modified-removed">-     switch (STOREVAL_MODE) {</span>
<span class="udiff-line-removed">-     case NONE:</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     case READ_BARRIER:</span>
<span class="udiff-line-removed">-       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     case WRITE_BARRIER:</span>
<span class="udiff-line-removed">-       if (_heap-&gt;in_collection_set(obj)) {</span>
<span class="udiff-line-removed">-         oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="udiff-line-removed">-         if (oopDesc::equals_raw(forw, obj)) {</span>
<span class="udiff-line-removed">-           forw = _heap-&gt;evacuate_object(forw, thread);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         obj = forw;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       enqueue(obj);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   oop previous = Raw::oop_atomic_xchg(addr, new_value);</span>
  
<span class="udiff-line-modified-removed">-     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(cur_dst, obj);</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     // Store null.</span>
<span class="udiff-line-modified-removed">-     RawAccess&lt;&gt;::oop_store(cur_dst, o);</span>
<span class="udiff-line-modified-added">+   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="udiff-line-modified-added">+   // because it must be the previous value.</span>
<span class="udiff-line-modified-added">+   if (previous != NULL) {</span>
<span class="udiff-line-modified-added">+     previous = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(previous);</span>
<span class="udiff-line-added">+     bs-&gt;satb_enqueue(previous);</span>
    }
<span class="udiff-line-modified-removed">-   return true;</span>
<span class="udiff-line-modified-added">+   return previous;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-added">+ template &lt;typename T&gt;</span>
<span class="udiff-line-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
<span class="udiff-line-added">+   return oop_atomic_xchg_not_in_heap(addr, new_value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="udiff-line-added">+ inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
<span class="udiff-line-added">+   return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), new_value);</span>
  }
  
  // Clone barrier support
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
<span class="udiff-line-modified-removed">-   src = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src));</span>
<span class="udiff-line-modified-removed">-   dst = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst));</span>
<span class="udiff-line-modified-added">+   if (ShenandoahCloneBarrier) {</span>
<span class="udiff-line-modified-added">+     ShenandoahBarrierSet::barrier_set()-&gt;clone_barrier_runtime(src);</span>
<span class="udiff-line-added">+   }</span>
    Raw::clone(src, dst, size);
<span class="udiff-line-removed">-   ShenandoahBarrierSet::barrier_set()-&gt;write_region(MemRegion((HeapWord*) dst, size));</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
  bool ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                                                                           arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                                                                           size_t length) {
<span class="udiff-line-modified-removed">-   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="udiff-line-modified-removed">-   if (!CompressedOops::is_null(src_obj)) {</span>
<span class="udiff-line-modified-removed">-     src_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;read_barrier(src_obj));</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   if (!CompressedOops::is_null(dst_obj)) {</span>
<span class="udiff-line-modified-removed">-     dst_obj = arrayOop(ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(dst_obj));</span>
<span class="udiff-line-modified-added">+   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-modified-added">+   bs-&gt;arraycopy_pre(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),</span>
<span class="udiff-line-modified-added">+                     arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),</span>
<span class="udiff-line-modified-added">+                     length);</span>
<span class="udiff-line-modified-added">+   return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;</span>
<span class="udiff-line-added">+ void ShenandoahBarrierSet::arraycopy_work(T* src, size_t count) {</span>
<span class="udiff-line-added">+   Thread* thread = Thread::current();</span>
<span class="udiff-line-added">+   SATBMarkQueue&amp; queue = ShenandoahThreadLocalData::satb_mark_queue(thread);</span>
<span class="udiff-line-added">+   ShenandoahMarkingContext* ctx = _heap-&gt;marking_context();</span>
<span class="udiff-line-added">+   const ShenandoahCollectionSet* const cset = _heap-&gt;collection_set();</span>
<span class="udiff-line-added">+   T* end = src + count;</span>
<span class="udiff-line-added">+   for (T* elem_ptr = src; elem_ptr &lt; end; elem_ptr++) {</span>
<span class="udiff-line-added">+     T o = RawAccess&lt;&gt;::oop_load(elem_ptr);</span>
<span class="udiff-line-added">+     if (!CompressedOops::is_null(o)) {</span>
<span class="udiff-line-added">+       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="udiff-line-added">+       if (HAS_FWD &amp;&amp; cset-&gt;is_in(obj)) {</span>
<span class="udiff-line-added">+         assert(_heap-&gt;has_forwarded_objects(), &quot;only get here with forwarded objects&quot;);</span>
<span class="udiff-line-added">+         oop fwd = resolve_forwarded_not_null(obj);</span>
<span class="udiff-line-added">+         if (EVAC &amp;&amp; obj == fwd) {</span>
<span class="udiff-line-added">+           fwd = _heap-&gt;evacuate_object(obj, thread);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert(obj != fwd || _heap-&gt;cancelled_gc(), &quot;must be forwarded&quot;);</span>
<span class="udiff-line-added">+         oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);</span>
<span class="udiff-line-added">+         obj = fwd;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (ENQUEUE &amp;&amp; !ctx-&gt;is_marked(obj)) {</span>
<span class="udiff-line-added">+         queue.enqueue_known_active(obj);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   bool satb = ShenandoahSATBBarrier &amp;&amp; heap-&gt;is_concurrent_mark_in_progress();</span>
<span class="udiff-line-modified-removed">-   bool checkcast = HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value;</span>
<span class="udiff-line-modified-removed">-   bool disjoint = HasDecorator&lt;decorators, ARRAYCOPY_DISJOINT&gt;::value;</span>
<span class="udiff-line-modified-removed">-   ArrayCopyStoreValMode storeval_mode;</span>
<span class="udiff-line-modified-removed">-   if (heap-&gt;has_forwarded_objects()) {</span>
<span class="udiff-line-removed">-     if (heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="udiff-line-removed">-       storeval_mode = WRITE_BARRIER;</span>
<span class="udiff-line-removed">-     } else if (heap-&gt;is_concurrent_mark_in_progress() || heap-&gt;is_update_refs_in_progress()) {</span>
<span class="udiff-line-removed">-       storeval_mode = READ_BARRIER;</span>
<span class="udiff-line-modified-added">+ template &lt;class T&gt;</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSet::arraycopy_pre_work(T* src, T* dst, size_t count) {</span>
<span class="udiff-line-modified-added">+   if (_heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="udiff-line-modified-added">+     if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="udiff-line-modified-added">+       arraycopy_work&lt;T, true, false, true&gt;(dst, count);</span>
      } else {
<span class="udiff-line-modified-removed">-       assert(heap-&gt;is_idle() || heap-&gt;is_evacuation_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="udiff-line-removed">-       storeval_mode = NONE; // E.g. during evac or outside cycle</span>
<span class="udiff-line-modified-added">+       arraycopy_work&lt;T, false, false, true&gt;(dst, count);</span>
      }
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     assert(heap-&gt;is_stable() || heap-&gt;is_concurrent_mark_in_progress(), &quot;must not have anything in progress&quot;);</span>
<span class="udiff-line-removed">-     storeval_mode = NONE;</span>
    }
  
<span class="udiff-line-modified-removed">-   if (!satb &amp;&amp; !checkcast &amp;&amp; storeval_mode == NONE) {</span>
<span class="udiff-line-modified-removed">-     // Short-circuit to bulk copy.</span>
<span class="udiff-line-modified-removed">-     return Raw::oop_arraycopy(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
<span class="udiff-line-modified-added">+   arraycopy_update_impl(src, count);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahBarrierSet::arraycopy_pre(oop* src, oop* dst, size_t count) {</span>
<span class="udiff-line-added">+   arraycopy_pre_work(src, dst, count);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ShenandoahBarrierSet::arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count) {</span>
<span class="udiff-line-added">+   arraycopy_pre_work(src, dst, count);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template &lt;class T&gt;</span>
<span class="udiff-line-added">+ void ShenandoahBarrierSet::arraycopy_update_impl(T* src, size_t count) {</span>
<span class="udiff-line-added">+   if (_heap-&gt;is_evacuation_in_progress()) {</span>
<span class="udiff-line-added">+     ShenandoahEvacOOMScope oom_evac;</span>
<span class="udiff-line-added">+     arraycopy_work&lt;T, true, true, false&gt;(src, count);</span>
<span class="udiff-line-added">+   } else if (_heap-&gt;is_concurrent_traversal_in_progress()){</span>
<span class="udiff-line-added">+     ShenandoahEvacOOMScope oom_evac;</span>
<span class="udiff-line-added">+     arraycopy_work&lt;T, true, true, true&gt;(src, count);</span>
<span class="udiff-line-added">+   } else if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="udiff-line-added">+     arraycopy_work&lt;T, true, false, false&gt;(src, count);</span>
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);</span>
<span class="udiff-line-modified-removed">-   dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSet::arraycopy_update(oop* src, size_t count) {</span>
<span class="udiff-line-modified-added">+   arraycopy_update_impl(src, count);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   Klass* bound = objArrayOop(dst_obj)-&gt;element_klass();</span>
<span class="udiff-line-modified-removed">-   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="udiff-line-removed">-   return bs-&gt;arraycopy_loop_1(src_raw, dst_raw, length, bound, checkcast, satb, disjoint, storeval_mode);</span>
<span class="udiff-line-modified-added">+ void ShenandoahBarrierSet::arraycopy_update(narrowOop* src, size_t count) {</span>
<span class="udiff-line-modified-added">+   arraycopy_update_impl(src, count);</span>
  }
  
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
</pre>
<center><a href="shenandoahBarrierSet.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetAssembler.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;gc/shared/barrierSet.hpp&quot;
<a name="2" id="anc2"></a>

  26 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  30 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  31 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  32 #include &quot;opto/arraycopynode.hpp&quot;
  33 #include &quot;opto/escape.hpp&quot;
  34 #include &quot;opto/graphKit.hpp&quot;
  35 #include &quot;opto/idealKit.hpp&quot;
  36 #include &quot;opto/macro.hpp&quot;
  37 #include &quot;opto/movenode.hpp&quot;
  38 #include &quot;opto/narrowptrnode.hpp&quot;
  39 #include &quot;opto/rootnode.hpp&quot;
<a name="3" id="anc3"></a>
  40 
  41 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  42   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  43 }
  44 
  45 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
<a name="4" id="anc4"></a><span class="line-modified">  46   : _shenandoah_barriers(new (comp_arena) GrowableArray&lt;ShenandoahWriteBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {</span>

  47 }
  48 
<a name="5" id="anc5"></a><span class="line-modified">  49 int ShenandoahBarrierSetC2State::shenandoah_barriers_count() const {</span>
<span class="line-modified">  50   return _shenandoah_barriers-&gt;length();</span>
  51 }
  52 
<a name="6" id="anc6"></a><span class="line-modified">  53 ShenandoahWriteBarrierNode* ShenandoahBarrierSetC2State::shenandoah_barrier(int idx) const {</span>
<span class="line-modified">  54   return _shenandoah_barriers-&gt;at(idx);</span>
  55 }
  56 
<a name="7" id="anc7"></a><span class="line-modified">  57 void ShenandoahBarrierSetC2State::add_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {</span>
<span class="line-modified">  58   assert(!_shenandoah_barriers-&gt;contains(n), &quot;duplicate entry in barrier list&quot;);</span>
<span class="line-modified">  59   _shenandoah_barriers-&gt;append(n);</span>
  60 }
  61 
<a name="8" id="anc8"></a><span class="line-modified">  62 void ShenandoahBarrierSetC2State::remove_shenandoah_barrier(ShenandoahWriteBarrierNode * n) {</span>
<span class="line-modified">  63   if (_shenandoah_barriers-&gt;contains(n)) {</span>
<span class="line-modified">  64     _shenandoah_barriers-&gt;remove(n);</span>
  65   }
  66 }
  67 
<a name="9" id="anc9"></a><span class="line-modified">  68 #define __ kit-&gt;</span>
<span class="line-modified">  69 </span>
<span class="line-removed">  70 Node* ShenandoahBarrierSetC2::shenandoah_read_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="line-removed">  71   if (ShenandoahReadBarrier) {</span>
<span class="line-removed">  72     obj = shenandoah_read_barrier_impl(kit, obj, false, true, true);</span>
<span class="line-removed">  73   }</span>
<span class="line-removed">  74   return obj;</span>
  75 }
  76 
<a name="10" id="anc10"></a><span class="line-modified">  77 Node* ShenandoahBarrierSetC2::shenandoah_storeval_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="line-modified">  78   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="line-removed">  79     obj = shenandoah_write_barrier(kit, obj);</span>
<span class="line-removed">  80     obj = shenandoah_enqueue_barrier(kit, obj);</span>
<span class="line-removed">  81   }</span>
<span class="line-removed">  82   if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-removed">  83     obj = shenandoah_read_barrier_impl(kit, obj, true, false, false);</span>
<span class="line-removed">  84   }</span>
<span class="line-removed">  85   return obj;</span>
  86 }
  87 
<a name="11" id="anc11"></a><span class="line-modified">  88 Node* ShenandoahBarrierSetC2::shenandoah_read_barrier_impl(GraphKit* kit, Node* obj, bool use_ctrl, bool use_mem, bool allow_fromspace) const {</span>
<span class="line-modified">  89   const Type* obj_type = obj-&gt;bottom_type();</span>
<span class="line-modified">  90   if (obj_type-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-removed">  91     return obj;</span>
<span class="line-removed">  92   }</span>
<span class="line-removed">  93   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="line-removed">  94   Node* mem = use_mem ? __ memory(adr_type) : __ immutable_memory();</span>
<span class="line-removed">  95 </span>
<span class="line-removed">  96   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, mem, allow_fromspace)) {</span>
<span class="line-removed">  97     // We know it is null, no barrier needed.</span>
<span class="line-removed">  98     return obj;</span>
<span class="line-removed">  99   }</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101   if (obj_type-&gt;meet(TypePtr::NULL_PTR) == obj_type-&gt;remove_speculative()) {</span>
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103     // We don&#39;t know if it&#39;s null or not. Need null-check.</span>
<span class="line-removed"> 104     enum { _not_null_path = 1, _null_path, PATH_LIMIT };</span>
<span class="line-removed"> 105     RegionNode* region = new RegionNode(PATH_LIMIT);</span>
<span class="line-removed"> 106     Node*       phi    = new PhiNode(region, obj_type);</span>
<span class="line-removed"> 107     Node* null_ctrl = __ top();</span>
<span class="line-removed"> 108     Node* not_null_obj = __ null_check_oop(obj, &amp;null_ctrl);</span>
<span class="line-removed"> 109 </span>
<span class="line-removed"> 110     region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-removed"> 111     phi   -&gt;init_req(_null_path, __ zerocon(T_OBJECT));</span>
<span class="line-removed"> 112 </span>
<span class="line-removed"> 113     Node* ctrl = use_ctrl ? __ control() : NULL;</span>
<span class="line-removed"> 114     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, not_null_obj, allow_fromspace);</span>
<span class="line-removed"> 115     Node* n = __ gvn().transform(rb);</span>
<span class="line-removed"> 116 </span>
<span class="line-removed"> 117     region-&gt;init_req(_not_null_path, __ control());</span>
<span class="line-removed"> 118     phi   -&gt;init_req(_not_null_path, n);</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120     __ set_control(__ gvn().transform(region));</span>
<span class="line-removed"> 121     __ record_for_igvn(region);</span>
<span class="line-removed"> 122     return __ gvn().transform(phi);</span>
<span class="line-removed"> 123 </span>
<span class="line-removed"> 124   } else {</span>
<span class="line-removed"> 125     // We know it is not null. Simple barrier is sufficient.</span>
<span class="line-removed"> 126     Node* ctrl = use_ctrl ? __ control() : NULL;</span>
<span class="line-removed"> 127     ShenandoahReadBarrierNode* rb = new ShenandoahReadBarrierNode(ctrl, mem, obj, allow_fromspace);</span>
<span class="line-removed"> 128     Node* n = __ gvn().transform(rb);</span>
<span class="line-removed"> 129     __ record_for_igvn(n);</span>
<span class="line-removed"> 130     return n;</span>
<span class="line-removed"> 131   }</span>
 132 }
 133 
<a name="12" id="anc12"></a><span class="line-modified"> 134 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_helper(GraphKit* kit, Node* obj, const TypePtr* adr_type) const {</span>
<span class="line-modified"> 135   ShenandoahWriteBarrierNode* wb = new ShenandoahWriteBarrierNode(kit-&gt;C, kit-&gt;control(), kit-&gt;memory(adr_type), obj);</span>
<span class="line-modified"> 136   Node* n = __ gvn().transform(wb);</span>
<span class="line-removed"> 137   if (n == wb) { // New barrier needs memory projection.</span>
<span class="line-removed"> 138     Node* proj = __ gvn().transform(new ShenandoahWBMemProjNode(n));</span>
<span class="line-removed"> 139     __ set_memory(proj, adr_type);</span>
 140   }
<a name="13" id="anc13"></a><span class="line-removed"> 141   return n;</span>
 142 }
 143 
<a name="14" id="anc14"></a><span class="line-modified"> 144 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier(GraphKit* kit, Node* obj) const {</span>
<span class="line-modified"> 145   if (ShenandoahWriteBarrier) {</span>
<span class="line-modified"> 146     obj = shenandoah_write_barrier_impl(kit, obj);</span>
 147   }
 148   return obj;
 149 }
 150 
<a name="15" id="anc15"></a><span class="line-modified"> 151 Node* ShenandoahBarrierSetC2::shenandoah_write_barrier_impl(GraphKit* kit, Node* obj) const {</span>
<span class="line-removed"> 152   if (! ShenandoahBarrierNode::needs_barrier(&amp;__ gvn(), NULL, obj, NULL, true)) {</span>
<span class="line-removed"> 153     return obj;</span>
<span class="line-removed"> 154   }</span>
<span class="line-removed"> 155   const Type* obj_type = obj-&gt;bottom_type();</span>
<span class="line-removed"> 156   const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="line-removed"> 157   Node* n = shenandoah_write_barrier_helper(kit, obj, adr_type);</span>
<span class="line-removed"> 158   __ record_for_igvn(n);</span>
<span class="line-removed"> 159   return n;</span>
<span class="line-removed"> 160 }</span>
 161 
 162 bool ShenandoahBarrierSetC2::satb_can_remove_pre_barrier(GraphKit* kit, PhaseTransform* phase, Node* adr,
 163                                                          BasicType bt, uint adr_idx) const {
 164   intptr_t offset = 0;
 165   Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);
 166   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);
 167 
 168   if (offset == Type::OffsetBot) {
 169     return false; // cannot unalias unless there are precise offsets
 170   }
 171 
 172   if (alloc == NULL) {
 173     return false; // No allocation found
 174   }
 175 
 176   intptr_t size_in_bytes = type2aelembytes(bt);
 177 
 178   Node* mem = __ memory(adr_idx); // start searching here...
 179 
 180   for (int cnt = 0; cnt &lt; 50; cnt++) {
 181 
 182     if (mem-&gt;is_Store()) {
 183 
 184       Node* st_adr = mem-&gt;in(MemNode::Address);
 185       intptr_t st_offset = 0;
 186       Node* st_base = AddPNode::Ideal_base_and_offset(st_adr, phase, st_offset);
 187 
 188       if (st_base == NULL) {
 189         break; // inscrutable pointer
 190       }
 191 
 192       // Break we have found a store with same base and offset as ours so break
 193       if (st_base == base &amp;&amp; st_offset == offset) {
 194         break;
 195       }
 196 
 197       if (st_offset != offset &amp;&amp; st_offset != Type::OffsetBot) {
 198         const int MAX_STORE = BytesPerLong;
 199         if (st_offset &gt;= offset + size_in_bytes ||
 200             st_offset &lt;= offset - MAX_STORE ||
 201             st_offset &lt;= offset - mem-&gt;as_Store()-&gt;memory_size()) {
 202           // Success:  The offsets are provably independent.
 203           // (You may ask, why not just test st_offset != offset and be done?
 204           // The answer is that stores of different sizes can co-exist
 205           // in the same sequence of RawMem effects.  We sometimes initialize
 206           // a whole &#39;tile&#39; of array elements with a single jint or jlong.)
 207           mem = mem-&gt;in(MemNode::Memory);
 208           continue; // advance through independent store memory
 209         }
 210       }
 211 
 212       if (st_base != base
 213           &amp;&amp; MemNode::detect_ptr_independence(base, alloc, st_base,
 214                                               AllocateNode::Ideal_allocation(st_base, phase),
 215                                               phase)) {
 216         // Success:  The bases are provably independent.
 217         mem = mem-&gt;in(MemNode::Memory);
 218         continue; // advance through independent store memory
 219       }
 220     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Initialize()) {
 221 
 222       InitializeNode* st_init = mem-&gt;in(0)-&gt;as_Initialize();
 223       AllocateNode* st_alloc = st_init-&gt;allocation();
 224 
 225       // Make sure that we are looking at the same allocation site.
 226       // The alloc variable is guaranteed to not be null here from earlier check.
 227       if (alloc == st_alloc) {
 228         // Check that the initialization is storing NULL so that no previous store
 229         // has been moved up and directly write a reference
 230         Node* captured_store = st_init-&gt;find_captured_store(offset,
 231                                                             type2aelembytes(T_OBJECT),
 232                                                             phase);
 233         if (captured_store == NULL || captured_store == st_init-&gt;zero_memory()) {
 234           return true;
 235         }
 236       }
 237     }
 238 
 239     // Unless there is an explicit &#39;continue&#39;, we must bail out here,
 240     // because &#39;mem&#39; is an inscrutable memory state (e.g., a call).
 241     break;
 242   }
 243 
 244   return false;
 245 }
 246 
 247 #undef __
 248 #define __ ideal.
 249 
 250 void ShenandoahBarrierSetC2::satb_write_barrier_pre(GraphKit* kit,
 251                                                     bool do_load,
 252                                                     Node* obj,
 253                                                     Node* adr,
 254                                                     uint alias_idx,
 255                                                     Node* val,
 256                                                     const TypeOopPtr* val_type,
 257                                                     Node* pre_val,
 258                                                     BasicType bt) const {
 259   // Some sanity checks
 260   // Note: val is unused in this routine.
 261 
 262   if (do_load) {
 263     // We need to generate the load of the previous value
 264     assert(obj != NULL, &quot;must have a base&quot;);
 265     assert(adr != NULL, &quot;where are loading from?&quot;);
 266     assert(pre_val == NULL, &quot;loaded already?&quot;);
 267     assert(val_type != NULL, &quot;need a type&quot;);
 268 
 269     if (ReduceInitialCardMarks
 270         &amp;&amp; satb_can_remove_pre_barrier(kit, &amp;kit-&gt;gvn(), adr, bt, alias_idx)) {
 271       return;
 272     }
 273 
 274   } else {
 275     // In this case both val_type and alias_idx are unused.
 276     assert(pre_val != NULL, &quot;must be loaded already&quot;);
 277     // Nothing to be done if pre_val is null.
 278     if (pre_val-&gt;bottom_type() == TypePtr::NULL_PTR) return;
 279     assert(pre_val-&gt;bottom_type()-&gt;basic_type() == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 280   }
 281   assert(bt == T_OBJECT, &quot;or we shouldn&#39;t be here&quot;);
 282 
 283   IdealKit ideal(kit, true);
 284 
 285   Node* tls = __ thread(); // ThreadLocalStorage
 286 
 287   Node* no_base = __ top();
 288   Node* zero  = __ ConI(0);
 289   Node* zeroX = __ ConX(0);
 290 
 291   float likely  = PROB_LIKELY(0.999);
 292   float unlikely  = PROB_UNLIKELY(0.999);
 293 
 294   // Offsets into the thread
 295   const int index_offset   = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
 296   const int buffer_offset  = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
 297 
 298   // Now the actual pointers into the thread
 299   Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));
 300   Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));
 301 
 302   // Now some of the values
 303   Node* marking;
 304   Node* gc_state = __ AddP(no_base, tls, __ ConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset())));
 305   Node* ld = __ load(__ ctrl(), gc_state, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);
 306   marking = __ AndI(ld, __ ConI(ShenandoahHeap::MARKING));
<a name="16" id="anc16"></a><span class="line-modified"> 307   assert(ShenandoahWriteBarrierNode::is_gc_state_load(ld), &quot;Should match the shape&quot;);</span>
 308 
 309   // if (!marking)
 310   __ if_then(marking, BoolTest::ne, zero, unlikely); {
 311     BasicType index_bt = TypeX_X-&gt;basic_type();
 312     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
 313     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
 314 
 315     if (do_load) {
 316       // load original value
 317       // alias_idx correct??
 318       pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
 319     }
 320 
 321     // if (pre_val != NULL)
 322     __ if_then(pre_val, BoolTest::ne, kit-&gt;null()); {
 323       Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);
 324 
 325       // is the queue for this thread full?
 326       __ if_then(index, BoolTest::ne, zeroX, likely); {
 327 
 328         // decrement the index
 329         Node* next_index = kit-&gt;gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));
 330 
 331         // Now get the buffer location we will log the previous value into and store it
 332         Node *log_addr = __ AddP(no_base, buffer, next_index);
 333         __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);
 334         // update the index
 335         __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);
 336 
 337       } __ else_(); {
 338 
 339         // logging buffer is full, call the runtime
 340         const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();
 341         __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, pre_val, tls);
 342       } __ end_if();  // (!index)
 343     } __ end_if();  // (pre_val != NULL)
 344   } __ end_if();  // (!marking)
 345 
 346   // Final sync IdealKit and GraphKit.
 347   kit-&gt;final_sync(ideal);
 348 
 349   if (ShenandoahSATBBarrier &amp;&amp; adr != NULL) {
 350     Node* c = kit-&gt;control();
 351     Node* call = c-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(0);
 352     assert(is_shenandoah_wb_pre_call(call), &quot;shenandoah_wb_pre call expected&quot;);
 353     call-&gt;add_req(adr);
 354   }
 355 }
 356 
 357 bool ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(Node* call) {
 358   return call-&gt;is_CallLeaf() &amp;&amp;
 359          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);
 360 }
 361 
<a name="17" id="anc17"></a><span class="line-modified"> 362 bool ShenandoahBarrierSetC2::is_shenandoah_wb_call(Node* call) {</span>
<span class="line-modified"> 363   return call-&gt;is_CallLeaf() &amp;&amp;</span>
<span class="line-modified"> 364          call-&gt;as_CallLeaf()-&gt;entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT);</span>






 365 }
 366 
 367 bool ShenandoahBarrierSetC2::is_shenandoah_marking_if(PhaseTransform *phase, Node* n) {
 368   if (n-&gt;Opcode() != Op_If) {
 369     return false;
 370   }
 371 
 372   Node* bol = n-&gt;in(1);
 373   assert(bol-&gt;is_Bool(), &quot;&quot;);
 374   Node* cmpx = bol-&gt;in(1);
 375   if (bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 376       cmpx-&gt;is_Cmp() &amp;&amp; cmpx-&gt;in(2) == phase-&gt;intcon(0) &amp;&amp;
 377       is_shenandoah_state_load(cmpx-&gt;in(1)-&gt;in(1)) &amp;&amp;
 378       cmpx-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp;
 379       cmpx-&gt;in(1)-&gt;in(2) == phase-&gt;intcon(ShenandoahHeap::MARKING)) {
 380     return true;
 381   }
 382 
 383   return false;
 384 }
 385 
 386 bool ShenandoahBarrierSetC2::is_shenandoah_state_load(Node* n) {
 387   if (!n-&gt;is_Load()) return false;
 388   const int state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());
 389   return n-&gt;in(2)-&gt;is_AddP() &amp;&amp; n-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
 390          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;is_Con()
 391          &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == state_offset;
 392 }
 393 
 394 void ShenandoahBarrierSetC2::shenandoah_write_barrier_pre(GraphKit* kit,
 395                                                           bool do_load,
 396                                                           Node* obj,
 397                                                           Node* adr,
 398                                                           uint alias_idx,
 399                                                           Node* val,
 400                                                           const TypeOopPtr* val_type,
 401                                                           Node* pre_val,
 402                                                           BasicType bt) const {
 403   if (ShenandoahSATBBarrier) {
 404     IdealKit ideal(kit);
 405     kit-&gt;sync_kit(ideal);
 406 
 407     satb_write_barrier_pre(kit, do_load, obj, adr, alias_idx, val, val_type, pre_val, bt);
 408 
 409     ideal.sync_kit(kit);
 410     kit-&gt;final_sync(ideal);
 411   }
 412 }
 413 
 414 Node* ShenandoahBarrierSetC2::shenandoah_enqueue_barrier(GraphKit* kit, Node* pre_val) const {
 415   return kit-&gt;gvn().transform(new ShenandoahEnqueueBarrierNode(pre_val));
 416 }
 417 
 418 // Helper that guards and inserts a pre-barrier.
 419 void ShenandoahBarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,
 420                                                 Node* pre_val, bool need_mem_bar) const {
 421   // We could be accessing the referent field of a reference object. If so, when G1
 422   // is enabled, we need to log the value in the referent field in an SATB buffer.
 423   // This routine performs some compile time filters and generates suitable
 424   // runtime filters that guard the pre-barrier code.
 425   // Also add memory barrier for non volatile load from the referent field
 426   // to prevent commoning of loads across safepoint.
 427 
 428   // Some compile time checks.
 429 
 430   // If offset is a constant, is it java_lang_ref_Reference::_reference_offset?
 431   const TypeX* otype = offset-&gt;find_intptr_t_type();
 432   if (otype != NULL &amp;&amp; otype-&gt;is_con() &amp;&amp;
 433       otype-&gt;get_con() != java_lang_ref_Reference::referent_offset) {
 434     // Constant offset but not the reference_offset so just return
 435     return;
 436   }
 437 
 438   // We only need to generate the runtime guards for instances.
 439   const TypeOopPtr* btype = base_oop-&gt;bottom_type()-&gt;isa_oopptr();
 440   if (btype != NULL) {
 441     if (btype-&gt;isa_aryptr()) {
 442       // Array type so nothing to do
 443       return;
 444     }
 445 
 446     const TypeInstPtr* itype = btype-&gt;isa_instptr();
 447     if (itype != NULL) {
 448       // Can the klass of base_oop be statically determined to be
 449       // _not_ a sub-class of Reference and _not_ Object?
 450       ciKlass* klass = itype-&gt;klass();
 451       if ( klass-&gt;is_loaded() &amp;&amp;
 452           !klass-&gt;is_subtype_of(kit-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 453           !kit-&gt;env()-&gt;Object_klass()-&gt;is_subtype_of(klass)) {
 454         return;
 455       }
 456     }
 457   }
 458 
 459   // The compile time filters did not reject base_oop/offset so
 460   // we need to generate the following runtime filters
 461   //
 462   // if (offset == java_lang_ref_Reference::_reference_offset) {
 463   //   if (instance_of(base, java.lang.ref.Reference)) {
 464   //     pre_barrier(_, pre_val, ...);
 465   //   }
 466   // }
 467 
 468   float likely   = PROB_LIKELY(  0.999);
 469   float unlikely = PROB_UNLIKELY(0.999);
 470 
 471   IdealKit ideal(kit);
 472 
 473   Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset);
 474 
 475   __ if_then(offset, BoolTest::eq, referent_off, unlikely); {
 476       // Update graphKit memory and control from IdealKit.
 477       kit-&gt;sync_kit(ideal);
 478 
 479       Node* ref_klass_con = kit-&gt;makecon(TypeKlassPtr::make(kit-&gt;env()-&gt;Reference_klass()));
 480       Node* is_instof = kit-&gt;gen_instanceof(base_oop, ref_klass_con);
 481 
 482       // Update IdealKit memory and control from graphKit.
 483       __ sync_kit(kit);
 484 
 485       Node* one = __ ConI(1);
 486       // is_instof == 0 if base_oop == NULL
 487       __ if_then(is_instof, BoolTest::eq, one, unlikely); {
 488 
 489         // Update graphKit from IdeakKit.
 490         kit-&gt;sync_kit(ideal);
 491 
 492         // Use the pre-barrier to record the value in the referent field
 493         satb_write_barrier_pre(kit, false /* do_load */,
 494                                NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,
 495                                pre_val /* pre_val */,
 496                                T_OBJECT);
 497         if (need_mem_bar) {
 498           // Add memory barrier to prevent commoning reads from this field
 499           // across safepoint since GC can change its value.
 500           kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);
 501         }
 502         // Update IdealKit from graphKit.
 503         __ sync_kit(kit);
 504 
 505       } __ end_if(); // _ref_type != ref_none
 506   } __ end_if(); // offset == referent_offset
 507 
 508   // Final sync IdealKit and GraphKit.
 509   kit-&gt;final_sync(ideal);
 510 }
 511 
 512 #undef __
 513 
 514 const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {
 515   const Type **fields = TypeTuple::fields(2);
 516   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
 517   fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; // thread
 518   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 519 
 520   // create result type (range)
 521   fields = TypeTuple::fields(0);
 522   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 523 
 524   return TypeFunc::make(domain, range);
 525 }
 526 
 527 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 528   const Type **fields = TypeTuple::fields(1);
<a name="18" id="anc18"></a><span class="line-modified"> 529   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value</span>
 530   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 531 
 532   // create result type (range)
 533   fields = TypeTuple::fields(0);
 534   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 535 
 536   return TypeFunc::make(domain, range);
 537 }
 538 
<a name="19" id="anc19"></a><span class="line-modified"> 539 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_write_barrier_Type() {</span>
<span class="line-modified"> 540   const Type **fields = TypeTuple::fields(1);</span>
 541   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value
<a name="20" id="anc20"></a><span class="line-modified"> 542   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);</span>


 543 
 544   // create result type (range)
 545   fields = TypeTuple::fields(1);
 546   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;
 547   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 548 
 549   return TypeFunc::make(domain, range);
 550 }
 551 
<a name="21" id="anc21"></a><span class="line-removed"> 552 void ShenandoahBarrierSetC2::resolve_address(C2Access&amp; access) const {</span>
<span class="line-removed"> 553   const TypePtr* adr_type = access.addr().type();</span>
<span class="line-removed"> 554 </span>
<span class="line-removed"> 555   if ((access.decorators() &amp; IN_NATIVE) == 0 &amp;&amp; (adr_type-&gt;isa_instptr() || adr_type-&gt;isa_aryptr())) {</span>
<span class="line-removed"> 556     int off = adr_type-&gt;is_ptr()-&gt;offset();</span>
<span class="line-removed"> 557     int base_off = adr_type-&gt;isa_instptr() ? instanceOopDesc::base_offset_in_bytes() :</span>
<span class="line-removed"> 558       arrayOopDesc::base_offset_in_bytes(adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type());</span>
<span class="line-removed"> 559     assert(off != Type::OffsetTop, &quot;unexpected offset&quot;);</span>
<span class="line-removed"> 560     if (off == Type::OffsetBot || off &gt;= base_off) {</span>
<span class="line-removed"> 561       DecoratorSet decorators = access.decorators();</span>
<span class="line-removed"> 562       bool is_write = (decorators &amp; C2_WRITE_ACCESS) != 0;</span>
<span class="line-removed"> 563       GraphKit* kit = NULL;</span>
<span class="line-removed"> 564       if (access.is_parse_access()) {</span>
<span class="line-removed"> 565         C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-removed"> 566         kit = parse_access.kit();</span>
<span class="line-removed"> 567       }</span>
<span class="line-removed"> 568       Node* adr = access.addr().node();</span>
<span class="line-removed"> 569       assert(adr-&gt;is_AddP(), &quot;unexpected address shape&quot;);</span>
<span class="line-removed"> 570       Node* base = adr-&gt;in(AddPNode::Base);</span>
<span class="line-removed"> 571 </span>
<span class="line-removed"> 572       if (is_write) {</span>
<span class="line-removed"> 573         if (kit != NULL) {</span>
<span class="line-removed"> 574           base = shenandoah_write_barrier(kit, base);</span>
<span class="line-removed"> 575         } else {</span>
<span class="line-removed"> 576           assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="line-removed"> 577           assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for clone&quot;);</span>
<span class="line-removed"> 578         }</span>
<span class="line-removed"> 579       } else {</span>
<span class="line-removed"> 580         if (adr_type-&gt;isa_instptr()) {</span>
<span class="line-removed"> 581           Compile* C = access.gvn().C;</span>
<span class="line-removed"> 582           ciField* field = C-&gt;alias_type(adr_type)-&gt;field();</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584           // Insert read barrier for Shenandoah.</span>
<span class="line-removed"> 585           if (field != NULL &amp;&amp;</span>
<span class="line-removed"> 586               ((ShenandoahOptimizeStaticFinals   &amp;&amp; field-&gt;is_static()  &amp;&amp; field-&gt;is_final()) ||</span>
<span class="line-removed"> 587                (ShenandoahOptimizeInstanceFinals &amp;&amp; !field-&gt;is_static() &amp;&amp; field-&gt;is_final()) ||</span>
<span class="line-removed"> 588                (ShenandoahOptimizeStableFinals   &amp;&amp; field-&gt;is_stable()))) {</span>
<span class="line-removed"> 589             // Skip the barrier for special fields</span>
<span class="line-removed"> 590           } else {</span>
<span class="line-removed"> 591             if (kit != NULL) {</span>
<span class="line-removed"> 592               base = shenandoah_read_barrier(kit, base);</span>
<span class="line-removed"> 593             } else {</span>
<span class="line-removed"> 594               assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="line-removed"> 595               assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);</span>
<span class="line-removed"> 596             }</span>
<span class="line-removed"> 597           }</span>
<span class="line-removed"> 598         } else {</span>
<span class="line-removed"> 599           if (kit != NULL) {</span>
<span class="line-removed"> 600             base = shenandoah_read_barrier(kit, base);</span>
<span class="line-removed"> 601           } else {</span>
<span class="line-removed"> 602             assert(access.is_opt_access(), &quot;either parse or opt access&quot;);</span>
<span class="line-removed"> 603             assert((access.decorators() &amp; C2_ARRAY_COPY) != 0, &quot;can be skipped for arraycopy&quot;);</span>
<span class="line-removed"> 604           }</span>
<span class="line-removed"> 605         }</span>
<span class="line-removed"> 606       }</span>
<span class="line-removed"> 607       if (base != adr-&gt;in(AddPNode::Base)) {</span>
<span class="line-removed"> 608         assert(kit != NULL, &quot;no barrier should have been added&quot;);</span>
<span class="line-removed"> 609 </span>
<span class="line-removed"> 610         Node* address = adr-&gt;in(AddPNode::Address);</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612         if (address-&gt;is_AddP()) {</span>
<span class="line-removed"> 613           assert(address-&gt;in(AddPNode::Base) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="line-removed"> 614           assert(!address-&gt;in(AddPNode::Address)-&gt;is_AddP(), &quot;unexpected address shape&quot;);</span>
<span class="line-removed"> 615           assert(address-&gt;in(AddPNode::Address) == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="line-removed"> 616           address = address-&gt;clone();</span>
<span class="line-removed"> 617           address-&gt;set_req(AddPNode::Base, base);</span>
<span class="line-removed"> 618           address-&gt;set_req(AddPNode::Address, base);</span>
<span class="line-removed"> 619           address = kit-&gt;gvn().transform(address);</span>
<span class="line-removed"> 620         } else {</span>
<span class="line-removed"> 621           assert(address == adr-&gt;in(AddPNode::Base), &quot;unexpected address shape&quot;);</span>
<span class="line-removed"> 622           address = base;</span>
<span class="line-removed"> 623         }</span>
<span class="line-removed"> 624         adr = adr-&gt;clone();</span>
<span class="line-removed"> 625         adr-&gt;set_req(AddPNode::Base, base);</span>
<span class="line-removed"> 626         adr-&gt;set_req(AddPNode::Address, address);</span>
<span class="line-removed"> 627         adr = kit-&gt;gvn().transform(adr);</span>
<span class="line-removed"> 628         access.addr().set_node(adr);</span>
<span class="line-removed"> 629       }</span>
<span class="line-removed"> 630     }</span>
<span class="line-removed"> 631   }</span>
<span class="line-removed"> 632 }</span>
<span class="line-removed"> 633 </span>
 634 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 635   DecoratorSet decorators = access.decorators();
 636 
 637   const TypePtr* adr_type = access.addr().type();
 638   Node* adr = access.addr().node();
 639 
 640   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 641   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 642 
 643   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 644     return BarrierSetC2::store_at_resolved(access, val);
 645   }
 646 
 647   if (access.is_parse_access()) {
 648     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
 649     GraphKit* kit = parse_access.kit();
 650 
 651     uint adr_idx = kit-&gt;C-&gt;get_alias_index(adr_type);
 652     assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
 653     Node* value = val.node();
 654     value = shenandoah_storeval_barrier(kit, value);
 655     val.set_node(value);
 656     shenandoah_write_barrier_pre(kit, true /* do_load */, /*kit-&gt;control(),*/ access.base(), adr, adr_idx, val.node(),
 657                                  static_cast&lt;const TypeOopPtr*&gt;(val.type()), NULL /* pre_val */, access.type());
 658   } else {
 659     assert(access.is_opt_access(), &quot;only for optimization passes&quot;);
 660     assert(((decorators &amp; C2_TIGHTLY_COUPLED_ALLOC) != 0 || !ShenandoahSATBBarrier) &amp;&amp; (decorators &amp; C2_ARRAY_COPY) != 0, &quot;unexpected caller of this code&quot;);
 661     C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
 662     PhaseGVN&amp; gvn =  opt_access.gvn();
 663     MergeMemNode* mm = opt_access.mem();
 664 
<a name="22" id="anc22"></a><span class="line-removed"> 665     if (ShenandoahStoreValReadBarrier) {</span>
<span class="line-removed"> 666       RegionNode* region = new RegionNode(3);</span>
<span class="line-removed"> 667       const Type* v_t = gvn.type(val.node());</span>
<span class="line-removed"> 668       Node* phi = new PhiNode(region, v_t-&gt;isa_oopptr() ? v_t-&gt;is_oopptr()-&gt;cast_to_nonconst() : v_t);</span>
<span class="line-removed"> 669       Node* cmp = gvn.transform(new CmpPNode(val.node(), gvn.zerocon(T_OBJECT)));</span>
<span class="line-removed"> 670       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
<span class="line-removed"> 671       IfNode* iff = new IfNode(opt_access.ctl(), bol, PROB_LIKELY_MAG(3), COUNT_UNKNOWN);</span>
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673       gvn.transform(iff);</span>
<span class="line-removed"> 674       if (gvn.is_IterGVN()) {</span>
<span class="line-removed"> 675         gvn.is_IterGVN()-&gt;_worklist.push(iff);</span>
<span class="line-removed"> 676       } else {</span>
<span class="line-removed"> 677         gvn.record_for_igvn(iff);</span>
<span class="line-removed"> 678       }</span>
<span class="line-removed"> 679 </span>
<span class="line-removed"> 680       Node* null_true = gvn.transform(new IfFalseNode(iff));</span>
<span class="line-removed"> 681       Node* null_false = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-removed"> 682       region-&gt;init_req(1, null_true);</span>
<span class="line-removed"> 683       region-&gt;init_req(2, null_false);</span>
<span class="line-removed"> 684       phi-&gt;init_req(1, gvn.zerocon(T_OBJECT));</span>
<span class="line-removed"> 685       Node* cast = new CastPPNode(val.node(), gvn.type(val.node())-&gt;join_speculative(TypePtr::NOTNULL));</span>
<span class="line-removed"> 686       cast-&gt;set_req(0, null_false);</span>
<span class="line-removed"> 687       cast = gvn.transform(cast);</span>
<span class="line-removed"> 688       Node* rb = gvn.transform(new ShenandoahReadBarrierNode(null_false, gvn.C-&gt;immutable_memory(), cast, false));</span>
<span class="line-removed"> 689       phi-&gt;init_req(2, rb);</span>
<span class="line-removed"> 690       opt_access.set_ctl(gvn.transform(region));</span>
<span class="line-removed"> 691       val.set_node(gvn.transform(phi));</span>
<span class="line-removed"> 692     }</span>
 693     if (ShenandoahStoreValEnqueueBarrier) {
<a name="23" id="anc23"></a><span class="line-modified"> 694       const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(gvn.type(val.node()));</span>
<span class="line-removed"> 695       int alias = gvn.C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 696       Node* wb = new ShenandoahWriteBarrierNode(gvn.C, opt_access.ctl(), mm-&gt;memory_at(alias), val.node());</span>
<span class="line-removed"> 697       Node* wb_transformed = gvn.transform(wb);</span>
<span class="line-removed"> 698       Node* enqueue = gvn.transform(new ShenandoahEnqueueBarrierNode(wb_transformed));</span>
<span class="line-removed"> 699       if (wb_transformed == wb) {</span>
<span class="line-removed"> 700         Node* proj = gvn.transform(new ShenandoahWBMemProjNode(wb));</span>
<span class="line-removed"> 701         mm-&gt;set_memory_at(alias, proj);</span>
<span class="line-removed"> 702       }</span>
 703       val.set_node(enqueue);
 704     }
 705   }
 706   return BarrierSetC2::store_at_resolved(access, val);
 707 }
 708 
 709 Node* ShenandoahBarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
<a name="24" id="anc24"></a><span class="line-modified"> 710   DecoratorSet decorators = access.decorators();</span>
<span class="line-modified"> 711 </span>
<span class="line-modified"> 712   Node* adr = access.addr().node();</span>
<span class="line-modified"> 713   Node* obj = access.base();</span>
<span class="line-removed"> 714 </span>
<span class="line-removed"> 715   bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;</span>
<span class="line-removed"> 716   bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;</span>
<span class="line-removed"> 717   bool on_heap = (decorators &amp; IN_HEAP) != 0;</span>
<span class="line-removed"> 718   bool on_weak = (decorators &amp; ON_WEAK_OOP_REF) != 0;</span>
<span class="line-removed"> 719   bool is_unordered = (decorators &amp; MO_UNORDERED) != 0;</span>
<span class="line-removed"> 720   bool need_cpu_mem_bar = !is_unordered || mismatched || !on_heap;</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722   Node* top = Compile::current()-&gt;top();</span>
 723 
<a name="25" id="anc25"></a><span class="line-removed"> 724   Node* offset = adr-&gt;is_AddP() ? adr-&gt;in(AddPNode::Offset) : top;</span>
 725   Node* load = BarrierSetC2::load_at_resolved(access, val_type);
<a name="26" id="anc26"></a><span class="line-modified"> 726 </span>
<span class="line-modified"> 727   // If we are reading the value of the referent field of a Reference</span>
<span class="line-modified"> 728   // object (either by using Unsafe directly or through reflection)</span>
<span class="line-modified"> 729   // then, if SATB is enabled, we need to record the referent in an</span>
<span class="line-modified"> 730   // SATB log buffer using the pre-barrier mechanism.</span>
<span class="line-modified"> 731   // Also we need to add memory barrier to prevent commoning reads</span>
<span class="line-modified"> 732   // from this field across safepoint since GC can change its value.</span>
<span class="line-modified"> 733   bool need_read_barrier = ShenandoahKeepAliveBarrier &amp;&amp;</span>
<span class="line-modified"> 734     (on_heap &amp;&amp; (on_weak || (unknown &amp;&amp; offset != top &amp;&amp; obj != top)));</span>
<span class="line-modified"> 735 </span>
<span class="line-modified"> 736   if (!access.is_oop() || !need_read_barrier) {</span>
<span class="line-modified"> 737     return load;</span>

 738   }
 739 
<a name="27" id="anc27"></a><span class="line-modified"> 740   assert(access.is_parse_access(), &quot;entry not supported at optimization time&quot;);</span>
<span class="line-modified"> 741   C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);</span>
<span class="line-modified"> 742   GraphKit* kit = parse_access.kit();</span>
<span class="line-modified"> 743 </span>
<span class="line-modified"> 744   if (on_weak) {</span>
<span class="line-modified"> 745     // Use the pre-barrier to record the value in the referent field</span>
<span class="line-modified"> 746     satb_write_barrier_pre(kit, false /* do_load */,</span>
<span class="line-modified"> 747                            NULL /* obj */, NULL /* adr */, max_juint /* alias_idx */, NULL /* val */, NULL /* val_type */,</span>
<span class="line-modified"> 748                            load /* pre_val */, T_OBJECT);</span>
<span class="line-modified"> 749     // Add memory barrier to prevent commoning reads from this field</span>
<span class="line-modified"> 750     // across safepoint since GC can change its value.</span>
<span class="line-modified"> 751     kit-&gt;insert_mem_bar(Op_MemBarCPUOrder);</span>
<span class="line-modified"> 752   } else if (unknown) {</span>
<span class="line-modified"> 753     // We do not require a mem bar inside pre_barrier if need_mem_bar</span>
<span class="line-modified"> 754     // is set: the barriers would be emitted by us.</span>
<span class="line-modified"> 755     insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);</span>



























 756   }
 757 
 758   return load;
 759 }
 760 
 761 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 762                                                    Node* new_val, const Type* value_type) const {
 763   GraphKit* kit = access.kit();
 764   if (access.is_oop()) {
 765     new_val = shenandoah_storeval_barrier(kit, new_val);
 766     shenandoah_write_barrier_pre(kit, false /* do_load */,
 767                                  NULL, NULL, max_juint, NULL, NULL,
 768                                  expected_val /* pre_val */, T_OBJECT);
 769 
 770     MemNode::MemOrd mo = access.mem_node_mo();
 771     Node* mem = access.memory();
 772     Node* adr = access.addr().node();
 773     const TypePtr* adr_type = access.addr().type();
 774     Node* load_store = NULL;
 775 
 776 #ifdef _LP64
 777     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 778       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 779       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 780       if (ShenandoahCASBarrier) {
 781         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 782       } else {
 783         load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));
 784       }
 785     } else
 786 #endif
 787     {
 788       if (ShenandoahCASBarrier) {
 789         load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 790       } else {
 791         load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));
 792       }
 793     }
 794 
 795     access.set_raw_access(load_store);
 796     pin_atomic_op(access);
 797 
 798 #ifdef _LP64
 799     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
<a name="28" id="anc28"></a><span class="line-modified"> 800       return kit-&gt;gvn().transform(new DecodeNNode(load_store, load_store-&gt;get_ptr_type()));</span>
 801     }
 802 #endif
<a name="29" id="anc29"></a>
 803     return load_store;
 804   }
 805   return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);
 806 }
 807 
 808 Node* ShenandoahBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access, Node* expected_val,
 809                                                               Node* new_val, const Type* value_type) const {
 810   GraphKit* kit = access.kit();
 811   if (access.is_oop()) {
 812     new_val = shenandoah_storeval_barrier(kit, new_val);
 813     shenandoah_write_barrier_pre(kit, false /* do_load */,
 814                                  NULL, NULL, max_juint, NULL, NULL,
 815                                  expected_val /* pre_val */, T_OBJECT);
 816     DecoratorSet decorators = access.decorators();
 817     MemNode::MemOrd mo = access.mem_node_mo();
 818     Node* mem = access.memory();
 819     bool is_weak_cas = (decorators &amp; C2_WEAK_CMPXCHG) != 0;
 820     Node* load_store = NULL;
 821     Node* adr = access.addr().node();
 822 #ifdef _LP64
 823     if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
 824       Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
 825       Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
 826       if (ShenandoahCASBarrier) {
 827         if (is_weak_cas) {
 828           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 829         } else {
 830           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 831         }
 832       } else {
 833         if (is_weak_cas) {
 834           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 835         } else {
 836           load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));
 837         }
 838       }
 839     } else
 840 #endif
 841     {
 842       if (ShenandoahCASBarrier) {
 843         if (is_weak_cas) {
 844           load_store = kit-&gt;gvn().transform(new ShenandoahWeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 845         } else {
 846           load_store = kit-&gt;gvn().transform(new ShenandoahCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 847         }
 848       } else {
 849         if (is_weak_cas) {
 850           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 851         } else {
 852           load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));
 853         }
 854       }
 855     }
 856     access.set_raw_access(load_store);
 857     pin_atomic_op(access);
 858     return load_store;
 859   }
 860   return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);
 861 }
 862 
 863 Node* ShenandoahBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access, Node* val, const Type* value_type) const {
 864   GraphKit* kit = access.kit();
 865   if (access.is_oop()) {
 866     val = shenandoah_storeval_barrier(kit, val);
 867   }
 868   Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, val, value_type);
 869   if (access.is_oop()) {
<a name="30" id="anc30"></a>
 870     shenandoah_write_barrier_pre(kit, false /* do_load */,
 871                                  NULL, NULL, max_juint, NULL, NULL,
 872                                  result /* pre_val */, T_OBJECT);
 873   }
 874   return result;
 875 }
 876 
<a name="31" id="anc31"></a><span class="line-removed"> 877 void ShenandoahBarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {</span>
<span class="line-removed"> 878   assert(!src-&gt;is_AddP(), &quot;unexpected input&quot;);</span>
<span class="line-removed"> 879   src = shenandoah_read_barrier(kit, src);</span>
<span class="line-removed"> 880   BarrierSetC2::clone(kit, src, dst, size, is_array);</span>
<span class="line-removed"> 881 }</span>
<span class="line-removed"> 882 </span>
<span class="line-removed"> 883 Node* ShenandoahBarrierSetC2::resolve(GraphKit* kit, Node* n, DecoratorSet decorators) const {</span>
<span class="line-removed"> 884   bool is_write = decorators &amp; ACCESS_WRITE;</span>
<span class="line-removed"> 885   if (is_write) {</span>
<span class="line-removed"> 886     return shenandoah_write_barrier(kit, n);</span>
<span class="line-removed"> 887   } else {</span>
<span class="line-removed"> 888   return shenandoah_read_barrier(kit, n);</span>
<span class="line-removed"> 889   }</span>
<span class="line-removed"> 890 }</span>
<span class="line-removed"> 891 </span>
<span class="line-removed"> 892 Node* ShenandoahBarrierSetC2::obj_allocate(PhaseMacroExpand* macro, Node* ctrl, Node* mem, Node* toobig_false, Node* size_in_bytes,</span>
<span class="line-removed"> 893                                            Node*&amp; i_o, Node*&amp; needgc_ctrl,</span>
<span class="line-removed"> 894                                            Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem,</span>
<span class="line-removed"> 895                                            intx prefetch_lines) const {</span>
<span class="line-removed"> 896   PhaseIterGVN&amp; igvn = macro-&gt;igvn();</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898   // Allocate several words more for the Shenandoah brooks pointer.</span>
<span class="line-removed"> 899   size_in_bytes = new AddXNode(size_in_bytes, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));</span>
<span class="line-removed"> 900   macro-&gt;transform_later(size_in_bytes);</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902   Node* fast_oop = BarrierSetC2::obj_allocate(macro, ctrl, mem, toobig_false, size_in_bytes,</span>
<span class="line-removed"> 903                                               i_o, needgc_ctrl, fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="line-removed"> 904                                               prefetch_lines);</span>
<span class="line-removed"> 905 </span>
<span class="line-removed"> 906   // Bump up object for Shenandoah brooks pointer.</span>
<span class="line-removed"> 907   fast_oop = new AddPNode(macro-&gt;top(), fast_oop, igvn.MakeConX(ShenandoahBrooksPointer::byte_size()));</span>
<span class="line-removed"> 908   macro-&gt;transform_later(fast_oop);</span>
<span class="line-removed"> 909 </span>
<span class="line-removed"> 910   // Initialize Shenandoah brooks pointer to point to the object itself.</span>
<span class="line-removed"> 911   fast_oop_rawmem = macro-&gt;make_store(fast_oop_ctrl, fast_oop_rawmem, fast_oop, ShenandoahBrooksPointer::byte_offset(), fast_oop, T_OBJECT);</span>
<span class="line-removed"> 912 </span>
<span class="line-removed"> 913   return fast_oop;</span>
<span class="line-removed"> 914 }</span>
<span class="line-removed"> 915 </span>
 916 // Support for GC barriers emitted during parsing
 917 bool ShenandoahBarrierSetC2::is_gc_barrier_node(Node* node) const {
<a name="32" id="anc32"></a>
 918   if (node-&gt;Opcode() != Op_CallLeaf &amp;&amp; node-&gt;Opcode() != Op_CallLeafNoFP) {
 919     return false;
 920   }
 921   CallLeafNode *call = node-&gt;as_CallLeaf();
 922   if (call-&gt;_name == NULL) {
 923     return false;
 924   }
 925 
 926   return strcmp(call-&gt;_name, &quot;shenandoah_clone_barrier&quot;) == 0 ||
 927          strcmp(call-&gt;_name, &quot;shenandoah_cas_obj&quot;) == 0 ||
 928          strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;) == 0;
 929 }
 930 
 931 Node* ShenandoahBarrierSetC2::step_over_gc_barrier(Node* c) const {
<a name="33" id="anc33"></a><span class="line-modified"> 932   return ShenandoahBarrierNode::skip_through_barrier(c);</span>









 933 }
 934 
 935 bool ShenandoahBarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const {
<a name="34" id="anc34"></a><span class="line-modified"> 936   return !ShenandoahWriteBarrierNode::expand(C, igvn);</span>
 937 }
 938 
 939 bool ShenandoahBarrierSetC2::optimize_loops(PhaseIdealLoop* phase, LoopOptsMode mode, VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; worklist) const {
 940   if (mode == LoopOptsShenandoahExpand) {
 941     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<a name="35" id="anc35"></a><span class="line-modified"> 942     ShenandoahWriteBarrierNode::pin_and_expand(phase);</span>
 943     return true;
 944   } else if (mode == LoopOptsShenandoahPostExpand) {
 945     assert(UseShenandoahGC, &quot;only for shenandoah&quot;);
<a name="36" id="anc36"></a><span class="line-modified"> 946     visited.Clear();</span>
<span class="line-modified"> 947     ShenandoahWriteBarrierNode::optimize_after_expansion(visited, nstack, worklist, phase);</span>
 948     return true;
 949   }
<a name="37" id="anc37"></a><span class="line-removed"> 950   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;</span>
<span class="line-removed"> 951   ShenandoahWriteBarrierNode::optimize_before_expansion(phase, memory_graph_fixers, false);</span>
 952   return false;
 953 }
 954 
 955 bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
<a name="38" id="anc38"></a><span class="line-modified"> 956   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
 957   if (!is_oop) {
 958     return false;
 959   }
<a name="39" id="anc39"></a><span class="line-removed"> 960 </span>
 961   if (tightly_coupled_alloc) {
 962     if (phase == Optimization) {
 963       return false;
 964     }
 965     return !is_clone;
 966   }
 967   if (phase == Optimization) {
 968     return !ShenandoahStoreValEnqueueBarrier;
 969   }
 970   return true;
 971 }
 972 
<a name="40" id="anc40"></a><span class="line-modified"> 973 bool ShenandoahBarrierSetC2::clone_needs_postbarrier(ArrayCopyNode *ac, PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified"> 974   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-removed"> 975   const TypeOopPtr* src_type = igvn.type(src)-&gt;is_oopptr();</span>
 976   if (src_type-&gt;isa_instptr() != NULL) {
 977     ciInstanceKlass* ik = src_type-&gt;klass()-&gt;as_instance_klass();
 978     if ((src_type-&gt;klass_is_exact() || (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass())) &amp;&amp; !ik-&gt;has_injected_fields()) {
 979       if (ik-&gt;has_object_fields()) {
 980         return true;
 981       } else {
 982         if (!src_type-&gt;klass_is_exact()) {
<a name="41" id="anc41"></a><span class="line-modified"> 983           igvn.C-&gt;dependencies()-&gt;assert_leaf_type(ik);</span>
 984         }
 985       }
 986     } else {
 987       return true;
<a name="42" id="anc42"></a><span class="line-modified"> 988     }</span>
 989   } else if (src_type-&gt;isa_aryptr()) {
 990     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<a name="43" id="anc43"></a><span class="line-modified"> 991     if (src_elem == T_OBJECT || src_elem == T_ARRAY) {</span>
 992       return true;
 993     }
 994   } else {
 995     return true;
 996   }
 997   return false;
 998 }
 999 
<a name="44" id="anc44"></a><span class="line-modified">1000 void ShenandoahBarrierSetC2::clone_barrier_at_expansion(ArrayCopyNode* ac, Node* call, PhaseIterGVN&amp; igvn) const {</span>
<span class="line-modified">1001   assert(ac-&gt;is_clonebasic(), &quot;no other kind of arraycopy here&quot;);</span>
<span class="line-modified">1002 </span>
<span class="line-modified">1003   if (!clone_needs_postbarrier(ac, igvn)) {</span>
<span class="line-modified">1004     BarrierSetC2::clone_barrier_at_expansion(ac, call, igvn);</span>
<span class="line-removed">1005     return;</span>
<span class="line-removed">1006   }</span>
<span class="line-removed">1007 </span>
<span class="line-removed">1008   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
<span class="line-removed">1009   Node* c = new ProjNode(call,TypeFunc::Control);</span>
<span class="line-removed">1010   c = igvn.transform(c);</span>
<span class="line-removed">1011   Node* m = new ProjNode(call, TypeFunc::Memory);</span>
<span class="line-removed">1012   m = igvn.transform(m);</span>
<span class="line-removed">1013 </span>
1014   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
<a name="45" id="anc45"></a><span class="line-modified">1015   assert(dest-&gt;is_AddP(), &quot;bad input&quot;);</span>
<span class="line-modified">1016   Node* barrier_call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),</span>
<span class="line-modified">1017                                         CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),</span>
<span class="line-modified">1018                                         &quot;shenandoah_clone_barrier&quot;, raw_adr_type);</span>
<span class="line-modified">1019   barrier_call-&gt;init_req(TypeFunc::Control, c);</span>
<span class="line-modified">1020   barrier_call-&gt;init_req(TypeFunc::I_O    , igvn.C-&gt;top());</span>
<span class="line-modified">1021   barrier_call-&gt;init_req(TypeFunc::Memory , m);</span>
<span class="line-modified">1022   barrier_call-&gt;init_req(TypeFunc::ReturnAdr, igvn.C-&gt;top());</span>
<span class="line-modified">1023   barrier_call-&gt;init_req(TypeFunc::FramePtr, igvn.C-&gt;top());</span>
<span class="line-modified">1024   barrier_call-&gt;init_req(TypeFunc::Parms+0, dest-&gt;in(AddPNode::Base));</span>
<span class="line-modified">1025 </span>
<span class="line-modified">1026   barrier_call = igvn.transform(barrier_call);</span>
<span class="line-modified">1027   c = new ProjNode(barrier_call,TypeFunc::Control);</span>
<span class="line-modified">1028   c = igvn.transform(c);</span>
<span class="line-modified">1029   m = new ProjNode(barrier_call, TypeFunc::Memory);</span>
<span class="line-modified">1030   m = igvn.transform(m);</span>
<span class="line-modified">1031 </span>
<span class="line-modified">1032   Node* out_c = ac-&gt;proj_out(TypeFunc::Control);</span>
<span class="line-modified">1033   Node* out_m = ac-&gt;proj_out(TypeFunc::Memory);</span>
<span class="line-modified">1034   igvn.replace_node(out_c, c);</span>
<span class="line-modified">1035   igvn.replace_node(out_m, m);</span>














































1036 }
1037 
1038 
1039 // Support for macro expanded GC barriers
1040 void ShenandoahBarrierSetC2::register_potential_barrier_node(Node* node) const {
<a name="46" id="anc46"></a><span class="line-modified">1041   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-modified">1042     state()-&gt;add_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);</span>



1043   }
1044 }
1045 
1046 void ShenandoahBarrierSetC2::unregister_potential_barrier_node(Node* node) const {
<a name="47" id="anc47"></a><span class="line-modified">1047   if (node-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-modified">1048     state()-&gt;remove_shenandoah_barrier((ShenandoahWriteBarrierNode*) node);</span>



1049   }
1050 }
1051 
1052 void ShenandoahBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* n) const {
1053   if (is_shenandoah_wb_pre_call(n)) {
1054     shenandoah_eliminate_wb_pre(n, &amp;macro-&gt;igvn());
1055   }
1056 }
1057 
1058 void ShenandoahBarrierSetC2::shenandoah_eliminate_wb_pre(Node* call, PhaseIterGVN* igvn) const {
1059   assert(UseShenandoahGC &amp;&amp; is_shenandoah_wb_pre_call(call), &quot;&quot;);
1060   Node* c = call-&gt;as_Call()-&gt;proj_out(TypeFunc::Control);
1061   c = c-&gt;unique_ctrl_out();
1062   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1063   c = c-&gt;unique_ctrl_out();
1064   assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1065   Node* iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
1066   assert(iff-&gt;is_If(), &quot;expect test&quot;);
1067   if (!is_shenandoah_marking_if(igvn, iff)) {
1068     c = c-&gt;unique_ctrl_out();
1069     assert(c-&gt;is_Region() &amp;&amp; c-&gt;req() == 3, &quot;where&#39;s the pre barrier control flow?&quot;);
1070     iff = c-&gt;in(1)-&gt;is_IfProj() ? c-&gt;in(1)-&gt;in(0) : c-&gt;in(2)-&gt;in(0);
1071     assert(is_shenandoah_marking_if(igvn, iff), &quot;expect marking test&quot;);
1072   }
1073   Node* cmpx = iff-&gt;in(1)-&gt;in(1);
1074   igvn-&gt;replace_node(cmpx, igvn-&gt;makecon(TypeInt::CC_EQ));
1075   igvn-&gt;rehash_node_delayed(call);
1076   call-&gt;del_req(call-&gt;req()-1);
1077 }
1078 
1079 void ShenandoahBarrierSetC2::enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const {
1080   if (node-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(node)) {
1081     igvn-&gt;add_users_to_worklist(node);
1082   }
1083 }
1084 
1085 void ShenandoahBarrierSetC2::eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const {
1086   for (uint i = 0; i &lt; useful.size(); i++) {
1087     Node* n = useful.at(i);
1088     if (n-&gt;Opcode() == Op_AddP &amp;&amp; ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(n)) {
1089       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1090         C-&gt;record_for_igvn(n-&gt;fast_out(i));
1091       }
1092     }
1093   }
<a name="48" id="anc48"></a><span class="line-modified">1094   for (int i = state()-&gt;shenandoah_barriers_count()-1; i &gt;= 0; i--) {</span>
<span class="line-modified">1095     ShenandoahWriteBarrierNode* n = state()-&gt;shenandoah_barrier(i);</span>
1096     if (!useful.member(n)) {
<a name="49" id="anc49"></a><span class="line-modified">1097       state()-&gt;remove_shenandoah_barrier(n);</span>






1098     }
1099   }
<a name="50" id="anc50"></a><span class="line-removed">1100 </span>
<span class="line-removed">1101 }</span>
<span class="line-removed">1102 </span>
<span class="line-removed">1103 bool ShenandoahBarrierSetC2::has_special_unique_user(const Node* node) const {</span>
<span class="line-removed">1104   assert(node-&gt;outcnt() == 1, &quot;match only for unique out&quot;);</span>
<span class="line-removed">1105   Node* n = node-&gt;unique_out();</span>
<span class="line-removed">1106   return node-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; n-&gt;Opcode() == Op_ShenandoahWBMemProj;</span>
1107 }
1108 
<a name="51" id="anc51"></a><span class="line-removed">1109 void ShenandoahBarrierSetC2::add_users_to_worklist(Unique_Node_List* worklist) const {}</span>
<span class="line-removed">1110 </span>
1111 void* ShenandoahBarrierSetC2::create_barrier_state(Arena* comp_arena) const {
1112   return new(comp_arena) ShenandoahBarrierSetC2State(comp_arena);
1113 }
1114 
1115 ShenandoahBarrierSetC2State* ShenandoahBarrierSetC2::state() const {
1116   return reinterpret_cast&lt;ShenandoahBarrierSetC2State*&gt;(Compile::current()-&gt;barrier_set_state());
1117 }
1118 
1119 // If the BarrierSetC2 state has kept macro nodes in its compilation unit state to be
1120 // expanded later, then now is the time to do so.
1121 bool ShenandoahBarrierSetC2::expand_macro_nodes(PhaseMacroExpand* macro) const { return false; }
1122 
1123 #ifdef ASSERT
1124 void ShenandoahBarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {
<a name="52" id="anc52"></a><span class="line-modified">1125   if (ShenandoahVerifyOptoBarriers &amp;&amp; phase == BarrierSetC2::BeforeExpand) {</span>
<span class="line-modified">1126     ShenandoahBarrierNode::verify(Compile::current()-&gt;root());</span>
1127   } else if (phase == BarrierSetC2::BeforeCodeGen) {
1128     // Verify G1 pre-barriers
1129     const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());
1130 
1131     ResourceArea *area = Thread::current()-&gt;resource_area();
1132     Unique_Node_List visited(area);
1133     Node_List worklist(area);
1134     // We&#39;re going to walk control flow backwards starting from the Root
1135     worklist.push(compile-&gt;root());
1136     while (worklist.size() &gt; 0) {
1137       Node *x = worklist.pop();
1138       if (x == NULL || x == compile-&gt;top()) continue;
1139       if (visited.member(x)) {
1140         continue;
1141       } else {
1142         visited.push(x);
1143       }
1144 
1145       if (x-&gt;is_Region()) {
1146         for (uint i = 1; i &lt; x-&gt;req(); i++) {
1147           worklist.push(x-&gt;in(i));
1148         }
1149       } else {
1150         worklist.push(x-&gt;in(0));
1151         // We are looking for the pattern:
1152         //                            /-&gt;ThreadLocal
1153         // If-&gt;Bool-&gt;CmpI-&gt;LoadB-&gt;AddP-&gt;ConL(marking_offset)
1154         //              \-&gt;ConI(0)
1155         // We want to verify that the If and the LoadB have the same control
1156         // See GraphKit::g1_write_barrier_pre()
1157         if (x-&gt;is_If()) {
1158           IfNode *iff = x-&gt;as_If();
1159           if (iff-&gt;in(1)-&gt;is_Bool() &amp;&amp; iff-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {
1160             CmpNode *cmp = iff-&gt;in(1)-&gt;in(1)-&gt;as_Cmp();
1161             if (cmp-&gt;Opcode() == Op_CmpI &amp;&amp; cmp-&gt;in(2)-&gt;is_Con() &amp;&amp; cmp-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0
1162                 &amp;&amp; cmp-&gt;in(1)-&gt;is_Load()) {
1163               LoadNode *load = cmp-&gt;in(1)-&gt;as_Load();
1164               if (load-&gt;Opcode() == Op_LoadB &amp;&amp; load-&gt;in(2)-&gt;is_AddP() &amp;&amp; load-&gt;in(2)-&gt;in(2)-&gt;Opcode() == Op_ThreadLocal
1165                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;is_Con()
1166                   &amp;&amp; load-&gt;in(2)-&gt;in(3)-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() == marking_offset) {
1167 
1168                 Node *if_ctrl = iff-&gt;in(0);
1169                 Node *load_ctrl = load-&gt;in(0);
1170 
1171                 if (if_ctrl != load_ctrl) {
1172                   // Skip possible CProj-&gt;NeverBranch in infinite loops
1173                   if ((if_ctrl-&gt;is_Proj() &amp;&amp; if_ctrl-&gt;Opcode() == Op_CProj)
1174                       &amp;&amp; (if_ctrl-&gt;in(0)-&gt;is_MultiBranch() &amp;&amp; if_ctrl-&gt;in(0)-&gt;Opcode() == Op_NeverBranch)) {
1175                     if_ctrl = if_ctrl-&gt;in(0)-&gt;in(0);
1176                   }
1177                 }
1178                 assert(load_ctrl != NULL &amp;&amp; if_ctrl == load_ctrl, &quot;controls must match&quot;);
1179               }
1180             }
1181           }
1182         }
1183       }
1184     }
1185   }
1186 }
1187 #endif
1188 
1189 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1190   if (is_shenandoah_wb_pre_call(n)) {
1191     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1192     if (n-&gt;req() &gt; cnt) {
1193       Node* addp = n-&gt;in(cnt);
1194       if (has_only_shenandoah_wb_pre_uses(addp)) {
1195         n-&gt;del_req(cnt);
1196         if (can_reshape) {
1197           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1198         }
1199         return n;
1200       }
1201     }
1202   }
1203   if (n-&gt;Opcode() == Op_CmpP) {
1204     Node* in1 = n-&gt;in(1);
1205     Node* in2 = n-&gt;in(2);
1206     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {
1207       in2 = step_over_gc_barrier(in2);
1208     }
1209     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {
1210       in1 = step_over_gc_barrier(in1);
1211     }
1212     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
1213     if (in1 != n-&gt;in(1)) {
1214       if (igvn != NULL) {
1215         n-&gt;set_req_X(1, in1, igvn);
1216       } else {
1217         n-&gt;set_req(1, in1);
1218       }
1219       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);
1220       return n;
1221     }
1222     if (in2 != n-&gt;in(2)) {
1223       if (igvn != NULL) {
1224         n-&gt;set_req_X(2, in2, igvn);
1225       } else {
1226         n-&gt;set_req(2, in2);
1227       }
1228       return n;
1229     }
1230   } else if (can_reshape &amp;&amp;
1231              n-&gt;Opcode() == Op_If &amp;&amp;
<a name="53" id="anc53"></a><span class="line-modified">1232              ShenandoahWriteBarrierNode::is_heap_stable_test(n) &amp;&amp;</span>
1233              n-&gt;in(0) != NULL) {
1234     Node* dom = n-&gt;in(0);
1235     Node* prev_dom = n;
1236     int op = n-&gt;Opcode();
1237     int dist = 16;
1238     // Search up the dominator tree for another heap stable test
1239     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
<a name="54" id="anc54"></a><span class="line-modified">1240            !ShenandoahWriteBarrierNode::is_heap_stable_test(dom) ||  // Not same input 1?</span>
1241            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1242       if (dist &lt; 0) return NULL;
1243 
1244       dist--;
1245       prev_dom = dom;
1246       dom = IfNode::up_one_dom(dom);
1247       if (!dom) return NULL;
1248     }
1249 
1250     // Check that we did not follow a loop back to ourselves
1251     if (n == dom) {
1252       return NULL;
1253     }
1254 
1255     return n-&gt;as_If()-&gt;dominated_by(prev_dom, phase-&gt;is_IterGVN());
1256   }
1257 
1258   return NULL;
1259 }
1260 
<a name="55" id="anc55"></a><span class="line-removed">1261 Node* ShenandoahBarrierSetC2::identity_node(PhaseGVN* phase, Node* n) const {</span>
<span class="line-removed">1262   if (n-&gt;is_Load()) {</span>
<span class="line-removed">1263     Node *mem = n-&gt;in(MemNode::Memory);</span>
<span class="line-removed">1264     Node *value = n-&gt;as_Load()-&gt;can_see_stored_value(mem, phase);</span>
<span class="line-removed">1265     if (value) {</span>
<span class="line-removed">1266       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed">1267       if (igvn != NULL &amp;&amp;</span>
<span class="line-removed">1268           value-&gt;is_Phi() &amp;&amp;</span>
<span class="line-removed">1269           value-&gt;req() &gt; 2 &amp;&amp;</span>
<span class="line-removed">1270           value-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">1271           value-&gt;in(1)-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1272         if (igvn-&gt;_worklist.member(value) ||</span>
<span class="line-removed">1273             igvn-&gt;_worklist.member(value-&gt;in(0)) ||</span>
<span class="line-removed">1274             (value-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">1275              value-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-removed">1276              (igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)) ||</span>
<span class="line-removed">1277               (value-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">1278                igvn-&gt;_worklist.member(value-&gt;in(0)-&gt;in(1)-&gt;in(0)))))) {</span>
<span class="line-removed">1279           igvn-&gt;_worklist.push(n);</span>
<span class="line-removed">1280           return n;</span>
<span class="line-removed">1281         }</span>
<span class="line-removed">1282       }</span>
<span class="line-removed">1283       // (This works even when value is a Con, but LoadNode::Value</span>
<span class="line-removed">1284       // usually runs first, producing the singleton type of the Con.)</span>
<span class="line-removed">1285       Node *value_no_barrier = step_over_gc_barrier(value-&gt;Opcode() == Op_EncodeP ? value-&gt;in(1) : value);</span>
<span class="line-removed">1286       if (value-&gt;Opcode() == Op_EncodeP) {</span>
<span class="line-removed">1287         if (value_no_barrier != value-&gt;in(1)) {</span>
<span class="line-removed">1288           Node *encode = value-&gt;clone();</span>
<span class="line-removed">1289           encode-&gt;set_req(1, value_no_barrier);</span>
<span class="line-removed">1290           encode = phase-&gt;transform(encode);</span>
<span class="line-removed">1291           return encode;</span>
<span class="line-removed">1292         }</span>
<span class="line-removed">1293       } else {</span>
<span class="line-removed">1294         return value_no_barrier;</span>
<span class="line-removed">1295       }</span>
<span class="line-removed">1296     }</span>
<span class="line-removed">1297   }</span>
<span class="line-removed">1298   return n;</span>
<span class="line-removed">1299 }</span>
<span class="line-removed">1300 </span>
1301 bool ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(Node* n) {
1302   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1303     Node* u = n-&gt;fast_out(i);
1304     if (!is_shenandoah_wb_pre_call(u)) {
1305       return false;
1306     }
1307   }
1308   return n-&gt;outcnt() &gt; 0;
1309 }
1310 
<a name="56" id="anc56"></a><span class="line-removed">1311 bool ShenandoahBarrierSetC2::flatten_gc_alias_type(const TypePtr*&amp; adr_type) const {</span>
<span class="line-removed">1312   int offset = adr_type-&gt;offset();</span>
<span class="line-removed">1313   if (offset == ShenandoahBrooksPointer::byte_offset()) {</span>
<span class="line-removed">1314     if (adr_type-&gt;isa_aryptr()) {</span>
<span class="line-removed">1315       adr_type = TypeAryPtr::make(adr_type-&gt;ptr(), adr_type-&gt;isa_aryptr()-&gt;ary(), adr_type-&gt;isa_aryptr()-&gt;klass(), false, offset);</span>
<span class="line-removed">1316     } else if (adr_type-&gt;isa_instptr()) {</span>
<span class="line-removed">1317       adr_type = TypeInstPtr::make(adr_type-&gt;ptr(), ciEnv::current()-&gt;Object_klass(), false, NULL, offset);</span>
<span class="line-removed">1318     }</span>
<span class="line-removed">1319     return true;</span>
<span class="line-removed">1320   } else {</span>
<span class="line-removed">1321     return false;</span>
<span class="line-removed">1322   }</span>
<span class="line-removed">1323 }</span>
<span class="line-removed">1324 </span>
1325 bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {
1326   switch (opcode) {
1327     case Op_CallLeaf:
1328     case Op_CallLeafNoFP: {
1329       assert (n-&gt;is_Call(), &quot;&quot;);
1330       CallNode *call = n-&gt;as_Call();
1331       if (ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(call)) {
1332         uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1333         if (call-&gt;req() &gt; cnt) {
1334           assert(call-&gt;req() == cnt + 1, &quot;only one extra input&quot;);
1335           Node *addp = call-&gt;in(cnt);
1336           assert(!ShenandoahBarrierSetC2::has_only_shenandoah_wb_pre_uses(addp), &quot;useless address computation?&quot;);
1337           call-&gt;del_req(cnt);
1338         }
1339       }
1340       return false;
1341     }
1342     case Op_ShenandoahCompareAndSwapP:
1343     case Op_ShenandoahCompareAndSwapN:
1344     case Op_ShenandoahWeakCompareAndSwapN:
1345     case Op_ShenandoahWeakCompareAndSwapP:
1346     case Op_ShenandoahCompareAndExchangeP:
1347     case Op_ShenandoahCompareAndExchangeN:
1348 #ifdef ASSERT
1349       if( VerifyOptoOopOffsets ) {
1350         MemNode* mem  = n-&gt;as_Mem();
1351         // Check to see if address types have grounded out somehow.
1352         const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
1353         ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
1354         bool oop_offset_is_sane = k-&gt;contains_field_offset(tp-&gt;offset());
1355         assert( !tp || oop_offset_is_sane, &quot;&quot; );
1356       }
1357 #endif
1358       return true;
<a name="57" id="anc57"></a><span class="line-modified">1359     case Op_ShenandoahReadBarrier:</span>
<span class="line-removed">1360       return true;</span>
<span class="line-removed">1361     case Op_ShenandoahWriteBarrier:</span>
1362       assert(false, &quot;should have been expanded already&quot;);
1363       return true;
1364     default:
1365       return false;
1366   }
1367 }
1368 
<a name="58" id="anc58"></a><span class="line-removed">1369 #ifdef ASSERT</span>
<span class="line-removed">1370 bool ShenandoahBarrierSetC2::verify_gc_alias_type(const TypePtr* adr_type, int offset) const {</span>
<span class="line-removed">1371   if (offset == ShenandoahBrooksPointer::byte_offset() &amp;&amp;</span>
<span class="line-removed">1372       (adr_type-&gt;base() == Type::AryPtr || adr_type-&gt;base() == Type::OopPtr)) {</span>
<span class="line-removed">1373     return true;</span>
<span class="line-removed">1374   } else {</span>
<span class="line-removed">1375     return false;</span>
<span class="line-removed">1376   }</span>
<span class="line-removed">1377 }</span>
<span class="line-removed">1378 #endif</span>
<span class="line-removed">1379 </span>
1380 bool ShenandoahBarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {
1381   switch (opcode) {
1382     case Op_ShenandoahCompareAndExchangeP:
1383     case Op_ShenandoahCompareAndExchangeN:
1384       conn_graph-&gt;add_objload_to_connection_graph(n, delayed_worklist);
1385       // fallthrough
1386     case Op_ShenandoahWeakCompareAndSwapP:
1387     case Op_ShenandoahWeakCompareAndSwapN:
1388     case Op_ShenandoahCompareAndSwapP:
1389     case Op_ShenandoahCompareAndSwapN:
1390       conn_graph-&gt;add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
1391       return true;
1392     case Op_StoreP: {
1393       Node* adr = n-&gt;in(MemNode::Address);
1394       const Type* adr_type = gvn-&gt;type(adr);
1395       // Pointer stores in G1 barriers looks like unsafe access.
1396       // Ignore such stores to be able scalar replace non-escaping
1397       // allocations.
1398       if (adr_type-&gt;isa_rawptr() &amp;&amp; adr-&gt;is_AddP()) {
1399         Node* base = conn_graph-&gt;get_addp_base(adr);
1400         if (base-&gt;Opcode() == Op_LoadP &amp;&amp;
1401           base-&gt;in(MemNode::Address)-&gt;is_AddP()) {
1402           adr = base-&gt;in(MemNode::Address);
1403           Node* tls = conn_graph-&gt;get_addp_base(adr);
1404           if (tls-&gt;Opcode() == Op_ThreadLocal) {
1405              int offs = (int) gvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
1406              const int buf_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
1407              if (offs == buf_offset) {
1408                return true; // Pre barrier previous oop value store.
1409              }
1410           }
1411         }
1412       }
1413       return false;
1414     }
<a name="59" id="anc59"></a><span class="line-removed">1415     case Op_ShenandoahReadBarrier:</span>
<span class="line-removed">1416     case Op_ShenandoahWriteBarrier:</span>
<span class="line-removed">1417       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.</span>
<span class="line-removed">1418       // It doesn&#39;t escape.</span>
<span class="line-removed">1419       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), delayed_worklist);</span>
<span class="line-removed">1420       break;</span>
1421     case Op_ShenandoahEnqueueBarrier:
1422       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), delayed_worklist);
1423       break;
<a name="60" id="anc60"></a>


1424     default:
1425       // Nothing
1426       break;
1427   }
1428   return false;
1429 }
1430 
1431 bool ShenandoahBarrierSetC2::escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const {
1432   switch (opcode) {
1433     case Op_ShenandoahCompareAndExchangeP:
1434     case Op_ShenandoahCompareAndExchangeN: {
1435       Node *adr = n-&gt;in(MemNode::Address);
1436       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
1437       // fallthrough
1438     }
1439     case Op_ShenandoahCompareAndSwapP:
1440     case Op_ShenandoahCompareAndSwapN:
1441     case Op_ShenandoahWeakCompareAndSwapP:
1442     case Op_ShenandoahWeakCompareAndSwapN:
1443       return conn_graph-&gt;add_final_edges_unsafe_access(n, opcode);
<a name="61" id="anc61"></a><span class="line-removed">1444     case Op_ShenandoahReadBarrier:</span>
<span class="line-removed">1445     case Op_ShenandoahWriteBarrier:</span>
<span class="line-removed">1446       // Barriers &#39;pass through&#39; its arguments. I.e. what goes in, comes out.</span>
<span class="line-removed">1447       // It doesn&#39;t escape.</span>
<span class="line-removed">1448       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(ShenandoahBarrierNode::ValueIn), NULL);</span>
<span class="line-removed">1449       return true;</span>
1450     case Op_ShenandoahEnqueueBarrier:
1451       conn_graph-&gt;add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(1), NULL);
1452       return true;
<a name="62" id="anc62"></a>


1453     default:
1454       // Nothing
1455       break;
1456   }
1457   return false;
1458 }
1459 
1460 bool ShenandoahBarrierSetC2::escape_has_out_with_unsafe_object(Node* n) const {
1461   return n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeP) || n-&gt;has_out_with(Op_ShenandoahCompareAndExchangeN) ||
1462          n-&gt;has_out_with(Op_ShenandoahCompareAndSwapP, Op_ShenandoahCompareAndSwapN, Op_ShenandoahWeakCompareAndSwapP, Op_ShenandoahWeakCompareAndSwapN);
1463 
1464 }
1465 
<a name="63" id="anc63"></a><span class="line-removed">1466 bool ShenandoahBarrierSetC2::escape_is_barrier_node(Node* n) const {</span>
<span class="line-removed">1467   return n-&gt;is_ShenandoahBarrier();</span>
<span class="line-removed">1468 }</span>
<span class="line-removed">1469 </span>
<span class="line-removed">1470 bool ShenandoahBarrierSetC2::matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const {</span>
<span class="line-removed">1471   switch (opcode) {</span>
<span class="line-removed">1472     case Op_ShenandoahReadBarrier:</span>
<span class="line-removed">1473       if (n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;is_DecodeNarrowPtr()) {</span>
<span class="line-removed">1474         matcher-&gt;set_shared(n-&gt;in(ShenandoahBarrierNode::ValueIn)-&gt;in(1));</span>
<span class="line-removed">1475       }</span>
<span class="line-removed">1476       matcher-&gt;set_shared(n);</span>
<span class="line-removed">1477       return true;</span>
<span class="line-removed">1478     default:</span>
<span class="line-removed">1479       break;</span>
<span class="line-removed">1480   }</span>
<span class="line-removed">1481   return false;</span>
<span class="line-removed">1482 }</span>
<span class="line-removed">1483 </span>
1484 bool ShenandoahBarrierSetC2::matcher_find_shared_post_visit(Matcher* matcher, Node* n, uint opcode) const {
1485   switch (opcode) {
1486     case Op_ShenandoahCompareAndExchangeP:
1487     case Op_ShenandoahCompareAndExchangeN:
1488     case Op_ShenandoahWeakCompareAndSwapP:
1489     case Op_ShenandoahWeakCompareAndSwapN:
1490     case Op_ShenandoahCompareAndSwapP:
1491     case Op_ShenandoahCompareAndSwapN: {   // Convert trinary to binary-tree
1492       Node* newval = n-&gt;in(MemNode::ValueIn);
1493       Node* oldval = n-&gt;in(LoadStoreConditionalNode::ExpectedIn);
1494       Node* pair = new BinaryNode(oldval, newval);
1495       n-&gt;set_req(MemNode::ValueIn,pair);
1496       n-&gt;del_req(LoadStoreConditionalNode::ExpectedIn);
1497       return true;
1498     }
1499     default:
1500       break;
1501   }
1502   return false;
1503 }
1504 
1505 bool ShenandoahBarrierSetC2::matcher_is_store_load_barrier(Node* x, uint xop) const {
1506   return xop == Op_ShenandoahCompareAndExchangeP ||
1507          xop == Op_ShenandoahCompareAndExchangeN ||
1508          xop == Op_ShenandoahWeakCompareAndSwapP ||
1509          xop == Op_ShenandoahWeakCompareAndSwapN ||
1510          xop == Op_ShenandoahCompareAndSwapN ||
1511          xop == Op_ShenandoahCompareAndSwapP;
1512 }
<a name="64" id="anc64"></a><span class="line-removed">1513 </span>
<span class="line-removed">1514 void ShenandoahBarrierSetC2::igvn_add_users_to_worklist(PhaseIterGVN* igvn, Node* use) const {</span>
<span class="line-removed">1515   if (use-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1516     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {</span>
<span class="line-removed">1517       Node* u = use-&gt;fast_out(i2);</span>
<span class="line-removed">1518       Node* cmp = use-&gt;find_out_with(Op_CmpP);</span>
<span class="line-removed">1519       if (u-&gt;Opcode() == Op_CmpP) {</span>
<span class="line-removed">1520         igvn-&gt;_worklist.push(cmp);</span>
<span class="line-removed">1521       }</span>
<span class="line-removed">1522     }</span>
<span class="line-removed">1523   }</span>
<span class="line-removed">1524 }</span>
<span class="line-removed">1525 </span>
<span class="line-removed">1526 void ShenandoahBarrierSetC2::ccp_analyze(PhaseCCP* ccp, Unique_Node_List&amp; worklist, Node* use) const {</span>
<span class="line-removed">1527   if (use-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1528     for (DUIterator_Fast i2max, i2 = use-&gt;fast_outs(i2max); i2 &lt; i2max; i2++) {</span>
<span class="line-removed">1529       Node* p = use-&gt;fast_out(i2);</span>
<span class="line-removed">1530       if (p-&gt;Opcode() == Op_AddP) {</span>
<span class="line-removed">1531         for (DUIterator_Fast i3max, i3 = p-&gt;fast_outs(i3max); i3 &lt; i3max; i3++) {</span>
<span class="line-removed">1532           Node* q = p-&gt;fast_out(i3);</span>
<span class="line-removed">1533           if (q-&gt;is_Load()) {</span>
<span class="line-removed">1534             if(q-&gt;bottom_type() != ccp-&gt;type(q)) {</span>
<span class="line-removed">1535               worklist.push(q);</span>
<span class="line-removed">1536             }</span>
<span class="line-removed">1537           }</span>
<span class="line-removed">1538         }</span>
<span class="line-removed">1539       }</span>
<span class="line-removed">1540     }</span>
<span class="line-removed">1541   }</span>
<span class="line-removed">1542 }</span>
<span class="line-removed">1543 </span>
<span class="line-removed">1544 Node* ShenandoahBarrierSetC2::split_if_pre(PhaseIdealLoop* phase, Node* n) const {</span>
<span class="line-removed">1545   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {</span>
<span class="line-removed">1546     ((ShenandoahReadBarrierNode*)n)-&gt;try_move(phase);</span>
<span class="line-removed">1547   } else if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1548     return ((ShenandoahWriteBarrierNode*)n)-&gt;try_split_thru_phi(phase);</span>
<span class="line-removed">1549   }</span>
<span class="line-removed">1550 </span>
<span class="line-removed">1551   return NULL;</span>
<span class="line-removed">1552 }</span>
<span class="line-removed">1553 </span>
<span class="line-removed">1554 bool ShenandoahBarrierSetC2::build_loop_late_post(PhaseIdealLoop* phase, Node* n) const {</span>
<span class="line-removed">1555   return ShenandoahBarrierNode::build_loop_late_post(phase, n);</span>
<span class="line-removed">1556 }</span>
<span class="line-removed">1557 </span>
<span class="line-removed">1558 bool ShenandoahBarrierSetC2::sink_node(PhaseIdealLoop* phase, Node* n, Node* x, Node* x_ctrl, Node* n_ctrl) const {</span>
<span class="line-removed">1559   if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1560     return x-&gt;as_ShenandoahBarrier()-&gt;sink_node(phase, x_ctrl, n_ctrl);</span>
<span class="line-removed">1561   }</span>
<span class="line-removed">1562   if (n-&gt;is_MergeMem()) {</span>
<span class="line-removed">1563     // PhaseIdealLoop::split_if_with_blocks_post() would:</span>
<span class="line-removed">1564     // _igvn._worklist.yank(x);</span>
<span class="line-removed">1565     // which sometimes causes chains of MergeMem which some of</span>
<span class="line-removed">1566     // shenandoah specific code doesn&#39;t support</span>
<span class="line-removed">1567     phase-&gt;register_new_node(x, x_ctrl);</span>
<span class="line-removed">1568     return true;</span>
<span class="line-removed">1569   }</span>
<span class="line-removed">1570   return false;</span>
<span class="line-removed">1571 }</span>
<a name="65" id="anc65"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="65" type="hidden" />
</body>
</html>
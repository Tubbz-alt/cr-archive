<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSet.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
   * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,18 +31,20 @@</span>
  #include &quot;gc/shenandoah/shenandoahSATBMarkQueueSet.hpp&quot;
  
  class ShenandoahBarrierSetAssembler;
  
  class ShenandoahBarrierSet: public BarrierSet {
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-added">+ public:</span>
    enum ArrayCopyStoreValMode {
      NONE,
<span class="udiff-line-modified-removed">-     READ_BARRIER,</span>
<span class="udiff-line-modified-removed">-     WRITE_BARRIER</span>
<span class="udiff-line-modified-added">+     RESOLVE_BARRIER,</span>
<span class="udiff-line-modified-added">+     EVAC_BARRIER</span>
    };
<span class="udiff-line-added">+ private:</span>
  
    ShenandoahHeap* _heap;
<span class="udiff-line-added">+   BufferNode::Allocator _satb_mark_queue_buffer_allocator;</span>
    ShenandoahSATBMarkQueueSet _satb_mark_queue_set;
  
  public:
    ShenandoahBarrierSet(ShenandoahHeap* heap);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53,209 +56,100 @@</span>
  
    static ShenandoahSATBMarkQueueSet&amp; satb_mark_queue_set() {
      return barrier_set()-&gt;_satb_mark_queue_set;
    }
  
<span class="udiff-line-added">+   static bool need_load_reference_barrier(DecoratorSet decorators, BasicType type);</span>
<span class="udiff-line-added">+   static bool use_load_reference_barrier_native(DecoratorSet decorators, BasicType type);</span>
<span class="udiff-line-added">+   static bool need_keep_alive_barrier(DecoratorSet decorators, BasicType type);</span>
<span class="udiff-line-added">+ </span>
    void print_on(outputStream* st) const;
  
    bool is_a(BarrierSet::Name bsn);
  
    bool is_aligned(HeapWord* hw);
  
<span class="udiff-line-removed">-   void write_ref_array(HeapWord* start, size_t count);</span>
<span class="udiff-line-removed">- </span>
    template &lt;class T&gt; void
<span class="udiff-line-modified-removed">-   write_ref_array_pre_work(T* dst, size_t count);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void write_ref_array_pre(oop* dst, size_t count, bool dest_uninitialized);</span>
<span class="udiff-line-modified-added">+   write_ref_array_pre_work(T* src, T* dst, size_t count, bool dest_uninitialized);</span>
  
<span class="udiff-line-modified-removed">-   void write_ref_array_pre(narrowOop* dst, size_t count, bool dest_uninitialized);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   // We export this to make it available in cases where the static</span>
<span class="udiff-line-modified-removed">-   // type of the barrier set is known.  Note that it is non-virtual.</span>
<span class="udiff-line-modified-removed">-   template &lt;class T&gt; inline void inline_write_ref_field_pre(T* field, oop new_val);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   // These are the more general virtual versions.</span>
<span class="udiff-line-removed">-   void write_ref_field_pre_work(oop* field, oop new_val);</span>
<span class="udiff-line-removed">-   void write_ref_field_pre_work(narrowOop* field, oop new_val);</span>
<span class="udiff-line-removed">-   void write_ref_field_pre_work(void* field, oop new_val);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void write_ref_field_work(void* v, oop o, bool release = false);</span>
<span class="udiff-line-removed">-   void write_region(MemRegion mr);</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_pre(oop* src, oop* dst, size_t count);</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count);</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_update(oop* src, size_t count);</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_update(narrowOop* src, size_t count);</span>
<span class="udiff-line-modified-added">+   inline void clone_barrier(oop src);</span>
<span class="udiff-line-modified-added">+   void clone_barrier_runtime(oop src);</span>
  
    virtual void on_thread_create(Thread* thread);
    virtual void on_thread_destroy(Thread* thread);
    virtual void on_thread_attach(Thread* thread);
    virtual void on_thread_detach(Thread* thread);
  
<span class="udiff-line-removed">-   virtual oop read_barrier(oop src);</span>
<span class="udiff-line-removed">- </span>
    static inline oop resolve_forwarded_not_null(oop p);
    static inline oop resolve_forwarded(oop p);
  
<span class="udiff-line-modified-removed">-   virtual oop write_barrier(oop obj);</span>
<span class="udiff-line-modified-added">+   template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="udiff-line-added">+   inline void satb_barrier(T* field);</span>
<span class="udiff-line-added">+   inline void satb_enqueue(oop value);</span>
<span class="udiff-line-added">+   inline void storeval_barrier(oop obj);</span>
  
<span class="udiff-line-modified-removed">-   oop write_barrier_mutator(oop obj);</span>
<span class="udiff-line-modified-added">+   template &lt;DecoratorSet decorators&gt;</span>
<span class="udiff-line-added">+   inline void keep_alive_if_weak(oop value);</span>
<span class="udiff-line-added">+   inline void keep_alive_if_weak(DecoratorSet decorators, oop value);</span>
<span class="udiff-line-added">+   inline void keep_alive_barrier(oop value);</span>
  
<span class="udiff-line-modified-removed">-   virtual oop storeval_barrier(oop obj);</span>
<span class="udiff-line-modified-added">+   inline void enqueue(oop obj);</span>
  
<span class="udiff-line-modified-removed">-   virtual void keep_alive_barrier(oop obj);</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier(oop obj);</span>
<span class="udiff-line-added">+   oop load_reference_barrier_not_null(oop obj);</span>
  
<span class="udiff-line-modified-removed">-   bool obj_equals(oop obj1, oop obj2);</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier_mutator(oop obj, oop* load_addr);</span>
<span class="udiff-line-added">+   oop load_reference_barrier_mutator(oop obj, narrowOop* load_addr);</span>
  
<span class="udiff-line-modified-removed">- #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="udiff-line-modified-removed">-   bool oop_equals_operator_allowed() { return !ShenandoahVerifyObjectEquals; }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   template &lt;class T&gt;</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier_mutator_work(oop obj, T* load_addr);</span>
  
<span class="udiff-line-modified-removed">-   void enqueue(oop obj);</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier_native(oop obj, oop* load_addr);</span>
<span class="udiff-line-added">+   oop load_reference_barrier_native(oop obj, narrowOop* load_addr);</span>
  
  private:
<span class="udiff-line-modified-removed">-   inline bool need_update_refs_barrier();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   template &lt;class T, bool STOREVAL_WRITE_BARRIER&gt;</span>
<span class="udiff-line-modified-removed">-   void write_ref_array_loop(HeapWord* start, size_t count);</span>
<span class="udiff-line-modified-added">+   template &lt;class T&gt;</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_pre_work(T* src, T* dst, size_t count);</span>
<span class="udiff-line-modified-added">+   template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;</span>
<span class="udiff-line-modified-added">+   inline void arraycopy_work(T* src, size_t count);</span>
<span class="udiff-line-added">+   template &lt;class T&gt;</span>
<span class="udiff-line-added">+   inline void arraycopy_update_impl(T* src, size_t count);</span>
  
<span class="udiff-line-modified-removed">-   oop write_barrier_impl(oop obj);</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier_impl(oop obj);</span>
  
<span class="udiff-line-modified-removed">-   static void keep_alive_if_weak(DecoratorSet decorators, oop value) {</span>
<span class="udiff-line-modified-removed">-     assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="udiff-line-removed">-     const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;</span>
<span class="udiff-line-removed">-     const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;</span>
<span class="udiff-line-removed">-     if (!peek &amp;&amp; !on_strong_oop_ref &amp;&amp; value != NULL) {</span>
<span class="udiff-line-removed">-       ShenandoahBarrierSet::barrier_set()-&gt;keep_alive_barrier(value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-   bool arraycopy_loop_1(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="udiff-line-removed">-                         bool checkcast, bool satb, bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;typename T, bool CHECKCAST&gt;</span>
<span class="udiff-line-removed">-   bool arraycopy_loop_2(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="udiff-line-removed">-                         bool satb, bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;typename T, bool CHECKCAST, bool SATB&gt;</span>
<span class="udiff-line-removed">-   bool arraycopy_loop_3(T* src, T* dst, size_t length, Klass* bound,</span>
<span class="udiff-line-removed">-                         bool disjoint, ShenandoahBarrierSet::ArrayCopyStoreValMode storeval_mode);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="udiff-line-removed">-   bool arraycopy_loop(T* src, T* dst, size_t length, Klass* bound, bool disjoint);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   template &lt;typename T, bool CHECKCAST, bool SATB, ShenandoahBarrierSet::ArrayCopyStoreValMode STOREVAL_MODE&gt;</span>
<span class="udiff-line-removed">-   bool arraycopy_element(T* cur_src, T* cur_dst, Klass* bound, Thread* thread);</span>
<span class="udiff-line-modified-added">+   template &lt;class T&gt;</span>
<span class="udiff-line-modified-added">+   oop load_reference_barrier_native_impl(oop obj, T* load_addr);</span>
  
  public:
    // Callbacks for runtime accesses.
    template &lt;DecoratorSet decorators, typename BarrierSetT = ShenandoahBarrierSet&gt;
    class AccessBarrier: public BarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt; {
      typedef BarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt; Raw;
  
    public:
<span class="udiff-line-removed">-     // Primitive heap accesses. These accessors get resolved when</span>
<span class="udiff-line-removed">-     // IN_HEAP is set (e.g. when using the HeapAccess API), it is</span>
<span class="udiff-line-removed">-     // not an oop_* overload, and the barrier strength is AS_NORMAL.</span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T load_in_heap(T* addr) {</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return Raw::template load&lt;T&gt;(addr);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T load_in_heap_at(oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::resolve_forwarded(base);</span>
<span class="udiff-line-removed">-       return Raw::template load_at&lt;T&gt;(base, offset);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static void store_in_heap(T* addr, T value) {</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       Raw::store(addr, value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       Raw::store_at(base, offset, value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T atomic_cmpxchg_in_heap(T new_value, T* addr, T compare_value) {</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T atomic_cmpxchg_in_heap_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       return Raw::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T atomic_xchg_in_heap(T new_value, T* addr) {</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       return Raw::atomic_xchg(new_value, addr);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static T atomic_xchg_in_heap_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       return Raw::atomic_xchg_at(new_value, base, offset);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename T&gt;</span>
<span class="udiff-line-removed">-     static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,</span>
<span class="udiff-line-removed">-                                   arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,</span>
<span class="udiff-line-removed">-                                   size_t length);</span>
<span class="udiff-line-removed">- </span>
      // Heap oop accesses. These accessors get resolved when
      // IN_HEAP is set (e.g. when using the HeapAccess API), it is
      // an oop_* overload, and the barrier strength is AS_NORMAL.
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     static oop oop_load_in_heap(T* addr) {</span>
<span class="udiff-line-modified-removed">-       // ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       oop value = Raw::template oop_load&lt;oop&gt;(addr);</span>
<span class="udiff-line-removed">-       keep_alive_if_weak(decorators, value);</span>
<span class="udiff-line-removed">-       return value;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static oop oop_load_in_heap_at(oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::resolve_forwarded(base);</span>
<span class="udiff-line-removed">-       oop value = Raw::template oop_load_at&lt;oop&gt;(base, offset);</span>
<span class="udiff-line-removed">-       keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset), value);</span>
<span class="udiff-line-removed">-       return value;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     static oop oop_load_in_heap(T* addr);</span>
<span class="udiff-line-modified-added">+     static oop oop_load_in_heap_at(oop base, ptrdiff_t offset);</span>
  
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     static void oop_store_in_heap(T* addr, oop value) {</span>
<span class="udiff-line-modified-removed">-       ShenandoahBarrierSet::barrier_set()-&gt;write_ref_field_pre_work(addr, value);</span>
<span class="udiff-line-removed">-       Raw::oop_store(addr, value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       value = ShenandoahBarrierSet::barrier_set()-&gt;storeval_barrier(value);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       oop_store_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     static void oop_store_in_heap(T* addr, oop value);</span>
<span class="udiff-line-modified-added">+     static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value);</span>
  
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     static oop oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     static oop oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       new_value = ShenandoahBarrierSet::barrier_set()-&gt;storeval_barrier(new_value);</span>
<span class="udiff-line-removed">-       return oop_atomic_cmpxchg_in_heap(new_value, AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), compare_value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value);</span>
  
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     static oop oop_atomic_xchg_in_heap(oop new_value, T* addr);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     static oop oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {</span>
<span class="udiff-line-removed">-       base = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(base);</span>
<span class="udiff-line-removed">-       new_value = ShenandoahBarrierSet::barrier_set()-&gt;storeval_barrier(new_value);</span>
<span class="udiff-line-removed">-       return oop_atomic_xchg_in_heap(new_value, AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value);</span>
  
      template &lt;typename T&gt;
      static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                        arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
                                        size_t length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,23 +157,21 @@</span>
      // Clone barrier support
      static void clone_in_heap(oop src, oop dst, size_t size);
  
      // Needed for loads on non-heap weak references
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     static oop oop_load_not_in_heap(T* addr) {</span>
<span class="udiff-line-modified-removed">-       oop value = Raw::oop_load_not_in_heap(addr);</span>
<span class="udiff-line-modified-removed">-       keep_alive_if_weak(decorators, value);</span>
<span class="udiff-line-modified-removed">-       return value;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static oop resolve(oop obj) {</span>
<span class="udiff-line-modified-removed">-       return ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(obj);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static bool equals(oop o1, oop o2) {</span>
<span class="udiff-line-removed">-       return ShenandoahBarrierSet::barrier_set()-&gt;obj_equals(o1, o2);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     static oop oop_load_not_in_heap(T* addr);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     // Used for catching bad stores</span>
<span class="udiff-line-modified-added">+     template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+     static void oop_store_not_in_heap(T* addr, oop value);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     template &lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+     static oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value);</span>
  
    };
  
  };
  
</pre>
<center><a href="shenandoahBarrierSet.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSet.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
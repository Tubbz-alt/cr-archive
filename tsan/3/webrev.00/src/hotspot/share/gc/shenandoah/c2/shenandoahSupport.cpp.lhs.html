<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
<a name="1" id="anc1"></a>
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
  27 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  29 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  30 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  34 #include &quot;opto/arraycopynode.hpp&quot;
  35 #include &quot;opto/block.hpp&quot;
  36 #include &quot;opto/callnode.hpp&quot;
  37 #include &quot;opto/castnode.hpp&quot;
  38 #include &quot;opto/movenode.hpp&quot;
  39 #include &quot;opto/phaseX.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/runtime.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 
<a name="3" id="anc3"></a><span class="line-modified">  44 Node* ShenandoahBarrierNode::skip_through_barrier(Node* n) {</span>
<span class="line-modified">  45   if (n == NULL) {</span>
<span class="line-modified">  46     return NULL;</span>
<span class="line-modified">  47   }</span>
<span class="line-modified">  48   if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified">  49     n = n-&gt;in(1);</span>
<span class="line-modified">  50   }</span>
<span class="line-modified">  51 </span>
<span class="line-modified">  52   if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-modified">  53     return n-&gt;in(ValueIn);</span>
<span class="line-modified">  54   } else if (n-&gt;is_Phi() &amp;&amp;</span>
<span class="line-modified">  55              n-&gt;req() == 3 &amp;&amp;</span>
<span class="line-modified">  56              n-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  57              n-&gt;in(1)-&gt;is_ShenandoahBarrier() &amp;&amp;</span>
<span class="line-removed">  58              n-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  59              n-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR &amp;&amp;</span>
<span class="line-removed">  60              n-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">  61              n-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  62              n-&gt;in(0)-&gt;in(1)-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-removed">  63              n-&gt;in(0)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  64              n-&gt;in(0)-&gt;in(2)-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-removed">  65              n-&gt;in(0)-&gt;in(1)-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">  66              n-&gt;in(0)-&gt;in(1)-&gt;in(0) == n-&gt;in(0)-&gt;in(2)-&gt;in(0) &amp;&amp;</span>
<span class="line-removed">  67              n-&gt;in(1)-&gt;in(ValueIn)-&gt;Opcode() == Op_CastPP) {</span>
<span class="line-removed">  68     Node* iff = n-&gt;in(0)-&gt;in(1)-&gt;in(0);</span>
<span class="line-removed">  69     Node* res = n-&gt;in(1)-&gt;in(ValueIn)-&gt;in(1);</span>
<span class="line-removed">  70     if (iff-&gt;is_If() &amp;&amp;</span>
<span class="line-removed">  71         iff-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  72         iff-&gt;in(1)-&gt;is_Bool() &amp;&amp;</span>
<span class="line-removed">  73         iff-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-removed">  74         iff-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  75         iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-removed">  76         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-removed">  77         iff-&gt;in(1)-&gt;in(1)-&gt;in(1) == res &amp;&amp;</span>
<span class="line-removed">  78         iff-&gt;in(1)-&gt;in(1)-&gt;in(2) != NULL &amp;&amp;</span>
<span class="line-removed">  79         iff-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-removed">  80       return res;</span>
<span class="line-removed">  81     }</span>
<span class="line-removed">  82   }</span>
<span class="line-removed">  83   return n;</span>
<span class="line-removed">  84 }</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86 bool ShenandoahBarrierNode::needs_barrier(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace) {</span>
<span class="line-removed">  87   Unique_Node_List visited;</span>
<span class="line-removed">  88   return needs_barrier_impl(phase, orig, n, rb_mem, allow_fromspace, visited);</span>
<span class="line-removed">  89 }</span>
<span class="line-removed">  90 </span>
<span class="line-removed">  91 bool ShenandoahBarrierNode::needs_barrier_impl(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace, Unique_Node_List &amp;visited) {</span>
<span class="line-removed">  92   if (visited.member(n)) {</span>
<span class="line-removed">  93     return false; // Been there.</span>
<span class="line-removed">  94   }</span>
<span class="line-removed">  95   visited.push(n);</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97   if (n-&gt;is_Allocate()) {</span>
<span class="line-removed">  98     return false;</span>
<span class="line-removed">  99   }</span>
<span class="line-removed"> 100 </span>
<span class="line-removed"> 101   if (n-&gt;is_Call()) {</span>
<span class="line-removed"> 102     return true;</span>
<span class="line-removed"> 103   }</span>
<span class="line-removed"> 104 </span>
<span class="line-removed"> 105   const Type* type = phase-&gt;type(n);</span>
<span class="line-removed"> 106   if (type == Type::TOP) {</span>
<span class="line-removed"> 107     return false;</span>
<span class="line-removed"> 108   }</span>
<span class="line-removed"> 109   if (type-&gt;make_ptr()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-removed"> 110     return false;</span>
<span class="line-removed"> 111   }</span>
<span class="line-removed"> 112   if (type-&gt;make_oopptr() &amp;&amp; type-&gt;make_oopptr()-&gt;const_oop() != NULL) {</span>
<span class="line-removed"> 113     return false;</span>
<span class="line-removed"> 114   }</span>
<span class="line-removed"> 115 </span>
<span class="line-removed"> 116   if (ShenandoahOptimizeStableFinals) {</span>
<span class="line-removed"> 117     const TypeAryPtr* ary = type-&gt;isa_aryptr();</span>
<span class="line-removed"> 118     if (ary &amp;&amp; ary-&gt;is_stable() &amp;&amp; allow_fromspace) {</span>
<span class="line-removed"> 119       return false;</span>
<span class="line-removed"> 120     }</span>
<span class="line-removed"> 121   }</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123   if (n-&gt;is_CheckCastPP() || n-&gt;is_ConstraintCast() || n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-removed"> 124     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 125   }</span>
<span class="line-removed"> 126   if (n-&gt;is_Parm()) {</span>
<span class="line-removed"> 127     return true;</span>
<span class="line-removed"> 128   }</span>
<span class="line-removed"> 129   if (n-&gt;is_Proj()) {</span>
<span class="line-removed"> 130     return needs_barrier_impl(phase, orig, n-&gt;in(0), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 131   }</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133   if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 134     return needs_barrier_impl(phase, orig, n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 135   }</span>
<span class="line-removed"> 136   if (n-&gt;is_Phi()) {</span>
<span class="line-removed"> 137     bool need_barrier = false;</span>
<span class="line-removed"> 138     for (uint i = 1; i &lt; n-&gt;req() &amp;&amp; ! need_barrier; i++) {</span>
<span class="line-removed"> 139       Node* input = n-&gt;in(i);</span>
<span class="line-removed"> 140       if (input == NULL) {</span>
<span class="line-removed"> 141         need_barrier = true; // Phi not complete yet?</span>
<span class="line-removed"> 142       } else if (needs_barrier_impl(phase, orig, input, rb_mem, allow_fromspace, visited)) {</span>
<span class="line-removed"> 143         need_barrier = true;</span>
<span class="line-removed"> 144       }</span>
<span class="line-removed"> 145     }</span>
<span class="line-removed"> 146     return need_barrier;</span>
<span class="line-removed"> 147   }</span>
<span class="line-removed"> 148   if (n-&gt;is_CMove()) {</span>
<span class="line-removed"> 149     return needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfFalse), rb_mem, allow_fromspace, visited) ||</span>
<span class="line-removed"> 150            needs_barrier_impl(phase, orig, n-&gt;in(CMoveNode::IfTrue ), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 151   }</span>
<span class="line-removed"> 152   if (n-&gt;Opcode() == Op_CreateEx) {</span>
<span class="line-removed"> 153     return true;</span>
<span class="line-removed"> 154   }</span>
<span class="line-removed"> 155   if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 156     return false;</span>
<span class="line-removed"> 157   }</span>
<span class="line-removed"> 158   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier) {</span>
<span class="line-removed"> 159     if (rb_mem == n-&gt;in(Memory)) {</span>
<span class="line-removed"> 160       return false;</span>
<span class="line-removed"> 161     } else {</span>
<span class="line-removed"> 162       return true;</span>
<span class="line-removed"> 163     }</span>
<span class="line-removed"> 164   }</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166   if (n-&gt;Opcode() == Op_LoadP ||</span>
<span class="line-removed"> 167       n-&gt;Opcode() == Op_LoadN ||</span>
<span class="line-removed"> 168       n-&gt;Opcode() == Op_GetAndSetP ||</span>
<span class="line-removed"> 169       n-&gt;Opcode() == Op_CompareAndExchangeP ||</span>
<span class="line-removed"> 170       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeP ||</span>
<span class="line-removed"> 171       n-&gt;Opcode() == Op_GetAndSetN ||</span>
<span class="line-removed"> 172       n-&gt;Opcode() == Op_CompareAndExchangeN ||</span>
<span class="line-removed"> 173       n-&gt;Opcode() == Op_ShenandoahCompareAndExchangeN) {</span>
<span class="line-removed"> 174     return true;</span>
<span class="line-removed"> 175   }</span>
<span class="line-removed"> 176   if (n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="line-removed"> 177       n-&gt;Opcode() == Op_EncodeP) {</span>
<span class="line-removed"> 178     return needs_barrier_impl(phase, orig, n-&gt;in(1), rb_mem, allow_fromspace, visited);</span>
<span class="line-removed"> 179   }</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181 #ifdef ASSERT</span>
<span class="line-removed"> 182   tty-&gt;print(&quot;need barrier on?: &quot;); n-&gt;dump();</span>
<span class="line-removed"> 183   ShouldNotReachHere();</span>
<span class="line-removed"> 184 #endif</span>
<span class="line-removed"> 185   return true;</span>
<span class="line-removed"> 186 }</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188 bool ShenandoahReadBarrierNode::dominates_memory_rb_impl(PhaseGVN* phase,</span>
<span class="line-removed"> 189                                                          Node* b1,</span>
<span class="line-removed"> 190                                                          Node* b2,</span>
<span class="line-removed"> 191                                                          Node* current,</span>
<span class="line-removed"> 192                                                          bool linear) {</span>
<span class="line-removed"> 193   ResourceMark rm;</span>
<span class="line-removed"> 194   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 195   Node_Stack phis(0);</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197   for(int i = 0; i &lt; 10; i++) {</span>
<span class="line-removed"> 198     if (current == NULL) {</span>
<span class="line-removed"> 199       return false;</span>
<span class="line-removed"> 200     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="line-removed"> 201       current = NULL;</span>
<span class="line-removed"> 202       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="line-removed"> 203         uint idx = phis.index();</span>
<span class="line-removed"> 204         Node* phi = phis.node();</span>
<span class="line-removed"> 205         if (idx &gt;= phi-&gt;req()) {</span>
<span class="line-removed"> 206           phis.pop();</span>
<span class="line-removed"> 207         } else {</span>
<span class="line-removed"> 208           current = phi-&gt;in(idx);</span>
<span class="line-removed"> 209           phis.set_index(idx+1);</span>
<span class="line-removed"> 210         }</span>
<span class="line-removed"> 211       }</span>
<span class="line-removed"> 212       if (current == NULL) {</span>
<span class="line-removed"> 213         return true;</span>
<span class="line-removed"> 214       }</span>
<span class="line-removed"> 215     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="line-removed"> 216       return false;</span>
<span class="line-removed"> 217     } else if (current-&gt;isa_Phi()) {</span>
<span class="line-removed"> 218       if (!linear) {</span>
<span class="line-removed"> 219         return false;</span>
<span class="line-removed"> 220       }</span>
<span class="line-removed"> 221       phis.push(current, 2);</span>
<span class="line-removed"> 222       current = current-&gt;in(1);</span>
<span class="line-removed"> 223     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 224       const Type* in_type = current-&gt;bottom_type();</span>
<span class="line-removed"> 225       const Type* this_type = b2-&gt;bottom_type();</span>
<span class="line-removed"> 226       if (is_independent(in_type, this_type)) {</span>
<span class="line-removed"> 227         current = current-&gt;in(Memory);</span>
<span class="line-removed"> 228       } else {</span>
 229         return false;
 230       }
<a name="4" id="anc4"></a><span class="line-removed"> 231     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 232       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 233     } else if (current-&gt;is_Proj()) {</span>
<span class="line-removed"> 234       current = current-&gt;in(0);</span>
<span class="line-removed"> 235     } else if (current-&gt;is_Call()) {</span>
<span class="line-removed"> 236       return false; // TODO: Maybe improve by looking at the call&#39;s memory effects?</span>
<span class="line-removed"> 237     } else if (current-&gt;is_MemBar()) {</span>
<span class="line-removed"> 238       return false; // TODO: Do we need to stop at *any* membar?</span>
<span class="line-removed"> 239     } else if (current-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 240       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="line-removed"> 241       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 242       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 243     } else {</span>
<span class="line-removed"> 244 #ifdef ASSERT</span>
<span class="line-removed"> 245       current-&gt;dump();</span>
<span class="line-removed"> 246 #endif</span>
<span class="line-removed"> 247       ShouldNotReachHere();</span>
<span class="line-removed"> 248       return false;</span>
<span class="line-removed"> 249     }</span>
<span class="line-removed"> 250   }</span>
<span class="line-removed"> 251   return false;</span>
<span class="line-removed"> 252 }</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254 bool ShenandoahReadBarrierNode::is_independent(Node* mem) {</span>
<span class="line-removed"> 255   if (mem-&gt;is_Phi() || mem-&gt;is_Proj() || mem-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 256     return true;</span>
<span class="line-removed"> 257   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 258     return true;</span>
<span class="line-removed"> 259   } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 260     const Type* mem_type = mem-&gt;bottom_type();</span>
<span class="line-removed"> 261     const Type* this_type = bottom_type();</span>
<span class="line-removed"> 262     if (is_independent(mem_type, this_type)) {</span>
<span class="line-removed"> 263       return true;</span>
<span class="line-removed"> 264     } else {</span>
<span class="line-removed"> 265       return false;</span>
<span class="line-removed"> 266     }</span>
<span class="line-removed"> 267   } else if (mem-&gt;is_Call() || mem-&gt;is_MemBar()) {</span>
<span class="line-removed"> 268     return false;</span>
<span class="line-removed"> 269   }</span>
<span class="line-removed"> 270 #ifdef ASSERT</span>
<span class="line-removed"> 271   mem-&gt;dump();</span>
<span class="line-removed"> 272 #endif</span>
<span class="line-removed"> 273   ShouldNotReachHere();</span>
<span class="line-removed"> 274   return true;</span>
<span class="line-removed"> 275 }</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277 bool ShenandoahReadBarrierNode::dominates_memory_rb(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="line-removed"> 278   return dominates_memory_rb_impl(phase, b1-&gt;in(Memory), b2, b2-&gt;in(Memory), linear);</span>
<span class="line-removed"> 279 }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281 bool ShenandoahReadBarrierNode::is_independent(const Type* in_type, const Type* this_type) {</span>
<span class="line-removed"> 282   assert(in_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="line-removed"> 283   assert(this_type-&gt;isa_oopptr(), &quot;expect oop ptr&quot;);</span>
<span class="line-removed"> 284 </span>
<span class="line-removed"> 285   ciKlass* in_kls = in_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-removed"> 286   ciKlass* this_kls = this_type-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-removed"> 287   if (in_kls != NULL &amp;&amp; this_kls != NULL &amp;&amp;</span>
<span class="line-removed"> 288       in_kls-&gt;is_loaded() &amp;&amp; this_kls-&gt;is_loaded() &amp;&amp;</span>
<span class="line-removed"> 289       (!in_kls-&gt;is_subclass_of(this_kls)) &amp;&amp;</span>
<span class="line-removed"> 290       (!this_kls-&gt;is_subclass_of(in_kls))) {</span>
<span class="line-removed"> 291     return true;</span>
<span class="line-removed"> 292   }</span>
<span class="line-removed"> 293   return false;</span>
<span class="line-removed"> 294 }</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296 Node* ShenandoahReadBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed"> 297   if (! can_reshape) {</span>
<span class="line-removed"> 298     return NULL;</span>
<span class="line-removed"> 299   }</span>
<span class="line-removed"> 300 </span>
<span class="line-removed"> 301   if (in(Memory) == phase-&gt;C-&gt;immutable_memory()) return NULL;</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303   // If memory input is a MergeMem, take the appropriate slice out of it.</span>
<span class="line-removed"> 304   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 305   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="line-removed"> 306     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="line-removed"> 307     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 308     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 309     set_req(Memory, mem_in);</span>
<span class="line-removed"> 310     return this;</span>
<span class="line-removed"> 311   }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313   Node* input = in(Memory);</span>
<span class="line-removed"> 314   if (input-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 315     ResourceMark rm;</span>
<span class="line-removed"> 316     VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 317     Node* n = in(Memory);</span>
<span class="line-removed"> 318     while (n-&gt;Opcode() == Op_ShenandoahWBMemProj &amp;&amp;</span>
<span class="line-removed"> 319            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier) != NULL &amp;&amp;</span>
<span class="line-removed"> 320            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="line-removed"> 321            n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory) != NULL) {</span>
<span class="line-removed"> 322       if (seen.test_set(n-&gt;_idx)) {</span>
<span class="line-removed"> 323         return NULL; // loop</span>
<span class="line-removed"> 324       }</span>
<span class="line-removed"> 325       n = n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(Memory);</span>
<span class="line-removed"> 326     }</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328     Node* wb = input-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 329     const Type* in_type = phase-&gt;type(wb);</span>
<span class="line-removed"> 330     // is_top() test not sufficient here: we can come here after CCP</span>
<span class="line-removed"> 331     // in a dead branch of the graph that has not yet been removed.</span>
<span class="line-removed"> 332     if (in_type == Type::TOP) return NULL; // Dead path.</span>
<span class="line-removed"> 333     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="line-removed"> 334     if (is_independent(in_type, _type)) {</span>
<span class="line-removed"> 335       phase-&gt;igvn_rehash_node_delayed(wb);</span>
<span class="line-removed"> 336       set_req(Memory, wb-&gt;in(Memory));</span>
<span class="line-removed"> 337       if (can_reshape &amp;&amp; input-&gt;outcnt() == 0) {</span>
<span class="line-removed"> 338         phase-&gt;is_IterGVN()-&gt;_worklist.push(input);</span>
<span class="line-removed"> 339       }</span>
<span class="line-removed"> 340       return this;</span>
<span class="line-removed"> 341     }</span>
<span class="line-removed"> 342   }</span>
<span class="line-removed"> 343   return NULL;</span>
<span class="line-removed"> 344 }</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346 ShenandoahWriteBarrierNode::ShenandoahWriteBarrierNode(Compile* C, Node* ctrl, Node* mem, Node* obj)</span>
<span class="line-removed"> 347   : ShenandoahBarrierNode(ctrl, mem, obj, false) {</span>
<span class="line-removed"> 348   assert(UseShenandoahGC &amp;&amp; ShenandoahWriteBarrier, &quot;should be enabled&quot;);</span>
<span class="line-removed"> 349   ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;add_shenandoah_barrier(this);</span>
<span class="line-removed"> 350 }</span>
<span class="line-removed"> 351 </span>
<span class="line-removed"> 352 Node* ShenandoahWriteBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 353   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="line-removed"> 354   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 355   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 356   Node* mem_proj = NULL;</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   if (igvn != NULL) {</span>
<span class="line-removed"> 359     mem_proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed"> 360     if (mem_in == mem_proj) {</span>
<span class="line-removed"> 361       return this;</span>
<span class="line-removed"> 362     }</span>
<span class="line-removed"> 363   }</span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365   Node* replacement = Identity_impl(phase);</span>
<span class="line-removed"> 366   if (igvn != NULL) {</span>
<span class="line-removed"> 367     if (replacement != NULL &amp;&amp; replacement != this &amp;&amp; mem_proj != NULL) {</span>
<span class="line-removed"> 368       igvn-&gt;replace_node(mem_proj, mem_in);</span>
<span class="line-removed"> 369     }</span>
<span class="line-removed"> 370   }</span>
<span class="line-removed"> 371   return replacement;</span>
<span class="line-removed"> 372 }</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374 Node* ShenandoahWriteBarrierNode::Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed"> 375   assert(in(0) != NULL, &quot;should have control&quot;);</span>
<span class="line-removed"> 376   if (!can_reshape) {</span>
<span class="line-removed"> 377     return NULL;</span>
<span class="line-removed"> 378   }</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380   Node* mem_in = in(Memory);</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382   if (mem_in-&gt;isa_MergeMem()) {</span>
<span class="line-removed"> 383     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="line-removed"> 384     uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 385     mem_in = mem_in-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 386     set_req(Memory, mem_in);</span>
<span class="line-removed"> 387     return this;</span>
<span class="line-removed"> 388   }</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390   Node* val = in(ValueIn);</span>
<span class="line-removed"> 391   if (val-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed"> 392     set_req(ValueIn, val-&gt;in(ValueIn));</span>
<span class="line-removed"> 393     return this;</span>
<span class="line-removed"> 394   }</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   return NULL;</span>
<span class="line-removed"> 397 }</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399 bool ShenandoahWriteBarrierNode::expand(Compile* C, PhaseIterGVN&amp; igvn) {</span>
<span class="line-removed"> 400   if (UseShenandoahGC) {</span>
<span class="line-removed"> 401     if (ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() &gt; 0 || (!ShenandoahWriteBarrier &amp;&amp; ShenandoahStoreValEnqueueBarrier)) {</span>
<span class="line-removed"> 402       bool attempt_more_loopopts = ShenandoahLoopOptsAfterExpansion;</span>
 403       C-&gt;clear_major_progress();
<a name="5" id="anc5"></a><span class="line-modified"> 404       PhaseIdealLoop ideal_loop(igvn, LoopOptsShenandoahExpand);</span>
<span class="line-modified"> 405       if (C-&gt;failing()) return false;</span>
<span class="line-modified"> 406       PhaseIdealLoop::verify(igvn);</span>
<span class="line-modified"> 407       DEBUG_ONLY(ShenandoahBarrierNode::verify_raw_mem(C-&gt;root());)</span>
<span class="line-removed"> 408       if (attempt_more_loopopts) {</span>
<span class="line-removed"> 409         C-&gt;set_major_progress();</span>
<span class="line-removed"> 410         if (!C-&gt;optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {</span>
<span class="line-removed"> 411           return false;</span>
<span class="line-removed"> 412         }</span>
<span class="line-removed"> 413         C-&gt;clear_major_progress();</span>
 414       }
 415     }
 416   }
 417   return true;
 418 }
 419 
<a name="6" id="anc6"></a><span class="line-modified"> 420 bool ShenandoahWriteBarrierNode::is_heap_state_test(Node* iff, int mask) {</span>
 421   if (!UseShenandoahGC) {
 422     return false;
 423   }
 424   assert(iff-&gt;is_If(), &quot;bad input&quot;);
 425   if (iff-&gt;Opcode() != Op_If) {
 426     return false;
 427   }
 428   Node* bol = iff-&gt;in(1);
 429   if (!bol-&gt;is_Bool() || bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne) {
 430     return false;
 431   }
 432   Node* cmp = bol-&gt;in(1);
 433   if (cmp-&gt;Opcode() != Op_CmpI) {
 434     return false;
 435   }
 436   Node* in1 = cmp-&gt;in(1);
 437   Node* in2 = cmp-&gt;in(2);
 438   if (in2-&gt;find_int_con(-1) != 0) {
 439     return false;
 440   }
 441   if (in1-&gt;Opcode() != Op_AndI) {
 442     return false;
 443   }
 444   in2 = in1-&gt;in(2);
 445   if (in2-&gt;find_int_con(-1) != mask) {
 446     return false;
 447   }
 448   in1 = in1-&gt;in(1);
 449 
 450   return is_gc_state_load(in1);
 451 }
 452 
<a name="7" id="anc7"></a><span class="line-modified"> 453 bool ShenandoahWriteBarrierNode::is_heap_stable_test(Node* iff) {</span>
 454   return is_heap_state_test(iff, ShenandoahHeap::HAS_FORWARDED);
 455 }
 456 
<a name="8" id="anc8"></a><span class="line-modified"> 457 bool ShenandoahWriteBarrierNode::is_gc_state_load(Node *n) {</span>
 458   if (!UseShenandoahGC) {
 459     return false;
 460   }
 461   if (n-&gt;Opcode() != Op_LoadB &amp;&amp; n-&gt;Opcode() != Op_LoadUB) {
 462     return false;
 463   }
 464   Node* addp = n-&gt;in(MemNode::Address);
 465   if (!addp-&gt;is_AddP()) {
 466     return false;
 467   }
 468   Node* base = addp-&gt;in(AddPNode::Address);
 469   Node* off = addp-&gt;in(AddPNode::Offset);
 470   if (base-&gt;Opcode() != Op_ThreadLocal) {
 471     return false;
 472   }
 473   if (off-&gt;find_intptr_t_con(-1) != in_bytes(ShenandoahThreadLocalData::gc_state_offset())) {
 474     return false;
 475   }
 476   return true;
 477 }
 478 
<a name="9" id="anc9"></a><span class="line-modified"> 479 bool ShenandoahWriteBarrierNode::has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase) {</span>
 480   assert(phase-&gt;is_dominator(stop, start), &quot;bad inputs&quot;);
 481   ResourceMark rm;
 482   Unique_Node_List wq;
 483   wq.push(start);
 484   for (uint next = 0; next &lt; wq.size(); next++) {
 485     Node *m = wq.at(next);
 486     if (m == stop) {
 487       continue;
 488     }
 489     if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
 490       return true;
 491     }
 492     if (m-&gt;is_Region()) {
 493       for (uint i = 1; i &lt; m-&gt;req(); i++) {
 494         wq.push(m-&gt;in(i));
 495       }
 496     } else {
 497       wq.push(m-&gt;in(0));
 498     }
 499   }
 500   return false;
 501 }
 502 
<a name="10" id="anc10"></a><span class="line-modified"> 503 bool ShenandoahWriteBarrierNode::try_common_gc_state_load(Node *n, PhaseIdealLoop *phase) {</span>
 504   assert(is_gc_state_load(n), &quot;inconsistent&quot;);
 505   Node* addp = n-&gt;in(MemNode::Address);
 506   Node* dominator = NULL;
 507   for (DUIterator_Fast imax, i = addp-&gt;fast_outs(imax); i &lt; imax; i++) {
 508     Node* u = addp-&gt;fast_out(i);
 509     assert(is_gc_state_load(u), &quot;inconsistent&quot;);
 510     if (u != n &amp;&amp; phase-&gt;is_dominator(u-&gt;in(0), n-&gt;in(0))) {
 511       if (dominator == NULL) {
 512         dominator = u;
 513       } else {
 514         if (phase-&gt;dom_depth(u-&gt;in(0)) &lt; phase-&gt;dom_depth(dominator-&gt;in(0))) {
 515           dominator = u;
 516         }
 517       }
 518     }
 519   }
 520   if (dominator == NULL || has_safepoint_between(n-&gt;in(0), dominator-&gt;in(0), phase)) {
 521     return false;
 522   }
 523   phase-&gt;igvn().replace_node(n, dominator);
 524 
 525   return true;
 526 }
 527 
<a name="11" id="anc11"></a><span class="line-removed"> 528 bool ShenandoahBarrierNode::dominates_memory_impl(PhaseGVN* phase,</span>
<span class="line-removed"> 529                                                   Node* b1,</span>
<span class="line-removed"> 530                                                   Node* b2,</span>
<span class="line-removed"> 531                                                   Node* current,</span>
<span class="line-removed"> 532                                                   bool linear) {</span>
<span class="line-removed"> 533   ResourceMark rm;</span>
<span class="line-removed"> 534   VectorSet visited(Thread::current()-&gt;resource_area());</span>
<span class="line-removed"> 535   Node_Stack phis(0);</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537   for(int i = 0; i &lt; 10; i++) {</span>
<span class="line-removed"> 538     if (current == NULL) {</span>
<span class="line-removed"> 539       return false;</span>
<span class="line-removed"> 540     } else if (visited.test_set(current-&gt;_idx) || current-&gt;is_top() || current == b1) {</span>
<span class="line-removed"> 541       current = NULL;</span>
<span class="line-removed"> 542       while (phis.is_nonempty() &amp;&amp; current == NULL) {</span>
<span class="line-removed"> 543         uint idx = phis.index();</span>
<span class="line-removed"> 544         Node* phi = phis.node();</span>
<span class="line-removed"> 545         if (idx &gt;= phi-&gt;req()) {</span>
<span class="line-removed"> 546           phis.pop();</span>
<span class="line-removed"> 547         } else {</span>
<span class="line-removed"> 548           current = phi-&gt;in(idx);</span>
<span class="line-removed"> 549           phis.set_index(idx+1);</span>
<span class="line-removed"> 550         }</span>
<span class="line-removed"> 551       }</span>
<span class="line-removed"> 552       if (current == NULL) {</span>
<span class="line-removed"> 553         return true;</span>
<span class="line-removed"> 554       }</span>
<span class="line-removed"> 555     } else if (current == b2) {</span>
<span class="line-removed"> 556       return false;</span>
<span class="line-removed"> 557     } else if (current == phase-&gt;C-&gt;immutable_memory()) {</span>
<span class="line-removed"> 558       return false;</span>
<span class="line-removed"> 559     } else if (current-&gt;isa_Phi()) {</span>
<span class="line-removed"> 560       if (!linear) {</span>
<span class="line-removed"> 561         return false;</span>
<span class="line-removed"> 562       }</span>
<span class="line-removed"> 563       phis.push(current, 2);</span>
<span class="line-removed"> 564       current = current-&gt;in(1);</span>
<span class="line-removed"> 565     } else if (current-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 566       current = current-&gt;in(Memory);</span>
<span class="line-removed"> 567     } else if (current-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed"> 568       current = current-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed"> 569     } else if (current-&gt;is_Proj()) {</span>
<span class="line-removed"> 570       current = current-&gt;in(0);</span>
<span class="line-removed"> 571     } else if (current-&gt;is_Call()) {</span>
<span class="line-removed"> 572       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 573     } else if (current-&gt;is_MemBar()) {</span>
<span class="line-removed"> 574       current = current-&gt;in(TypeFunc::Memory);</span>
<span class="line-removed"> 575     } else if (current-&gt;is_MergeMem()) {</span>
<span class="line-removed"> 576       const TypePtr* adr_type = brooks_pointer_type(phase-&gt;type(b2));</span>
<span class="line-removed"> 577       uint alias_idx = phase-&gt;C-&gt;get_alias_index(adr_type);</span>
<span class="line-removed"> 578       current = current-&gt;as_MergeMem()-&gt;memory_at(alias_idx);</span>
<span class="line-removed"> 579     } else {</span>
<span class="line-removed"> 580 #ifdef ASSERT</span>
<span class="line-removed"> 581       current-&gt;dump();</span>
<span class="line-removed"> 582 #endif</span>
<span class="line-removed"> 583       ShouldNotReachHere();</span>
<span class="line-removed"> 584       return false;</span>
<span class="line-removed"> 585     }</span>
<span class="line-removed"> 586   }</span>
<span class="line-removed"> 587   return false;</span>
<span class="line-removed"> 588 }</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590 /**</span>
<span class="line-removed"> 591  * Determines if b1 dominates b2 through memory inputs. It returns true if:</span>
<span class="line-removed"> 592  * - b1 can be reached by following each branch in b2&#39;s memory input (through phis, etc)</span>
<span class="line-removed"> 593  * - or we get back to b2 (i.e. through a loop) without seeing b1</span>
<span class="line-removed"> 594  * In all other cases, (in particular, if we reach immutable_memory without having seen b1)</span>
<span class="line-removed"> 595  * we return false.</span>
<span class="line-removed"> 596  */</span>
<span class="line-removed"> 597 bool ShenandoahBarrierNode::dominates_memory(PhaseGVN* phase, Node* b1, Node* b2, bool linear) {</span>
<span class="line-removed"> 598   return dominates_memory_impl(phase, b1, b2, b2-&gt;in(Memory), linear);</span>
<span class="line-removed"> 599 }</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601 Node* ShenandoahBarrierNode::Identity_impl(PhaseGVN* phase) {</span>
<span class="line-removed"> 602   Node* n = in(ValueIn);</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604   Node* rb_mem = Opcode() == Op_ShenandoahReadBarrier ? in(Memory) : NULL;</span>
<span class="line-removed"> 605   if (! needs_barrier(phase, this, n, rb_mem, _allow_fromspace)) {</span>
<span class="line-removed"> 606     return n;</span>
<span class="line-removed"> 607   }</span>
<span class="line-removed"> 608 </span>
<span class="line-removed"> 609   // Try to find a write barrier sibling with identical inputs that we can fold into.</span>
<span class="line-removed"> 610   for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-removed"> 611     Node* sibling = n-&gt;out(i);</span>
<span class="line-removed"> 612     if (sibling == this) {</span>
<span class="line-removed"> 613       continue;</span>
<span class="line-removed"> 614     }</span>
<span class="line-removed"> 615     if (sibling-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 616       continue;</span>
<span class="line-removed"> 617     }</span>
<span class="line-removed"> 618 </span>
<span class="line-removed"> 619     assert(sibling-&gt;in(ValueIn) == in(ValueIn), &quot;sanity&quot;);</span>
<span class="line-removed"> 620     assert(sibling-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;sanity&quot;);</span>
<span class="line-removed"> 621 </span>
<span class="line-removed"> 622     if (dominates_memory(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="line-removed"> 623       return sibling;</span>
<span class="line-removed"> 624     }</span>
<span class="line-removed"> 625   }</span>
<span class="line-removed"> 626   return this;</span>
<span class="line-removed"> 627 }</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629 #ifndef PRODUCT</span>
<span class="line-removed"> 630 void ShenandoahBarrierNode::dump_spec(outputStream *st) const {</span>
<span class="line-removed"> 631   const TypePtr* adr = adr_type();</span>
<span class="line-removed"> 632   if (adr == NULL) {</span>
<span class="line-removed"> 633     return;</span>
<span class="line-removed"> 634   }</span>
<span class="line-removed"> 635   st-&gt;print(&quot; @&quot;);</span>
<span class="line-removed"> 636   adr-&gt;dump_on(st);</span>
<span class="line-removed"> 637   st-&gt;print(&quot; (&quot;);</span>
<span class="line-removed"> 638   Compile::current()-&gt;alias_type(adr)-&gt;adr_type()-&gt;dump_on(st);</span>
<span class="line-removed"> 639   st-&gt;print(&quot;) &quot;);</span>
<span class="line-removed"> 640 }</span>
<span class="line-removed"> 641 #endif</span>
<span class="line-removed"> 642 </span>
<span class="line-removed"> 643 Node* ShenandoahReadBarrierNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 644   Node* id = Identity_impl(phase);</span>
<span class="line-removed"> 645 </span>
<span class="line-removed"> 646   if (id == this &amp;&amp; phase-&gt;is_IterGVN()) {</span>
<span class="line-removed"> 647     Node* n = in(ValueIn);</span>
<span class="line-removed"> 648     // No success in super call. Try to combine identical read barriers.</span>
<span class="line-removed"> 649     for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {</span>
<span class="line-removed"> 650       Node* sibling = n-&gt;out(i);</span>
<span class="line-removed"> 651       if (sibling == this || sibling-&gt;Opcode() != Op_ShenandoahReadBarrier) {</span>
<span class="line-removed"> 652         continue;</span>
<span class="line-removed"> 653       }</span>
<span class="line-removed"> 654       assert(sibling-&gt;in(ValueIn)  == in(ValueIn), &quot;sanity&quot;);</span>
<span class="line-removed"> 655       if (phase-&gt;is_IterGVN()-&gt;hash_find(sibling) &amp;&amp;</span>
<span class="line-removed"> 656           sibling-&gt;bottom_type() == bottom_type() &amp;&amp;</span>
<span class="line-removed"> 657           sibling-&gt;in(Control) == in(Control) &amp;&amp;</span>
<span class="line-removed"> 658           dominates_memory_rb(phase, sibling, this, phase-&gt;is_IterGVN() == NULL)) {</span>
<span class="line-removed"> 659         return sibling;</span>
<span class="line-removed"> 660       }</span>
<span class="line-removed"> 661     }</span>
<span class="line-removed"> 662   }</span>
<span class="line-removed"> 663   return id;</span>
<span class="line-removed"> 664 }</span>
<span class="line-removed"> 665 </span>
<span class="line-removed"> 666 const Type* ShenandoahBarrierNode::Value(PhaseGVN* phase) const {</span>
<span class="line-removed"> 667   // Either input is TOP ==&gt; the result is TOP</span>
<span class="line-removed"> 668   const Type *t1 = phase-&gt;type(in(Memory));</span>
<span class="line-removed"> 669   if (t1 == Type::TOP) return Type::TOP;</span>
<span class="line-removed"> 670   const Type *t2 = phase-&gt;type(in(ValueIn));</span>
<span class="line-removed"> 671   if( t2 == Type::TOP ) return Type::TOP;</span>
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673   if (t2 == TypePtr::NULL_PTR) {</span>
<span class="line-removed"> 674     return _type;</span>
<span class="line-removed"> 675   }</span>
<span class="line-removed"> 676 </span>
<span class="line-removed"> 677   const Type* type = t2-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
<span class="line-removed"> 678   return type;</span>
<span class="line-removed"> 679 }</span>
<span class="line-removed"> 680 </span>
<span class="line-removed"> 681 uint ShenandoahBarrierNode::hash() const {</span>
<span class="line-removed"> 682   return TypeNode::hash() + _allow_fromspace;</span>
<span class="line-removed"> 683 }</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685 uint ShenandoahBarrierNode::cmp(const Node&amp; n) const {</span>
<span class="line-removed"> 686   return _allow_fromspace == ((ShenandoahBarrierNode&amp;) n)._allow_fromspace</span>
<span class="line-removed"> 687     &amp;&amp; TypeNode::cmp(n);</span>
<span class="line-removed"> 688 }</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690 uint ShenandoahBarrierNode::size_of() const {</span>
<span class="line-removed"> 691   return sizeof(*this);</span>
<span class="line-removed"> 692 }</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694 Node* ShenandoahWBMemProjNode::Identity(PhaseGVN* phase) {</span>
<span class="line-removed"> 695   Node* wb = in(WriteBarrier);</span>
<span class="line-removed"> 696   if (wb-&gt;is_top()) return phase-&gt;C-&gt;top(); // Dead path.</span>
<span class="line-removed"> 697 </span>
<span class="line-removed"> 698   assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;expect write barrier&quot;);</span>
<span class="line-removed"> 699   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed"> 700   // We can&#39;t do the below unless the graph is fully constructed.</span>
<span class="line-removed"> 701   if (igvn == NULL) {</span>
<span class="line-removed"> 702     return this;</span>
<span class="line-removed"> 703   }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705   // If the mem projection has no barrier users, it&#39;s not needed anymore.</span>
<span class="line-removed"> 706   if (wb-&gt;outcnt() == 1) {</span>
<span class="line-removed"> 707     return wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed"> 708   }</span>
<span class="line-removed"> 709 </span>
<span class="line-removed"> 710   return this;</span>
<span class="line-removed"> 711 }</span>
<span class="line-removed"> 712 </span>
 713 #ifdef ASSERT
<a name="12" id="anc12"></a><span class="line-modified"> 714 bool ShenandoahBarrierNode::verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used) {</span>
 715   assert(phis.size() == 0, &quot;&quot;);
 716 
 717   while (true) {
 718     if (in-&gt;bottom_type() == TypePtr::NULL_PTR) {
 719       if (trace) {tty-&gt;print_cr(&quot;NULL&quot;);}
 720     } else if (!in-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
 721       if (trace) {tty-&gt;print_cr(&quot;Non oop&quot;);}
<a name="13" id="anc13"></a><span class="line-removed"> 722     } else if (t == ShenandoahLoad &amp;&amp; ShenandoahOptimizeStableFinals &amp;&amp;</span>
<span class="line-removed"> 723                in-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_aryptr() &amp;&amp;</span>
<span class="line-removed"> 724                in-&gt;bottom_type()-&gt;make_ptr()-&gt;is_aryptr()-&gt;is_stable()) {</span>
<span class="line-removed"> 725       if (trace) {tty-&gt;print_cr(&quot;Stable array load&quot;);}</span>
 726     } else {
 727       if (in-&gt;is_ConstraintCast()) {
 728         in = in-&gt;in(1);
 729         continue;
 730       } else if (in-&gt;is_AddP()) {
 731         assert(!in-&gt;in(AddPNode::Address)-&gt;is_top(), &quot;no raw memory access&quot;);
 732         in = in-&gt;in(AddPNode::Address);
 733         continue;
 734       } else if (in-&gt;is_Con()) {
<a name="14" id="anc14"></a><span class="line-modified"> 735         if (trace) {tty-&gt;print(&quot;Found constant&quot;); in-&gt;dump();}</span>
<span class="line-modified"> 736       } else if (in-&gt;is_ShenandoahBarrier()) {</span>















 737         if (t == ShenandoahOopStore) {
<a name="15" id="anc15"></a><span class="line-removed"> 738           if (in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 739             return false;</span>
<span class="line-removed"> 740           }</span>
 741           uint i = 0;
 742           for (; i &lt; phis.size(); i++) {
 743             Node* n = phis.node_at(i);
 744             if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 745               break;
 746             }
 747           }
 748           if (i == phis.size()) {
 749             return false;
 750           }
<a name="16" id="anc16"></a><span class="line-removed"> 751         } else if (t == ShenandoahStore &amp;&amp; in-&gt;Opcode() != Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed"> 752           return false;</span>
 753         }
 754         barriers_used.push(in);
 755         if (trace) {tty-&gt;print(&quot;Found barrier&quot;); in-&gt;dump();}
 756       } else if (in-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {
 757         if (t != ShenandoahOopStore) {
 758           in = in-&gt;in(1);
 759           continue;
 760         }
 761         if (trace) {tty-&gt;print(&quot;Found enqueue barrier&quot;); in-&gt;dump();}
 762         phis.push(in, in-&gt;req());
 763         in = in-&gt;in(1);
 764         continue;
 765       } else if (in-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;is_Allocate()) {
<a name="17" id="anc17"></a><span class="line-modified"> 766         if (trace) {tty-&gt;print(&quot;Found alloc&quot;); in-&gt;in(0)-&gt;dump();}</span>







 767       } else if (in-&gt;is_Phi()) {
 768         if (!visited.test_set(in-&gt;_idx)) {
 769           if (trace) {tty-&gt;print(&quot;Pushed phi:&quot;); in-&gt;dump();}
 770           phis.push(in, 2);
 771           in = in-&gt;in(1);
 772           continue;
 773         }
 774         if (trace) {tty-&gt;print(&quot;Already seen phi:&quot;); in-&gt;dump();}
 775       } else if (in-&gt;Opcode() == Op_CMoveP || in-&gt;Opcode() == Op_CMoveN) {
 776         if (!visited.test_set(in-&gt;_idx)) {
 777           if (trace) {tty-&gt;print(&quot;Pushed cmovep:&quot;); in-&gt;dump();}
 778           phis.push(in, CMoveNode::IfTrue);
 779           in = in-&gt;in(CMoveNode::IfFalse);
 780           continue;
 781         }
 782         if (trace) {tty-&gt;print(&quot;Already seen cmovep:&quot;); in-&gt;dump();}
 783       } else if (in-&gt;Opcode() == Op_EncodeP || in-&gt;Opcode() == Op_DecodeN) {
 784         in = in-&gt;in(1);
 785         continue;
 786       } else {
 787         return false;
 788       }
 789     }
 790     bool cont = false;
 791     while (phis.is_nonempty()) {
 792       uint idx = phis.index();
 793       Node* phi = phis.node();
 794       if (idx &gt;= phi-&gt;req()) {
 795         if (trace) {tty-&gt;print(&quot;Popped phi:&quot;); phi-&gt;dump();}
 796         phis.pop();
 797         continue;
 798       }
 799       if (trace) {tty-&gt;print(&quot;Next entry(%d) for phi:&quot;, idx); phi-&gt;dump();}
 800       in = phi-&gt;in(idx);
 801       phis.set_index(idx+1);
 802       cont = true;
 803       break;
 804     }
 805     if (!cont) {
 806       break;
 807     }
 808   }
 809   return true;
 810 }
 811 
<a name="18" id="anc18"></a><span class="line-modified"> 812 void ShenandoahBarrierNode::report_verify_failure(const char *msg, Node *n1, Node *n2) {</span>
 813   if (n1 != NULL) {
 814     n1-&gt;dump(+10);
 815   }
 816   if (n2 != NULL) {
 817     n2-&gt;dump(+10);
 818   }
 819   fatal(&quot;%s&quot;, msg);
 820 }
 821 
<a name="19" id="anc19"></a><span class="line-modified"> 822 void ShenandoahBarrierNode::verify(RootNode* root) {</span>
 823   ResourceMark rm;
 824   Unique_Node_List wq;
 825   GrowableArray&lt;Node*&gt; barriers;
 826   Unique_Node_List barriers_used;
 827   Node_Stack phis(0);
 828   VectorSet visited(Thread::current()-&gt;resource_area());
 829   const bool trace = false;
 830   const bool verify_no_useless_barrier = false;
 831 
 832   wq.push(root);
 833   for (uint next = 0; next &lt; wq.size(); next++) {
 834     Node *n = wq.at(next);
 835     if (n-&gt;is_Load()) {
 836       const bool trace = false;
 837       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 838       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 839         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 840       } else {
 841         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 842 
 843         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 844           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 845         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 846                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
 847                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {
 848           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
<a name="20" id="anc20"></a><span class="line-modified"> 849         } else {</span>
<span class="line-modified"> 850           bool verify = true;</span>
<span class="line-removed"> 851           if (adr_type-&gt;isa_instptr()) {</span>
<span class="line-removed"> 852             const TypeInstPtr* tinst = adr_type-&gt;is_instptr();</span>
<span class="line-removed"> 853             ciKlass* k = tinst-&gt;klass();</span>
<span class="line-removed"> 854             assert(k-&gt;is_instance_klass(), &quot;&quot;);</span>
<span class="line-removed"> 855             ciInstanceKlass* ik = (ciInstanceKlass*)k;</span>
<span class="line-removed"> 856             int offset = adr_type-&gt;offset();</span>
<span class="line-removed"> 857 </span>
<span class="line-removed"> 858             if ((ik-&gt;debug_final_field_at(offset) &amp;&amp; ShenandoahOptimizeInstanceFinals) ||</span>
<span class="line-removed"> 859                 (ik-&gt;debug_stable_field_at(offset) &amp;&amp; ShenandoahOptimizeStableFinals)) {</span>
<span class="line-removed"> 860               if (trace) {tty-&gt;print_cr(&quot;Final/stable&quot;);}</span>
<span class="line-removed"> 861               verify = false;</span>
<span class="line-removed"> 862             } else if (k == ciEnv::current()-&gt;Class_klass() &amp;&amp;</span>
<span class="line-removed"> 863                        tinst-&gt;const_oop() != NULL &amp;&amp;</span>
<span class="line-removed"> 864                        tinst-&gt;offset() &gt;= (ik-&gt;size_helper() * wordSize)) {</span>
<span class="line-removed"> 865               ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();</span>
<span class="line-removed"> 866               ciField* field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);</span>
<span class="line-removed"> 867               if ((ShenandoahOptimizeStaticFinals &amp;&amp; field-&gt;is_final()) ||</span>
<span class="line-removed"> 868                   (ShenandoahOptimizeStableFinals &amp;&amp; field-&gt;is_stable())) {</span>
<span class="line-removed"> 869                 verify = false;</span>
<span class="line-removed"> 870               }</span>
<span class="line-removed"> 871             }</span>
<span class="line-removed"> 872           }</span>
<span class="line-removed"> 873 </span>
<span class="line-removed"> 874           if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
<span class="line-removed"> 875             report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);</span>
<span class="line-removed"> 876           }</span>
 877         }
 878       }
 879     } else if (n-&gt;is_Store()) {
 880       const bool trace = false;
 881 
 882       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 883       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 884         Node* adr = n-&gt;in(MemNode::Address);
 885         bool verify = true;
 886 
 887         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 888           adr = adr-&gt;in(AddPNode::Address);
 889           if (adr-&gt;is_AddP()) {
 890             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 891             adr = adr-&gt;in(AddPNode::Address);
 892             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 893                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
 894                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_ThreadLocal &amp;&amp;
 895                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Offset)-&gt;find_intptr_t_con(-1) == in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset())) {
 896               if (trace) {tty-&gt;print_cr(&quot;SATB prebarrier&quot;);}
 897               verify = false;
 898             }
 899           }
 900         }
 901 
<a name="21" id="anc21"></a><span class="line-modified"> 902         if (verify &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 903           report_verify_failure(&quot;Shenandoah verification: Store should have barriers&quot;, n);
 904         }
 905       }
<a name="22" id="anc22"></a><span class="line-modified"> 906       if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 907         report_verify_failure(&quot;Shenandoah verification: Store (address) should have barriers&quot;, n);
 908       }
 909     } else if (n-&gt;Opcode() == Op_CmpP) {
 910       const bool trace = false;
 911 
 912       Node* in1 = n-&gt;in(1);
 913       Node* in2 = n-&gt;in(2);
 914       if (in1-&gt;bottom_type()-&gt;isa_oopptr()) {
 915         if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 916 
 917         bool mark_inputs = false;
 918         if (in1-&gt;bottom_type() == TypePtr::NULL_PTR || in2-&gt;bottom_type() == TypePtr::NULL_PTR ||
 919             (in1-&gt;is_Con() || in2-&gt;is_Con())) {
 920           if (trace) {tty-&gt;print_cr(&quot;Comparison against a constant&quot;);}
 921           mark_inputs = true;
 922         } else if ((in1-&gt;is_CheckCastPP() &amp;&amp; in1-&gt;in(1)-&gt;is_Proj() &amp;&amp; in1-&gt;in(1)-&gt;in(0)-&gt;is_Allocate()) ||
 923                    (in2-&gt;is_CheckCastPP() &amp;&amp; in2-&gt;in(1)-&gt;is_Proj() &amp;&amp; in2-&gt;in(1)-&gt;in(0)-&gt;is_Allocate())) {
 924           if (trace) {tty-&gt;print_cr(&quot;Comparison with newly alloc&#39;ed object&quot;);}
 925           mark_inputs = true;
 926         } else {
 927           assert(in2-&gt;bottom_type()-&gt;isa_oopptr(), &quot;&quot;);
 928 
<a name="23" id="anc23"></a><span class="line-modified"> 929           if (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahStore, trace, barriers_used) ||</span>
<span class="line-modified"> 930               !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 931             report_verify_failure(&quot;Shenandoah verification: Cmp should have barriers&quot;, n);
 932           }
 933         }
 934         if (verify_no_useless_barrier &amp;&amp;
 935             mark_inputs &amp;&amp;
<a name="24" id="anc24"></a><span class="line-modified"> 936             (!ShenandoahBarrierNode::verify_helper(in1, phis, visited, ShenandoahValue, trace, barriers_used) ||</span>
<span class="line-modified"> 937              !ShenandoahBarrierNode::verify_helper(in2, phis, visited, ShenandoahValue, trace, barriers_used))) {</span>
 938           phis.clear();
<a name="25" id="anc25"></a><span class="line-modified"> 939           visited.Reset();</span>
 940         }
 941       }
 942     } else if (n-&gt;is_LoadStore()) {
 943       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
<a name="26" id="anc26"></a><span class="line-modified"> 944           !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::ValueIn), phis, visited, ShenandoahStoreValEnqueueBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {</span>
 945         report_verify_failure(&quot;Shenandoah verification: LoadStore (value) should have barriers&quot;, n);
 946       }
 947 
<a name="27" id="anc27"></a><span class="line-modified"> 948       if (n-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; !ShenandoahBarrierNode::verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
 949         report_verify_failure(&quot;Shenandoah verification: LoadStore (address) should have barriers&quot;, n);
 950       }
 951     } else if (n-&gt;Opcode() == Op_CallLeafNoFP || n-&gt;Opcode() == Op_CallLeaf) {
 952       CallNode* call = n-&gt;as_Call();
 953 
 954       static struct {
 955         const char* name;
 956         struct {
 957           int pos;
 958           verify_type t;
 959         } args[6];
 960       } calls[] = {
 961         &quot;aescrypt_encryptBlock&quot;,
 962         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 963           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 964         &quot;aescrypt_decryptBlock&quot;,
 965         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 966           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 967         &quot;multiplyToLen&quot;,
 968         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { TypeFunc::Parms+4, ShenandoahStore },
 969           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 970         &quot;squareToLen&quot;,
 971         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },   { -1,  ShenandoahNone},
 972           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 973         &quot;montgomery_multiply&quot;,
 974         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },
 975           { TypeFunc::Parms+6, ShenandoahStore }, { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 976         &quot;montgomery_square&quot;,
 977         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+5, ShenandoahStore },
 978           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 979         &quot;mulAdd&quot;,
 980         { { TypeFunc::Parms, ShenandoahStore },  { TypeFunc::Parms+1, ShenandoahLoad },   { -1,  ShenandoahNone},
 981           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 982         &quot;vectorizedMismatch&quot;,
 983         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahLoad },   { -1,  ShenandoahNone},
 984           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 985         &quot;updateBytesCRC32&quot;,
 986         { { TypeFunc::Parms+1, ShenandoahLoad }, { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
 987           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 988         &quot;updateBytesAdler32&quot;,
 989         { { TypeFunc::Parms+1, ShenandoahLoad }, { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
 990           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 991         &quot;updateBytesCRC32C&quot;,
 992         { { TypeFunc::Parms+1, ShenandoahLoad }, { TypeFunc::Parms+3, ShenandoahLoad},    { -1,  ShenandoahNone},
 993           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
 994         &quot;counterMode_AESCrypt&quot;,
 995         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 996           { TypeFunc::Parms+3, ShenandoahStore }, { TypeFunc::Parms+5, ShenandoahStore }, { TypeFunc::Parms+6, ShenandoahStore } },
 997         &quot;cipherBlockChaining_encryptAESCrypt&quot;,
 998         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
 999           { TypeFunc::Parms+3, ShenandoahLoad },  { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1000         &quot;cipherBlockChaining_decryptAESCrypt&quot;,
1001         { { TypeFunc::Parms, ShenandoahLoad },   { TypeFunc::Parms+1, ShenandoahStore },  { TypeFunc::Parms+2, ShenandoahLoad },
1002           { TypeFunc::Parms+3, ShenandoahLoad },  { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1003         &quot;shenandoah_clone_barrier&quot;,
1004         { { TypeFunc::Parms, ShenandoahLoad },   { -1,  ShenandoahNone},                  { -1,  ShenandoahNone},
1005           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1006         &quot;ghash_processBlocks&quot;,
1007         { { TypeFunc::Parms, ShenandoahStore },  { TypeFunc::Parms+1, ShenandoahLoad },   { TypeFunc::Parms+2, ShenandoahLoad },
1008           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1009         &quot;sha1_implCompress&quot;,
1010         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1011           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1012         &quot;sha256_implCompress&quot;,
1013         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1014           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1015         &quot;sha512_implCompress&quot;,
1016         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1017           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1018         &quot;sha1_implCompressMB&quot;,
1019         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1020           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1021         &quot;sha256_implCompressMB&quot;,
1022         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1023           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1024         &quot;sha512_implCompressMB&quot;,
1025         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahStore },   { -1, ShenandoahNone },
1026           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1027         &quot;encodeBlock&quot;,
1028         { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+3, ShenandoahStore },   { -1, ShenandoahNone },
1029           { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },
1030       };
1031 
1032       if (call-&gt;is_call_to_arraycopystub()) {
1033         Node* dest = NULL;
1034         const TypeTuple* args = n-&gt;as_Call()-&gt;_tf-&gt;domain();
1035         for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
1036           if (args-&gt;field_at(i)-&gt;isa_ptr()) {
1037             j++;
1038             if (j == 2) {
1039               dest = n-&gt;in(i);
1040               break;
1041             }
1042           }
1043         }
<a name="28" id="anc28"></a><span class="line-modified">1044         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahLoad, trace, barriers_used) ||</span>
<span class="line-modified">1045             !ShenandoahBarrierNode::verify_helper(dest, phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
1046           report_verify_failure(&quot;Shenandoah verification: ArrayCopy should have barriers&quot;, n);
1047         }
1048       } else if (strlen(call-&gt;_name) &gt; 5 &amp;&amp;
1049                  !strcmp(call-&gt;_name + strlen(call-&gt;_name) - 5, &quot;_fill&quot;)) {
<a name="29" id="anc29"></a><span class="line-modified">1050         if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(TypeFunc::Parms), phis, visited, ShenandoahStore, trace, barriers_used)) {</span>
1051           report_verify_failure(&quot;Shenandoah verification: _fill should have barriers&quot;, n);
1052         }
1053       } else if (!strcmp(call-&gt;_name, &quot;shenandoah_wb_pre&quot;)) {
1054         // skip
1055       } else {
1056         const int calls_len = sizeof(calls) / sizeof(calls[0]);
1057         int i = 0;
1058         for (; i &lt; calls_len; i++) {
1059           if (!strcmp(calls[i].name, call-&gt;_name)) {
1060             break;
1061           }
1062         }
1063         if (i != calls_len) {
1064           const uint args_len = sizeof(calls[0].args) / sizeof(calls[0].args[0]);
1065           for (uint j = 0; j &lt; args_len; j++) {
1066             int pos = calls[i].args[j].pos;
1067             if (pos == -1) {
1068               break;
1069             }
<a name="30" id="anc30"></a><span class="line-modified">1070             if (!ShenandoahBarrierNode::verify_helper(call-&gt;in(pos), phis, visited, calls[i].args[j].t, trace, barriers_used)) {</span>
1071               report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
1072             }
1073           }
1074           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
1075             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1076                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
1077               uint k = 0;
1078               for (; k &lt; args_len &amp;&amp; calls[i].args[k].pos != (int)j; k++);
1079               if (k == args_len) {
1080                 fatal(&quot;arg %d for call %s not covered&quot;, j, call-&gt;_name);
1081               }
1082             }
1083           }
1084         } else {
1085           for (uint j = TypeFunc::Parms; j &lt; call-&gt;req(); j++) {
1086             if (call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1087                 call-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_oopptr()) {
1088               fatal(&quot;%s not covered&quot;, call-&gt;_name);
1089             }
1090           }
1091         }
1092       }
<a name="31" id="anc31"></a><span class="line-modified">1093     } else if (n-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1094       assert(!barriers.contains(n), &quot;&quot;);</span>
<span class="line-removed">1095       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;find_out_with(Op_ShenandoahWBMemProj) != NULL, &quot;bad shenandoah write barrier&quot;);</span>
<span class="line-removed">1096       assert(n-&gt;Opcode() != Op_ShenandoahWriteBarrier || n-&gt;outcnt() &gt; 1, &quot;bad shenandoah write barrier&quot;);</span>
<span class="line-removed">1097       barriers.push(n);</span>
<span class="line-removed">1098     } else if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
1099       // skip
<a name="32" id="anc32"></a><span class="line-removed">1100     } else if (n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1101       assert(n-&gt;in(0) == NULL &amp;&amp; n-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;strange ShenandoahWBMemProj&quot;);</span>
1102     } else if (n-&gt;is_AddP()
1103                || n-&gt;is_Phi()
1104                || n-&gt;is_ConstraintCast()
1105                || n-&gt;Opcode() == Op_Return
1106                || n-&gt;Opcode() == Op_CMoveP
1107                || n-&gt;Opcode() == Op_CMoveN
1108                || n-&gt;Opcode() == Op_Rethrow
1109                || n-&gt;is_MemBar()
1110                || n-&gt;Opcode() == Op_Conv2B
1111                || n-&gt;Opcode() == Op_SafePoint
1112                || n-&gt;is_CallJava()
1113                || n-&gt;Opcode() == Op_Unlock
1114                || n-&gt;Opcode() == Op_EncodeP
1115                || n-&gt;Opcode() == Op_DecodeN) {
1116       // nothing to do
1117     } else {
1118       static struct {
1119         int opcode;
1120         struct {
1121           int pos;
1122           verify_type t;
1123         } inputs[2];
1124       } others[] = {
1125         Op_FastLock,
1126         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
1127         Op_Lock,
1128         { { TypeFunc::Parms, ShenandoahLoad },    { -1, ShenandoahNone} },
1129         Op_ArrayCopy,
1130         { { ArrayCopyNode::Src, ShenandoahLoad }, { ArrayCopyNode::Dest, ShenandoahStore } },
1131         Op_StrCompressedCopy,
1132         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
1133         Op_StrInflatedCopy,
1134         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
1135         Op_AryEq,
1136         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
1137         Op_StrIndexOf,
1138         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
1139         Op_StrComp,
1140         { { 2, ShenandoahLoad },                  { 4, ShenandoahLoad } },
1141         Op_StrEquals,
1142         { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } },
1143         Op_EncodeISOArray,
1144         { { 2, ShenandoahLoad },                  { 3, ShenandoahStore } },
1145         Op_HasNegatives,
1146         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone} },
1147         Op_CastP2X,
1148         { { 1, ShenandoahLoad },                  { -1, ShenandoahNone} },
1149         Op_StrIndexOfChar,
1150         { { 2, ShenandoahLoad },                  { -1, ShenandoahNone } },
1151       };
1152 
1153       const int others_len = sizeof(others) / sizeof(others[0]);
1154       int i = 0;
1155       for (; i &lt; others_len; i++) {
1156         if (others[i].opcode == n-&gt;Opcode()) {
1157           break;
1158         }
1159       }
1160       uint stop = n-&gt;is_Call() ? n-&gt;as_Call()-&gt;tf()-&gt;domain()-&gt;cnt() : n-&gt;req();
1161       if (i != others_len) {
1162         const uint inputs_len = sizeof(others[0].inputs) / sizeof(others[0].inputs[0]);
1163         for (uint j = 0; j &lt; inputs_len; j++) {
1164           int pos = others[i].inputs[j].pos;
1165           if (pos == -1) {
1166             break;
1167           }
<a name="33" id="anc33"></a><span class="line-modified">1168           if (!ShenandoahBarrierNode::verify_helper(n-&gt;in(pos), phis, visited, others[i].inputs[j].t, trace, barriers_used)) {</span>
1169             report_verify_failure(&quot;Shenandoah verification: intrinsic calls should have barriers&quot;, n);
1170           }
1171         }
1172         for (uint j = 1; j &lt; stop; j++) {
1173           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1174               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
1175             uint k = 0;
1176             for (; k &lt; inputs_len &amp;&amp; others[i].inputs[k].pos != (int)j; k++);
1177             if (k == inputs_len) {
1178               fatal(&quot;arg %d for node %s not covered&quot;, j, n-&gt;Name());
1179             }
1180           }
1181         }
1182       } else {
1183         for (uint j = 1; j &lt; stop; j++) {
1184           if (n-&gt;in(j) != NULL &amp;&amp; n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr() &amp;&amp;
1185               n-&gt;in(j)-&gt;bottom_type()-&gt;make_ptr()-&gt;make_oopptr()) {
1186             fatal(&quot;%s not covered&quot;, n-&gt;Name());
1187           }
1188         }
1189       }
1190     }
1191 
1192     if (n-&gt;is_SafePoint()) {
1193       SafePointNode* sfpt = n-&gt;as_SafePoint();
1194       if (verify_no_useless_barrier &amp;&amp; sfpt-&gt;jvms() != NULL) {
1195         for (uint i = sfpt-&gt;jvms()-&gt;scloff(); i &lt; sfpt-&gt;jvms()-&gt;endoff(); i++) {
<a name="34" id="anc34"></a><span class="line-modified">1196           if (!ShenandoahBarrierNode::verify_helper(sfpt-&gt;in(i), phis, visited, ShenandoahLoad, trace, barriers_used)) {</span>
1197             phis.clear();
<a name="35" id="anc35"></a><span class="line-modified">1198             visited.Reset();</span>
1199           }
1200         }
1201       }
1202     }
<a name="36" id="anc36"></a><span class="line-modified">1203     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {</span>
<span class="line-removed">1204       Node *m = n-&gt;in(i);</span>
<span class="line-removed">1205       if (m == NULL) continue;</span>
<span class="line-removed">1206 </span>
<span class="line-removed">1207       // In most cases, inputs should be known to be non null. If it&#39;s</span>
<span class="line-removed">1208       // not the case, it could be a missing cast_not_null() in an</span>
<span class="line-removed">1209       // intrinsic or support might be needed in AddPNode::Ideal() to</span>
<span class="line-removed">1210       // avoid a NULL+offset input.</span>
<span class="line-removed">1211       if (!(n-&gt;is_Phi() ||</span>
<span class="line-removed">1212             (n-&gt;is_SafePoint() &amp;&amp; (!n-&gt;is_CallRuntime() || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;shenandoah_wb_pre&quot;) || !strcmp(n-&gt;as_Call()-&gt;_name, &quot;unsafe_arraycopy&quot;))) ||</span>
<span class="line-removed">1213             n-&gt;Opcode() == Op_CmpP ||</span>
<span class="line-removed">1214             n-&gt;Opcode() == Op_CmpN ||</span>
<span class="line-removed">1215             (n-&gt;Opcode() == Op_StoreP &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="line-removed">1216             (n-&gt;Opcode() == Op_StoreN &amp;&amp; i == StoreNode::ValueIn) ||</span>
<span class="line-removed">1217             n-&gt;is_ConstraintCast() ||</span>
<span class="line-removed">1218             n-&gt;Opcode() == Op_Return ||</span>
<span class="line-removed">1219             n-&gt;Opcode() == Op_Conv2B ||</span>
<span class="line-removed">1220             n-&gt;is_AddP() ||</span>
<span class="line-removed">1221             n-&gt;Opcode() == Op_CMoveP ||</span>
<span class="line-removed">1222             n-&gt;Opcode() == Op_CMoveN ||</span>
<span class="line-removed">1223             n-&gt;Opcode() == Op_Rethrow ||</span>
<span class="line-removed">1224             n-&gt;is_MemBar() ||</span>
<span class="line-removed">1225             n-&gt;is_Mem() ||</span>
<span class="line-removed">1226             n-&gt;Opcode() == Op_AryEq ||</span>
<span class="line-removed">1227             n-&gt;Opcode() == Op_SCMemProj ||</span>
<span class="line-removed">1228             n-&gt;Opcode() == Op_EncodeP ||</span>
<span class="line-removed">1229             n-&gt;Opcode() == Op_DecodeN ||</span>
<span class="line-removed">1230             n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="line-removed">1231             n-&gt;Opcode() == Op_ShenandoahWBMemProj ||</span>
<span class="line-removed">1232             n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier)) {</span>
<span class="line-removed">1233         if (m-&gt;bottom_type()-&gt;make_oopptr() &amp;&amp; m-&gt;bottom_type()-&gt;make_oopptr()-&gt;meet(TypePtr::NULL_PTR) == m-&gt;bottom_type()) {</span>
<span class="line-removed">1234           report_verify_failure(&quot;Shenandoah verification: null input&quot;, n, m);</span>
<span class="line-removed">1235         }</span>
<span class="line-removed">1236       }</span>
<span class="line-removed">1237 </span>
<span class="line-removed">1238       wq.push(m);</span>
<span class="line-removed">1239     }</span>
<span class="line-removed">1240   }</span>
1241 
1242   if (verify_no_useless_barrier) {
1243     for (int i = 0; i &lt; barriers.length(); i++) {
1244       Node* n = barriers.at(i);
1245       if (!barriers_used.member(n)) {
1246         tty-&gt;print(&quot;XXX useless barrier&quot;); n-&gt;dump(-2);
1247         ShouldNotReachHere();
1248       }
1249     }
1250   }
1251 }
1252 #endif
1253 
<a name="37" id="anc37"></a><span class="line-modified">1254 bool ShenandoahBarrierNode::is_dominator_same_ctrl(Node*c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
1255   // That both nodes have the same control is not sufficient to prove
1256   // domination, verify that there&#39;s no path from d to n
1257   ResourceMark rm;
1258   Unique_Node_List wq;
1259   wq.push(d);
1260   for (uint next = 0; next &lt; wq.size(); next++) {
1261     Node *m = wq.at(next);
1262     if (m == n) {
1263       return false;
1264     }
1265     if (m-&gt;is_Phi() &amp;&amp; m-&gt;in(0)-&gt;is_Loop()) {
1266       assert(phase-&gt;ctrl_or_self(m-&gt;in(LoopNode::EntryControl)) != c, &quot;following loop entry should lead to new control&quot;);
1267     } else {
<a name="38" id="anc38"></a>










1268       for (uint i = 0; i &lt; m-&gt;req(); i++) {
1269         if (m-&gt;in(i) != NULL &amp;&amp; phase-&gt;ctrl_or_self(m-&gt;in(i)) == c) {
1270           wq.push(m-&gt;in(i));
1271         }
1272       }
1273     }
1274   }
1275   return true;
1276 }
1277 
<a name="39" id="anc39"></a><span class="line-modified">1278 bool ShenandoahBarrierNode::is_dominator(Node *d_c, Node *n_c, Node* d, Node* n, PhaseIdealLoop* phase) {</span>
1279   if (d_c != n_c) {
1280     return phase-&gt;is_dominator(d_c, n_c);
1281   }
1282   return is_dominator_same_ctrl(d_c, d, n, phase);
1283 }
1284 
1285 Node* next_mem(Node* mem, int alias) {
1286   Node* res = NULL;
1287   if (mem-&gt;is_Proj()) {
1288     res = mem-&gt;in(0);
1289   } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
1290     res = mem-&gt;in(TypeFunc::Memory);
1291   } else if (mem-&gt;is_Phi()) {
1292     res = mem-&gt;in(1);
<a name="40" id="anc40"></a><span class="line-removed">1293   } else if (mem-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1294     res = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
1295   } else if (mem-&gt;is_MergeMem()) {
1296     res = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
1297   } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
1298     assert(alias = Compile::AliasIdxRaw, &quot;following raw memory can&#39;t lead to a barrier&quot;);
1299     res = mem-&gt;in(MemNode::Memory);
<a name="41" id="anc41"></a><span class="line-removed">1300   } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1301     res = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
1302   } else {
1303 #ifdef ASSERT
1304     mem-&gt;dump();
1305 #endif
1306     ShouldNotReachHere();
1307   }
1308   return res;
1309 }
1310 
<a name="42" id="anc42"></a><span class="line-modified">1311 Node* ShenandoahBarrierNode::no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase) {</span>
1312   Node* iffproj = NULL;
1313   while (c != dom) {
1314     Node* next = phase-&gt;idom(c);
1315     assert(next-&gt;unique_ctrl_out() == c || c-&gt;is_Proj() || c-&gt;is_Region(), &quot;multiple control flow out but no proj or region?&quot;);
1316     if (c-&gt;is_Region()) {
1317       ResourceMark rm;
1318       Unique_Node_List wq;
1319       wq.push(c);
1320       for (uint i = 0; i &lt; wq.size(); i++) {
1321         Node *n = wq.at(i);
1322         if (n == next) {
1323           continue;
1324         }
1325         if (n-&gt;is_Region()) {
1326           for (uint j = 1; j &lt; n-&gt;req(); j++) {
1327             wq.push(n-&gt;in(j));
1328           }
1329         } else {
1330           wq.push(n-&gt;in(0));
1331         }
1332       }
1333       for (uint i = 0; i &lt; wq.size(); i++) {
1334         Node *n = wq.at(i);
1335         assert(n-&gt;is_CFG(), &quot;&quot;);
1336         if (n-&gt;is_Multi()) {
1337           for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1338             Node* u = n-&gt;fast_out(j);
1339             if (u-&gt;is_CFG()) {
1340               if (!wq.member(u) &amp;&amp; !u-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
1341                 return NodeSentinel;
1342               }
1343             }
1344           }
1345         }
1346       }
1347     } else  if (c-&gt;is_Proj()) {
1348       if (c-&gt;is_IfProj()) {
1349         if (c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) != NULL) {
1350           // continue;
1351         } else {
1352           if (!allow_one_proj) {
1353             return NodeSentinel;
1354           }
1355           if (iffproj == NULL) {
1356             iffproj = c;
1357           } else {
1358             return NodeSentinel;
1359           }
1360         }
1361       } else if (c-&gt;Opcode() == Op_JumpProj) {
1362         return NodeSentinel; // unsupported
1363       } else if (c-&gt;Opcode() == Op_CatchProj) {
1364         return NodeSentinel; // unsupported
1365       } else if (c-&gt;Opcode() == Op_CProj &amp;&amp; next-&gt;Opcode() == Op_NeverBranch) {
1366         return NodeSentinel; // unsupported
1367       } else {
1368         assert(next-&gt;unique_ctrl_out() == c, &quot;unsupported branch pattern&quot;);
1369       }
1370     }
1371     c = next;
1372   }
1373   return iffproj;
1374 }
1375 
<a name="43" id="anc43"></a><span class="line-modified">1376 bool ShenandoahBarrierNode::build_loop_late_post(PhaseIdealLoop* phase, Node* n) {</span>
<span class="line-removed">1377   if (n-&gt;Opcode() == Op_ShenandoahReadBarrier ||</span>
<span class="line-removed">1378       n-&gt;Opcode() == Op_ShenandoahWriteBarrier ||</span>
<span class="line-removed">1379       n-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">1380 </span>
<span class="line-removed">1381     phase-&gt;build_loop_late_post_work(n, false);</span>
<span class="line-removed">1382 </span>
<span class="line-removed">1383     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1384       // The write barrier and its memory proj must have the same</span>
<span class="line-removed">1385       // control otherwise some loop opts could put nodes (Phis) between</span>
<span class="line-removed">1386       // them</span>
<span class="line-removed">1387       Node* proj = n-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1388       if (proj != NULL) {</span>
<span class="line-removed">1389         phase-&gt;set_ctrl_and_loop(proj, phase-&gt;get_ctrl(n));</span>
<span class="line-removed">1390       }</span>
<span class="line-removed">1391     }</span>
<span class="line-removed">1392     return true;</span>
<span class="line-removed">1393   }</span>
<span class="line-removed">1394   return false;</span>
<span class="line-removed">1395 }</span>
<span class="line-removed">1396 </span>
<span class="line-removed">1397 bool ShenandoahBarrierNode::sink_node(PhaseIdealLoop* phase, Node* ctrl, Node* n_ctrl) {</span>
<span class="line-removed">1398   ctrl = phase-&gt;find_non_split_ctrl(ctrl);</span>
<span class="line-removed">1399   assert(phase-&gt;dom_depth(n_ctrl) &lt;= phase-&gt;dom_depth(ctrl), &quot;n is later than its clone&quot;);</span>
<span class="line-removed">1400   set_req(0, ctrl);</span>
<span class="line-removed">1401   phase-&gt;register_new_node(this, ctrl);</span>
<span class="line-removed">1402   return true;</span>
<span class="line-removed">1403 }</span>
<span class="line-removed">1404 </span>
<span class="line-removed">1405 #ifdef ASSERT</span>
<span class="line-removed">1406 void ShenandoahWriteBarrierNode::memory_dominates_all_paths_helper(Node* c, Node* rep_ctrl, Unique_Node_List&amp; controls, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1407   const bool trace = false;</span>
<span class="line-removed">1408   if (trace) { tty-&gt;print(&quot;X control is&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1409 </span>
<span class="line-removed">1410   uint start = controls.size();</span>
<span class="line-removed">1411   controls.push(c);</span>
<span class="line-removed">1412   for (uint i = start; i &lt; controls.size(); i++) {</span>
<span class="line-removed">1413     Node *n = controls.at(i);</span>
<span class="line-removed">1414 </span>
<span class="line-removed">1415     if (trace) { tty-&gt;print(&quot;X from&quot;); n-&gt;dump(); }</span>
<span class="line-removed">1416 </span>
<span class="line-removed">1417     if (n == rep_ctrl) {</span>
<span class="line-removed">1418       continue;</span>
<span class="line-removed">1419     }</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421     if (n-&gt;is_Proj()) {</span>
<span class="line-removed">1422       Node* n_dom = n-&gt;in(0);</span>
<span class="line-removed">1423       IdealLoopTree* n_dom_loop = phase-&gt;get_loop(n_dom);</span>
<span class="line-removed">1424       if (n-&gt;is_IfProj() &amp;&amp; n_dom-&gt;outcnt() == 2) {</span>
<span class="line-removed">1425         n_dom_loop = phase-&gt;get_loop(n_dom-&gt;as_If()-&gt;proj_out(n-&gt;as_Proj()-&gt;_con == 0 ? 1 : 0));</span>
<span class="line-removed">1426       }</span>
<span class="line-removed">1427       if (n_dom_loop != phase-&gt;ltree_root()) {</span>
<span class="line-removed">1428         Node* tail = n_dom_loop-&gt;tail();</span>
<span class="line-removed">1429         if (tail-&gt;is_Region()) {</span>
<span class="line-removed">1430           for (uint j = 1; j &lt; tail-&gt;req(); j++) {</span>
<span class="line-removed">1431             if (phase-&gt;is_dominator(n_dom, tail-&gt;in(j)) &amp;&amp; !phase-&gt;is_dominator(n, tail-&gt;in(j))) {</span>
<span class="line-removed">1432               assert(phase-&gt;is_dominator(rep_ctrl, tail-&gt;in(j)), &quot;why are we here?&quot;);</span>
<span class="line-removed">1433               // entering loop from below, mark backedge</span>
<span class="line-removed">1434               if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;in(j)-&gt;dump(); }</span>
<span class="line-removed">1435               controls.push(tail-&gt;in(j));</span>
<span class="line-removed">1436               //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="line-removed">1437             }</span>
<span class="line-removed">1438           }</span>
<span class="line-removed">1439         } else if (phase-&gt;get_loop(n) != n_dom_loop &amp;&amp; phase-&gt;is_dominator(n_dom, tail)) {</span>
<span class="line-removed">1440           // entering loop from below, mark backedge</span>
<span class="line-removed">1441           if (trace) { tty-&gt;print(&quot;X pushing backedge&quot;); tail-&gt;dump(); }</span>
<span class="line-removed">1442           controls.push(tail);</span>
<span class="line-removed">1443           //assert(n-&gt;in(0) == n_dom, &quot;strange flow control&quot;);</span>
<span class="line-removed">1444         }</span>
<span class="line-removed">1445       }</span>
<span class="line-removed">1446     }</span>
<span class="line-removed">1447 </span>
<span class="line-removed">1448     if (n-&gt;is_Loop()) {</span>
<span class="line-removed">1449       Node* c = n-&gt;in(LoopNode::EntryControl);</span>
<span class="line-removed">1450       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1451       controls.push(c);</span>
<span class="line-removed">1452     } else if (n-&gt;is_Region()) {</span>
<span class="line-removed">1453       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-removed">1454         Node* c = n-&gt;in(i);</span>
<span class="line-removed">1455         if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1456         controls.push(c);</span>
<span class="line-removed">1457       }</span>
<span class="line-removed">1458     } else {</span>
<span class="line-removed">1459       Node* c = n-&gt;in(0);</span>
<span class="line-removed">1460       if (trace) { tty-&gt;print(&quot;X pushing&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1461       controls.push(c);</span>
<span class="line-removed">1462     }</span>
<span class="line-removed">1463   }</span>
<span class="line-removed">1464 }</span>
<span class="line-removed">1465 </span>
<span class="line-removed">1466 bool ShenandoahWriteBarrierNode::memory_dominates_all_paths(Node* mem, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1467   const bool trace = false;</span>
<span class="line-removed">1468   if (trace) {</span>
<span class="line-removed">1469     tty-&gt;print(&quot;XXX mem is&quot;); mem-&gt;dump();</span>
<span class="line-removed">1470     tty-&gt;print(&quot;XXX rep ctrl is&quot;); rep_ctrl-&gt;dump();</span>
<span class="line-removed">1471     tty-&gt;print_cr(&quot;XXX alias is %d&quot;, alias);</span>
<span class="line-removed">1472   }</span>
<span class="line-removed">1473   ResourceMark rm;</span>
<span class="line-removed">1474   Unique_Node_List wq;</span>
<span class="line-removed">1475   Unique_Node_List controls;</span>
<span class="line-removed">1476   wq.push(mem);</span>
<span class="line-removed">1477   for (uint next = 0; next &lt; wq.size(); next++) {</span>
<span class="line-removed">1478     Node *nn = wq.at(next);</span>
<span class="line-removed">1479     if (trace) { tty-&gt;print(&quot;XX from mem&quot;); nn-&gt;dump(); }</span>
<span class="line-removed">1480     assert(nn-&gt;bottom_type() == Type::MEMORY, &quot;memory only&quot;);</span>
<span class="line-removed">1481 </span>
<span class="line-removed">1482     if (nn-&gt;is_Phi()) {</span>
<span class="line-removed">1483       Node* r = nn-&gt;in(0);</span>
<span class="line-removed">1484       for (DUIterator_Fast jmax, j = r-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1485         Node* u = r-&gt;fast_out(j);</span>
<span class="line-removed">1486         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u != nn &amp;&amp;</span>
<span class="line-removed">1487             (u-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1488           if (trace) { tty-&gt;print(&quot;XX Next mem (other phi)&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1489           wq.push(u);</span>
<span class="line-removed">1490         }</span>
<span class="line-removed">1491       }</span>
<span class="line-removed">1492     }</span>
<span class="line-removed">1493 </span>
<span class="line-removed">1494     for (DUIterator_Fast imax, i = nn-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1495       Node* use = nn-&gt;fast_out(i);</span>
<span class="line-removed">1496 </span>
<span class="line-removed">1497       if (trace) { tty-&gt;print(&quot;XX use %p&quot;, use-&gt;adr_type()); use-&gt;dump(); }</span>
<span class="line-removed">1498       if (use-&gt;is_CFG() &amp;&amp; use-&gt;in(TypeFunc::Memory) == nn) {</span>
<span class="line-removed">1499         Node* c = use-&gt;in(0);</span>
<span class="line-removed">1500         if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="line-removed">1501           memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="line-removed">1502         } else if (use-&gt;is_CallStaticJava() &amp;&amp; use-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0 &amp;&amp; c-&gt;is_Region()) {</span>
<span class="line-removed">1503           Node* region = c;</span>
<span class="line-removed">1504           if (trace) { tty-&gt;print(&quot;XX unc region&quot;); region-&gt;dump(); }</span>
<span class="line-removed">1505           for (uint j = 1; j &lt; region-&gt;req(); j++) {</span>
<span class="line-removed">1506             if (phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {</span>
<span class="line-removed">1507               if (trace) { tty-&gt;print(&quot;XX unc follows&quot;); region-&gt;in(j)-&gt;dump(); }</span>
<span class="line-removed">1508               memory_dominates_all_paths_helper(region-&gt;in(j), rep_ctrl, controls, phase);</span>
<span class="line-removed">1509             }</span>
<span class="line-removed">1510           }</span>
<span class="line-removed">1511         }</span>
<span class="line-removed">1512         //continue;</span>
<span class="line-removed">1513       } else if (use-&gt;is_Phi()) {</span>
<span class="line-removed">1514         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="line-removed">1515         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="line-removed">1516             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1517           for (uint j = 1; j &lt; use-&gt;req(); j++) {</span>
<span class="line-removed">1518             if (use-&gt;in(j) == nn) {</span>
<span class="line-removed">1519               Node* c = use-&gt;in(0)-&gt;in(j);</span>
<span class="line-removed">1520               if (phase-&gt;is_dominator(rep_ctrl, c)) {</span>
<span class="line-removed">1521                 memory_dominates_all_paths_helper(c, rep_ctrl, controls, phase);</span>
<span class="line-removed">1522               }</span>
<span class="line-removed">1523             }</span>
<span class="line-removed">1524           }</span>
<span class="line-removed">1525         }</span>
<span class="line-removed">1526         //        continue;</span>
<span class="line-removed">1527       }</span>
<span class="line-removed">1528 </span>
<span class="line-removed">1529       if (use-&gt;is_MergeMem()) {</span>
<span class="line-removed">1530         if (use-&gt;as_MergeMem()-&gt;memory_at(alias) == nn) {</span>
<span class="line-removed">1531           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1532           // follow the memory edges</span>
<span class="line-removed">1533           wq.push(use);</span>
<span class="line-removed">1534         }</span>
<span class="line-removed">1535       } else if (use-&gt;is_Phi()) {</span>
<span class="line-removed">1536         assert(use-&gt;bottom_type() == Type::MEMORY, &quot;bad phi&quot;);</span>
<span class="line-removed">1537         if ((use-&gt;adr_type() == TypePtr::BOTTOM) ||</span>
<span class="line-removed">1538             phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1539           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1540           // follow the memory edges</span>
<span class="line-removed">1541           wq.push(use);</span>
<span class="line-removed">1542         }</span>
<span class="line-removed">1543       } else if (use-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">1544                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1545         if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); use-&gt;dump(); }</span>
<span class="line-removed">1546         // follow the memory edges</span>
<span class="line-removed">1547         wq.push(use);</span>
<span class="line-removed">1548       } else if ((use-&gt;is_SafePoint() || use-&gt;is_MemBar()) &amp;&amp;</span>
<span class="line-removed">1549                  (use-&gt;adr_type() == TypePtr::BOTTOM || phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias)) {</span>
<span class="line-removed">1550         for (DUIterator_Fast jmax, j = use-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1551           Node* u = use-&gt;fast_out(j);</span>
<span class="line-removed">1552           if (u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">1553             if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1554             // follow the memory edges</span>
<span class="line-removed">1555             wq.push(u);</span>
<span class="line-removed">1556           }</span>
<span class="line-removed">1557         }</span>
<span class="line-removed">1558       } else if (use-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp; phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == alias) {</span>
<span class="line-removed">1559         Node* m = use-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1560         if (m != NULL) {</span>
<span class="line-removed">1561           if (trace) { tty-&gt;print(&quot;XX Next mem&quot;); m-&gt;dump(); }</span>
<span class="line-removed">1562           // follow the memory edges</span>
<span class="line-removed">1563           wq.push(m);</span>
<span class="line-removed">1564         }</span>
<span class="line-removed">1565       }</span>
<span class="line-removed">1566     }</span>
<span class="line-removed">1567   }</span>
<span class="line-removed">1568 </span>
<span class="line-removed">1569   if (controls.size() == 0) {</span>
<span class="line-removed">1570     return false;</span>
<span class="line-removed">1571   }</span>
<span class="line-removed">1572 </span>
<span class="line-removed">1573   for (uint i = 0; i &lt; controls.size(); i++) {</span>
<span class="line-removed">1574     Node *n = controls.at(i);</span>
<span class="line-removed">1575 </span>
<span class="line-removed">1576     if (trace) { tty-&gt;print(&quot;X checking&quot;); n-&gt;dump(); }</span>
<span class="line-removed">1577 </span>
<span class="line-removed">1578     if (n-&gt;unique_ctrl_out() != NULL) {</span>
<span class="line-removed">1579       continue;</span>
<span class="line-removed">1580     }</span>
<span class="line-removed">1581 </span>
<span class="line-removed">1582     if (n-&gt;Opcode() == Op_NeverBranch) {</span>
<span class="line-removed">1583       Node* taken = n-&gt;as_Multi()-&gt;proj_out(0);</span>
<span class="line-removed">1584       if (!controls.member(taken)) {</span>
<span class="line-removed">1585         if (trace) { tty-&gt;print(&quot;X not seen&quot;); taken-&gt;dump(); }</span>
<span class="line-removed">1586         return false;</span>
<span class="line-removed">1587       }</span>
<span class="line-removed">1588       continue;</span>
<span class="line-removed">1589     }</span>
<span class="line-removed">1590 </span>
<span class="line-removed">1591     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1592       Node* u = n-&gt;fast_out(j);</span>
<span class="line-removed">1593 </span>
<span class="line-removed">1594       if (u-&gt;is_CFG()) {</span>
<span class="line-removed">1595         if (!controls.member(u)) {</span>
<span class="line-removed">1596           if (u-&gt;is_Proj() &amp;&amp; u-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {</span>
<span class="line-removed">1597             if (trace) { tty-&gt;print(&quot;X not seen but unc&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1598           } else {</span>
<span class="line-removed">1599             Node* c = u;</span>
<span class="line-removed">1600             do {</span>
<span class="line-removed">1601               c = c-&gt;unique_ctrl_out();</span>
<span class="line-removed">1602             } while (c != NULL &amp;&amp; c-&gt;is_Region());</span>
<span class="line-removed">1603             if (c != NULL &amp;&amp; c-&gt;Opcode() == Op_Halt) {</span>
<span class="line-removed">1604               if (trace) { tty-&gt;print(&quot;X not seen but halt&quot;); c-&gt;dump(); }</span>
<span class="line-removed">1605             } else {</span>
<span class="line-removed">1606               if (trace) { tty-&gt;print(&quot;X not seen&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1607               return false;</span>
<span class="line-removed">1608             }</span>
<span class="line-removed">1609           }</span>
<span class="line-removed">1610         } else {</span>
<span class="line-removed">1611           if (trace) { tty-&gt;print(&quot;X seen&quot;); u-&gt;dump(); }</span>
<span class="line-removed">1612         }</span>
<span class="line-removed">1613       }</span>
<span class="line-removed">1614     }</span>
<span class="line-removed">1615   }</span>
<span class="line-removed">1616   return true;</span>
<span class="line-removed">1617 }</span>
<span class="line-removed">1618 #endif</span>
<span class="line-removed">1619 </span>
<span class="line-removed">1620 Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node*&amp; mem_ctrl, Node* n, Node* rep_ctrl, int alias, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1621   ResourceMark rm;</span>
<span class="line-removed">1622   VectorSet wq(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">1623   wq.set(mem-&gt;_idx);</span>
<span class="line-removed">1624   mem_ctrl = phase-&gt;get_ctrl(mem);</span>
<span class="line-removed">1625   while (!is_dominator(mem_ctrl, rep_ctrl, mem, n, phase)) {</span>
<span class="line-removed">1626     mem = next_mem(mem, alias);</span>
<span class="line-removed">1627     if (wq.test_set(mem-&gt;_idx)) {</span>
<span class="line-removed">1628       return NULL; // hit an unexpected loop</span>
<span class="line-removed">1629     }</span>
<span class="line-removed">1630     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="line-removed">1631   }</span>
<span class="line-removed">1632   if (mem-&gt;is_MergeMem()) {</span>
<span class="line-removed">1633     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);</span>
<span class="line-removed">1634     mem_ctrl = phase-&gt;ctrl_or_self(mem);</span>
<span class="line-removed">1635   }</span>
<span class="line-removed">1636   return mem;</span>
<span class="line-removed">1637 }</span>
<span class="line-removed">1638 </span>
<span class="line-removed">1639 Node* ShenandoahBarrierNode::dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase) {</span>
1640   ResourceMark rm;
1641   VectorSet wq(Thread::current()-&gt;resource_area());
1642   wq.set(mem-&gt;_idx);
1643   mem_ctrl = phase-&gt;ctrl_or_self(mem);
1644   while (!phase-&gt;is_dominator(mem_ctrl, ctrl) || mem_ctrl == ctrl) {
1645     mem = next_mem(mem, alias);
1646     if (wq.test_set(mem-&gt;_idx)) {
1647       return NULL;
1648     }
1649     mem_ctrl = phase-&gt;ctrl_or_self(mem);
1650   }
1651   if (mem-&gt;is_MergeMem()) {
1652     mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias);
1653     mem_ctrl = phase-&gt;ctrl_or_self(mem);
1654   }
1655   return mem;
1656 }
1657 
<a name="44" id="anc44"></a><span class="line-modified">1658 static void disconnect_barrier_mem(Node* wb, PhaseIterGVN&amp; igvn) {</span>
<span class="line-modified">1659   Node* mem_in = wb-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-modified">1660   Node* proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-modified">1661 </span>
<span class="line-modified">1662   for (DUIterator_Last imin, i = proj-&gt;last_outs(imin); i &gt;= imin; ) {</span>
<span class="line-modified">1663     Node* u = proj-&gt;last_out(i);</span>
<span class="line-modified">1664     igvn.rehash_node_delayed(u);</span>
<span class="line-modified">1665     int nb = u-&gt;replace_edge(proj, mem_in);</span>
<span class="line-modified">1666     assert(nb &gt; 0, &quot;no replacement?&quot;);</span>
<span class="line-modified">1667     i -= nb;</span>
<span class="line-modified">1668   }</span>
<span class="line-modified">1669 }</span>
<span class="line-modified">1670 </span>
<span class="line-modified">1671 Node* ShenandoahWriteBarrierNode::move_above_predicates(LoopNode* cl, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified">1672   Node* entry = cl-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl);</span>
<span class="line-modified">1673   Node* above_pred = phase-&gt;skip_all_loop_predicates(entry);</span>
<span class="line-modified">1674   Node* ctrl = entry;</span>
<span class="line-modified">1675   while (ctrl != above_pred) {</span>
<span class="line-modified">1676     Node* next = ctrl-&gt;in(0);</span>
<span class="line-modified">1677     if (!phase-&gt;is_dominator(val_ctrl, next)) {</span>
<span class="line-modified">1678       break;</span>






























1679     }
<a name="45" id="anc45"></a><span class="line-modified">1680     ctrl = next;</span>
<span class="line-modified">1681   }</span>
<span class="line-modified">1682   return ctrl;</span>
1683 }
1684 
<a name="46" id="anc46"></a><span class="line-modified">1685 static MemoryGraphFixer* find_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias) {</span>
<span class="line-modified">1686   for (int i = 0; i &lt; memory_graph_fixers.length(); i++) {</span>
<span class="line-modified">1687     if (memory_graph_fixers.at(i)-&gt;alias() == alias) {</span>
<span class="line-modified">1688       return memory_graph_fixers.at(i);</span>

1689     }
1690   }
<a name="47" id="anc47"></a><span class="line-removed">1691   return NULL;</span>
1692 }
1693 
<a name="48" id="anc48"></a><span class="line-modified">1694 static MemoryGraphFixer* create_fixer(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, int alias, PhaseIdealLoop* phase, bool include_lsm) {</span>
<span class="line-modified">1695   assert(find_fixer(memory_graph_fixers, alias) == NULL, &quot;none should exist yet&quot;);</span>
<span class="line-modified">1696   MemoryGraphFixer* fixer = new MemoryGraphFixer(alias, include_lsm, phase);</span>
<span class="line-modified">1697   memory_graph_fixers.push(fixer);</span>
<span class="line-modified">1698   return fixer;</span>




1699 }
1700 
<a name="49" id="anc49"></a><span class="line-modified">1701 void ShenandoahWriteBarrierNode::try_move_before_loop_helper(LoopNode* cl, Node* val_ctrl, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="line-modified">1702   assert(cl-&gt;is_Loop(), &quot;bad control&quot;);</span>
<span class="line-modified">1703   Node* ctrl = move_above_predicates(cl, val_ctrl, phase);</span>
<span class="line-modified">1704   Node* mem_ctrl = NULL;</span>
<span class="line-modified">1705   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-modified">1706 </span>
<span class="line-modified">1707   MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="line-modified">1708   if (fixer == NULL) {</span>
<span class="line-modified">1709     fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="line-modified">1710   }</span>
<span class="line-modified">1711 </span>
<span class="line-modified">1712   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1713 </span>
<span class="line-removed">1714   fixer-&gt;remove(proj);</span>
<span class="line-removed">1715   Node* mem = fixer-&gt;find_mem(ctrl, NULL);</span>
<span class="line-removed">1716 </span>
<span class="line-removed">1717   assert(!ShenandoahVerifyOptoBarriers || memory_dominates_all_paths(mem, ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="line-removed">1718 </span>
<span class="line-removed">1719   phase-&gt;set_ctrl_and_loop(this, ctrl);</span>
<span class="line-removed">1720   phase-&gt;igvn().replace_input_of(this, Control, ctrl);</span>
1721 
<a name="50" id="anc50"></a><span class="line-modified">1722   disconnect_barrier_mem(this, phase-&gt;igvn());</span>









1723 
<a name="51" id="anc51"></a><span class="line-modified">1724   phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="line-modified">1725   phase-&gt;set_ctrl_and_loop(proj, ctrl);</span>


1726 
<a name="52" id="anc52"></a><span class="line-modified">1727   fixer-&gt;fix_mem(ctrl, ctrl, mem, mem, proj, uses);</span>
<span class="line-removed">1728   assert(proj-&gt;outcnt() &gt; 0, &quot;disconnected write barrier&quot;);</span>
1729 }
1730 
<a name="53" id="anc53"></a><span class="line-modified">1731 LoopNode* ShenandoahWriteBarrierNode::try_move_before_pre_loop(Node* c, Node* val_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-modified">1732   // A write barrier between a pre and main loop can get in the way of</span>
<span class="line-modified">1733   // vectorization. Move it above the pre loop if possible</span>
<span class="line-modified">1734   CountedLoopNode* cl = NULL;</span>
<span class="line-modified">1735   if (c-&gt;is_IfFalse() &amp;&amp;</span>
<span class="line-modified">1736       c-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="line-modified">1737     cl = c-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">1738   } else if (c-&gt;is_IfProj() &amp;&amp;</span>
<span class="line-modified">1739              c-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-modified">1740              c-&gt;in(0)-&gt;in(0)-&gt;is_IfFalse() &amp;&amp;</span>
<span class="line-modified">1741              c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_CountedLoopEnd()) {</span>
<span class="line-modified">1742     cl = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;as_CountedLoopEnd()-&gt;loopnode();</span>
<span class="line-modified">1743   }</span>
<span class="line-modified">1744   if (cl != NULL &amp;&amp;</span>
<span class="line-removed">1745       cl-&gt;is_pre_loop() &amp;&amp;</span>
<span class="line-removed">1746       val_ctrl != cl &amp;&amp;</span>
<span class="line-removed">1747       phase-&gt;is_dominator(val_ctrl, cl)) {</span>
<span class="line-removed">1748     return cl;</span>
1749   }
<a name="54" id="anc54"></a><span class="line-removed">1750   return NULL;</span>
1751 }
1752 
<a name="55" id="anc55"></a><span class="line-modified">1753 void ShenandoahWriteBarrierNode::try_move_before_loop(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses) {</span>
<span class="line-modified">1754   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-modified">1755   IdealLoopTree *n_loop = phase-&gt;get_loop(n_ctrl);</span>
<span class="line-modified">1756   Node* val = in(ValueIn);</span>
<span class="line-modified">1757   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-modified">1758   if (n_loop != phase-&gt;ltree_root() &amp;&amp; !n_loop-&gt;_irreducible) {</span>
<span class="line-modified">1759     IdealLoopTree *val_loop = phase-&gt;get_loop(val_ctrl);</span>
<span class="line-modified">1760     Node* mem = in(Memory);</span>
<span class="line-modified">1761     IdealLoopTree *mem_loop = phase-&gt;get_loop(phase-&gt;get_ctrl(mem));</span>
<span class="line-modified">1762     if (!n_loop-&gt;is_member(val_loop) &amp;&amp;</span>
<span class="line-modified">1763         n_loop-&gt;is_member(mem_loop)) {</span>
<span class="line-modified">1764       Node* n_loop_head = n_loop-&gt;_head;</span>
<span class="line-modified">1765 </span>
<span class="line-modified">1766       if (n_loop_head-&gt;is_Loop()) {</span>
<span class="line-modified">1767         LoopNode* loop = n_loop_head-&gt;as_Loop();</span>
<span class="line-modified">1768         if (n_loop_head-&gt;is_CountedLoop() &amp;&amp; n_loop_head-&gt;as_CountedLoop()-&gt;is_main_loop()) {</span>
<span class="line-modified">1769           LoopNode* res = try_move_before_pre_loop(n_loop_head-&gt;in(LoopNode::EntryControl), val_ctrl, phase);</span>
<span class="line-modified">1770           if (res != NULL) {</span>
<span class="line-modified">1771             loop = res;</span>
<span class="line-modified">1772           }</span>
<span class="line-removed">1773         }</span>
1774 
<a name="56" id="anc56"></a><span class="line-modified">1775         try_move_before_loop_helper(loop, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1776       }</span>
<span class="line-removed">1777     }</span>
<span class="line-removed">1778   }</span>
<span class="line-removed">1779   LoopNode* ctrl = try_move_before_pre_loop(in(0), val_ctrl, phase);</span>
<span class="line-removed">1780   if (ctrl != NULL) {</span>
<span class="line-removed">1781     try_move_before_loop_helper(ctrl, val_ctrl, memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1782   }</span>
<span class="line-removed">1783 }</span>
<span class="line-removed">1784 </span>
<span class="line-removed">1785 Node* ShenandoahWriteBarrierNode::would_subsume(ShenandoahBarrierNode* other, PhaseIdealLoop* phase) {</span>
<span class="line-removed">1786   Node* val = in(ValueIn);</span>
<span class="line-removed">1787   Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-removed">1788   Node* other_mem = other-&gt;in(Memory);</span>
<span class="line-removed">1789   Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="line-removed">1790   Node* this_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">1791   IdealLoopTree* this_loop = phase-&gt;get_loop(this_ctrl);</span>
<span class="line-removed">1792   IdealLoopTree* other_loop = phase-&gt;get_loop(other_ctrl);</span>
<span class="line-removed">1793 </span>
<span class="line-removed">1794   Node* ctrl = phase-&gt;dom_lca(other_ctrl, this_ctrl);</span>
<span class="line-removed">1795 </span>
<span class="line-removed">1796   if (ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">1797       ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="line-removed">1798       ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="line-removed">1799       ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch &amp;&amp;</span>
<span class="line-removed">1800       !phase-&gt;is_dominator(val_ctrl, ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="line-removed">1801     return NULL;</span>
<span class="line-removed">1802   }</span>
<span class="line-removed">1803 </span>
<span class="line-removed">1804   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">1805 </span>
<span class="line-removed">1806   // We don&#39;t want to move a write barrier in a loop</span>
<span class="line-removed">1807   // If the LCA is in a inner loop, try a control out of loop if possible</span>
<span class="line-removed">1808   while (!loop-&gt;is_member(this_loop) &amp;&amp; (other-&gt;Opcode() != Op_ShenandoahWriteBarrier || !loop-&gt;is_member(other_loop))) {</span>
<span class="line-removed">1809     ctrl = phase-&gt;idom(ctrl);</span>
<span class="line-removed">1810     if (ctrl-&gt;is_MultiBranch()) {</span>
<span class="line-removed">1811       ctrl = ctrl-&gt;in(0);</span>
<span class="line-removed">1812     }</span>
<span class="line-removed">1813     if (ctrl != val_ctrl &amp;&amp; phase-&gt;is_dominator(ctrl, val_ctrl)) {</span>
<span class="line-removed">1814       return NULL;</span>
<span class="line-removed">1815     }</span>
<span class="line-removed">1816     loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">1817   }</span>
<span class="line-removed">1818 </span>
<span class="line-removed">1819   if (ShenandoahDontIncreaseWBFreq) {</span>
<span class="line-removed">1820     Node* this_iffproj = no_branches(this_ctrl, ctrl, true, phase);</span>
<span class="line-removed">1821     if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1822       Node* other_iffproj = no_branches(other_ctrl, ctrl, true, phase);</span>
<span class="line-removed">1823       if (other_iffproj == NULL || this_iffproj == NULL) {</span>
<span class="line-removed">1824         return ctrl;</span>
<span class="line-removed">1825       } else if (other_iffproj != NodeSentinel &amp;&amp; this_iffproj != NodeSentinel &amp;&amp;</span>
<span class="line-removed">1826                  other_iffproj-&gt;in(0) == this_iffproj-&gt;in(0)) {</span>
<span class="line-removed">1827         return ctrl;</span>
<span class="line-removed">1828       }</span>
<span class="line-removed">1829     } else if (this_iffproj == NULL) {</span>
<span class="line-removed">1830       return ctrl;</span>
<span class="line-removed">1831     }</span>
<span class="line-removed">1832     return NULL;</span>
<span class="line-removed">1833   }</span>
<span class="line-removed">1834 </span>
<span class="line-removed">1835   return ctrl;</span>
<span class="line-removed">1836 }</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838 void ShenandoahWriteBarrierNode::optimize_before_expansion(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers, bool include_lsm) {</span>
<span class="line-removed">1839   bool progress = false;</span>
<span class="line-removed">1840   Unique_Node_List uses;</span>
<span class="line-removed">1841   do {</span>
<span class="line-removed">1842     progress = false;</span>
<span class="line-removed">1843     for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="line-removed">1844       ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="line-removed">1845 </span>
<span class="line-removed">1846       wb-&gt;try_move_before_loop(memory_graph_fixers, phase, include_lsm, uses);</span>
<span class="line-removed">1847 </span>
<span class="line-removed">1848       Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-removed">1849 </span>
<span class="line-removed">1850       for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">1851         Node* u = val-&gt;fast_out(j);</span>
<span class="line-removed">1852         if (u != wb &amp;&amp; u-&gt;is_ShenandoahBarrier()) {</span>
<span class="line-removed">1853           Node* rep_ctrl = wb-&gt;would_subsume(u-&gt;as_ShenandoahBarrier(), phase);</span>
<span class="line-removed">1854 </span>
<span class="line-removed">1855           if (rep_ctrl != NULL) {</span>
<span class="line-removed">1856             Node* other = u;</span>
<span class="line-removed">1857             Node* val_ctrl = phase-&gt;get_ctrl(val);</span>
<span class="line-removed">1858             if (rep_ctrl-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">1859                 rep_ctrl-&gt;in(0)-&gt;is_Call() &amp;&amp;</span>
<span class="line-removed">1860                 rep_ctrl-&gt;unique_ctrl_out() != NULL &amp;&amp;</span>
<span class="line-removed">1861                 rep_ctrl-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Catch) {</span>
<span class="line-removed">1862               rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">1863 </span>
<span class="line-removed">1864               assert(phase-&gt;is_dominator(val_ctrl, rep_ctrl), &quot;bad control&quot;);</span>
<span class="line-removed">1865             } else {</span>
<span class="line-removed">1866               LoopNode* c = ShenandoahWriteBarrierNode::try_move_before_pre_loop(rep_ctrl, val_ctrl, phase);</span>
<span class="line-removed">1867               if (c != NULL) {</span>
<span class="line-removed">1868                 rep_ctrl = ShenandoahWriteBarrierNode::move_above_predicates(c, val_ctrl, phase);</span>
<span class="line-removed">1869               } else {</span>
<span class="line-removed">1870                 while (rep_ctrl-&gt;is_IfProj()) {</span>
<span class="line-removed">1871                   CallStaticJavaNode* unc = rep_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-removed">1872                   if (unc != NULL) {</span>
<span class="line-removed">1873                     int req = unc-&gt;uncommon_trap_request();</span>
<span class="line-removed">1874                     Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);</span>
<span class="line-removed">1875                     if ((trap_reason == Deoptimization::Reason_loop_limit_check ||</span>
<span class="line-removed">1876                          trap_reason == Deoptimization::Reason_predicate ||</span>
<span class="line-removed">1877                          trap_reason == Deoptimization::Reason_profile_predicate) &amp;&amp;</span>
<span class="line-removed">1878                         phase-&gt;is_dominator(val_ctrl, rep_ctrl-&gt;in(0)-&gt;in(0))) {</span>
<span class="line-removed">1879                       rep_ctrl = rep_ctrl-&gt;in(0)-&gt;in(0);</span>
<span class="line-removed">1880                       continue;</span>
<span class="line-removed">1881                     }</span>
<span class="line-removed">1882                   }</span>
<span class="line-removed">1883                   break;</span>
<span class="line-removed">1884                 }</span>
<span class="line-removed">1885               }</span>
<span class="line-removed">1886             }</span>
<span class="line-removed">1887 </span>
<span class="line-removed">1888             Node* wb_ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="line-removed">1889             Node* other_ctrl = phase-&gt;get_ctrl(other);</span>
<span class="line-removed">1890             int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="line-removed">1891             MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);;</span>
<span class="line-removed">1892             if (!is_dominator(wb_ctrl, other_ctrl, wb, other, phase)) {</span>
<span class="line-removed">1893               if (fixer == NULL) {</span>
<span class="line-removed">1894                 fixer = create_fixer(memory_graph_fixers, alias, phase, include_lsm);</span>
<span class="line-removed">1895               }</span>
<span class="line-removed">1896               Node* mem = fixer-&gt;find_mem(rep_ctrl, phase-&gt;get_ctrl(other) == rep_ctrl ? other : NULL);</span>
<span class="line-removed">1897 </span>
<span class="line-removed">1898               if (mem-&gt;has_out_with(Op_Lock) || mem-&gt;has_out_with(Op_Unlock)) {</span>
<span class="line-removed">1899                 continue;</span>
<span class="line-removed">1900               }</span>
<span class="line-removed">1901 </span>
<span class="line-removed">1902               Node* wb_proj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1903               fixer-&gt;remove(wb_proj);</span>
<span class="line-removed">1904               Node* mem_for_ctrl = fixer-&gt;find_mem(rep_ctrl, NULL);</span>
<span class="line-removed">1905 </span>
<span class="line-removed">1906               if (wb-&gt;in(Memory) != mem) {</span>
<span class="line-removed">1907                 disconnect_barrier_mem(wb, phase-&gt;igvn());</span>
<span class="line-removed">1908                 phase-&gt;igvn().replace_input_of(wb, Memory, mem);</span>
<span class="line-removed">1909               }</span>
<span class="line-removed">1910               if (rep_ctrl != wb_ctrl) {</span>
<span class="line-removed">1911                 phase-&gt;set_ctrl_and_loop(wb, rep_ctrl);</span>
<span class="line-removed">1912                 phase-&gt;igvn().replace_input_of(wb, Control, rep_ctrl);</span>
<span class="line-removed">1913                 phase-&gt;set_ctrl_and_loop(wb_proj, rep_ctrl);</span>
<span class="line-removed">1914                 progress = true;</span>
<span class="line-removed">1915               }</span>
<span class="line-removed">1916 </span>
<span class="line-removed">1917               fixer-&gt;fix_mem(rep_ctrl, rep_ctrl, mem, mem_for_ctrl, wb_proj, uses);</span>
<span class="line-removed">1918 </span>
<span class="line-removed">1919               assert(!ShenandoahVerifyOptoBarriers || ShenandoahWriteBarrierNode::memory_dominates_all_paths(mem, rep_ctrl, alias, phase), &quot;can&#39;t fix the memory graph&quot;);</span>
<span class="line-removed">1920             }</span>
<span class="line-removed">1921 </span>
<span class="line-removed">1922             if (other-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">1923               Node* other_proj = other-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1924               if (fixer != NULL) {</span>
<span class="line-removed">1925                 fixer-&gt;remove(other_proj);</span>
<span class="line-removed">1926               }</span>
<span class="line-removed">1927               phase-&gt;igvn().replace_node(other_proj, other-&gt;in(Memory));</span>
<span class="line-removed">1928             }</span>
<span class="line-removed">1929             phase-&gt;igvn().replace_node(other, wb);</span>
<span class="line-removed">1930             --j; --jmax;</span>
<span class="line-removed">1931           }</span>
<span class="line-removed">1932         }</span>
<span class="line-removed">1933       }</span>
<span class="line-removed">1934     }</span>
<span class="line-removed">1935   } while(progress);</span>
<span class="line-removed">1936 }</span>
<span class="line-removed">1937 </span>
<span class="line-removed">1938 // Some code duplication with PhaseIdealLoop::split_if_with_blocks_pre()</span>
<span class="line-removed">1939 Node* ShenandoahWriteBarrierNode::try_split_thru_phi(PhaseIdealLoop* phase) {</span>
<span class="line-removed">1940   Node *ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">1941   if (ctrl == NULL) {</span>
<span class="line-removed">1942     return this;</span>
<span class="line-removed">1943   }</span>
<span class="line-removed">1944   Node *blk = phase-&gt;has_local_phi_input(this);</span>
<span class="line-removed">1945   if (blk == NULL) {</span>
<span class="line-removed">1946     return this;</span>
<span class="line-removed">1947   }</span>
<span class="line-removed">1948 </span>
<span class="line-removed">1949   if (in(0) != blk) {</span>
<span class="line-removed">1950     return this;</span>
<span class="line-removed">1951   }</span>
<span class="line-removed">1952 </span>
<span class="line-removed">1953   int policy = blk-&gt;req() &gt;&gt; 2;</span>
<span class="line-removed">1954 </span>
<span class="line-removed">1955   if (blk-&gt;is_CountedLoop()) {</span>
<span class="line-removed">1956     IdealLoopTree *lp = phase-&gt;get_loop(blk);</span>
<span class="line-removed">1957     if (lp &amp;&amp; lp-&gt;_rce_candidate) {</span>
<span class="line-removed">1958       return this;</span>
<span class="line-removed">1959     }</span>
<span class="line-removed">1960   }</span>
<span class="line-removed">1961 </span>
<span class="line-removed">1962   if (phase-&gt;C-&gt;live_nodes() &gt; 35000) {</span>
<span class="line-removed">1963     return this;</span>
<span class="line-removed">1964   }</span>
<span class="line-removed">1965 </span>
<span class="line-removed">1966   uint unique = phase-&gt;C-&gt;unique();</span>
<span class="line-removed">1967   Node *phi = phase-&gt;split_thru_phi(this, blk, policy);</span>
<span class="line-removed">1968   if (phi == NULL) {</span>
<span class="line-removed">1969     return this;</span>
<span class="line-removed">1970   }</span>
<span class="line-removed">1971 </span>
<span class="line-removed">1972   Node* mem_phi = new PhiNode(blk, Type::MEMORY, phase-&gt;C-&gt;alias_type(adr_type())-&gt;adr_type());</span>
<span class="line-removed">1973   for (uint i = 1; i &lt; blk-&gt;req(); i++) {</span>
<span class="line-removed">1974     Node* n = phi-&gt;in(i);</span>
<span class="line-removed">1975     if (n-&gt;Opcode() == Op_ShenandoahWriteBarrier &amp;&amp;</span>
<span class="line-removed">1976         n-&gt;_idx &gt;= unique) {</span>
<span class="line-removed">1977       Node* proj = new ShenandoahWBMemProjNode(n);</span>
<span class="line-removed">1978       phase-&gt;register_new_node(proj, phase-&gt;get_ctrl(n));</span>
<span class="line-removed">1979       mem_phi-&gt;init_req(i, proj);</span>
<span class="line-removed">1980     } else {</span>
<span class="line-removed">1981       Node* mem = in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed">1982       if (mem-&gt;is_Phi() &amp;&amp; mem-&gt;in(0) == blk) {</span>
<span class="line-removed">1983         mem = mem-&gt;in(i);</span>
<span class="line-removed">1984       }</span>
<span class="line-removed">1985       mem_phi-&gt;init_req(i, mem);</span>
<span class="line-removed">1986     }</span>
<span class="line-removed">1987   }</span>
<span class="line-removed">1988   phase-&gt;register_new_node(mem_phi, blk);</span>
<span class="line-removed">1989 </span>
<span class="line-removed">1990 </span>
<span class="line-removed">1991   Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">1992   phase-&gt;igvn().replace_node(proj, mem_phi);</span>
<span class="line-removed">1993   phase-&gt;igvn().replace_node(this, phi);</span>
<span class="line-removed">1994 </span>
<span class="line-removed">1995   return phi;</span>
<span class="line-removed">1996 }</span>
<span class="line-removed">1997 </span>
<span class="line-removed">1998 void ShenandoahReadBarrierNode::try_move(PhaseIdealLoop* phase) {</span>
<span class="line-removed">1999   Node *n_ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2000   if (n_ctrl == NULL) {</span>
<span class="line-removed">2001     return;</span>
<span class="line-removed">2002   }</span>
<span class="line-removed">2003   Node* mem = in(MemNode::Memory);</span>
<span class="line-removed">2004   int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-removed">2005   const bool trace = false;</span>
<span class="line-removed">2006 </span>
<span class="line-removed">2007 #ifdef ASSERT</span>
<span class="line-removed">2008   if (trace) { tty-&gt;print(&quot;Trying to move mem of&quot;); dump(); }</span>
<span class="line-removed">2009 #endif</span>
<span class="line-removed">2010 </span>
<span class="line-removed">2011   Node* new_mem = mem;</span>
<span class="line-removed">2012 </span>
<span class="line-removed">2013   ResourceMark rm;</span>
<span class="line-removed">2014   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-removed">2015   Node_List phis;</span>
<span class="line-removed">2016 </span>
<span class="line-removed">2017   for (;;) {</span>
<span class="line-removed">2018 #ifdef ASSERT</span>
<span class="line-removed">2019     if (trace) { tty-&gt;print(&quot;Looking for dominator from&quot;); mem-&gt;dump(); }</span>
<span class="line-removed">2020 #endif</span>
<span class="line-removed">2021     if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;in(0)-&gt;is_Start()) {</span>
<span class="line-removed">2022       if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2023 #ifdef ASSERT</span>
<span class="line-removed">2024         if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2025 #endif</span>
<span class="line-removed">2026         phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2027       }</span>
<span class="line-removed">2028       return;</span>
<span class="line-removed">2029     }</span>
<span class="line-removed">2030 </span>
<span class="line-removed">2031     Node* candidate = mem;</span>
<span class="line-removed">2032     do {</span>
<span class="line-removed">2033       if (!is_independent(mem)) {</span>
<span class="line-removed">2034         if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="line-removed">2035         if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2036 #ifdef ASSERT</span>
<span class="line-removed">2037           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2038 #endif</span>
<span class="line-removed">2039           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2040         }</span>
<span class="line-removed">2041         return;</span>
<span class="line-removed">2042       }</span>
<span class="line-removed">2043       if (seen.test_set(mem-&gt;_idx)) {</span>
<span class="line-removed">2044         if (trace) { tty-&gt;print_cr(&quot;Already seen&quot;); }</span>
<span class="line-removed">2045         ShouldNotReachHere();</span>
<span class="line-removed">2046         // Strange graph</span>
<span class="line-removed">2047         if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2048 #ifdef ASSERT</span>
<span class="line-removed">2049           if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2050 #endif</span>
<span class="line-removed">2051           phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2052         }</span>
<span class="line-removed">2053         return;</span>
<span class="line-removed">2054       }</span>
<span class="line-removed">2055       if (mem-&gt;is_Phi()) {</span>
<span class="line-removed">2056         phis.push(mem);</span>
<span class="line-removed">2057       }</span>
<span class="line-removed">2058       mem = next_mem(mem, alias);</span>
<span class="line-removed">2059       if (mem-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">2060         candidate = mem;</span>
<span class="line-removed">2061       }</span>
<span class="line-removed">2062       assert(is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl, mem, this, phase) == phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl), &quot;strange dominator&quot;);</span>
<span class="line-removed">2063 #ifdef ASSERT</span>
<span class="line-removed">2064       if (trace) { tty-&gt;print(&quot;Next mem is&quot;); mem-&gt;dump(); }</span>
<span class="line-removed">2065 #endif</span>
<span class="line-removed">2066     } while (mem-&gt;bottom_type() != Type::MEMORY || !phase-&gt;is_dominator(phase-&gt;ctrl_or_self(mem), n_ctrl));</span>
<span class="line-removed">2067 </span>
<span class="line-removed">2068     assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;bad mem&quot;);</span>
<span class="line-removed">2069 </span>
<span class="line-removed">2070     bool not_dom = false;</span>
<span class="line-removed">2071     for (uint i = 0; i &lt; phis.size() &amp;&amp; !not_dom; i++) {</span>
<span class="line-removed">2072       Node* nn = phis.at(i);</span>
<span class="line-removed">2073 </span>
<span class="line-removed">2074 #ifdef ASSERT</span>
<span class="line-removed">2075       if (trace) { tty-&gt;print(&quot;Looking from phi&quot;); nn-&gt;dump(); }</span>
<span class="line-removed">2076 #endif</span>
<span class="line-removed">2077       assert(nn-&gt;is_Phi(), &quot;phis only&quot;);</span>
<span class="line-removed">2078       for (uint j = 2; j &lt; nn-&gt;req() &amp;&amp; !not_dom; j++) {</span>
<span class="line-removed">2079         Node* m = nn-&gt;in(j);</span>
<span class="line-removed">2080 #ifdef ASSERT</span>
<span class="line-removed">2081         if (trace) { tty-&gt;print(&quot;Input %d is&quot;, j); m-&gt;dump(); }</span>
<span class="line-removed">2082 #endif</span>
<span class="line-removed">2083         while (m != mem &amp;&amp; !seen.test_set(m-&gt;_idx)) {</span>
<span class="line-removed">2084           if (is_dominator(phase-&gt;ctrl_or_self(m), phase-&gt;ctrl_or_self(mem), m, mem, phase)) {</span>
<span class="line-removed">2085             not_dom = true;</span>
<span class="line-removed">2086             // Scheduling anomaly</span>
<span class="line-removed">2087 #ifdef ASSERT</span>
<span class="line-removed">2088             if (trace) { tty-&gt;print(&quot;Giving up&quot;); m-&gt;dump(); }</span>
<span class="line-removed">2089 #endif</span>
<span class="line-removed">2090             break;</span>
<span class="line-removed">2091           }</span>
<span class="line-removed">2092           if (!is_independent(m)) {</span>
<span class="line-removed">2093             if (trace) { tty-&gt;print_cr(&quot;Not independent&quot;); }</span>
<span class="line-removed">2094             if (new_mem != in(MemNode::Memory)) {</span>
<span class="line-removed">2095 #ifdef ASSERT</span>
<span class="line-removed">2096               if (trace) { tty-&gt;print(&quot;XXX Setting mem to&quot;); new_mem-&gt;dump(); tty-&gt;print(&quot; for &quot;); dump(); }</span>
<span class="line-removed">2097 #endif</span>
<span class="line-removed">2098               phase-&gt;igvn().replace_input_of(this, MemNode::Memory, new_mem);</span>
<span class="line-removed">2099             }</span>
<span class="line-removed">2100             return;</span>
<span class="line-removed">2101           }</span>
<span class="line-removed">2102           if (m-&gt;is_Phi()) {</span>
<span class="line-removed">2103             phis.push(m);</span>
<span class="line-removed">2104           }</span>
<span class="line-removed">2105           m = next_mem(m, alias);</span>
<span class="line-removed">2106 #ifdef ASSERT</span>
<span class="line-removed">2107           if (trace) { tty-&gt;print(&quot;Next mem is&quot;); m-&gt;dump(); }</span>
<span class="line-removed">2108 #endif</span>
<span class="line-removed">2109         }</span>
<span class="line-removed">2110       }</span>
<span class="line-removed">2111     }</span>
<span class="line-removed">2112     if (!not_dom) {</span>
<span class="line-removed">2113       new_mem = mem;</span>
<span class="line-removed">2114       phis.clear();</span>
<span class="line-removed">2115     } else {</span>
<span class="line-removed">2116       seen.Clear();</span>
<span class="line-removed">2117     }</span>
<span class="line-removed">2118   }</span>
<span class="line-removed">2119 }</span>
<span class="line-removed">2120 </span>
<span class="line-removed">2121 CallStaticJavaNode* ShenandoahWriteBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="line-removed">2122   Node* val = in(ValueIn);</span>
<span class="line-removed">2123 </span>
<span class="line-removed">2124   const Type* val_t = igvn.type(val);</span>
<span class="line-removed">2125 </span>
<span class="line-removed">2126   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="line-removed">2127       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-removed">2128       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-removed">2129       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-removed">2130       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-removed">2131       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-removed">2132       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-removed">2133       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-removed">2134       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-removed">2135       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="line-removed">2136       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-removed">2137     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="line-removed">2138     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-removed">2139     return unc;</span>
<span class="line-removed">2140   }</span>
<span class="line-removed">2141   return NULL;</span>
<span class="line-removed">2142 }</span>
<span class="line-removed">2143 </span>
<span class="line-removed">2144 void ShenandoahWriteBarrierNode::pin_and_expand_move_barrier(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, Unique_Node_List&amp; uses) {</span>
<span class="line-removed">2145   Node* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2146   Node* val = in(ValueIn);</span>
<span class="line-removed">2147 </span>
<span class="line-removed">2148   if (unc != NULL) {</span>
<span class="line-removed">2149     Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2150     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2151 </span>
<span class="line-removed">2152     // Don&#39;t move write barrier in a loop</span>
<span class="line-removed">2153     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2154     IdealLoopTree* unc_loop = phase-&gt;get_loop(unc_ctrl);</span>
<span class="line-removed">2155 </span>
<span class="line-removed">2156     if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="line-removed">2157       return;</span>
<span class="line-removed">2158     }</span>
<span class="line-removed">2159 </span>
<span class="line-removed">2160     Node* branch = no_branches(ctrl, unc_ctrl, false, phase);</span>
<span class="line-removed">2161     assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="line-removed">2162     if (branch == NodeSentinel) {</span>
<span class="line-removed">2163       return;</span>
<span class="line-removed">2164     }</span>
<span class="line-removed">2165 </span>
<span class="line-removed">2166     RegionNode* r = new RegionNode(3);</span>
<span class="line-removed">2167     IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">2168 </span>
<span class="line-removed">2169     Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="line-removed">2170     Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="line-removed">2171     phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="line-removed">2172     Node* c = unc_ctrl_clone;</span>
<span class="line-removed">2173     Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="line-removed">2174     r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="line-removed">2175 </span>
<span class="line-removed">2176     phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="line-removed">2177     phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="line-removed">2178     phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="line-removed">2179     c = NULL;;</span>
<span class="line-removed">2180     phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="line-removed">2181     phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="line-removed">2182 </span>
<span class="line-removed">2183     IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="line-removed">2184     fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="line-removed">2185     Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="line-removed">2186     r-&gt;init_req(2, iff_proj);</span>
<span class="line-removed">2187     phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="line-removed">2188 </span>
<span class="line-removed">2189     Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">2190     Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="line-removed">2191     assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="line-removed">2192     assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="line-removed">2193     new_bol-&gt;set_req(1, new_cmp);</span>
<span class="line-removed">2194     new_cmp-&gt;set_req(1, this);</span>
<span class="line-removed">2195     phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="line-removed">2196     phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="line-removed">2197     phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="line-removed">2198     phase-&gt;igvn().replace_input_of(new_cast, 1, this);</span>
<span class="line-removed">2199 </span>
<span class="line-removed">2200     for (DUIterator_Fast imax, i = this-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2201       Node* u = this-&gt;fast_out(i);</span>
<span class="line-removed">2202       if (u == new_cast || u-&gt;Opcode() == Op_ShenandoahWBMemProj || u == new_cmp) {</span>
<span class="line-removed">2203         continue;</span>
<span class="line-removed">2204       }</span>
<span class="line-removed">2205       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2206       int nb = u-&gt;replace_edge(this, new_cast);</span>
<span class="line-removed">2207       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2208       --i; imax -= nb;</span>
<span class="line-removed">2209     }</span>
<span class="line-removed">2210 </span>
<span class="line-removed">2211     for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2212       Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">2213       if (u == this) {</span>
<span class="line-removed">2214         continue;</span>
<span class="line-removed">2215       }</span>
<span class="line-removed">2216       phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2217       int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="line-removed">2218       assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2219       --i; imax -= nb;</span>
<span class="line-removed">2220     }</span>
<span class="line-removed">2221 </span>
<span class="line-removed">2222     Node* new_ctrl = unc_ctrl_clone;</span>
<span class="line-removed">2223 </span>
<span class="line-removed">2224     int alias = phase-&gt;C-&gt;get_alias_index(adr_type());</span>
<span class="line-removed">2225     MemoryGraphFixer* fixer = find_fixer(memory_graph_fixers, alias);</span>
<span class="line-removed">2226     if (fixer == NULL) {</span>
<span class="line-removed">2227       fixer = create_fixer(memory_graph_fixers, alias, phase, true);</span>
<span class="line-removed">2228     }</span>
<span class="line-removed">2229 </span>
<span class="line-removed">2230     Node* proj = find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">2231     fixer-&gt;remove(proj);</span>
<span class="line-removed">2232     Node* mem = fixer-&gt;find_mem(new_ctrl, NULL);</span>
<span class="line-removed">2233 </span>
<span class="line-removed">2234     if (in(Memory) != mem) {</span>
<span class="line-removed">2235       disconnect_barrier_mem(this, phase-&gt;igvn());</span>
<span class="line-removed">2236       phase-&gt;igvn().replace_input_of(this, Memory, mem);</span>
<span class="line-removed">2237     }</span>
<span class="line-removed">2238 </span>
<span class="line-removed">2239     phase-&gt;set_ctrl_and_loop(this, new_ctrl);</span>
<span class="line-removed">2240     phase-&gt;igvn().replace_input_of(this, Control, new_ctrl);</span>
<span class="line-removed">2241     phase-&gt;set_ctrl_and_loop(proj, new_ctrl);</span>
<span class="line-removed">2242 </span>
<span class="line-removed">2243     fixer-&gt;fix_mem(new_ctrl, new_ctrl, mem, mem, proj, uses);</span>
<span class="line-removed">2244   }</span>
<span class="line-removed">2245 }</span>
<span class="line-removed">2246 </span>
<span class="line-removed">2247 void ShenandoahWriteBarrierNode::pin_and_expand_helper(PhaseIdealLoop* phase) {</span>
<span class="line-removed">2248   Node* val = in(ValueIn);</span>
<span class="line-removed">2249   CallStaticJavaNode* unc = pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2250   Node* rep = this;</span>
<span class="line-removed">2251   Node* ctrl = phase-&gt;get_ctrl(this);</span>
<span class="line-removed">2252   if (unc != NULL &amp;&amp; val-&gt;in(0) == ctrl) {</span>
<span class="line-removed">2253     Node* unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2254     IfNode* other_iff = unc_ctrl-&gt;unique_ctrl_out()-&gt;as_If();</span>
<span class="line-removed">2255     ProjNode* other_unc_ctrl = other_iff-&gt;proj_out(1);</span>
<span class="line-removed">2256     Node* cast = NULL;</span>
<span class="line-removed">2257     for (DUIterator_Fast imax, i = other_unc_ctrl-&gt;fast_outs(imax); i &lt; imax &amp;&amp; cast == NULL; i++) {</span>
<span class="line-removed">2258       Node* u = other_unc_ctrl-&gt;fast_out(i);</span>
<span class="line-removed">2259       if (u-&gt;Opcode() == Op_CastPP &amp;&amp; u-&gt;in(1) == this) {</span>
<span class="line-removed">2260         cast = u;</span>
<span class="line-removed">2261       }</span>
<span class="line-removed">2262     }</span>
<span class="line-removed">2263     assert(other_unc_ctrl-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) == unc, &quot;broken&quot;);</span>
<span class="line-removed">2264     rep = cast;</span>
<span class="line-removed">2265   }</span>
<span class="line-removed">2266 </span>
<span class="line-removed">2267   // Replace all uses of barrier&#39;s input that are dominated by ctrl</span>
<span class="line-removed">2268   // with the value returned by the barrier: no need to keep both</span>
<span class="line-removed">2269   // live.</span>
<span class="line-removed">2270   for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2271     Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">2272     if (u != this) {</span>
<span class="line-removed">2273       if (u-&gt;is_Phi()) {</span>
<span class="line-removed">2274         int nb = 0;</span>
<span class="line-removed">2275         for (uint j = 1; j &lt; u-&gt;req(); j++) {</span>
<span class="line-removed">2276           if (u-&gt;in(j) == val) {</span>
<span class="line-removed">2277             Node* c = u-&gt;in(0)-&gt;in(j);</span>
<span class="line-removed">2278             if (phase-&gt;is_dominator(ctrl, c)) {</span>
<span class="line-removed">2279               phase-&gt;igvn().replace_input_of(u, j, rep);</span>
<span class="line-removed">2280               nb++;</span>
<span class="line-removed">2281             }</span>
<span class="line-removed">2282           }</span>
<span class="line-removed">2283         }</span>
<span class="line-removed">2284         if (nb &gt; 0) {</span>
<span class="line-removed">2285           imax -= nb;</span>
<span class="line-removed">2286           --i;</span>
<span class="line-removed">2287         }</span>
<span class="line-removed">2288       } else {</span>
<span class="line-removed">2289         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-removed">2290         if (is_dominator(ctrl, c, this, u, phase)) {</span>
<span class="line-removed">2291           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">2292           int nb = u-&gt;replace_edge(val, rep);</span>
<span class="line-removed">2293           assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-removed">2294           --i, imax -= nb;</span>
<span class="line-removed">2295         }</span>
<span class="line-removed">2296       }</span>
<span class="line-removed">2297     }</span>
<span class="line-removed">2298   }</span>
<span class="line-removed">2299 }</span>
<span class="line-removed">2300 </span>
<span class="line-removed">2301 Node* ShenandoahWriteBarrierNode::find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2302   Node* mem = NULL;</span>
<span class="line-removed">2303   Node* c = ctrl;</span>
<span class="line-removed">2304   do {</span>
<span class="line-removed">2305     if (c-&gt;is_Region()) {</span>
<span class="line-removed">2306       Node* phi_bottom = NULL;</span>
<span class="line-removed">2307       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-removed">2308         Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">2309         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY) {</span>
<span class="line-removed">2310           if (u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2311             mem = u;</span>
<span class="line-removed">2312           }</span>
<span class="line-removed">2313         }</span>
<span class="line-removed">2314       }</span>
<span class="line-removed">2315     } else {</span>
<span class="line-removed">2316       if (c-&gt;is_Call() &amp;&amp; c-&gt;as_Call()-&gt;adr_type() != NULL) {</span>
<span class="line-removed">2317         CallProjections projs;</span>
<span class="line-removed">2318         c-&gt;as_Call()-&gt;extract_projections(&amp;projs, true, false);</span>
<span class="line-removed">2319         if (projs.fallthrough_memproj != NULL) {</span>
<span class="line-removed">2320           if (projs.fallthrough_memproj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2321             if (projs.catchall_memproj == NULL) {</span>
<span class="line-removed">2322               mem = projs.fallthrough_memproj;</span>
<span class="line-removed">2323             } else {</span>
<span class="line-removed">2324               if (phase-&gt;is_dominator(projs.fallthrough_catchproj, ctrl)) {</span>
<span class="line-removed">2325                 mem = projs.fallthrough_memproj;</span>
<span class="line-removed">2326               } else {</span>
<span class="line-removed">2327                 assert(phase-&gt;is_dominator(projs.catchall_catchproj, ctrl), &quot;one proj must dominate barrier&quot;);</span>
<span class="line-removed">2328                 mem = projs.catchall_memproj;</span>
<span class="line-removed">2329               }</span>
<span class="line-removed">2330             }</span>
<span class="line-removed">2331           }</span>
<span class="line-removed">2332         } else {</span>
<span class="line-removed">2333           Node* proj = c-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory);</span>
<span class="line-removed">2334           if (proj != NULL &amp;&amp;</span>
<span class="line-removed">2335               proj-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2336             mem = proj;</span>
<span class="line-removed">2337           }</span>
<span class="line-removed">2338         }</span>
<span class="line-removed">2339       } else {</span>
<span class="line-removed">2340         for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2341           Node* u = c-&gt;fast_out(i);</span>
<span class="line-removed">2342           if (u-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">2343               u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-removed">2344               u-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-removed">2345               assert(c-&gt;is_SafePoint() || c-&gt;is_MemBar() || c-&gt;is_Start(), &quot;&quot;);</span>
<span class="line-removed">2346               assert(mem == NULL, &quot;only one proj&quot;);</span>
<span class="line-removed">2347               mem = u;</span>
<span class="line-removed">2348           }</span>
<span class="line-removed">2349         }</span>
<span class="line-removed">2350         assert(!c-&gt;is_Call() || c-&gt;as_Call()-&gt;adr_type() != NULL || mem == NULL, &quot;no mem projection expected&quot;);</span>
<span class="line-removed">2351       }</span>
<span class="line-removed">2352     }</span>
<span class="line-removed">2353     c = phase-&gt;idom(c);</span>
<span class="line-removed">2354   } while (mem == NULL);</span>
<span class="line-removed">2355   return mem;</span>
<span class="line-removed">2356 }</span>
<span class="line-removed">2357 </span>
<span class="line-removed">2358 void ShenandoahWriteBarrierNode::follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2359   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">2360     Node* u = n-&gt;fast_out(i);</span>
<span class="line-removed">2361     if (!u-&gt;is_CFG() &amp;&amp; phase-&gt;get_ctrl(u) == ctrl &amp;&amp; (!u-&gt;is_Phi() || !u-&gt;in(0)-&gt;is_Loop() || u-&gt;in(LoopNode::LoopBackControl) != n)) {</span>
<span class="line-removed">2362       uses.push(u);</span>
<span class="line-removed">2363     }</span>
<span class="line-removed">2364   }</span>
<span class="line-removed">2365 }</span>
<span class="line-removed">2366 </span>
<span class="line-removed">2367 static void hide_strip_mined_loop(OuterStripMinedLoopNode* outer, CountedLoopNode* inner, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2368   OuterStripMinedLoopEndNode* le = inner-&gt;outer_loop_end();</span>
<span class="line-removed">2369   Node* new_outer = new LoopNode(outer-&gt;in(LoopNode::EntryControl), outer-&gt;in(LoopNode::LoopBackControl));</span>
<span class="line-removed">2370   phase-&gt;register_control(new_outer, phase-&gt;get_loop(outer), outer-&gt;in(LoopNode::EntryControl));</span>
<span class="line-removed">2371   Node* new_le = new IfNode(le-&gt;in(0), le-&gt;in(1), le-&gt;_prob, le-&gt;_fcnt);</span>
<span class="line-removed">2372   phase-&gt;register_control(new_le, phase-&gt;get_loop(le), le-&gt;in(0));</span>
<span class="line-removed">2373   phase-&gt;lazy_replace(outer, new_outer);</span>
<span class="line-removed">2374   phase-&gt;lazy_replace(le, new_le);</span>
<span class="line-removed">2375   inner-&gt;clear_strip_mined();</span>
<span class="line-removed">2376 }</span>
<span class="line-removed">2377 </span>
<span class="line-removed">2378 void ShenandoahWriteBarrierNode::test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,</span>
<span class="line-removed">2379                                                   PhaseIdealLoop* phase) {</span>
<span class="line-removed">2380   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2381   Node* thread = new ThreadLocalNode();</span>
<span class="line-removed">2382   phase-&gt;register_new_node(thread, ctrl);</span>
<span class="line-removed">2383   Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));</span>
<span class="line-removed">2384   phase-&gt;set_ctrl(offset, phase-&gt;C-&gt;root());</span>
<span class="line-removed">2385   Node* gc_state_addr = new AddPNode(phase-&gt;C-&gt;top(), thread, offset);</span>
<span class="line-removed">2386   phase-&gt;register_new_node(gc_state_addr, ctrl);</span>
<span class="line-removed">2387   uint gc_state_idx = Compile::AliasIdxRaw;</span>
<span class="line-removed">2388   const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument</span>
<span class="line-removed">2389   debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));</span>
<span class="line-removed">2390 </span>
<span class="line-removed">2391   Node* gc_state = new LoadBNode(ctrl, raw_mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered);</span>
<span class="line-removed">2392   phase-&gt;register_new_node(gc_state, ctrl);</span>
<span class="line-removed">2393   Node* heap_stable_and = new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED));</span>
<span class="line-removed">2394   phase-&gt;register_new_node(heap_stable_and, ctrl);</span>
<span class="line-removed">2395   Node* heap_stable_cmp = new CmpINode(heap_stable_and, phase-&gt;igvn().zerocon(T_INT));</span>
<span class="line-removed">2396   phase-&gt;register_new_node(heap_stable_cmp, ctrl);</span>
<span class="line-removed">2397   Node* heap_stable_test = new BoolNode(heap_stable_cmp, BoolTest::ne);</span>
<span class="line-removed">2398   phase-&gt;register_new_node(heap_stable_test, ctrl);</span>
<span class="line-removed">2399   IfNode* heap_stable_iff = new IfNode(ctrl, heap_stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2400   phase-&gt;register_control(heap_stable_iff, loop, ctrl);</span>
<span class="line-removed">2401 </span>
<span class="line-removed">2402   heap_stable_ctrl = new IfFalseNode(heap_stable_iff);</span>
<span class="line-removed">2403   phase-&gt;register_control(heap_stable_ctrl, loop, heap_stable_iff);</span>
<span class="line-removed">2404   ctrl = new IfTrueNode(heap_stable_iff);</span>
<span class="line-removed">2405   phase-&gt;register_control(ctrl, loop, heap_stable_iff);</span>
<span class="line-removed">2406 </span>
<span class="line-removed">2407   assert(is_heap_stable_test(heap_stable_iff), &quot;Should match the shape&quot;);</span>
<span class="line-removed">2408 }</span>
<span class="line-removed">2409 </span>
<span class="line-removed">2410 void ShenandoahWriteBarrierNode::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2411   const Type* val_t = phase-&gt;igvn().type(val);</span>
<span class="line-removed">2412   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {</span>
<span class="line-removed">2413     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2414     Node* null_cmp = new CmpPNode(val, phase-&gt;igvn().zerocon(T_OBJECT));</span>
<span class="line-removed">2415     phase-&gt;register_new_node(null_cmp, ctrl);</span>
<span class="line-removed">2416     Node* null_test = new BoolNode(null_cmp, BoolTest::ne);</span>
<span class="line-removed">2417     phase-&gt;register_new_node(null_test, ctrl);</span>
<span class="line-removed">2418     IfNode* null_iff = new IfNode(ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2419     phase-&gt;register_control(null_iff, loop, ctrl);</span>
<span class="line-removed">2420     ctrl = new IfTrueNode(null_iff);</span>
<span class="line-removed">2421     phase-&gt;register_control(ctrl, loop, null_iff);</span>
<span class="line-removed">2422     null_ctrl = new IfFalseNode(null_iff);</span>
<span class="line-removed">2423     phase-&gt;register_control(null_ctrl, loop, null_iff);</span>
<span class="line-removed">2424   }</span>
<span class="line-removed">2425 }</span>
<span class="line-removed">2426 </span>
<span class="line-removed">2427 Node* ShenandoahWriteBarrierNode::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-removed">2428   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="line-removed">2429   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="line-removed">2430   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="line-removed">2431   Node* new_iff = iff-&gt;clone();</span>
<span class="line-removed">2432   new_iff-&gt;set_req(0, c);</span>
<span class="line-removed">2433   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="line-removed">2434   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="line-removed">2435   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="line-removed">2436   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="line-removed">2437   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="line-removed">2438   c = iftrue;</span>
<span class="line-removed">2439   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="line-removed">2440   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="line-removed">2441   Node* uncasted_val = val-&gt;in(1);</span>
<span class="line-removed">2442   val = new CastPPNode(uncasted_val, t);</span>
<span class="line-removed">2443   val-&gt;init_req(0, c);</span>
<span class="line-removed">2444   phase-&gt;register_new_node(val, c);</span>
<span class="line-removed">2445   return val;</span>
<span class="line-removed">2446 }</span>
<span class="line-removed">2447 </span>
<span class="line-removed">2448 void ShenandoahWriteBarrierNode::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
2449                                                 Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {
2450   IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();
2451   Node* proj = iff-&gt;proj_out(0);
2452   assert(proj != unc_ctrl, &quot;bad projection&quot;);
2453   Node* use = proj-&gt;unique_ctrl_out();
2454 
2455   assert(use == unc || use-&gt;is_Region(), &quot;what else?&quot;);
2456 
2457   uses.clear();
2458   if (use == unc) {
2459     phase-&gt;set_idom(use, new_unc_ctrl, phase-&gt;dom_depth(use));
2460     for (uint i = 1; i &lt; unc-&gt;req(); i++) {
2461       Node* n = unc-&gt;in(i);
2462       if (phase-&gt;has_ctrl(n) &amp;&amp; phase-&gt;get_ctrl(n) == proj) {
2463         uses.push(n);
2464       }
2465     }
2466   } else {
2467     assert(use-&gt;is_Region(), &quot;what else?&quot;);
2468     uint idx = 1;
2469     for (; use-&gt;in(idx) != proj; idx++);
2470     for (DUIterator_Fast imax, i = use-&gt;fast_outs(imax); i &lt; imax; i++) {
2471       Node* u = use-&gt;fast_out(i);
2472       if (u-&gt;is_Phi() &amp;&amp; phase-&gt;get_ctrl(u-&gt;in(idx)) == proj) {
2473         uses.push(u-&gt;in(idx));
2474       }
2475     }
2476   }
2477   for(uint next = 0; next &lt; uses.size(); next++ ) {
2478     Node *n = uses.at(next);
2479     assert(phase-&gt;get_ctrl(n) == proj, &quot;bad control&quot;);
2480     phase-&gt;set_ctrl_and_loop(n, new_unc_ctrl);
2481     if (n-&gt;in(0) == proj) {
2482       phase-&gt;igvn().replace_input_of(n, 0, new_unc_ctrl);
2483     }
2484     for (uint i = 0; i &lt; n-&gt;req(); i++) {
2485       Node* m = n-&gt;in(i);
2486       if (m != NULL &amp;&amp; phase-&gt;has_ctrl(m) &amp;&amp; phase-&gt;get_ctrl(m) == proj) {
2487         uses.push(m);
2488       }
2489     }
2490   }
2491 
2492   phase-&gt;igvn().rehash_node_delayed(use);
2493   int nb = use-&gt;replace_edge(proj, new_unc_ctrl);
2494   assert(nb == 1, &quot;only use expected&quot;);
2495 }
2496 
<a name="57" id="anc57"></a><span class="line-modified">2497 void ShenandoahWriteBarrierNode::in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {</span>
2498   IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
2499   Node* raw_rbtrue = new CastP2XNode(ctrl, val);
2500   phase-&gt;register_new_node(raw_rbtrue, ctrl);
2501   Node* cset_offset = new URShiftXNode(raw_rbtrue, phase-&gt;igvn().intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
2502   phase-&gt;register_new_node(cset_offset, ctrl);
2503   Node* in_cset_fast_test_base_addr = phase-&gt;igvn().makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
2504   phase-&gt;set_ctrl(in_cset_fast_test_base_addr, phase-&gt;C-&gt;root());
2505   Node* in_cset_fast_test_adr = new AddPNode(phase-&gt;C-&gt;top(), in_cset_fast_test_base_addr, cset_offset);
2506   phase-&gt;register_new_node(in_cset_fast_test_adr, ctrl);
2507   uint in_cset_fast_test_idx = Compile::AliasIdxRaw;
2508   const TypePtr* in_cset_fast_test_adr_type = NULL; // debug-mode-only argument
2509   debug_only(in_cset_fast_test_adr_type = phase-&gt;C-&gt;get_adr_type(in_cset_fast_test_idx));
2510   Node* in_cset_fast_test_load = new LoadBNode(ctrl, raw_mem, in_cset_fast_test_adr, in_cset_fast_test_adr_type, TypeInt::BYTE, MemNode::unordered);
2511   phase-&gt;register_new_node(in_cset_fast_test_load, ctrl);
2512   Node* in_cset_fast_test_cmp = new CmpINode(in_cset_fast_test_load, phase-&gt;igvn().zerocon(T_INT));
2513   phase-&gt;register_new_node(in_cset_fast_test_cmp, ctrl);
2514   Node* in_cset_fast_test_test = new BoolNode(in_cset_fast_test_cmp, BoolTest::eq);
2515   phase-&gt;register_new_node(in_cset_fast_test_test, ctrl);
2516   IfNode* in_cset_fast_test_iff = new IfNode(ctrl, in_cset_fast_test_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
2517   phase-&gt;register_control(in_cset_fast_test_iff, loop, ctrl);
2518 
2519   not_cset_ctrl = new IfTrueNode(in_cset_fast_test_iff);
2520   phase-&gt;register_control(not_cset_ctrl, loop, in_cset_fast_test_iff);
2521 
2522   ctrl = new IfFalseNode(in_cset_fast_test_iff);
2523   phase-&gt;register_control(ctrl, loop, in_cset_fast_test_iff);
2524 }
2525 
<a name="58" id="anc58"></a><span class="line-modified">2526 void ShenandoahWriteBarrierNode::call_wb_stub(Node*&amp; ctrl, Node*&amp; val, Node*&amp; result_mem,</span>
<span class="line-removed">2527                                               Node* raw_mem, Node* wb_mem,</span>
<span class="line-removed">2528                                               int alias,</span>
<span class="line-removed">2529                                               PhaseIdealLoop* phase) {</span>
2530   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
<a name="59" id="anc59"></a><span class="line-modified">2531   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
2532 
2533   // The slow path stub consumes and produces raw memory in addition
2534   // to the existing memory edges
2535   Node* base = find_bottom_mem(ctrl, phase);
<a name="60" id="anc60"></a><span class="line-removed">2536 </span>
2537   MergeMemNode* mm = MergeMemNode::make(base);
<a name="61" id="anc61"></a><span class="line-removed">2538   mm-&gt;set_memory_at(alias, wb_mem);</span>
2539   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
2540   phase-&gt;register_new_node(mm, ctrl);
2541 
<a name="62" id="anc62"></a><span class="line-modified">2542   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_write_barrier_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_JRT), &quot;shenandoah_write_barrier&quot;, TypeRawPtr::BOTTOM);</span>








2543   call-&gt;init_req(TypeFunc::Control, ctrl);
2544   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
2545   call-&gt;init_req(TypeFunc::Memory, mm);
2546   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
2547   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
2548   call-&gt;init_req(TypeFunc::Parms, val);
<a name="63" id="anc63"></a>
2549   phase-&gt;register_control(call, loop, ctrl);
2550   ctrl = new ProjNode(call, TypeFunc::Control);
2551   phase-&gt;register_control(ctrl, loop, call);
2552   result_mem = new ProjNode(call, TypeFunc::Memory);
2553   phase-&gt;register_new_node(result_mem, call);
2554   val = new ProjNode(call, TypeFunc::Parms);
2555   phase-&gt;register_new_node(val, call);
2556   val = new CheckCastPPNode(ctrl, val, obj_type);
2557   phase-&gt;register_new_node(val, ctrl);
2558 }
2559 
<a name="64" id="anc64"></a><span class="line-modified">2560 void ShenandoahWriteBarrierNode::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {</span>
2561   Node* ctrl = phase-&gt;get_ctrl(barrier);
2562   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
2563 
2564   // Update the control of all nodes that should be after the
2565   // barrier control flow
2566   uses.clear();
2567   // Every node that is control dependent on the barrier&#39;s input
2568   // control will be after the expanded barrier. The raw memory (if
2569   // its memory is control dependent on the barrier&#39;s input control)
2570   // must stay above the barrier.
2571   uses_to_ignore.clear();
2572   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
2573     uses_to_ignore.push(init_raw_mem);
2574   }
2575   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
2576     Node *n = uses_to_ignore.at(next);
2577     for (uint i = 0; i &lt; n-&gt;req(); i++) {
2578       Node* in = n-&gt;in(i);
2579       if (in != NULL &amp;&amp; phase-&gt;has_ctrl(in) &amp;&amp; phase-&gt;get_ctrl(in) == ctrl) {
2580         uses_to_ignore.push(in);
2581       }
2582     }
2583   }
2584   for (DUIterator_Fast imax, i = ctrl-&gt;fast_outs(imax); i &lt; imax; i++) {
2585     Node* u = ctrl-&gt;fast_out(i);
2586     if (u-&gt;_idx &lt; last &amp;&amp;
2587         u != barrier &amp;&amp;
2588         !uses_to_ignore.member(u) &amp;&amp;
2589         (u-&gt;in(0) != ctrl || (!u-&gt;is_Region() &amp;&amp; !u-&gt;is_Phi())) &amp;&amp;
2590         (ctrl-&gt;Opcode() != Op_CatchProj || u-&gt;Opcode() != Op_CreateEx)) {
2591       Node* old_c = phase-&gt;ctrl_or_self(u);
2592       Node* c = old_c;
2593       if (c != ctrl ||
2594           is_dominator_same_ctrl(old_c, barrier, u, phase) ||
2595           ShenandoahBarrierSetC2::is_shenandoah_state_load(u)) {
2596         phase-&gt;igvn().rehash_node_delayed(u);
2597         int nb = u-&gt;replace_edge(ctrl, region);
2598         if (u-&gt;is_CFG()) {
2599           if (phase-&gt;idom(u) == ctrl) {
2600             phase-&gt;set_idom(u, region, phase-&gt;dom_depth(region));
2601           }
2602         } else if (phase-&gt;get_ctrl(u) == ctrl) {
2603           assert(u != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
2604           uses.push(u);
2605         }
2606         assert(nb == 1, &quot;more than 1 ctrl input?&quot;);
2607         --i, imax -= nb;
2608       }
2609     }
2610   }
2611 }
2612 
<a name="65" id="anc65"></a><span class="line-modified">2613 void ShenandoahWriteBarrierNode::pin_and_expand(PhaseIdealLoop* phase) {</span>
<span class="line-modified">2614   Node_List enqueue_barriers;</span>
<span class="line-modified">2615   if (ShenandoahStoreValEnqueueBarrier) {</span>
<span class="line-modified">2616     Unique_Node_List wq;</span>
<span class="line-modified">2617     wq.push(phase-&gt;C-&gt;root());</span>
<span class="line-modified">2618     for (uint i = 0; i &lt; wq.size(); i++) {</span>
<span class="line-modified">2619       Node* n = wq.at(i);</span>
<span class="line-modified">2620       if (n-&gt;Opcode() == Op_ShenandoahEnqueueBarrier) {</span>
<span class="line-modified">2621         enqueue_barriers.push(n);</span>
<span class="line-modified">2622       }</span>
<span class="line-modified">2623       for (uint i = 0; i &lt; n-&gt;req(); i++) {</span>
<span class="line-modified">2624         Node* in = n-&gt;in(i);</span>
<span class="line-modified">2625         if (in != NULL) {</span>
<span class="line-modified">2626           wq.push(in);</span>
<span class="line-modified">2627         }</span>
<span class="line-modified">2628       }</span>


2629     }
2630   }
<a name="66" id="anc66"></a>


2631 
<a name="67" id="anc67"></a><span class="line-modified">2632   const bool trace = false;</span>





















































2633 
<a name="68" id="anc68"></a><span class="line-modified">2634   // Collect raw memory state at CFG points in the entire graph and</span>
<span class="line-modified">2635   // record it in memory_nodes. Optimize the raw memory graph in the</span>
<span class="line-modified">2636   // process. Optimizing the memory graph also makes the memory graph</span>
<span class="line-modified">2637   // simpler.</span>
<span class="line-modified">2638   GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers;</span>
















2639 
<a name="69" id="anc69"></a><span class="line-modified">2640   // Let&#39;s try to common write barriers again</span>
<span class="line-modified">2641   optimize_before_expansion(phase, memory_graph_fixers, true);</span>










































2642 
<a name="70" id="anc70"></a><span class="line-modified">2643   Unique_Node_List uses;</span>
<span class="line-modified">2644   for (int i = 0; i &lt; ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i++) {</span>
<span class="line-modified">2645     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i);</span>
<span class="line-modified">2646     Node* ctrl = phase-&gt;get_ctrl(wb);</span>






2647 
<a name="71" id="anc71"></a><span class="line-modified">2648     Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-modified">2649     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {</span>
<span class="line-modified">2650       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0)-&gt;in(0), val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);</span>
<span class="line-modified">2651       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0)-&gt;in(0));</span>
<span class="line-modified">2652     } else if (ctrl-&gt;is_CallRuntime()) {</span>
<span class="line-removed">2653       assert(is_dominator(phase-&gt;get_ctrl(val), ctrl-&gt;in(0), val, ctrl, phase), &quot;can&#39;t move&quot;);</span>
<span class="line-removed">2654       phase-&gt;set_ctrl(wb, ctrl-&gt;in(0));</span>
2655     }
<a name="72" id="anc72"></a>



































2656 
<a name="73" id="anc73"></a><span class="line-modified">2657     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;only for write barriers&quot;);</span>
<span class="line-modified">2658     // Look for a null check that dominates this barrier and move the</span>
<span class="line-modified">2659     // barrier right after the null check to enable implicit null</span>
<span class="line-removed">2660     // checks</span>
<span class="line-removed">2661     wb-&gt;pin_and_expand_move_barrier(phase, memory_graph_fixers, uses);</span>
2662 
<a name="74" id="anc74"></a><span class="line-modified">2663     wb-&gt;pin_and_expand_helper(phase);</span>
<span class="line-modified">2664   }</span>
2665 
<a name="75" id="anc75"></a><span class="line-modified">2666   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="line-modified">2667     Node* barrier = enqueue_barriers.at(i);</span>
<span class="line-modified">2668     Node* ctrl = phase-&gt;get_ctrl(barrier);</span>
<span class="line-modified">2669     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-modified">2670     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {</span>
<span class="line-modified">2671       // Expanding a barrier here will break loop strip mining</span>
<span class="line-modified">2672       // verification. Transform the loop so the loop nest doesn&#39;t</span>
<span class="line-modified">2673       // appear as strip mined.</span>
<span class="line-modified">2674       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();</span>
<span class="line-modified">2675       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);</span>






















































2676     }
2677   }
2678 
<a name="76" id="anc76"></a><span class="line-modified">2679   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="line-modified">2680     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="line-modified">2681     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="line-modified">2682     Node* ctrl = phase-&gt;get_ctrl(wb);</span>


2683     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
2684     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
2685       // Expanding a barrier here will break loop strip mining
2686       // verification. Transform the loop so the loop nest doesn&#39;t
2687       // appear as strip mined.
2688       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
2689       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
2690     }
2691   }
2692 
<a name="77" id="anc77"></a>
2693   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
2694   Unique_Node_List uses_to_ignore;
<a name="78" id="anc78"></a><span class="line-modified">2695   for (uint i = 0; i &lt; enqueue_barriers.size(); i++) {</span>
<span class="line-modified">2696     Node* barrier = enqueue_barriers.at(i);</span>

















































































































































































2697     Node* pre_val = barrier-&gt;in(1);
2698 
2699     if (phase-&gt;igvn().type(pre_val)-&gt;higher_equal(TypePtr::NULL_PTR)) {
2700       ShouldNotReachHere();
2701       continue;
2702     }
2703 
2704     Node* ctrl = phase-&gt;get_ctrl(barrier);
2705 
2706     if (ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) {
2707       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0)-&gt;in(0), pre_val, ctrl-&gt;in(0), phase), &quot;can&#39;t move&quot;);
2708       ctrl = ctrl-&gt;in(0)-&gt;in(0);
2709       phase-&gt;set_ctrl(barrier, ctrl);
2710     } else if (ctrl-&gt;is_CallRuntime()) {
2711       assert(is_dominator(phase-&gt;get_ctrl(pre_val), ctrl-&gt;in(0), pre_val, ctrl, phase), &quot;can&#39;t move&quot;);
2712       ctrl = ctrl-&gt;in(0);
2713       phase-&gt;set_ctrl(barrier, ctrl);
2714     }
2715 
2716     Node* init_ctrl = ctrl;
2717     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
2718     Node* raw_mem = fixer.find_mem(ctrl, barrier);
2719     Node* init_raw_mem = raw_mem;
2720     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
2721     Node* heap_stable_ctrl = NULL;
2722     Node* null_ctrl = NULL;
2723     uint last = phase-&gt;C-&gt;unique();
2724 
2725     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
2726     Node* region = new RegionNode(PATH_LIMIT);
2727     Node* phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
2728 
2729     enum { _fast_path = 1, _slow_path, _null_path, PATH_LIMIT2 };
2730     Node* region2 = new RegionNode(PATH_LIMIT2);
2731     Node* phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
2732 
2733     // Stable path.
2734     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);
2735     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
2736     phi-&gt;init_req(_heap_stable, raw_mem);
2737 
2738     // Null path
2739     Node* reg2_ctrl = NULL;
2740     test_null(ctrl, pre_val, null_ctrl, phase);
2741     if (null_ctrl != NULL) {
2742       reg2_ctrl = null_ctrl-&gt;in(0);
2743       region2-&gt;init_req(_null_path, null_ctrl);
2744       phi2-&gt;init_req(_null_path, raw_mem);
2745     } else {
2746       region2-&gt;del_req(_null_path);
2747       phi2-&gt;del_req(_null_path);
2748     }
2749 
2750     const int index_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset());
2751     const int buffer_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset());
2752     Node* thread = new ThreadLocalNode();
2753     phase-&gt;register_new_node(thread, ctrl);
2754     Node* buffer_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(buffer_offset));
2755     phase-&gt;register_new_node(buffer_adr, ctrl);
2756     Node* index_adr = new AddPNode(phase-&gt;C-&gt;top(), thread, phase-&gt;igvn().MakeConX(index_offset));
2757     phase-&gt;register_new_node(index_adr, ctrl);
2758 
2759     BasicType index_bt = TypeX_X-&gt;basic_type();
2760     assert(sizeof(size_t) == type2aelembytes(index_bt), &quot;Loading G1 SATBMarkQueue::_index with wrong size.&quot;);
2761     const TypePtr* adr_type = TypeRawPtr::BOTTOM;
2762     Node* index = new LoadXNode(ctrl, raw_mem, index_adr, adr_type, TypeX_X, MemNode::unordered);
2763     phase-&gt;register_new_node(index, ctrl);
2764     Node* index_cmp = new CmpXNode(index, phase-&gt;igvn().MakeConX(0));
2765     phase-&gt;register_new_node(index_cmp, ctrl);
2766     Node* index_test = new BoolNode(index_cmp, BoolTest::ne);
2767     phase-&gt;register_new_node(index_test, ctrl);
2768     IfNode* queue_full_iff = new IfNode(ctrl, index_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
2769     if (reg2_ctrl == NULL) reg2_ctrl = queue_full_iff;
2770     phase-&gt;register_control(queue_full_iff, loop, ctrl);
2771     Node* not_full = new IfTrueNode(queue_full_iff);
2772     phase-&gt;register_control(not_full, loop, queue_full_iff);
2773     Node* full = new IfFalseNode(queue_full_iff);
2774     phase-&gt;register_control(full, loop, queue_full_iff);
2775 
2776     ctrl = not_full;
2777 
2778     Node* next_index = new SubXNode(index, phase-&gt;igvn().MakeConX(sizeof(intptr_t)));
2779     phase-&gt;register_new_node(next_index, ctrl);
2780 
2781     Node* buffer  = new LoadPNode(ctrl, raw_mem, buffer_adr, adr_type, TypeRawPtr::NOTNULL, MemNode::unordered);
2782     phase-&gt;register_new_node(buffer, ctrl);
2783     Node *log_addr = new AddPNode(phase-&gt;C-&gt;top(), buffer, next_index);
2784     phase-&gt;register_new_node(log_addr, ctrl);
2785     Node* log_store = new StorePNode(ctrl, raw_mem, log_addr, adr_type, pre_val, MemNode::unordered);
2786     phase-&gt;register_new_node(log_store, ctrl);
2787     // update the index
<a name="79" id="anc79"></a><span class="line-modified">2788     Node* index_update = new StoreXNode(ctrl, log_store, index_adr, adr_type, next_index, MemNode::unordered);</span>
<span class="line-modified">2789     phase-&gt;register_new_node(index_update, ctrl);</span>
<span class="line-removed">2790 </span>
<span class="line-removed">2791     // Fast-path case</span>
<span class="line-removed">2792     region2-&gt;init_req(_fast_path, ctrl);</span>
<span class="line-removed">2793     phi2-&gt;init_req(_fast_path, index_update);</span>
<span class="line-removed">2794 </span>
<span class="line-removed">2795     ctrl = full;</span>
<span class="line-removed">2796 </span>
<span class="line-removed">2797     Node* base = find_bottom_mem(ctrl, phase);</span>
<span class="line-removed">2798 </span>
<span class="line-removed">2799     MergeMemNode* mm = MergeMemNode::make(base);</span>
<span class="line-removed">2800     mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);</span>
<span class="line-removed">2801     phase-&gt;register_new_node(mm, ctrl);</span>
<span class="line-removed">2802 </span>
<span class="line-removed">2803     Node* call = new CallLeafNode(ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type(), CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), &quot;shenandoah_wb_pre&quot;, TypeRawPtr::BOTTOM);</span>
<span class="line-removed">2804     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-removed">2805     call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2806     call-&gt;init_req(TypeFunc::Memory, mm);</span>
<span class="line-removed">2807     call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2808     call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());</span>
<span class="line-removed">2809     call-&gt;init_req(TypeFunc::Parms, pre_val);</span>
<span class="line-removed">2810     call-&gt;init_req(TypeFunc::Parms+1, thread);</span>
<span class="line-removed">2811     phase-&gt;register_control(call, loop, ctrl);</span>
<span class="line-removed">2812 </span>
<span class="line-removed">2813     Node* ctrl_proj = new ProjNode(call, TypeFunc::Control);</span>
<span class="line-removed">2814     phase-&gt;register_control(ctrl_proj, loop, call);</span>
<span class="line-removed">2815     Node* mem_proj = new ProjNode(call, TypeFunc::Memory);</span>
<span class="line-removed">2816     phase-&gt;register_new_node(mem_proj, call);</span>
<span class="line-removed">2817 </span>
<span class="line-removed">2818     // Slow-path case</span>
<span class="line-removed">2819     region2-&gt;init_req(_slow_path, ctrl_proj);</span>
<span class="line-removed">2820     phi2-&gt;init_req(_slow_path, mem_proj);</span>
<span class="line-removed">2821 </span>
<span class="line-removed">2822     phase-&gt;register_control(region2, loop, reg2_ctrl);</span>
<span class="line-removed">2823     phase-&gt;register_new_node(phi2, region2);</span>
<span class="line-removed">2824 </span>
<span class="line-removed">2825     region-&gt;init_req(_heap_unstable, region2);</span>
<span class="line-removed">2826     phi-&gt;init_req(_heap_unstable, phi2);</span>
<span class="line-removed">2827 </span>
<span class="line-removed">2828     phase-&gt;register_control(region, loop, heap_stable_ctrl-&gt;in(0));</span>
<span class="line-removed">2829     phase-&gt;register_new_node(phi, region);</span>
<span class="line-removed">2830 </span>
<span class="line-removed">2831     fix_ctrl(barrier, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="line-removed">2832     for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="line-removed">2833       Node *n = uses.at(next);</span>
<span class="line-removed">2834       assert(phase-&gt;get_ctrl(n) == init_ctrl, &quot;bad control&quot;);</span>
<span class="line-removed">2835       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);</span>
<span class="line-removed">2836       phase-&gt;set_ctrl(n, region);</span>
<span class="line-removed">2837       follow_barrier_uses(n, init_ctrl, uses, phase);</span>
<span class="line-removed">2838     }</span>
<span class="line-removed">2839     fixer.fix_mem(init_ctrl, region, init_raw_mem, raw_mem_for_ctrl, phi, uses);</span>
<span class="line-removed">2840 </span>
<span class="line-removed">2841     phase-&gt;igvn().replace_node(barrier, pre_val);</span>
<span class="line-removed">2842   }</span>
<span class="line-removed">2843 </span>
<span class="line-removed">2844   for (int i = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count(); i &gt; 0; i--) {</span>
<span class="line-removed">2845     int cnt = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count();</span>
<span class="line-removed">2846     ShenandoahWriteBarrierNode* wb = ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barrier(i-1);</span>
<span class="line-removed">2847 </span>
<span class="line-removed">2848     uint last = phase-&gt;C-&gt;unique();</span>
<span class="line-removed">2849     Node* ctrl = phase-&gt;get_ctrl(wb);</span>
<span class="line-removed">2850     Node* orig_ctrl = ctrl;</span>
<span class="line-removed">2851 </span>
<span class="line-removed">2852     Node* raw_mem = fixer.find_mem(ctrl, wb);</span>
<span class="line-removed">2853     Node* init_raw_mem = raw_mem;</span>
<span class="line-removed">2854     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);</span>
<span class="line-removed">2855     int alias = phase-&gt;C-&gt;get_alias_index(wb-&gt;adr_type());</span>
<span class="line-removed">2856     Node* wb_mem =  wb-&gt;in(Memory);</span>
<span class="line-removed">2857     Node* init_wb_mem = wb_mem;</span>
<span class="line-removed">2858 </span>
<span class="line-removed">2859     Node* val = wb-&gt;in(ValueIn);</span>
<span class="line-removed">2860     Node* wbproj = wb-&gt;find_out_with(Op_ShenandoahWBMemProj);</span>
<span class="line-removed">2861     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-removed">2862 </span>
<span class="line-removed">2863     assert(val-&gt;Opcode() != Op_ShenandoahWriteBarrier, &quot;No chain of write barriers&quot;);</span>
<span class="line-removed">2864 </span>
<span class="line-removed">2865     CallStaticJavaNode* unc = wb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-removed">2866     Node* unc_ctrl = NULL;</span>
<span class="line-removed">2867     if (unc != NULL) {</span>
<span class="line-removed">2868       if (val-&gt;in(0) != ctrl) {</span>
<span class="line-removed">2869         unc = NULL;</span>
<span class="line-removed">2870       } else {</span>
<span class="line-removed">2871         unc_ctrl = val-&gt;in(0);</span>
<span class="line-removed">2872       }</span>
<span class="line-removed">2873     }</span>
<span class="line-removed">2874 </span>
<span class="line-removed">2875     Node* uncasted_val = val;</span>
<span class="line-removed">2876     if (unc != NULL) {</span>
<span class="line-removed">2877       uncasted_val = val-&gt;in(1);</span>
<span class="line-removed">2878     }</span>
<span class="line-removed">2879 </span>
<span class="line-removed">2880     Node* heap_stable_ctrl = NULL;</span>
<span class="line-removed">2881     Node* null_ctrl = NULL;</span>
<span class="line-removed">2882 </span>
<span class="line-removed">2883     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);</span>
<span class="line-removed">2884     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);</span>
<span class="line-removed">2885 </span>
<span class="line-removed">2886     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };</span>
<span class="line-removed">2887     Node* region = new RegionNode(PATH_LIMIT);</span>
<span class="line-removed">2888     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="line-removed">2889     Node* mem_phi = PhiNode::make(region, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="line-removed">2890     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
2891 
<a name="80" id="anc80"></a><span class="line-modified">2892     enum { _not_cset = 1, _not_equal, _evac_path, _null_path, PATH_LIMIT2 };</span>
<span class="line-modified">2893     Node* region2 = new RegionNode(PATH_LIMIT2);</span>
<span class="line-modified">2894     Node* val_phi2 = new PhiNode(region2, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
<span class="line-removed">2895     Node* mem_phi2 = PhiNode::make(region2, wb_mem, Type::MEMORY, phase-&gt;C-&gt;alias_type(wb-&gt;adr_type())-&gt;adr_type());</span>
<span class="line-removed">2896     Node* raw_mem_phi2 = PhiNode::make(region2, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);</span>
2897 
<a name="81" id="anc81"></a><span class="line-modified">2898       // Stable path.</span>
<span class="line-removed">2899     test_heap_stable(ctrl, raw_mem, heap_stable_ctrl, phase);</span>
<span class="line-removed">2900     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();</span>
2901 
<a name="82" id="anc82"></a><span class="line-modified">2902     // Heap stable case</span>
<span class="line-removed">2903     region-&gt;init_req(_heap_stable, heap_stable_ctrl);</span>
<span class="line-removed">2904     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
<span class="line-removed">2905     mem_phi-&gt;init_req(_heap_stable, wb_mem);</span>
<span class="line-removed">2906     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);</span>
2907 
<a name="83" id="anc83"></a><span class="line-modified">2908     Node* reg2_ctrl = NULL;</span>
<span class="line-modified">2909     // Null case</span>
<span class="line-modified">2910     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="line-removed">2911     if (null_ctrl != NULL) {</span>
<span class="line-removed">2912       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="line-removed">2913       region2-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-removed">2914       val_phi2-&gt;init_req(_null_path, uncasted_val);</span>
<span class="line-removed">2915       mem_phi2-&gt;init_req(_null_path, wb_mem);</span>
<span class="line-removed">2916       raw_mem_phi2-&gt;init_req(_null_path, raw_mem);</span>
<span class="line-removed">2917     } else {</span>
<span class="line-removed">2918       region2-&gt;del_req(_null_path);</span>
<span class="line-removed">2919       val_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2920       mem_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2921       raw_mem_phi2-&gt;del_req(_null_path);</span>
<span class="line-removed">2922     }</span>
2923 
<a name="84" id="anc84"></a><span class="line-modified">2924     // Test for in-cset.</span>
<span class="line-modified">2925     // Wires !in_cset(obj) to slot 2 of region and phis</span>
<span class="line-modified">2926     Node* not_cset_ctrl = NULL;</span>
<span class="line-modified">2927     in_cset_fast_test(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
<span class="line-modified">2928     if (not_cset_ctrl != NULL) {</span>
<span class="line-modified">2929       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
<span class="line-modified">2930       region2-&gt;init_req(_not_cset, not_cset_ctrl);</span>
<span class="line-modified">2931       val_phi2-&gt;init_req(_not_cset, uncasted_val);</span>
<span class="line-modified">2932       mem_phi2-&gt;init_req(_not_cset, wb_mem);</span>
<span class="line-removed">2933       raw_mem_phi2-&gt;init_req(_not_cset, raw_mem);</span>
<span class="line-removed">2934     }</span>
2935 
<a name="85" id="anc85"></a><span class="line-modified">2936     // Resolve object when orig-value is in cset.</span>
<span class="line-modified">2937     // Make the unconditional resolve for fwdptr, not the read barrier.</span>
<span class="line-modified">2938     Node* new_val = uncasted_val;</span>
<span class="line-modified">2939     if (unc_ctrl != NULL) {</span>
<span class="line-removed">2940       // Clone the null check in this branch to allow implicit null check</span>
<span class="line-removed">2941       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="line-removed">2942       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
2943 
<a name="86" id="anc86"></a><span class="line-modified">2944       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-modified">2945       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="line-modified">2946     }</span>
<span class="line-removed">2947     Node* addr = new AddPNode(new_val, uncasted_val, phase-&gt;igvn().MakeConX(ShenandoahBrooksPointer::byte_offset()));</span>
<span class="line-removed">2948     phase-&gt;register_new_node(addr, ctrl);</span>
<span class="line-removed">2949     assert(val-&gt;bottom_type()-&gt;isa_oopptr(), &quot;what else?&quot;);</span>
<span class="line-removed">2950     const TypePtr* obj_type =  val-&gt;bottom_type()-&gt;is_oopptr();</span>
<span class="line-removed">2951     const TypePtr* adr_type = ShenandoahBarrierNode::brooks_pointer_type(obj_type);</span>
<span class="line-removed">2952     Node* fwd = new LoadPNode(ctrl, wb_mem, addr, adr_type, obj_type, MemNode::unordered);</span>
<span class="line-removed">2953     phase-&gt;register_new_node(fwd, ctrl);</span>
<span class="line-removed">2954 </span>
<span class="line-removed">2955     // Only branch to WB stub if object is not forwarded; otherwise reply with fwd ptr</span>
<span class="line-removed">2956     Node* cmp = new CmpPNode(fwd, new_val);</span>
<span class="line-removed">2957     phase-&gt;register_new_node(cmp, ctrl);</span>
<span class="line-removed">2958     Node* bol = new BoolNode(cmp, BoolTest::eq);</span>
<span class="line-removed">2959     phase-&gt;register_new_node(bol, ctrl);</span>
<span class="line-removed">2960 </span>
<span class="line-removed">2961     IfNode* iff = new IfNode(ctrl, bol, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);</span>
<span class="line-removed">2962     if (reg2_ctrl == NULL) reg2_ctrl = iff;</span>
<span class="line-removed">2963     phase-&gt;register_control(iff, loop, ctrl);</span>
<span class="line-removed">2964     Node* if_not_eq = new IfFalseNode(iff);</span>
<span class="line-removed">2965     phase-&gt;register_control(if_not_eq, loop, iff);</span>
<span class="line-removed">2966     Node* if_eq = new IfTrueNode(iff);</span>
<span class="line-removed">2967     phase-&gt;register_control(if_eq, loop, iff);</span>
<span class="line-removed">2968 </span>
<span class="line-removed">2969     // Wire up not-equal-path in slots 3.</span>
<span class="line-removed">2970     region2-&gt;init_req(_not_equal, if_not_eq);</span>
<span class="line-removed">2971     val_phi2-&gt;init_req(_not_equal, fwd);</span>
<span class="line-removed">2972     mem_phi2-&gt;init_req(_not_equal, wb_mem);</span>
<span class="line-removed">2973     raw_mem_phi2-&gt;init_req(_not_equal, raw_mem);</span>
<span class="line-removed">2974 </span>
<span class="line-removed">2975     // Call wb-stub and wire up that path in slots 4</span>
<span class="line-removed">2976     Node* result_mem = NULL;</span>
<span class="line-removed">2977     ctrl = if_eq;</span>
<span class="line-removed">2978     call_wb_stub(ctrl, new_val, result_mem,</span>
<span class="line-removed">2979                  raw_mem, wb_mem,</span>
<span class="line-removed">2980                  alias, phase);</span>
<span class="line-removed">2981     region2-&gt;init_req(_evac_path, ctrl);</span>
<span class="line-removed">2982     val_phi2-&gt;init_req(_evac_path, new_val);</span>
<span class="line-removed">2983     mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
<span class="line-removed">2984     raw_mem_phi2-&gt;init_req(_evac_path, result_mem);</span>
2985 
2986     phase-&gt;register_control(region2, loop, reg2_ctrl);
<a name="87" id="anc87"></a><span class="line-modified">2987     phase-&gt;register_new_node(val_phi2, region2);</span>
<span class="line-removed">2988     phase-&gt;register_new_node(mem_phi2, region2);</span>
<span class="line-removed">2989     phase-&gt;register_new_node(raw_mem_phi2, region2);</span>
2990 
2991     region-&gt;init_req(_heap_unstable, region2);
<a name="88" id="anc88"></a><span class="line-modified">2992     val_phi-&gt;init_req(_heap_unstable, val_phi2);</span>
<span class="line-removed">2993     mem_phi-&gt;init_req(_heap_unstable, mem_phi2);</span>
<span class="line-removed">2994     raw_mem_phi-&gt;init_req(_heap_unstable, raw_mem_phi2);</span>
<span class="line-removed">2995 </span>
<span class="line-removed">2996     phase-&gt;register_control(region, loop, heap_stable_iff);</span>
<span class="line-removed">2997     Node* out_val = val_phi;</span>
<span class="line-removed">2998     phase-&gt;register_new_node(val_phi, region);</span>
<span class="line-removed">2999     phase-&gt;register_new_node(mem_phi, region);</span>
<span class="line-removed">3000     phase-&gt;register_new_node(raw_mem_phi, region);</span>
<span class="line-removed">3001 </span>
<span class="line-removed">3002     fix_ctrl(wb, region, fixer, uses, uses_to_ignore, last, phase);</span>
<span class="line-removed">3003 </span>
<span class="line-removed">3004     ctrl = orig_ctrl;</span>
<span class="line-removed">3005 </span>
<span class="line-removed">3006     phase-&gt;igvn().replace_input_of(wbproj, ShenandoahWBMemProjNode::WriteBarrier, phase-&gt;C-&gt;top());</span>
<span class="line-removed">3007     phase-&gt;igvn().replace_node(wbproj, mem_phi);</span>
<span class="line-removed">3008     if (unc != NULL) {</span>
<span class="line-removed">3009       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">3010         Node* u = val-&gt;fast_out(i);</span>
<span class="line-removed">3011         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-removed">3012         if (u != wb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, wb, u, phase))) {</span>
<span class="line-removed">3013           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-removed">3014           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="line-removed">3015           --i, imax -= nb;</span>
<span class="line-removed">3016         }</span>
<span class="line-removed">3017       }</span>
<span class="line-removed">3018       if (val-&gt;outcnt() == 0) {</span>
<span class="line-removed">3019         phase-&gt;igvn()._worklist.push(val);</span>
<span class="line-removed">3020       }</span>
<span class="line-removed">3021     }</span>
<span class="line-removed">3022     phase-&gt;igvn().replace_node(wb, out_val);</span>
3023 
<a name="89" id="anc89"></a><span class="line-modified">3024     follow_barrier_uses(mem_phi, ctrl, uses, phase);</span>
<span class="line-modified">3025     follow_barrier_uses(out_val, ctrl, uses, phase);</span>
3026 
<a name="90" id="anc90"></a>
3027     for(uint next = 0; next &lt; uses.size(); next++ ) {
3028       Node *n = uses.at(next);
<a name="91" id="anc91"></a><span class="line-modified">3029       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);</span>
3030       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
3031       phase-&gt;set_ctrl(n, region);
<a name="92" id="anc92"></a><span class="line-modified">3032       follow_barrier_uses(n, ctrl, uses, phase);</span>
3033     }
<a name="93" id="anc93"></a>
3034 
<a name="94" id="anc94"></a><span class="line-modified">3035     // The slow path call produces memory: hook the raw memory phi</span>
<span class="line-modified">3036     // from the expanded write barrier with the rest of the graph</span>
<span class="line-modified">3037     // which may require adding memory phis at every post dominated</span>
<span class="line-modified">3038     // region and at enclosing loop heads. Use the memory state</span>
<span class="line-modified">3039     // collected in memory_nodes to fix the memory graph. Update that</span>
<span class="line-modified">3040     // memory state as we go.</span>
<span class="line-modified">3041     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);</span>
<span class="line-modified">3042     assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == cnt - 1, &quot;not replaced&quot;);</span>































































3043   }
3044 
<a name="95" id="anc95"></a><span class="line-removed">3045   assert(ShenandoahBarrierSetC2::bsc2()-&gt;state()-&gt;shenandoah_barriers_count() == 0, &quot;all write barrier nodes should have been replaced&quot;);</span>
3046 }
3047 
<a name="96" id="anc96"></a><span class="line-modified">3048 void ShenandoahWriteBarrierNode::move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {</span>
3049   IdealLoopTree *loop = phase-&gt;get_loop(iff);
3050   Node* loop_head = loop-&gt;_head;
3051   Node* entry_c = loop_head-&gt;in(LoopNode::EntryControl);
3052 
3053   Node* bol = iff-&gt;in(1);
3054   Node* cmp = bol-&gt;in(1);
3055   Node* andi = cmp-&gt;in(1);
3056   Node* load = andi-&gt;in(1);
3057 
3058   assert(is_gc_state_load(load), &quot;broken&quot;);
3059   if (!phase-&gt;is_dominator(load-&gt;in(0), entry_c)) {
3060     Node* mem_ctrl = NULL;
3061     Node* mem = dom_mem(load-&gt;in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);
3062     load = load-&gt;clone();
3063     load-&gt;set_req(MemNode::Memory, mem);
3064     load-&gt;set_req(0, entry_c);
3065     phase-&gt;register_new_node(load, entry_c);
3066     andi = andi-&gt;clone();
3067     andi-&gt;set_req(1, load);
3068     phase-&gt;register_new_node(andi, entry_c);
3069     cmp = cmp-&gt;clone();
3070     cmp-&gt;set_req(1, andi);
3071     phase-&gt;register_new_node(cmp, entry_c);
3072     bol = bol-&gt;clone();
3073     bol-&gt;set_req(1, cmp);
3074     phase-&gt;register_new_node(bol, entry_c);
3075 
3076     Node* old_bol =iff-&gt;in(1);
3077     phase-&gt;igvn().replace_input_of(iff, 1, bol);
3078   }
3079 }
3080 
<a name="97" id="anc97"></a><span class="line-modified">3081 bool ShenandoahWriteBarrierNode::identical_backtoback_ifs(Node *n, PhaseIdealLoop* phase) {</span>
3082   if (!n-&gt;is_If() || n-&gt;is_CountedLoopEnd()) {
3083     return false;
3084   }
3085   Node* region = n-&gt;in(0);
3086 
3087   if (!region-&gt;is_Region()) {
3088     return false;
3089   }
3090   Node* dom = phase-&gt;idom(region);
3091   if (!dom-&gt;is_If()) {
3092     return false;
3093   }
3094 
3095   if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {
3096     return false;
3097   }
3098 
3099   IfNode* dom_if = dom-&gt;as_If();
3100   Node* proj_true = dom_if-&gt;proj_out(1);
3101   Node* proj_false = dom_if-&gt;proj_out(0);
3102 
3103   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3104     if (phase-&gt;is_dominator(proj_true, region-&gt;in(i))) {
3105       continue;
3106     }
3107     if (phase-&gt;is_dominator(proj_false, region-&gt;in(i))) {
3108       continue;
3109     }
3110     return false;
3111   }
3112 
3113   return true;
3114 }
3115 
<a name="98" id="anc98"></a><span class="line-modified">3116 void ShenandoahWriteBarrierNode::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {</span>
3117   assert(is_heap_stable_test(n), &quot;no other tests&quot;);
3118   if (identical_backtoback_ifs(n, phase)) {
3119     Node* n_ctrl = n-&gt;in(0);
3120     if (phase-&gt;can_split_if(n_ctrl)) {
3121       IfNode* dom_if = phase-&gt;idom(n_ctrl)-&gt;as_If();
3122       if (is_heap_stable_test(n)) {
3123         Node* gc_state_load = n-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
3124         assert(is_gc_state_load(gc_state_load), &quot;broken&quot;);
3125         Node* dom_gc_state_load = dom_if-&gt;in(1)-&gt;in(1)-&gt;in(1)-&gt;in(1);
3126         assert(is_gc_state_load(dom_gc_state_load), &quot;broken&quot;);
3127         if (gc_state_load != dom_gc_state_load) {
3128           phase-&gt;igvn().replace_node(gc_state_load, dom_gc_state_load);
3129         }
3130       }
3131       PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n-&gt;in(1));
3132       Node* proj_true = dom_if-&gt;proj_out(1);
3133       Node* proj_false = dom_if-&gt;proj_out(0);
3134       Node* con_true = phase-&gt;igvn().makecon(TypeInt::ONE);
3135       Node* con_false = phase-&gt;igvn().makecon(TypeInt::ZERO);
3136 
3137       for (uint i = 1; i &lt; n_ctrl-&gt;req(); i++) {
3138         if (phase-&gt;is_dominator(proj_true, n_ctrl-&gt;in(i))) {
3139           bolphi-&gt;init_req(i, con_true);
3140         } else {
3141           assert(phase-&gt;is_dominator(proj_false, n_ctrl-&gt;in(i)), &quot;bad if&quot;);
3142           bolphi-&gt;init_req(i, con_false);
3143         }
3144       }
3145       phase-&gt;register_new_node(bolphi, n_ctrl);
3146       phase-&gt;igvn().replace_input_of(n, 1, bolphi);
3147       phase-&gt;do_split_if(n);
3148     }
3149   }
3150 }
3151 
<a name="99" id="anc99"></a><span class="line-modified">3152 IfNode* ShenandoahWriteBarrierNode::find_unswitching_candidate(const IdealLoopTree *loop, PhaseIdealLoop* phase) {</span>
3153   // Find first invariant test that doesn&#39;t exit the loop
3154   LoopNode *head = loop-&gt;_head-&gt;as_Loop();
3155   IfNode* unswitch_iff = NULL;
3156   Node* n = head-&gt;in(LoopNode::LoopBackControl);
3157   int loop_has_sfpts = -1;
3158   while (n != head) {
3159     Node* n_dom = phase-&gt;idom(n);
3160     if (n-&gt;is_Region()) {
3161       if (n_dom-&gt;is_If()) {
3162         IfNode* iff = n_dom-&gt;as_If();
3163         if (iff-&gt;in(1)-&gt;is_Bool()) {
3164           BoolNode* bol = iff-&gt;in(1)-&gt;as_Bool();
3165           if (bol-&gt;in(1)-&gt;is_Cmp()) {
3166             // If condition is invariant and not a loop exit,
3167             // then found reason to unswitch.
3168             if (is_heap_stable_test(iff) &amp;&amp;
3169                 (loop_has_sfpts == -1 || loop_has_sfpts == 0)) {
3170               assert(!loop-&gt;is_loop_exit(iff), &quot;both branches should be in the loop&quot;);
3171               if (loop_has_sfpts == -1) {
3172                 for(uint i = 0; i &lt; loop-&gt;_body.size(); i++) {
3173                   Node *m = loop-&gt;_body[i];
3174                   if (m-&gt;is_SafePoint() &amp;&amp; !m-&gt;is_CallLeaf()) {
3175                     loop_has_sfpts = 1;
3176                     break;
3177                   }
3178                 }
3179                 if (loop_has_sfpts == -1) {
3180                   loop_has_sfpts = 0;
3181                 }
3182               }
3183               if (!loop_has_sfpts) {
3184                 unswitch_iff = iff;
3185               }
3186             }
3187           }
3188         }
3189       }
3190     }
3191     n = n_dom;
3192   }
3193   return unswitch_iff;
3194 }
3195 
3196 
<a name="100" id="anc100"></a><span class="line-modified">3197 void ShenandoahWriteBarrierNode::optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;stack, Node_List &amp;old_new, PhaseIdealLoop* phase) {</span>
3198   Node_List heap_stable_tests;
3199   Node_List gc_state_loads;
<a name="101" id="anc101"></a><span class="line-removed">3200 </span>
3201   stack.push(phase-&gt;C-&gt;start(), 0);
3202   do {
3203     Node* n = stack.node();
3204     uint i = stack.index();
3205 
3206     if (i &lt; n-&gt;outcnt()) {
3207       Node* u = n-&gt;raw_out(i);
3208       stack.set_index(i+1);
3209       if (!visited.test_set(u-&gt;_idx)) {
3210         stack.push(u, 0);
3211       }
3212     } else {
3213       stack.pop();
3214       if (ShenandoahCommonGCStateLoads &amp;&amp; is_gc_state_load(n)) {
3215         gc_state_loads.push(n);
3216       }
3217       if (n-&gt;is_If() &amp;&amp; is_heap_stable_test(n)) {
3218         heap_stable_tests.push(n);
3219       }
3220     }
3221   } while (stack.size() &gt; 0);
3222 
3223   bool progress;
3224   do {
3225     progress = false;
3226     for (uint i = 0; i &lt; gc_state_loads.size(); i++) {
3227       Node* n = gc_state_loads.at(i);
3228       if (n-&gt;outcnt() != 0) {
3229         progress |= try_common_gc_state_load(n, phase);
3230       }
3231     }
3232   } while (progress);
3233 
3234   for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
3235     Node* n = heap_stable_tests.at(i);
3236     assert(is_heap_stable_test(n), &quot;only evacuation test&quot;);
3237     merge_back_to_back_tests(n, phase);
3238   }
3239 
3240   if (!phase-&gt;C-&gt;major_progress()) {
3241     VectorSet seen(Thread::current()-&gt;resource_area());
3242     for (uint i = 0; i &lt; heap_stable_tests.size(); i++) {
3243       Node* n = heap_stable_tests.at(i);
3244       IdealLoopTree* loop = phase-&gt;get_loop(n);
3245       if (loop != phase-&gt;ltree_root() &amp;&amp;
3246           loop-&gt;_child == NULL &amp;&amp;
3247           !loop-&gt;_irreducible) {
<a name="102" id="anc102"></a><span class="line-modified">3248         LoopNode* head = loop-&gt;_head-&gt;as_Loop();</span>
<span class="line-modified">3249         if ((!head-&gt;is_CountedLoop() || head-&gt;as_CountedLoop()-&gt;is_main_loop() || head-&gt;as_CountedLoop()-&gt;is_normal_loop()) &amp;&amp;</span>

3250             !seen.test_set(head-&gt;_idx)) {
3251           IfNode* iff = find_unswitching_candidate(loop, phase);
3252           if (iff != NULL) {
3253             Node* bol = iff-&gt;in(1);
<a name="103" id="anc103"></a><span class="line-modified">3254             if (head-&gt;is_strip_mined()) {</span>
<span class="line-modified">3255               head-&gt;verify_strip_mined(0);</span>
3256             }
3257             move_heap_stable_test_out_of_loop(iff, phase);
<a name="104" id="anc104"></a>


3258             if (loop-&gt;policy_unswitching(phase)) {
<a name="105" id="anc105"></a><span class="line-modified">3259               if (head-&gt;is_strip_mined()) {</span>
3260                 OuterStripMinedLoopNode* outer = head-&gt;as_CountedLoop()-&gt;outer_loop();
3261                 hide_strip_mined_loop(outer, head-&gt;as_CountedLoop(), phase);
3262               }
3263               phase-&gt;do_unswitching(loop, old_new);
3264             } else {
3265               // Not proceeding with unswitching. Move load back in
3266               // the loop.
3267               phase-&gt;igvn().replace_input_of(iff, 1, bol);
3268             }
3269           }
3270         }
3271       }
3272     }
3273   }
3274 }
3275 
3276 #ifdef ASSERT
<a name="106" id="anc106"></a><span class="line-modified">3277 void ShenandoahBarrierNode::verify_raw_mem(RootNode* root) {</span>
3278   const bool trace = false;
3279   ResourceMark rm;
3280   Unique_Node_List nodes;
3281   Unique_Node_List controls;
3282   Unique_Node_List memories;
3283 
3284   nodes.push(root);
3285   for (uint next = 0; next &lt; nodes.size(); next++) {
3286     Node *n  = nodes.at(next);
<a name="107" id="anc107"></a><span class="line-modified">3287     if (ShenandoahBarrierSetC2::is_shenandoah_wb_call(n)) {</span>
3288       controls.push(n);
3289       if (trace) { tty-&gt;print(&quot;XXXXXX verifying&quot;); n-&gt;dump(); }
3290       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
3291         Node *m = controls.at(next2);
3292         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3293           Node* u = m-&gt;fast_out(i);
3294           if (u-&gt;is_CFG() &amp;&amp; !u-&gt;is_Root() &amp;&amp;
3295               !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1) &amp;&amp;
3296               !(u-&gt;is_Region() &amp;&amp; u-&gt;unique_ctrl_out()-&gt;Opcode() == Op_Halt)) {
3297             if (trace) { tty-&gt;print(&quot;XXXXXX pushing control&quot;); u-&gt;dump(); }
3298             controls.push(u);
3299           }
3300         }
3301       }
3302       memories.push(n-&gt;as_Call()-&gt;proj_out(TypeFunc::Memory));
3303       for (uint next2 = 0; next2 &lt; memories.size(); next2++) {
3304         Node *m = memories.at(next2);
3305         assert(m-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3306         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3307           Node* u = m-&gt;fast_out(i);
3308           if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; (u-&gt;is_Mem() || u-&gt;is_ClearArray())) {
3309             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
3310             memories.push(u);
3311           } else if (u-&gt;is_LoadStore()) {
3312             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;find_out_with(Op_SCMemProj)-&gt;dump(); }
3313             memories.push(u-&gt;find_out_with(Op_SCMemProj));
3314           } else if (u-&gt;is_MergeMem() &amp;&amp; u-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw) == m) {
3315             if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
3316             memories.push(u);
3317           } else if (u-&gt;is_Phi()) {
3318             assert(u-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3319             if (u-&gt;adr_type() == TypeRawPtr::BOTTOM || u-&gt;adr_type() == TypePtr::BOTTOM) {
3320               assert(controls.member(u-&gt;in(0)), &quot;&quot;);
3321               if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); u-&gt;dump(); }
3322               memories.push(u);
3323             }
3324           } else if (u-&gt;is_SafePoint() || u-&gt;is_MemBar()) {
3325             for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3326               Node* uu = u-&gt;fast_out(j);
3327               if (uu-&gt;bottom_type() == Type::MEMORY) {
3328                 if (trace) { tty-&gt;print(&quot;XXXXXX pushing memory&quot;); uu-&gt;dump(); }
3329                 memories.push(uu);
3330               }
3331             }
3332           }
3333         }
3334       }
3335       for (uint next2 = 0; next2 &lt; controls.size(); next2++) {
3336         Node *m = controls.at(next2);
3337         if (m-&gt;is_Region()) {
3338           bool all_in = true;
3339           for (uint i = 1; i &lt; m-&gt;req(); i++) {
3340             if (!controls.member(m-&gt;in(i))) {
3341               all_in = false;
3342               break;
3343             }
3344           }
3345           if (trace) { tty-&gt;print(&quot;XXX verifying %s&quot;, all_in ? &quot;all in&quot; : &quot;&quot;); m-&gt;dump(); }
3346           bool found_phi = false;
3347           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax &amp;&amp; !found_phi; j++) {
3348             Node* u = m-&gt;fast_out(j);
3349             if (u-&gt;is_Phi() &amp;&amp; memories.member(u)) {
3350               found_phi = true;
3351               for (uint i = 1; i &lt; u-&gt;req() &amp;&amp; found_phi; i++) {
3352                 Node* k = u-&gt;in(i);
3353                 if (memories.member(k) != controls.member(m-&gt;in(i))) {
3354                   found_phi = false;
3355                 }
3356               }
3357             }
3358           }
3359           assert(found_phi || all_in, &quot;&quot;);
3360         }
3361       }
3362       controls.clear();
3363       memories.clear();
3364     }
3365     for( uint i = 0; i &lt; n-&gt;len(); ++i ) {
3366       Node *m = n-&gt;in(i);
3367       if (m != NULL) {
3368         nodes.push(m);
3369       }
3370     }
3371   }
3372 }
3373 #endif
3374 
<a name="108" id="anc108"></a>



3375 const Type* ShenandoahEnqueueBarrierNode::bottom_type() const {
3376   if (in(1) == NULL || in(1)-&gt;is_top()) {
3377     return Type::TOP;
3378   }
3379   const Type* t = in(1)-&gt;bottom_type();
3380   if (t == TypePtr::NULL_PTR) {
3381     return t;
3382   }
<a name="109" id="anc109"></a><span class="line-modified">3383   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
3384 }
3385 
3386 const Type* ShenandoahEnqueueBarrierNode::Value(PhaseGVN* phase) const {
3387   if (in(1) == NULL) {
3388     return Type::TOP;
3389   }
3390   const Type* t = phase-&gt;type(in(1));
3391   if (t == Type::TOP) {
3392     return Type::TOP;
3393   }
3394   if (t == TypePtr::NULL_PTR) {
3395     return t;
3396   }
<a name="110" id="anc110"></a><span class="line-modified">3397   return t-&gt;is_oopptr()-&gt;cast_to_nonconst();</span>
3398 }
3399 
3400 int ShenandoahEnqueueBarrierNode::needed(Node* n) {
3401   if (n == NULL ||
3402       n-&gt;is_Allocate() ||
<a name="111" id="anc111"></a>
3403       n-&gt;bottom_type() == TypePtr::NULL_PTR ||
3404       (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL)) {
3405     return NotNeeded;
3406   }
3407   if (n-&gt;is_Phi() ||
3408       n-&gt;is_CMove()) {
3409     return MaybeNeeded;
3410   }
3411   return Needed;
3412 }
3413 
3414 Node* ShenandoahEnqueueBarrierNode::next(Node* n) {
3415   for (;;) {
3416     if (n == NULL) {
3417       return n;
3418     } else if (n-&gt;bottom_type() == TypePtr::NULL_PTR) {
3419       return n;
3420     } else if (n-&gt;bottom_type()-&gt;make_oopptr() != NULL &amp;&amp; n-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() != NULL) {
3421       return n;
3422     } else if (n-&gt;is_ConstraintCast() ||
3423                n-&gt;Opcode() == Op_DecodeN ||
3424                n-&gt;Opcode() == Op_EncodeP) {
3425       n = n-&gt;in(1);
3426     } else if (n-&gt;is_Proj()) {
3427       n = n-&gt;in(0);
3428     } else {
3429       return n;
3430     }
3431   }
3432   ShouldNotReachHere();
3433   return NULL;
3434 }
3435 
3436 Node* ShenandoahEnqueueBarrierNode::Identity(PhaseGVN* phase) {
3437   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
3438 
3439   Node* n = next(in(1));
3440 
3441   int cont = needed(n);
3442 
3443   if (cont == NotNeeded) {
3444     return in(1);
3445   } else if (cont == MaybeNeeded) {
3446     if (igvn == NULL) {
3447       phase-&gt;record_for_igvn(this);
3448       return this;
3449     } else {
3450       ResourceMark rm;
3451       Unique_Node_List wq;
3452       uint wq_i = 0;
3453 
3454       for (;;) {
3455         if (n-&gt;is_Phi()) {
3456           for (uint i = 1; i &lt; n-&gt;req(); i++) {
3457             Node* m = n-&gt;in(i);
3458             if (m != NULL) {
3459               wq.push(m);
3460             }
3461           }
3462         } else {
3463           assert(n-&gt;is_CMove(), &quot;nothing else here&quot;);
3464           Node* m = n-&gt;in(CMoveNode::IfFalse);
3465           wq.push(m);
3466           m = n-&gt;in(CMoveNode::IfTrue);
3467           wq.push(m);
3468         }
3469         Node* orig_n = NULL;
3470         do {
3471           if (wq_i &gt;= wq.size()) {
3472             return in(1);
3473           }
3474           n = wq.at(wq_i);
3475           wq_i++;
3476           orig_n = n;
3477           n = next(n);
3478           cont = needed(n);
3479           if (cont == Needed) {
3480             return this;
3481           }
3482         } while (cont != MaybeNeeded || (orig_n != n &amp;&amp; wq.member(n)));
3483       }
3484     }
3485   }
3486 
3487   return this;
3488 }
3489 
3490 #ifdef ASSERT
3491 static bool has_never_branch(Node* root) {
3492   for (uint i = 1; i &lt; root-&gt;req(); i++) {
3493     Node* in = root-&gt;in(i);
3494     if (in != NULL &amp;&amp; in-&gt;Opcode() == Op_Halt &amp;&amp; in-&gt;in(0)-&gt;is_Proj() &amp;&amp; in-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_NeverBranch) {
3495       return true;
3496     }
3497   }
3498   return false;
3499 }
3500 #endif
3501 
3502 void MemoryGraphFixer::collect_memory_nodes() {
3503   Node_Stack stack(0);
3504   VectorSet visited(Thread::current()-&gt;resource_area());
3505   Node_List regions;
3506 
3507   // Walk the raw memory graph and create a mapping from CFG node to
3508   // memory node. Exclude phis for now.
3509   stack.push(_phase-&gt;C-&gt;root(), 1);
3510   do {
3511     Node* n = stack.node();
3512     int opc = n-&gt;Opcode();
3513     uint i = stack.index();
3514     if (i &lt; n-&gt;req()) {
3515       Node* mem = NULL;
3516       if (opc == Op_Root) {
3517         Node* in = n-&gt;in(i);
3518         int in_opc = in-&gt;Opcode();
3519         if (in_opc == Op_Return || in_opc == Op_Rethrow) {
3520           mem = in-&gt;in(TypeFunc::Memory);
3521         } else if (in_opc == Op_Halt) {
<a name="112" id="anc112"></a><span class="line-modified">3522           if (!in-&gt;in(0)-&gt;is_Region()) {</span>





3523             Node* proj = in-&gt;in(0);
3524             assert(proj-&gt;is_Proj(), &quot;&quot;);
3525             Node* in = proj-&gt;in(0);
3526             assert(in-&gt;is_CallStaticJava() || in-&gt;Opcode() == Op_NeverBranch || in-&gt;Opcode() == Op_Catch || proj-&gt;is_IfProj(), &quot;&quot;);
3527             if (in-&gt;is_CallStaticJava()) {
3528               mem = in-&gt;in(TypeFunc::Memory);
3529             } else if (in-&gt;Opcode() == Op_Catch) {
3530               Node* call = in-&gt;in(0)-&gt;in(0);
3531               assert(call-&gt;is_Call(), &quot;&quot;);
3532               mem = call-&gt;in(TypeFunc::Memory);
<a name="113" id="anc113"></a>































3533             }
3534           }
3535         } else {
3536 #ifdef ASSERT
3537           n-&gt;dump();
3538           in-&gt;dump();
3539 #endif
3540           ShouldNotReachHere();
3541         }
3542       } else {
3543         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3544         assert(n-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(n-&gt;adr_type()) == _alias, &quot;&quot;);
3545         mem = n-&gt;in(i);
3546       }
3547       i++;
3548       stack.set_index(i);
3549       if (mem == NULL) {
3550         continue;
3551       }
3552       for (;;) {
3553         if (visited.test_set(mem-&gt;_idx) || mem-&gt;is_Start()) {
3554           break;
3555         }
3556         if (mem-&gt;is_Phi()) {
3557           stack.push(mem, 2);
3558           mem = mem-&gt;in(1);
3559         } else if (mem-&gt;is_Proj()) {
3560           stack.push(mem, mem-&gt;req());
3561           mem = mem-&gt;in(0);
3562         } else if (mem-&gt;is_SafePoint() || mem-&gt;is_MemBar()) {
3563           mem = mem-&gt;in(TypeFunc::Memory);
3564         } else if (mem-&gt;is_MergeMem()) {
3565           MergeMemNode* mm = mem-&gt;as_MergeMem();
3566           mem = mm-&gt;memory_at(_alias);
3567         } else if (mem-&gt;is_Store() || mem-&gt;is_LoadStore() || mem-&gt;is_ClearArray()) {
3568           assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3569           stack.push(mem, mem-&gt;req());
3570           mem = mem-&gt;in(MemNode::Memory);
<a name="114" id="anc114"></a><span class="line-removed">3571         } else if (mem-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">3572           assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3573           mem = mem-&gt;in(ShenandoahBarrierNode::Memory);</span>
<span class="line-removed">3574         } else if (mem-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">3575           stack.push(mem, mem-&gt;req());</span>
<span class="line-removed">3576           mem = mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
3577         } else {
3578 #ifdef ASSERT
3579           mem-&gt;dump();
3580 #endif
3581           ShouldNotReachHere();
3582         }
3583       }
3584     } else {
3585       if (n-&gt;is_Phi()) {
3586         // Nothing
3587       } else if (!n-&gt;is_Root()) {
3588         Node* c = get_ctrl(n);
3589         _memory_nodes.map(c-&gt;_idx, n);
3590       }
3591       stack.pop();
3592     }
3593   } while(stack.is_nonempty());
3594 
3595   // Iterate over CFG nodes in rpo and propagate memory state to
3596   // compute memory state at regions, creating new phis if needed.
3597   Node_List rpo_list;
<a name="115" id="anc115"></a><span class="line-modified">3598   visited.Clear();</span>
3599   _phase-&gt;rpo(_phase-&gt;C-&gt;root(), stack, visited, rpo_list);
3600   Node* root = rpo_list.pop();
3601   assert(root == _phase-&gt;C-&gt;root(), &quot;&quot;);
3602 
3603   const bool trace = false;
3604 #ifdef ASSERT
3605   if (trace) {
3606     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3607       Node* c = rpo_list.at(i);
3608       if (_memory_nodes[c-&gt;_idx] != NULL) {
3609         tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump();
3610       }
3611     }
3612   }
3613 #endif
3614   uint last = _phase-&gt;C-&gt;unique();
3615 
3616 #ifdef ASSERT
3617   uint8_t max_depth = 0;
3618   for (LoopTreeIterator iter(_phase-&gt;ltree_root()); !iter.done(); iter.next()) {
3619     IdealLoopTree* lpt = iter.current();
3620     max_depth = MAX2(max_depth, lpt-&gt;_nest);
3621   }
3622 #endif
3623 
3624   bool progress = true;
3625   int iteration = 0;
3626   Node_List dead_phis;
3627   while (progress) {
3628     progress = false;
3629     iteration++;
<a name="116" id="anc116"></a><span class="line-modified">3630     assert(iteration &lt;= 2+max_depth || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);</span>
3631     if (trace) { tty-&gt;print_cr(&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;); }
3632     IdealLoopTree* last_updated_ilt = NULL;
3633     for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3634       Node* c = rpo_list.at(i);
3635 
3636       Node* prev_mem = _memory_nodes[c-&gt;_idx];
3637       if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
3638         Node* prev_region = regions[c-&gt;_idx];
3639         Node* unique = NULL;
3640         for (uint j = 1; j &lt; c-&gt;req() &amp;&amp; unique != NodeSentinel; j++) {
3641           Node* m = _memory_nodes[c-&gt;in(j)-&gt;_idx];
3642           assert(m != NULL || (c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl &amp;&amp; iteration == 1) || _phase-&gt;C-&gt;has_irreducible_loop() || has_never_branch(_phase-&gt;C-&gt;root()), &quot;expect memory state&quot;);
3643           if (m != NULL) {
3644             if (m == prev_region &amp;&amp; ((c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl) || (prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c))) {
3645               assert(c-&gt;is_Loop() &amp;&amp; j == LoopNode::LoopBackControl || _phase-&gt;C-&gt;has_irreducible_loop(), &quot;&quot;);
3646               // continue
3647             } else if (unique == NULL) {
3648               unique = m;
3649             } else if (m == unique) {
3650               // continue
3651             } else {
3652               unique = NodeSentinel;
3653             }
3654           }
3655         }
3656         assert(unique != NULL, &quot;empty phi???&quot;);
3657         if (unique != NodeSentinel) {
3658           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c) {
3659             dead_phis.push(prev_region);
3660           }
3661           regions.map(c-&gt;_idx, unique);
3662         } else {
3663           Node* phi = NULL;
3664           if (prev_region != NULL &amp;&amp; prev_region-&gt;is_Phi() &amp;&amp; prev_region-&gt;in(0) == c &amp;&amp; prev_region-&gt;_idx &gt;= last) {
3665             phi = prev_region;
3666             for (uint k = 1; k &lt; c-&gt;req(); k++) {
3667               Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
3668               assert(m != NULL, &quot;expect memory state&quot;);
3669               phi-&gt;set_req(k, m);
3670             }
3671           } else {
3672             for (DUIterator_Fast jmax, j = c-&gt;fast_outs(jmax); j &lt; jmax &amp;&amp; phi == NULL; j++) {
3673               Node* u = c-&gt;fast_out(j);
3674               if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
3675                   (u-&gt;adr_type() == TypePtr::BOTTOM || _phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias)) {
3676                 phi = u;
3677                 for (uint k = 1; k &lt; c-&gt;req() &amp;&amp; phi != NULL; k++) {
3678                   Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
3679                   assert(m != NULL, &quot;expect memory state&quot;);
3680                   if (u-&gt;in(k) != m) {
3681                     phi = NULL;
3682                   }
3683                 }
3684               }
3685             }
3686             if (phi == NULL) {
3687               phi = new PhiNode(c, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
3688               for (uint k = 1; k &lt; c-&gt;req(); k++) {
3689                 Node* m = _memory_nodes[c-&gt;in(k)-&gt;_idx];
3690                 assert(m != NULL, &quot;expect memory state&quot;);
3691                 phi-&gt;init_req(k, m);
3692               }
3693             }
3694           }
3695           assert(phi != NULL, &quot;&quot;);
3696           regions.map(c-&gt;_idx, phi);
3697         }
3698         Node* current_region = regions[c-&gt;_idx];
3699         if (current_region != prev_region) {
3700           progress = true;
3701           if (prev_region == prev_mem) {
3702             _memory_nodes.map(c-&gt;_idx, current_region);
3703           }
3704         }
3705       } else if (prev_mem == NULL || prev_mem-&gt;is_Phi() || ctrl_or_self(prev_mem) != c) {
3706         Node* m = _memory_nodes[_phase-&gt;idom(c)-&gt;_idx];
3707         assert(m != NULL, &quot;expect memory state&quot;);
3708         if (m != prev_mem) {
3709           _memory_nodes.map(c-&gt;_idx, m);
3710           progress = true;
3711         }
3712       }
3713 #ifdef ASSERT
3714       if (trace) { tty-&gt;print(&quot;X %d&quot;, c-&gt;_idx);  _memory_nodes[c-&gt;_idx]-&gt;dump(); }
3715 #endif
3716     }
3717   }
3718 
3719   // Replace existing phi with computed memory state for that region
3720   // if different (could be a new phi or a dominating memory node if
3721   // that phi was found to be useless).
3722   while (dead_phis.size() &gt; 0) {
3723     Node* n = dead_phis.pop();
3724     n-&gt;replace_by(_phase-&gt;C-&gt;top());
3725     n-&gt;destruct();
3726   }
3727   for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3728     Node* c = rpo_list.at(i);
3729     if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
3730       Node* n = regions[c-&gt;_idx];
3731       if (n-&gt;is_Phi() &amp;&amp; n-&gt;_idx &gt;= last &amp;&amp; n-&gt;in(0) == c) {
3732         _phase-&gt;register_new_node(n, c);
3733       }
3734     }
3735   }
3736   for (int i = rpo_list.size() - 1; i &gt;= 0; i--) {
3737     Node* c = rpo_list.at(i);
3738     if (c-&gt;is_Region() &amp;&amp; (_include_lsm || !c-&gt;is_OuterStripMinedLoop())) {
3739       Node* n = regions[c-&gt;_idx];
3740       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax; i++) {
3741         Node* u = c-&gt;fast_out(i);
3742         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;
3743             u != n) {
3744           if (u-&gt;adr_type() == TypePtr::BOTTOM) {
3745             fix_memory_uses(u, n, n, c);
3746           } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
3747             _phase-&gt;lazy_replace(u, n);
3748             --i; --imax;
3749           }
3750         }
3751       }
3752     }
3753   }
3754 }
3755 
3756 Node* MemoryGraphFixer::get_ctrl(Node* n) const {
3757   Node* c = _phase-&gt;get_ctrl(n);
3758   if (n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_Call()) {
3759     assert(c == n-&gt;in(0), &quot;&quot;);
3760     CallNode* call = c-&gt;as_Call();
3761     CallProjections projs;
3762     call-&gt;extract_projections(&amp;projs, true, false);
3763     if (projs.catchall_memproj != NULL) {
3764       if (projs.fallthrough_memproj == n) {
3765         c = projs.fallthrough_catchproj;
3766       } else {
3767         assert(projs.catchall_memproj == n, &quot;&quot;);
3768         c = projs.catchall_catchproj;
3769       }
3770     }
3771   }
3772   return c;
3773 }
3774 
3775 Node* MemoryGraphFixer::ctrl_or_self(Node* n) const {
3776   if (_phase-&gt;has_ctrl(n))
3777     return get_ctrl(n);
3778   else {
3779     assert (n-&gt;is_CFG(), &quot;must be a CFG node&quot;);
3780     return n;
3781   }
3782 }
3783 
3784 bool MemoryGraphFixer::mem_is_valid(Node* m, Node* c) const {
3785   return m != NULL &amp;&amp; get_ctrl(m) == c;
3786 }
3787 
3788 Node* MemoryGraphFixer::find_mem(Node* ctrl, Node* n) const {
3789   assert(n == NULL || _phase-&gt;ctrl_or_self(n) == ctrl, &quot;&quot;);
3790   Node* mem = _memory_nodes[ctrl-&gt;_idx];
3791   Node* c = ctrl;
3792   while (!mem_is_valid(mem, c) &amp;&amp;
3793          (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem))) {
3794     c = _phase-&gt;idom(c);
3795     mem = _memory_nodes[c-&gt;_idx];
3796   }
3797   if (n != NULL &amp;&amp; mem_is_valid(mem, c)) {
<a name="117" id="anc117"></a><span class="line-modified">3798     while (!ShenandoahWriteBarrierNode::is_dominator_same_ctrl(c, mem, n, _phase) &amp;&amp; _phase-&gt;ctrl_or_self(mem) == ctrl) {</span>
3799       mem = next_mem(mem, _alias);
3800     }
3801     if (mem-&gt;is_MergeMem()) {
3802       mem = mem-&gt;as_MergeMem()-&gt;memory_at(_alias);
3803     }
3804     if (!mem_is_valid(mem, c)) {
3805       do {
3806         c = _phase-&gt;idom(c);
3807         mem = _memory_nodes[c-&gt;_idx];
3808       } while (!mem_is_valid(mem, c) &amp;&amp;
3809                (!c-&gt;is_CatchProj() || mem == NULL || c-&gt;in(0)-&gt;in(0)-&gt;in(0) != get_ctrl(mem)));
3810     }
3811   }
3812   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
3813   return mem;
3814 }
3815 
3816 bool MemoryGraphFixer::has_mem_phi(Node* region) const {
3817   for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
3818     Node* use = region-&gt;fast_out(i);
3819     if (use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY &amp;&amp;
3820         (_phase-&gt;C-&gt;get_alias_index(use-&gt;adr_type()) == _alias)) {
3821       return true;
3822     }
3823   }
3824   return false;
3825 }
3826 
3827 void MemoryGraphFixer::fix_mem(Node* ctrl, Node* new_ctrl, Node* mem, Node* mem_for_ctrl, Node* new_mem, Unique_Node_List&amp; uses) {
3828   assert(_phase-&gt;ctrl_or_self(new_mem) == new_ctrl, &quot;&quot;);
3829   const bool trace = false;
3830   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ control is&quot;); ctrl-&gt;dump(); });
3831   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ mem is&quot;); mem-&gt;dump(); });
3832   GrowableArray&lt;Node*&gt; phis;
3833   if (mem_for_ctrl != mem) {
3834     Node* old = mem_for_ctrl;
3835     Node* prev = NULL;
3836     while (old != mem) {
3837       prev = old;
3838       if (old-&gt;is_Store() || old-&gt;is_ClearArray() || old-&gt;is_LoadStore()) {
3839         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3840         old = old-&gt;in(MemNode::Memory);
3841       } else if (old-&gt;Opcode() == Op_SCMemProj) {
3842         assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3843         old = old-&gt;in(0);
<a name="118" id="anc118"></a><span class="line-removed">3844       } else if (old-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-removed">3845         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3846         old = old-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed">3847       } else if (old-&gt;Opcode() == Op_ShenandoahWriteBarrier) {</span>
<span class="line-removed">3848         assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3849         old = old-&gt;in(ShenandoahBarrierNode::Memory);</span>
3850       } else {
3851         ShouldNotReachHere();
3852       }
3853     }
3854     assert(prev != NULL, &quot;&quot;);
3855     if (new_ctrl != ctrl) {
3856       _memory_nodes.map(ctrl-&gt;_idx, mem);
3857       _memory_nodes.map(new_ctrl-&gt;_idx, mem_for_ctrl);
3858     }
<a name="119" id="anc119"></a><span class="line-modified">3859     uint input = prev-&gt;Opcode() == Op_ShenandoahWriteBarrier ? (uint)ShenandoahBarrierNode::Memory : (uint)MemNode::Memory;</span>
3860     _phase-&gt;igvn().replace_input_of(prev, input, new_mem);
3861   } else {
3862     uses.clear();
3863     _memory_nodes.map(new_ctrl-&gt;_idx, new_mem);
3864     uses.push(new_ctrl);
3865     for(uint next = 0; next &lt; uses.size(); next++ ) {
3866       Node *n = uses.at(next);
3867       assert(n-&gt;is_CFG(), &quot;&quot;);
3868       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ ctrl&quot;); n-&gt;dump(); });
3869       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3870         Node* u = n-&gt;fast_out(i);
3871         if (!u-&gt;is_Root() &amp;&amp; u-&gt;is_CFG() &amp;&amp; u != n) {
3872           Node* m = _memory_nodes[u-&gt;_idx];
3873           if (u-&gt;is_Region() &amp;&amp; (!u-&gt;is_OuterStripMinedLoop() || _include_lsm) &amp;&amp;
3874               !has_mem_phi(u) &amp;&amp;
3875               u-&gt;unique_ctrl_out()-&gt;Opcode() != Op_Halt) {
3876             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ region&quot;); u-&gt;dump(); });
3877             DEBUG_ONLY(if (trace &amp;&amp; m != NULL) { tty-&gt;print(&quot;ZZZ mem&quot;); m-&gt;dump(); });
3878 
3879             if (!mem_is_valid(m, u) || !m-&gt;is_Phi()) {
3880               bool push = true;
3881               bool create_phi = true;
3882               if (_phase-&gt;is_dominator(new_ctrl, u)) {
3883                 create_phi = false;
3884               } else if (!_phase-&gt;C-&gt;has_irreducible_loop()) {
3885                 IdealLoopTree* loop = _phase-&gt;get_loop(ctrl);
3886                 bool do_check = true;
3887                 IdealLoopTree* l = loop;
3888                 create_phi = false;
3889                 while (l != _phase-&gt;ltree_root()) {
<a name="120" id="anc120"></a><span class="line-modified">3890                   if (_phase-&gt;is_dominator(l-&gt;_head, u) &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), l-&gt;_head)) {</span>




3891                     create_phi = true;
3892                     do_check = false;
3893                     break;
3894                   }
3895                   l = l-&gt;_parent;
3896                 }
3897 
3898                 if (do_check) {
3899                   assert(!create_phi, &quot;&quot;);
3900                   IdealLoopTree* u_loop = _phase-&gt;get_loop(u);
3901                   if (u_loop != _phase-&gt;ltree_root() &amp;&amp; u_loop-&gt;is_member(loop)) {
3902                     Node* c = ctrl;
3903                     while (!_phase-&gt;is_dominator(c, u_loop-&gt;tail())) {
3904                       c = _phase-&gt;idom(c);
3905                     }
3906                     if (!_phase-&gt;is_dominator(c, u)) {
3907                       do_check = false;
3908                     }
3909                   }
3910                 }
3911 
3912                 if (do_check &amp;&amp; _phase-&gt;is_dominator(_phase-&gt;idom(u), new_ctrl)) {
3913                   create_phi = true;
3914                 }
3915               }
3916               if (create_phi) {
3917                 Node* phi = new PhiNode(u, Type::MEMORY, _phase-&gt;C-&gt;get_adr_type(_alias));
3918                 _phase-&gt;register_new_node(phi, u);
3919                 phis.push(phi);
3920                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ new phi&quot;); phi-&gt;dump(); });
3921                 if (!mem_is_valid(m, u)) {
3922                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting mem&quot;); phi-&gt;dump(); });
3923                   _memory_nodes.map(u-&gt;_idx, phi);
3924                 } else {
3925                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ NOT setting mem&quot;); m-&gt;dump(); });
3926                   for (;;) {
<a name="121" id="anc121"></a><span class="line-modified">3927                     assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;is_Proj() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier || m-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
3928                     Node* next = NULL;
3929                     if (m-&gt;is_Proj()) {
3930                       next = m-&gt;in(0);
<a name="122" id="anc122"></a><span class="line-modified">3931                     } else if (m-&gt;Opcode() == Op_ShenandoahWBMemProj) {</span>
<span class="line-modified">3932                       next = m-&gt;in(ShenandoahWBMemProjNode::WriteBarrier);</span>
<span class="line-removed">3933                     } else if (m-&gt;is_Mem() || m-&gt;is_LoadStore()) {</span>
3934                       assert(_alias == Compile::AliasIdxRaw, &quot;&quot;);
3935                       next = m-&gt;in(MemNode::Memory);
<a name="123" id="anc123"></a><span class="line-removed">3936                     } else {</span>
<span class="line-removed">3937                       assert(_alias != Compile::AliasIdxRaw, &quot;&quot;);</span>
<span class="line-removed">3938                       assert (m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="line-removed">3939                       next = m-&gt;in(ShenandoahBarrierNode::Memory);</span>
3940                     }
3941                     if (_phase-&gt;get_ctrl(next) != u) {
3942                       break;
3943                     }
3944                     if (next-&gt;is_MergeMem()) {
3945                       assert(_phase-&gt;get_ctrl(next-&gt;as_MergeMem()-&gt;memory_at(_alias)) != u, &quot;&quot;);
3946                       break;
3947                     }
3948                     if (next-&gt;is_Phi()) {
3949                       assert(next-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; next-&gt;in(0) == u, &quot;&quot;);
3950                       break;
3951                     }
3952                     m = next;
3953                   }
3954 
3955                   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting to phi&quot;); m-&gt;dump(); });
<a name="124" id="anc124"></a><span class="line-modified">3956                   assert(m-&gt;is_Mem() || m-&gt;is_LoadStore() || m-&gt;Opcode() == Op_ShenandoahWriteBarrier, &quot;&quot;);</span>
<span class="line-modified">3957                   uint input = (m-&gt;is_Mem() || m-&gt;is_LoadStore()) ? (uint)MemNode::Memory : (uint)ShenandoahBarrierNode::Memory;</span>
3958                   _phase-&gt;igvn().replace_input_of(m, input, phi);
3959                   push = false;
3960                 }
3961               } else {
3962                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ skipping region&quot;); u-&gt;dump(); });
3963               }
3964               if (push) {
3965                 uses.push(u);
3966               }
3967             }
3968           } else if (!mem_is_valid(m, u) &amp;&amp;
3969                      !(u-&gt;Opcode() == Op_CProj &amp;&amp; u-&gt;in(0)-&gt;Opcode() == Op_NeverBranch &amp;&amp; u-&gt;as_Proj()-&gt;_con == 1)) {
3970             uses.push(u);
3971           }
3972         }
3973       }
3974     }
3975     for (int i = 0; i &lt; phis.length(); i++) {
3976       Node* n = phis.at(i);
3977       Node* r = n-&gt;in(0);
3978       DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi&quot;); n-&gt;dump(); });
3979       for (uint j = 1; j &lt; n-&gt;req(); j++) {
3980         Node* m = find_mem(r-&gt;in(j), NULL);
3981         _phase-&gt;igvn().replace_input_of(n, j, m);
3982         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ fixing new phi: %d&quot;, j); m-&gt;dump(); });
3983       }
3984     }
3985   }
3986   uint last = _phase-&gt;C-&gt;unique();
3987   MergeMemNode* mm = NULL;
3988   int alias = _alias;
3989   DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ raw mem is&quot;); mem-&gt;dump(); });
<a name="125" id="anc125"></a>













3990   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
3991     Node* u = mem-&gt;out(i);
3992     if (u-&gt;_idx &lt; last) {
3993       if (u-&gt;is_Mem()) {
3994         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
3995           Node* m = find_mem(_phase-&gt;get_ctrl(u), u);
3996           if (m != mem) {
3997             DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
3998             _phase-&gt;igvn().replace_input_of(u, MemNode::Memory, m);
3999             --i;
4000           }
4001         }
4002       } else if (u-&gt;is_MergeMem()) {
4003         MergeMemNode* u_mm = u-&gt;as_MergeMem();
4004         if (u_mm-&gt;memory_at(alias) == mem) {
4005           MergeMemNode* newmm = NULL;
4006           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4007             Node* uu = u-&gt;fast_out(j);
4008             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
4009             if (uu-&gt;is_Phi()) {
4010               assert(uu-&gt;adr_type() == TypePtr::BOTTOM, &quot;&quot;);
4011               Node* region = uu-&gt;in(0);
4012               int nb = 0;
4013               for (uint k = 1; k &lt; uu-&gt;req(); k++) {
4014                 if (uu-&gt;in(k) == u) {
4015                   Node* m = find_mem(region-&gt;in(k), NULL);
4016                   if (m != mem) {
4017                     DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of phi %d&quot;, k); uu-&gt;dump(); });
4018                     newmm = clone_merge_mem(u, mem, m, _phase-&gt;ctrl_or_self(m), i);
4019                     if (newmm != u) {
4020                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
4021                       nb++;
4022                       --jmax;
4023                     }
4024                   }
4025                 }
4026               }
4027               if (nb &gt; 0) {
4028                 --j;
4029               }
4030             } else {
4031               Node* m = find_mem(_phase-&gt;ctrl_or_self(uu), uu);
4032               if (m != mem) {
4033                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); uu-&gt;dump(); });
4034                 newmm = clone_merge_mem(u, mem, m, _phase-&gt;ctrl_or_self(m), i);
4035                 if (newmm != u) {
4036                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
4037                   --j, --jmax;
4038                 }
4039               }
4040             }
4041           }
4042         }
4043       } else if (u-&gt;is_Phi()) {
4044         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
4045         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias || u-&gt;adr_type() == TypePtr::BOTTOM) {
4046           Node* region = u-&gt;in(0);
4047           bool replaced = false;
4048           for (uint j = 1; j &lt; u-&gt;req(); j++) {
4049             if (u-&gt;in(j) == mem) {
4050               Node* m = find_mem(region-&gt;in(j), NULL);
4051               Node* nnew = m;
4052               if (m != mem) {
4053                 if (u-&gt;adr_type() == TypePtr::BOTTOM) {
4054                   mm = allocate_merge_mem(mem, m, _phase-&gt;ctrl_or_self(m));
4055                   nnew = mm;
4056                 }
4057                 DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of phi %d&quot;, j); u-&gt;dump(); });
4058                 _phase-&gt;igvn().replace_input_of(u, j, nnew);
4059                 replaced = true;
4060               }
4061             }
4062           }
4063           if (replaced) {
4064             --i;
4065           }
4066         }
4067       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
4068                  u-&gt;adr_type() == NULL) {
4069         assert(u-&gt;adr_type() != NULL ||
4070                u-&gt;Opcode() == Op_Rethrow ||
4071                u-&gt;Opcode() == Op_Return ||
4072                u-&gt;Opcode() == Op_SafePoint ||
4073                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
4074                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
4075                u-&gt;Opcode() == Op_CallLeaf, &quot;&quot;);
4076         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
4077         if (m != mem) {
4078           mm = allocate_merge_mem(mem, m, _phase-&gt;get_ctrl(m));
4079           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
4080           --i;
4081         }
4082       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == alias) {
4083         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
4084         if (m != mem) {
4085           DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
4086           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), m);
4087           --i;
4088         }
4089       } else if (u-&gt;adr_type() != TypePtr::BOTTOM &amp;&amp;
4090                  _memory_nodes[_phase-&gt;ctrl_or_self(u)-&gt;_idx] == u) {
4091         Node* m = find_mem(_phase-&gt;ctrl_or_self(u), u);
4092         assert(m != mem, &quot;&quot;);
4093         // u is on the wrong slice...
4094         assert(u-&gt;is_ClearArray(), &quot;&quot;);
4095         DEBUG_ONLY(if (trace) { tty-&gt;print(&quot;ZZZ setting memory of use&quot;); u-&gt;dump(); });
4096         _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), m);
4097         --i;
4098       }
4099     }
4100   }
4101 #ifdef ASSERT
4102   assert(new_mem-&gt;outcnt() &gt; 0, &quot;&quot;);
4103   for (int i = 0; i &lt; phis.length(); i++) {
4104     Node* n = phis.at(i);
4105     assert(n-&gt;outcnt() &gt; 0, &quot;new phi must have uses now&quot;);
4106   }
4107 #endif
4108 }
4109 
4110 MergeMemNode* MemoryGraphFixer::allocate_merge_mem(Node* mem, Node* rep_proj, Node* rep_ctrl) const {
4111   MergeMemNode* mm = MergeMemNode::make(mem);
4112   mm-&gt;set_memory_at(_alias, rep_proj);
4113   _phase-&gt;register_new_node(mm, rep_ctrl);
4114   return mm;
4115 }
4116 
4117 MergeMemNode* MemoryGraphFixer::clone_merge_mem(Node* u, Node* mem, Node* rep_proj, Node* rep_ctrl, DUIterator&amp; i) const {
4118   MergeMemNode* newmm = NULL;
4119   MergeMemNode* u_mm = u-&gt;as_MergeMem();
4120   Node* c = _phase-&gt;get_ctrl(u);
4121   if (_phase-&gt;is_dominator(c, rep_ctrl)) {
4122     c = rep_ctrl;
4123   } else {
4124     assert(_phase-&gt;is_dominator(rep_ctrl, c), &quot;one must dominate the other&quot;);
4125   }
4126   if (u-&gt;outcnt() == 1) {
4127     if (u-&gt;req() &gt; (uint)_alias &amp;&amp; u-&gt;in(_alias) == mem) {
4128       _phase-&gt;igvn().replace_input_of(u, _alias, rep_proj);
4129       --i;
4130     } else {
4131       _phase-&gt;igvn().rehash_node_delayed(u);
4132       u_mm-&gt;set_memory_at(_alias, rep_proj);
4133     }
4134     newmm = u_mm;
4135     _phase-&gt;set_ctrl_and_loop(u, c);
4136   } else {
4137     // can&#39;t simply clone u and then change one of its input because
4138     // it adds and then removes an edge which messes with the
4139     // DUIterator
4140     newmm = MergeMemNode::make(u_mm-&gt;base_memory());
4141     for (uint j = 0; j &lt; u-&gt;req(); j++) {
4142       if (j &lt; newmm-&gt;req()) {
4143         if (j == (uint)_alias) {
4144           newmm-&gt;set_req(j, rep_proj);
4145         } else if (newmm-&gt;in(j) != u-&gt;in(j)) {
4146           newmm-&gt;set_req(j, u-&gt;in(j));
4147         }
4148       } else if (j == (uint)_alias) {
4149         newmm-&gt;add_req(rep_proj);
4150       } else {
4151         newmm-&gt;add_req(u-&gt;in(j));
4152       }
4153     }
4154     if ((uint)_alias &gt;= u-&gt;req()) {
4155       newmm-&gt;set_memory_at(_alias, rep_proj);
4156     }
4157     _phase-&gt;register_new_node(newmm, c);
4158   }
4159   return newmm;
4160 }
4161 
4162 bool MemoryGraphFixer::should_process_phi(Node* phi) const {
4163   if (phi-&gt;adr_type() == TypePtr::BOTTOM) {
4164     Node* region = phi-&gt;in(0);
4165     for (DUIterator_Fast jmax, j = region-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4166       Node* uu = region-&gt;fast_out(j);
4167       if (uu-&gt;is_Phi() &amp;&amp; uu != phi &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY &amp;&amp; _phase-&gt;C-&gt;get_alias_index(uu-&gt;adr_type()) == _alias) {
4168         return false;
4169       }
4170     }
4171     return true;
4172   }
4173   return _phase-&gt;C-&gt;get_alias_index(phi-&gt;adr_type()) == _alias;
4174 }
4175 
4176 void MemoryGraphFixer::fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const {
4177   uint last = _phase-&gt; C-&gt;unique();
4178   MergeMemNode* mm = NULL;
4179   assert(mem-&gt;bottom_type() == Type::MEMORY, &quot;&quot;);
4180   for (DUIterator i = mem-&gt;outs(); mem-&gt;has_out(i); i++) {
4181     Node* u = mem-&gt;out(i);
4182     if (u != replacement &amp;&amp; u-&gt;_idx &lt; last) {
<a name="126" id="anc126"></a><span class="line-modified">4183       if (u-&gt;is_ShenandoahBarrier() &amp;&amp; _alias != Compile::AliasIdxRaw) {</span>
<span class="line-removed">4184         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="line-removed">4185           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="line-removed">4186           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="line-removed">4187           --i;</span>
<span class="line-removed">4188         }</span>
<span class="line-removed">4189       } else if (u-&gt;is_Mem()) {</span>
<span class="line-removed">4190         if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
<span class="line-removed">4191           assert(_alias == Compile::AliasIdxRaw , &quot;only raw memory can lead to a memory operation&quot;);</span>
<span class="line-removed">4192           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);</span>
<span class="line-removed">4193           assert(u-&gt;find_edge(mem) == -1, &quot;only one edge&quot;);</span>
<span class="line-removed">4194           --i;</span>
<span class="line-removed">4195         }</span>
<span class="line-removed">4196       } else if (u-&gt;is_MergeMem()) {</span>
4197         MergeMemNode* u_mm = u-&gt;as_MergeMem();
4198         if (u_mm-&gt;memory_at(_alias) == mem) {
4199           MergeMemNode* newmm = NULL;
4200           for (DUIterator_Fast jmax, j = u-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4201             Node* uu = u-&gt;fast_out(j);
4202             assert(!uu-&gt;is_MergeMem(), &quot;chain of MergeMems?&quot;);
4203             if (uu-&gt;is_Phi()) {
4204               if (should_process_phi(uu)) {
4205                 Node* region = uu-&gt;in(0);
4206                 int nb = 0;
4207                 for (uint k = 1; k &lt; uu-&gt;req(); k++) {
4208                   if (uu-&gt;in(k) == u &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(k))) {
4209                     if (newmm == NULL) {
4210                       newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
4211                     }
4212                     if (newmm != u) {
4213                       _phase-&gt;igvn().replace_input_of(uu, k, newmm);
4214                       nb++;
4215                       --jmax;
4216                     }
4217                   }
4218                 }
4219                 if (nb &gt; 0) {
4220                   --j;
4221                 }
4222               }
4223             } else {
<a name="127" id="anc127"></a><span class="line-modified">4224               if (rep_ctrl != uu &amp;&amp; ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(uu), replacement, uu, _phase)) {</span>
4225                 if (newmm == NULL) {
4226                   newmm = clone_merge_mem(u, mem, rep_proj, rep_ctrl, i);
4227                 }
4228                 if (newmm != u) {
4229                   _phase-&gt;igvn().replace_input_of(uu, uu-&gt;find_edge(u), newmm);
4230                   --j, --jmax;
4231                 }
4232               }
4233             }
4234           }
4235         }
4236       } else if (u-&gt;is_Phi()) {
4237         assert(u-&gt;bottom_type() == Type::MEMORY, &quot;what else?&quot;);
4238         Node* region = u-&gt;in(0);
4239         if (should_process_phi(u)) {
4240           bool replaced = false;
4241           for (uint j = 1; j &lt; u-&gt;req(); j++) {
4242             if (u-&gt;in(j) == mem &amp;&amp; _phase-&gt;is_dominator(rep_ctrl, region-&gt;in(j))) {
4243               Node* nnew = rep_proj;
4244               if (u-&gt;adr_type() == TypePtr::BOTTOM) {
4245                 if (mm == NULL) {
4246                   mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
4247                 }
4248                 nnew = mm;
4249               }
4250               _phase-&gt;igvn().replace_input_of(u, j, nnew);
4251               replaced = true;
4252             }
4253           }
4254           if (replaced) {
4255             --i;
4256           }
4257 
4258         }
4259       } else if ((u-&gt;adr_type() == TypePtr::BOTTOM &amp;&amp; u-&gt;Opcode() != Op_StrInflatedCopy) ||
4260                  u-&gt;adr_type() == NULL) {
4261         assert(u-&gt;adr_type() != NULL ||
4262                u-&gt;Opcode() == Op_Rethrow ||
4263                u-&gt;Opcode() == Op_Return ||
4264                u-&gt;Opcode() == Op_SafePoint ||
<a name="128" id="anc128"></a>

4265                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) ||
4266                (u-&gt;is_CallStaticJava() &amp;&amp; u-&gt;as_CallStaticJava()-&gt;_entry_point == OptoRuntime::rethrow_stub()) ||
<a name="129" id="anc129"></a><span class="line-modified">4267                u-&gt;Opcode() == Op_CallLeaf, &quot;&quot;);</span>
<span class="line-modified">4268         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
4269           if (mm == NULL) {
4270             mm = allocate_merge_mem(mem, rep_proj, rep_ctrl);
4271           }
4272           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), mm);
4273           --i;
4274         }
4275       } else if (_phase-&gt;C-&gt;get_alias_index(u-&gt;adr_type()) == _alias) {
<a name="130" id="anc130"></a><span class="line-modified">4276         if (ShenandoahWriteBarrierNode::is_dominator(rep_ctrl, _phase-&gt;ctrl_or_self(u), replacement, u, _phase)) {</span>
4277           _phase-&gt;igvn().replace_input_of(u, u-&gt;find_edge(mem), rep_proj);
4278           --i;
4279         }
4280       }
4281     }
4282   }
4283 }
4284 
<a name="131" id="anc131"></a><span class="line-modified">4285 void MemoryGraphFixer::remove(Node* n) {</span>
<span class="line-modified">4286   assert(n-&gt;Opcode() == Op_ShenandoahWBMemProj, &quot;&quot;);</span>
<span class="line-modified">4287   Node* c = _phase-&gt;get_ctrl(n);</span>
<span class="line-modified">4288   Node* mem = find_mem(c, NULL);</span>
<span class="line-modified">4289   if (mem == n) {</span>
<span class="line-modified">4290     _memory_nodes.map(c-&gt;_idx, mem-&gt;in(ShenandoahWBMemProjNode::WriteBarrier)-&gt;in(ShenandoahBarrierNode::Memory));</span>




























































































































































































































































































































4291   }
<a name="132" id="anc132"></a>
4292 }
<a name="133" id="anc133"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="133" type="hidden" />
</body>
</html>
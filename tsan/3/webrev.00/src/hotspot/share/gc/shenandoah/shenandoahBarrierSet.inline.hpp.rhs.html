<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
 27 
 28 #include &quot;gc/shared/barrierSet.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 29 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;</span>
 30 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 31 #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;</span>
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 34 #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;</span>
<span class="line-modified"> 35 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;</span>
<span class="line-modified"> 36 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;</span>
<span class="line-modified"> 37 #include &quot;memory/iterator.inline.hpp&quot;</span>
<span class="line-modified"> 38 #include &quot;oops/oop.inline.hpp&quot;</span>

 39 
 40 inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {
<a name="5" id="anc5"></a><span class="line-modified"> 41   return ShenandoahForwarding::get_forwardee(p);</span>
 42 }
 43 
 44 inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {
<a name="6" id="anc6"></a><span class="line-modified"> 45   if (p != NULL) {</span>
 46     return resolve_forwarded_not_null(p);
 47   } else {
 48     return p;
 49   }
 50 }
 51 
<a name="7" id="anc7"></a><span class="line-modified"> 52 inline void ShenandoahBarrierSet::enqueue(oop obj) {</span>
<span class="line-modified"> 53   shenandoah_assert_not_forwarded_if(NULL, obj, _heap-&gt;is_concurrent_traversal_in_progress());</span>
<span class="line-modified"> 54   assert(_satb_mark_queue_set.is_active(), &quot;only get here when SATB active&quot;);</span>
<span class="line-modified"> 55 </span>
<span class="line-modified"> 56   // Filter marked objects before hitting the SATB queues. The same predicate would</span>
<span class="line-modified"> 57   // be used by SATBMQ::filter to eliminate already marked objects downstream, but</span>
<span class="line-modified"> 58   // filtering here helps to avoid wasteful SATB queueing work to begin with.</span>
<span class="line-modified"> 59   if (!_heap-&gt;requires_marking&lt;false&gt;(obj)) return;</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61   ShenandoahThreadLocalData::satb_mark_queue(Thread::current()).enqueue_known_active(obj);</span>
<span class="line-modified"> 62 }</span>
<span class="line-modified"> 63 </span>
<span class="line-modified"> 64 template &lt;DecoratorSet decorators, typename T&gt;</span>
<span class="line-added"> 65 inline void ShenandoahBarrierSet::satb_barrier(T *field) {</span>
<span class="line-added"> 66   if (HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value ||</span>
<span class="line-added"> 67       HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="line-added"> 68     return;</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 71     T heap_oop = RawAccess&lt;&gt;::oop_load(field);</span>
<span class="line-added"> 72     if (!CompressedOops::is_null(heap_oop)) {</span>
<span class="line-added"> 73       enqueue(CompressedOops::decode(heap_oop));</span>
 74     }
 75   }
<a name="8" id="anc8"></a><span class="line-modified"> 76 }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 inline void ShenandoahBarrierSet::satb_enqueue(oop value) {</span>
<span class="line-added"> 79   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="line-added"> 80   if (ShenandoahSATBBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 81     enqueue(value);</span>
<span class="line-added"> 82   }</span>
<span class="line-added"> 83 }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85 inline void ShenandoahBarrierSet::storeval_barrier(oop obj) {</span>
<span class="line-added"> 86   if (obj != NULL &amp;&amp; ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-added"> 87     enqueue(obj);</span>
<span class="line-added"> 88   }</span>
<span class="line-added"> 89 }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91 inline void ShenandoahBarrierSet::keep_alive_barrier(oop value) {</span>
<span class="line-added"> 92   assert(value != NULL, &quot;checked before&quot;);</span>
<span class="line-added"> 93   if (ShenandoahKeepAliveBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-added"> 94     enqueue(value);</span>
<span class="line-added"> 95   }</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 inline void ShenandoahBarrierSet::keep_alive_if_weak(DecoratorSet decorators, oop value) {</span>
<span class="line-added"> 99   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="line-added">100   const bool on_strong_oop_ref = (decorators &amp; ON_STRONG_OOP_REF) != 0;</span>
<span class="line-added">101   const bool peek              = (decorators &amp; AS_NO_KEEPALIVE) != 0;</span>
<span class="line-added">102   if (!peek &amp;&amp; !on_strong_oop_ref) {</span>
<span class="line-added">103     keep_alive_barrier(value);</span>
<span class="line-added">104   }</span>
<span class="line-added">105 }</span>
<span class="line-added">106 </span>
<span class="line-added">107 template &lt;DecoratorSet decorators&gt;</span>
<span class="line-added">108 inline void ShenandoahBarrierSet::keep_alive_if_weak(oop value) {</span>
<span class="line-added">109   assert((decorators &amp; ON_UNKNOWN_OOP_REF) == 0, &quot;Reference strength must be known&quot;);</span>
<span class="line-added">110   if (!HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value &amp;&amp;</span>
<span class="line-added">111       !HasDecorator&lt;decorators, AS_NO_KEEPALIVE&gt;::value) {</span>
<span class="line-added">112     keep_alive_barrier(value);</span>
<span class="line-added">113   }</span>
114 }
115 
116 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
117 template &lt;typename T&gt;
<a name="9" id="anc9"></a><span class="line-modified">118 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_not_in_heap(T* addr) {</span>
<span class="line-modified">119   oop value = Raw::oop_load_not_in_heap(addr);</span>
<span class="line-modified">120   if (value != NULL) {</span>
<span class="line-modified">121     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">122     value = bs-&gt;load_reference_barrier_native(value, addr);</span>
<span class="line-added">123     if (value != NULL) {</span>
<span class="line-added">124       bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
125     }
126   }
<a name="10" id="anc10"></a><span class="line-modified">127   return value;</span>
128 }
129 
130 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
131 template &lt;typename T&gt;
<a name="11" id="anc11"></a><span class="line-modified">132 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap(T* addr) {</span>
<span class="line-modified">133   oop value = Raw::oop_load_in_heap(addr);</span>
<span class="line-modified">134   if (value != NULL) {</span>
<span class="line-modified">135     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">136     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="line-added">137     bs-&gt;keep_alive_if_weak&lt;decorators&gt;(value);</span>
138   }
<a name="12" id="anc12"></a><span class="line-modified">139   return value;</span>
<span class="line-modified">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">143 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_load_in_heap_at(oop base, ptrdiff_t offset) {</span>
<span class="line-added">144   oop value = Raw::oop_load_in_heap_at(base, offset);</span>
<span class="line-added">145   if (value != NULL) {</span>
<span class="line-added">146     ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-added">147     value = bs-&gt;load_reference_barrier_not_null(value);</span>
<span class="line-added">148     bs-&gt;keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength&lt;decorators&gt;(base, offset),</span>
<span class="line-added">149                            value);</span>
150   }
<a name="13" id="anc13"></a><span class="line-modified">151   return value;</span>
152 }
153 
<a name="14" id="anc14"></a><span class="line-added">154 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
155 template &lt;typename T&gt;
<a name="15" id="anc15"></a><span class="line-modified">156 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_not_in_heap(T* addr, oop value) {</span>
<span class="line-modified">157   shenandoah_assert_marked_if(NULL, value, !CompressedOops::is_null(value) &amp;&amp; ShenandoahHeap::heap()-&gt;is_evacuation_in_progress());</span>
<span class="line-modified">158   ShenandoahBarrierSet* const bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">159   bs-&gt;storeval_barrier(value);</span>
<span class="line-modified">160   bs-&gt;satb_barrier&lt;decorators&gt;(addr);</span>
<span class="line-modified">161   Raw::oop_store(addr, value);</span>


162 }
163 
<a name="16" id="anc16"></a><span class="line-modified">164 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">165 template &lt;typename T&gt;</span>
<span class="line-modified">166 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap(T* addr, oop value) {</span>
<span class="line-modified">167   shenandoah_assert_not_in_cset_loc_except(addr, ShenandoahHeap::heap()-&gt;cancelled_gc());</span>
<span class="line-modified">168   shenandoah_assert_not_forwarded_except  (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="line-modified">169   shenandoah_assert_not_in_cset_except    (addr, value, value == NULL || ShenandoahHeap::heap()-&gt;cancelled_gc() || !ShenandoahHeap::heap()-&gt;is_concurrent_mark_in_progress());</span>
<span class="line-modified">170 </span>
<span class="line-modified">171   oop_store_not_in_heap(addr, value);</span>

172 }
173 
<a name="17" id="anc17"></a><span class="line-modified">174 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">175 inline void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {</span>
<span class="line-modified">176   oop_store_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), value);</span>











177 }
178 
<a name="18" id="anc18"></a><span class="line-modified">179 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">180 template &lt;typename T&gt;</span>
<span class="line-modified">181 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-added">182   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-added">183   bs-&gt;storeval_barrier(new_value);</span>
184 
<a name="19" id="anc19"></a><span class="line-modified">185   oop res;</span>
<span class="line-modified">186   oop expected = compare_value;</span>
<span class="line-modified">187   do {</span>
<span class="line-modified">188     compare_value = expected;</span>
<span class="line-modified">189     res = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
<span class="line-modified">190     expected = res;</span>
<span class="line-modified">191   } while ((compare_value != expected) &amp;&amp; (resolve_forwarded(compare_value) == resolve_forwarded(expected)));</span>
<span class="line-modified">192 </span>
<span class="line-modified">193   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="line-modified">194   // because it must be the previous value.</span>
<span class="line-modified">195   if (res != NULL) {</span>
<span class="line-modified">196     res = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(res);</span>
<span class="line-modified">197     bs-&gt;satb_enqueue(res);</span>


























198   }
<a name="20" id="anc20"></a><span class="line-modified">199   return res;</span>
200 }
201 
<a name="21" id="anc21"></a><span class="line-modified">202 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">203 template &lt;typename T&gt;</span>
<span class="line-modified">204 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-modified">205   return oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);</span>
<span class="line-modified">206 }</span>






207 
<a name="22" id="anc22"></a><span class="line-modified">208 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">209 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
<span class="line-added">210   return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), compare_value, new_value);</span>
<span class="line-added">211 }</span>
212 
<a name="23" id="anc23"></a><span class="line-modified">213 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-modified">214 template &lt;typename T&gt;</span>
<span class="line-modified">215 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
<span class="line-modified">216   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">217   bs-&gt;storeval_barrier(new_value);</span>

218 
<a name="24" id="anc24"></a><span class="line-modified">219   oop previous = Raw::oop_atomic_xchg(addr, new_value);</span>


















220 
<a name="25" id="anc25"></a><span class="line-modified">221   // Note: We don&#39;t need a keep-alive-barrier here. We already enqueue any loaded reference for SATB anyway,</span>
<span class="line-modified">222   // because it must be the previous value.</span>
<span class="line-modified">223   if (previous != NULL) {</span>
<span class="line-modified">224     previous = ShenandoahBarrierSet::barrier_set()-&gt;load_reference_barrier_not_null(previous);</span>
<span class="line-added">225     bs-&gt;satb_enqueue(previous);</span>
226   }
<a name="26" id="anc26"></a><span class="line-modified">227   return previous;</span>
<span class="line-added">228 }</span>
<span class="line-added">229 </span>
<span class="line-added">230 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">231 template &lt;typename T&gt;</span>
<span class="line-added">232 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
<span class="line-added">233   return oop_atomic_xchg_not_in_heap(addr, new_value);</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
<span class="line-added">236 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;</span>
<span class="line-added">237 inline oop ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
<span class="line-added">238   return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr&lt;decorators&gt;(base, offset), new_value);</span>
239 }
240 
241 // Clone barrier support
242 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
243 void ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::clone_in_heap(oop src, oop dst, size_t size) {
<a name="27" id="anc27"></a><span class="line-modified">244   if (ShenandoahCloneBarrier) {</span>
<span class="line-modified">245     ShenandoahBarrierSet::barrier_set()-&gt;clone_barrier_runtime(src);</span>
<span class="line-added">246   }</span>
247   Raw::clone(src, dst, size);
<a name="28" id="anc28"></a>
248 }
249 
250 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
251 template &lt;typename T&gt;
252 bool ShenandoahBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
253                                                                                          arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
254                                                                                          size_t length) {
<a name="29" id="anc29"></a><span class="line-modified">255   ShenandoahBarrierSet* bs = ShenandoahBarrierSet::barrier_set();</span>
<span class="line-modified">256   bs-&gt;arraycopy_pre(arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw),</span>
<span class="line-modified">257                     arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw),</span>
<span class="line-modified">258                     length);</span>
<span class="line-modified">259   return Raw::oop_arraycopy_in_heap(src_obj, src_offset_in_bytes, src_raw, dst_obj, dst_offset_in_bytes, dst_raw, length);</span>
<span class="line-modified">260 }</span>
<span class="line-added">261 </span>
<span class="line-added">262 template &lt;class T, bool HAS_FWD, bool EVAC, bool ENQUEUE&gt;</span>
<span class="line-added">263 void ShenandoahBarrierSet::arraycopy_work(T* src, size_t count) {</span>
<span class="line-added">264   Thread* thread = Thread::current();</span>
<span class="line-added">265   SATBMarkQueue&amp; queue = ShenandoahThreadLocalData::satb_mark_queue(thread);</span>
<span class="line-added">266   ShenandoahMarkingContext* ctx = _heap-&gt;marking_context();</span>
<span class="line-added">267   const ShenandoahCollectionSet* const cset = _heap-&gt;collection_set();</span>
<span class="line-added">268   T* end = src + count;</span>
<span class="line-added">269   for (T* elem_ptr = src; elem_ptr &lt; end; elem_ptr++) {</span>
<span class="line-added">270     T o = RawAccess&lt;&gt;::oop_load(elem_ptr);</span>
<span class="line-added">271     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added">272       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added">273       if (HAS_FWD &amp;&amp; cset-&gt;is_in(obj)) {</span>
<span class="line-added">274         assert(_heap-&gt;has_forwarded_objects(), &quot;only get here with forwarded objects&quot;);</span>
<span class="line-added">275         oop fwd = resolve_forwarded_not_null(obj);</span>
<span class="line-added">276         if (EVAC &amp;&amp; obj == fwd) {</span>
<span class="line-added">277           fwd = _heap-&gt;evacuate_object(obj, thread);</span>
<span class="line-added">278         }</span>
<span class="line-added">279         assert(obj != fwd || _heap-&gt;cancelled_gc(), &quot;must be forwarded&quot;);</span>
<span class="line-added">280         oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);</span>
<span class="line-added">281         obj = fwd;</span>
<span class="line-added">282       }</span>
<span class="line-added">283       if (ENQUEUE &amp;&amp; !ctx-&gt;is_marked(obj)) {</span>
<span class="line-added">284         queue.enqueue_known_active(obj);</span>
<span class="line-added">285       }</span>
<span class="line-added">286     }</span>
287   }
<a name="30" id="anc30"></a><span class="line-added">288 }</span>
289 
<a name="31" id="anc31"></a><span class="line-modified">290 template &lt;class T&gt;</span>
<span class="line-modified">291 void ShenandoahBarrierSet::arraycopy_pre_work(T* src, T* dst, size_t count) {</span>
<span class="line-modified">292   if (_heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-modified">293     if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">294       arraycopy_work&lt;T, true, false, true&gt;(dst, count);</span>




295     } else {
<a name="32" id="anc32"></a><span class="line-modified">296       arraycopy_work&lt;T, false, false, true&gt;(dst, count);</span>

297     }
<a name="33" id="anc33"></a>


298   }
299 
<a name="34" id="anc34"></a><span class="line-modified">300   arraycopy_update_impl(src, count);</span>
<span class="line-modified">301 }</span>
<span class="line-modified">302 </span>
<span class="line-added">303 void ShenandoahBarrierSet::arraycopy_pre(oop* src, oop* dst, size_t count) {</span>
<span class="line-added">304   arraycopy_pre_work(src, dst, count);</span>
<span class="line-added">305 }</span>
<span class="line-added">306 </span>
<span class="line-added">307 void ShenandoahBarrierSet::arraycopy_pre(narrowOop* src, narrowOop* dst, size_t count) {</span>
<span class="line-added">308   arraycopy_pre_work(src, dst, count);</span>
<span class="line-added">309 }</span>
<span class="line-added">310 </span>
<span class="line-added">311 template &lt;class T&gt;</span>
<span class="line-added">312 void ShenandoahBarrierSet::arraycopy_update_impl(T* src, size_t count) {</span>
<span class="line-added">313   if (_heap-&gt;is_evacuation_in_progress()) {</span>
<span class="line-added">314     ShenandoahEvacOOMScope oom_evac;</span>
<span class="line-added">315     arraycopy_work&lt;T, true, true, false&gt;(src, count);</span>
<span class="line-added">316   } else if (_heap-&gt;is_concurrent_traversal_in_progress()){</span>
<span class="line-added">317     ShenandoahEvacOOMScope oom_evac;</span>
<span class="line-added">318     arraycopy_work&lt;T, true, true, true&gt;(src, count);</span>
<span class="line-added">319   } else if (_heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added">320     arraycopy_work&lt;T, true, false, false&gt;(src, count);</span>
321   }
<a name="35" id="anc35"></a><span class="line-added">322 }</span>
323 
<a name="36" id="anc36"></a><span class="line-modified">324 void ShenandoahBarrierSet::arraycopy_update(oop* src, size_t count) {</span>
<span class="line-modified">325   arraycopy_update_impl(src, count);</span>
<span class="line-added">326 }</span>
327 
<a name="37" id="anc37"></a><span class="line-modified">328 void ShenandoahBarrierSet::arraycopy_update(narrowOop* src, size_t count) {</span>
<span class="line-modified">329   arraycopy_update_impl(src, count);</span>

330 }
331 
332 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHBARRIERSET_INLINE_HPP
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
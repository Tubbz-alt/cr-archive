<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../heuristics/shenandoahAdaptiveHeuristics.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
 25 #define SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
 26 
<span class="line-removed"> 27 #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;opto/addnode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;opto/machnode.hpp&quot;
 32 #include &quot;opto/memnode.hpp&quot;
 33 #include &quot;opto/multnode.hpp&quot;
 34 #include &quot;opto/node.hpp&quot;
 35 
 36 class PhaseGVN;
 37 class MemoryGraphFixer;
 38 
<span class="line-modified"> 39 class ShenandoahBarrierNode : public TypeNode {</span>
 40 private:
<span class="line-removed"> 41   bool _allow_fromspace;</span>
<span class="line-removed"> 42 </span>
 43 #ifdef ASSERT
 44   enum verify_type {
 45     ShenandoahLoad,
 46     ShenandoahStore,
 47     ShenandoahValue,
 48     ShenandoahOopStore,
<span class="line-modified"> 49     ShenandoahNone,</span>
 50   };
 51 
 52   static bool verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used);
<span class="line-removed"> 53 #endif</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55 public:</span>
<span class="line-removed"> 56   enum { Control,</span>
<span class="line-removed"> 57          Memory,</span>
<span class="line-removed"> 58          ValueIn</span>
<span class="line-removed"> 59   };</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61   ShenandoahBarrierNode(Node* ctrl, Node* mem, Node* obj, bool allow_fromspace)</span>
<span class="line-removed"> 62     : TypeNode(obj-&gt;bottom_type()-&gt;isa_oopptr() ? obj-&gt;bottom_type()-&gt;is_oopptr()-&gt;cast_to_nonconst() : obj-&gt;bottom_type(), 3),</span>
<span class="line-removed"> 63       _allow_fromspace(allow_fromspace) {</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65     init_req(Control, ctrl);</span>
<span class="line-removed"> 66     init_req(Memory, mem);</span>
<span class="line-removed"> 67     init_req(ValueIn, obj);</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69     init_class_id(Class_ShenandoahBarrier);</span>
<span class="line-removed"> 70   }</span>
<span class="line-removed"> 71 </span>
<span class="line-removed"> 72   static Node* skip_through_barrier(Node* n);</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   static const TypeOopPtr* brooks_pointer_type(const Type* t) {</span>
<span class="line-removed"> 75     return t-&gt;is_oopptr()-&gt;cast_to_nonconst()-&gt;add_offset(ShenandoahBrooksPointer::byte_offset())-&gt;is_oopptr();</span>
<span class="line-removed"> 76   }</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78   virtual const TypePtr* adr_type() const {</span>
<span class="line-removed"> 79     if (bottom_type() == Type::TOP) {</span>
<span class="line-removed"> 80       return NULL;</span>
<span class="line-removed"> 81     }</span>
<span class="line-removed"> 82     //const TypePtr* adr_type = in(MemNode::Address)-&gt;bottom_type()-&gt;is_ptr();</span>
<span class="line-removed"> 83     const TypePtr* adr_type = brooks_pointer_type(bottom_type());</span>
<span class="line-removed"> 84     assert(adr_type-&gt;offset() == ShenandoahBrooksPointer::byte_offset(), &quot;sane offset&quot;);</span>
<span class="line-removed"> 85     assert(Compile::current()-&gt;alias_type(adr_type)-&gt;is_rewritable(), &quot;brooks ptr must be rewritable&quot;);</span>
<span class="line-removed"> 86     return adr_type;</span>
<span class="line-removed"> 87   }</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89   virtual uint  ideal_reg() const { return Op_RegP; }</span>
<span class="line-removed"> 90   virtual uint match_edge(uint idx) const {</span>
<span class="line-removed"> 91     return idx &gt;= ValueIn;</span>
<span class="line-removed"> 92   }</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94   Node* Identity_impl(PhaseGVN* phase);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96   virtual const Type* Value(PhaseGVN* phase) const;</span>
<span class="line-removed"> 97   virtual bool depends_only_on_test() const {</span>
<span class="line-removed"> 98     return true;</span>
<span class="line-removed"> 99   };</span>
<span class="line-removed">100 </span>
<span class="line-removed">101   static bool needs_barrier(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace);</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 #ifdef ASSERT</span>
104   static void report_verify_failure(const char* msg, Node* n1 = NULL, Node* n2 = NULL);
<span class="line-removed">105   static void verify(RootNode* root);</span>
106   static void verify_raw_mem(RootNode* root);
107 #endif
<span class="line-removed">108 #ifndef PRODUCT</span>
<span class="line-removed">109   virtual void dump_spec(outputStream *st) const;</span>
<span class="line-removed">110 #endif</span>
<span class="line-removed">111 </span>
<span class="line-removed">112   // protected:</span>
<span class="line-removed">113   static Node* dom_mem(Node* mem, Node*&amp; mem_ctrl, Node* n, Node* rep_ctrl, int alias, PhaseIdealLoop* phase);</span>
114   static Node* dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase);
<span class="line-removed">115   static bool is_dominator(Node *d_c, Node *n_c, Node* d, Node* n, PhaseIdealLoop* phase);</span>
<span class="line-removed">116   static bool is_dominator_same_ctrl(Node* c, Node* d, Node* n, PhaseIdealLoop* phase);</span>
117   static Node* no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase);
<span class="line-removed">118   static bool build_loop_late_post(PhaseIdealLoop* phase, Node* n);</span>
<span class="line-removed">119   bool sink_node(PhaseIdealLoop* phase, Node* ctrl, Node* n_ctrl);</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 protected:</span>
<span class="line-removed">122   uint hash() const;</span>
<span class="line-removed">123   uint cmp(const Node&amp; n) const;</span>
<span class="line-removed">124   uint size_of() const;</span>
<span class="line-removed">125 </span>
<span class="line-removed">126 private:</span>
<span class="line-removed">127   static bool needs_barrier_impl(PhaseGVN* phase, ShenandoahBarrierNode* orig, Node* n, Node* rb_mem, bool allow_fromspace, Unique_Node_List &amp;visited);</span>
<span class="line-removed">128 </span>
<span class="line-removed">129   static bool dominates_memory(PhaseGVN* phase, Node* b1, Node* b2, bool linear);</span>
<span class="line-removed">130   static bool dominates_memory_impl(PhaseGVN* phase, Node* b1, Node* b2, Node* current, bool linear);</span>
<span class="line-removed">131 };</span>
<span class="line-removed">132 </span>
<span class="line-removed">133 class ShenandoahReadBarrierNode : public ShenandoahBarrierNode {</span>
<span class="line-removed">134 public:</span>
<span class="line-removed">135   ShenandoahReadBarrierNode(Node* ctrl, Node* mem, Node* obj)</span>
<span class="line-removed">136     : ShenandoahBarrierNode(ctrl, mem, obj, true) {</span>
<span class="line-removed">137     assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier ||</span>
<span class="line-removed">138                                ShenandoahWriteBarrier || ShenandoahAcmpBarrier),</span>
<span class="line-removed">139            &quot;should be enabled&quot;);</span>
<span class="line-removed">140   }</span>
<span class="line-removed">141   ShenandoahReadBarrierNode(Node* ctrl, Node* mem, Node* obj, bool allow_fromspace)</span>
<span class="line-removed">142     : ShenandoahBarrierNode(ctrl, mem, obj, allow_fromspace) {</span>
<span class="line-removed">143     assert(UseShenandoahGC &amp;&amp; (ShenandoahReadBarrier || ShenandoahStoreValReadBarrier ||</span>
<span class="line-removed">144                                ShenandoahWriteBarrier || ShenandoahAcmpBarrier),</span>
<span class="line-removed">145            &quot;should be enabled&quot;);</span>
<span class="line-removed">146   }</span>
<span class="line-removed">147 </span>
<span class="line-removed">148   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);</span>
<span class="line-removed">149   virtual Node* Identity(PhaseGVN* phase);</span>
<span class="line-removed">150   virtual int Opcode() const;</span>
<span class="line-removed">151 </span>
<span class="line-removed">152   bool is_independent(Node* mem);</span>
<span class="line-removed">153 </span>
<span class="line-removed">154   void try_move(PhaseIdealLoop* phase);</span>
<span class="line-removed">155 </span>
<span class="line-removed">156 private:</span>
<span class="line-removed">157   static bool is_independent(const Type* in_type, const Type* this_type);</span>
<span class="line-removed">158   static bool dominates_memory_rb(PhaseGVN* phase, Node* b1, Node* b2, bool linear);</span>
<span class="line-removed">159   static bool dominates_memory_rb_impl(PhaseGVN* phase, Node* b1, Node* b2, Node* current, bool linear);</span>
<span class="line-removed">160 };</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 class ShenandoahWriteBarrierNode : public ShenandoahBarrierNode {</span>
<span class="line-removed">163 public:</span>
<span class="line-removed">164   ShenandoahWriteBarrierNode(Compile* C, Node* ctrl, Node* mem, Node* obj);</span>
<span class="line-removed">165 </span>
<span class="line-removed">166   virtual int Opcode() const;</span>
<span class="line-removed">167   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);</span>
<span class="line-removed">168   virtual Node* Identity(PhaseGVN* phase);</span>
<span class="line-removed">169   virtual bool depends_only_on_test() const { return false; }</span>
<span class="line-removed">170 </span>
<span class="line-removed">171   static bool expand(Compile* C, PhaseIterGVN&amp; igvn);</span>
<span class="line-removed">172   static bool is_gc_state_load(Node *n);</span>
173   static bool is_heap_state_test(Node* iff, int mask);
<span class="line-removed">174   static bool is_heap_stable_test(Node* iff);</span>
175   static bool try_common_gc_state_load(Node *n, PhaseIdealLoop *phase);
176   static bool has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase);
<span class="line-removed">177 </span>
<span class="line-removed">178   static LoopNode* try_move_before_pre_loop(Node* c, Node* val_ctrl, PhaseIdealLoop* phase);</span>
<span class="line-removed">179   static Node* move_above_predicates(LoopNode* cl, Node* val_ctrl, PhaseIdealLoop* phase);</span>
<span class="line-removed">180 #ifdef ASSERT</span>
<span class="line-removed">181   static bool memory_dominates_all_paths(Node* mem, Node* rep_ctrl, int alias, PhaseIdealLoop* phase);</span>
<span class="line-removed">182   static void memory_dominates_all_paths_helper(Node* c, Node* rep_ctrl, Unique_Node_List&amp; controls, PhaseIdealLoop* phase);</span>
<span class="line-removed">183 #endif</span>
<span class="line-removed">184   void try_move_before_loop(GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses);</span>
<span class="line-removed">185   void try_move_before_loop_helper(LoopNode* cl, Node* val_ctrl, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, PhaseIdealLoop* phase, bool include_lsm, Unique_Node_List&amp; uses);</span>
<span class="line-removed">186   static void pin_and_expand(PhaseIdealLoop* phase);</span>
<span class="line-removed">187   CallStaticJavaNode* pin_and_expand_null_check(PhaseIterGVN&amp; igvn);</span>
<span class="line-removed">188   void pin_and_expand_move_barrier(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt;&amp; memory_graph_fixers, Unique_Node_List&amp; uses);</span>
<span class="line-removed">189   void pin_and_expand_helper(PhaseIdealLoop* phase);</span>
190   static Node* find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase);
191   static void follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase);
192   static void test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase);
<span class="line-removed">193 </span>
194   static void test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,
195                                PhaseIdealLoop* phase);
<span class="line-modified">196   static void call_wb_stub(Node*&amp; ctrl, Node*&amp; val, Node*&amp; result_mem,</span>
<span class="line-removed">197                            Node* raw_mem, Node* wb_mem, int alias,</span>
<span class="line-removed">198                            PhaseIdealLoop* phase);</span>
199   static Node* clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase);
200   static void fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl, Unique_Node_List&amp; uses,
201                              PhaseIdealLoop* phase);
202   static void in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase);
203   static void move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase);
<span class="line-removed">204 </span>
<span class="line-removed">205   static void optimize_after_expansion(VectorSet &amp;visited, Node_Stack &amp;nstack, Node_List &amp;old_new, PhaseIdealLoop* phase);</span>
206   static void merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase);
207   static bool identical_backtoback_ifs(Node *n, PhaseIdealLoop* phase);
208   static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase);
<span class="line-removed">209 </span>
<span class="line-removed">210   static void optimize_before_expansion(PhaseIdealLoop* phase, GrowableArray&lt;MemoryGraphFixer*&gt; memory_graph_fixers, bool include_lsm);</span>
<span class="line-removed">211   Node* would_subsume(ShenandoahBarrierNode* other, PhaseIdealLoop* phase);</span>
212   static IfNode* find_unswitching_candidate(const IdealLoopTree *loop, PhaseIdealLoop* phase);
213 
<span class="line-modified">214   Node* try_split_thru_phi(PhaseIdealLoop* phase);</span>
<span class="line-removed">215 };</span>
<span class="line-removed">216 </span>
<span class="line-removed">217 class ShenandoahWBMemProjNode : public Node {</span>
218 public:
<span class="line-modified">219   enum { Control,</span>
<span class="line-modified">220          WriteBarrier };</span>
221 
<span class="line-modified">222   ShenandoahWBMemProjNode(Node *src) : Node(NULL, src) {</span>
<span class="line-modified">223     assert(UseShenandoahGC &amp;&amp; ShenandoahWriteBarrier, &quot;should be enabled&quot;);</span>
<span class="line-removed">224     assert(src-&gt;Opcode() == Op_ShenandoahWriteBarrier || src-&gt;is_Mach(), &quot;epxect wb&quot;);</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226   virtual Node* Identity(PhaseGVN* phase);</span>
227 
<span class="line-modified">228   virtual int Opcode() const;</span>
<span class="line-modified">229   virtual bool      is_CFG() const  { return false; }</span>
<span class="line-modified">230   virtual const Type *bottom_type() const {return Type::MEMORY;}</span>
<span class="line-removed">231   virtual const TypePtr *adr_type() const {</span>
<span class="line-removed">232     Node* wb = in(WriteBarrier);</span>
<span class="line-removed">233     if (wb == NULL || wb-&gt;is_top())  return NULL; // node is dead</span>
<span class="line-removed">234     assert(wb-&gt;Opcode() == Op_ShenandoahWriteBarrier || (wb-&gt;is_Mach() &amp;&amp; wb-&gt;as_Mach()-&gt;ideal_Opcode() == Op_ShenandoahWriteBarrier) || wb-&gt;is_Phi(), &quot;expect wb&quot;);</span>
<span class="line-removed">235     return ShenandoahBarrierNode::brooks_pointer_type(wb-&gt;bottom_type());</span>
<span class="line-removed">236   }</span>
237 
<span class="line-modified">238   virtual uint ideal_reg() const { return 0;} // memory projections don&#39;t have a register</span>
<span class="line-modified">239   virtual const Type *Value(PhaseGVN* phase ) const {</span>
<span class="line-removed">240     return bottom_type();</span>
<span class="line-removed">241   }</span>
<span class="line-removed">242 #ifndef PRODUCT</span>
<span class="line-removed">243   virtual void dump_spec(outputStream *st) const {};</span>
244 #endif
245 };
246 
247 class ShenandoahEnqueueBarrierNode : public Node {
248 public:
<span class="line-modified">249   ShenandoahEnqueueBarrierNode(Node* val) : Node(NULL, val) {</span>
<span class="line-removed">250   }</span>
251 
252   const Type *bottom_type() const;
253   const Type* Value(PhaseGVN* phase) const;
254   Node* Identity(PhaseGVN* phase);
255 
256   int Opcode() const;
257 
258 private:
259   enum { Needed, NotNeeded, MaybeNeeded };
260 
261   static int needed(Node* n);
262   static Node* next(Node* n);
263 };
264 
265 class MemoryGraphFixer : public ResourceObj {
266 private:
267   Node_List _memory_nodes;
268   int _alias;
269   PhaseIdealLoop* _phase;
270   bool _include_lsm;
</pre>
<hr />
<pre>
272   void collect_memory_nodes();
273   Node* get_ctrl(Node* n) const;
274   Node* ctrl_or_self(Node* n) const;
275   bool mem_is_valid(Node* m, Node* c) const;
276   MergeMemNode* allocate_merge_mem(Node* mem, Node* rep_proj, Node* rep_ctrl) const;
277   MergeMemNode* clone_merge_mem(Node* u, Node* mem, Node* rep_proj, Node* rep_ctrl, DUIterator&amp; i) const;
278   void fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const;
279   bool should_process_phi(Node* phi) const;
280   bool has_mem_phi(Node* region) const;
281 
282 public:
283   MemoryGraphFixer(int alias, bool include_lsm, PhaseIdealLoop* phase) :
284     _alias(alias), _phase(phase), _include_lsm(include_lsm) {
285     assert(_alias != Compile::AliasIdxBot, &quot;unsupported&quot;);
286     collect_memory_nodes();
287   }
288 
289   Node* find_mem(Node* ctrl, Node* n) const;
290   void fix_mem(Node* ctrl, Node* region, Node* mem, Node* mem_for_ctrl, Node* mem_phi, Unique_Node_List&amp; uses);
291   int alias() const { return _alias; }
<span class="line-removed">292   void remove(Node* n);</span>
293 };
294 
295 class ShenandoahCompareAndSwapPNode : public CompareAndSwapPNode {
296 public:
297   ShenandoahCompareAndSwapPNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord)
298     : CompareAndSwapPNode(c, mem, adr, val, ex, mem_ord) { }
299 
300   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
301     if (in(ExpectedIn) != NULL &amp;&amp; phase-&gt;type(in(ExpectedIn)) == TypePtr::NULL_PTR) {
302       return new CompareAndSwapPNode(in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), in(MemNode::ValueIn), in(ExpectedIn), order());
303     }
304     return NULL;
305   }
306 
307   virtual int Opcode() const;
308 };
309 
310 class ShenandoahCompareAndSwapNNode : public CompareAndSwapNNode {
311 public:
312   ShenandoahCompareAndSwapNNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord)
</pre>
<hr />
<pre>
365   }
366 
367   virtual int Opcode() const;
368 };
369 
370 class ShenandoahCompareAndExchangeNNode : public CompareAndExchangeNNode {
371 public:
372   ShenandoahCompareAndExchangeNNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord)
373     : CompareAndExchangeNNode(c, mem, adr, val, ex, at, t, mem_ord) { }
374 
375   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
376     if (in(ExpectedIn) != NULL &amp;&amp; phase-&gt;type(in(ExpectedIn)) == TypeNarrowOop::NULL_PTR) {
377       return new CompareAndExchangeNNode(in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), in(MemNode::ValueIn), in(ExpectedIn), adr_type(), bottom_type(), order());
378     }
379     return NULL;
380   }
381 
382   virtual int Opcode() const;
383 };
384 










































385 #endif // SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
 26 #define SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
 27 

 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;opto/addnode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;opto/machnode.hpp&quot;
 32 #include &quot;opto/memnode.hpp&quot;
 33 #include &quot;opto/multnode.hpp&quot;
 34 #include &quot;opto/node.hpp&quot;
 35 
 36 class PhaseGVN;
 37 class MemoryGraphFixer;
 38 
<span class="line-modified"> 39 class ShenandoahBarrierC2Support : public AllStatic {</span>
 40 private:


 41 #ifdef ASSERT
 42   enum verify_type {
 43     ShenandoahLoad,
 44     ShenandoahStore,
 45     ShenandoahValue,
 46     ShenandoahOopStore,
<span class="line-modified"> 47     ShenandoahNone</span>
 48   };
 49 
 50   static bool verify_helper(Node* in, Node_Stack&amp; phis, VectorSet&amp; visited, verify_type t, bool trace, Unique_Node_List&amp; barriers_used);



















































 51   static void report_verify_failure(const char* msg, Node* n1 = NULL, Node* n2 = NULL);

 52   static void verify_raw_mem(RootNode* root);
 53 #endif






 54   static Node* dom_mem(Node* mem, Node* ctrl, int alias, Node*&amp; mem_ctrl, PhaseIdealLoop* phase);


 55   static Node* no_branches(Node* c, Node* dom, bool allow_one_proj, PhaseIdealLoop* phase);























































 56   static bool is_heap_state_test(Node* iff, int mask);

 57   static bool try_common_gc_state_load(Node *n, PhaseIdealLoop *phase);
 58   static bool has_safepoint_between(Node* start, Node* stop, PhaseIdealLoop *phase);













 59   static Node* find_bottom_mem(Node* ctrl, PhaseIdealLoop* phase);
 60   static void follow_barrier_uses(Node* n, Node* ctrl, Unique_Node_List&amp; uses, PhaseIdealLoop* phase);
 61   static void test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase);

 62   static void test_heap_stable(Node*&amp; ctrl, Node* raw_mem, Node*&amp; heap_stable_ctrl,
 63                                PhaseIdealLoop* phase);
<span class="line-modified"> 64   static void call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase);</span>


 65   static Node* clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase);
 66   static void fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl, Unique_Node_List&amp; uses,
 67                              PhaseIdealLoop* phase);
 68   static void in_cset_fast_test(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase);
 69   static void move_heap_stable_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase);


 70   static void merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase);
 71   static bool identical_backtoback_ifs(Node *n, PhaseIdealLoop* phase);
 72   static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase);



 73   static IfNode* find_unswitching_candidate(const IdealLoopTree *loop, PhaseIdealLoop* phase);
 74 
<span class="line-modified"> 75   static Node* get_load_addr(PhaseIdealLoop* phase, VectorSet&amp; visited, Node* lrb);</span>



 76 public:
<span class="line-modified"> 77   static bool is_dominator(Node* d_c, Node* n_c, Node* d, Node* n, PhaseIdealLoop* phase);</span>
<span class="line-modified"> 78   static bool is_dominator_same_ctrl(Node* c, Node* d, Node* n, PhaseIdealLoop* phase);</span>
 79 
<span class="line-modified"> 80   static bool is_gc_state_load(Node* n);</span>
<span class="line-modified"> 81   static bool is_heap_stable_test(Node* iff);</span>



 82 
<span class="line-modified"> 83   static bool expand(Compile* C, PhaseIterGVN&amp; igvn);</span>
<span class="line-modified"> 84   static void pin_and_expand(PhaseIdealLoop* phase);</span>
<span class="line-modified"> 85   static void optimize_after_expansion(VectorSet&amp; visited, Node_Stack&amp; nstack, Node_List&amp; old_new, PhaseIdealLoop* phase);</span>






 86 
<span class="line-modified"> 87 #ifdef ASSERT</span>
<span class="line-modified"> 88   static void verify(RootNode* root);</span>




 89 #endif
 90 };
 91 
 92 class ShenandoahEnqueueBarrierNode : public Node {
 93 public:
<span class="line-modified"> 94   ShenandoahEnqueueBarrierNode(Node* val);</span>

 95 
 96   const Type *bottom_type() const;
 97   const Type* Value(PhaseGVN* phase) const;
 98   Node* Identity(PhaseGVN* phase);
 99 
100   int Opcode() const;
101 
102 private:
103   enum { Needed, NotNeeded, MaybeNeeded };
104 
105   static int needed(Node* n);
106   static Node* next(Node* n);
107 };
108 
109 class MemoryGraphFixer : public ResourceObj {
110 private:
111   Node_List _memory_nodes;
112   int _alias;
113   PhaseIdealLoop* _phase;
114   bool _include_lsm;
</pre>
<hr />
<pre>
116   void collect_memory_nodes();
117   Node* get_ctrl(Node* n) const;
118   Node* ctrl_or_self(Node* n) const;
119   bool mem_is_valid(Node* m, Node* c) const;
120   MergeMemNode* allocate_merge_mem(Node* mem, Node* rep_proj, Node* rep_ctrl) const;
121   MergeMemNode* clone_merge_mem(Node* u, Node* mem, Node* rep_proj, Node* rep_ctrl, DUIterator&amp; i) const;
122   void fix_memory_uses(Node* mem, Node* replacement, Node* rep_proj, Node* rep_ctrl) const;
123   bool should_process_phi(Node* phi) const;
124   bool has_mem_phi(Node* region) const;
125 
126 public:
127   MemoryGraphFixer(int alias, bool include_lsm, PhaseIdealLoop* phase) :
128     _alias(alias), _phase(phase), _include_lsm(include_lsm) {
129     assert(_alias != Compile::AliasIdxBot, &quot;unsupported&quot;);
130     collect_memory_nodes();
131   }
132 
133   Node* find_mem(Node* ctrl, Node* n) const;
134   void fix_mem(Node* ctrl, Node* region, Node* mem, Node* mem_for_ctrl, Node* mem_phi, Unique_Node_List&amp; uses);
135   int alias() const { return _alias; }

136 };
137 
138 class ShenandoahCompareAndSwapPNode : public CompareAndSwapPNode {
139 public:
140   ShenandoahCompareAndSwapPNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord)
141     : CompareAndSwapPNode(c, mem, adr, val, ex, mem_ord) { }
142 
143   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
144     if (in(ExpectedIn) != NULL &amp;&amp; phase-&gt;type(in(ExpectedIn)) == TypePtr::NULL_PTR) {
145       return new CompareAndSwapPNode(in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), in(MemNode::ValueIn), in(ExpectedIn), order());
146     }
147     return NULL;
148   }
149 
150   virtual int Opcode() const;
151 };
152 
153 class ShenandoahCompareAndSwapNNode : public CompareAndSwapNNode {
154 public:
155   ShenandoahCompareAndSwapNNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, MemNode::MemOrd mem_ord)
</pre>
<hr />
<pre>
208   }
209 
210   virtual int Opcode() const;
211 };
212 
213 class ShenandoahCompareAndExchangeNNode : public CompareAndExchangeNNode {
214 public:
215   ShenandoahCompareAndExchangeNNode(Node *c, Node *mem, Node *adr, Node *val, Node *ex, const TypePtr* at, const Type* t, MemNode::MemOrd mem_ord)
216     : CompareAndExchangeNNode(c, mem, adr, val, ex, at, t, mem_ord) { }
217 
218   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {
219     if (in(ExpectedIn) != NULL &amp;&amp; phase-&gt;type(in(ExpectedIn)) == TypeNarrowOop::NULL_PTR) {
220       return new CompareAndExchangeNNode(in(MemNode::Control), in(MemNode::Memory), in(MemNode::Address), in(MemNode::ValueIn), in(ExpectedIn), adr_type(), bottom_type(), order());
221     }
222     return NULL;
223   }
224 
225   virtual int Opcode() const;
226 };
227 
<span class="line-added">228 class ShenandoahLoadReferenceBarrierNode : public Node {</span>
<span class="line-added">229 public:</span>
<span class="line-added">230   enum {</span>
<span class="line-added">231     Control,</span>
<span class="line-added">232     ValueIn</span>
<span class="line-added">233   };</span>
<span class="line-added">234 </span>
<span class="line-added">235   enum Strength {</span>
<span class="line-added">236     NONE, STRONG</span>
<span class="line-added">237   };</span>
<span class="line-added">238 </span>
<span class="line-added">239 private:</span>
<span class="line-added">240   bool _native;</span>
<span class="line-added">241 </span>
<span class="line-added">242 public:</span>
<span class="line-added">243   ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* val, bool native);</span>
<span class="line-added">244 </span>
<span class="line-added">245   bool is_native() const;</span>
<span class="line-added">246   virtual int Opcode() const;</span>
<span class="line-added">247   virtual const Type* bottom_type() const;</span>
<span class="line-added">248   virtual const Type* Value(PhaseGVN* phase) const;</span>
<span class="line-added">249   virtual const class TypePtr *adr_type() const { return TypeOopPtr::BOTTOM; }</span>
<span class="line-added">250   virtual uint match_edge(uint idx) const {</span>
<span class="line-added">251     return idx &gt;= ValueIn;</span>
<span class="line-added">252   }</span>
<span class="line-added">253   virtual uint ideal_reg() const { return Op_RegP; }</span>
<span class="line-added">254 </span>
<span class="line-added">255   virtual Node* Identity(PhaseGVN* phase);</span>
<span class="line-added">256 </span>
<span class="line-added">257   virtual uint size_of() const;</span>
<span class="line-added">258   virtual uint hash() const;</span>
<span class="line-added">259   virtual bool cmp( const Node &amp;n ) const;</span>
<span class="line-added">260 </span>
<span class="line-added">261   Strength get_barrier_strength();</span>
<span class="line-added">262   CallStaticJavaNode* pin_and_expand_null_check(PhaseIterGVN&amp; igvn);</span>
<span class="line-added">263 </span>
<span class="line-added">264 private:</span>
<span class="line-added">265   bool needs_barrier(PhaseGVN* phase, Node* n);</span>
<span class="line-added">266   bool needs_barrier_impl(PhaseGVN* phase, Node* n, Unique_Node_List &amp;visited);</span>
<span class="line-added">267 };</span>
<span class="line-added">268 </span>
<span class="line-added">269 </span>
270 #endif // SHARE_GC_SHENANDOAH_C2_SHENANDOAHSUPPORT_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../heuristics/shenandoahAdaptiveHeuristics.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
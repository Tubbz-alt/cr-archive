<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<a name="2" id="anc2"></a><span class="line-modified"> 26 #include &quot;gc/shared/owstTaskTerminator.hpp&quot;</span>

 27 #include &quot;gc/shared/taskqueue.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
<a name="3" id="anc3"></a>
 29 #include &quot;runtime/mutex.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 
 32 template&lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
 33 class BufferedOverflowTaskQueue: public OverflowTaskQueue&lt;E, F, N&gt;
 34 {
 35 public:
 36   typedef OverflowTaskQueue&lt;E, F, N&gt; taskqueue_t;
 37 
 38   BufferedOverflowTaskQueue() : _buf_empty(true) {};
 39 
 40   TASKQUEUE_STATS_ONLY(using taskqueue_t::stats;)
 41 
 42   // Push task t into the queue. Returns true on success.
 43   inline bool push(E t);
 44 
 45   // Attempt to pop from the queue. Returns true on success.
 46   inline bool pop(E &amp;t);
 47 
 48   inline void clear();
 49 
 50   inline bool is_empty()        const {
 51     return _buf_empty &amp;&amp; taskqueue_t::is_empty();
 52   }
 53 
 54 private:
 55   bool _buf_empty;
 56   E _elem;
 57 };
 58 
 59 // ObjArrayChunkedTask
 60 //
 61 // Encodes both regular oops, and the array oops plus chunking data for parallel array processing.
 62 // The design goal is to make the regular oop ops very fast, because that would be the prevailing
 63 // case. On the other hand, it should not block parallel array processing from efficiently dividing
 64 // the array work.
 65 //
 66 // The idea is to steal the bits from the 64-bit oop to encode array data, if needed. For the
 67 // proper divide-and-conquer strategies, we want to encode the &quot;blocking&quot; data. It turns out, the
 68 // most efficient way to do this is to encode the array block as (chunk * 2^pow), where it is assumed
 69 // that the block has the size of 2^pow. This requires for pow to have only 5 bits (2^32) to encode
 70 // all possible arrays.
 71 //
 72 //    |---------oop---------|-pow-|--chunk---|
 73 //    0                    49     54        64
 74 //
 75 // By definition, chunk == 0 means &quot;no chunk&quot;, i.e. chunking starts from 1.
 76 //
 77 // This encoding gives a few interesting benefits:
 78 //
 79 // a) Encoding/decoding regular oops is very simple, because the upper bits are zero in that task:
 80 //
 81 //    |---------oop---------|00000|0000000000| // no chunk data
 82 //
 83 //    This helps the most ubiquitous path. The initialization amounts to putting the oop into the word
 84 //    with zero padding. Testing for &quot;chunkedness&quot; is testing for zero with chunk mask.
 85 //
 86 // b) Splitting tasks for divide-and-conquer is possible. Suppose we have chunk &lt;C, P&gt; that covers
 87 // interval [ (C-1)*2^P; C*2^P ). We can then split it into two chunks:
 88 //      &lt;2*C - 1, P-1&gt;, that covers interval [ (2*C - 2)*2^(P-1); (2*C - 1)*2^(P-1) )
 89 //      &lt;2*C, P-1&gt;,     that covers interval [ (2*C - 1)*2^(P-1);       2*C*2^(P-1) )
 90 //
 91 //    Observe that the union of these two intervals is:
 92 //      [ (2*C - 2)*2^(P-1); 2*C*2^(P-1) )
 93 //
 94 //    ...which is the original interval:
 95 //      [ (C-1)*2^P; C*2^P )
 96 //
 97 // c) The divide-and-conquer strategy could even start with chunk &lt;1, round-log2-len(arr)&gt;, and split
 98 //    down in the parallel threads, which alleviates the upfront (serial) splitting costs.
 99 //
100 // Encoding limitations caused by current bitscales mean:
101 //    10 bits for chunk: max 1024 blocks per array
102 //     5 bits for power: max 2^32 array
103 //    49 bits for   oop: max 512 TB of addressable space
104 //
105 // Stealing bits from oop trims down the addressable space. Stealing too few bits for chunk ID limits
106 // potential parallelism. Stealing too few bits for pow limits the maximum array size that can be handled.
107 // In future, these might be rebalanced to favor one degree of freedom against another. For example,
108 // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
109 // some bits back if chunks are counted in ObjArrayMarkingStride units.
110 //
111 // There is also a fallback version that uses plain fields, when we don&#39;t have enough space to steal the
<a name="4" id="anc4"></a><span class="line-modified">112 // bits from the native pointer. It is useful to debug the _LP64 version.</span>
113 //
114 
115 #ifdef _MSC_VER
116 #pragma warning(push)
117 // warning C4522: multiple assignment operators specified
118 #pragma warning( disable:4522 )
119 #endif
120 
121 #ifdef _LP64
<a name="5" id="anc5"></a>





122 class ObjArrayChunkedTask
123 {
124 public:
125   enum {
126     chunk_bits   = 10,
127     pow_bits     = 5,
<a name="6" id="anc6"></a><span class="line-modified">128     oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits,</span>
129   };
130   enum {
131     oop_shift    = 0,
132     pow_shift    = oop_shift + oop_bits,
<a name="7" id="anc7"></a><span class="line-modified">133     chunk_shift  = pow_shift + pow_bits,</span>
134   };
135 
136 public:
137   ObjArrayChunkedTask(oop o = NULL) {
<a name="8" id="anc8"></a><span class="line-modified">138     _obj = ((uintptr_t)(void*) o) &lt;&lt; oop_shift;</span>

139   }
<a name="9" id="anc9"></a><span class="line-modified">140   ObjArrayChunkedTask(oop o, int chunk, int mult) {</span>
<span class="line-modified">141     assert(0 &lt;= chunk &amp;&amp; chunk &lt; nth_bit(chunk_bits), &quot;chunk is sane: %d&quot;, chunk);</span>
<span class="line-modified">142     assert(0 &lt;= mult &amp;&amp; mult &lt; nth_bit(pow_bits), &quot;pow is sane: %d&quot;, mult);</span>
<span class="line-modified">143     uintptr_t t_b = ((uintptr_t) chunk) &lt;&lt; chunk_shift;</span>
<span class="line-modified">144     uintptr_t t_m = ((uintptr_t) mult) &lt;&lt; pow_shift;</span>
<span class="line-removed">145     uintptr_t obj = (uintptr_t)(void*)o;</span>
<span class="line-removed">146     assert(obj &lt; nth_bit(oop_bits), &quot;obj ref is sane: &quot; PTR_FORMAT, obj);</span>
<span class="line-removed">147     intptr_t t_o = obj &lt;&lt; oop_shift;</span>
<span class="line-removed">148     _obj = t_o | t_m | t_b;</span>
149   }
150   ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj) { }
151 
152   ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
153     _obj = t._obj;
154     return *this;
155   }
156   volatile ObjArrayChunkedTask&amp;
157   operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
158     (void)const_cast&lt;uintptr_t&amp;&gt;(_obj = t._obj);
159     return *this;
160   }
161 
<a name="10" id="anc10"></a><span class="line-modified">162   inline oop obj()   const { return (oop) reinterpret_cast&lt;void*&gt;((_obj &gt;&gt; oop_shift) &amp; right_n_bits(oop_bits)); }</span>
<span class="line-modified">163   inline int chunk() const { return (int) (_obj &gt;&gt; chunk_shift) &amp; right_n_bits(chunk_bits); }</span>
<span class="line-modified">164   inline int pow()   const { return (int) ((_obj &gt;&gt; pow_shift) &amp; right_n_bits(pow_bits)); }</span>
























165   inline bool is_not_chunked() const { return (_obj &amp; ~right_n_bits(oop_bits + pow_bits)) == 0; }
166 
167   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
168 
<a name="11" id="anc11"></a><span class="line-modified">169   static size_t max_addressable() {</span>
170     return nth_bit(oop_bits);
171   }
172 
173   static int chunk_size() {
174     return nth_bit(chunk_bits);
175   }
176 
177 private:
178   uintptr_t _obj;
179 };
180 #else
181 class ObjArrayChunkedTask
182 {
183 public:
184   enum {
185     chunk_bits  = 10,
186     pow_bits    = 5,
187   };
188 public:
189   ObjArrayChunkedTask(oop o = NULL, int chunk = 0, int pow = 0): _obj(o) {
190     assert(0 &lt;= chunk &amp;&amp; chunk &lt; nth_bit(chunk_bits), &quot;chunk is sane: %d&quot;, chunk);
191     assert(0 &lt;= pow &amp;&amp; pow &lt; nth_bit(pow_bits), &quot;pow is sane: %d&quot;, pow);
192     _chunk = chunk;
193     _pow = pow;
194   }
195   ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj), _chunk(t._chunk), _pow(t._pow) { }
196 
197   ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
198     _obj = t._obj;
199     _chunk = t._chunk;
200     _pow = t._pow;
201     return *this;
202   }
203   volatile ObjArrayChunkedTask&amp;
204   operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
205     (void)const_cast&lt;oop&amp;&gt;(_obj = t._obj);
206     _chunk = t._chunk;
207     _pow = t._pow;
208     return *this;
209   }
210 
211   inline oop obj()   const { return _obj; }
212   inline int chunk() const { return _chunk; }
213   inline int pow()  const { return _pow; }
214 
215   inline bool is_not_chunked() const { return _chunk == 0; }
216 
217   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
218 
219   static size_t max_addressable() {
220     return sizeof(oop);
221   }
222 
223   static int chunk_size() {
224     return nth_bit(chunk_bits);
225   }
226 
227 private:
228   oop _obj;
229   int _chunk;
230   int _pow;
231 };
<a name="12" id="anc12"></a><span class="line-modified">232 #endif</span>
233 
234 #ifdef _MSC_VER
235 #pragma warning(pop)
236 #endif
237 
238 typedef ObjArrayChunkedTask ShenandoahMarkTask;
239 typedef BufferedOverflowTaskQueue&lt;ShenandoahMarkTask, mtGC&gt; ShenandoahBufferedOverflowTaskQueue;
240 typedef Padded&lt;ShenandoahBufferedOverflowTaskQueue&gt; ShenandoahObjToScanQueue;
241 
242 template &lt;class T, MEMFLAGS F&gt;
243 class ParallelClaimableQueueSet: public GenericTaskQueueSet&lt;T, F&gt; {
244 private:
245   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile jint));
246   volatile jint     _claimed_index;
247   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
248 
249   debug_only(uint   _reserved;  )
250 
251 public:
252   using GenericTaskQueueSet&lt;T, F&gt;::size;
253 
254 public:
255   ParallelClaimableQueueSet(int n) : GenericTaskQueueSet&lt;T, F&gt;(n), _claimed_index(0) {
256     debug_only(_reserved = 0; )
257   }
258 
259   void clear_claimed() { _claimed_index = 0; }
260   T*   claim_next();
261 
262   // reserve queues that not for parallel claiming
263   void reserve(uint n) {
264     assert(n &lt;= size(), &quot;Sanity&quot;);
265     _claimed_index = (jint)n;
266     debug_only(_reserved = n;)
267   }
268 
269   debug_only(uint get_reserved() const { return (uint)_reserved; })
270 };
271 
272 template &lt;class T, MEMFLAGS F&gt;
273 T* ParallelClaimableQueueSet&lt;T, F&gt;::claim_next() {
274   jint size = (jint)GenericTaskQueueSet&lt;T, F&gt;::size();
275 
276   if (_claimed_index &gt;= size) {
277     return NULL;
278   }
279 
<a name="13" id="anc13"></a><span class="line-modified">280   jint index = Atomic::add(1, &amp;_claimed_index);</span>
281 
282   if (index &lt;= size) {
283     return GenericTaskQueueSet&lt;T, F&gt;::queue((uint)index - 1);
284   } else {
285     return NULL;
286   }
287 }
288 
289 class ShenandoahObjToScanQueueSet: public ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt; {
290 public:
291   ShenandoahObjToScanQueueSet(int n) : ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt;(n) {}
292 
293   bool is_empty();
294   void clear();
295 
296 #if TASKQUEUE_STATS
297   static void print_taskqueue_stats_hdr(outputStream* const st);
298   void print_taskqueue_stats() const;
299   void reset_taskqueue_stats();
300 #endif // TASKQUEUE_STATS
301 };
302 
303 class ShenandoahTerminatorTerminator : public TerminatorTerminator {
304 private:
305   ShenandoahHeap* _heap;
306 public:
307   ShenandoahTerminatorTerminator(ShenandoahHeap* const heap) : _heap(heap) { }
308   // return true, terminates immediately, even if there&#39;s remaining work left
309   virtual bool should_exit_termination() { return _heap-&gt;cancelled_gc(); }
310 };
311 
<a name="14" id="anc14"></a><span class="line-removed">312 class ShenandoahTaskTerminator : public StackObj {</span>
<span class="line-removed">313 private:</span>
<span class="line-removed">314   OWSTTaskTerminator* const   _terminator;</span>
<span class="line-removed">315 public:</span>
<span class="line-removed">316   ShenandoahTaskTerminator(uint n_threads, TaskQueueSetSuper* queue_set);</span>
<span class="line-removed">317   ~ShenandoahTaskTerminator();</span>
<span class="line-removed">318 </span>
<span class="line-removed">319   bool offer_termination(ShenandoahTerminatorTerminator* terminator) {</span>
<span class="line-removed">320     return _terminator-&gt;offer_termination(terminator);</span>
<span class="line-removed">321   }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323   void reset_for_reuse() { _terminator-&gt;reset_for_reuse(); }</span>
<span class="line-removed">324   bool offer_termination() { return offer_termination((ShenandoahTerminatorTerminator*)NULL); }</span>
<span class="line-removed">325 };</span>
<span class="line-removed">326 </span>
327 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
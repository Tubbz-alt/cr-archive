<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Red Hat, Inc. All rights reserved.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 26 
 27 #include &quot;gc/shared/space.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
 32 #include &quot;memory/universe.hpp&quot;
 33 #include &quot;utilities/sizes.hpp&quot;
 34 
 35 class VMStructs;
 36 
 37 class ShenandoahHeapRegion : public ContiguousSpace {
 38   friend class VMStructs;
 39 private:
 40   /*
 41     Region state is described by a state machine. Transitions are guarded by
 42     heap lock, which allows changing the state of several regions atomically.
 43     Region states can be logically aggregated in groups.
 44 
 45       &quot;Empty&quot;:
 46       .................................................................
 47       .                                                               .
 48       .                                                               .
 49       .         Uncommitted  &lt;-------  Committed &lt;------------------------\
 50       .              |                     |                          .   |
 51       .              \---------v-----------/                          .   |
 52       .                        |                                      .   |
 53       .........................|.......................................   |
 54                                |                                          |
 55       &quot;Active&quot;:                |                                          |
 56       .........................|.......................................   |
 57       .                        |                                      .   |
 58       .      /-----------------^-------------------\                  .   |
 59       .      |                                     |                  .   |
 60       .      v                                     v    &quot;Humongous&quot;:  .   |
 61       .   Regular ---\-----\     ..................O................  .   |
 62       .     |  ^     |     |     .                 |               .  .   |
 63       .     |  |     |     |     .                 *---------\     .  .   |
 64       .     v  |     |     |     .                 v         v     .  .   |
 65       .    Pinned  Cset    |     .  HStart &lt;--&gt; H/Start   H/Cont   .  .   |
 66       .       ^    / |     |     .  Pinned         v         |     .  .   |
 67       .       |   /  |     |     .                 *&lt;--------/     .  .   |
 68       .       |  v   |     |     .                 |               .  .   |
 69       .  CsetPinned  |     |     ..................O................  .   |
 70       .              |     |                       |                  .   |
 71       .              \-----\---v-------------------/                  .   |
 72       .                        |                                      .   |
 73       .........................|.......................................   |
 74                                |                                          |
 75       &quot;Trash&quot;:                 |                                          |
 76       .........................|.......................................   |
 77       .                        |                                      .   |
 78       .                        v                                      .   |
 79       .                      Trash ---------------------------------------/
 80       .                                                               .
 81       .                                                               .
 82       .................................................................
 83 
 84     Transition from &quot;Empty&quot; to &quot;Active&quot; is first allocation. It can go from {Uncommitted, Committed}
 85     to {Regular, &quot;Humongous&quot;}. The allocation may happen in Regular regions too, but not in Humongous.
 86 
 87     Transition from &quot;Active&quot; to &quot;Trash&quot; is reclamation. It can go from CSet during the normal cycle,
 88     and from {Regular, &quot;Humongous&quot;} for immediate reclamation. The existence of Trash state allows
 89     quick reclamation without actual cleaning up.
 90 
 91     Transition from &quot;Trash&quot; to &quot;Empty&quot; is recycling. It cleans up the regions and corresponding metadata.
 92     Can be done asynchronously and in bulk.
 93 
 94     Note how internal transitions disallow logic bugs:
 95       a) No region can go Empty, unless properly reclaimed/recycled;
 96       b) No region can go Uncommitted, unless reclaimed/recycled first;
 97       c) Only Regular regions can go to CSet;
 98       d) Pinned cannot go Trash, thus it could never be reclaimed until unpinned;
 99       e) Pinned cannot go CSet, thus it never moves;
100       f) Humongous cannot be used for regular allocations;
101       g) Humongous cannot go CSet, thus it never moves;
102       h) Humongous start can go pinned, and thus can be protected from moves (humongous continuations should
103          follow associated humongous starts, not pinnable/movable by themselves);
104       i) Empty cannot go Trash, avoiding useless work;
105       j) ...
106    */
107 
108   enum RegionState {
109     _empty_uncommitted,       // region is empty and has memory uncommitted
110     _empty_committed,         // region is empty and has memory committed
111     _regular,                 // region is for regular allocations
112     _humongous_start,         // region is the humongous start
113     _humongous_cont,          // region is the humongous continuation
114     _pinned_humongous_start,  // region is both humongous start and pinned
115     _cset,                    // region is in collection set
116     _pinned,                  // region is pinned
117     _pinned_cset,             // region is pinned and in cset (evac failure path)
118     _trash,                   // region contains only trash
119   };
120 
121   const char* region_state_to_string(RegionState s) const {
122     switch (s) {
123       case _empty_uncommitted:       return &quot;Empty Uncommitted&quot;;
124       case _empty_committed:         return &quot;Empty Committed&quot;;
125       case _regular:                 return &quot;Regular&quot;;
126       case _humongous_start:         return &quot;Humongous Start&quot;;
127       case _humongous_cont:          return &quot;Humongous Continuation&quot;;
128       case _pinned_humongous_start:  return &quot;Humongous Start, Pinned&quot;;
129       case _cset:                    return &quot;Collection Set&quot;;
130       case _pinned:                  return &quot;Pinned&quot;;
131       case _pinned_cset:             return &quot;Collection Set, Pinned&quot;;
132       case _trash:                   return &quot;Trash&quot;;
133       default:
134         ShouldNotReachHere();
135         return &quot;&quot;;
136     }
137   }
138 
139   // This method protects from accidental changes in enum order:
140   int region_state_to_ordinal(RegionState s) const {
141     switch (s) {
142       case _empty_uncommitted:      return 0;
143       case _empty_committed:        return 1;
144       case _regular:                return 2;
145       case _humongous_start:        return 3;
146       case _humongous_cont:         return 4;
147       case _cset:                   return 5;
148       case _pinned:                 return 6;
149       case _trash:                  return 7;
150       case _pinned_cset:            return 8;
151       case _pinned_humongous_start: return 9;
152       default:
153         ShouldNotReachHere();
154         return -1;
155     }
156   }
157 
158   void report_illegal_transition(const char* method);
159 
160 public:
161   // Allowed transitions from the outside code:
162   void make_regular_allocation();
163   void make_regular_bypass();
164   void make_humongous_start();
165   void make_humongous_cont();
166   void make_humongous_start_bypass();
167   void make_humongous_cont_bypass();
168   void make_pinned();
169   void make_unpinned();
170   void make_cset();
171   void make_trash();
172   void make_trash_immediate();
173   void make_empty();
174   void make_uncommitted();
175   void make_committed_bypass();
176 
177   // Individual states:
178   bool is_empty_uncommitted()      const { return _state == _empty_uncommitted; }
179   bool is_empty_committed()        const { return _state == _empty_committed; }
180   bool is_regular()                const { return _state == _regular; }
181   bool is_humongous_continuation() const { return _state == _humongous_cont; }
182 
183   // Participation in logical groups:
184   bool is_empty()                  const { return is_empty_committed() || is_empty_uncommitted(); }
185   bool is_active()                 const { return !is_empty() &amp;&amp; !is_trash(); }
186   bool is_trash()                  const { return _state == _trash; }
187   bool is_humongous_start()        const { return _state == _humongous_start || _state == _pinned_humongous_start; }
188   bool is_humongous()              const { return is_humongous_start() || is_humongous_continuation(); }
189   bool is_committed()              const { return !is_empty_uncommitted(); }
190   bool is_cset()                   const { return _state == _cset   || _state == _pinned_cset; }
191   bool is_pinned()                 const { return _state == _pinned || _state == _pinned_cset || _state == _pinned_humongous_start; }
192 
193   // Macro-properties:
194   bool is_alloc_allowed()          const { return is_empty() || is_regular() || _state == _pinned; }
195   bool is_move_allowed()           const { return is_regular() || _state == _cset || (ShenandoahHumongousMoves &amp;&amp; _state == _humongous_start); }
196 
197   RegionState state()              const { return _state; }
198   int  state_ordinal()             const { return region_state_to_ordinal(_state); }
199 
200 private:
201   static size_t RegionCount;
202   static size_t RegionSizeBytes;
203   static size_t RegionSizeWords;
204   static size_t RegionSizeBytesShift;
205   static size_t RegionSizeWordsShift;
206   static size_t RegionSizeBytesMask;
207   static size_t RegionSizeWordsMask;
208   static size_t HumongousThresholdBytes;
209   static size_t HumongousThresholdWords;
210   static size_t MaxTLABSizeBytes;
211   static size_t MaxTLABSizeWords;
212 
213   // Global allocation counter, increased for each allocation under Shenandoah heap lock.
214   // Padded to avoid false sharing with the read-only fields above.
215   struct PaddedAllocSeqNum {
216     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(uint64_t));
217     uint64_t value;
218     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
219 
220     PaddedAllocSeqNum() {
221       // start with 1, reserve 0 for uninitialized value
222       value = 1;
223     }
224   };
225 
226   static PaddedAllocSeqNum _alloc_seq_num;
227 
228   // Never updated fields
229   ShenandoahHeap* _heap;
230   MemRegion _reserved;
231   size_t _region_number;
232 
233   // Rarely updated fields
234   HeapWord* _new_top;
235   size_t _critical_pins;
236   double _empty_time;
237 
238   // Seldom updated fields
239   RegionState _state;
240 
241   // Frequently updated fields
242   size_t _tlab_allocs;
243   size_t _gclab_allocs;
244   size_t _shared_allocs;
245 
246   uint64_t _seqnum_first_alloc_mutator;
247   uint64_t _seqnum_first_alloc_gc;
248   uint64_t _seqnum_last_alloc_mutator;
249   uint64_t _seqnum_last_alloc_gc;
250 
251   volatile size_t _live_data;
252 
253   // Claim some space at the end to protect next region
254   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);
255 
256 public:
257   ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start, size_t size_words, size_t index, bool committed);
258 
259   static const size_t MIN_NUM_REGIONS = 10;
260 
261   static void setup_sizes(size_t initial_heap_size, size_t max_heap_size);
262 
263   double empty_time() {
264     return _empty_time;
265   }
266 
267   inline static size_t required_regions(size_t bytes) {
268     return (bytes + ShenandoahHeapRegion::region_size_bytes() - 1) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
269   }
270 
271   inline static size_t region_count() {
272     return ShenandoahHeapRegion::RegionCount;
273   }
274 
275   inline static size_t region_size_bytes() {
276     return ShenandoahHeapRegion::RegionSizeBytes;
277   }
278 
279   inline static size_t region_size_words() {
280     return ShenandoahHeapRegion::RegionSizeWords;
281   }
282 
283   inline static size_t region_size_bytes_shift() {
284     return ShenandoahHeapRegion::RegionSizeBytesShift;
285   }
286 
287   inline static size_t region_size_words_shift() {
288     return ShenandoahHeapRegion::RegionSizeWordsShift;
289   }
290 
291   inline static size_t region_size_bytes_mask() {
292     return ShenandoahHeapRegion::RegionSizeBytesMask;
293   }
294 
295   inline static size_t region_size_words_mask() {
296     return ShenandoahHeapRegion::RegionSizeWordsMask;
297   }
298 
299   // Convert to jint with sanity checking
300   inline static jint region_size_bytes_jint() {
301     assert (ShenandoahHeapRegion::RegionSizeBytes &lt;= (size_t)max_jint, &quot;sanity&quot;);
302     return (jint)ShenandoahHeapRegion::RegionSizeBytes;
303   }
304 
305   // Convert to jint with sanity checking
306   inline static jint region_size_words_jint() {
307     assert (ShenandoahHeapRegion::RegionSizeWords &lt;= (size_t)max_jint, &quot;sanity&quot;);
308     return (jint)ShenandoahHeapRegion::RegionSizeWords;
309   }
310 
311   // Convert to jint with sanity checking
312   inline static jint region_size_bytes_shift_jint() {
313     assert (ShenandoahHeapRegion::RegionSizeBytesShift &lt;= (size_t)max_jint, &quot;sanity&quot;);
314     return (jint)ShenandoahHeapRegion::RegionSizeBytesShift;
315   }
316 
317   // Convert to jint with sanity checking
318   inline static jint region_size_words_shift_jint() {
319     assert (ShenandoahHeapRegion::RegionSizeWordsShift &lt;= (size_t)max_jint, &quot;sanity&quot;);
320     return (jint)ShenandoahHeapRegion::RegionSizeWordsShift;
321   }
322 
323   inline static size_t humongous_threshold_bytes() {
324     return ShenandoahHeapRegion::HumongousThresholdBytes;
325   }
326 
327   inline static size_t humongous_threshold_words() {
328     return ShenandoahHeapRegion::HumongousThresholdWords;
329   }
330 
331   inline static size_t max_tlab_size_bytes() {
332     return ShenandoahHeapRegion::MaxTLABSizeBytes;
333   }
334 
335   inline static size_t max_tlab_size_words() {
336     return ShenandoahHeapRegion::MaxTLABSizeWords;
337   }
338 
339   static uint64_t seqnum_current_alloc() {
340     // Last used seq number
341     return _alloc_seq_num.value - 1;
342   }
343 
344   size_t region_number() const;
345 
346   // Allocation (return NULL if full)
347   inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest::Type type);
348 
349   HeapWord* allocate(size_t word_size) shenandoah_not_implemented_return(NULL)
350 
351   void clear_live_data();
352   void set_live_data(size_t s);
353 
354   // Increase live data for newly allocated region
355   inline void increase_live_data_alloc_words(size_t s);
356 
357   // Increase live data for region scanned with GC
358   inline void increase_live_data_gc_words(size_t s);
359 
360   bool has_live() const;
361   size_t get_live_data_bytes() const;
362   size_t get_live_data_words() const;
363 
364   void print_on(outputStream* st) const;
365 
366   size_t garbage() const;
367 
368   void recycle();
369 
370   void oop_iterate(OopIterateClosure* cl);
371 
372   HeapWord* block_start_const(const void* p) const;
373 
374   bool in_collection_set() const;
375 
376   // Find humongous start region that this region belongs to
377   ShenandoahHeapRegion* humongous_start_region() const;
378 
379   CompactibleSpace* next_compaction_space() const shenandoah_not_implemented_return(NULL);
380   void prepare_for_compaction(CompactPoint* cp)   shenandoah_not_implemented;
381   void adjust_pointers()                          shenandoah_not_implemented;
382   void compact()                                  shenandoah_not_implemented;
383 
384   void set_new_top(HeapWord* new_top) { _new_top = new_top; }
385   HeapWord* new_top() const { return _new_top; }
386 
387   inline void adjust_alloc_metadata(ShenandoahAllocRequest::Type type, size_t);
388   void reset_alloc_metadata_to_shared();
389   void reset_alloc_metadata();
390   size_t get_shared_allocs() const;
391   size_t get_tlab_allocs() const;
392   size_t get_gclab_allocs() const;
393 
394   uint64_t seqnum_first_alloc() const {
395     if (_seqnum_first_alloc_mutator == 0) return _seqnum_first_alloc_gc;
396     if (_seqnum_first_alloc_gc == 0)      return _seqnum_first_alloc_mutator;
397     return MIN2(_seqnum_first_alloc_mutator, _seqnum_first_alloc_gc);
398   }
399 
400   uint64_t seqnum_last_alloc() const {
401     return MAX2(_seqnum_last_alloc_mutator, _seqnum_last_alloc_gc);
402   }
403 
404   uint64_t seqnum_first_alloc_mutator() const {
405     return _seqnum_first_alloc_mutator;
406   }
407 
408   uint64_t seqnum_last_alloc_mutator()  const {
409     return _seqnum_last_alloc_mutator;
410   }
411 
412   uint64_t seqnum_first_alloc_gc() const {
413     return _seqnum_first_alloc_gc;
414   }
415 
416   uint64_t seqnum_last_alloc_gc()  const {
417     return _seqnum_last_alloc_gc;
418   }
419 
420 private:
421   void do_commit();
422   void do_uncommit();
423 
424   void oop_iterate_objects(OopIterateClosure* cl);
425   void oop_iterate_humongous(OopIterateClosure* cl);
426 
427   inline void internal_increase_live_data(size_t s);
428 };
429 
430 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;code/codeCache.hpp&quot;

 26 #include &quot;code/nmethod.hpp&quot;
<span class="line-removed"> 27 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
 28 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;




 29 #include &quot;memory/resourceArea.hpp&quot;



 30 
 31 ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
 32   _length = heaps-&gt;length();
 33   _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
 34   for (int h = 0; h &lt; _length; h++) {
 35     _iters[h] = ShenandoahParallelCodeHeapIterator(heaps-&gt;at(h));
 36   }
 37 }
 38 
 39 ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {
 40   FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);
 41 }
 42 
 43 void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {
 44   for (int c = 0; c &lt; _length; c++) {
 45     _iters[c].parallel_blobs_do(f);
 46   }
 47 }
 48 
 49 ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :
</pre>
<hr />
<pre>
 62    * next attempt without processing.
 63    *
 64    * Late threads would return immediately if iterator is finished.
 65    */
 66 
 67   if (_finished) {
 68     return;
 69   }
 70 
 71   int stride = 256; // educated guess
 72   int stride_mask = stride - 1;
 73   assert (is_power_of_2(stride), &quot;sanity&quot;);
 74 
 75   int count = 0;
 76   bool process_block = true;
 77 
 78   for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != NULL; cb = CodeCache::next_blob(_heap, cb)) {
 79     int current = count++;
 80     if ((current &amp; stride_mask) == 0) {
 81       process_block = (current &gt;= _claimed_idx) &amp;&amp;
<span class="line-modified"> 82                       (Atomic::cmpxchg(current + stride, &amp;_claimed_idx, current) == current);</span>
 83     }
 84     if (process_block) {
 85       if (cb-&gt;is_alive()) {
 86         f-&gt;do_code_blob(cb);
 87 #ifdef ASSERT
 88         if (cb-&gt;is_nmethod())
 89           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 90 #endif
 91       }
 92     }
 93   }
 94 
 95   _finished = true;
 96 }
 97 
<span class="line-modified"> 98 class ShenandoahNMethodOopDetector : public OopClosure {</span>
<span class="line-modified"> 99 private:</span>
<span class="line-removed">100   ResourceMark rm; // For growable array allocation below.</span>
<span class="line-removed">101   GrowableArray&lt;oop*&gt; _oops;</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 public:</span>
<span class="line-removed">104   ShenandoahNMethodOopDetector() : _oops(10) {};</span>
105 
<span class="line-modified">106   void do_oop(oop* o) {</span>
<span class="line-modified">107     _oops.append(o);</span>
<span class="line-modified">108   }</span>
<span class="line-removed">109   void do_oop(narrowOop* o) {</span>
<span class="line-removed">110     fatal(&quot;NMethods should not have compressed oops embedded.&quot;);</span>
<span class="line-removed">111   }</span>
<span class="line-removed">112 </span>
<span class="line-removed">113   GrowableArray&lt;oop*&gt;* oops() {</span>
<span class="line-removed">114     return &amp;_oops;</span>
<span class="line-removed">115   }</span>
<span class="line-removed">116 </span>
<span class="line-removed">117   bool has_oops() {</span>
<span class="line-removed">118     return !_oops.is_empty();</span>
<span class="line-removed">119   }</span>
<span class="line-removed">120 };</span>
<span class="line-removed">121 </span>
<span class="line-removed">122 class ShenandoahNMethodOopInitializer : public OopClosure {</span>
<span class="line-removed">123 private:</span>
<span class="line-removed">124   ShenandoahHeap* const _heap;</span>
<span class="line-removed">125 </span>
<span class="line-removed">126 public:</span>
<span class="line-removed">127   ShenandoahNMethodOopInitializer() : _heap(ShenandoahHeap::heap()) {};</span>
128 
<span class="line-modified">129 private:</span>
<span class="line-modified">130   template &lt;class T&gt;</span>
<span class="line-modified">131   inline void do_oop_work(T* p) {</span>
<span class="line-modified">132     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-modified">133     if (! CompressedOops::is_null(o)) {</span>
<span class="line-modified">134       oop obj1 = CompressedOops::decode_not_null(o);</span>
<span class="line-modified">135       oop obj2 = ShenandoahBarrierSet::barrier_set()-&gt;write_barrier(obj1);</span>
<span class="line-modified">136       if (! oopDesc::equals_raw(obj1, obj2)) {</span>
<span class="line-modified">137         shenandoah_assert_not_in_cset(NULL, obj2);</span>
<span class="line-removed">138         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj2);</span>
<span class="line-removed">139         if (_heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-removed">140           ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj2);</span>
<span class="line-removed">141         }</span>
<span class="line-removed">142       }</span>
143     }


144   }
<span class="line-removed">145 </span>
<span class="line-removed">146 public:</span>
<span class="line-removed">147   void do_oop(oop* o) {</span>
<span class="line-removed">148     do_oop_work(o);</span>
<span class="line-removed">149   }</span>
<span class="line-removed">150   void do_oop(narrowOop* o) {</span>
<span class="line-removed">151     do_oop_work(o);</span>
<span class="line-removed">152   }</span>
<span class="line-removed">153 };</span>
<span class="line-removed">154 </span>
<span class="line-removed">155 ShenandoahCodeRoots::PaddedLock ShenandoahCodeRoots::_recorded_nms_lock;</span>
<span class="line-removed">156 GrowableArray&lt;ShenandoahNMethod*&gt;* ShenandoahCodeRoots::_recorded_nms;</span>
<span class="line-removed">157 </span>
<span class="line-removed">158 void ShenandoahCodeRoots::initialize() {</span>
<span class="line-removed">159   _recorded_nms_lock._lock = 0;</span>
<span class="line-removed">160   _recorded_nms = new (ResourceObj::C_HEAP, mtGC) GrowableArray&lt;ShenandoahNMethod*&gt;(100, true, mtGC);</span>
161 }
162 
<span class="line-modified">163 void ShenandoahCodeRoots::add_nmethod(nmethod* nm) {</span>
164   switch (ShenandoahCodeRootsStyle) {
165     case 0:
166     case 1: {
<span class="line-removed">167       ShenandoahNMethodOopInitializer init;</span>
<span class="line-removed">168       nm-&gt;oops_do(&amp;init);</span>
<span class="line-removed">169       nm-&gt;fix_oop_relocations();</span>
170       break;
171     }
172     case 2: {
<span class="line-modified">173       ShenandoahNMethodOopDetector detector;</span>
<span class="line-modified">174       nm-&gt;oops_do(&amp;detector);</span>
<span class="line-removed">175 </span>
<span class="line-removed">176       if (detector.has_oops()) {</span>
<span class="line-removed">177         ShenandoahNMethodOopInitializer init;</span>
<span class="line-removed">178         nm-&gt;oops_do(&amp;init);</span>
<span class="line-removed">179         nm-&gt;fix_oop_relocations();</span>
<span class="line-removed">180 </span>
<span class="line-removed">181         ShenandoahNMethod* nmr = new ShenandoahNMethod(nm, detector.oops());</span>
<span class="line-removed">182         nmr-&gt;assert_alive_and_correct();</span>
<span class="line-removed">183 </span>
<span class="line-removed">184         ShenandoahCodeRootsLock lock(true);</span>
<span class="line-removed">185 </span>
<span class="line-removed">186         int idx = _recorded_nms-&gt;find(nm, ShenandoahNMethod::find_with_nmethod);</span>
<span class="line-removed">187         if (idx != -1) {</span>
<span class="line-removed">188           ShenandoahNMethod* old = _recorded_nms-&gt;at(idx);</span>
<span class="line-removed">189           _recorded_nms-&gt;at_put(idx, nmr);</span>
<span class="line-removed">190           delete old;</span>
<span class="line-removed">191         } else {</span>
<span class="line-removed">192           _recorded_nms-&gt;append(nmr);</span>
<span class="line-removed">193         }</span>
<span class="line-removed">194       }</span>
195       break;
196     }
197     default:
198       ShouldNotReachHere();
199   }
<span class="line-modified">200 };</span>
201 
<span class="line-modified">202 void ShenandoahCodeRoots::remove_nmethod(nmethod* nm) {</span>
203   switch (ShenandoahCodeRootsStyle) {
204     case 0:
205     case 1: {
206       break;
207     }
208     case 2: {
<span class="line-modified">209       ShenandoahNMethodOopDetector detector;</span>
<span class="line-modified">210       nm-&gt;oops_do(&amp;detector, /* allow_zombie = */ true);</span>
<span class="line-removed">211 </span>
<span class="line-removed">212       if (detector.has_oops()) {</span>
<span class="line-removed">213         ShenandoahCodeRootsLock lock(true);</span>
<span class="line-removed">214 </span>
<span class="line-removed">215         int idx = _recorded_nms-&gt;find(nm, ShenandoahNMethod::find_with_nmethod);</span>
<span class="line-removed">216         assert(idx != -1, &quot;nmethod &quot; PTR_FORMAT &quot; should be registered&quot;, p2i(nm));</span>
<span class="line-removed">217         ShenandoahNMethod* old = _recorded_nms-&gt;at(idx);</span>
<span class="line-removed">218         old-&gt;assert_same_oops(detector.oops());</span>
<span class="line-removed">219         _recorded_nms-&gt;delete_at(idx);</span>
<span class="line-removed">220         delete old;</span>
<span class="line-removed">221       }</span>
222       break;
223     }
224     default:
225       ShouldNotReachHere();
226   }
227 }
228 



















































































































































































229 ShenandoahCodeRootsIterator::ShenandoahCodeRootsIterator() :
<span class="line-removed">230         _heap(ShenandoahHeap::heap()),</span>
231         _par_iterator(CodeCache::heaps()),
<span class="line-modified">232         _claimed(0) {</span>
233   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
234   assert(!Thread::current()-&gt;is_Worker_thread(), &quot;Should not be acquired by workers&quot;);
235   switch (ShenandoahCodeRootsStyle) {
236     case 0:
237     case 1: {
238       // No need to do anything here
239       break;
240     }
241     case 2: {
<span class="line-modified">242       ShenandoahCodeRoots::acquire_lock(false);</span>

243       break;
244     }
245     default:
246       ShouldNotReachHere();
247   }
248 }
249 
250 ShenandoahCodeRootsIterator::~ShenandoahCodeRootsIterator() {
251   switch (ShenandoahCodeRootsStyle) {
252     case 0:
253     case 1: {
254       // No need to do anything here
255       break;
256     }
257     case 2: {
<span class="line-modified">258       ShenandoahCodeRoots::release_lock(false);</span>


259       break;
260     }
261     default:
262       ShouldNotReachHere();
263   }
264 }
265 
266 template&lt;bool CSET_FILTER&gt;
267 void ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do(CodeBlobClosure *f) {
268   switch (ShenandoahCodeRootsStyle) {
269     case 0: {
270       if (_seq_claimed.try_set()) {
271         CodeCache::blobs_do(f);
272       }
273       break;
274     }
275     case 1: {
276       _par_iterator.parallel_blobs_do(f);
277       break;
278     }
279     case 2: {
280       ShenandoahCodeRootsIterator::fast_parallel_blobs_do&lt;CSET_FILTER&gt;(f);
281       break;
282     }
283     default:
284       ShouldNotReachHere();
285   }
286 }
287 
<span class="line-removed">288 ShenandoahAllCodeRootsIterator ShenandoahCodeRoots::iterator() {</span>
<span class="line-removed">289   return ShenandoahAllCodeRootsIterator();</span>
<span class="line-removed">290 }</span>
<span class="line-removed">291 </span>
<span class="line-removed">292 ShenandoahCsetCodeRootsIterator ShenandoahCodeRoots::cset_iterator() {</span>
<span class="line-removed">293   return ShenandoahCsetCodeRootsIterator();</span>
<span class="line-removed">294 }</span>
<span class="line-removed">295 </span>
296 void ShenandoahAllCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
297   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;false&gt;(f);
298 }
299 
300 void ShenandoahCsetCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
301   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;true&gt;(f);
302 }
303 
304 template &lt;bool CSET_FILTER&gt;
305 void ShenandoahCodeRootsIterator::fast_parallel_blobs_do(CodeBlobClosure *f) {
306   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
<span class="line-modified">307 </span>
<span class="line-modified">308   size_t stride = 256; // educated guess</span>
<span class="line-removed">309 </span>
<span class="line-removed">310   GrowableArray&lt;ShenandoahNMethod*&gt;* list = ShenandoahCodeRoots::_recorded_nms;</span>
<span class="line-removed">311 </span>
<span class="line-removed">312   size_t max = (size_t)list-&gt;length();</span>
<span class="line-removed">313   while (_claimed &lt; max) {</span>
<span class="line-removed">314     size_t cur = Atomic::add(stride, &amp;_claimed) - stride;</span>
<span class="line-removed">315     size_t start = cur;</span>
<span class="line-removed">316     size_t end = MIN2(cur + stride, max);</span>
<span class="line-removed">317     if (start &gt;= max) break;</span>
<span class="line-removed">318 </span>
<span class="line-removed">319     for (size_t idx = start; idx &lt; end; idx++) {</span>
<span class="line-removed">320       ShenandoahNMethod* nmr = list-&gt;at((int) idx);</span>
<span class="line-removed">321       nmr-&gt;assert_alive_and_correct();</span>
<span class="line-removed">322 </span>
<span class="line-removed">323       if (CSET_FILTER &amp;&amp; !nmr-&gt;has_cset_oops(_heap)) {</span>
<span class="line-removed">324         continue;</span>
<span class="line-removed">325       }</span>
<span class="line-removed">326 </span>
<span class="line-removed">327       f-&gt;do_code_blob(nmr-&gt;nm());</span>
<span class="line-removed">328     }</span>
<span class="line-removed">329   }</span>
330 }
331 
<span class="line-removed">332 ShenandoahNMethod::ShenandoahNMethod(nmethod* nm, GrowableArray&lt;oop*&gt;* oops) {</span>
<span class="line-removed">333   _nm = nm;</span>
<span class="line-removed">334   _oops = NEW_C_HEAP_ARRAY(oop*, oops-&gt;length(), mtGC);</span>
<span class="line-removed">335   _oops_count = oops-&gt;length();</span>
<span class="line-removed">336   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">337     _oops[c] = oops-&gt;at(c);</span>
<span class="line-removed">338   }</span>
<span class="line-removed">339 }</span>
<span class="line-removed">340 </span>
<span class="line-removed">341 ShenandoahNMethod::~ShenandoahNMethod() {</span>
<span class="line-removed">342   if (_oops != NULL) {</span>
<span class="line-removed">343     FREE_C_HEAP_ARRAY(oop*, _oops);</span>
<span class="line-removed">344   }</span>
<span class="line-removed">345 }</span>
<span class="line-removed">346 </span>
<span class="line-removed">347 bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {</span>
<span class="line-removed">348   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">349     oop o = RawAccess&lt;&gt;::oop_load(_oops[c]);</span>
<span class="line-removed">350     if (heap-&gt;in_collection_set(o)) {</span>
<span class="line-removed">351       return true;</span>
<span class="line-removed">352     }</span>
<span class="line-removed">353   }</span>
<span class="line-removed">354   return false;</span>
<span class="line-removed">355 }</span>
<span class="line-removed">356 </span>
<span class="line-removed">357 #ifdef ASSERT</span>
<span class="line-removed">358 void ShenandoahNMethod::assert_alive_and_correct() {</span>
<span class="line-removed">359   assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);</span>
<span class="line-removed">360   assert(_oops_count &gt; 0, &quot;should have filtered nmethods without oops before&quot;);</span>
<span class="line-removed">361   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-removed">362   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">363     oop *loc = _oops[c];</span>
<span class="line-removed">364     assert(_nm-&gt;code_contains((address) loc) || _nm-&gt;oops_contains(loc), &quot;nmethod should contain the oop*&quot;);</span>
<span class="line-removed">365     oop o = RawAccess&lt;&gt;::oop_load(loc);</span>
<span class="line-removed">366     shenandoah_assert_correct_except(loc, o, o == NULL || heap-&gt;is_full_gc_move_in_progress());</span>
<span class="line-removed">367   }</span>
<span class="line-removed">368 }</span>
<span class="line-removed">369 </span>
<span class="line-removed">370 void ShenandoahNMethod::assert_same_oops(GrowableArray&lt;oop*&gt;* oops) {</span>
<span class="line-removed">371   assert(_oops_count == oops-&gt;length(), &quot;should have the same number of oop*&quot;);</span>
<span class="line-removed">372   for (int c = 0; c &lt; _oops_count; c++) {</span>
<span class="line-removed">373     assert(_oops[c] == oops-&gt;at(c), &quot;should be the same oop*&quot;);</span>
<span class="line-removed">374   }</span>
<span class="line-removed">375 }</span>
<span class="line-removed">376 #endif</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
<span class="line-added"> 27 #include &quot;code/icBuffer.hpp&quot;</span>
 28 #include &quot;code/nmethod.hpp&quot;

 29 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shenandoah/shenandoahEvacOOMHandler.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shenandoah/shenandoahNMethod.inline.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;</span>
 34 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 35 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 36 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 38 
 39 ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps) {
 40   _length = heaps-&gt;length();
 41   _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);
 42   for (int h = 0; h &lt; _length; h++) {
 43     _iters[h] = ShenandoahParallelCodeHeapIterator(heaps-&gt;at(h));
 44   }
 45 }
 46 
 47 ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {
 48   FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);
 49 }
 50 
 51 void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {
 52   for (int c = 0; c &lt; _length; c++) {
 53     _iters[c].parallel_blobs_do(f);
 54   }
 55 }
 56 
 57 ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :
</pre>
<hr />
<pre>
 70    * next attempt without processing.
 71    *
 72    * Late threads would return immediately if iterator is finished.
 73    */
 74 
 75   if (_finished) {
 76     return;
 77   }
 78 
 79   int stride = 256; // educated guess
 80   int stride_mask = stride - 1;
 81   assert (is_power_of_2(stride), &quot;sanity&quot;);
 82 
 83   int count = 0;
 84   bool process_block = true;
 85 
 86   for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != NULL; cb = CodeCache::next_blob(_heap, cb)) {
 87     int current = count++;
 88     if ((current &amp; stride_mask) == 0) {
 89       process_block = (current &gt;= _claimed_idx) &amp;&amp;
<span class="line-modified"> 90                       (Atomic::cmpxchg(&amp;_claimed_idx, current, current + stride) == current);</span>
 91     }
 92     if (process_block) {
 93       if (cb-&gt;is_alive()) {
 94         f-&gt;do_code_blob(cb);
 95 #ifdef ASSERT
 96         if (cb-&gt;is_nmethod())
 97           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 98 #endif
 99       }
100     }
101   }
102 
103   _finished = true;
104 }
105 
<span class="line-modified">106 ShenandoahNMethodTable* ShenandoahCodeRoots::_nmethod_table;</span>
<span class="line-modified">107 int ShenandoahCodeRoots::_disarmed_value = 1;</span>





108 
<span class="line-modified">109 void ShenandoahCodeRoots::initialize() {</span>
<span class="line-modified">110   _nmethod_table = new ShenandoahNMethodTable();</span>
<span class="line-modified">111 }</span>



















112 
<span class="line-modified">113 void ShenandoahCodeRoots::register_nmethod(nmethod* nm) {</span>
<span class="line-modified">114   switch (ShenandoahCodeRootsStyle) {</span>
<span class="line-modified">115     case 0:</span>
<span class="line-modified">116     case 1:</span>
<span class="line-modified">117       break;</span>
<span class="line-modified">118     case 2: {</span>
<span class="line-modified">119       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">120       _nmethod_table-&gt;register_nmethod(nm);</span>
<span class="line-modified">121       break;</span>





122     }
<span class="line-added">123     default:</span>
<span class="line-added">124       ShouldNotReachHere();</span>
125   }
















126 }
127 
<span class="line-modified">128 void ShenandoahCodeRoots::unregister_nmethod(nmethod* nm) {</span>
129   switch (ShenandoahCodeRootsStyle) {
130     case 0:
131     case 1: {



132       break;
133     }
134     case 2: {
<span class="line-modified">135       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">136       _nmethod_table-&gt;unregister_nmethod(nm);</span>




















137       break;
138     }
139     default:
140       ShouldNotReachHere();
141   }
<span class="line-modified">142 }</span>
143 
<span class="line-modified">144 void ShenandoahCodeRoots::flush_nmethod(nmethod* nm) {</span>
145   switch (ShenandoahCodeRootsStyle) {
146     case 0:
147     case 1: {
148       break;
149     }
150     case 2: {
<span class="line-modified">151       assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-modified">152       _nmethod_table-&gt;flush_nmethod(nm);</span>











153       break;
154     }
155     default:
156       ShouldNotReachHere();
157   }
158 }
159 
<span class="line-added">160 void ShenandoahCodeRoots::arm_nmethods() {</span>
<span class="line-added">161   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at a safepoint&quot;);</span>
<span class="line-added">162   _disarmed_value ++;</span>
<span class="line-added">163   // 0 is reserved for new nmethod</span>
<span class="line-added">164   if (_disarmed_value == 0) {</span>
<span class="line-added">165     _disarmed_value = 1;</span>
<span class="line-added">166   }</span>
<span class="line-added">167 </span>
<span class="line-added">168   JavaThreadIteratorWithHandle jtiwh;</span>
<span class="line-added">169   for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {</span>
<span class="line-added">170     ShenandoahThreadLocalData::set_disarmed_value(thr, _disarmed_value);</span>
<span class="line-added">171   }</span>
<span class="line-added">172 }</span>
<span class="line-added">173 </span>
<span class="line-added">174 class ShenandoahNMethodUnlinkClosure : public NMethodClosure {</span>
<span class="line-added">175 private:</span>
<span class="line-added">176   bool            _unloading_occurred;</span>
<span class="line-added">177   volatile bool   _failed;</span>
<span class="line-added">178   ShenandoahHeap* _heap;</span>
<span class="line-added">179 </span>
<span class="line-added">180   void set_failed() {</span>
<span class="line-added">181     Atomic::store(&amp;_failed, true);</span>
<span class="line-added">182   }</span>
<span class="line-added">183 </span>
<span class="line-added">184    void unlink(nmethod* nm) {</span>
<span class="line-added">185      // Unlinking of the dependencies must happen before the</span>
<span class="line-added">186      // handshake separating unlink and purge.</span>
<span class="line-added">187      nm-&gt;flush_dependencies(false /* delete_immediately */);</span>
<span class="line-added">188 </span>
<span class="line-added">189      // unlink_from_method will take the CompiledMethod_lock.</span>
<span class="line-added">190      // In this case we don&#39;t strictly need it when unlinking nmethods from</span>
<span class="line-added">191      // the Method, because it is only concurrently unlinked by</span>
<span class="line-added">192      // the entry barrier, which acquires the per nmethod lock.</span>
<span class="line-added">193      nm-&gt;unlink_from_method();</span>
<span class="line-added">194 </span>
<span class="line-added">195      if (nm-&gt;is_osr_method()) {</span>
<span class="line-added">196        // Invalidate the osr nmethod only once</span>
<span class="line-added">197        nm-&gt;invalidate_osr_method();</span>
<span class="line-added">198      }</span>
<span class="line-added">199    }</span>
<span class="line-added">200 public:</span>
<span class="line-added">201   ShenandoahNMethodUnlinkClosure(bool unloading_occurred) :</span>
<span class="line-added">202       _unloading_occurred(unloading_occurred),</span>
<span class="line-added">203       _failed(false),</span>
<span class="line-added">204       _heap(ShenandoahHeap::heap()) {}</span>
<span class="line-added">205 </span>
<span class="line-added">206   virtual void do_nmethod(nmethod* nm) {</span>
<span class="line-added">207     assert(_heap-&gt;is_concurrent_root_in_progress(), &quot;Only this phase&quot;);</span>
<span class="line-added">208     if (failed()) {</span>
<span class="line-added">209       return;</span>
<span class="line-added">210     }</span>
<span class="line-added">211 </span>
<span class="line-added">212     ShenandoahNMethod* nm_data = ShenandoahNMethod::gc_data(nm);</span>
<span class="line-added">213     assert(!nm_data-&gt;is_unregistered(), &quot;Should not see unregistered entry&quot;);</span>
<span class="line-added">214 </span>
<span class="line-added">215     if (!nm-&gt;is_alive()) {</span>
<span class="line-added">216       return;</span>
<span class="line-added">217     }</span>
<span class="line-added">218 </span>
<span class="line-added">219     if (nm-&gt;is_unloading()) {</span>
<span class="line-added">220       ShenandoahReentrantLocker locker(nm_data-&gt;lock());</span>
<span class="line-added">221       unlink(nm);</span>
<span class="line-added">222       return;</span>
<span class="line-added">223     }</span>
<span class="line-added">224 </span>
<span class="line-added">225     ShenandoahReentrantLocker locker(nm_data-&gt;lock());</span>
<span class="line-added">226 </span>
<span class="line-added">227     // Heal oops and disarm</span>
<span class="line-added">228     if (_heap-&gt;is_evacuation_in_progress()) {</span>
<span class="line-added">229       ShenandoahNMethod::heal_nmethod(nm);</span>
<span class="line-added">230     }</span>
<span class="line-added">231     ShenandoahNMethod::disarm_nmethod(nm);</span>
<span class="line-added">232 </span>
<span class="line-added">233     // Clear compiled ICs and exception caches</span>
<span class="line-added">234     if (!nm-&gt;unload_nmethod_caches(_unloading_occurred)) {</span>
<span class="line-added">235       set_failed();</span>
<span class="line-added">236     }</span>
<span class="line-added">237   }</span>
<span class="line-added">238 </span>
<span class="line-added">239   bool failed() const {</span>
<span class="line-added">240     return Atomic::load(&amp;_failed);</span>
<span class="line-added">241   }</span>
<span class="line-added">242 };</span>
<span class="line-added">243 </span>
<span class="line-added">244 class ShenandoahUnlinkTask : public AbstractGangTask {</span>
<span class="line-added">245 private:</span>
<span class="line-added">246   ShenandoahNMethodUnlinkClosure      _cl;</span>
<span class="line-added">247   ICRefillVerifier*                   _verifier;</span>
<span class="line-added">248   ShenandoahConcurrentNMethodIterator _iterator;</span>
<span class="line-added">249 </span>
<span class="line-added">250 public:</span>
<span class="line-added">251   ShenandoahUnlinkTask(bool unloading_occurred, ICRefillVerifier* verifier) :</span>
<span class="line-added">252     AbstractGangTask(&quot;ShenandoahNMethodUnlinkTask&quot;),</span>
<span class="line-added">253     _cl(unloading_occurred),</span>
<span class="line-added">254     _verifier(verifier),</span>
<span class="line-added">255     _iterator(ShenandoahCodeRoots::table()) {</span>
<span class="line-added">256     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">257     _iterator.nmethods_do_begin();</span>
<span class="line-added">258   }</span>
<span class="line-added">259 </span>
<span class="line-added">260   ~ShenandoahUnlinkTask() {</span>
<span class="line-added">261     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">262     _iterator.nmethods_do_end();</span>
<span class="line-added">263   }</span>
<span class="line-added">264 </span>
<span class="line-added">265   virtual void work(uint worker_id) {</span>
<span class="line-added">266     ICRefillVerifierMark mark(_verifier);</span>
<span class="line-added">267     _iterator.nmethods_do(&amp;_cl);</span>
<span class="line-added">268   }</span>
<span class="line-added">269 </span>
<span class="line-added">270   bool success() const {</span>
<span class="line-added">271     return !_cl.failed();</span>
<span class="line-added">272   }</span>
<span class="line-added">273 };</span>
<span class="line-added">274 </span>
<span class="line-added">275 void ShenandoahCodeRoots::unlink(WorkGang* workers, bool unloading_occurred) {</span>
<span class="line-added">276   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),</span>
<span class="line-added">277          &quot;Only when running concurrent class unloading&quot;);</span>
<span class="line-added">278 </span>
<span class="line-added">279   for (;;) {</span>
<span class="line-added">280     ICRefillVerifier verifier;</span>
<span class="line-added">281 </span>
<span class="line-added">282     {</span>
<span class="line-added">283       ShenandoahUnlinkTask task(unloading_occurred, &amp;verifier);</span>
<span class="line-added">284       workers-&gt;run_task(&amp;task);</span>
<span class="line-added">285       if (task.success()) {</span>
<span class="line-added">286         return;</span>
<span class="line-added">287       }</span>
<span class="line-added">288     }</span>
<span class="line-added">289 </span>
<span class="line-added">290     // Cleaning failed because we ran out of transitional IC stubs,</span>
<span class="line-added">291     // so we have to refill and try again. Refilling requires taking</span>
<span class="line-added">292     // a safepoint, so we temporarily leave the suspendible thread set.</span>
<span class="line-added">293     SuspendibleThreadSetLeaver sts;</span>
<span class="line-added">294     InlineCacheBuffer::refill_ic_stubs();</span>
<span class="line-added">295   }</span>
<span class="line-added">296 }</span>
<span class="line-added">297 </span>
<span class="line-added">298 class ShenandoahNMethodPurgeClosure : public NMethodClosure {</span>
<span class="line-added">299 public:</span>
<span class="line-added">300   virtual void do_nmethod(nmethod* nm) {</span>
<span class="line-added">301     if (nm-&gt;is_alive() &amp;&amp; nm-&gt;is_unloading()) {</span>
<span class="line-added">302       nm-&gt;make_unloaded();</span>
<span class="line-added">303     }</span>
<span class="line-added">304   }</span>
<span class="line-added">305 };</span>
<span class="line-added">306 </span>
<span class="line-added">307 class ShenandoahNMethodPurgeTask : public AbstractGangTask {</span>
<span class="line-added">308 private:</span>
<span class="line-added">309   ShenandoahNMethodPurgeClosure       _cl;</span>
<span class="line-added">310   ShenandoahConcurrentNMethodIterator _iterator;</span>
<span class="line-added">311 </span>
<span class="line-added">312 public:</span>
<span class="line-added">313   ShenandoahNMethodPurgeTask() :</span>
<span class="line-added">314     AbstractGangTask(&quot;ShenandoahNMethodPurgeTask&quot;),</span>
<span class="line-added">315     _cl(),</span>
<span class="line-added">316     _iterator(ShenandoahCodeRoots::table()) {</span>
<span class="line-added">317     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">318     _iterator.nmethods_do_begin();</span>
<span class="line-added">319   }</span>
<span class="line-added">320 </span>
<span class="line-added">321   ~ShenandoahNMethodPurgeTask() {</span>
<span class="line-added">322     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">323     _iterator.nmethods_do_end();</span>
<span class="line-added">324   }</span>
<span class="line-added">325 </span>
<span class="line-added">326   virtual void work(uint worker_id) {</span>
<span class="line-added">327     _iterator.nmethods_do(&amp;_cl);</span>
<span class="line-added">328   }</span>
<span class="line-added">329 };</span>
<span class="line-added">330 </span>
<span class="line-added">331 void ShenandoahCodeRoots::purge(WorkGang* workers) {</span>
<span class="line-added">332   assert(ShenandoahConcurrentRoots::should_do_concurrent_class_unloading(),</span>
<span class="line-added">333          &quot;Only when running concurrent class unloading&quot;);</span>
<span class="line-added">334 </span>
<span class="line-added">335   ShenandoahNMethodPurgeTask task;</span>
<span class="line-added">336   workers-&gt;run_task(&amp;task);</span>
<span class="line-added">337 }</span>
<span class="line-added">338 </span>
339 ShenandoahCodeRootsIterator::ShenandoahCodeRootsIterator() :

340         _par_iterator(CodeCache::heaps()),
<span class="line-modified">341         _table_snapshot(NULL) {</span>
342   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
343   assert(!Thread::current()-&gt;is_Worker_thread(), &quot;Should not be acquired by workers&quot;);
344   switch (ShenandoahCodeRootsStyle) {
345     case 0:
346     case 1: {
347       // No need to do anything here
348       break;
349     }
350     case 2: {
<span class="line-modified">351       CodeCache_lock-&gt;lock_without_safepoint_check();</span>
<span class="line-added">352       _table_snapshot = ShenandoahCodeRoots::table()-&gt;snapshot_for_iteration();</span>
353       break;
354     }
355     default:
356       ShouldNotReachHere();
357   }
358 }
359 
360 ShenandoahCodeRootsIterator::~ShenandoahCodeRootsIterator() {
361   switch (ShenandoahCodeRootsStyle) {
362     case 0:
363     case 1: {
364       // No need to do anything here
365       break;
366     }
367     case 2: {
<span class="line-modified">368       ShenandoahCodeRoots::table()-&gt;finish_iteration(_table_snapshot);</span>
<span class="line-added">369       _table_snapshot = NULL;</span>
<span class="line-added">370       CodeCache_lock-&gt;unlock();</span>
371       break;
372     }
373     default:
374       ShouldNotReachHere();
375   }
376 }
377 
378 template&lt;bool CSET_FILTER&gt;
379 void ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do(CodeBlobClosure *f) {
380   switch (ShenandoahCodeRootsStyle) {
381     case 0: {
382       if (_seq_claimed.try_set()) {
383         CodeCache::blobs_do(f);
384       }
385       break;
386     }
387     case 1: {
388       _par_iterator.parallel_blobs_do(f);
389       break;
390     }
391     case 2: {
392       ShenandoahCodeRootsIterator::fast_parallel_blobs_do&lt;CSET_FILTER&gt;(f);
393       break;
394     }
395     default:
396       ShouldNotReachHere();
397   }
398 }
399 








400 void ShenandoahAllCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
401   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;false&gt;(f);
402 }
403 
404 void ShenandoahCsetCodeRootsIterator::possibly_parallel_blobs_do(CodeBlobClosure *f) {
405   ShenandoahCodeRootsIterator::dispatch_parallel_blobs_do&lt;true&gt;(f);
406 }
407 
408 template &lt;bool CSET_FILTER&gt;
409 void ShenandoahCodeRootsIterator::fast_parallel_blobs_do(CodeBlobClosure *f) {
410   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint&quot;);
<span class="line-modified">411   assert(_table_snapshot != NULL, &quot;Sanity&quot;);</span>
<span class="line-modified">412   _table_snapshot-&gt;parallel_blobs_do&lt;CSET_FILTER&gt;(f);</span>





















413 }
414 













































</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetAssembler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCodeRoots.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
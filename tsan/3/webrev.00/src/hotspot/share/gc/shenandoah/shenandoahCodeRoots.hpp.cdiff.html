<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCodeRoots.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCollectionSet.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahCodeRoots.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,16 ***</span>
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
  
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  
  class ShenandoahHeap;
  class ShenandoahHeapRegion;
<span class="line-removed">- class ShenandoahCodeRootsLock;</span>
  
  class ShenandoahParallelCodeHeapIterator {
    friend class CodeCache;
  private:
    CodeHeap*     _heap;
<span class="line-new-header">--- 25,18 ---</span>
  #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
  #define SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
  
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahSharedVariables.hpp&quot;
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahLock.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shenandoah/shenandoahNMethod.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
<span class="line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  
  class ShenandoahHeap;
  class ShenandoahHeapRegion;
  
  class ShenandoahParallelCodeHeapIterator {
    friend class CodeCache;
  private:
    CodeHeap*     _heap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,53 ***</span>
  class ShenandoahParallelCodeCacheIterator {
    friend class CodeCache;
  private:
    ShenandoahParallelCodeHeapIterator* _iters;
    int                       _length;
  public:
    ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps);
    ~ShenandoahParallelCodeCacheIterator();
    void parallel_blobs_do(CodeBlobClosure* f);
  };
  
<span class="line-removed">- // ShenandoahNMethod tuple records the internal locations of oop slots within the nmethod.</span>
<span class="line-removed">- // This allows us to quickly scan the oops without doing the nmethod-internal scans, that</span>
<span class="line-removed">- // sometimes involves parsing the machine code. Note it does not record the oops themselves,</span>
<span class="line-removed">- // because it would then require handling these tuples as the new class of roots.</span>
<span class="line-removed">- class ShenandoahNMethod : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   nmethod* _nm;</span>
<span class="line-removed">-   oop**    _oops;</span>
<span class="line-removed">-   int      _oops_count;</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ShenandoahNMethod(nmethod *nm, GrowableArray&lt;oop*&gt;* oops);</span>
<span class="line-removed">-   ~ShenandoahNMethod();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   nmethod* nm() {</span>
<span class="line-removed">-     return _nm;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool has_cset_oops(ShenandoahHeap* heap);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void assert_alive_and_correct() NOT_DEBUG_RETURN;</span>
<span class="line-removed">-   void assert_same_oops(GrowableArray&lt;oop*&gt;* oops) NOT_DEBUG_RETURN;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static bool find_with_nmethod(void* nm, ShenandoahNMethod* other) {</span>
<span class="line-removed">-     return other-&gt;_nm == nm;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  class ShenandoahCodeRootsIterator {
    friend class ShenandoahCodeRoots;
  protected:
<span class="line-removed">-   ShenandoahHeap* _heap;</span>
    ShenandoahParallelCodeCacheIterator _par_iterator;
    ShenandoahSharedFlag _seq_claimed;
<span class="line-modified">!   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile size_t));</span>
<span class="line-modified">!   volatile size_t _claimed;</span>
<span class="line-removed">-   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
  protected:
    ShenandoahCodeRootsIterator();
    ~ShenandoahCodeRootsIterator();
  
    template&lt;bool CSET_FILTER&gt;
<span class="line-new-header">--- 52,26 ---</span>
  class ShenandoahParallelCodeCacheIterator {
    friend class CodeCache;
  private:
    ShenandoahParallelCodeHeapIterator* _iters;
    int                       _length;
<span class="line-added">+ </span>
<span class="line-added">+   NONCOPYABLE(ShenandoahParallelCodeCacheIterator);</span>
<span class="line-added">+ </span>
  public:
    ShenandoahParallelCodeCacheIterator(const GrowableArray&lt;CodeHeap*&gt;* heaps);
    ~ShenandoahParallelCodeCacheIterator();
    void parallel_blobs_do(CodeBlobClosure* f);
  };
  
  class ShenandoahCodeRootsIterator {
    friend class ShenandoahCodeRoots;
  protected:
    ShenandoahParallelCodeCacheIterator _par_iterator;
    ShenandoahSharedFlag _seq_claimed;
<span class="line-modified">!   ShenandoahNMethodTableSnapshot* _table_snapshot;</span>
<span class="line-modified">! </span>
  protected:
    ShenandoahCodeRootsIterator();
    ~ShenandoahCodeRootsIterator();
  
    template&lt;bool CSET_FILTER&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,86 ***</span>
  public:
    ShenandoahCsetCodeRootsIterator() : ShenandoahCodeRootsIterator() {};
    void possibly_parallel_blobs_do(CodeBlobClosure* f);
  };
  
<span class="line-modified">! class ShenandoahCodeRoots : public CHeapObj&lt;mtGC&gt; {</span>
    friend class ShenandoahHeap;
<span class="line-removed">-   friend class ShenandoahCodeRootsLock;</span>
    friend class ShenandoahCodeRootsIterator;
  
  public:
    static void initialize();
<span class="line-modified">!   static void add_nmethod(nmethod* nm);</span>
<span class="line-modified">!   static void remove_nmethod(nmethod* nm);</span>
<span class="line-modified">! </span>
<span class="line-removed">-   /**</span>
<span class="line-removed">-    * Provides the iterator over all nmethods in the code cache that have oops.</span>
<span class="line-removed">-    * @return</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   static ShenandoahAllCodeRootsIterator iterator();</span>
  
<span class="line-modified">!   /**</span>
<span class="line-modified">!    * Provides the iterator over nmethods that have at least one oop in collection set.</span>
<span class="line-removed">-    * @return</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   static ShenandoahCsetCodeRootsIterator cset_iterator();</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   struct PaddedLock {</span>
<span class="line-removed">-     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));</span>
<span class="line-removed">-     volatile int _lock;</span>
<span class="line-removed">-     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static PaddedLock _recorded_nms_lock;</span>
<span class="line-removed">-   static GrowableArray&lt;ShenandoahNMethod*&gt;* _recorded_nms;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static void acquire_lock(bool write) {</span>
<span class="line-removed">-     volatile int* loc = &amp;_recorded_nms_lock._lock;</span>
<span class="line-removed">-     if (write) {</span>
<span class="line-removed">-       while ((OrderAccess::load_acquire(loc) != 0) ||</span>
<span class="line-removed">-              Atomic::cmpxchg(-1, loc, 0) != 0) {</span>
<span class="line-removed">-         SpinPause();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       assert (*loc == -1, &quot;acquired for write&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       while (true) {</span>
<span class="line-removed">-         int cur = OrderAccess::load_acquire(loc);</span>
<span class="line-removed">-         if (cur &gt;= 0) {</span>
<span class="line-removed">-           if (Atomic::cmpxchg(cur + 1, loc, cur) == cur) {</span>
<span class="line-removed">-             // Success!</span>
<span class="line-removed">-             assert (*loc &gt; 0, &quot;acquired for read&quot;);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         SpinPause();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
    }
  
<span class="line-modified">!   static void release_lock(bool write) {</span>
<span class="line-modified">!     volatile int* loc = &amp;ShenandoahCodeRoots::_recorded_nms_lock._lock;</span>
<span class="line-modified">!     if (write) {</span>
<span class="line-modified">!       OrderAccess::release_store_fence(loc, 0);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       Atomic::dec(loc);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-removed">- // Very simple unranked read-write lock</span>
<span class="line-removed">- class ShenandoahCodeRootsLock : public StackObj {</span>
<span class="line-removed">-   friend class ShenandoahCodeRoots;</span>
  private:
<span class="line-modified">!   const bool _write;</span>
<span class="line-modified">! public:</span>
<span class="line-removed">-   ShenandoahCodeRootsLock(bool write) : _write(write) {</span>
<span class="line-removed">-     ShenandoahCodeRoots::acquire_lock(write);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ~ShenandoahCodeRootsLock() {</span>
<span class="line-removed">-     ShenandoahCodeRoots::release_lock(_write);</span>
<span class="line-removed">-   }</span>
  };
  
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
<span class="line-new-header">--- 91,32 ---</span>
  public:
    ShenandoahCsetCodeRootsIterator() : ShenandoahCodeRootsIterator() {};
    void possibly_parallel_blobs_do(CodeBlobClosure* f);
  };
  
<span class="line-modified">! class ShenandoahCodeRoots : public AllStatic {</span>
    friend class ShenandoahHeap;
    friend class ShenandoahCodeRootsIterator;
  
  public:
    static void initialize();
<span class="line-modified">!   static void register_nmethod(nmethod* nm);</span>
<span class="line-modified">!   static void unregister_nmethod(nmethod* nm);</span>
<span class="line-modified">!   static void flush_nmethod(nmethod* nm);</span>
  
<span class="line-modified">!   static ShenandoahNMethodTable* table() {</span>
<span class="line-modified">!     return _nmethod_table;</span>
    }
  
<span class="line-modified">!   // Concurrent nmethod unloading support</span>
<span class="line-modified">!   static void unlink(WorkGang* workers, bool unloading_occurred);</span>
<span class="line-modified">!   static void purge(WorkGang* workers);</span>
<span class="line-modified">!   static void arm_nmethods();</span>
<span class="line-modified">!   static int  disarmed_value()         { return _disarmed_value; }</span>
<span class="line-modified">!   static int* disarmed_value_address() { return &amp;_disarmed_value; }</span>
  
  private:
<span class="line-modified">!   static ShenandoahNMethodTable* _nmethod_table;</span>
<span class="line-modified">!   static int                     _disarmed_value;</span>
  };
  
  #endif // SHARE_GC_SHENANDOAH_SHENANDOAHCODEROOTS_HPP
</pre>
<center><a href="shenandoahCodeRoots.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahCollectionSet.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
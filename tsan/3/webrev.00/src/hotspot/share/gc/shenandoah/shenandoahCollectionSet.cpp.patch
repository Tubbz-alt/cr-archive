diff a/src/hotspot/share/gc/shenandoah/shenandoahCollectionSet.cpp b/src/hotspot/share/gc/shenandoah/shenandoahCollectionSet.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahCollectionSet.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahCollectionSet.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -26,28 +27,58 @@
 #include "gc/shenandoah/shenandoahCollectionSet.hpp"
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahHeapRegionSet.hpp"
 #include "gc/shenandoah/shenandoahUtils.hpp"
 #include "runtime/atomic.hpp"
+#include "services/memTracker.hpp"
 #include "utilities/copy.hpp"
 
-ShenandoahCollectionSet::ShenandoahCollectionSet(ShenandoahHeap* heap, HeapWord* heap_base) :
+ShenandoahCollectionSet::ShenandoahCollectionSet(ShenandoahHeap* heap, char* heap_base, size_t size) :
   _map_size(heap->num_regions()),
   _region_size_bytes_shift(ShenandoahHeapRegion::region_size_bytes_shift()),
-  _cset_map(NEW_C_HEAP_ARRAY(jbyte, _map_size, mtGC)),
-  _biased_cset_map(_cset_map - ((uintx)heap_base >> _region_size_bytes_shift)),
+  _map_space(align_up(((uintx)heap_base + size) >> _region_size_bytes_shift, os::vm_allocation_granularity())),
+  _cset_map(_map_space.base() + ((uintx)heap_base >> _region_size_bytes_shift)),
+  _biased_cset_map(_map_space.base()),
   _heap(heap),
   _garbage(0),
   _live_data(0),
   _used(0),
   _region_count(0),
   _current_index(0) {
-  // Use 1-byte data type
-  STATIC_ASSERT(sizeof(jbyte) == 1);
 
-  // Initialize cset map
+  // The collection set map is reserved to cover the entire heap *and* zero addresses.
+  // This is needed to accept in-cset checks for both heap oops and NULLs, freeing
+  // high-performance code from checking for NULL first.
+  //
+  // Since heap_base can be far away, committing the entire map would waste memory.
+  // Therefore, we only commit the parts that are needed to operate: the heap view,
+  // and the zero page.
+  //
+  // Note: we could instead commit the entire map, and piggyback on OS virtual memory
+  // subsystem for mapping not-yet-written-to pages to a single physical backing page,
+  // but this is not guaranteed, and would confuse NMT and other memory accounting tools.
+
+  MemTracker::record_virtual_memory_type(_map_space.base(), mtGC);
+
+  size_t page_size = (size_t)os::vm_page_size();
+
+  if (!_map_space.special()) {
+    // Commit entire pages that cover the heap cset map.
+    char* bot_addr = align_down(_cset_map, page_size);
+    char* top_addr = align_up(_cset_map + _map_size, page_size);
+    os::commit_memory_or_exit(bot_addr, pointer_delta(top_addr, bot_addr, 1), false,
+                              "Unable to commit collection set bitmap: heap");
+
+    // Commit the zero page, if not yet covered by heap cset map.
+    if (bot_addr != _biased_cset_map) {
+      os::commit_memory_or_exit(_biased_cset_map, page_size, false,
+                                "Unable to commit collection set bitmap: zero page");
+    }
+  }
+
   Copy::zero_to_bytes(_cset_map, _map_size);
+  Copy::zero_to_bytes(_biased_cset_map, page_size);
 }
 
 void ShenandoahCollectionSet::add_region(ShenandoahHeapRegion* r) {
   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), "Must be at a safepoint");
   assert(Thread::current()->is_VM_thread(), "Must be VMThread");
@@ -114,11 +145,11 @@
   jint saved_current = _current_index;
   size_t index = (size_t)saved_current;
 
   while(index < num_regions) {
     if (is_in(index)) {
-      jint cur = Atomic::cmpxchg((jint)(index + 1), &_current_index, saved_current);
+      jint cur = Atomic::cmpxchg(&_current_index, saved_current, (jint)(index + 1));
       assert(cur >= (jint)saved_current, "Must move forward");
       if (cur == saved_current) {
         assert(is_in(index), "Invariant");
         return _heap->get_region(index);
       } else {

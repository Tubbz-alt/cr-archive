<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahConcurrentMark.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahControlThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2018, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="udiff-line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -35,10 +36,11 @@</span>
  #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  #include &quot;memory/iterator.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  
  ShenandoahControlThread::ShenandoahControlThread() :
    ConcurrentGCThread(),
    _alloc_failure_waiters_lock(Mutex::leaf, &quot;ShenandoahAllocFailureGC_lock&quot;, true, Monitor::_safepoint_check_always),
    _gc_waiters_lock(Mutex::leaf, &quot;ShenandoahRequestedGC_lock&quot;, true, Monitor::_safepoint_check_always),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,10 +68,14 @@</span>
  }
  
  void ShenandoahControlThread::run_service() {
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="udiff-line-added">+   GCMode default_mode = heap-&gt;is_traversal_mode() ?</span>
<span class="udiff-line-added">+                            concurrent_traversal : concurrent_normal;</span>
<span class="udiff-line-added">+   GCCause::Cause default_cause = heap-&gt;is_traversal_mode() ?</span>
<span class="udiff-line-added">+                            GCCause::_shenandoah_traversal_gc : GCCause::_shenandoah_concurrent_gc;</span>
    int sleep = ShenandoahControlIntervalMin;
  
    double last_shrink_time = os::elapsedTime();
    double last_sleep_adjust_time = os::elapsedTime();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,11 +92,11 @@</span>
      bool alloc_failure_pending = _alloc_failure_gc.is_set();
      bool explicit_gc_requested = _gc_requested.is_set() &amp;&amp;  is_explicit_gc(_requested_gc_cause);
      bool implicit_gc_requested = _gc_requested.is_set() &amp;&amp; !is_explicit_gc(_requested_gc_cause);
  
      // This control loop iteration have seen this much allocations.
<span class="udiff-line-modified-removed">-     size_t allocs_seen = Atomic::xchg&lt;size_t&gt;(0, &amp;_allocs_seen);</span>
<span class="udiff-line-modified-added">+     size_t allocs_seen = Atomic::xchg(&amp;_allocs_seen, (size_t)0);</span>
  
      // Choose which GC mode to run in. The block below should select a single mode.
      GCMode mode = none;
      GCCause::Cause cause = GCCause::_last_gc_cause;
      ShenandoahHeap::ShenandoahDegenPoint degen_point = ShenandoahHeap::_degenerated_unset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,15 +127,11 @@</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ExplicitGCInvokesConcurrent) {
          policy-&gt;record_explicit_to_concurrent();
<span class="udiff-line-modified-removed">-         if (heuristics-&gt;can_do_traversal_gc()) {</span>
<span class="udiff-line-removed">-           mode = concurrent_traversal;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           mode = concurrent_normal;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         mode = default_mode;</span>
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_explicit_to_full();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141,31 +143,24 @@</span>
  
        heuristics-&gt;record_requested_gc();
  
        if (ShenandoahImplicitGCInvokesConcurrent) {
          policy-&gt;record_implicit_to_concurrent();
<span class="udiff-line-modified-removed">-         if (heuristics-&gt;can_do_traversal_gc()) {</span>
<span class="udiff-line-removed">-           mode = concurrent_traversal;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           mode = concurrent_normal;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         mode = default_mode;</span>
  
          // Unload and clean up everything
          heap-&gt;set_process_references(heuristics-&gt;can_process_references());
          heap-&gt;set_unload_classes(heuristics-&gt;can_unload_classes());
        } else {
          policy-&gt;record_implicit_to_full();
          mode = stw_full;
        }
      } else {
        // Potential normal cycle: ask heuristics if it wants to act
<span class="udiff-line-modified-removed">-       if (heuristics-&gt;should_start_traversal_gc()) {</span>
<span class="udiff-line-modified-removed">-         mode = concurrent_traversal;</span>
<span class="udiff-line-modified-removed">-         cause = GCCause::_shenandoah_traversal_gc;</span>
<span class="udiff-line-removed">-       } else if (heuristics-&gt;should_start_normal_gc()) {</span>
<span class="udiff-line-removed">-         mode = concurrent_normal;</span>
<span class="udiff-line-removed">-         cause = GCCause::_shenandoah_concurrent_gc;</span>
<span class="udiff-line-modified-added">+       if (heuristics-&gt;should_start_gc()) {</span>
<span class="udiff-line-modified-added">+         mode = default_mode;</span>
<span class="udiff-line-modified-added">+         cause = default_cause;</span>
        }
  
        // Ask policy if this cycle wants to process references or unload classes
        heap-&gt;set_process_references(heuristics-&gt;should_process_references());
        heap-&gt;set_unload_classes(heuristics-&gt;should_unload_classes());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -375,10 +370,13 @@</span>
    heap-&gt;entry_preclean();
  
    // Complete marking under STW, and start evacuation
    heap-&gt;vmop_entry_final_mark();
  
<span class="udiff-line-added">+   // Evacuate concurrent roots</span>
<span class="udiff-line-added">+   heap-&gt;entry_roots();</span>
<span class="udiff-line-added">+ </span>
    // Final mark might have reclaimed some immediate garbage, kick cleanup to reclaim
    // the space. This would be the last action if there is nothing to evacuate.
    heap-&gt;entry_cleanup();
  
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -460,13 +458,15 @@</span>
  }
  
  void ShenandoahControlThread::service_uncommit(double shrink_before) {
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="udiff-line-modified-removed">-   // Scan through the heap and determine if there is work to do. This avoids taking</span>
<span class="udiff-line-modified-removed">-   // heap lock if there is no work available, avoids spamming logs with superfluous</span>
<span class="udiff-line-modified-removed">-   // logging messages, and minimises the amount of work while locks are taken.</span>
<span class="udiff-line-modified-added">+   // Determine if there is work to do. This avoids taking heap lock if there is</span>
<span class="udiff-line-modified-added">+   // no work available, avoids spamming logs with superfluous logging messages,</span>
<span class="udiff-line-modified-added">+   // and minimises the amount of work while locks are taken.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (heap-&gt;committed() &lt;= heap-&gt;min_capacity()) return;</span>
  
    bool has_work = false;
    for (size_t i = 0; i &lt; heap-&gt;num_regions(); i++) {
      ShenandoahHeapRegion *r = heap-&gt;get_region(i);
      if (r-&gt;is_empty_committed() &amp;&amp; (r-&gt;empty_time() &lt; shrink_before)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -504,11 +504,11 @@</span>
  }
  
  void ShenandoahControlThread::handle_requested_gc(GCCause::Cause cause) {
    _requested_gc_cause = cause;
    _gc_requested.set();
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(&amp;_gc_waiters_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(&amp;_gc_waiters_lock);</span>
    while (_gc_requested.is_set()) {
      ml.wait();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -524,11 +524,11 @@</span>
  
      // Now that alloc failure GC is scheduled, we can abort everything else
      heap-&gt;cancel_gc(GCCause::_allocation_failure);
    }
  
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(&amp;_alloc_failure_waiters_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(&amp;_alloc_failure_waiters_lock);</span>
    while (is_alloc_failure_gc()) {
      ml.wait();
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -545,11 +545,11 @@</span>
    heap-&gt;cancel_gc(GCCause::_shenandoah_allocation_failure_evac);
  }
  
  void ShenandoahControlThread::notify_alloc_failure_waiters() {
    _alloc_failure_gc.unset();
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(&amp;_alloc_failure_waiters_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(&amp;_alloc_failure_waiters_lock);</span>
    ml.notify_all();
  }
  
  bool ShenandoahControlThread::try_set_alloc_failure_gc() {
    return _alloc_failure_gc.try_set();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,11 +559,11 @@</span>
    return _alloc_failure_gc.is_set();
  }
  
  void ShenandoahControlThread::notify_gc_waiters() {
    _gc_requested.unset();
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(&amp;_gc_waiters_lock);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(&amp;_gc_waiters_lock);</span>
    ml.notify_all();
  }
  
  void ShenandoahControlThread::handle_counters_update() {
    if (_do_counters_update.is_set()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,11 +593,11 @@</span>
    }
  }
  
  void ShenandoahControlThread::pacing_notify_alloc(size_t words) {
    assert(ShenandoahPacing, &quot;should only call when pacing is enabled&quot;);
<span class="udiff-line-modified-removed">-   Atomic::add(words, &amp;_allocs_seen);</span>
<span class="udiff-line-modified-added">+   Atomic::add(&amp;_allocs_seen, words);</span>
  }
  
  void ShenandoahControlThread::set_forced_counters_update(bool value) {
    _force_counters_update.set_cond(value);
  }
</pre>
<center><a href="shenandoahConcurrentMark.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
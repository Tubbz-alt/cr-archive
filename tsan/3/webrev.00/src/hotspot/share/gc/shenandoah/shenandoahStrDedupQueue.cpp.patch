diff a/src/hotspot/share/gc/shenandoah/shenandoahStrDedupQueue.cpp b/src/hotspot/share/gc/shenandoah/shenandoahStrDedupQueue.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahStrDedupQueue.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahStrDedupQueue.cpp
@@ -1,7 +1,8 @@
 /*
  * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -46,31 +47,31 @@
     _producer_queues[index] = NULL;
   }
 }
 
 ShenandoahStrDedupQueue::~ShenandoahStrDedupQueue() {
-  MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
   for (size_t index = 0; index < num_queues(); index ++) {
     release_buffers(queue_at(index));
   }
 
   release_buffers(_free_list);
   FREE_C_HEAP_ARRAY(ShenandoahQueueBuffer*, _producer_queues);
 }
 
 void ShenandoahStrDedupQueue::wait_impl() {
-  MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
   while (_consumer_queue == NULL && !_cancel) {
-    ml.wait(Mutex::_no_safepoint_check_flag);
+    ml.wait();
     assert(_consumer_queue == NULL, "Why wait?");
     _consumer_queue = _published_queues;
     _published_queues = NULL;
   }
 }
 
 void ShenandoahStrDedupQueue::cancel_wait_impl() {
-  MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
   _cancel = true;
   ml.notify();
 }
 
 void ShenandoahStrDedupQueue::unlink_or_oops_do_impl(StringDedupUnlinkOrOopsDoClosure* cl, size_t queue) {
@@ -103,15 +104,15 @@
   assert(ShenandoahStringDedup::is_candidate(string_oop), "Not a candidate");
 
   ShenandoahQueueBuffer* buf = queue_at((size_t)worker_id);
 
   if (buf == NULL) {
-    MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
     buf = new_buffer();
     set_producer_buffer(buf, worker_id);
   } else if (buf->is_full()) {
-    MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
     buf->set_next(_published_queues);
     _published_queues = buf;
     buf = new_buffer();
     set_producer_buffer(buf, worker_id);
     ml.notify();
@@ -123,11 +124,11 @@
 
 oop ShenandoahStrDedupQueue::pop_impl() {
   assert(Thread::current() == StringDedupThread::thread(), "Must be dedup thread");
   while (true) {
     if (_consumer_queue == NULL) {
-      MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+      MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
       _consumer_queue = _published_queues;
       _published_queues = NULL;
     }
 
     // there is nothing
@@ -161,11 +162,11 @@
     }
     obj = _consumer_queue->pop();
   } while (obj == NULL);
 
   if (to_release != NULL) {
-    MonitorLockerEx ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
+    MonitorLocker ml(StringDedupQueue_lock, Mutex::_no_safepoint_check_flag);
     release_buffers(to_release);
   }
 
   return suc;
 }
@@ -203,12 +204,15 @@
 }
 
 void ShenandoahStrDedupQueue::print_statistics_impl() {
   Log(gc, stringdedup) log;
   log.debug("  Queue:");
-  log.debug("    Total buffers: " SIZE_FORMAT " (" SIZE_FORMAT " K). " SIZE_FORMAT " buffers are on free list",
-    _total_buffers, (_total_buffers * sizeof(ShenandoahQueueBuffer) / K), _num_free_buffer);
+  log.debug("    Total buffers: " SIZE_FORMAT " (" SIZE_FORMAT " %s). " SIZE_FORMAT " buffers are on free list",
+    _total_buffers,
+    byte_size_in_proper_unit(_total_buffers * sizeof(ShenandoahQueueBuffer)),
+    proper_unit_for_byte_size(_total_buffers * sizeof(ShenandoahQueueBuffer)),
+    _num_free_buffer);
 }
 
 class VerifyQueueClosure : public OopClosure {
 private:
   ShenandoahHeap* _heap;

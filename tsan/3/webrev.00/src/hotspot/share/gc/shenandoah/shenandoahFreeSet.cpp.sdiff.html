<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahEvacOOMHandler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahFreeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 
 26 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;

 32 
 33 ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :
 34   _heap(heap),
 35   _mutator_free_bitmap(max_regions, mtGC),
 36   _collector_free_bitmap(max_regions, mtGC),
 37   _max(max_regions)
 38 {
 39   clear_internal();
 40 }
 41 
 42 void ShenandoahFreeSet::increase_used(size_t num_bytes) {
 43   assert_heaplock_owned_by_current_thread();
 44   _used += num_bytes;
 45 
 46   assert(_used &lt;= _capacity, &quot;must not use more than we have: used: &quot; SIZE_FORMAT
 47          &quot;, capacity: &quot; SIZE_FORMAT &quot;, num_bytes: &quot; SIZE_FORMAT, _used, _capacity, num_bytes);
 48 }
 49 
 50 bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {
 51   assert (idx &lt; _max, &quot;index is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT &quot; (left: &quot; SIZE_FORMAT &quot;, right: &quot; SIZE_FORMAT &quot;)&quot;,
</pre>
<hr />
<pre>
 97       for (size_t c = _collector_rightmost + 1; c &gt; _collector_leftmost; c--) {
 98         size_t idx = c - 1;
 99         if (is_collector_free(idx)) {
100           HeapWord* result = try_allocate_in(_heap-&gt;get_region(idx), req, in_new_region);
101           if (result != NULL) {
102             return result;
103           }
104         }
105       }
106 
107       // No dice. Can we borrow space from mutator view?
108       if (!ShenandoahEvacReserveOverflow) {
109         return NULL;
110       }
111 
112       // Try to steal the empty region from the mutator view
113       for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
114         size_t idx = c - 1;
115         if (is_mutator_free(idx)) {
116           ShenandoahHeapRegion* r = _heap-&gt;get_region(idx);
<span class="line-modified">117           if (is_empty_or_trash(r)) {</span>
118             flip_to_gc(r);
119             HeapWord *result = try_allocate_in(r, req, in_new_region);
120             if (result != NULL) {
121               return result;
122             }
123           }
124         }
125       }
126 
127       // Try to mix the allocation into the mutator view:
128       if (ShenandoahAllowMixedAllocs) {
129         for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
130           size_t idx = c - 1;
131           if (is_mutator_free(idx)) {
132             HeapWord* result = try_allocate_in(_heap-&gt;get_region(idx), req, in_new_region);
133             if (result != NULL) {
134               return result;
135             }
136           }
137         }
138       }
139       break;
140     }
141     default:
142       ShouldNotReachHere();
143   }
144 
145   return NULL;
146 }
147 
148 HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
149   assert (!has_no_alloc_capacity(r), &quot;Performance: should avoid full regions on this path: &quot; SIZE_FORMAT, r-&gt;region_number());
150 





151   try_recycle_trashed(r);
152 
153   in_new_region = r-&gt;is_empty();
154 
155   HeapWord* result = NULL;
156   size_t size = req.size();
157 
158   if (ShenandoahElasticTLAB &amp;&amp; req.is_lab_alloc()) {
159     size_t free = align_down(r-&gt;free() &gt;&gt; LogHeapWordSize, MinObjAlignment);
160     if (size &gt; free) {
161       size = free;
162     }
163     if (size &gt;= req.min_size()) {
164       result = r-&gt;allocate(size, req.type());
165       assert (result != NULL, &quot;Allocation must succeed: free &quot; SIZE_FORMAT &quot;, actual &quot; SIZE_FORMAT, free, size);
166     }
167   } else {
168     result = r-&gt;allocate(size, req.type());
169   }
170 
</pre>
<hr />
<pre>
256 
257   // No regions left to satisfy allocation, bye.
258   if (num &gt; mutator_count()) {
259     return NULL;
260   }
261 
262   // Find the continuous interval of $num regions, starting from $beg and ending in $end,
263   // inclusive. Contiguous allocations are biased to the beginning.
264 
265   size_t beg = _mutator_leftmost;
266   size_t end = beg;
267 
268   while (true) {
269     if (end &gt;= _max) {
270       // Hit the end, goodbye
271       return NULL;
272     }
273 
274     // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
275     // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
<span class="line-modified">276     if (!is_mutator_free(end) || !is_empty_or_trash(_heap-&gt;get_region(end))) {</span>
277       end++;
278       beg = end;
279       continue;
280     }
281 
282     if ((end - beg + 1) == num) {
283       // found the match
284       break;
285     }
286 
287     end++;
288   };
289 
290   size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
291 
292   // Initialize regions:
293   for (size_t i = beg; i &lt;= end; i++) {
294     ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
295     try_recycle_trashed(r);
296 
</pre>
<hr />
<pre>
319 
320   // While individual regions report their true use, all humongous regions are
321   // marked used in the free set.
322   increase_used(ShenandoahHeapRegion::region_size_bytes() * num);
323 
324   if (remainder != 0) {
325     // Record this remainder as allocation waste
326     _heap-&gt;notify_mutator_alloc_words(ShenandoahHeapRegion::region_size_words() - remainder, true);
327   }
328 
329   // Allocated at left/rightmost? Move the bounds appropriately.
330   if (beg == _mutator_leftmost || end == _mutator_rightmost) {
331     adjust_bounds();
332   }
333   assert_bounds();
334 
335   req.set_actual_size(words_size);
336   return _heap-&gt;get_region(beg)-&gt;bottom();
337 }
338 
<span class="line-modified">339 bool ShenandoahFreeSet::is_empty_or_trash(ShenandoahHeapRegion *r) {</span>
<span class="line-modified">340   return r-&gt;is_empty() || r-&gt;is_trash();</span>
341 }
342 
343 size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {
344   if (r-&gt;is_trash()) {
345     // This would be recycled on allocation path
346     return ShenandoahHeapRegion::region_size_bytes();
347   } else {
348     return r-&gt;free();
349   }
350 }
351 
352 bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) {
353   return alloc_capacity(r) == 0;
354 }
355 
356 void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion *r) {
357   if (r-&gt;is_trash()) {
358     _heap-&gt;decrease_used(r-&gt;used());
359     r-&gt;recycle();
360   }
361 }
362 
363 void ShenandoahFreeSet::recycle_trash() {
364   // lock is not reentrable, check we don&#39;t have it
365   assert_heaplock_not_owned_by_current_thread();
366 
367   for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
368     ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
369     if (r-&gt;is_trash()) {
370       ShenandoahHeapLocker locker(_heap-&gt;lock());
371       try_recycle_trashed(r);
372     }
373     SpinPause(); // allow allocators to take the lock
374   }
375 }
376 
377 void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {
378   size_t idx = r-&gt;region_number();
379 
380   assert(_mutator_free_bitmap.at(idx), &quot;Should be in mutator view&quot;);
<span class="line-modified">381   assert(is_empty_or_trash(r), &quot;Should not be allocated&quot;);</span>
382 
383   _mutator_free_bitmap.clear_bit(idx);
384   _collector_free_bitmap.set_bit(idx);
385   _collector_leftmost = MIN2(idx, _collector_leftmost);
386   _collector_rightmost = MAX2(idx, _collector_rightmost);
387 
388   _capacity -= alloc_capacity(r);
389 
390   if (touches_bounds(idx)) {
391     adjust_bounds();
392   }
393   assert_bounds();
394 }
395 
396 void ShenandoahFreeSet::clear() {
397   assert_heaplock_owned_by_current_thread();
398   clear_internal();
399 }
400 
401 void ShenandoahFreeSet::clear_internal() {
</pre>
<hr />
<pre>
413   assert_heaplock_owned_by_current_thread();
414   clear();
415 
416   for (size_t idx = 0; idx &lt; _heap-&gt;num_regions(); idx++) {
417     ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
418     if (region-&gt;is_alloc_allowed() || region-&gt;is_trash()) {
419       assert(!region-&gt;is_cset(), &quot;Shouldn&#39;t be adding those to the free set&quot;);
420 
421       // Do not add regions that would surely fail allocation
422       if (has_no_alloc_capacity(region)) continue;
423 
424       _capacity += alloc_capacity(region);
425       assert(_used &lt;= _capacity, &quot;must not use more than we have&quot;);
426 
427       assert(!is_mutator_free(idx), &quot;We are about to add it, it shouldn&#39;t be there already&quot;);
428       _mutator_free_bitmap.set_bit(idx);
429     }
430   }
431 
432   // Evac reserve: reserve trailing space for evacuations
<span class="line-modified">433   size_t to_reserve = ShenandoahEvacReserve * _heap-&gt;capacity() / 100;</span>
434   size_t reserved = 0;
435 
436   for (size_t idx = _heap-&gt;num_regions() - 1; idx &gt; 0; idx--) {
437     if (reserved &gt;= to_reserve) break;
438 
439     ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
<span class="line-modified">440     if (_mutator_free_bitmap.at(idx) &amp;&amp; is_empty_or_trash(region)) {</span>
441       _mutator_free_bitmap.clear_bit(idx);
442       _collector_free_bitmap.set_bit(idx);
443       size_t ac = alloc_capacity(region);
444       _capacity -= ac;
445       reserved += ac;
446     }
447   }
448 
449   recompute_bounds();
450   assert_bounds();
451 }
452 
453 void ShenandoahFreeSet::log_status() {
454   assert_heaplock_owned_by_current_thread();
455 
456   LogTarget(Info, gc, ergo) lt;
457   if (lt.is_enabled()) {
458     ResourceMark rm;
459     LogStream ls(lt);
460 
</pre>
<hr />
<pre>
474 
475           max = MAX2(max, free);
476 
477           if (r-&gt;is_empty() &amp;&amp; (last_idx + 1 == idx)) {
478             empty_contig++;
479           } else {
480             empty_contig = 0;
481           }
482 
483           total_used += r-&gt;used();
484           total_free += free;
485 
486           max_contig = MAX2(max_contig, empty_contig);
487           last_idx = idx;
488         }
489       }
490 
491       size_t max_humongous = max_contig * ShenandoahHeapRegion::region_size_bytes();
492       size_t free = capacity() - used();
493 
<span class="line-modified">494       ls.print(&quot;Free: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;K, Max humongous: &quot; SIZE_FORMAT &quot;K, &quot;,</span>
<span class="line-modified">495                total_free / M, mutator_count(), max / K, max_humongous / K);</span>




496 
497       size_t frag_ext;
498       if (free &gt; 0) {
499         frag_ext = 100 - (100 * max_humongous / free);
500       } else {
501         frag_ext = 0;
502       }
503       ls.print(&quot;External frag: &quot; SIZE_FORMAT &quot;%%, &quot;, frag_ext);
504 
505       size_t frag_int;
506       if (mutator_count() &gt; 0) {
507         frag_int = (100 * (total_used / mutator_count()) / ShenandoahHeapRegion::region_size_bytes());
508       } else {
509         frag_int = 0;
510       }
511       ls.print(&quot;Internal frag: &quot; SIZE_FORMAT &quot;%%&quot;, frag_int);
512       ls.cr();
513     }
514 
515     {
516       size_t max = 0;
517       size_t total_free = 0;
518 
519       for (size_t idx = _collector_leftmost; idx &lt;= _collector_rightmost; idx++) {
520         if (is_collector_free(idx)) {
521           ShenandoahHeapRegion *r = _heap-&gt;get_region(idx);
522           size_t free = alloc_capacity(r);
523           max = MAX2(max, free);
524           total_free += free;
525         }
526       }
527 
<span class="line-modified">528       ls.print_cr(&quot;Evacuation Reserve: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;K&quot;,</span>
<span class="line-modified">529                   total_free / M, collector_count(), max / K);</span>


530     }
531   }
532 }
533 
534 HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
535   assert_heaplock_owned_by_current_thread();
536   assert_bounds();
537 
538   if (req.size() &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
539     switch (req.type()) {
540       case ShenandoahAllocRequest::_alloc_shared:
541       case ShenandoahAllocRequest::_alloc_shared_gc:
542         in_new_region = true;
543         return allocate_contiguous(req);
544       case ShenandoahAllocRequest::_alloc_gclab:
545       case ShenandoahAllocRequest::_alloc_tlab:
546         in_new_region = false;
547         assert(false, &quot;Trying to allocate TLAB larger than the humongous threshold: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT,
548                req.size(), ShenandoahHeapRegion::humongous_threshold_words());
549         return NULL;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/orderAccess.hpp&quot;</span>
 34 
 35 ShenandoahFreeSet::ShenandoahFreeSet(ShenandoahHeap* heap, size_t max_regions) :
 36   _heap(heap),
 37   _mutator_free_bitmap(max_regions, mtGC),
 38   _collector_free_bitmap(max_regions, mtGC),
 39   _max(max_regions)
 40 {
 41   clear_internal();
 42 }
 43 
 44 void ShenandoahFreeSet::increase_used(size_t num_bytes) {
 45   assert_heaplock_owned_by_current_thread();
 46   _used += num_bytes;
 47 
 48   assert(_used &lt;= _capacity, &quot;must not use more than we have: used: &quot; SIZE_FORMAT
 49          &quot;, capacity: &quot; SIZE_FORMAT &quot;, num_bytes: &quot; SIZE_FORMAT, _used, _capacity, num_bytes);
 50 }
 51 
 52 bool ShenandoahFreeSet::is_mutator_free(size_t idx) const {
 53   assert (idx &lt; _max, &quot;index is sane: &quot; SIZE_FORMAT &quot; &lt; &quot; SIZE_FORMAT &quot; (left: &quot; SIZE_FORMAT &quot;, right: &quot; SIZE_FORMAT &quot;)&quot;,
</pre>
<hr />
<pre>
 99       for (size_t c = _collector_rightmost + 1; c &gt; _collector_leftmost; c--) {
100         size_t idx = c - 1;
101         if (is_collector_free(idx)) {
102           HeapWord* result = try_allocate_in(_heap-&gt;get_region(idx), req, in_new_region);
103           if (result != NULL) {
104             return result;
105           }
106         }
107       }
108 
109       // No dice. Can we borrow space from mutator view?
110       if (!ShenandoahEvacReserveOverflow) {
111         return NULL;
112       }
113 
114       // Try to steal the empty region from the mutator view
115       for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
116         size_t idx = c - 1;
117         if (is_mutator_free(idx)) {
118           ShenandoahHeapRegion* r = _heap-&gt;get_region(idx);
<span class="line-modified">119           if (can_allocate_from(r)) {</span>
120             flip_to_gc(r);
121             HeapWord *result = try_allocate_in(r, req, in_new_region);
122             if (result != NULL) {
123               return result;
124             }
125           }
126         }
127       }
128 
129       // Try to mix the allocation into the mutator view:
130       if (ShenandoahAllowMixedAllocs) {
131         for (size_t c = _mutator_rightmost + 1; c &gt; _mutator_leftmost; c--) {
132           size_t idx = c - 1;
133           if (is_mutator_free(idx)) {
134             HeapWord* result = try_allocate_in(_heap-&gt;get_region(idx), req, in_new_region);
135             if (result != NULL) {
136               return result;
137             }
138           }
139         }
140       }
141       break;
142     }
143     default:
144       ShouldNotReachHere();
145   }
146 
147   return NULL;
148 }
149 
150 HeapWord* ShenandoahFreeSet::try_allocate_in(ShenandoahHeapRegion* r, ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
151   assert (!has_no_alloc_capacity(r), &quot;Performance: should avoid full regions on this path: &quot; SIZE_FORMAT, r-&gt;region_number());
152 
<span class="line-added">153   if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp;</span>
<span class="line-added">154       r-&gt;is_trash()) {</span>
<span class="line-added">155     return NULL;</span>
<span class="line-added">156   }</span>
<span class="line-added">157 </span>
158   try_recycle_trashed(r);
159 
160   in_new_region = r-&gt;is_empty();
161 
162   HeapWord* result = NULL;
163   size_t size = req.size();
164 
165   if (ShenandoahElasticTLAB &amp;&amp; req.is_lab_alloc()) {
166     size_t free = align_down(r-&gt;free() &gt;&gt; LogHeapWordSize, MinObjAlignment);
167     if (size &gt; free) {
168       size = free;
169     }
170     if (size &gt;= req.min_size()) {
171       result = r-&gt;allocate(size, req.type());
172       assert (result != NULL, &quot;Allocation must succeed: free &quot; SIZE_FORMAT &quot;, actual &quot; SIZE_FORMAT, free, size);
173     }
174   } else {
175     result = r-&gt;allocate(size, req.type());
176   }
177 
</pre>
<hr />
<pre>
263 
264   // No regions left to satisfy allocation, bye.
265   if (num &gt; mutator_count()) {
266     return NULL;
267   }
268 
269   // Find the continuous interval of $num regions, starting from $beg and ending in $end,
270   // inclusive. Contiguous allocations are biased to the beginning.
271 
272   size_t beg = _mutator_leftmost;
273   size_t end = beg;
274 
275   while (true) {
276     if (end &gt;= _max) {
277       // Hit the end, goodbye
278       return NULL;
279     }
280 
281     // If regions are not adjacent, then current [beg; end] is useless, and we may fast-forward.
282     // If region is not completely free, the current [beg; end] is useless, and we may fast-forward.
<span class="line-modified">283     if (!is_mutator_free(end) || !can_allocate_from(_heap-&gt;get_region(end))) {</span>
284       end++;
285       beg = end;
286       continue;
287     }
288 
289     if ((end - beg + 1) == num) {
290       // found the match
291       break;
292     }
293 
294     end++;
295   };
296 
297   size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
298 
299   // Initialize regions:
300   for (size_t i = beg; i &lt;= end; i++) {
301     ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
302     try_recycle_trashed(r);
303 
</pre>
<hr />
<pre>
326 
327   // While individual regions report their true use, all humongous regions are
328   // marked used in the free set.
329   increase_used(ShenandoahHeapRegion::region_size_bytes() * num);
330 
331   if (remainder != 0) {
332     // Record this remainder as allocation waste
333     _heap-&gt;notify_mutator_alloc_words(ShenandoahHeapRegion::region_size_words() - remainder, true);
334   }
335 
336   // Allocated at left/rightmost? Move the bounds appropriately.
337   if (beg == _mutator_leftmost || end == _mutator_rightmost) {
338     adjust_bounds();
339   }
340   assert_bounds();
341 
342   req.set_actual_size(words_size);
343   return _heap-&gt;get_region(beg)-&gt;bottom();
344 }
345 
<span class="line-modified">346 bool ShenandoahFreeSet::can_allocate_from(ShenandoahHeapRegion *r) {</span>
<span class="line-modified">347   return r-&gt;is_empty() || (r-&gt;is_trash() &amp;&amp; !_heap-&gt;is_concurrent_root_in_progress());</span>
348 }
349 
350 size_t ShenandoahFreeSet::alloc_capacity(ShenandoahHeapRegion *r) {
351   if (r-&gt;is_trash()) {
352     // This would be recycled on allocation path
353     return ShenandoahHeapRegion::region_size_bytes();
354   } else {
355     return r-&gt;free();
356   }
357 }
358 
359 bool ShenandoahFreeSet::has_no_alloc_capacity(ShenandoahHeapRegion *r) {
360   return alloc_capacity(r) == 0;
361 }
362 
363 void ShenandoahFreeSet::try_recycle_trashed(ShenandoahHeapRegion *r) {
364   if (r-&gt;is_trash()) {
365     _heap-&gt;decrease_used(r-&gt;used());
366     r-&gt;recycle();
367   }
368 }
369 
370 void ShenandoahFreeSet::recycle_trash() {
371   // lock is not reentrable, check we don&#39;t have it
372   assert_heaplock_not_owned_by_current_thread();
373 
374   for (size_t i = 0; i &lt; _heap-&gt;num_regions(); i++) {
375     ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
376     if (r-&gt;is_trash()) {
377       ShenandoahHeapLocker locker(_heap-&gt;lock());
378       try_recycle_trashed(r);
379     }
380     SpinPause(); // allow allocators to take the lock
381   }
382 }
383 
384 void ShenandoahFreeSet::flip_to_gc(ShenandoahHeapRegion* r) {
385   size_t idx = r-&gt;region_number();
386 
387   assert(_mutator_free_bitmap.at(idx), &quot;Should be in mutator view&quot;);
<span class="line-modified">388   assert(can_allocate_from(r), &quot;Should not be allocated&quot;);</span>
389 
390   _mutator_free_bitmap.clear_bit(idx);
391   _collector_free_bitmap.set_bit(idx);
392   _collector_leftmost = MIN2(idx, _collector_leftmost);
393   _collector_rightmost = MAX2(idx, _collector_rightmost);
394 
395   _capacity -= alloc_capacity(r);
396 
397   if (touches_bounds(idx)) {
398     adjust_bounds();
399   }
400   assert_bounds();
401 }
402 
403 void ShenandoahFreeSet::clear() {
404   assert_heaplock_owned_by_current_thread();
405   clear_internal();
406 }
407 
408 void ShenandoahFreeSet::clear_internal() {
</pre>
<hr />
<pre>
420   assert_heaplock_owned_by_current_thread();
421   clear();
422 
423   for (size_t idx = 0; idx &lt; _heap-&gt;num_regions(); idx++) {
424     ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
425     if (region-&gt;is_alloc_allowed() || region-&gt;is_trash()) {
426       assert(!region-&gt;is_cset(), &quot;Shouldn&#39;t be adding those to the free set&quot;);
427 
428       // Do not add regions that would surely fail allocation
429       if (has_no_alloc_capacity(region)) continue;
430 
431       _capacity += alloc_capacity(region);
432       assert(_used &lt;= _capacity, &quot;must not use more than we have&quot;);
433 
434       assert(!is_mutator_free(idx), &quot;We are about to add it, it shouldn&#39;t be there already&quot;);
435       _mutator_free_bitmap.set_bit(idx);
436     }
437   }
438 
439   // Evac reserve: reserve trailing space for evacuations
<span class="line-modified">440   size_t to_reserve = _heap-&gt;max_capacity() / 100 * ShenandoahEvacReserve;</span>
441   size_t reserved = 0;
442 
443   for (size_t idx = _heap-&gt;num_regions() - 1; idx &gt; 0; idx--) {
444     if (reserved &gt;= to_reserve) break;
445 
446     ShenandoahHeapRegion* region = _heap-&gt;get_region(idx);
<span class="line-modified">447     if (_mutator_free_bitmap.at(idx) &amp;&amp; can_allocate_from(region)) {</span>
448       _mutator_free_bitmap.clear_bit(idx);
449       _collector_free_bitmap.set_bit(idx);
450       size_t ac = alloc_capacity(region);
451       _capacity -= ac;
452       reserved += ac;
453     }
454   }
455 
456   recompute_bounds();
457   assert_bounds();
458 }
459 
460 void ShenandoahFreeSet::log_status() {
461   assert_heaplock_owned_by_current_thread();
462 
463   LogTarget(Info, gc, ergo) lt;
464   if (lt.is_enabled()) {
465     ResourceMark rm;
466     LogStream ls(lt);
467 
</pre>
<hr />
<pre>
481 
482           max = MAX2(max, free);
483 
484           if (r-&gt;is_empty() &amp;&amp; (last_idx + 1 == idx)) {
485             empty_contig++;
486           } else {
487             empty_contig = 0;
488           }
489 
490           total_used += r-&gt;used();
491           total_free += free;
492 
493           max_contig = MAX2(max_contig, empty_contig);
494           last_idx = idx;
495         }
496       }
497 
498       size_t max_humongous = max_contig * ShenandoahHeapRegion::region_size_bytes();
499       size_t free = capacity() - used();
500 
<span class="line-modified">501       ls.print(&quot;Free: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;%s, Max humongous: &quot; SIZE_FORMAT &quot;%s, &quot;,</span>
<span class="line-modified">502                byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),</span>
<span class="line-added">503                mutator_count(),</span>
<span class="line-added">504                byte_size_in_proper_unit(max),           proper_unit_for_byte_size(max),</span>
<span class="line-added">505                byte_size_in_proper_unit(max_humongous), proper_unit_for_byte_size(max_humongous)</span>
<span class="line-added">506       );</span>
507 
508       size_t frag_ext;
509       if (free &gt; 0) {
510         frag_ext = 100 - (100 * max_humongous / free);
511       } else {
512         frag_ext = 0;
513       }
514       ls.print(&quot;External frag: &quot; SIZE_FORMAT &quot;%%, &quot;, frag_ext);
515 
516       size_t frag_int;
517       if (mutator_count() &gt; 0) {
518         frag_int = (100 * (total_used / mutator_count()) / ShenandoahHeapRegion::region_size_bytes());
519       } else {
520         frag_int = 0;
521       }
522       ls.print(&quot;Internal frag: &quot; SIZE_FORMAT &quot;%%&quot;, frag_int);
523       ls.cr();
524     }
525 
526     {
527       size_t max = 0;
528       size_t total_free = 0;
529 
530       for (size_t idx = _collector_leftmost; idx &lt;= _collector_rightmost; idx++) {
531         if (is_collector_free(idx)) {
532           ShenandoahHeapRegion *r = _heap-&gt;get_region(idx);
533           size_t free = alloc_capacity(r);
534           max = MAX2(max, free);
535           total_free += free;
536         }
537       }
538 
<span class="line-modified">539       ls.print_cr(&quot;Evacuation Reserve: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot; regions), Max regular: &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">540                   byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),</span>
<span class="line-added">541                   collector_count(),</span>
<span class="line-added">542                   byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));</span>
543     }
544   }
545 }
546 
547 HeapWord* ShenandoahFreeSet::allocate(ShenandoahAllocRequest&amp; req, bool&amp; in_new_region) {
548   assert_heaplock_owned_by_current_thread();
549   assert_bounds();
550 
551   if (req.size() &gt; ShenandoahHeapRegion::humongous_threshold_words()) {
552     switch (req.type()) {
553       case ShenandoahAllocRequest::_alloc_shared:
554       case ShenandoahAllocRequest::_alloc_shared_gc:
555         in_new_region = true;
556         return allocate_contiguous(req);
557       case ShenandoahAllocRequest::_alloc_gclab:
558       case ShenandoahAllocRequest::_alloc_tlab:
559         in_new_region = false;
560         assert(false, &quot;Trying to allocate TLAB larger than the humongous threshold: &quot; SIZE_FORMAT &quot; &gt; &quot; SIZE_FORMAT,
561                req.size(), ShenandoahHeapRegion::humongous_threshold_words());
562         return NULL;
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahEvacOOMHandler.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahFreeSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
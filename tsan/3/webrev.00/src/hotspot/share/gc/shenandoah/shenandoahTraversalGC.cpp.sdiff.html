<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTracer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.</span>

   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.
   7  *
   8  * This code is distributed in the hope that it will be useful, but WITHOUT
   9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  11  * version 2 for more details (a copy is included in the LICENSE file that
  12  * accompanied this code).
  13  *
  14  * You should have received a copy of the GNU General Public License version
  15  * 2 along with this work; if not, write to the Free Software Foundation,
  16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  17  *
  18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  19  * or visit www.oracle.com if you need additional information or have any
  20  * questions.
  21  *
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 
  26 #include &quot;classfile/classLoaderData.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  29 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  30 #include &quot;gc/shared/workgroup.hpp&quot;
<span class="line-removed">  31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;</span>
  32 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;

  33 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-modified">  43 #include &quot;gc/shenandoah/shenandoahRootProcessor.hpp&quot;</span>
  44 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  50 
  51 #include &quot;memory/iterator.hpp&quot;
  52 #include &quot;memory/metaspace.hpp&quot;
  53 #include &quot;memory/resourceArea.hpp&quot;

  54 
  55 /**
  56  * NOTE: We are using the SATB buffer in thread.hpp and satbMarkQueue.hpp, however, it is not an SATB algorithm.
  57  * We&#39;re using the buffer as generic oop buffer to enqueue new values in concurrent oop stores, IOW, the algorithm
  58  * is incremental-update-based.
  59  *
  60  * NOTE on interaction with TAMS: we want to avoid traversing new objects for
  61  * several reasons:
  62  * - We will not reclaim them in this cycle anyway, because they are not in the
  63  *   cset
  64  * - It makes up for the bulk of work during final-pause
  65  * - It also shortens the concurrent cycle because we don&#39;t need to
  66  *   pointlessly traverse through newly allocated objects.
  67  * - As a nice side-effect, it solves the I-U termination problem (mutators
  68  *   cannot outrun the GC by allocating like crazy)
  69  * - It is an easy way to achieve MWF. What MWF does is to also enqueue the
  70  *   target object of stores if it&#39;s new. Treating new objects live implicitely
  71  *   achieves the same, but without extra barriers. I think the effect of
  72  *   shortened final-pause (mentioned above) is the main advantage of MWF. In
  73  *   particular, we will not see the head of a completely new long linked list
</pre>
<hr />
<pre>
 122 private:
 123   ShenandoahTraversalSATBBufferClosure* _satb_cl;
 124 
 125 public:
 126   ShenandoahTraversalSATBThreadsClosure(ShenandoahTraversalSATBBufferClosure* satb_cl) :
 127     _satb_cl(satb_cl) {}
 128 
 129   void do_thread(Thread* thread) {
 130     ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
 131   }
 132 };
 133 
 134 // Like CLDToOopClosure, but clears has_modified_oops, so that we can record modified CLDs during traversal
 135 // and remark them later during final-traversal.
 136 class ShenandoahMarkCLDClosure : public CLDClosure {
 137 private:
 138   OopClosure* _cl;
 139 public:
 140   ShenandoahMarkCLDClosure(OopClosure* cl) : _cl(cl) {}
 141   void do_cld(ClassLoaderData* cld) {
<span class="line-modified"> 142     cld-&gt;oops_do(_cl, true, true);</span>
 143   }
 144 };
 145 
 146 // Like CLDToOopClosure, but only process modified CLDs
 147 class ShenandoahRemarkCLDClosure : public CLDClosure {
 148 private:
 149   OopClosure* _cl;
 150 public:
 151   ShenandoahRemarkCLDClosure(OopClosure* cl) : _cl(cl) {}
 152   void do_cld(ClassLoaderData* cld) {
 153     if (cld-&gt;has_modified_oops()) {
<span class="line-modified"> 154       cld-&gt;oops_do(_cl, true, true);</span>
 155     }
 156   }
 157 };
 158 
 159 class ShenandoahInitTraversalCollectionTask : public AbstractGangTask {
 160 private:
<span class="line-modified"> 161   ShenandoahRootProcessor* _rp;</span>
 162   ShenandoahHeap* _heap;
 163   ShenandoahCsetCodeRootsIterator* _cset_coderoots;


 164 public:
<span class="line-modified"> 165   ShenandoahInitTraversalCollectionTask(ShenandoahRootProcessor* rp, ShenandoahCsetCodeRootsIterator* cset_coderoots) :</span>
 166     AbstractGangTask(&quot;Shenandoah Init Traversal Collection&quot;),
 167     _rp(rp),
<span class="line-modified"> 168     _heap(ShenandoahHeap::heap()),</span>
<span class="line-removed"> 169     _cset_coderoots(cset_coderoots) {}</span>
 170 
 171   void work(uint worker_id) {
 172     ShenandoahParallelWorkerSession worker_session(worker_id);
 173 
<span class="line-removed"> 174     ShenandoahEvacOOMScope oom_evac_scope;</span>
 175     ShenandoahObjToScanQueueSet* queues = _heap-&gt;traversal_gc()-&gt;task_queues();
 176     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 177 
 178     bool process_refs = _heap-&gt;process_references();
 179     bool unload_classes = _heap-&gt;unload_classes();
 180     ReferenceProcessor* rp = NULL;
 181     if (process_refs) {
 182       rp = _heap-&gt;ref_processor();
 183     }
 184 
 185     // Step 1: Process ordinary GC roots.
 186     {
<span class="line-modified"> 187       ShenandoahTraversalClosure roots_cl(q, rp);</span>
 188       ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
 189       MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
 190       if (unload_classes) {
<span class="line-modified"> 191         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, NULL, NULL, worker_id);</span>
<span class="line-removed"> 192         // Need to pre-evac code roots here. Otherwise we might see from-space constants.</span>
<span class="line-removed"> 193         ShenandoahWorkerTimings* worker_times = _heap-&gt;phase_timings()-&gt;worker_times();</span>
<span class="line-removed"> 194         ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);</span>
<span class="line-removed"> 195         _cset_coderoots-&gt;possibly_parallel_blobs_do(&amp;code_cl);</span>
 196       } else {
<span class="line-modified"> 197         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;code_cl, NULL, worker_id);</span>
 198       }
 199     }
 200   }
 201 };
 202 
 203 class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
 204 private:
<span class="line-modified"> 205   ShenandoahTaskTerminator* _terminator;</span>
 206   ShenandoahHeap* _heap;
 207 public:
<span class="line-modified"> 208   ShenandoahConcurrentTraversalCollectionTask(ShenandoahTaskTerminator* terminator) :</span>
 209     AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
 210     _terminator(terminator),
 211     _heap(ShenandoahHeap::heap()) {}
 212 
 213   void work(uint worker_id) {
 214     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 215     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
<span class="line-removed"> 216     ShenandoahEvacOOMScope oom_evac_scope;</span>
 217     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 218 
 219     // Drain all outstanding work in queues.
 220     traversal_gc-&gt;main_loop(worker_id, _terminator, true);
 221   }
 222 };
 223 
 224 class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
 225 private:
<span class="line-modified"> 226   ShenandoahRootProcessor* _rp;</span>
<span class="line-modified"> 227   ShenandoahTaskTerminator* _terminator;</span>
 228   ShenandoahHeap* _heap;
 229 public:
<span class="line-modified"> 230   ShenandoahFinalTraversalCollectionTask(ShenandoahRootProcessor* rp, ShenandoahTaskTerminator* terminator) :</span>
 231     AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
 232     _rp(rp),
 233     _terminator(terminator),
 234     _heap(ShenandoahHeap::heap()) {}
 235 
 236   void work(uint worker_id) {
 237     ShenandoahParallelWorkerSession worker_session(worker_id);
 238 
<span class="line-removed"> 239     ShenandoahEvacOOMScope oom_evac_scope;</span>
 240     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 241 
 242     ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
 243     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 244 
 245     bool process_refs = _heap-&gt;process_references();
 246     bool unload_classes = _heap-&gt;unload_classes();
 247     ReferenceProcessor* rp = NULL;
 248     if (process_refs) {
 249       rp = _heap-&gt;ref_processor();
 250     }
 251 
 252     // Step 0: Drain outstanding SATB queues.
 253     // NOTE: we piggy-back draining of remaining thread SATB buffers on the final root scan below.
 254     ShenandoahTraversalSATBBufferClosure satb_cl(q);
 255     {
 256       // Process remaining finished SATB buffers.
 257       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
 258       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;satb_cl));
 259       // Process remaining threads SATB buffers below.
 260     }
 261 
 262     // Step 1: Process GC roots.
 263     // For oops in code roots, they are marked, evacuated, enqueued for further traversal,
 264     // and the references to the oops are updated during init pause. New nmethods are handled
 265     // in similar way during nmethod-register process. Therefore, we don&#39;t need to rescan code
 266     // roots here.
 267     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
<span class="line-modified"> 268       ShenandoahTraversalClosure roots_cl(q, rp);</span>
<span class="line-removed"> 269       CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
 270       ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
 271       if (unload_classes) {
<span class="line-modified"> 272         ShenandoahRemarkCLDClosure weak_cld_cl(&amp;roots_cl);</span>
<span class="line-modified"> 273         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;weak_cld_cl, NULL, &amp;tc, worker_id);</span>
 274       } else {
<span class="line-modified"> 275         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc, worker_id);</span>

 276       }
 277     } else {
 278       ShenandoahTraversalDegenClosure roots_cl(q, rp);
<span class="line-removed"> 279       CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
 280       ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
 281       if (unload_classes) {
<span class="line-modified"> 282         ShenandoahRemarkCLDClosure weak_cld_cl(&amp;roots_cl);</span>
<span class="line-modified"> 283         _rp-&gt;process_strong_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, &amp;weak_cld_cl, NULL, &amp;tc, worker_id);</span>
 284       } else {
<span class="line-modified"> 285         _rp-&gt;process_all_roots(&amp;roots_cl, process_refs ? NULL : &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc, worker_id);</span>

 286       }
 287     }
 288 
 289     {
 290       ShenandoahWorkerTimings *worker_times = _heap-&gt;phase_timings()-&gt;worker_times();
 291       ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::FinishQueues, worker_id);
 292 
 293       // Step 3: Finally drain all outstanding work in queues.
 294       traversal_gc-&gt;main_loop(worker_id, _terminator, false);
 295     }
 296 
 297   }
 298 };
 299 
 300 ShenandoahTraversalGC::ShenandoahTraversalGC(ShenandoahHeap* heap, size_t num_regions) :
 301   _heap(heap),
 302   _task_queues(new ShenandoahObjToScanQueueSet(heap-&gt;max_workers())),
 303   _traversal_set(ShenandoahHeapRegionSet()) {
 304 



 305   uint num_queues = heap-&gt;max_workers();
 306   for (uint i = 0; i &lt; num_queues; ++i) {
 307     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
 308     task_queue-&gt;initialize();
 309     _task_queues-&gt;register_queue(i, task_queue);
 310   }
 311 }
 312 
 313 ShenandoahTraversalGC::~ShenandoahTraversalGC() {
 314 }
 315 
 316 void ShenandoahTraversalGC::prepare_regions() {
 317   size_t num_regions = _heap-&gt;num_regions();
 318   ShenandoahMarkingContext* const ctx = _heap-&gt;marking_context();
 319   for (size_t i = 0; i &lt; num_regions; i++) {
 320     ShenandoahHeapRegion* region = _heap-&gt;get_region(i);
 321     if (_heap-&gt;is_bitmap_slice_committed(region)) {
 322       if (_traversal_set.is_in(i)) {
 323         ctx-&gt;capture_top_at_mark_start(region);
 324         region-&gt;clear_live_data();
 325         assert(ctx-&gt;is_bitmap_clear_range(region-&gt;bottom(), region-&gt;end()), &quot;bitmap for traversal regions must be cleared&quot;);
 326       } else {
 327         // Everything outside the traversal set is always considered live.
 328         ctx-&gt;reset_top_at_mark_start(region);
 329       }
 330     } else {
 331       // FreeSet may contain uncommitted empty regions, once they are recommitted,
 332       // their TAMS may have old values, so reset them here.
 333       ctx-&gt;reset_top_at_mark_start(region);
 334     }
 335   }
 336 }
 337 
 338 void ShenandoahTraversalGC::prepare() {
<span class="line-removed"> 339   _heap-&gt;collection_set()-&gt;clear();</span>
<span class="line-removed"> 340   assert(_heap-&gt;collection_set()-&gt;count() == 0, &quot;collection set not clear&quot;);</span>
<span class="line-removed"> 341 </span>
 342   {
 343     ShenandoahGCPhase phase(ShenandoahPhaseTimings::traversal_gc_make_parsable);
 344     _heap-&gt;make_parsable(true);
 345   }
 346 
 347   if (UseTLAB) {
 348     ShenandoahGCPhase phase(ShenandoahPhaseTimings::traversal_gc_resize_tlabs);
 349     _heap-&gt;resize_tlabs();
 350   }
 351 
 352   assert(_heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;need clean mark bitmap&quot;);
 353   assert(!_heap-&gt;marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
 354 
<span class="line-modified"> 355   ShenandoahFreeSet* free_set = _heap-&gt;free_set();</span>





 356   ShenandoahCollectionSet* collection_set = _heap-&gt;collection_set();


 357 
<span class="line-modified"> 358   // Find collection set</span>
<span class="line-modified"> 359   _heap-&gt;heuristics()-&gt;choose_collection_set(collection_set);</span>
<span class="line-removed"> 360   prepare_regions();</span>
 361 
<span class="line-modified"> 362   // Rebuild free set</span>
<span class="line-modified"> 363   free_set-&gt;rebuild();</span>

 364 
<span class="line-modified"> 365   log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;M, &quot; SIZE_FORMAT &quot;M CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified"> 366                      collection_set-&gt;garbage() / M, collection_set-&gt;live_data() / M, collection_set-&gt;count());</span>






 367 }
 368 
 369 void ShenandoahTraversalGC::init_traversal_collection() {
 370   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;STW traversal GC&quot;);
 371 
 372   if (ShenandoahVerify) {
 373     _heap-&gt;verifier()-&gt;verify_before_traversal();
 374   }
 375 
 376   if (VerifyBeforeGC) {
 377     Universe::verify();
 378   }
 379 
 380   {
 381     ShenandoahGCPhase phase_prepare(ShenandoahPhaseTimings::traversal_gc_prepare);
<span class="line-removed"> 382     ShenandoahHeapLocker lock(_heap-&gt;lock());</span>
 383     prepare();
 384   }
 385 
 386   _heap-&gt;set_concurrent_traversal_in_progress(true);

 387 
 388   bool process_refs = _heap-&gt;process_references();
 389   if (process_refs) {
 390     ReferenceProcessor* rp = _heap-&gt;ref_processor();
 391     rp-&gt;enable_discovery(true /*verify_no_refs*/);
 392     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
 393   }
 394 
 395   {
 396     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::init_traversal_gc_work);
 397     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty before traversal GC&quot;);
 398     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 399 
<span class="line-modified"> 400 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 401     DerivedPointerTable::clear();
 402 #endif
 403 
 404     {
 405       uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 406       task_queues()-&gt;reserve(nworkers);
<span class="line-modified"> 407       ShenandoahRootProcessor rp(_heap, nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);</span>
<span class="line-modified"> 408 </span>
<span class="line-removed"> 409       ShenandoahCsetCodeRootsIterator cset_coderoots = ShenandoahCodeRoots::cset_iterator();</span>
<span class="line-removed"> 410 </span>
<span class="line-removed"> 411       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp, &amp;cset_coderoots);</span>
 412       _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
 413     }
 414 
<span class="line-modified"> 415 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 416     DerivedPointerTable::update_pointers();
 417 #endif
 418   }
 419 
 420   if (ShenandoahPacing) {
 421     _heap-&gt;pacer()-&gt;setup_for_traversal();
 422   }
 423 }
 424 
<span class="line-modified"> 425 void ShenandoahTraversalGC::main_loop(uint w, ShenandoahTaskTerminator* t, bool sts_yield) {</span>
 426   ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
 427 
 428   // Initialize live data.
 429   jushort* ld = _heap-&gt;get_liveness_cache(w);
 430 
 431   ReferenceProcessor* rp = NULL;
 432   if (_heap-&gt;process_references()) {
 433     rp = _heap-&gt;ref_processor();
 434   }
 435   {
 436     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
 437       if (_heap-&gt;unload_classes()) {
 438         if (ShenandoahStringDedup::is_enabled()) {
 439           ShenandoahTraversalMetadataDedupClosure cl(q, rp);
 440           main_loop_work&lt;ShenandoahTraversalMetadataDedupClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 441         } else {
 442           ShenandoahTraversalMetadataClosure cl(q, rp);
 443           main_loop_work&lt;ShenandoahTraversalMetadataClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 444         }
 445       } else {
</pre>
<hr />
<pre>
 459         } else {
 460           ShenandoahTraversalMetadataDegenClosure cl(q, rp);
 461           main_loop_work&lt;ShenandoahTraversalMetadataDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 462         }
 463       } else {
 464         if (ShenandoahStringDedup::is_enabled()) {
 465           ShenandoahTraversalDedupDegenClosure cl(q, rp);
 466           main_loop_work&lt;ShenandoahTraversalDedupDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 467         } else {
 468           ShenandoahTraversalDegenClosure cl(q, rp);
 469           main_loop_work&lt;ShenandoahTraversalDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 470         }
 471       }
 472     }
 473   }
 474 
 475   _heap-&gt;flush_liveness_cache(w);
 476 }
 477 
 478 template &lt;class T&gt;
<span class="line-modified"> 479 void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
 480   ShenandoahObjToScanQueueSet* queues = task_queues();
 481   ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 482   ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
 483 
 484   uintx stride = ShenandoahMarkLoopStride;
 485 
 486   ShenandoahMarkTask task;
 487 
 488   // Process outstanding queues, if any.
 489   q = queues-&gt;claim_next();
 490   while (q != NULL) {
 491     if (_heap-&gt;check_cancelled_gc_and_yield(sts_yield)) {
 492       return;
 493     }
 494 
 495     for (uint i = 0; i &lt; stride; i++) {
 496       if (q-&gt;pop(task)) {
 497         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 498       } else {
 499         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
</pre>
<hr />
<pre>
 514   while (true) {
 515     if (check_and_handle_cancelled_gc(terminator, sts_yield)) return;
 516 
 517     while (satb_mq_set.completed_buffers_num() &gt; 0) {
 518       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
 519     }
 520 
 521     uint work = 0;
 522     for (uint i = 0; i &lt; stride; i++) {
 523       if (q-&gt;pop(task) ||
 524           queues-&gt;steal(worker_id, task)) {
 525         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 526         work++;
 527       } else {
 528         break;
 529       }
 530     }
 531 
 532     if (work == 0) {
 533       // No more work, try to terminate
<span class="line-removed"> 534       ShenandoahEvacOOMScopeLeaver oom_scope_leaver;</span>
 535       ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
 536       ShenandoahTerminationTimingsTracker term_tracker(worker_id);
 537       ShenandoahTerminatorTerminator tt(_heap);
 538 
 539       if (terminator-&gt;offer_termination(&amp;tt)) return;
 540     }
 541   }
 542 }
 543 
<span class="line-modified"> 544 bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
 545   if (_heap-&gt;cancelled_gc()) {
 546     return true;
 547   }
 548   return false;
 549 }
 550 
 551 void ShenandoahTraversalGC::concurrent_traversal_collection() {
<span class="line-removed"> 552   ClassLoaderDataGraph::clear_claimed_marks();</span>
<span class="line-removed"> 553 </span>
 554   ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
 555   if (!_heap-&gt;cancelled_gc()) {
 556     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 557     task_queues()-&gt;reserve(nworkers);
 558     ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
 559 
<span class="line-modified"> 560     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
 561     ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
 562     _heap-&gt;workers()-&gt;run_task(&amp;task);
 563   }
 564 
 565   if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
 566     preclean_weak_refs();
 567   }
 568 }
 569 
 570 void ShenandoahTraversalGC::final_traversal_collection() {
 571   _heap-&gt;make_parsable(true);
 572 
 573   if (!_heap-&gt;cancelled_gc()) {
<span class="line-modified"> 574 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 575     DerivedPointerTable::clear();
 576 #endif
 577     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
 578     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 579     task_queues()-&gt;reserve(nworkers);
 580 
 581     // Finish traversal
<span class="line-modified"> 582     ShenandoahRootProcessor rp(_heap, nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);</span>
 583     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
 584 
<span class="line-modified"> 585     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
 586     ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
 587     _heap-&gt;workers()-&gt;run_task(&amp;task);
<span class="line-modified"> 588 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 589     DerivedPointerTable::update_pointers();
 590 #endif
 591   }
 592 
 593   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
 594     weak_refs_work();
 595   }
 596 
<span class="line-removed"> 597   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;unload_classes()) {</span>
<span class="line-removed"> 598     _heap-&gt;unload_classes_and_cleanup_tables(false);</span>
<span class="line-removed"> 599     fixup_roots();</span>
<span class="line-removed"> 600   }</span>
<span class="line-removed"> 601 </span>
 602   if (!_heap-&gt;cancelled_gc()) {
 603     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
 604     TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
 605     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 606 
 607     // No more marking expected

 608     _heap-&gt;mark_complete_marking_context();
 609 





 610     // Resize metaspace
 611     MetaspaceGC::compute_new_size();
 612 







 613     // Still good? We can now trash the cset, and make final verification
 614     {
 615       ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_cleanup);
 616       ShenandoahHeapLocker lock(_heap-&gt;lock());
 617 
 618       // Trash everything
 619       // Clear immediate garbage regions.
 620       size_t num_regions = _heap-&gt;num_regions();
 621 
 622       ShenandoahHeapRegionSet* traversal_regions = traversal_set();
 623       ShenandoahFreeSet* free_regions = _heap-&gt;free_set();
 624       ShenandoahMarkingContext* const ctx = _heap-&gt;marking_context();
 625       free_regions-&gt;clear();
 626       for (size_t i = 0; i &lt; num_regions; i++) {
 627         ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
 628         bool not_allocated = ctx-&gt;top_at_mark_start(r) == r-&gt;top();
 629 
 630         bool candidate = traversal_regions-&gt;is_in(r) &amp;&amp; !r-&gt;has_live() &amp;&amp; not_allocated;
 631         if (r-&gt;is_humongous_start() &amp;&amp; candidate) {
 632           // Trash humongous.
<span class="line-modified"> 633           HeapWord* humongous_obj = r-&gt;bottom() + ShenandoahBrooksPointer::word_size();</span>
 634           assert(!ctx-&gt;is_marked(oop(humongous_obj)), &quot;must not be marked&quot;);
 635           r-&gt;make_trash_immediate();
 636           while (i + 1 &lt; num_regions &amp;&amp; _heap-&gt;get_region(i + 1)-&gt;is_humongous_continuation()) {
 637             i++;
 638             r = _heap-&gt;get_region(i);
 639             assert(r-&gt;is_humongous_continuation(), &quot;must be humongous continuation&quot;);
 640             r-&gt;make_trash_immediate();
 641           }
 642         } else if (!r-&gt;is_empty() &amp;&amp; candidate) {
 643           // Trash regular.
 644           assert(!r-&gt;is_humongous(), &quot;handled above&quot;);
 645           assert(!r-&gt;is_trash(), &quot;must not already be trashed&quot;);
 646           r-&gt;make_trash_immediate();
 647         }
 648       }
 649       _heap-&gt;collection_set()-&gt;clear();
 650       _heap-&gt;free_set()-&gt;rebuild();
 651       reset();
 652     }
 653 
 654     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
<span class="line-removed"> 655     _heap-&gt;set_concurrent_traversal_in_progress(false);</span>
 656     assert(!_heap-&gt;cancelled_gc(), &quot;must not be cancelled when getting out here&quot;);
 657 
 658     if (ShenandoahVerify) {
 659       _heap-&gt;verifier()-&gt;verify_after_traversal();
 660     }





 661 
 662     if (VerifyAfterGC) {
 663       Universe::verify();
 664     }
 665   }
 666 }
 667 
























 668 class ShenandoahTraversalFixRootsClosure : public OopClosure {
 669 private:
 670   template &lt;class T&gt;
 671   inline void do_oop_work(T* p) {
 672     T o = RawAccess&lt;&gt;::oop_load(p);
 673     if (!CompressedOops::is_null(o)) {
 674       oop obj = CompressedOops::decode_not_null(o);
 675       oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified"> 676       if (!oopDesc::equals_raw(obj, forw)) {</span>
 677         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);
 678       }
 679     }
 680   }
 681 
 682 public:
 683   inline void do_oop(oop* p) { do_oop_work(p); }
 684   inline void do_oop(narrowOop* p) { do_oop_work(p); }
 685 };
 686 
 687 class ShenandoahTraversalFixRootsTask : public AbstractGangTask {
 688 private:
<span class="line-modified"> 689   ShenandoahRootProcessor* _rp;</span>
 690 
 691 public:
<span class="line-modified"> 692   ShenandoahTraversalFixRootsTask(ShenandoahRootProcessor* rp) :</span>
 693     AbstractGangTask(&quot;Shenandoah traversal fix roots&quot;),
<span class="line-modified"> 694     _rp(rp) {}</span>


 695 
 696   void work(uint worker_id) {
 697     ShenandoahParallelWorkerSession worker_session(worker_id);
 698     ShenandoahTraversalFixRootsClosure cl;
<span class="line-modified"> 699     MarkingCodeBlobClosure blobsCl(&amp;cl, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified"> 700     CLDToOopClosure cldCl(&amp;cl, ClassLoaderData::_claim_strong);</span>
<span class="line-removed"> 701     _rp-&gt;process_all_roots(&amp;cl, &amp;cl, &amp;cldCl, &amp;blobsCl, NULL, worker_id);</span>
 702   }
 703 };
 704 
 705 void ShenandoahTraversalGC::fixup_roots() {
<span class="line-modified"> 706 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 707   DerivedPointerTable::clear();
 708 #endif
<span class="line-modified"> 709   ShenandoahRootProcessor rp(_heap, _heap-&gt;workers()-&gt;active_workers(), ShenandoahPhaseTimings::final_traversal_update_roots);</span>
 710   ShenandoahTraversalFixRootsTask update_roots_task(&amp;rp);
 711   _heap-&gt;workers()-&gt;run_task(&amp;update_roots_task);
<span class="line-modified"> 712 #if defined(COMPILER2) || INCLUDE_JVMCI</span>
 713   DerivedPointerTable::update_pointers();
 714 #endif
 715 }
 716 
 717 void ShenandoahTraversalGC::reset() {
 718   _task_queues-&gt;clear();
 719 }
 720 
 721 ShenandoahObjToScanQueueSet* ShenandoahTraversalGC::task_queues() {
 722   return _task_queues;
 723 }
 724 
 725 class ShenandoahTraversalCancelledGCYieldClosure : public YieldClosure {
 726 private:
 727   ShenandoahHeap* const _heap;
 728 public:
 729   ShenandoahTraversalCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
 730   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
 731 };
 732 
 733 class ShenandoahTraversalPrecleanCompleteGCClosure : public VoidClosure {
 734 public:
 735   void do_void() {
 736     ShenandoahHeap* sh = ShenandoahHeap::heap();
 737     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 738     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified"> 739     ShenandoahTaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
 740     shenandoah_assert_rp_isalive_installed();
 741     traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
 742   }
 743 };
 744 
 745 class ShenandoahTraversalKeepAliveUpdateClosure : public OopClosure {
 746 private:
 747   ShenandoahObjToScanQueue* _queue;
 748   Thread* _thread;
 749   ShenandoahTraversalGC* _traversal_gc;
 750   ShenandoahMarkingContext* const _mark_context;
 751 
 752   template &lt;class T&gt;
 753   inline void do_oop_work(T* p) {
<span class="line-modified"> 754     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
 755   }
 756 
 757 public:
 758   ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 759     _queue(q), _thread(Thread::current()),
 760     _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 761     _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 762 
 763   void do_oop(narrowOop* p) { do_oop_work(p); }
 764   void do_oop(oop* p)       { do_oop_work(p); }
 765 };
 766 
<span class="line-removed"> 767 class ShenandoahTraversalWeakUpdateClosure : public OopClosure {</span>
<span class="line-removed"> 768 private:</span>
<span class="line-removed"> 769   template &lt;class T&gt;</span>
<span class="line-removed"> 770   inline void do_oop_work(T* p) {</span>
<span class="line-removed"> 771     // Cannot call maybe_update_with_forwarded, because on traversal-degen</span>
<span class="line-removed"> 772     // path the collection set is already dropped. Instead, do the unguarded store.</span>
<span class="line-removed"> 773     // TODO: This can be fixed after degen-traversal stops dropping cset.</span>
<span class="line-removed"> 774     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 775     if (!CompressedOops::is_null(o)) {</span>
<span class="line-removed"> 776       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-removed"> 777       obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-removed"> 778       shenandoah_assert_marked(p, obj);</span>
<span class="line-removed"> 779       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, obj);</span>
<span class="line-removed"> 780     }</span>
<span class="line-removed"> 781   }</span>
<span class="line-removed"> 782 </span>
<span class="line-removed"> 783 public:</span>
<span class="line-removed"> 784   ShenandoahTraversalWeakUpdateClosure() {}</span>
<span class="line-removed"> 785 </span>
<span class="line-removed"> 786   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed"> 787   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed"> 788 };</span>
<span class="line-removed"> 789 </span>
 790 class ShenandoahTraversalKeepAliveUpdateDegenClosure : public OopClosure {
 791 private:
 792   ShenandoahObjToScanQueue* _queue;
 793   Thread* _thread;
 794   ShenandoahTraversalGC* _traversal_gc;
 795   ShenandoahMarkingContext* const _mark_context;
 796 
 797   template &lt;class T&gt;
 798   inline void do_oop_work(T* p) {
<span class="line-modified"> 799     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
 800   }
 801 
 802 public:
 803   ShenandoahTraversalKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
 804           _queue(q), _thread(Thread::current()),
 805           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 806           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 807 
 808   void do_oop(narrowOop* p) { do_oop_work(p); }
 809   void do_oop(oop* p)       { do_oop_work(p); }
 810 };
 811 
 812 class ShenandoahTraversalSingleThreadKeepAliveUpdateClosure : public OopClosure {
 813 private:
 814   ShenandoahObjToScanQueue* _queue;
 815   Thread* _thread;
 816   ShenandoahTraversalGC* _traversal_gc;
 817   ShenandoahMarkingContext* const _mark_context;
 818 
 819   template &lt;class T&gt;
 820   inline void do_oop_work(T* p) {
<span class="line-modified"> 821     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-removed"> 822     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
 823   }
 824 
 825 public:
 826   ShenandoahTraversalSingleThreadKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 827           _queue(q), _thread(Thread::current()),
 828           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 829           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 830 
 831   void do_oop(narrowOop* p) { do_oop_work(p); }
 832   void do_oop(oop* p)       { do_oop_work(p); }
 833 };
 834 
 835 class ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure : public OopClosure {
 836 private:
 837   ShenandoahObjToScanQueue* _queue;
 838   Thread* _thread;
 839   ShenandoahTraversalGC* _traversal_gc;
 840   ShenandoahMarkingContext* const _mark_context;
 841 
 842   template &lt;class T&gt;
 843   inline void do_oop_work(T* p) {
<span class="line-modified"> 844     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-removed"> 845     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */&gt;(p, _thread, _queue, _mark_context);</span>
 846   }
 847 
 848 public:
 849   ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
 850           _queue(q), _thread(Thread::current()),
 851           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 852           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 853 
 854   void do_oop(narrowOop* p) { do_oop_work(p); }
 855   void do_oop(oop* p)       { do_oop_work(p); }
 856 };
 857 
 858 class ShenandoahTraversalPrecleanTask : public AbstractGangTask {
 859 private:
 860   ReferenceProcessor* _rp;
 861 
 862 public:
 863   ShenandoahTraversalPrecleanTask(ReferenceProcessor* rp) :
 864           AbstractGangTask(&quot;Precleaning task&quot;),
 865           _rp(rp) {}
 866 
 867   void work(uint worker_id) {
 868     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
 869     ShenandoahParallelWorkerSession worker_session(worker_id);
 870     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
<span class="line-removed"> 871     ShenandoahEvacOOMScope oom_evac_scope;</span>
 872 
 873     ShenandoahHeap* sh = ShenandoahHeap::heap();
 874 
 875     ShenandoahObjToScanQueue* q = sh-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id);
 876 
 877     ShenandoahForwardedIsAliveClosure is_alive;
 878     ShenandoahTraversalCancelledGCYieldClosure yield;
 879     ShenandoahTraversalPrecleanCompleteGCClosure complete_gc;
 880     ShenandoahTraversalKeepAliveUpdateClosure keep_alive(q);
 881     ResourceMark rm;
 882     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,
 883                                         &amp;complete_gc, &amp;yield,
 884                                         NULL);
 885   }
 886 };
 887 
 888 void ShenandoahTraversalGC::preclean_weak_refs() {
 889   // Pre-cleaning weak references before diving into STW makes sense at the
 890   // end of concurrent mark. This will filter out the references which referents
 891   // are alive. Note that ReferenceProcessor already filters out these on reference
</pre>
<hr />
<pre>
 912 
 913   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
 914   // queues and other goodies. When upstream ReferenceProcessor starts supporting
 915   // parallel precleans, we can extend this to more threads.
 916   ShenandoahPushWorkerScope scope(_heap-&gt;workers(), 1, /* check_workers = */ false);
 917 
 918   WorkGang* workers = _heap-&gt;workers();
 919   uint nworkers = workers-&gt;active_workers();
 920   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
 921   task_queues()-&gt;reserve(nworkers);
 922 
 923   ShenandoahTraversalPrecleanTask task(rp);
 924   workers-&gt;run_task(&amp;task);
 925 
 926   assert(_heap-&gt;cancelled_gc() || task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 927 }
 928 
 929 // Weak Reference Closures
 930 class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
 931   uint _worker_id;
<span class="line-modified"> 932   ShenandoahTaskTerminator* _terminator;</span>
 933   bool _reset_terminator;
 934 
 935 public:
<span class="line-modified"> 936   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
 937     _worker_id(worker_id),
 938     _terminator(t),
 939     _reset_terminator(reset_terminator) {
 940   }
 941 
 942   void do_void() {
 943     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 944 
 945     ShenandoahHeap* sh = ShenandoahHeap::heap();
 946     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 947     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 948     shenandoah_assert_rp_isalive_installed();
 949 
 950     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 951 
 952     if (_reset_terminator) {
 953       _terminator-&gt;reset_for_reuse();
 954     }
 955   }
 956 };
 957 
 958 class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
 959   uint _worker_id;
<span class="line-modified"> 960   ShenandoahTaskTerminator* _terminator;</span>
 961   bool _reset_terminator;
 962 
 963 public:
<span class="line-modified"> 964   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
 965           _worker_id(worker_id),
 966           _terminator(t),
 967           _reset_terminator(reset_terminator) {
 968   }
 969 
 970   void do_void() {
 971     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 972 
 973     ShenandoahHeap* sh = ShenandoahHeap::heap();
 974     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 975     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 976     shenandoah_assert_rp_isalive_installed();
 977 
<span class="line-removed"> 978     ShenandoahEvacOOMScope evac_scope;</span>
 979     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 980 
 981     if (_reset_terminator) {
 982       _terminator-&gt;reset_for_reuse();
 983     }
 984   }
 985 };
 986 
 987 void ShenandoahTraversalGC::weak_refs_work() {
 988   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
 989 
 990   ShenandoahPhaseTimings::Phase phase_root = ShenandoahPhaseTimings::weakrefs;
 991 
 992   ShenandoahGCPhase phase(phase_root);
 993 
 994   ReferenceProcessor* rp = _heap-&gt;ref_processor();
 995 
 996   // NOTE: We cannot shortcut on has_discovered_references() here, because
 997   // we will miss marking JNI Weak refs then, see implementation in
 998   // ReferenceProcessor::process_discovered_references.
 999   weak_refs_work_doit();
1000 
1001   rp-&gt;verify_no_references_recorded();
1002   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
1003 
1004 }
1005 
1006 class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
1007 private:
1008   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">1009   ShenandoahTaskTerminator* _terminator;</span>
1010 
1011 public:
1012   ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">1013                                       ShenandoahTaskTerminator* t) :</span>
1014     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
1015     _proc_task(proc_task),
1016     _terminator(t) {
1017   }
1018 
1019   void work(uint worker_id) {
<span class="line-removed">1020     ShenandoahEvacOOMScope oom_evac_scope;</span>
1021     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1022     ShenandoahHeap* heap = ShenandoahHeap::heap();
1023     ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
1024 
1025     ShenandoahForwardedIsAliveClosure is_alive;
1026     if (!heap-&gt;is_degenerated_gc_in_progress()) {
1027       ShenandoahTraversalKeepAliveUpdateClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1028       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1029     } else {
1030       ShenandoahTraversalKeepAliveUpdateDegenClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1031       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1032     }
1033   }
1034 };
1035 
1036 class ShenandoahTraversalRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
1037 private:
1038   WorkGang* _workers;
1039 
1040 public:
1041   ShenandoahTraversalRefProcTaskExecutor(WorkGang* workers) : _workers(workers) {}
1042 
1043   // Executes a task using worker threads.
1044   void execute(ProcessTask&amp; task, uint ergo_workers) {
1045     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1046 
1047     ShenandoahHeap* heap = ShenandoahHeap::heap();
1048     ShenandoahTraversalGC* traversal_gc = heap-&gt;traversal_gc();
1049     ShenandoahPushWorkerQueuesScope scope(_workers,
1050                                           traversal_gc-&gt;task_queues(),
1051                                           ergo_workers,
1052                                           /* do_check = */ false);
1053     uint nworkers = _workers-&gt;active_workers();
1054     traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">1055     ShenandoahTaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
1056     ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
1057     _workers-&gt;run_task(&amp;proc_task_proxy);
1058   }
1059 };
1060 
1061 void ShenandoahTraversalGC::weak_refs_work_doit() {
1062   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1063 
1064   ShenandoahPhaseTimings::Phase phase_process = ShenandoahPhaseTimings::weakrefs_process;
1065 
1066   shenandoah_assert_rp_isalive_not_installed();
1067   ShenandoahForwardedIsAliveClosure is_alive;
1068   ReferenceProcessorIsAliveMutator fix_isalive(rp, &amp;is_alive);
1069 
1070   WorkGang* workers = _heap-&gt;workers();
1071   uint nworkers = workers-&gt;active_workers();
1072 
1073   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
1074   rp-&gt;set_active_mt_degree(nworkers);
1075 
1076   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
1077 
1078   // complete_gc and keep_alive closures instantiated here are only needed for
1079   // single-threaded path in RP. They share the queue 0 for tracking work, which
1080   // simplifies implementation. Since RP may decide to call complete_gc several
1081   // times, we need to be able to reuse the terminator.
1082   uint serial_worker_id = 0;
<span class="line-modified">1083   ShenandoahTaskTerminator terminator(1, task_queues());</span>
1084   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
1085   ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
1086 
1087   ShenandoahTraversalRefProcTaskExecutor executor(workers);
1088 
1089   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
1090   if (!_heap-&gt;is_degenerated_gc_in_progress()) {
1091     ShenandoahTraversalSingleThreadKeepAliveUpdateClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1092     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1093                                       &amp;complete_gc, &amp;executor,
1094                                       &amp;pt);
1095   } else {
1096     ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1097     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1098                                       &amp;complete_gc, &amp;executor,
1099                                       &amp;pt);
1100   }
1101 
<span class="line-modified">1102   {</span>
<span class="line-modified">1103     ShenandoahGCPhase phase(phase_process);</span>
<span class="line-removed">1104     ShenandoahTerminationTracker termination(ShenandoahPhaseTimings::weakrefs_termination);</span>
<span class="line-removed">1105 </span>
<span class="line-removed">1106     // Process leftover weak oops (using parallel version)</span>
<span class="line-removed">1107     ShenandoahTraversalWeakUpdateClosure cl;</span>
<span class="line-removed">1108     WeakProcessor::weak_oops_do(workers, &amp;is_alive, &amp;cl, 1);</span>
<span class="line-removed">1109 </span>
<span class="line-removed">1110     pt.print_all_references();</span>
<span class="line-removed">1111 </span>
<span class="line-removed">1112     assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);</span>
<span class="line-removed">1113   }</span>
1114 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  30 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  31 #include &quot;gc/shared/workgroup.hpp&quot;

  32 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-added">  33 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;</span>
  34 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.inline.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-modified">  44 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;</span>
  45 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
  48 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;
  49 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  50 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  51 
  52 #include &quot;memory/iterator.hpp&quot;
  53 #include &quot;memory/metaspace.hpp&quot;
  54 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  55 #include &quot;memory/universe.hpp&quot;</span>
  56 
  57 /**
  58  * NOTE: We are using the SATB buffer in thread.hpp and satbMarkQueue.hpp, however, it is not an SATB algorithm.
  59  * We&#39;re using the buffer as generic oop buffer to enqueue new values in concurrent oop stores, IOW, the algorithm
  60  * is incremental-update-based.
  61  *
  62  * NOTE on interaction with TAMS: we want to avoid traversing new objects for
  63  * several reasons:
  64  * - We will not reclaim them in this cycle anyway, because they are not in the
  65  *   cset
  66  * - It makes up for the bulk of work during final-pause
  67  * - It also shortens the concurrent cycle because we don&#39;t need to
  68  *   pointlessly traverse through newly allocated objects.
  69  * - As a nice side-effect, it solves the I-U termination problem (mutators
  70  *   cannot outrun the GC by allocating like crazy)
  71  * - It is an easy way to achieve MWF. What MWF does is to also enqueue the
  72  *   target object of stores if it&#39;s new. Treating new objects live implicitely
  73  *   achieves the same, but without extra barriers. I think the effect of
  74  *   shortened final-pause (mentioned above) is the main advantage of MWF. In
  75  *   particular, we will not see the head of a completely new long linked list
</pre>
<hr />
<pre>
 124 private:
 125   ShenandoahTraversalSATBBufferClosure* _satb_cl;
 126 
 127 public:
 128   ShenandoahTraversalSATBThreadsClosure(ShenandoahTraversalSATBBufferClosure* satb_cl) :
 129     _satb_cl(satb_cl) {}
 130 
 131   void do_thread(Thread* thread) {
 132     ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
 133   }
 134 };
 135 
 136 // Like CLDToOopClosure, but clears has_modified_oops, so that we can record modified CLDs during traversal
 137 // and remark them later during final-traversal.
 138 class ShenandoahMarkCLDClosure : public CLDClosure {
 139 private:
 140   OopClosure* _cl;
 141 public:
 142   ShenandoahMarkCLDClosure(OopClosure* cl) : _cl(cl) {}
 143   void do_cld(ClassLoaderData* cld) {
<span class="line-modified"> 144     cld-&gt;oops_do(_cl, ClassLoaderData::_claim_strong, true);</span>
 145   }
 146 };
 147 
 148 // Like CLDToOopClosure, but only process modified CLDs
 149 class ShenandoahRemarkCLDClosure : public CLDClosure {
 150 private:
 151   OopClosure* _cl;
 152 public:
 153   ShenandoahRemarkCLDClosure(OopClosure* cl) : _cl(cl) {}
 154   void do_cld(ClassLoaderData* cld) {
 155     if (cld-&gt;has_modified_oops()) {
<span class="line-modified"> 156       cld-&gt;oops_do(_cl, ClassLoaderData::_claim_strong, true);</span>
 157     }
 158   }
 159 };
 160 
 161 class ShenandoahInitTraversalCollectionTask : public AbstractGangTask {
 162 private:
<span class="line-modified"> 163   ShenandoahCSetRootScanner* _rp;</span>
 164   ShenandoahHeap* _heap;
 165   ShenandoahCsetCodeRootsIterator* _cset_coderoots;
<span class="line-added"> 166   ShenandoahStringDedupRoots       _dedup_roots;</span>
<span class="line-added"> 167 </span>
 168 public:
<span class="line-modified"> 169   ShenandoahInitTraversalCollectionTask(ShenandoahCSetRootScanner* rp) :</span>
 170     AbstractGangTask(&quot;Shenandoah Init Traversal Collection&quot;),
 171     _rp(rp),
<span class="line-modified"> 172     _heap(ShenandoahHeap::heap()) {}</span>

 173 
 174   void work(uint worker_id) {
 175     ShenandoahParallelWorkerSession worker_session(worker_id);
 176 

 177     ShenandoahObjToScanQueueSet* queues = _heap-&gt;traversal_gc()-&gt;task_queues();
 178     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 179 
 180     bool process_refs = _heap-&gt;process_references();
 181     bool unload_classes = _heap-&gt;unload_classes();
 182     ReferenceProcessor* rp = NULL;
 183     if (process_refs) {
 184       rp = _heap-&gt;ref_processor();
 185     }
 186 
 187     // Step 1: Process ordinary GC roots.
 188     {
<span class="line-modified"> 189       ShenandoahTraversalRootsClosure roots_cl(q, rp);</span>
 190       ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
 191       MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
 192       if (unload_classes) {
<span class="line-modified"> 193         _rp-&gt;roots_do(worker_id, &amp;roots_cl, NULL, &amp;code_cl);</span>




 194       } else {
<span class="line-modified"> 195         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, &amp;code_cl);</span>
 196       }
 197     }
 198   }
 199 };
 200 
 201 class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
 202 private:
<span class="line-modified"> 203   TaskTerminator* _terminator;</span>
 204   ShenandoahHeap* _heap;
 205 public:
<span class="line-modified"> 206   ShenandoahConcurrentTraversalCollectionTask(TaskTerminator* terminator) :</span>
 207     AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
 208     _terminator(terminator),
 209     _heap(ShenandoahHeap::heap()) {}
 210 
 211   void work(uint worker_id) {
 212     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 213     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);

 214     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 215 
 216     // Drain all outstanding work in queues.
 217     traversal_gc-&gt;main_loop(worker_id, _terminator, true);
 218   }
 219 };
 220 
 221 class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
 222 private:
<span class="line-modified"> 223   ShenandoahAllRootScanner* _rp;</span>
<span class="line-modified"> 224   TaskTerminator*           _terminator;</span>
 225   ShenandoahHeap* _heap;
 226 public:
<span class="line-modified"> 227   ShenandoahFinalTraversalCollectionTask(ShenandoahAllRootScanner* rp, TaskTerminator* terminator) :</span>
 228     AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
 229     _rp(rp),
 230     _terminator(terminator),
 231     _heap(ShenandoahHeap::heap()) {}
 232 
 233   void work(uint worker_id) {
 234     ShenandoahParallelWorkerSession worker_session(worker_id);
 235 

 236     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 237 
 238     ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
 239     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 240 
 241     bool process_refs = _heap-&gt;process_references();
 242     bool unload_classes = _heap-&gt;unload_classes();
 243     ReferenceProcessor* rp = NULL;
 244     if (process_refs) {
 245       rp = _heap-&gt;ref_processor();
 246     }
 247 
 248     // Step 0: Drain outstanding SATB queues.
 249     // NOTE: we piggy-back draining of remaining thread SATB buffers on the final root scan below.
 250     ShenandoahTraversalSATBBufferClosure satb_cl(q);
 251     {
 252       // Process remaining finished SATB buffers.
 253       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
 254       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;satb_cl));
 255       // Process remaining threads SATB buffers below.
 256     }
 257 
 258     // Step 1: Process GC roots.
 259     // For oops in code roots, they are marked, evacuated, enqueued for further traversal,
 260     // and the references to the oops are updated during init pause. New nmethods are handled
 261     // in similar way during nmethod-register process. Therefore, we don&#39;t need to rescan code
 262     // roots here.
 263     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
<span class="line-modified"> 264       ShenandoahTraversalRootsClosure roots_cl(q, rp);</span>

 265       ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
 266       if (unload_classes) {
<span class="line-modified"> 267         ShenandoahRemarkCLDClosure remark_cld_cl(&amp;roots_cl);</span>
<span class="line-modified"> 268         _rp-&gt;strong_roots_do(worker_id, &amp;roots_cl, &amp;remark_cld_cl, NULL, &amp;tc);</span>
 269       } else {
<span class="line-modified"> 270         CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added"> 271         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc);</span>
 272       }
 273     } else {
 274       ShenandoahTraversalDegenClosure roots_cl(q, rp);

 275       ShenandoahTraversalSATBThreadsClosure tc(&amp;satb_cl);
 276       if (unload_classes) {
<span class="line-modified"> 277         ShenandoahRemarkCLDClosure remark_cld_cl(&amp;roots_cl);</span>
<span class="line-modified"> 278         _rp-&gt;strong_roots_do(worker_id, &amp;roots_cl, &amp;remark_cld_cl, NULL, &amp;tc);</span>
 279       } else {
<span class="line-modified"> 280         CLDToOopClosure cld_cl(&amp;roots_cl, ClassLoaderData::_claim_strong);</span>
<span class="line-added"> 281         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, NULL, &amp;tc);</span>
 282       }
 283     }
 284 
 285     {
 286       ShenandoahWorkerTimings *worker_times = _heap-&gt;phase_timings()-&gt;worker_times();
 287       ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::FinishQueues, worker_id);
 288 
 289       // Step 3: Finally drain all outstanding work in queues.
 290       traversal_gc-&gt;main_loop(worker_id, _terminator, false);
 291     }
 292 
 293   }
 294 };
 295 
 296 ShenandoahTraversalGC::ShenandoahTraversalGC(ShenandoahHeap* heap, size_t num_regions) :
 297   _heap(heap),
 298   _task_queues(new ShenandoahObjToScanQueueSet(heap-&gt;max_workers())),
 299   _traversal_set(ShenandoahHeapRegionSet()) {
 300 
<span class="line-added"> 301   // Traversal does not support concurrent code root scanning</span>
<span class="line-added"> 302   FLAG_SET_DEFAULT(ShenandoahConcurrentScanCodeRoots, false);</span>
<span class="line-added"> 303 </span>
 304   uint num_queues = heap-&gt;max_workers();
 305   for (uint i = 0; i &lt; num_queues; ++i) {
 306     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
 307     task_queue-&gt;initialize();
 308     _task_queues-&gt;register_queue(i, task_queue);
 309   }
 310 }
 311 
 312 ShenandoahTraversalGC::~ShenandoahTraversalGC() {
 313 }
 314 
 315 void ShenandoahTraversalGC::prepare_regions() {
 316   size_t num_regions = _heap-&gt;num_regions();
 317   ShenandoahMarkingContext* const ctx = _heap-&gt;marking_context();
 318   for (size_t i = 0; i &lt; num_regions; i++) {
 319     ShenandoahHeapRegion* region = _heap-&gt;get_region(i);
 320     if (_heap-&gt;is_bitmap_slice_committed(region)) {
 321       if (_traversal_set.is_in(i)) {
 322         ctx-&gt;capture_top_at_mark_start(region);
 323         region-&gt;clear_live_data();
 324         assert(ctx-&gt;is_bitmap_clear_range(region-&gt;bottom(), region-&gt;end()), &quot;bitmap for traversal regions must be cleared&quot;);
 325       } else {
 326         // Everything outside the traversal set is always considered live.
 327         ctx-&gt;reset_top_at_mark_start(region);
 328       }
 329     } else {
 330       // FreeSet may contain uncommitted empty regions, once they are recommitted,
 331       // their TAMS may have old values, so reset them here.
 332       ctx-&gt;reset_top_at_mark_start(region);
 333     }
 334   }
 335 }
 336 
 337 void ShenandoahTraversalGC::prepare() {



 338   {
 339     ShenandoahGCPhase phase(ShenandoahPhaseTimings::traversal_gc_make_parsable);
 340     _heap-&gt;make_parsable(true);
 341   }
 342 
 343   if (UseTLAB) {
 344     ShenandoahGCPhase phase(ShenandoahPhaseTimings::traversal_gc_resize_tlabs);
 345     _heap-&gt;resize_tlabs();
 346   }
 347 
 348   assert(_heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;need clean mark bitmap&quot;);
 349   assert(!_heap-&gt;marking_context()-&gt;is_complete(), &quot;should not be complete&quot;);
 350 
<span class="line-modified"> 351   // About to choose the collection set, make sure we know which regions are pinned.</span>
<span class="line-added"> 352   {</span>
<span class="line-added"> 353     ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_prepare_sync_pinned);</span>
<span class="line-added"> 354     _heap-&gt;sync_pinned_region_status();</span>
<span class="line-added"> 355   }</span>
<span class="line-added"> 356 </span>
 357   ShenandoahCollectionSet* collection_set = _heap-&gt;collection_set();
<span class="line-added"> 358   {</span>
<span class="line-added"> 359     ShenandoahHeapLocker lock(_heap-&gt;lock());</span>
 360 
<span class="line-modified"> 361     collection_set-&gt;clear();</span>
<span class="line-modified"> 362     assert(collection_set-&gt;count() == 0, &quot;collection set not clear&quot;);</span>

 363 
<span class="line-modified"> 364     // Find collection set</span>
<span class="line-modified"> 365     _heap-&gt;heuristics()-&gt;choose_collection_set(collection_set);</span>
<span class="line-added"> 366     prepare_regions();</span>
 367 
<span class="line-modified"> 368     // Rebuild free set</span>
<span class="line-modified"> 369     _heap-&gt;free_set()-&gt;rebuild();</span>
<span class="line-added"> 370   }</span>
<span class="line-added"> 371 </span>
<span class="line-added"> 372   log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;%s, &quot; SIZE_FORMAT &quot;%s CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-added"> 373                      byte_size_in_proper_unit(collection_set-&gt;garbage()),   proper_unit_for_byte_size(collection_set-&gt;garbage()),</span>
<span class="line-added"> 374                      byte_size_in_proper_unit(collection_set-&gt;live_data()), proper_unit_for_byte_size(collection_set-&gt;live_data()),</span>
<span class="line-added"> 375                      collection_set-&gt;count());</span>
 376 }
 377 
 378 void ShenandoahTraversalGC::init_traversal_collection() {
 379   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;STW traversal GC&quot;);
 380 
 381   if (ShenandoahVerify) {
 382     _heap-&gt;verifier()-&gt;verify_before_traversal();
 383   }
 384 
 385   if (VerifyBeforeGC) {
 386     Universe::verify();
 387   }
 388 
 389   {
 390     ShenandoahGCPhase phase_prepare(ShenandoahPhaseTimings::traversal_gc_prepare);

 391     prepare();
 392   }
 393 
 394   _heap-&gt;set_concurrent_traversal_in_progress(true);
<span class="line-added"> 395   _heap-&gt;set_has_forwarded_objects(true);</span>
 396 
 397   bool process_refs = _heap-&gt;process_references();
 398   if (process_refs) {
 399     ReferenceProcessor* rp = _heap-&gt;ref_processor();
 400     rp-&gt;enable_discovery(true /*verify_no_refs*/);
 401     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
 402   }
 403 
 404   {
 405     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::init_traversal_gc_work);
 406     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty before traversal GC&quot;);
 407     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 408 
<span class="line-modified"> 409 #if COMPILER2_OR_JVMCI</span>
 410     DerivedPointerTable::clear();
 411 #endif
 412 
 413     {
 414       uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 415       task_queues()-&gt;reserve(nworkers);
<span class="line-modified"> 416       ShenandoahCSetRootScanner rp(nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);</span>
<span class="line-modified"> 417       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp);</span>



 418       _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
 419     }
 420 
<span class="line-modified"> 421 #if COMPILER2_OR_JVMCI</span>
 422     DerivedPointerTable::update_pointers();
 423 #endif
 424   }
 425 
 426   if (ShenandoahPacing) {
 427     _heap-&gt;pacer()-&gt;setup_for_traversal();
 428   }
 429 }
 430 
<span class="line-modified"> 431 void ShenandoahTraversalGC::main_loop(uint w, TaskTerminator* t, bool sts_yield) {</span>
 432   ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
 433 
 434   // Initialize live data.
 435   jushort* ld = _heap-&gt;get_liveness_cache(w);
 436 
 437   ReferenceProcessor* rp = NULL;
 438   if (_heap-&gt;process_references()) {
 439     rp = _heap-&gt;ref_processor();
 440   }
 441   {
 442     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
 443       if (_heap-&gt;unload_classes()) {
 444         if (ShenandoahStringDedup::is_enabled()) {
 445           ShenandoahTraversalMetadataDedupClosure cl(q, rp);
 446           main_loop_work&lt;ShenandoahTraversalMetadataDedupClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 447         } else {
 448           ShenandoahTraversalMetadataClosure cl(q, rp);
 449           main_loop_work&lt;ShenandoahTraversalMetadataClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 450         }
 451       } else {
</pre>
<hr />
<pre>
 465         } else {
 466           ShenandoahTraversalMetadataDegenClosure cl(q, rp);
 467           main_loop_work&lt;ShenandoahTraversalMetadataDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 468         }
 469       } else {
 470         if (ShenandoahStringDedup::is_enabled()) {
 471           ShenandoahTraversalDedupDegenClosure cl(q, rp);
 472           main_loop_work&lt;ShenandoahTraversalDedupDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 473         } else {
 474           ShenandoahTraversalDegenClosure cl(q, rp);
 475           main_loop_work&lt;ShenandoahTraversalDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 476         }
 477       }
 478     }
 479   }
 480 
 481   _heap-&gt;flush_liveness_cache(w);
 482 }
 483 
 484 template &lt;class T&gt;
<span class="line-modified"> 485 void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, TaskTerminator* terminator, bool sts_yield) {</span>
 486   ShenandoahObjToScanQueueSet* queues = task_queues();
 487   ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 488   ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
 489 
 490   uintx stride = ShenandoahMarkLoopStride;
 491 
 492   ShenandoahMarkTask task;
 493 
 494   // Process outstanding queues, if any.
 495   q = queues-&gt;claim_next();
 496   while (q != NULL) {
 497     if (_heap-&gt;check_cancelled_gc_and_yield(sts_yield)) {
 498       return;
 499     }
 500 
 501     for (uint i = 0; i &lt; stride; i++) {
 502       if (q-&gt;pop(task)) {
 503         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 504       } else {
 505         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
</pre>
<hr />
<pre>
 520   while (true) {
 521     if (check_and_handle_cancelled_gc(terminator, sts_yield)) return;
 522 
 523     while (satb_mq_set.completed_buffers_num() &gt; 0) {
 524       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
 525     }
 526 
 527     uint work = 0;
 528     for (uint i = 0; i &lt; stride; i++) {
 529       if (q-&gt;pop(task) ||
 530           queues-&gt;steal(worker_id, task)) {
 531         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 532         work++;
 533       } else {
 534         break;
 535       }
 536     }
 537 
 538     if (work == 0) {
 539       // No more work, try to terminate

 540       ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
 541       ShenandoahTerminationTimingsTracker term_tracker(worker_id);
 542       ShenandoahTerminatorTerminator tt(_heap);
 543 
 544       if (terminator-&gt;offer_termination(&amp;tt)) return;
 545     }
 546   }
 547 }
 548 
<span class="line-modified"> 549 bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(TaskTerminator* terminator, bool sts_yield) {</span>
 550   if (_heap-&gt;cancelled_gc()) {
 551     return true;
 552   }
 553   return false;
 554 }
 555 
 556 void ShenandoahTraversalGC::concurrent_traversal_collection() {


 557   ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
 558   if (!_heap-&gt;cancelled_gc()) {
 559     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 560     task_queues()-&gt;reserve(nworkers);
 561     ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
 562 
<span class="line-modified"> 563     TaskTerminator terminator(nworkers, task_queues());</span>
 564     ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
 565     _heap-&gt;workers()-&gt;run_task(&amp;task);
 566   }
 567 
 568   if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
 569     preclean_weak_refs();
 570   }
 571 }
 572 
 573 void ShenandoahTraversalGC::final_traversal_collection() {
 574   _heap-&gt;make_parsable(true);
 575 
 576   if (!_heap-&gt;cancelled_gc()) {
<span class="line-modified"> 577 #if COMPILER2_OR_JVMCI</span>
 578     DerivedPointerTable::clear();
 579 #endif
 580     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
 581     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 582     task_queues()-&gt;reserve(nworkers);
 583 
 584     // Finish traversal
<span class="line-modified"> 585     ShenandoahAllRootScanner rp(nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);</span>
 586     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
 587 
<span class="line-modified"> 588     TaskTerminator terminator(nworkers, task_queues());</span>
 589     ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
 590     _heap-&gt;workers()-&gt;run_task(&amp;task);
<span class="line-modified"> 591 #if COMPILER2_OR_JVMCI</span>
 592     DerivedPointerTable::update_pointers();
 593 #endif
 594   }
 595 
 596   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
 597     weak_refs_work();
 598   }
 599 





 600   if (!_heap-&gt;cancelled_gc()) {
 601     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
 602     TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
 603     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 604 
 605     // No more marking expected
<span class="line-added"> 606     _heap-&gt;set_concurrent_traversal_in_progress(false);</span>
 607     _heap-&gt;mark_complete_marking_context();
 608 
<span class="line-added"> 609     _heap-&gt;parallel_cleaning(false);</span>
<span class="line-added"> 610     fixup_roots();</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612     _heap-&gt;set_has_forwarded_objects(false);</span>
<span class="line-added"> 613 </span>
 614     // Resize metaspace
 615     MetaspaceGC::compute_new_size();
 616 
<span class="line-added"> 617     // Need to see that pinned region status is updated: newly pinned regions must not</span>
<span class="line-added"> 618     // be trashed. New unpinned regions should be trashed.</span>
<span class="line-added"> 619     {</span>
<span class="line-added"> 620       ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_sync_pinned);</span>
<span class="line-added"> 621       _heap-&gt;sync_pinned_region_status();</span>
<span class="line-added"> 622     }</span>
<span class="line-added"> 623 </span>
 624     // Still good? We can now trash the cset, and make final verification
 625     {
 626       ShenandoahGCPhase phase_cleanup(ShenandoahPhaseTimings::traversal_gc_cleanup);
 627       ShenandoahHeapLocker lock(_heap-&gt;lock());
 628 
 629       // Trash everything
 630       // Clear immediate garbage regions.
 631       size_t num_regions = _heap-&gt;num_regions();
 632 
 633       ShenandoahHeapRegionSet* traversal_regions = traversal_set();
 634       ShenandoahFreeSet* free_regions = _heap-&gt;free_set();
 635       ShenandoahMarkingContext* const ctx = _heap-&gt;marking_context();
 636       free_regions-&gt;clear();
 637       for (size_t i = 0; i &lt; num_regions; i++) {
 638         ShenandoahHeapRegion* r = _heap-&gt;get_region(i);
 639         bool not_allocated = ctx-&gt;top_at_mark_start(r) == r-&gt;top();
 640 
 641         bool candidate = traversal_regions-&gt;is_in(r) &amp;&amp; !r-&gt;has_live() &amp;&amp; not_allocated;
 642         if (r-&gt;is_humongous_start() &amp;&amp; candidate) {
 643           // Trash humongous.
<span class="line-modified"> 644           HeapWord* humongous_obj = r-&gt;bottom();</span>
 645           assert(!ctx-&gt;is_marked(oop(humongous_obj)), &quot;must not be marked&quot;);
 646           r-&gt;make_trash_immediate();
 647           while (i + 1 &lt; num_regions &amp;&amp; _heap-&gt;get_region(i + 1)-&gt;is_humongous_continuation()) {
 648             i++;
 649             r = _heap-&gt;get_region(i);
 650             assert(r-&gt;is_humongous_continuation(), &quot;must be humongous continuation&quot;);
 651             r-&gt;make_trash_immediate();
 652           }
 653         } else if (!r-&gt;is_empty() &amp;&amp; candidate) {
 654           // Trash regular.
 655           assert(!r-&gt;is_humongous(), &quot;handled above&quot;);
 656           assert(!r-&gt;is_trash(), &quot;must not already be trashed&quot;);
 657           r-&gt;make_trash_immediate();
 658         }
 659       }
 660       _heap-&gt;collection_set()-&gt;clear();
 661       _heap-&gt;free_set()-&gt;rebuild();
 662       reset();
 663     }
 664 
 665     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);

 666     assert(!_heap-&gt;cancelled_gc(), &quot;must not be cancelled when getting out here&quot;);
 667 
 668     if (ShenandoahVerify) {
 669       _heap-&gt;verifier()-&gt;verify_after_traversal();
 670     }
<span class="line-added"> 671 #ifdef ASSERT</span>
<span class="line-added"> 672     else {</span>
<span class="line-added"> 673       verify_roots_after_gc();</span>
<span class="line-added"> 674     }</span>
<span class="line-added"> 675 #endif</span>
 676 
 677     if (VerifyAfterGC) {
 678       Universe::verify();
 679     }
 680   }
 681 }
 682 
<span class="line-added"> 683 class ShenandoahVerifyAfterGC : public OopClosure {</span>
<span class="line-added"> 684 private:</span>
<span class="line-added"> 685   template &lt;class T&gt;</span>
<span class="line-added"> 686   void do_oop_work(T* p) {</span>
<span class="line-added"> 687     T o = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added"> 688     if (!CompressedOops::is_null(o)) {</span>
<span class="line-added"> 689       oop obj = CompressedOops::decode_not_null(o);</span>
<span class="line-added"> 690       shenandoah_assert_correct(p, obj);</span>
<span class="line-added"> 691       shenandoah_assert_not_in_cset_except(p, obj, ShenandoahHeap::heap()-&gt;cancelled_gc());</span>
<span class="line-added"> 692       shenandoah_assert_not_forwarded(p, obj);</span>
<span class="line-added"> 693     }</span>
<span class="line-added"> 694   }</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696 public:</span>
<span class="line-added"> 697   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-added"> 698   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-added"> 699 };</span>
<span class="line-added"> 700 </span>
<span class="line-added"> 701 void ShenandoahTraversalGC::verify_roots_after_gc() {</span>
<span class="line-added"> 702   ShenandoahRootVerifier verifier;</span>
<span class="line-added"> 703   ShenandoahVerifyAfterGC cl;</span>
<span class="line-added"> 704   verifier.oops_do(&amp;cl);</span>
<span class="line-added"> 705 }</span>
<span class="line-added"> 706 </span>
 707 class ShenandoahTraversalFixRootsClosure : public OopClosure {
 708 private:
 709   template &lt;class T&gt;
 710   inline void do_oop_work(T* p) {
 711     T o = RawAccess&lt;&gt;::oop_load(p);
 712     if (!CompressedOops::is_null(o)) {
 713       oop obj = CompressedOops::decode_not_null(o);
 714       oop forw = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);
<span class="line-modified"> 715       if (obj != forw) {</span>
 716         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);
 717       }
 718     }
 719   }
 720 
 721 public:
 722   inline void do_oop(oop* p) { do_oop_work(p); }
 723   inline void do_oop(narrowOop* p) { do_oop_work(p); }
 724 };
 725 
 726 class ShenandoahTraversalFixRootsTask : public AbstractGangTask {
 727 private:
<span class="line-modified"> 728   ShenandoahRootUpdater* _rp;</span>
 729 
 730 public:
<span class="line-modified"> 731   ShenandoahTraversalFixRootsTask(ShenandoahRootUpdater* rp) :</span>
 732     AbstractGangTask(&quot;Shenandoah traversal fix roots&quot;),
<span class="line-modified"> 733     _rp(rp) {</span>
<span class="line-added"> 734     assert(ShenandoahHeap::heap()-&gt;has_forwarded_objects(), &quot;Must be&quot;);</span>
<span class="line-added"> 735   }</span>
 736 
 737   void work(uint worker_id) {
 738     ShenandoahParallelWorkerSession worker_session(worker_id);
 739     ShenandoahTraversalFixRootsClosure cl;
<span class="line-modified"> 740     ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified"> 741     _rp-&gt;roots_do(worker_id, &amp;is_alive, &amp;cl);</span>

 742   }
 743 };
 744 
 745 void ShenandoahTraversalGC::fixup_roots() {
<span class="line-modified"> 746 #if COMPILER2_OR_JVMCI</span>
 747   DerivedPointerTable::clear();
 748 #endif
<span class="line-modified"> 749   ShenandoahRootUpdater rp(_heap-&gt;workers()-&gt;active_workers(), ShenandoahPhaseTimings::final_traversal_update_roots);</span>
 750   ShenandoahTraversalFixRootsTask update_roots_task(&amp;rp);
 751   _heap-&gt;workers()-&gt;run_task(&amp;update_roots_task);
<span class="line-modified"> 752 #if COMPILER2_OR_JVMCI</span>
 753   DerivedPointerTable::update_pointers();
 754 #endif
 755 }
 756 
 757 void ShenandoahTraversalGC::reset() {
 758   _task_queues-&gt;clear();
 759 }
 760 
 761 ShenandoahObjToScanQueueSet* ShenandoahTraversalGC::task_queues() {
 762   return _task_queues;
 763 }
 764 
 765 class ShenandoahTraversalCancelledGCYieldClosure : public YieldClosure {
 766 private:
 767   ShenandoahHeap* const _heap;
 768 public:
 769   ShenandoahTraversalCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
 770   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
 771 };
 772 
 773 class ShenandoahTraversalPrecleanCompleteGCClosure : public VoidClosure {
 774 public:
 775   void do_void() {
 776     ShenandoahHeap* sh = ShenandoahHeap::heap();
 777     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 778     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified"> 779     TaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
 780     shenandoah_assert_rp_isalive_installed();
 781     traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
 782   }
 783 };
 784 
 785 class ShenandoahTraversalKeepAliveUpdateClosure : public OopClosure {
 786 private:
 787   ShenandoahObjToScanQueue* _queue;
 788   Thread* _thread;
 789   ShenandoahTraversalGC* _traversal_gc;
 790   ShenandoahMarkingContext* const _mark_context;
 791 
 792   template &lt;class T&gt;
 793   inline void do_oop_work(T* p) {
<span class="line-modified"> 794     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
 795   }
 796 
 797 public:
 798   ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 799     _queue(q), _thread(Thread::current()),
 800     _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 801     _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 802 
 803   void do_oop(narrowOop* p) { do_oop_work(p); }
 804   void do_oop(oop* p)       { do_oop_work(p); }
 805 };
 806 























 807 class ShenandoahTraversalKeepAliveUpdateDegenClosure : public OopClosure {
 808 private:
 809   ShenandoahObjToScanQueue* _queue;
 810   Thread* _thread;
 811   ShenandoahTraversalGC* _traversal_gc;
 812   ShenandoahMarkingContext* const _mark_context;
 813 
 814   template &lt;class T&gt;
 815   inline void do_oop_work(T* p) {
<span class="line-modified"> 816     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */, false /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>
 817   }
 818 
 819 public:
 820   ShenandoahTraversalKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
 821           _queue(q), _thread(Thread::current()),
 822           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 823           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 824 
 825   void do_oop(narrowOop* p) { do_oop_work(p); }
 826   void do_oop(oop* p)       { do_oop_work(p); }
 827 };
 828 
 829 class ShenandoahTraversalSingleThreadKeepAliveUpdateClosure : public OopClosure {
 830 private:
 831   ShenandoahObjToScanQueue* _queue;
 832   Thread* _thread;
 833   ShenandoahTraversalGC* _traversal_gc;
 834   ShenandoahMarkingContext* const _mark_context;
 835 
 836   template &lt;class T&gt;
 837   inline void do_oop_work(T* p) {
<span class="line-modified"> 838     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>

 839   }
 840 
 841 public:
 842   ShenandoahTraversalSingleThreadKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 843           _queue(q), _thread(Thread::current()),
 844           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 845           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 846 
 847   void do_oop(narrowOop* p) { do_oop_work(p); }
 848   void do_oop(oop* p)       { do_oop_work(p); }
 849 };
 850 
 851 class ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure : public OopClosure {
 852 private:
 853   ShenandoahObjToScanQueue* _queue;
 854   Thread* _thread;
 855   ShenandoahTraversalGC* _traversal_gc;
 856   ShenandoahMarkingContext* const _mark_context;
 857 
 858   template &lt;class T&gt;
 859   inline void do_oop_work(T* p) {
<span class="line-modified"> 860     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, true /* degen */, false /* atomic update */&gt;(p, _thread, _queue, _mark_context);</span>

 861   }
 862 
 863 public:
 864   ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure(ShenandoahObjToScanQueue* q) :
 865           _queue(q), _thread(Thread::current()),
 866           _traversal_gc(ShenandoahHeap::heap()-&gt;traversal_gc()),
 867           _mark_context(ShenandoahHeap::heap()-&gt;marking_context()) {}
 868 
 869   void do_oop(narrowOop* p) { do_oop_work(p); }
 870   void do_oop(oop* p)       { do_oop_work(p); }
 871 };
 872 
 873 class ShenandoahTraversalPrecleanTask : public AbstractGangTask {
 874 private:
 875   ReferenceProcessor* _rp;
 876 
 877 public:
 878   ShenandoahTraversalPrecleanTask(ReferenceProcessor* rp) :
 879           AbstractGangTask(&quot;Precleaning task&quot;),
 880           _rp(rp) {}
 881 
 882   void work(uint worker_id) {
 883     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
 884     ShenandoahParallelWorkerSession worker_session(worker_id);
 885     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);

 886 
 887     ShenandoahHeap* sh = ShenandoahHeap::heap();
 888 
 889     ShenandoahObjToScanQueue* q = sh-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id);
 890 
 891     ShenandoahForwardedIsAliveClosure is_alive;
 892     ShenandoahTraversalCancelledGCYieldClosure yield;
 893     ShenandoahTraversalPrecleanCompleteGCClosure complete_gc;
 894     ShenandoahTraversalKeepAliveUpdateClosure keep_alive(q);
 895     ResourceMark rm;
 896     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,
 897                                         &amp;complete_gc, &amp;yield,
 898                                         NULL);
 899   }
 900 };
 901 
 902 void ShenandoahTraversalGC::preclean_weak_refs() {
 903   // Pre-cleaning weak references before diving into STW makes sense at the
 904   // end of concurrent mark. This will filter out the references which referents
 905   // are alive. Note that ReferenceProcessor already filters out these on reference
</pre>
<hr />
<pre>
 926 
 927   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
 928   // queues and other goodies. When upstream ReferenceProcessor starts supporting
 929   // parallel precleans, we can extend this to more threads.
 930   ShenandoahPushWorkerScope scope(_heap-&gt;workers(), 1, /* check_workers = */ false);
 931 
 932   WorkGang* workers = _heap-&gt;workers();
 933   uint nworkers = workers-&gt;active_workers();
 934   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
 935   task_queues()-&gt;reserve(nworkers);
 936 
 937   ShenandoahTraversalPrecleanTask task(rp);
 938   workers-&gt;run_task(&amp;task);
 939 
 940   assert(_heap-&gt;cancelled_gc() || task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 941 }
 942 
 943 // Weak Reference Closures
 944 class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
 945   uint _worker_id;
<span class="line-modified"> 946   TaskTerminator* _terminator;</span>
 947   bool _reset_terminator;
 948 
 949 public:
<span class="line-modified"> 950   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
 951     _worker_id(worker_id),
 952     _terminator(t),
 953     _reset_terminator(reset_terminator) {
 954   }
 955 
 956   void do_void() {
 957     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 958 
 959     ShenandoahHeap* sh = ShenandoahHeap::heap();
 960     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 961     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 962     shenandoah_assert_rp_isalive_installed();
 963 
 964     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 965 
 966     if (_reset_terminator) {
 967       _terminator-&gt;reset_for_reuse();
 968     }
 969   }
 970 };
 971 
 972 class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
 973   uint _worker_id;
<span class="line-modified"> 974   TaskTerminator* _terminator;</span>
 975   bool _reset_terminator;
 976 
 977 public:
<span class="line-modified"> 978   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
 979           _worker_id(worker_id),
 980           _terminator(t),
 981           _reset_terminator(reset_terminator) {
 982   }
 983 
 984   void do_void() {
 985     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 986 
 987     ShenandoahHeap* sh = ShenandoahHeap::heap();
 988     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 989     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 990     shenandoah_assert_rp_isalive_installed();
 991 

 992     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 993 
 994     if (_reset_terminator) {
 995       _terminator-&gt;reset_for_reuse();
 996     }
 997   }
 998 };
 999 
1000 void ShenandoahTraversalGC::weak_refs_work() {
1001   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
1002 
1003   ShenandoahPhaseTimings::Phase phase_root = ShenandoahPhaseTimings::weakrefs;
1004 
1005   ShenandoahGCPhase phase(phase_root);
1006 
1007   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1008 
1009   // NOTE: We cannot shortcut on has_discovered_references() here, because
1010   // we will miss marking JNI Weak refs then, see implementation in
1011   // ReferenceProcessor::process_discovered_references.
1012   weak_refs_work_doit();
1013 
1014   rp-&gt;verify_no_references_recorded();
1015   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
1016 
1017 }
1018 
1019 class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
1020 private:
1021   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">1022   TaskTerminator* _terminator;</span>
1023 
1024 public:
1025   ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">1026                                       TaskTerminator* t) :</span>
1027     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
1028     _proc_task(proc_task),
1029     _terminator(t) {
1030   }
1031 
1032   void work(uint worker_id) {

1033     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1034     ShenandoahHeap* heap = ShenandoahHeap::heap();
1035     ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
1036 
1037     ShenandoahForwardedIsAliveClosure is_alive;
1038     if (!heap-&gt;is_degenerated_gc_in_progress()) {
1039       ShenandoahTraversalKeepAliveUpdateClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1040       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1041     } else {
1042       ShenandoahTraversalKeepAliveUpdateDegenClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1043       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1044     }
1045   }
1046 };
1047 
1048 class ShenandoahTraversalRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
1049 private:
1050   WorkGang* _workers;
1051 
1052 public:
1053   ShenandoahTraversalRefProcTaskExecutor(WorkGang* workers) : _workers(workers) {}
1054 
1055   // Executes a task using worker threads.
1056   void execute(ProcessTask&amp; task, uint ergo_workers) {
1057     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1058 
1059     ShenandoahHeap* heap = ShenandoahHeap::heap();
1060     ShenandoahTraversalGC* traversal_gc = heap-&gt;traversal_gc();
1061     ShenandoahPushWorkerQueuesScope scope(_workers,
1062                                           traversal_gc-&gt;task_queues(),
1063                                           ergo_workers,
1064                                           /* do_check = */ false);
1065     uint nworkers = _workers-&gt;active_workers();
1066     traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">1067     TaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
1068     ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
1069     _workers-&gt;run_task(&amp;proc_task_proxy);
1070   }
1071 };
1072 
1073 void ShenandoahTraversalGC::weak_refs_work_doit() {
1074   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1075 
1076   ShenandoahPhaseTimings::Phase phase_process = ShenandoahPhaseTimings::weakrefs_process;
1077 
1078   shenandoah_assert_rp_isalive_not_installed();
1079   ShenandoahForwardedIsAliveClosure is_alive;
1080   ReferenceProcessorIsAliveMutator fix_isalive(rp, &amp;is_alive);
1081 
1082   WorkGang* workers = _heap-&gt;workers();
1083   uint nworkers = workers-&gt;active_workers();
1084 
1085   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
1086   rp-&gt;set_active_mt_degree(nworkers);
1087 
1088   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
1089 
1090   // complete_gc and keep_alive closures instantiated here are only needed for
1091   // single-threaded path in RP. They share the queue 0 for tracking work, which
1092   // simplifies implementation. Since RP may decide to call complete_gc several
1093   // times, we need to be able to reuse the terminator.
1094   uint serial_worker_id = 0;
<span class="line-modified">1095   TaskTerminator terminator(1, task_queues());</span>
1096   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
1097   ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
1098 
1099   ShenandoahTraversalRefProcTaskExecutor executor(workers);
1100 
1101   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
1102   if (!_heap-&gt;is_degenerated_gc_in_progress()) {
1103     ShenandoahTraversalSingleThreadKeepAliveUpdateClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1104     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1105                                       &amp;complete_gc, &amp;executor,
1106                                       &amp;pt);
1107   } else {
1108     ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1109     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1110                                       &amp;complete_gc, &amp;executor,
1111                                       &amp;pt);
1112   }
1113 
<span class="line-modified">1114   pt.print_all_references();</span>
<span class="line-modified">1115   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);</span>










1116 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahTracer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 26 
 27 #include &quot;gc/shared/space.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;
<span class="line-removed"> 32 #include &quot;memory/universe.hpp&quot;</span>
 33 #include &quot;utilities/sizes.hpp&quot;
 34 
 35 class VMStructs;

 36 
 37 class ShenandoahHeapRegion : public ContiguousSpace {
 38   friend class VMStructs;

 39 private:
 40   /*
 41     Region state is described by a state machine. Transitions are guarded by
 42     heap lock, which allows changing the state of several regions atomically.
 43     Region states can be logically aggregated in groups.
 44 
 45       &quot;Empty&quot;:
 46       .................................................................
 47       .                                                               .
 48       .                                                               .
 49       .         Uncommitted  &lt;-------  Committed &lt;------------------------\
 50       .              |                     |                          .   |
 51       .              \---------v-----------/                          .   |
 52       .                        |                                      .   |
 53       .........................|.......................................   |
 54                                |                                          |
 55       &quot;Active&quot;:                |                                          |
 56       .........................|.......................................   |
 57       .                        |                                      .   |
 58       .      /-----------------^-------------------\                  .   |
</pre>
<hr />
<pre>
 99       e) Pinned cannot go CSet, thus it never moves;
100       f) Humongous cannot be used for regular allocations;
101       g) Humongous cannot go CSet, thus it never moves;
102       h) Humongous start can go pinned, and thus can be protected from moves (humongous continuations should
103          follow associated humongous starts, not pinnable/movable by themselves);
104       i) Empty cannot go Trash, avoiding useless work;
105       j) ...
106    */
107 
108   enum RegionState {
109     _empty_uncommitted,       // region is empty and has memory uncommitted
110     _empty_committed,         // region is empty and has memory committed
111     _regular,                 // region is for regular allocations
112     _humongous_start,         // region is the humongous start
113     _humongous_cont,          // region is the humongous continuation
114     _pinned_humongous_start,  // region is both humongous start and pinned
115     _cset,                    // region is in collection set
116     _pinned,                  // region is pinned
117     _pinned_cset,             // region is pinned and in cset (evac failure path)
118     _trash,                   // region contains only trash

119   };
120 
<span class="line-modified">121   const char* region_state_to_string(RegionState s) const {</span>
122     switch (s) {
123       case _empty_uncommitted:       return &quot;Empty Uncommitted&quot;;
124       case _empty_committed:         return &quot;Empty Committed&quot;;
125       case _regular:                 return &quot;Regular&quot;;
126       case _humongous_start:         return &quot;Humongous Start&quot;;
127       case _humongous_cont:          return &quot;Humongous Continuation&quot;;
128       case _pinned_humongous_start:  return &quot;Humongous Start, Pinned&quot;;
129       case _cset:                    return &quot;Collection Set&quot;;
130       case _pinned:                  return &quot;Pinned&quot;;
131       case _pinned_cset:             return &quot;Collection Set, Pinned&quot;;
132       case _trash:                   return &quot;Trash&quot;;
133       default:
134         ShouldNotReachHere();
135         return &quot;&quot;;
136     }
137   }
138 
139   // This method protects from accidental changes in enum order:
140   int region_state_to_ordinal(RegionState s) const {
141     switch (s) {
142       case _empty_uncommitted:      return 0;
143       case _empty_committed:        return 1;
144       case _regular:                return 2;
145       case _humongous_start:        return 3;
146       case _humongous_cont:         return 4;
147       case _cset:                   return 5;
148       case _pinned:                 return 6;
149       case _trash:                  return 7;
150       case _pinned_cset:            return 8;
151       case _pinned_humongous_start: return 9;
152       default:
153         ShouldNotReachHere();
154         return -1;
155     }
156   }
157 
158   void report_illegal_transition(const char* method);
159 
160 public:




161   // Allowed transitions from the outside code:
162   void make_regular_allocation();
163   void make_regular_bypass();
164   void make_humongous_start();
165   void make_humongous_cont();
166   void make_humongous_start_bypass();
167   void make_humongous_cont_bypass();
168   void make_pinned();
169   void make_unpinned();
170   void make_cset();
171   void make_trash();
172   void make_trash_immediate();
173   void make_empty();
174   void make_uncommitted();
175   void make_committed_bypass();
176 
177   // Individual states:
178   bool is_empty_uncommitted()      const { return _state == _empty_uncommitted; }
179   bool is_empty_committed()        const { return _state == _empty_committed; }
180   bool is_regular()                const { return _state == _regular; }
181   bool is_humongous_continuation() const { return _state == _humongous_cont; }
182 
183   // Participation in logical groups:
184   bool is_empty()                  const { return is_empty_committed() || is_empty_uncommitted(); }
185   bool is_active()                 const { return !is_empty() &amp;&amp; !is_trash(); }
186   bool is_trash()                  const { return _state == _trash; }
187   bool is_humongous_start()        const { return _state == _humongous_start || _state == _pinned_humongous_start; }
188   bool is_humongous()              const { return is_humongous_start() || is_humongous_continuation(); }
189   bool is_committed()              const { return !is_empty_uncommitted(); }
190   bool is_cset()                   const { return _state == _cset   || _state == _pinned_cset; }
191   bool is_pinned()                 const { return _state == _pinned || _state == _pinned_cset || _state == _pinned_humongous_start; }
192 
193   // Macro-properties:
194   bool is_alloc_allowed()          const { return is_empty() || is_regular() || _state == _pinned; }
<span class="line-modified">195   bool is_move_allowed()           const { return is_regular() || _state == _cset || (ShenandoahHumongousMoves &amp;&amp; _state == _humongous_start); }</span>
196 
197   RegionState state()              const { return _state; }
198   int  state_ordinal()             const { return region_state_to_ordinal(_state); }
199 




200 private:
201   static size_t RegionCount;
202   static size_t RegionSizeBytes;
203   static size_t RegionSizeWords;
204   static size_t RegionSizeBytesShift;
205   static size_t RegionSizeWordsShift;
206   static size_t RegionSizeBytesMask;
207   static size_t RegionSizeWordsMask;
208   static size_t HumongousThresholdBytes;
209   static size_t HumongousThresholdWords;
210   static size_t MaxTLABSizeBytes;
211   static size_t MaxTLABSizeWords;
212 
213   // Global allocation counter, increased for each allocation under Shenandoah heap lock.
214   // Padded to avoid false sharing with the read-only fields above.
215   struct PaddedAllocSeqNum {
216     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(uint64_t));
217     uint64_t value;
218     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
219 
220     PaddedAllocSeqNum() {
221       // start with 1, reserve 0 for uninitialized value
222       value = 1;
223     }
224   };
225 
226   static PaddedAllocSeqNum _alloc_seq_num;
227 
228   // Never updated fields
229   ShenandoahHeap* _heap;
230   MemRegion _reserved;
231   size_t _region_number;
232 
233   // Rarely updated fields
234   HeapWord* _new_top;
<span class="line-removed">235   size_t _critical_pins;</span>
236   double _empty_time;
237 
238   // Seldom updated fields
239   RegionState _state;
240 
241   // Frequently updated fields
242   size_t _tlab_allocs;
243   size_t _gclab_allocs;
244   size_t _shared_allocs;
245 
246   uint64_t _seqnum_first_alloc_mutator;
247   uint64_t _seqnum_first_alloc_gc;
248   uint64_t _seqnum_last_alloc_mutator;
249   uint64_t _seqnum_last_alloc_gc;
250 
251   volatile size_t _live_data;

252 
253   // Claim some space at the end to protect next region
254   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);
255 
256 public:
257   ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start, size_t size_words, size_t index, bool committed);
258 
259   static const size_t MIN_NUM_REGIONS = 10;
260 
<span class="line-modified">261   static void setup_sizes(size_t initial_heap_size, size_t max_heap_size);</span>
262 
263   double empty_time() {
264     return _empty_time;
265   }
266 
267   inline static size_t required_regions(size_t bytes) {
268     return (bytes + ShenandoahHeapRegion::region_size_bytes() - 1) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
269   }
270 
271   inline static size_t region_count() {
272     return ShenandoahHeapRegion::RegionCount;
273   }
274 
275   inline static size_t region_size_bytes() {
276     return ShenandoahHeapRegion::RegionSizeBytes;
277   }
278 
279   inline static size_t region_size_words() {
280     return ShenandoahHeapRegion::RegionSizeWords;
281   }
</pre>
<hr />
<pre>
408   uint64_t seqnum_last_alloc_mutator()  const {
409     return _seqnum_last_alloc_mutator;
410   }
411 
412   uint64_t seqnum_first_alloc_gc() const {
413     return _seqnum_first_alloc_gc;
414   }
415 
416   uint64_t seqnum_last_alloc_gc()  const {
417     return _seqnum_last_alloc_gc;
418   }
419 
420 private:
421   void do_commit();
422   void do_uncommit();
423 
424   void oop_iterate_objects(OopIterateClosure* cl);
425   void oop_iterate_humongous(OopIterateClosure* cl);
426 
427   inline void internal_increase_live_data(size_t s);


428 };
429 
430 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
 27 
 28 #include &quot;gc/shared/space.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahAllocRequest.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahPacer.hpp&quot;

 33 #include &quot;utilities/sizes.hpp&quot;
 34 
 35 class VMStructs;
<span class="line-added"> 36 class ShenandoahHeapRegionStateConstant;</span>
 37 
 38 class ShenandoahHeapRegion : public ContiguousSpace {
 39   friend class VMStructs;
<span class="line-added"> 40   friend class ShenandoahHeapRegionStateConstant;</span>
 41 private:
 42   /*
 43     Region state is described by a state machine. Transitions are guarded by
 44     heap lock, which allows changing the state of several regions atomically.
 45     Region states can be logically aggregated in groups.
 46 
 47       &quot;Empty&quot;:
 48       .................................................................
 49       .                                                               .
 50       .                                                               .
 51       .         Uncommitted  &lt;-------  Committed &lt;------------------------\
 52       .              |                     |                          .   |
 53       .              \---------v-----------/                          .   |
 54       .                        |                                      .   |
 55       .........................|.......................................   |
 56                                |                                          |
 57       &quot;Active&quot;:                |                                          |
 58       .........................|.......................................   |
 59       .                        |                                      .   |
 60       .      /-----------------^-------------------\                  .   |
</pre>
<hr />
<pre>
101       e) Pinned cannot go CSet, thus it never moves;
102       f) Humongous cannot be used for regular allocations;
103       g) Humongous cannot go CSet, thus it never moves;
104       h) Humongous start can go pinned, and thus can be protected from moves (humongous continuations should
105          follow associated humongous starts, not pinnable/movable by themselves);
106       i) Empty cannot go Trash, avoiding useless work;
107       j) ...
108    */
109 
110   enum RegionState {
111     _empty_uncommitted,       // region is empty and has memory uncommitted
112     _empty_committed,         // region is empty and has memory committed
113     _regular,                 // region is for regular allocations
114     _humongous_start,         // region is the humongous start
115     _humongous_cont,          // region is the humongous continuation
116     _pinned_humongous_start,  // region is both humongous start and pinned
117     _cset,                    // region is in collection set
118     _pinned,                  // region is pinned
119     _pinned_cset,             // region is pinned and in cset (evac failure path)
120     _trash,                   // region contains only trash
<span class="line-added">121     _REGION_STATES_NUM        // last</span>
122   };
123 
<span class="line-modified">124   static const char* region_state_to_string(RegionState s) {</span>
125     switch (s) {
126       case _empty_uncommitted:       return &quot;Empty Uncommitted&quot;;
127       case _empty_committed:         return &quot;Empty Committed&quot;;
128       case _regular:                 return &quot;Regular&quot;;
129       case _humongous_start:         return &quot;Humongous Start&quot;;
130       case _humongous_cont:          return &quot;Humongous Continuation&quot;;
131       case _pinned_humongous_start:  return &quot;Humongous Start, Pinned&quot;;
132       case _cset:                    return &quot;Collection Set&quot;;
133       case _pinned:                  return &quot;Pinned&quot;;
134       case _pinned_cset:             return &quot;Collection Set, Pinned&quot;;
135       case _trash:                   return &quot;Trash&quot;;
136       default:
137         ShouldNotReachHere();
138         return &quot;&quot;;
139     }
140   }
141 
142   // This method protects from accidental changes in enum order:
143   int region_state_to_ordinal(RegionState s) const {
144     switch (s) {
145       case _empty_uncommitted:      return 0;
146       case _empty_committed:        return 1;
147       case _regular:                return 2;
148       case _humongous_start:        return 3;
149       case _humongous_cont:         return 4;
150       case _cset:                   return 5;
151       case _pinned:                 return 6;
152       case _trash:                  return 7;
153       case _pinned_cset:            return 8;
154       case _pinned_humongous_start: return 9;
155       default:
156         ShouldNotReachHere();
157         return -1;
158     }
159   }
160 
161   void report_illegal_transition(const char* method);
162 
163 public:
<span class="line-added">164   static const int region_states_num() {</span>
<span class="line-added">165     return _REGION_STATES_NUM;</span>
<span class="line-added">166   }</span>
<span class="line-added">167 </span>
168   // Allowed transitions from the outside code:
169   void make_regular_allocation();
170   void make_regular_bypass();
171   void make_humongous_start();
172   void make_humongous_cont();
173   void make_humongous_start_bypass();
174   void make_humongous_cont_bypass();
175   void make_pinned();
176   void make_unpinned();
177   void make_cset();
178   void make_trash();
179   void make_trash_immediate();
180   void make_empty();
181   void make_uncommitted();
182   void make_committed_bypass();
183 
184   // Individual states:
185   bool is_empty_uncommitted()      const { return _state == _empty_uncommitted; }
186   bool is_empty_committed()        const { return _state == _empty_committed; }
187   bool is_regular()                const { return _state == _regular; }
188   bool is_humongous_continuation() const { return _state == _humongous_cont; }
189 
190   // Participation in logical groups:
191   bool is_empty()                  const { return is_empty_committed() || is_empty_uncommitted(); }
192   bool is_active()                 const { return !is_empty() &amp;&amp; !is_trash(); }
193   bool is_trash()                  const { return _state == _trash; }
194   bool is_humongous_start()        const { return _state == _humongous_start || _state == _pinned_humongous_start; }
195   bool is_humongous()              const { return is_humongous_start() || is_humongous_continuation(); }
196   bool is_committed()              const { return !is_empty_uncommitted(); }
197   bool is_cset()                   const { return _state == _cset   || _state == _pinned_cset; }
198   bool is_pinned()                 const { return _state == _pinned || _state == _pinned_cset || _state == _pinned_humongous_start; }
199 
200   // Macro-properties:
201   bool is_alloc_allowed()          const { return is_empty() || is_regular() || _state == _pinned; }
<span class="line-modified">202   bool is_stw_move_allowed()       const { return is_regular() || _state == _cset || (ShenandoahHumongousMoves &amp;&amp; _state == _humongous_start); }</span>
203 
204   RegionState state()              const { return _state; }
205   int  state_ordinal()             const { return region_state_to_ordinal(_state); }
206 
<span class="line-added">207   void record_pin();</span>
<span class="line-added">208   void record_unpin();</span>
<span class="line-added">209   size_t pin_count() const;</span>
<span class="line-added">210 </span>
211 private:
212   static size_t RegionCount;
213   static size_t RegionSizeBytes;
214   static size_t RegionSizeWords;
215   static size_t RegionSizeBytesShift;
216   static size_t RegionSizeWordsShift;
217   static size_t RegionSizeBytesMask;
218   static size_t RegionSizeWordsMask;
219   static size_t HumongousThresholdBytes;
220   static size_t HumongousThresholdWords;
221   static size_t MaxTLABSizeBytes;
222   static size_t MaxTLABSizeWords;
223 
224   // Global allocation counter, increased for each allocation under Shenandoah heap lock.
225   // Padded to avoid false sharing with the read-only fields above.
226   struct PaddedAllocSeqNum {
227     DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(uint64_t));
228     uint64_t value;
229     DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
230 
231     PaddedAllocSeqNum() {
232       // start with 1, reserve 0 for uninitialized value
233       value = 1;
234     }
235   };
236 
237   static PaddedAllocSeqNum _alloc_seq_num;
238 
239   // Never updated fields
240   ShenandoahHeap* _heap;
241   MemRegion _reserved;
242   size_t _region_number;
243 
244   // Rarely updated fields
245   HeapWord* _new_top;

246   double _empty_time;
247 
248   // Seldom updated fields
249   RegionState _state;
250 
251   // Frequently updated fields
252   size_t _tlab_allocs;
253   size_t _gclab_allocs;
254   size_t _shared_allocs;
255 
256   uint64_t _seqnum_first_alloc_mutator;
257   uint64_t _seqnum_first_alloc_gc;
258   uint64_t _seqnum_last_alloc_mutator;
259   uint64_t _seqnum_last_alloc_gc;
260 
261   volatile size_t _live_data;
<span class="line-added">262   volatile size_t _critical_pins;</span>
263 
264   // Claim some space at the end to protect next region
265   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);
266 
267 public:
268   ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start, size_t size_words, size_t index, bool committed);
269 
270   static const size_t MIN_NUM_REGIONS = 10;
271 
<span class="line-modified">272   static void setup_sizes(size_t max_heap_size);</span>
273 
274   double empty_time() {
275     return _empty_time;
276   }
277 
278   inline static size_t required_regions(size_t bytes) {
279     return (bytes + ShenandoahHeapRegion::region_size_bytes() - 1) &gt;&gt; ShenandoahHeapRegion::region_size_bytes_shift();
280   }
281 
282   inline static size_t region_count() {
283     return ShenandoahHeapRegion::RegionCount;
284   }
285 
286   inline static size_t region_size_bytes() {
287     return ShenandoahHeapRegion::RegionSizeBytes;
288   }
289 
290   inline static size_t region_size_words() {
291     return ShenandoahHeapRegion::RegionSizeWords;
292   }
</pre>
<hr />
<pre>
419   uint64_t seqnum_last_alloc_mutator()  const {
420     return _seqnum_last_alloc_mutator;
421   }
422 
423   uint64_t seqnum_first_alloc_gc() const {
424     return _seqnum_first_alloc_gc;
425   }
426 
427   uint64_t seqnum_last_alloc_gc()  const {
428     return _seqnum_last_alloc_gc;
429   }
430 
431 private:
432   void do_commit();
433   void do_uncommit();
434 
435   void oop_iterate_objects(OopIterateClosure* cl);
436   void oop_iterate_humongous(OopIterateClosure* cl);
437 
438   inline void internal_increase_live_data(size_t s);
<span class="line-added">439 </span>
<span class="line-added">440   void set_state(RegionState to);</span>
441 };
442 
443 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGION_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeapRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeapRegion.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
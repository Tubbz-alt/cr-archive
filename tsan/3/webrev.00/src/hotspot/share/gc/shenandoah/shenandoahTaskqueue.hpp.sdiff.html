<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTaskqueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTaskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahTaskqueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Red Hat, Inc. All rights reserved.</span>

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<span class="line-modified"> 26 #include &quot;gc/shared/owstTaskTerminator.hpp&quot;</span>

 27 #include &quot;gc/shared/taskqueue.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;

 29 #include &quot;runtime/mutex.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 
 32 template&lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
 33 class BufferedOverflowTaskQueue: public OverflowTaskQueue&lt;E, F, N&gt;
 34 {
 35 public:
 36   typedef OverflowTaskQueue&lt;E, F, N&gt; taskqueue_t;
 37 
 38   BufferedOverflowTaskQueue() : _buf_empty(true) {};
 39 
 40   TASKQUEUE_STATS_ONLY(using taskqueue_t::stats;)
 41 
 42   // Push task t into the queue. Returns true on success.
 43   inline bool push(E t);
 44 
 45   // Attempt to pop from the queue. Returns true on success.
 46   inline bool pop(E &amp;t);
 47 
 48   inline void clear();
</pre>
<hr />
<pre>
 92 //      [ (2*C - 2)*2^(P-1); 2*C*2^(P-1) )
 93 //
 94 //    ...which is the original interval:
 95 //      [ (C-1)*2^P; C*2^P )
 96 //
 97 // c) The divide-and-conquer strategy could even start with chunk &lt;1, round-log2-len(arr)&gt;, and split
 98 //    down in the parallel threads, which alleviates the upfront (serial) splitting costs.
 99 //
100 // Encoding limitations caused by current bitscales mean:
101 //    10 bits for chunk: max 1024 blocks per array
102 //     5 bits for power: max 2^32 array
103 //    49 bits for   oop: max 512 TB of addressable space
104 //
105 // Stealing bits from oop trims down the addressable space. Stealing too few bits for chunk ID limits
106 // potential parallelism. Stealing too few bits for pow limits the maximum array size that can be handled.
107 // In future, these might be rebalanced to favor one degree of freedom against another. For example,
108 // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
109 // some bits back if chunks are counted in ObjArrayMarkingStride units.
110 //
111 // There is also a fallback version that uses plain fields, when we don&#39;t have enough space to steal the
<span class="line-modified">112 // bits from the native pointer. It is useful to debug the _LP64 version.</span>
113 //
114 
115 #ifdef _MSC_VER
116 #pragma warning(push)
117 // warning C4522: multiple assignment operators specified
118 #pragma warning( disable:4522 )
119 #endif
120 
121 #ifdef _LP64






122 class ObjArrayChunkedTask
123 {
124 public:
125   enum {
126     chunk_bits   = 10,
127     pow_bits     = 5,
<span class="line-modified">128     oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits,</span>
129   };
130   enum {
131     oop_shift    = 0,
132     pow_shift    = oop_shift + oop_bits,
<span class="line-modified">133     chunk_shift  = pow_shift + pow_bits,</span>
134   };
135 
136 public:
137   ObjArrayChunkedTask(oop o = NULL) {
<span class="line-modified">138     _obj = ((uintptr_t)(void*) o) &lt;&lt; oop_shift;</span>

139   }
<span class="line-modified">140   ObjArrayChunkedTask(oop o, int chunk, int mult) {</span>
<span class="line-modified">141     assert(0 &lt;= chunk &amp;&amp; chunk &lt; nth_bit(chunk_bits), &quot;chunk is sane: %d&quot;, chunk);</span>
<span class="line-modified">142     assert(0 &lt;= mult &amp;&amp; mult &lt; nth_bit(pow_bits), &quot;pow is sane: %d&quot;, mult);</span>
<span class="line-modified">143     uintptr_t t_b = ((uintptr_t) chunk) &lt;&lt; chunk_shift;</span>
<span class="line-modified">144     uintptr_t t_m = ((uintptr_t) mult) &lt;&lt; pow_shift;</span>
<span class="line-removed">145     uintptr_t obj = (uintptr_t)(void*)o;</span>
<span class="line-removed">146     assert(obj &lt; nth_bit(oop_bits), &quot;obj ref is sane: &quot; PTR_FORMAT, obj);</span>
<span class="line-removed">147     intptr_t t_o = obj &lt;&lt; oop_shift;</span>
<span class="line-removed">148     _obj = t_o | t_m | t_b;</span>
149   }
150   ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj) { }
151 
152   ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
153     _obj = t._obj;
154     return *this;
155   }
156   volatile ObjArrayChunkedTask&amp;
157   operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
158     (void)const_cast&lt;uintptr_t&amp;&gt;(_obj = t._obj);
159     return *this;
160   }
161 
<span class="line-modified">162   inline oop obj()   const { return (oop) reinterpret_cast&lt;void*&gt;((_obj &gt;&gt; oop_shift) &amp; right_n_bits(oop_bits)); }</span>
<span class="line-modified">163   inline int chunk() const { return (int) (_obj &gt;&gt; chunk_shift) &amp; right_n_bits(chunk_bits); }</span>
<span class="line-modified">164   inline int pow()   const { return (int) ((_obj &gt;&gt; pow_shift) &amp; right_n_bits(pow_bits)); }</span>
























165   inline bool is_not_chunked() const { return (_obj &amp; ~right_n_bits(oop_bits + pow_bits)) == 0; }
166 
167   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
168 
<span class="line-modified">169   static size_t max_addressable() {</span>
170     return nth_bit(oop_bits);
171   }
172 
173   static int chunk_size() {
174     return nth_bit(chunk_bits);
175   }
176 
177 private:
178   uintptr_t _obj;
179 };
180 #else
181 class ObjArrayChunkedTask
182 {
183 public:
184   enum {
185     chunk_bits  = 10,
186     pow_bits    = 5,
187   };
188 public:
189   ObjArrayChunkedTask(oop o = NULL, int chunk = 0, int pow = 0): _obj(o) {
</pre>
<hr />
<pre>
212   inline int chunk() const { return _chunk; }
213   inline int pow()  const { return _pow; }
214 
215   inline bool is_not_chunked() const { return _chunk == 0; }
216 
217   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
218 
219   static size_t max_addressable() {
220     return sizeof(oop);
221   }
222 
223   static int chunk_size() {
224     return nth_bit(chunk_bits);
225   }
226 
227 private:
228   oop _obj;
229   int _chunk;
230   int _pow;
231 };
<span class="line-modified">232 #endif</span>
233 
234 #ifdef _MSC_VER
235 #pragma warning(pop)
236 #endif
237 
238 typedef ObjArrayChunkedTask ShenandoahMarkTask;
239 typedef BufferedOverflowTaskQueue&lt;ShenandoahMarkTask, mtGC&gt; ShenandoahBufferedOverflowTaskQueue;
240 typedef Padded&lt;ShenandoahBufferedOverflowTaskQueue&gt; ShenandoahObjToScanQueue;
241 
242 template &lt;class T, MEMFLAGS F&gt;
243 class ParallelClaimableQueueSet: public GenericTaskQueueSet&lt;T, F&gt; {
244 private:
245   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile jint));
246   volatile jint     _claimed_index;
247   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
248 
249   debug_only(uint   _reserved;  )
250 
251 public:
252   using GenericTaskQueueSet&lt;T, F&gt;::size;
</pre>
<hr />
<pre>
260   T*   claim_next();
261 
262   // reserve queues that not for parallel claiming
263   void reserve(uint n) {
264     assert(n &lt;= size(), &quot;Sanity&quot;);
265     _claimed_index = (jint)n;
266     debug_only(_reserved = n;)
267   }
268 
269   debug_only(uint get_reserved() const { return (uint)_reserved; })
270 };
271 
272 template &lt;class T, MEMFLAGS F&gt;
273 T* ParallelClaimableQueueSet&lt;T, F&gt;::claim_next() {
274   jint size = (jint)GenericTaskQueueSet&lt;T, F&gt;::size();
275 
276   if (_claimed_index &gt;= size) {
277     return NULL;
278   }
279 
<span class="line-modified">280   jint index = Atomic::add(1, &amp;_claimed_index);</span>
281 
282   if (index &lt;= size) {
283     return GenericTaskQueueSet&lt;T, F&gt;::queue((uint)index - 1);
284   } else {
285     return NULL;
286   }
287 }
288 
289 class ShenandoahObjToScanQueueSet: public ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt; {
290 public:
291   ShenandoahObjToScanQueueSet(int n) : ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt;(n) {}
292 
293   bool is_empty();
294   void clear();
295 
296 #if TASKQUEUE_STATS
297   static void print_taskqueue_stats_hdr(outputStream* const st);
298   void print_taskqueue_stats() const;
299   void reset_taskqueue_stats();
300 #endif // TASKQUEUE_STATS
301 };
302 
303 class ShenandoahTerminatorTerminator : public TerminatorTerminator {
304 private:
305   ShenandoahHeap* _heap;
306 public:
307   ShenandoahTerminatorTerminator(ShenandoahHeap* const heap) : _heap(heap) { }
308   // return true, terminates immediately, even if there&#39;s remaining work left
309   virtual bool should_exit_termination() { return _heap-&gt;cancelled_gc(); }
310 };
311 
<span class="line-removed">312 class ShenandoahTaskTerminator : public StackObj {</span>
<span class="line-removed">313 private:</span>
<span class="line-removed">314   OWSTTaskTerminator* const   _terminator;</span>
<span class="line-removed">315 public:</span>
<span class="line-removed">316   ShenandoahTaskTerminator(uint n_threads, TaskQueueSetSuper* queue_set);</span>
<span class="line-removed">317   ~ShenandoahTaskTerminator();</span>
<span class="line-removed">318 </span>
<span class="line-removed">319   bool offer_termination(ShenandoahTerminatorTerminator* terminator) {</span>
<span class="line-removed">320     return _terminator-&gt;offer_termination(terminator);</span>
<span class="line-removed">321   }</span>
<span class="line-removed">322 </span>
<span class="line-removed">323   void reset_for_reuse() { _terminator-&gt;reset_for_reuse(); }</span>
<span class="line-removed">324   bool offer_termination() { return offer_termination((ShenandoahTerminatorTerminator*)NULL); }</span>
<span class="line-removed">325 };</span>
<span class="line-removed">326 </span>
327 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
<span class="line-modified"> 27 </span>
<span class="line-added"> 28 #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
 29 #include &quot;gc/shared/taskqueue.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 31 #include &quot;runtime/atomic.hpp&quot;</span>
 32 #include &quot;runtime/mutex.hpp&quot;
 33 #include &quot;runtime/thread.hpp&quot;
 34 
 35 template&lt;class E, MEMFLAGS F, unsigned int N = TASKQUEUE_SIZE&gt;
 36 class BufferedOverflowTaskQueue: public OverflowTaskQueue&lt;E, F, N&gt;
 37 {
 38 public:
 39   typedef OverflowTaskQueue&lt;E, F, N&gt; taskqueue_t;
 40 
 41   BufferedOverflowTaskQueue() : _buf_empty(true) {};
 42 
 43   TASKQUEUE_STATS_ONLY(using taskqueue_t::stats;)
 44 
 45   // Push task t into the queue. Returns true on success.
 46   inline bool push(E t);
 47 
 48   // Attempt to pop from the queue. Returns true on success.
 49   inline bool pop(E &amp;t);
 50 
 51   inline void clear();
</pre>
<hr />
<pre>
 95 //      [ (2*C - 2)*2^(P-1); 2*C*2^(P-1) )
 96 //
 97 //    ...which is the original interval:
 98 //      [ (C-1)*2^P; C*2^P )
 99 //
100 // c) The divide-and-conquer strategy could even start with chunk &lt;1, round-log2-len(arr)&gt;, and split
101 //    down in the parallel threads, which alleviates the upfront (serial) splitting costs.
102 //
103 // Encoding limitations caused by current bitscales mean:
104 //    10 bits for chunk: max 1024 blocks per array
105 //     5 bits for power: max 2^32 array
106 //    49 bits for   oop: max 512 TB of addressable space
107 //
108 // Stealing bits from oop trims down the addressable space. Stealing too few bits for chunk ID limits
109 // potential parallelism. Stealing too few bits for pow limits the maximum array size that can be handled.
110 // In future, these might be rebalanced to favor one degree of freedom against another. For example,
111 // if/when Arrays 2.0 bring 2^64-sized arrays, we might need to steal another bit for power. We could regain
112 // some bits back if chunks are counted in ObjArrayMarkingStride units.
113 //
114 // There is also a fallback version that uses plain fields, when we don&#39;t have enough space to steal the
<span class="line-modified">115 // bits from the native pointer. It is useful to debug the optimized version.</span>
116 //
117 
118 #ifdef _MSC_VER
119 #pragma warning(push)
120 // warning C4522: multiple assignment operators specified
121 #pragma warning( disable:4522 )
122 #endif
123 
124 #ifdef _LP64
<span class="line-added">125 #define SHENANDOAH_OPTIMIZED_OBJTASK 1</span>
<span class="line-added">126 #else</span>
<span class="line-added">127 #define SHENANDOAH_OPTIMIZED_OBJTASK 0</span>
<span class="line-added">128 #endif</span>
<span class="line-added">129 </span>
<span class="line-added">130 #if SHENANDOAH_OPTIMIZED_OBJTASK</span>
131 class ObjArrayChunkedTask
132 {
133 public:
134   enum {
135     chunk_bits   = 10,
136     pow_bits     = 5,
<span class="line-modified">137     oop_bits     = sizeof(uintptr_t)*8 - chunk_bits - pow_bits</span>
138   };
139   enum {
140     oop_shift    = 0,
141     pow_shift    = oop_shift + oop_bits,
<span class="line-modified">142     chunk_shift  = pow_shift + pow_bits</span>
143   };
144 
145 public:
146   ObjArrayChunkedTask(oop o = NULL) {
<span class="line-modified">147     assert(decode_oop(encode_oop(o)) ==  o, &quot;oop can be encoded: &quot; PTR_FORMAT, p2i(o));</span>
<span class="line-added">148     _obj = encode_oop(o);</span>
149   }
<span class="line-modified">150   ObjArrayChunkedTask(oop o, int chunk, int pow) {</span>
<span class="line-modified">151     assert(decode_oop(encode_oop(o)) == o, &quot;oop can be encoded: &quot; PTR_FORMAT, p2i(o));</span>
<span class="line-modified">152     assert(decode_chunk(encode_chunk(chunk)) == chunk, &quot;chunk can be encoded: %d&quot;, chunk);</span>
<span class="line-modified">153     assert(decode_pow(encode_pow(pow)) == pow, &quot;pow can be encoded: %d&quot;, pow);</span>
<span class="line-modified">154     _obj = encode_oop(o) | encode_chunk(chunk) | encode_pow(pow);</span>




155   }
156   ObjArrayChunkedTask(const ObjArrayChunkedTask&amp; t): _obj(t._obj) { }
157 
158   ObjArrayChunkedTask&amp; operator =(const ObjArrayChunkedTask&amp; t) {
159     _obj = t._obj;
160     return *this;
161   }
162   volatile ObjArrayChunkedTask&amp;
163   operator =(const volatile ObjArrayChunkedTask&amp; t) volatile {
164     (void)const_cast&lt;uintptr_t&amp;&gt;(_obj = t._obj);
165     return *this;
166   }
167 
<span class="line-modified">168   inline oop decode_oop(uintptr_t val) const {</span>
<span class="line-modified">169     return (oop) reinterpret_cast&lt;void*&gt;((val &gt;&gt; oop_shift) &amp; right_n_bits(oop_bits));</span>
<span class="line-modified">170   }</span>
<span class="line-added">171 </span>
<span class="line-added">172   inline int decode_chunk(uintptr_t val) const {</span>
<span class="line-added">173     return (int) ((val &gt;&gt; chunk_shift) &amp; right_n_bits(chunk_bits));</span>
<span class="line-added">174   }</span>
<span class="line-added">175 </span>
<span class="line-added">176   inline int decode_pow(uintptr_t val) const {</span>
<span class="line-added">177     return (int) ((val &gt;&gt; pow_shift) &amp; right_n_bits(pow_bits));</span>
<span class="line-added">178   }</span>
<span class="line-added">179 </span>
<span class="line-added">180   inline uintptr_t encode_oop(oop obj) const {</span>
<span class="line-added">181     return ((uintptr_t)(void*) obj) &lt;&lt; oop_shift;</span>
<span class="line-added">182   }</span>
<span class="line-added">183 </span>
<span class="line-added">184   inline uintptr_t encode_chunk(int chunk) const {</span>
<span class="line-added">185     return ((uintptr_t) chunk) &lt;&lt; chunk_shift;</span>
<span class="line-added">186   }</span>
<span class="line-added">187 </span>
<span class="line-added">188   inline uintptr_t encode_pow(int pow) const {</span>
<span class="line-added">189     return ((uintptr_t) pow) &lt;&lt; pow_shift;</span>
<span class="line-added">190   }</span>
<span class="line-added">191 </span>
<span class="line-added">192   inline oop obj()   const { return decode_oop(_obj);   }</span>
<span class="line-added">193   inline int chunk() const { return decode_chunk(_obj); }</span>
<span class="line-added">194   inline int pow()   const { return decode_pow(_obj);   }</span>
195   inline bool is_not_chunked() const { return (_obj &amp; ~right_n_bits(oop_bits + pow_bits)) == 0; }
196 
197   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
198 
<span class="line-modified">199   static uintptr_t max_addressable() {</span>
200     return nth_bit(oop_bits);
201   }
202 
203   static int chunk_size() {
204     return nth_bit(chunk_bits);
205   }
206 
207 private:
208   uintptr_t _obj;
209 };
210 #else
211 class ObjArrayChunkedTask
212 {
213 public:
214   enum {
215     chunk_bits  = 10,
216     pow_bits    = 5,
217   };
218 public:
219   ObjArrayChunkedTask(oop o = NULL, int chunk = 0, int pow = 0): _obj(o) {
</pre>
<hr />
<pre>
242   inline int chunk() const { return _chunk; }
243   inline int pow()  const { return _pow; }
244 
245   inline bool is_not_chunked() const { return _chunk == 0; }
246 
247   DEBUG_ONLY(bool is_valid() const); // Tasks to be pushed/popped must be valid.
248 
249   static size_t max_addressable() {
250     return sizeof(oop);
251   }
252 
253   static int chunk_size() {
254     return nth_bit(chunk_bits);
255   }
256 
257 private:
258   oop _obj;
259   int _chunk;
260   int _pow;
261 };
<span class="line-modified">262 #endif // SHENANDOAH_OPTIMIZED_OBJTASK</span>
263 
264 #ifdef _MSC_VER
265 #pragma warning(pop)
266 #endif
267 
268 typedef ObjArrayChunkedTask ShenandoahMarkTask;
269 typedef BufferedOverflowTaskQueue&lt;ShenandoahMarkTask, mtGC&gt; ShenandoahBufferedOverflowTaskQueue;
270 typedef Padded&lt;ShenandoahBufferedOverflowTaskQueue&gt; ShenandoahObjToScanQueue;
271 
272 template &lt;class T, MEMFLAGS F&gt;
273 class ParallelClaimableQueueSet: public GenericTaskQueueSet&lt;T, F&gt; {
274 private:
275   DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile jint));
276   volatile jint     _claimed_index;
277   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
278 
279   debug_only(uint   _reserved;  )
280 
281 public:
282   using GenericTaskQueueSet&lt;T, F&gt;::size;
</pre>
<hr />
<pre>
290   T*   claim_next();
291 
292   // reserve queues that not for parallel claiming
293   void reserve(uint n) {
294     assert(n &lt;= size(), &quot;Sanity&quot;);
295     _claimed_index = (jint)n;
296     debug_only(_reserved = n;)
297   }
298 
299   debug_only(uint get_reserved() const { return (uint)_reserved; })
300 };
301 
302 template &lt;class T, MEMFLAGS F&gt;
303 T* ParallelClaimableQueueSet&lt;T, F&gt;::claim_next() {
304   jint size = (jint)GenericTaskQueueSet&lt;T, F&gt;::size();
305 
306   if (_claimed_index &gt;= size) {
307     return NULL;
308   }
309 
<span class="line-modified">310   jint index = Atomic::add(&amp;_claimed_index, 1);</span>
311 
312   if (index &lt;= size) {
313     return GenericTaskQueueSet&lt;T, F&gt;::queue((uint)index - 1);
314   } else {
315     return NULL;
316   }
317 }
318 
319 class ShenandoahObjToScanQueueSet: public ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt; {
320 public:
321   ShenandoahObjToScanQueueSet(int n) : ParallelClaimableQueueSet&lt;ShenandoahObjToScanQueue, mtGC&gt;(n) {}
322 
323   bool is_empty();
324   void clear();
325 
326 #if TASKQUEUE_STATS
327   static void print_taskqueue_stats_hdr(outputStream* const st);
328   void print_taskqueue_stats() const;
329   void reset_taskqueue_stats();
330 #endif // TASKQUEUE_STATS
331 };
332 
333 class ShenandoahTerminatorTerminator : public TerminatorTerminator {
334 private:
335   ShenandoahHeap* _heap;
336 public:
337   ShenandoahTerminatorTerminator(ShenandoahHeap* const heap) : _heap(heap) { }
338   // return true, terminates immediately, even if there&#39;s remaining work left
339   virtual bool should_exit_termination() { return _heap-&gt;cancelled_gc(); }
340 };
341 















342 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTASKQUEUE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahTaskqueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTaskqueue.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
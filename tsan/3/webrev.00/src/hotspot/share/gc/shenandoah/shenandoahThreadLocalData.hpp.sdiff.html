<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahThreadLocalData.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTaskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTimingTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahThreadLocalData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 25 #define SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 26 
 27 #include &quot;gc/shared/plab.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;

 29 #include &quot;gc/shenandoah/shenandoahSATBMarkQueueSet.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/sizes.hpp&quot;
 33 
 34 class ShenandoahThreadLocalData {
 35 public:
 36   static const uint INVALID_WORKER_ID = uint(-1);
 37 
 38 private:
 39   char _gc_state;
 40   char _oom_during_evac;
 41   ShenandoahSATBMarkQueue _satb_mark_queue;
 42   PLAB* _gclab;
 43   size_t _gclab_size;
 44   uint  _worker_id;
 45   bool _force_satb_flush;

 46 
 47   ShenandoahThreadLocalData() :
 48     _gc_state(0),
 49     _oom_during_evac(0),
 50     _satb_mark_queue(&amp;ShenandoahBarrierSet::satb_mark_queue_set()),
 51     _gclab(NULL),
 52     _gclab_size(0),
 53     _worker_id(INVALID_WORKER_ID),
 54     _force_satb_flush(false) {
 55   }
 56 
 57   ~ShenandoahThreadLocalData() {
 58     if (_gclab != NULL) {
 59       delete _gclab;
 60     }
 61   }
 62 
 63   static ShenandoahThreadLocalData* data(Thread* thread) {
 64     assert(UseShenandoahGC, &quot;Sanity&quot;);
 65     return thread-&gt;gc_data&lt;ShenandoahThreadLocalData&gt;();
</pre>
<hr />
<pre>
108   }
109 
110   static uint worker_id(Thread* thread) {
111     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
112     return data(thread)-&gt;_worker_id;
113   }
114 
115   static void set_force_satb_flush(Thread* thread, bool v) {
116     data(thread)-&gt;_force_satb_flush = v;
117   }
118 
119   static bool is_force_satb_flush(Thread* thread) {
120     return data(thread)-&gt;_force_satb_flush;
121   }
122 
123   static void initialize_gclab(Thread* thread) {
124     assert (thread-&gt;is_Java_thread() || thread-&gt;is_Worker_thread(), &quot;Only Java and GC worker threads are allowed to get GCLABs&quot;);
125     assert(data(thread)-&gt;_gclab == NULL, &quot;Only initialize once&quot;);
126     data(thread)-&gt;_gclab = new PLAB(PLAB::min_size());
127     data(thread)-&gt;_gclab_size = 0;

128   }
129 
130   static PLAB* gclab(Thread* thread) {
131     return data(thread)-&gt;_gclab;
132   }
133 
134   static size_t gclab_size(Thread* thread) {
135     return data(thread)-&gt;_gclab_size;
136   }
137 
138   static void set_gclab_size(Thread* thread, size_t v) {
139     data(thread)-&gt;_gclab_size = v;
140   }
141 




142 #ifdef ASSERT
143   static void set_evac_allowed(Thread* thread, bool evac_allowed) {
144     if (evac_allowed) {
145       data(thread)-&gt;_oom_during_evac |= 2;
146     } else {
147       data(thread)-&gt;_oom_during_evac &amp;= ~2;
148     }
149   }
150 
151   static bool is_evac_allowed(Thread* thread) {
152     return (data(thread)-&gt;_oom_during_evac &amp; 2) == 2;
153   }
154 #endif
155 
156   // Offsets
157   static ByteSize satb_mark_queue_active_offset() {
158     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();
159   }
160 
161   static ByteSize satb_mark_queue_index_offset() {
162     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_index();
163   }
164 
165   static ByteSize satb_mark_queue_buffer_offset() {
166     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_buf();
167   }
168 
169   static ByteSize gc_state_offset() {
170     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _gc_state);
171   }
172 



173 };
174 
175 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 26 #define SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
 27 
 28 #include &quot;gc/shared/plab.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shenandoah/shenandoahCodeRoots.hpp&quot;</span>
 31 #include &quot;gc/shenandoah/shenandoahSATBMarkQueueSet.hpp&quot;
 32 #include &quot;runtime/thread.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/sizes.hpp&quot;
 35 
 36 class ShenandoahThreadLocalData {
 37 public:
 38   static const uint INVALID_WORKER_ID = uint(-1);
 39 
 40 private:
 41   char _gc_state;
 42   char _oom_during_evac;
 43   ShenandoahSATBMarkQueue _satb_mark_queue;
 44   PLAB* _gclab;
 45   size_t _gclab_size;
 46   uint  _worker_id;
 47   bool _force_satb_flush;
<span class="line-added"> 48   int  _disarmed_value;</span>
 49 
 50   ShenandoahThreadLocalData() :
 51     _gc_state(0),
 52     _oom_during_evac(0),
 53     _satb_mark_queue(&amp;ShenandoahBarrierSet::satb_mark_queue_set()),
 54     _gclab(NULL),
 55     _gclab_size(0),
 56     _worker_id(INVALID_WORKER_ID),
 57     _force_satb_flush(false) {
 58   }
 59 
 60   ~ShenandoahThreadLocalData() {
 61     if (_gclab != NULL) {
 62       delete _gclab;
 63     }
 64   }
 65 
 66   static ShenandoahThreadLocalData* data(Thread* thread) {
 67     assert(UseShenandoahGC, &quot;Sanity&quot;);
 68     return thread-&gt;gc_data&lt;ShenandoahThreadLocalData&gt;();
</pre>
<hr />
<pre>
111   }
112 
113   static uint worker_id(Thread* thread) {
114     assert(thread-&gt;is_Worker_thread(), &quot;Must be a worker thread&quot;);
115     return data(thread)-&gt;_worker_id;
116   }
117 
118   static void set_force_satb_flush(Thread* thread, bool v) {
119     data(thread)-&gt;_force_satb_flush = v;
120   }
121 
122   static bool is_force_satb_flush(Thread* thread) {
123     return data(thread)-&gt;_force_satb_flush;
124   }
125 
126   static void initialize_gclab(Thread* thread) {
127     assert (thread-&gt;is_Java_thread() || thread-&gt;is_Worker_thread(), &quot;Only Java and GC worker threads are allowed to get GCLABs&quot;);
128     assert(data(thread)-&gt;_gclab == NULL, &quot;Only initialize once&quot;);
129     data(thread)-&gt;_gclab = new PLAB(PLAB::min_size());
130     data(thread)-&gt;_gclab_size = 0;
<span class="line-added">131     data(thread)-&gt;_disarmed_value = ShenandoahCodeRoots::disarmed_value();</span>
132   }
133 
134   static PLAB* gclab(Thread* thread) {
135     return data(thread)-&gt;_gclab;
136   }
137 
138   static size_t gclab_size(Thread* thread) {
139     return data(thread)-&gt;_gclab_size;
140   }
141 
142   static void set_gclab_size(Thread* thread, size_t v) {
143     data(thread)-&gt;_gclab_size = v;
144   }
145 
<span class="line-added">146   static void set_disarmed_value(Thread* thread, int value) {</span>
<span class="line-added">147     data(thread)-&gt;_disarmed_value = value;</span>
<span class="line-added">148   }</span>
<span class="line-added">149 </span>
150 #ifdef ASSERT
151   static void set_evac_allowed(Thread* thread, bool evac_allowed) {
152     if (evac_allowed) {
153       data(thread)-&gt;_oom_during_evac |= 2;
154     } else {
155       data(thread)-&gt;_oom_during_evac &amp;= ~2;
156     }
157   }
158 
159   static bool is_evac_allowed(Thread* thread) {
160     return (data(thread)-&gt;_oom_during_evac &amp; 2) == 2;
161   }
162 #endif
163 
164   // Offsets
165   static ByteSize satb_mark_queue_active_offset() {
166     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();
167   }
168 
169   static ByteSize satb_mark_queue_index_offset() {
170     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_index();
171   }
172 
173   static ByteSize satb_mark_queue_buffer_offset() {
174     return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_buf();
175   }
176 
177   static ByteSize gc_state_offset() {
178     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _gc_state);
179   }
180 
<span class="line-added">181   static ByteSize disarmed_value_offset() {</span>
<span class="line-added">182     return Thread::gc_data_offset() + byte_offset_of(ShenandoahThreadLocalData, _disarmed_value);</span>
<span class="line-added">183   }</span>
184 };
185 
186 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHTHREADLOCALDATA_HPP
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahTaskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTimingTracker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
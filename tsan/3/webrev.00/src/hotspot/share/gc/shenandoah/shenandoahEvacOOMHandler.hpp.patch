diff a/src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp b/src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahEvacOOMHandler.hpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -29,12 +30,12 @@
 
 /**
  * Provides safe handling of out-of-memory situations during evacuation.
  *
  * When a Java thread encounters out-of-memory while evacuating an object in a
- * write-barrier (i.e. it cannot copy the object to to-space), it does not necessarily
- * follow we can return immediately from the WB (and store to from-space).
+ * load-reference-barrier (i.e. it cannot copy the object to to-space), it does not
+ * necessarily follow we can return immediately from the LRB (and store to from-space).
  *
  * In very basic case, on such failure we may wait until the the evacuation is over,
  * and then resolve the forwarded copy, and to the store there. This is possible
  * because other threads might still have space in their GCLABs, and successfully
  * evacuate the object.
@@ -62,21 +63,21 @@
  * using a CAS. Depending on the result of the CAS:
  * - success: carry on with evac
  * - failure:
  *   - if offending value is a valid counter, then try again
  *   - if offending value is OOM-during-evac special value: loop until
- *     counter drops to 0, then exit with read-barrier
+ *     counter drops to 0, then exit with resolving the ptr
  *
  * Upon exit, exiting thread will decrease the counter using atomic dec.
  *
  * Upon OOM-during-evac, any thread will attempt to CAS OOM-during-evac
  * special value into the counter. Depending on result:
- *   - success: busy-loop until counter drops to zero, then exit with RB
+ *   - success: busy-loop until counter drops to zero, then exit with resolve
  *   - failure:
  *     - offender is valid counter update: try again
  *     - offender is OOM-during-evac: busy loop until counter drops to
- *       zero, then exit with RB
+ *       zero, then exit with resolve
  */
 class ShenandoahEvacOOMHandler {
 private:
   static const jint OOM_MARKER_MASK;
 
@@ -92,11 +93,11 @@
   /**
    * Attempt to enter the protected evacuation path.
    *
    * When this returns true, it is safe to continue with normal evacuation.
    * When this method returns false, evacuation must not be entered, and caller
-   * may safely continue with a read-barrier (if Java thread).
+   * may safely continue with a simple resolve (if Java thread).
    */
   void enter_evacuation();
 
   /**
    * Leave evacuation path.
@@ -104,11 +105,11 @@
   void leave_evacuation();
 
   /**
    * Signal out-of-memory during evacuation. It will prevent any other threads
    * from entering the evacuation path, then wait until all threads have left the
-   * evacuation path, and then return. It is then safe to continue with a read-barrier.
+   * evacuation path, and then return. It is then safe to continue with a simple resolve.
    */
   void handle_out_of_memory_during_evacuation();
 
   void clear();
 };
@@ -117,12 +118,6 @@
 public:
   ShenandoahEvacOOMScope();
   ~ShenandoahEvacOOMScope();
 };
 
-class ShenandoahEvacOOMScopeLeaver : public StackObj {
-public:
-  ShenandoahEvacOOMScopeLeaver();
-  ~ShenandoahEvacOOMScopeLeaver();
-};
-
 #endif // SHARE_GC_SHENANDOAH_SHENANDOAHEVACOOMHANDLER_HPP

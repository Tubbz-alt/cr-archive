<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeapRegionSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeuristics.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeuristics.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Red Hat, Inc. All rights reserved.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Red Hat, Inc. All rights reserved.</span>
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,11 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  
  #include &quot;gc/shared/gcCause.hpp&quot;
<span class="line-removed">- #include &quot;gc/shenandoah/shenandoahBrooksPointer.hpp&quot;</span>
  #include &quot;gc/shenandoah/shenandoahCollectionSet.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeapRegion.hpp&quot;
  #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,10 ***</span>
<span class="line-new-header">--- 119,13 ---</span>
  void ShenandoahHeuristics::choose_collection_set(ShenandoahCollectionSet* collection_set) {
    assert(collection_set-&gt;count() == 0, &quot;Must be empty&quot;);
  
    ShenandoahHeap* heap = ShenandoahHeap::heap();
  
<span class="line-added">+   // Check all pinned regions have updated status before choosing the collection set.</span>
<span class="line-added">+   heap-&gt;assert_pinned_region_status();</span>
<span class="line-added">+ </span>
    // Step 1. Build up the region candidates we care about, rejecting losers and accepting winners right away.
  
    size_t num_regions = heap-&gt;num_regions();
  
    RegionData* candidates = get_region_data_cache(num_regions);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,11 ***</span>
        }
      } else if (region-&gt;is_humongous_start()) {
        // Reclaim humongous regions here, and count them as the immediate garbage
  #ifdef ASSERT
        bool reg_live = region-&gt;has_live();
<span class="line-modified">!       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom() + ShenandoahBrooksPointer::word_size()));</span>
        assert(reg_live == bm_live,
               &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
               BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
  #endif
        if (!region-&gt;has_live()) {
<span class="line-new-header">--- 165,11 ---</span>
        }
      } else if (region-&gt;is_humongous_start()) {
        // Reclaim humongous regions here, and count them as the immediate garbage
  #ifdef ASSERT
        bool reg_live = region-&gt;has_live();
<span class="line-modified">!       bool bm_live = ctx-&gt;is_marked(oop(region-&gt;bottom()));</span>
        assert(reg_live == bm_live,
               &quot;Humongous liveness and marks should agree. Region live: %s; Bitmap live: %s; Region Live Words: &quot; SIZE_FORMAT,
               BOOL_TO_STR(reg_live), BOOL_TO_STR(bm_live), region-&gt;get_live_data_words());
  #endif
        if (!region-&gt;has_live()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,26 ***</span>
  
    // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
    // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
  
    assert (immediate_garbage &lt;= total_garbage,
<span class="line-modified">!           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;M vs &quot; SIZE_FORMAT &quot;M&quot;,</span>
<span class="line-modified">!           immediate_garbage / M, total_garbage / M);</span>
  
    size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
  
    if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
      choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
      collection_set-&gt;update_region_status();
  
      size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<span class="line-modified">!     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;M CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">!                        collection_set-&gt;garbage() / M, cset_percent, collection_set-&gt;live_data() / M, collection_set-&gt;count());</span>
    }
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;M (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">!                      immediate_garbage / M, immediate_percent, immediate_regions);</span>
  }
  
  void ShenandoahHeuristics::record_gc_start() {
    // Do nothing
  }
<span class="line-new-header">--- 188,31 ---</span>
  
    // Step 2. Look back at garbage statistics, and decide if we want to collect anything,
    // given the amount of immediately reclaimable garbage. If we do, figure out the collection set.
  
    assert (immediate_garbage &lt;= total_garbage,
<span class="line-modified">!           &quot;Cannot have more immediate garbage than total garbage: &quot; SIZE_FORMAT &quot;%s vs &quot; SIZE_FORMAT &quot;%s&quot;,</span>
<span class="line-modified">!           byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">+           byte_size_in_proper_unit(total_garbage),     proper_unit_for_byte_size(total_garbage));</span>
  
    size_t immediate_percent = total_garbage == 0 ? 0 : (immediate_garbage * 100 / total_garbage);
  
    if (immediate_percent &lt;= ShenandoahImmediateThreshold) {
      choose_collection_set_from_regiondata(collection_set, candidates, cand_idx, immediate_garbage + free);
      collection_set-&gt;update_region_status();
  
      size_t cset_percent = total_garbage == 0 ? 0 : (collection_set-&gt;garbage() * 100 / total_garbage);
<span class="line-modified">!     log_info(gc, ergo)(&quot;Collectable Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot;%s CSet, &quot; SIZE_FORMAT &quot; CSet regions&quot;,</span>
<span class="line-modified">!                        byte_size_in_proper_unit(collection_set-&gt;garbage()),   proper_unit_for_byte_size(collection_set-&gt;garbage()),</span>
<span class="line-added">+                        cset_percent,</span>
<span class="line-added">+                        byte_size_in_proper_unit(collection_set-&gt;live_data()), proper_unit_for_byte_size(collection_set-&gt;live_data()),</span>
<span class="line-added">+                        collection_set-&gt;count());</span>
    }
  
<span class="line-modified">!   log_info(gc, ergo)(&quot;Immediate Garbage: &quot; SIZE_FORMAT &quot;%s (&quot; SIZE_FORMAT &quot;%% of total), &quot; SIZE_FORMAT &quot; regions&quot;,</span>
<span class="line-modified">!                      byte_size_in_proper_unit(immediate_garbage), proper_unit_for_byte_size(immediate_garbage),</span>
<span class="line-added">+                      immediate_percent, immediate_regions);</span>
  }
  
  void ShenandoahHeuristics::record_gc_start() {
    // Do nothing
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,32 ***</span>
  
  bool ShenandoahHeuristics::should_start_update_refs() {
    return _update_refs_early;
  }
  
<span class="line-modified">! bool ShenandoahHeuristics::should_start_normal_gc() const {</span>
    // Perform GC to cleanup metaspace
    if (has_metaspace_oom()) {
      // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
      log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
      return true;
    }
  
<span class="line-modified">!   double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">!   bool periodic_gc = (last_time_ms &gt; ShenandoahGuaranteedGCInterval);</span>
<span class="line-modified">!   if (periodic_gc) {</span>
<span class="line-modified">!     log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">!                   last_time_ms, ShenandoahGuaranteedGCInterval);</span>
    }
<span class="line-removed">-   return periodic_gc;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ShenandoahHeuristics::should_start_traversal_gc() {</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
  
<span class="line-removed">- bool ShenandoahHeuristics::can_do_traversal_gc() {</span>
    return false;
  }
  
  bool ShenandoahHeuristics::should_degenerate_cycle() {
    return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
<span class="line-new-header">--- 235,27 ---</span>
  
  bool ShenandoahHeuristics::should_start_update_refs() {
    return _update_refs_early;
  }
  
<span class="line-modified">! bool ShenandoahHeuristics::should_start_gc() const {</span>
    // Perform GC to cleanup metaspace
    if (has_metaspace_oom()) {
      // Some of vmTestbase/metaspace tests depend on following line to count GC cycles
      log_info(gc)(&quot;Trigger: %s&quot;, GCCause::to_string(GCCause::_metadata_GC_threshold));
      return true;
    }
  
<span class="line-modified">!   if (ShenandoahGuaranteedGCInterval &gt; 0) {</span>
<span class="line-modified">!     double last_time_ms = (os::elapsedTime() - _last_cycle_end) * 1000;</span>
<span class="line-modified">!     if (last_time_ms &gt; ShenandoahGuaranteedGCInterval) {</span>
<span class="line-modified">!       log_info(gc)(&quot;Trigger: Time since last GC (%.0f ms) is larger than guaranteed interval (&quot; UINTX_FORMAT &quot; ms)&quot;,</span>
<span class="line-modified">!                    last_time_ms, ShenandoahGuaranteedGCInterval);</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
    }
  
    return false;
  }
  
  bool ShenandoahHeuristics::should_degenerate_cycle() {
    return _degenerated_cycles_in_a_row &lt;= ShenandoahFullGCThreshold;
</pre>
<center><a href="shenandoahHeapRegionSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeuristics.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/psPromotionManager.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psPromotionManager.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 155,20 ***</span>
    oop new_obj = NULL;
  
    // NOTE! We must be very careful with any methods that access the mark
    // in o. There may be multiple threads racing on it, and it may be forwarded
    // at any time. Do not use oop methods for accessing the mark!
<span class="line-modified">!   markOop test_mark = o-&gt;mark_raw();</span>
  
    // The same test as &quot;o-&gt;is_forwarded()&quot;
<span class="line-modified">!   if (!test_mark-&gt;is_marked()) {</span>
      bool new_obj_is_tenured = false;
      size_t new_obj_size = o-&gt;size();
  
      // Find the objects age, MT safe.
<span class="line-modified">!     uint age = (test_mark-&gt;has_displaced_mark_helper() /* o-&gt;has_displaced_mark() */) ?</span>
<span class="line-modified">!       test_mark-&gt;displaced_mark_helper()-&gt;age() : test_mark-&gt;age();</span>
  
      if (!promote_immediately) {
        // Try allocating obj in to-space (unless too old)
        if (age &lt; PSScavenge::tenuring_threshold()) {
          new_obj = (oop) _young_lab.allocate(new_obj_size);
<span class="line-new-header">--- 155,20 ---</span>
    oop new_obj = NULL;
  
    // NOTE! We must be very careful with any methods that access the mark
    // in o. There may be multiple threads racing on it, and it may be forwarded
    // at any time. Do not use oop methods for accessing the mark!
<span class="line-modified">!   markWord test_mark = o-&gt;mark_raw();</span>
  
    // The same test as &quot;o-&gt;is_forwarded()&quot;
<span class="line-modified">!   if (!test_mark.is_marked()) {</span>
      bool new_obj_is_tenured = false;
      size_t new_obj_size = o-&gt;size();
  
      // Find the objects age, MT safe.
<span class="line-modified">!     uint age = (test_mark.has_displaced_mark_helper() /* o-&gt;has_displaced_mark() */) ?</span>
<span class="line-modified">!       test_mark.displaced_mark_helper().age() : test_mark.age();</span>
  
      if (!promote_immediately) {
        // Try allocating obj in to-space (unless too old)
        if (age &lt; PSScavenge::tenuring_threshold()) {
          new_obj = (oop) _young_lab.allocate(new_obj_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,11 ***</span>
              if(lab_base != NULL) {
  #ifdef ASSERT
                // Delay the initialization of the promotion lab (plab).
                // This exposes uninitialized plabs to card table processing.
                if (GCWorkerDelayMillis &gt; 0) {
<span class="line-modified">!                 os::sleep(Thread::current(), GCWorkerDelayMillis, false);</span>
                }
  #endif
                _old_lab.initialize(MemRegion(lab_base, OldPLABSize));
                // Try the old lab allocation again.
                new_obj = (oop) _old_lab.allocate(new_obj_size);
<span class="line-new-header">--- 222,11 ---</span>
              if(lab_base != NULL) {
  #ifdef ASSERT
                // Delay the initialization of the promotion lab (plab).
                // This exposes uninitialized plabs to card table processing.
                if (GCWorkerDelayMillis &gt; 0) {
<span class="line-modified">!                 os::naked_sleep(GCWorkerDelayMillis);</span>
                }
  #endif
                _old_lab.initialize(MemRegion(lab_base, OldPLABSize));
                // Try the old lab allocation again.
                new_obj = (oop) _old_lab.allocate(new_obj_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,20 ***</span>
      }
  
      assert(new_obj != NULL, &quot;allocation should have succeeded&quot;);
  
      // Copy obj
<span class="line-modified">!     Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)new_obj, new_obj_size);</span>
  
      // Now we have to CAS in the header.
      // Make copy visible to threads reading the forwardee.
      if (o-&gt;cas_forward_to(new_obj, test_mark, memory_order_release)) {
        // We won any races, we &quot;own&quot; this object.
        assert(new_obj == o-&gt;forwardee(), &quot;Sanity&quot;);
  
        // Increment age if obj still in new generation. Now that
<span class="line-modified">!       // we&#39;re dealing with a markOop that cannot change, it is</span>
        // okay to use the non mt safe oop methods.
        if (!new_obj_is_tenured) {
          new_obj-&gt;incr_age();
          assert(young_space()-&gt;contains(new_obj), &quot;Attempt to push non-promoted obj&quot;);
        }
<span class="line-new-header">--- 249,20 ---</span>
      }
  
      assert(new_obj != NULL, &quot;allocation should have succeeded&quot;);
  
      // Copy obj
<span class="line-modified">!     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(o), cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
  
      // Now we have to CAS in the header.
      // Make copy visible to threads reading the forwardee.
      if (o-&gt;cas_forward_to(new_obj, test_mark, memory_order_release)) {
        // We won any races, we &quot;own&quot; this object.
        assert(new_obj == o-&gt;forwardee(), &quot;Sanity&quot;);
  
        // Increment age if obj still in new generation. Now that
<span class="line-modified">!       // we&#39;re dealing with a markWord that cannot change, it is</span>
        // okay to use the non mt safe oop methods.
        if (!new_obj_is_tenured) {
          new_obj-&gt;incr_age();
          assert(young_space()-&gt;contains(new_obj), &quot;Attempt to push non-promoted obj&quot;);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,15 ***</span>
  
        // Try to deallocate the space.  If it was directly allocated we cannot
        // deallocate it, so we have to test.  If the deallocation fails,
        // overwrite with a filler object.
        if (new_obj_is_tenured) {
<span class="line-modified">!         if (!_old_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {</span>
<span class="line-modified">!           CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);</span>
          }
<span class="line-modified">!       } else if (!_young_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {</span>
<span class="line-modified">!         CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);</span>
        }
  
        // don&#39;t update this before the unallocation!
        // Using acquire though consume would be accurate for accessing new_obj.
        new_obj = o-&gt;forwardee_acquire();
<span class="line-new-header">--- 288,15 ---</span>
  
        // Try to deallocate the space.  If it was directly allocated we cannot
        // deallocate it, so we have to test.  If the deallocation fails,
        // overwrite with a filler object.
        if (new_obj_is_tenured) {
<span class="line-modified">!         if (!_old_lab.unallocate_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size)) {</span>
<span class="line-modified">!           CollectedHeap::fill_with_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
          }
<span class="line-modified">!       } else if (!_young_lab.unallocate_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size)) {</span>
<span class="line-modified">!         CollectedHeap::fill_with_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
        }
  
        // don&#39;t update this before the unallocation!
        // Using acquire though consume would be accurate for accessing new_obj.
        new_obj = o-&gt;forwardee_acquire();
</pre>
<center><a href="psPromotionManager.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
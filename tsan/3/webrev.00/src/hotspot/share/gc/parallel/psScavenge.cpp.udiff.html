<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/psScavenge.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psScavenge.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,22 +21,22 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;aot/aotLoader.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;classfile/classLoaderDataGraph.hpp&quot;</span>
  #include &quot;classfile/stringTable.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  #include &quot;gc/parallel/psClosure.inline.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/parallel/psMarkSweepProxy.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/parallel/psCompactionManager.hpp&quot;</span>
  #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/parallel/psRootType.hpp&quot;</span>
  #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/parallel/psTasks.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;gc/shared/gcCause.hpp&quot;
  #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcTimer.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -44,22 +44,29 @@</span>
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  #include &quot;gc/shared/referencePolicy.hpp&quot;
  #include &quot;gc/shared/referenceProcessor.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shared/scavengableNMethods.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
  #include &quot;gc/shared/weakProcessor.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/workerPolicy.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/workgroup.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/threadCritical.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
<span class="udiff-line-added">+ #include &quot;services/management.hpp&quot;</span>
  #include &quot;services/memoryService.hpp&quot;
  #include &quot;utilities/stack.inline.hpp&quot;
  
  HeapWord*                     PSScavenge::_to_space_top_before_gc = NULL;
  int                           PSScavenge::_consecutive_skipped_scavenges = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,10 +80,91 @@</span>
  elapsedTimer                  PSScavenge::_accumulated_time;
  STWGCTimer                    PSScavenge::_gc_timer;
  ParallelScavengeTracer        PSScavenge::_gc_tracer;
  CollectorCounters*            PSScavenge::_counters = NULL;
  
<span class="udiff-line-added">+ static void scavenge_roots_work(ParallelRootType::Value root_type, uint worker_id) {</span>
<span class="udiff-line-added">+   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="udiff-line-added">+   PSScavengeRootsClosure roots_closure(pm);</span>
<span class="udiff-line-added">+   PSPromoteRootsClosure  roots_to_old_closure(pm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   switch (root_type) {</span>
<span class="udiff-line-added">+     case ParallelRootType::universe:</span>
<span class="udiff-line-added">+       Universe::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::jni_handles:</span>
<span class="udiff-line-added">+       JNIHandles::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::object_synchronizer:</span>
<span class="udiff-line-added">+       ObjectSynchronizer::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::system_dictionary:</span>
<span class="udiff-line-added">+       SystemDictionary::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::class_loader_data:</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         PSScavengeCLDClosure cld_closure(pm);</span>
<span class="udiff-line-added">+         ClassLoaderDataGraph::cld_do(&amp;cld_closure);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::management:</span>
<span class="udiff-line-added">+       Management::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::jvmti:</span>
<span class="udiff-line-added">+       JvmtiExport::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::code_cache:</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         MarkingCodeBlobClosure code_closure(&amp;roots_to_old_closure, CodeBlobToOopClosure::FixRelocations);</span>
<span class="udiff-line-added">+         ScavengableNMethods::nmethods_do(&amp;code_closure);</span>
<span class="udiff-line-added">+         AOTLoader::oops_do(&amp;roots_closure);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ParallelRootType::sentinel:</span>
<span class="udiff-line-added">+     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds</span>
<span class="udiff-line-added">+       fatal(&quot;Bad enumeration value: %u&quot;, root_type);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Do the real work</span>
<span class="udiff-line-added">+   pm-&gt;drain_stacks(false);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void steal_work(TaskTerminator&amp; terminator, uint worker_id) {</span>
<span class="udiff-line-added">+   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   PSPromotionManager* pm =</span>
<span class="udiff-line-added">+     PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="udiff-line-added">+   pm-&gt;drain_stacks(true);</span>
<span class="udiff-line-added">+   guarantee(pm-&gt;stacks_empty(),</span>
<span class="udiff-line-added">+             &quot;stacks should be empty at this point&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   while (true) {</span>
<span class="udiff-line-added">+     StarTask p;</span>
<span class="udiff-line-added">+     if (PSPromotionManager::steal_depth(worker_id, p)) {</span>
<span class="udiff-line-added">+       TASKQUEUE_STATS_ONLY(pm-&gt;record_steal(p));</span>
<span class="udiff-line-added">+       pm-&gt;process_popped_location_depth(p);</span>
<span class="udiff-line-added">+       pm-&gt;drain_stacks_depth(true);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       if (terminator.offer_termination()) {</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   guarantee(pm-&gt;stacks_empty(), &quot;stacks should be empty at this point&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Define before use
  class PSIsAliveClosure: public BoolObjectClosure {
  public:
    bool do_object_b(oop p) {
      return (!PSScavenge::is_obj_in_young(p)) || p-&gt;is_forwarded();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,61 +211,46 @@</span>
      guarantee(_promotion_manager-&gt;stacks_empty(),
                &quot;stacks should be empty at this point&quot;);
    }
  };
  
<span class="udiff-line-removed">- class PSRefProcTaskProxy: public GCTask {</span>
<span class="udiff-line-removed">-   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="udiff-line-removed">-   ProcessTask &amp; _rp_task;</span>
<span class="udiff-line-removed">-   uint          _work_id;</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   PSRefProcTaskProxy(ProcessTask &amp; rp_task, uint work_id)</span>
<span class="udiff-line-removed">-     : _rp_task(rp_task),</span>
<span class="udiff-line-removed">-       _work_id(work_id)</span>
<span class="udiff-line-removed">-   { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-   virtual char* name() { return (char *)&quot;Process referents by policy in parallel&quot;; }</span>
<span class="udiff-line-removed">-   virtual void do_it(GCTaskManager* manager, uint which);</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void PSRefProcTaskProxy::do_it(GCTaskManager* manager, uint which)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   PSPromotionManager* promotion_manager =</span>
<span class="udiff-line-removed">-     PSPromotionManager::gc_thread_promotion_manager(which);</span>
<span class="udiff-line-removed">-   assert(promotion_manager != NULL, &quot;sanity check&quot;);</span>
<span class="udiff-line-removed">-   PSKeepAliveClosure keep_alive(promotion_manager);</span>
<span class="udiff-line-removed">-   PSEvacuateFollowersClosure evac_followers(promotion_manager);</span>
<span class="udiff-line-removed">-   PSIsAliveClosure is_alive;</span>
<span class="udiff-line-removed">-   _rp_task.work(_work_id, is_alive, keep_alive, evac_followers);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {
<span class="udiff-line-modified-removed">-   virtual void execute(ProcessTask&amp; task, uint ergo_workers);</span>
<span class="udiff-line-modified-added">+   virtual void execute(ProcessTask&amp; process_task, uint ergo_workers);</span>
  };
  
<span class="udiff-line-modified-removed">- void PSRefProcTaskExecutor::execute(ProcessTask&amp; task, uint ergo_workers)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-   GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="udiff-line-modified-removed">-   GCTaskManager* manager = ParallelScavengeHeap::gc_task_manager();</span>
<span class="udiff-line-modified-removed">-   uint active_workers = manager-&gt;active_workers();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(active_workers == ergo_workers,</span>
<span class="udiff-line-removed">-          &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,</span>
<span class="udiff-line-removed">-          ergo_workers, active_workers);</span>
<span class="udiff-line-modified-added">+ class PSRefProcTask : public AbstractGangTask {</span>
<span class="udiff-line-modified-added">+   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="udiff-line-modified-added">+   TaskTerminator _terminator;</span>
<span class="udiff-line-modified-added">+   ProcessTask&amp; _task;</span>
<span class="udiff-line-modified-added">+   uint _active_workers;</span>
  
<span class="udiff-line-modified-removed">-   for(uint i=0; i &lt; active_workers; i++) {</span>
<span class="udiff-line-modified-removed">-     q-&gt;enqueue(new PSRefProcTaskProxy(task, i));</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-modified-added">+   PSRefProcTask(ProcessTask&amp; task, uint active_workers)</span>
<span class="udiff-line-added">+     : AbstractGangTask(&quot;PSRefProcTask&quot;),</span>
<span class="udiff-line-added">+       _terminator(active_workers, PSPromotionManager::stack_array_depth()),</span>
<span class="udiff-line-added">+       _task(task),</span>
<span class="udiff-line-added">+       _active_workers(active_workers) {</span>
    }
<span class="udiff-line-modified-removed">-   TaskTerminator terminator(active_workers,</span>
<span class="udiff-line-modified-removed">-                             (TaskQueueSetSuper*) PSPromotionManager::stack_array_depth());</span>
<span class="udiff-line-modified-removed">-   if (task.marks_oops_alive() &amp;&amp; active_workers &gt; 1) {</span>
<span class="udiff-line-modified-removed">-     for (uint j = 0; j &lt; active_workers; j++) {</span>
<span class="udiff-line-modified-removed">-       q-&gt;enqueue(new StealTask(terminator.terminator()));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   virtual void work(uint worker_id) {</span>
<span class="udiff-line-modified-added">+     PSPromotionManager* promotion_manager =</span>
<span class="udiff-line-modified-added">+       PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="udiff-line-modified-added">+     assert(promotion_manager != NULL, &quot;sanity check&quot;);</span>
<span class="udiff-line-added">+     PSKeepAliveClosure keep_alive(promotion_manager);</span>
<span class="udiff-line-added">+     PSEvacuateFollowersClosure evac_followers(promotion_manager);</span>
<span class="udiff-line-added">+     PSIsAliveClosure is_alive;</span>
<span class="udiff-line-added">+     _task.work(worker_id, is_alive, keep_alive, evac_followers);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (_task.marks_oops_alive() &amp;&amp; _active_workers &gt; 1) {</span>
<span class="udiff-line-added">+       steal_work(_terminator, worker_id);</span>
      }
    }
<span class="udiff-line-modified-removed">-   manager-&gt;execute_and_wait(q);</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void PSRefProcTaskExecutor::execute(ProcessTask&amp; process_task, uint ergo_workers) {</span>
<span class="udiff-line-added">+   PSRefProcTask task(process_task, ergo_workers);</span>
<span class="udiff-line-added">+   ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
  }
  
  // This method contains all heap specific policy for invoking scavenge.
  // PSScavenge::invoke_no_policy() will do nothing but attempt to
  // scavenge. It will not clean up after failed promotions, bail out if
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,28 +282,106 @@</span>
    if (need_full_gc) {
      GCCauseSetter gccs(heap, GCCause::_adaptive_size_policy);
      SoftRefPolicy* srp = heap-&gt;soft_ref_policy();
      const bool clear_all_softrefs = srp-&gt;should_clear_all_soft_refs();
  
<span class="udiff-line-modified-removed">-     if (UseParallelOldGC) {</span>
<span class="udiff-line-removed">-       full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       full_gc_done = PSMarkSweepProxy::invoke_no_policy(clear_all_softrefs);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span>
    }
  
    return full_gc_done;
  }
  
<span class="udiff-line-modified-removed">- class PSAddThreadRootsTaskClosure : public ThreadClosure {</span>
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-   GCTaskQueue* _q;</span>
<span class="udiff-line-modified-added">+ class PSThreadRootsTaskClosure : public ThreadClosure {</span>
<span class="udiff-line-modified-added">+   uint _worker_id;</span>
<span class="udiff-line-modified-added">+ public:</span>
<span class="udiff-line-added">+   PSThreadRootsTaskClosure(uint worker_id) : _worker_id(worker_id) { }</span>
<span class="udiff-line-added">+   virtual void do_thread(Thread* thread) {</span>
<span class="udiff-line-added">+     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(_worker_id);</span>
<span class="udiff-line-added">+     PSScavengeRootsClosure roots_closure(pm);</span>
<span class="udiff-line-added">+     MarkingCodeBlobClosure roots_in_blobs(&amp;roots_closure, CodeBlobToOopClosure::FixRelocations);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     thread-&gt;oops_do(&amp;roots_closure, &amp;roots_in_blobs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Do the real work</span>
<span class="udiff-line-added">+     pm-&gt;drain_stacks(false);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class ScavengeRootsTask : public AbstractGangTask {</span>
<span class="udiff-line-added">+   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do</span>
<span class="udiff-line-added">+   SequentialSubTasksDone _subtasks;</span>
<span class="udiff-line-added">+   PSOldGen* _old_gen;</span>
<span class="udiff-line-added">+   HeapWord* _gen_top;</span>
<span class="udiff-line-added">+   uint _active_workers;</span>
<span class="udiff-line-added">+   bool _is_empty;</span>
<span class="udiff-line-added">+   TaskTerminator _terminator;</span>
  
  public:
<span class="udiff-line-modified-removed">-   PSAddThreadRootsTaskClosure(GCTaskQueue* q) : _q(q) { }</span>
<span class="udiff-line-modified-removed">-   void do_thread(Thread* t) {</span>
<span class="udiff-line-modified-removed">-     _q-&gt;enqueue(new ThreadRootsTask(t));</span>
<span class="udiff-line-modified-added">+   ScavengeRootsTask(PSOldGen* old_gen,</span>
<span class="udiff-line-modified-added">+                     HeapWord* gen_top,</span>
<span class="udiff-line-modified-added">+                     uint active_workers,</span>
<span class="udiff-line-added">+                     bool is_empty) :</span>
<span class="udiff-line-added">+       AbstractGangTask(&quot;ScavengeRootsTask&quot;),</span>
<span class="udiff-line-added">+       _strong_roots_scope(active_workers),</span>
<span class="udiff-line-added">+       _subtasks(),</span>
<span class="udiff-line-added">+       _old_gen(old_gen),</span>
<span class="udiff-line-added">+       _gen_top(gen_top),</span>
<span class="udiff-line-added">+       _active_workers(active_workers),</span>
<span class="udiff-line-added">+       _is_empty(is_empty),</span>
<span class="udiff-line-added">+       _terminator(active_workers, PSPromotionManager::vm_thread_promotion_manager()-&gt;stack_array_depth()) {</span>
<span class="udiff-line-added">+     _subtasks.set_n_threads(active_workers);</span>
<span class="udiff-line-added">+     _subtasks.set_n_tasks(ParallelRootType::sentinel);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   virtual void work(uint worker_id) {</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!_is_empty) {</span>
<span class="udiff-line-added">+       // There are only old-to-young pointers if there are objects</span>
<span class="udiff-line-added">+       // in the old gen.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       assert(_old_gen != NULL, &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+       // There are no old-to-young pointers if the old gen is empty.</span>
<span class="udiff-line-added">+       assert(!_old_gen-&gt;object_space()-&gt;is_empty(), &quot;Should not be called is there is no work&quot;);</span>
<span class="udiff-line-added">+       assert(_old_gen-&gt;object_space()-&gt;contains(_gen_top) || _gen_top == _old_gen-&gt;object_space()-&gt;top(), &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+       assert(worker_id &lt; ParallelGCThreads, &quot;Sanity&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="udiff-line-added">+         PSCardTable* card_table = ParallelScavengeHeap::heap()-&gt;card_table();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         card_table-&gt;scavenge_contents_parallel(_old_gen-&gt;start_array(),</span>
<span class="udiff-line-added">+                                                _old_gen-&gt;object_space(),</span>
<span class="udiff-line-added">+                                                _gen_top,</span>
<span class="udiff-line-added">+                                                pm,</span>
<span class="udiff-line-added">+                                                worker_id,</span>
<span class="udiff-line-added">+                                                _active_workers);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Do the real work</span>
<span class="udiff-line-added">+         pm-&gt;drain_stacks(false);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (uint root_type = 0; _subtasks.try_claim_task(root_type); /* empty */ ) {</span>
<span class="udiff-line-added">+       scavenge_roots_work(static_cast&lt;ParallelRootType::Value&gt;(root_type), worker_id);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     _subtasks.all_tasks_completed();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     PSThreadRootsTaskClosure closure(worker_id);</span>
<span class="udiff-line-added">+     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // If active_workers can exceed 1, add a steal_work().</span>
<span class="udiff-line-added">+     // PSPromotionManager::drain_stacks_depth() does not fully drain its</span>
<span class="udiff-line-added">+     // stacks and expects a steal_work() to complete the draining if</span>
<span class="udiff-line-added">+     // ParallelGCThreads is &gt; 1.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (_active_workers &gt; 1) {</span>
<span class="udiff-line-added">+       steal_work(_terminator, worker_id);</span>
<span class="udiff-line-added">+     }</span>
    }
  };
  
  // This method contains no policy. You should probably
  // be calling invoke() instead.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -275,11 +426,11 @@</span>
    }
  
    heap-&gt;print_heap_before_gc();
    heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
  
<span class="udiff-line-modified-removed">-   assert(!NeverTenure || _tenuring_threshold == markOopDesc::max_age + 1, &quot;Sanity&quot;);</span>
<span class="udiff-line-modified-added">+   assert(!NeverTenure || _tenuring_threshold == markWord::max_age + 1, &quot;Sanity&quot;);</span>
    assert(!AlwaysTenure || _tenuring_threshold == 0, &quot;Sanity&quot;);
  
    // Fill in TLABs
    heap-&gt;ensure_parsability(true);  // retire TLABs
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -326,75 +477,36 @@</span>
  #endif
  
      reference_processor()-&gt;enable_discovery();
      reference_processor()-&gt;setup_policy(false);
  
<span class="udiff-line-modified-removed">-     PreGCValues pre_gc_values(heap);</span>
<span class="udiff-line-modified-added">+     const PreGenGCValues pre_gc_values = heap-&gt;get_pre_gc_values();</span>
  
      // Reset our survivor overflow.
      set_survivor_overflow(false);
  
      // We need to save the old top values before
      // creating the promotion_manager. We pass the top
      // values to the card_table, to prevent it from
      // straying into the promotion labs.
      HeapWord* old_top = old_gen-&gt;object_space()-&gt;top();
  
<span class="udiff-line-modified-removed">-     // Release all previously held resources</span>
<span class="udiff-line-modified-removed">-     gc_task_manager()-&gt;release_all_resources();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Set the number of GC threads to be used in this collection</span>
<span class="udiff-line-modified-removed">-     gc_task_manager()-&gt;set_active_gang();</span>
<span class="udiff-line-removed">-     gc_task_manager()-&gt;task_idle_workers();</span>
<span class="udiff-line-removed">-     // Get the active number of workers here and use that value</span>
<span class="udiff-line-removed">-     // throughout the methods.</span>
<span class="udiff-line-removed">-     uint active_workers = gc_task_manager()-&gt;active_workers();</span>
<span class="udiff-line-modified-added">+     const uint active_workers =</span>
<span class="udiff-line-modified-added">+       WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()-&gt;workers().total_workers(),</span>
<span class="udiff-line-modified-added">+                                         ParallelScavengeHeap::heap()-&gt;workers().active_workers(),</span>
<span class="udiff-line-modified-added">+                                         Threads::number_of_non_daemon_threads());</span>
<span class="udiff-line-modified-added">+     ParallelScavengeHeap::heap()-&gt;workers().update_active_workers(active_workers);</span>
  
      PSPromotionManager::pre_scavenge();
  
      // We&#39;ll use the promotion manager again later.
      PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();
      {
        GCTraceTime(Debug, gc, phases) tm(&quot;Scavenge&quot;, &amp;_gc_timer);
<span class="udiff-line-removed">-       ParallelScavengeHeap::ParStrongRootsScope psrs;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       GCTaskQueue* q = GCTaskQueue::create();</span>
  
<span class="udiff-line-modified-removed">-       if (!old_gen-&gt;object_space()-&gt;is_empty()) {</span>
<span class="udiff-line-modified-removed">-         // There are only old-to-young pointers if there are objects</span>
<span class="udiff-line-removed">-         // in the old gen.</span>
<span class="udiff-line-removed">-         uint stripe_total = active_workers;</span>
<span class="udiff-line-removed">-         for(uint i=0; i &lt; stripe_total; i++) {</span>
<span class="udiff-line-removed">-           q-&gt;enqueue(new OldToYoungRootsTask(old_gen, old_top, i, stripe_total));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::universe));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::jni_handles));</span>
<span class="udiff-line-removed">-       // We scan the thread roots in parallel</span>
<span class="udiff-line-removed">-       PSAddThreadRootsTaskClosure cl(q);</span>
<span class="udiff-line-removed">-       Threads::java_threads_and_vm_thread_do(&amp;cl);</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::object_synchronizer));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::management));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::system_dictionary));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::class_loader_data));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::jvmti));</span>
<span class="udiff-line-removed">-       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::code_cache));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       TaskTerminator terminator(active_workers,</span>
<span class="udiff-line-removed">-                                 (TaskQueueSetSuper*) promotion_manager-&gt;stack_array_depth());</span>
<span class="udiff-line-removed">-         // If active_workers can exceed 1, add a StrealTask.</span>
<span class="udiff-line-removed">-         // PSPromotionManager::drain_stacks_depth() does not fully drain its</span>
<span class="udiff-line-removed">-         // stacks and expects a StealTask to complete the draining if</span>
<span class="udiff-line-removed">-         // ParallelGCThreads is &gt; 1.</span>
<span class="udiff-line-removed">-         if (gc_task_manager()-&gt;workers() &gt; 1) {</span>
<span class="udiff-line-removed">-           for (uint j = 0; j &lt; active_workers; j++) {</span>
<span class="udiff-line-removed">-             q-&gt;enqueue(new StealTask(terminator.terminator()));</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       gc_task_manager()-&gt;execute_and_wait(q);</span>
<span class="udiff-line-modified-added">+       ScavengeRootsTask task(old_gen, old_top, active_workers, old_gen-&gt;object_space()-&gt;is_empty());</span>
<span class="udiff-line-modified-added">+       ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
      }
  
      scavenge_midpoint.update();
  
      // Process reference objects discovered during scavenge
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -596,19 +708,15 @@</span>
  
      if (log_is_enabled(Debug, gc, heap, exit)) {
        accumulated_time()-&gt;stop();
      }
  
<span class="udiff-line-modified-removed">-     young_gen-&gt;print_used_change(pre_gc_values.young_gen_used());</span>
<span class="udiff-line-removed">-     old_gen-&gt;print_used_change(pre_gc_values.old_gen_used());</span>
<span class="udiff-line-removed">-     MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());</span>
<span class="udiff-line-modified-added">+     heap-&gt;print_heap_change(pre_gc_values);</span>
  
      // Track memory usage and detect low memory
      MemoryService::track_memory_usage();
      heap-&gt;update_counters();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     gc_task_manager()-&gt;release_idle_workers();</span>
    }
  
    if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
      HandleMark hm;  // Discard invalid handles created during verification
      Universe::verify(&quot;After GC&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -620,15 +728,10 @@</span>
    scavenge_exit.update();
  
    log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
                              scavenge_entry.ticks(), scavenge_midpoint.ticks(),
                              scavenge_exit.ticks());
<span class="udiff-line-removed">-   gc_task_manager()-&gt;print_task_time_stamps();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef TRACESPINNING</span>
<span class="udiff-line-removed">-   ParallelTaskTerminator::print_termination_counts();</span>
<span class="udiff-line-removed">- #endif</span>
  
    AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
  
    _gc_timer.register_gc_end();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -698,17 +801,10 @@</span>
      }
    }
    return result;
  }
  
<span class="udiff-line-removed">-   // Used to add tasks</span>
<span class="udiff-line-removed">- GCTaskManager* const PSScavenge::gc_task_manager() {</span>
<span class="udiff-line-removed">-   assert(ParallelScavengeHeap::gc_task_manager() != NULL,</span>
<span class="udiff-line-removed">-    &quot;shouldn&#39;t return NULL&quot;);</span>
<span class="udiff-line-removed">-   return ParallelScavengeHeap::gc_task_manager();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  // Adaptive size policy support.  When the young generation/old generation
  // boundary moves, _young_generation_boundary must be reset
  void PSScavenge::set_young_generation_boundary(HeapWord* v) {
    _young_generation_boundary = v;
    if (UseCompressedOops) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,12 +814,12 @@</span>
  
  void PSScavenge::initialize() {
    // Arguments must have been parsed
  
    if (AlwaysTenure || NeverTenure) {
<span class="udiff-line-modified-removed">-     assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOopDesc::max_age + 1,</span>
<span class="udiff-line-modified-removed">-            &quot;MaxTenuringThreshold should be 0 or markOopDesc::max_age + 1, but is %d&quot;, (int) MaxTenuringThreshold);</span>
<span class="udiff-line-modified-added">+     assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,</span>
<span class="udiff-line-modified-added">+            &quot;MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is %d&quot;, (int) MaxTenuringThreshold);</span>
      _tenuring_threshold = MaxTenuringThreshold;
    } else {
      // We want to smooth out our startup times for the AdaptiveSizePolicy
      _tenuring_threshold = (UseAdaptiveSizePolicy) ? InitialTenuringThreshold :
                                                      MaxTenuringThreshold;
</pre>
<center><a href="psPromotionManager.inline.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psCardTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psAdaptiveSizePolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCardTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psCardTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-removed"> 26 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
 27 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
 28 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 29 #include &quot;gc/parallel/psCardTable.hpp&quot;
 30 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 31 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
<span class="line-removed"> 32 #include &quot;gc/parallel/psTasks.hpp&quot;</span>
 33 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 34 #include &quot;memory/iterator.inline.hpp&quot;
 35 #include &quot;oops/access.inline.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;runtime/prefetch.inline.hpp&quot;
 38 #include &quot;utilities/align.hpp&quot;
 39 
 40 // Checks an individual oop for missing precise marks. Mark
 41 // may be either dirty or newgen.
 42 class CheckForUnmarkedOops : public BasicOopIterateClosure {
 43  private:
 44   PSYoungGen*  _young_gen;
 45   PSCardTable* _card_table;
 46   HeapWord*    _unmarked_addr;
 47 
 48  protected:
 49   template &lt;class T&gt; void do_oop_work(T* p) {
 50     oop obj = RawAccess&lt;&gt;::oop_load(p);
 51     if (_young_gen-&gt;is_in_reserved(obj) &amp;&amp;
 52         !_card_table-&gt;addr_is_marked_imprecise(p)) {
</pre>
<hr />
<pre>
111     }
112   }
113 
114  public:
115   CheckForPreciseMarks(PSYoungGen* young_gen, PSCardTable* card_table) :
116     _young_gen(young_gen), _card_table(card_table) { }
117 
118   virtual void do_oop(oop* p)       { CheckForPreciseMarks::do_oop_work(p); }
119   virtual void do_oop(narrowOop* p) { CheckForPreciseMarks::do_oop_work(p); }
120 };
121 
122 // We get passed the space_top value to prevent us from traversing into
123 // the old_gen promotion labs, which cannot be safely parsed.
124 
125 // Do not call this method if the space is empty.
126 // It is a waste to start tasks and get here only to
127 // do no work.  If this method needs to be called
128 // when the space is empty, fix the calculation of
129 // end_card to allow sp_top == sp-&gt;bottom().
130 
































131 void PSCardTable::scavenge_contents_parallel(ObjectStartArray* start_array,
132                                              MutableSpace* sp,
133                                              HeapWord* space_top,
134                                              PSPromotionManager* pm,
135                                              uint stripe_number,
136                                              uint stripe_total) {
137   int ssize = 128; // Naked constant!  Work unit = 64k.
138   int dirty_card_count = 0;
139 
140   // It is a waste to get here if empty.
141   assert(sp-&gt;bottom() &lt; sp-&gt;top(), &quot;Should not be called if empty&quot;);
142   oop* sp_top = (oop*)space_top;
143   CardValue* start_card = byte_for(sp-&gt;bottom());
144   CardValue* end_card   = byte_for(sp_top - 1) + 1;
145   oop* last_scanned = NULL; // Prevent scanning objects more than once
146   // The width of the stripe ssize*stripe_total must be
147   // consistent with the number of stripes so that the complete slice
148   // is covered.
149   size_t slice_width = ssize * stripe_total;
150   for (CardValue* slice = start_card; slice &lt; end_card; slice += slice_width) {
</pre>
<hr />
<pre>
153       return; // We&#39;re done.
154 
155     CardValue* worker_end_card = worker_start_card + ssize;
156     if (worker_end_card &gt; end_card)
157       worker_end_card = end_card;
158 
159     // We do not want to scan objects more than once. In order to accomplish
160     // this, we assert that any object with an object head inside our &#39;slice&#39;
161     // belongs to us. We may need to extend the range of scanned cards if the
162     // last object continues into the next &#39;slice&#39;.
163     //
164     // Note! ending cards are exclusive!
165     HeapWord* slice_start = addr_for(worker_start_card);
166     HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));
167 
168 #ifdef ASSERT
169     if (GCWorkerDelayMillis &gt; 0) {
170       // Delay 1 worker so that it proceeds after all the work
171       // has been completed.
172       if (stripe_number &lt; 2) {
<span class="line-modified">173         os::sleep(Thread::current(), GCWorkerDelayMillis, false);</span>
174       }
175     }
176 #endif
177 
178     // If there are not objects starting within the chunk, skip it.
179     if (!start_array-&gt;object_starts_in_range(slice_start, slice_end)) {
180       continue;
181     }
182     // Update our beginning addr
183     HeapWord* first_object = start_array-&gt;object_start(slice_start);
184     debug_only(oop* first_object_within_slice = (oop*) first_object;)
185     if (first_object &lt; slice_start) {
186       last_scanned = (oop*)(first_object + oop(first_object)-&gt;size());
187       debug_only(first_object_within_slice = last_scanned;)
188       worker_start_card = byte_for(last_scanned);
189     }
190 
191     // Update the ending addr
192     if (slice_end &lt; (HeapWord*)sp_top) {
193       // The subtraction is important! An object may start precisely at slice_end.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 28 #include &quot;gc/parallel/psCardTable.hpp&quot;
 29 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 30 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;

 31 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 // Checks an individual oop for missing precise marks. Mark
 39 // may be either dirty or newgen.
 40 class CheckForUnmarkedOops : public BasicOopIterateClosure {
 41  private:
 42   PSYoungGen*  _young_gen;
 43   PSCardTable* _card_table;
 44   HeapWord*    _unmarked_addr;
 45 
 46  protected:
 47   template &lt;class T&gt; void do_oop_work(T* p) {
 48     oop obj = RawAccess&lt;&gt;::oop_load(p);
 49     if (_young_gen-&gt;is_in_reserved(obj) &amp;&amp;
 50         !_card_table-&gt;addr_is_marked_imprecise(p)) {
</pre>
<hr />
<pre>
109     }
110   }
111 
112  public:
113   CheckForPreciseMarks(PSYoungGen* young_gen, PSCardTable* card_table) :
114     _young_gen(young_gen), _card_table(card_table) { }
115 
116   virtual void do_oop(oop* p)       { CheckForPreciseMarks::do_oop_work(p); }
117   virtual void do_oop(narrowOop* p) { CheckForPreciseMarks::do_oop_work(p); }
118 };
119 
120 // We get passed the space_top value to prevent us from traversing into
121 // the old_gen promotion labs, which cannot be safely parsed.
122 
123 // Do not call this method if the space is empty.
124 // It is a waste to start tasks and get here only to
125 // do no work.  If this method needs to be called
126 // when the space is empty, fix the calculation of
127 // end_card to allow sp_top == sp-&gt;bottom().
128 
<span class="line-added">129 // The generation (old gen) is divided into slices, which are further</span>
<span class="line-added">130 // subdivided into stripes, with one stripe per GC thread. The size of</span>
<span class="line-added">131 // a stripe is a constant, ssize.</span>
<span class="line-added">132 //</span>
<span class="line-added">133 //      +===============+        slice 0</span>
<span class="line-added">134 //      |  stripe 0     |</span>
<span class="line-added">135 //      +---------------+</span>
<span class="line-added">136 //      |  stripe 1     |</span>
<span class="line-added">137 //      +---------------+</span>
<span class="line-added">138 //      |  stripe 2     |</span>
<span class="line-added">139 //      +---------------+</span>
<span class="line-added">140 //      |  stripe 3     |</span>
<span class="line-added">141 //      +===============+        slice 1</span>
<span class="line-added">142 //      |  stripe 0     |</span>
<span class="line-added">143 //      +---------------+</span>
<span class="line-added">144 //      |  stripe 1     |</span>
<span class="line-added">145 //      +---------------+</span>
<span class="line-added">146 //      |  stripe 2     |</span>
<span class="line-added">147 //      +---------------+</span>
<span class="line-added">148 //      |  stripe 3     |</span>
<span class="line-added">149 //      +===============+        slice 2</span>
<span class="line-added">150 //      ...</span>
<span class="line-added">151 //</span>
<span class="line-added">152 // In this case there are 4 threads, so 4 stripes.  A GC thread first works on</span>
<span class="line-added">153 // its stripe within slice 0 and then moves to its stripe in the next slice</span>
<span class="line-added">154 // until it has exceeded the top of the generation.  The distance to stripe in</span>
<span class="line-added">155 // the next slice is calculated based on the number of stripes.  The next</span>
<span class="line-added">156 // stripe is at ssize * number_of_stripes (= slice_stride)..  So after</span>
<span class="line-added">157 // finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1 by</span>
<span class="line-added">158 // adding slice_stride to the start of stripe 0 in slice 0 to get to the start</span>
<span class="line-added">159 // of stride 0 in slice 1.</span>
<span class="line-added">160 </span>
161 void PSCardTable::scavenge_contents_parallel(ObjectStartArray* start_array,
162                                              MutableSpace* sp,
163                                              HeapWord* space_top,
164                                              PSPromotionManager* pm,
165                                              uint stripe_number,
166                                              uint stripe_total) {
167   int ssize = 128; // Naked constant!  Work unit = 64k.
168   int dirty_card_count = 0;
169 
170   // It is a waste to get here if empty.
171   assert(sp-&gt;bottom() &lt; sp-&gt;top(), &quot;Should not be called if empty&quot;);
172   oop* sp_top = (oop*)space_top;
173   CardValue* start_card = byte_for(sp-&gt;bottom());
174   CardValue* end_card   = byte_for(sp_top - 1) + 1;
175   oop* last_scanned = NULL; // Prevent scanning objects more than once
176   // The width of the stripe ssize*stripe_total must be
177   // consistent with the number of stripes so that the complete slice
178   // is covered.
179   size_t slice_width = ssize * stripe_total;
180   for (CardValue* slice = start_card; slice &lt; end_card; slice += slice_width) {
</pre>
<hr />
<pre>
183       return; // We&#39;re done.
184 
185     CardValue* worker_end_card = worker_start_card + ssize;
186     if (worker_end_card &gt; end_card)
187       worker_end_card = end_card;
188 
189     // We do not want to scan objects more than once. In order to accomplish
190     // this, we assert that any object with an object head inside our &#39;slice&#39;
191     // belongs to us. We may need to extend the range of scanned cards if the
192     // last object continues into the next &#39;slice&#39;.
193     //
194     // Note! ending cards are exclusive!
195     HeapWord* slice_start = addr_for(worker_start_card);
196     HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));
197 
198 #ifdef ASSERT
199     if (GCWorkerDelayMillis &gt; 0) {
200       // Delay 1 worker so that it proceeds after all the work
201       // has been completed.
202       if (stripe_number &lt; 2) {
<span class="line-modified">203         os::naked_sleep(GCWorkerDelayMillis);</span>
204       }
205     }
206 #endif
207 
208     // If there are not objects starting within the chunk, skip it.
209     if (!start_array-&gt;object_starts_in_range(slice_start, slice_end)) {
210       continue;
211     }
212     // Update our beginning addr
213     HeapWord* first_object = start_array-&gt;object_start(slice_start);
214     debug_only(oop* first_object_within_slice = (oop*) first_object;)
215     if (first_object &lt; slice_start) {
216       last_scanned = (oop*)(first_object + oop(first_object)-&gt;size());
217       debug_only(first_object_within_slice = last_scanned;)
218       worker_start_card = byte_for(last_scanned);
219     }
220 
221     // Update the ending addr
222     if (slice_end &lt; (HeapWord*)sp_top) {
223       // The subtraction is important! An object may start precisely at slice_end.
</pre>
</td>
</tr>
</table>
<center><a href="psAdaptiveSizePolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCardTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
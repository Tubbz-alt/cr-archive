<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/pcTasks.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;aot/aotLoader.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 31 #include &quot;gc/parallel/pcTasks.hpp&quot;
 32 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
 33 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
 35 #include &quot;gc/shared/gcTimer.hpp&quot;
 36 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;memory/iterator.inline.hpp&quot;
 39 #include &quot;memory/resourceArea.hpp&quot;
 40 #include &quot;memory/universe.hpp&quot;
 41 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;prims/jvmtiExport.hpp&quot;
 44 #include &quot;runtime/jniHandles.hpp&quot;
 45 #include &quot;runtime/thread.hpp&quot;
 46 #include &quot;runtime/vmThread.hpp&quot;
 47 #include &quot;services/management.hpp&quot;
 48 #include &quot;utilities/stack.inline.hpp&quot;
 49 
 50 //
 51 // ThreadRootsMarkingTask
 52 //
 53 
 54 void ThreadRootsMarkingTask::do_it(GCTaskManager* manager, uint which) {
 55   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
 56 
 57   ResourceMark rm;
 58 
 59   ParCompactionManager* cm =
 60     ParCompactionManager::gc_thread_compaction_manager(which);
 61 
 62   PCMarkAndPushClosure mark_and_push_closure(cm);
 63   MarkingCodeBlobClosure mark_and_push_in_blobs(&amp;mark_and_push_closure, !CodeBlobToOopClosure::FixRelocations);
 64 
 65   _thread-&gt;oops_do(&amp;mark_and_push_closure, &amp;mark_and_push_in_blobs);
 66 
 67   // Do the real work
 68   cm-&gt;follow_marking_stacks();
 69 }
 70 
 71 
 72 void MarkFromRootsTask::do_it(GCTaskManager* manager, uint which) {
 73   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
 74 
 75   ParCompactionManager* cm =
 76     ParCompactionManager::gc_thread_compaction_manager(which);
 77   PCMarkAndPushClosure mark_and_push_closure(cm);
 78 
 79   switch (_root_type) {
 80     case universe:
 81       Universe::oops_do(&amp;mark_and_push_closure);
 82       break;
 83 
 84     case jni_handles:
 85       JNIHandles::oops_do(&amp;mark_and_push_closure);
 86       break;
 87 
 88     case threads:
 89     {
 90       ResourceMark rm;
 91       MarkingCodeBlobClosure each_active_code_blob(&amp;mark_and_push_closure, !CodeBlobToOopClosure::FixRelocations);
 92       Threads::oops_do(&amp;mark_and_push_closure, &amp;each_active_code_blob);
 93     }
 94     break;
 95 
 96     case object_synchronizer:
 97       ObjectSynchronizer::oops_do(&amp;mark_and_push_closure);
 98       break;
 99 
100     case management:
101       Management::oops_do(&amp;mark_and_push_closure);
102       break;
103 
104     case jvmti:
105       JvmtiExport::oops_do(&amp;mark_and_push_closure);
106       break;
107 
108     case system_dictionary:
109       SystemDictionary::oops_do(&amp;mark_and_push_closure);
110       break;
111 
112     case class_loader_data: {
113         CLDToOopClosure cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
114         ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
115       }
116       break;
117 
118     case code_cache:
119       // Do not treat nmethods as strong roots for mark/sweep, since we can unload them.
120       //ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure(&amp;mark_and_push_closure));
121       AOTLoader::oops_do(&amp;mark_and_push_closure);
122       break;
123 
124     default:
125       fatal(&quot;Unknown root type&quot;);
126   }
127 
128   // Do the real work
129   cm-&gt;follow_marking_stacks();
130 }
131 
132 
133 //
134 // RefProcTaskProxy
135 //
136 
137 void RefProcTaskProxy::do_it(GCTaskManager* manager, uint which)
138 {
139   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
140 
141   ParCompactionManager* cm =
142     ParCompactionManager::gc_thread_compaction_manager(which);
143   PCMarkAndPushClosure mark_and_push_closure(cm);
144   ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
145   _rp_task.work(_work_id, *PSParallelCompact::is_alive_closure(),
146                 mark_and_push_closure, follow_stack_closure);
147 }
148 
149 //
150 // RefProcTaskExecutor
151 //
152 
153 void RefProcTaskExecutor::execute(ProcessTask&amp; task, uint ergo_workers)
154 {
155   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
156   uint active_gc_threads = heap-&gt;gc_task_manager()-&gt;active_workers();
157   assert(active_gc_threads == ergo_workers,
158          &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,
159          ergo_workers, active_gc_threads);
160   OopTaskQueueSet* qset = ParCompactionManager::stack_array();
161   TaskTerminator terminator(active_gc_threads, qset);
162 
163   GCTaskQueue* q = GCTaskQueue::create();
164   for(uint i=0; i&lt;active_gc_threads; i++) {
165     q-&gt;enqueue(new RefProcTaskProxy(task, i));
166   }
167   if (task.marks_oops_alive() &amp;&amp; (active_gc_threads&gt;1)) {
168     for (uint j=0; j&lt;active_gc_threads; j++) {
169       q-&gt;enqueue(new StealMarkingTask(terminator.terminator()));
170     }
171   }
172   PSParallelCompact::gc_task_manager()-&gt;execute_and_wait(q);
173 }
174 
175 //
176 // StealMarkingTask
177 //
178 
179 StealMarkingTask::StealMarkingTask(ParallelTaskTerminator* t) :
180   _terminator(t) {}
181 
182 void StealMarkingTask::do_it(GCTaskManager* manager, uint which) {
183   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
184 
185   ParCompactionManager* cm =
186     ParCompactionManager::gc_thread_compaction_manager(which);
187 
188   oop obj = NULL;
189   ObjArrayTask task;
190   do {
191     while (ParCompactionManager::steal_objarray(which,  task)) {
192       cm-&gt;follow_array((objArrayOop)task.obj(), task.index());
193       cm-&gt;follow_marking_stacks();
194     }
195     while (ParCompactionManager::steal(which, obj)) {
196       cm-&gt;follow_contents(obj);
197       cm-&gt;follow_marking_stacks();
198     }
199   } while (!terminator()-&gt;offer_termination());
200 }
201 
202 //
203 // CompactionWithStealingTask
204 //
205 
206 CompactionWithStealingTask::CompactionWithStealingTask(ParallelTaskTerminator* t):
207   _terminator(t) {}
208 
209 void CompactionWithStealingTask::do_it(GCTaskManager* manager, uint which) {
210   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
211 
212   ParCompactionManager* cm =
213     ParCompactionManager::gc_thread_compaction_manager(which);
214 
215   // Drain the stacks that have been preloaded with regions
216   // that are ready to fill.
217 
218   cm-&gt;drain_region_stacks();
219 
220   guarantee(cm-&gt;region_stack()-&gt;is_empty(), &quot;Not empty&quot;);
221 
222   size_t region_index = 0;
223 
224   while(true) {
225     if (ParCompactionManager::steal(which, region_index)) {
226       PSParallelCompact::fill_and_update_region(cm, region_index);
227       cm-&gt;drain_region_stacks();
228     } else {
229       if (terminator()-&gt;offer_termination()) {
230         break;
231       }
232       // Go around again.
233     }
234   }
235   return;
236 }
237 
238 UpdateDensePrefixTask::UpdateDensePrefixTask(
239                                    PSParallelCompact::SpaceId space_id,
240                                    size_t region_index_start,
241                                    size_t region_index_end) :
242   _space_id(space_id), _region_index_start(region_index_start),
243   _region_index_end(region_index_end) {}
244 
245 void UpdateDensePrefixTask::do_it(GCTaskManager* manager, uint which) {
246 
247   ParCompactionManager* cm =
248     ParCompactionManager::gc_thread_compaction_manager(which);
249 
250   PSParallelCompact::update_and_deadwood_in_dense_prefix(cm,
251                                                          _space_id,
252                                                          _region_index_start,
253                                                          _region_index_end);
254 }
    </pre>
  </body>
</html>
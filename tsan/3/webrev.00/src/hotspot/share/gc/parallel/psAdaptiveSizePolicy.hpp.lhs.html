<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psAdaptiveSizePolicy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
 26 #define SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
 27 
 28 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcStats.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
 32 #include &quot;utilities/align.hpp&quot;
 33 
 34 // This class keeps statistical information and computes the
 35 // optimal free space for both the young and old generation
 36 // based on current application characteristics (based on gc cost
 37 // and application footprint).
 38 //
 39 // It also computes an optimal tenuring threshold between the young
 40 // and old generations, so as to equalize the cost of collections
 41 // of those generations, as well as optimal survivor space sizes
 42 // for the young generation.
 43 //
 44 // While this class is specifically intended for a generational system
 45 // consisting of a young gen (containing an Eden and two semi-spaces)
 46 // and a tenured gen, as well as a perm gen for reflective data, it
 47 // makes NO references to specific generations.
 48 //
 49 // 05/02/2003 Update
 50 // The 1.5 policy makes use of data gathered for the costs of GC on
 51 // specific generations.  That data does reference specific
 52 // generation.  Also diagnostics specific to generations have
 53 // been added.
 54 
 55 // Forward decls
 56 class elapsedTimer;
 57 
 58 class PSAdaptiveSizePolicy : public AdaptiveSizePolicy {
 59  friend class PSGCAdaptivePolicyCounters;
 60  private:
 61   // These values are used to record decisions made during the
 62   // policy.  For example, if the young generation was decreased
 63   // to decrease the GC cost of minor collections the value
 64   // decrease_young_gen_for_throughput_true is used.
 65 
 66   // Last calculated sizes, in bytes, and aligned
 67   // NEEDS_CLEANUP should use sizes.hpp,  but it works in ints, not size_t&#39;s
 68 
 69   // Time statistics
 70   AdaptivePaddedAverage* _avg_major_pause;
 71 
 72   // Footprint statistics
 73   AdaptiveWeightedAverage* _avg_base_footprint;
 74 
 75   // Statistical data gathered for GC
 76   GCStats _gc_stats;
 77 
<a name="1" id="anc1"></a><span class="line-removed"> 78   size_t _survivor_size_limit;   // Limit in bytes of survivor size</span>
 79   const double _collection_cost_margin_fraction;
 80 
 81   // Variable for estimating the major and minor pause times.
 82   // These variables represent linear least-squares fits of
 83   // the data.
 84   //   major pause time vs. old gen size
 85   LinearLeastSquareFit* _major_pause_old_estimator;
 86   //   major pause time vs. young gen size
 87   LinearLeastSquareFit* _major_pause_young_estimator;
 88 
 89 
 90   // These record the most recent collection times.  They
 91   // are available as an alternative to using the averages
 92   // for making ergonomic decisions.
 93   double _latest_major_mutator_interval_seconds;
 94 
 95   const size_t _space_alignment; // alignment for eden, survivors
 96 
 97   const double _gc_minor_pause_goal_sec;    // goal for maximum minor gc pause
 98 
 99   // The amount of live data in the heap at the last full GC, used
100   // as a baseline to help us determine when we need to perform the
101   // next full GC.
102   size_t _live_at_last_full_gc;
103 
104   // decrease/increase the old generation for minor pause time
105   int _change_old_gen_for_min_pauses;
106 
107   // increase/decrease the young generation for major pause time
108   int _change_young_gen_for_maj_pauses;
109 
110 
111   // Flag indicating that the adaptive policy is ready to use
112   bool _old_gen_policy_is_ready;
113 
<a name="2" id="anc2"></a><span class="line-removed">114   // Changing the generation sizing depends on the data that is</span>
<span class="line-removed">115   // gathered about the effects of changes on the pause times and</span>
<span class="line-removed">116   // throughput.  These variable count the number of data points</span>
<span class="line-removed">117   // gathered.  The policy may use these counters as a threshold</span>
<span class="line-removed">118   // for reliable data.</span>
<span class="line-removed">119   julong _young_gen_change_for_major_pause_count;</span>
<span class="line-removed">120 </span>
121   // To facilitate faster growth at start up, supplement the normal
122   // growth percentage for the young gen eden and the
123   // old gen space for promotion with these value which decay
124   // with increasing collections.
125   uint _young_gen_size_increment_supplement;
126   uint _old_gen_size_increment_supplement;
127 
128   // The number of bytes absorbed from eden into the old gen by moving the
129   // boundary over live data.
130   size_t _bytes_absorbed_from_eden;
131 
132  private:
133 
134   // Accessors
135   AdaptivePaddedAverage* avg_major_pause() const { return _avg_major_pause; }
136   double gc_minor_pause_goal_sec() const { return _gc_minor_pause_goal_sec; }
137 
138   void adjust_eden_for_minor_pause_time(bool is_full_gc,
139                                    size_t* desired_eden_size_ptr);
140   // Change the generation sizes to achieve a GC pause time goal
141   // Returned sizes are not necessarily aligned.
142   void adjust_promo_for_pause_time(bool is_full_gc,
143                          size_t* desired_promo_size_ptr,
144                          size_t* desired_eden_size_ptr);
145   void adjust_eden_for_pause_time(bool is_full_gc,
146                          size_t* desired_promo_size_ptr,
147                          size_t* desired_eden_size_ptr);
148   // Change the generation sizes to achieve an application throughput goal
149   // Returned sizes are not necessarily aligned.
150   void adjust_promo_for_throughput(bool is_full_gc,
151                              size_t* desired_promo_size_ptr);
152   void adjust_eden_for_throughput(bool is_full_gc,
153                              size_t* desired_eden_size_ptr);
154   // Change the generation sizes to achieve minimum footprint
155   // Returned sizes are not aligned.
156   size_t adjust_promo_for_footprint(size_t desired_promo_size,
157                                     size_t desired_total);
158   size_t adjust_eden_for_footprint(size_t desired_promo_size,
159                                    size_t desired_total);
160 
161   // Size in bytes for an increment or decrement of eden.
162   virtual size_t eden_increment(size_t cur_eden, uint percent_change);
163   virtual size_t eden_decrement(size_t cur_eden);
164   size_t eden_decrement_aligned_down(size_t cur_eden);
165   size_t eden_increment_with_supplement_aligned_up(size_t cur_eden);
166 
167   // Size in bytes for an increment or decrement of the promotion area
168   virtual size_t promo_increment(size_t cur_promo, uint percent_change);
169   virtual size_t promo_decrement(size_t cur_promo);
170   size_t promo_decrement_aligned_down(size_t cur_promo);
171   size_t promo_increment_with_supplement_aligned_up(size_t cur_promo);
172 
173   // Returns a change that has been scaled down.  Result
174   // is not aligned.  (If useful, move to some shared
175   // location.)
176   size_t scale_down(size_t change, double part, double total);
177 
178  protected:
179   // Time accessors
180 
181   // Footprint accessors
182   size_t live_space() const {
183     return (size_t)(avg_base_footprint()-&gt;average() +
184                     avg_young_live()-&gt;average() +
185                     avg_old_live()-&gt;average());
186   }
187   size_t free_space() const {
188     return _eden_size + _promo_size;
189   }
190 
191   void set_promo_size(size_t new_size) {
192     _promo_size = new_size;
193   }
194   void set_survivor_size(size_t new_size) {
195     _survivor_size = new_size;
196   }
197 
198   // Update estimators
199   void update_minor_pause_old_estimator(double minor_pause_in_ms);
200 
201   virtual GCPolicyKind kind() const { return _gc_ps_adaptive_size_policy; }
202 
203  public:
204   // Use by ASPSYoungGen and ASPSOldGen to limit boundary moving.
205   size_t eden_increment_aligned_up(size_t cur_eden);
206   size_t eden_increment_aligned_down(size_t cur_eden);
207   size_t promo_increment_aligned_up(size_t cur_promo);
208   size_t promo_increment_aligned_down(size_t cur_promo);
209 
210   virtual size_t eden_increment(size_t cur_eden);
211   virtual size_t promo_increment(size_t cur_promo);
212 
213   // Accessors for use by performance counters
214   AdaptivePaddedNoZeroDevAverage*  avg_promoted() const {
215     return _gc_stats.avg_promoted();
216   }
217   AdaptiveWeightedAverage* avg_base_footprint() const {
218     return _avg_base_footprint;
219   }
220 
221   // Input arguments are initial free space sizes for young and old
222   // generations, the initial survivor space size, the
223   // alignment values and the pause &amp; throughput goals.
224   //
225   // NEEDS_CLEANUP this is a singleton object
226   PSAdaptiveSizePolicy(size_t init_eden_size,
227                        size_t init_promo_size,
228                        size_t init_survivor_size,
229                        size_t space_alignment,
230                        double gc_pause_goal_sec,
231                        double gc_minor_pause_goal_sec,
232                        uint gc_time_ratio);
233 
234   // Methods indicating events of interest to the adaptive size policy,
235   // called by GC algorithms. It is the responsibility of users of this
236   // policy to call these methods at the correct times!
237   void major_collection_begin();
238   void major_collection_end(size_t amount_live, GCCause::Cause gc_cause);
239 
240   void tenured_allocation(size_t size) {
241     _avg_pretenured-&gt;sample(size);
242   }
243 
244   // Accessors
245   // NEEDS_CLEANUP   should use sizes.hpp
246 
247   static size_t calculate_free_based_on_live(size_t live, uintx ratio_as_percentage);
248 
249   size_t calculated_old_free_size_in_bytes() const;
250 
251   size_t average_old_live_in_bytes() const {
252     return (size_t) avg_old_live()-&gt;average();
253   }
254 
255   size_t average_promoted_in_bytes() const {
256     return (size_t)avg_promoted()-&gt;average();
257   }
258 
259   size_t padded_average_promoted_in_bytes() const {
260     return (size_t)avg_promoted()-&gt;padded_average();
261   }
262 
263   int change_young_gen_for_maj_pauses() {
264     return _change_young_gen_for_maj_pauses;
265   }
266   void set_change_young_gen_for_maj_pauses(int v) {
267     _change_young_gen_for_maj_pauses = v;
268   }
269 
270   int change_old_gen_for_min_pauses() {
271     return _change_old_gen_for_min_pauses;
272   }
273   void set_change_old_gen_for_min_pauses(int v) {
274     _change_old_gen_for_min_pauses = v;
275   }
276 
277   // Return true if the old generation size was changed
278   // to try to reach a pause time goal.
279   bool old_gen_changed_for_pauses() {
280     bool result = _change_old_gen_for_maj_pauses != 0 ||
281                   _change_old_gen_for_min_pauses != 0;
282     return result;
283   }
284 
285   // Return true if the young generation size was changed
286   // to try to reach a pause time goal.
287   bool young_gen_changed_for_pauses() {
288     bool result = _change_young_gen_for_min_pauses != 0 ||
289                   _change_young_gen_for_maj_pauses != 0;
290     return result;
291   }
292   // end flags for pause goal
293 
294   // Return true if the old generation size was changed
295   // to try to reach a throughput goal.
296   bool old_gen_changed_for_throughput() {
297     bool result = _change_old_gen_for_throughput != 0;
298     return result;
299   }
300 
301   // Return true if the young generation size was changed
302   // to try to reach a throughput goal.
303   bool young_gen_changed_for_throughput() {
304     bool result = _change_young_gen_for_throughput != 0;
305     return result;
306   }
307 
308   int decrease_for_footprint() { return _decrease_for_footprint; }
309 
310 
311   // Accessors for estimators.  The slope of the linear fit is
312   // currently all that is used for making decisions.
313 
314   LinearLeastSquareFit* major_pause_old_estimator() {
315     return _major_pause_old_estimator;
316   }
317 
318   LinearLeastSquareFit* major_pause_young_estimator() {
319     return _major_pause_young_estimator;
320   }
321 
322 
323   virtual void clear_generation_free_space_flags();
324 
325   float major_pause_old_slope() { return _major_pause_old_estimator-&gt;slope(); }
326   float major_pause_young_slope() {
327     return _major_pause_young_estimator-&gt;slope();
328   }
329   float major_collection_slope() { return _major_collection_estimator-&gt;slope();}
330 
331   bool old_gen_policy_is_ready() { return _old_gen_policy_is_ready; }
332 
333   // Given the amount of live data in the heap, should we
334   // perform a Full GC?
335   bool should_full_GC(size_t live_in_old_gen);
336 
337   // Calculates optimal (free) space sizes for both the young and old
338   // generations.  Stores results in _eden_size and _promo_size.
339   // Takes current used space in all generations as input, as well
340   // as an indication if a full gc has just been performed, for use
341   // in deciding if an OOM error should be thrown.
342   void compute_generations_free_space(size_t young_live,
343                                       size_t eden_live,
344                                       size_t old_live,
345                                       size_t cur_eden,  // current eden in bytes
346                                       size_t max_old_gen_size,
347                                       size_t max_eden_size,
348                                       bool   is_full_gc);
349 
350   void compute_eden_space_size(size_t young_live,
351                                size_t eden_live,
352                                size_t cur_eden,  // current eden in bytes
353                                size_t max_eden_size,
354                                bool   is_full_gc);
355 
356   void compute_old_gen_free_space(size_t old_live,
357                                              size_t cur_eden,  // current eden in bytes
358                                              size_t max_old_gen_size,
359                                              bool   is_full_gc);
360 
361   // Calculates new survivor space size;  returns a new tenuring threshold
362   // value. Stores new survivor size in _survivor_size.
363   uint compute_survivor_space_size_and_threshold(bool   is_survivor_overflow,
364                                                  uint    tenuring_threshold,
365                                                  size_t survivor_limit);
366 
367   // Return the maximum size of a survivor space if the young generation were of
368   // size gen_size.
369   size_t max_survivor_size(size_t gen_size) {
370     // Never allow the target survivor size to grow more than MinSurvivorRatio
371     // of the young generation size.  We cannot grow into a two semi-space
372     // system, with Eden zero sized.  Even if the survivor space grows, from()
373     // might grow by moving the bottom boundary &quot;down&quot; -- so from space will
374     // remain almost full anyway (top() will be near end(), but there will be a
375     // large filler object at the bottom).
376     const size_t sz = gen_size / MinSurvivorRatio;
377     const size_t alignment = _space_alignment;
378     return sz &gt; alignment ? align_down(sz, alignment) : alignment;
379   }
380 
381   size_t live_at_last_full_gc() {
382     return _live_at_last_full_gc;
383   }
384 
385   size_t bytes_absorbed_from_eden() const { return _bytes_absorbed_from_eden; }
386   void   reset_bytes_absorbed_from_eden() { _bytes_absorbed_from_eden = 0; }
387 
388   void set_bytes_absorbed_from_eden(size_t val) {
389     _bytes_absorbed_from_eden = val;
390   }
391 
392   // Update averages that are always used (even
393   // if adaptive sizing is turned off).
394   void update_averages(bool is_survivor_overflow,
395                        size_t survived,
396                        size_t promoted);
397 
398   // Printing support
399   virtual bool print() const;
400 
401   // Decay the supplemental growth additive.
402   void decay_supplemental_growth(bool is_full_gc);
403 };
404 
405 #endif // SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
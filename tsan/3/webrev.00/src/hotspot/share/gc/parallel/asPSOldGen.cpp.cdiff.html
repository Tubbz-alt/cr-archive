<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/asPSOldGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="adjoiningGenerationsForHeteroHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSYoungGen.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/asPSOldGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,12 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/asPSOldGen.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
<span class="line-removed">- #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  // Whereas PSOldGen takes the maximum size of the generation
<span class="line-new-header">--- 24,12 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/asPSOldGen.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  // Whereas PSOldGen takes the maximum size of the generation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,28 ***</span>
  
  size_t ASPSOldGen::available_for_expansion() {
    assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
    assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
  
<span class="line-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
    size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
<span class="line-modified">!   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
    return result_aligned;
  }
  
  size_t ASPSOldGen::available_for_contraction() {
    size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
    if (uncommitted_bytes != 0) {
      return uncommitted_bytes;
    }
  
    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-removed">-   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
    PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
    const size_t working_size =
      used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
<span class="line-modified">!   const size_t working_aligned = align_up(working_size, gen_alignment);</span>
    const size_t working_or_min = MAX2(working_aligned, min_gen_size());
    if (working_or_min &gt; reserved().byte_size()) {
      // If the used or minimum gen size (aligned up) is greater
      // than the total reserved size, then the space available
      // for contraction should (after proper alignment) be 0
<span class="line-new-header">--- 88,26 ---</span>
  
  size_t ASPSOldGen::available_for_expansion() {
    assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
    assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
  
    size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
<span class="line-modified">!   size_t result_aligned = align_down(result, GenAlignment);</span>
    return result_aligned;
  }
  
  size_t ASPSOldGen::available_for_contraction() {
    size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
    if (uncommitted_bytes != 0) {
      return uncommitted_bytes;
    }
  
    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
    PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
    const size_t working_size =
      used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
<span class="line-modified">!   const size_t working_aligned = align_up(working_size, GenAlignment);</span>
    const size_t working_or_min = MAX2(working_aligned, min_gen_size());
    if (working_or_min &gt; reserved().byte_size()) {
      // If the used or minimum gen size (aligned up) is greater
      // than the total reserved size, then the space available
      // for contraction should (after proper alignment) be 0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,11 ***</span>
    // &quot;decrement&quot; fraction is conservative because its intent is to
    // only reduce the footprint.
  
    size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
    // Also adjust for inter-generational alignment
<span class="line-modified">!   size_t result_aligned = align_down(result, gen_alignment);</span>
  
    Log(gc, ergo) log;
    if (log.is_trace()) {
      size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
      size_t promo_increment = policy-&gt;promo_increment(max_contraction);
<span class="line-new-header">--- 121,11 ---</span>
    // &quot;decrement&quot; fraction is conservative because its intent is to
    // only reduce the footprint.
  
    size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
    // Also adjust for inter-generational alignment
<span class="line-modified">!   size_t result_aligned = align_down(result, GenAlignment);</span>
  
    Log(gc, ergo) log;
    if (log.is_trace()) {
      size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
      size_t promo_increment = policy-&gt;promo_increment(max_contraction);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,11 ***</span>
      log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
      log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
      log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
      log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
      log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
<span class="line-modified">!     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, gen_alignment);</span>
    }
  
    assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
    return result_aligned;
  }
<span class="line-new-header">--- 134,11 ---</span>
      log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
      log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
      log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
      log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
      log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
<span class="line-modified">!     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, GenAlignment);</span>
    }
  
    assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
    return result_aligned;
  }
</pre>
<center><a href="adjoiningGenerationsForHeteroHeap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSYoungGen.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
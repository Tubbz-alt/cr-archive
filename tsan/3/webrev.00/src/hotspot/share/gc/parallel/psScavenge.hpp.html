<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/psScavenge.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 26 #define SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 27 
 28 #include &quot;gc/parallel/psCardTable.hpp&quot;
 29 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 30 #include &quot;gc/shared/collectorCounters.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;utilities/stack.hpp&quot;
 35 
 36 class OopStack;
 37 class ReferenceProcessor;
 38 class ParallelScavengeHeap;
 39 class ParallelScavengeTracer;
 40 class PSIsAliveClosure;
 41 class PSRefProcTaskExecutor;
 42 class STWGCTimer;
 43 
 44 class PSScavenge: AllStatic {
 45   friend class PSIsAliveClosure;
 46   friend class PSKeepAliveClosure;
 47   friend class PSPromotionManager;
 48 
 49  enum ScavengeSkippedCause {
 50    not_skipped = 0,
 51    to_space_not_empty,
 52    promoted_too_large,
 53    full_follows_scavenge
 54  };
 55 
 56   // Saved value of to_space-&gt;top(), used to prevent objects in to_space from
 57   // being rescanned.
 58   static HeapWord* _to_space_top_before_gc;
 59 
 60   // Number of consecutive attempts to scavenge that were skipped
 61   static int                _consecutive_skipped_scavenges;
 62 
 63 
 64  protected:
 65   // Flags/counters
 66   static SpanSubjectToDiscoveryClosure _span_based_discoverer;
 67   static ReferenceProcessor*           _ref_processor;        // Reference processor for scavenging.
 68   static PSIsAliveClosure              _is_alive_closure;     // Closure used for reference processing
 69   static PSCardTable*                  _card_table;           // We cache the card table for fast access.
 70   static bool                          _survivor_overflow;    // Overflow this collection
 71   static uint                          _tenuring_threshold;   // tenuring threshold for next scavenge
 72   static elapsedTimer                  _accumulated_time;     // total time spent on scavenge
 73   static STWGCTimer                    _gc_timer;             // GC time book keeper
 74   static ParallelScavengeTracer        _gc_tracer;          // GC tracing
 75   // The lowest address possible for the young_gen.
 76   // This is used to decide if an oop should be scavenged,
 77   // cards should be marked, etc.
 78   static HeapWord*            _young_generation_boundary;
 79   // Used to optimize compressed oops young gen boundary checking.
 80   static uintptr_t            _young_generation_boundary_compressed;
 81   static CollectorCounters*   _counters;             // collector performance counters
 82 
 83   static void clean_up_failed_promotion();
 84 
 85   static bool should_attempt_scavenge();
 86 
 87   static HeapWord* to_space_top_before_gc() { return _to_space_top_before_gc; }
 88   static inline void save_to_space_top_before_gc();
 89 
 90   // Private accessors
 91   static PSCardTable* const card_table()           { assert(_card_table != NULL, &quot;Sanity&quot;); return _card_table; }
 92   static const ParallelScavengeTracer* gc_tracer() { return &amp;_gc_tracer; }
 93 
 94  public:
 95   // Accessors
 96   static uint             tenuring_threshold()  { return _tenuring_threshold; }
 97   static elapsedTimer*    accumulated_time()    { return &amp;_accumulated_time; }
 98   static int              consecutive_skipped_scavenges()
 99     { return _consecutive_skipped_scavenges; }
100 
101   // Performance Counters
102   static CollectorCounters* counters()           { return _counters; }
103 
104   static void set_subject_to_discovery_span(MemRegion mr) {
105     _span_based_discoverer.set_span(mr);
106   }
107   // Used by scavenge_contents
108   static ReferenceProcessor* const reference_processor() {
109     assert(_ref_processor != NULL, &quot;Sanity&quot;);
110     return _ref_processor;
111   }
112   // The promotion managers tell us if they encountered overflow
113   static void set_survivor_overflow(bool state) {
114     _survivor_overflow = state;
115   }
116   // Adaptive size policy support.  When the young generation/old generation
117   // boundary moves, _young_generation_boundary must be reset
118   static void set_young_generation_boundary(HeapWord* v);
119 
120   // Called by parallelScavengeHeap to init the tenuring threshold
121   static void initialize();
122 
123   // Scavenge entry point.  This may invoke a full gc; return true if so.
124   static bool invoke();
125   // Return true if a collection was done; false otherwise.
126   static bool invoke_no_policy();
127 
128   template &lt;class T&gt; static inline bool should_scavenge(T* p);
129 
130   // These call should_scavenge() above and, if it returns true, also check that
131   // the object was not newly copied into to_space.  The version with the bool
132   // argument is a convenience wrapper that fetches the to_space pointer from
133   // the heap and calls the other version (if the arg is true).
134   template &lt;class T&gt; static inline bool should_scavenge(T* p, MutableSpace* to_space);
135   template &lt;class T&gt; static inline bool should_scavenge(T* p, bool check_to_space);
136 
137   static void copy_and_push_safe_barrier_from_klass(PSPromotionManager* pm, oop* p);
138 
139   // Is an object in the young generation
140   // This assumes that the &#39;o&#39; is in the heap,
141   // so it only checks one side of the complete predicate.
142 
143   inline static bool is_obj_in_young(oop o) {
144     return cast_from_oop&lt;HeapWord*&gt;(o) &gt;= _young_generation_boundary;
145   }
146 
147   inline static bool is_obj_in_young(narrowOop o) {
148     return (uintptr_t)o &gt;= _young_generation_boundary_compressed;
149   }
150 
151   inline static bool is_obj_in_young(HeapWord* o) {
152     return o &gt;= _young_generation_boundary;
153   }
154 };
155 
156 #endif // SHARE_GC_PARALLEL_PSSCAVENGE_HPP
    </pre>
  </body>
</html>
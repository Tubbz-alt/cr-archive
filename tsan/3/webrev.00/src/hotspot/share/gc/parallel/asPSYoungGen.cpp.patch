diff a/src/hotspot/share/gc/parallel/asPSYoungGen.cpp b/src/hotspot/share/gc/parallel/asPSYoungGen.cpp
--- a/src/hotspot/share/gc/parallel/asPSYoungGen.cpp
+++ b/src/hotspot/share/gc/parallel/asPSYoungGen.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,15 +23,15 @@
  */
 
 #include "precompiled.hpp"
 #include "gc/parallel/asPSYoungGen.hpp"
 #include "gc/parallel/parallelScavengeHeap.hpp"
-#include "gc/parallel/psMarkSweepDecorator.hpp"
 #include "gc/parallel/psScavenge.inline.hpp"
 #include "gc/parallel/psYoungGen.hpp"
 #include "gc/shared/gcUtil.hpp"
-#include "gc/shared/spaceDecorator.hpp"
+#include "gc/shared/genArguments.hpp"
+#include "gc/shared/spaceDecorator.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/java.hpp"
 #include "utilities/align.hpp"
 
 ASPSYoungGen::ASPSYoungGen(size_t init_byte_size,
@@ -58,12 +58,11 @@
 void ASPSYoungGen::initialize_virtual_space(ReservedSpace rs,
                                             size_t alignment) {
   assert(_init_gen_size != 0, "Should have a finite size");
   _virtual_space = new PSVirtualSpaceHighToLow(rs, alignment);
   if (!_virtual_space->expand_by(_init_gen_size)) {
-    vm_exit_during_initialization("Could not reserve enough space for "
-                                  "object heap");
+    vm_exit_during_initialization("Could not reserve enough space for object heap");
   }
 }
 
 void ASPSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
   initialize_virtual_space(rs, alignment);
@@ -72,13 +71,13 @@
 
 size_t ASPSYoungGen::available_for_expansion() {
   size_t current_committed_size = virtual_space()->committed_size();
   assert((gen_size_limit() >= current_committed_size),
     "generation size limit is wrong");
-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
+
   size_t result =  gen_size_limit() - current_committed_size;
-  size_t result_aligned = align_down(result, heap->generation_alignment());
+  size_t result_aligned = align_down(result, GenAlignment);
   return result_aligned;
 }
 
 // Return the number of bytes the young gen is willing give up.
 //
@@ -91,17 +90,16 @@
   }
 
   if (eden_space()->is_empty()) {
     // Respect the minimum size for eden and for the young gen as a whole.
     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
-    const size_t eden_alignment = heap->space_alignment();
-    const size_t gen_alignment = heap->generation_alignment();
+    const size_t eden_alignment = SpaceAlignment;
 
     assert(eden_space()->capacity_in_bytes() >= eden_alignment,
       "Alignment is wrong");
     size_t eden_avail = eden_space()->capacity_in_bytes() - eden_alignment;
-    eden_avail = align_down(eden_avail, gen_alignment);
+    eden_avail = align_down(eden_avail, GenAlignment);
 
     assert(virtual_space()->committed_size() >= min_gen_size(),
       "minimum gen size is wrong");
     size_t gen_avail = virtual_space()->committed_size() - min_gen_size();
     assert(virtual_space()->is_aligned(gen_avail), "not aligned");
@@ -109,11 +107,11 @@
     const size_t max_contraction = MIN2(eden_avail, gen_avail);
     // See comment for ASPSOldGen::available_for_contraction()
     // for reasons the "increment" fraction is used.
     PSAdaptiveSizePolicy* policy = heap->size_policy();
     size_t result = policy->eden_increment_aligned_down(max_contraction);
-    size_t result_aligned = align_down(result, gen_alignment);
+    size_t result_aligned = align_down(result, GenAlignment);
 
     log_trace(gc, ergo)("ASPSYoungGen::available_for_contraction: " SIZE_FORMAT " K", result_aligned/K);
     log_trace(gc, ergo)("  max_contraction " SIZE_FORMAT " K", max_contraction/K);
     log_trace(gc, ergo)("  eden_avail " SIZE_FORMAT " K", eden_avail/K);
     log_trace(gc, ergo)("  gen_avail " SIZE_FORMAT " K", gen_avail/K);
@@ -126,12 +124,11 @@
 
 // The current implementation only considers to the end of eden.
 // If to_space is below from_space, to_space is not considered.
 // to_space can be.
 size_t ASPSYoungGen::available_to_live() {
-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
-  const size_t alignment = heap->space_alignment();
+  const size_t alignment = SpaceAlignment;
 
   // Include any space that is committed but is not in eden.
   size_t available = pointer_delta(eden_space()->bottom(),
                                    virtual_space()->low(),
                                    sizeof(char));
@@ -166,12 +163,11 @@
          "just checking");
 
   // Adjust new generation size
   const size_t eden_plus_survivors =
     align_up(eden_size + 2 * survivor_size, alignment);
-  size_t desired_size = MAX2(MIN2(eden_plus_survivors, gen_size_limit()),
-                             min_gen_size());
+  size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), gen_size_limit());
   assert(desired_size <= gen_size_limit(), "just checking");
 
   if (desired_size > orig_size) {
     // Grow the generation
     size_t change = desired_size - orig_size;
@@ -273,11 +269,10 @@
   char* to_end     = (char*)to_space()->end();
 
   assert(eden_start < from_start, "Cannot push into from_space");
 
   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
-  const size_t alignment = heap->space_alignment();
   const bool maintain_minimum =
     (requested_eden_size + 2 * requested_survivor_size) <= min_gen_size();
 
   bool eden_from_to_order = from_start < to_start;
   // Check whether from space is below to space
@@ -329,13 +324,13 @@
       size_t from_size =
         pointer_delta(from_space()->top(), from_start, sizeof(char));
 
       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
       if (from_size == 0) {
-        from_size = alignment;
+        from_size = SpaceAlignment;
       } else {
-        from_size = align_up(from_size, alignment);
+        from_size = align_up(from_size, SpaceAlignment);
       }
 
       from_end = from_start + from_size;
       assert(from_end > from_start, "addition overflow or from_size problem");
 
@@ -378,11 +373,11 @@
     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
                                     sizeof(char));
     // if the space sizes are to be increased by several times then
     // 'to_start' will point beyond the young generation. In this case
     // 'to_start' should be adjusted.
-    to_start = MAX2(to_start, eden_start + alignment);
+    to_start = MAX2(to_start, eden_start + SpaceAlignment);
 
     // Compute how big eden can be, then adjust end.
     // See  comments above on calculating eden_end.
     size_t eden_size;
     if (maintain_minimum) {
@@ -393,11 +388,11 @@
     }
     eden_end = eden_start + eden_size;
     assert(eden_end >= eden_start, "addition overflowed");
 
     // Don't let eden shrink down to 0 or less.
-    eden_end = MAX2(eden_end, eden_start + alignment);
+    eden_end = MAX2(eden_end, eden_start + SpaceAlignment);
     to_start = MAX2(to_start, eden_end);
 
     log_trace(gc, ergo)("    [eden_start .. eden_end): "
                         "[" PTR_FORMAT " .. " PTR_FORMAT ") " SIZE_FORMAT,
                         p2i(eden_start),

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psScavenge.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psScavenge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psScavenge.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 26 #define SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 27 
 28 #include &quot;gc/parallel/psCardTable.hpp&quot;
 29 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 30 #include &quot;gc/shared/collectorCounters.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;utilities/stack.hpp&quot;
 35 
<span class="line-removed"> 36 class GCTaskManager;</span>
<span class="line-removed"> 37 class GCTaskQueue;</span>
 38 class OopStack;
 39 class ReferenceProcessor;
 40 class ParallelScavengeHeap;
 41 class ParallelScavengeTracer;
 42 class PSIsAliveClosure;
 43 class PSRefProcTaskExecutor;
 44 class STWGCTimer;
 45 
 46 class PSScavenge: AllStatic {
 47   friend class PSIsAliveClosure;
 48   friend class PSKeepAliveClosure;
 49   friend class PSPromotionManager;
 50 
 51  enum ScavengeSkippedCause {
 52    not_skipped = 0,
 53    to_space_not_empty,
 54    promoted_too_large,
 55    full_follows_scavenge
 56  };
 57 
</pre>
<hr />
<pre>
 89   static HeapWord* to_space_top_before_gc() { return _to_space_top_before_gc; }
 90   static inline void save_to_space_top_before_gc();
 91 
 92   // Private accessors
 93   static PSCardTable* const card_table()           { assert(_card_table != NULL, &quot;Sanity&quot;); return _card_table; }
 94   static const ParallelScavengeTracer* gc_tracer() { return &amp;_gc_tracer; }
 95 
 96  public:
 97   // Accessors
 98   static uint             tenuring_threshold()  { return _tenuring_threshold; }
 99   static elapsedTimer*    accumulated_time()    { return &amp;_accumulated_time; }
100   static int              consecutive_skipped_scavenges()
101     { return _consecutive_skipped_scavenges; }
102 
103   // Performance Counters
104   static CollectorCounters* counters()           { return _counters; }
105 
106   static void set_subject_to_discovery_span(MemRegion mr) {
107     _span_based_discoverer.set_span(mr);
108   }
<span class="line-modified">109   // Used by scavenge_contents &amp;&amp; psMarkSweep</span>
110   static ReferenceProcessor* const reference_processor() {
111     assert(_ref_processor != NULL, &quot;Sanity&quot;);
112     return _ref_processor;
113   }
<span class="line-removed">114   // Used to add tasks</span>
<span class="line-removed">115   static GCTaskManager* const gc_task_manager();</span>
116   // The promotion managers tell us if they encountered overflow
117   static void set_survivor_overflow(bool state) {
118     _survivor_overflow = state;
119   }
120   // Adaptive size policy support.  When the young generation/old generation
121   // boundary moves, _young_generation_boundary must be reset
122   static void set_young_generation_boundary(HeapWord* v);
123 
124   // Called by parallelScavengeHeap to init the tenuring threshold
125   static void initialize();
126 
127   // Scavenge entry point.  This may invoke a full gc; return true if so.
128   static bool invoke();
129   // Return true if a collection was done; false otherwise.
130   static bool invoke_no_policy();
131 
132   template &lt;class T&gt; static inline bool should_scavenge(T* p);
133 
134   // These call should_scavenge() above and, if it returns true, also check that
135   // the object was not newly copied into to_space.  The version with the bool
136   // argument is a convenience wrapper that fetches the to_space pointer from
137   // the heap and calls the other version (if the arg is true).
138   template &lt;class T&gt; static inline bool should_scavenge(T* p, MutableSpace* to_space);
139   template &lt;class T&gt; static inline bool should_scavenge(T* p, bool check_to_space);
140 
141   static void copy_and_push_safe_barrier_from_klass(PSPromotionManager* pm, oop* p);
142 
143   // Is an object in the young generation
144   // This assumes that the &#39;o&#39; is in the heap,
145   // so it only checks one side of the complete predicate.
146 
147   inline static bool is_obj_in_young(oop o) {
<span class="line-modified">148     return (HeapWord*)o &gt;= _young_generation_boundary;</span>
149   }
150 
151   inline static bool is_obj_in_young(narrowOop o) {
152     return (uintptr_t)o &gt;= _young_generation_boundary_compressed;
153   }
154 
155   inline static bool is_obj_in_young(HeapWord* o) {
156     return o &gt;= _young_generation_boundary;
157   }
158 };
159 
160 #endif // SHARE_GC_PARALLEL_PSSCAVENGE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 26 #define SHARE_GC_PARALLEL_PSSCAVENGE_HPP
 27 
 28 #include &quot;gc/parallel/psCardTable.hpp&quot;
 29 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 30 #include &quot;gc/shared/collectorCounters.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;oops/oop.hpp&quot;
 34 #include &quot;utilities/stack.hpp&quot;
 35 


 36 class OopStack;
 37 class ReferenceProcessor;
 38 class ParallelScavengeHeap;
 39 class ParallelScavengeTracer;
 40 class PSIsAliveClosure;
 41 class PSRefProcTaskExecutor;
 42 class STWGCTimer;
 43 
 44 class PSScavenge: AllStatic {
 45   friend class PSIsAliveClosure;
 46   friend class PSKeepAliveClosure;
 47   friend class PSPromotionManager;
 48 
 49  enum ScavengeSkippedCause {
 50    not_skipped = 0,
 51    to_space_not_empty,
 52    promoted_too_large,
 53    full_follows_scavenge
 54  };
 55 
</pre>
<hr />
<pre>
 87   static HeapWord* to_space_top_before_gc() { return _to_space_top_before_gc; }
 88   static inline void save_to_space_top_before_gc();
 89 
 90   // Private accessors
 91   static PSCardTable* const card_table()           { assert(_card_table != NULL, &quot;Sanity&quot;); return _card_table; }
 92   static const ParallelScavengeTracer* gc_tracer() { return &amp;_gc_tracer; }
 93 
 94  public:
 95   // Accessors
 96   static uint             tenuring_threshold()  { return _tenuring_threshold; }
 97   static elapsedTimer*    accumulated_time()    { return &amp;_accumulated_time; }
 98   static int              consecutive_skipped_scavenges()
 99     { return _consecutive_skipped_scavenges; }
100 
101   // Performance Counters
102   static CollectorCounters* counters()           { return _counters; }
103 
104   static void set_subject_to_discovery_span(MemRegion mr) {
105     _span_based_discoverer.set_span(mr);
106   }
<span class="line-modified">107   // Used by scavenge_contents</span>
108   static ReferenceProcessor* const reference_processor() {
109     assert(_ref_processor != NULL, &quot;Sanity&quot;);
110     return _ref_processor;
111   }


112   // The promotion managers tell us if they encountered overflow
113   static void set_survivor_overflow(bool state) {
114     _survivor_overflow = state;
115   }
116   // Adaptive size policy support.  When the young generation/old generation
117   // boundary moves, _young_generation_boundary must be reset
118   static void set_young_generation_boundary(HeapWord* v);
119 
120   // Called by parallelScavengeHeap to init the tenuring threshold
121   static void initialize();
122 
123   // Scavenge entry point.  This may invoke a full gc; return true if so.
124   static bool invoke();
125   // Return true if a collection was done; false otherwise.
126   static bool invoke_no_policy();
127 
128   template &lt;class T&gt; static inline bool should_scavenge(T* p);
129 
130   // These call should_scavenge() above and, if it returns true, also check that
131   // the object was not newly copied into to_space.  The version with the bool
132   // argument is a convenience wrapper that fetches the to_space pointer from
133   // the heap and calls the other version (if the arg is true).
134   template &lt;class T&gt; static inline bool should_scavenge(T* p, MutableSpace* to_space);
135   template &lt;class T&gt; static inline bool should_scavenge(T* p, bool check_to_space);
136 
137   static void copy_and_push_safe_barrier_from_klass(PSPromotionManager* pm, oop* p);
138 
139   // Is an object in the young generation
140   // This assumes that the &#39;o&#39; is in the heap,
141   // so it only checks one side of the complete predicate.
142 
143   inline static bool is_obj_in_young(oop o) {
<span class="line-modified">144     return cast_from_oop&lt;HeapWord*&gt;(o) &gt;= _young_generation_boundary;</span>
145   }
146 
147   inline static bool is_obj_in_young(narrowOop o) {
148     return (uintptr_t)o &gt;= _young_generation_boundary_compressed;
149   }
150 
151   inline static bool is_obj_in_young(HeapWord* o) {
152     return o &gt;= _young_generation_boundary;
153   }
154 };
155 
156 #endif // SHARE_GC_PARALLEL_PSSCAVENGE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="psScavenge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
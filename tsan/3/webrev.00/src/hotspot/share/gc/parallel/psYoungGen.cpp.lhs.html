<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 28 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 29 #include &quot;gc/parallel/psScavenge.hpp&quot;
 30 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
<a name="4" id="anc4"></a><span class="line-modified"> 38 PSYoungGen::PSYoungGen(size_t        initial_size,</span>
<span class="line-modified"> 39                        size_t        min_size,</span>
<span class="line-modified"> 40                        size_t        max_size) :</span>



 41   _init_gen_size(initial_size),
 42   _min_gen_size(min_size),
<a name="5" id="anc5"></a><span class="line-modified"> 43   _max_gen_size(max_size)</span>




 44 {}
 45 
 46 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 47   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 48   _virtual_space = new PSVirtualSpace(rs, alignment);
 49   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {
 50     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 51                                   &quot;object heap&quot;);
 52   }
 53 }
 54 
 55 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 56   initialize_virtual_space(rs, alignment);
 57   initialize_work();
 58 }
 59 
 60 void PSYoungGen::initialize_work() {
 61 
 62   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 63                         (HeapWord*)virtual_space()-&gt;high_boundary());
 64 
 65   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 66                 (HeapWord*)virtual_space()-&gt;high());
 67   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 68 
 69   if (ZapUnusedHeapArea) {
 70     // Mangle newly committed space immediately because it
 71     // can be done here more simply that after the new
 72     // spaces have been computed.
 73     SpaceMangler::mangle_region(cmr);
 74   }
 75 
 76   if (UseNUMA) {
 77     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 78   } else {
 79     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 80   }
 81   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 82   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 83 
<a name="6" id="anc6"></a><span class="line-removed"> 84   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {</span>
<span class="line-removed"> 85     vm_exit_during_initialization(&quot;Could not allocate a young gen space&quot;);</span>
<span class="line-removed"> 86   }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88   // Allocate the mark sweep views of spaces</span>
<span class="line-removed"> 89   _eden_mark_sweep =</span>
<span class="line-removed"> 90       new PSMarkSweepDecorator(_eden_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 91   _from_mark_sweep =</span>
<span class="line-removed"> 92       new PSMarkSweepDecorator(_from_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 93   _to_mark_sweep =</span>
<span class="line-removed"> 94       new PSMarkSweepDecorator(_to_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96   if (_eden_mark_sweep == NULL ||</span>
<span class="line-removed"> 97       _from_mark_sweep == NULL ||</span>
<span class="line-removed"> 98       _to_mark_sweep == NULL) {</span>
<span class="line-removed"> 99     vm_exit_during_initialization(&quot;Could not complete allocation&quot;</span>
<span class="line-removed">100                                   &quot; of the young generation&quot;);</span>
<span class="line-removed">101   }</span>
<span class="line-removed">102 </span>
103   // Generation Counters - generation 0, 3 subspaces
104   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
105                                            _max_gen_size, _virtual_space);
106 
107   // Compute maximum space sizes for performance counters
<a name="7" id="anc7"></a><span class="line-modified">108   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">109   size_t alignment = heap-&gt;space_alignment();</span>
110   size_t size = virtual_space()-&gt;reserved_size();
111 
112   size_t max_survivor_size;
113   size_t max_eden_size;
114 
115   if (UseAdaptiveSizePolicy) {
116     max_survivor_size = size / MinSurvivorRatio;
117 
118     // round the survivor space size down to the nearest alignment
119     // and make sure its size is greater than 0.
120     max_survivor_size = align_down(max_survivor_size, alignment);
121     max_survivor_size = MAX2(max_survivor_size, alignment);
122 
123     // set the maximum size of eden to be the size of the young gen
124     // less two times the minimum survivor size. The minimum survivor
125     // size for UseAdaptiveSizePolicy is one alignment.
126     max_eden_size = size - 2 * alignment;
127   } else {
128     max_survivor_size = size / InitialSurvivorRatio;
129 
130     // round the survivor space size down to the nearest alignment
131     // and make sure its size is greater than 0.
132     max_survivor_size = align_down(max_survivor_size, alignment);
133     max_survivor_size = MAX2(max_survivor_size, alignment);
134 
135     // set the maximum size of eden to be the size of the young gen
136     // less two times the survivor size when the generation is 100%
137     // committed. The minimum survivor size for -UseAdaptiveSizePolicy
138     // is dependent on the committed portion (current capacity) of the
139     // generation - the less space committed, the smaller the survivor
140     // space, possibly as small as an alignment. However, we are interested
141     // in the case where the young generation is 100% committed, as this
142     // is the point where eden reaches its maximum size. At this point,
143     // the size of a survivor space is max_survivor_size.
144     max_eden_size = size - 2 * max_survivor_size;
145   }
146 
147   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
148                                      _gen_counters);
149   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
150                                      _gen_counters);
151   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
152                                    _gen_counters);
153 
154   compute_initial_space_boundaries();
155 }
156 
157 void PSYoungGen::compute_initial_space_boundaries() {
<a name="8" id="anc8"></a><span class="line-removed">158   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">159 </span>
160   // Compute sizes
<a name="9" id="anc9"></a><span class="line-removed">161   size_t alignment = heap-&gt;space_alignment();</span>
162   size_t size = virtual_space()-&gt;committed_size();
<a name="10" id="anc10"></a><span class="line-modified">163   assert(size &gt;= 3 * alignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);</span>
164 
165   size_t survivor_size = size / InitialSurvivorRatio;
<a name="11" id="anc11"></a><span class="line-modified">166   survivor_size = align_down(survivor_size, alignment);</span>
167   // ... but never less than an alignment
<a name="12" id="anc12"></a><span class="line-modified">168   survivor_size = MAX2(survivor_size, alignment);</span>
169 
170   // Young generation is eden + 2 survivor spaces
171   size_t eden_size = size - (2 * survivor_size);
172 
173   // Now go ahead and set &#39;em.
174   set_space_boundaries(eden_size, survivor_size);
175   space_invariants();
176 
177   if (UsePerfData) {
178     _eden_counters-&gt;update_capacity();
179     _from_counters-&gt;update_capacity();
180     _to_counters-&gt;update_capacity();
181   }
182 }
183 
184 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
185   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
186   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
187 
188   // Initial layout is Eden, to, from. After swapping survivor spaces,
189   // that leaves us with Eden, from, to, which is step one in our two
190   // step resize-with-live-data procedure.
191   char *eden_start = virtual_space()-&gt;low();
192   char *to_start   = eden_start + eden_size;
193   char *from_start = to_start   + survivor_size;
194   char *from_end   = from_start + survivor_size;
195 
196   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
197   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
198   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
199   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
200 
201   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
202   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
203   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
204 
205   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
206     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
207   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
208 }
209 
210 #ifndef PRODUCT
211 void PSYoungGen::space_invariants() {
<a name="13" id="anc13"></a><span class="line-removed">212   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">213   const size_t alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">214 </span>
215   // Currently, our eden size cannot shrink to zero
<a name="14" id="anc14"></a><span class="line-modified">216   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;eden too small&quot;);</span>
<span class="line-modified">217   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;from too small&quot;);</span>
<span class="line-modified">218   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;to too small&quot;);</span>
219 
220   // Relationship of spaces to each other
221   char* eden_start = (char*)eden_space()-&gt;bottom();
222   char* eden_end   = (char*)eden_space()-&gt;end();
223   char* from_start = (char*)from_space()-&gt;bottom();
224   char* from_end   = (char*)from_space()-&gt;end();
225   char* to_start   = (char*)to_space()-&gt;bottom();
226   char* to_end     = (char*)to_space()-&gt;end();
227 
228   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
229   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
230   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
231   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
232 
233   // Check whether from space is below to space
234   if (from_start &lt; to_start) {
235     // Eden, from, to
236     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
237     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
238     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
239   } else {
240     // Eden, to, from
241     guarantee(eden_end &lt;= to_start, &quot;eden/to boundary&quot;);
242     guarantee(to_end &lt;= from_start, &quot;to/from boundary&quot;);
243     guarantee(from_end &lt;= virtual_space()-&gt;high(), &quot;from end&quot;);
244   }
245 
246   // More checks that the virtual space is consistent with the spaces
247   assert(virtual_space()-&gt;committed_size() &gt;=
248     (eden_space()-&gt;capacity_in_bytes() +
249      to_space()-&gt;capacity_in_bytes() +
250      from_space()-&gt;capacity_in_bytes()), &quot;Committed size is inconsistent&quot;);
251   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
252     &quot;Space invariant&quot;);
253   char* eden_top = (char*)eden_space()-&gt;top();
254   char* from_top = (char*)from_space()-&gt;top();
255   char* to_top = (char*)to_space()-&gt;top();
256   assert(eden_top &lt;= virtual_space()-&gt;high(), &quot;eden top&quot;);
257   assert(from_top &lt;= virtual_space()-&gt;high(), &quot;from top&quot;);
258   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
259 
260   virtual_space()-&gt;verify();
261 }
262 #endif
263 
264 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
265   // Resize the generation if needed. If the generation resize
266   // reports false, do not attempt to resize the spaces.
267   if (resize_generation(eden_size, survivor_size)) {
268     // Then we lay out the spaces inside the generation
269     resize_spaces(eden_size, survivor_size);
270 
271     space_invariants();
272 
273     log_trace(gc, ergo)(&quot;Young generation size: &quot;
274                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
275                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
276                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
277                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
278                         _max_gen_size, min_gen_size());
279   }
280 }
281 
282 
283 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
284   const size_t alignment = virtual_space()-&gt;alignment();
285   size_t orig_size = virtual_space()-&gt;committed_size();
286   bool size_changed = false;
287 
288   // There used to be this guarantee there.
289   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);
290   // Code below forces this requirement.  In addition the desired eden
291   // size and desired survivor sizes are desired goals and may
292   // exceed the total generation size.
293 
294   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
295 
296   // Adjust new generation size
297   const size_t eden_plus_survivors =
298           align_up(eden_size + 2 * survivor_size, alignment);
<a name="15" id="anc15"></a><span class="line-modified">299   size_t desired_size = MAX2(MIN2(eden_plus_survivors, max_size()),</span>
<span class="line-removed">300                              min_gen_size());</span>
301   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
302 
303   if (desired_size &gt; orig_size) {
304     // Grow the generation
305     size_t change = desired_size - orig_size;
306     assert(change % alignment == 0, &quot;just checking&quot;);
307     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
308     if (!virtual_space()-&gt;expand_by(change)) {
309       return false; // Error if we fail to resize!
310     }
311     if (ZapUnusedHeapArea) {
312       // Mangle newly committed space immediately because it
313       // can be done here more simply that after the new
314       // spaces have been computed.
315       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
316       MemRegion mangle_region(prev_high, new_high);
317       SpaceMangler::mangle_region(mangle_region);
318     }
319     size_changed = true;
320   } else if (desired_size &lt; orig_size) {
321     size_t desired_change = orig_size - desired_size;
322     assert(desired_change % alignment == 0, &quot;just checking&quot;);
323 
324     desired_change = limit_gen_shrink(desired_change);
325 
326     if (desired_change &gt; 0) {
327       virtual_space()-&gt;shrink_by(desired_change);
328       reset_survivors_after_shrink();
329 
330       size_changed = true;
331     }
332   } else {
333     if (orig_size == gen_size_limit()) {
334       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
335     } else if (orig_size == min_gen_size()) {
336       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
337     }
338   }
339 
340   if (size_changed) {
341     post_resize();
342     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
343                   orig_size/K, virtual_space()-&gt;committed_size()/K);
344   }
345 
346   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
347             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);
348 
349   return true;
350 }
351 
352 #ifndef PRODUCT
353 // In the numa case eden is not mangled so a survivor space
354 // moving into a region previously occupied by a survivor
355 // may find an unmangled region.  Also in the PS case eden
356 // to-space and from-space may not touch (i.e., there may be
357 // gaps between them due to movement while resizing the
358 // spaces).  Those gaps must be mangled.
359 void PSYoungGen::mangle_survivors(MutableSpace* s1,
360                                   MemRegion s1MR,
361                                   MutableSpace* s2,
362                                   MemRegion s2MR) {
363   // Check eden and gap between eden and from-space, in deciding
364   // what to mangle in from-space.  Check the gap between from-space
365   // and to-space when deciding what to mangle.
366   //
367   //      +--------+   +----+    +---+
368   //      | eden   |   |s1  |    |s2 |
369   //      +--------+   +----+    +---+
370   //                 +-------+ +-----+
371   //                 |s1MR   | |s2MR |
372   //                 +-------+ +-----+
373   // All of survivor-space is properly mangled so find the
374   // upper bound on the mangling for any portion above current s1.
375   HeapWord* delta_end = MIN2(s1-&gt;bottom(), s1MR.end());
376   MemRegion delta1_left;
377   if (s1MR.start() &lt; delta_end) {
378     delta1_left = MemRegion(s1MR.start(), delta_end);
379     s1-&gt;mangle_region(delta1_left);
380   }
381   // Find any portion to the right of the current s1.
382   HeapWord* delta_start = MAX2(s1-&gt;end(), s1MR.start());
383   MemRegion delta1_right;
384   if (delta_start &lt; s1MR.end()) {
385     delta1_right = MemRegion(delta_start, s1MR.end());
386     s1-&gt;mangle_region(delta1_right);
387   }
388 
389   // Similarly for the second survivor space except that
390   // any of the new region that overlaps with the current
391   // region of the first survivor space has already been
392   // mangled.
393   delta_end = MIN2(s2-&gt;bottom(), s2MR.end());
394   delta_start = MAX2(s2MR.start(), s1-&gt;end());
395   MemRegion delta2_left;
396   if (s2MR.start() &lt; delta_end) {
397     delta2_left = MemRegion(s2MR.start(), delta_end);
398     s2-&gt;mangle_region(delta2_left);
399   }
400   delta_start = MAX2(s2-&gt;end(), s2MR.start());
401   MemRegion delta2_right;
402   if (delta_start &lt; s2MR.end()) {
403     s2-&gt;mangle_region(delta2_right);
404   }
405 
406   // s1
407   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
408     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
409     p2i(s1-&gt;bottom()), p2i(s1-&gt;end()),
410     p2i(s1MR.start()), p2i(s1MR.end()));
411   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
412     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
413     p2i(delta1_left.start()), p2i(delta1_left.end()),
414     p2i(delta1_right.start()), p2i(delta1_right.end()));
415 
416   // s2
417   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
418     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
419     p2i(s2-&gt;bottom()), p2i(s2-&gt;end()),
420     p2i(s2MR.start()), p2i(s2MR.end()));
421   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
422     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
423     p2i(delta2_left.start()), p2i(delta2_left.end()),
424     p2i(delta2_right.start()), p2i(delta2_right.end()));
425 }
426 #endif // NOT PRODUCT
427 
428 void PSYoungGen::resize_spaces(size_t requested_eden_size,
429                                size_t requested_survivor_size) {
430   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
431   assert(requested_eden_size &gt; 0  &amp;&amp; requested_survivor_size &gt; 0,
432          &quot;just checking&quot;);
433 
434   // We require eden and to space to be empty
435   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
436     return;
437   }
438 
439   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot; SIZE_FORMAT &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
440                       requested_eden_size, requested_survivor_size);
441   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
442                       p2i(eden_space()-&gt;bottom()),
443                       p2i(eden_space()-&gt;end()),
444                       pointer_delta(eden_space()-&gt;end(),
445                                     eden_space()-&gt;bottom(),
446                                     sizeof(char)));
447   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
448                       p2i(from_space()-&gt;bottom()),
449                       p2i(from_space()-&gt;end()),
450                       pointer_delta(from_space()-&gt;end(),
451                                     from_space()-&gt;bottom(),
452                                     sizeof(char)));
453   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
454                       p2i(to_space()-&gt;bottom()),
455                       p2i(to_space()-&gt;end()),
456                       pointer_delta(  to_space()-&gt;end(),
457                                       to_space()-&gt;bottom(),
458                                       sizeof(char)));
459 
460   // There&#39;s nothing to do if the new sizes are the same as the current
461   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
462       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
463       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
464     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
465     return;
466   }
467 
468   char* eden_start = (char*)eden_space()-&gt;bottom();
469   char* eden_end   = (char*)eden_space()-&gt;end();
470   char* from_start = (char*)from_space()-&gt;bottom();
471   char* from_end   = (char*)from_space()-&gt;end();
472   char* to_start   = (char*)to_space()-&gt;bottom();
473   char* to_end     = (char*)to_space()-&gt;end();
474 
<a name="16" id="anc16"></a><span class="line-removed">475   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">476   const size_t alignment = heap-&gt;space_alignment();</span>
477   const bool maintain_minimum =
478     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
479 
480   bool eden_from_to_order = from_start &lt; to_start;
481   // Check whether from space is below to space
482   if (eden_from_to_order) {
483     // Eden, from, to
484     eden_from_to_order = true;
485     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
486 
487     // Set eden
488     // &quot;requested_eden_size&quot; is a goal for the size of eden
489     // and may not be attainable.  &quot;eden_size&quot; below is
490     // calculated based on the location of from-space and
491     // the goal for the size of eden.  from-space is
492     // fixed in place because it contains live data.
493     // The calculation is done this way to avoid 32bit
494     // overflow (i.e., eden_start + requested_eden_size
495     // may too large for representation in 32bits).
496     size_t eden_size;
497     if (maintain_minimum) {
498       // Only make eden larger than the requested size if
499       // the minimum size of the generation has to be maintained.
500       // This could be done in general but policy at a higher
501       // level is determining a requested size for eden and that
502       // should be honored unless there is a fundamental reason.
503       eden_size = pointer_delta(from_start,
504                                 eden_start,
505                                 sizeof(char));
506     } else {
507       eden_size = MIN2(requested_eden_size,
508                        pointer_delta(from_start, eden_start, sizeof(char)));
509     }
510 
511     eden_end = eden_start + eden_size;
512     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
513 
514     // To may resize into from space as long as it is clear of live data.
515     // From space must remain page aligned, though, so we need to do some
516     // extra calculations.
517 
518     // First calculate an optimal to-space
519     to_end   = (char*)virtual_space()-&gt;high();
520     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
521                                     sizeof(char));
522 
523     // Does the optimal to-space overlap from-space?
524     if (to_start &lt; (char*)from_space()-&gt;end()) {
525       // Calculate the minimum offset possible for from_end
526       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
527 
528       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
529       if (from_size == 0) {
<a name="17" id="anc17"></a><span class="line-modified">530         from_size = alignment;</span>
531       } else {
<a name="18" id="anc18"></a><span class="line-modified">532         from_size = align_up(from_size, alignment);</span>
533       }
534 
535       from_end = from_start + from_size;
536       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
537 
538       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
539 
540       // Now update to_start with the new from_end
541       to_start = MAX2(from_end, to_start);
542     }
543 
544     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
545 
546     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
547                         p2i(eden_start),
548                         p2i(eden_end),
549                         pointer_delta(eden_end, eden_start, sizeof(char)));
550     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
551                         p2i(from_start),
552                         p2i(from_end),
553                         pointer_delta(from_end, from_start, sizeof(char)));
554     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
555                         p2i(to_start),
556                         p2i(to_end),
557                         pointer_delta(  to_end,   to_start, sizeof(char)));
558   } else {
559     // Eden, to, from
560     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
561 
562     // To space gets priority over eden resizing. Note that we position
563     // to space as if we were able to resize from space, even though from
564     // space is not modified.
565     // Giving eden priority was tried and gave poorer performance.
566     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
567                                     (char*)requested_survivor_size,
568                                     sizeof(char));
569     to_end   = MIN2(to_end, from_start);
570     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
571                                     sizeof(char));
572     // if the space sizes are to be increased by several times then
573     // &#39;to_start&#39; will point beyond the young generation. In this case
574     // &#39;to_start&#39; should be adjusted.
<a name="19" id="anc19"></a><span class="line-modified">575     to_start = MAX2(to_start, eden_start + alignment);</span>
576 
577     // Compute how big eden can be, then adjust end.
578     // See  comments above on calculating eden_end.
579     size_t eden_size;
580     if (maintain_minimum) {
581       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
582     } else {
583       eden_size = MIN2(requested_eden_size,
584                        pointer_delta(to_start, eden_start, sizeof(char)));
585     }
586     eden_end = eden_start + eden_size;
587     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
588 
589     // Could choose to not let eden shrink
590     // to_start = MAX2(to_start, eden_end);
591 
592     // Don&#39;t let eden shrink down to 0 or less.
<a name="20" id="anc20"></a><span class="line-modified">593     eden_end = MAX2(eden_end, eden_start + alignment);</span>
594     to_start = MAX2(to_start, eden_end);
595 
596     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
597                         p2i(eden_start),
598                         p2i(eden_end),
599                         pointer_delta(eden_end, eden_start, sizeof(char)));
600     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
601                         p2i(to_start),
602                         p2i(to_end),
603                         pointer_delta(  to_end,   to_start, sizeof(char)));
604     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
605                         p2i(from_start),
606                         p2i(from_end),
607                         pointer_delta(from_end, from_start, sizeof(char)));
608   }
609 
610 
611   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
612             &quot;from start moved to the right&quot;);
613   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
614             &quot;from end moved into live data&quot;);
615   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
616   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
617   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
618 
619   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
620   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
621   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
622 
623   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
624   HeapWord* old_from_top = from_space()-&gt;top();
625 
626   // For logging block  below
627   size_t old_from = from_space()-&gt;capacity_in_bytes();
628   size_t old_to   = to_space()-&gt;capacity_in_bytes();
629 
630   if (ZapUnusedHeapArea) {
631     // NUMA is a special case because a numa space is not mangled
632     // in order to not prematurely bind its address to memory to
633     // the wrong memory (i.e., don&#39;t want the GC thread to first
634     // touch the memory).  The survivor spaces are not numa
635     // spaces and are mangled.
636     if (UseNUMA) {
637       if (eden_from_to_order) {
638         mangle_survivors(from_space(), fromMR, to_space(), toMR);
639       } else {
640         mangle_survivors(to_space(), toMR, from_space(), fromMR);
641       }
642     }
643 
644     // If not mangling the spaces, do some checking to verify that
645     // the spaces are already mangled.
646     // The spaces should be correctly mangled at this point so
647     // do some checking here. Note that they are not being mangled
648     // in the calls to initialize().
649     // Must check mangling before the spaces are reshaped.  Otherwise,
650     // the bottom or end of one space may have moved into an area
651     // covered by another space and a failure of the check may
652     // not correctly indicate which space is not properly mangled.
653     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
654     eden_space()-&gt;check_mangled_unused_area(limit);
655     from_space()-&gt;check_mangled_unused_area(limit);
656       to_space()-&gt;check_mangled_unused_area(limit);
657   }
658   // When an existing space is being initialized, it is not
659   // mangled because the space has been previously mangled.
660   eden_space()-&gt;initialize(edenMR,
661                            SpaceDecorator::Clear,
662                            SpaceDecorator::DontMangle);
663     to_space()-&gt;initialize(toMR,
664                            SpaceDecorator::Clear,
665                            SpaceDecorator::DontMangle);
666   from_space()-&gt;initialize(fromMR,
667                            SpaceDecorator::DontClear,
668                            SpaceDecorator::DontMangle);
669 
670   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
671 
672   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
673                       ParallelScavengeHeap::heap()-&gt;total_collections(),
674                       old_from, old_to,
675                       from_space()-&gt;capacity_in_bytes(),
676                       to_space()-&gt;capacity_in_bytes());
677 }
678 
679 void PSYoungGen::swap_spaces() {
680   MutableSpace* s    = from_space();
681   _from_space        = to_space();
682   _to_space          = s;
<a name="21" id="anc21"></a><span class="line-removed">683 </span>
<span class="line-removed">684   // Now update the decorators.</span>
<span class="line-removed">685   PSMarkSweepDecorator* md = from_mark_sweep();</span>
<span class="line-removed">686   _from_mark_sweep           = to_mark_sweep();</span>
<span class="line-removed">687   _to_mark_sweep             = md;</span>
<span class="line-removed">688 </span>
<span class="line-removed">689   assert(from_mark_sweep()-&gt;space() == from_space(), &quot;Sanity&quot;);</span>
<span class="line-removed">690   assert(to_mark_sweep()-&gt;space() == to_space(), &quot;Sanity&quot;);</span>
691 }
692 
693 size_t PSYoungGen::capacity_in_bytes() const {
694   return eden_space()-&gt;capacity_in_bytes()
695        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
696 }
697 
698 
699 size_t PSYoungGen::used_in_bytes() const {
700   return eden_space()-&gt;used_in_bytes()
701        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
702 }
703 
704 
705 size_t PSYoungGen::free_in_bytes() const {
706   return eden_space()-&gt;free_in_bytes()
707        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
708 }
709 
710 size_t PSYoungGen::capacity_in_words() const {
711   return eden_space()-&gt;capacity_in_words()
712        + from_space()-&gt;capacity_in_words();  // to_space() is only used during scavenge
713 }
714 
715 
716 size_t PSYoungGen::used_in_words() const {
717   return eden_space()-&gt;used_in_words()
718        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
719 }
720 
721 
722 size_t PSYoungGen::free_in_words() const {
723   return eden_space()-&gt;free_in_words()
724        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
725 }
726 
727 void PSYoungGen::object_iterate(ObjectClosure* blk) {
728   eden_space()-&gt;object_iterate(blk);
729   from_space()-&gt;object_iterate(blk);
730   to_space()-&gt;object_iterate(blk);
731 }
732 
<a name="22" id="anc22"></a><span class="line-removed">733 #if INCLUDE_SERIALGC</span>
<span class="line-removed">734 </span>
<span class="line-removed">735 void PSYoungGen::precompact() {</span>
<span class="line-removed">736   eden_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">737   from_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">738   to_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">739 }</span>
<span class="line-removed">740 </span>
<span class="line-removed">741 void PSYoungGen::adjust_pointers() {</span>
<span class="line-removed">742   eden_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">743   from_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">744   to_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">745 }</span>
<span class="line-removed">746 </span>
<span class="line-removed">747 void PSYoungGen::compact() {</span>
<span class="line-removed">748   eden_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">749   from_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">750   // Mark sweep stores preserved markOops in to space, don&#39;t disturb!</span>
<span class="line-removed">751   to_mark_sweep()-&gt;compact(false);</span>
<span class="line-removed">752 }</span>
<span class="line-removed">753 </span>
<span class="line-removed">754 #endif // INCLUDE_SERIALGC</span>
<span class="line-removed">755 </span>
756 void PSYoungGen::print() const { print_on(tty); }
757 void PSYoungGen::print_on(outputStream* st) const {
758   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
759   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
760              capacity_in_bytes()/K, used_in_bytes()/K);
761   virtual_space()-&gt;print_space_boundaries_on(st);
762   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
763   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
764   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
765 }
766 
<a name="23" id="anc23"></a><span class="line-removed">767 // Note that a space is not printed before the [NAME:</span>
<span class="line-removed">768 void PSYoungGen::print_used_change(size_t prev_used) const {</span>
<span class="line-removed">769   log_info(gc, heap)(&quot;%s: &quot;  SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-removed">770       name(), prev_used / K, used_in_bytes() / K, capacity_in_bytes() / K);</span>
<span class="line-removed">771 }</span>
<span class="line-removed">772 </span>
773 size_t PSYoungGen::available_for_expansion() {
774   ShouldNotReachHere();
775   return 0;
776 }
777 
778 size_t PSYoungGen::available_for_contraction() {
779   ShouldNotReachHere();
780   return 0;
781 }
782 
783 size_t PSYoungGen::available_to_min_gen() {
784   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
785   return virtual_space()-&gt;committed_size() - min_gen_size();
786 }
787 
788 // This method assumes that from-space has live data and that
789 // any shrinkage of the young gen is limited by location of
790 // from-space.
791 size_t PSYoungGen::available_to_live() {
792   size_t delta_in_survivor = 0;
<a name="24" id="anc24"></a><span class="line-removed">793   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">794   const size_t space_alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">795   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
<span class="line-removed">796 </span>
797   MutableSpace* space_shrinking = NULL;
798   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
799     space_shrinking = from_space();
800   } else {
801     space_shrinking = to_space();
802   }
803 
804   // Include any space that is committed but not included in
805   // the survivor spaces.
806   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
807     &quot;Survivor space beyond high end&quot;);
808   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
809     space_shrinking-&gt;end(), sizeof(char));
810 
811   if (space_shrinking-&gt;is_empty()) {
812     // Don&#39;t let the space shrink to 0
<a name="25" id="anc25"></a><span class="line-modified">813     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= space_alignment,</span>
814       &quot;Space is too small&quot;);
<a name="26" id="anc26"></a><span class="line-modified">815     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - space_alignment;</span>
816   } else {
817     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
818                                       space_shrinking-&gt;top(),
819                                       sizeof(char));
820   }
821 
822   size_t delta_in_bytes = unused_committed + delta_in_survivor;
<a name="27" id="anc27"></a><span class="line-modified">823   delta_in_bytes = align_down(delta_in_bytes, gen_alignment);</span>
824   return delta_in_bytes;
825 }
826 
827 // Return the number of bytes available for resizing down the young
828 // generation.  This is the minimum of
829 //      input &quot;bytes&quot;
830 //      bytes to the minimum young gen size
831 //      bytes to the size currently being used + some small extra
832 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
833   // Allow shrinkage into the current eden but keep eden large enough
834   // to maintain the minimum young gen size
835   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
836   return align_down(bytes, virtual_space()-&gt;alignment());
837 }
838 
839 void PSYoungGen::reset_after_change() {
840   ShouldNotReachHere();
841 }
842 
843 void PSYoungGen::reset_survivors_after_shrink() {
844   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
845                         (HeapWord*)virtual_space()-&gt;high_boundary());
846   PSScavenge::set_subject_to_discovery_span(_reserved);
847 
848   MutableSpace* space_shrinking = NULL;
849   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
850     space_shrinking = from_space();
851   } else {
852     space_shrinking = to_space();
853   }
854 
855   HeapWord* new_end = (HeapWord*)virtual_space()-&gt;high();
856   assert(new_end &gt;= space_shrinking-&gt;bottom(), &quot;Shrink was too large&quot;);
857   // Was there a shrink of the survivor space?
858   if (new_end &lt; space_shrinking-&gt;end()) {
859     MemRegion mr(space_shrinking-&gt;bottom(), new_end);
860     space_shrinking-&gt;initialize(mr,
861                                 SpaceDecorator::DontClear,
862                                 SpaceDecorator::Mangle);
863   }
864 }
865 
866 // This method currently does not expect to expand into eden (i.e.,
867 // the virtual space boundaries is expected to be consistent
868 // with the eden boundaries..
869 void PSYoungGen::post_resize() {
870   assert_locked_or_safepoint(Heap_lock);
871   assert((eden_space()-&gt;bottom() &lt; to_space()-&gt;bottom()) &amp;&amp;
872          (eden_space()-&gt;bottom() &lt; from_space()-&gt;bottom()),
873          &quot;Eden is assumed to be below the survivor spaces&quot;);
874 
875   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
876                 (HeapWord*)virtual_space()-&gt;high());
877   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
878   space_invariants();
879 }
880 
881 
882 
883 void PSYoungGen::update_counters() {
884   if (UsePerfData) {
885     _eden_counters-&gt;update_all();
886     _from_counters-&gt;update_all();
887     _to_counters-&gt;update_all();
888     _gen_counters-&gt;update_all();
889   }
890 }
891 
892 void PSYoungGen::verify() {
893   eden_space()-&gt;verify();
894   from_space()-&gt;verify();
895   to_space()-&gt;verify();
896 }
897 
898 #ifndef PRODUCT
899 void PSYoungGen::record_spaces_top() {
900   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
901   eden_space()-&gt;set_top_for_allocations();
902   from_space()-&gt;set_top_for_allocations();
903   to_space()-&gt;set_top_for_allocations();
904 }
905 #endif
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
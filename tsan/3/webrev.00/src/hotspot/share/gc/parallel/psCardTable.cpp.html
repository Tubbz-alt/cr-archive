<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/psCardTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 28 #include &quot;gc/parallel/psCardTable.hpp&quot;
 29 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 30 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 31 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 // Checks an individual oop for missing precise marks. Mark
 39 // may be either dirty or newgen.
 40 class CheckForUnmarkedOops : public BasicOopIterateClosure {
 41  private:
 42   PSYoungGen*  _young_gen;
 43   PSCardTable* _card_table;
 44   HeapWord*    _unmarked_addr;
 45 
 46  protected:
 47   template &lt;class T&gt; void do_oop_work(T* p) {
 48     oop obj = RawAccess&lt;&gt;::oop_load(p);
 49     if (_young_gen-&gt;is_in_reserved(obj) &amp;&amp;
 50         !_card_table-&gt;addr_is_marked_imprecise(p)) {
 51       // Don&#39;t overwrite the first missing card mark
 52       if (_unmarked_addr == NULL) {
 53         _unmarked_addr = (HeapWord*)p;
 54       }
 55     }
 56   }
 57 
 58  public:
 59   CheckForUnmarkedOops(PSYoungGen* young_gen, PSCardTable* card_table) :
 60     _young_gen(young_gen), _card_table(card_table), _unmarked_addr(NULL) { }
 61 
 62   virtual void do_oop(oop* p)       { CheckForUnmarkedOops::do_oop_work(p); }
 63   virtual void do_oop(narrowOop* p) { CheckForUnmarkedOops::do_oop_work(p); }
 64 
 65   bool has_unmarked_oop() {
 66     return _unmarked_addr != NULL;
 67   }
 68 };
 69 
 70 // Checks all objects for the existence of some type of mark,
 71 // precise or imprecise, dirty or newgen.
 72 class CheckForUnmarkedObjects : public ObjectClosure {
 73  private:
 74   PSYoungGen*  _young_gen;
 75   PSCardTable* _card_table;
 76 
 77  public:
 78   CheckForUnmarkedObjects() {
 79     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 80     _young_gen = heap-&gt;young_gen();
 81     _card_table = heap-&gt;card_table();
 82   }
 83 
 84   // Card marks are not precise. The current system can leave us with
 85   // a mismatch of precise marks and beginning of object marks. This means
 86   // we test for missing precise marks first. If any are found, we don&#39;t
 87   // fail unless the object head is also unmarked.
 88   virtual void do_object(oop obj) {
 89     CheckForUnmarkedOops object_check(_young_gen, _card_table);
 90     obj-&gt;oop_iterate(&amp;object_check);
 91     if (object_check.has_unmarked_oop()) {
 92       guarantee(_card_table-&gt;addr_is_marked_imprecise(obj), &quot;Found unmarked young_gen object&quot;);
 93     }
 94   }
 95 };
 96 
 97 // Checks for precise marking of oops as newgen.
 98 class CheckForPreciseMarks : public BasicOopIterateClosure {
 99  private:
100   PSYoungGen*  _young_gen;
101   PSCardTable* _card_table;
102 
103  protected:
104   template &lt;class T&gt; void do_oop_work(T* p) {
105     oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
106     if (_young_gen-&gt;is_in_reserved(obj)) {
107       assert(_card_table-&gt;addr_is_marked_precise(p), &quot;Found unmarked precise oop&quot;);
108       _card_table-&gt;set_card_newgen(p);
109     }
110   }
111 
112  public:
113   CheckForPreciseMarks(PSYoungGen* young_gen, PSCardTable* card_table) :
114     _young_gen(young_gen), _card_table(card_table) { }
115 
116   virtual void do_oop(oop* p)       { CheckForPreciseMarks::do_oop_work(p); }
117   virtual void do_oop(narrowOop* p) { CheckForPreciseMarks::do_oop_work(p); }
118 };
119 
120 // We get passed the space_top value to prevent us from traversing into
121 // the old_gen promotion labs, which cannot be safely parsed.
122 
123 // Do not call this method if the space is empty.
124 // It is a waste to start tasks and get here only to
125 // do no work.  If this method needs to be called
126 // when the space is empty, fix the calculation of
127 // end_card to allow sp_top == sp-&gt;bottom().
128 
129 // The generation (old gen) is divided into slices, which are further
130 // subdivided into stripes, with one stripe per GC thread. The size of
131 // a stripe is a constant, ssize.
132 //
133 //      +===============+        slice 0
134 //      |  stripe 0     |
135 //      +---------------+
136 //      |  stripe 1     |
137 //      +---------------+
138 //      |  stripe 2     |
139 //      +---------------+
140 //      |  stripe 3     |
141 //      +===============+        slice 1
142 //      |  stripe 0     |
143 //      +---------------+
144 //      |  stripe 1     |
145 //      +---------------+
146 //      |  stripe 2     |
147 //      +---------------+
148 //      |  stripe 3     |
149 //      +===============+        slice 2
150 //      ...
151 //
152 // In this case there are 4 threads, so 4 stripes.  A GC thread first works on
153 // its stripe within slice 0 and then moves to its stripe in the next slice
154 // until it has exceeded the top of the generation.  The distance to stripe in
155 // the next slice is calculated based on the number of stripes.  The next
156 // stripe is at ssize * number_of_stripes (= slice_stride)..  So after
157 // finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1 by
158 // adding slice_stride to the start of stripe 0 in slice 0 to get to the start
159 // of stride 0 in slice 1.
160 
161 void PSCardTable::scavenge_contents_parallel(ObjectStartArray* start_array,
162                                              MutableSpace* sp,
163                                              HeapWord* space_top,
164                                              PSPromotionManager* pm,
165                                              uint stripe_number,
166                                              uint stripe_total) {
167   int ssize = 128; // Naked constant!  Work unit = 64k.
168   int dirty_card_count = 0;
169 
170   // It is a waste to get here if empty.
171   assert(sp-&gt;bottom() &lt; sp-&gt;top(), &quot;Should not be called if empty&quot;);
172   oop* sp_top = (oop*)space_top;
173   CardValue* start_card = byte_for(sp-&gt;bottom());
174   CardValue* end_card   = byte_for(sp_top - 1) + 1;
175   oop* last_scanned = NULL; // Prevent scanning objects more than once
176   // The width of the stripe ssize*stripe_total must be
177   // consistent with the number of stripes so that the complete slice
178   // is covered.
179   size_t slice_width = ssize * stripe_total;
180   for (CardValue* slice = start_card; slice &lt; end_card; slice += slice_width) {
181     CardValue* worker_start_card = slice + stripe_number * ssize;
182     if (worker_start_card &gt;= end_card)
183       return; // We&#39;re done.
184 
185     CardValue* worker_end_card = worker_start_card + ssize;
186     if (worker_end_card &gt; end_card)
187       worker_end_card = end_card;
188 
189     // We do not want to scan objects more than once. In order to accomplish
190     // this, we assert that any object with an object head inside our &#39;slice&#39;
191     // belongs to us. We may need to extend the range of scanned cards if the
192     // last object continues into the next &#39;slice&#39;.
193     //
194     // Note! ending cards are exclusive!
195     HeapWord* slice_start = addr_for(worker_start_card);
196     HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));
197 
198 #ifdef ASSERT
199     if (GCWorkerDelayMillis &gt; 0) {
200       // Delay 1 worker so that it proceeds after all the work
201       // has been completed.
202       if (stripe_number &lt; 2) {
203         os::naked_sleep(GCWorkerDelayMillis);
204       }
205     }
206 #endif
207 
208     // If there are not objects starting within the chunk, skip it.
209     if (!start_array-&gt;object_starts_in_range(slice_start, slice_end)) {
210       continue;
211     }
212     // Update our beginning addr
213     HeapWord* first_object = start_array-&gt;object_start(slice_start);
214     debug_only(oop* first_object_within_slice = (oop*) first_object;)
215     if (first_object &lt; slice_start) {
216       last_scanned = (oop*)(first_object + oop(first_object)-&gt;size());
217       debug_only(first_object_within_slice = last_scanned;)
218       worker_start_card = byte_for(last_scanned);
219     }
220 
221     // Update the ending addr
222     if (slice_end &lt; (HeapWord*)sp_top) {
223       // The subtraction is important! An object may start precisely at slice_end.
224       HeapWord* last_object = start_array-&gt;object_start(slice_end - 1);
225       slice_end = last_object + oop(last_object)-&gt;size();
226       // worker_end_card is exclusive, so bump it one past the end of last_object&#39;s
227       // covered span.
228       worker_end_card = byte_for(slice_end) + 1;
229 
230       if (worker_end_card &gt; end_card)
231         worker_end_card = end_card;
232     }
233 
234     assert(slice_end &lt;= (HeapWord*)sp_top, &quot;Last object in slice crosses space boundary&quot;);
235     assert(is_valid_card_address(worker_start_card), &quot;Invalid worker start card&quot;);
236     assert(is_valid_card_address(worker_end_card), &quot;Invalid worker end card&quot;);
237     // Note that worker_start_card &gt;= worker_end_card is legal, and happens when
238     // an object spans an entire slice.
239     assert(worker_start_card &lt;= end_card, &quot;worker start card beyond end card&quot;);
240     assert(worker_end_card &lt;= end_card, &quot;worker end card beyond end card&quot;);
241 
242     CardValue* current_card = worker_start_card;
243     while (current_card &lt; worker_end_card) {
244       // Find an unclean card.
245       while (current_card &lt; worker_end_card &amp;&amp; card_is_clean(*current_card)) {
246         current_card++;
247       }
248       CardValue* first_unclean_card = current_card;
249 
250       // Find the end of a run of contiguous unclean cards
251       while (current_card &lt; worker_end_card &amp;&amp; !card_is_clean(*current_card)) {
252         while (current_card &lt; worker_end_card &amp;&amp; !card_is_clean(*current_card)) {
253           current_card++;
254         }
255 
256         if (current_card &lt; worker_end_card) {
257           // Some objects may be large enough to span several cards. If such
258           // an object has more than one dirty card, separated by a clean card,
259           // we will attempt to scan it twice. The test against &quot;last_scanned&quot;
260           // prevents the redundant object scan, but it does not prevent newly
261           // marked cards from being cleaned.
262           HeapWord* last_object_in_dirty_region = start_array-&gt;object_start(addr_for(current_card)-1);
263           size_t size_of_last_object = oop(last_object_in_dirty_region)-&gt;size();
264           HeapWord* end_of_last_object = last_object_in_dirty_region + size_of_last_object;
265           CardValue* ending_card_of_last_object = byte_for(end_of_last_object);
266           assert(ending_card_of_last_object &lt;= worker_end_card, &quot;ending_card_of_last_object is greater than worker_end_card&quot;);
267           if (ending_card_of_last_object &gt; current_card) {
268             // This means the object spans the next complete card.
269             // We need to bump the current_card to ending_card_of_last_object
270             current_card = ending_card_of_last_object;
271           }
272         }
273       }
274       CardValue* following_clean_card = current_card;
275 
276       if (first_unclean_card &lt; worker_end_card) {
277         oop* p = (oop*) start_array-&gt;object_start(addr_for(first_unclean_card));
278         assert((HeapWord*)p &lt;= addr_for(first_unclean_card), &quot;checking&quot;);
279         // &quot;p&quot; should always be &gt;= &quot;last_scanned&quot; because newly GC dirtied
280         // cards are no longer scanned again (see comment at end
281         // of loop on the increment of &quot;current_card&quot;).  Test that
282         // hypothesis before removing this code.
283         // If this code is removed, deal with the first time through
284         // the loop when the last_scanned is the object starting in
285         // the previous slice.
286         assert((p &gt;= last_scanned) ||
287                (last_scanned == first_object_within_slice),
288                &quot;Should no longer be possible&quot;);
289         if (p &lt; last_scanned) {
290           // Avoid scanning more than once; this can happen because
291           // newgen cards set by GC may a different set than the
292           // originally dirty set
293           p = last_scanned;
294         }
295         oop* to = (oop*)addr_for(following_clean_card);
296 
297         // Test slice_end first!
298         if ((HeapWord*)to &gt; slice_end) {
299           to = (oop*)slice_end;
300         } else if (to &gt; sp_top) {
301           to = sp_top;
302         }
303 
304         // we know which cards to scan, now clear them
305         if (first_unclean_card &lt;= worker_start_card+1)
306           first_unclean_card = worker_start_card+1;
307         if (following_clean_card &gt;= worker_end_card-1)
308           following_clean_card = worker_end_card-1;
309 
310         while (first_unclean_card &lt; following_clean_card) {
311           *first_unclean_card++ = clean_card;
312         }
313 
314         const int interval = PrefetchScanIntervalInBytes;
315         // scan all objects in the range
316         if (interval != 0) {
317           while (p &lt; to) {
318             Prefetch::write(p, interval);
319             oop m = oop(p);
320             assert(oopDesc::is_oop_or_null(m), &quot;Expected an oop or NULL for header field at &quot; PTR_FORMAT, p2i(m));
321             pm-&gt;push_contents(m);
322             p += m-&gt;size();
323           }
324           pm-&gt;drain_stacks_cond_depth();
325         } else {
326           while (p &lt; to) {
327             oop m = oop(p);
328             assert(oopDesc::is_oop_or_null(m), &quot;Expected an oop or NULL for header field at &quot; PTR_FORMAT, p2i(m));
329             pm-&gt;push_contents(m);
330             p += m-&gt;size();
331           }
332           pm-&gt;drain_stacks_cond_depth();
333         }
334         last_scanned = p;
335       }
336       // &quot;current_card&quot; is still the &quot;following_clean_card&quot; or
337       // the current_card is &gt;= the worker_end_card so the
338       // loop will not execute again.
339       assert((current_card == following_clean_card) ||
340              (current_card &gt;= worker_end_card),
341         &quot;current_card should only be incremented if it still equals &quot;
342         &quot;following_clean_card&quot;);
343       // Increment current_card so that it is not processed again.
344       // It may now be dirty because a old-to-young pointer was
345       // found on it an updated.  If it is now dirty, it cannot be
346       // be safely cleaned in the next iteration.
347       current_card++;
348     }
349   }
350 }
351 
352 // This should be called before a scavenge.
353 void PSCardTable::verify_all_young_refs_imprecise() {
354   CheckForUnmarkedObjects check;
355 
356   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
357   PSOldGen* old_gen = heap-&gt;old_gen();
358 
359   old_gen-&gt;object_iterate(&amp;check);
360 }
361 
362 // This should be called immediately after a scavenge, before mutators resume.
363 void PSCardTable::verify_all_young_refs_precise() {
364   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
365   PSOldGen* old_gen = heap-&gt;old_gen();
366 
367   CheckForPreciseMarks check(heap-&gt;young_gen(), this);
368 
369   old_gen-&gt;oop_iterate(&amp;check);
370 
371   verify_all_young_refs_precise_helper(old_gen-&gt;object_space()-&gt;used_region());
372 }
373 
374 void PSCardTable::verify_all_young_refs_precise_helper(MemRegion mr) {
375   CardValue* bot = byte_for(mr.start());
376   CardValue* top = byte_for(mr.end());
377   while (bot &lt;= top) {
378     assert(*bot == clean_card || *bot == verify_card, &quot;Found unwanted or unknown card mark&quot;);
379     if (*bot == verify_card)
380       *bot = youngergen_card;
381     bot++;
382   }
383 }
384 
385 bool PSCardTable::addr_is_marked_imprecise(void *addr) {
386   CardValue* p = byte_for(addr);
387   CardValue val = *p;
388 
389   if (card_is_dirty(val))
390     return true;
391 
392   if (card_is_newgen(val))
393     return true;
394 
395   if (card_is_clean(val))
396     return false;
397 
398   assert(false, &quot;Found unhandled card mark type&quot;);
399 
400   return false;
401 }
402 
403 // Also includes verify_card
404 bool PSCardTable::addr_is_marked_precise(void *addr) {
405   CardValue* p = byte_for(addr);
406   CardValue val = *p;
407 
408   if (card_is_newgen(val))
409     return true;
410 
411   if (card_is_verify(val))
412     return true;
413 
414   if (card_is_clean(val))
415     return false;
416 
417   if (card_is_dirty(val))
418     return false;
419 
420   assert(false, &quot;Found unhandled card mark type&quot;);
421 
422   return false;
423 }
424 
425 // Assumes that only the base or the end changes.  This allows indentification
426 // of the region that is being resized.  The
427 // CardTable::resize_covered_region() is used for the normal case
428 // where the covered regions are growing or shrinking at the high end.
429 // The method resize_covered_region_by_end() is analogous to
430 // CardTable::resize_covered_region() but
431 // for regions that grow or shrink at the low end.
432 void PSCardTable::resize_covered_region(MemRegion new_region) {
433   for (int i = 0; i &lt; _cur_covered_regions; i++) {
434     if (_covered[i].start() == new_region.start()) {
435       // Found a covered region with the same start as the
436       // new region.  The region is growing or shrinking
437       // from the start of the region.
438       resize_covered_region_by_start(new_region);
439       return;
440     }
441     if (_covered[i].start() &gt; new_region.start()) {
442       break;
443     }
444   }
445 
446   int changed_region = -1;
447   for (int j = 0; j &lt; _cur_covered_regions; j++) {
448     if (_covered[j].end() == new_region.end()) {
449       changed_region = j;
450       // This is a case where the covered region is growing or shrinking
451       // at the start of the region.
452       assert(changed_region != -1, &quot;Don&#39;t expect to add a covered region&quot;);
453       assert(_covered[changed_region].byte_size() != new_region.byte_size(),
454         &quot;The sizes should be different here&quot;);
455       resize_covered_region_by_end(changed_region, new_region);
456       return;
457     }
458   }
459   // This should only be a new covered region (where no existing
460   // covered region matches at the start or the end).
461   assert(_cur_covered_regions &lt; _max_covered_regions,
462     &quot;An existing region should have been found&quot;);
463   resize_covered_region_by_start(new_region);
464 }
465 
466 void PSCardTable::resize_covered_region_by_start(MemRegion new_region) {
467   CardTable::resize_covered_region(new_region);
468   debug_only(verify_guard();)
469 }
470 
471 void PSCardTable::resize_covered_region_by_end(int changed_region,
472                                                MemRegion new_region) {
473   assert(SafepointSynchronize::is_at_safepoint(),
474     &quot;Only expect an expansion at the low end at a GC&quot;);
475   debug_only(verify_guard();)
476 #ifdef ASSERT
477   for (int k = 0; k &lt; _cur_covered_regions; k++) {
478     if (_covered[k].end() == new_region.end()) {
479       assert(changed_region == k, &quot;Changed region is incorrect&quot;);
480       break;
481     }
482   }
483 #endif
484 
485   // Commit new or uncommit old pages, if necessary.
486   if (resize_commit_uncommit(changed_region, new_region)) {
487     // Set the new start of the committed region
488     resize_update_committed_table(changed_region, new_region);
489   }
490 
491   // Update card table entries
492   resize_update_card_table_entries(changed_region, new_region);
493 
494   // Update the covered region
495   resize_update_covered_table(changed_region, new_region);
496 
497   int ind = changed_region;
498   log_trace(gc, barrier)(&quot;CardTable::resize_covered_region: &quot;);
499   log_trace(gc, barrier)(&quot;    _covered[%d].start(): &quot; INTPTR_FORMAT &quot;  _covered[%d].last(): &quot; INTPTR_FORMAT,
500                 ind, p2i(_covered[ind].start()), ind, p2i(_covered[ind].last()));
501   log_trace(gc, barrier)(&quot;    _committed[%d].start(): &quot; INTPTR_FORMAT &quot;  _committed[%d].last(): &quot; INTPTR_FORMAT,
502                 ind, p2i(_committed[ind].start()), ind, p2i(_committed[ind].last()));
503   log_trace(gc, barrier)(&quot;    byte_for(start): &quot; INTPTR_FORMAT &quot;  byte_for(last): &quot; INTPTR_FORMAT,
504                 p2i(byte_for(_covered[ind].start())),  p2i(byte_for(_covered[ind].last())));
505   log_trace(gc, barrier)(&quot;    addr_for(start): &quot; INTPTR_FORMAT &quot;  addr_for(last): &quot; INTPTR_FORMAT,
506                 p2i(addr_for((CardValue*) _committed[ind].start())), p2i(addr_for((CardValue*) _committed[ind].last())));
507 
508   debug_only(verify_guard();)
509 }
510 
511 bool PSCardTable::resize_commit_uncommit(int changed_region,
512                                          MemRegion new_region) {
513   bool result = false;
514   // Commit new or uncommit old pages, if necessary.
515   MemRegion cur_committed = _committed[changed_region];
516   assert(_covered[changed_region].end() == new_region.end(),
517     &quot;The ends of the regions are expected to match&quot;);
518   // Extend the start of this _committed region to
519   // to cover the start of any previous _committed region.
520   // This forms overlapping regions, but never interior regions.
521   HeapWord* min_prev_start = lowest_prev_committed_start(changed_region);
522   if (min_prev_start &lt; cur_committed.start()) {
523     // Only really need to set start of &quot;cur_committed&quot; to
524     // the new start (min_prev_start) but assertion checking code
525     // below use cur_committed.end() so make it correct.
526     MemRegion new_committed =
527         MemRegion(min_prev_start, cur_committed.end());
528     cur_committed = new_committed;
529   }
530 #ifdef ASSERT
531   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
532   assert(cur_committed.start() == align_up(cur_committed.start(), os::vm_page_size()),
533          &quot;Starts should have proper alignment&quot;);
534 #endif
535 
536   CardValue* new_start = byte_for(new_region.start());
537   // Round down because this is for the start address
538   HeapWord* new_start_aligned = align_down((HeapWord*)new_start, os::vm_page_size());
539   // The guard page is always committed and should not be committed over.
540   // This method is used in cases where the generation is growing toward
541   // lower addresses but the guard region is still at the end of the
542   // card table.  That still makes sense when looking for writes
543   // off the end of the card table.
544   if (new_start_aligned &lt; cur_committed.start()) {
545     // Expand the committed region
546     //
547     // Case A
548     //                                          |+ guard +|
549     //                          |+ cur committed +++++++++|
550     //                  |+ new committed +++++++++++++++++|
551     //
552     // Case B
553     //                                          |+ guard +|
554     //                        |+ cur committed +|
555     //                  |+ new committed +++++++|
556     //
557     // These are not expected because the calculation of the
558     // cur committed region and the new committed region
559     // share the same end for the covered region.
560     // Case C
561     //                                          |+ guard +|
562     //                        |+ cur committed +|
563     //                  |+ new committed +++++++++++++++++|
564     // Case D
565     //                                          |+ guard +|
566     //                        |+ cur committed +++++++++++|
567     //                  |+ new committed +++++++|
568 
569     HeapWord* new_end_for_commit =
570       MIN2(cur_committed.end(), _guard_region.start());
571     if(new_start_aligned &lt; new_end_for_commit) {
572       MemRegion new_committed =
573         MemRegion(new_start_aligned, new_end_for_commit);
574       os::commit_memory_or_exit((char*)new_committed.start(),
575                                 new_committed.byte_size(), !ExecMem,
576                                 &quot;card table expansion&quot;);
577     }
578     result = true;
579   } else if (new_start_aligned &gt; cur_committed.start()) {
580     // Shrink the committed region
581 #if 0 // uncommitting space is currently unsafe because of the interactions
582       // of growing and shrinking regions.  One region A can uncommit space
583       // that it owns but which is being used by another region B (maybe).
584       // Region B has not committed the space because it was already
585       // committed by region A.
586     MemRegion uncommit_region = committed_unique_to_self(changed_region,
587       MemRegion(cur_committed.start(), new_start_aligned));
588     if (!uncommit_region.is_empty()) {
589       if (!os::uncommit_memory((char*)uncommit_region.start(),
590                                uncommit_region.byte_size())) {
591         // If the uncommit fails, ignore it.  Let the
592         // committed table resizing go even though the committed
593         // table will over state the committed space.
594       }
595     }
596 #else
597     assert(!result, &quot;Should be false with current workaround&quot;);
598 #endif
599   }
600   assert(_committed[changed_region].end() == cur_committed.end(),
601     &quot;end should not change&quot;);
602   return result;
603 }
604 
605 void PSCardTable::resize_update_committed_table(int changed_region,
606                                                 MemRegion new_region) {
607 
608   CardValue* new_start = byte_for(new_region.start());
609   // Set the new start of the committed region
610   HeapWord* new_start_aligned = align_down((HeapWord*)new_start, os::vm_page_size());
611   MemRegion new_committed = MemRegion(new_start_aligned,
612                                       _committed[changed_region].end());
613   _committed[changed_region] = new_committed;
614   _committed[changed_region].set_start(new_start_aligned);
615 }
616 
617 void PSCardTable::resize_update_card_table_entries(int changed_region,
618                                                    MemRegion new_region) {
619   debug_only(verify_guard();)
620   MemRegion original_covered = _covered[changed_region];
621   // Initialize the card entries.  Only consider the
622   // region covered by the card table (_whole_heap)
623   CardValue* entry;
624   if (new_region.start() &lt; _whole_heap.start()) {
625     entry = byte_for(_whole_heap.start());
626   } else {
627     entry = byte_for(new_region.start());
628   }
629   CardValue* end = byte_for(original_covered.start());
630   // If _whole_heap starts at the original covered regions start,
631   // this loop will not execute.
632   while (entry &lt; end) { *entry++ = clean_card; }
633 }
634 
635 void PSCardTable::resize_update_covered_table(int changed_region,
636                                               MemRegion new_region) {
637   // Update the covered region
638   _covered[changed_region].set_start(new_region.start());
639   _covered[changed_region].set_word_size(new_region.word_size());
640 
641   // reorder regions.  There should only be at most 1 out
642   // of order.
643   for (int i = _cur_covered_regions-1 ; i &gt; 0; i--) {
644     if (_covered[i].start() &lt; _covered[i-1].start()) {
645         MemRegion covered_mr = _covered[i-1];
646         _covered[i-1] = _covered[i];
647         _covered[i] = covered_mr;
648         MemRegion committed_mr = _committed[i-1];
649       _committed[i-1] = _committed[i];
650       _committed[i] = committed_mr;
651       break;
652     }
653   }
654 #ifdef ASSERT
655   for (int m = 0; m &lt; _cur_covered_regions-1; m++) {
656     assert(_covered[m].start() &lt;= _covered[m+1].start(),
657       &quot;Covered regions out of order&quot;);
658     assert(_committed[m].start() &lt;= _committed[m+1].start(),
659       &quot;Committed regions out of order&quot;);
660   }
661 #endif
662 }
663 
664 // Returns the start of any committed region that is lower than
665 // the target committed region (index ind) and that intersects the
666 // target region.  If none, return start of target region.
667 //
668 //      -------------
669 //      |           |
670 //      -------------
671 //              ------------
672 //              | target   |
673 //              ------------
674 //                               -------------
675 //                               |           |
676 //                               -------------
677 //      ^ returns this
678 //
679 //      -------------
680 //      |           |
681 //      -------------
682 //                      ------------
683 //                      | target   |
684 //                      ------------
685 //                               -------------
686 //                               |           |
687 //                               -------------
688 //                      ^ returns this
689 
690 HeapWord* PSCardTable::lowest_prev_committed_start(int ind) const {
691   assert(_cur_covered_regions &gt;= 0, &quot;Expecting at least on region&quot;);
692   HeapWord* min_start = _committed[ind].start();
693   for (int j = 0; j &lt; ind; j++) {
694     HeapWord* this_start = _committed[j].start();
695     if ((this_start &lt; min_start) &amp;&amp;
696         !(_committed[j].intersection(_committed[ind])).is_empty()) {
697        min_start = this_start;
698     }
699   }
700   return min_start;
701 }
702 
703 bool PSCardTable::is_in_young(oop obj) const {
704   return ParallelScavengeHeap::heap()-&gt;is_in_young(obj);
705 }
    </pre>
  </body>
</html>
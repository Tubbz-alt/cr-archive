<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelScavengeHeap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,29 +23,30 @@</span>
   */
  
  #ifndef SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
  #define SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
  
<span class="udiff-line-removed">- #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
  #include &quot;gc/parallel/objectStartArray.hpp&quot;
  #include &quot;gc/parallel/psGCAdaptivePolicyCounters.hpp&quot;
  #include &quot;gc/parallel/psOldGen.hpp&quot;
  #include &quot;gc/parallel/psYoungGen.hpp&quot;
  #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/preGCValues.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/referenceProcessor.hpp&quot;</span>
  #include &quot;gc/shared/softRefPolicy.hpp&quot;
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/workgroup.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;memory/metaspace.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  
  class AdjoiningGenerations;
  class GCHeapSummary;
<span class="udiff-line-removed">- class GCTaskManager;</span>
  class MemoryManager;
  class MemoryPool;
  class PSAdaptiveSizePolicy;
  class PSCardTable;
  class PSHeapSummary;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58,29 +59,26 @@</span>
  
    // Sizing policy for entire heap
    static PSAdaptiveSizePolicy*       _size_policy;
    static PSGCAdaptivePolicyCounters* _gc_policy_counters;
  
<span class="udiff-line-removed">-   GenerationSizer* _collector_policy;</span>
<span class="udiff-line-removed">- </span>
    SoftRefPolicy _soft_ref_policy;
  
    // Collection of generations that are adjacent in the
    // space reserved for the heap.
    AdjoiningGenerations* _gens;
    unsigned int _death_march_count;
  
<span class="udiff-line-removed">-   // The task manager</span>
<span class="udiff-line-removed">-   static GCTaskManager* _gc_task_manager;</span>
<span class="udiff-line-removed">- </span>
    GCMemoryManager* _young_manager;
    GCMemoryManager* _old_manager;
  
    MemoryPool* _eden_pool;
    MemoryPool* _survivor_pool;
    MemoryPool* _old_pool;
  
<span class="udiff-line-added">+   WorkGang _workers;</span>
<span class="udiff-line-added">+ </span>
    virtual void initialize_serviceability();
  
    void trace_heap(GCWhen::Type when, const GCTracer* tracer);
  
   protected:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,12 +88,23 @@</span>
    inline bool should_alloc_in_eden(size_t size) const;
    inline void death_march_check(HeapWord* const result, size_t size);
    HeapWord* mem_allocate_old_gen(size_t size);
  
   public:
<span class="udiff-line-modified-removed">-   ParallelScavengeHeap(GenerationSizer* policy) :</span>
<span class="udiff-line-modified-removed">-     CollectedHeap(), _collector_policy(policy), _death_march_count(0) { }</span>
<span class="udiff-line-modified-added">+   ParallelScavengeHeap() :</span>
<span class="udiff-line-modified-added">+     CollectedHeap(),</span>
<span class="udiff-line-added">+     _gens(NULL),</span>
<span class="udiff-line-added">+     _death_march_count(0),</span>
<span class="udiff-line-added">+     _young_manager(NULL),</span>
<span class="udiff-line-added">+     _old_manager(NULL),</span>
<span class="udiff-line-added">+     _eden_pool(NULL),</span>
<span class="udiff-line-added">+     _survivor_pool(NULL),</span>
<span class="udiff-line-added">+     _old_pool(NULL),</span>
<span class="udiff-line-added">+     _workers(&quot;GC Thread&quot;,</span>
<span class="udiff-line-added">+              ParallelGCThreads,</span>
<span class="udiff-line-added">+              true /* are_GC_task_threads */,</span>
<span class="udiff-line-added">+              false /* are_ConcurrentGC_threads */) { }</span>
  
    // For use by VM operations
    enum CollectionType {
      Scavenge,
      MarkSweep
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107,14 +116,10 @@</span>
  
    virtual const char* name() const {
      return &quot;Parallel&quot;;
    }
  
<span class="udiff-line-removed">-   virtual CollectorPolicy* collector_policy() const { return _collector_policy; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   virtual GenerationSizer* ps_collector_policy() const { return _collector_policy; }</span>
<span class="udiff-line-removed">- </span>
    virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
  
    virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
    virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,12 +130,10 @@</span>
  
    static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
  
    static ParallelScavengeHeap* heap();
  
<span class="udiff-line-removed">-   static GCTaskManager* const gc_task_manager() { return _gc_task_manager; }</span>
<span class="udiff-line-removed">- </span>
    CardTableBarrierSet* barrier_set();
    PSCardTable* card_table();
  
    AdjoiningGenerations* gens() { return _gens; }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,19 +141,10 @@</span>
    virtual jint initialize();
  
    void post_initialize();
    void update_counters();
  
<span class="udiff-line-removed">-   // The alignment used for the various areas</span>
<span class="udiff-line-removed">-   size_t space_alignment()      { return _collector_policy-&gt;space_alignment(); }</span>
<span class="udiff-line-removed">-   size_t generation_alignment() { return _collector_policy-&gt;gen_alignment(); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Return the (conservative) maximum heap alignment</span>
<span class="udiff-line-removed">-   static size_t conservative_max_heap_alignment() {</span>
<span class="udiff-line-removed">-     return CollectorPolicy::compute_heap_alignment();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    size_t capacity() const;
    size_t used() const;
  
    // Return &quot;true&quot; if all generations have reached the
    // maximal committed limit that they can reach, without a garbage
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160,11 +154,11 @@</span>
    virtual void register_nmethod(nmethod* nm);
    virtual void unregister_nmethod(nmethod* nm);
    virtual void verify_nmethod(nmethod* nm);
    virtual void flush_nmethod(nmethod* nm);
  
<span class="udiff-line-modified-removed">-   void prune_nmethods();</span>
<span class="udiff-line-modified-added">+   void prune_scavengable_nmethods();</span>
  
    size_t max_capacity() const;
  
    // Whether p is in the allocated part of the heap
    bool is_in(const void* p) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -172,10 +166,13 @@</span>
    bool is_in_reserved(const void* p) const;
  
    bool is_in_young(oop p);  // reserved part
    bool is_in_old(oop p);    // reserved part
  
<span class="udiff-line-added">+   MemRegion reserved_region() const { return _reserved; }</span>
<span class="udiff-line-added">+   HeapWord* base() const { return _reserved.start(); }</span>
<span class="udiff-line-added">+ </span>
    // Memory allocation.   &quot;gc_time_limit_was_exceeded&quot; will
    // be set to true if the adaptive size policy determine that
    // an excessive amount of time is being spent doing collections
    // and caused a NULL to be returned.  If a NULL is not returned,
    // &quot;gc_time_limit_was_exceeded&quot; has an undefined meaning.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,11 +211,10 @@</span>
    size_t tlab_capacity(Thread* thr) const;
    size_t tlab_used(Thread* thr) const;
    size_t unsafe_max_tlab_alloc(Thread* thr) const;
  
    void object_iterate(ObjectClosure* cl);
<span class="udiff-line-removed">-   void safe_object_iterate(ObjectClosure* cl) { object_iterate(cl); }</span>
  
    HeapWord* block_start(const void* addr) const;
    bool block_is_obj(const HeapWord* addr) const;
  
    jlong millis_since_last_gc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,10 +225,16 @@</span>
    virtual void print_on_error(outputStream* st) const;
    virtual void print_gc_threads_on(outputStream* st) const;
    virtual void gc_threads_do(ThreadClosure* tc) const;
    virtual void print_tracing_info() const;
  
<span class="udiff-line-added">+   PreGenGCValues get_pre_gc_values() const;</span>
<span class="udiff-line-added">+   void print_heap_change(const PreGenGCValues&amp; pre_gc_values) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Used to print information about locations in the hs_err file.</span>
<span class="udiff-line-added">+   virtual bool print_location(outputStream* st, void* addr) const;</span>
<span class="udiff-line-added">+ </span>
    void verify(VerifyOption option /* ignored */);
  
    // Resize the young generation.  The reserved space for the
    // generation may be expanded in preparation for the resize.
    void resize_young_gen(size_t eden_size, size_t survivor_size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -254,32 +256,14 @@</span>
      ~ParStrongRootsScope();
    };
  
    GCMemoryManager* old_gc_manager() const { return _old_manager; }
    GCMemoryManager* young_gc_manager() const { return _young_manager; }
<span class="udiff-line-removed">- };</span>
  
<span class="udiff-line-modified-removed">- // Simple class for storing info about the heap at the start of GC, to be used</span>
<span class="udiff-line-modified-removed">- // after GC for comparison/printing.</span>
<span class="udiff-line-modified-removed">- class PreGCValues {</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-   PreGCValues(ParallelScavengeHeap* heap) :</span>
<span class="udiff-line-removed">-       _heap_used(heap-&gt;used()),</span>
<span class="udiff-line-removed">-       _young_gen_used(heap-&gt;young_gen()-&gt;used_in_bytes()),</span>
<span class="udiff-line-removed">-       _old_gen_used(heap-&gt;old_gen()-&gt;used_in_bytes()),</span>
<span class="udiff-line-removed">-       _metadata_used(MetaspaceUtils::used_bytes()) { };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t heap_used() const      { return _heap_used; }</span>
<span class="udiff-line-removed">-   size_t young_gen_used() const { return _young_gen_used; }</span>
<span class="udiff-line-removed">-   size_t old_gen_used() const   { return _old_gen_used; }</span>
<span class="udiff-line-removed">-   size_t metadata_used() const  { return _metadata_used; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-   size_t _heap_used;</span>
<span class="udiff-line-removed">-   size_t _young_gen_used;</span>
<span class="udiff-line-removed">-   size_t _old_gen_used;</span>
<span class="udiff-line-removed">-   size_t _metadata_used;</span>
<span class="udiff-line-modified-added">+   WorkGang&amp; workers() {</span>
<span class="udiff-line-modified-added">+     return _workers;</span>
<span class="udiff-line-modified-added">+   }</span>
  };
  
  // Class that can be used to print information about the
  // adaptive size policy at intervals specified by
  // AdaptiveSizePolicyOutputInterval.  Only print information
</pre>
<center><a href="parallelScavengeHeap.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
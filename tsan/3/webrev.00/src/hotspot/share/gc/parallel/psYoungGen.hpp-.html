<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/psYoungGen.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 26 #define SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 27 
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGenerationCounters.hpp&quot;
 31 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 32 #include &quot;gc/parallel/spaceCounters.hpp&quot;
 33 
 34 class PSMarkSweepDecorator;
 35 
 36 class PSYoungGen : public CHeapObj&lt;mtGC&gt; {
 37   friend class VMStructs;
 38   friend class ParallelScavengeHeap;
 39   friend class AdjoiningGenerations;
 40 
 41  protected:
 42   MemRegion       _reserved;
 43   PSVirtualSpace* _virtual_space;
 44 
 45   // Spaces
 46   MutableSpace* _eden_space;
 47   MutableSpace* _from_space;
 48   MutableSpace* _to_space;
 49 
 50 
 51   // MarkSweep Decorators
 52   PSMarkSweepDecorator* _eden_mark_sweep;
 53   PSMarkSweepDecorator* _from_mark_sweep;
 54   PSMarkSweepDecorator* _to_mark_sweep;
 55 
 56   // Sizing information, in bytes, set in constructor
 57   const size_t _init_gen_size;
 58   const size_t _min_gen_size;
 59   const size_t _max_gen_size;
 60 
 61   // Performance counters
 62   PSGenerationCounters*     _gen_counters;
 63   SpaceCounters*            _eden_counters;
 64   SpaceCounters*            _from_counters;
 65   SpaceCounters*            _to_counters;
 66 
 67   // Initialize the space boundaries
 68   void compute_initial_space_boundaries();
 69 
 70   // Space boundary helper
 71   void set_space_boundaries(size_t eden_size, size_t survivor_size);
 72 
 73   virtual bool resize_generation(size_t eden_size, size_t survivor_size);
 74   virtual void resize_spaces(size_t eden_size, size_t survivor_size);
 75 
 76   // Adjust the spaces to be consistent with the virtual space.
 77   void post_resize();
 78 
 79   // Return number of bytes that the generation can change.
 80   // These should not be used by PSYoungGen
 81   virtual size_t available_for_expansion();
 82   virtual size_t available_for_contraction();
 83 
 84   // Given a desired shrinkage in the size of the young generation,
 85   // return the actual size available for shrinkage.
 86   virtual size_t limit_gen_shrink(size_t desired_change);
 87   // returns the number of bytes available from the current size
 88   // down to the minimum generation size.
 89   size_t available_to_min_gen();
 90   // Return the number of bytes available for shrinkage considering
 91   // the location the live data in the generation.
 92   virtual size_t available_to_live();
 93 
 94  public:
 95   // Initialize the generation.
 96   PSYoungGen(size_t        initial_byte_size,
 97              size_t        minimum_byte_size,
 98              size_t        maximum_byte_size);
 99   void initialize_work();
100   virtual void initialize(ReservedSpace rs, size_t alignment);
101   virtual void initialize_virtual_space(ReservedSpace rs, size_t alignment);
102 
103   MemRegion reserved() const            { return _reserved; }
104 
105   bool is_in(const void* p) const   {
106       return _virtual_space-&gt;contains((void *)p);
107   }
108 
109   bool is_in_reserved(const void* p) const   {
110       return reserved().contains((void *)p);
111   }
112 
113   MutableSpace*   eden_space() const    { return _eden_space; }
114   MutableSpace*   from_space() const    { return _from_space; }
115   MutableSpace*   to_space() const      { return _to_space; }
116   PSVirtualSpace* virtual_space() const { return _virtual_space; }
117 
118   // For Adaptive size policy
119   size_t min_gen_size() { return _min_gen_size; }
120 
121   // MarkSweep support
122   PSMarkSweepDecorator* eden_mark_sweep() const    { return _eden_mark_sweep; }
123   PSMarkSweepDecorator* from_mark_sweep() const    { return _from_mark_sweep; }
124   PSMarkSweepDecorator* to_mark_sweep() const      { return _to_mark_sweep;   }
125 
126 #if INCLUDE_SERIALGC
127   void precompact();
128   void adjust_pointers();
129   void compact();
130 #endif
131 
132   // Called during/after GC
133   void swap_spaces();
134 
135   // Resize generation using suggested free space size and survivor size
136   // NOTE:  &quot;eden_size&quot; and &quot;survivor_size&quot; are suggestions only. Current
137   //        heap layout (particularly, live objects in from space) might
138   //        not allow us to use these values.
139   void resize(size_t eden_size, size_t survivor_size);
140 
141   // Size info
142   size_t capacity_in_bytes() const;
143   size_t used_in_bytes() const;
144   size_t free_in_bytes() const;
145 
146   size_t capacity_in_words() const;
147   size_t used_in_words() const;
148   size_t free_in_words() const;
149 
150   // The max this generation can grow to
151   size_t max_size() const { return _reserved.byte_size(); }
152 
153   // The max this generation can grow to if the boundary between
154   // the generations are allowed to move.
155   size_t gen_size_limit() const { return _max_gen_size; }
156 
157   bool is_maximal_no_gc() const {
158     return true;  // Never expands except at a GC
159   }
160 
161   // Allocation
162   HeapWord* allocate(size_t word_size) {
163     HeapWord* result = eden_space()-&gt;cas_allocate(word_size);
164     return result;
165   }
166 
167   HeapWord* volatile* top_addr() const   { return eden_space()-&gt;top_addr(); }
168   HeapWord** end_addr() const   { return eden_space()-&gt;end_addr(); }
169 
170   // Iteration.
171   void oop_iterate(OopIterateClosure* cl);
172   void object_iterate(ObjectClosure* cl);
173 
174   virtual void reset_after_change();
175   virtual void reset_survivors_after_shrink();
176 
177   // Performance Counter support
178   void update_counters();
179 
180   // Debugging - do not use for time critical operations
181   void print() const;
182   void print_on(outputStream* st) const;
183   void print_used_change(size_t prev_used) const;
184   virtual const char* name() const { return &quot;PSYoungGen&quot;; }
185 
186   void verify();
187 
188   // Space boundary invariant checker
189   void space_invariants() PRODUCT_RETURN;
190 
191   // Helper for mangling survivor spaces.
192   void mangle_survivors(MutableSpace* s1,
193                         MemRegion s1MR,
194                         MutableSpace* s2,
195                         MemRegion s2MR) PRODUCT_RETURN;
196 
197   void record_spaces_top() PRODUCT_RETURN;
198 };
199 
200 #endif // SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
    </pre>
  </body>
</html>
diff a/src/hotspot/share/gc/parallel/parMarkBitMap.cpp b/src/hotspot/share/gc/parallel/parMarkBitMap.cpp
--- a/src/hotspot/share/gc/parallel/parMarkBitMap.cpp
+++ b/src/hotspot/share/gc/parallel/parMarkBitMap.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -37,11 +37,11 @@
 ParMarkBitMap::initialize(MemRegion covered_region)
 {
   const idx_t bits = bits_required(covered_region);
   // The bits will be divided evenly between two bitmaps; each of them should be
   // an integral number of words.
-  assert(bits % (BitsPerWord * 2) == 0, "region size unaligned");
+  assert(is_aligned(bits, (BitsPerWord * 2)), "region size unaligned");
 
   const size_t words = bits / BitsPerWord;
   const size_t raw_bytes = words * sizeof(idx_t);
   const size_t page_sz = os::page_size_for_region_aligned(raw_bytes, 10);
   const size_t granularity = os::vm_allocation_granularity();
@@ -88,11 +88,11 @@
   if (_beg_bits.par_set_bit(beg_bit)) {
     const idx_t end_bit = addr_to_bit(addr + size - 1);
     bool end_bit_ok = _end_bits.par_set_bit(end_bit);
     assert(end_bit_ok, "concurrency problem");
     DEBUG_ONLY(Atomic::inc(&mark_bitmap_count));
-    DEBUG_ONLY(Atomic::add(size, &mark_bitmap_size));
+    DEBUG_ONLY(Atomic::add(&mark_bitmap_size, size));
     return true;
   }
   return false;
 }
 
@@ -109,18 +109,18 @@
 }
 
 size_t
 ParMarkBitMap::live_words_in_range_helper(HeapWord* beg_addr, oop end_obj) const
 {
-  assert(beg_addr <= (HeapWord*)end_obj, "bad range");
+  assert(beg_addr <= cast_from_oop<HeapWord*>(end_obj), "bad range");
   assert(is_marked(end_obj), "end_obj must be live");
 
   idx_t live_bits = 0;
 
   // The bitmap routines require the right boundary to be word-aligned.
-  const idx_t end_bit = addr_to_bit((HeapWord*)end_obj);
-  const idx_t range_end = BitMap::word_align_up(end_bit);
+  const idx_t end_bit = addr_to_bit(cast_from_oop<HeapWord*>(end_obj));
+  const idx_t range_end = align_range_end(end_bit);
 
   idx_t beg_bit = find_obj_beg(addr_to_bit(beg_addr), range_end);
   while (beg_bit < end_bit) {
     idx_t tmp_end = find_obj_end(beg_bit, range_end);
     assert(tmp_end < end_bit, "missing end bit");
@@ -132,12 +132,12 @@
 
 size_t
 ParMarkBitMap::live_words_in_range_use_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_oop) const
 {
   HeapWord* last_beg = cm->last_query_begin();
-  HeapWord* last_obj = (HeapWord*)cm->last_query_object();
-  HeapWord* end_obj  = (HeapWord*)end_oop;
+  HeapWord* last_obj = cast_from_oop<HeapWord*>(cm->last_query_object());
+  HeapWord* end_obj  = cast_from_oop<HeapWord*>(end_oop);
 
   size_t last_ret = cm->last_query_return();
   if (end_obj > last_obj) {
     last_ret = last_ret + live_words_in_range_helper(last_obj, end_oop);
     last_obj = end_obj;
@@ -175,11 +175,11 @@
   DEBUG_ONLY(verify_bit(range_beg);)
   DEBUG_ONLY(verify_bit(range_end);)
   assert(range_beg <= range_end, "live range invalid");
 
   // The bitmap routines require the right boundary to be word-aligned.
-  const idx_t search_end = BitMap::word_align_up(range_end);
+  const idx_t search_end = align_range_end(range_end);
 
   idx_t cur_beg = find_obj_beg(range_beg, search_end);
   while (cur_beg < range_end) {
     const idx_t cur_end = find_obj_end(cur_beg, search_end);
     if (cur_end >= range_end) {
@@ -214,12 +214,12 @@
   DEBUG_ONLY(verify_bit(dead_range_end);)
   assert(range_beg <= range_end, "live range invalid");
   assert(range_end <= dead_range_end, "dead range invalid");
 
   // The bitmap routines require the right boundary to be word-aligned.
-  const idx_t live_search_end = BitMap::word_align_up(range_end);
-  const idx_t dead_search_end = BitMap::word_align_up(dead_range_end);
+  const idx_t live_search_end = align_range_end(range_end);
+  const idx_t dead_search_end = align_range_end(dead_range_end);
 
   idx_t cur_beg = range_beg;
   if (range_beg < range_end && is_unmarked(range_beg)) {
     // The range starts with dead space.  Look for the next object, then fill.
     cur_beg = find_obj_beg(range_beg + 1, dead_search_end);

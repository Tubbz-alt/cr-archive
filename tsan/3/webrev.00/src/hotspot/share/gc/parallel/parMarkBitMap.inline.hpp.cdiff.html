<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parMarkBitMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
  
  #ifndef SHARE_GC_PARALLEL_PARMARKBITMAP_INLINE_HPP
  #define SHARE_GC_PARALLEL_PARMARKBITMAP_INLINE_HPP
  
  #include &quot;gc/parallel/parMarkBitMap.hpp&quot;
<span class="line-added">+ #include &quot;utilities/align.hpp&quot;</span>
  #include &quot;utilities/bitMap.inline.hpp&quot;
  
  inline ParMarkBitMap::ParMarkBitMap():
    _region_start(NULL), _region_size(0), _beg_bits(), _end_bits(), _virtual_space(NULL), _reserved_byte_size(0)
  { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,11 ***</span>
  inline bool ParMarkBitMap::is_marked(HeapWord* addr) const {
    return is_marked(addr_to_bit(addr));
  }
  
  inline bool ParMarkBitMap::is_marked(oop obj) const {
<span class="line-modified">!   return is_marked((HeapWord*)obj);</span>
  }
  
  inline bool ParMarkBitMap::is_unmarked(idx_t bit) const {
    return !is_marked(bit);
  }
<span class="line-new-header">--- 79,11 ---</span>
  inline bool ParMarkBitMap::is_marked(HeapWord* addr) const {
    return is_marked(addr_to_bit(addr));
  }
  
  inline bool ParMarkBitMap::is_marked(oop obj) const {
<span class="line-modified">!   return is_marked(cast_from_oop&lt;HeapWord*&gt;(obj));</span>
  }
  
  inline bool ParMarkBitMap::is_unmarked(idx_t bit) const {
    return !is_marked(bit);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,23 ***</span>
                   addr_to_bit(range_beg), addr_to_bit(range_end),
                   addr_to_bit(dead_range_end));
  }
  
  inline bool ParMarkBitMap::mark_obj(oop obj, int size) {
<span class="line-modified">!   return mark_obj((HeapWord*)obj, (size_t)size);</span>
  }
  
<span class="line-modified">! inline BitMap::idx_t ParMarkBitMap::addr_to_bit(HeapWord* addr) const {</span>
    DEBUG_ONLY(verify_addr(addr);)
    return words_to_bits(pointer_delta(addr, region_start()));
  }
  
  inline HeapWord* ParMarkBitMap::bit_to_addr(idx_t bit) const {
    DEBUG_ONLY(verify_bit(bit);)
    return region_start() + bits_to_words(bit);
  }
  
  inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_beg(idx_t beg, idx_t end) const {
    return _beg_bits.get_next_one_offset_aligned_right(beg, end);
  }
  
  inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_end(idx_t beg, idx_t end) const {
<span class="line-new-header">--- 142,29 ---</span>
                   addr_to_bit(range_beg), addr_to_bit(range_end),
                   addr_to_bit(dead_range_end));
  }
  
  inline bool ParMarkBitMap::mark_obj(oop obj, int size) {
<span class="line-modified">!   return mark_obj(cast_from_oop&lt;HeapWord*&gt;(obj), (size_t)size);</span>
  }
  
<span class="line-modified">! inline ParMarkBitMap::idx_t ParMarkBitMap::addr_to_bit(HeapWord* addr) const {</span>
    DEBUG_ONLY(verify_addr(addr);)
    return words_to_bits(pointer_delta(addr, region_start()));
  }
  
  inline HeapWord* ParMarkBitMap::bit_to_addr(idx_t bit) const {
    DEBUG_ONLY(verify_bit(bit);)
    return region_start() + bits_to_words(bit);
  }
  
<span class="line-added">+ inline ParMarkBitMap::idx_t ParMarkBitMap::align_range_end(idx_t range_end) const {</span>
<span class="line-added">+   // size is aligned, so if range_end &lt;= size then so is aligned result.</span>
<span class="line-added">+   assert(range_end &lt;= size(), &quot;range end out of range&quot;);</span>
<span class="line-added">+   return align_up(range_end, BitsPerWord);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_beg(idx_t beg, idx_t end) const {
    return _beg_bits.get_next_one_offset_aligned_right(beg, end);
  }
  
  inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_end(idx_t beg, idx_t end) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,19 ***</span>
  }
  
  inline HeapWord* ParMarkBitMap::find_obj_beg(HeapWord* beg, HeapWord* end) const {
    const idx_t beg_bit = addr_to_bit(beg);
    const idx_t end_bit = addr_to_bit(end);
<span class="line-modified">!   const idx_t search_end = BitMap::word_align_up(end_bit);</span>
    const idx_t res_bit = MIN2(find_obj_beg(beg_bit, search_end), end_bit);
    return bit_to_addr(res_bit);
  }
  
  inline HeapWord* ParMarkBitMap::find_obj_end(HeapWord* beg, HeapWord* end) const {
    const idx_t beg_bit = addr_to_bit(beg);
    const idx_t end_bit = addr_to_bit(end);
<span class="line-modified">!   const idx_t search_end = BitMap::word_align_up(end_bit);</span>
    const idx_t res_bit = MIN2(find_obj_end(beg_bit, search_end), end_bit);
    return bit_to_addr(res_bit);
  }
  
  #ifdef  ASSERT
<span class="line-new-header">--- 172,19 ---</span>
  }
  
  inline HeapWord* ParMarkBitMap::find_obj_beg(HeapWord* beg, HeapWord* end) const {
    const idx_t beg_bit = addr_to_bit(beg);
    const idx_t end_bit = addr_to_bit(end);
<span class="line-modified">!   const idx_t search_end = align_range_end(end_bit);</span>
    const idx_t res_bit = MIN2(find_obj_beg(beg_bit, search_end), end_bit);
    return bit_to_addr(res_bit);
  }
  
  inline HeapWord* ParMarkBitMap::find_obj_end(HeapWord* beg, HeapWord* end) const {
    const idx_t beg_bit = addr_to_bit(beg);
    const idx_t end_bit = addr_to_bit(end);
<span class="line-modified">!   const idx_t search_end = align_range_end(end_bit);</span>
    const idx_t res_bit = MIN2(find_obj_end(beg_bit, search_end), end_bit);
    return bit_to_addr(res_bit);
  }
  
  #ifdef  ASSERT
</pre>
<center><a href="parMarkBitMap.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelArguments.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
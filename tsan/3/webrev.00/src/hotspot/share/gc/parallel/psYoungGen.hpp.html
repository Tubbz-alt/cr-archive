<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/psYoungGen.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 26 #define SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 27 
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGenerationCounters.hpp&quot;
 31 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 32 #include &quot;gc/parallel/spaceCounters.hpp&quot;
 33 
 34 class PSYoungGen : public CHeapObj&lt;mtGC&gt; {
 35   friend class VMStructs;
 36   friend class ParallelScavengeHeap;
 37   friend class AdjoiningGenerations;
 38 
 39  protected:
 40   MemRegion       _reserved;
 41   PSVirtualSpace* _virtual_space;
 42 
 43   // Spaces
 44   MutableSpace* _eden_space;
 45   MutableSpace* _from_space;
 46   MutableSpace* _to_space;
 47 
 48   // Sizing information, in bytes, set in constructor
 49   const size_t _init_gen_size;
 50   const size_t _min_gen_size;
 51   const size_t _max_gen_size;
 52 
 53   // Performance counters
 54   PSGenerationCounters*     _gen_counters;
 55   SpaceCounters*            _eden_counters;
 56   SpaceCounters*            _from_counters;
 57   SpaceCounters*            _to_counters;
 58 
 59   // Initialize the space boundaries
 60   void compute_initial_space_boundaries();
 61 
 62   // Space boundary helper
 63   void set_space_boundaries(size_t eden_size, size_t survivor_size);
 64 
 65   virtual bool resize_generation(size_t eden_size, size_t survivor_size);
 66   virtual void resize_spaces(size_t eden_size, size_t survivor_size);
 67 
 68   // Adjust the spaces to be consistent with the virtual space.
 69   void post_resize();
 70 
 71   // Return number of bytes that the generation can change.
 72   // These should not be used by PSYoungGen
 73   virtual size_t available_for_expansion();
 74   virtual size_t available_for_contraction();
 75 
 76   // Given a desired shrinkage in the size of the young generation,
 77   // return the actual size available for shrinkage.
 78   virtual size_t limit_gen_shrink(size_t desired_change);
 79   // returns the number of bytes available from the current size
 80   // down to the minimum generation size.
 81   size_t available_to_min_gen();
 82   // Return the number of bytes available for shrinkage considering
 83   // the location the live data in the generation.
 84   virtual size_t available_to_live();
 85 
 86  public:
 87   // Initialize the generation.
 88   PSYoungGen(size_t        initial_byte_size,
 89              size_t        minimum_byte_size,
 90              size_t        maximum_byte_size);
 91   void initialize_work();
 92   virtual void initialize(ReservedSpace rs, size_t alignment);
 93   virtual void initialize_virtual_space(ReservedSpace rs, size_t alignment);
 94 
 95   MemRegion reserved() const            { return _reserved; }
 96 
 97   bool is_in(const void* p) const   {
 98       return _virtual_space-&gt;contains((void *)p);
 99   }
100 
101   bool is_in_reserved(const void* p) const   {
102       return reserved().contains((void *)p);
103   }
104 
105   MutableSpace*   eden_space() const    { return _eden_space; }
106   MutableSpace*   from_space() const    { return _from_space; }
107   MutableSpace*   to_space() const      { return _to_space; }
108   PSVirtualSpace* virtual_space() const { return _virtual_space; }
109 
110   // For Adaptive size policy
111   size_t min_gen_size() { return _min_gen_size; }
112 
113   // Called during/after GC
114   void swap_spaces();
115 
116   // Resize generation using suggested free space size and survivor size
117   // NOTE:  &quot;eden_size&quot; and &quot;survivor_size&quot; are suggestions only. Current
118   //        heap layout (particularly, live objects in from space) might
119   //        not allow us to use these values.
120   void resize(size_t eden_size, size_t survivor_size);
121 
122   // Size info
123   size_t capacity_in_bytes() const;
124   size_t used_in_bytes() const;
125   size_t free_in_bytes() const;
126 
127   size_t capacity_in_words() const;
128   size_t used_in_words() const;
129   size_t free_in_words() const;
130 
131   // The max this generation can grow to
132   size_t max_size() const { return _reserved.byte_size(); }
133 
134   // The max this generation can grow to if the boundary between
135   // the generations are allowed to move.
136   size_t gen_size_limit() const { return _max_gen_size; }
137 
138   bool is_maximal_no_gc() const {
139     return true;  // Never expands except at a GC
140   }
141 
142   // Allocation
143   HeapWord* allocate(size_t word_size) {
144     HeapWord* result = eden_space()-&gt;cas_allocate(word_size);
145     return result;
146   }
147 
148   HeapWord* volatile* top_addr() const   { return eden_space()-&gt;top_addr(); }
149   HeapWord** end_addr() const   { return eden_space()-&gt;end_addr(); }
150 
151   // Iteration.
152   void oop_iterate(OopIterateClosure* cl);
153   void object_iterate(ObjectClosure* cl);
154 
155   virtual void reset_after_change();
156   virtual void reset_survivors_after_shrink();
157 
158   // Performance Counter support
159   void update_counters();
160 
161   // Debugging - do not use for time critical operations
162   void print() const;
163   void print_on(outputStream* st) const;
164   virtual const char* name() const { return &quot;PSYoungGen&quot;; }
165 
166   void verify();
167 
168   // Space boundary invariant checker
169   void space_invariants() PRODUCT_RETURN;
170 
171   // Helper for mangling survivor spaces.
172   void mangle_survivors(MutableSpace* s1,
173                         MemRegion s1MR,
174                         MutableSpace* s2,
175                         MemRegion s2MR) PRODUCT_RETURN;
176 
177   void record_spaces_top() PRODUCT_RETURN;
178 };
179 
180 #endif // SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
    </pre>
  </body>
</html>
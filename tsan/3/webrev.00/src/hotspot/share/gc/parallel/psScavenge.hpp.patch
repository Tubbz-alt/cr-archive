diff a/src/hotspot/share/gc/parallel/psScavenge.hpp b/src/hotspot/share/gc/parallel/psScavenge.hpp
--- a/src/hotspot/share/gc/parallel/psScavenge.hpp
+++ b/src/hotspot/share/gc/parallel/psScavenge.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,12 +31,10 @@
 #include "gc/shared/gcTrace.hpp"
 #include "memory/allocation.hpp"
 #include "oops/oop.hpp"
 #include "utilities/stack.hpp"
 
-class GCTaskManager;
-class GCTaskQueue;
 class OopStack;
 class ReferenceProcessor;
 class ParallelScavengeHeap;
 class ParallelScavengeTracer;
 class PSIsAliveClosure;
@@ -104,17 +102,15 @@
   static CollectorCounters* counters()           { return _counters; }
 
   static void set_subject_to_discovery_span(MemRegion mr) {
     _span_based_discoverer.set_span(mr);
   }
-  // Used by scavenge_contents && psMarkSweep
+  // Used by scavenge_contents
   static ReferenceProcessor* const reference_processor() {
     assert(_ref_processor != NULL, "Sanity");
     return _ref_processor;
   }
-  // Used to add tasks
-  static GCTaskManager* const gc_task_manager();
   // The promotion managers tell us if they encountered overflow
   static void set_survivor_overflow(bool state) {
     _survivor_overflow = state;
   }
   // Adaptive size policy support.  When the young generation/old generation
@@ -143,11 +139,11 @@
   // Is an object in the young generation
   // This assumes that the 'o' is in the heap,
   // so it only checks one side of the complete predicate.
 
   inline static bool is_obj_in_young(oop o) {
-    return (HeapWord*)o >= _young_generation_boundary;
+    return cast_from_oop<HeapWord*>(o) >= _young_generation_boundary;
   }
 
   inline static bool is_obj_in_young(narrowOop o) {
     return (uintptr_t)o >= _young_generation_boundary_compressed;
   }

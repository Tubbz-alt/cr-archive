<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/parMarkBitMap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parMarkBitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parMarkBitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parMarkBitMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
121   // Return the number of live words in the range [beg_addr, end_obj) due to
122   // objects that start in the range.  If a live object extends onto the range,
123   // the caller must detect and account for any live words due to that object.
124   // If a live object extends beyond the end of the range, only the words within
125   // the range are included in the result. The end of the range must be a live object,
126   // which is the case when updating pointers.  This allows a branch to be removed
127   // from inside the loop.
128   size_t live_words_in_range(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj) const;
129 
130   inline HeapWord* region_start() const;
131   inline HeapWord* region_end() const;
132   inline size_t    region_size() const;
133   inline size_t    size() const;
134 
135   size_t reserved_byte_size() const { return _reserved_byte_size; }
136 
137   // Convert a heap address to/from a bit index.
138   inline idx_t     addr_to_bit(HeapWord* addr) const;
139   inline HeapWord* bit_to_addr(idx_t bit) const;
140 



141   // Return the bit index of the first marked object that begins (or ends,
142   // respectively) in the range [beg, end).  If no object is found, return end.

143   inline idx_t find_obj_beg(idx_t beg, idx_t end) const;
144   inline idx_t find_obj_end(idx_t beg, idx_t end) const;
145 
146   inline HeapWord* find_obj_beg(HeapWord* beg, HeapWord* end) const;
147   inline HeapWord* find_obj_end(HeapWord* beg, HeapWord* end) const;
148 
149   // Clear a range of bits or the entire bitmap (both begin and end bits are
150   // cleared).
151   inline void clear_range(idx_t beg, idx_t end);
152 
153   // Return the number of bits required to represent the specified number of
154   // HeapWords, or the specified region.
155   static inline idx_t bits_required(size_t words);
156   static inline idx_t bits_required(MemRegion covered_region);
157 
158   void print_on_error(outputStream* st) const {
159     st-&gt;print_cr(&quot;Marking Bits: (ParMarkBitMap*) &quot; PTR_FORMAT, p2i(this));
160     _beg_bits.print_on_error(st, &quot; Begin Bits: &quot;);
161     _end_bits.print_on_error(st, &quot; End Bits:   &quot;);
162   }
</pre>
</td>
<td>
<hr />
<pre>
121   // Return the number of live words in the range [beg_addr, end_obj) due to
122   // objects that start in the range.  If a live object extends onto the range,
123   // the caller must detect and account for any live words due to that object.
124   // If a live object extends beyond the end of the range, only the words within
125   // the range are included in the result. The end of the range must be a live object,
126   // which is the case when updating pointers.  This allows a branch to be removed
127   // from inside the loop.
128   size_t live_words_in_range(ParCompactionManager* cm, HeapWord* beg_addr, oop end_obj) const;
129 
130   inline HeapWord* region_start() const;
131   inline HeapWord* region_end() const;
132   inline size_t    region_size() const;
133   inline size_t    size() const;
134 
135   size_t reserved_byte_size() const { return _reserved_byte_size; }
136 
137   // Convert a heap address to/from a bit index.
138   inline idx_t     addr_to_bit(HeapWord* addr) const;
139   inline HeapWord* bit_to_addr(idx_t bit) const;
140 
<span class="line-added">141   // Return word-aligned up range_end, which must not be greater than size().</span>
<span class="line-added">142   inline idx_t align_range_end(idx_t range_end) const;</span>
<span class="line-added">143 </span>
144   // Return the bit index of the first marked object that begins (or ends,
145   // respectively) in the range [beg, end).  If no object is found, return end.
<span class="line-added">146   // end must be word-aligned.</span>
147   inline idx_t find_obj_beg(idx_t beg, idx_t end) const;
148   inline idx_t find_obj_end(idx_t beg, idx_t end) const;
149 
150   inline HeapWord* find_obj_beg(HeapWord* beg, HeapWord* end) const;
151   inline HeapWord* find_obj_end(HeapWord* beg, HeapWord* end) const;
152 
153   // Clear a range of bits or the entire bitmap (both begin and end bits are
154   // cleared).
155   inline void clear_range(idx_t beg, idx_t end);
156 
157   // Return the number of bits required to represent the specified number of
158   // HeapWords, or the specified region.
159   static inline idx_t bits_required(size_t words);
160   static inline idx_t bits_required(MemRegion covered_region);
161 
162   void print_on_error(outputStream* st) const {
163     st-&gt;print_cr(&quot;Marking Bits: (ParMarkBitMap*) &quot; PTR_FORMAT, p2i(this));
164     _beg_bits.print_on_error(st, &quot; Begin Bits: &quot;);
165     _end_bits.print_on_error(st, &quot; End Bits:   &quot;);
166   }
</pre>
</td>
</tr>
</table>
<center><a href="parMarkBitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parMarkBitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/parallelArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parMarkBitMap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelArguments.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelArguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,34 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-removed">- #include &quot;gc/parallel/heterogeneousGenerationSizer.hpp&quot;</span>
  #include &quot;gc/parallel/parallelArguments.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/shared/gcArguments.inline.hpp&quot;</span>
  #include &quot;gc/shared/workerPolicy.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  
  size_t ParallelArguments::conservative_max_heap_alignment() {
<span class="line-modified">!   return CollectorPolicy::compute_heap_alignment();</span>
  }
  
  void ParallelArguments::initialize() {
    GCArguments::initialize();
<span class="line-modified">!   assert(UseParallelGC || UseParallelOldGC, &quot;Error&quot;);</span>
<span class="line-removed">-   // Enable ParallelOld unless it was explicitly disabled (cmd line or rc file).</span>
<span class="line-removed">-   if (FLAG_IS_DEFAULT(UseParallelOldGC)) {</span>
<span class="line-removed">-     FLAG_SET_DEFAULT(UseParallelOldGC, true);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   FLAG_SET_DEFAULT(UseParallelGC, true);</span>
  
    // If no heap maximum was requested explicitly, use some reasonable fraction
    // of the physical memory, up to a maximum of 1GB.
    FLAG_SET_DEFAULT(ParallelGCThreads,
                     WorkerPolicy::parallel_worker_threads());
<span class="line-new-header">--- 22,32 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/parallelArguments.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/gcArguments.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/shared/genArguments.hpp&quot;</span>
  #include &quot;gc/shared/workerPolicy.hpp&quot;
<span class="line-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const double MaxRamFractionForYoung = 0.8;</span>
  
  size_t ParallelArguments::conservative_max_heap_alignment() {
<span class="line-modified">!   return compute_heap_alignment();</span>
  }
  
  void ParallelArguments::initialize() {
    GCArguments::initialize();
<span class="line-modified">!   assert(UseParallelGC, &quot;Error&quot;);</span>
  
    // If no heap maximum was requested explicitly, use some reasonable fraction
    // of the physical memory, up to a maximum of 1GB.
    FLAG_SET_DEFAULT(ParallelGCThreads,
                     WorkerPolicy::parallel_worker_threads());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,22 ***</span>
      if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
        FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
      }
    }
  
<span class="line-modified">!   if (UseParallelOldGC) {</span>
<span class="line-modified">!     // Par compact uses lower default values since they are treated as</span>
<span class="line-modified">!     // minimums.  These are different defaults because of the different</span>
<span class="line-modified">!     // interpretation and are not ergonomically set.</span>
<span class="line-modified">!     if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {</span>
<span class="line-removed">-       FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);</span>
<span class="line-removed">-     }</span>
    }
  }
  
<span class="line-modified">! CollectedHeap* ParallelArguments::create_heap() {</span>
<span class="line-modified">!   if (AllocateOldGenAt != NULL) {</span>
<span class="line-modified">!     return create_heap_with_policy&lt;ParallelScavengeHeap, HeterogeneousGenerationSizer&gt;();</span>
    } else {
<span class="line-modified">!     return create_heap_with_policy&lt;ParallelScavengeHeap, GenerationSizer&gt;();</span>
    }
  }
<span class="line-new-header">--- 79,139 ---</span>
      if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
        FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
      }
    }
  
<span class="line-modified">!   // Par compact uses lower default values since they are treated as</span>
<span class="line-modified">!   // minimums.  These are different defaults because of the different</span>
<span class="line-modified">!   // interpretation and are not ergonomically set.</span>
<span class="line-modified">!   if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {</span>
<span class="line-modified">!     FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);</span>
    }
  }
  
<span class="line-modified">! // The alignment used for boundary between young gen and old gen</span>
<span class="line-modified">! static size_t default_gen_alignment() {</span>
<span class="line-modified">!   return 64 * K * HeapWordSize;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParallelArguments::initialize_alignments() {</span>
<span class="line-added">+   SpaceAlignment = GenAlignment = default_gen_alignment();</span>
<span class="line-added">+   HeapAlignment = compute_heap_alignment();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParallelArguments::initialize_heap_flags_and_sizes_one_pass() {</span>
<span class="line-added">+   // Do basic sizing work</span>
<span class="line-added">+   GenArguments::initialize_heap_flags_and_sizes();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The survivor ratio&#39;s are calculated &quot;raw&quot;, unlike the</span>
<span class="line-added">+   // default gc, which adds 2 to the ratio value. We need to</span>
<span class="line-added">+   // make sure the values are valid before using them.</span>
<span class="line-added">+   if (MinSurvivorRatio &lt; 3) {</span>
<span class="line-added">+     FLAG_SET_ERGO(MinSurvivorRatio, 3);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (InitialSurvivorRatio &lt; 3) {</span>
<span class="line-added">+     FLAG_SET_ERGO(InitialSurvivorRatio, 3);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParallelArguments::initialize_heap_flags_and_sizes() {</span>
<span class="line-added">+   if (is_heterogeneous_heap()) {</span>
<span class="line-added">+     initialize_heterogeneous();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   initialize_heap_flags_and_sizes_one_pass();</span>
<span class="line-added">+ </span>
<span class="line-added">+   const size_t max_page_sz = os::page_size_for_region_aligned(MaxHeapSize, 8);</span>
<span class="line-added">+   const size_t min_pages = 4; // 1 for eden + 1 for each survivor + 1 for old</span>
<span class="line-added">+   const size_t min_page_sz = os::page_size_for_region_aligned(MinHeapSize, min_pages);</span>
<span class="line-added">+   const size_t page_sz = MIN2(max_page_sz, min_page_sz);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Can a page size be something else than a power of two?</span>
<span class="line-added">+   assert(is_power_of_2((intptr_t)page_sz), &quot;must be a power of 2&quot;);</span>
<span class="line-added">+   size_t new_alignment = align_up(page_sz, GenAlignment);</span>
<span class="line-added">+   if (new_alignment != GenAlignment) {</span>
<span class="line-added">+     GenAlignment = new_alignment;</span>
<span class="line-added">+     SpaceAlignment = new_alignment;</span>
<span class="line-added">+     // Redo everything from the start</span>
<span class="line-added">+     initialize_heap_flags_and_sizes_one_pass();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Check the available dram memory to limit NewSize and MaxNewSize before</span>
<span class="line-added">+ // calling base class initialize_flags().</span>
<span class="line-added">+ void ParallelArguments::initialize_heterogeneous() {</span>
<span class="line-added">+   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   julong phys_mem;</span>
<span class="line-added">+   // If MaxRam is specified, we use that as maximum physical memory available.</span>
<span class="line-added">+   if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="line-added">+     phys_mem = os::physical_memory();</span>
<span class="line-added">+     calc_str.append(&quot;Physical_Memory&quot;);</span>
    } else {
<span class="line-modified">!     phys_mem = (julong)MaxRAM;</span>
<span class="line-added">+     calc_str.append(&quot;MaxRAM&quot;);</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   julong reasonable_max = phys_mem;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate</span>
<span class="line-added">+   // reasonable max size of young generation.</span>
<span class="line-added">+   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {</span>
<span class="line-added">+     reasonable_max = (julong)(phys_mem / MaxRAMFraction);</span>
<span class="line-added">+     calc_str.append(&quot; / MaxRAMFraction&quot;);</span>
<span class="line-added">+   } else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {</span>
<span class="line-added">+     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);</span>
<span class="line-added">+     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // We use our own fraction to calculate max size of young generation.</span>
<span class="line-added">+     reasonable_max = phys_mem * MaxRamFractionForYoung;</span>
<span class="line-added">+     calc_str.append(&quot; * %0.2f&quot;, MaxRamFractionForYoung);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   reasonable_max = align_up(reasonable_max, GenAlignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (MaxNewSize &gt; reasonable_max) {</span>
<span class="line-added">+     if (FLAG_IS_CMDLINE(MaxNewSize)) {</span>
<span class="line-added">+       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">+                             (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;</span>
<span class="line-added">+                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     MaxNewSize = reasonable_max;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (NewSize &gt; reasonable_max) {</span>
<span class="line-added">+     if (FLAG_IS_CMDLINE(NewSize)) {</span>
<span class="line-added">+       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">+                             (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     NewSize = reasonable_max;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool ParallelArguments::is_heterogeneous_heap() {</span>
<span class="line-added">+   return AllocateOldGenAt != NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ParallelArguments::heap_reserved_size_bytes() {</span>
<span class="line-added">+   if (!is_heterogeneous_heap() || !UseAdaptiveGCBoundary) {</span>
<span class="line-added">+     return MaxHeapSize;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Heterogeneous heap and adaptive size gc boundary</span>
<span class="line-added">+ </span>
<span class="line-added">+   // This is the size that young gen can grow to, when UseAdaptiveGCBoundary is true.</span>
<span class="line-added">+   size_t max_yg_size = MaxHeapSize - MinOldSize;</span>
<span class="line-added">+   // This is the size that old gen can grow to, when UseAdaptiveGCBoundary is true.</span>
<span class="line-added">+   size_t max_old_size = MaxHeapSize - MinNewSize;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return max_yg_size + max_old_size;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ParallelArguments::heap_max_size_bytes() {</span>
<span class="line-added">+   return MaxHeapSize;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CollectedHeap* ParallelArguments::create_heap() {</span>
<span class="line-added">+   return new ParallelScavengeHeap();</span>
  }
</pre>
<center><a href="parMarkBitMap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelArguments.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
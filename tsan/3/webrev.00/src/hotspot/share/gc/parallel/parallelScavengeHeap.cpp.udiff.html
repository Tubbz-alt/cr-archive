<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelArguments.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,27 +25,29 @@</span>
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
  #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>
  #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/parallel/psMarkSweepProxy.hpp&quot;</span>
  #include &quot;gc/parallel/psMemoryPool.hpp&quot;
  #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  #include &quot;gc/parallel/psPromotionManager.hpp&quot;
  #include &quot;gc/parallel/psScavenge.hpp&quot;
  #include &quot;gc/parallel/psVMOperations.hpp&quot;
  #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
  #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/metaspaceCounters.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;services/memoryManager.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55,27 +57,26 @@</span>
  
  PSYoungGen*  ParallelScavengeHeap::_young_gen = NULL;
  PSOldGen*    ParallelScavengeHeap::_old_gen = NULL;
  PSAdaptiveSizePolicy* ParallelScavengeHeap::_size_policy = NULL;
  PSGCAdaptivePolicyCounters* ParallelScavengeHeap::_gc_policy_counters = NULL;
<span class="udiff-line-removed">- GCTaskManager* ParallelScavengeHeap::_gc_task_manager = NULL;</span>
  
  jint ParallelScavengeHeap::initialize() {
<span class="udiff-line-modified-removed">-   size_t heap_size = _collector_policy-&gt;heap_reserved_size_bytes();</span>
<span class="udiff-line-modified-added">+   const size_t reserved_heap_size = ParallelArguments::heap_reserved_size_bytes();</span>
  
<span class="udiff-line-modified-removed">-   ReservedSpace heap_rs = Universe::reserve_heap(heap_size, _collector_policy-&gt;heap_alignment());</span>
<span class="udiff-line-modified-added">+   ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment);</span>
  
    os::trace_page_sizes(&quot;Heap&quot;,
<span class="udiff-line-modified-removed">-                        _collector_policy-&gt;min_heap_byte_size(),</span>
<span class="udiff-line-modified-removed">-                        heap_size,</span>
<span class="udiff-line-modified-removed">-                        generation_alignment(),</span>
<span class="udiff-line-modified-added">+                        MinHeapSize,</span>
<span class="udiff-line-modified-added">+                        reserved_heap_size,</span>
<span class="udiff-line-modified-added">+                        GenAlignment,</span>
                         heap_rs.base(),
                         heap_rs.size());
  
<span class="udiff-line-modified-removed">-   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size()));</span>
<span class="udiff-line-modified-added">+   initialize_reserved_region(heap_rs);</span>
  
<span class="udiff-line-modified-removed">-   PSCardTable* card_table = new PSCardTable(reserved_region());</span>
<span class="udiff-line-modified-added">+   PSCardTable* card_table = new PSCardTable(heap_rs.region());</span>
    card_table-&gt;initialize();
    CardTableBarrierSet* const barrier_set = new CardTableBarrierSet(card_table);
    barrier_set-&gt;initialize();
    BarrierSet::set_barrier_set(barrier_set);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,11 +87,11 @@</span>
    // size of the generation as the boundaries currently stand.
    // _max_gen_size is still used as that value.
    double max_gc_pause_sec = ((double) MaxGCPauseMillis)/1000.0;
    double max_gc_minor_pause_sec = ((double) MaxGCMinorPauseMillis)/1000.0;
  
<span class="udiff-line-modified-removed">-   _gens = AdjoiningGenerations::create_adjoining_generations(heap_rs, _collector_policy, generation_alignment());</span>
<span class="udiff-line-modified-added">+   _gens = AdjoiningGenerations::create_adjoining_generations(heap_rs);</span>
  
    _old_gen = _gens-&gt;old_gen();
    _young_gen = _gens-&gt;young_gen();
  
    const size_t eden_capacity = _young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98,31 +99,31 @@</span>
    const size_t initial_promo_size = MIN2(eden_capacity, old_capacity);
    _size_policy =
      new PSAdaptiveSizePolicy(eden_capacity,
                               initial_promo_size,
                               young_gen()-&gt;to_space()-&gt;capacity_in_bytes(),
<span class="udiff-line-modified-removed">-                              _collector_policy-&gt;gen_alignment(),</span>
<span class="udiff-line-modified-added">+                              GenAlignment,</span>
                               max_gc_pause_sec,
                               max_gc_minor_pause_sec,
                               GCTimeRatio
                               );
  
<span class="udiff-line-modified-removed">-   assert(_collector_policy-&gt;is_hetero_heap() || !UseAdaptiveGCBoundary ||</span>
<span class="udiff-line-modified-added">+   assert(ParallelArguments::is_heterogeneous_heap() || !UseAdaptiveGCBoundary ||</span>
      (old_gen()-&gt;virtual_space()-&gt;high_boundary() ==
       young_gen()-&gt;virtual_space()-&gt;low_boundary()),
      &quot;Boundaries must meet&quot;);
    // initialize the policy counters - 2 collectors, 2 generations
    _gc_policy_counters =
      new PSGCAdaptivePolicyCounters(&quot;ParScav:MSC&quot;, 2, 2, _size_policy);
  
<span class="udiff-line-modified-removed">-   // Set up the GCTaskManager</span>
<span class="udiff-line-removed">-   _gc_task_manager = GCTaskManager::create(ParallelGCThreads);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (UseParallelOldGC &amp;&amp; !PSParallelCompact::initialize()) {</span>
<span class="udiff-line-modified-added">+   if (!PSParallelCompact::initialize()) {</span>
      return JNI_ENOMEM;
    }
  
<span class="udiff-line-added">+   // Set up WorkGang</span>
<span class="udiff-line-added">+   _workers.initialize_workers();</span>
<span class="udiff-line-added">+ </span>
    return JNI_OK;
  }
  
  void ParallelScavengeHeap::initialize_serviceability() {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,15 +162,11 @@</span>
  
  void ParallelScavengeHeap::post_initialize() {
    CollectedHeap::post_initialize();
    // Need to init the tenuring threshold
    PSScavenge::initialize();
<span class="udiff-line-modified-removed">-   if (UseParallelOldGC) {</span>
<span class="udiff-line-removed">-     PSParallelCompact::post_initialize();</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     PSMarkSweepProxy::initialize();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   PSParallelCompact::post_initialize();</span>
    PSPromotionManager::initialize();
  
    ScavengableNMethods::initialize(&amp;_is_scavengable);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -410,19 +407,15 @@</span>
    }
    return NULL;
  }
  
  void ParallelScavengeHeap::do_full_collection(bool clear_all_soft_refs) {
<span class="udiff-line-modified-removed">-   if (UseParallelOldGC) {</span>
<span class="udiff-line-modified-removed">-     // The do_full_collection() parameter clear_all_soft_refs</span>
<span class="udiff-line-modified-removed">-     // is interpreted here as maximum_compaction which will</span>
<span class="udiff-line-modified-removed">-     // cause SoftRefs to be cleared.</span>
<span class="udiff-line-modified-removed">-     bool maximum_compaction = clear_all_soft_refs;</span>
<span class="udiff-line-removed">-     PSParallelCompact::invoke(maximum_compaction);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     PSMarkSweepProxy::invoke(clear_all_soft_refs);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // The do_full_collection() parameter clear_all_soft_refs</span>
<span class="udiff-line-modified-added">+   // is interpreted here as maximum_compaction which will</span>
<span class="udiff-line-modified-added">+   // cause SoftRefs to be cleared.</span>
<span class="udiff-line-modified-added">+   bool maximum_compaction = clear_all_soft_refs;</span>
<span class="udiff-line-modified-added">+   PSParallelCompact::invoke(maximum_compaction);</span>
  }
  
  // Failed allocation policy. Must be called from the VM thread, and
  // only at a safepoint! Note that this method has policy for allocation
  // flow, and NOT collection policy. So we do not check for gc collection
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -516,10 +509,14 @@</span>
      // This value is guarded by the Heap_lock
      gc_count      = total_collections();
      full_gc_count = total_full_collections();
    }
  
<span class="udiff-line-added">+   if (GCLocker::should_discard(cause, gc_count)) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);
    VMThread::execute(&amp;op);
  }
  
  void ParallelScavengeHeap::object_iterate(ObjectClosure* cl) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -546,13 +543,11 @@</span>
  bool ParallelScavengeHeap::block_is_obj(const HeapWord* addr) const {
    return block_start(addr) == addr;
  }
  
  jlong ParallelScavengeHeap::millis_since_last_gc() {
<span class="udiff-line-modified-removed">-   return UseParallelOldGC ?</span>
<span class="udiff-line-removed">-     PSParallelCompact::millis_since_last_gc() :</span>
<span class="udiff-line-removed">-     PSMarkSweepProxy::millis_since_last_gc();</span>
<span class="udiff-line-modified-added">+   return PSParallelCompact::millis_since_last_gc();</span>
  }
  
  void ParallelScavengeHeap::prepare_for_verify() {
    ensure_parsability(false);  // no need to retire TLABs for verification
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -578,41 +573,90 @@</span>
  
    VirtualSpaceSummary heap_summary = create_heap_space_summary();
    return PSHeapSummary(heap_summary, used(), old_summary, old_space, young_summary, eden_space, from_space, to_space);
  }
  
<span class="udiff-line-added">+ bool ParallelScavengeHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="udiff-line-added">+   return BlockLocationPrinter&lt;ParallelScavengeHeap&gt;::print_location(st, addr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void ParallelScavengeHeap::print_on(outputStream* st) const {
    young_gen()-&gt;print_on(st);
    old_gen()-&gt;print_on(st);
    MetaspaceUtils::print_on(st);
  }
  
  void ParallelScavengeHeap::print_on_error(outputStream* st) const {
    this-&gt;CollectedHeap::print_on_error(st);
  
<span class="udiff-line-modified-removed">-   if (UseParallelOldGC) {</span>
<span class="udiff-line-modified-removed">-     st-&gt;cr();</span>
<span class="udiff-line-removed">-     PSParallelCompact::print_on_error(st);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   st-&gt;cr();</span>
<span class="udiff-line-modified-added">+   PSParallelCompact::print_on_error(st);</span>
  }
  
  void ParallelScavengeHeap::gc_threads_do(ThreadClosure* tc) const {
<span class="udiff-line-modified-removed">-   PSScavenge::gc_task_manager()-&gt;threads_do(tc);</span>
<span class="udiff-line-modified-added">+   ParallelScavengeHeap::heap()-&gt;workers().threads_do(tc);</span>
  }
  
  void ParallelScavengeHeap::print_gc_threads_on(outputStream* st) const {
<span class="udiff-line-modified-removed">-   PSScavenge::gc_task_manager()-&gt;print_threads_on(st);</span>
<span class="udiff-line-modified-added">+   ParallelScavengeHeap::heap()-&gt;workers().print_worker_threads_on(st);</span>
  }
  
  void ParallelScavengeHeap::print_tracing_info() const {
    AdaptiveSizePolicyOutput::print();
    log_debug(gc, heap, exit)(&quot;Accumulated young generation GC time %3.7f secs&quot;, PSScavenge::accumulated_time()-&gt;seconds());
<span class="udiff-line-modified-removed">-   log_debug(gc, heap, exit)(&quot;Accumulated old generation GC time %3.7f secs&quot;,</span>
<span class="udiff-line-modified-removed">-       UseParallelOldGC ? PSParallelCompact::accumulated_time()-&gt;seconds() : PSMarkSweepProxy::accumulated_time()-&gt;seconds());</span>
<span class="udiff-line-modified-added">+   log_debug(gc, heap, exit)(&quot;Accumulated old generation GC time %3.7f secs&quot;, PSParallelCompact::accumulated_time()-&gt;seconds());</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ PreGenGCValues ParallelScavengeHeap::get_pre_gc_values() const {</span>
<span class="udiff-line-added">+   const PSYoungGen* const young = young_gen();</span>
<span class="udiff-line-added">+   const MutableSpace* const eden = young-&gt;eden_space();</span>
<span class="udiff-line-added">+   const MutableSpace* const from = young-&gt;from_space();</span>
<span class="udiff-line-added">+   const PSOldGen* const old = old_gen();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return PreGenGCValues(young-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                         young-&gt;capacity_in_bytes(),</span>
<span class="udiff-line-added">+                         eden-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                         eden-&gt;capacity_in_bytes(),</span>
<span class="udiff-line-added">+                         from-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                         from-&gt;capacity_in_bytes(),</span>
<span class="udiff-line-added">+                         old-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                         old-&gt;capacity_in_bytes());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ParallelScavengeHeap::print_heap_change(const PreGenGCValues&amp; pre_gc_values) const {</span>
<span class="udiff-line-added">+   const PSYoungGen* const young = young_gen();</span>
<span class="udiff-line-added">+   const MutableSpace* const eden = young-&gt;eden_space();</span>
<span class="udiff-line-added">+   const MutableSpace* const from = young-&gt;from_space();</span>
<span class="udiff-line-added">+   const PSOldGen* const old = old_gen();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   log_info(gc, heap)(HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT,</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(young-&gt;name(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.young_gen_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.young_gen_capacity(),</span>
<span class="udiff-line-added">+                                              young-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                                              young-&gt;capacity_in_bytes()),</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(&quot;Eden&quot;,</span>
<span class="udiff-line-added">+                                              pre_gc_values.eden_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.eden_capacity(),</span>
<span class="udiff-line-added">+                                              eden-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                                              eden-&gt;capacity_in_bytes()),</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(&quot;From&quot;,</span>
<span class="udiff-line-added">+                                              pre_gc_values.from_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.from_capacity(),</span>
<span class="udiff-line-added">+                                              from-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                                              from-&gt;capacity_in_bytes()));</span>
<span class="udiff-line-added">+   log_info(gc, heap)(HEAP_CHANGE_FORMAT,</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(old-&gt;name(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.old_gen_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.old_gen_capacity(),</span>
<span class="udiff-line-added">+                                              old-&gt;used_in_bytes(),</span>
<span class="udiff-line-added">+                                              old-&gt;capacity_in_bytes()));</span>
<span class="udiff-line-added">+   MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());</span>
  }
  
<span class="udiff-line-removed">- </span>
  void ParallelScavengeHeap::verify(VerifyOption option /* ignored */) {
    // Why do we need the total_collections()-filter below?
    if (total_collections() &gt; 0) {
      log_debug(gc, verify)(&quot;Tenured&quot;);
      old_gen()-&gt;verify();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -715,14 +759,14 @@</span>
  void ParallelScavengeHeap::verify_nmethod(nmethod* nm) {
    ScavengableNMethods::verify_nmethod(nm);
  }
  
  void ParallelScavengeHeap::flush_nmethod(nmethod* nm) {
<span class="udiff-line-modified-removed">-   ScavengableNMethods::flush_nmethod(nm);</span>
<span class="udiff-line-modified-added">+   // nothing particular</span>
  }
  
<span class="udiff-line-modified-removed">- void ParallelScavengeHeap::prune_nmethods() {</span>
<span class="udiff-line-modified-added">+ void ParallelScavengeHeap::prune_scavengable_nmethods() {</span>
    ScavengableNMethods::prune_nmethods();
  }
  
  GrowableArray&lt;GCMemoryManager*&gt; ParallelScavengeHeap::memory_managers() {
    GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
</pre>
<center><a href="parallelArguments.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
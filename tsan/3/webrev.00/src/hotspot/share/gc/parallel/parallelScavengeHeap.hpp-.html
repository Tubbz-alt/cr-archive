<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 26 #define SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 27 
 28 #include &quot;gc/parallel/generationSizer.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGCAdaptivePolicyCounters.hpp&quot;
 31 #include &quot;gc/parallel/psOldGen.hpp&quot;
 32 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
 35 #include &quot;gc/shared/collectorPolicy.hpp&quot;
 36 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
 37 #include &quot;gc/shared/gcWhen.hpp&quot;
 38 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 39 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 40 #include &quot;memory/metaspace.hpp&quot;
 41 #include &quot;utilities/growableArray.hpp&quot;
 42 #include &quot;utilities/ostream.hpp&quot;
 43 
 44 class AdjoiningGenerations;
 45 class GCHeapSummary;
 46 class GCTaskManager;
 47 class MemoryManager;
 48 class MemoryPool;
 49 class PSAdaptiveSizePolicy;
 50 class PSCardTable;
 51 class PSHeapSummary;
 52 
 53 class ParallelScavengeHeap : public CollectedHeap {
 54   friend class VMStructs;
 55  private:
 56   static PSYoungGen* _young_gen;
 57   static PSOldGen*   _old_gen;
 58 
 59   // Sizing policy for entire heap
 60   static PSAdaptiveSizePolicy*       _size_policy;
 61   static PSGCAdaptivePolicyCounters* _gc_policy_counters;
 62 
 63   GenerationSizer* _collector_policy;
 64 
 65   SoftRefPolicy _soft_ref_policy;
 66 
 67   // Collection of generations that are adjacent in the
 68   // space reserved for the heap.
 69   AdjoiningGenerations* _gens;
 70   unsigned int _death_march_count;
 71 
 72   // The task manager
 73   static GCTaskManager* _gc_task_manager;
 74 
 75   GCMemoryManager* _young_manager;
 76   GCMemoryManager* _old_manager;
 77 
 78   MemoryPool* _eden_pool;
 79   MemoryPool* _survivor_pool;
 80   MemoryPool* _old_pool;
 81 
 82   virtual void initialize_serviceability();
 83 
 84   void trace_heap(GCWhen::Type when, const GCTracer* tracer);
 85 
 86  protected:
 87   static inline size_t total_invocations();
 88   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
 89 
 90   inline bool should_alloc_in_eden(size_t size) const;
 91   inline void death_march_check(HeapWord* const result, size_t size);
 92   HeapWord* mem_allocate_old_gen(size_t size);
 93 
 94  public:
 95   ParallelScavengeHeap(GenerationSizer* policy) :
 96     CollectedHeap(), _collector_policy(policy), _death_march_count(0) { }
 97 
 98   // For use by VM operations
 99   enum CollectionType {
100     Scavenge,
101     MarkSweep
102   };
103 
104   virtual Name kind() const {
105     return CollectedHeap::Parallel;
106   }
107 
108   virtual const char* name() const {
109     return &quot;Parallel&quot;;
110   }
111 
112   virtual CollectorPolicy* collector_policy() const { return _collector_policy; }
113 
114   virtual GenerationSizer* ps_collector_policy() const { return _collector_policy; }
115 
116   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
117 
118   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
119   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
120 
121   static PSYoungGen* young_gen() { return _young_gen; }
122   static PSOldGen* old_gen()     { return _old_gen; }
123 
124   virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }
125 
126   static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
127 
128   static ParallelScavengeHeap* heap();
129 
130   static GCTaskManager* const gc_task_manager() { return _gc_task_manager; }
131 
132   CardTableBarrierSet* barrier_set();
133   PSCardTable* card_table();
134 
135   AdjoiningGenerations* gens() { return _gens; }
136 
137   // Returns JNI_OK on success
138   virtual jint initialize();
139 
140   void post_initialize();
141   void update_counters();
142 
143   // The alignment used for the various areas
144   size_t space_alignment()      { return _collector_policy-&gt;space_alignment(); }
145   size_t generation_alignment() { return _collector_policy-&gt;gen_alignment(); }
146 
147   // Return the (conservative) maximum heap alignment
148   static size_t conservative_max_heap_alignment() {
149     return CollectorPolicy::compute_heap_alignment();
150   }
151 
152   size_t capacity() const;
153   size_t used() const;
154 
155   // Return &quot;true&quot; if all generations have reached the
156   // maximal committed limit that they can reach, without a garbage
157   // collection.
158   virtual bool is_maximal_no_gc() const;
159 
160   virtual void register_nmethod(nmethod* nm);
161   virtual void unregister_nmethod(nmethod* nm);
162   virtual void verify_nmethod(nmethod* nm);
163   virtual void flush_nmethod(nmethod* nm);
164 
165   void prune_nmethods();
166 
167   size_t max_capacity() const;
168 
169   // Whether p is in the allocated part of the heap
170   bool is_in(const void* p) const;
171 
172   bool is_in_reserved(const void* p) const;
173 
174   bool is_in_young(oop p);  // reserved part
175   bool is_in_old(oop p);    // reserved part
176 
177   // Memory allocation.   &quot;gc_time_limit_was_exceeded&quot; will
178   // be set to true if the adaptive size policy determine that
179   // an excessive amount of time is being spent doing collections
180   // and caused a NULL to be returned.  If a NULL is not returned,
181   // &quot;gc_time_limit_was_exceeded&quot; has an undefined meaning.
182   HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);
183 
184   // Allocation attempt(s) during a safepoint. It should never be called
185   // to allocate a new TLAB as this allocation might be satisfied out
186   // of the old generation.
187   HeapWord* failed_mem_allocate(size_t size);
188 
189   // Support for System.gc()
190   void collect(GCCause::Cause cause);
191 
192   // These also should be called by the vm thread at a safepoint (e.g., from a
193   // VM operation).
194   //
195   // The first collects the young generation only, unless the scavenge fails; it
196   // will then attempt a full gc.  The second collects the entire heap; if
197   // maximum_compaction is true, it will compact everything and clear all soft
198   // references.
199   inline void invoke_scavenge();
200 
201   // Perform a full collection
202   virtual void do_full_collection(bool clear_all_soft_refs);
203 
204   bool supports_inline_contig_alloc() const { return !UseNUMA; }
205 
206   HeapWord* volatile* top_addr() const { return !UseNUMA ? young_gen()-&gt;top_addr() : (HeapWord* volatile*)-1; }
207   HeapWord** end_addr() const { return !UseNUMA ? young_gen()-&gt;end_addr() : (HeapWord**)-1; }
208 
209   void ensure_parsability(bool retire_tlabs);
210   void resize_all_tlabs();
211 
212   bool supports_tlab_allocation() const { return true; }
213 
214   size_t tlab_capacity(Thread* thr) const;
215   size_t tlab_used(Thread* thr) const;
216   size_t unsafe_max_tlab_alloc(Thread* thr) const;
217 
218   void object_iterate(ObjectClosure* cl);
219   void safe_object_iterate(ObjectClosure* cl) { object_iterate(cl); }
220 
221   HeapWord* block_start(const void* addr) const;
222   bool block_is_obj(const HeapWord* addr) const;
223 
224   jlong millis_since_last_gc();
225 
226   void prepare_for_verify();
227   PSHeapSummary create_ps_heap_summary();
228   virtual void print_on(outputStream* st) const;
229   virtual void print_on_error(outputStream* st) const;
230   virtual void print_gc_threads_on(outputStream* st) const;
231   virtual void gc_threads_do(ThreadClosure* tc) const;
232   virtual void print_tracing_info() const;
233 
234   void verify(VerifyOption option /* ignored */);
235 
236   // Resize the young generation.  The reserved space for the
237   // generation may be expanded in preparation for the resize.
238   void resize_young_gen(size_t eden_size, size_t survivor_size);
239 
240   // Resize the old generation.  The reserved space for the
241   // generation may be expanded in preparation for the resize.
242   void resize_old_gen(size_t desired_free_space);
243 
244   // Save the tops of the spaces in all generations
245   void record_gen_tops_before_GC() PRODUCT_RETURN;
246 
247   // Mangle the unused parts of all spaces in the heap
248   void gen_mangle_unused_area() PRODUCT_RETURN;
249 
250   // Call these in sequential code around the processing of strong roots.
251   class ParStrongRootsScope : public MarkScope {
252    public:
253     ParStrongRootsScope();
254     ~ParStrongRootsScope();
255   };
256 
257   GCMemoryManager* old_gc_manager() const { return _old_manager; }
258   GCMemoryManager* young_gc_manager() const { return _young_manager; }
259 };
260 
261 // Simple class for storing info about the heap at the start of GC, to be used
262 // after GC for comparison/printing.
263 class PreGCValues {
264 public:
265   PreGCValues(ParallelScavengeHeap* heap) :
266       _heap_used(heap-&gt;used()),
267       _young_gen_used(heap-&gt;young_gen()-&gt;used_in_bytes()),
268       _old_gen_used(heap-&gt;old_gen()-&gt;used_in_bytes()),
269       _metadata_used(MetaspaceUtils::used_bytes()) { };
270 
271   size_t heap_used() const      { return _heap_used; }
272   size_t young_gen_used() const { return _young_gen_used; }
273   size_t old_gen_used() const   { return _old_gen_used; }
274   size_t metadata_used() const  { return _metadata_used; }
275 
276 private:
277   size_t _heap_used;
278   size_t _young_gen_used;
279   size_t _old_gen_used;
280   size_t _metadata_used;
281 };
282 
283 // Class that can be used to print information about the
284 // adaptive size policy at intervals specified by
285 // AdaptiveSizePolicyOutputInterval.  Only print information
286 // if an adaptive size policy is in use.
287 class AdaptiveSizePolicyOutput : AllStatic {
288   static bool enabled() {
289     return UseParallelGC &amp;&amp;
290            UseAdaptiveSizePolicy &amp;&amp;
291            log_is_enabled(Debug, gc, ergo);
292   }
293  public:
294   static void print() {
295     if (enabled()) {
296       ParallelScavengeHeap::heap()-&gt;size_policy()-&gt;print();
297     }
298   }
299 
300   static void print(AdaptiveSizePolicy* size_policy, uint count) {
301     bool do_print =
302         enabled() &amp;&amp;
303         (AdaptiveSizePolicyOutputInterval &gt; 0) &amp;&amp;
304         (count % AdaptiveSizePolicyOutputInterval) == 0;
305 
306     if (do_print) {
307       size_policy-&gt;print();
308     }
309   }
310 };
311 
312 #endif // SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
    </pre>
  </body>
</html>
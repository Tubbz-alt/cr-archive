<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psCompactionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psCompactionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psCompactionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 26 #define SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 27 

 28 #include &quot;gc/shared/taskqueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/stack.hpp&quot;
 31 
 32 class MutableSpace;
 33 class PSOldGen;
 34 class ParCompactionManager;
 35 class ObjectStartArray;
 36 class ParallelCompactData;
 37 class ParMarkBitMap;
 38 
 39 class ParCompactionManager : public CHeapObj&lt;mtGC&gt; {
<span class="line-removed"> 40   friend class ParallelTaskTerminator;</span>
 41   friend class ParMarkBitMap;
 42   friend class PSParallelCompact;
 43   friend class CompactionWithStealingTask;
 44   friend class UpdateAndFillClosure;
 45   friend class RefProcTaskExecutor;
<span class="line-modified"> 46   friend class IdleGCTask;</span>


 47 
 48  public:
 49 
<span class="line-removed"> 50 // ------------------------  Don&#39;t putback if not needed</span>
<span class="line-removed"> 51   // Actions that the compaction manager should take.</span>
<span class="line-removed"> 52   enum Action {</span>
<span class="line-removed"> 53     Update,</span>
<span class="line-removed"> 54     Copy,</span>
<span class="line-removed"> 55     UpdateAndCopy,</span>
<span class="line-removed"> 56     CopyAndUpdate,</span>
<span class="line-removed"> 57     NotValid</span>
<span class="line-removed"> 58   };</span>
<span class="line-removed"> 59 // ------------------------  End don&#39;t putback if not needed</span>
 60 
 61  private:



 62   // 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB
 63   #define QUEUE_SIZE (1 &lt;&lt; NOT_LP64(12) LP64_ONLY(13))
 64   typedef OverflowTaskQueue&lt;ObjArrayTask, mtGC, QUEUE_SIZE&gt; ObjArrayTaskQueue;
 65   typedef GenericTaskQueueSet&lt;ObjArrayTaskQueue, mtGC&gt;      ObjArrayTaskQueueSet;
 66   #undef QUEUE_SIZE


 67 
 68   static ParCompactionManager** _manager_array;
<span class="line-modified"> 69   static OopTaskQueueSet*       _stack_array;</span>
<span class="line-modified"> 70   static ObjArrayTaskQueueSet*  _objarray_queues;</span>
 71   static ObjectStartArray*      _start_array;
<span class="line-modified"> 72   static RegionTaskQueueSet*    _region_array;</span>
 73   static PSOldGen*              _old_gen;
 74 
 75 private:
 76   OverflowTaskQueue&lt;oop, mtGC&gt;        _marking_stack;
 77   ObjArrayTaskQueue             _objarray_stack;

 78 
 79   // Is there a way to reuse the _marking_stack for the
 80   // saving empty regions?  For now just create a different
 81   // type of TaskQueue.
 82   RegionTaskQueue              _region_stack;
 83 
 84   static ParMarkBitMap* _mark_bitmap;
 85 
<span class="line-modified"> 86   Action _action;</span>






 87 
 88   HeapWord* _last_query_beg;
 89   oop _last_query_obj;
 90   size_t _last_query_ret;
 91 
 92   static PSOldGen* old_gen()             { return _old_gen; }
 93   static ObjectStartArray* start_array() { return _start_array; }
<span class="line-modified"> 94   static OopTaskQueueSet* stack_array()  { return _stack_array; }</span>
 95 
 96   static void initialize(ParMarkBitMap* mbm);
 97 
 98  protected:
<span class="line-modified"> 99   // Array of tasks.  Needed by the ParallelTaskTerminator.</span>
<span class="line-modified">100   static RegionTaskQueueSet* region_array()      { return _region_array; }</span>
101   OverflowTaskQueue&lt;oop, mtGC&gt;*  marking_stack()       { return &amp;_marking_stack; }
102 
103   // Pushes onto the marking stack.  If the marking stack is full,
104   // pushes onto the overflow stack.
105   void stack_push(oop obj);
106   // Do not implement an equivalent stack_pop.  Deal with the
107   // marking stack and overflow stack directly.
108 
109  public:













110   void reset_bitmap_query_cache() {
111     _last_query_beg = NULL;
112     _last_query_obj = NULL;
113     _last_query_ret = 0;
114   }
115 
<span class="line-removed">116   Action action() { return _action; }</span>
<span class="line-removed">117   void set_action(Action v) { _action = v; }</span>
<span class="line-removed">118 </span>
119   // Bitmap query support, cache last query and result
120   HeapWord* last_query_begin() { return _last_query_beg; }
121   oop last_query_object() { return _last_query_obj; }
122   size_t last_query_return() { return _last_query_ret; }
123 
124   void set_last_query_begin(HeapWord *new_beg) { _last_query_beg = new_beg; }
125   void set_last_query_object(oop new_obj) { _last_query_obj = new_obj; }
126   void set_last_query_return(size_t new_ret) { _last_query_ret = new_ret; }
127 
128   static void reset_all_bitmap_query_caches();
129 
130   RegionTaskQueue* region_stack()                { return &amp;_region_stack; }
131 
132   inline static ParCompactionManager* manager_array(uint index);
133 
134   ParCompactionManager();
135 
136   // Pushes onto the region stack at the given index.  If the
137   // region stack is full,
138   // pushes onto the region overflow stack.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 26 #define SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 27 
<span class="line-added"> 28 #include &quot;gc/parallel/psParallelCompact.hpp&quot;</span>
 29 #include &quot;gc/shared/taskqueue.hpp&quot;
 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;utilities/stack.hpp&quot;
 32 
 33 class MutableSpace;
 34 class PSOldGen;
 35 class ParCompactionManager;
 36 class ObjectStartArray;
 37 class ParallelCompactData;
 38 class ParMarkBitMap;
 39 
 40 class ParCompactionManager : public CHeapObj&lt;mtGC&gt; {

 41   friend class ParMarkBitMap;
 42   friend class PSParallelCompact;
 43   friend class CompactionWithStealingTask;
 44   friend class UpdateAndFillClosure;
 45   friend class RefProcTaskExecutor;
<span class="line-modified"> 46   friend class PCRefProcTask;</span>
<span class="line-added"> 47   friend class MarkFromRootsTask;</span>
<span class="line-added"> 48   friend class UpdateDensePrefixAndCompactionTask;</span>
 49 
 50  public:
 51 










 52 
 53  private:
<span class="line-added"> 54   typedef GenericTaskQueue&lt;oop, mtGC&gt;             OopTaskQueue;</span>
<span class="line-added"> 55   typedef GenericTaskQueueSet&lt;OopTaskQueue, mtGC&gt; OopTaskQueueSet;</span>
<span class="line-added"> 56 </span>
 57   // 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB
 58   #define QUEUE_SIZE (1 &lt;&lt; NOT_LP64(12) LP64_ONLY(13))
 59   typedef OverflowTaskQueue&lt;ObjArrayTask, mtGC, QUEUE_SIZE&gt; ObjArrayTaskQueue;
 60   typedef GenericTaskQueueSet&lt;ObjArrayTaskQueue, mtGC&gt;      ObjArrayTaskQueueSet;
 61   #undef QUEUE_SIZE
<span class="line-added"> 62   typedef OverflowTaskQueue&lt;size_t, mtGC&gt;             RegionTaskQueue;</span>
<span class="line-added"> 63   typedef GenericTaskQueueSet&lt;RegionTaskQueue, mtGC&gt;  RegionTaskQueueSet;</span>
 64 
 65   static ParCompactionManager** _manager_array;
<span class="line-modified"> 66   static OopTaskQueueSet*       _oop_task_queues;</span>
<span class="line-modified"> 67   static ObjArrayTaskQueueSet*  _objarray_task_queues;</span>
 68   static ObjectStartArray*      _start_array;
<span class="line-modified"> 69   static RegionTaskQueueSet*    _region_task_queues;</span>
 70   static PSOldGen*              _old_gen;
 71 
 72 private:
 73   OverflowTaskQueue&lt;oop, mtGC&gt;        _marking_stack;
 74   ObjArrayTaskQueue             _objarray_stack;
<span class="line-added"> 75   size_t                        _next_shadow_region;</span>
 76 
 77   // Is there a way to reuse the _marking_stack for the
 78   // saving empty regions?  For now just create a different
 79   // type of TaskQueue.
 80   RegionTaskQueue              _region_stack;
 81 
 82   static ParMarkBitMap* _mark_bitmap;
 83 
<span class="line-modified"> 84   // Contains currently free shadow regions. We use it in</span>
<span class="line-added"> 85   // a LIFO fashion for better data locality and utilization.</span>
<span class="line-added"> 86   static GrowableArray&lt;size_t&gt;* _shadow_region_array;</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88   // Provides mutual exclusive access of _shadow_region_array.</span>
<span class="line-added"> 89   // See pop/push_shadow_region_mt_safe() below</span>
<span class="line-added"> 90   static Monitor*               _shadow_region_monitor;</span>
 91 
 92   HeapWord* _last_query_beg;
 93   oop _last_query_obj;
 94   size_t _last_query_ret;
 95 
 96   static PSOldGen* old_gen()             { return _old_gen; }
 97   static ObjectStartArray* start_array() { return _start_array; }
<span class="line-modified"> 98   static OopTaskQueueSet* oop_task_queues()  { return _oop_task_queues; }</span>
 99 
100   static void initialize(ParMarkBitMap* mbm);
101 
102  protected:
<span class="line-modified">103   // Array of task queues.  Needed by the task terminator.</span>
<span class="line-modified">104   static RegionTaskQueueSet* region_task_queues()      { return _region_task_queues; }</span>
105   OverflowTaskQueue&lt;oop, mtGC&gt;*  marking_stack()       { return &amp;_marking_stack; }
106 
107   // Pushes onto the marking stack.  If the marking stack is full,
108   // pushes onto the overflow stack.
109   void stack_push(oop obj);
110   // Do not implement an equivalent stack_pop.  Deal with the
111   // marking stack and overflow stack directly.
112 
113  public:
<span class="line-added">114   static const size_t InvalidShadow = ~0;</span>
<span class="line-added">115   static size_t  pop_shadow_region_mt_safe(PSParallelCompact::RegionData* region_ptr);</span>
<span class="line-added">116   static void    push_shadow_region_mt_safe(size_t shadow_region);</span>
<span class="line-added">117   static void    push_shadow_region(size_t shadow_region);</span>
<span class="line-added">118   static void    remove_all_shadow_regions();</span>
<span class="line-added">119 </span>
<span class="line-added">120   inline size_t  next_shadow_region() { return _next_shadow_region; }</span>
<span class="line-added">121   inline void    set_next_shadow_region(size_t record) { _next_shadow_region = record; }</span>
<span class="line-added">122   inline size_t  move_next_shadow_region_by(size_t workers) {</span>
<span class="line-added">123     _next_shadow_region += workers;</span>
<span class="line-added">124     return next_shadow_region();</span>
<span class="line-added">125   }</span>
<span class="line-added">126 </span>
127   void reset_bitmap_query_cache() {
128     _last_query_beg = NULL;
129     _last_query_obj = NULL;
130     _last_query_ret = 0;
131   }
132 



133   // Bitmap query support, cache last query and result
134   HeapWord* last_query_begin() { return _last_query_beg; }
135   oop last_query_object() { return _last_query_obj; }
136   size_t last_query_return() { return _last_query_ret; }
137 
138   void set_last_query_begin(HeapWord *new_beg) { _last_query_beg = new_beg; }
139   void set_last_query_object(oop new_obj) { _last_query_obj = new_obj; }
140   void set_last_query_return(size_t new_ret) { _last_query_ret = new_ret; }
141 
142   static void reset_all_bitmap_query_caches();
143 
144   RegionTaskQueue* region_stack()                { return &amp;_region_stack; }
145 
146   inline static ParCompactionManager* manager_array(uint index);
147 
148   ParCompactionManager();
149 
150   // Pushes onto the region stack at the given index.  If the
151   // region stack is full,
152   // pushes onto the region overflow stack.
</pre>
</td>
</tr>
</table>
<center><a href="psCompactionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
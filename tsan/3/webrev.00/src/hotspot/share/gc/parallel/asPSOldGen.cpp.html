<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/asPSOldGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSOldGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
 29 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 30 #include &quot;gc/shared/genArguments.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Whereas PSOldGen takes the maximum size of the generation
 36 // (which doesn&#39;t change in the case of PSOldGen) as a parameter,
 37 // ASPSOldGen takes the upper limit on the size of
 38 // the generation as a parameter.  In ASPSOldGen the
 39 // maximum size of the generation can change as the boundary
 40 // moves.  The &quot;maximum size of the generation&quot; is still a valid
 41 // concept since the generation can grow and shrink within that
 42 // maximum.  There are lots of useful checks that use that
 43 // maximum.  In PSOldGen the method max_gen_size() returns
 44 // _max_gen_size (as set by the PSOldGen constructor).  This
 45 // is how it always worked.  In ASPSOldGen max_gen_size()
 46 // returned the size of the reserved space for the generation.
 47 // That can change as the boundary moves.  Below the limit of
 48 // the size of the generation is passed to the PSOldGen constructor
 49 // for &quot;_max_gen_size&quot; (have to pass something) but it is not used later.
 50 //
 51 ASPSOldGen::ASPSOldGen(size_t initial_size,
 52                        size_t min_size,
 53                        size_t size_limit,
 54                        const char* gen_name,
 55                        int level) :
 56   PSOldGen(initial_size, min_size, size_limit, gen_name, level),
 57   _gen_size_limit(size_limit)
 58 {}
 59 
 60 ASPSOldGen::ASPSOldGen(PSVirtualSpace* vs,
 61                        size_t initial_size,
 62                        size_t min_size,
 63                        size_t size_limit,
 64                        const char* gen_name,
 65                        int level) :
 66   PSOldGen(initial_size, min_size, size_limit, gen_name, level),
 67   _gen_size_limit(size_limit)
 68 {
 69   _virtual_space = vs;
 70 }
 71 
 72 void ASPSOldGen::initialize_work(const char* perf_data_name, int level) {
 73   PSOldGen::initialize_work(perf_data_name, level);
 74 
 75   // The old gen can grow to gen_size_limit().  _reserve reflects only
 76   // the current maximum that can be committed.
 77   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 78 
 79   initialize_performance_counters(perf_data_name, level);
 80 }
 81 
 82 void ASPSOldGen::reset_after_change() {
 83   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 84                         (HeapWord*)virtual_space()-&gt;high_boundary());
 85   post_resize();
 86 }
 87 
 88 
 89 size_t ASPSOldGen::available_for_expansion() {
 90   assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
 91   assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
 92 
 93   size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
 94   size_t result_aligned = align_down(result, GenAlignment);
 95   return result_aligned;
 96 }
 97 
 98 size_t ASPSOldGen::available_for_contraction() {
 99   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
100   if (uncommitted_bytes != 0) {
101     return uncommitted_bytes;
102   }
103 
104   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
105   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
106   const size_t working_size =
107     used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
108   const size_t working_aligned = align_up(working_size, GenAlignment);
109   const size_t working_or_min = MAX2(working_aligned, min_gen_size());
110   if (working_or_min &gt; reserved().byte_size()) {
111     // If the used or minimum gen size (aligned up) is greater
112     // than the total reserved size, then the space available
113     // for contraction should (after proper alignment) be 0
114     return 0;
115   }
116   const size_t max_contraction =
117     reserved().byte_size() - working_or_min;
118 
119   // Use the &quot;increment&quot; fraction instead of the &quot;decrement&quot; fraction
120   // to allow the other gen to expand more aggressively.  The
121   // &quot;decrement&quot; fraction is conservative because its intent is to
122   // only reduce the footprint.
123 
124   size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
125   // Also adjust for inter-generational alignment
126   size_t result_aligned = align_down(result, GenAlignment);
127 
128   Log(gc, ergo) log;
129   if (log.is_trace()) {
130     size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
131     size_t promo_increment = policy-&gt;promo_increment(max_contraction);
132     log.trace(&quot;ASPSOldGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, result_aligned/K, result_aligned);
133     log.trace(&quot; reserved().byte_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, reserved().byte_size()/K, reserved().byte_size());
134     log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
135     log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
136     log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
137     log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
138     log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
139     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, GenAlignment);
140   }
141 
142   assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
143   return result_aligned;
144 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp b/src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp
--- a/src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp
+++ b/src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp
@@ -54,12 +54,12 @@
     PSVirtualSpace* old_vs() { return low(); }
 
   public:
     HeteroVirtualSpaces(ReservedSpace rs,
                         size_t min_old_byte_size,
-                        size_t min_young_byte_size, size_t max_total_size,
-                        size_t alignment);
+                        size_t min_young_byte_size,
+                        size_t max_total_size);
 
     // Increase old generation size and decrease young generation size by same amount
     bool adjust_boundary_up(size_t size_in_bytes);
     // Increase young generation size and decrease old generation size by same amount
     bool adjust_boundary_down(size_t size_in_bytes);
@@ -70,15 +70,15 @@
     void initialize(size_t initial_old_reserved_size, size_t init_low_byte_size,
                     size_t init_high_byte_size);
   };
 
 public:
-  AdjoiningGenerationsForHeteroHeap(ReservedSpace rs, GenerationSizer* policy, size_t alignment);
+  AdjoiningGenerationsForHeteroHeap(ReservedSpace rs);
 
   // Given the size policy, calculate the total amount of memory that needs to be reserved.
   // We need to reserve more memory than Xmx, since we use non-overlapping virtual spaces for the young and old generations.
-  static size_t required_reserved_memory(GenerationSizer* policy);
+  static size_t required_reserved_memory();
 
   // Return the total byte size of the reserved space
   size_t reserved_byte_size();
 };
 #endif // SHARE_GC_PARALLEL_ADJOININGGENERATIONSFORHETEROHEAP_HPP

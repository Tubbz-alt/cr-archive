<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/psAdaptiveSizePolicy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
 26 #define SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
 27 
 28 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcStats.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
 32 #include &quot;utilities/align.hpp&quot;
 33 
 34 // This class keeps statistical information and computes the
 35 // optimal free space for both the young and old generation
 36 // based on current application characteristics (based on gc cost
 37 // and application footprint).
 38 //
 39 // It also computes an optimal tenuring threshold between the young
 40 // and old generations, so as to equalize the cost of collections
 41 // of those generations, as well as optimal survivor space sizes
 42 // for the young generation.
 43 //
 44 // While this class is specifically intended for a generational system
 45 // consisting of a young gen (containing an Eden and two semi-spaces)
 46 // and a tenured gen, as well as a perm gen for reflective data, it
 47 // makes NO references to specific generations.
 48 //
 49 // 05/02/2003 Update
 50 // The 1.5 policy makes use of data gathered for the costs of GC on
 51 // specific generations.  That data does reference specific
 52 // generation.  Also diagnostics specific to generations have
 53 // been added.
 54 
 55 // Forward decls
 56 class elapsedTimer;
 57 
 58 class PSAdaptiveSizePolicy : public AdaptiveSizePolicy {
 59  friend class PSGCAdaptivePolicyCounters;
 60  private:
 61   // These values are used to record decisions made during the
 62   // policy.  For example, if the young generation was decreased
 63   // to decrease the GC cost of minor collections the value
 64   // decrease_young_gen_for_throughput_true is used.
 65 
 66   // Last calculated sizes, in bytes, and aligned
 67   // NEEDS_CLEANUP should use sizes.hpp,  but it works in ints, not size_t&#39;s
 68 
 69   // Time statistics
 70   AdaptivePaddedAverage* _avg_major_pause;
 71 
 72   // Footprint statistics
 73   AdaptiveWeightedAverage* _avg_base_footprint;
 74 
 75   // Statistical data gathered for GC
 76   GCStats _gc_stats;
 77 
 78   const double _collection_cost_margin_fraction;
 79 
 80   // Variable for estimating the major and minor pause times.
 81   // These variables represent linear least-squares fits of
 82   // the data.
 83   //   major pause time vs. old gen size
 84   LinearLeastSquareFit* _major_pause_old_estimator;
 85   //   major pause time vs. young gen size
 86   LinearLeastSquareFit* _major_pause_young_estimator;
 87 
 88 
 89   // These record the most recent collection times.  They
 90   // are available as an alternative to using the averages
 91   // for making ergonomic decisions.
 92   double _latest_major_mutator_interval_seconds;
 93 
 94   const size_t _space_alignment; // alignment for eden, survivors
 95 
 96   const double _gc_minor_pause_goal_sec;    // goal for maximum minor gc pause
 97 
 98   // The amount of live data in the heap at the last full GC, used
 99   // as a baseline to help us determine when we need to perform the
100   // next full GC.
101   size_t _live_at_last_full_gc;
102 
103   // decrease/increase the old generation for minor pause time
104   int _change_old_gen_for_min_pauses;
105 
106   // increase/decrease the young generation for major pause time
107   int _change_young_gen_for_maj_pauses;
108 
109 
110   // Flag indicating that the adaptive policy is ready to use
111   bool _old_gen_policy_is_ready;
112 
113   // To facilitate faster growth at start up, supplement the normal
114   // growth percentage for the young gen eden and the
115   // old gen space for promotion with these value which decay
116   // with increasing collections.
117   uint _young_gen_size_increment_supplement;
118   uint _old_gen_size_increment_supplement;
119 
120   // The number of bytes absorbed from eden into the old gen by moving the
121   // boundary over live data.
122   size_t _bytes_absorbed_from_eden;
123 
124  private:
125 
126   // Accessors
127   AdaptivePaddedAverage* avg_major_pause() const { return _avg_major_pause; }
128   double gc_minor_pause_goal_sec() const { return _gc_minor_pause_goal_sec; }
129 
130   void adjust_eden_for_minor_pause_time(bool is_full_gc,
131                                    size_t* desired_eden_size_ptr);
132   // Change the generation sizes to achieve a GC pause time goal
133   // Returned sizes are not necessarily aligned.
134   void adjust_promo_for_pause_time(bool is_full_gc,
135                          size_t* desired_promo_size_ptr,
136                          size_t* desired_eden_size_ptr);
137   void adjust_eden_for_pause_time(bool is_full_gc,
138                          size_t* desired_promo_size_ptr,
139                          size_t* desired_eden_size_ptr);
140   // Change the generation sizes to achieve an application throughput goal
141   // Returned sizes are not necessarily aligned.
142   void adjust_promo_for_throughput(bool is_full_gc,
143                              size_t* desired_promo_size_ptr);
144   void adjust_eden_for_throughput(bool is_full_gc,
145                              size_t* desired_eden_size_ptr);
146   // Change the generation sizes to achieve minimum footprint
147   // Returned sizes are not aligned.
148   size_t adjust_promo_for_footprint(size_t desired_promo_size,
149                                     size_t desired_total);
150   size_t adjust_eden_for_footprint(size_t desired_promo_size,
151                                    size_t desired_total);
152 
153   // Size in bytes for an increment or decrement of eden.
154   virtual size_t eden_increment(size_t cur_eden, uint percent_change);
155   virtual size_t eden_decrement(size_t cur_eden);
156   size_t eden_decrement_aligned_down(size_t cur_eden);
157   size_t eden_increment_with_supplement_aligned_up(size_t cur_eden);
158 
159   // Size in bytes for an increment or decrement of the promotion area
160   virtual size_t promo_increment(size_t cur_promo, uint percent_change);
161   virtual size_t promo_decrement(size_t cur_promo);
162   size_t promo_decrement_aligned_down(size_t cur_promo);
163   size_t promo_increment_with_supplement_aligned_up(size_t cur_promo);
164 
165   // Returns a change that has been scaled down.  Result
166   // is not aligned.  (If useful, move to some shared
167   // location.)
168   size_t scale_down(size_t change, double part, double total);
169 
170  protected:
171   // Time accessors
172 
173   // Footprint accessors
174   size_t live_space() const {
175     return (size_t)(avg_base_footprint()-&gt;average() +
176                     avg_young_live()-&gt;average() +
177                     avg_old_live()-&gt;average());
178   }
179   size_t free_space() const {
180     return _eden_size + _promo_size;
181   }
182 
183   void set_promo_size(size_t new_size) {
184     _promo_size = new_size;
185   }
186   void set_survivor_size(size_t new_size) {
187     _survivor_size = new_size;
188   }
189 
190   // Update estimators
191   void update_minor_pause_old_estimator(double minor_pause_in_ms);
192 
193   virtual GCPolicyKind kind() const { return _gc_ps_adaptive_size_policy; }
194 
195  public:
196   // Use by ASPSYoungGen and ASPSOldGen to limit boundary moving.
197   size_t eden_increment_aligned_up(size_t cur_eden);
198   size_t eden_increment_aligned_down(size_t cur_eden);
199   size_t promo_increment_aligned_up(size_t cur_promo);
200   size_t promo_increment_aligned_down(size_t cur_promo);
201 
202   virtual size_t eden_increment(size_t cur_eden);
203   virtual size_t promo_increment(size_t cur_promo);
204 
205   // Accessors for use by performance counters
206   AdaptivePaddedNoZeroDevAverage*  avg_promoted() const {
207     return _gc_stats.avg_promoted();
208   }
209   AdaptiveWeightedAverage* avg_base_footprint() const {
210     return _avg_base_footprint;
211   }
212 
213   // Input arguments are initial free space sizes for young and old
214   // generations, the initial survivor space size, the
215   // alignment values and the pause &amp; throughput goals.
216   //
217   // NEEDS_CLEANUP this is a singleton object
218   PSAdaptiveSizePolicy(size_t init_eden_size,
219                        size_t init_promo_size,
220                        size_t init_survivor_size,
221                        size_t space_alignment,
222                        double gc_pause_goal_sec,
223                        double gc_minor_pause_goal_sec,
224                        uint gc_time_ratio);
225 
226   // Methods indicating events of interest to the adaptive size policy,
227   // called by GC algorithms. It is the responsibility of users of this
228   // policy to call these methods at the correct times!
229   void major_collection_begin();
230   void major_collection_end(size_t amount_live, GCCause::Cause gc_cause);
231 
232   void tenured_allocation(size_t size) {
233     _avg_pretenured-&gt;sample(size);
234   }
235 
236   // Accessors
237   // NEEDS_CLEANUP   should use sizes.hpp
238 
239   static size_t calculate_free_based_on_live(size_t live, uintx ratio_as_percentage);
240 
241   size_t calculated_old_free_size_in_bytes() const;
242 
243   size_t average_old_live_in_bytes() const {
244     return (size_t) avg_old_live()-&gt;average();
245   }
246 
247   size_t average_promoted_in_bytes() const {
248     return (size_t)avg_promoted()-&gt;average();
249   }
250 
251   size_t padded_average_promoted_in_bytes() const {
252     return (size_t)avg_promoted()-&gt;padded_average();
253   }
254 
255   int change_young_gen_for_maj_pauses() {
256     return _change_young_gen_for_maj_pauses;
257   }
258   void set_change_young_gen_for_maj_pauses(int v) {
259     _change_young_gen_for_maj_pauses = v;
260   }
261 
262   int change_old_gen_for_min_pauses() {
263     return _change_old_gen_for_min_pauses;
264   }
265   void set_change_old_gen_for_min_pauses(int v) {
266     _change_old_gen_for_min_pauses = v;
267   }
268 
269   // Return true if the old generation size was changed
270   // to try to reach a pause time goal.
271   bool old_gen_changed_for_pauses() {
272     bool result = _change_old_gen_for_maj_pauses != 0 ||
273                   _change_old_gen_for_min_pauses != 0;
274     return result;
275   }
276 
277   // Return true if the young generation size was changed
278   // to try to reach a pause time goal.
279   bool young_gen_changed_for_pauses() {
280     bool result = _change_young_gen_for_min_pauses != 0 ||
281                   _change_young_gen_for_maj_pauses != 0;
282     return result;
283   }
284   // end flags for pause goal
285 
286   // Return true if the old generation size was changed
287   // to try to reach a throughput goal.
288   bool old_gen_changed_for_throughput() {
289     bool result = _change_old_gen_for_throughput != 0;
290     return result;
291   }
292 
293   // Return true if the young generation size was changed
294   // to try to reach a throughput goal.
295   bool young_gen_changed_for_throughput() {
296     bool result = _change_young_gen_for_throughput != 0;
297     return result;
298   }
299 
300   int decrease_for_footprint() { return _decrease_for_footprint; }
301 
302 
303   // Accessors for estimators.  The slope of the linear fit is
304   // currently all that is used for making decisions.
305 
306   LinearLeastSquareFit* major_pause_old_estimator() {
307     return _major_pause_old_estimator;
308   }
309 
310   LinearLeastSquareFit* major_pause_young_estimator() {
311     return _major_pause_young_estimator;
312   }
313 
314 
315   virtual void clear_generation_free_space_flags();
316 
317   float major_pause_old_slope() { return _major_pause_old_estimator-&gt;slope(); }
318   float major_pause_young_slope() {
319     return _major_pause_young_estimator-&gt;slope();
320   }
321   float major_collection_slope() { return _major_collection_estimator-&gt;slope();}
322 
323   bool old_gen_policy_is_ready() { return _old_gen_policy_is_ready; }
324 
325   // Given the amount of live data in the heap, should we
326   // perform a Full GC?
327   bool should_full_GC(size_t live_in_old_gen);
328 
329   // Calculates optimal (free) space sizes for both the young and old
330   // generations.  Stores results in _eden_size and _promo_size.
331   // Takes current used space in all generations as input, as well
332   // as an indication if a full gc has just been performed, for use
333   // in deciding if an OOM error should be thrown.
334   void compute_generations_free_space(size_t young_live,
335                                       size_t eden_live,
336                                       size_t old_live,
337                                       size_t cur_eden,  // current eden in bytes
338                                       size_t max_old_gen_size,
339                                       size_t max_eden_size,
340                                       bool   is_full_gc);
341 
342   void compute_eden_space_size(size_t young_live,
343                                size_t eden_live,
344                                size_t cur_eden,  // current eden in bytes
345                                size_t max_eden_size,
346                                bool   is_full_gc);
347 
348   void compute_old_gen_free_space(size_t old_live,
349                                              size_t cur_eden,  // current eden in bytes
350                                              size_t max_old_gen_size,
351                                              bool   is_full_gc);
352 
353   // Calculates new survivor space size;  returns a new tenuring threshold
354   // value. Stores new survivor size in _survivor_size.
355   uint compute_survivor_space_size_and_threshold(bool   is_survivor_overflow,
356                                                  uint    tenuring_threshold,
357                                                  size_t survivor_limit);
358 
359   // Return the maximum size of a survivor space if the young generation were of
360   // size gen_size.
361   size_t max_survivor_size(size_t gen_size) {
362     // Never allow the target survivor size to grow more than MinSurvivorRatio
363     // of the young generation size.  We cannot grow into a two semi-space
364     // system, with Eden zero sized.  Even if the survivor space grows, from()
365     // might grow by moving the bottom boundary &quot;down&quot; -- so from space will
366     // remain almost full anyway (top() will be near end(), but there will be a
367     // large filler object at the bottom).
368     const size_t sz = gen_size / MinSurvivorRatio;
369     const size_t alignment = _space_alignment;
370     return sz &gt; alignment ? align_down(sz, alignment) : alignment;
371   }
372 
373   size_t live_at_last_full_gc() {
374     return _live_at_last_full_gc;
375   }
376 
377   size_t bytes_absorbed_from_eden() const { return _bytes_absorbed_from_eden; }
378   void   reset_bytes_absorbed_from_eden() { _bytes_absorbed_from_eden = 0; }
379 
380   void set_bytes_absorbed_from_eden(size_t val) {
381     _bytes_absorbed_from_eden = val;
382   }
383 
384   // Update averages that are always used (even
385   // if adaptive sizing is turned off).
386   void update_averages(bool is_survivor_overflow,
387                        size_t survived,
388                        size_t promoted);
389 
390   // Printing support
391   virtual bool print() const;
392 
393   // Decay the supplemental growth additive.
394   void decay_supplemental_growth(bool is_full_gc);
395 };
396 
397 #endif // SHARE_GC_PARALLEL_PSADAPTIVESIZEPOLICY_HPP
    </pre>
  </body>
</html>
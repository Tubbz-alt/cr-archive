<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psOldGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psFileBackedVirtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psOldGen.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psOldGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;

 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
 29 #include &quot;gc/parallel/psCardTable.hpp&quot;
 30 #include &quot;gc/parallel/psFileBackedVirtualspace.hpp&quot;
<span class="line-removed"> 31 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 32 #include &quot;gc/parallel/psOldGen.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/gcLocker.hpp&quot;
<span class="line-modified"> 35 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
 36 #include &quot;logging/log.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 
<span class="line-removed"> 41 inline const char* PSOldGen::select_name() {</span>
<span class="line-removed"> 42   return UseParallelOldGC ? &quot;ParOldGen&quot; : &quot;PSOldGen&quot;;</span>
<span class="line-removed"> 43 }</span>
<span class="line-removed"> 44 </span>
 45 PSOldGen::PSOldGen(ReservedSpace rs, size_t alignment,
 46                    size_t initial_size, size_t min_size, size_t max_size,
 47                    const char* perf_data_name, int level):
<span class="line-modified"> 48   _name(select_name()), _init_gen_size(initial_size), _min_gen_size(min_size),</span>
 49   _max_gen_size(max_size)
 50 {
 51   initialize(rs, alignment, perf_data_name, level);
 52 }
 53 
 54 PSOldGen::PSOldGen(size_t initial_size,
 55                    size_t min_size, size_t max_size,
 56                    const char* perf_data_name, int level):
<span class="line-modified"> 57   _name(select_name()), _init_gen_size(initial_size), _min_gen_size(min_size),</span>
 58   _max_gen_size(max_size)
 59 {}
 60 
 61 void PSOldGen::initialize(ReservedSpace rs, size_t alignment,
 62                           const char* perf_data_name, int level) {
 63   initialize_virtual_space(rs, alignment);
 64   initialize_work(perf_data_name, level);
 65 
 66   // The old gen can grow to gen_size_limit().  _reserve reflects only
 67   // the current maximum that can be committed.
 68   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 69 
 70   initialize_performance_counters(perf_data_name, level);
 71 }
 72 
 73 void PSOldGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 74 
<span class="line-modified"> 75   if(ParallelScavengeHeap::heap()-&gt;ps_collector_policy()-&gt;is_hetero_heap()) {</span>
 76     _virtual_space = new PSFileBackedVirtualSpace(rs, alignment, AllocateOldGenAt);
 77     if (!(static_cast &lt;PSFileBackedVirtualSpace*&gt;(_virtual_space))-&gt;initialize()) {
 78       vm_exit_during_initialization(&quot;Could not map space for PSOldGen at given AllocateOldGenAt path&quot;);
 79     }
 80   } else {
 81     _virtual_space = new PSVirtualSpace(rs, alignment);
 82   }
 83   if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
 84     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 85                                   &quot;object heap&quot;);
 86   }
 87 }
 88 
 89 void PSOldGen::initialize_work(const char* perf_data_name, int level) {
 90   //
 91   // Basic memory initialization
 92   //
 93 
 94   MemRegion limit_reserved((HeapWord*)virtual_space()-&gt;low_boundary(),
 95     heap_word_size(_max_gen_size));
</pre>
<hr />
<pre>
122   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
123   PSCardTable* ct = heap-&gt;card_table();
124   ct-&gt;resize_covered_region(cmr);
125 
126   // Verify that the start and end of this generation is the start of a card.
127   // If this wasn&#39;t true, a single card could span more than one generation,
128   // which would cause problems when we commit/uncommit memory, and when we
129   // clear and dirty cards.
130   guarantee(ct-&gt;is_card_aligned(_reserved.start()), &quot;generation must be card aligned&quot;);
131   if (_reserved.end() != heap-&gt;reserved_region().end()) {
132     // Don&#39;t check at the very end of the heap as we&#39;ll assert that we&#39;re probing off
133     // the end if we try.
134     guarantee(ct-&gt;is_card_aligned(_reserved.end()), &quot;generation must be card aligned&quot;);
135   }
136 
137   //
138   // ObjectSpace stuff
139   //
140 
141   _object_space = new MutableSpace(virtual_space()-&gt;alignment());
<span class="line-removed">142 </span>
<span class="line-removed">143   if (_object_space == NULL)</span>
<span class="line-removed">144     vm_exit_during_initialization(&quot;Could not allocate an old gen space&quot;);</span>
<span class="line-removed">145 </span>
146   object_space()-&gt;initialize(cmr,
147                              SpaceDecorator::Clear,
148                              SpaceDecorator::Mangle);
149 
<span class="line-removed">150 #if INCLUDE_SERIALGC</span>
<span class="line-removed">151   _object_mark_sweep = new PSMarkSweepDecorator(_object_space, start_array(), MarkSweepDeadRatio);</span>
<span class="line-removed">152 </span>
<span class="line-removed">153   if (_object_mark_sweep == NULL) {</span>
<span class="line-removed">154     vm_exit_during_initialization(&quot;Could not complete allocation of old generation&quot;);</span>
<span class="line-removed">155   }</span>
<span class="line-removed">156 #endif // INCLUDE_SERIALGC</span>
<span class="line-removed">157 </span>
158   // Update the start_array
159   start_array()-&gt;set_covered_region(cmr);
160 }
161 
162 void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {
163   // Generation Counters, generation &#39;level&#39;, 1 subspace
164   _gen_counters = new PSGenerationCounters(perf_data_name, level, 1, _min_gen_size,
165                                            _max_gen_size, virtual_space());
166   _space_counters = new SpaceCounters(perf_data_name, 0,
167                                       virtual_space()-&gt;reserved_size(),
168                                       _object_space, _gen_counters);
169 }
170 
171 // Assume that the generation has been allocated if its
172 // reserved size is not 0.
173 bool  PSOldGen::is_allocated() {
174   return virtual_space()-&gt;reserved_size() != 0;
175 }
176 
<span class="line-removed">177 #if INCLUDE_SERIALGC</span>
<span class="line-removed">178 </span>
<span class="line-removed">179 void PSOldGen::precompact() {</span>
<span class="line-removed">180   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">181 </span>
<span class="line-removed">182   // Reset start array first.</span>
<span class="line-removed">183   start_array()-&gt;reset();</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   object_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">186 </span>
<span class="line-removed">187   // Now compact the young gen</span>
<span class="line-removed">188   heap-&gt;young_gen()-&gt;precompact();</span>
<span class="line-removed">189 }</span>
<span class="line-removed">190 </span>
<span class="line-removed">191 void PSOldGen::adjust_pointers() {</span>
<span class="line-removed">192   object_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">193 }</span>
<span class="line-removed">194 </span>
<span class="line-removed">195 void PSOldGen::compact() {</span>
<span class="line-removed">196   object_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">197 }</span>
<span class="line-removed">198 </span>
<span class="line-removed">199 #endif // INCLUDE_SERIALGC</span>
<span class="line-removed">200 </span>
201 size_t PSOldGen::contiguous_available() const {
202   return object_space()-&gt;free_in_bytes() + virtual_space()-&gt;uncommitted_size();
203 }
204 
205 // Allocation. We report all successful allocations to the size policy
206 // Note that the perm gen does not use this method, and should not!
207 HeapWord* PSOldGen::allocate(size_t word_size) {
208   assert_locked_or_safepoint(Heap_lock);
209   HeapWord* res = allocate_noexpand(word_size);
210 
211   if (res == NULL) {
212     res = expand_and_allocate(word_size);
213   }
214 
215   // Allocations in the old generation need to be reported
216   if (res != NULL) {
217     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
218     heap-&gt;size_policy()-&gt;tenured_allocation(word_size * HeapWordSize);
219   }
220 
221   return res;
222 }
223 
224 HeapWord* PSOldGen::expand_and_allocate(size_t word_size) {
225   expand(word_size*HeapWordSize);
226   if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">227     os::sleep(Thread::current(), GCExpandToAllocateDelayMillis, false);</span>
228   }
229   return allocate_noexpand(word_size);
230 }
231 
232 HeapWord* PSOldGen::expand_and_cas_allocate(size_t word_size) {
233   expand(word_size*HeapWordSize);
234   if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">235     os::sleep(Thread::current(), GCExpandToAllocateDelayMillis, false);</span>
236   }
237   return cas_allocate_noexpand(word_size);
238 }
239 
240 void PSOldGen::expand(size_t bytes) {
241   if (bytes == 0) {
242     return;
243   }
244   MutexLocker x(ExpandHeap_lock);
245   const size_t alignment = virtual_space()-&gt;alignment();
246   size_t aligned_bytes  = align_up(bytes, alignment);
247   size_t aligned_expand_bytes = align_up(MinHeapDeltaBytes, alignment);
248 
249   if (UseNUMA) {
250     // With NUMA we use round-robin page allocation for the old gen. Expand by at least
251     // providing a page per lgroup. Alignment is larger or equal to the page size.
252     aligned_expand_bytes = MAX2(aligned_expand_bytes, alignment * os::numa_get_groups_num());
253   }
254   if (aligned_bytes == 0){
255     // The alignment caused the number of bytes to wrap.  An expand_by(0) will
</pre>
<hr />
<pre>
337     assert_lock_strong(ExpandHeap_lock);
338     virtual_space()-&gt;shrink_by(bytes);
339     post_resize();
340 
341     size_t new_mem_size = virtual_space()-&gt;committed_size();
342     size_t old_mem_size = new_mem_size + bytes;
343     log_debug(gc)(&quot;Shrinking %s from &quot; SIZE_FORMAT &quot;K by &quot; SIZE_FORMAT &quot;K to &quot; SIZE_FORMAT &quot;K&quot;,
344                   name(), old_mem_size/K, bytes/K, new_mem_size/K);
345   }
346 }
347 
348 void PSOldGen::resize(size_t desired_free_space) {
349   const size_t alignment = virtual_space()-&gt;alignment();
350   const size_t size_before = virtual_space()-&gt;committed_size();
351   size_t new_size = used_in_bytes() + desired_free_space;
352   if (new_size &lt; used_in_bytes()) {
353     // Overflowed the addition.
354     new_size = gen_size_limit();
355   }
356   // Adjust according to our min and max
<span class="line-modified">357   new_size = MAX2(MIN2(new_size, gen_size_limit()), min_gen_size());</span>
358 
359   assert(gen_size_limit() &gt;= reserved().byte_size(), &quot;max new size problem?&quot;);
360   new_size = align_up(new_size, alignment);
361 
362   const size_t current_size = capacity_in_bytes();
363 
364   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::old generation size: &quot;
365     &quot;desired free: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT
366     &quot; new size: &quot; SIZE_FORMAT &quot; current size &quot; SIZE_FORMAT
367     &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
368     desired_free_space, used_in_bytes(), new_size, current_size,
369     gen_size_limit(), min_gen_size());
370 
371   if (new_size == current_size) {
372     // No change requested
373     return;
374   }
375   if (new_size &gt; current_size) {
376     size_t change_bytes = new_size - current_size;
377     expand(change_bytes);
</pre>
<hr />
<pre>
425 }
426 
427 size_t PSOldGen::available_for_contraction() {
428   ShouldNotReachHere();
429   return 0;
430 }
431 
432 void PSOldGen::print() const { print_on(tty);}
433 void PSOldGen::print_on(outputStream* st) const {
434   st-&gt;print(&quot; %-15s&quot;, name());
435   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
436               capacity_in_bytes()/K, used_in_bytes()/K);
437   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
438                 p2i(virtual_space()-&gt;low_boundary()),
439                 p2i(virtual_space()-&gt;high()),
440                 p2i(virtual_space()-&gt;high_boundary()));
441 
442   st-&gt;print(&quot;  object&quot;); object_space()-&gt;print_on(st);
443 }
444 
<span class="line-removed">445 void PSOldGen::print_used_change(size_t prev_used) const {</span>
<span class="line-removed">446   log_info(gc, heap)(&quot;%s: &quot;  SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-removed">447       name(), prev_used / K, used_in_bytes() / K, capacity_in_bytes() / K);</span>
<span class="line-removed">448 }</span>
<span class="line-removed">449 </span>
450 void PSOldGen::update_counters() {
451   if (UsePerfData) {
452     _space_counters-&gt;update_all();
453     _gen_counters-&gt;update_all();
454   }
455 }
456 
457 #ifndef PRODUCT
458 
459 void PSOldGen::space_invariants() {
460   assert(object_space()-&gt;end() == (HeapWord*) virtual_space()-&gt;high(),
461     &quot;Space invariant&quot;);
462   assert(object_space()-&gt;bottom() == (HeapWord*) virtual_space()-&gt;low(),
463     &quot;Space invariant&quot;);
464   assert(virtual_space()-&gt;low_boundary() &lt;= virtual_space()-&gt;low(),
465     &quot;Space invariant&quot;);
466   assert(virtual_space()-&gt;high_boundary() &gt;= virtual_space()-&gt;high(),
467     &quot;Space invariant&quot;);
468   assert(virtual_space()-&gt;low_boundary() == (char*) _reserved.start(),
469     &quot;Space invariant&quot;);
470   assert(virtual_space()-&gt;high_boundary() == (char*) _reserved.end(),
471     &quot;Space invariant&quot;);
472   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
473     &quot;Space invariant&quot;);
474 }
475 #endif
476 
477 void PSOldGen::verify() {
478   object_space()-&gt;verify();
479 }
480 class VerifyObjectStartArrayClosure : public ObjectClosure {
481   PSOldGen* _old_gen;
482   ObjectStartArray* _start_array;
483 
484  public:
485   VerifyObjectStartArrayClosure(PSOldGen* old_gen, ObjectStartArray* start_array) :
486     _old_gen(old_gen), _start_array(start_array) { }
487 
488   virtual void do_object(oop obj) {
<span class="line-modified">489     HeapWord* test_addr = (HeapWord*)obj + 1;</span>
<span class="line-modified">490     guarantee(_start_array-&gt;object_start(test_addr) == (HeapWord*)obj, &quot;ObjectStartArray cannot find start of object&quot;);</span>
<span class="line-modified">491     guarantee(_start_array-&gt;is_block_allocated((HeapWord*)obj), &quot;ObjectStartArray missing block allocation&quot;);</span>
492   }
493 };
494 
495 void PSOldGen::verify_object_start_array() {
496   VerifyObjectStartArrayClosure check( this, &amp;_start_array );
497   object_iterate(&amp;check);
498 }
499 
500 #ifndef PRODUCT
501 void PSOldGen::record_spaces_top() {
502   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
503   object_space()-&gt;set_top_for_allocations();
504 }
505 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
<span class="line-added"> 27 #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
 30 #include &quot;gc/parallel/psCardTable.hpp&quot;
 31 #include &quot;gc/parallel/psFileBackedVirtualspace.hpp&quot;

 32 #include &quot;gc/parallel/psOldGen.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/gcLocker.hpp&quot;
<span class="line-modified"> 35 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
 36 #include &quot;logging/log.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 




 41 PSOldGen::PSOldGen(ReservedSpace rs, size_t alignment,
 42                    size_t initial_size, size_t min_size, size_t max_size,
 43                    const char* perf_data_name, int level):
<span class="line-modified"> 44   _init_gen_size(initial_size), _min_gen_size(min_size),</span>
 45   _max_gen_size(max_size)
 46 {
 47   initialize(rs, alignment, perf_data_name, level);
 48 }
 49 
 50 PSOldGen::PSOldGen(size_t initial_size,
 51                    size_t min_size, size_t max_size,
 52                    const char* perf_data_name, int level):
<span class="line-modified"> 53   _init_gen_size(initial_size), _min_gen_size(min_size),</span>
 54   _max_gen_size(max_size)
 55 {}
 56 
 57 void PSOldGen::initialize(ReservedSpace rs, size_t alignment,
 58                           const char* perf_data_name, int level) {
 59   initialize_virtual_space(rs, alignment);
 60   initialize_work(perf_data_name, level);
 61 
 62   // The old gen can grow to gen_size_limit().  _reserve reflects only
 63   // the current maximum that can be committed.
 64   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 65 
 66   initialize_performance_counters(perf_data_name, level);
 67 }
 68 
 69 void PSOldGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 70 
<span class="line-modified"> 71   if(ParallelArguments::is_heterogeneous_heap()) {</span>
 72     _virtual_space = new PSFileBackedVirtualSpace(rs, alignment, AllocateOldGenAt);
 73     if (!(static_cast &lt;PSFileBackedVirtualSpace*&gt;(_virtual_space))-&gt;initialize()) {
 74       vm_exit_during_initialization(&quot;Could not map space for PSOldGen at given AllocateOldGenAt path&quot;);
 75     }
 76   } else {
 77     _virtual_space = new PSVirtualSpace(rs, alignment);
 78   }
 79   if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
 80     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 81                                   &quot;object heap&quot;);
 82   }
 83 }
 84 
 85 void PSOldGen::initialize_work(const char* perf_data_name, int level) {
 86   //
 87   // Basic memory initialization
 88   //
 89 
 90   MemRegion limit_reserved((HeapWord*)virtual_space()-&gt;low_boundary(),
 91     heap_word_size(_max_gen_size));
</pre>
<hr />
<pre>
118   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
119   PSCardTable* ct = heap-&gt;card_table();
120   ct-&gt;resize_covered_region(cmr);
121 
122   // Verify that the start and end of this generation is the start of a card.
123   // If this wasn&#39;t true, a single card could span more than one generation,
124   // which would cause problems when we commit/uncommit memory, and when we
125   // clear and dirty cards.
126   guarantee(ct-&gt;is_card_aligned(_reserved.start()), &quot;generation must be card aligned&quot;);
127   if (_reserved.end() != heap-&gt;reserved_region().end()) {
128     // Don&#39;t check at the very end of the heap as we&#39;ll assert that we&#39;re probing off
129     // the end if we try.
130     guarantee(ct-&gt;is_card_aligned(_reserved.end()), &quot;generation must be card aligned&quot;);
131   }
132 
133   //
134   // ObjectSpace stuff
135   //
136 
137   _object_space = new MutableSpace(virtual_space()-&gt;alignment());




138   object_space()-&gt;initialize(cmr,
139                              SpaceDecorator::Clear,
140                              SpaceDecorator::Mangle);
141 








142   // Update the start_array
143   start_array()-&gt;set_covered_region(cmr);
144 }
145 
146 void PSOldGen::initialize_performance_counters(const char* perf_data_name, int level) {
147   // Generation Counters, generation &#39;level&#39;, 1 subspace
148   _gen_counters = new PSGenerationCounters(perf_data_name, level, 1, _min_gen_size,
149                                            _max_gen_size, virtual_space());
150   _space_counters = new SpaceCounters(perf_data_name, 0,
151                                       virtual_space()-&gt;reserved_size(),
152                                       _object_space, _gen_counters);
153 }
154 
155 // Assume that the generation has been allocated if its
156 // reserved size is not 0.
157 bool  PSOldGen::is_allocated() {
158   return virtual_space()-&gt;reserved_size() != 0;
159 }
160 
























161 size_t PSOldGen::contiguous_available() const {
162   return object_space()-&gt;free_in_bytes() + virtual_space()-&gt;uncommitted_size();
163 }
164 
165 // Allocation. We report all successful allocations to the size policy
166 // Note that the perm gen does not use this method, and should not!
167 HeapWord* PSOldGen::allocate(size_t word_size) {
168   assert_locked_or_safepoint(Heap_lock);
169   HeapWord* res = allocate_noexpand(word_size);
170 
171   if (res == NULL) {
172     res = expand_and_allocate(word_size);
173   }
174 
175   // Allocations in the old generation need to be reported
176   if (res != NULL) {
177     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
178     heap-&gt;size_policy()-&gt;tenured_allocation(word_size * HeapWordSize);
179   }
180 
181   return res;
182 }
183 
184 HeapWord* PSOldGen::expand_and_allocate(size_t word_size) {
185   expand(word_size*HeapWordSize);
186   if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">187     os::naked_sleep(GCExpandToAllocateDelayMillis);</span>
188   }
189   return allocate_noexpand(word_size);
190 }
191 
192 HeapWord* PSOldGen::expand_and_cas_allocate(size_t word_size) {
193   expand(word_size*HeapWordSize);
194   if (GCExpandToAllocateDelayMillis &gt; 0) {
<span class="line-modified">195     os::naked_sleep(GCExpandToAllocateDelayMillis);</span>
196   }
197   return cas_allocate_noexpand(word_size);
198 }
199 
200 void PSOldGen::expand(size_t bytes) {
201   if (bytes == 0) {
202     return;
203   }
204   MutexLocker x(ExpandHeap_lock);
205   const size_t alignment = virtual_space()-&gt;alignment();
206   size_t aligned_bytes  = align_up(bytes, alignment);
207   size_t aligned_expand_bytes = align_up(MinHeapDeltaBytes, alignment);
208 
209   if (UseNUMA) {
210     // With NUMA we use round-robin page allocation for the old gen. Expand by at least
211     // providing a page per lgroup. Alignment is larger or equal to the page size.
212     aligned_expand_bytes = MAX2(aligned_expand_bytes, alignment * os::numa_get_groups_num());
213   }
214   if (aligned_bytes == 0){
215     // The alignment caused the number of bytes to wrap.  An expand_by(0) will
</pre>
<hr />
<pre>
297     assert_lock_strong(ExpandHeap_lock);
298     virtual_space()-&gt;shrink_by(bytes);
299     post_resize();
300 
301     size_t new_mem_size = virtual_space()-&gt;committed_size();
302     size_t old_mem_size = new_mem_size + bytes;
303     log_debug(gc)(&quot;Shrinking %s from &quot; SIZE_FORMAT &quot;K by &quot; SIZE_FORMAT &quot;K to &quot; SIZE_FORMAT &quot;K&quot;,
304                   name(), old_mem_size/K, bytes/K, new_mem_size/K);
305   }
306 }
307 
308 void PSOldGen::resize(size_t desired_free_space) {
309   const size_t alignment = virtual_space()-&gt;alignment();
310   const size_t size_before = virtual_space()-&gt;committed_size();
311   size_t new_size = used_in_bytes() + desired_free_space;
312   if (new_size &lt; used_in_bytes()) {
313     // Overflowed the addition.
314     new_size = gen_size_limit();
315   }
316   // Adjust according to our min and max
<span class="line-modified">317   new_size = clamp(new_size, min_gen_size(), gen_size_limit());</span>
318 
319   assert(gen_size_limit() &gt;= reserved().byte_size(), &quot;max new size problem?&quot;);
320   new_size = align_up(new_size, alignment);
321 
322   const size_t current_size = capacity_in_bytes();
323 
324   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::old generation size: &quot;
325     &quot;desired free: &quot; SIZE_FORMAT &quot; used: &quot; SIZE_FORMAT
326     &quot; new size: &quot; SIZE_FORMAT &quot; current size &quot; SIZE_FORMAT
327     &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
328     desired_free_space, used_in_bytes(), new_size, current_size,
329     gen_size_limit(), min_gen_size());
330 
331   if (new_size == current_size) {
332     // No change requested
333     return;
334   }
335   if (new_size &gt; current_size) {
336     size_t change_bytes = new_size - current_size;
337     expand(change_bytes);
</pre>
<hr />
<pre>
385 }
386 
387 size_t PSOldGen::available_for_contraction() {
388   ShouldNotReachHere();
389   return 0;
390 }
391 
392 void PSOldGen::print() const { print_on(tty);}
393 void PSOldGen::print_on(outputStream* st) const {
394   st-&gt;print(&quot; %-15s&quot;, name());
395   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
396               capacity_in_bytes()/K, used_in_bytes()/K);
397   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
398                 p2i(virtual_space()-&gt;low_boundary()),
399                 p2i(virtual_space()-&gt;high()),
400                 p2i(virtual_space()-&gt;high_boundary()));
401 
402   st-&gt;print(&quot;  object&quot;); object_space()-&gt;print_on(st);
403 }
404 





405 void PSOldGen::update_counters() {
406   if (UsePerfData) {
407     _space_counters-&gt;update_all();
408     _gen_counters-&gt;update_all();
409   }
410 }
411 
412 #ifndef PRODUCT
413 
414 void PSOldGen::space_invariants() {
415   assert(object_space()-&gt;end() == (HeapWord*) virtual_space()-&gt;high(),
416     &quot;Space invariant&quot;);
417   assert(object_space()-&gt;bottom() == (HeapWord*) virtual_space()-&gt;low(),
418     &quot;Space invariant&quot;);
419   assert(virtual_space()-&gt;low_boundary() &lt;= virtual_space()-&gt;low(),
420     &quot;Space invariant&quot;);
421   assert(virtual_space()-&gt;high_boundary() &gt;= virtual_space()-&gt;high(),
422     &quot;Space invariant&quot;);
423   assert(virtual_space()-&gt;low_boundary() == (char*) _reserved.start(),
424     &quot;Space invariant&quot;);
425   assert(virtual_space()-&gt;high_boundary() == (char*) _reserved.end(),
426     &quot;Space invariant&quot;);
427   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
428     &quot;Space invariant&quot;);
429 }
430 #endif
431 
432 void PSOldGen::verify() {
433   object_space()-&gt;verify();
434 }
435 class VerifyObjectStartArrayClosure : public ObjectClosure {
436   PSOldGen* _old_gen;
437   ObjectStartArray* _start_array;
438 
439  public:
440   VerifyObjectStartArrayClosure(PSOldGen* old_gen, ObjectStartArray* start_array) :
441     _old_gen(old_gen), _start_array(start_array) { }
442 
443   virtual void do_object(oop obj) {
<span class="line-modified">444     HeapWord* test_addr = cast_from_oop&lt;HeapWord*&gt;(obj) + 1;</span>
<span class="line-modified">445     guarantee(_start_array-&gt;object_start(test_addr) == cast_from_oop&lt;HeapWord*&gt;(obj), &quot;ObjectStartArray cannot find start of object&quot;);</span>
<span class="line-modified">446     guarantee(_start_array-&gt;is_block_allocated(cast_from_oop&lt;HeapWord*&gt;(obj)), &quot;ObjectStartArray missing block allocation&quot;);</span>
447   }
448 };
449 
450 void PSOldGen::verify_object_start_array() {
451   VerifyObjectStartArrayClosure check( this, &amp;_start_array );
452   object_iterate(&amp;check);
453 }
454 
455 #ifndef PRODUCT
456 void PSOldGen::record_spaces_top() {
457   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
458   object_space()-&gt;set_top_for_allocations();
459 }
460 #endif
</pre>
</td>
</tr>
</table>
<center><a href="psFileBackedVirtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psOldGen.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
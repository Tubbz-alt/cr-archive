<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psParallelCompact.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionLAB.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psParallelCompact.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  26 #define SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  27 
  28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
  29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
  30 #include &quot;gc/parallel/parMarkBitMap.hpp&quot;
  31 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.hpp&quot;
  33 #include &quot;gc/shared/collectorCounters.hpp&quot;
  34 #include &quot;oops/oop.hpp&quot;


  35 
  36 class ParallelScavengeHeap;
  37 class PSAdaptiveSizePolicy;
  38 class PSYoungGen;
  39 class PSOldGen;
  40 class ParCompactionManager;
<span class="line-removed">  41 class ParallelTaskTerminator;</span>
  42 class PSParallelCompact;
<span class="line-removed">  43 class GCTaskManager;</span>
<span class="line-removed">  44 class GCTaskQueue;</span>
<span class="line-removed">  45 class PreGCValues;</span>
  46 class MoveAndUpdateClosure;
  47 class RefProcTaskExecutor;
  48 class ParallelOldTracer;
  49 class STWGCTimer;
  50 
  51 // The SplitInfo class holds the information needed to &#39;split&#39; a source region
  52 // so that the live data can be copied to two destination *spaces*.  Normally,
  53 // all the live data in a region is copied to a single destination space (e.g.,
  54 // everything live in a region in eden is copied entirely into the old gen).
  55 // However, when the heap is nearly full, all the live data in eden may not fit
  56 // into the old gen.  Copying only some of the regions from eden to old gen
  57 // requires finding a region that does not contain a partial object (i.e., no
  58 // live object crosses the region boundary) somewhere near the last object that
  59 // does fit into the old gen.  Since it&#39;s not always possible to find such a
  60 // region, splitting is necessary for predictable behavior.
  61 //
  62 // A region is always split at the end of the partial object.  This avoids
  63 // additional tests when calculating the new location of a pointer, which is a
  64 // very hot code path.  The partial object and everything to its left will be
  65 // copied to another space (call it dest_space_1).  The live data to the right
</pre>
<hr />
<pre>
 224   static const size_t Log2BlockSize;
 225   static const size_t BlockSize;
 226   static const size_t BlockSizeBytes;
 227 
 228   static const size_t BlockSizeOffsetMask;
 229   static const size_t BlockAddrOffsetMask;
 230   static const size_t BlockAddrMask;
 231 
 232   static const size_t BlocksPerRegion;
 233   static const size_t Log2BlocksPerRegion;
 234 
 235   class RegionData
 236   {
 237   public:
 238     // Destination address of the region.
 239     HeapWord* destination() const { return _destination; }
 240 
 241     // The first region containing data destined for this region.
 242     size_t source_region() const { return _source_region; }
 243 



 244     // The object (if any) starting in this region and ending in a different
 245     // region that could not be updated during the main (parallel) compaction
 246     // phase.  This is different from _partial_obj_addr, which is an object that
 247     // extends onto a source region.  However, the two uses do not overlap in
 248     // time, so the same field is used to save space.
 249     HeapWord* deferred_obj_addr() const { return _partial_obj_addr; }
 250 
 251     // The starting address of the partial object extending onto the region.
 252     HeapWord* partial_obj_addr() const { return _partial_obj_addr; }
 253 
 254     // Size of the partial object extending onto the region (words).
 255     size_t partial_obj_size() const { return _partial_obj_size; }
 256 
 257     // Size of live data that lies within this region due to objects that start
 258     // in this region (words).  This does not include the partial object
 259     // extending onto the region (if any), or the part of an object that extends
 260     // onto the next region (if any).
 261     size_t live_obj_size() const { return _dc_and_los &amp; los_mask; }
 262 
 263     // Total live data that lies within the region (words).
</pre>
<hr />
<pre>
 292 
 293     // The location of the java heap data that corresponds to this region.
 294     inline HeapWord* data_location() const;
 295 
 296     // The highest address referenced by objects in this region.
 297     inline HeapWord* highest_ref() const;
 298 
 299     // Whether this region is available to be claimed, has been claimed, or has
 300     // been completed.
 301     //
 302     // Minor subtlety:  claimed() returns true if the region is marked
 303     // completed(), which is desirable since a region must be claimed before it
 304     // can be completed.
 305     bool available() const { return _dc_and_los &lt; dc_one; }
 306     bool claimed()   const { return _dc_and_los &gt;= dc_claimed; }
 307     bool completed() const { return _dc_and_los &gt;= dc_completed; }
 308 
 309     // These are not atomic.
 310     void set_destination(HeapWord* addr)       { _destination = addr; }
 311     void set_source_region(size_t region)      { _source_region = region; }

 312     void set_deferred_obj_addr(HeapWord* addr) { _partial_obj_addr = addr; }
 313     void set_partial_obj_addr(HeapWord* addr)  { _partial_obj_addr = addr; }
 314     void set_partial_obj_size(size_t words)    {
 315       _partial_obj_size = (region_sz_t) words;
 316     }
 317     inline void set_blocks_filled();
 318 
 319     inline void set_destination_count(uint count);
 320     inline void set_live_obj_size(size_t words);
 321     inline void set_data_location(HeapWord* addr);
 322     inline void set_completed();
 323     inline bool claim_unsafe();
 324 
 325     // These are atomic.
 326     inline void add_live_obj(size_t words);
 327     inline void set_highest_ref(HeapWord* addr);
 328     inline void decrement_destination_count();
 329     inline bool claim();
 330 


























 331   private:
 332     // The type used to represent object sizes within a region.
 333     typedef uint region_sz_t;
 334 
 335     // Constants for manipulating the _dc_and_los field, which holds both the
 336     // destination count and live obj size.  The live obj size lives at the
 337     // least significant end so no masking is necessary when adding.
 338     static const region_sz_t dc_shift;           // Shift amount.
 339     static const region_sz_t dc_mask;            // Mask for destination count.
 340     static const region_sz_t dc_one;             // 1, shifted appropriately.
 341     static const region_sz_t dc_claimed;         // Region has been claimed.
 342     static const region_sz_t dc_completed;       // Region has been completed.
 343     static const region_sz_t los_mask;           // Mask for live obj size.
 344 
 345     HeapWord*            _destination;
 346     size_t               _source_region;
 347     HeapWord*            _partial_obj_addr;
 348     region_sz_t          _partial_obj_size;
 349     region_sz_t volatile _dc_and_los;
 350     bool        volatile _blocks_filled;

 351 
 352 #ifdef ASSERT
 353     size_t               _blocks_filled_count;   // Number of block table fills.
 354 
 355     // These enable optimizations that are only partially implemented.  Use
 356     // debug builds to prevent the code fragments from breaking.
 357     HeapWord*            _data_location;
 358     HeapWord*            _highest_ref;
 359 #endif  // #ifdef ASSERT
 360 
 361 #ifdef ASSERT
 362    public:
 363     uint                 _pushed;   // 0 until region is pushed onto a stack
 364    private:
 365 #endif
 366   };
 367 
 368   // &quot;Blocks&quot; allow shorter sections of the bitmap to be searched.  Each Block
 369   // holds an offset, which is the amount of live data in the Region to the left
 370   // of the first live object that starts in the Block.
</pre>
<hr />
<pre>
 379   private:
 380     blk_ofs_t _offset;
 381   };
 382 
 383 public:
 384   ParallelCompactData();
 385   bool initialize(MemRegion covered_region);
 386 
 387   size_t region_count() const { return _region_count; }
 388   size_t reserved_byte_size() const { return _reserved_byte_size; }
 389 
 390   // Convert region indices to/from RegionData pointers.
 391   inline RegionData* region(size_t region_idx) const;
 392   inline size_t     region(const RegionData* const region_ptr) const;
 393 
 394   size_t block_count() const { return _block_count; }
 395   inline BlockData* block(size_t block_idx) const;
 396   inline size_t     block(const BlockData* block_ptr) const;
 397 
 398   void add_obj(HeapWord* addr, size_t len);
<span class="line-modified"> 399   void add_obj(oop p, size_t len) { add_obj((HeapWord*)p, len); }</span>
 400 
 401   // Fill in the regions covering [beg, end) so that no data moves; i.e., the
 402   // destination of region n is simply the start of region n.  The argument beg
 403   // must be region-aligned; end need not be.
 404   void summarize_dense_prefix(HeapWord* beg, HeapWord* end);
 405 
 406   HeapWord* summarize_split_space(size_t src_region, SplitInfo&amp; split_info,
 407                                   HeapWord* destination, HeapWord* target_end,
 408                                   HeapWord** target_next);
 409   bool summarize(SplitInfo&amp; split_info,
 410                  HeapWord* source_beg, HeapWord* source_end,
 411                  HeapWord** source_next,
 412                  HeapWord* target_beg, HeapWord* target_end,
 413                  HeapWord** target_next);
 414 
 415   void clear();
 416   void clear_range(size_t beg_region, size_t end_region);
 417   void clear_range(HeapWord* beg, HeapWord* end) {
 418     clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));
 419   }
 420 
 421   // Return the number of words between addr and the start of the region
 422   // containing addr.
 423   inline size_t     region_offset(const HeapWord* addr) const;
 424 
 425   // Convert addresses to/from a region index or region pointer.
 426   inline size_t     addr_to_region_idx(const HeapWord* addr) const;
 427   inline RegionData* addr_to_region_ptr(const HeapWord* addr) const;
 428   inline HeapWord*  region_to_addr(size_t region) const;
 429   inline HeapWord*  region_to_addr(size_t region, size_t offset) const;
 430   inline HeapWord*  region_to_addr(const RegionData* region) const;
 431 
 432   inline HeapWord*  region_align_down(HeapWord* addr) const;
 433   inline HeapWord*  region_align_up(HeapWord* addr) const;
 434   inline bool       is_region_aligned(HeapWord* addr) const;
 435 
 436   // Analogous to region_offset() for blocks.
 437   size_t     block_offset(const HeapWord* addr) const;
 438   size_t     addr_to_block_idx(const HeapWord* addr) const;
 439   size_t     addr_to_block_idx(const oop obj) const {
<span class="line-modified"> 440     return addr_to_block_idx((HeapWord*) obj);</span>
 441   }
 442   inline BlockData* addr_to_block_ptr(const HeapWord* addr) const;
 443   inline HeapWord*  block_to_addr(size_t block) const;
 444   inline size_t     region_to_block_idx(size_t region) const;
 445 
 446   inline HeapWord*  block_align_down(HeapWord* addr) const;
 447   inline HeapWord*  block_align_up(HeapWord* addr) const;
 448   inline bool       is_block_aligned(HeapWord* addr) const;
 449 
 450   // Return the address one past the end of the partial object.
 451   HeapWord* partial_obj_end(size_t region_idx) const;
 452 
 453   // Return the location of the object after compaction.
 454   HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm);
 455 
 456   HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) {
<span class="line-modified"> 457     return calc_new_pointer((HeapWord*) p, cm);</span>
 458   }
 459 
 460 #ifdef  ASSERT
 461   void verify_clear(const PSVirtualSpace* vspace);
 462   void verify_clear();
 463 #endif  // #ifdef ASSERT
 464 
 465 private:
 466   bool initialize_block_data();
 467   bool initialize_region_data(size_t region_size);
 468   PSVirtualSpace* create_vspace(size_t count, size_t element_size);
 469 
 470 private:
 471   HeapWord*       _region_start;
 472 #ifdef  ASSERT
 473   HeapWord*       _region_end;
 474 #endif  // #ifdef ASSERT
 475 
 476   PSVirtualSpace* _region_vspace;
 477   size_t          _reserved_byte_size;
</pre>
<hr />
<pre>
 521 }
 522 
 523 inline void
 524 ParallelCompactData::RegionData::set_destination_count(uint count)
 525 {
 526   assert(count &lt;= (dc_completed &gt;&gt; dc_shift), &quot;count too large&quot;);
 527   const region_sz_t live_sz = (region_sz_t) live_obj_size();
 528   _dc_and_los = (count &lt;&lt; dc_shift) | live_sz;
 529 }
 530 
 531 inline void ParallelCompactData::RegionData::set_live_obj_size(size_t words)
 532 {
 533   assert(words &lt;= los_mask, &quot;would overflow&quot;);
 534   _dc_and_los = destination_count_raw() | (region_sz_t)words;
 535 }
 536 
 537 inline void ParallelCompactData::RegionData::decrement_destination_count()
 538 {
 539   assert(_dc_and_los &lt; dc_claimed, &quot;already claimed&quot;);
 540   assert(_dc_and_los &gt;= dc_one, &quot;count would go negative&quot;);
<span class="line-modified"> 541   Atomic::add(dc_mask, &amp;_dc_and_los);</span>
 542 }
 543 
 544 inline HeapWord* ParallelCompactData::RegionData::data_location() const
 545 {
 546   DEBUG_ONLY(return _data_location;)
 547   NOT_DEBUG(return NULL;)
 548 }
 549 
 550 inline HeapWord* ParallelCompactData::RegionData::highest_ref() const
 551 {
 552   DEBUG_ONLY(return _highest_ref;)
 553   NOT_DEBUG(return NULL;)
 554 }
 555 
 556 inline void ParallelCompactData::RegionData::set_data_location(HeapWord* addr)
 557 {
 558   DEBUG_ONLY(_data_location = addr;)
 559 }
 560 
 561 inline void ParallelCompactData::RegionData::set_completed()
 562 {
 563   assert(claimed(), &quot;must be claimed first&quot;);
 564   _dc_and_los = dc_completed | (region_sz_t) live_obj_size();
 565 }
 566 
 567 // MT-unsafe claiming of a region.  Should only be used during single threaded
 568 // execution.
 569 inline bool ParallelCompactData::RegionData::claim_unsafe()
 570 {
 571   if (available()) {
 572     _dc_and_los |= dc_claimed;
 573     return true;
 574   }
 575   return false;
 576 }
 577 
 578 inline void ParallelCompactData::RegionData::add_live_obj(size_t words)
 579 {
 580   assert(words &lt;= (size_t)los_mask - live_obj_size(), &quot;overflow&quot;);
<span class="line-modified"> 581   Atomic::add(static_cast&lt;region_sz_t&gt;(words), &amp;_dc_and_los);</span>
 582 }
 583 
 584 inline void ParallelCompactData::RegionData::set_highest_ref(HeapWord* addr)
 585 {
 586 #ifdef ASSERT
 587   HeapWord* tmp = _highest_ref;
 588   while (addr &gt; tmp) {
<span class="line-modified"> 589     tmp = Atomic::cmpxchg(addr, &amp;_highest_ref, tmp);</span>
 590   }
 591 #endif  // #ifdef ASSERT
 592 }
 593 
 594 inline bool ParallelCompactData::RegionData::claim()
 595 {
 596   const region_sz_t los = static_cast&lt;region_sz_t&gt;(live_obj_size());
<span class="line-modified"> 597   const region_sz_t old = Atomic::cmpxchg(dc_claimed | los, &amp;_dc_and_los, los);</span>
 598   return old == los;
 599 }
 600 























 601 inline ParallelCompactData::RegionData*
 602 ParallelCompactData::region(size_t region_idx) const
 603 {
 604   assert(region_idx &lt;= region_count(), &quot;bad arg&quot;);
 605   return _region_data + region_idx;
 606 }
 607 
 608 inline size_t
 609 ParallelCompactData::region(const RegionData* const region_ptr) const
 610 {
 611   assert(region_ptr &gt;= _region_data, &quot;bad arg&quot;);
 612   assert(region_ptr &lt;= _region_data + region_count(), &quot;bad arg&quot;);
 613   return pointer_delta(region_ptr, _region_data, sizeof(RegionData));
 614 }
 615 
 616 inline ParallelCompactData::BlockData*
 617 ParallelCompactData::block(size_t n) const {
 618   assert(n &lt; block_count(), &quot;bad arg&quot;);
 619   return _block_data + n;
 620 }
</pre>
<hr />
<pre>
 810   return _words_remaining;
 811 }
 812 
 813 inline bool ParMarkBitMapClosure::is_full() const {
 814   return words_remaining() == 0;
 815 }
 816 
 817 inline HeapWord* ParMarkBitMapClosure::source() const {
 818   return _source;
 819 }
 820 
 821 inline void ParMarkBitMapClosure::set_source(HeapWord* addr) {
 822   _source = addr;
 823 }
 824 
 825 inline void ParMarkBitMapClosure::decrement_words_remaining(size_t words) {
 826   assert(_words_remaining &gt;= words, &quot;processed too many words&quot;);
 827   _words_remaining -= words;
 828 }
 829 
<span class="line-modified"> 830 // The UseParallelOldGC collector is a stop-the-world garbage collector that</span>
 831 // does parts of the collection using parallel threads.  The collection includes
<span class="line-modified"> 832 // the tenured generation and the young generation.  The permanent generation is</span>
<span class="line-removed"> 833 // collected at the same time as the other two generations but the permanent</span>
<span class="line-removed"> 834 // generation is collect by a single GC thread.  The permanent generation is</span>
<span class="line-removed"> 835 // collected serially because of the requirement that during the processing of a</span>
<span class="line-removed"> 836 // klass AAA, any objects reference by AAA must already have been processed.</span>
<span class="line-removed"> 837 // This requirement is enforced by a left (lower address) to right (higher</span>
<span class="line-removed"> 838 // address) sliding compaction.</span>
 839 //
 840 // There are four phases of the collection.
 841 //
 842 //      - marking phase
 843 //      - summary phase
 844 //      - compacting phase
 845 //      - clean up phase
 846 //
 847 // Roughly speaking these phases correspond, respectively, to
 848 //      - mark all the live objects
 849 //      - calculate the destination of each object at the end of the collection
 850 //      - move the objects to their destination
 851 //      - update some references and reinitialize some variables
 852 //
 853 // These three phases are invoked in PSParallelCompact::invoke_no_policy().  The
 854 // marking phase is implemented in PSParallelCompact::marking_phase() and does a
 855 // complete marking of the heap.  The summary phase is implemented in
 856 // PSParallelCompact::summary_phase().  The move and update phase is implemented
 857 // in PSParallelCompact::compact().
 858 //
</pre>
<hr />
<pre>
 897 // references in the object.
 898 //
 899 // A current exception is that objects that cross a region boundary are moved
 900 // but do not have their references updated.  References are not updated because
 901 // it cannot easily be determined if the klass pointer KKK for the object AAA
 902 // has been updated.  KKK likely resides in a region to the left of the region
 903 // containing AAA.  These AAA&#39;s have there references updated at the end in a
 904 // clean up phase.  See the method PSParallelCompact::update_deferred_objects().
 905 // An alternate strategy is being investigated for this deferral of updating.
 906 //
 907 // Compaction is done on a region basis.  A region that is ready to be filled is
 908 // put on a ready list and GC threads take region off the list and fill them.  A
 909 // region is ready to be filled if it empty of live objects.  Such a region may
 910 // have been initially empty (only contained dead objects) or may have had all
 911 // its live objects copied out already.  A region that compacts into itself is
 912 // also ready for filling.  The ready list is initially filled with empty
 913 // regions and regions compacting into themselves.  There is always at least 1
 914 // region that can be put on the ready list.  The regions are atomically added
 915 // and removed from the ready list.
 916 


 917 class PSParallelCompact : AllStatic {
 918  public:
 919   // Convenient access to type names.
 920   typedef ParMarkBitMap::idx_t idx_t;
 921   typedef ParallelCompactData::RegionData RegionData;
 922   typedef ParallelCompactData::BlockData BlockData;
 923 
 924   typedef enum {
 925     old_space_id, eden_space_id,
 926     from_space_id, to_space_id, last_space_id
 927   } SpaceId;
 928 


















 929  public:
 930   // Inline closure decls
 931   //
 932   class IsAliveClosure: public BoolObjectClosure {
 933    public:
 934     virtual bool do_object_b(oop p);
 935   };
 936 
 937   friend class RefProcTaskProxy;
 938   friend class PSParallelCompactTest;
 939 
 940  private:
 941   static STWGCTimer           _gc_timer;
 942   static ParallelOldTracer    _gc_tracer;
 943   static elapsedTimer         _accumulated_time;
 944   static unsigned int         _total_invocations;
 945   static unsigned int         _maximum_compaction_gc_num;
 946   static jlong                _time_of_last_gc;   // ms
 947   static CollectorCounters*   _counters;
 948   static ParMarkBitMap        _mark_bitmap;
</pre>
<hr />
<pre>
1034 
1035   // Summary phase utility routine to fill dead space (if any) at the dense
1036   // prefix boundary.  Should only be called if the the dense prefix is
1037   // non-empty.
1038   static void fill_dense_prefix_end(SpaceId id);
1039 
1040   static void summarize_spaces_quick();
1041   static void summarize_space(SpaceId id, bool maximum_compaction);
1042   static void summary_phase(ParCompactionManager* cm, bool maximum_compaction);
1043 
1044   // Adjust addresses in roots.  Does not adjust addresses in heap.
1045   static void adjust_roots(ParCompactionManager* cm);
1046 
1047   DEBUG_ONLY(static void write_block_fill_histogram();)
1048 
1049   // Move objects to new locations.
1050   static void compact_perm(ParCompactionManager* cm);
1051   static void compact();
1052 
1053   // Add available regions to the stack and draining tasks to the task queue.
<span class="line-modified">1054   static void prepare_region_draining_tasks(GCTaskQueue* q,</span>
<span class="line-removed">1055                                             uint parallel_gc_threads);</span>
1056 
1057   // Add dense prefix update tasks to the task queue.
<span class="line-modified">1058   static void enqueue_dense_prefix_tasks(GCTaskQueue* q,</span>
1059                                          uint parallel_gc_threads);
1060 
<span class="line-removed">1061   // Add region stealing tasks to the task queue.</span>
<span class="line-removed">1062   static void enqueue_region_stealing_tasks(</span>
<span class="line-removed">1063                                        GCTaskQueue* q,</span>
<span class="line-removed">1064                                        ParallelTaskTerminator* terminator_ptr,</span>
<span class="line-removed">1065                                        uint parallel_gc_threads);</span>
<span class="line-removed">1066 </span>
1067   // If objects are left in eden after a collection, try to move the boundary
1068   // and absorb them into the old gen.  Returns true if eden was emptied.
1069   static bool absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1070                                          PSYoungGen* young_gen,
1071                                          PSOldGen* old_gen);
1072 
1073   // Reset time since last full gc
1074   static void reset_millis_since_last_gc();
1075 
1076 #ifndef PRODUCT
1077   // Print generic summary data
1078   static void print_generic_summary_data(ParallelCompactData&amp; summary_data,
1079                                          HeapWord* const beg_addr,
1080                                          HeapWord* const end_addr);
1081 #endif  // #ifndef PRODUCT
1082 
1083  public:
1084 
1085   PSParallelCompact();
1086 
1087   static void invoke(bool maximum_heap_compaction);
1088   static bool invoke_no_policy(bool maximum_heap_compaction);
1089 
1090   static void post_initialize();
1091   // Perform initialization for PSParallelCompact that requires
1092   // allocations.  This should be called during the VM initialization
1093   // at a pointer where it would be appropriate to return a JNI_ENOMEM
1094   // in the event of a failure.
1095   static bool initialize();
1096 
1097   // Closure accessors
1098   static BoolObjectClosure* is_alive_closure()     { return (BoolObjectClosure*)&amp;_is_alive_closure; }
1099 
1100   // Public accessors
1101   static elapsedTimer* accumulated_time() { return &amp;_accumulated_time; }
1102   static unsigned int total_invocations() { return _total_invocations; }
1103   static CollectorCounters* counters()    { return _counters; }
1104 
<span class="line-removed">1105   // Used to add tasks</span>
<span class="line-removed">1106   static GCTaskManager* const gc_task_manager();</span>
<span class="line-removed">1107 </span>
1108   // Marking support
1109   static inline bool mark_obj(oop obj);
1110   static inline bool is_marked(oop obj);
1111 
1112   template &lt;class T&gt; static inline void adjust_pointer(T* p, ParCompactionManager* cm);
1113 
1114   // Compaction support.
1115   // Return true if p is in the range [beg_addr, end_addr).
1116   static inline bool is_in(HeapWord* p, HeapWord* beg_addr, HeapWord* end_addr);
1117   static inline bool is_in(oop* p, HeapWord* beg_addr, HeapWord* end_addr);
1118 
1119   // Convenience wrappers for per-space data kept in _space_info.
1120   static inline MutableSpace*     space(SpaceId space_id);
1121   static inline HeapWord*         new_top(SpaceId space_id);
1122   static inline HeapWord*         dense_prefix(SpaceId space_id);
1123   static inline ObjectStartArray* start_array(SpaceId space_id);
1124 
<span class="line-removed">1125   // Move and update the live objects in the specified space.</span>
<span class="line-removed">1126   static void move_and_update(ParCompactionManager* cm, SpaceId space_id);</span>
<span class="line-removed">1127 </span>
1128   // Process the end of the given region range in the dense prefix.
1129   // This includes saving any object not updated.
1130   static void dense_prefix_regions_epilogue(ParCompactionManager* cm,
1131                                             size_t region_start_index,
1132                                             size_t region_end_index,
1133                                             idx_t exiting_object_offset,
1134                                             idx_t region_offset_start,
1135                                             idx_t region_offset_end);
1136 
1137   // Update a region in the dense prefix.  For each live object
1138   // in the region, update it&#39;s interior references.  For each
1139   // dead object, fill it with deadwood. Dead space at the end
1140   // of a region range will be filled to the start of the next
1141   // live object regardless of the region_index_end.  None of the
1142   // objects in the dense prefix move and dead space is dead
1143   // (holds only dead objects that don&#39;t need any processing), so
1144   // dead space can be filled in any order.
1145   static void update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,
1146                                                   SpaceId space_id,
1147                                                   size_t region_index_start,
</pre>
<hr />
<pre>
1157                                   size_t src_region_idx);
1158 
1159   // Determine the next source region, set closure.source() to the start of the
1160   // new region return the region index.  Parameter end_addr is the address one
1161   // beyond the end of source range just processed.  If necessary, switch to a
1162   // new source space and set src_space_id (in-out parameter) and src_space_top
1163   // (out parameter) accordingly.
1164   static size_t next_src_region(MoveAndUpdateClosure&amp; closure,
1165                                 SpaceId&amp; src_space_id,
1166                                 HeapWord*&amp; src_space_top,
1167                                 HeapWord* end_addr);
1168 
1169   // Decrement the destination count for each non-empty source region in the
1170   // range [beg_region, region(region_align_up(end_addr))).  If the destination
1171   // count for a region goes to 0 and it needs to be filled, enqueue it.
1172   static void decrement_destination_counts(ParCompactionManager* cm,
1173                                            SpaceId src_space_id,
1174                                            size_t beg_region,
1175                                            HeapWord* end_addr);
1176 
<span class="line-modified">1177   // Fill a region, copying objects from one or more source regions.</span>
<span class="line-modified">1178   static void fill_region(ParCompactionManager* cm, size_t region_idx);</span>
<span class="line-modified">1179   static void fill_and_update_region(ParCompactionManager* cm, size_t region) {</span>
<span class="line-modified">1180     fill_region(cm, region);</span>
<span class="line-modified">1181   }</span>





1182 
1183   // Fill in the block table for the specified region.
1184   static void fill_blocks(size_t region_idx);
1185 
1186   // Update the deferred objects in the space.
1187   static void update_deferred_objects(ParCompactionManager* cm, SpaceId id);
1188 
1189   static ParMarkBitMap* mark_bitmap() { return &amp;_mark_bitmap; }
1190   static ParallelCompactData&amp; summary_data() { return _summary_data; }
1191 
1192   // Reference Processing
1193   static ReferenceProcessor* const ref_processor() { return _ref_processor; }
1194 
1195   static STWGCTimer* gc_timer() { return &amp;_gc_timer; }
1196 
1197   // Return the SpaceId for the given address.
1198   static SpaceId space_id(HeapWord* addr);
1199 
1200   // Time since last full gc (in milliseconds).
1201   static jlong millis_since_last_gc();
</pre>
<hr />
<pre>
1208   static void print_region_ranges();
1209   static void print_dense_prefix_stats(const char* const algorithm,
1210                                        const SpaceId id,
1211                                        const bool maximum_compaction,
1212                                        HeapWord* const addr);
1213   static void summary_phase_msg(SpaceId dst_space_id,
1214                                 HeapWord* dst_beg, HeapWord* dst_end,
1215                                 SpaceId src_space_id,
1216                                 HeapWord* src_beg, HeapWord* src_end);
1217 #endif  // #ifndef PRODUCT
1218 
1219 #ifdef  ASSERT
1220   // Sanity check the new location of a word in the heap.
1221   static inline void check_new_location(HeapWord* old_addr, HeapWord* new_addr);
1222   // Verify that all the regions have been emptied.
1223   static void verify_complete(SpaceId space_id);
1224 #endif  // #ifdef ASSERT
1225 };
1226 
1227 class MoveAndUpdateClosure: public ParMarkBitMapClosure {

1228  public:
1229   inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,
<span class="line-modified">1230                               ObjectStartArray* start_array,</span>
<span class="line-removed">1231                               HeapWord* destination, size_t words);</span>
1232 
1233   // Accessors.
1234   HeapWord* destination() const         { return _destination; }

1235 
1236   // If the object will fit (size &lt;= words_remaining()), copy it to the current
1237   // destination, update the interior oops and the start array and return either
1238   // full (if the closure is full) or incomplete.  If the object will not fit,
1239   // return would_overflow.
<span class="line-modified">1240   virtual IterationStatus do_addr(HeapWord* addr, size_t size);</span>
1241 
1242   // Copy enough words to fill this closure, starting at source().  Interior
1243   // oops and the start array are not updated.  Return full.
1244   IterationStatus copy_until_full();
1245 
1246   // Copy enough words to fill this closure or to the end of an object,
1247   // whichever is smaller, starting at source().  Interior oops and the start
1248   // array are not updated.
1249   void copy_partial_obj();
1250 
<span class="line-modified">1251  protected:</span>



1252   // Update variables to indicate that word_count words were processed.
1253   inline void update_state(size_t word_count);
1254 
1255  protected:
<span class="line-removed">1256   ObjectStartArray* const _start_array;</span>
1257   HeapWord*               _destination;         // Next addr to be written.


1258 };
1259 









1260 inline
1261 MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,
1262                                            ParCompactionManager* cm,
<span class="line-modified">1263                                            ObjectStartArray* start_array,</span>
<span class="line-modified">1264                                            HeapWord* destination,</span>
<span class="line-modified">1265                                            size_t words) :</span>
<span class="line-modified">1266   ParMarkBitMapClosure(bitmap, cm, words), _start_array(start_array)</span>
<span class="line-modified">1267 {</span>
<span class="line-modified">1268   _destination = destination;</span>
<span class="line-removed">1269 }</span>
1270 
1271 inline void MoveAndUpdateClosure::update_state(size_t words)
1272 {
1273   decrement_words_remaining(words);
1274   _source += words;
1275   _destination += words;
1276 }
1277 






























1278 class UpdateOnlyClosure: public ParMarkBitMapClosure {
1279  private:
1280   const PSParallelCompact::SpaceId _space_id;
1281   ObjectStartArray* const          _start_array;
1282 
1283  public:
1284   UpdateOnlyClosure(ParMarkBitMap* mbm,
1285                     ParCompactionManager* cm,
1286                     PSParallelCompact::SpaceId space_id);
1287 
1288   // Update the object.
1289   virtual IterationStatus do_addr(HeapWord* addr, size_t words);
1290 
1291   inline void do_addr(HeapWord* addr);
1292 };
1293 
1294 class FillClosure: public ParMarkBitMapClosure {
1295  public:
1296   FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id);
1297 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  26 #define SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  27 
  28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
  29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
  30 #include &quot;gc/parallel/parMarkBitMap.hpp&quot;
  31 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.hpp&quot;
  33 #include &quot;gc/shared/collectorCounters.hpp&quot;
  34 #include &quot;oops/oop.hpp&quot;
<span class="line-added">  35 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">  36 #include &quot;runtime/orderAccess.hpp&quot;</span>
  37 
  38 class ParallelScavengeHeap;
  39 class PSAdaptiveSizePolicy;
  40 class PSYoungGen;
  41 class PSOldGen;
  42 class ParCompactionManager;

  43 class PSParallelCompact;



  44 class MoveAndUpdateClosure;
  45 class RefProcTaskExecutor;
  46 class ParallelOldTracer;
  47 class STWGCTimer;
  48 
  49 // The SplitInfo class holds the information needed to &#39;split&#39; a source region
  50 // so that the live data can be copied to two destination *spaces*.  Normally,
  51 // all the live data in a region is copied to a single destination space (e.g.,
  52 // everything live in a region in eden is copied entirely into the old gen).
  53 // However, when the heap is nearly full, all the live data in eden may not fit
  54 // into the old gen.  Copying only some of the regions from eden to old gen
  55 // requires finding a region that does not contain a partial object (i.e., no
  56 // live object crosses the region boundary) somewhere near the last object that
  57 // does fit into the old gen.  Since it&#39;s not always possible to find such a
  58 // region, splitting is necessary for predictable behavior.
  59 //
  60 // A region is always split at the end of the partial object.  This avoids
  61 // additional tests when calculating the new location of a pointer, which is a
  62 // very hot code path.  The partial object and everything to its left will be
  63 // copied to another space (call it dest_space_1).  The live data to the right
</pre>
<hr />
<pre>
 222   static const size_t Log2BlockSize;
 223   static const size_t BlockSize;
 224   static const size_t BlockSizeBytes;
 225 
 226   static const size_t BlockSizeOffsetMask;
 227   static const size_t BlockAddrOffsetMask;
 228   static const size_t BlockAddrMask;
 229 
 230   static const size_t BlocksPerRegion;
 231   static const size_t Log2BlocksPerRegion;
 232 
 233   class RegionData
 234   {
 235   public:
 236     // Destination address of the region.
 237     HeapWord* destination() const { return _destination; }
 238 
 239     // The first region containing data destined for this region.
 240     size_t source_region() const { return _source_region; }
 241 
<span class="line-added"> 242     // Reuse _source_region to store the corresponding shadow region index</span>
<span class="line-added"> 243     size_t shadow_region() const { return _source_region; }</span>
<span class="line-added"> 244 </span>
 245     // The object (if any) starting in this region and ending in a different
 246     // region that could not be updated during the main (parallel) compaction
 247     // phase.  This is different from _partial_obj_addr, which is an object that
 248     // extends onto a source region.  However, the two uses do not overlap in
 249     // time, so the same field is used to save space.
 250     HeapWord* deferred_obj_addr() const { return _partial_obj_addr; }
 251 
 252     // The starting address of the partial object extending onto the region.
 253     HeapWord* partial_obj_addr() const { return _partial_obj_addr; }
 254 
 255     // Size of the partial object extending onto the region (words).
 256     size_t partial_obj_size() const { return _partial_obj_size; }
 257 
 258     // Size of live data that lies within this region due to objects that start
 259     // in this region (words).  This does not include the partial object
 260     // extending onto the region (if any), or the part of an object that extends
 261     // onto the next region (if any).
 262     size_t live_obj_size() const { return _dc_and_los &amp; los_mask; }
 263 
 264     // Total live data that lies within the region (words).
</pre>
<hr />
<pre>
 293 
 294     // The location of the java heap data that corresponds to this region.
 295     inline HeapWord* data_location() const;
 296 
 297     // The highest address referenced by objects in this region.
 298     inline HeapWord* highest_ref() const;
 299 
 300     // Whether this region is available to be claimed, has been claimed, or has
 301     // been completed.
 302     //
 303     // Minor subtlety:  claimed() returns true if the region is marked
 304     // completed(), which is desirable since a region must be claimed before it
 305     // can be completed.
 306     bool available() const { return _dc_and_los &lt; dc_one; }
 307     bool claimed()   const { return _dc_and_los &gt;= dc_claimed; }
 308     bool completed() const { return _dc_and_los &gt;= dc_completed; }
 309 
 310     // These are not atomic.
 311     void set_destination(HeapWord* addr)       { _destination = addr; }
 312     void set_source_region(size_t region)      { _source_region = region; }
<span class="line-added"> 313     void set_shadow_region(size_t region)      { _source_region = region; }</span>
 314     void set_deferred_obj_addr(HeapWord* addr) { _partial_obj_addr = addr; }
 315     void set_partial_obj_addr(HeapWord* addr)  { _partial_obj_addr = addr; }
 316     void set_partial_obj_size(size_t words)    {
 317       _partial_obj_size = (region_sz_t) words;
 318     }
 319     inline void set_blocks_filled();
 320 
 321     inline void set_destination_count(uint count);
 322     inline void set_live_obj_size(size_t words);
 323     inline void set_data_location(HeapWord* addr);
 324     inline void set_completed();
 325     inline bool claim_unsafe();
 326 
 327     // These are atomic.
 328     inline void add_live_obj(size_t words);
 329     inline void set_highest_ref(HeapWord* addr);
 330     inline void decrement_destination_count();
 331     inline bool claim();
 332 
<span class="line-added"> 333     // Possible values of _shadow_state, and transition is as follows</span>
<span class="line-added"> 334     // Normal Path:</span>
<span class="line-added"> 335     // UnusedRegion -&gt; mark_normal() -&gt; NormalRegion</span>
<span class="line-added"> 336     // Shadow Path:</span>
<span class="line-added"> 337     // UnusedRegion -&gt; mark_shadow() -&gt; ShadowRegion -&gt;</span>
<span class="line-added"> 338     // mark_filled() -&gt; FilledShadow -&gt; mark_copied() -&gt; CopiedShadow</span>
<span class="line-added"> 339     static const int UnusedRegion = 0; // The region is not collected yet</span>
<span class="line-added"> 340     static const int ShadowRegion = 1; // Stolen by an idle thread, and a shadow region is created for it</span>
<span class="line-added"> 341     static const int FilledShadow = 2; // Its shadow region has been filled and ready to be copied back</span>
<span class="line-added"> 342     static const int CopiedShadow = 3; // The data of the shadow region has been copied back</span>
<span class="line-added"> 343     static const int NormalRegion = 4; // The region will be collected by the original parallel algorithm</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345     // Mark the current region as normal or shadow to enter different processing paths</span>
<span class="line-added"> 346     inline bool mark_normal();</span>
<span class="line-added"> 347     inline bool mark_shadow();</span>
<span class="line-added"> 348     // Mark the shadow region as filled and ready to be copied back</span>
<span class="line-added"> 349     inline void mark_filled();</span>
<span class="line-added"> 350     // Mark the shadow region as copied back to avoid double copying.</span>
<span class="line-added"> 351     inline bool mark_copied();</span>
<span class="line-added"> 352     // Special case: see the comment in PSParallelCompact::fill_and_update_shadow_region.</span>
<span class="line-added"> 353     // Return to the normal path here</span>
<span class="line-added"> 354     inline void shadow_to_normal();</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357     int shadow_state() { return _shadow_state; }</span>
<span class="line-added"> 358 </span>
 359   private:
 360     // The type used to represent object sizes within a region.
 361     typedef uint region_sz_t;
 362 
 363     // Constants for manipulating the _dc_and_los field, which holds both the
 364     // destination count and live obj size.  The live obj size lives at the
 365     // least significant end so no masking is necessary when adding.
 366     static const region_sz_t dc_shift;           // Shift amount.
 367     static const region_sz_t dc_mask;            // Mask for destination count.
 368     static const region_sz_t dc_one;             // 1, shifted appropriately.
 369     static const region_sz_t dc_claimed;         // Region has been claimed.
 370     static const region_sz_t dc_completed;       // Region has been completed.
 371     static const region_sz_t los_mask;           // Mask for live obj size.
 372 
 373     HeapWord*            _destination;
 374     size_t               _source_region;
 375     HeapWord*            _partial_obj_addr;
 376     region_sz_t          _partial_obj_size;
 377     region_sz_t volatile _dc_and_los;
 378     bool        volatile _blocks_filled;
<span class="line-added"> 379     int         volatile _shadow_state;</span>
 380 
 381 #ifdef ASSERT
 382     size_t               _blocks_filled_count;   // Number of block table fills.
 383 
 384     // These enable optimizations that are only partially implemented.  Use
 385     // debug builds to prevent the code fragments from breaking.
 386     HeapWord*            _data_location;
 387     HeapWord*            _highest_ref;
 388 #endif  // #ifdef ASSERT
 389 
 390 #ifdef ASSERT
 391    public:
 392     uint                 _pushed;   // 0 until region is pushed onto a stack
 393    private:
 394 #endif
 395   };
 396 
 397   // &quot;Blocks&quot; allow shorter sections of the bitmap to be searched.  Each Block
 398   // holds an offset, which is the amount of live data in the Region to the left
 399   // of the first live object that starts in the Block.
</pre>
<hr />
<pre>
 408   private:
 409     blk_ofs_t _offset;
 410   };
 411 
 412 public:
 413   ParallelCompactData();
 414   bool initialize(MemRegion covered_region);
 415 
 416   size_t region_count() const { return _region_count; }
 417   size_t reserved_byte_size() const { return _reserved_byte_size; }
 418 
 419   // Convert region indices to/from RegionData pointers.
 420   inline RegionData* region(size_t region_idx) const;
 421   inline size_t     region(const RegionData* const region_ptr) const;
 422 
 423   size_t block_count() const { return _block_count; }
 424   inline BlockData* block(size_t block_idx) const;
 425   inline size_t     block(const BlockData* block_ptr) const;
 426 
 427   void add_obj(HeapWord* addr, size_t len);
<span class="line-modified"> 428   void add_obj(oop p, size_t len) { add_obj(cast_from_oop&lt;HeapWord*&gt;(p), len); }</span>
 429 
 430   // Fill in the regions covering [beg, end) so that no data moves; i.e., the
 431   // destination of region n is simply the start of region n.  The argument beg
 432   // must be region-aligned; end need not be.
 433   void summarize_dense_prefix(HeapWord* beg, HeapWord* end);
 434 
 435   HeapWord* summarize_split_space(size_t src_region, SplitInfo&amp; split_info,
 436                                   HeapWord* destination, HeapWord* target_end,
 437                                   HeapWord** target_next);
 438   bool summarize(SplitInfo&amp; split_info,
 439                  HeapWord* source_beg, HeapWord* source_end,
 440                  HeapWord** source_next,
 441                  HeapWord* target_beg, HeapWord* target_end,
 442                  HeapWord** target_next);
 443 
 444   void clear();
 445   void clear_range(size_t beg_region, size_t end_region);
 446   void clear_range(HeapWord* beg, HeapWord* end) {
 447     clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));
 448   }
 449 
 450   // Return the number of words between addr and the start of the region
 451   // containing addr.
 452   inline size_t     region_offset(const HeapWord* addr) const;
 453 
 454   // Convert addresses to/from a region index or region pointer.
 455   inline size_t     addr_to_region_idx(const HeapWord* addr) const;
 456   inline RegionData* addr_to_region_ptr(const HeapWord* addr) const;
 457   inline HeapWord*  region_to_addr(size_t region) const;
 458   inline HeapWord*  region_to_addr(size_t region, size_t offset) const;
 459   inline HeapWord*  region_to_addr(const RegionData* region) const;
 460 
 461   inline HeapWord*  region_align_down(HeapWord* addr) const;
 462   inline HeapWord*  region_align_up(HeapWord* addr) const;
 463   inline bool       is_region_aligned(HeapWord* addr) const;
 464 
 465   // Analogous to region_offset() for blocks.
 466   size_t     block_offset(const HeapWord* addr) const;
 467   size_t     addr_to_block_idx(const HeapWord* addr) const;
 468   size_t     addr_to_block_idx(const oop obj) const {
<span class="line-modified"> 469     return addr_to_block_idx(cast_from_oop&lt;HeapWord*&gt;(obj));</span>
 470   }
 471   inline BlockData* addr_to_block_ptr(const HeapWord* addr) const;
 472   inline HeapWord*  block_to_addr(size_t block) const;
 473   inline size_t     region_to_block_idx(size_t region) const;
 474 
 475   inline HeapWord*  block_align_down(HeapWord* addr) const;
 476   inline HeapWord*  block_align_up(HeapWord* addr) const;
 477   inline bool       is_block_aligned(HeapWord* addr) const;
 478 
 479   // Return the address one past the end of the partial object.
 480   HeapWord* partial_obj_end(size_t region_idx) const;
 481 
 482   // Return the location of the object after compaction.
 483   HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm);
 484 
 485   HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) {
<span class="line-modified"> 486     return calc_new_pointer(cast_from_oop&lt;HeapWord*&gt;(p), cm);</span>
 487   }
 488 
 489 #ifdef  ASSERT
 490   void verify_clear(const PSVirtualSpace* vspace);
 491   void verify_clear();
 492 #endif  // #ifdef ASSERT
 493 
 494 private:
 495   bool initialize_block_data();
 496   bool initialize_region_data(size_t region_size);
 497   PSVirtualSpace* create_vspace(size_t count, size_t element_size);
 498 
 499 private:
 500   HeapWord*       _region_start;
 501 #ifdef  ASSERT
 502   HeapWord*       _region_end;
 503 #endif  // #ifdef ASSERT
 504 
 505   PSVirtualSpace* _region_vspace;
 506   size_t          _reserved_byte_size;
</pre>
<hr />
<pre>
 550 }
 551 
 552 inline void
 553 ParallelCompactData::RegionData::set_destination_count(uint count)
 554 {
 555   assert(count &lt;= (dc_completed &gt;&gt; dc_shift), &quot;count too large&quot;);
 556   const region_sz_t live_sz = (region_sz_t) live_obj_size();
 557   _dc_and_los = (count &lt;&lt; dc_shift) | live_sz;
 558 }
 559 
 560 inline void ParallelCompactData::RegionData::set_live_obj_size(size_t words)
 561 {
 562   assert(words &lt;= los_mask, &quot;would overflow&quot;);
 563   _dc_and_los = destination_count_raw() | (region_sz_t)words;
 564 }
 565 
 566 inline void ParallelCompactData::RegionData::decrement_destination_count()
 567 {
 568   assert(_dc_and_los &lt; dc_claimed, &quot;already claimed&quot;);
 569   assert(_dc_and_los &gt;= dc_one, &quot;count would go negative&quot;);
<span class="line-modified"> 570   Atomic::add(&amp;_dc_and_los, dc_mask);</span>
 571 }
 572 
 573 inline HeapWord* ParallelCompactData::RegionData::data_location() const
 574 {
 575   DEBUG_ONLY(return _data_location;)
 576   NOT_DEBUG(return NULL;)
 577 }
 578 
 579 inline HeapWord* ParallelCompactData::RegionData::highest_ref() const
 580 {
 581   DEBUG_ONLY(return _highest_ref;)
 582   NOT_DEBUG(return NULL;)
 583 }
 584 
 585 inline void ParallelCompactData::RegionData::set_data_location(HeapWord* addr)
 586 {
 587   DEBUG_ONLY(_data_location = addr;)
 588 }
 589 
 590 inline void ParallelCompactData::RegionData::set_completed()
 591 {
 592   assert(claimed(), &quot;must be claimed first&quot;);
 593   _dc_and_los = dc_completed | (region_sz_t) live_obj_size();
 594 }
 595 
 596 // MT-unsafe claiming of a region.  Should only be used during single threaded
 597 // execution.
 598 inline bool ParallelCompactData::RegionData::claim_unsafe()
 599 {
 600   if (available()) {
 601     _dc_and_los |= dc_claimed;
 602     return true;
 603   }
 604   return false;
 605 }
 606 
 607 inline void ParallelCompactData::RegionData::add_live_obj(size_t words)
 608 {
 609   assert(words &lt;= (size_t)los_mask - live_obj_size(), &quot;overflow&quot;);
<span class="line-modified"> 610   Atomic::add(&amp;_dc_and_los, static_cast&lt;region_sz_t&gt;(words));</span>
 611 }
 612 
 613 inline void ParallelCompactData::RegionData::set_highest_ref(HeapWord* addr)
 614 {
 615 #ifdef ASSERT
 616   HeapWord* tmp = _highest_ref;
 617   while (addr &gt; tmp) {
<span class="line-modified"> 618     tmp = Atomic::cmpxchg(&amp;_highest_ref, tmp, addr);</span>
 619   }
 620 #endif  // #ifdef ASSERT
 621 }
 622 
 623 inline bool ParallelCompactData::RegionData::claim()
 624 {
 625   const region_sz_t los = static_cast&lt;region_sz_t&gt;(live_obj_size());
<span class="line-modified"> 626   const region_sz_t old = Atomic::cmpxchg(&amp;_dc_and_los, los, dc_claimed | los);</span>
 627   return old == los;
 628 }
 629 
<span class="line-added"> 630 inline bool ParallelCompactData::RegionData::mark_normal() {</span>
<span class="line-added"> 631   return Atomic::cmpxchg(&amp;_shadow_state, UnusedRegion, NormalRegion) == UnusedRegion;</span>
<span class="line-added"> 632 }</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634 inline bool ParallelCompactData::RegionData::mark_shadow() {</span>
<span class="line-added"> 635   if (_shadow_state != UnusedRegion) return false;</span>
<span class="line-added"> 636   return Atomic::cmpxchg(&amp;_shadow_state, UnusedRegion, ShadowRegion) == UnusedRegion;</span>
<span class="line-added"> 637 }</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639 inline void ParallelCompactData::RegionData::mark_filled() {</span>
<span class="line-added"> 640   int old = Atomic::cmpxchg(&amp;_shadow_state, ShadowRegion, FilledShadow);</span>
<span class="line-added"> 641   assert(old == ShadowRegion, &quot;Fail to mark the region as filled&quot;);</span>
<span class="line-added"> 642 }</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644 inline bool ParallelCompactData::RegionData::mark_copied() {</span>
<span class="line-added"> 645   return Atomic::cmpxchg(&amp;_shadow_state, FilledShadow, CopiedShadow) == FilledShadow;</span>
<span class="line-added"> 646 }</span>
<span class="line-added"> 647 </span>
<span class="line-added"> 648 void ParallelCompactData::RegionData::shadow_to_normal() {</span>
<span class="line-added"> 649   int old = Atomic::cmpxchg(&amp;_shadow_state, ShadowRegion, NormalRegion);</span>
<span class="line-added"> 650   assert(old == ShadowRegion, &quot;Fail to mark the region as finish&quot;);</span>
<span class="line-added"> 651 }</span>
<span class="line-added"> 652 </span>
 653 inline ParallelCompactData::RegionData*
 654 ParallelCompactData::region(size_t region_idx) const
 655 {
 656   assert(region_idx &lt;= region_count(), &quot;bad arg&quot;);
 657   return _region_data + region_idx;
 658 }
 659 
 660 inline size_t
 661 ParallelCompactData::region(const RegionData* const region_ptr) const
 662 {
 663   assert(region_ptr &gt;= _region_data, &quot;bad arg&quot;);
 664   assert(region_ptr &lt;= _region_data + region_count(), &quot;bad arg&quot;);
 665   return pointer_delta(region_ptr, _region_data, sizeof(RegionData));
 666 }
 667 
 668 inline ParallelCompactData::BlockData*
 669 ParallelCompactData::block(size_t n) const {
 670   assert(n &lt; block_count(), &quot;bad arg&quot;);
 671   return _block_data + n;
 672 }
</pre>
<hr />
<pre>
 862   return _words_remaining;
 863 }
 864 
 865 inline bool ParMarkBitMapClosure::is_full() const {
 866   return words_remaining() == 0;
 867 }
 868 
 869 inline HeapWord* ParMarkBitMapClosure::source() const {
 870   return _source;
 871 }
 872 
 873 inline void ParMarkBitMapClosure::set_source(HeapWord* addr) {
 874   _source = addr;
 875 }
 876 
 877 inline void ParMarkBitMapClosure::decrement_words_remaining(size_t words) {
 878   assert(_words_remaining &gt;= words, &quot;processed too many words&quot;);
 879   _words_remaining -= words;
 880 }
 881 
<span class="line-modified"> 882 // The Parallel collector is a stop-the-world garbage collector that</span>
 883 // does parts of the collection using parallel threads.  The collection includes
<span class="line-modified"> 884 // the tenured generation and the young generation.</span>






 885 //
 886 // There are four phases of the collection.
 887 //
 888 //      - marking phase
 889 //      - summary phase
 890 //      - compacting phase
 891 //      - clean up phase
 892 //
 893 // Roughly speaking these phases correspond, respectively, to
 894 //      - mark all the live objects
 895 //      - calculate the destination of each object at the end of the collection
 896 //      - move the objects to their destination
 897 //      - update some references and reinitialize some variables
 898 //
 899 // These three phases are invoked in PSParallelCompact::invoke_no_policy().  The
 900 // marking phase is implemented in PSParallelCompact::marking_phase() and does a
 901 // complete marking of the heap.  The summary phase is implemented in
 902 // PSParallelCompact::summary_phase().  The move and update phase is implemented
 903 // in PSParallelCompact::compact().
 904 //
</pre>
<hr />
<pre>
 943 // references in the object.
 944 //
 945 // A current exception is that objects that cross a region boundary are moved
 946 // but do not have their references updated.  References are not updated because
 947 // it cannot easily be determined if the klass pointer KKK for the object AAA
 948 // has been updated.  KKK likely resides in a region to the left of the region
 949 // containing AAA.  These AAA&#39;s have there references updated at the end in a
 950 // clean up phase.  See the method PSParallelCompact::update_deferred_objects().
 951 // An alternate strategy is being investigated for this deferral of updating.
 952 //
 953 // Compaction is done on a region basis.  A region that is ready to be filled is
 954 // put on a ready list and GC threads take region off the list and fill them.  A
 955 // region is ready to be filled if it empty of live objects.  Such a region may
 956 // have been initially empty (only contained dead objects) or may have had all
 957 // its live objects copied out already.  A region that compacts into itself is
 958 // also ready for filling.  The ready list is initially filled with empty
 959 // regions and regions compacting into themselves.  There is always at least 1
 960 // region that can be put on the ready list.  The regions are atomically added
 961 // and removed from the ready list.
 962 
<span class="line-added"> 963 class TaskQueue;</span>
<span class="line-added"> 964 </span>
 965 class PSParallelCompact : AllStatic {
 966  public:
 967   // Convenient access to type names.
 968   typedef ParMarkBitMap::idx_t idx_t;
 969   typedef ParallelCompactData::RegionData RegionData;
 970   typedef ParallelCompactData::BlockData BlockData;
 971 
 972   typedef enum {
 973     old_space_id, eden_space_id,
 974     from_space_id, to_space_id, last_space_id
 975   } SpaceId;
 976 
<span class="line-added"> 977   struct UpdateDensePrefixTask : public CHeapObj&lt;mtGC&gt; {</span>
<span class="line-added"> 978     SpaceId _space_id;</span>
<span class="line-added"> 979     size_t _region_index_start;</span>
<span class="line-added"> 980     size_t _region_index_end;</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982     UpdateDensePrefixTask() :</span>
<span class="line-added"> 983         _space_id(SpaceId(0)),</span>
<span class="line-added"> 984         _region_index_start(0),</span>
<span class="line-added"> 985         _region_index_end(0) {}</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987     UpdateDensePrefixTask(SpaceId space_id,</span>
<span class="line-added"> 988                           size_t region_index_start,</span>
<span class="line-added"> 989                           size_t region_index_end) :</span>
<span class="line-added"> 990         _space_id(space_id),</span>
<span class="line-added"> 991         _region_index_start(region_index_start),</span>
<span class="line-added"> 992         _region_index_end(region_index_end) {}</span>
<span class="line-added"> 993   };</span>
<span class="line-added"> 994 </span>
 995  public:
 996   // Inline closure decls
 997   //
 998   class IsAliveClosure: public BoolObjectClosure {
 999    public:
1000     virtual bool do_object_b(oop p);
1001   };
1002 
1003   friend class RefProcTaskProxy;
1004   friend class PSParallelCompactTest;
1005 
1006  private:
1007   static STWGCTimer           _gc_timer;
1008   static ParallelOldTracer    _gc_tracer;
1009   static elapsedTimer         _accumulated_time;
1010   static unsigned int         _total_invocations;
1011   static unsigned int         _maximum_compaction_gc_num;
1012   static jlong                _time_of_last_gc;   // ms
1013   static CollectorCounters*   _counters;
1014   static ParMarkBitMap        _mark_bitmap;
</pre>
<hr />
<pre>
1100 
1101   // Summary phase utility routine to fill dead space (if any) at the dense
1102   // prefix boundary.  Should only be called if the the dense prefix is
1103   // non-empty.
1104   static void fill_dense_prefix_end(SpaceId id);
1105 
1106   static void summarize_spaces_quick();
1107   static void summarize_space(SpaceId id, bool maximum_compaction);
1108   static void summary_phase(ParCompactionManager* cm, bool maximum_compaction);
1109 
1110   // Adjust addresses in roots.  Does not adjust addresses in heap.
1111   static void adjust_roots(ParCompactionManager* cm);
1112 
1113   DEBUG_ONLY(static void write_block_fill_histogram();)
1114 
1115   // Move objects to new locations.
1116   static void compact_perm(ParCompactionManager* cm);
1117   static void compact();
1118 
1119   // Add available regions to the stack and draining tasks to the task queue.
<span class="line-modified">1120   static void prepare_region_draining_tasks(uint parallel_gc_threads);</span>

1121 
1122   // Add dense prefix update tasks to the task queue.
<span class="line-modified">1123   static void enqueue_dense_prefix_tasks(TaskQueue&amp; task_queue,</span>
1124                                          uint parallel_gc_threads);
1125 






1126   // If objects are left in eden after a collection, try to move the boundary
1127   // and absorb them into the old gen.  Returns true if eden was emptied.
1128   static bool absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1129                                          PSYoungGen* young_gen,
1130                                          PSOldGen* old_gen);
1131 
1132   // Reset time since last full gc
1133   static void reset_millis_since_last_gc();
1134 
1135 #ifndef PRODUCT
1136   // Print generic summary data
1137   static void print_generic_summary_data(ParallelCompactData&amp; summary_data,
1138                                          HeapWord* const beg_addr,
1139                                          HeapWord* const end_addr);
1140 #endif  // #ifndef PRODUCT
1141 
1142  public:
1143 
1144   PSParallelCompact();
1145 
1146   static void invoke(bool maximum_heap_compaction);
1147   static bool invoke_no_policy(bool maximum_heap_compaction);
1148 
1149   static void post_initialize();
1150   // Perform initialization for PSParallelCompact that requires
1151   // allocations.  This should be called during the VM initialization
1152   // at a pointer where it would be appropriate to return a JNI_ENOMEM
1153   // in the event of a failure.
1154   static bool initialize();
1155 
1156   // Closure accessors
1157   static BoolObjectClosure* is_alive_closure()     { return (BoolObjectClosure*)&amp;_is_alive_closure; }
1158 
1159   // Public accessors
1160   static elapsedTimer* accumulated_time() { return &amp;_accumulated_time; }
1161   static unsigned int total_invocations() { return _total_invocations; }
1162   static CollectorCounters* counters()    { return _counters; }
1163 



1164   // Marking support
1165   static inline bool mark_obj(oop obj);
1166   static inline bool is_marked(oop obj);
1167 
1168   template &lt;class T&gt; static inline void adjust_pointer(T* p, ParCompactionManager* cm);
1169 
1170   // Compaction support.
1171   // Return true if p is in the range [beg_addr, end_addr).
1172   static inline bool is_in(HeapWord* p, HeapWord* beg_addr, HeapWord* end_addr);
1173   static inline bool is_in(oop* p, HeapWord* beg_addr, HeapWord* end_addr);
1174 
1175   // Convenience wrappers for per-space data kept in _space_info.
1176   static inline MutableSpace*     space(SpaceId space_id);
1177   static inline HeapWord*         new_top(SpaceId space_id);
1178   static inline HeapWord*         dense_prefix(SpaceId space_id);
1179   static inline ObjectStartArray* start_array(SpaceId space_id);
1180 



1181   // Process the end of the given region range in the dense prefix.
1182   // This includes saving any object not updated.
1183   static void dense_prefix_regions_epilogue(ParCompactionManager* cm,
1184                                             size_t region_start_index,
1185                                             size_t region_end_index,
1186                                             idx_t exiting_object_offset,
1187                                             idx_t region_offset_start,
1188                                             idx_t region_offset_end);
1189 
1190   // Update a region in the dense prefix.  For each live object
1191   // in the region, update it&#39;s interior references.  For each
1192   // dead object, fill it with deadwood. Dead space at the end
1193   // of a region range will be filled to the start of the next
1194   // live object regardless of the region_index_end.  None of the
1195   // objects in the dense prefix move and dead space is dead
1196   // (holds only dead objects that don&#39;t need any processing), so
1197   // dead space can be filled in any order.
1198   static void update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,
1199                                                   SpaceId space_id,
1200                                                   size_t region_index_start,
</pre>
<hr />
<pre>
1210                                   size_t src_region_idx);
1211 
1212   // Determine the next source region, set closure.source() to the start of the
1213   // new region return the region index.  Parameter end_addr is the address one
1214   // beyond the end of source range just processed.  If necessary, switch to a
1215   // new source space and set src_space_id (in-out parameter) and src_space_top
1216   // (out parameter) accordingly.
1217   static size_t next_src_region(MoveAndUpdateClosure&amp; closure,
1218                                 SpaceId&amp; src_space_id,
1219                                 HeapWord*&amp; src_space_top,
1220                                 HeapWord* end_addr);
1221 
1222   // Decrement the destination count for each non-empty source region in the
1223   // range [beg_region, region(region_align_up(end_addr))).  If the destination
1224   // count for a region goes to 0 and it needs to be filled, enqueue it.
1225   static void decrement_destination_counts(ParCompactionManager* cm,
1226                                            SpaceId src_space_id,
1227                                            size_t beg_region,
1228                                            HeapWord* end_addr);
1229 
<span class="line-modified">1230   static void fill_region(ParCompactionManager* cm, MoveAndUpdateClosure&amp; closure, size_t region);</span>
<span class="line-modified">1231   static void fill_and_update_region(ParCompactionManager* cm, size_t region);</span>
<span class="line-modified">1232 </span>
<span class="line-modified">1233   static bool steal_unavailable_region(ParCompactionManager* cm, size_t&amp; region_idx);</span>
<span class="line-modified">1234   static void fill_and_update_shadow_region(ParCompactionManager* cm, size_t region);</span>
<span class="line-added">1235   // Copy the content of a shadow region back to its corresponding heap region</span>
<span class="line-added">1236   static void copy_back(HeapWord* shadow_addr, HeapWord* region_addr);</span>
<span class="line-added">1237   // Collect empty regions as shadow regions and initialize the</span>
<span class="line-added">1238   // _next_shadow_region filed for each compact manager</span>
<span class="line-added">1239   static void initialize_shadow_regions(uint parallel_gc_threads);</span>
1240 
1241   // Fill in the block table for the specified region.
1242   static void fill_blocks(size_t region_idx);
1243 
1244   // Update the deferred objects in the space.
1245   static void update_deferred_objects(ParCompactionManager* cm, SpaceId id);
1246 
1247   static ParMarkBitMap* mark_bitmap() { return &amp;_mark_bitmap; }
1248   static ParallelCompactData&amp; summary_data() { return _summary_data; }
1249 
1250   // Reference Processing
1251   static ReferenceProcessor* const ref_processor() { return _ref_processor; }
1252 
1253   static STWGCTimer* gc_timer() { return &amp;_gc_timer; }
1254 
1255   // Return the SpaceId for the given address.
1256   static SpaceId space_id(HeapWord* addr);
1257 
1258   // Time since last full gc (in milliseconds).
1259   static jlong millis_since_last_gc();
</pre>
<hr />
<pre>
1266   static void print_region_ranges();
1267   static void print_dense_prefix_stats(const char* const algorithm,
1268                                        const SpaceId id,
1269                                        const bool maximum_compaction,
1270                                        HeapWord* const addr);
1271   static void summary_phase_msg(SpaceId dst_space_id,
1272                                 HeapWord* dst_beg, HeapWord* dst_end,
1273                                 SpaceId src_space_id,
1274                                 HeapWord* src_beg, HeapWord* src_end);
1275 #endif  // #ifndef PRODUCT
1276 
1277 #ifdef  ASSERT
1278   // Sanity check the new location of a word in the heap.
1279   static inline void check_new_location(HeapWord* old_addr, HeapWord* new_addr);
1280   // Verify that all the regions have been emptied.
1281   static void verify_complete(SpaceId space_id);
1282 #endif  // #ifdef ASSERT
1283 };
1284 
1285 class MoveAndUpdateClosure: public ParMarkBitMapClosure {
<span class="line-added">1286   static inline size_t calculate_words_remaining(size_t region);</span>
1287  public:
1288   inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,
<span class="line-modified">1289                               size_t region);</span>

1290 
1291   // Accessors.
1292   HeapWord* destination() const         { return _destination; }
<span class="line-added">1293   HeapWord* copy_destination() const    { return _destination + _offset; }</span>
1294 
1295   // If the object will fit (size &lt;= words_remaining()), copy it to the current
1296   // destination, update the interior oops and the start array and return either
1297   // full (if the closure is full) or incomplete.  If the object will not fit,
1298   // return would_overflow.
<span class="line-modified">1299   IterationStatus do_addr(HeapWord* addr, size_t size);</span>
1300 
1301   // Copy enough words to fill this closure, starting at source().  Interior
1302   // oops and the start array are not updated.  Return full.
1303   IterationStatus copy_until_full();
1304 
1305   // Copy enough words to fill this closure or to the end of an object,
1306   // whichever is smaller, starting at source().  Interior oops and the start
1307   // array are not updated.
1308   void copy_partial_obj();
1309 
<span class="line-modified">1310   virtual void complete_region(ParCompactionManager* cm, HeapWord* dest_addr,</span>
<span class="line-added">1311                                PSParallelCompact::RegionData* region_ptr);</span>
<span class="line-added">1312 </span>
<span class="line-added">1313 protected:</span>
1314   // Update variables to indicate that word_count words were processed.
1315   inline void update_state(size_t word_count);
1316 
1317  protected:

1318   HeapWord*               _destination;         // Next addr to be written.
<span class="line-added">1319   ObjectStartArray* const _start_array;</span>
<span class="line-added">1320   size_t                  _offset;</span>
1321 };
1322 
<span class="line-added">1323 inline size_t MoveAndUpdateClosure::calculate_words_remaining(size_t region) {</span>
<span class="line-added">1324   HeapWord* dest_addr = PSParallelCompact::summary_data().region_to_addr(region);</span>
<span class="line-added">1325   PSParallelCompact::SpaceId dest_space_id = PSParallelCompact::space_id(dest_addr);</span>
<span class="line-added">1326   HeapWord* new_top = PSParallelCompact::new_top(dest_space_id);</span>
<span class="line-added">1327   assert(dest_addr &lt; new_top, &quot;sanity&quot;);</span>
<span class="line-added">1328 </span>
<span class="line-added">1329   return MIN2(pointer_delta(new_top, dest_addr), ParallelCompactData::RegionSize);</span>
<span class="line-added">1330 }</span>
<span class="line-added">1331 </span>
1332 inline
1333 MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,
1334                                            ParCompactionManager* cm,
<span class="line-modified">1335                                            size_t region_idx) :</span>
<span class="line-modified">1336   ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),</span>
<span class="line-modified">1337   _destination(PSParallelCompact::summary_data().region_to_addr(region_idx)),</span>
<span class="line-modified">1338   _start_array(PSParallelCompact::start_array(PSParallelCompact::space_id(_destination))),</span>
<span class="line-modified">1339   _offset(0) { }</span>
<span class="line-modified">1340 </span>

1341 
1342 inline void MoveAndUpdateClosure::update_state(size_t words)
1343 {
1344   decrement_words_remaining(words);
1345   _source += words;
1346   _destination += words;
1347 }
1348 
<span class="line-added">1349 class MoveAndUpdateShadowClosure: public MoveAndUpdateClosure {</span>
<span class="line-added">1350   inline size_t calculate_shadow_offset(size_t region_idx, size_t shadow_idx);</span>
<span class="line-added">1351 public:</span>
<span class="line-added">1352   inline MoveAndUpdateShadowClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,</span>
<span class="line-added">1353                        size_t region, size_t shadow);</span>
<span class="line-added">1354 </span>
<span class="line-added">1355   virtual void complete_region(ParCompactionManager* cm, HeapWord* dest_addr,</span>
<span class="line-added">1356                                PSParallelCompact::RegionData* region_ptr);</span>
<span class="line-added">1357 </span>
<span class="line-added">1358 private:</span>
<span class="line-added">1359   size_t _shadow;</span>
<span class="line-added">1360 };</span>
<span class="line-added">1361 </span>
<span class="line-added">1362 inline size_t MoveAndUpdateShadowClosure::calculate_shadow_offset(size_t region_idx, size_t shadow_idx) {</span>
<span class="line-added">1363   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();</span>
<span class="line-added">1364   HeapWord* dest_addr = sd.region_to_addr(region_idx);</span>
<span class="line-added">1365   HeapWord* shadow_addr = sd.region_to_addr(shadow_idx);</span>
<span class="line-added">1366   return pointer_delta(shadow_addr, dest_addr);</span>
<span class="line-added">1367 }</span>
<span class="line-added">1368 </span>
<span class="line-added">1369 inline</span>
<span class="line-added">1370 MoveAndUpdateShadowClosure::MoveAndUpdateShadowClosure(ParMarkBitMap *bitmap,</span>
<span class="line-added">1371                                                        ParCompactionManager *cm,</span>
<span class="line-added">1372                                                        size_t region,</span>
<span class="line-added">1373                                                        size_t shadow) :</span>
<span class="line-added">1374   MoveAndUpdateClosure(bitmap, cm, region),</span>
<span class="line-added">1375   _shadow(shadow) {</span>
<span class="line-added">1376   _offset = calculate_shadow_offset(region, shadow);</span>
<span class="line-added">1377 }</span>
<span class="line-added">1378 </span>
1379 class UpdateOnlyClosure: public ParMarkBitMapClosure {
1380  private:
1381   const PSParallelCompact::SpaceId _space_id;
1382   ObjectStartArray* const          _start_array;
1383 
1384  public:
1385   UpdateOnlyClosure(ParMarkBitMap* mbm,
1386                     ParCompactionManager* cm,
1387                     PSParallelCompact::SpaceId space_id);
1388 
1389   // Update the object.
1390   virtual IterationStatus do_addr(HeapWord* addr, size_t words);
1391 
1392   inline void do_addr(HeapWord* addr);
1393 };
1394 
1395 class FillClosure: public ParMarkBitMapClosure {
1396  public:
1397   FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id);
1398 
</pre>
</td>
</tr>
</table>
<center><a href="psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionLAB.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psScavenge.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psScavenge.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;


 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;code/codeCache.hpp&quot;
<span class="line-removed"> 28 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
 29 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 30 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
 31 #include &quot;gc/parallel/psClosure.inline.hpp&quot;
<span class="line-modified"> 32 #include &quot;gc/parallel/psMarkSweepProxy.hpp&quot;</span>
 33 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 34 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;

 35 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
<span class="line-removed"> 36 #include &quot;gc/parallel/psTasks.hpp&quot;</span>
<span class="line-removed"> 37 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 38 #include &quot;gc/shared/gcCause.hpp&quot;
 39 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 40 #include &quot;gc/shared/gcId.hpp&quot;
 41 #include &quot;gc/shared/gcLocker.hpp&quot;
 42 #include &quot;gc/shared/gcTimer.hpp&quot;
 43 #include &quot;gc/shared/gcTrace.hpp&quot;
 44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 45 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 46 #include &quot;gc/shared/referencePolicy.hpp&quot;
 47 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 48 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="line-modified"> 49 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>


 50 #include &quot;gc/shared/weakProcessor.hpp&quot;



 51 #include &quot;memory/resourceArea.hpp&quot;

 52 #include &quot;logging/log.hpp&quot;
 53 #include &quot;oops/access.inline.hpp&quot;
 54 #include &quot;oops/compressedOops.inline.hpp&quot;
 55 #include &quot;oops/oop.inline.hpp&quot;
 56 #include &quot;runtime/biasedLocking.hpp&quot;
 57 #include &quot;runtime/handles.inline.hpp&quot;
 58 #include &quot;runtime/threadCritical.hpp&quot;
 59 #include &quot;runtime/vmThread.hpp&quot;
 60 #include &quot;runtime/vmOperations.hpp&quot;

 61 #include &quot;services/memoryService.hpp&quot;
 62 #include &quot;utilities/stack.inline.hpp&quot;
 63 
 64 HeapWord*                     PSScavenge::_to_space_top_before_gc = NULL;
 65 int                           PSScavenge::_consecutive_skipped_scavenges = 0;
 66 SpanSubjectToDiscoveryClosure PSScavenge::_span_based_discoverer;
 67 ReferenceProcessor*           PSScavenge::_ref_processor = NULL;
 68 PSCardTable*                  PSScavenge::_card_table = NULL;
 69 bool                          PSScavenge::_survivor_overflow = false;
 70 uint                          PSScavenge::_tenuring_threshold = 0;
 71 HeapWord*                     PSScavenge::_young_generation_boundary = NULL;
 72 uintptr_t                     PSScavenge::_young_generation_boundary_compressed = 0;
 73 elapsedTimer                  PSScavenge::_accumulated_time;
 74 STWGCTimer                    PSScavenge::_gc_timer;
 75 ParallelScavengeTracer        PSScavenge::_gc_tracer;
 76 CollectorCounters*            PSScavenge::_counters = NULL;
 77 

















































































 78 // Define before use
 79 class PSIsAliveClosure: public BoolObjectClosure {
 80 public:
 81   bool do_object_b(oop p) {
 82     return (!PSScavenge::is_obj_in_young(p)) || p-&gt;is_forwarded();
 83   }
 84 };
 85 
 86 PSIsAliveClosure PSScavenge::_is_alive_closure;
 87 
 88 class PSKeepAliveClosure: public OopClosure {
 89 protected:
 90   MutableSpace* _to_space;
 91   PSPromotionManager* _promotion_manager;
 92 
 93 public:
 94   PSKeepAliveClosure(PSPromotionManager* pm) : _promotion_manager(pm) {
 95     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 96     _to_space = heap-&gt;young_gen()-&gt;to_space();
 97 
</pre>
<hr />
<pre>
108     }
109   }
110   virtual void do_oop(oop* p)       { PSKeepAliveClosure::do_oop_work(p); }
111   virtual void do_oop(narrowOop* p) { PSKeepAliveClosure::do_oop_work(p); }
112 };
113 
114 class PSEvacuateFollowersClosure: public VoidClosure {
115  private:
116   PSPromotionManager* _promotion_manager;
117  public:
118   PSEvacuateFollowersClosure(PSPromotionManager* pm) : _promotion_manager(pm) {}
119 
120   virtual void do_void() {
121     assert(_promotion_manager != NULL, &quot;Sanity&quot;);
122     _promotion_manager-&gt;drain_stacks(true);
123     guarantee(_promotion_manager-&gt;stacks_empty(),
124               &quot;stacks should be empty at this point&quot;);
125   }
126 };
127 
<span class="line-removed">128 class PSRefProcTaskProxy: public GCTask {</span>
<span class="line-removed">129   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="line-removed">130   ProcessTask &amp; _rp_task;</span>
<span class="line-removed">131   uint          _work_id;</span>
<span class="line-removed">132 public:</span>
<span class="line-removed">133   PSRefProcTaskProxy(ProcessTask &amp; rp_task, uint work_id)</span>
<span class="line-removed">134     : _rp_task(rp_task),</span>
<span class="line-removed">135       _work_id(work_id)</span>
<span class="line-removed">136   { }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138 private:</span>
<span class="line-removed">139   virtual char* name() { return (char *)&quot;Process referents by policy in parallel&quot;; }</span>
<span class="line-removed">140   virtual void do_it(GCTaskManager* manager, uint which);</span>
<span class="line-removed">141 };</span>
<span class="line-removed">142 </span>
<span class="line-removed">143 void PSRefProcTaskProxy::do_it(GCTaskManager* manager, uint which)</span>
<span class="line-removed">144 {</span>
<span class="line-removed">145   PSPromotionManager* promotion_manager =</span>
<span class="line-removed">146     PSPromotionManager::gc_thread_promotion_manager(which);</span>
<span class="line-removed">147   assert(promotion_manager != NULL, &quot;sanity check&quot;);</span>
<span class="line-removed">148   PSKeepAliveClosure keep_alive(promotion_manager);</span>
<span class="line-removed">149   PSEvacuateFollowersClosure evac_followers(promotion_manager);</span>
<span class="line-removed">150   PSIsAliveClosure is_alive;</span>
<span class="line-removed">151   _rp_task.work(_work_id, is_alive, keep_alive, evac_followers);</span>
<span class="line-removed">152 }</span>
<span class="line-removed">153 </span>
154 class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {
<span class="line-modified">155   virtual void execute(ProcessTask&amp; task, uint ergo_workers);</span>
156 };
157 
<span class="line-modified">158 void PSRefProcTaskExecutor::execute(ProcessTask&amp; task, uint ergo_workers)</span>
<span class="line-modified">159 {</span>
<span class="line-modified">160   GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-modified">161   GCTaskManager* manager = ParallelScavengeHeap::gc_task_manager();</span>
<span class="line-modified">162   uint active_workers = manager-&gt;active_workers();</span>
<span class="line-removed">163 </span>
<span class="line-removed">164   assert(active_workers == ergo_workers,</span>
<span class="line-removed">165          &quot;Ergonomically chosen workers (%u) must be equal to active workers (%u)&quot;,</span>
<span class="line-removed">166          ergo_workers, active_workers);</span>
167 
<span class="line-modified">168   for(uint i=0; i &lt; active_workers; i++) {</span>
<span class="line-modified">169     q-&gt;enqueue(new PSRefProcTaskProxy(task, i));</span>




170   }
<span class="line-modified">171   TaskTerminator terminator(active_workers,</span>
<span class="line-modified">172                             (TaskQueueSetSuper*) PSPromotionManager::stack_array_depth());</span>
<span class="line-modified">173   if (task.marks_oops_alive() &amp;&amp; active_workers &gt; 1) {</span>
<span class="line-modified">174     for (uint j = 0; j &lt; active_workers; j++) {</span>
<span class="line-modified">175       q-&gt;enqueue(new StealTask(terminator.terminator()));</span>







176     }
177   }
<span class="line-modified">178   manager-&gt;execute_and_wait(q);</span>




179 }
180 
181 // This method contains all heap specific policy for invoking scavenge.
182 // PSScavenge::invoke_no_policy() will do nothing but attempt to
183 // scavenge. It will not clean up after failed promotions, bail out if
184 // we&#39;ve exceeded policy time limits, or any other special behavior.
185 // All such policy should be placed here.
186 //
187 // Note that this method should only be called from the vm_thread while
188 // at a safepoint!
189 bool PSScavenge::invoke() {
190   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
191   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
192   assert(!ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;not reentrant&quot;);
193 
194   ParallelScavengeHeap* const heap = ParallelScavengeHeap::heap();
195   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
196   IsGCActiveMark mark;
197 
198   const bool scavenge_done = PSScavenge::invoke_no_policy();
199   const bool need_full_gc = !scavenge_done ||
200     policy-&gt;should_full_GC(heap-&gt;old_gen()-&gt;free_in_bytes());
201   bool full_gc_done = false;
202 
203   if (UsePerfData) {
204     PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
205     const int ffs_val = need_full_gc ? full_follows_scavenge : not_skipped;
206     counters-&gt;update_full_follows_scavenge(ffs_val);
207   }
208 
209   if (need_full_gc) {
210     GCCauseSetter gccs(heap, GCCause::_adaptive_size_policy);
211     SoftRefPolicy* srp = heap-&gt;soft_ref_policy();
212     const bool clear_all_softrefs = srp-&gt;should_clear_all_soft_refs();
213 
<span class="line-modified">214     if (UseParallelOldGC) {</span>
<span class="line-removed">215       full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span>
<span class="line-removed">216     } else {</span>
<span class="line-removed">217       full_gc_done = PSMarkSweepProxy::invoke_no_policy(clear_all_softrefs);</span>
<span class="line-removed">218     }</span>
219   }
220 
221   return full_gc_done;
222 }
223 
<span class="line-modified">224 class PSAddThreadRootsTaskClosure : public ThreadClosure {</span>
<span class="line-modified">225 private:</span>
<span class="line-modified">226   GCTaskQueue* _q;</span>























227 
228 public:
<span class="line-modified">229   PSAddThreadRootsTaskClosure(GCTaskQueue* q) : _q(q) { }</span>
<span class="line-modified">230   void do_thread(Thread* t) {</span>
<span class="line-modified">231     _q-&gt;enqueue(new ThreadRootsTask(t));</span>



























































232   }
233 };
234 
235 // This method contains no policy. You should probably
236 // be calling invoke() instead.
237 bool PSScavenge::invoke_no_policy() {
238   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
239   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
240 
241   _gc_timer.register_gc_start();
242 
243   TimeStamp scavenge_entry;
244   TimeStamp scavenge_midpoint;
245   TimeStamp scavenge_exit;
246 
247   scavenge_entry.update();
248 
249   if (GCLocker::check_active_before_gc()) {
250     return false;
251   }
</pre>
<hr />
<pre>
260 
261   GCIdMark gc_id_mark;
262   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
263 
264   bool promotion_failure_occurred = false;
265 
266   PSYoungGen* young_gen = heap-&gt;young_gen();
267   PSOldGen* old_gen = heap-&gt;old_gen();
268   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
269 
270   heap-&gt;increment_total_collections();
271 
272   if (AdaptiveSizePolicy::should_update_eden_stats(gc_cause)) {
273     // Gather the feedback data for eden occupancy.
274     young_gen-&gt;eden_space()-&gt;accumulate_statistics();
275   }
276 
277   heap-&gt;print_heap_before_gc();
278   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
279 
<span class="line-modified">280   assert(!NeverTenure || _tenuring_threshold == markOopDesc::max_age + 1, &quot;Sanity&quot;);</span>
281   assert(!AlwaysTenure || _tenuring_threshold == 0, &quot;Sanity&quot;);
282 
283   // Fill in TLABs
284   heap-&gt;ensure_parsability(true);  // retire TLABs
285 
286   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
287     HandleMark hm;  // Discard invalid handles created during verification
288     Universe::verify(&quot;Before GC&quot;);
289   }
290 
291   {
292     ResourceMark rm;
293     HandleMark hm;
294 
295     GCTraceCPUTime tcpu;
296     GCTraceTime(Info, gc) tm(&quot;Pause Young&quot;, NULL, gc_cause, true);
297     TraceCollectorStats tcs(counters());
298     TraceMemoryManagerStats tms(heap-&gt;young_gc_manager(), gc_cause);
299 
300     if (log_is_enabled(Debug, gc, heap, exit)) {
</pre>
<hr />
<pre>
311     }
312 
313     // Verify no unmarked old-&gt;young roots
314     if (VerifyRememberedSets) {
315       heap-&gt;card_table()-&gt;verify_all_young_refs_imprecise();
316     }
317 
318     assert(young_gen-&gt;to_space()-&gt;is_empty(),
319            &quot;Attempt to scavenge with live objects in to_space&quot;);
320     young_gen-&gt;to_space()-&gt;clear(SpaceDecorator::Mangle);
321 
322     save_to_space_top_before_gc();
323 
324 #if COMPILER2_OR_JVMCI
325     DerivedPointerTable::clear();
326 #endif
327 
328     reference_processor()-&gt;enable_discovery();
329     reference_processor()-&gt;setup_policy(false);
330 
<span class="line-modified">331     PreGCValues pre_gc_values(heap);</span>
332 
333     // Reset our survivor overflow.
334     set_survivor_overflow(false);
335 
336     // We need to save the old top values before
337     // creating the promotion_manager. We pass the top
338     // values to the card_table, to prevent it from
339     // straying into the promotion labs.
340     HeapWord* old_top = old_gen-&gt;object_space()-&gt;top();
341 
<span class="line-modified">342     // Release all previously held resources</span>
<span class="line-modified">343     gc_task_manager()-&gt;release_all_resources();</span>
<span class="line-modified">344 </span>
<span class="line-modified">345     // Set the number of GC threads to be used in this collection</span>
<span class="line-modified">346     gc_task_manager()-&gt;set_active_gang();</span>
<span class="line-removed">347     gc_task_manager()-&gt;task_idle_workers();</span>
<span class="line-removed">348     // Get the active number of workers here and use that value</span>
<span class="line-removed">349     // throughout the methods.</span>
<span class="line-removed">350     uint active_workers = gc_task_manager()-&gt;active_workers();</span>
351 
352     PSPromotionManager::pre_scavenge();
353 
354     // We&#39;ll use the promotion manager again later.
355     PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();
356     {
357       GCTraceTime(Debug, gc, phases) tm(&quot;Scavenge&quot;, &amp;_gc_timer);
<span class="line-removed">358       ParallelScavengeHeap::ParStrongRootsScope psrs;</span>
<span class="line-removed">359 </span>
<span class="line-removed">360       GCTaskQueue* q = GCTaskQueue::create();</span>
361 
<span class="line-modified">362       if (!old_gen-&gt;object_space()-&gt;is_empty()) {</span>
<span class="line-modified">363         // There are only old-to-young pointers if there are objects</span>
<span class="line-removed">364         // in the old gen.</span>
<span class="line-removed">365         uint stripe_total = active_workers;</span>
<span class="line-removed">366         for(uint i=0; i &lt; stripe_total; i++) {</span>
<span class="line-removed">367           q-&gt;enqueue(new OldToYoungRootsTask(old_gen, old_top, i, stripe_total));</span>
<span class="line-removed">368         }</span>
<span class="line-removed">369       }</span>
<span class="line-removed">370 </span>
<span class="line-removed">371       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::universe));</span>
<span class="line-removed">372       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::jni_handles));</span>
<span class="line-removed">373       // We scan the thread roots in parallel</span>
<span class="line-removed">374       PSAddThreadRootsTaskClosure cl(q);</span>
<span class="line-removed">375       Threads::java_threads_and_vm_thread_do(&amp;cl);</span>
<span class="line-removed">376       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::object_synchronizer));</span>
<span class="line-removed">377       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::management));</span>
<span class="line-removed">378       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::system_dictionary));</span>
<span class="line-removed">379       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::class_loader_data));</span>
<span class="line-removed">380       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::jvmti));</span>
<span class="line-removed">381       q-&gt;enqueue(new ScavengeRootsTask(ScavengeRootsTask::code_cache));</span>
<span class="line-removed">382 </span>
<span class="line-removed">383       TaskTerminator terminator(active_workers,</span>
<span class="line-removed">384                                 (TaskQueueSetSuper*) promotion_manager-&gt;stack_array_depth());</span>
<span class="line-removed">385         // If active_workers can exceed 1, add a StrealTask.</span>
<span class="line-removed">386         // PSPromotionManager::drain_stacks_depth() does not fully drain its</span>
<span class="line-removed">387         // stacks and expects a StealTask to complete the draining if</span>
<span class="line-removed">388         // ParallelGCThreads is &gt; 1.</span>
<span class="line-removed">389         if (gc_task_manager()-&gt;workers() &gt; 1) {</span>
<span class="line-removed">390           for (uint j = 0; j &lt; active_workers; j++) {</span>
<span class="line-removed">391             q-&gt;enqueue(new StealTask(terminator.terminator()));</span>
<span class="line-removed">392           }</span>
<span class="line-removed">393         }</span>
<span class="line-removed">394 </span>
<span class="line-removed">395       gc_task_manager()-&gt;execute_and_wait(q);</span>
396     }
397 
398     scavenge_midpoint.update();
399 
400     // Process reference objects discovered during scavenge
401     {
402       GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
403 
404       reference_processor()-&gt;setup_policy(false); // not always_clear
405       reference_processor()-&gt;set_active_mt_degree(active_workers);
406       PSKeepAliveClosure keep_alive(promotion_manager);
407       PSEvacuateFollowersClosure evac_followers(promotion_manager);
408       ReferenceProcessorStats stats;
409       ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, reference_processor()-&gt;max_num_queues());
410       if (reference_processor()-&gt;processing_is_mt()) {
411         PSRefProcTaskExecutor task_executor;
412         stats = reference_processor()-&gt;process_discovered_references(
413           &amp;_is_alive_closure, &amp;keep_alive, &amp;evac_followers, &amp;task_executor,
414           &amp;pt);
415       } else {
</pre>
<hr />
<pre>
581     NOT_PRODUCT(reference_processor()-&gt;verify_no_references_recorded());
582 
583     // Re-verify object start arrays
584     if (VerifyObjectStartArray &amp;&amp;
585         VerifyAfterGC) {
586       old_gen-&gt;verify_object_start_array();
587     }
588 
589     // Verify all old -&gt; young cards are now precise
590     if (VerifyRememberedSets) {
591       // Precise verification will give false positives. Until this is fixed,
592       // use imprecise verification.
593       // heap-&gt;card_table()-&gt;verify_all_young_refs_precise();
594       heap-&gt;card_table()-&gt;verify_all_young_refs_imprecise();
595     }
596 
597     if (log_is_enabled(Debug, gc, heap, exit)) {
598       accumulated_time()-&gt;stop();
599     }
600 
<span class="line-modified">601     young_gen-&gt;print_used_change(pre_gc_values.young_gen_used());</span>
<span class="line-removed">602     old_gen-&gt;print_used_change(pre_gc_values.old_gen_used());</span>
<span class="line-removed">603     MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());</span>
604 
605     // Track memory usage and detect low memory
606     MemoryService::track_memory_usage();
607     heap-&gt;update_counters();
<span class="line-removed">608 </span>
<span class="line-removed">609     gc_task_manager()-&gt;release_idle_workers();</span>
610   }
611 
612   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
613     HandleMark hm;  // Discard invalid handles created during verification
614     Universe::verify(&quot;After GC&quot;);
615   }
616 
617   heap-&gt;print_heap_after_gc();
618   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
619 
620   scavenge_exit.update();
621 
622   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
623                             scavenge_entry.ticks(), scavenge_midpoint.ticks(),
624                             scavenge_exit.ticks());
<span class="line-removed">625   gc_task_manager()-&gt;print_task_time_stamps();</span>
<span class="line-removed">626 </span>
<span class="line-removed">627 #ifdef TRACESPINNING</span>
<span class="line-removed">628   ParallelTaskTerminator::print_termination_counts();</span>
<span class="line-removed">629 #endif</span>
630 
631   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
632 
633   _gc_timer.register_gc_end();
634 
635   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
636 
637   return !promotion_failure_occurred;
638 }
639 
640 // This method iterates over all objects in the young generation,
641 // removing all forwarding references. It then restores any preserved marks.
642 void PSScavenge::clean_up_failed_promotion() {
643   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
644   PSYoungGen* young_gen = heap-&gt;young_gen();
645 
646   RemoveForwardedPointerClosure remove_fwd_ptr_closure;
647   young_gen-&gt;object_iterate(&amp;remove_fwd_ptr_closure);
648 
649   PSPromotionManager::restore_preserved_marks();
</pre>
<hr />
<pre>
683 
684   log_trace(ergo)(&quot;%s scavenge: average_promoted &quot; SIZE_FORMAT &quot; padded_average_promoted &quot; SIZE_FORMAT &quot; free in old gen &quot; SIZE_FORMAT,
685                 result ? &quot;Do&quot; : &quot;Skip&quot;, (size_t) policy-&gt;average_promoted_in_bytes(),
686                 (size_t) policy-&gt;padded_average_promoted_in_bytes(),
687                 old_gen-&gt;free_in_bytes());
688   if (young_gen-&gt;used_in_bytes() &lt; (size_t) policy-&gt;padded_average_promoted_in_bytes()) {
689     log_trace(ergo)(&quot; padded_promoted_average is greater than maximum promotion = &quot; SIZE_FORMAT, young_gen-&gt;used_in_bytes());
690   }
691 
692   if (result) {
693     _consecutive_skipped_scavenges = 0;
694   } else {
695     _consecutive_skipped_scavenges++;
696     if (UsePerfData) {
697       counters-&gt;update_scavenge_skipped(promoted_too_large);
698     }
699   }
700   return result;
701 }
702 
<span class="line-removed">703   // Used to add tasks</span>
<span class="line-removed">704 GCTaskManager* const PSScavenge::gc_task_manager() {</span>
<span class="line-removed">705   assert(ParallelScavengeHeap::gc_task_manager() != NULL,</span>
<span class="line-removed">706    &quot;shouldn&#39;t return NULL&quot;);</span>
<span class="line-removed">707   return ParallelScavengeHeap::gc_task_manager();</span>
<span class="line-removed">708 }</span>
<span class="line-removed">709 </span>
710 // Adaptive size policy support.  When the young generation/old generation
711 // boundary moves, _young_generation_boundary must be reset
712 void PSScavenge::set_young_generation_boundary(HeapWord* v) {
713   _young_generation_boundary = v;
714   if (UseCompressedOops) {
715     _young_generation_boundary_compressed = (uintptr_t)CompressedOops::encode((oop)v);
716   }
717 }
718 
719 void PSScavenge::initialize() {
720   // Arguments must have been parsed
721 
722   if (AlwaysTenure || NeverTenure) {
<span class="line-modified">723     assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOopDesc::max_age + 1,</span>
<span class="line-modified">724            &quot;MaxTenuringThreshold should be 0 or markOopDesc::max_age + 1, but is %d&quot;, (int) MaxTenuringThreshold);</span>
725     _tenuring_threshold = MaxTenuringThreshold;
726   } else {
727     // We want to smooth out our startup times for the AdaptiveSizePolicy
728     _tenuring_threshold = (UseAdaptiveSizePolicy) ? InitialTenuringThreshold :
729                                                     MaxTenuringThreshold;
730   }
731 
732   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
733   PSYoungGen* young_gen = heap-&gt;young_gen();
734   PSOldGen* old_gen = heap-&gt;old_gen();
735 
736   // Set boundary between young_gen and old_gen
737   assert(old_gen-&gt;reserved().end() &lt;= young_gen-&gt;eden_space()-&gt;bottom(),
738          &quot;old above young&quot;);
739   set_young_generation_boundary(young_gen-&gt;eden_space()-&gt;bottom());
740 
741   // Initialize ref handling object for scavenging.
742   _span_based_discoverer.set_span(young_gen-&gt;reserved());
743   _ref_processor =
744     new ReferenceProcessor(&amp;_span_based_discoverer,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;aot/aotLoader.hpp&quot;</span>
<span class="line-added"> 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;</span>
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;

 30 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 31 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
 32 #include &quot;gc/parallel/psClosure.inline.hpp&quot;
<span class="line-modified"> 33 #include &quot;gc/parallel/psCompactionManager.hpp&quot;</span>
 34 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 35 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
<span class="line-added"> 36 #include &quot;gc/parallel/psRootType.hpp&quot;</span>
 37 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;


 38 #include &quot;gc/shared/gcCause.hpp&quot;
 39 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 40 #include &quot;gc/shared/gcId.hpp&quot;
 41 #include &quot;gc/shared/gcLocker.hpp&quot;
 42 #include &quot;gc/shared/gcTimer.hpp&quot;
 43 #include &quot;gc/shared/gcTrace.hpp&quot;
 44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 45 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 46 #include &quot;gc/shared/referencePolicy.hpp&quot;
 47 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 48 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<span class="line-modified"> 49 #include &quot;gc/shared/scavengableNMethods.hpp&quot;</span>
<span class="line-added"> 50 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
<span class="line-added"> 51 #include &quot;gc/shared/taskTerminator.hpp&quot;</span>
 52 #include &quot;gc/shared/weakProcessor.hpp&quot;
<span class="line-added"> 53 #include &quot;gc/shared/workerPolicy.hpp&quot;</span>
<span class="line-added"> 54 #include &quot;gc/shared/workgroup.hpp&quot;</span>
<span class="line-added"> 55 #include &quot;memory/iterator.hpp&quot;</span>
 56 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 57 #include &quot;memory/universe.hpp&quot;</span>
 58 #include &quot;logging/log.hpp&quot;
 59 #include &quot;oops/access.inline.hpp&quot;
 60 #include &quot;oops/compressedOops.inline.hpp&quot;
 61 #include &quot;oops/oop.inline.hpp&quot;
 62 #include &quot;runtime/biasedLocking.hpp&quot;
 63 #include &quot;runtime/handles.inline.hpp&quot;
 64 #include &quot;runtime/threadCritical.hpp&quot;
 65 #include &quot;runtime/vmThread.hpp&quot;
 66 #include &quot;runtime/vmOperations.hpp&quot;
<span class="line-added"> 67 #include &quot;services/management.hpp&quot;</span>
 68 #include &quot;services/memoryService.hpp&quot;
 69 #include &quot;utilities/stack.inline.hpp&quot;
 70 
 71 HeapWord*                     PSScavenge::_to_space_top_before_gc = NULL;
 72 int                           PSScavenge::_consecutive_skipped_scavenges = 0;
 73 SpanSubjectToDiscoveryClosure PSScavenge::_span_based_discoverer;
 74 ReferenceProcessor*           PSScavenge::_ref_processor = NULL;
 75 PSCardTable*                  PSScavenge::_card_table = NULL;
 76 bool                          PSScavenge::_survivor_overflow = false;
 77 uint                          PSScavenge::_tenuring_threshold = 0;
 78 HeapWord*                     PSScavenge::_young_generation_boundary = NULL;
 79 uintptr_t                     PSScavenge::_young_generation_boundary_compressed = 0;
 80 elapsedTimer                  PSScavenge::_accumulated_time;
 81 STWGCTimer                    PSScavenge::_gc_timer;
 82 ParallelScavengeTracer        PSScavenge::_gc_tracer;
 83 CollectorCounters*            PSScavenge::_counters = NULL;
 84 
<span class="line-added"> 85 static void scavenge_roots_work(ParallelRootType::Value root_type, uint worker_id) {</span>
<span class="line-added"> 86   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88   PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="line-added"> 89   PSScavengeRootsClosure roots_closure(pm);</span>
<span class="line-added"> 90   PSPromoteRootsClosure  roots_to_old_closure(pm);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92   switch (root_type) {</span>
<span class="line-added"> 93     case ParallelRootType::universe:</span>
<span class="line-added"> 94       Universe::oops_do(&amp;roots_closure);</span>
<span class="line-added"> 95       break;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     case ParallelRootType::jni_handles:</span>
<span class="line-added"> 98       JNIHandles::oops_do(&amp;roots_closure);</span>
<span class="line-added"> 99       break;</span>
<span class="line-added">100 </span>
<span class="line-added">101     case ParallelRootType::object_synchronizer:</span>
<span class="line-added">102       ObjectSynchronizer::oops_do(&amp;roots_closure);</span>
<span class="line-added">103       break;</span>
<span class="line-added">104 </span>
<span class="line-added">105     case ParallelRootType::system_dictionary:</span>
<span class="line-added">106       SystemDictionary::oops_do(&amp;roots_closure);</span>
<span class="line-added">107       break;</span>
<span class="line-added">108 </span>
<span class="line-added">109     case ParallelRootType::class_loader_data:</span>
<span class="line-added">110       {</span>
<span class="line-added">111         PSScavengeCLDClosure cld_closure(pm);</span>
<span class="line-added">112         ClassLoaderDataGraph::cld_do(&amp;cld_closure);</span>
<span class="line-added">113       }</span>
<span class="line-added">114       break;</span>
<span class="line-added">115 </span>
<span class="line-added">116     case ParallelRootType::management:</span>
<span class="line-added">117       Management::oops_do(&amp;roots_closure);</span>
<span class="line-added">118       break;</span>
<span class="line-added">119 </span>
<span class="line-added">120     case ParallelRootType::jvmti:</span>
<span class="line-added">121       JvmtiExport::oops_do(&amp;roots_closure);</span>
<span class="line-added">122       break;</span>
<span class="line-added">123 </span>
<span class="line-added">124     case ParallelRootType::code_cache:</span>
<span class="line-added">125       {</span>
<span class="line-added">126         MarkingCodeBlobClosure code_closure(&amp;roots_to_old_closure, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">127         ScavengableNMethods::nmethods_do(&amp;code_closure);</span>
<span class="line-added">128         AOTLoader::oops_do(&amp;roots_closure);</span>
<span class="line-added">129       }</span>
<span class="line-added">130       break;</span>
<span class="line-added">131 </span>
<span class="line-added">132     case ParallelRootType::sentinel:</span>
<span class="line-added">133     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds</span>
<span class="line-added">134       fatal(&quot;Bad enumeration value: %u&quot;, root_type);</span>
<span class="line-added">135       break;</span>
<span class="line-added">136   }</span>
<span class="line-added">137 </span>
<span class="line-added">138   // Do the real work</span>
<span class="line-added">139   pm-&gt;drain_stacks(false);</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 static void steal_work(TaskTerminator&amp; terminator, uint worker_id) {</span>
<span class="line-added">143   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">144 </span>
<span class="line-added">145   PSPromotionManager* pm =</span>
<span class="line-added">146     PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="line-added">147   pm-&gt;drain_stacks(true);</span>
<span class="line-added">148   guarantee(pm-&gt;stacks_empty(),</span>
<span class="line-added">149             &quot;stacks should be empty at this point&quot;);</span>
<span class="line-added">150 </span>
<span class="line-added">151   while (true) {</span>
<span class="line-added">152     StarTask p;</span>
<span class="line-added">153     if (PSPromotionManager::steal_depth(worker_id, p)) {</span>
<span class="line-added">154       TASKQUEUE_STATS_ONLY(pm-&gt;record_steal(p));</span>
<span class="line-added">155       pm-&gt;process_popped_location_depth(p);</span>
<span class="line-added">156       pm-&gt;drain_stacks_depth(true);</span>
<span class="line-added">157     } else {</span>
<span class="line-added">158       if (terminator.offer_termination()) {</span>
<span class="line-added">159         break;</span>
<span class="line-added">160       }</span>
<span class="line-added">161     }</span>
<span class="line-added">162   }</span>
<span class="line-added">163   guarantee(pm-&gt;stacks_empty(), &quot;stacks should be empty at this point&quot;);</span>
<span class="line-added">164 }</span>
<span class="line-added">165 </span>
166 // Define before use
167 class PSIsAliveClosure: public BoolObjectClosure {
168 public:
169   bool do_object_b(oop p) {
170     return (!PSScavenge::is_obj_in_young(p)) || p-&gt;is_forwarded();
171   }
172 };
173 
174 PSIsAliveClosure PSScavenge::_is_alive_closure;
175 
176 class PSKeepAliveClosure: public OopClosure {
177 protected:
178   MutableSpace* _to_space;
179   PSPromotionManager* _promotion_manager;
180 
181 public:
182   PSKeepAliveClosure(PSPromotionManager* pm) : _promotion_manager(pm) {
183     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
184     _to_space = heap-&gt;young_gen()-&gt;to_space();
185 
</pre>
<hr />
<pre>
196     }
197   }
198   virtual void do_oop(oop* p)       { PSKeepAliveClosure::do_oop_work(p); }
199   virtual void do_oop(narrowOop* p) { PSKeepAliveClosure::do_oop_work(p); }
200 };
201 
202 class PSEvacuateFollowersClosure: public VoidClosure {
203  private:
204   PSPromotionManager* _promotion_manager;
205  public:
206   PSEvacuateFollowersClosure(PSPromotionManager* pm) : _promotion_manager(pm) {}
207 
208   virtual void do_void() {
209     assert(_promotion_manager != NULL, &quot;Sanity&quot;);
210     _promotion_manager-&gt;drain_stacks(true);
211     guarantee(_promotion_manager-&gt;stacks_empty(),
212               &quot;stacks should be empty at this point&quot;);
213   }
214 };
215 


























216 class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {
<span class="line-modified">217   virtual void execute(ProcessTask&amp; process_task, uint ergo_workers);</span>
218 };
219 
<span class="line-modified">220 class PSRefProcTask : public AbstractGangTask {</span>
<span class="line-modified">221   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;</span>
<span class="line-modified">222   TaskTerminator _terminator;</span>
<span class="line-modified">223   ProcessTask&amp; _task;</span>
<span class="line-modified">224   uint _active_workers;</span>




225 
<span class="line-modified">226 public:</span>
<span class="line-modified">227   PSRefProcTask(ProcessTask&amp; task, uint active_workers)</span>
<span class="line-added">228     : AbstractGangTask(&quot;PSRefProcTask&quot;),</span>
<span class="line-added">229       _terminator(active_workers, PSPromotionManager::stack_array_depth()),</span>
<span class="line-added">230       _task(task),</span>
<span class="line-added">231       _active_workers(active_workers) {</span>
232   }
<span class="line-modified">233 </span>
<span class="line-modified">234   virtual void work(uint worker_id) {</span>
<span class="line-modified">235     PSPromotionManager* promotion_manager =</span>
<span class="line-modified">236       PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="line-modified">237     assert(promotion_manager != NULL, &quot;sanity check&quot;);</span>
<span class="line-added">238     PSKeepAliveClosure keep_alive(promotion_manager);</span>
<span class="line-added">239     PSEvacuateFollowersClosure evac_followers(promotion_manager);</span>
<span class="line-added">240     PSIsAliveClosure is_alive;</span>
<span class="line-added">241     _task.work(worker_id, is_alive, keep_alive, evac_followers);</span>
<span class="line-added">242 </span>
<span class="line-added">243     if (_task.marks_oops_alive() &amp;&amp; _active_workers &gt; 1) {</span>
<span class="line-added">244       steal_work(_terminator, worker_id);</span>
245     }
246   }
<span class="line-modified">247 };</span>
<span class="line-added">248 </span>
<span class="line-added">249 void PSRefProcTaskExecutor::execute(ProcessTask&amp; process_task, uint ergo_workers) {</span>
<span class="line-added">250   PSRefProcTask task(process_task, ergo_workers);</span>
<span class="line-added">251   ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
252 }
253 
254 // This method contains all heap specific policy for invoking scavenge.
255 // PSScavenge::invoke_no_policy() will do nothing but attempt to
256 // scavenge. It will not clean up after failed promotions, bail out if
257 // we&#39;ve exceeded policy time limits, or any other special behavior.
258 // All such policy should be placed here.
259 //
260 // Note that this method should only be called from the vm_thread while
261 // at a safepoint!
262 bool PSScavenge::invoke() {
263   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
264   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
265   assert(!ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;not reentrant&quot;);
266 
267   ParallelScavengeHeap* const heap = ParallelScavengeHeap::heap();
268   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
269   IsGCActiveMark mark;
270 
271   const bool scavenge_done = PSScavenge::invoke_no_policy();
272   const bool need_full_gc = !scavenge_done ||
273     policy-&gt;should_full_GC(heap-&gt;old_gen()-&gt;free_in_bytes());
274   bool full_gc_done = false;
275 
276   if (UsePerfData) {
277     PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
278     const int ffs_val = need_full_gc ? full_follows_scavenge : not_skipped;
279     counters-&gt;update_full_follows_scavenge(ffs_val);
280   }
281 
282   if (need_full_gc) {
283     GCCauseSetter gccs(heap, GCCause::_adaptive_size_policy);
284     SoftRefPolicy* srp = heap-&gt;soft_ref_policy();
285     const bool clear_all_softrefs = srp-&gt;should_clear_all_soft_refs();
286 
<span class="line-modified">287     full_gc_done = PSParallelCompact::invoke_no_policy(clear_all_softrefs);</span>




288   }
289 
290   return full_gc_done;
291 }
292 
<span class="line-modified">293 class PSThreadRootsTaskClosure : public ThreadClosure {</span>
<span class="line-modified">294   uint _worker_id;</span>
<span class="line-modified">295 public:</span>
<span class="line-added">296   PSThreadRootsTaskClosure(uint worker_id) : _worker_id(worker_id) { }</span>
<span class="line-added">297   virtual void do_thread(Thread* thread) {</span>
<span class="line-added">298     assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);</span>
<span class="line-added">299 </span>
<span class="line-added">300     PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(_worker_id);</span>
<span class="line-added">301     PSScavengeRootsClosure roots_closure(pm);</span>
<span class="line-added">302     MarkingCodeBlobClosure roots_in_blobs(&amp;roots_closure, CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">303 </span>
<span class="line-added">304     thread-&gt;oops_do(&amp;roots_closure, &amp;roots_in_blobs);</span>
<span class="line-added">305 </span>
<span class="line-added">306     // Do the real work</span>
<span class="line-added">307     pm-&gt;drain_stacks(false);</span>
<span class="line-added">308   }</span>
<span class="line-added">309 };</span>
<span class="line-added">310 </span>
<span class="line-added">311 class ScavengeRootsTask : public AbstractGangTask {</span>
<span class="line-added">312   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do</span>
<span class="line-added">313   SequentialSubTasksDone _subtasks;</span>
<span class="line-added">314   PSOldGen* _old_gen;</span>
<span class="line-added">315   HeapWord* _gen_top;</span>
<span class="line-added">316   uint _active_workers;</span>
<span class="line-added">317   bool _is_empty;</span>
<span class="line-added">318   TaskTerminator _terminator;</span>
319 
320 public:
<span class="line-modified">321   ScavengeRootsTask(PSOldGen* old_gen,</span>
<span class="line-modified">322                     HeapWord* gen_top,</span>
<span class="line-modified">323                     uint active_workers,</span>
<span class="line-added">324                     bool is_empty) :</span>
<span class="line-added">325       AbstractGangTask(&quot;ScavengeRootsTask&quot;),</span>
<span class="line-added">326       _strong_roots_scope(active_workers),</span>
<span class="line-added">327       _subtasks(),</span>
<span class="line-added">328       _old_gen(old_gen),</span>
<span class="line-added">329       _gen_top(gen_top),</span>
<span class="line-added">330       _active_workers(active_workers),</span>
<span class="line-added">331       _is_empty(is_empty),</span>
<span class="line-added">332       _terminator(active_workers, PSPromotionManager::vm_thread_promotion_manager()-&gt;stack_array_depth()) {</span>
<span class="line-added">333     _subtasks.set_n_threads(active_workers);</span>
<span class="line-added">334     _subtasks.set_n_tasks(ParallelRootType::sentinel);</span>
<span class="line-added">335   }</span>
<span class="line-added">336 </span>
<span class="line-added">337   virtual void work(uint worker_id) {</span>
<span class="line-added">338     ResourceMark rm;</span>
<span class="line-added">339 </span>
<span class="line-added">340     if (!_is_empty) {</span>
<span class="line-added">341       // There are only old-to-young pointers if there are objects</span>
<span class="line-added">342       // in the old gen.</span>
<span class="line-added">343 </span>
<span class="line-added">344       assert(_old_gen != NULL, &quot;Sanity&quot;);</span>
<span class="line-added">345       // There are no old-to-young pointers if the old gen is empty.</span>
<span class="line-added">346       assert(!_old_gen-&gt;object_space()-&gt;is_empty(), &quot;Should not be called is there is no work&quot;);</span>
<span class="line-added">347       assert(_old_gen-&gt;object_space()-&gt;contains(_gen_top) || _gen_top == _old_gen-&gt;object_space()-&gt;top(), &quot;Sanity&quot;);</span>
<span class="line-added">348       assert(worker_id &lt; ParallelGCThreads, &quot;Sanity&quot;);</span>
<span class="line-added">349 </span>
<span class="line-added">350       {</span>
<span class="line-added">351         PSPromotionManager* pm = PSPromotionManager::gc_thread_promotion_manager(worker_id);</span>
<span class="line-added">352         PSCardTable* card_table = ParallelScavengeHeap::heap()-&gt;card_table();</span>
<span class="line-added">353 </span>
<span class="line-added">354         card_table-&gt;scavenge_contents_parallel(_old_gen-&gt;start_array(),</span>
<span class="line-added">355                                                _old_gen-&gt;object_space(),</span>
<span class="line-added">356                                                _gen_top,</span>
<span class="line-added">357                                                pm,</span>
<span class="line-added">358                                                worker_id,</span>
<span class="line-added">359                                                _active_workers);</span>
<span class="line-added">360 </span>
<span class="line-added">361         // Do the real work</span>
<span class="line-added">362         pm-&gt;drain_stacks(false);</span>
<span class="line-added">363       }</span>
<span class="line-added">364     }</span>
<span class="line-added">365 </span>
<span class="line-added">366     for (uint root_type = 0; _subtasks.try_claim_task(root_type); /* empty */ ) {</span>
<span class="line-added">367       scavenge_roots_work(static_cast&lt;ParallelRootType::Value&gt;(root_type), worker_id);</span>
<span class="line-added">368     }</span>
<span class="line-added">369     _subtasks.all_tasks_completed();</span>
<span class="line-added">370 </span>
<span class="line-added">371     PSThreadRootsTaskClosure closure(worker_id);</span>
<span class="line-added">372     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);</span>
<span class="line-added">373 </span>
<span class="line-added">374 </span>
<span class="line-added">375     // If active_workers can exceed 1, add a steal_work().</span>
<span class="line-added">376     // PSPromotionManager::drain_stacks_depth() does not fully drain its</span>
<span class="line-added">377     // stacks and expects a steal_work() to complete the draining if</span>
<span class="line-added">378     // ParallelGCThreads is &gt; 1.</span>
<span class="line-added">379 </span>
<span class="line-added">380     if (_active_workers &gt; 1) {</span>
<span class="line-added">381       steal_work(_terminator, worker_id);</span>
<span class="line-added">382     }</span>
383   }
384 };
385 
386 // This method contains no policy. You should probably
387 // be calling invoke() instead.
388 bool PSScavenge::invoke_no_policy() {
389   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
390   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
391 
392   _gc_timer.register_gc_start();
393 
394   TimeStamp scavenge_entry;
395   TimeStamp scavenge_midpoint;
396   TimeStamp scavenge_exit;
397 
398   scavenge_entry.update();
399 
400   if (GCLocker::check_active_before_gc()) {
401     return false;
402   }
</pre>
<hr />
<pre>
411 
412   GCIdMark gc_id_mark;
413   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
414 
415   bool promotion_failure_occurred = false;
416 
417   PSYoungGen* young_gen = heap-&gt;young_gen();
418   PSOldGen* old_gen = heap-&gt;old_gen();
419   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
420 
421   heap-&gt;increment_total_collections();
422 
423   if (AdaptiveSizePolicy::should_update_eden_stats(gc_cause)) {
424     // Gather the feedback data for eden occupancy.
425     young_gen-&gt;eden_space()-&gt;accumulate_statistics();
426   }
427 
428   heap-&gt;print_heap_before_gc();
429   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
430 
<span class="line-modified">431   assert(!NeverTenure || _tenuring_threshold == markWord::max_age + 1, &quot;Sanity&quot;);</span>
432   assert(!AlwaysTenure || _tenuring_threshold == 0, &quot;Sanity&quot;);
433 
434   // Fill in TLABs
435   heap-&gt;ensure_parsability(true);  // retire TLABs
436 
437   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
438     HandleMark hm;  // Discard invalid handles created during verification
439     Universe::verify(&quot;Before GC&quot;);
440   }
441 
442   {
443     ResourceMark rm;
444     HandleMark hm;
445 
446     GCTraceCPUTime tcpu;
447     GCTraceTime(Info, gc) tm(&quot;Pause Young&quot;, NULL, gc_cause, true);
448     TraceCollectorStats tcs(counters());
449     TraceMemoryManagerStats tms(heap-&gt;young_gc_manager(), gc_cause);
450 
451     if (log_is_enabled(Debug, gc, heap, exit)) {
</pre>
<hr />
<pre>
462     }
463 
464     // Verify no unmarked old-&gt;young roots
465     if (VerifyRememberedSets) {
466       heap-&gt;card_table()-&gt;verify_all_young_refs_imprecise();
467     }
468 
469     assert(young_gen-&gt;to_space()-&gt;is_empty(),
470            &quot;Attempt to scavenge with live objects in to_space&quot;);
471     young_gen-&gt;to_space()-&gt;clear(SpaceDecorator::Mangle);
472 
473     save_to_space_top_before_gc();
474 
475 #if COMPILER2_OR_JVMCI
476     DerivedPointerTable::clear();
477 #endif
478 
479     reference_processor()-&gt;enable_discovery();
480     reference_processor()-&gt;setup_policy(false);
481 
<span class="line-modified">482     const PreGenGCValues pre_gc_values = heap-&gt;get_pre_gc_values();</span>
483 
484     // Reset our survivor overflow.
485     set_survivor_overflow(false);
486 
487     // We need to save the old top values before
488     // creating the promotion_manager. We pass the top
489     // values to the card_table, to prevent it from
490     // straying into the promotion labs.
491     HeapWord* old_top = old_gen-&gt;object_space()-&gt;top();
492 
<span class="line-modified">493     const uint active_workers =</span>
<span class="line-modified">494       WorkerPolicy::calc_active_workers(ParallelScavengeHeap::heap()-&gt;workers().total_workers(),</span>
<span class="line-modified">495                                         ParallelScavengeHeap::heap()-&gt;workers().active_workers(),</span>
<span class="line-modified">496                                         Threads::number_of_non_daemon_threads());</span>
<span class="line-modified">497     ParallelScavengeHeap::heap()-&gt;workers().update_active_workers(active_workers);</span>




498 
499     PSPromotionManager::pre_scavenge();
500 
501     // We&#39;ll use the promotion manager again later.
502     PSPromotionManager* promotion_manager = PSPromotionManager::vm_thread_promotion_manager();
503     {
504       GCTraceTime(Debug, gc, phases) tm(&quot;Scavenge&quot;, &amp;_gc_timer);



505 
<span class="line-modified">506       ScavengeRootsTask task(old_gen, old_top, active_workers, old_gen-&gt;object_space()-&gt;is_empty());</span>
<span class="line-modified">507       ParallelScavengeHeap::heap()-&gt;workers().run_task(&amp;task);</span>
































508     }
509 
510     scavenge_midpoint.update();
511 
512     // Process reference objects discovered during scavenge
513     {
514       GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
515 
516       reference_processor()-&gt;setup_policy(false); // not always_clear
517       reference_processor()-&gt;set_active_mt_degree(active_workers);
518       PSKeepAliveClosure keep_alive(promotion_manager);
519       PSEvacuateFollowersClosure evac_followers(promotion_manager);
520       ReferenceProcessorStats stats;
521       ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, reference_processor()-&gt;max_num_queues());
522       if (reference_processor()-&gt;processing_is_mt()) {
523         PSRefProcTaskExecutor task_executor;
524         stats = reference_processor()-&gt;process_discovered_references(
525           &amp;_is_alive_closure, &amp;keep_alive, &amp;evac_followers, &amp;task_executor,
526           &amp;pt);
527       } else {
</pre>
<hr />
<pre>
693     NOT_PRODUCT(reference_processor()-&gt;verify_no_references_recorded());
694 
695     // Re-verify object start arrays
696     if (VerifyObjectStartArray &amp;&amp;
697         VerifyAfterGC) {
698       old_gen-&gt;verify_object_start_array();
699     }
700 
701     // Verify all old -&gt; young cards are now precise
702     if (VerifyRememberedSets) {
703       // Precise verification will give false positives. Until this is fixed,
704       // use imprecise verification.
705       // heap-&gt;card_table()-&gt;verify_all_young_refs_precise();
706       heap-&gt;card_table()-&gt;verify_all_young_refs_imprecise();
707     }
708 
709     if (log_is_enabled(Debug, gc, heap, exit)) {
710       accumulated_time()-&gt;stop();
711     }
712 
<span class="line-modified">713     heap-&gt;print_heap_change(pre_gc_values);</span>


714 
715     // Track memory usage and detect low memory
716     MemoryService::track_memory_usage();
717     heap-&gt;update_counters();


718   }
719 
720   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
721     HandleMark hm;  // Discard invalid handles created during verification
722     Universe::verify(&quot;After GC&quot;);
723   }
724 
725   heap-&gt;print_heap_after_gc();
726   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
727 
728   scavenge_exit.update();
729 
730   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
731                             scavenge_entry.ticks(), scavenge_midpoint.ticks(),
732                             scavenge_exit.ticks());





733 
734   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
735 
736   _gc_timer.register_gc_end();
737 
738   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
739 
740   return !promotion_failure_occurred;
741 }
742 
743 // This method iterates over all objects in the young generation,
744 // removing all forwarding references. It then restores any preserved marks.
745 void PSScavenge::clean_up_failed_promotion() {
746   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
747   PSYoungGen* young_gen = heap-&gt;young_gen();
748 
749   RemoveForwardedPointerClosure remove_fwd_ptr_closure;
750   young_gen-&gt;object_iterate(&amp;remove_fwd_ptr_closure);
751 
752   PSPromotionManager::restore_preserved_marks();
</pre>
<hr />
<pre>
786 
787   log_trace(ergo)(&quot;%s scavenge: average_promoted &quot; SIZE_FORMAT &quot; padded_average_promoted &quot; SIZE_FORMAT &quot; free in old gen &quot; SIZE_FORMAT,
788                 result ? &quot;Do&quot; : &quot;Skip&quot;, (size_t) policy-&gt;average_promoted_in_bytes(),
789                 (size_t) policy-&gt;padded_average_promoted_in_bytes(),
790                 old_gen-&gt;free_in_bytes());
791   if (young_gen-&gt;used_in_bytes() &lt; (size_t) policy-&gt;padded_average_promoted_in_bytes()) {
792     log_trace(ergo)(&quot; padded_promoted_average is greater than maximum promotion = &quot; SIZE_FORMAT, young_gen-&gt;used_in_bytes());
793   }
794 
795   if (result) {
796     _consecutive_skipped_scavenges = 0;
797   } else {
798     _consecutive_skipped_scavenges++;
799     if (UsePerfData) {
800       counters-&gt;update_scavenge_skipped(promoted_too_large);
801     }
802   }
803   return result;
804 }
805 







806 // Adaptive size policy support.  When the young generation/old generation
807 // boundary moves, _young_generation_boundary must be reset
808 void PSScavenge::set_young_generation_boundary(HeapWord* v) {
809   _young_generation_boundary = v;
810   if (UseCompressedOops) {
811     _young_generation_boundary_compressed = (uintptr_t)CompressedOops::encode((oop)v);
812   }
813 }
814 
815 void PSScavenge::initialize() {
816   // Arguments must have been parsed
817 
818   if (AlwaysTenure || NeverTenure) {
<span class="line-modified">819     assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,</span>
<span class="line-modified">820            &quot;MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is %d&quot;, (int) MaxTenuringThreshold);</span>
821     _tenuring_threshold = MaxTenuringThreshold;
822   } else {
823     // We want to smooth out our startup times for the AdaptiveSizePolicy
824     _tenuring_threshold = (UseAdaptiveSizePolicy) ? InitialTenuringThreshold :
825                                                     MaxTenuringThreshold;
826   }
827 
828   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
829   PSYoungGen* young_gen = heap-&gt;young_gen();
830   PSOldGen* old_gen = heap-&gt;old_gen();
831 
832   // Set boundary between young_gen and old_gen
833   assert(old_gen-&gt;reserved().end() &lt;= young_gen-&gt;eden_space()-&gt;bottom(),
834          &quot;old above young&quot;);
835   set_young_generation_boundary(young_gen-&gt;eden_space()-&gt;bottom());
836 
837   // Initialize ref handling object for scavenging.
838   _span_based_discoverer.set_span(young_gen-&gt;reserved());
839   _ref_processor =
840     new ReferenceProcessor(&amp;_span_based_discoverer,
</pre>
</td>
</tr>
</table>
<center><a href="psPromotionManager.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/asPSYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="asPSOldGen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsParallel.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/asPSYoungGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSYoungGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="line-removed"> 28 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 29 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 30 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified"> 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/java.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 
 37 ASPSYoungGen::ASPSYoungGen(size_t init_byte_size,
 38                            size_t minimum_byte_size,
 39                            size_t byte_size_limit) :
 40   PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 41   _gen_size_limit(byte_size_limit) {
 42 }
 43 
 44 
 45 ASPSYoungGen::ASPSYoungGen(PSVirtualSpace* vs,
 46                            size_t init_byte_size,
 47                            size_t minimum_byte_size,
 48                            size_t byte_size_limit) :
 49   //PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 50   PSYoungGen(vs-&gt;committed_size(), minimum_byte_size, byte_size_limit),
 51   _gen_size_limit(byte_size_limit) {
 52 
 53   assert(vs-&gt;committed_size() == init_byte_size, &quot;Cannot replace with&quot;);
 54 
 55   _virtual_space = vs;
 56 }
 57 
 58 void ASPSYoungGen::initialize_virtual_space(ReservedSpace rs,
 59                                             size_t alignment) {
 60   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 61   _virtual_space = new PSVirtualSpaceHighToLow(rs, alignment);
 62   if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
<span class="line-modified"> 63     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;</span>
<span class="line-removed"> 64                                   &quot;object heap&quot;);</span>
 65   }
 66 }
 67 
 68 void ASPSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 69   initialize_virtual_space(rs, alignment);
 70   initialize_work();
 71 }
 72 
 73 size_t ASPSYoungGen::available_for_expansion() {
 74   size_t current_committed_size = virtual_space()-&gt;committed_size();
 75   assert((gen_size_limit() &gt;= current_committed_size),
 76     &quot;generation size limit is wrong&quot;);
<span class="line-modified"> 77   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
 78   size_t result =  gen_size_limit() - current_committed_size;
<span class="line-modified"> 79   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
 80   return result_aligned;
 81 }
 82 
 83 // Return the number of bytes the young gen is willing give up.
 84 //
 85 // Future implementations could check the survivors and if to_space is in the
 86 // right place (below from_space), take a chunk from to_space.
 87 size_t ASPSYoungGen::available_for_contraction() {
 88   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
 89   if (uncommitted_bytes != 0) {
 90     return uncommitted_bytes;
 91   }
 92 
 93   if (eden_space()-&gt;is_empty()) {
 94     // Respect the minimum size for eden and for the young gen as a whole.
 95     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-modified"> 96     const size_t eden_alignment = heap-&gt;space_alignment();</span>
<span class="line-removed"> 97     const size_t gen_alignment = heap-&gt;generation_alignment();</span>
 98 
 99     assert(eden_space()-&gt;capacity_in_bytes() &gt;= eden_alignment,
100       &quot;Alignment is wrong&quot;);
101     size_t eden_avail = eden_space()-&gt;capacity_in_bytes() - eden_alignment;
<span class="line-modified">102     eden_avail = align_down(eden_avail, gen_alignment);</span>
103 
104     assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(),
105       &quot;minimum gen size is wrong&quot;);
106     size_t gen_avail = virtual_space()-&gt;committed_size() - min_gen_size();
107     assert(virtual_space()-&gt;is_aligned(gen_avail), &quot;not aligned&quot;);
108 
109     const size_t max_contraction = MIN2(eden_avail, gen_avail);
110     // See comment for ASPSOldGen::available_for_contraction()
111     // for reasons the &quot;increment&quot; fraction is used.
112     PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
113     size_t result = policy-&gt;eden_increment_aligned_down(max_contraction);
<span class="line-modified">114     size_t result_aligned = align_down(result, gen_alignment);</span>
115 
116     log_trace(gc, ergo)(&quot;ASPSYoungGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K&quot;, result_aligned/K);
117     log_trace(gc, ergo)(&quot;  max_contraction &quot; SIZE_FORMAT &quot; K&quot;, max_contraction/K);
118     log_trace(gc, ergo)(&quot;  eden_avail &quot; SIZE_FORMAT &quot; K&quot;, eden_avail/K);
119     log_trace(gc, ergo)(&quot;  gen_avail &quot; SIZE_FORMAT &quot; K&quot;, gen_avail/K);
120 
121     return result_aligned;
122   }
123 
124   return 0;
125 }
126 
127 // The current implementation only considers to the end of eden.
128 // If to_space is below from_space, to_space is not considered.
129 // to_space can be.
130 size_t ASPSYoungGen::available_to_live() {
<span class="line-modified">131   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">132   const size_t alignment = heap-&gt;space_alignment();</span>
133 
134   // Include any space that is committed but is not in eden.
135   size_t available = pointer_delta(eden_space()-&gt;bottom(),
136                                    virtual_space()-&gt;low(),
137                                    sizeof(char));
138 
139   const size_t eden_capacity = eden_space()-&gt;capacity_in_bytes();
140   if (eden_space()-&gt;is_empty() &amp;&amp; eden_capacity &gt; alignment) {
141     available += eden_capacity - alignment;
142   }
143   return available;
144 }
145 
146 // Similar to PSYoungGen::resize_generation() but
147 //  allows sum of eden_size and 2 * survivor_size to exceed _max_gen_size
148 //  expands at the low end of the virtual space
149 //  moves the boundary between the generations in order to expand
150 //  some additional diagnostics
151 // If no additional changes are required, this can be deleted
152 // and the changes factored back into PSYoungGen::resize_generation().
153 bool ASPSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
154   const size_t alignment = virtual_space()-&gt;alignment();
155   size_t orig_size = virtual_space()-&gt;committed_size();
156   bool size_changed = false;
157 
158   // There used to be a guarantee here that
159   //   (eden_size + 2*survivor_size)  &lt;= _max_gen_size
160   // This requirement is enforced by the calculation of desired_size
161   // below.  It may not be true on entry since the size of the
162   // eden_size is no bounded by the generation size.
163 
164   assert(max_size() == reserved().byte_size(), &quot;max gen size problem?&quot;);
165   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(),
166          &quot;just checking&quot;);
167 
168   // Adjust new generation size
169   const size_t eden_plus_survivors =
170     align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">171   size_t desired_size = MAX2(MIN2(eden_plus_survivors, gen_size_limit()),</span>
<span class="line-removed">172                              min_gen_size());</span>
173   assert(desired_size &lt;= gen_size_limit(), &quot;just checking&quot;);
174 
175   if (desired_size &gt; orig_size) {
176     // Grow the generation
177     size_t change = desired_size - orig_size;
178     HeapWord* prev_low = (HeapWord*) virtual_space()-&gt;low();
179     if (!virtual_space()-&gt;expand_by(change)) {
180       return false;
181     }
182     if (ZapUnusedHeapArea) {
183       // Mangle newly committed space immediately because it
184       // can be done here more simply that after the new
185       // spaces have been computed.
186       HeapWord* new_low = (HeapWord*) virtual_space()-&gt;low();
187       assert(new_low &lt; prev_low, &quot;Did not grow&quot;);
188 
189       MemRegion mangle_region(new_low, prev_low);
190       SpaceMangler::mangle_region(mangle_region);
191     }
192     size_changed = true;
</pre>
<hr />
<pre>
258                       pointer_delta(  to_space()-&gt;end(), to_space()-&gt;bottom(), sizeof(char)));
259 
260   // There&#39;s nothing to do if the new sizes are the same as the current
261   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
262       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
263       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
264     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
265     return;
266   }
267 
268   char* eden_start = (char*)virtual_space()-&gt;low();
269   char* eden_end   = (char*)eden_space()-&gt;end();
270   char* from_start = (char*)from_space()-&gt;bottom();
271   char* from_end   = (char*)from_space()-&gt;end();
272   char* to_start   = (char*)to_space()-&gt;bottom();
273   char* to_end     = (char*)to_space()-&gt;end();
274 
275   assert(eden_start &lt; from_start, &quot;Cannot push into from_space&quot;);
276 
277   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-removed">278   const size_t alignment = heap-&gt;space_alignment();</span>
279   const bool maintain_minimum =
280     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
281 
282   bool eden_from_to_order = from_start &lt; to_start;
283   // Check whether from space is below to space
284   if (eden_from_to_order) {
285     // Eden, from, to
286 
287     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
288 
289     // Set eden
290     // &quot;requested_eden_size&quot; is a goal for the size of eden
291     // and may not be attainable.  &quot;eden_size&quot; below is
292     // calculated based on the location of from-space and
293     // the goal for the size of eden.  from-space is
294     // fixed in place because it contains live data.
295     // The calculation is done this way to avoid 32bit
296     // overflow (i.e., eden_start + requested_eden_size
297     // may too large for representation in 32bits).
298     size_t eden_size;
</pre>
<hr />
<pre>
314     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
315 
316     // To may resize into from space as long as it is clear of live data.
317     // From space must remain page aligned, though, so we need to do some
318     // extra calculations.
319 
320     // First calculate an optimal to-space
321     to_end   = (char*)virtual_space()-&gt;high();
322     to_start = (char*)pointer_delta(to_end,
323                                     (char*)requested_survivor_size,
324                                     sizeof(char));
325 
326     // Does the optimal to-space overlap from-space?
327     if (to_start &lt; (char*)from_space()-&gt;end()) {
328       // Calculate the minimum offset possible for from_end
329       size_t from_size =
330         pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
331 
332       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
333       if (from_size == 0) {
<span class="line-modified">334         from_size = alignment;</span>
335       } else {
<span class="line-modified">336         from_size = align_up(from_size, alignment);</span>
337       }
338 
339       from_end = from_start + from_size;
340       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
341 
342       guarantee(from_end &lt;= (char*)from_space()-&gt;end(),
343         &quot;from_end moved to the right&quot;);
344 
345       // Now update to_start with the new from_end
346       to_start = MAX2(from_end, to_start);
347     }
348 
349     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
350 
351     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
352                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
353                         p2i(eden_start),
354                         p2i(eden_end),
355                         pointer_delta(eden_end, eden_start, sizeof(char)));
356     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
</pre>
<hr />
<pre>
363                         p2i(to_start),
364                         p2i(to_end),
365                         pointer_delta(  to_end,   to_start, sizeof(char)));
366   } else {
367     // Eden, to, from
368     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
369 
370     // To space gets priority over eden resizing. Note that we position
371     // to space as if we were able to resize from space, even though from
372     // space is not modified.
373     // Giving eden priority was tried and gave poorer performance.
374     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
375                                     (char*)requested_survivor_size,
376                                     sizeof(char));
377     to_end   = MIN2(to_end, from_start);
378     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
379                                     sizeof(char));
380     // if the space sizes are to be increased by several times then
381     // &#39;to_start&#39; will point beyond the young generation. In this case
382     // &#39;to_start&#39; should be adjusted.
<span class="line-modified">383     to_start = MAX2(to_start, eden_start + alignment);</span>
384 
385     // Compute how big eden can be, then adjust end.
386     // See  comments above on calculating eden_end.
387     size_t eden_size;
388     if (maintain_minimum) {
389       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
390     } else {
391       eden_size = MIN2(requested_eden_size,
392                        pointer_delta(to_start, eden_start, sizeof(char)));
393     }
394     eden_end = eden_start + eden_size;
395     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
396 
397     // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">398     eden_end = MAX2(eden_end, eden_start + alignment);</span>
399     to_start = MAX2(to_start, eden_end);
400 
401     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
402                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
403                         p2i(eden_start),
404                         p2i(eden_end),
405                         pointer_delta(eden_end, eden_start, sizeof(char)));
406     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): &quot;
407                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
408                         p2i(to_start),
409                         p2i(to_end),
410                         pointer_delta(  to_end,   to_start, sizeof(char)));
411     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
412                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
413                         p2i(from_start),
414                         p2i(from_end),
415                         pointer_delta(from_end, from_start, sizeof(char)));
416   }
417 
418 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSYoungGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;

 28 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/java.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 
 37 ASPSYoungGen::ASPSYoungGen(size_t init_byte_size,
 38                            size_t minimum_byte_size,
 39                            size_t byte_size_limit) :
 40   PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 41   _gen_size_limit(byte_size_limit) {
 42 }
 43 
 44 
 45 ASPSYoungGen::ASPSYoungGen(PSVirtualSpace* vs,
 46                            size_t init_byte_size,
 47                            size_t minimum_byte_size,
 48                            size_t byte_size_limit) :
 49   //PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 50   PSYoungGen(vs-&gt;committed_size(), minimum_byte_size, byte_size_limit),
 51   _gen_size_limit(byte_size_limit) {
 52 
 53   assert(vs-&gt;committed_size() == init_byte_size, &quot;Cannot replace with&quot;);
 54 
 55   _virtual_space = vs;
 56 }
 57 
 58 void ASPSYoungGen::initialize_virtual_space(ReservedSpace rs,
 59                                             size_t alignment) {
 60   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 61   _virtual_space = new PSVirtualSpaceHighToLow(rs, alignment);
 62   if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
<span class="line-modified"> 63     vm_exit_during_initialization(&quot;Could not reserve enough space for object heap&quot;);</span>

 64   }
 65 }
 66 
 67 void ASPSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 68   initialize_virtual_space(rs, alignment);
 69   initialize_work();
 70 }
 71 
 72 size_t ASPSYoungGen::available_for_expansion() {
 73   size_t current_committed_size = virtual_space()-&gt;committed_size();
 74   assert((gen_size_limit() &gt;= current_committed_size),
 75     &quot;generation size limit is wrong&quot;);
<span class="line-modified"> 76 </span>
 77   size_t result =  gen_size_limit() - current_committed_size;
<span class="line-modified"> 78   size_t result_aligned = align_down(result, GenAlignment);</span>
 79   return result_aligned;
 80 }
 81 
 82 // Return the number of bytes the young gen is willing give up.
 83 //
 84 // Future implementations could check the survivors and if to_space is in the
 85 // right place (below from_space), take a chunk from to_space.
 86 size_t ASPSYoungGen::available_for_contraction() {
 87   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
 88   if (uncommitted_bytes != 0) {
 89     return uncommitted_bytes;
 90   }
 91 
 92   if (eden_space()-&gt;is_empty()) {
 93     // Respect the minimum size for eden and for the young gen as a whole.
 94     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-modified"> 95     const size_t eden_alignment = SpaceAlignment;</span>

 96 
 97     assert(eden_space()-&gt;capacity_in_bytes() &gt;= eden_alignment,
 98       &quot;Alignment is wrong&quot;);
 99     size_t eden_avail = eden_space()-&gt;capacity_in_bytes() - eden_alignment;
<span class="line-modified">100     eden_avail = align_down(eden_avail, GenAlignment);</span>
101 
102     assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(),
103       &quot;minimum gen size is wrong&quot;);
104     size_t gen_avail = virtual_space()-&gt;committed_size() - min_gen_size();
105     assert(virtual_space()-&gt;is_aligned(gen_avail), &quot;not aligned&quot;);
106 
107     const size_t max_contraction = MIN2(eden_avail, gen_avail);
108     // See comment for ASPSOldGen::available_for_contraction()
109     // for reasons the &quot;increment&quot; fraction is used.
110     PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
111     size_t result = policy-&gt;eden_increment_aligned_down(max_contraction);
<span class="line-modified">112     size_t result_aligned = align_down(result, GenAlignment);</span>
113 
114     log_trace(gc, ergo)(&quot;ASPSYoungGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K&quot;, result_aligned/K);
115     log_trace(gc, ergo)(&quot;  max_contraction &quot; SIZE_FORMAT &quot; K&quot;, max_contraction/K);
116     log_trace(gc, ergo)(&quot;  eden_avail &quot; SIZE_FORMAT &quot; K&quot;, eden_avail/K);
117     log_trace(gc, ergo)(&quot;  gen_avail &quot; SIZE_FORMAT &quot; K&quot;, gen_avail/K);
118 
119     return result_aligned;
120   }
121 
122   return 0;
123 }
124 
125 // The current implementation only considers to the end of eden.
126 // If to_space is below from_space, to_space is not considered.
127 // to_space can be.
128 size_t ASPSYoungGen::available_to_live() {
<span class="line-modified">129   const size_t alignment = SpaceAlignment;</span>

130 
131   // Include any space that is committed but is not in eden.
132   size_t available = pointer_delta(eden_space()-&gt;bottom(),
133                                    virtual_space()-&gt;low(),
134                                    sizeof(char));
135 
136   const size_t eden_capacity = eden_space()-&gt;capacity_in_bytes();
137   if (eden_space()-&gt;is_empty() &amp;&amp; eden_capacity &gt; alignment) {
138     available += eden_capacity - alignment;
139   }
140   return available;
141 }
142 
143 // Similar to PSYoungGen::resize_generation() but
144 //  allows sum of eden_size and 2 * survivor_size to exceed _max_gen_size
145 //  expands at the low end of the virtual space
146 //  moves the boundary between the generations in order to expand
147 //  some additional diagnostics
148 // If no additional changes are required, this can be deleted
149 // and the changes factored back into PSYoungGen::resize_generation().
150 bool ASPSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
151   const size_t alignment = virtual_space()-&gt;alignment();
152   size_t orig_size = virtual_space()-&gt;committed_size();
153   bool size_changed = false;
154 
155   // There used to be a guarantee here that
156   //   (eden_size + 2*survivor_size)  &lt;= _max_gen_size
157   // This requirement is enforced by the calculation of desired_size
158   // below.  It may not be true on entry since the size of the
159   // eden_size is no bounded by the generation size.
160 
161   assert(max_size() == reserved().byte_size(), &quot;max gen size problem?&quot;);
162   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(),
163          &quot;just checking&quot;);
164 
165   // Adjust new generation size
166   const size_t eden_plus_survivors =
167     align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">168   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), gen_size_limit());</span>

169   assert(desired_size &lt;= gen_size_limit(), &quot;just checking&quot;);
170 
171   if (desired_size &gt; orig_size) {
172     // Grow the generation
173     size_t change = desired_size - orig_size;
174     HeapWord* prev_low = (HeapWord*) virtual_space()-&gt;low();
175     if (!virtual_space()-&gt;expand_by(change)) {
176       return false;
177     }
178     if (ZapUnusedHeapArea) {
179       // Mangle newly committed space immediately because it
180       // can be done here more simply that after the new
181       // spaces have been computed.
182       HeapWord* new_low = (HeapWord*) virtual_space()-&gt;low();
183       assert(new_low &lt; prev_low, &quot;Did not grow&quot;);
184 
185       MemRegion mangle_region(new_low, prev_low);
186       SpaceMangler::mangle_region(mangle_region);
187     }
188     size_changed = true;
</pre>
<hr />
<pre>
254                       pointer_delta(  to_space()-&gt;end(), to_space()-&gt;bottom(), sizeof(char)));
255 
256   // There&#39;s nothing to do if the new sizes are the same as the current
257   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
258       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
259       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
260     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
261     return;
262   }
263 
264   char* eden_start = (char*)virtual_space()-&gt;low();
265   char* eden_end   = (char*)eden_space()-&gt;end();
266   char* from_start = (char*)from_space()-&gt;bottom();
267   char* from_end   = (char*)from_space()-&gt;end();
268   char* to_start   = (char*)to_space()-&gt;bottom();
269   char* to_end     = (char*)to_space()-&gt;end();
270 
271   assert(eden_start &lt; from_start, &quot;Cannot push into from_space&quot;);
272 
273   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();

274   const bool maintain_minimum =
275     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
276 
277   bool eden_from_to_order = from_start &lt; to_start;
278   // Check whether from space is below to space
279   if (eden_from_to_order) {
280     // Eden, from, to
281 
282     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
283 
284     // Set eden
285     // &quot;requested_eden_size&quot; is a goal for the size of eden
286     // and may not be attainable.  &quot;eden_size&quot; below is
287     // calculated based on the location of from-space and
288     // the goal for the size of eden.  from-space is
289     // fixed in place because it contains live data.
290     // The calculation is done this way to avoid 32bit
291     // overflow (i.e., eden_start + requested_eden_size
292     // may too large for representation in 32bits).
293     size_t eden_size;
</pre>
<hr />
<pre>
309     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
310 
311     // To may resize into from space as long as it is clear of live data.
312     // From space must remain page aligned, though, so we need to do some
313     // extra calculations.
314 
315     // First calculate an optimal to-space
316     to_end   = (char*)virtual_space()-&gt;high();
317     to_start = (char*)pointer_delta(to_end,
318                                     (char*)requested_survivor_size,
319                                     sizeof(char));
320 
321     // Does the optimal to-space overlap from-space?
322     if (to_start &lt; (char*)from_space()-&gt;end()) {
323       // Calculate the minimum offset possible for from_end
324       size_t from_size =
325         pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
326 
327       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
328       if (from_size == 0) {
<span class="line-modified">329         from_size = SpaceAlignment;</span>
330       } else {
<span class="line-modified">331         from_size = align_up(from_size, SpaceAlignment);</span>
332       }
333 
334       from_end = from_start + from_size;
335       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
336 
337       guarantee(from_end &lt;= (char*)from_space()-&gt;end(),
338         &quot;from_end moved to the right&quot;);
339 
340       // Now update to_start with the new from_end
341       to_start = MAX2(from_end, to_start);
342     }
343 
344     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
345 
346     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
347                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
348                         p2i(eden_start),
349                         p2i(eden_end),
350                         pointer_delta(eden_end, eden_start, sizeof(char)));
351     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
</pre>
<hr />
<pre>
358                         p2i(to_start),
359                         p2i(to_end),
360                         pointer_delta(  to_end,   to_start, sizeof(char)));
361   } else {
362     // Eden, to, from
363     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
364 
365     // To space gets priority over eden resizing. Note that we position
366     // to space as if we were able to resize from space, even though from
367     // space is not modified.
368     // Giving eden priority was tried and gave poorer performance.
369     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
370                                     (char*)requested_survivor_size,
371                                     sizeof(char));
372     to_end   = MIN2(to_end, from_start);
373     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
374                                     sizeof(char));
375     // if the space sizes are to be increased by several times then
376     // &#39;to_start&#39; will point beyond the young generation. In this case
377     // &#39;to_start&#39; should be adjusted.
<span class="line-modified">378     to_start = MAX2(to_start, eden_start + SpaceAlignment);</span>
379 
380     // Compute how big eden can be, then adjust end.
381     // See  comments above on calculating eden_end.
382     size_t eden_size;
383     if (maintain_minimum) {
384       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
385     } else {
386       eden_size = MIN2(requested_eden_size,
387                        pointer_delta(to_start, eden_start, sizeof(char)));
388     }
389     eden_end = eden_start + eden_size;
390     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
391 
392     // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">393     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);</span>
394     to_start = MAX2(to_start, eden_end);
395 
396     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
397                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
398                         p2i(eden_start),
399                         p2i(eden_end),
400                         pointer_delta(eden_end, eden_start, sizeof(char)));
401     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): &quot;
402                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
403                         p2i(to_start),
404                         p2i(to_end),
405                         pointer_delta(  to_end,   to_start, sizeof(char)));
406     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
407                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
408                         p2i(from_start),
409                         p2i(from_end),
410                         pointer_delta(from_end, from_start, sizeof(char)));
411   }
412 
413 
</pre>
</td>
</tr>
</table>
<center><a href="asPSOldGen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsParallel.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/psCompactionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psCompactionManager.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psCompactionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   */
  
  #ifndef SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
  #define SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
  
<span class="line-added">+ #include &quot;gc/parallel/psParallelCompact.hpp&quot;</span>
  #include &quot;gc/shared/taskqueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;utilities/stack.hpp&quot;
  
  class MutableSpace;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,89 ***</span>
  class ObjectStartArray;
  class ParallelCompactData;
  class ParMarkBitMap;
  
  class ParCompactionManager : public CHeapObj&lt;mtGC&gt; {
<span class="line-removed">-   friend class ParallelTaskTerminator;</span>
    friend class ParMarkBitMap;
    friend class PSParallelCompact;
    friend class CompactionWithStealingTask;
    friend class UpdateAndFillClosure;
    friend class RefProcTaskExecutor;
<span class="line-modified">!   friend class IdleGCTask;</span>
  
   public:
  
<span class="line-removed">- // ------------------------  Don&#39;t putback if not needed</span>
<span class="line-removed">-   // Actions that the compaction manager should take.</span>
<span class="line-removed">-   enum Action {</span>
<span class="line-removed">-     Update,</span>
<span class="line-removed">-     Copy,</span>
<span class="line-removed">-     UpdateAndCopy,</span>
<span class="line-removed">-     CopyAndUpdate,</span>
<span class="line-removed">-     NotValid</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- // ------------------------  End don&#39;t putback if not needed</span>
  
   private:
    // 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB
    #define QUEUE_SIZE (1 &lt;&lt; NOT_LP64(12) LP64_ONLY(13))
    typedef OverflowTaskQueue&lt;ObjArrayTask, mtGC, QUEUE_SIZE&gt; ObjArrayTaskQueue;
    typedef GenericTaskQueueSet&lt;ObjArrayTaskQueue, mtGC&gt;      ObjArrayTaskQueueSet;
    #undef QUEUE_SIZE
  
    static ParCompactionManager** _manager_array;
<span class="line-modified">!   static OopTaskQueueSet*       _stack_array;</span>
<span class="line-modified">!   static ObjArrayTaskQueueSet*  _objarray_queues;</span>
    static ObjectStartArray*      _start_array;
<span class="line-modified">!   static RegionTaskQueueSet*    _region_array;</span>
    static PSOldGen*              _old_gen;
  
  private:
    OverflowTaskQueue&lt;oop, mtGC&gt;        _marking_stack;
    ObjArrayTaskQueue             _objarray_stack;
  
    // Is there a way to reuse the _marking_stack for the
    // saving empty regions?  For now just create a different
    // type of TaskQueue.
    RegionTaskQueue              _region_stack;
  
    static ParMarkBitMap* _mark_bitmap;
  
<span class="line-modified">!   Action _action;</span>
  
    HeapWord* _last_query_beg;
    oop _last_query_obj;
    size_t _last_query_ret;
  
    static PSOldGen* old_gen()             { return _old_gen; }
    static ObjectStartArray* start_array() { return _start_array; }
<span class="line-modified">!   static OopTaskQueueSet* stack_array()  { return _stack_array; }</span>
  
    static void initialize(ParMarkBitMap* mbm);
  
   protected:
<span class="line-modified">!   // Array of tasks.  Needed by the ParallelTaskTerminator.</span>
<span class="line-modified">!   static RegionTaskQueueSet* region_array()      { return _region_array; }</span>
    OverflowTaskQueue&lt;oop, mtGC&gt;*  marking_stack()       { return &amp;_marking_stack; }
  
    // Pushes onto the marking stack.  If the marking stack is full,
    // pushes onto the overflow stack.
    void stack_push(oop obj);
    // Do not implement an equivalent stack_pop.  Deal with the
    // marking stack and overflow stack directly.
  
   public:
    void reset_bitmap_query_cache() {
      _last_query_beg = NULL;
      _last_query_obj = NULL;
      _last_query_ret = 0;
    }
  
<span class="line-removed">-   Action action() { return _action; }</span>
<span class="line-removed">-   void set_action(Action v) { _action = v; }</span>
<span class="line-removed">- </span>
    // Bitmap query support, cache last query and result
    HeapWord* last_query_begin() { return _last_query_beg; }
    oop last_query_object() { return _last_query_obj; }
    size_t last_query_return() { return _last_query_ret; }
  
<span class="line-new-header">--- 36,102 ---</span>
  class ObjectStartArray;
  class ParallelCompactData;
  class ParMarkBitMap;
  
  class ParCompactionManager : public CHeapObj&lt;mtGC&gt; {
    friend class ParMarkBitMap;
    friend class PSParallelCompact;
    friend class CompactionWithStealingTask;
    friend class UpdateAndFillClosure;
    friend class RefProcTaskExecutor;
<span class="line-modified">!   friend class PCRefProcTask;</span>
<span class="line-added">+   friend class MarkFromRootsTask;</span>
<span class="line-added">+   friend class UpdateDensePrefixAndCompactionTask;</span>
  
   public:
  
  
   private:
<span class="line-added">+   typedef GenericTaskQueue&lt;oop, mtGC&gt;             OopTaskQueue;</span>
<span class="line-added">+   typedef GenericTaskQueueSet&lt;OopTaskQueue, mtGC&gt; OopTaskQueueSet;</span>
<span class="line-added">+ </span>
    // 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB
    #define QUEUE_SIZE (1 &lt;&lt; NOT_LP64(12) LP64_ONLY(13))
    typedef OverflowTaskQueue&lt;ObjArrayTask, mtGC, QUEUE_SIZE&gt; ObjArrayTaskQueue;
    typedef GenericTaskQueueSet&lt;ObjArrayTaskQueue, mtGC&gt;      ObjArrayTaskQueueSet;
    #undef QUEUE_SIZE
<span class="line-added">+   typedef OverflowTaskQueue&lt;size_t, mtGC&gt;             RegionTaskQueue;</span>
<span class="line-added">+   typedef GenericTaskQueueSet&lt;RegionTaskQueue, mtGC&gt;  RegionTaskQueueSet;</span>
  
    static ParCompactionManager** _manager_array;
<span class="line-modified">!   static OopTaskQueueSet*       _oop_task_queues;</span>
<span class="line-modified">!   static ObjArrayTaskQueueSet*  _objarray_task_queues;</span>
    static ObjectStartArray*      _start_array;
<span class="line-modified">!   static RegionTaskQueueSet*    _region_task_queues;</span>
    static PSOldGen*              _old_gen;
  
  private:
    OverflowTaskQueue&lt;oop, mtGC&gt;        _marking_stack;
    ObjArrayTaskQueue             _objarray_stack;
<span class="line-added">+   size_t                        _next_shadow_region;</span>
  
    // Is there a way to reuse the _marking_stack for the
    // saving empty regions?  For now just create a different
    // type of TaskQueue.
    RegionTaskQueue              _region_stack;
  
    static ParMarkBitMap* _mark_bitmap;
  
<span class="line-modified">!   // Contains currently free shadow regions. We use it in</span>
<span class="line-added">+   // a LIFO fashion for better data locality and utilization.</span>
<span class="line-added">+   static GrowableArray&lt;size_t&gt;* _shadow_region_array;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Provides mutual exclusive access of _shadow_region_array.</span>
<span class="line-added">+   // See pop/push_shadow_region_mt_safe() below</span>
<span class="line-added">+   static Monitor*               _shadow_region_monitor;</span>
  
    HeapWord* _last_query_beg;
    oop _last_query_obj;
    size_t _last_query_ret;
  
    static PSOldGen* old_gen()             { return _old_gen; }
    static ObjectStartArray* start_array() { return _start_array; }
<span class="line-modified">!   static OopTaskQueueSet* oop_task_queues()  { return _oop_task_queues; }</span>
  
    static void initialize(ParMarkBitMap* mbm);
  
   protected:
<span class="line-modified">!   // Array of task queues.  Needed by the task terminator.</span>
<span class="line-modified">!   static RegionTaskQueueSet* region_task_queues()      { return _region_task_queues; }</span>
    OverflowTaskQueue&lt;oop, mtGC&gt;*  marking_stack()       { return &amp;_marking_stack; }
  
    // Pushes onto the marking stack.  If the marking stack is full,
    // pushes onto the overflow stack.
    void stack_push(oop obj);
    // Do not implement an equivalent stack_pop.  Deal with the
    // marking stack and overflow stack directly.
  
   public:
<span class="line-added">+   static const size_t InvalidShadow = ~0;</span>
<span class="line-added">+   static size_t  pop_shadow_region_mt_safe(PSParallelCompact::RegionData* region_ptr);</span>
<span class="line-added">+   static void    push_shadow_region_mt_safe(size_t shadow_region);</span>
<span class="line-added">+   static void    push_shadow_region(size_t shadow_region);</span>
<span class="line-added">+   static void    remove_all_shadow_regions();</span>
<span class="line-added">+ </span>
<span class="line-added">+   inline size_t  next_shadow_region() { return _next_shadow_region; }</span>
<span class="line-added">+   inline void    set_next_shadow_region(size_t record) { _next_shadow_region = record; }</span>
<span class="line-added">+   inline size_t  move_next_shadow_region_by(size_t workers) {</span>
<span class="line-added">+     _next_shadow_region += workers;</span>
<span class="line-added">+     return next_shadow_region();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    void reset_bitmap_query_cache() {
      _last_query_beg = NULL;
      _last_query_obj = NULL;
      _last_query_ret = 0;
    }
  
    // Bitmap query support, cache last query and result
    HeapWord* last_query_begin() { return _last_query_beg; }
    oop last_query_object() { return _last_query_obj; }
    size_t last_query_return() { return _last_query_ret; }
  
</pre>
<center><a href="psCompactionManager.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/parallel/psCompactionManager.hpp b/src/hotspot/share/gc/parallel/psCompactionManager.hpp
--- a/src/hotspot/share/gc/parallel/psCompactionManager.hpp
+++ b/src/hotspot/share/gc/parallel/psCompactionManager.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,10 +23,11 @@
  */
 
 #ifndef SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 #define SHARE_GC_PARALLEL_PSCOMPACTIONMANAGER_HPP
 
+#include "gc/parallel/psParallelCompact.hpp"
 #include "gc/shared/taskqueue.hpp"
 #include "memory/allocation.hpp"
 #include "utilities/stack.hpp"
 
 class MutableSpace;
@@ -35,89 +36,102 @@
 class ObjectStartArray;
 class ParallelCompactData;
 class ParMarkBitMap;
 
 class ParCompactionManager : public CHeapObj<mtGC> {
-  friend class ParallelTaskTerminator;
   friend class ParMarkBitMap;
   friend class PSParallelCompact;
   friend class CompactionWithStealingTask;
   friend class UpdateAndFillClosure;
   friend class RefProcTaskExecutor;
-  friend class IdleGCTask;
+  friend class PCRefProcTask;
+  friend class MarkFromRootsTask;
+  friend class UpdateDensePrefixAndCompactionTask;
 
  public:
 
-// ------------------------  Don't putback if not needed
-  // Actions that the compaction manager should take.
-  enum Action {
-    Update,
-    Copy,
-    UpdateAndCopy,
-    CopyAndUpdate,
-    NotValid
-  };
-// ------------------------  End don't putback if not needed
 
  private:
+  typedef GenericTaskQueue<oop, mtGC>             OopTaskQueue;
+  typedef GenericTaskQueueSet<OopTaskQueue, mtGC> OopTaskQueueSet;
+
   // 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB
   #define QUEUE_SIZE (1 << NOT_LP64(12) LP64_ONLY(13))
   typedef OverflowTaskQueue<ObjArrayTask, mtGC, QUEUE_SIZE> ObjArrayTaskQueue;
   typedef GenericTaskQueueSet<ObjArrayTaskQueue, mtGC>      ObjArrayTaskQueueSet;
   #undef QUEUE_SIZE
+  typedef OverflowTaskQueue<size_t, mtGC>             RegionTaskQueue;
+  typedef GenericTaskQueueSet<RegionTaskQueue, mtGC>  RegionTaskQueueSet;
 
   static ParCompactionManager** _manager_array;
-  static OopTaskQueueSet*       _stack_array;
-  static ObjArrayTaskQueueSet*  _objarray_queues;
+  static OopTaskQueueSet*       _oop_task_queues;
+  static ObjArrayTaskQueueSet*  _objarray_task_queues;
   static ObjectStartArray*      _start_array;
-  static RegionTaskQueueSet*    _region_array;
+  static RegionTaskQueueSet*    _region_task_queues;
   static PSOldGen*              _old_gen;
 
 private:
   OverflowTaskQueue<oop, mtGC>        _marking_stack;
   ObjArrayTaskQueue             _objarray_stack;
+  size_t                        _next_shadow_region;
 
   // Is there a way to reuse the _marking_stack for the
   // saving empty regions?  For now just create a different
   // type of TaskQueue.
   RegionTaskQueue              _region_stack;
 
   static ParMarkBitMap* _mark_bitmap;
 
-  Action _action;
+  // Contains currently free shadow regions. We use it in
+  // a LIFO fashion for better data locality and utilization.
+  static GrowableArray<size_t>* _shadow_region_array;
+
+  // Provides mutual exclusive access of _shadow_region_array.
+  // See pop/push_shadow_region_mt_safe() below
+  static Monitor*               _shadow_region_monitor;
 
   HeapWord* _last_query_beg;
   oop _last_query_obj;
   size_t _last_query_ret;
 
   static PSOldGen* old_gen()             { return _old_gen; }
   static ObjectStartArray* start_array() { return _start_array; }
-  static OopTaskQueueSet* stack_array()  { return _stack_array; }
+  static OopTaskQueueSet* oop_task_queues()  { return _oop_task_queues; }
 
   static void initialize(ParMarkBitMap* mbm);
 
  protected:
-  // Array of tasks.  Needed by the ParallelTaskTerminator.
-  static RegionTaskQueueSet* region_array()      { return _region_array; }
+  // Array of task queues.  Needed by the task terminator.
+  static RegionTaskQueueSet* region_task_queues()      { return _region_task_queues; }
   OverflowTaskQueue<oop, mtGC>*  marking_stack()       { return &_marking_stack; }
 
   // Pushes onto the marking stack.  If the marking stack is full,
   // pushes onto the overflow stack.
   void stack_push(oop obj);
   // Do not implement an equivalent stack_pop.  Deal with the
   // marking stack and overflow stack directly.
 
  public:
+  static const size_t InvalidShadow = ~0;
+  static size_t  pop_shadow_region_mt_safe(PSParallelCompact::RegionData* region_ptr);
+  static void    push_shadow_region_mt_safe(size_t shadow_region);
+  static void    push_shadow_region(size_t shadow_region);
+  static void    remove_all_shadow_regions();
+
+  inline size_t  next_shadow_region() { return _next_shadow_region; }
+  inline void    set_next_shadow_region(size_t record) { _next_shadow_region = record; }
+  inline size_t  move_next_shadow_region_by(size_t workers) {
+    _next_shadow_region += workers;
+    return next_shadow_region();
+  }
+
   void reset_bitmap_query_cache() {
     _last_query_beg = NULL;
     _last_query_obj = NULL;
     _last_query_ret = 0;
   }
 
-  Action action() { return _action; }
-  void set_action(Action v) { _action = v; }
-
   // Bitmap query support, cache last query and result
   HeapWord* last_query_begin() { return _last_query_beg; }
   oop last_query_object() { return _last_query_obj; }
   size_t last_query_return() { return _last_query_ret; }
 

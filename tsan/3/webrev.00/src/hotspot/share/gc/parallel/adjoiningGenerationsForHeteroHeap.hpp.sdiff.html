<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="adjoiningGenerationsForHeteroHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSOldGen.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/adjoiningGenerationsForHeteroHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
39   }
40 
41   // HeteroVirtualSpaces creates non-overlapping virtual spaces. Here _low and _high do not share a reserved space, i.e. there is no boundary
42   // separating the two virtual spaces.
43   class HeteroVirtualSpaces : public AdjoiningVirtualSpaces {
44     size_t _max_total_size;
45     size_t _min_old_byte_size;
46     size_t _min_young_byte_size;
47     size_t _max_old_byte_size;
48     size_t _max_young_byte_size;
49 
50     // Internally we access the virtual spaces using these methods. It increases readability, since we were not really
51     // dealing with adjoining virtual spaces separated by a boundary as is the case in base class.
52     // Externally they are accessed using low() and high() methods of base class.
53     PSVirtualSpace* young_vs() { return high(); }
54     PSVirtualSpace* old_vs() { return low(); }
55 
56   public:
57     HeteroVirtualSpaces(ReservedSpace rs,
58                         size_t min_old_byte_size,
<span class="line-modified">59                         size_t min_young_byte_size, size_t max_total_size,</span>
<span class="line-modified">60                         size_t alignment);</span>
61 
62     // Increase old generation size and decrease young generation size by same amount
63     bool adjust_boundary_up(size_t size_in_bytes);
64     // Increase young generation size and decrease old generation size by same amount
65     bool adjust_boundary_down(size_t size_in_bytes);
66 
67     size_t max_young_size() const { return _max_young_byte_size; }
68     size_t max_old_size() const { return _max_old_byte_size; }
69 
70     void initialize(size_t initial_old_reserved_size, size_t init_low_byte_size,
71                     size_t init_high_byte_size);
72   };
73 
74 public:
<span class="line-modified">75   AdjoiningGenerationsForHeteroHeap(ReservedSpace rs, GenerationSizer* policy, size_t alignment);</span>
76 
77   // Given the size policy, calculate the total amount of memory that needs to be reserved.
78   // We need to reserve more memory than Xmx, since we use non-overlapping virtual spaces for the young and old generations.
<span class="line-modified">79   static size_t required_reserved_memory(GenerationSizer* policy);</span>
80 
81   // Return the total byte size of the reserved space
82   size_t reserved_byte_size();
83 };
84 #endif // SHARE_GC_PARALLEL_ADJOININGGENERATIONSFORHETEROHEAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
39   }
40 
41   // HeteroVirtualSpaces creates non-overlapping virtual spaces. Here _low and _high do not share a reserved space, i.e. there is no boundary
42   // separating the two virtual spaces.
43   class HeteroVirtualSpaces : public AdjoiningVirtualSpaces {
44     size_t _max_total_size;
45     size_t _min_old_byte_size;
46     size_t _min_young_byte_size;
47     size_t _max_old_byte_size;
48     size_t _max_young_byte_size;
49 
50     // Internally we access the virtual spaces using these methods. It increases readability, since we were not really
51     // dealing with adjoining virtual spaces separated by a boundary as is the case in base class.
52     // Externally they are accessed using low() and high() methods of base class.
53     PSVirtualSpace* young_vs() { return high(); }
54     PSVirtualSpace* old_vs() { return low(); }
55 
56   public:
57     HeteroVirtualSpaces(ReservedSpace rs,
58                         size_t min_old_byte_size,
<span class="line-modified">59                         size_t min_young_byte_size,</span>
<span class="line-modified">60                         size_t max_total_size);</span>
61 
62     // Increase old generation size and decrease young generation size by same amount
63     bool adjust_boundary_up(size_t size_in_bytes);
64     // Increase young generation size and decrease old generation size by same amount
65     bool adjust_boundary_down(size_t size_in_bytes);
66 
67     size_t max_young_size() const { return _max_young_byte_size; }
68     size_t max_old_size() const { return _max_old_byte_size; }
69 
70     void initialize(size_t initial_old_reserved_size, size_t init_low_byte_size,
71                     size_t init_high_byte_size);
72   };
73 
74 public:
<span class="line-modified">75   AdjoiningGenerationsForHeteroHeap(ReservedSpace rs);</span>
76 
77   // Given the size policy, calculate the total amount of memory that needs to be reserved.
78   // We need to reserve more memory than Xmx, since we use non-overlapping virtual spaces for the young and old generations.
<span class="line-modified">79   static size_t required_reserved_memory();</span>
80 
81   // Return the total byte size of the reserved space
82   size_t reserved_byte_size();
83 };
84 #endif // SHARE_GC_PARALLEL_ADJOININGGENERATIONSFORHETEROHEAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="adjoiningGenerationsForHeteroHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSOldGen.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
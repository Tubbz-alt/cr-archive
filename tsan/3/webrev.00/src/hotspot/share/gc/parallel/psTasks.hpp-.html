<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/psTasks.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSTASKS_HPP
 26 #define SHARE_GC_PARALLEL_PSTASKS_HPP
 27 
 28 #include &quot;utilities/growableArray.hpp&quot;
 29 
 30 //
 31 // psTasks.hpp is a collection of GCTasks used by the
 32 // parallelScavenge collector.
 33 //
 34 
 35 class GCTask;
 36 class OopClosure;
 37 class OopStack;
 38 class ObjectStartArray;
 39 class ParallelTaskTerminator;
 40 class MutableSpace;
 41 class PSOldGen;
 42 class Thread;
 43 class VMThread;
 44 
 45 //
 46 // ScavengeRootsTask
 47 //
 48 // This task scans all the roots of a given type.
 49 //
 50 //
 51 
 52 class ScavengeRootsTask : public GCTask {
 53  public:
 54   enum RootType {
 55     universe              = 1,
 56     jni_handles           = 2,
 57     threads               = 3,
 58     object_synchronizer   = 4,
 59     system_dictionary     = 5,
 60     class_loader_data     = 6,
 61     management            = 7,
 62     jvmti                 = 8,
 63     code_cache            = 9
 64   };
 65  private:
 66   RootType _root_type;
 67  public:
 68   ScavengeRootsTask(RootType value) : _root_type(value) {}
 69 
 70   char* name() { return (char *)&quot;scavenge-roots-task&quot;; }
 71 
 72   virtual void do_it(GCTaskManager* manager, uint which);
 73 };
 74 
 75 //
 76 // ThreadRootsTask
 77 //
 78 // This task scans the roots of a single thread. This task
 79 // enables scanning of thread roots in parallel.
 80 //
 81 
 82 class ThreadRootsTask : public GCTask {
 83  private:
 84   Thread* _thread;
 85 
 86  public:
 87   ThreadRootsTask(Thread* root) : _thread(root) {}
 88 
 89   char* name() { return (char *)&quot;thread-roots-task&quot;; }
 90 
 91   virtual void do_it(GCTaskManager* manager, uint which);
 92 };
 93 
 94 //
 95 // StealTask
 96 //
 97 // This task is used to distribute work to idle threads.
 98 //
 99 
100 class StealTask : public GCTask {
101  private:
102    ParallelTaskTerminator* const _terminator;
103  public:
104   char* name() { return (char *)&quot;steal-task&quot;; }
105 
106   StealTask(ParallelTaskTerminator* t);
107 
108   ParallelTaskTerminator* terminator() { return _terminator; }
109 
110   virtual void do_it(GCTaskManager* manager, uint which);
111 };
112 
113 //
114 // OldToYoungRootsTask
115 //
116 // This task is used to scan old to young roots in parallel
117 //
118 // A GC thread executing this tasks divides the generation (old gen)
119 // into slices and takes a stripe in the slice as its part of the
120 // work.
121 //
122 //      +===============+        slice 0
123 //      |  stripe 0     |
124 //      +---------------+
125 //      |  stripe 1     |
126 //      +---------------+
127 //      |  stripe 2     |
128 //      +---------------+
129 //      |  stripe 3     |
130 //      +===============+        slice 1
131 //      |  stripe 0     |
132 //      +---------------+
133 //      |  stripe 1     |
134 //      +---------------+
135 //      |  stripe 2     |
136 //      +---------------+
137 //      |  stripe 3     |
138 //      +===============+        slice 2
139 //      ...
140 //
141 // A task is created for each stripe.  In this case there are 4 tasks
142 // created.  A GC thread first works on its stripe within slice 0
143 // and then moves to its stripe in the next slice until all stripes
144 // exceed the top of the generation.  Note that having fewer GC threads
145 // than stripes works because all the tasks are executed so all stripes
146 // will be covered.  In this example if 4 tasks have been created to cover
147 // all the stripes and there are only 3 threads, one of the threads will
148 // get the tasks with the 4th stripe.  However, there is a dependence in
149 // PSCardTable::scavenge_contents_parallel() on the number
150 // of tasks created.  In scavenge_contents_parallel the distance
151 // to the next stripe is calculated based on the number of tasks.
152 // If the stripe width is ssize, a task&#39;s next stripe is at
153 // ssize * number_of_tasks (= slice_stride).  In this case after
154 // finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1
155 // by adding slice_stride to the start of stripe 0 in slice 0 to get
156 // to the start of stride 0 in slice 1.
157 
158 class OldToYoungRootsTask : public GCTask {
159  private:
160   PSOldGen* _old_gen;
161   HeapWord* _gen_top;
162   uint _stripe_number;
163   uint _stripe_total;
164 
165  public:
166   OldToYoungRootsTask(PSOldGen *old_gen,
167                       HeapWord* gen_top,
168                       uint stripe_number,
169                       uint stripe_total) :
170     _old_gen(old_gen),
171     _gen_top(gen_top),
172     _stripe_number(stripe_number),
173     _stripe_total(stripe_total) { }
174 
175   char* name() { return (char *)&quot;old-to-young-roots-task&quot;; }
176 
177   virtual void do_it(GCTaskManager* manager, uint which);
178 };
179 
180 #endif // SHARE_GC_PARALLEL_PSTASKS_HPP
    </pre>
  </body>
</html>
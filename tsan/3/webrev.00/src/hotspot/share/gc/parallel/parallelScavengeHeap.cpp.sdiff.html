<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelArguments.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 29 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
<span class="line-modified"> 30 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
<span class="line-removed"> 31 #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
 32 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
 33 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 34 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
<span class="line-removed"> 35 #include &quot;gc/parallel/psMarkSweepProxy.hpp&quot;</span>
 36 #include &quot;gc/parallel/psMemoryPool.hpp&quot;
 37 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 38 #include &quot;gc/parallel/psPromotionManager.hpp&quot;
 39 #include &quot;gc/parallel/psScavenge.hpp&quot;
 40 #include &quot;gc/parallel/psVMOperations.hpp&quot;
 41 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 42 #include &quot;gc/shared/gcLocker.hpp&quot;
 43 #include &quot;gc/shared/gcWhen.hpp&quot;


 44 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 45 #include &quot;logging/log.hpp&quot;

 46 #include &quot;memory/metaspaceCounters.hpp&quot;

 47 #include &quot;oops/oop.inline.hpp&quot;
 48 #include &quot;runtime/handles.inline.hpp&quot;
 49 #include &quot;runtime/java.hpp&quot;
 50 #include &quot;runtime/vmThread.hpp&quot;
 51 #include &quot;services/memoryManager.hpp&quot;
 52 #include &quot;services/memTracker.hpp&quot;
 53 #include &quot;utilities/macros.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 PSYoungGen*  ParallelScavengeHeap::_young_gen = NULL;
 57 PSOldGen*    ParallelScavengeHeap::_old_gen = NULL;
 58 PSAdaptiveSizePolicy* ParallelScavengeHeap::_size_policy = NULL;
 59 PSGCAdaptivePolicyCounters* ParallelScavengeHeap::_gc_policy_counters = NULL;
<span class="line-removed"> 60 GCTaskManager* ParallelScavengeHeap::_gc_task_manager = NULL;</span>
 61 
 62 jint ParallelScavengeHeap::initialize() {
<span class="line-modified"> 63   size_t heap_size = _collector_policy-&gt;heap_reserved_size_bytes();</span>
 64 
<span class="line-modified"> 65   ReservedSpace heap_rs = Universe::reserve_heap(heap_size, _collector_policy-&gt;heap_alignment());</span>
 66 
 67   os::trace_page_sizes(&quot;Heap&quot;,
<span class="line-modified"> 68                        _collector_policy-&gt;min_heap_byte_size(),</span>
<span class="line-modified"> 69                        heap_size,</span>
<span class="line-modified"> 70                        generation_alignment(),</span>
 71                        heap_rs.base(),
 72                        heap_rs.size());
 73 
<span class="line-modified"> 74   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size()));</span>
 75 
<span class="line-modified"> 76   PSCardTable* card_table = new PSCardTable(reserved_region());</span>
 77   card_table-&gt;initialize();
 78   CardTableBarrierSet* const barrier_set = new CardTableBarrierSet(card_table);
 79   barrier_set-&gt;initialize();
 80   BarrierSet::set_barrier_set(barrier_set);
 81 
 82   // Make up the generations
 83   // Calculate the maximum size that a generation can grow.  This
 84   // includes growth into the other generation.  Note that the
 85   // parameter _max_gen_size is kept as the maximum
 86   // size of the generation as the boundaries currently stand.
 87   // _max_gen_size is still used as that value.
 88   double max_gc_pause_sec = ((double) MaxGCPauseMillis)/1000.0;
 89   double max_gc_minor_pause_sec = ((double) MaxGCMinorPauseMillis)/1000.0;
 90 
<span class="line-modified"> 91   _gens = AdjoiningGenerations::create_adjoining_generations(heap_rs, _collector_policy, generation_alignment());</span>
 92 
 93   _old_gen = _gens-&gt;old_gen();
 94   _young_gen = _gens-&gt;young_gen();
 95 
 96   const size_t eden_capacity = _young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
 97   const size_t old_capacity = _old_gen-&gt;capacity_in_bytes();
 98   const size_t initial_promo_size = MIN2(eden_capacity, old_capacity);
 99   _size_policy =
100     new PSAdaptiveSizePolicy(eden_capacity,
101                              initial_promo_size,
102                              young_gen()-&gt;to_space()-&gt;capacity_in_bytes(),
<span class="line-modified">103                              _collector_policy-&gt;gen_alignment(),</span>
104                              max_gc_pause_sec,
105                              max_gc_minor_pause_sec,
106                              GCTimeRatio
107                              );
108 
<span class="line-modified">109   assert(_collector_policy-&gt;is_hetero_heap() || !UseAdaptiveGCBoundary ||</span>
110     (old_gen()-&gt;virtual_space()-&gt;high_boundary() ==
111      young_gen()-&gt;virtual_space()-&gt;low_boundary()),
112     &quot;Boundaries must meet&quot;);
113   // initialize the policy counters - 2 collectors, 2 generations
114   _gc_policy_counters =
115     new PSGCAdaptivePolicyCounters(&quot;ParScav:MSC&quot;, 2, 2, _size_policy);
116 
<span class="line-modified">117   // Set up the GCTaskManager</span>
<span class="line-removed">118   _gc_task_manager = GCTaskManager::create(ParallelGCThreads);</span>
<span class="line-removed">119 </span>
<span class="line-removed">120   if (UseParallelOldGC &amp;&amp; !PSParallelCompact::initialize()) {</span>
121     return JNI_ENOMEM;
122   }
123 



124   return JNI_OK;
125 }
126 
127 void ParallelScavengeHeap::initialize_serviceability() {
128 
129   _eden_pool = new EdenMutableSpacePool(_young_gen,
130                                         _young_gen-&gt;eden_space(),
131                                         &quot;PS Eden Space&quot;,
132                                         false /* support_usage_threshold */);
133 
134   _survivor_pool = new SurvivorMutableSpacePool(_young_gen,
135                                                 &quot;PS Survivor Space&quot;,
136                                                 false /* support_usage_threshold */);
137 
138   _old_pool = new PSGenerationPool(_old_gen,
139                                    &quot;PS Old Gen&quot;,
140                                    true /* support_usage_threshold */);
141 
142   _young_manager = new GCMemoryManager(&quot;PS Scavenge&quot;, &quot;end of minor GC&quot;);
143   _old_manager = new GCMemoryManager(&quot;PS MarkSweep&quot;, &quot;end of major GC&quot;);
</pre>
<hr />
<pre>
146   _old_manager-&gt;add_pool(_survivor_pool);
147   _old_manager-&gt;add_pool(_old_pool);
148 
149   _young_manager-&gt;add_pool(_eden_pool);
150   _young_manager-&gt;add_pool(_survivor_pool);
151 
152 }
153 
154 class PSIsScavengable : public BoolObjectClosure {
155   bool do_object_b(oop obj) {
156     return ParallelScavengeHeap::heap()-&gt;is_in_young(obj);
157   }
158 };
159 
160 static PSIsScavengable _is_scavengable;
161 
162 void ParallelScavengeHeap::post_initialize() {
163   CollectedHeap::post_initialize();
164   // Need to init the tenuring threshold
165   PSScavenge::initialize();
<span class="line-modified">166   if (UseParallelOldGC) {</span>
<span class="line-removed">167     PSParallelCompact::post_initialize();</span>
<span class="line-removed">168   } else {</span>
<span class="line-removed">169     PSMarkSweepProxy::initialize();</span>
<span class="line-removed">170   }</span>
171   PSPromotionManager::initialize();
172 
173   ScavengableNMethods::initialize(&amp;_is_scavengable);
174 }
175 
176 void ParallelScavengeHeap::update_counters() {
177   young_gen()-&gt;update_counters();
178   old_gen()-&gt;update_counters();
179   MetaspaceCounters::update_performance_counters();
180   CompressedClassSpaceCounters::update_performance_counters();
181 }
182 
183 size_t ParallelScavengeHeap::capacity() const {
184   size_t value = young_gen()-&gt;capacity_in_bytes() + old_gen()-&gt;capacity_in_bytes();
185   return value;
186 }
187 
188 size_t ParallelScavengeHeap::used() const {
189   size_t value = young_gen()-&gt;used_in_bytes() + old_gen()-&gt;used_in_bytes();
190   return value;
</pre>
<hr />
<pre>
395 HeapWord* ParallelScavengeHeap::mem_allocate_old_gen(size_t size) {
396   if (!should_alloc_in_eden(size) || GCLocker::is_active_and_needs_gc()) {
397     // Size is too big for eden, or gc is locked out.
398     return old_gen()-&gt;allocate(size);
399   }
400 
401   // If a &quot;death march&quot; is in progress, allocate from the old gen a limited
402   // number of times before doing a GC.
403   if (_death_march_count &gt; 0) {
404     if (_death_march_count &lt; 64) {
405       ++_death_march_count;
406       return old_gen()-&gt;allocate(size);
407     } else {
408       _death_march_count = 0;
409     }
410   }
411   return NULL;
412 }
413 
414 void ParallelScavengeHeap::do_full_collection(bool clear_all_soft_refs) {
<span class="line-modified">415   if (UseParallelOldGC) {</span>
<span class="line-modified">416     // The do_full_collection() parameter clear_all_soft_refs</span>
<span class="line-modified">417     // is interpreted here as maximum_compaction which will</span>
<span class="line-modified">418     // cause SoftRefs to be cleared.</span>
<span class="line-modified">419     bool maximum_compaction = clear_all_soft_refs;</span>
<span class="line-removed">420     PSParallelCompact::invoke(maximum_compaction);</span>
<span class="line-removed">421   } else {</span>
<span class="line-removed">422     PSMarkSweepProxy::invoke(clear_all_soft_refs);</span>
<span class="line-removed">423   }</span>
424 }
425 
426 // Failed allocation policy. Must be called from the VM thread, and
427 // only at a safepoint! Note that this method has policy for allocation
428 // flow, and NOT collection policy. So we do not check for gc collection
429 // time over limit here, that is the responsibility of the heap specific
430 // collection methods. This method decides where to attempt allocations,
431 // and when to attempt collections, but no collection specific policy.
432 HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size) {
433   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
434   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
435   assert(!is_gc_active(), &quot;not reentrant&quot;);
436   assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);
437 
438   // We assume that allocation in eden will fail unless we collect.
439 
440   // First level allocation failure, scavenge and allocate in young gen.
441   GCCauseSetter gccs(this, GCCause::_allocation_failure);
442   const bool invoked_full_gc = PSScavenge::invoke();
443   HeapWord* result = young_gen()-&gt;allocate(size);
</pre>
<hr />
<pre>
501 }
502 
503 void ParallelScavengeHeap::resize_all_tlabs() {
504   CollectedHeap::resize_all_tlabs();
505 }
506 
507 // This method is used by System.gc() and JVMTI.
508 void ParallelScavengeHeap::collect(GCCause::Cause cause) {
509   assert(!Heap_lock-&gt;owned_by_self(),
510     &quot;this thread should not own the Heap_lock&quot;);
511 
512   uint gc_count      = 0;
513   uint full_gc_count = 0;
514   {
515     MutexLocker ml(Heap_lock);
516     // This value is guarded by the Heap_lock
517     gc_count      = total_collections();
518     full_gc_count = total_full_collections();
519   }
520 




521   VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);
522   VMThread::execute(&amp;op);
523 }
524 
525 void ParallelScavengeHeap::object_iterate(ObjectClosure* cl) {
526   young_gen()-&gt;object_iterate(cl);
527   old_gen()-&gt;object_iterate(cl);
528 }
529 
530 
531 HeapWord* ParallelScavengeHeap::block_start(const void* addr) const {
532   if (young_gen()-&gt;is_in_reserved(addr)) {
533     assert(young_gen()-&gt;is_in(addr),
534            &quot;addr should be in allocated part of young gen&quot;);
535     // called from os::print_location by find or VMError
536     if (Debugging || VMError::fatal_error_in_progress())  return NULL;
537     Unimplemented();
538   } else if (old_gen()-&gt;is_in_reserved(addr)) {
539     assert(old_gen()-&gt;is_in(addr),
540            &quot;addr should be in allocated part of old gen&quot;);
541     return old_gen()-&gt;start_array()-&gt;object_start((HeapWord*)addr);
542   }
543   return 0;
544 }
545 
546 bool ParallelScavengeHeap::block_is_obj(const HeapWord* addr) const {
547   return block_start(addr) == addr;
548 }
549 
550 jlong ParallelScavengeHeap::millis_since_last_gc() {
<span class="line-modified">551   return UseParallelOldGC ?</span>
<span class="line-removed">552     PSParallelCompact::millis_since_last_gc() :</span>
<span class="line-removed">553     PSMarkSweepProxy::millis_since_last_gc();</span>
554 }
555 
556 void ParallelScavengeHeap::prepare_for_verify() {
557   ensure_parsability(false);  // no need to retire TLABs for verification
558 }
559 
560 PSHeapSummary ParallelScavengeHeap::create_ps_heap_summary() {
561   PSOldGen* old = old_gen();
562   HeapWord* old_committed_end = (HeapWord*)old-&gt;virtual_space()-&gt;committed_high_addr();
563   VirtualSpaceSummary old_summary(old-&gt;reserved().start(), old_committed_end, old-&gt;reserved().end());
564   SpaceSummary old_space(old-&gt;reserved().start(), old_committed_end, old-&gt;used_in_bytes());
565 
566   PSYoungGen* young = young_gen();
567   VirtualSpaceSummary young_summary(young-&gt;reserved().start(),
568     (HeapWord*)young-&gt;virtual_space()-&gt;committed_high_addr(), young-&gt;reserved().end());
569 
570   MutableSpace* eden = young_gen()-&gt;eden_space();
571   SpaceSummary eden_space(eden-&gt;bottom(), eden-&gt;end(), eden-&gt;used_in_bytes());
572 
573   MutableSpace* from = young_gen()-&gt;from_space();
574   SpaceSummary from_space(from-&gt;bottom(), from-&gt;end(), from-&gt;used_in_bytes());
575 
576   MutableSpace* to = young_gen()-&gt;to_space();
577   SpaceSummary to_space(to-&gt;bottom(), to-&gt;end(), to-&gt;used_in_bytes());
578 
579   VirtualSpaceSummary heap_summary = create_heap_space_summary();
580   return PSHeapSummary(heap_summary, used(), old_summary, old_space, young_summary, eden_space, from_space, to_space);
581 }
582 




583 void ParallelScavengeHeap::print_on(outputStream* st) const {
584   young_gen()-&gt;print_on(st);
585   old_gen()-&gt;print_on(st);
586   MetaspaceUtils::print_on(st);
587 }
588 
589 void ParallelScavengeHeap::print_on_error(outputStream* st) const {
590   this-&gt;CollectedHeap::print_on_error(st);
591 
<span class="line-modified">592   if (UseParallelOldGC) {</span>
<span class="line-modified">593     st-&gt;cr();</span>
<span class="line-removed">594     PSParallelCompact::print_on_error(st);</span>
<span class="line-removed">595   }</span>
596 }
597 
598 void ParallelScavengeHeap::gc_threads_do(ThreadClosure* tc) const {
<span class="line-modified">599   PSScavenge::gc_task_manager()-&gt;threads_do(tc);</span>
600 }
601 
602 void ParallelScavengeHeap::print_gc_threads_on(outputStream* st) const {
<span class="line-modified">603   PSScavenge::gc_task_manager()-&gt;print_threads_on(st);</span>
604 }
605 
606 void ParallelScavengeHeap::print_tracing_info() const {
607   AdaptiveSizePolicyOutput::print();
608   log_debug(gc, heap, exit)(&quot;Accumulated young generation GC time %3.7f secs&quot;, PSScavenge::accumulated_time()-&gt;seconds());
<span class="line-modified">609   log_debug(gc, heap, exit)(&quot;Accumulated old generation GC time %3.7f secs&quot;,</span>
<span class="line-modified">610       UseParallelOldGC ? PSParallelCompact::accumulated_time()-&gt;seconds() : PSMarkSweepProxy::accumulated_time()-&gt;seconds());</span>
















































611 }
612 
<span class="line-removed">613 </span>
614 void ParallelScavengeHeap::verify(VerifyOption option /* ignored */) {
615   // Why do we need the total_collections()-filter below?
616   if (total_collections() &gt; 0) {
617     log_debug(gc, verify)(&quot;Tenured&quot;);
618     old_gen()-&gt;verify();
619 
620     log_debug(gc, verify)(&quot;Eden&quot;);
621     young_gen()-&gt;verify();
622   }
623 }
624 
625 void ParallelScavengeHeap::trace_heap(GCWhen::Type when, const GCTracer* gc_tracer) {
626   const PSHeapSummary&amp; heap_summary = create_ps_heap_summary();
627   gc_tracer-&gt;report_gc_heap_summary(when, heap_summary);
628 
629   const MetaspaceSummary&amp; metaspace_summary = create_metaspace_summary();
630   gc_tracer-&gt;report_metaspace_summary(when, metaspace_summary);
631 }
632 
633 ParallelScavengeHeap* ParallelScavengeHeap::heap() {
</pre>
<hr />
<pre>
700     young_gen()-&gt;to_space()-&gt;mangle_unused_area();
701     young_gen()-&gt;from_space()-&gt;mangle_unused_area();
702     old_gen()-&gt;object_space()-&gt;mangle_unused_area();
703   }
704 }
705 #endif
706 
707 void ParallelScavengeHeap::register_nmethod(nmethod* nm) {
708   ScavengableNMethods::register_nmethod(nm);
709 }
710 
711 void ParallelScavengeHeap::unregister_nmethod(nmethod* nm) {
712   ScavengableNMethods::unregister_nmethod(nm);
713 }
714 
715 void ParallelScavengeHeap::verify_nmethod(nmethod* nm) {
716   ScavengableNMethods::verify_nmethod(nm);
717 }
718 
719 void ParallelScavengeHeap::flush_nmethod(nmethod* nm) {
<span class="line-modified">720   ScavengableNMethods::flush_nmethod(nm);</span>
721 }
722 
<span class="line-modified">723 void ParallelScavengeHeap::prune_nmethods() {</span>
724   ScavengableNMethods::prune_nmethods();
725 }
726 
727 GrowableArray&lt;GCMemoryManager*&gt; ParallelScavengeHeap::memory_managers() {
728   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
729   memory_managers.append(_young_manager);
730   memory_managers.append(_old_manager);
731   return memory_managers;
732 }
733 
734 GrowableArray&lt;MemoryPool*&gt; ParallelScavengeHeap::memory_pools() {
735   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
736   memory_pools.append(_eden_pool);
737   memory_pools.append(_survivor_pool);
738   memory_pools.append(_old_pool);
739   return memory_pools;
740 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 29 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
<span class="line-modified"> 30 #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>

 31 #include &quot;gc/parallel/objectStartArray.inline.hpp&quot;
 32 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
 33 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;

 34 #include &quot;gc/parallel/psMemoryPool.hpp&quot;
 35 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 36 #include &quot;gc/parallel/psPromotionManager.hpp&quot;
 37 #include &quot;gc/parallel/psScavenge.hpp&quot;
 38 #include &quot;gc/parallel/psVMOperations.hpp&quot;
 39 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 40 #include &quot;gc/shared/gcLocker.hpp&quot;
 41 #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="line-added"> 42 #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="line-added"> 43 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
 44 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 45 #include &quot;logging/log.hpp&quot;
<span class="line-added"> 46 #include &quot;memory/iterator.hpp&quot;</span>
 47 #include &quot;memory/metaspaceCounters.hpp&quot;
<span class="line-added"> 48 #include &quot;memory/universe.hpp&quot;</span>
 49 #include &quot;oops/oop.inline.hpp&quot;
 50 #include &quot;runtime/handles.inline.hpp&quot;
 51 #include &quot;runtime/java.hpp&quot;
 52 #include &quot;runtime/vmThread.hpp&quot;
 53 #include &quot;services/memoryManager.hpp&quot;
 54 #include &quot;services/memTracker.hpp&quot;
 55 #include &quot;utilities/macros.hpp&quot;
 56 #include &quot;utilities/vmError.hpp&quot;
 57 
 58 PSYoungGen*  ParallelScavengeHeap::_young_gen = NULL;
 59 PSOldGen*    ParallelScavengeHeap::_old_gen = NULL;
 60 PSAdaptiveSizePolicy* ParallelScavengeHeap::_size_policy = NULL;
 61 PSGCAdaptivePolicyCounters* ParallelScavengeHeap::_gc_policy_counters = NULL;

 62 
 63 jint ParallelScavengeHeap::initialize() {
<span class="line-modified"> 64   const size_t reserved_heap_size = ParallelArguments::heap_reserved_size_bytes();</span>
 65 
<span class="line-modified"> 66   ReservedHeapSpace heap_rs = Universe::reserve_heap(reserved_heap_size, HeapAlignment);</span>
 67 
 68   os::trace_page_sizes(&quot;Heap&quot;,
<span class="line-modified"> 69                        MinHeapSize,</span>
<span class="line-modified"> 70                        reserved_heap_size,</span>
<span class="line-modified"> 71                        GenAlignment,</span>
 72                        heap_rs.base(),
 73                        heap_rs.size());
 74 
<span class="line-modified"> 75   initialize_reserved_region(heap_rs);</span>
 76 
<span class="line-modified"> 77   PSCardTable* card_table = new PSCardTable(heap_rs.region());</span>
 78   card_table-&gt;initialize();
 79   CardTableBarrierSet* const barrier_set = new CardTableBarrierSet(card_table);
 80   barrier_set-&gt;initialize();
 81   BarrierSet::set_barrier_set(barrier_set);
 82 
 83   // Make up the generations
 84   // Calculate the maximum size that a generation can grow.  This
 85   // includes growth into the other generation.  Note that the
 86   // parameter _max_gen_size is kept as the maximum
 87   // size of the generation as the boundaries currently stand.
 88   // _max_gen_size is still used as that value.
 89   double max_gc_pause_sec = ((double) MaxGCPauseMillis)/1000.0;
 90   double max_gc_minor_pause_sec = ((double) MaxGCMinorPauseMillis)/1000.0;
 91 
<span class="line-modified"> 92   _gens = AdjoiningGenerations::create_adjoining_generations(heap_rs);</span>
 93 
 94   _old_gen = _gens-&gt;old_gen();
 95   _young_gen = _gens-&gt;young_gen();
 96 
 97   const size_t eden_capacity = _young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
 98   const size_t old_capacity = _old_gen-&gt;capacity_in_bytes();
 99   const size_t initial_promo_size = MIN2(eden_capacity, old_capacity);
100   _size_policy =
101     new PSAdaptiveSizePolicy(eden_capacity,
102                              initial_promo_size,
103                              young_gen()-&gt;to_space()-&gt;capacity_in_bytes(),
<span class="line-modified">104                              GenAlignment,</span>
105                              max_gc_pause_sec,
106                              max_gc_minor_pause_sec,
107                              GCTimeRatio
108                              );
109 
<span class="line-modified">110   assert(ParallelArguments::is_heterogeneous_heap() || !UseAdaptiveGCBoundary ||</span>
111     (old_gen()-&gt;virtual_space()-&gt;high_boundary() ==
112      young_gen()-&gt;virtual_space()-&gt;low_boundary()),
113     &quot;Boundaries must meet&quot;);
114   // initialize the policy counters - 2 collectors, 2 generations
115   _gc_policy_counters =
116     new PSGCAdaptivePolicyCounters(&quot;ParScav:MSC&quot;, 2, 2, _size_policy);
117 
<span class="line-modified">118   if (!PSParallelCompact::initialize()) {</span>



119     return JNI_ENOMEM;
120   }
121 
<span class="line-added">122   // Set up WorkGang</span>
<span class="line-added">123   _workers.initialize_workers();</span>
<span class="line-added">124 </span>
125   return JNI_OK;
126 }
127 
128 void ParallelScavengeHeap::initialize_serviceability() {
129 
130   _eden_pool = new EdenMutableSpacePool(_young_gen,
131                                         _young_gen-&gt;eden_space(),
132                                         &quot;PS Eden Space&quot;,
133                                         false /* support_usage_threshold */);
134 
135   _survivor_pool = new SurvivorMutableSpacePool(_young_gen,
136                                                 &quot;PS Survivor Space&quot;,
137                                                 false /* support_usage_threshold */);
138 
139   _old_pool = new PSGenerationPool(_old_gen,
140                                    &quot;PS Old Gen&quot;,
141                                    true /* support_usage_threshold */);
142 
143   _young_manager = new GCMemoryManager(&quot;PS Scavenge&quot;, &quot;end of minor GC&quot;);
144   _old_manager = new GCMemoryManager(&quot;PS MarkSweep&quot;, &quot;end of major GC&quot;);
</pre>
<hr />
<pre>
147   _old_manager-&gt;add_pool(_survivor_pool);
148   _old_manager-&gt;add_pool(_old_pool);
149 
150   _young_manager-&gt;add_pool(_eden_pool);
151   _young_manager-&gt;add_pool(_survivor_pool);
152 
153 }
154 
155 class PSIsScavengable : public BoolObjectClosure {
156   bool do_object_b(oop obj) {
157     return ParallelScavengeHeap::heap()-&gt;is_in_young(obj);
158   }
159 };
160 
161 static PSIsScavengable _is_scavengable;
162 
163 void ParallelScavengeHeap::post_initialize() {
164   CollectedHeap::post_initialize();
165   // Need to init the tenuring threshold
166   PSScavenge::initialize();
<span class="line-modified">167   PSParallelCompact::post_initialize();</span>




168   PSPromotionManager::initialize();
169 
170   ScavengableNMethods::initialize(&amp;_is_scavengable);
171 }
172 
173 void ParallelScavengeHeap::update_counters() {
174   young_gen()-&gt;update_counters();
175   old_gen()-&gt;update_counters();
176   MetaspaceCounters::update_performance_counters();
177   CompressedClassSpaceCounters::update_performance_counters();
178 }
179 
180 size_t ParallelScavengeHeap::capacity() const {
181   size_t value = young_gen()-&gt;capacity_in_bytes() + old_gen()-&gt;capacity_in_bytes();
182   return value;
183 }
184 
185 size_t ParallelScavengeHeap::used() const {
186   size_t value = young_gen()-&gt;used_in_bytes() + old_gen()-&gt;used_in_bytes();
187   return value;
</pre>
<hr />
<pre>
392 HeapWord* ParallelScavengeHeap::mem_allocate_old_gen(size_t size) {
393   if (!should_alloc_in_eden(size) || GCLocker::is_active_and_needs_gc()) {
394     // Size is too big for eden, or gc is locked out.
395     return old_gen()-&gt;allocate(size);
396   }
397 
398   // If a &quot;death march&quot; is in progress, allocate from the old gen a limited
399   // number of times before doing a GC.
400   if (_death_march_count &gt; 0) {
401     if (_death_march_count &lt; 64) {
402       ++_death_march_count;
403       return old_gen()-&gt;allocate(size);
404     } else {
405       _death_march_count = 0;
406     }
407   }
408   return NULL;
409 }
410 
411 void ParallelScavengeHeap::do_full_collection(bool clear_all_soft_refs) {
<span class="line-modified">412   // The do_full_collection() parameter clear_all_soft_refs</span>
<span class="line-modified">413   // is interpreted here as maximum_compaction which will</span>
<span class="line-modified">414   // cause SoftRefs to be cleared.</span>
<span class="line-modified">415   bool maximum_compaction = clear_all_soft_refs;</span>
<span class="line-modified">416   PSParallelCompact::invoke(maximum_compaction);</span>




417 }
418 
419 // Failed allocation policy. Must be called from the VM thread, and
420 // only at a safepoint! Note that this method has policy for allocation
421 // flow, and NOT collection policy. So we do not check for gc collection
422 // time over limit here, that is the responsibility of the heap specific
423 // collection methods. This method decides where to attempt allocations,
424 // and when to attempt collections, but no collection specific policy.
425 HeapWord* ParallelScavengeHeap::failed_mem_allocate(size_t size) {
426   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
427   assert(Thread::current() == (Thread*)VMThread::vm_thread(), &quot;should be in vm thread&quot;);
428   assert(!is_gc_active(), &quot;not reentrant&quot;);
429   assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);
430 
431   // We assume that allocation in eden will fail unless we collect.
432 
433   // First level allocation failure, scavenge and allocate in young gen.
434   GCCauseSetter gccs(this, GCCause::_allocation_failure);
435   const bool invoked_full_gc = PSScavenge::invoke();
436   HeapWord* result = young_gen()-&gt;allocate(size);
</pre>
<hr />
<pre>
494 }
495 
496 void ParallelScavengeHeap::resize_all_tlabs() {
497   CollectedHeap::resize_all_tlabs();
498 }
499 
500 // This method is used by System.gc() and JVMTI.
501 void ParallelScavengeHeap::collect(GCCause::Cause cause) {
502   assert(!Heap_lock-&gt;owned_by_self(),
503     &quot;this thread should not own the Heap_lock&quot;);
504 
505   uint gc_count      = 0;
506   uint full_gc_count = 0;
507   {
508     MutexLocker ml(Heap_lock);
509     // This value is guarded by the Heap_lock
510     gc_count      = total_collections();
511     full_gc_count = total_full_collections();
512   }
513 
<span class="line-added">514   if (GCLocker::should_discard(cause, gc_count)) {</span>
<span class="line-added">515     return;</span>
<span class="line-added">516   }</span>
<span class="line-added">517 </span>
518   VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause);
519   VMThread::execute(&amp;op);
520 }
521 
522 void ParallelScavengeHeap::object_iterate(ObjectClosure* cl) {
523   young_gen()-&gt;object_iterate(cl);
524   old_gen()-&gt;object_iterate(cl);
525 }
526 
527 
528 HeapWord* ParallelScavengeHeap::block_start(const void* addr) const {
529   if (young_gen()-&gt;is_in_reserved(addr)) {
530     assert(young_gen()-&gt;is_in(addr),
531            &quot;addr should be in allocated part of young gen&quot;);
532     // called from os::print_location by find or VMError
533     if (Debugging || VMError::fatal_error_in_progress())  return NULL;
534     Unimplemented();
535   } else if (old_gen()-&gt;is_in_reserved(addr)) {
536     assert(old_gen()-&gt;is_in(addr),
537            &quot;addr should be in allocated part of old gen&quot;);
538     return old_gen()-&gt;start_array()-&gt;object_start((HeapWord*)addr);
539   }
540   return 0;
541 }
542 
543 bool ParallelScavengeHeap::block_is_obj(const HeapWord* addr) const {
544   return block_start(addr) == addr;
545 }
546 
547 jlong ParallelScavengeHeap::millis_since_last_gc() {
<span class="line-modified">548   return PSParallelCompact::millis_since_last_gc();</span>


549 }
550 
551 void ParallelScavengeHeap::prepare_for_verify() {
552   ensure_parsability(false);  // no need to retire TLABs for verification
553 }
554 
555 PSHeapSummary ParallelScavengeHeap::create_ps_heap_summary() {
556   PSOldGen* old = old_gen();
557   HeapWord* old_committed_end = (HeapWord*)old-&gt;virtual_space()-&gt;committed_high_addr();
558   VirtualSpaceSummary old_summary(old-&gt;reserved().start(), old_committed_end, old-&gt;reserved().end());
559   SpaceSummary old_space(old-&gt;reserved().start(), old_committed_end, old-&gt;used_in_bytes());
560 
561   PSYoungGen* young = young_gen();
562   VirtualSpaceSummary young_summary(young-&gt;reserved().start(),
563     (HeapWord*)young-&gt;virtual_space()-&gt;committed_high_addr(), young-&gt;reserved().end());
564 
565   MutableSpace* eden = young_gen()-&gt;eden_space();
566   SpaceSummary eden_space(eden-&gt;bottom(), eden-&gt;end(), eden-&gt;used_in_bytes());
567 
568   MutableSpace* from = young_gen()-&gt;from_space();
569   SpaceSummary from_space(from-&gt;bottom(), from-&gt;end(), from-&gt;used_in_bytes());
570 
571   MutableSpace* to = young_gen()-&gt;to_space();
572   SpaceSummary to_space(to-&gt;bottom(), to-&gt;end(), to-&gt;used_in_bytes());
573 
574   VirtualSpaceSummary heap_summary = create_heap_space_summary();
575   return PSHeapSummary(heap_summary, used(), old_summary, old_space, young_summary, eden_space, from_space, to_space);
576 }
577 
<span class="line-added">578 bool ParallelScavengeHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">579   return BlockLocationPrinter&lt;ParallelScavengeHeap&gt;::print_location(st, addr);</span>
<span class="line-added">580 }</span>
<span class="line-added">581 </span>
582 void ParallelScavengeHeap::print_on(outputStream* st) const {
583   young_gen()-&gt;print_on(st);
584   old_gen()-&gt;print_on(st);
585   MetaspaceUtils::print_on(st);
586 }
587 
588 void ParallelScavengeHeap::print_on_error(outputStream* st) const {
589   this-&gt;CollectedHeap::print_on_error(st);
590 
<span class="line-modified">591   st-&gt;cr();</span>
<span class="line-modified">592   PSParallelCompact::print_on_error(st);</span>


593 }
594 
595 void ParallelScavengeHeap::gc_threads_do(ThreadClosure* tc) const {
<span class="line-modified">596   ParallelScavengeHeap::heap()-&gt;workers().threads_do(tc);</span>
597 }
598 
599 void ParallelScavengeHeap::print_gc_threads_on(outputStream* st) const {
<span class="line-modified">600   ParallelScavengeHeap::heap()-&gt;workers().print_worker_threads_on(st);</span>
601 }
602 
603 void ParallelScavengeHeap::print_tracing_info() const {
604   AdaptiveSizePolicyOutput::print();
605   log_debug(gc, heap, exit)(&quot;Accumulated young generation GC time %3.7f secs&quot;, PSScavenge::accumulated_time()-&gt;seconds());
<span class="line-modified">606   log_debug(gc, heap, exit)(&quot;Accumulated old generation GC time %3.7f secs&quot;, PSParallelCompact::accumulated_time()-&gt;seconds());</span>
<span class="line-modified">607 }</span>
<span class="line-added">608 </span>
<span class="line-added">609 PreGenGCValues ParallelScavengeHeap::get_pre_gc_values() const {</span>
<span class="line-added">610   const PSYoungGen* const young = young_gen();</span>
<span class="line-added">611   const MutableSpace* const eden = young-&gt;eden_space();</span>
<span class="line-added">612   const MutableSpace* const from = young-&gt;from_space();</span>
<span class="line-added">613   const PSOldGen* const old = old_gen();</span>
<span class="line-added">614 </span>
<span class="line-added">615   return PreGenGCValues(young-&gt;used_in_bytes(),</span>
<span class="line-added">616                         young-&gt;capacity_in_bytes(),</span>
<span class="line-added">617                         eden-&gt;used_in_bytes(),</span>
<span class="line-added">618                         eden-&gt;capacity_in_bytes(),</span>
<span class="line-added">619                         from-&gt;used_in_bytes(),</span>
<span class="line-added">620                         from-&gt;capacity_in_bytes(),</span>
<span class="line-added">621                         old-&gt;used_in_bytes(),</span>
<span class="line-added">622                         old-&gt;capacity_in_bytes());</span>
<span class="line-added">623 }</span>
<span class="line-added">624 </span>
<span class="line-added">625 void ParallelScavengeHeap::print_heap_change(const PreGenGCValues&amp; pre_gc_values) const {</span>
<span class="line-added">626   const PSYoungGen* const young = young_gen();</span>
<span class="line-added">627   const MutableSpace* const eden = young-&gt;eden_space();</span>
<span class="line-added">628   const MutableSpace* const from = young-&gt;from_space();</span>
<span class="line-added">629   const PSOldGen* const old = old_gen();</span>
<span class="line-added">630 </span>
<span class="line-added">631   log_info(gc, heap)(HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="line-added">632                      HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="line-added">633                      HEAP_CHANGE_FORMAT,</span>
<span class="line-added">634                      HEAP_CHANGE_FORMAT_ARGS(young-&gt;name(),</span>
<span class="line-added">635                                              pre_gc_values.young_gen_used(),</span>
<span class="line-added">636                                              pre_gc_values.young_gen_capacity(),</span>
<span class="line-added">637                                              young-&gt;used_in_bytes(),</span>
<span class="line-added">638                                              young-&gt;capacity_in_bytes()),</span>
<span class="line-added">639                      HEAP_CHANGE_FORMAT_ARGS(&quot;Eden&quot;,</span>
<span class="line-added">640                                              pre_gc_values.eden_used(),</span>
<span class="line-added">641                                              pre_gc_values.eden_capacity(),</span>
<span class="line-added">642                                              eden-&gt;used_in_bytes(),</span>
<span class="line-added">643                                              eden-&gt;capacity_in_bytes()),</span>
<span class="line-added">644                      HEAP_CHANGE_FORMAT_ARGS(&quot;From&quot;,</span>
<span class="line-added">645                                              pre_gc_values.from_used(),</span>
<span class="line-added">646                                              pre_gc_values.from_capacity(),</span>
<span class="line-added">647                                              from-&gt;used_in_bytes(),</span>
<span class="line-added">648                                              from-&gt;capacity_in_bytes()));</span>
<span class="line-added">649   log_info(gc, heap)(HEAP_CHANGE_FORMAT,</span>
<span class="line-added">650                      HEAP_CHANGE_FORMAT_ARGS(old-&gt;name(),</span>
<span class="line-added">651                                              pre_gc_values.old_gen_used(),</span>
<span class="line-added">652                                              pre_gc_values.old_gen_capacity(),</span>
<span class="line-added">653                                              old-&gt;used_in_bytes(),</span>
<span class="line-added">654                                              old-&gt;capacity_in_bytes()));</span>
<span class="line-added">655   MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());</span>
656 }
657 

658 void ParallelScavengeHeap::verify(VerifyOption option /* ignored */) {
659   // Why do we need the total_collections()-filter below?
660   if (total_collections() &gt; 0) {
661     log_debug(gc, verify)(&quot;Tenured&quot;);
662     old_gen()-&gt;verify();
663 
664     log_debug(gc, verify)(&quot;Eden&quot;);
665     young_gen()-&gt;verify();
666   }
667 }
668 
669 void ParallelScavengeHeap::trace_heap(GCWhen::Type when, const GCTracer* gc_tracer) {
670   const PSHeapSummary&amp; heap_summary = create_ps_heap_summary();
671   gc_tracer-&gt;report_gc_heap_summary(when, heap_summary);
672 
673   const MetaspaceSummary&amp; metaspace_summary = create_metaspace_summary();
674   gc_tracer-&gt;report_metaspace_summary(when, metaspace_summary);
675 }
676 
677 ParallelScavengeHeap* ParallelScavengeHeap::heap() {
</pre>
<hr />
<pre>
744     young_gen()-&gt;to_space()-&gt;mangle_unused_area();
745     young_gen()-&gt;from_space()-&gt;mangle_unused_area();
746     old_gen()-&gt;object_space()-&gt;mangle_unused_area();
747   }
748 }
749 #endif
750 
751 void ParallelScavengeHeap::register_nmethod(nmethod* nm) {
752   ScavengableNMethods::register_nmethod(nm);
753 }
754 
755 void ParallelScavengeHeap::unregister_nmethod(nmethod* nm) {
756   ScavengableNMethods::unregister_nmethod(nm);
757 }
758 
759 void ParallelScavengeHeap::verify_nmethod(nmethod* nm) {
760   ScavengableNMethods::verify_nmethod(nm);
761 }
762 
763 void ParallelScavengeHeap::flush_nmethod(nmethod* nm) {
<span class="line-modified">764   // nothing particular</span>
765 }
766 
<span class="line-modified">767 void ParallelScavengeHeap::prune_scavengable_nmethods() {</span>
768   ScavengableNMethods::prune_nmethods();
769 }
770 
771 GrowableArray&lt;GCMemoryManager*&gt; ParallelScavengeHeap::memory_managers() {
772   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(2);
773   memory_managers.append(_young_manager);
774   memory_managers.append(_old_manager);
775   return memory_managers;
776 }
777 
778 GrowableArray&lt;MemoryPool*&gt; ParallelScavengeHeap::memory_pools() {
779   GrowableArray&lt;MemoryPool*&gt; memory_pools(3);
780   memory_pools.append(_eden_pool);
781   memory_pools.append(_survivor_pool);
782   memory_pools.append(_old_pool);
783   return memory_pools;
784 }
</pre>
</td>
</tr>
</table>
<center><a href="parallelArguments.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
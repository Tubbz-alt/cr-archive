<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/asPSOldGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="adjoiningGenerationsForHeteroHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSYoungGen.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/asPSOldGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSOldGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;

 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Whereas PSOldGen takes the maximum size of the generation
 36 // (which doesn&#39;t change in the case of PSOldGen) as a parameter,
 37 // ASPSOldGen takes the upper limit on the size of
 38 // the generation as a parameter.  In ASPSOldGen the
 39 // maximum size of the generation can change as the boundary
 40 // moves.  The &quot;maximum size of the generation&quot; is still a valid
 41 // concept since the generation can grow and shrink within that
 42 // maximum.  There are lots of useful checks that use that
 43 // maximum.  In PSOldGen the method max_gen_size() returns
 44 // _max_gen_size (as set by the PSOldGen constructor).  This
 45 // is how it always worked.  In ASPSOldGen max_gen_size()
 46 // returned the size of the reserved space for the generation.
 47 // That can change as the boundary moves.  Below the limit of
 48 // the size of the generation is passed to the PSOldGen constructor
 49 // for &quot;_max_gen_size&quot; (have to pass something) but it is not used later.
 50 //
</pre>
<hr />
<pre>
 73   PSOldGen::initialize_work(perf_data_name, level);
 74 
 75   // The old gen can grow to gen_size_limit().  _reserve reflects only
 76   // the current maximum that can be committed.
 77   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 78 
 79   initialize_performance_counters(perf_data_name, level);
 80 }
 81 
 82 void ASPSOldGen::reset_after_change() {
 83   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 84                         (HeapWord*)virtual_space()-&gt;high_boundary());
 85   post_resize();
 86 }
 87 
 88 
 89 size_t ASPSOldGen::available_for_expansion() {
 90   assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
 91   assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
 92 
<span class="line-removed"> 93   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
 94   size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
<span class="line-modified"> 95   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
 96   return result_aligned;
 97 }
 98 
 99 size_t ASPSOldGen::available_for_contraction() {
100   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
101   if (uncommitted_bytes != 0) {
102     return uncommitted_bytes;
103   }
104 
105   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="line-removed">106   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
107   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
108   const size_t working_size =
109     used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
<span class="line-modified">110   const size_t working_aligned = align_up(working_size, gen_alignment);</span>
111   const size_t working_or_min = MAX2(working_aligned, min_gen_size());
112   if (working_or_min &gt; reserved().byte_size()) {
113     // If the used or minimum gen size (aligned up) is greater
114     // than the total reserved size, then the space available
115     // for contraction should (after proper alignment) be 0
116     return 0;
117   }
118   const size_t max_contraction =
119     reserved().byte_size() - working_or_min;
120 
121   // Use the &quot;increment&quot; fraction instead of the &quot;decrement&quot; fraction
122   // to allow the other gen to expand more aggressively.  The
123   // &quot;decrement&quot; fraction is conservative because its intent is to
124   // only reduce the footprint.
125 
126   size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
127   // Also adjust for inter-generational alignment
<span class="line-modified">128   size_t result_aligned = align_down(result, gen_alignment);</span>
129 
130   Log(gc, ergo) log;
131   if (log.is_trace()) {
132     size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
133     size_t promo_increment = policy-&gt;promo_increment(max_contraction);
134     log.trace(&quot;ASPSOldGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, result_aligned/K, result_aligned);
135     log.trace(&quot; reserved().byte_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, reserved().byte_size()/K, reserved().byte_size());
136     log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
137     log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
138     log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
139     log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
140     log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
<span class="line-modified">141     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, gen_alignment);</span>
142   }
143 
144   assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
145   return result_aligned;
146 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSOldGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;

 29 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/genArguments.hpp&quot;</span>
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Whereas PSOldGen takes the maximum size of the generation
 36 // (which doesn&#39;t change in the case of PSOldGen) as a parameter,
 37 // ASPSOldGen takes the upper limit on the size of
 38 // the generation as a parameter.  In ASPSOldGen the
 39 // maximum size of the generation can change as the boundary
 40 // moves.  The &quot;maximum size of the generation&quot; is still a valid
 41 // concept since the generation can grow and shrink within that
 42 // maximum.  There are lots of useful checks that use that
 43 // maximum.  In PSOldGen the method max_gen_size() returns
 44 // _max_gen_size (as set by the PSOldGen constructor).  This
 45 // is how it always worked.  In ASPSOldGen max_gen_size()
 46 // returned the size of the reserved space for the generation.
 47 // That can change as the boundary moves.  Below the limit of
 48 // the size of the generation is passed to the PSOldGen constructor
 49 // for &quot;_max_gen_size&quot; (have to pass something) but it is not used later.
 50 //
</pre>
<hr />
<pre>
 73   PSOldGen::initialize_work(perf_data_name, level);
 74 
 75   // The old gen can grow to gen_size_limit().  _reserve reflects only
 76   // the current maximum that can be committed.
 77   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 78 
 79   initialize_performance_counters(perf_data_name, level);
 80 }
 81 
 82 void ASPSOldGen::reset_after_change() {
 83   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 84                         (HeapWord*)virtual_space()-&gt;high_boundary());
 85   post_resize();
 86 }
 87 
 88 
 89 size_t ASPSOldGen::available_for_expansion() {
 90   assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
 91   assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
 92 

 93   size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
<span class="line-modified"> 94   size_t result_aligned = align_down(result, GenAlignment);</span>
 95   return result_aligned;
 96 }
 97 
 98 size_t ASPSOldGen::available_for_contraction() {
 99   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
100   if (uncommitted_bytes != 0) {
101     return uncommitted_bytes;
102   }
103 
104   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();

105   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
106   const size_t working_size =
107     used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
<span class="line-modified">108   const size_t working_aligned = align_up(working_size, GenAlignment);</span>
109   const size_t working_or_min = MAX2(working_aligned, min_gen_size());
110   if (working_or_min &gt; reserved().byte_size()) {
111     // If the used or minimum gen size (aligned up) is greater
112     // than the total reserved size, then the space available
113     // for contraction should (after proper alignment) be 0
114     return 0;
115   }
116   const size_t max_contraction =
117     reserved().byte_size() - working_or_min;
118 
119   // Use the &quot;increment&quot; fraction instead of the &quot;decrement&quot; fraction
120   // to allow the other gen to expand more aggressively.  The
121   // &quot;decrement&quot; fraction is conservative because its intent is to
122   // only reduce the footprint.
123 
124   size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
125   // Also adjust for inter-generational alignment
<span class="line-modified">126   size_t result_aligned = align_down(result, GenAlignment);</span>
127 
128   Log(gc, ergo) log;
129   if (log.is_trace()) {
130     size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
131     size_t promo_increment = policy-&gt;promo_increment(max_contraction);
132     log.trace(&quot;ASPSOldGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, result_aligned/K, result_aligned);
133     log.trace(&quot; reserved().byte_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, reserved().byte_size()/K, reserved().byte_size());
134     log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
135     log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
136     log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
137     log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
138     log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
<span class="line-modified">139     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, GenAlignment);</span>
140   }
141 
142   assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
143   return result_aligned;
144 }
</pre>
</td>
</tr>
</table>
<center><a href="adjoiningGenerationsForHeteroHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="asPSYoungGen.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
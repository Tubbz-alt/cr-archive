<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psPromotionManager.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psPromotionManager.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
140 inline void PSPromotionManager::push_contents(oop obj) {
141   if (!obj-&gt;klass()-&gt;is_typeArray_klass()) {
142     PSPushContentsClosure pcc(this);
143     obj-&gt;oop_iterate_backwards(&amp;pcc);
144   }
145 }
146 //
147 // This method is pretty bulky. It would be nice to split it up
148 // into smaller submethods, but we need to be careful not to hurt
149 // performance.
150 //
151 template&lt;bool promote_immediately&gt;
152 inline oop PSPromotionManager::copy_to_survivor_space(oop o) {
153   assert(should_scavenge(&amp;o), &quot;Sanity&quot;);
154 
155   oop new_obj = NULL;
156 
157   // NOTE! We must be very careful with any methods that access the mark
158   // in o. There may be multiple threads racing on it, and it may be forwarded
159   // at any time. Do not use oop methods for accessing the mark!
<span class="line-modified">160   markOop test_mark = o-&gt;mark_raw();</span>
161 
162   // The same test as &quot;o-&gt;is_forwarded()&quot;
<span class="line-modified">163   if (!test_mark-&gt;is_marked()) {</span>
164     bool new_obj_is_tenured = false;
165     size_t new_obj_size = o-&gt;size();
166 
167     // Find the objects age, MT safe.
<span class="line-modified">168     uint age = (test_mark-&gt;has_displaced_mark_helper() /* o-&gt;has_displaced_mark() */) ?</span>
<span class="line-modified">169       test_mark-&gt;displaced_mark_helper()-&gt;age() : test_mark-&gt;age();</span>
170 
171     if (!promote_immediately) {
172       // Try allocating obj in to-space (unless too old)
173       if (age &lt; PSScavenge::tenuring_threshold()) {
174         new_obj = (oop) _young_lab.allocate(new_obj_size);
175         if (new_obj == NULL &amp;&amp; !_young_gen_is_full) {
176           // Do we allocate directly, or flush and refill?
177           if (new_obj_size &gt; (YoungPLABSize / 2)) {
178             // Allocate this object directly
179             new_obj = (oop)young_space()-&gt;cas_allocate(new_obj_size);
180             promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);
181           } else {
182             // Flush and fill
183             _young_lab.flush();
184 
185             HeapWord* lab_base = young_space()-&gt;cas_allocate(YoungPLABSize);
186             if (lab_base != NULL) {
187               _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));
188               // Try the young lab allocation again.
189               new_obj = (oop) _young_lab.allocate(new_obj_size);
</pre>
<hr />
<pre>
207       new_obj = (oop) _old_lab.allocate(new_obj_size);
208       new_obj_is_tenured = true;
209 
210       if (new_obj == NULL) {
211         if (!_old_gen_is_full) {
212           // Do we allocate directly, or flush and refill?
213           if (new_obj_size &gt; (OldPLABSize / 2)) {
214             // Allocate this object directly
215             new_obj = (oop)old_gen()-&gt;cas_allocate(new_obj_size);
216             promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);
217           } else {
218             // Flush and fill
219             _old_lab.flush();
220 
221             HeapWord* lab_base = old_gen()-&gt;cas_allocate(OldPLABSize);
222             if(lab_base != NULL) {
223 #ifdef ASSERT
224               // Delay the initialization of the promotion lab (plab).
225               // This exposes uninitialized plabs to card table processing.
226               if (GCWorkerDelayMillis &gt; 0) {
<span class="line-modified">227                 os::sleep(Thread::current(), GCWorkerDelayMillis, false);</span>
228               }
229 #endif
230               _old_lab.initialize(MemRegion(lab_base, OldPLABSize));
231               // Try the old lab allocation again.
232               new_obj = (oop) _old_lab.allocate(new_obj_size);
233               promotion_trace_event(new_obj, o, new_obj_size, age, true, &amp;_old_lab);
234             }
235           }
236         }
237 
238         // This is the promotion failed test, and code handling.
239         // The code belongs here for two reasons. It is slightly
240         // different than the code below, and cannot share the
241         // CAS testing code. Keeping the code here also minimizes
242         // the impact on the common case fast path code.
243 
244         if (new_obj == NULL) {
245           _old_gen_is_full = true;
246           return oop_promotion_failed(o, test_mark);
247         }
248       }
249     }
250 
251     assert(new_obj != NULL, &quot;allocation should have succeeded&quot;);
252 
253     // Copy obj
<span class="line-modified">254     Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)new_obj, new_obj_size);</span>
255 
256     // Now we have to CAS in the header.
257     // Make copy visible to threads reading the forwardee.
258     if (o-&gt;cas_forward_to(new_obj, test_mark, memory_order_release)) {
259       // We won any races, we &quot;own&quot; this object.
260       assert(new_obj == o-&gt;forwardee(), &quot;Sanity&quot;);
261 
262       // Increment age if obj still in new generation. Now that
<span class="line-modified">263       // we&#39;re dealing with a markOop that cannot change, it is</span>
264       // okay to use the non mt safe oop methods.
265       if (!new_obj_is_tenured) {
266         new_obj-&gt;incr_age();
267         assert(young_space()-&gt;contains(new_obj), &quot;Attempt to push non-promoted obj&quot;);
268       }
269 
270       // Do the size comparison first with new_obj_size, which we
271       // already have. Hopefully, only a few objects are larger than
272       // _min_array_size_for_chunking, and most of them will be arrays.
273       // So, the is-&gt;objArray() test would be very infrequent.
274       if (new_obj_size &gt; _min_array_size_for_chunking &amp;&amp;
275           new_obj-&gt;is_objArray() &amp;&amp;
276           PSChunkLargeArrays) {
277         // we&#39;ll chunk it
278         oop* const masked_o = mask_chunked_array_oop(o);
279         push_depth(masked_o);
280         TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_masked_pushes);
281       } else {
282         // we&#39;ll just push its contents
283         push_contents(new_obj);
284       }
285     }  else {
286       // We lost, someone else &quot;owns&quot; this object
287       guarantee(o-&gt;is_forwarded(), &quot;Object must be forwarded if the cas failed.&quot;);
288 
289       // Try to deallocate the space.  If it was directly allocated we cannot
290       // deallocate it, so we have to test.  If the deallocation fails,
291       // overwrite with a filler object.
292       if (new_obj_is_tenured) {
<span class="line-modified">293         if (!_old_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {</span>
<span class="line-modified">294           CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);</span>
295         }
<span class="line-modified">296       } else if (!_young_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {</span>
<span class="line-modified">297         CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);</span>
298       }
299 
300       // don&#39;t update this before the unallocation!
301       // Using acquire though consume would be accurate for accessing new_obj.
302       new_obj = o-&gt;forwardee_acquire();
303     }
304   } else {
305     assert(o-&gt;is_forwarded(), &quot;Sanity&quot;);
306     new_obj = o-&gt;forwardee_acquire();
307   }
308 
309   // This code must come after the CAS test, or it will print incorrect
310   // information.
311   log_develop_trace(gc, scavenge)(&quot;{%s %s &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot; (%d)}&quot;,
312                                   should_scavenge(&amp;new_obj) ? &quot;copying&quot; : &quot;tenuring&quot;,
313                                   new_obj-&gt;klass()-&gt;internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj-&gt;size());
314 
315   return new_obj;
316 }
317 
</pre>
</td>
<td>
<hr />
<pre>
140 inline void PSPromotionManager::push_contents(oop obj) {
141   if (!obj-&gt;klass()-&gt;is_typeArray_klass()) {
142     PSPushContentsClosure pcc(this);
143     obj-&gt;oop_iterate_backwards(&amp;pcc);
144   }
145 }
146 //
147 // This method is pretty bulky. It would be nice to split it up
148 // into smaller submethods, but we need to be careful not to hurt
149 // performance.
150 //
151 template&lt;bool promote_immediately&gt;
152 inline oop PSPromotionManager::copy_to_survivor_space(oop o) {
153   assert(should_scavenge(&amp;o), &quot;Sanity&quot;);
154 
155   oop new_obj = NULL;
156 
157   // NOTE! We must be very careful with any methods that access the mark
158   // in o. There may be multiple threads racing on it, and it may be forwarded
159   // at any time. Do not use oop methods for accessing the mark!
<span class="line-modified">160   markWord test_mark = o-&gt;mark_raw();</span>
161 
162   // The same test as &quot;o-&gt;is_forwarded()&quot;
<span class="line-modified">163   if (!test_mark.is_marked()) {</span>
164     bool new_obj_is_tenured = false;
165     size_t new_obj_size = o-&gt;size();
166 
167     // Find the objects age, MT safe.
<span class="line-modified">168     uint age = (test_mark.has_displaced_mark_helper() /* o-&gt;has_displaced_mark() */) ?</span>
<span class="line-modified">169       test_mark.displaced_mark_helper().age() : test_mark.age();</span>
170 
171     if (!promote_immediately) {
172       // Try allocating obj in to-space (unless too old)
173       if (age &lt; PSScavenge::tenuring_threshold()) {
174         new_obj = (oop) _young_lab.allocate(new_obj_size);
175         if (new_obj == NULL &amp;&amp; !_young_gen_is_full) {
176           // Do we allocate directly, or flush and refill?
177           if (new_obj_size &gt; (YoungPLABSize / 2)) {
178             // Allocate this object directly
179             new_obj = (oop)young_space()-&gt;cas_allocate(new_obj_size);
180             promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);
181           } else {
182             // Flush and fill
183             _young_lab.flush();
184 
185             HeapWord* lab_base = young_space()-&gt;cas_allocate(YoungPLABSize);
186             if (lab_base != NULL) {
187               _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));
188               // Try the young lab allocation again.
189               new_obj = (oop) _young_lab.allocate(new_obj_size);
</pre>
<hr />
<pre>
207       new_obj = (oop) _old_lab.allocate(new_obj_size);
208       new_obj_is_tenured = true;
209 
210       if (new_obj == NULL) {
211         if (!_old_gen_is_full) {
212           // Do we allocate directly, or flush and refill?
213           if (new_obj_size &gt; (OldPLABSize / 2)) {
214             // Allocate this object directly
215             new_obj = (oop)old_gen()-&gt;cas_allocate(new_obj_size);
216             promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);
217           } else {
218             // Flush and fill
219             _old_lab.flush();
220 
221             HeapWord* lab_base = old_gen()-&gt;cas_allocate(OldPLABSize);
222             if(lab_base != NULL) {
223 #ifdef ASSERT
224               // Delay the initialization of the promotion lab (plab).
225               // This exposes uninitialized plabs to card table processing.
226               if (GCWorkerDelayMillis &gt; 0) {
<span class="line-modified">227                 os::naked_sleep(GCWorkerDelayMillis);</span>
228               }
229 #endif
230               _old_lab.initialize(MemRegion(lab_base, OldPLABSize));
231               // Try the old lab allocation again.
232               new_obj = (oop) _old_lab.allocate(new_obj_size);
233               promotion_trace_event(new_obj, o, new_obj_size, age, true, &amp;_old_lab);
234             }
235           }
236         }
237 
238         // This is the promotion failed test, and code handling.
239         // The code belongs here for two reasons. It is slightly
240         // different than the code below, and cannot share the
241         // CAS testing code. Keeping the code here also minimizes
242         // the impact on the common case fast path code.
243 
244         if (new_obj == NULL) {
245           _old_gen_is_full = true;
246           return oop_promotion_failed(o, test_mark);
247         }
248       }
249     }
250 
251     assert(new_obj != NULL, &quot;allocation should have succeeded&quot;);
252 
253     // Copy obj
<span class="line-modified">254     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(o), cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
255 
256     // Now we have to CAS in the header.
257     // Make copy visible to threads reading the forwardee.
258     if (o-&gt;cas_forward_to(new_obj, test_mark, memory_order_release)) {
259       // We won any races, we &quot;own&quot; this object.
260       assert(new_obj == o-&gt;forwardee(), &quot;Sanity&quot;);
261 
262       // Increment age if obj still in new generation. Now that
<span class="line-modified">263       // we&#39;re dealing with a markWord that cannot change, it is</span>
264       // okay to use the non mt safe oop methods.
265       if (!new_obj_is_tenured) {
266         new_obj-&gt;incr_age();
267         assert(young_space()-&gt;contains(new_obj), &quot;Attempt to push non-promoted obj&quot;);
268       }
269 
270       // Do the size comparison first with new_obj_size, which we
271       // already have. Hopefully, only a few objects are larger than
272       // _min_array_size_for_chunking, and most of them will be arrays.
273       // So, the is-&gt;objArray() test would be very infrequent.
274       if (new_obj_size &gt; _min_array_size_for_chunking &amp;&amp;
275           new_obj-&gt;is_objArray() &amp;&amp;
276           PSChunkLargeArrays) {
277         // we&#39;ll chunk it
278         oop* const masked_o = mask_chunked_array_oop(o);
279         push_depth(masked_o);
280         TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_masked_pushes);
281       } else {
282         // we&#39;ll just push its contents
283         push_contents(new_obj);
284       }
285     }  else {
286       // We lost, someone else &quot;owns&quot; this object
287       guarantee(o-&gt;is_forwarded(), &quot;Object must be forwarded if the cas failed.&quot;);
288 
289       // Try to deallocate the space.  If it was directly allocated we cannot
290       // deallocate it, so we have to test.  If the deallocation fails,
291       // overwrite with a filler object.
292       if (new_obj_is_tenured) {
<span class="line-modified">293         if (!_old_lab.unallocate_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size)) {</span>
<span class="line-modified">294           CollectedHeap::fill_with_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
295         }
<span class="line-modified">296       } else if (!_young_lab.unallocate_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size)) {</span>
<span class="line-modified">297         CollectedHeap::fill_with_object(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj_size);</span>
298       }
299 
300       // don&#39;t update this before the unallocation!
301       // Using acquire though consume would be accurate for accessing new_obj.
302       new_obj = o-&gt;forwardee_acquire();
303     }
304   } else {
305     assert(o-&gt;is_forwarded(), &quot;Sanity&quot;);
306     new_obj = o-&gt;forwardee_acquire();
307   }
308 
309   // This code must come after the CAS test, or it will print incorrect
310   // information.
311   log_develop_trace(gc, scavenge)(&quot;{%s %s &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot; (%d)}&quot;,
312                                   should_scavenge(&amp;new_obj) ? &quot;copying&quot; : &quot;tenuring&quot;,
313                                   new_obj-&gt;klass()-&gt;internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj-&gt;size());
314 
315   return new_obj;
316 }
317 
</pre>
</td>
</tr>
</table>
<center><a href="psPromotionManager.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psScavenge.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
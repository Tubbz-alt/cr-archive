<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/asPSYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSYoungGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 28 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 29 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 30 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/java.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 
 37 ASPSYoungGen::ASPSYoungGen(size_t init_byte_size,
 38                            size_t minimum_byte_size,
 39                            size_t byte_size_limit) :
 40   PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 41   _gen_size_limit(byte_size_limit) {
 42 }
 43 
 44 
 45 ASPSYoungGen::ASPSYoungGen(PSVirtualSpace* vs,
 46                            size_t init_byte_size,
 47                            size_t minimum_byte_size,
 48                            size_t byte_size_limit) :
 49   //PSYoungGen(init_byte_size, minimum_byte_size, byte_size_limit),
 50   PSYoungGen(vs-&gt;committed_size(), minimum_byte_size, byte_size_limit),
 51   _gen_size_limit(byte_size_limit) {
 52 
 53   assert(vs-&gt;committed_size() == init_byte_size, &quot;Cannot replace with&quot;);
 54 
 55   _virtual_space = vs;
 56 }
 57 
 58 void ASPSYoungGen::initialize_virtual_space(ReservedSpace rs,
 59                                             size_t alignment) {
 60   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 61   _virtual_space = new PSVirtualSpaceHighToLow(rs, alignment);
 62   if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
<a name="4" id="anc4"></a><span class="line-modified"> 63     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;</span>
<span class="line-removed"> 64                                   &quot;object heap&quot;);</span>
 65   }
 66 }
 67 
 68 void ASPSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 69   initialize_virtual_space(rs, alignment);
 70   initialize_work();
 71 }
 72 
 73 size_t ASPSYoungGen::available_for_expansion() {
 74   size_t current_committed_size = virtual_space()-&gt;committed_size();
 75   assert((gen_size_limit() &gt;= current_committed_size),
 76     &quot;generation size limit is wrong&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 77   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
 78   size_t result =  gen_size_limit() - current_committed_size;
<a name="6" id="anc6"></a><span class="line-modified"> 79   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
 80   return result_aligned;
 81 }
 82 
 83 // Return the number of bytes the young gen is willing give up.
 84 //
 85 // Future implementations could check the survivors and if to_space is in the
 86 // right place (below from_space), take a chunk from to_space.
 87 size_t ASPSYoungGen::available_for_contraction() {
 88   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
 89   if (uncommitted_bytes != 0) {
 90     return uncommitted_bytes;
 91   }
 92 
 93   if (eden_space()-&gt;is_empty()) {
 94     // Respect the minimum size for eden and for the young gen as a whole.
 95     ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<a name="7" id="anc7"></a><span class="line-modified"> 96     const size_t eden_alignment = heap-&gt;space_alignment();</span>
<span class="line-removed"> 97     const size_t gen_alignment = heap-&gt;generation_alignment();</span>
 98 
 99     assert(eden_space()-&gt;capacity_in_bytes() &gt;= eden_alignment,
100       &quot;Alignment is wrong&quot;);
101     size_t eden_avail = eden_space()-&gt;capacity_in_bytes() - eden_alignment;
<a name="8" id="anc8"></a><span class="line-modified">102     eden_avail = align_down(eden_avail, gen_alignment);</span>
103 
104     assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(),
105       &quot;minimum gen size is wrong&quot;);
106     size_t gen_avail = virtual_space()-&gt;committed_size() - min_gen_size();
107     assert(virtual_space()-&gt;is_aligned(gen_avail), &quot;not aligned&quot;);
108 
109     const size_t max_contraction = MIN2(eden_avail, gen_avail);
110     // See comment for ASPSOldGen::available_for_contraction()
111     // for reasons the &quot;increment&quot; fraction is used.
112     PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
113     size_t result = policy-&gt;eden_increment_aligned_down(max_contraction);
<a name="9" id="anc9"></a><span class="line-modified">114     size_t result_aligned = align_down(result, gen_alignment);</span>
115 
116     log_trace(gc, ergo)(&quot;ASPSYoungGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K&quot;, result_aligned/K);
117     log_trace(gc, ergo)(&quot;  max_contraction &quot; SIZE_FORMAT &quot; K&quot;, max_contraction/K);
118     log_trace(gc, ergo)(&quot;  eden_avail &quot; SIZE_FORMAT &quot; K&quot;, eden_avail/K);
119     log_trace(gc, ergo)(&quot;  gen_avail &quot; SIZE_FORMAT &quot; K&quot;, gen_avail/K);
120 
121     return result_aligned;
122   }
123 
124   return 0;
125 }
126 
127 // The current implementation only considers to the end of eden.
128 // If to_space is below from_space, to_space is not considered.
129 // to_space can be.
130 size_t ASPSYoungGen::available_to_live() {
<a name="10" id="anc10"></a><span class="line-modified">131   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">132   const size_t alignment = heap-&gt;space_alignment();</span>
133 
134   // Include any space that is committed but is not in eden.
135   size_t available = pointer_delta(eden_space()-&gt;bottom(),
136                                    virtual_space()-&gt;low(),
137                                    sizeof(char));
138 
139   const size_t eden_capacity = eden_space()-&gt;capacity_in_bytes();
140   if (eden_space()-&gt;is_empty() &amp;&amp; eden_capacity &gt; alignment) {
141     available += eden_capacity - alignment;
142   }
143   return available;
144 }
145 
146 // Similar to PSYoungGen::resize_generation() but
147 //  allows sum of eden_size and 2 * survivor_size to exceed _max_gen_size
148 //  expands at the low end of the virtual space
149 //  moves the boundary between the generations in order to expand
150 //  some additional diagnostics
151 // If no additional changes are required, this can be deleted
152 // and the changes factored back into PSYoungGen::resize_generation().
153 bool ASPSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
154   const size_t alignment = virtual_space()-&gt;alignment();
155   size_t orig_size = virtual_space()-&gt;committed_size();
156   bool size_changed = false;
157 
158   // There used to be a guarantee here that
159   //   (eden_size + 2*survivor_size)  &lt;= _max_gen_size
160   // This requirement is enforced by the calculation of desired_size
161   // below.  It may not be true on entry since the size of the
162   // eden_size is no bounded by the generation size.
163 
164   assert(max_size() == reserved().byte_size(), &quot;max gen size problem?&quot;);
165   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(),
166          &quot;just checking&quot;);
167 
168   // Adjust new generation size
169   const size_t eden_plus_survivors =
170     align_up(eden_size + 2 * survivor_size, alignment);
<a name="11" id="anc11"></a><span class="line-modified">171   size_t desired_size = MAX2(MIN2(eden_plus_survivors, gen_size_limit()),</span>
<span class="line-removed">172                              min_gen_size());</span>
173   assert(desired_size &lt;= gen_size_limit(), &quot;just checking&quot;);
174 
175   if (desired_size &gt; orig_size) {
176     // Grow the generation
177     size_t change = desired_size - orig_size;
178     HeapWord* prev_low = (HeapWord*) virtual_space()-&gt;low();
179     if (!virtual_space()-&gt;expand_by(change)) {
180       return false;
181     }
182     if (ZapUnusedHeapArea) {
183       // Mangle newly committed space immediately because it
184       // can be done here more simply that after the new
185       // spaces have been computed.
186       HeapWord* new_low = (HeapWord*) virtual_space()-&gt;low();
187       assert(new_low &lt; prev_low, &quot;Did not grow&quot;);
188 
189       MemRegion mangle_region(new_low, prev_low);
190       SpaceMangler::mangle_region(mangle_region);
191     }
192     size_changed = true;
193   } else if (desired_size &lt; orig_size) {
194     size_t desired_change = orig_size - desired_size;
195 
196     // How much is available for shrinking.
197     size_t available_bytes = limit_gen_shrink(desired_change);
198     size_t change = MIN2(desired_change, available_bytes);
199     virtual_space()-&gt;shrink_by(change);
200     size_changed = true;
201   } else {
202     if (orig_size == gen_size_limit()) {
203       log_trace(gc)(&quot;ASPSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
204     } else if (orig_size == min_gen_size()) {
205       log_trace(gc)(&quot;ASPSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
206     }
207   }
208 
209   if (size_changed) {
210     reset_after_change();
211     log_trace(gc)(&quot;ASPSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
212                   orig_size/K, virtual_space()-&gt;committed_size()/K);
213   }
214 
215   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
216             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);
217 
218   return true;
219 }
220 
221 // Similar to PSYoungGen::resize_spaces() but
222 //  eden always starts at the low end of the committed virtual space
223 //  current implementation does not allow holes between the spaces
224 //  _young_generation_boundary has to be reset because it changes.
225 //  so additional verification
226 
227 void ASPSYoungGen::resize_spaces(size_t requested_eden_size,
228                                  size_t requested_survivor_size) {
229   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
230   assert(requested_eden_size &gt; 0 &amp;&amp; requested_survivor_size &gt; 0,
231          &quot;just checking&quot;);
232 
233   space_invariants();
234 
235   // We require eden and to space to be empty
236   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
237     return;
238   }
239 
240   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot;
241                       SIZE_FORMAT
242                       &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
243                       requested_eden_size, requested_survivor_size);
244   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot;
245                       SIZE_FORMAT,
246                       p2i(eden_space()-&gt;bottom()),
247                       p2i(eden_space()-&gt;end()),
248                       pointer_delta(eden_space()-&gt;end(), eden_space()-&gt;bottom(), sizeof(char)));
249   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot;
250                       SIZE_FORMAT,
251                       p2i(from_space()-&gt;bottom()),
252                       p2i(from_space()-&gt;end()),
253                       pointer_delta(from_space()-&gt;end(), from_space()-&gt;bottom(), sizeof(char)));
254   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot;
255                       SIZE_FORMAT,
256                       p2i(to_space()-&gt;bottom()),
257                       p2i(to_space()-&gt;end()),
258                       pointer_delta(  to_space()-&gt;end(), to_space()-&gt;bottom(), sizeof(char)));
259 
260   // There&#39;s nothing to do if the new sizes are the same as the current
261   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
262       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
263       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
264     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
265     return;
266   }
267 
268   char* eden_start = (char*)virtual_space()-&gt;low();
269   char* eden_end   = (char*)eden_space()-&gt;end();
270   char* from_start = (char*)from_space()-&gt;bottom();
271   char* from_end   = (char*)from_space()-&gt;end();
272   char* to_start   = (char*)to_space()-&gt;bottom();
273   char* to_end     = (char*)to_space()-&gt;end();
274 
275   assert(eden_start &lt; from_start, &quot;Cannot push into from_space&quot;);
276 
277   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<a name="12" id="anc12"></a><span class="line-removed">278   const size_t alignment = heap-&gt;space_alignment();</span>
279   const bool maintain_minimum =
280     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
281 
282   bool eden_from_to_order = from_start &lt; to_start;
283   // Check whether from space is below to space
284   if (eden_from_to_order) {
285     // Eden, from, to
286 
287     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
288 
289     // Set eden
290     // &quot;requested_eden_size&quot; is a goal for the size of eden
291     // and may not be attainable.  &quot;eden_size&quot; below is
292     // calculated based on the location of from-space and
293     // the goal for the size of eden.  from-space is
294     // fixed in place because it contains live data.
295     // The calculation is done this way to avoid 32bit
296     // overflow (i.e., eden_start + requested_eden_size
297     // may too large for representation in 32bits).
298     size_t eden_size;
299     if (maintain_minimum) {
300       // Only make eden larger than the requested size if
301       // the minimum size of the generation has to be maintained.
302       // This could be done in general but policy at a higher
303       // level is determining a requested size for eden and that
304       // should be honored unless there is a fundamental reason.
305       eden_size = pointer_delta(from_start,
306                                 eden_start,
307                                 sizeof(char));
308     } else {
309       eden_size = MIN2(requested_eden_size,
310                        pointer_delta(from_start, eden_start, sizeof(char)));
311     }
312 
313     eden_end = eden_start + eden_size;
314     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
315 
316     // To may resize into from space as long as it is clear of live data.
317     // From space must remain page aligned, though, so we need to do some
318     // extra calculations.
319 
320     // First calculate an optimal to-space
321     to_end   = (char*)virtual_space()-&gt;high();
322     to_start = (char*)pointer_delta(to_end,
323                                     (char*)requested_survivor_size,
324                                     sizeof(char));
325 
326     // Does the optimal to-space overlap from-space?
327     if (to_start &lt; (char*)from_space()-&gt;end()) {
328       // Calculate the minimum offset possible for from_end
329       size_t from_size =
330         pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
331 
332       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
333       if (from_size == 0) {
<a name="13" id="anc13"></a><span class="line-modified">334         from_size = alignment;</span>
335       } else {
<a name="14" id="anc14"></a><span class="line-modified">336         from_size = align_up(from_size, alignment);</span>
337       }
338 
339       from_end = from_start + from_size;
340       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
341 
342       guarantee(from_end &lt;= (char*)from_space()-&gt;end(),
343         &quot;from_end moved to the right&quot;);
344 
345       // Now update to_start with the new from_end
346       to_start = MAX2(from_end, to_start);
347     }
348 
349     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
350 
351     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
352                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
353                         p2i(eden_start),
354                         p2i(eden_end),
355                         pointer_delta(eden_end, eden_start, sizeof(char)));
356     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
357                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
358                         p2i(from_start),
359                         p2i(from_end),
360                         pointer_delta(from_end, from_start, sizeof(char)));
361     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): &quot;
362                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
363                         p2i(to_start),
364                         p2i(to_end),
365                         pointer_delta(  to_end,   to_start, sizeof(char)));
366   } else {
367     // Eden, to, from
368     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
369 
370     // To space gets priority over eden resizing. Note that we position
371     // to space as if we were able to resize from space, even though from
372     // space is not modified.
373     // Giving eden priority was tried and gave poorer performance.
374     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
375                                     (char*)requested_survivor_size,
376                                     sizeof(char));
377     to_end   = MIN2(to_end, from_start);
378     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
379                                     sizeof(char));
380     // if the space sizes are to be increased by several times then
381     // &#39;to_start&#39; will point beyond the young generation. In this case
382     // &#39;to_start&#39; should be adjusted.
<a name="15" id="anc15"></a><span class="line-modified">383     to_start = MAX2(to_start, eden_start + alignment);</span>
384 
385     // Compute how big eden can be, then adjust end.
386     // See  comments above on calculating eden_end.
387     size_t eden_size;
388     if (maintain_minimum) {
389       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
390     } else {
391       eden_size = MIN2(requested_eden_size,
392                        pointer_delta(to_start, eden_start, sizeof(char)));
393     }
394     eden_end = eden_start + eden_size;
395     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
396 
397     // Don&#39;t let eden shrink down to 0 or less.
<a name="16" id="anc16"></a><span class="line-modified">398     eden_end = MAX2(eden_end, eden_start + alignment);</span>
399     to_start = MAX2(to_start, eden_end);
400 
401     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
402                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
403                         p2i(eden_start),
404                         p2i(eden_end),
405                         pointer_delta(eden_end, eden_start, sizeof(char)));
406     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): &quot;
407                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
408                         p2i(to_start),
409                         p2i(to_end),
410                         pointer_delta(  to_end,   to_start, sizeof(char)));
411     log_trace(gc, ergo)(&quot;    [from_start .. from_end): &quot;
412                         &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
413                         p2i(from_start),
414                         p2i(from_end),
415                         pointer_delta(from_end, from_start, sizeof(char)));
416   }
417 
418 
419   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
420             &quot;from start moved to the right&quot;);
421   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
422             &quot;from end moved into live data&quot;);
423   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
424   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
425   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
426 
427   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
428   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
429   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
430 
431   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
432   DEBUG_ONLY(HeapWord* old_from_top = from_space()-&gt;top();)
433 
434   // For logging block  below
435   size_t old_from = from_space()-&gt;capacity_in_bytes();
436   size_t old_to   = to_space()-&gt;capacity_in_bytes();
437 
438   if (ZapUnusedHeapArea) {
439     // NUMA is a special case because a numa space is not mangled
440     // in order to not prematurely bind its address to memory to
441     // the wrong memory (i.e., don&#39;t want the GC thread to first
442     // touch the memory).  The survivor spaces are not numa
443     // spaces and are mangled.
444     if (UseNUMA) {
445       if (eden_from_to_order) {
446         mangle_survivors(from_space(), fromMR, to_space(), toMR);
447       } else {
448         mangle_survivors(to_space(), toMR, from_space(), fromMR);
449       }
450     }
451 
452     // If not mangling the spaces, do some checking to verify that
453     // the spaces are already mangled.
454     // The spaces should be correctly mangled at this point so
455     // do some checking here. Note that they are not being mangled
456     // in the calls to initialize().
457     // Must check mangling before the spaces are reshaped.  Otherwise,
458     // the bottom or end of one space may have moved into an area
459     // covered by another space and a failure of the check may
460     // not correctly indicate which space is not properly mangled.
461 
462     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
463     eden_space()-&gt;check_mangled_unused_area(limit);
464     from_space()-&gt;check_mangled_unused_area(limit);
465       to_space()-&gt;check_mangled_unused_area(limit);
466   }
467   // When an existing space is being initialized, it is not
468   // mangled because the space has been previously mangled.
469   eden_space()-&gt;initialize(edenMR,
470                            SpaceDecorator::Clear,
471                            SpaceDecorator::DontMangle);
472     to_space()-&gt;initialize(toMR,
473                            SpaceDecorator::Clear,
474                            SpaceDecorator::DontMangle);
475   from_space()-&gt;initialize(fromMR,
476                            SpaceDecorator::DontClear,
477                            SpaceDecorator::DontMangle);
478 
479   PSScavenge::set_young_generation_boundary(eden_space()-&gt;bottom());
480 
481   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
482 
483   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: &quot;
484                 &quot;collection: %d &quot;
485                 &quot;(&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; &quot;
486                 &quot;(&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
487                 ParallelScavengeHeap::heap()-&gt;total_collections(),
488                 old_from, old_to,
489                 from_space()-&gt;capacity_in_bytes(),
490                 to_space()-&gt;capacity_in_bytes());
491 
492     space_invariants();
493 }
494 void ASPSYoungGen::reset_after_change() {
495   assert_locked_or_safepoint(Heap_lock);
496 
497   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
498                         (HeapWord*)virtual_space()-&gt;high_boundary());
499   PSScavenge::set_subject_to_discovery_span(_reserved);
500 
501   HeapWord* new_eden_bottom = (HeapWord*)virtual_space()-&gt;low();
502   HeapWord* eden_bottom = eden_space()-&gt;bottom();
503   if (new_eden_bottom != eden_bottom) {
504     MemRegion eden_mr(new_eden_bottom, eden_space()-&gt;end());
505     eden_space()-&gt;initialize(eden_mr,
506                              SpaceDecorator::Clear,
507                              SpaceDecorator::Mangle);
508     PSScavenge::set_young_generation_boundary(eden_space()-&gt;bottom());
509   }
510   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
511                 (HeapWord*)virtual_space()-&gt;high());
512   ParallelScavengeHeap::heap()-&gt;barrier_set()-&gt;card_table()-&gt;resize_covered_region(cmr);
513 
514   space_invariants();
515 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psVirtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psYoungGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="line-removed"> 28 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 29 #include &quot;gc/parallel/psScavenge.hpp&quot;
 30 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 31 #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified"> 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
<span class="line-modified"> 38 PSYoungGen::PSYoungGen(size_t        initial_size,</span>
<span class="line-modified"> 39                        size_t        min_size,</span>
<span class="line-modified"> 40                        size_t        max_size) :</span>



 41   _init_gen_size(initial_size),
 42   _min_gen_size(min_size),
<span class="line-modified"> 43   _max_gen_size(max_size)</span>




 44 {}
 45 
 46 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 47   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 48   _virtual_space = new PSVirtualSpace(rs, alignment);
 49   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {
 50     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 51                                   &quot;object heap&quot;);
 52   }
 53 }
 54 
 55 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 56   initialize_virtual_space(rs, alignment);
 57   initialize_work();
 58 }
 59 
 60 void PSYoungGen::initialize_work() {
 61 
 62   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 63                         (HeapWord*)virtual_space()-&gt;high_boundary());
 64 
 65   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 66                 (HeapWord*)virtual_space()-&gt;high());
 67   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 68 
 69   if (ZapUnusedHeapArea) {
 70     // Mangle newly committed space immediately because it
 71     // can be done here more simply that after the new
 72     // spaces have been computed.
 73     SpaceMangler::mangle_region(cmr);
 74   }
 75 
 76   if (UseNUMA) {
 77     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 78   } else {
 79     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 80   }
 81   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 82   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 83 
<span class="line-removed"> 84   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {</span>
<span class="line-removed"> 85     vm_exit_during_initialization(&quot;Could not allocate a young gen space&quot;);</span>
<span class="line-removed"> 86   }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88   // Allocate the mark sweep views of spaces</span>
<span class="line-removed"> 89   _eden_mark_sweep =</span>
<span class="line-removed"> 90       new PSMarkSweepDecorator(_eden_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 91   _from_mark_sweep =</span>
<span class="line-removed"> 92       new PSMarkSweepDecorator(_from_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 93   _to_mark_sweep =</span>
<span class="line-removed"> 94       new PSMarkSweepDecorator(_to_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96   if (_eden_mark_sweep == NULL ||</span>
<span class="line-removed"> 97       _from_mark_sweep == NULL ||</span>
<span class="line-removed"> 98       _to_mark_sweep == NULL) {</span>
<span class="line-removed"> 99     vm_exit_during_initialization(&quot;Could not complete allocation&quot;</span>
<span class="line-removed">100                                   &quot; of the young generation&quot;);</span>
<span class="line-removed">101   }</span>
<span class="line-removed">102 </span>
103   // Generation Counters - generation 0, 3 subspaces
104   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
105                                            _max_gen_size, _virtual_space);
106 
107   // Compute maximum space sizes for performance counters
<span class="line-modified">108   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">109   size_t alignment = heap-&gt;space_alignment();</span>
110   size_t size = virtual_space()-&gt;reserved_size();
111 
112   size_t max_survivor_size;
113   size_t max_eden_size;
114 
115   if (UseAdaptiveSizePolicy) {
116     max_survivor_size = size / MinSurvivorRatio;
117 
118     // round the survivor space size down to the nearest alignment
119     // and make sure its size is greater than 0.
120     max_survivor_size = align_down(max_survivor_size, alignment);
121     max_survivor_size = MAX2(max_survivor_size, alignment);
122 
123     // set the maximum size of eden to be the size of the young gen
124     // less two times the minimum survivor size. The minimum survivor
125     // size for UseAdaptiveSizePolicy is one alignment.
126     max_eden_size = size - 2 * alignment;
127   } else {
128     max_survivor_size = size / InitialSurvivorRatio;
129 
</pre>
<hr />
<pre>
138     // is dependent on the committed portion (current capacity) of the
139     // generation - the less space committed, the smaller the survivor
140     // space, possibly as small as an alignment. However, we are interested
141     // in the case where the young generation is 100% committed, as this
142     // is the point where eden reaches its maximum size. At this point,
143     // the size of a survivor space is max_survivor_size.
144     max_eden_size = size - 2 * max_survivor_size;
145   }
146 
147   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
148                                      _gen_counters);
149   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
150                                      _gen_counters);
151   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
152                                    _gen_counters);
153 
154   compute_initial_space_boundaries();
155 }
156 
157 void PSYoungGen::compute_initial_space_boundaries() {
<span class="line-removed">158   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">159 </span>
160   // Compute sizes
<span class="line-removed">161   size_t alignment = heap-&gt;space_alignment();</span>
162   size_t size = virtual_space()-&gt;committed_size();
<span class="line-modified">163   assert(size &gt;= 3 * alignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);</span>
164 
165   size_t survivor_size = size / InitialSurvivorRatio;
<span class="line-modified">166   survivor_size = align_down(survivor_size, alignment);</span>
167   // ... but never less than an alignment
<span class="line-modified">168   survivor_size = MAX2(survivor_size, alignment);</span>
169 
170   // Young generation is eden + 2 survivor spaces
171   size_t eden_size = size - (2 * survivor_size);
172 
173   // Now go ahead and set &#39;em.
174   set_space_boundaries(eden_size, survivor_size);
175   space_invariants();
176 
177   if (UsePerfData) {
178     _eden_counters-&gt;update_capacity();
179     _from_counters-&gt;update_capacity();
180     _to_counters-&gt;update_capacity();
181   }
182 }
183 
184 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
185   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
186   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
187 
188   // Initial layout is Eden, to, from. After swapping survivor spaces,
</pre>
<hr />
<pre>
192   char *to_start   = eden_start + eden_size;
193   char *from_start = to_start   + survivor_size;
194   char *from_end   = from_start + survivor_size;
195 
196   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
197   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
198   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
199   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
200 
201   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
202   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
203   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
204 
205   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
206     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
207   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
208 }
209 
210 #ifndef PRODUCT
211 void PSYoungGen::space_invariants() {
<span class="line-removed">212   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">213   const size_t alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">214 </span>
215   // Currently, our eden size cannot shrink to zero
<span class="line-modified">216   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;eden too small&quot;);</span>
<span class="line-modified">217   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;from too small&quot;);</span>
<span class="line-modified">218   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;to too small&quot;);</span>
219 
220   // Relationship of spaces to each other
221   char* eden_start = (char*)eden_space()-&gt;bottom();
222   char* eden_end   = (char*)eden_space()-&gt;end();
223   char* from_start = (char*)from_space()-&gt;bottom();
224   char* from_end   = (char*)from_space()-&gt;end();
225   char* to_start   = (char*)to_space()-&gt;bottom();
226   char* to_end     = (char*)to_space()-&gt;end();
227 
228   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
229   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
230   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
231   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
232 
233   // Check whether from space is below to space
234   if (from_start &lt; to_start) {
235     // Eden, from, to
236     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
237     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
238     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
</pre>
<hr />
<pre>
279   }
280 }
281 
282 
283 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
284   const size_t alignment = virtual_space()-&gt;alignment();
285   size_t orig_size = virtual_space()-&gt;committed_size();
286   bool size_changed = false;
287 
288   // There used to be this guarantee there.
289   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);
290   // Code below forces this requirement.  In addition the desired eden
291   // size and desired survivor sizes are desired goals and may
292   // exceed the total generation size.
293 
294   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
295 
296   // Adjust new generation size
297   const size_t eden_plus_survivors =
298           align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">299   size_t desired_size = MAX2(MIN2(eden_plus_survivors, max_size()),</span>
<span class="line-removed">300                              min_gen_size());</span>
301   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
302 
303   if (desired_size &gt; orig_size) {
304     // Grow the generation
305     size_t change = desired_size - orig_size;
306     assert(change % alignment == 0, &quot;just checking&quot;);
307     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
308     if (!virtual_space()-&gt;expand_by(change)) {
309       return false; // Error if we fail to resize!
310     }
311     if (ZapUnusedHeapArea) {
312       // Mangle newly committed space immediately because it
313       // can be done here more simply that after the new
314       // spaces have been computed.
315       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
316       MemRegion mangle_region(prev_high, new_high);
317       SpaceMangler::mangle_region(mangle_region);
318     }
319     size_changed = true;
320   } else if (desired_size &lt; orig_size) {
</pre>
<hr />
<pre>
455                       p2i(to_space()-&gt;end()),
456                       pointer_delta(  to_space()-&gt;end(),
457                                       to_space()-&gt;bottom(),
458                                       sizeof(char)));
459 
460   // There&#39;s nothing to do if the new sizes are the same as the current
461   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
462       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
463       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
464     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
465     return;
466   }
467 
468   char* eden_start = (char*)eden_space()-&gt;bottom();
469   char* eden_end   = (char*)eden_space()-&gt;end();
470   char* from_start = (char*)from_space()-&gt;bottom();
471   char* from_end   = (char*)from_space()-&gt;end();
472   char* to_start   = (char*)to_space()-&gt;bottom();
473   char* to_end     = (char*)to_space()-&gt;end();
474 
<span class="line-removed">475   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">476   const size_t alignment = heap-&gt;space_alignment();</span>
477   const bool maintain_minimum =
478     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
479 
480   bool eden_from_to_order = from_start &lt; to_start;
481   // Check whether from space is below to space
482   if (eden_from_to_order) {
483     // Eden, from, to
484     eden_from_to_order = true;
485     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
486 
487     // Set eden
488     // &quot;requested_eden_size&quot; is a goal for the size of eden
489     // and may not be attainable.  &quot;eden_size&quot; below is
490     // calculated based on the location of from-space and
491     // the goal for the size of eden.  from-space is
492     // fixed in place because it contains live data.
493     // The calculation is done this way to avoid 32bit
494     // overflow (i.e., eden_start + requested_eden_size
495     // may too large for representation in 32bits).
496     size_t eden_size;
</pre>
<hr />
<pre>
510 
511     eden_end = eden_start + eden_size;
512     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
513 
514     // To may resize into from space as long as it is clear of live data.
515     // From space must remain page aligned, though, so we need to do some
516     // extra calculations.
517 
518     // First calculate an optimal to-space
519     to_end   = (char*)virtual_space()-&gt;high();
520     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
521                                     sizeof(char));
522 
523     // Does the optimal to-space overlap from-space?
524     if (to_start &lt; (char*)from_space()-&gt;end()) {
525       // Calculate the minimum offset possible for from_end
526       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
527 
528       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
529       if (from_size == 0) {
<span class="line-modified">530         from_size = alignment;</span>
531       } else {
<span class="line-modified">532         from_size = align_up(from_size, alignment);</span>
533       }
534 
535       from_end = from_start + from_size;
536       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
537 
538       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
539 
540       // Now update to_start with the new from_end
541       to_start = MAX2(from_end, to_start);
542     }
543 
544     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
545 
546     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
547                         p2i(eden_start),
548                         p2i(eden_end),
549                         pointer_delta(eden_end, eden_start, sizeof(char)));
550     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
551                         p2i(from_start),
552                         p2i(from_end),
</pre>
<hr />
<pre>
555                         p2i(to_start),
556                         p2i(to_end),
557                         pointer_delta(  to_end,   to_start, sizeof(char)));
558   } else {
559     // Eden, to, from
560     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
561 
562     // To space gets priority over eden resizing. Note that we position
563     // to space as if we were able to resize from space, even though from
564     // space is not modified.
565     // Giving eden priority was tried and gave poorer performance.
566     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
567                                     (char*)requested_survivor_size,
568                                     sizeof(char));
569     to_end   = MIN2(to_end, from_start);
570     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
571                                     sizeof(char));
572     // if the space sizes are to be increased by several times then
573     // &#39;to_start&#39; will point beyond the young generation. In this case
574     // &#39;to_start&#39; should be adjusted.
<span class="line-modified">575     to_start = MAX2(to_start, eden_start + alignment);</span>
576 
577     // Compute how big eden can be, then adjust end.
578     // See  comments above on calculating eden_end.
579     size_t eden_size;
580     if (maintain_minimum) {
581       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
582     } else {
583       eden_size = MIN2(requested_eden_size,
584                        pointer_delta(to_start, eden_start, sizeof(char)));
585     }
586     eden_end = eden_start + eden_size;
587     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
588 
589     // Could choose to not let eden shrink
590     // to_start = MAX2(to_start, eden_end);
591 
592     // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">593     eden_end = MAX2(eden_end, eden_start + alignment);</span>
594     to_start = MAX2(to_start, eden_end);
595 
596     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
597                         p2i(eden_start),
598                         p2i(eden_end),
599                         pointer_delta(eden_end, eden_start, sizeof(char)));
600     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
601                         p2i(to_start),
602                         p2i(to_end),
603                         pointer_delta(  to_end,   to_start, sizeof(char)));
604     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
605                         p2i(from_start),
606                         p2i(from_end),
607                         pointer_delta(from_end, from_start, sizeof(char)));
608   }
609 
610 
611   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
612             &quot;from start moved to the right&quot;);
613   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
</pre>
<hr />
<pre>
663     to_space()-&gt;initialize(toMR,
664                            SpaceDecorator::Clear,
665                            SpaceDecorator::DontMangle);
666   from_space()-&gt;initialize(fromMR,
667                            SpaceDecorator::DontClear,
668                            SpaceDecorator::DontMangle);
669 
670   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
671 
672   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
673                       ParallelScavengeHeap::heap()-&gt;total_collections(),
674                       old_from, old_to,
675                       from_space()-&gt;capacity_in_bytes(),
676                       to_space()-&gt;capacity_in_bytes());
677 }
678 
679 void PSYoungGen::swap_spaces() {
680   MutableSpace* s    = from_space();
681   _from_space        = to_space();
682   _to_space          = s;
<span class="line-removed">683 </span>
<span class="line-removed">684   // Now update the decorators.</span>
<span class="line-removed">685   PSMarkSweepDecorator* md = from_mark_sweep();</span>
<span class="line-removed">686   _from_mark_sweep           = to_mark_sweep();</span>
<span class="line-removed">687   _to_mark_sweep             = md;</span>
<span class="line-removed">688 </span>
<span class="line-removed">689   assert(from_mark_sweep()-&gt;space() == from_space(), &quot;Sanity&quot;);</span>
<span class="line-removed">690   assert(to_mark_sweep()-&gt;space() == to_space(), &quot;Sanity&quot;);</span>
691 }
692 
693 size_t PSYoungGen::capacity_in_bytes() const {
694   return eden_space()-&gt;capacity_in_bytes()
695        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
696 }
697 
698 
699 size_t PSYoungGen::used_in_bytes() const {
700   return eden_space()-&gt;used_in_bytes()
701        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
702 }
703 
704 
705 size_t PSYoungGen::free_in_bytes() const {
706   return eden_space()-&gt;free_in_bytes()
707        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
708 }
709 
710 size_t PSYoungGen::capacity_in_words() const {
</pre>
<hr />
<pre>
713 }
714 
715 
716 size_t PSYoungGen::used_in_words() const {
717   return eden_space()-&gt;used_in_words()
718        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
719 }
720 
721 
722 size_t PSYoungGen::free_in_words() const {
723   return eden_space()-&gt;free_in_words()
724        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
725 }
726 
727 void PSYoungGen::object_iterate(ObjectClosure* blk) {
728   eden_space()-&gt;object_iterate(blk);
729   from_space()-&gt;object_iterate(blk);
730   to_space()-&gt;object_iterate(blk);
731 }
732 
<span class="line-removed">733 #if INCLUDE_SERIALGC</span>
<span class="line-removed">734 </span>
<span class="line-removed">735 void PSYoungGen::precompact() {</span>
<span class="line-removed">736   eden_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">737   from_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">738   to_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">739 }</span>
<span class="line-removed">740 </span>
<span class="line-removed">741 void PSYoungGen::adjust_pointers() {</span>
<span class="line-removed">742   eden_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">743   from_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">744   to_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">745 }</span>
<span class="line-removed">746 </span>
<span class="line-removed">747 void PSYoungGen::compact() {</span>
<span class="line-removed">748   eden_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">749   from_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">750   // Mark sweep stores preserved markOops in to space, don&#39;t disturb!</span>
<span class="line-removed">751   to_mark_sweep()-&gt;compact(false);</span>
<span class="line-removed">752 }</span>
<span class="line-removed">753 </span>
<span class="line-removed">754 #endif // INCLUDE_SERIALGC</span>
<span class="line-removed">755 </span>
756 void PSYoungGen::print() const { print_on(tty); }
757 void PSYoungGen::print_on(outputStream* st) const {
758   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
759   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
760              capacity_in_bytes()/K, used_in_bytes()/K);
761   virtual_space()-&gt;print_space_boundaries_on(st);
762   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
763   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
764   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
765 }
766 
<span class="line-removed">767 // Note that a space is not printed before the [NAME:</span>
<span class="line-removed">768 void PSYoungGen::print_used_change(size_t prev_used) const {</span>
<span class="line-removed">769   log_info(gc, heap)(&quot;%s: &quot;  SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-removed">770       name(), prev_used / K, used_in_bytes() / K, capacity_in_bytes() / K);</span>
<span class="line-removed">771 }</span>
<span class="line-removed">772 </span>
773 size_t PSYoungGen::available_for_expansion() {
774   ShouldNotReachHere();
775   return 0;
776 }
777 
778 size_t PSYoungGen::available_for_contraction() {
779   ShouldNotReachHere();
780   return 0;
781 }
782 
783 size_t PSYoungGen::available_to_min_gen() {
784   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
785   return virtual_space()-&gt;committed_size() - min_gen_size();
786 }
787 
788 // This method assumes that from-space has live data and that
789 // any shrinkage of the young gen is limited by location of
790 // from-space.
791 size_t PSYoungGen::available_to_live() {
792   size_t delta_in_survivor = 0;
<span class="line-removed">793   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">794   const size_t space_alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">795   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
<span class="line-removed">796 </span>
797   MutableSpace* space_shrinking = NULL;
798   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
799     space_shrinking = from_space();
800   } else {
801     space_shrinking = to_space();
802   }
803 
804   // Include any space that is committed but not included in
805   // the survivor spaces.
806   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
807     &quot;Survivor space beyond high end&quot;);
808   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
809     space_shrinking-&gt;end(), sizeof(char));
810 
811   if (space_shrinking-&gt;is_empty()) {
812     // Don&#39;t let the space shrink to 0
<span class="line-modified">813     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= space_alignment,</span>
814       &quot;Space is too small&quot;);
<span class="line-modified">815     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - space_alignment;</span>
816   } else {
817     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
818                                       space_shrinking-&gt;top(),
819                                       sizeof(char));
820   }
821 
822   size_t delta_in_bytes = unused_committed + delta_in_survivor;
<span class="line-modified">823   delta_in_bytes = align_down(delta_in_bytes, gen_alignment);</span>
824   return delta_in_bytes;
825 }
826 
827 // Return the number of bytes available for resizing down the young
828 // generation.  This is the minimum of
829 //      input &quot;bytes&quot;
830 //      bytes to the minimum young gen size
831 //      bytes to the size currently being used + some small extra
832 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
833   // Allow shrinkage into the current eden but keep eden large enough
834   // to maintain the minimum young gen size
835   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
836   return align_down(bytes, virtual_space()-&gt;alignment());
837 }
838 
839 void PSYoungGen::reset_after_change() {
840   ShouldNotReachHere();
841 }
842 
843 void PSYoungGen::reset_survivors_after_shrink() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;

 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified"> 31 #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
<span class="line-modified"> 38 PSYoungGen::PSYoungGen(size_t initial_size, size_t min_size, size_t max_size) :</span>
<span class="line-modified"> 39   _reserved(),</span>
<span class="line-modified"> 40   _virtual_space(NULL),</span>
<span class="line-added"> 41   _eden_space(NULL),</span>
<span class="line-added"> 42   _from_space(NULL),</span>
<span class="line-added"> 43   _to_space(NULL),</span>
 44   _init_gen_size(initial_size),
 45   _min_gen_size(min_size),
<span class="line-modified"> 46   _max_gen_size(max_size),</span>
<span class="line-added"> 47   _gen_counters(NULL),</span>
<span class="line-added"> 48   _eden_counters(NULL),</span>
<span class="line-added"> 49   _from_counters(NULL),</span>
<span class="line-added"> 50   _to_counters(NULL)</span>
 51 {}
 52 
 53 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 54   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 55   _virtual_space = new PSVirtualSpace(rs, alignment);
 56   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {
 57     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 58                                   &quot;object heap&quot;);
 59   }
 60 }
 61 
 62 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 63   initialize_virtual_space(rs, alignment);
 64   initialize_work();
 65 }
 66 
 67 void PSYoungGen::initialize_work() {
 68 
 69   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 70                         (HeapWord*)virtual_space()-&gt;high_boundary());
 71 
 72   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 73                 (HeapWord*)virtual_space()-&gt;high());
 74   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 75 
 76   if (ZapUnusedHeapArea) {
 77     // Mangle newly committed space immediately because it
 78     // can be done here more simply that after the new
 79     // spaces have been computed.
 80     SpaceMangler::mangle_region(cmr);
 81   }
 82 
 83   if (UseNUMA) {
 84     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 85   } else {
 86     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 87   }
 88   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 89   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 90 



















 91   // Generation Counters - generation 0, 3 subspaces
 92   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
 93                                            _max_gen_size, _virtual_space);
 94 
 95   // Compute maximum space sizes for performance counters
<span class="line-modified"> 96   size_t alignment = SpaceAlignment;</span>

 97   size_t size = virtual_space()-&gt;reserved_size();
 98 
 99   size_t max_survivor_size;
100   size_t max_eden_size;
101 
102   if (UseAdaptiveSizePolicy) {
103     max_survivor_size = size / MinSurvivorRatio;
104 
105     // round the survivor space size down to the nearest alignment
106     // and make sure its size is greater than 0.
107     max_survivor_size = align_down(max_survivor_size, alignment);
108     max_survivor_size = MAX2(max_survivor_size, alignment);
109 
110     // set the maximum size of eden to be the size of the young gen
111     // less two times the minimum survivor size. The minimum survivor
112     // size for UseAdaptiveSizePolicy is one alignment.
113     max_eden_size = size - 2 * alignment;
114   } else {
115     max_survivor_size = size / InitialSurvivorRatio;
116 
</pre>
<hr />
<pre>
125     // is dependent on the committed portion (current capacity) of the
126     // generation - the less space committed, the smaller the survivor
127     // space, possibly as small as an alignment. However, we are interested
128     // in the case where the young generation is 100% committed, as this
129     // is the point where eden reaches its maximum size. At this point,
130     // the size of a survivor space is max_survivor_size.
131     max_eden_size = size - 2 * max_survivor_size;
132   }
133 
134   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
135                                      _gen_counters);
136   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
137                                      _gen_counters);
138   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
139                                    _gen_counters);
140 
141   compute_initial_space_boundaries();
142 }
143 
144 void PSYoungGen::compute_initial_space_boundaries() {


145   // Compute sizes

146   size_t size = virtual_space()-&gt;committed_size();
<span class="line-modified">147   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);</span>
148 
149   size_t survivor_size = size / InitialSurvivorRatio;
<span class="line-modified">150   survivor_size = align_down(survivor_size, SpaceAlignment);</span>
151   // ... but never less than an alignment
<span class="line-modified">152   survivor_size = MAX2(survivor_size, SpaceAlignment);</span>
153 
154   // Young generation is eden + 2 survivor spaces
155   size_t eden_size = size - (2 * survivor_size);
156 
157   // Now go ahead and set &#39;em.
158   set_space_boundaries(eden_size, survivor_size);
159   space_invariants();
160 
161   if (UsePerfData) {
162     _eden_counters-&gt;update_capacity();
163     _from_counters-&gt;update_capacity();
164     _to_counters-&gt;update_capacity();
165   }
166 }
167 
168 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
169   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
170   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
171 
172   // Initial layout is Eden, to, from. After swapping survivor spaces,
</pre>
<hr />
<pre>
176   char *to_start   = eden_start + eden_size;
177   char *from_start = to_start   + survivor_size;
178   char *from_end   = from_start + survivor_size;
179 
180   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
181   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
182   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
183   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
184 
185   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
186   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
187   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
188 
189   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
190     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
191   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
192 }
193 
194 #ifndef PRODUCT
195 void PSYoungGen::space_invariants() {



196   // Currently, our eden size cannot shrink to zero
<span class="line-modified">197   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);</span>
<span class="line-modified">198   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);</span>
<span class="line-modified">199   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);</span>
200 
201   // Relationship of spaces to each other
202   char* eden_start = (char*)eden_space()-&gt;bottom();
203   char* eden_end   = (char*)eden_space()-&gt;end();
204   char* from_start = (char*)from_space()-&gt;bottom();
205   char* from_end   = (char*)from_space()-&gt;end();
206   char* to_start   = (char*)to_space()-&gt;bottom();
207   char* to_end     = (char*)to_space()-&gt;end();
208 
209   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
210   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
211   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
212   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
213 
214   // Check whether from space is below to space
215   if (from_start &lt; to_start) {
216     // Eden, from, to
217     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
218     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
219     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
</pre>
<hr />
<pre>
260   }
261 }
262 
263 
264 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
265   const size_t alignment = virtual_space()-&gt;alignment();
266   size_t orig_size = virtual_space()-&gt;committed_size();
267   bool size_changed = false;
268 
269   // There used to be this guarantee there.
270   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);
271   // Code below forces this requirement.  In addition the desired eden
272   // size and desired survivor sizes are desired goals and may
273   // exceed the total generation size.
274 
275   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
276 
277   // Adjust new generation size
278   const size_t eden_plus_survivors =
279           align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">280   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());</span>

281   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
282 
283   if (desired_size &gt; orig_size) {
284     // Grow the generation
285     size_t change = desired_size - orig_size;
286     assert(change % alignment == 0, &quot;just checking&quot;);
287     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
288     if (!virtual_space()-&gt;expand_by(change)) {
289       return false; // Error if we fail to resize!
290     }
291     if (ZapUnusedHeapArea) {
292       // Mangle newly committed space immediately because it
293       // can be done here more simply that after the new
294       // spaces have been computed.
295       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
296       MemRegion mangle_region(prev_high, new_high);
297       SpaceMangler::mangle_region(mangle_region);
298     }
299     size_changed = true;
300   } else if (desired_size &lt; orig_size) {
</pre>
<hr />
<pre>
435                       p2i(to_space()-&gt;end()),
436                       pointer_delta(  to_space()-&gt;end(),
437                                       to_space()-&gt;bottom(),
438                                       sizeof(char)));
439 
440   // There&#39;s nothing to do if the new sizes are the same as the current
441   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
442       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
443       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
444     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
445     return;
446   }
447 
448   char* eden_start = (char*)eden_space()-&gt;bottom();
449   char* eden_end   = (char*)eden_space()-&gt;end();
450   char* from_start = (char*)from_space()-&gt;bottom();
451   char* from_end   = (char*)from_space()-&gt;end();
452   char* to_start   = (char*)to_space()-&gt;bottom();
453   char* to_end     = (char*)to_space()-&gt;end();
454 


455   const bool maintain_minimum =
456     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
457 
458   bool eden_from_to_order = from_start &lt; to_start;
459   // Check whether from space is below to space
460   if (eden_from_to_order) {
461     // Eden, from, to
462     eden_from_to_order = true;
463     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
464 
465     // Set eden
466     // &quot;requested_eden_size&quot; is a goal for the size of eden
467     // and may not be attainable.  &quot;eden_size&quot; below is
468     // calculated based on the location of from-space and
469     // the goal for the size of eden.  from-space is
470     // fixed in place because it contains live data.
471     // The calculation is done this way to avoid 32bit
472     // overflow (i.e., eden_start + requested_eden_size
473     // may too large for representation in 32bits).
474     size_t eden_size;
</pre>
<hr />
<pre>
488 
489     eden_end = eden_start + eden_size;
490     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
491 
492     // To may resize into from space as long as it is clear of live data.
493     // From space must remain page aligned, though, so we need to do some
494     // extra calculations.
495 
496     // First calculate an optimal to-space
497     to_end   = (char*)virtual_space()-&gt;high();
498     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
499                                     sizeof(char));
500 
501     // Does the optimal to-space overlap from-space?
502     if (to_start &lt; (char*)from_space()-&gt;end()) {
503       // Calculate the minimum offset possible for from_end
504       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
505 
506       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
507       if (from_size == 0) {
<span class="line-modified">508         from_size = SpaceAlignment;</span>
509       } else {
<span class="line-modified">510         from_size = align_up(from_size, SpaceAlignment);</span>
511       }
512 
513       from_end = from_start + from_size;
514       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
515 
516       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
517 
518       // Now update to_start with the new from_end
519       to_start = MAX2(from_end, to_start);
520     }
521 
522     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
523 
524     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
525                         p2i(eden_start),
526                         p2i(eden_end),
527                         pointer_delta(eden_end, eden_start, sizeof(char)));
528     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
529                         p2i(from_start),
530                         p2i(from_end),
</pre>
<hr />
<pre>
533                         p2i(to_start),
534                         p2i(to_end),
535                         pointer_delta(  to_end,   to_start, sizeof(char)));
536   } else {
537     // Eden, to, from
538     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
539 
540     // To space gets priority over eden resizing. Note that we position
541     // to space as if we were able to resize from space, even though from
542     // space is not modified.
543     // Giving eden priority was tried and gave poorer performance.
544     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
545                                     (char*)requested_survivor_size,
546                                     sizeof(char));
547     to_end   = MIN2(to_end, from_start);
548     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
549                                     sizeof(char));
550     // if the space sizes are to be increased by several times then
551     // &#39;to_start&#39; will point beyond the young generation. In this case
552     // &#39;to_start&#39; should be adjusted.
<span class="line-modified">553     to_start = MAX2(to_start, eden_start + SpaceAlignment);</span>
554 
555     // Compute how big eden can be, then adjust end.
556     // See  comments above on calculating eden_end.
557     size_t eden_size;
558     if (maintain_minimum) {
559       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
560     } else {
561       eden_size = MIN2(requested_eden_size,
562                        pointer_delta(to_start, eden_start, sizeof(char)));
563     }
564     eden_end = eden_start + eden_size;
565     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
566 
567     // Could choose to not let eden shrink
568     // to_start = MAX2(to_start, eden_end);
569 
570     // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">571     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);</span>
572     to_start = MAX2(to_start, eden_end);
573 
574     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
575                         p2i(eden_start),
576                         p2i(eden_end),
577                         pointer_delta(eden_end, eden_start, sizeof(char)));
578     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
579                         p2i(to_start),
580                         p2i(to_end),
581                         pointer_delta(  to_end,   to_start, sizeof(char)));
582     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
583                         p2i(from_start),
584                         p2i(from_end),
585                         pointer_delta(from_end, from_start, sizeof(char)));
586   }
587 
588 
589   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
590             &quot;from start moved to the right&quot;);
591   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
</pre>
<hr />
<pre>
641     to_space()-&gt;initialize(toMR,
642                            SpaceDecorator::Clear,
643                            SpaceDecorator::DontMangle);
644   from_space()-&gt;initialize(fromMR,
645                            SpaceDecorator::DontClear,
646                            SpaceDecorator::DontMangle);
647 
648   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
649 
650   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
651                       ParallelScavengeHeap::heap()-&gt;total_collections(),
652                       old_from, old_to,
653                       from_space()-&gt;capacity_in_bytes(),
654                       to_space()-&gt;capacity_in_bytes());
655 }
656 
657 void PSYoungGen::swap_spaces() {
658   MutableSpace* s    = from_space();
659   _from_space        = to_space();
660   _to_space          = s;








661 }
662 
663 size_t PSYoungGen::capacity_in_bytes() const {
664   return eden_space()-&gt;capacity_in_bytes()
665        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
666 }
667 
668 
669 size_t PSYoungGen::used_in_bytes() const {
670   return eden_space()-&gt;used_in_bytes()
671        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
672 }
673 
674 
675 size_t PSYoungGen::free_in_bytes() const {
676   return eden_space()-&gt;free_in_bytes()
677        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
678 }
679 
680 size_t PSYoungGen::capacity_in_words() const {
</pre>
<hr />
<pre>
683 }
684 
685 
686 size_t PSYoungGen::used_in_words() const {
687   return eden_space()-&gt;used_in_words()
688        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
689 }
690 
691 
692 size_t PSYoungGen::free_in_words() const {
693   return eden_space()-&gt;free_in_words()
694        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
695 }
696 
697 void PSYoungGen::object_iterate(ObjectClosure* blk) {
698   eden_space()-&gt;object_iterate(blk);
699   from_space()-&gt;object_iterate(blk);
700   to_space()-&gt;object_iterate(blk);
701 }
702 























703 void PSYoungGen::print() const { print_on(tty); }
704 void PSYoungGen::print_on(outputStream* st) const {
705   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
706   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
707              capacity_in_bytes()/K, used_in_bytes()/K);
708   virtual_space()-&gt;print_space_boundaries_on(st);
709   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
710   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
711   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
712 }
713 






714 size_t PSYoungGen::available_for_expansion() {
715   ShouldNotReachHere();
716   return 0;
717 }
718 
719 size_t PSYoungGen::available_for_contraction() {
720   ShouldNotReachHere();
721   return 0;
722 }
723 
724 size_t PSYoungGen::available_to_min_gen() {
725   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
726   return virtual_space()-&gt;committed_size() - min_gen_size();
727 }
728 
729 // This method assumes that from-space has live data and that
730 // any shrinkage of the young gen is limited by location of
731 // from-space.
732 size_t PSYoungGen::available_to_live() {
733   size_t delta_in_survivor = 0;




734   MutableSpace* space_shrinking = NULL;
735   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
736     space_shrinking = from_space();
737   } else {
738     space_shrinking = to_space();
739   }
740 
741   // Include any space that is committed but not included in
742   // the survivor spaces.
743   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
744     &quot;Survivor space beyond high end&quot;);
745   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
746     space_shrinking-&gt;end(), sizeof(char));
747 
748   if (space_shrinking-&gt;is_empty()) {
749     // Don&#39;t let the space shrink to 0
<span class="line-modified">750     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,</span>
751       &quot;Space is too small&quot;);
<span class="line-modified">752     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;</span>
753   } else {
754     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
755                                       space_shrinking-&gt;top(),
756                                       sizeof(char));
757   }
758 
759   size_t delta_in_bytes = unused_committed + delta_in_survivor;
<span class="line-modified">760   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);</span>
761   return delta_in_bytes;
762 }
763 
764 // Return the number of bytes available for resizing down the young
765 // generation.  This is the minimum of
766 //      input &quot;bytes&quot;
767 //      bytes to the minimum young gen size
768 //      bytes to the size currently being used + some small extra
769 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
770   // Allow shrinkage into the current eden but keep eden large enough
771   // to maintain the minimum young gen size
772   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
773   return align_down(bytes, virtual_space()-&gt;alignment());
774 }
775 
776 void PSYoungGen::reset_after_change() {
777   ShouldNotReachHere();
778 }
779 
780 void PSYoungGen::reset_survivors_after_shrink() {
</pre>
</td>
</tr>
</table>
<center><a href="psVirtualspace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
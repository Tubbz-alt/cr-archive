<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
 29 #include &quot;gc/parallel/generationSizer.hpp&quot;
 30 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;utilities/align.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 
 37 // If boundary moving is being used, create the young gen and old
 38 // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
 39 // the old behavior otherwise (with PSYoungGen and PSOldGen).
 40 
 41 AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs,
 42                                            GenerationSizer* policy,
 43                                            size_t alignment) :
 44   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, policy-&gt;min_old_size(),
 45                                              policy-&gt;min_young_size(), alignment)) {
 46   size_t init_low_byte_size = policy-&gt;initial_old_size();
 47   size_t min_low_byte_size = policy-&gt;min_old_size();
 48   size_t max_low_byte_size = policy-&gt;max_old_size();
 49   size_t init_high_byte_size = policy-&gt;initial_young_size();
 50   size_t min_high_byte_size = policy-&gt;min_young_size();
 51   size_t max_high_byte_size = policy-&gt;max_young_size();
 52 
 53   assert(min_low_byte_size &lt;= init_low_byte_size &amp;&amp;
 54          init_low_byte_size &lt;= max_low_byte_size, &quot;Parameter check&quot;);
 55   assert(min_high_byte_size &lt;= init_high_byte_size &amp;&amp;
 56          init_high_byte_size &lt;= max_high_byte_size, &quot;Parameter check&quot;);
 57   // Create the generations differently based on the option to
 58   // move the boundary.
 59   if (UseAdaptiveGCBoundary) {
 60     // Initialize the adjoining virtual spaces.  Then pass the
 61     // a virtual to each generation for initialization of the
 62     // generation.
 63 
 64     // Does the actual creation of the virtual spaces
 65     _virtual_spaces-&gt;initialize(max_low_byte_size,
 66                                 init_low_byte_size,
 67                                 init_high_byte_size);
 68 
 69     // Place the young gen at the high end.  Passes in the virtual space.
 70     _young_gen = new ASPSYoungGen(_virtual_spaces-&gt;high(),
 71                                   _virtual_spaces-&gt;high()-&gt;committed_size(),
 72                                   min_high_byte_size,
 73                                   _virtual_spaces-&gt;high_byte_size_limit());
 74 
 75     // Place the old gen at the low end. Passes in the virtual space.
 76     _old_gen = new ASPSOldGen(_virtual_spaces-&gt;low(),
 77                               _virtual_spaces-&gt;low()-&gt;committed_size(),
 78                               min_low_byte_size,
 79                               _virtual_spaces-&gt;low_byte_size_limit(),
 80                               &quot;old&quot;, 1);
 81 
 82     young_gen()-&gt;initialize_work();
 83     assert(young_gen()-&gt;reserved().byte_size() &lt;= young_gen()-&gt;gen_size_limit(),
 84      &quot;Consistency check&quot;);
 85     assert(old_young_rs.size() &gt;= young_gen()-&gt;gen_size_limit(),
 86      &quot;Consistency check&quot;);
 87 
 88     old_gen()-&gt;initialize_work(&quot;old&quot;, 1);
 89     assert(old_gen()-&gt;reserved().byte_size() &lt;= old_gen()-&gt;gen_size_limit(),
 90      &quot;Consistency check&quot;);
 91     assert(old_young_rs.size() &gt;= old_gen()-&gt;gen_size_limit(),
 92      &quot;Consistency check&quot;);
 93   } else {
 94 
 95     // Layout the reserved space for the generations.
 96     // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
 97     ReservedSpace old_rs   =
 98       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, policy-&gt;is_hetero_heap() /* split */);
 99     ReservedSpace heap_rs  =
100       virtual_spaces()-&gt;reserved_space().last_part(max_low_byte_size);
101     ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
102     assert(young_rs.size() == heap_rs.size(), &quot;Didn&#39;t reserve all of the heap&quot;);
103 
104     // Create the generations.  Virtual spaces are not passed in.
105     _young_gen = new PSYoungGen(init_high_byte_size,
106                                 min_high_byte_size,
107                                 max_high_byte_size);
108     _old_gen = new PSOldGen(init_low_byte_size,
109                             min_low_byte_size,
110                             max_low_byte_size,
111                             &quot;old&quot;, 1);
112 
113     // The virtual spaces are created by the initialization of the gens.
114     _young_gen-&gt;initialize(young_rs, alignment);
115     assert(young_gen()-&gt;gen_size_limit() == young_rs.size(),
116       &quot;Consistency check&quot;);
117     _old_gen-&gt;initialize(old_rs, alignment, &quot;old&quot;, 1);
118     assert(old_gen()-&gt;gen_size_limit() == old_rs.size(), &quot;Consistency check&quot;);
119   }
120 }
121 
122 AdjoiningGenerations::AdjoiningGenerations() { }
123 
124 size_t AdjoiningGenerations::reserved_byte_size() {
125   return virtual_spaces()-&gt;reserved_space().size();
126 }
127 
128 void log_before_expansion(bool old, size_t expand_in_bytes, size_t change_in_bytes, size_t max_size) {
129   Log(gc, ergo, heap) log;
130   if (!log.is_debug()) {
131    return;
132   }
133   log.debug(&quot;Before expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
134   log.debug(&quot;  Requested change: &quot; SIZE_FORMAT_HEX &quot;  Attempted change: &quot; SIZE_FORMAT_HEX,
135                         expand_in_bytes, change_in_bytes);
136   ResourceMark rm;
137   LogStream ls(log.debug());
138   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
139   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
140 }
141 
142 void log_after_expansion(bool old, size_t max_size) {
143   Log(gc, ergo, heap) log;
144   if (!log.is_debug()) {
145    return;
146   }
147   log.debug(&quot;After expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
148   ResourceMark rm;
149   LogStream ls(log.debug());
150   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
151   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
152 }
153 
154 // Make checks on the current sizes of the generations and
155 // the constraints on the sizes of the generations.  Push
156 // up the boundary within the constraints.  A partial
157 // push can occur.
158 void AdjoiningGenerations::request_old_gen_expansion(size_t expand_in_bytes) {
159   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
160 
161   assert_lock_strong(ExpandHeap_lock);
162   assert_locked_or_safepoint(Heap_lock);
163 
164   // These sizes limit the amount the boundaries can move.  Effectively,
165   // the generation says how much it is willing to yield to the other
166   // generation.
167   const size_t young_gen_available = young_gen()-&gt;available_for_contraction();
168   const size_t old_gen_available = old_gen()-&gt;available_for_expansion();
169   const size_t alignment = virtual_spaces()-&gt;alignment();
170   size_t change_in_bytes = MIN3(young_gen_available,
171                                 old_gen_available,
172                                 align_up(expand_in_bytes, alignment));
173 
174   if (change_in_bytes == 0) {
175     return;
176   }
177 
178   log_before_expansion(true, expand_in_bytes, change_in_bytes, old_gen()-&gt;max_gen_size());
179 
180   // Move the boundary between the generations up (smaller young gen).
181   if (virtual_spaces()-&gt;adjust_boundary_up(change_in_bytes)) {
182     young_gen()-&gt;reset_after_change();
183     old_gen()-&gt;reset_after_change();
184   }
185 
186   // The total reserved for the generations should match the sum
187   // of the two even if the boundary is moving.
188   assert(reserved_byte_size() ==
189          old_gen()-&gt;max_gen_size() + young_gen()-&gt;max_size(),
190          &quot;Space is missing&quot;);
191   young_gen()-&gt;space_invariants();
192   old_gen()-&gt;space_invariants();
193 
194   log_after_expansion(true, old_gen()-&gt;max_gen_size());
195 }
196 
197 // See comments on request_old_gen_expansion()
198 bool AdjoiningGenerations::request_young_gen_expansion(size_t expand_in_bytes) {
199   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
200 
201   // If eden is not empty, the boundary can be moved but no advantage
202   // can be made of the move since eden cannot be moved.
203   if (!young_gen()-&gt;eden_space()-&gt;is_empty()) {
204     return false;
205   }
206 
207 
208   bool result = false;
209   const size_t young_gen_available = young_gen()-&gt;available_for_expansion();
210   const size_t old_gen_available = old_gen()-&gt;available_for_contraction();
211   const size_t alignment = virtual_spaces()-&gt;alignment();
212   size_t change_in_bytes = MIN3(young_gen_available,
213                                 old_gen_available,
214                                 align_up(expand_in_bytes, alignment));
215 
216   if (change_in_bytes == 0) {
217     return false;
218   }
219 
220   log_before_expansion(false, expand_in_bytes, change_in_bytes, young_gen()-&gt;max_size());
221 
222   // Move the boundary between the generations down (smaller old gen).
223   MutexLocker x(ExpandHeap_lock);
224   if (virtual_spaces()-&gt;adjust_boundary_down(change_in_bytes)) {
225     young_gen()-&gt;reset_after_change();
226     old_gen()-&gt;reset_after_change();
227     result = true;
228   }
229 
230   // The total reserved for the generations should match the sum
231   // of the two even if the boundary is moving.
232   assert(reserved_byte_size() ==
233          old_gen()-&gt;max_gen_size() + young_gen()-&gt;max_size(),
234          &quot;Space is missing&quot;);
235   young_gen()-&gt;space_invariants();
236   old_gen()-&gt;space_invariants();
237 
238   log_after_expansion(false, young_gen()-&gt;max_size());
239 
240   return result;
241 }
242 
243 // Additional space is needed in the old generation.  Try to move the boundary
244 // up to meet the need.  Moves boundary up only
245 void AdjoiningGenerations::adjust_boundary_for_old_gen_needs(
246   size_t desired_free_space) {
247   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
248 
249   // Stress testing.
250   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 1) {
251     MutexLocker x(ExpandHeap_lock);
252     request_old_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
253   }
254 
255   // Expand only if the entire generation is already committed.
256   if (old_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
257     if (old_gen()-&gt;free_in_bytes() &lt; desired_free_space) {
258       MutexLocker x(ExpandHeap_lock);
259       request_old_gen_expansion(desired_free_space);
260     }
261   }
262 }
263 
264 // See comment on adjust_boundary_for_old_gen_needss().
265 // Adjust boundary down only.
266 void AdjoiningGenerations::adjust_boundary_for_young_gen_needs(size_t eden_size,
267     size_t survivor_size) {
268 
269   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
270 
271   // Stress testing.
272   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 0) {
273     request_young_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
274     eden_size = young_gen()-&gt;eden_space()-&gt;capacity_in_bytes();
275   }
276 
277   // Expand only if the entire generation is already committed.
278   if (young_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
279     size_t desired_size = eden_size + 2 * survivor_size;
280     const size_t committed = young_gen()-&gt;virtual_space()-&gt;committed_size();
281     if (desired_size &gt; committed) {
282       request_young_gen_expansion(desired_size - committed);
283     }
284   }
285 }
286 
287 AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs,
288                                                                          GenerationSizer* policy,
289                                                                          size_t alignment) {
290   if (policy-&gt;is_hetero_heap() &amp;&amp; UseAdaptiveGCBoundary) {
291     return new AdjoiningGenerationsForHeteroHeap(old_young_rs, policy, alignment);
292   } else {
293     return new AdjoiningGenerations(old_young_rs, policy, alignment);
294   }
295 }
    </pre>
  </body>
</html>
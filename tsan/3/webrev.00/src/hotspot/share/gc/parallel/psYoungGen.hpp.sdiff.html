<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psYoungGen.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psYoungGen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="spaceCounters.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psYoungGen.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 26 #define SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 27 
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGenerationCounters.hpp&quot;
 31 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 32 #include &quot;gc/parallel/spaceCounters.hpp&quot;
 33 
<span class="line-removed"> 34 class PSMarkSweepDecorator;</span>
<span class="line-removed"> 35 </span>
 36 class PSYoungGen : public CHeapObj&lt;mtGC&gt; {
 37   friend class VMStructs;
 38   friend class ParallelScavengeHeap;
 39   friend class AdjoiningGenerations;
 40 
 41  protected:
 42   MemRegion       _reserved;
 43   PSVirtualSpace* _virtual_space;
 44 
 45   // Spaces
 46   MutableSpace* _eden_space;
 47   MutableSpace* _from_space;
 48   MutableSpace* _to_space;
 49 
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51   // MarkSweep Decorators</span>
<span class="line-removed"> 52   PSMarkSweepDecorator* _eden_mark_sweep;</span>
<span class="line-removed"> 53   PSMarkSweepDecorator* _from_mark_sweep;</span>
<span class="line-removed"> 54   PSMarkSweepDecorator* _to_mark_sweep;</span>
<span class="line-removed"> 55 </span>
 56   // Sizing information, in bytes, set in constructor
 57   const size_t _init_gen_size;
 58   const size_t _min_gen_size;
 59   const size_t _max_gen_size;
 60 
 61   // Performance counters
 62   PSGenerationCounters*     _gen_counters;
 63   SpaceCounters*            _eden_counters;
 64   SpaceCounters*            _from_counters;
 65   SpaceCounters*            _to_counters;
 66 
 67   // Initialize the space boundaries
 68   void compute_initial_space_boundaries();
 69 
 70   // Space boundary helper
 71   void set_space_boundaries(size_t eden_size, size_t survivor_size);
 72 
 73   virtual bool resize_generation(size_t eden_size, size_t survivor_size);
 74   virtual void resize_spaces(size_t eden_size, size_t survivor_size);
 75 
</pre>
<hr />
<pre>
101   virtual void initialize_virtual_space(ReservedSpace rs, size_t alignment);
102 
103   MemRegion reserved() const            { return _reserved; }
104 
105   bool is_in(const void* p) const   {
106       return _virtual_space-&gt;contains((void *)p);
107   }
108 
109   bool is_in_reserved(const void* p) const   {
110       return reserved().contains((void *)p);
111   }
112 
113   MutableSpace*   eden_space() const    { return _eden_space; }
114   MutableSpace*   from_space() const    { return _from_space; }
115   MutableSpace*   to_space() const      { return _to_space; }
116   PSVirtualSpace* virtual_space() const { return _virtual_space; }
117 
118   // For Adaptive size policy
119   size_t min_gen_size() { return _min_gen_size; }
120 
<span class="line-removed">121   // MarkSweep support</span>
<span class="line-removed">122   PSMarkSweepDecorator* eden_mark_sweep() const    { return _eden_mark_sweep; }</span>
<span class="line-removed">123   PSMarkSweepDecorator* from_mark_sweep() const    { return _from_mark_sweep; }</span>
<span class="line-removed">124   PSMarkSweepDecorator* to_mark_sweep() const      { return _to_mark_sweep;   }</span>
<span class="line-removed">125 </span>
<span class="line-removed">126 #if INCLUDE_SERIALGC</span>
<span class="line-removed">127   void precompact();</span>
<span class="line-removed">128   void adjust_pointers();</span>
<span class="line-removed">129   void compact();</span>
<span class="line-removed">130 #endif</span>
<span class="line-removed">131 </span>
132   // Called during/after GC
133   void swap_spaces();
134 
135   // Resize generation using suggested free space size and survivor size
136   // NOTE:  &quot;eden_size&quot; and &quot;survivor_size&quot; are suggestions only. Current
137   //        heap layout (particularly, live objects in from space) might
138   //        not allow us to use these values.
139   void resize(size_t eden_size, size_t survivor_size);
140 
141   // Size info
142   size_t capacity_in_bytes() const;
143   size_t used_in_bytes() const;
144   size_t free_in_bytes() const;
145 
146   size_t capacity_in_words() const;
147   size_t used_in_words() const;
148   size_t free_in_words() const;
149 
150   // The max this generation can grow to
151   size_t max_size() const { return _reserved.byte_size(); }
</pre>
<hr />
<pre>
163     HeapWord* result = eden_space()-&gt;cas_allocate(word_size);
164     return result;
165   }
166 
167   HeapWord* volatile* top_addr() const   { return eden_space()-&gt;top_addr(); }
168   HeapWord** end_addr() const   { return eden_space()-&gt;end_addr(); }
169 
170   // Iteration.
171   void oop_iterate(OopIterateClosure* cl);
172   void object_iterate(ObjectClosure* cl);
173 
174   virtual void reset_after_change();
175   virtual void reset_survivors_after_shrink();
176 
177   // Performance Counter support
178   void update_counters();
179 
180   // Debugging - do not use for time critical operations
181   void print() const;
182   void print_on(outputStream* st) const;
<span class="line-removed">183   void print_used_change(size_t prev_used) const;</span>
184   virtual const char* name() const { return &quot;PSYoungGen&quot;; }
185 
186   void verify();
187 
188   // Space boundary invariant checker
189   void space_invariants() PRODUCT_RETURN;
190 
191   // Helper for mangling survivor spaces.
192   void mangle_survivors(MutableSpace* s1,
193                         MemRegion s1MR,
194                         MutableSpace* s2,
195                         MemRegion s2MR) PRODUCT_RETURN;
196 
197   void record_spaces_top() PRODUCT_RETURN;
198 };
199 
200 #endif // SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 26 #define SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 27 
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGenerationCounters.hpp&quot;
 31 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 32 #include &quot;gc/parallel/spaceCounters.hpp&quot;
 33 


 34 class PSYoungGen : public CHeapObj&lt;mtGC&gt; {
 35   friend class VMStructs;
 36   friend class ParallelScavengeHeap;
 37   friend class AdjoiningGenerations;
 38 
 39  protected:
 40   MemRegion       _reserved;
 41   PSVirtualSpace* _virtual_space;
 42 
 43   // Spaces
 44   MutableSpace* _eden_space;
 45   MutableSpace* _from_space;
 46   MutableSpace* _to_space;
 47 






 48   // Sizing information, in bytes, set in constructor
 49   const size_t _init_gen_size;
 50   const size_t _min_gen_size;
 51   const size_t _max_gen_size;
 52 
 53   // Performance counters
 54   PSGenerationCounters*     _gen_counters;
 55   SpaceCounters*            _eden_counters;
 56   SpaceCounters*            _from_counters;
 57   SpaceCounters*            _to_counters;
 58 
 59   // Initialize the space boundaries
 60   void compute_initial_space_boundaries();
 61 
 62   // Space boundary helper
 63   void set_space_boundaries(size_t eden_size, size_t survivor_size);
 64 
 65   virtual bool resize_generation(size_t eden_size, size_t survivor_size);
 66   virtual void resize_spaces(size_t eden_size, size_t survivor_size);
 67 
</pre>
<hr />
<pre>
 93   virtual void initialize_virtual_space(ReservedSpace rs, size_t alignment);
 94 
 95   MemRegion reserved() const            { return _reserved; }
 96 
 97   bool is_in(const void* p) const   {
 98       return _virtual_space-&gt;contains((void *)p);
 99   }
100 
101   bool is_in_reserved(const void* p) const   {
102       return reserved().contains((void *)p);
103   }
104 
105   MutableSpace*   eden_space() const    { return _eden_space; }
106   MutableSpace*   from_space() const    { return _from_space; }
107   MutableSpace*   to_space() const      { return _to_space; }
108   PSVirtualSpace* virtual_space() const { return _virtual_space; }
109 
110   // For Adaptive size policy
111   size_t min_gen_size() { return _min_gen_size; }
112 











113   // Called during/after GC
114   void swap_spaces();
115 
116   // Resize generation using suggested free space size and survivor size
117   // NOTE:  &quot;eden_size&quot; and &quot;survivor_size&quot; are suggestions only. Current
118   //        heap layout (particularly, live objects in from space) might
119   //        not allow us to use these values.
120   void resize(size_t eden_size, size_t survivor_size);
121 
122   // Size info
123   size_t capacity_in_bytes() const;
124   size_t used_in_bytes() const;
125   size_t free_in_bytes() const;
126 
127   size_t capacity_in_words() const;
128   size_t used_in_words() const;
129   size_t free_in_words() const;
130 
131   // The max this generation can grow to
132   size_t max_size() const { return _reserved.byte_size(); }
</pre>
<hr />
<pre>
144     HeapWord* result = eden_space()-&gt;cas_allocate(word_size);
145     return result;
146   }
147 
148   HeapWord* volatile* top_addr() const   { return eden_space()-&gt;top_addr(); }
149   HeapWord** end_addr() const   { return eden_space()-&gt;end_addr(); }
150 
151   // Iteration.
152   void oop_iterate(OopIterateClosure* cl);
153   void object_iterate(ObjectClosure* cl);
154 
155   virtual void reset_after_change();
156   virtual void reset_survivors_after_shrink();
157 
158   // Performance Counter support
159   void update_counters();
160 
161   // Debugging - do not use for time critical operations
162   void print() const;
163   void print_on(outputStream* st) const;

164   virtual const char* name() const { return &quot;PSYoungGen&quot;; }
165 
166   void verify();
167 
168   // Space boundary invariant checker
169   void space_invariants() PRODUCT_RETURN;
170 
171   // Helper for mangling survivor spaces.
172   void mangle_survivors(MutableSpace* s1,
173                         MemRegion s1MR,
174                         MutableSpace* s2,
175                         MemRegion s2MR) PRODUCT_RETURN;
176 
177   void record_spaces_top() PRODUCT_RETURN;
178 };
179 
180 #endif // SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
</pre>
</td>
</tr>
</table>
<center><a href="psYoungGen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="spaceCounters.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
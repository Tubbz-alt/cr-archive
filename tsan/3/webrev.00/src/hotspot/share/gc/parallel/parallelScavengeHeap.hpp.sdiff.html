<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parallelScavengeHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 26 #define SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 27 
<span class="line-removed"> 28 #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGCAdaptivePolicyCounters.hpp&quot;
 31 #include &quot;gc/parallel/psOldGen.hpp&quot;
 32 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-removed"> 35 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 36 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
 37 #include &quot;gc/shared/gcWhen.hpp&quot;


 38 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 39 #include &quot;gc/shared/strongRootsScope.hpp&quot;


 40 #include &quot;memory/metaspace.hpp&quot;
 41 #include &quot;utilities/growableArray.hpp&quot;
 42 #include &quot;utilities/ostream.hpp&quot;
 43 
 44 class AdjoiningGenerations;
 45 class GCHeapSummary;
<span class="line-removed"> 46 class GCTaskManager;</span>
 47 class MemoryManager;
 48 class MemoryPool;
 49 class PSAdaptiveSizePolicy;
 50 class PSCardTable;
 51 class PSHeapSummary;
 52 
 53 class ParallelScavengeHeap : public CollectedHeap {
 54   friend class VMStructs;
 55  private:
 56   static PSYoungGen* _young_gen;
 57   static PSOldGen*   _old_gen;
 58 
 59   // Sizing policy for entire heap
 60   static PSAdaptiveSizePolicy*       _size_policy;
 61   static PSGCAdaptivePolicyCounters* _gc_policy_counters;
 62 
<span class="line-removed"> 63   GenerationSizer* _collector_policy;</span>
<span class="line-removed"> 64 </span>
 65   SoftRefPolicy _soft_ref_policy;
 66 
 67   // Collection of generations that are adjacent in the
 68   // space reserved for the heap.
 69   AdjoiningGenerations* _gens;
 70   unsigned int _death_march_count;
 71 
<span class="line-removed"> 72   // The task manager</span>
<span class="line-removed"> 73   static GCTaskManager* _gc_task_manager;</span>
<span class="line-removed"> 74 </span>
 75   GCMemoryManager* _young_manager;
 76   GCMemoryManager* _old_manager;
 77 
 78   MemoryPool* _eden_pool;
 79   MemoryPool* _survivor_pool;
 80   MemoryPool* _old_pool;
 81 


 82   virtual void initialize_serviceability();
 83 
 84   void trace_heap(GCWhen::Type when, const GCTracer* tracer);
 85 
 86  protected:
 87   static inline size_t total_invocations();
 88   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
 89 
 90   inline bool should_alloc_in_eden(size_t size) const;
 91   inline void death_march_check(HeapWord* const result, size_t size);
 92   HeapWord* mem_allocate_old_gen(size_t size);
 93 
 94  public:
<span class="line-modified"> 95   ParallelScavengeHeap(GenerationSizer* policy) :</span>
<span class="line-modified"> 96     CollectedHeap(), _collector_policy(policy), _death_march_count(0) { }</span>











 97 
 98   // For use by VM operations
 99   enum CollectionType {
100     Scavenge,
101     MarkSweep
102   };
103 
104   virtual Name kind() const {
105     return CollectedHeap::Parallel;
106   }
107 
108   virtual const char* name() const {
109     return &quot;Parallel&quot;;
110   }
111 
<span class="line-removed">112   virtual CollectorPolicy* collector_policy() const { return _collector_policy; }</span>
<span class="line-removed">113 </span>
<span class="line-removed">114   virtual GenerationSizer* ps_collector_policy() const { return _collector_policy; }</span>
<span class="line-removed">115 </span>
116   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
117 
118   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
119   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
120 
121   static PSYoungGen* young_gen() { return _young_gen; }
122   static PSOldGen* old_gen()     { return _old_gen; }
123 
124   virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }
125 
126   static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
127 
128   static ParallelScavengeHeap* heap();
129 
<span class="line-removed">130   static GCTaskManager* const gc_task_manager() { return _gc_task_manager; }</span>
<span class="line-removed">131 </span>
132   CardTableBarrierSet* barrier_set();
133   PSCardTable* card_table();
134 
135   AdjoiningGenerations* gens() { return _gens; }
136 
137   // Returns JNI_OK on success
138   virtual jint initialize();
139 
140   void post_initialize();
141   void update_counters();
142 
<span class="line-removed">143   // The alignment used for the various areas</span>
<span class="line-removed">144   size_t space_alignment()      { return _collector_policy-&gt;space_alignment(); }</span>
<span class="line-removed">145   size_t generation_alignment() { return _collector_policy-&gt;gen_alignment(); }</span>
<span class="line-removed">146 </span>
<span class="line-removed">147   // Return the (conservative) maximum heap alignment</span>
<span class="line-removed">148   static size_t conservative_max_heap_alignment() {</span>
<span class="line-removed">149     return CollectorPolicy::compute_heap_alignment();</span>
<span class="line-removed">150   }</span>
<span class="line-removed">151 </span>
152   size_t capacity() const;
153   size_t used() const;
154 
155   // Return &quot;true&quot; if all generations have reached the
156   // maximal committed limit that they can reach, without a garbage
157   // collection.
158   virtual bool is_maximal_no_gc() const;
159 
160   virtual void register_nmethod(nmethod* nm);
161   virtual void unregister_nmethod(nmethod* nm);
162   virtual void verify_nmethod(nmethod* nm);
163   virtual void flush_nmethod(nmethod* nm);
164 
<span class="line-modified">165   void prune_nmethods();</span>
166 
167   size_t max_capacity() const;
168 
169   // Whether p is in the allocated part of the heap
170   bool is_in(const void* p) const;
171 
172   bool is_in_reserved(const void* p) const;
173 
174   bool is_in_young(oop p);  // reserved part
175   bool is_in_old(oop p);    // reserved part
176 



177   // Memory allocation.   &quot;gc_time_limit_was_exceeded&quot; will
178   // be set to true if the adaptive size policy determine that
179   // an excessive amount of time is being spent doing collections
180   // and caused a NULL to be returned.  If a NULL is not returned,
181   // &quot;gc_time_limit_was_exceeded&quot; has an undefined meaning.
182   HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);
183 
184   // Allocation attempt(s) during a safepoint. It should never be called
185   // to allocate a new TLAB as this allocation might be satisfied out
186   // of the old generation.
187   HeapWord* failed_mem_allocate(size_t size);
188 
189   // Support for System.gc()
190   void collect(GCCause::Cause cause);
191 
192   // These also should be called by the vm thread at a safepoint (e.g., from a
193   // VM operation).
194   //
195   // The first collects the young generation only, unless the scavenge fails; it
196   // will then attempt a full gc.  The second collects the entire heap; if
</pre>
<hr />
<pre>
199   inline void invoke_scavenge();
200 
201   // Perform a full collection
202   virtual void do_full_collection(bool clear_all_soft_refs);
203 
204   bool supports_inline_contig_alloc() const { return !UseNUMA; }
205 
206   HeapWord* volatile* top_addr() const { return !UseNUMA ? young_gen()-&gt;top_addr() : (HeapWord* volatile*)-1; }
207   HeapWord** end_addr() const { return !UseNUMA ? young_gen()-&gt;end_addr() : (HeapWord**)-1; }
208 
209   void ensure_parsability(bool retire_tlabs);
210   void resize_all_tlabs();
211 
212   bool supports_tlab_allocation() const { return true; }
213 
214   size_t tlab_capacity(Thread* thr) const;
215   size_t tlab_used(Thread* thr) const;
216   size_t unsafe_max_tlab_alloc(Thread* thr) const;
217 
218   void object_iterate(ObjectClosure* cl);
<span class="line-removed">219   void safe_object_iterate(ObjectClosure* cl) { object_iterate(cl); }</span>
220 
221   HeapWord* block_start(const void* addr) const;
222   bool block_is_obj(const HeapWord* addr) const;
223 
224   jlong millis_since_last_gc();
225 
226   void prepare_for_verify();
227   PSHeapSummary create_ps_heap_summary();
228   virtual void print_on(outputStream* st) const;
229   virtual void print_on_error(outputStream* st) const;
230   virtual void print_gc_threads_on(outputStream* st) const;
231   virtual void gc_threads_do(ThreadClosure* tc) const;
232   virtual void print_tracing_info() const;
233 






234   void verify(VerifyOption option /* ignored */);
235 
236   // Resize the young generation.  The reserved space for the
237   // generation may be expanded in preparation for the resize.
238   void resize_young_gen(size_t eden_size, size_t survivor_size);
239 
240   // Resize the old generation.  The reserved space for the
241   // generation may be expanded in preparation for the resize.
242   void resize_old_gen(size_t desired_free_space);
243 
244   // Save the tops of the spaces in all generations
245   void record_gen_tops_before_GC() PRODUCT_RETURN;
246 
247   // Mangle the unused parts of all spaces in the heap
248   void gen_mangle_unused_area() PRODUCT_RETURN;
249 
250   // Call these in sequential code around the processing of strong roots.
251   class ParStrongRootsScope : public MarkScope {
252    public:
253     ParStrongRootsScope();
254     ~ParStrongRootsScope();
255   };
256 
257   GCMemoryManager* old_gc_manager() const { return _old_manager; }
258   GCMemoryManager* young_gc_manager() const { return _young_manager; }
<span class="line-removed">259 };</span>
260 
<span class="line-modified">261 // Simple class for storing info about the heap at the start of GC, to be used</span>
<span class="line-modified">262 // after GC for comparison/printing.</span>
<span class="line-modified">263 class PreGCValues {</span>
<span class="line-removed">264 public:</span>
<span class="line-removed">265   PreGCValues(ParallelScavengeHeap* heap) :</span>
<span class="line-removed">266       _heap_used(heap-&gt;used()),</span>
<span class="line-removed">267       _young_gen_used(heap-&gt;young_gen()-&gt;used_in_bytes()),</span>
<span class="line-removed">268       _old_gen_used(heap-&gt;old_gen()-&gt;used_in_bytes()),</span>
<span class="line-removed">269       _metadata_used(MetaspaceUtils::used_bytes()) { };</span>
<span class="line-removed">270 </span>
<span class="line-removed">271   size_t heap_used() const      { return _heap_used; }</span>
<span class="line-removed">272   size_t young_gen_used() const { return _young_gen_used; }</span>
<span class="line-removed">273   size_t old_gen_used() const   { return _old_gen_used; }</span>
<span class="line-removed">274   size_t metadata_used() const  { return _metadata_used; }</span>
<span class="line-removed">275 </span>
<span class="line-removed">276 private:</span>
<span class="line-removed">277   size_t _heap_used;</span>
<span class="line-removed">278   size_t _young_gen_used;</span>
<span class="line-removed">279   size_t _old_gen_used;</span>
<span class="line-removed">280   size_t _metadata_used;</span>
281 };
282 
283 // Class that can be used to print information about the
284 // adaptive size policy at intervals specified by
285 // AdaptiveSizePolicyOutputInterval.  Only print information
286 // if an adaptive size policy is in use.
287 class AdaptiveSizePolicyOutput : AllStatic {
288   static bool enabled() {
289     return UseParallelGC &amp;&amp;
290            UseAdaptiveSizePolicy &amp;&amp;
291            log_is_enabled(Debug, gc, ergo);
292   }
293  public:
294   static void print() {
295     if (enabled()) {
296       ParallelScavengeHeap::heap()-&gt;size_policy()-&gt;print();
297     }
298   }
299 
300   static void print(AdaptiveSizePolicy* size_policy, uint count) {
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 26 #define SHARE_GC_PARALLEL_PARALLELSCAVENGEHEAP_HPP
 27 

 28 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 29 #include &quot;gc/parallel/psGCAdaptivePolicyCounters.hpp&quot;
 30 #include &quot;gc/parallel/psOldGen.hpp&quot;
 31 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 33 #include &quot;gc/shared/collectedHeap.hpp&quot;

 34 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
 35 #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="line-added"> 36 #include &quot;gc/shared/preGCValues.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;gc/shared/referenceProcessor.hpp&quot;</span>
 38 #include &quot;gc/shared/softRefPolicy.hpp&quot;
 39 #include &quot;gc/shared/strongRootsScope.hpp&quot;
<span class="line-added"> 40 #include &quot;gc/shared/workgroup.hpp&quot;</span>
<span class="line-added"> 41 #include &quot;logging/log.hpp&quot;</span>
 42 #include &quot;memory/metaspace.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 #include &quot;utilities/ostream.hpp&quot;
 45 
 46 class AdjoiningGenerations;
 47 class GCHeapSummary;

 48 class MemoryManager;
 49 class MemoryPool;
 50 class PSAdaptiveSizePolicy;
 51 class PSCardTable;
 52 class PSHeapSummary;
 53 
 54 class ParallelScavengeHeap : public CollectedHeap {
 55   friend class VMStructs;
 56  private:
 57   static PSYoungGen* _young_gen;
 58   static PSOldGen*   _old_gen;
 59 
 60   // Sizing policy for entire heap
 61   static PSAdaptiveSizePolicy*       _size_policy;
 62   static PSGCAdaptivePolicyCounters* _gc_policy_counters;
 63 


 64   SoftRefPolicy _soft_ref_policy;
 65 
 66   // Collection of generations that are adjacent in the
 67   // space reserved for the heap.
 68   AdjoiningGenerations* _gens;
 69   unsigned int _death_march_count;
 70 



 71   GCMemoryManager* _young_manager;
 72   GCMemoryManager* _old_manager;
 73 
 74   MemoryPool* _eden_pool;
 75   MemoryPool* _survivor_pool;
 76   MemoryPool* _old_pool;
 77 
<span class="line-added"> 78   WorkGang _workers;</span>
<span class="line-added"> 79 </span>
 80   virtual void initialize_serviceability();
 81 
 82   void trace_heap(GCWhen::Type when, const GCTracer* tracer);
 83 
 84  protected:
 85   static inline size_t total_invocations();
 86   HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);
 87 
 88   inline bool should_alloc_in_eden(size_t size) const;
 89   inline void death_march_check(HeapWord* const result, size_t size);
 90   HeapWord* mem_allocate_old_gen(size_t size);
 91 
 92  public:
<span class="line-modified"> 93   ParallelScavengeHeap() :</span>
<span class="line-modified"> 94     CollectedHeap(),</span>
<span class="line-added"> 95     _gens(NULL),</span>
<span class="line-added"> 96     _death_march_count(0),</span>
<span class="line-added"> 97     _young_manager(NULL),</span>
<span class="line-added"> 98     _old_manager(NULL),</span>
<span class="line-added"> 99     _eden_pool(NULL),</span>
<span class="line-added">100     _survivor_pool(NULL),</span>
<span class="line-added">101     _old_pool(NULL),</span>
<span class="line-added">102     _workers(&quot;GC Thread&quot;,</span>
<span class="line-added">103              ParallelGCThreads,</span>
<span class="line-added">104              true /* are_GC_task_threads */,</span>
<span class="line-added">105              false /* are_ConcurrentGC_threads */) { }</span>
106 
107   // For use by VM operations
108   enum CollectionType {
109     Scavenge,
110     MarkSweep
111   };
112 
113   virtual Name kind() const {
114     return CollectedHeap::Parallel;
115   }
116 
117   virtual const char* name() const {
118     return &quot;Parallel&quot;;
119   }
120 




121   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_policy; }
122 
123   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers();
124   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools();
125 
126   static PSYoungGen* young_gen() { return _young_gen; }
127   static PSOldGen* old_gen()     { return _old_gen; }
128 
129   virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }
130 
131   static PSGCAdaptivePolicyCounters* gc_policy_counters() { return _gc_policy_counters; }
132 
133   static ParallelScavengeHeap* heap();
134 


135   CardTableBarrierSet* barrier_set();
136   PSCardTable* card_table();
137 
138   AdjoiningGenerations* gens() { return _gens; }
139 
140   // Returns JNI_OK on success
141   virtual jint initialize();
142 
143   void post_initialize();
144   void update_counters();
145 









146   size_t capacity() const;
147   size_t used() const;
148 
149   // Return &quot;true&quot; if all generations have reached the
150   // maximal committed limit that they can reach, without a garbage
151   // collection.
152   virtual bool is_maximal_no_gc() const;
153 
154   virtual void register_nmethod(nmethod* nm);
155   virtual void unregister_nmethod(nmethod* nm);
156   virtual void verify_nmethod(nmethod* nm);
157   virtual void flush_nmethod(nmethod* nm);
158 
<span class="line-modified">159   void prune_scavengable_nmethods();</span>
160 
161   size_t max_capacity() const;
162 
163   // Whether p is in the allocated part of the heap
164   bool is_in(const void* p) const;
165 
166   bool is_in_reserved(const void* p) const;
167 
168   bool is_in_young(oop p);  // reserved part
169   bool is_in_old(oop p);    // reserved part
170 
<span class="line-added">171   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-added">172   HeapWord* base() const { return _reserved.start(); }</span>
<span class="line-added">173 </span>
174   // Memory allocation.   &quot;gc_time_limit_was_exceeded&quot; will
175   // be set to true if the adaptive size policy determine that
176   // an excessive amount of time is being spent doing collections
177   // and caused a NULL to be returned.  If a NULL is not returned,
178   // &quot;gc_time_limit_was_exceeded&quot; has an undefined meaning.
179   HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);
180 
181   // Allocation attempt(s) during a safepoint. It should never be called
182   // to allocate a new TLAB as this allocation might be satisfied out
183   // of the old generation.
184   HeapWord* failed_mem_allocate(size_t size);
185 
186   // Support for System.gc()
187   void collect(GCCause::Cause cause);
188 
189   // These also should be called by the vm thread at a safepoint (e.g., from a
190   // VM operation).
191   //
192   // The first collects the young generation only, unless the scavenge fails; it
193   // will then attempt a full gc.  The second collects the entire heap; if
</pre>
<hr />
<pre>
196   inline void invoke_scavenge();
197 
198   // Perform a full collection
199   virtual void do_full_collection(bool clear_all_soft_refs);
200 
201   bool supports_inline_contig_alloc() const { return !UseNUMA; }
202 
203   HeapWord* volatile* top_addr() const { return !UseNUMA ? young_gen()-&gt;top_addr() : (HeapWord* volatile*)-1; }
204   HeapWord** end_addr() const { return !UseNUMA ? young_gen()-&gt;end_addr() : (HeapWord**)-1; }
205 
206   void ensure_parsability(bool retire_tlabs);
207   void resize_all_tlabs();
208 
209   bool supports_tlab_allocation() const { return true; }
210 
211   size_t tlab_capacity(Thread* thr) const;
212   size_t tlab_used(Thread* thr) const;
213   size_t unsafe_max_tlab_alloc(Thread* thr) const;
214 
215   void object_iterate(ObjectClosure* cl);

216 
217   HeapWord* block_start(const void* addr) const;
218   bool block_is_obj(const HeapWord* addr) const;
219 
220   jlong millis_since_last_gc();
221 
222   void prepare_for_verify();
223   PSHeapSummary create_ps_heap_summary();
224   virtual void print_on(outputStream* st) const;
225   virtual void print_on_error(outputStream* st) const;
226   virtual void print_gc_threads_on(outputStream* st) const;
227   virtual void gc_threads_do(ThreadClosure* tc) const;
228   virtual void print_tracing_info() const;
229 
<span class="line-added">230   PreGenGCValues get_pre_gc_values() const;</span>
<span class="line-added">231   void print_heap_change(const PreGenGCValues&amp; pre_gc_values) const;</span>
<span class="line-added">232 </span>
<span class="line-added">233   // Used to print information about locations in the hs_err file.</span>
<span class="line-added">234   virtual bool print_location(outputStream* st, void* addr) const;</span>
<span class="line-added">235 </span>
236   void verify(VerifyOption option /* ignored */);
237 
238   // Resize the young generation.  The reserved space for the
239   // generation may be expanded in preparation for the resize.
240   void resize_young_gen(size_t eden_size, size_t survivor_size);
241 
242   // Resize the old generation.  The reserved space for the
243   // generation may be expanded in preparation for the resize.
244   void resize_old_gen(size_t desired_free_space);
245 
246   // Save the tops of the spaces in all generations
247   void record_gen_tops_before_GC() PRODUCT_RETURN;
248 
249   // Mangle the unused parts of all spaces in the heap
250   void gen_mangle_unused_area() PRODUCT_RETURN;
251 
252   // Call these in sequential code around the processing of strong roots.
253   class ParStrongRootsScope : public MarkScope {
254    public:
255     ParStrongRootsScope();
256     ~ParStrongRootsScope();
257   };
258 
259   GCMemoryManager* old_gc_manager() const { return _old_manager; }
260   GCMemoryManager* young_gc_manager() const { return _young_manager; }

261 
<span class="line-modified">262   WorkGang&amp; workers() {</span>
<span class="line-modified">263     return _workers;</span>
<span class="line-modified">264   }</span>

















265 };
266 
267 // Class that can be used to print information about the
268 // adaptive size policy at intervals specified by
269 // AdaptiveSizePolicyOutputInterval.  Only print information
270 // if an adaptive size policy is in use.
271 class AdaptiveSizePolicyOutput : AllStatic {
272   static bool enabled() {
273     return UseParallelGC &amp;&amp;
274            UseAdaptiveSizePolicy &amp;&amp;
275            log_is_enabled(Debug, gc, ergo);
276   }
277  public:
278   static void print() {
279     if (enabled()) {
280       ParallelScavengeHeap::heap()-&gt;size_policy()-&gt;print();
281     }
282   }
283 
284   static void print(AdaptiveSizePolicy* size_policy, uint count) {
</pre>
</td>
</tr>
</table>
<center><a href="parallelScavengeHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelScavengeHeap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
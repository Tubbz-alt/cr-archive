<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
 29 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 30 #include &quot;gc/parallel/parallelArguments.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;logging/logStream.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 
 38 // If boundary moving is being used, create the young gen and old
 39 // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
 40 // the old behavior otherwise (with PSYoungGen and PSOldGen).
 41 
 42 AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs) :
 43   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, MinOldSize,
 44                                              MinNewSize, GenAlignment)) {
 45   size_t init_low_byte_size = OldSize;
 46   size_t min_low_byte_size = MinOldSize;
 47   size_t max_low_byte_size = MaxOldSize;
 48   size_t init_high_byte_size = NewSize;
 49   size_t min_high_byte_size = MinNewSize;
 50   size_t max_high_byte_size = MaxNewSize;
 51 
 52   assert(min_low_byte_size &lt;= init_low_byte_size &amp;&amp;
 53          init_low_byte_size &lt;= max_low_byte_size, &quot;Parameter check&quot;);
 54   assert(min_high_byte_size &lt;= init_high_byte_size &amp;&amp;
 55          init_high_byte_size &lt;= max_high_byte_size, &quot;Parameter check&quot;);
 56   // Create the generations differently based on the option to
 57   // move the boundary.
 58   if (UseAdaptiveGCBoundary) {
 59     // Initialize the adjoining virtual spaces.  Then pass the
 60     // a virtual to each generation for initialization of the
 61     // generation.
 62 
 63     // Does the actual creation of the virtual spaces
 64     _virtual_spaces-&gt;initialize(max_low_byte_size,
 65                                 init_low_byte_size,
 66                                 init_high_byte_size);
 67 
 68     // Place the young gen at the high end.  Passes in the virtual space.
 69     _young_gen = new ASPSYoungGen(_virtual_spaces-&gt;high(),
 70                                   _virtual_spaces-&gt;high()-&gt;committed_size(),
 71                                   min_high_byte_size,
 72                                   _virtual_spaces-&gt;high_byte_size_limit());
 73 
 74     // Place the old gen at the low end. Passes in the virtual space.
 75     _old_gen = new ASPSOldGen(_virtual_spaces-&gt;low(),
 76                               _virtual_spaces-&gt;low()-&gt;committed_size(),
 77                               min_low_byte_size,
 78                               _virtual_spaces-&gt;low_byte_size_limit(),
 79                               &quot;old&quot;, 1);
 80 
 81     young_gen()-&gt;initialize_work();
 82     assert(young_gen()-&gt;reserved().byte_size() &lt;= young_gen()-&gt;gen_size_limit(),
 83      &quot;Consistency check&quot;);
 84     assert(old_young_rs.size() &gt;= young_gen()-&gt;gen_size_limit(),
 85      &quot;Consistency check&quot;);
 86 
 87     old_gen()-&gt;initialize_work(&quot;old&quot;, 1);
 88     assert(old_gen()-&gt;reserved().byte_size() &lt;= old_gen()-&gt;gen_size_limit(),
 89      &quot;Consistency check&quot;);
 90     assert(old_young_rs.size() &gt;= old_gen()-&gt;gen_size_limit(),
 91      &quot;Consistency check&quot;);
 92   } else {
 93 
 94     // Layout the reserved space for the generations.
 95     // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
 96     ReservedSpace old_rs   =
 97       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, ParallelArguments::is_heterogeneous_heap() /* split */);
 98     ReservedSpace heap_rs  =
 99       virtual_spaces()-&gt;reserved_space().last_part(max_low_byte_size);
100     ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
101     assert(young_rs.size() == heap_rs.size(), &quot;Didn&#39;t reserve all of the heap&quot;);
102 
103     // Create the generations.  Virtual spaces are not passed in.
104     _young_gen = new PSYoungGen(init_high_byte_size,
105                                 min_high_byte_size,
106                                 max_high_byte_size);
107     _old_gen = new PSOldGen(init_low_byte_size,
108                             min_low_byte_size,
109                             max_low_byte_size,
110                             &quot;old&quot;, 1);
111 
112     // The virtual spaces are created by the initialization of the gens.
113     _young_gen-&gt;initialize(young_rs, GenAlignment);
114     assert(young_gen()-&gt;gen_size_limit() == young_rs.size(),
115       &quot;Consistency check&quot;);
116     _old_gen-&gt;initialize(old_rs, GenAlignment, &quot;old&quot;, 1);
117     assert(old_gen()-&gt;gen_size_limit() == old_rs.size(), &quot;Consistency check&quot;);
118   }
119 }
120 
121 AdjoiningGenerations::AdjoiningGenerations(): _young_gen(NULL), _old_gen(NULL), _virtual_spaces(NULL) { }
122 
123 size_t AdjoiningGenerations::reserved_byte_size() {
124   return virtual_spaces()-&gt;reserved_space().size();
125 }
126 
127 void log_before_expansion(bool old, size_t expand_in_bytes, size_t change_in_bytes, size_t max_size) {
128   Log(gc, ergo, heap) log;
129   if (!log.is_debug()) {
130    return;
131   }
132   log.debug(&quot;Before expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
133   log.debug(&quot;  Requested change: &quot; SIZE_FORMAT_HEX &quot;  Attempted change: &quot; SIZE_FORMAT_HEX,
134                         expand_in_bytes, change_in_bytes);
135   ResourceMark rm;
136   LogStream ls(log.debug());
137   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
138   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
139 }
140 
141 void log_after_expansion(bool old, size_t max_size) {
142   Log(gc, ergo, heap) log;
143   if (!log.is_debug()) {
144    return;
145   }
146   log.debug(&quot;After expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
147   ResourceMark rm;
148   LogStream ls(log.debug());
149   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
150   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
151 }
152 
153 // Make checks on the current sizes of the generations and
154 // the constraints on the sizes of the generations.  Push
155 // up the boundary within the constraints.  A partial
156 // push can occur.
157 void AdjoiningGenerations::request_old_gen_expansion(size_t expand_in_bytes) {
158   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
159 
160   assert_lock_strong(ExpandHeap_lock);
161   assert_locked_or_safepoint(Heap_lock);
162 
163   // These sizes limit the amount the boundaries can move.  Effectively,
164   // the generation says how much it is willing to yield to the other
165   // generation.
166   const size_t young_gen_available = young_gen()-&gt;available_for_contraction();
167   const size_t old_gen_available = old_gen()-&gt;available_for_expansion();
168   const size_t alignment = virtual_spaces()-&gt;alignment();
169   size_t change_in_bytes = MIN3(young_gen_available,
170                                 old_gen_available,
171                                 align_up(expand_in_bytes, alignment));
172 
173   if (change_in_bytes == 0) {
174     return;
175   }
176 
177   log_before_expansion(true, expand_in_bytes, change_in_bytes, old_gen()-&gt;max_gen_size());
178 
179   // Move the boundary between the generations up (smaller young gen).
180   if (virtual_spaces()-&gt;adjust_boundary_up(change_in_bytes)) {
181     young_gen()-&gt;reset_after_change();
182     old_gen()-&gt;reset_after_change();
183   }
184 
185   // The total reserved for the generations should match the sum
186   // of the two even if the boundary is moving.
187   assert(reserved_byte_size() ==
188          old_gen()-&gt;max_gen_size() + young_gen()-&gt;max_size(),
189          &quot;Space is missing&quot;);
190   young_gen()-&gt;space_invariants();
191   old_gen()-&gt;space_invariants();
192 
193   log_after_expansion(true, old_gen()-&gt;max_gen_size());
194 }
195 
196 // See comments on request_old_gen_expansion()
197 bool AdjoiningGenerations::request_young_gen_expansion(size_t expand_in_bytes) {
198   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
199 
200   // If eden is not empty, the boundary can be moved but no advantage
201   // can be made of the move since eden cannot be moved.
202   if (!young_gen()-&gt;eden_space()-&gt;is_empty()) {
203     return false;
204   }
205 
206 
207   bool result = false;
208   const size_t young_gen_available = young_gen()-&gt;available_for_expansion();
209   const size_t old_gen_available = old_gen()-&gt;available_for_contraction();
210   const size_t alignment = virtual_spaces()-&gt;alignment();
211   size_t change_in_bytes = MIN3(young_gen_available,
212                                 old_gen_available,
213                                 align_up(expand_in_bytes, alignment));
214 
215   if (change_in_bytes == 0) {
216     return false;
217   }
218 
219   log_before_expansion(false, expand_in_bytes, change_in_bytes, young_gen()-&gt;max_size());
220 
221   // Move the boundary between the generations down (smaller old gen).
222   MutexLocker x(ExpandHeap_lock);
223   if (virtual_spaces()-&gt;adjust_boundary_down(change_in_bytes)) {
224     young_gen()-&gt;reset_after_change();
225     old_gen()-&gt;reset_after_change();
226     result = true;
227   }
228 
229   // The total reserved for the generations should match the sum
230   // of the two even if the boundary is moving.
231   assert(reserved_byte_size() ==
232          old_gen()-&gt;max_gen_size() + young_gen()-&gt;max_size(),
233          &quot;Space is missing&quot;);
234   young_gen()-&gt;space_invariants();
235   old_gen()-&gt;space_invariants();
236 
237   log_after_expansion(false, young_gen()-&gt;max_size());
238 
239   return result;
240 }
241 
242 // Additional space is needed in the old generation.  Try to move the boundary
243 // up to meet the need.  Moves boundary up only
244 void AdjoiningGenerations::adjust_boundary_for_old_gen_needs(
245   size_t desired_free_space) {
246   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
247 
248   // Stress testing.
249   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 1) {
250     MutexLocker x(ExpandHeap_lock);
251     request_old_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
252   }
253 
254   // Expand only if the entire generation is already committed.
255   if (old_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
256     if (old_gen()-&gt;free_in_bytes() &lt; desired_free_space) {
257       MutexLocker x(ExpandHeap_lock);
258       request_old_gen_expansion(desired_free_space);
259     }
260   }
261 }
262 
263 // See comment on adjust_boundary_for_old_gen_needss().
264 // Adjust boundary down only.
265 void AdjoiningGenerations::adjust_boundary_for_young_gen_needs(size_t eden_size,
266     size_t survivor_size) {
267 
268   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
269 
270   // Stress testing.
271   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 0) {
272     request_young_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
273     eden_size = young_gen()-&gt;eden_space()-&gt;capacity_in_bytes();
274   }
275 
276   // Expand only if the entire generation is already committed.
277   if (young_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
278     size_t desired_size = eden_size + 2 * survivor_size;
279     const size_t committed = young_gen()-&gt;virtual_space()-&gt;committed_size();
280     if (desired_size &gt; committed) {
281       request_young_gen_expansion(desired_size - committed);
282     }
283   }
284 }
285 
286 AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs) {
287   if (ParallelArguments::is_heterogeneous_heap() &amp;&amp; UseAdaptiveGCBoundary) {
288     return new AdjoiningGenerationsForHeteroHeap(old_young_rs);
289   } else {
290     return new AdjoiningGenerations(old_young_rs);
291   }
292 }
    </pre>
  </body>
</html>
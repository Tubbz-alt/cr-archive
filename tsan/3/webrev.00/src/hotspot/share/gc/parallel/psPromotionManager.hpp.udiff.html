<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/psPromotionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionManager.inline.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psPromotionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,12 +49,18 @@</span>
  class PSOldGen;
  class ParCompactionManager;
  
  class PSPromotionManager {
    friend class PSScavenge;
<span class="udiff-line-added">+   friend class ScavengeRootsTask;</span>
    friend class PSRefProcTaskExecutor;
<span class="udiff-line-added">+   friend class PSRefProcTask;</span>
<span class="udiff-line-added">+ </span>
   private:
<span class="udiff-line-added">+   typedef OverflowTaskQueue&lt;StarTask, mtGC&gt;           OopStarTaskQueue;</span>
<span class="udiff-line-added">+   typedef GenericTaskQueueSet&lt;OopStarTaskQueue, mtGC&gt; OopStarTaskQueueSet;</span>
<span class="udiff-line-added">+ </span>
    static PaddedEnd&lt;PSPromotionManager&gt;* _manager_array;
    static OopStarTaskQueueSet*           _stack_array_depth;
    static PreservedMarksSet*             _preserved_marks_set;
    static PSOldGen*                      _old_gen;
    static MutableSpace*                  _young_space;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97,12 +103,11 @@</span>
  
    // On the task queues we push reference locations as well as
    // partially-scanned arrays (in the latter case, we push an oop to
    // the from-space image of the array and the length on the
    // from-space image indicates how many entries on the array we still
<span class="udiff-line-modified-removed">-   // need to scan; this is basically how ParNew does partial array</span>
<span class="udiff-line-removed">-   // scanning too). To be able to distinguish between reference</span>
<span class="udiff-line-modified-added">+   // need to scan. To be able to distinguish between reference</span>
    // locations and partially-scanned array oops we simply mask the
    // latter oops with 0x01. The next three methods do the masking,
    // unmasking, and checking whether the oop is masked or not. Notice
    // that the signature of the mask and unmask methods looks a bit
    // strange, as they accept and return different types (oop and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,22 +125,22 @@</span>
      return (((intptr_t)(oop*)p) &amp; PS_CHUNKED_ARRAY_OOP_MASK) ==
                                    PS_CHUNKED_ARRAY_OOP_MASK;
    }
  
    oop* mask_chunked_array_oop(oop obj) {
<span class="udiff-line-modified-removed">-     assert(!is_oop_masked((oop*) obj), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     assert(!is_oop_masked(cast_from_oop&lt;oop*&gt;(obj)), &quot;invariant&quot;);</span>
      oop* ret = (oop*) (cast_from_oop&lt;uintptr_t&gt;(obj) | PS_CHUNKED_ARRAY_OOP_MASK);
      assert(is_oop_masked(ret), &quot;invariant&quot;);
      return ret;
    }
  
    oop unmask_chunked_array_oop(StarTask p) {
      assert(is_oop_masked(p), &quot;invariant&quot;);
      assert(!p.is_narrow(), &quot;chunked array oops cannot be narrow&quot;);
      oop *chunk = (oop*)p;  // cast p to oop (uses conversion operator)
      oop ret = oop((oop*)((uintptr_t)chunk &amp; ~PS_CHUNKED_ARRAY_OOP_MASK));
<span class="udiff-line-modified-removed">-     assert(!is_oop_masked((oop*) ret), &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     assert(!is_oop_masked(cast_from_oop&lt;oop*&gt;(ret)), &quot;invariant&quot;);</span>
      return ret;
    }
  
    template &lt;class T&gt; void  process_array_chunk_work(oop obj,
                                                      int start, int end);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -173,11 +178,11 @@</span>
    bool old_gen_is_full()               { return _old_gen_is_full; }
    void set_old_gen_is_full(bool state) { _old_gen_is_full = state; }
  
    // Promotion methods
    template&lt;bool promote_immediately&gt; oop copy_to_survivor_space(oop o);
<span class="udiff-line-modified-removed">-   oop oop_promotion_failed(oop obj, markOop obj_mark);</span>
<span class="udiff-line-modified-added">+   oop oop_promotion_failed(oop obj, markWord obj_mark);</span>
  
    void reset();
    void register_preserved_marks(PreservedMarks* preserved_marks);
    static void restore_preserved_marks();
  
</pre>
<center><a href="psPromotionManager.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionManager.inline.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
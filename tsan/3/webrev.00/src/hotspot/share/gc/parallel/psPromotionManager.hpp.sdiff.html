<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psPromotionManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psPromotionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionManager.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psPromotionManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
 36 //
 37 // psPromotionManager is used by a single thread to manage object survival
 38 // during a scavenge. The promotion manager contains thread local data only.
 39 //
 40 // NOTE! Be careful when allocating the stacks on cheap. If you are going
 41 // to use a promotion manager in more than one thread, the stacks MUST be
 42 // on cheap. This can lead to memory leaks, though, as they are not auto
 43 // deallocated.
 44 //
 45 // FIX ME FIX ME Add a destructor, and don&#39;t rely on the user to drain/flush/deallocate!
 46 //
 47 
 48 class MutableSpace;
 49 class PSOldGen;
 50 class ParCompactionManager;
 51 
 52 class PSPromotionManager {
 53   friend class PSScavenge;

 54   friend class PSRefProcTaskExecutor;


 55  private:



 56   static PaddedEnd&lt;PSPromotionManager&gt;* _manager_array;
 57   static OopStarTaskQueueSet*           _stack_array_depth;
 58   static PreservedMarksSet*             _preserved_marks_set;
 59   static PSOldGen*                      _old_gen;
 60   static MutableSpace*                  _young_space;
 61 
 62 #if TASKQUEUE_STATS
 63   size_t                              _masked_pushes;
 64   size_t                              _masked_steals;
 65   size_t                              _arrays_chunked;
 66   size_t                              _array_chunks_processed;
 67 
 68   void print_local_stats(outputStream* const out, uint i) const;
 69   static void print_taskqueue_stats();
 70 
 71   void reset_stats();
 72 #endif // TASKQUEUE_STATS
 73 
 74   PSYoungPromotionLAB                 _young_lab;
 75   PSOldPromotionLAB                   _old_lab;
</pre>
<hr />
<pre>
 82   bool                                _totally_drain;
 83   uint                                _target_stack_size;
 84 
 85   uint                                _array_chunk_size;
 86   uint                                _min_array_size_for_chunking;
 87 
 88   PreservedMarks*                     _preserved_marks;
 89   PromotionFailedInfo                 _promotion_failed_info;
 90 
 91   // Accessors
 92   static PSOldGen* old_gen()         { return _old_gen; }
 93   static MutableSpace* young_space() { return _young_space; }
 94 
 95   inline static PSPromotionManager* manager_array(uint index);
 96   template &lt;class T&gt; inline void claim_or_forward_internal_depth(T* p);
 97 
 98   // On the task queues we push reference locations as well as
 99   // partially-scanned arrays (in the latter case, we push an oop to
100   // the from-space image of the array and the length on the
101   // from-space image indicates how many entries on the array we still
<span class="line-modified">102   // need to scan; this is basically how ParNew does partial array</span>
<span class="line-removed">103   // scanning too). To be able to distinguish between reference</span>
104   // locations and partially-scanned array oops we simply mask the
105   // latter oops with 0x01. The next three methods do the masking,
106   // unmasking, and checking whether the oop is masked or not. Notice
107   // that the signature of the mask and unmask methods looks a bit
108   // strange, as they accept and return different types (oop and
109   // oop*). This is because of the difference in types between what
110   // the task queue holds (oop*) and oops to partially-scanned arrays
111   // (oop). We do all the necessary casting in the mask / unmask
112   // methods to avoid sprinkling the rest of the code with more casts.
113 
114   // These are added to the taskqueue so PS_CHUNKED_ARRAY_OOP_MASK (or any
115   // future masks) can&#39;t conflict with COMPRESSED_OOP_MASK
116 #define PS_CHUNKED_ARRAY_OOP_MASK  0x2
117 
118   bool is_oop_masked(StarTask p) {
119     // If something is marked chunked it&#39;s always treated like wide oop*
120     return (((intptr_t)(oop*)p) &amp; PS_CHUNKED_ARRAY_OOP_MASK) ==
121                                   PS_CHUNKED_ARRAY_OOP_MASK;
122   }
123 
124   oop* mask_chunked_array_oop(oop obj) {
<span class="line-modified">125     assert(!is_oop_masked((oop*) obj), &quot;invariant&quot;);</span>
126     oop* ret = (oop*) (cast_from_oop&lt;uintptr_t&gt;(obj) | PS_CHUNKED_ARRAY_OOP_MASK);
127     assert(is_oop_masked(ret), &quot;invariant&quot;);
128     return ret;
129   }
130 
131   oop unmask_chunked_array_oop(StarTask p) {
132     assert(is_oop_masked(p), &quot;invariant&quot;);
133     assert(!p.is_narrow(), &quot;chunked array oops cannot be narrow&quot;);
134     oop *chunk = (oop*)p;  // cast p to oop (uses conversion operator)
135     oop ret = oop((oop*)((uintptr_t)chunk &amp; ~PS_CHUNKED_ARRAY_OOP_MASK));
<span class="line-modified">136     assert(!is_oop_masked((oop*) ret), &quot;invariant&quot;);</span>
137     return ret;
138   }
139 
140   template &lt;class T&gt; void  process_array_chunk_work(oop obj,
141                                                     int start, int end);
142   void process_array_chunk(oop old);
143 
144   template &lt;class T&gt; void push_depth(T* p);
145 
146   inline void promotion_trace_event(oop new_obj, oop old_obj, size_t obj_size,
147                                     uint age, bool tenured,
148                                     const PSPromotionLAB* lab);
149 
150  protected:
151   static OopStarTaskQueueSet* stack_array_depth()   { return _stack_array_depth; }
152  public:
153   // Static
154   static void initialize();
155 
156   static void pre_scavenge();
</pre>
<hr />
<pre>
158 
159   static PSPromotionManager* gc_thread_promotion_manager(uint index);
160   static PSPromotionManager* vm_thread_promotion_manager();
161 
162   static bool steal_depth(int queue_num, StarTask&amp; t);
163 
164   PSPromotionManager();
165 
166   // Accessors
167   OopStarTaskQueue* claimed_stack_depth() {
168     return &amp;_claimed_stack_depth;
169   }
170 
171   bool young_gen_is_full()             { return _young_gen_is_full; }
172 
173   bool old_gen_is_full()               { return _old_gen_is_full; }
174   void set_old_gen_is_full(bool state) { _old_gen_is_full = state; }
175 
176   // Promotion methods
177   template&lt;bool promote_immediately&gt; oop copy_to_survivor_space(oop o);
<span class="line-modified">178   oop oop_promotion_failed(oop obj, markOop obj_mark);</span>
179 
180   void reset();
181   void register_preserved_marks(PreservedMarks* preserved_marks);
182   static void restore_preserved_marks();
183 
184   void flush_labs();
185   void drain_stacks(bool totally_drain) {
186     drain_stacks_depth(totally_drain);
187   }
188  public:
189   void drain_stacks_cond_depth() {
190     if (claimed_stack_depth()-&gt;size() &gt; _target_stack_size) {
191       drain_stacks_depth(false);
192     }
193   }
194   void drain_stacks_depth(bool totally_drain);
195 
196   bool stacks_empty() {
197     return claimed_stack_depth()-&gt;is_empty();
198   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
 36 //
 37 // psPromotionManager is used by a single thread to manage object survival
 38 // during a scavenge. The promotion manager contains thread local data only.
 39 //
 40 // NOTE! Be careful when allocating the stacks on cheap. If you are going
 41 // to use a promotion manager in more than one thread, the stacks MUST be
 42 // on cheap. This can lead to memory leaks, though, as they are not auto
 43 // deallocated.
 44 //
 45 // FIX ME FIX ME Add a destructor, and don&#39;t rely on the user to drain/flush/deallocate!
 46 //
 47 
 48 class MutableSpace;
 49 class PSOldGen;
 50 class ParCompactionManager;
 51 
 52 class PSPromotionManager {
 53   friend class PSScavenge;
<span class="line-added"> 54   friend class ScavengeRootsTask;</span>
 55   friend class PSRefProcTaskExecutor;
<span class="line-added"> 56   friend class PSRefProcTask;</span>
<span class="line-added"> 57 </span>
 58  private:
<span class="line-added"> 59   typedef OverflowTaskQueue&lt;StarTask, mtGC&gt;           OopStarTaskQueue;</span>
<span class="line-added"> 60   typedef GenericTaskQueueSet&lt;OopStarTaskQueue, mtGC&gt; OopStarTaskQueueSet;</span>
<span class="line-added"> 61 </span>
 62   static PaddedEnd&lt;PSPromotionManager&gt;* _manager_array;
 63   static OopStarTaskQueueSet*           _stack_array_depth;
 64   static PreservedMarksSet*             _preserved_marks_set;
 65   static PSOldGen*                      _old_gen;
 66   static MutableSpace*                  _young_space;
 67 
 68 #if TASKQUEUE_STATS
 69   size_t                              _masked_pushes;
 70   size_t                              _masked_steals;
 71   size_t                              _arrays_chunked;
 72   size_t                              _array_chunks_processed;
 73 
 74   void print_local_stats(outputStream* const out, uint i) const;
 75   static void print_taskqueue_stats();
 76 
 77   void reset_stats();
 78 #endif // TASKQUEUE_STATS
 79 
 80   PSYoungPromotionLAB                 _young_lab;
 81   PSOldPromotionLAB                   _old_lab;
</pre>
<hr />
<pre>
 88   bool                                _totally_drain;
 89   uint                                _target_stack_size;
 90 
 91   uint                                _array_chunk_size;
 92   uint                                _min_array_size_for_chunking;
 93 
 94   PreservedMarks*                     _preserved_marks;
 95   PromotionFailedInfo                 _promotion_failed_info;
 96 
 97   // Accessors
 98   static PSOldGen* old_gen()         { return _old_gen; }
 99   static MutableSpace* young_space() { return _young_space; }
100 
101   inline static PSPromotionManager* manager_array(uint index);
102   template &lt;class T&gt; inline void claim_or_forward_internal_depth(T* p);
103 
104   // On the task queues we push reference locations as well as
105   // partially-scanned arrays (in the latter case, we push an oop to
106   // the from-space image of the array and the length on the
107   // from-space image indicates how many entries on the array we still
<span class="line-modified">108   // need to scan. To be able to distinguish between reference</span>

109   // locations and partially-scanned array oops we simply mask the
110   // latter oops with 0x01. The next three methods do the masking,
111   // unmasking, and checking whether the oop is masked or not. Notice
112   // that the signature of the mask and unmask methods looks a bit
113   // strange, as they accept and return different types (oop and
114   // oop*). This is because of the difference in types between what
115   // the task queue holds (oop*) and oops to partially-scanned arrays
116   // (oop). We do all the necessary casting in the mask / unmask
117   // methods to avoid sprinkling the rest of the code with more casts.
118 
119   // These are added to the taskqueue so PS_CHUNKED_ARRAY_OOP_MASK (or any
120   // future masks) can&#39;t conflict with COMPRESSED_OOP_MASK
121 #define PS_CHUNKED_ARRAY_OOP_MASK  0x2
122 
123   bool is_oop_masked(StarTask p) {
124     // If something is marked chunked it&#39;s always treated like wide oop*
125     return (((intptr_t)(oop*)p) &amp; PS_CHUNKED_ARRAY_OOP_MASK) ==
126                                   PS_CHUNKED_ARRAY_OOP_MASK;
127   }
128 
129   oop* mask_chunked_array_oop(oop obj) {
<span class="line-modified">130     assert(!is_oop_masked(cast_from_oop&lt;oop*&gt;(obj)), &quot;invariant&quot;);</span>
131     oop* ret = (oop*) (cast_from_oop&lt;uintptr_t&gt;(obj) | PS_CHUNKED_ARRAY_OOP_MASK);
132     assert(is_oop_masked(ret), &quot;invariant&quot;);
133     return ret;
134   }
135 
136   oop unmask_chunked_array_oop(StarTask p) {
137     assert(is_oop_masked(p), &quot;invariant&quot;);
138     assert(!p.is_narrow(), &quot;chunked array oops cannot be narrow&quot;);
139     oop *chunk = (oop*)p;  // cast p to oop (uses conversion operator)
140     oop ret = oop((oop*)((uintptr_t)chunk &amp; ~PS_CHUNKED_ARRAY_OOP_MASK));
<span class="line-modified">141     assert(!is_oop_masked(cast_from_oop&lt;oop*&gt;(ret)), &quot;invariant&quot;);</span>
142     return ret;
143   }
144 
145   template &lt;class T&gt; void  process_array_chunk_work(oop obj,
146                                                     int start, int end);
147   void process_array_chunk(oop old);
148 
149   template &lt;class T&gt; void push_depth(T* p);
150 
151   inline void promotion_trace_event(oop new_obj, oop old_obj, size_t obj_size,
152                                     uint age, bool tenured,
153                                     const PSPromotionLAB* lab);
154 
155  protected:
156   static OopStarTaskQueueSet* stack_array_depth()   { return _stack_array_depth; }
157  public:
158   // Static
159   static void initialize();
160 
161   static void pre_scavenge();
</pre>
<hr />
<pre>
163 
164   static PSPromotionManager* gc_thread_promotion_manager(uint index);
165   static PSPromotionManager* vm_thread_promotion_manager();
166 
167   static bool steal_depth(int queue_num, StarTask&amp; t);
168 
169   PSPromotionManager();
170 
171   // Accessors
172   OopStarTaskQueue* claimed_stack_depth() {
173     return &amp;_claimed_stack_depth;
174   }
175 
176   bool young_gen_is_full()             { return _young_gen_is_full; }
177 
178   bool old_gen_is_full()               { return _old_gen_is_full; }
179   void set_old_gen_is_full(bool state) { _old_gen_is_full = state; }
180 
181   // Promotion methods
182   template&lt;bool promote_immediately&gt; oop copy_to_survivor_space(oop o);
<span class="line-modified">183   oop oop_promotion_failed(oop obj, markWord obj_mark);</span>
184 
185   void reset();
186   void register_preserved_marks(PreservedMarks* preserved_marks);
187   static void restore_preserved_marks();
188 
189   void flush_labs();
190   void drain_stacks(bool totally_drain) {
191     drain_stacks_depth(totally_drain);
192   }
193  public:
194   void drain_stacks_cond_depth() {
195     if (claimed_stack_depth()-&gt;size() &gt; _target_stack_size) {
196       drain_stacks_depth(false);
197     }
198   }
199   void drain_stacks_depth(bool totally_drain);
200 
201   bool stacks_empty() {
202     return claimed_stack_depth()-&gt;is_empty();
203   }
</pre>
</td>
</tr>
</table>
<center><a href="psPromotionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psPromotionManager.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/psMarkSweepDecorator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
 30 #include &quot;gc/parallel/psMarkSweep.hpp&quot;
 31 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;
 32 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
 33 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 34 #include &quot;gc/shared/spaceDecorator.hpp&quot;
 35 #include &quot;memory/iterator.inline.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;runtime/prefetch.inline.hpp&quot;
 38 
 39 PSMarkSweepDecorator* PSMarkSweepDecorator::_destination_decorator = NULL;
 40 
 41 
 42 void PSMarkSweepDecorator::set_destination_decorator_tenured() {
 43   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 44   _destination_decorator = heap-&gt;old_gen()-&gt;object_mark_sweep();
 45 }
 46 
 47 void PSMarkSweepDecorator::advance_destination_decorator() {
 48   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 49 
 50   assert(_destination_decorator != NULL, &quot;Sanity&quot;);
 51 
 52   PSMarkSweepDecorator* first = heap-&gt;old_gen()-&gt;object_mark_sweep();
 53   PSMarkSweepDecorator* second = heap-&gt;young_gen()-&gt;eden_mark_sweep();
 54   PSMarkSweepDecorator* third = heap-&gt;young_gen()-&gt;from_mark_sweep();
 55   PSMarkSweepDecorator* fourth = heap-&gt;young_gen()-&gt;to_mark_sweep();
 56 
 57   if ( _destination_decorator == first ) {
 58     _destination_decorator = second;
 59   } else if ( _destination_decorator == second ) {
 60     _destination_decorator = third;
 61   } else if ( _destination_decorator == third ) {
 62     _destination_decorator = fourth;
 63   } else {
 64     fatal(&quot;PSMarkSweep attempting to advance past last compaction area&quot;);
 65   }
 66 }
 67 
 68 PSMarkSweepDecorator* PSMarkSweepDecorator::destination_decorator() {
 69   assert(_destination_decorator != NULL, &quot;Sanity&quot;);
 70 
 71   return _destination_decorator;
 72 }
 73 
 74 // FIX ME FIX ME FIX ME FIX ME!!!!!!!!!
 75 // The object forwarding code is duplicated. Factor this out!!!!!
 76 //
 77 // This method &quot;precompacts&quot; objects inside its space to dest. It places forwarding
 78 // pointers into markOops for use by adjust_pointers. If &quot;dest&quot; should overflow, we
 79 // finish by compacting into our own space.
 80 
 81 void PSMarkSweepDecorator::precompact() {
 82   // Reset our own compact top.
 83   set_compaction_top(space()-&gt;bottom());
 84 
 85   /* We allow some amount of garbage towards the bottom of the space, so
 86    * we don&#39;t start compacting before there is a significant gain to be made.
 87    * Occasionally, we want to ensure a full compaction, which is determined
 88    * by the MarkSweepAlwaysCompactCount parameter. This is a significant
 89    * performance improvement!
 90    */
 91   bool skip_dead = ((PSMarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0);
 92 
 93   size_t allowed_deadspace = 0;
 94   if (skip_dead) {
 95     const size_t ratio = allowed_dead_ratio();
 96     allowed_deadspace = space()-&gt;capacity_in_words() * ratio / 100;
 97   }
 98 
 99   // Fetch the current destination decorator
100   PSMarkSweepDecorator* dest = destination_decorator();
101   ObjectStartArray* start_array = dest-&gt;start_array();
102 
103   HeapWord* compact_top = dest-&gt;compaction_top();
104   HeapWord* compact_end = dest-&gt;space()-&gt;end();
105 
106   HeapWord* q = space()-&gt;bottom();
107   HeapWord* t = space()-&gt;top();
108 
109   HeapWord*  end_of_live= q;    /* One byte beyond the last byte of the last
110                                    live object. */
111   HeapWord*  first_dead = space()-&gt;end(); /* The first dead object. */
112 
113   const intx interval = PrefetchScanIntervalInBytes;
114 
115   while (q &lt; t) {
116     assert(oop(q)-&gt;mark_raw()-&gt;is_marked() || oop(q)-&gt;mark_raw()-&gt;is_unlocked() ||
117            oop(q)-&gt;mark_raw()-&gt;has_bias_pattern(),
118            &quot;these are the only valid states during a mark sweep&quot;);
119     if (oop(q)-&gt;is_gc_marked()) {
120       /* prefetch beyond q */
121       Prefetch::write(q, interval);
122       size_t size = oop(q)-&gt;size();
123 
124       size_t compaction_max_size = pointer_delta(compact_end, compact_top);
125 
126       // This should only happen if a space in the young gen overflows the
127       // old gen. If that should happen, we null out the start_array, because
128       // the young spaces are not covered by one.
129       while(size &gt; compaction_max_size) {
130         // First record the last compact_top
131         dest-&gt;set_compaction_top(compact_top);
132 
133         // Advance to the next compaction decorator
134         advance_destination_decorator();
135         dest = destination_decorator();
136 
137         // Update compaction info
138         start_array = dest-&gt;start_array();
139         compact_top = dest-&gt;compaction_top();
140         compact_end = dest-&gt;space()-&gt;end();
141         assert(compact_top == dest-&gt;space()-&gt;bottom(), &quot;Advanced to space already in use&quot;);
142         assert(compact_end &gt; compact_top, &quot;Must always be space remaining&quot;);
143         compaction_max_size =
144           pointer_delta(compact_end, compact_top);
145       }
146 
147       // store the forwarding pointer into the mark word
148       if (q != compact_top) {
149         oop(q)-&gt;forward_to(oop(compact_top));
150         assert(oop(q)-&gt;is_gc_marked(), &quot;encoding the pointer should preserve the mark&quot;);
151       } else {
152         // if the object isn&#39;t moving we can just set the mark to the default
153         // mark and handle it specially later on.
154         oop(q)-&gt;init_mark_raw();
155         assert(oop(q)-&gt;forwardee() == NULL, &quot;should be forwarded to NULL&quot;);
156       }
157 
158       // Update object start array
159       if (start_array) {
160         start_array-&gt;allocate_block(compact_top);
161       }
162 
163       compact_top += size;
164       assert(compact_top &lt;= dest-&gt;space()-&gt;end(),
165         &quot;Exceeding space in destination&quot;);
166 
167       q += size;
168       end_of_live = q;
169     } else {
170       /* run over all the contiguous dead objects */
171       HeapWord* end = q;
172       do {
173         /* prefetch beyond end */
174         Prefetch::write(end, interval);
175         end += oop(end)-&gt;size();
176       } while (end &lt; t &amp;&amp; (!oop(end)-&gt;is_gc_marked()));
177 
178       /* see if we might want to pretend this object is alive so that
179        * we don&#39;t have to compact quite as often.
180        */
181       if (allowed_deadspace &gt; 0 &amp;&amp; q == compact_top) {
182         size_t sz = pointer_delta(end, q);
183         if (insert_deadspace(allowed_deadspace, q, sz)) {
184           size_t compaction_max_size = pointer_delta(compact_end, compact_top);
185 
186           // This should only happen if a space in the young gen overflows the
187           // old gen. If that should happen, we null out the start_array, because
188           // the young spaces are not covered by one.
189           while (sz &gt; compaction_max_size) {
190             // First record the last compact_top
191             dest-&gt;set_compaction_top(compact_top);
192 
193             // Advance to the next compaction decorator
194             advance_destination_decorator();
195             dest = destination_decorator();
196 
197             // Update compaction info
198             start_array = dest-&gt;start_array();
199             compact_top = dest-&gt;compaction_top();
200             compact_end = dest-&gt;space()-&gt;end();
201             assert(compact_top == dest-&gt;space()-&gt;bottom(), &quot;Advanced to space already in use&quot;);
202             assert(compact_end &gt; compact_top, &quot;Must always be space remaining&quot;);
203             compaction_max_size =
204               pointer_delta(compact_end, compact_top);
205           }
206 
207           // store the forwarding pointer into the mark word
208           if (q != compact_top) {
209             oop(q)-&gt;forward_to(oop(compact_top));
210             assert(oop(q)-&gt;is_gc_marked(), &quot;encoding the pointer should preserve the mark&quot;);
211           } else {
212             // if the object isn&#39;t moving we can just set the mark to the default
213             // mark and handle it specially later on.
214             oop(q)-&gt;init_mark_raw();
215             assert(oop(q)-&gt;forwardee() == NULL, &quot;should be forwarded to NULL&quot;);
216           }
217 
218           // Update object start array
219           if (start_array) {
220             start_array-&gt;allocate_block(compact_top);
221           }
222 
223           compact_top += sz;
224           assert(compact_top &lt;= dest-&gt;space()-&gt;end(),
225             &quot;Exceeding space in destination&quot;);
226 
227           q = end;
228           end_of_live = end;
229           continue;
230         }
231       }
232 
233       // q is a pointer to a dead object. Use this dead memory to store a pointer to the next live object.
234       (*(HeapWord**)q) = end;
235 
236       /* see if this is the first dead region. */
237       if (q &lt; first_dead) {
238         first_dead = q;
239       }
240 
241       /* move on to the next object */
242       q = end;
243     }
244   }
245 
246   assert(q == t, &quot;just checking&quot;);
247   _end_of_live = end_of_live;
248   if (end_of_live &lt; first_dead) {
249     first_dead = end_of_live;
250   }
251   _first_dead = first_dead;
252 
253   // Update compaction top
254   dest-&gt;set_compaction_top(compact_top);
255 }
256 
257 bool PSMarkSweepDecorator::insert_deadspace(size_t&amp; allowed_deadspace_words,
258                                             HeapWord* q, size_t deadlength) {
259   if (allowed_deadspace_words &gt;= deadlength) {
260     allowed_deadspace_words -= deadlength;
261     CollectedHeap::fill_with_object(q, deadlength);
262     oop(q)-&gt;set_mark_raw(oop(q)-&gt;mark_raw()-&gt;set_marked());
263     assert((int) deadlength == oop(q)-&gt;size(), &quot;bad filler object size&quot;);
264     // Recall that we required &quot;q == compaction_top&quot;.
265     return true;
266   } else {
267     allowed_deadspace_words = 0;
268     return false;
269   }
270 }
271 
272 void PSMarkSweepDecorator::adjust_pointers() {
273   // adjust all the interior pointers to point at the new locations of objects
274   // Used by MarkSweep::mark_sweep_phase3()
275 
276   HeapWord* q = space()-&gt;bottom();
277   HeapWord* t = _end_of_live;  // Established by &quot;prepare_for_compaction&quot;.
278 
279   assert(_first_dead &lt;= _end_of_live, &quot;Stands to reason, no?&quot;);
280 
281   if (q &lt; t &amp;&amp; _first_dead &gt; q &amp;&amp;
282       !oop(q)-&gt;is_gc_marked()) {
283     // we have a chunk of the space which hasn&#39;t moved and we&#39;ve
284     // reinitialized the mark word during the previous pass, so we can&#39;t
285     // use is_gc_marked for the traversal.
286     HeapWord* end = _first_dead;
287 
288     while (q &lt; end) {
289       // point all the oops to the new location
290       size_t size = MarkSweep::adjust_pointers(oop(q));
291       q += size;
292     }
293 
294     if (_first_dead == t) {
295       q = t;
296     } else {
297       // The first dead object should contain a pointer to the first live object
298       q = *(HeapWord**)_first_dead;
299     }
300   }
301   const intx interval = PrefetchScanIntervalInBytes;
302 
303   debug_only(HeapWord* prev_q = NULL);
304   while (q &lt; t) {
305     // prefetch beyond q
306     Prefetch::write(q, interval);
307     if (oop(q)-&gt;is_gc_marked()) {
308       // q is alive
309       // point all the oops to the new location
310       size_t size = MarkSweep::adjust_pointers(oop(q));
311       debug_only(prev_q = q);
312       q += size;
313     } else {
314       debug_only(prev_q = q);
315       // The first dead object is no longer an object. At that memory address,
316       // there is a pointer to the first live object that the previous phase found.
317       q = *(HeapWord**)q;
318       assert(q &gt; prev_q, &quot;we should be moving forward through memory, q: &quot; PTR_FORMAT &quot;, prev_q: &quot; PTR_FORMAT, p2i(q), p2i(prev_q));
319     }
320   }
321 
322   assert(q == t, &quot;just checking&quot;);
323 }
324 
325 void PSMarkSweepDecorator::compact(bool mangle_free_space ) {
326   // Copy all live objects to their new location
327   // Used by MarkSweep::mark_sweep_phase4()
328 
329   HeapWord*       q = space()-&gt;bottom();
330   HeapWord* const t = _end_of_live;
331   debug_only(HeapWord* prev_q = NULL);
332 
333   if (q &lt; t &amp;&amp; _first_dead &gt; q &amp;&amp;
334       !oop(q)-&gt;is_gc_marked()) {
335 #ifdef ASSERT
336     // we have a chunk of the space which hasn&#39;t moved and we&#39;ve reinitialized the
337     // mark word during the previous pass, so we can&#39;t use is_gc_marked for the
338     // traversal.
339     HeapWord* const end = _first_dead;
340 
341     while (q &lt; end) {
342       size_t size = oop(q)-&gt;size();
343       assert(!oop(q)-&gt;is_gc_marked(), &quot;should be unmarked (special dense prefix handling)&quot;);
344       debug_only(prev_q = q);
345       q += size;
346     }
347 #endif
348 
349     if (_first_dead == t) {
350       q = t;
351     } else {
352       // $$$ Funky
353       q = (HeapWord*) oop(_first_dead)-&gt;mark_raw()-&gt;decode_pointer();
354     }
355   }
356 
357   const intx scan_interval = PrefetchScanIntervalInBytes;
358   const intx copy_interval = PrefetchCopyIntervalInBytes;
359 
360   while (q &lt; t) {
361     if (!oop(q)-&gt;is_gc_marked()) {
362       // mark is pointer to next marked oop
363       debug_only(prev_q = q);
364       q = (HeapWord*) oop(q)-&gt;mark_raw()-&gt;decode_pointer();
365       assert(q &gt; prev_q, &quot;we should be moving forward through memory&quot;);
366     } else {
367       // prefetch beyond q
368       Prefetch::read(q, scan_interval);
369 
370       // size and destination
371       size_t size = oop(q)-&gt;size();
372       HeapWord* compaction_top = (HeapWord*)oop(q)-&gt;forwardee();
373 
374       // prefetch beyond compaction_top
375       Prefetch::write(compaction_top, copy_interval);
376 
377       // copy object and reinit its mark
378       assert(q != compaction_top, &quot;everything in this pass should be moving&quot;);
379       Copy::aligned_conjoint_words(q, compaction_top, size);
380       oop(compaction_top)-&gt;init_mark_raw();
381       assert(oop(compaction_top)-&gt;klass() != NULL, &quot;should have a class&quot;);
382 
383       debug_only(prev_q = q);
384       q += size;
385     }
386   }
387 
388   assert(compaction_top() &gt;= space()-&gt;bottom() &amp;&amp; compaction_top() &lt;= space()-&gt;end(),
389          &quot;should point inside space&quot;);
390   space()-&gt;set_top(compaction_top());
391 
392   if (mangle_free_space) {
393     space()-&gt;mangle_unused_area();
394   }
395 }
    </pre>
  </body>
</html>
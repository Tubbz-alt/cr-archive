<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psAdaptiveSizePolicy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psAdaptiveSizePolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psAdaptiveSizePolicy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58 class PSAdaptiveSizePolicy : public AdaptiveSizePolicy {
 59  friend class PSGCAdaptivePolicyCounters;
 60  private:
 61   // These values are used to record decisions made during the
 62   // policy.  For example, if the young generation was decreased
 63   // to decrease the GC cost of minor collections the value
 64   // decrease_young_gen_for_throughput_true is used.
 65 
 66   // Last calculated sizes, in bytes, and aligned
 67   // NEEDS_CLEANUP should use sizes.hpp,  but it works in ints, not size_t&#39;s
 68 
 69   // Time statistics
 70   AdaptivePaddedAverage* _avg_major_pause;
 71 
 72   // Footprint statistics
 73   AdaptiveWeightedAverage* _avg_base_footprint;
 74 
 75   // Statistical data gathered for GC
 76   GCStats _gc_stats;
 77 
<span class="line-removed"> 78   size_t _survivor_size_limit;   // Limit in bytes of survivor size</span>
 79   const double _collection_cost_margin_fraction;
 80 
 81   // Variable for estimating the major and minor pause times.
 82   // These variables represent linear least-squares fits of
 83   // the data.
 84   //   major pause time vs. old gen size
 85   LinearLeastSquareFit* _major_pause_old_estimator;
 86   //   major pause time vs. young gen size
 87   LinearLeastSquareFit* _major_pause_young_estimator;
 88 
 89 
 90   // These record the most recent collection times.  They
 91   // are available as an alternative to using the averages
 92   // for making ergonomic decisions.
 93   double _latest_major_mutator_interval_seconds;
 94 
 95   const size_t _space_alignment; // alignment for eden, survivors
 96 
 97   const double _gc_minor_pause_goal_sec;    // goal for maximum minor gc pause
 98 
 99   // The amount of live data in the heap at the last full GC, used
100   // as a baseline to help us determine when we need to perform the
101   // next full GC.
102   size_t _live_at_last_full_gc;
103 
104   // decrease/increase the old generation for minor pause time
105   int _change_old_gen_for_min_pauses;
106 
107   // increase/decrease the young generation for major pause time
108   int _change_young_gen_for_maj_pauses;
109 
110 
111   // Flag indicating that the adaptive policy is ready to use
112   bool _old_gen_policy_is_ready;
113 
<span class="line-removed">114   // Changing the generation sizing depends on the data that is</span>
<span class="line-removed">115   // gathered about the effects of changes on the pause times and</span>
<span class="line-removed">116   // throughput.  These variable count the number of data points</span>
<span class="line-removed">117   // gathered.  The policy may use these counters as a threshold</span>
<span class="line-removed">118   // for reliable data.</span>
<span class="line-removed">119   julong _young_gen_change_for_major_pause_count;</span>
<span class="line-removed">120 </span>
121   // To facilitate faster growth at start up, supplement the normal
122   // growth percentage for the young gen eden and the
123   // old gen space for promotion with these value which decay
124   // with increasing collections.
125   uint _young_gen_size_increment_supplement;
126   uint _old_gen_size_increment_supplement;
127 
128   // The number of bytes absorbed from eden into the old gen by moving the
129   // boundary over live data.
130   size_t _bytes_absorbed_from_eden;
131 
132  private:
133 
134   // Accessors
135   AdaptivePaddedAverage* avg_major_pause() const { return _avg_major_pause; }
136   double gc_minor_pause_goal_sec() const { return _gc_minor_pause_goal_sec; }
137 
138   void adjust_eden_for_minor_pause_time(bool is_full_gc,
139                                    size_t* desired_eden_size_ptr);
140   // Change the generation sizes to achieve a GC pause time goal
</pre>
</td>
<td>
<hr />
<pre>
 58 class PSAdaptiveSizePolicy : public AdaptiveSizePolicy {
 59  friend class PSGCAdaptivePolicyCounters;
 60  private:
 61   // These values are used to record decisions made during the
 62   // policy.  For example, if the young generation was decreased
 63   // to decrease the GC cost of minor collections the value
 64   // decrease_young_gen_for_throughput_true is used.
 65 
 66   // Last calculated sizes, in bytes, and aligned
 67   // NEEDS_CLEANUP should use sizes.hpp,  but it works in ints, not size_t&#39;s
 68 
 69   // Time statistics
 70   AdaptivePaddedAverage* _avg_major_pause;
 71 
 72   // Footprint statistics
 73   AdaptiveWeightedAverage* _avg_base_footprint;
 74 
 75   // Statistical data gathered for GC
 76   GCStats _gc_stats;
 77 

 78   const double _collection_cost_margin_fraction;
 79 
 80   // Variable for estimating the major and minor pause times.
 81   // These variables represent linear least-squares fits of
 82   // the data.
 83   //   major pause time vs. old gen size
 84   LinearLeastSquareFit* _major_pause_old_estimator;
 85   //   major pause time vs. young gen size
 86   LinearLeastSquareFit* _major_pause_young_estimator;
 87 
 88 
 89   // These record the most recent collection times.  They
 90   // are available as an alternative to using the averages
 91   // for making ergonomic decisions.
 92   double _latest_major_mutator_interval_seconds;
 93 
 94   const size_t _space_alignment; // alignment for eden, survivors
 95 
 96   const double _gc_minor_pause_goal_sec;    // goal for maximum minor gc pause
 97 
 98   // The amount of live data in the heap at the last full GC, used
 99   // as a baseline to help us determine when we need to perform the
100   // next full GC.
101   size_t _live_at_last_full_gc;
102 
103   // decrease/increase the old generation for minor pause time
104   int _change_old_gen_for_min_pauses;
105 
106   // increase/decrease the young generation for major pause time
107   int _change_young_gen_for_maj_pauses;
108 
109 
110   // Flag indicating that the adaptive policy is ready to use
111   bool _old_gen_policy_is_ready;
112 







113   // To facilitate faster growth at start up, supplement the normal
114   // growth percentage for the young gen eden and the
115   // old gen space for promotion with these value which decay
116   // with increasing collections.
117   uint _young_gen_size_increment_supplement;
118   uint _old_gen_size_increment_supplement;
119 
120   // The number of bytes absorbed from eden into the old gen by moving the
121   // boundary over live data.
122   size_t _bytes_absorbed_from_eden;
123 
124  private:
125 
126   // Accessors
127   AdaptivePaddedAverage* avg_major_pause() const { return _avg_major_pause; }
128   double gc_minor_pause_goal_sec() const { return _gc_minor_pause_goal_sec; }
129 
130   void adjust_eden_for_minor_pause_time(bool is_full_gc,
131                                    size_t* desired_eden_size_ptr);
132   // Change the generation sizes to achieve a GC pause time goal
</pre>
</td>
</tr>
</table>
<center><a href="psAdaptiveSizePolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
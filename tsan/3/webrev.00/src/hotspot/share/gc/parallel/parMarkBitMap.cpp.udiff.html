<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/parMarkBitMap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mutableSpace.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parMarkBitMap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/parMarkBitMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37,11 +37,11 @@</span>
  ParMarkBitMap::initialize(MemRegion covered_region)
  {
    const idx_t bits = bits_required(covered_region);
    // The bits will be divided evenly between two bitmaps; each of them should be
    // an integral number of words.
<span class="udiff-line-modified-removed">-   assert(bits % (BitsPerWord * 2) == 0, &quot;region size unaligned&quot;);</span>
<span class="udiff-line-modified-added">+   assert(is_aligned(bits, (BitsPerWord * 2)), &quot;region size unaligned&quot;);</span>
  
    const size_t words = bits / BitsPerWord;
    const size_t raw_bytes = words * sizeof(idx_t);
    const size_t page_sz = os::page_size_for_region_aligned(raw_bytes, 10);
    const size_t granularity = os::vm_allocation_granularity();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88,11 +88,11 @@</span>
    if (_beg_bits.par_set_bit(beg_bit)) {
      const idx_t end_bit = addr_to_bit(addr + size - 1);
      bool end_bit_ok = _end_bits.par_set_bit(end_bit);
      assert(end_bit_ok, &quot;concurrency problem&quot;);
      DEBUG_ONLY(Atomic::inc(&amp;mark_bitmap_count));
<span class="udiff-line-modified-removed">-     DEBUG_ONLY(Atomic::add(size, &amp;mark_bitmap_size));</span>
<span class="udiff-line-modified-added">+     DEBUG_ONLY(Atomic::add(&amp;mark_bitmap_size, size));</span>
      return true;
    }
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,18 +109,18 @@</span>
  }
  
  size_t
  ParMarkBitMap::live_words_in_range_helper(HeapWord* beg_addr, oop end_obj) const
  {
<span class="udiff-line-modified-removed">-   assert(beg_addr &lt;= (HeapWord*)end_obj, &quot;bad range&quot;);</span>
<span class="udiff-line-modified-added">+   assert(beg_addr &lt;= cast_from_oop&lt;HeapWord*&gt;(end_obj), &quot;bad range&quot;);</span>
    assert(is_marked(end_obj), &quot;end_obj must be live&quot;);
  
    idx_t live_bits = 0;
  
    // The bitmap routines require the right boundary to be word-aligned.
<span class="udiff-line-modified-removed">-   const idx_t end_bit = addr_to_bit((HeapWord*)end_obj);</span>
<span class="udiff-line-modified-removed">-   const idx_t range_end = BitMap::word_align_up(end_bit);</span>
<span class="udiff-line-modified-added">+   const idx_t end_bit = addr_to_bit(cast_from_oop&lt;HeapWord*&gt;(end_obj));</span>
<span class="udiff-line-modified-added">+   const idx_t range_end = align_range_end(end_bit);</span>
  
    idx_t beg_bit = find_obj_beg(addr_to_bit(beg_addr), range_end);
    while (beg_bit &lt; end_bit) {
      idx_t tmp_end = find_obj_end(beg_bit, range_end);
      assert(tmp_end &lt; end_bit, &quot;missing end bit&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132,12 +132,12 @@</span>
  
  size_t
  ParMarkBitMap::live_words_in_range_use_cache(ParCompactionManager* cm, HeapWord* beg_addr, oop end_oop) const
  {
    HeapWord* last_beg = cm-&gt;last_query_begin();
<span class="udiff-line-modified-removed">-   HeapWord* last_obj = (HeapWord*)cm-&gt;last_query_object();</span>
<span class="udiff-line-modified-removed">-   HeapWord* end_obj  = (HeapWord*)end_oop;</span>
<span class="udiff-line-modified-added">+   HeapWord* last_obj = cast_from_oop&lt;HeapWord*&gt;(cm-&gt;last_query_object());</span>
<span class="udiff-line-modified-added">+   HeapWord* end_obj  = cast_from_oop&lt;HeapWord*&gt;(end_oop);</span>
  
    size_t last_ret = cm-&gt;last_query_return();
    if (end_obj &gt; last_obj) {
      last_ret = last_ret + live_words_in_range_helper(last_obj, end_oop);
      last_obj = end_obj;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,11 +175,11 @@</span>
    DEBUG_ONLY(verify_bit(range_beg);)
    DEBUG_ONLY(verify_bit(range_end);)
    assert(range_beg &lt;= range_end, &quot;live range invalid&quot;);
  
    // The bitmap routines require the right boundary to be word-aligned.
<span class="udiff-line-modified-removed">-   const idx_t search_end = BitMap::word_align_up(range_end);</span>
<span class="udiff-line-modified-added">+   const idx_t search_end = align_range_end(range_end);</span>
  
    idx_t cur_beg = find_obj_beg(range_beg, search_end);
    while (cur_beg &lt; range_end) {
      const idx_t cur_end = find_obj_end(cur_beg, search_end);
      if (cur_end &gt;= range_end) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,12 +214,12 @@</span>
    DEBUG_ONLY(verify_bit(dead_range_end);)
    assert(range_beg &lt;= range_end, &quot;live range invalid&quot;);
    assert(range_end &lt;= dead_range_end, &quot;dead range invalid&quot;);
  
    // The bitmap routines require the right boundary to be word-aligned.
<span class="udiff-line-modified-removed">-   const idx_t live_search_end = BitMap::word_align_up(range_end);</span>
<span class="udiff-line-modified-removed">-   const idx_t dead_search_end = BitMap::word_align_up(dead_range_end);</span>
<span class="udiff-line-modified-added">+   const idx_t live_search_end = align_range_end(range_end);</span>
<span class="udiff-line-modified-added">+   const idx_t dead_search_end = align_range_end(dead_range_end);</span>
  
    idx_t cur_beg = range_beg;
    if (range_beg &lt; range_end &amp;&amp; is_unmarked(range_beg)) {
      // The range starts with dead space.  Look for the next object, then fill.
      cur_beg = find_obj_beg(range_beg + 1, dead_search_end);
</pre>
<center><a href="mutableSpace.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parMarkBitMap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/pcTasks.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PCTASKS_HPP
 26 #define SHARE_GC_PARALLEL_PCTASKS_HPP
 27 
 28 #include &quot;gc/parallel/gcTaskManager.hpp&quot;
 29 #include &quot;gc/parallel/psParallelCompact.hpp&quot;
 30 #include &quot;gc/parallel/psTasks.hpp&quot;
 31 
 32 
 33 // Tasks for parallel compaction of the old generation
 34 //
 35 // Tasks are created and enqueued on a task queue. The
 36 // tasks for parallel old collector for marking objects
 37 // are MarkFromRootsTask and ThreadRootsMarkingTask.
 38 //
 39 // MarkFromRootsTask&#39;s are created
 40 // with a root group (e.g., jni_handles) and when the do_it()
 41 // method of a MarkFromRootsTask is executed, it starts marking
 42 // form it&#39;s root group.
 43 //
 44 // ThreadRootsMarkingTask&#39;s are created for each Java thread.  When
 45 // the do_it() method of a ThreadRootsMarkingTask is executed, it
 46 // starts marking from the thread&#39;s roots.
 47 //
 48 // The enqueueing of the MarkFromRootsTask and ThreadRootsMarkingTask
 49 // do little more than create the task and put it on a queue.  The
 50 // queue is a GCTaskQueue and threads steal tasks from this GCTaskQueue.
 51 //
 52 // In addition to the MarkFromRootsTask and ThreadRootsMarkingTask
 53 // tasks there are StealMarkingTask tasks.  The StealMarkingTask&#39;s
 54 // steal a reference from the marking stack of another
 55 // thread and transitively marks the object of the reference
 56 // and internal references.  After successfully stealing a reference
 57 // and marking it, the StealMarkingTask drains its marking stack
 58 // stack before attempting another steal.
 59 //
 60 // ThreadRootsMarkingTask
 61 //
 62 // This task marks from the roots of a single thread. This task
 63 // enables marking of thread roots in parallel.
 64 //
 65 
 66 class ParallelTaskTerminator;
 67 
 68 class ThreadRootsMarkingTask : public GCTask {
 69  private:
 70   Thread* _thread;
 71 
 72  public:
 73   ThreadRootsMarkingTask(Thread* root) : _thread(root) {}
 74 
 75   char* name() { return (char *)&quot;thread-roots-marking-task&quot;; }
 76 
 77   virtual void do_it(GCTaskManager* manager, uint which);
 78 };
 79 
 80 
 81 //
 82 // MarkFromRootsTask
 83 //
 84 // This task marks from all the roots to all live
 85 // objects.
 86 //
 87 //
 88 
 89 class MarkFromRootsTask : public GCTask {
 90  public:
 91   enum RootType {
 92     universe              = 1,
 93     jni_handles           = 2,
 94     threads               = 3,
 95     object_synchronizer   = 4,
 96     management            = 5,
 97     jvmti                 = 6,
 98     system_dictionary     = 7,
 99     class_loader_data     = 8,
100     code_cache            = 9
101   };
102  private:
103   RootType _root_type;
104  public:
105   MarkFromRootsTask(RootType value) : _root_type(value) {}
106 
107   char* name() { return (char *)&quot;mark-from-roots-task&quot;; }
108 
109   virtual void do_it(GCTaskManager* manager, uint which);
110 };
111 
112 //
113 // RefProcTaskProxy
114 //
115 // This task is used as a proxy to parallel reference processing tasks .
116 //
117 
118 class RefProcTaskProxy : public GCTask {
119   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
120   ProcessTask &amp; _rp_task;
121   uint          _work_id;
122 public:
123   RefProcTaskProxy(ProcessTask &amp; rp_task, uint work_id)
124     : _rp_task(rp_task),
125       _work_id(work_id)
126   { }
127 
128 private:
129   virtual char* name() { return (char *)&quot;Process referents by policy in parallel&quot;; }
130 
131   virtual void do_it(GCTaskManager* manager, uint which);
132 };
133 
134 
135 //
136 // RefProcTaskExecutor
137 //
138 // Task executor is an interface for the reference processor to run
139 // tasks using GCTaskManager.
140 //
141 
142 class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {
143   virtual void execute(ProcessTask&amp; task, uint ergo_workers);
144 };
145 
146 
147 //
148 // StealMarkingTask
149 //
150 // This task is used to distribute work to idle threads.
151 //
152 
153 class StealMarkingTask : public GCTask {
154  private:
155    ParallelTaskTerminator* const _terminator;
156  private:
157 
158  public:
159   char* name() { return (char *)&quot;steal-marking-task&quot;; }
160 
161   StealMarkingTask(ParallelTaskTerminator* t);
162 
163   ParallelTaskTerminator* terminator() { return _terminator; }
164 
165   virtual void do_it(GCTaskManager* manager, uint which);
166 };
167 
168 //
169 // CompactionWithStealingTask
170 //
171 // This task is used to distribute work to idle threads.
172 //
173 
174 class CompactionWithStealingTask : public GCTask {
175  private:
176    ParallelTaskTerminator* const _terminator;
177  public:
178   CompactionWithStealingTask(ParallelTaskTerminator* t);
179 
180   char* name() { return (char *)&quot;steal-region-task&quot;; }
181   ParallelTaskTerminator* terminator() { return _terminator; }
182 
183   virtual void do_it(GCTaskManager* manager, uint which);
184 };
185 
186 //
187 // UpdateDensePrefixTask
188 //
189 // This task is used to update the dense prefix
190 // of a space.
191 //
192 
193 class UpdateDensePrefixTask : public GCTask {
194  private:
195   PSParallelCompact::SpaceId _space_id;
196   size_t _region_index_start;
197   size_t _region_index_end;
198 
199  public:
200   char* name() { return (char *)&quot;update-dense_prefix-task&quot;; }
201 
202   UpdateDensePrefixTask(PSParallelCompact::SpaceId space_id,
203                         size_t region_index_start,
204                         size_t region_index_end);
205 
206   virtual void do_it(GCTaskManager* manager, uint which);
207 };
208 #endif // SHARE_GC_PARALLEL_PCTASKS_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/heterogeneousGenerationSizer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/heterogeneousGenerationSizer.hpp&quot;
 27 #include &quot;gc/shared/collectorPolicy.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;runtime/globals_extension.hpp&quot;
 30 #include &quot;runtime/os.hpp&quot;
 31 #include &quot;utilities/align.hpp&quot;
 32 #include &quot;utilities/formatBuffer.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 
 35 const double HeterogeneousGenerationSizer::MaxRamFractionForYoung = 0.8;
 36 
 37 // Check the available dram memory to limit NewSize and MaxNewSize before
 38 // calling base class initialize_flags().
 39 void HeterogeneousGenerationSizer::initialize_flags() {
 40   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);
 41 
 42   julong phys_mem;
 43   // If MaxRam is specified, we use that as maximum physical memory available.
 44   if (FLAG_IS_DEFAULT(MaxRAM)) {
 45     phys_mem = os::physical_memory();
 46     calc_str.append(&quot;Physical_Memory&quot;);
 47   } else {
 48     phys_mem = (julong)MaxRAM;
 49     calc_str.append(&quot;MaxRAM&quot;);
 50   }
 51 
 52   julong reasonable_max = phys_mem;
 53 
 54   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate
 55   // reasonable max size of young generation.
 56   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {
 57     reasonable_max = (julong)(phys_mem / MaxRAMFraction);
 58     calc_str.append(&quot; / MaxRAMFraction&quot;);
 59   } else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {
 60     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
 61     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);
 62   } else {
 63     // We use our own fraction to calculate max size of young generation.
 64     reasonable_max = phys_mem * MaxRamFractionForYoung;
 65     calc_str.append(&quot; * %0.2f&quot;, MaxRamFractionForYoung);
 66   }
 67   reasonable_max = align_up(reasonable_max, _gen_alignment);
 68 
 69   if (MaxNewSize &gt; reasonable_max) {
 70     if (FLAG_IS_CMDLINE(MaxNewSize)) {
 71       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,
 72                             (size_t)reasonable_max, calc_str.buffer());
 73     } else {
 74       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;
 75                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, (size_t)reasonable_max, calc_str.buffer());
 76     }
 77     MaxNewSize = reasonable_max;
 78   }
 79   if (NewSize &gt; reasonable_max) {
 80     if (FLAG_IS_CMDLINE(NewSize)) {
 81       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,
 82                             (size_t)reasonable_max, calc_str.buffer());
 83     }
 84     NewSize = reasonable_max;
 85   }
 86 
 87   // After setting new size flags, call base class initialize_flags()
 88   GenerationSizer::initialize_flags();
 89 }
 90 
 91 bool HeterogeneousGenerationSizer::is_hetero_heap() const {
 92   return true;
 93 }
 94 
 95 size_t HeterogeneousGenerationSizer::heap_reserved_size_bytes() const {
 96   if (UseAdaptiveGCBoundary) {
 97     // This is the size that young gen can grow to, when UseAdaptiveGCBoundary is true.
 98     size_t max_yg_size = _max_heap_byte_size - _min_old_size;
 99     // This is the size that old gen can grow to, when UseAdaptiveGCBoundary is true.
100     size_t max_old_size = _max_heap_byte_size - _min_young_size;
101 
102     return max_yg_size + max_old_size;
103   } else {
104     return _max_heap_byte_size;
105   }
106 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/gc/parallel/adjoiningGenerations.cpp b/src/hotspot/share/gc/parallel/adjoiningGenerations.cpp
--- a/src/hotspot/share/gc/parallel/adjoiningGenerations.cpp
+++ b/src/hotspot/share/gc/parallel/adjoiningGenerations.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,33 +24,32 @@
 
 #include "precompiled.hpp"
 #include "gc/parallel/adjoiningGenerations.hpp"
 #include "gc/parallel/adjoiningGenerationsForHeteroHeap.hpp"
 #include "gc/parallel/adjoiningVirtualSpaces.hpp"
-#include "gc/parallel/generationSizer.hpp"
 #include "gc/parallel/parallelScavengeHeap.hpp"
+#include "gc/parallel/parallelArguments.hpp"
+#include "gc/shared/genArguments.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
 #include "memory/resourceArea.hpp"
 #include "utilities/align.hpp"
 #include "utilities/ostream.hpp"
 
 // If boundary moving is being used, create the young gen and old
 // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
 // the old behavior otherwise (with PSYoungGen and PSOldGen).
 
-AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs,
-                                           GenerationSizer* policy,
-                                           size_t alignment) :
-  _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, policy->min_old_size(),
-                                             policy->min_young_size(), alignment)) {
-  size_t init_low_byte_size = policy->initial_old_size();
-  size_t min_low_byte_size = policy->min_old_size();
-  size_t max_low_byte_size = policy->max_old_size();
-  size_t init_high_byte_size = policy->initial_young_size();
-  size_t min_high_byte_size = policy->min_young_size();
-  size_t max_high_byte_size = policy->max_young_size();
+AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs) :
+  _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, MinOldSize,
+                                             MinNewSize, GenAlignment)) {
+  size_t init_low_byte_size = OldSize;
+  size_t min_low_byte_size = MinOldSize;
+  size_t max_low_byte_size = MaxOldSize;
+  size_t init_high_byte_size = NewSize;
+  size_t min_high_byte_size = MinNewSize;
+  size_t max_high_byte_size = MaxNewSize;
 
   assert(min_low_byte_size <= init_low_byte_size &&
          init_low_byte_size <= max_low_byte_size, "Parameter check");
   assert(min_high_byte_size <= init_high_byte_size &&
          init_high_byte_size <= max_high_byte_size, "Parameter check");
@@ -93,11 +92,11 @@
   } else {
 
     // Layout the reserved space for the generations.
     // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
     ReservedSpace old_rs   =
-      virtual_spaces()->reserved_space().first_part(max_low_byte_size, policy->is_hetero_heap() /* split */);
+      virtual_spaces()->reserved_space().first_part(max_low_byte_size, ParallelArguments::is_heterogeneous_heap() /* split */);
     ReservedSpace heap_rs  =
       virtual_spaces()->reserved_space().last_part(max_low_byte_size);
     ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
     assert(young_rs.size() == heap_rs.size(), "Didn't reserve all of the heap");
 
@@ -109,19 +108,19 @@
                             min_low_byte_size,
                             max_low_byte_size,
                             "old", 1);
 
     // The virtual spaces are created by the initialization of the gens.
-    _young_gen->initialize(young_rs, alignment);
+    _young_gen->initialize(young_rs, GenAlignment);
     assert(young_gen()->gen_size_limit() == young_rs.size(),
       "Consistency check");
-    _old_gen->initialize(old_rs, alignment, "old", 1);
+    _old_gen->initialize(old_rs, GenAlignment, "old", 1);
     assert(old_gen()->gen_size_limit() == old_rs.size(), "Consistency check");
   }
 }
 
-AdjoiningGenerations::AdjoiningGenerations() { }
+AdjoiningGenerations::AdjoiningGenerations(): _young_gen(NULL), _old_gen(NULL), _virtual_spaces(NULL) { }
 
 size_t AdjoiningGenerations::reserved_byte_size() {
   return virtual_spaces()->reserved_space().size();
 }
 
@@ -282,14 +281,12 @@
       request_young_gen_expansion(desired_size - committed);
     }
   }
 }
 
-AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs,
-                                                                         GenerationSizer* policy,
-                                                                         size_t alignment) {
-  if (policy->is_hetero_heap() && UseAdaptiveGCBoundary) {
-    return new AdjoiningGenerationsForHeteroHeap(old_young_rs, policy, alignment);
+AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs) {
+  if (ParallelArguments::is_heterogeneous_heap() && UseAdaptiveGCBoundary) {
+    return new AdjoiningGenerationsForHeteroHeap(old_young_rs);
   } else {
-    return new AdjoiningGenerations(old_young_rs, policy, alignment);
+    return new AdjoiningGenerations(old_young_rs);
   }
 }

diff a/src/hotspot/share/gc/parallel/psCompactionManager.cpp b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
--- a/src/hotspot/share/gc/parallel/psCompactionManager.cpp
+++ b/src/hotspot/share/gc/parallel/psCompactionManager.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,11 +22,10 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "classfile/systemDictionary.hpp"
-#include "gc/parallel/gcTaskManager.hpp"
 #include "gc/parallel/objectStartArray.hpp"
 #include "gc/parallel/parMarkBitMap.inline.hpp"
 #include "gc/parallel/parallelScavengeHeap.hpp"
 #include "gc/parallel/psCompactionManager.inline.hpp"
 #include "gc/parallel/psOldGen.hpp"
@@ -38,24 +37,24 @@
 #include "oops/compressedOops.inline.hpp"
 #include "oops/instanceKlass.inline.hpp"
 #include "oops/instanceMirrorKlass.inline.hpp"
 #include "oops/objArrayKlass.inline.hpp"
 #include "oops/oop.inline.hpp"
-#include "runtime/atomic.hpp"
 
-PSOldGen*            ParCompactionManager::_old_gen = NULL;
+PSOldGen*               ParCompactionManager::_old_gen = NULL;
 ParCompactionManager**  ParCompactionManager::_manager_array = NULL;
 
-OopTaskQueueSet*     ParCompactionManager::_stack_array = NULL;
-ParCompactionManager::ObjArrayTaskQueueSet*
-  ParCompactionManager::_objarray_queues = NULL;
+ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = NULL;
+ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = NULL;
+ParCompactionManager::RegionTaskQueueSet*   ParCompactionManager::_region_task_queues = NULL;
+
 ObjectStartArray*    ParCompactionManager::_start_array = NULL;
 ParMarkBitMap*       ParCompactionManager::_mark_bitmap = NULL;
-RegionTaskQueueSet*  ParCompactionManager::_region_array = NULL;
+GrowableArray<size_t >* ParCompactionManager::_shadow_region_array = NULL;
+Monitor*                ParCompactionManager::_shadow_region_monitor = NULL;
 
-ParCompactionManager::ParCompactionManager() :
-    _action(CopyAndUpdate) {
+ParCompactionManager::ParCompactionManager() {
 
   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 
   _old_gen = heap->old_gen();
   _start_array = old_gen()->start_array();
@@ -66,66 +65,51 @@
 
   reset_bitmap_query_cache();
 }
 
 void ParCompactionManager::initialize(ParMarkBitMap* mbm) {
-  assert(PSParallelCompact::gc_task_manager() != NULL,
+  assert(ParallelScavengeHeap::heap() != NULL,
     "Needed for initialization");
 
   _mark_bitmap = mbm;
 
-  uint parallel_gc_threads = PSParallelCompact::gc_task_manager()->workers();
+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();
 
   assert(_manager_array == NULL, "Attempt to initialize twice");
   _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads+1, mtGC);
-  guarantee(_manager_array != NULL, "Could not allocate manager_array");
 
-  _stack_array = new OopTaskQueueSet(parallel_gc_threads);
-  guarantee(_stack_array != NULL, "Could not allocate stack_array");
-  _objarray_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);
-  guarantee(_objarray_queues != NULL, "Could not allocate objarray_queues");
-  _region_array = new RegionTaskQueueSet(parallel_gc_threads);
-  guarantee(_region_array != NULL, "Could not allocate region_array");
+  _oop_task_queues = new OopTaskQueueSet(parallel_gc_threads);
+  _objarray_task_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);
+  _region_task_queues = new RegionTaskQueueSet(parallel_gc_threads);
 
   // Create and register the ParCompactionManager(s) for the worker threads.
   for(uint i=0; i<parallel_gc_threads; i++) {
     _manager_array[i] = new ParCompactionManager();
-    guarantee(_manager_array[i] != NULL, "Could not create ParCompactionManager");
-    stack_array()->register_queue(i, _manager_array[i]->marking_stack());
-    _objarray_queues->register_queue(i, &_manager_array[i]->_objarray_stack);
-    region_array()->register_queue(i, _manager_array[i]->region_stack());
+    oop_task_queues()->register_queue(i, _manager_array[i]->marking_stack());
+    _objarray_task_queues->register_queue(i, &_manager_array[i]->_objarray_stack);
+    region_task_queues()->register_queue(i, _manager_array[i]->region_stack());
   }
 
   // The VMThread gets its own ParCompactionManager, which is not available
   // for work stealing.
   _manager_array[parallel_gc_threads] = new ParCompactionManager();
-  guarantee(_manager_array[parallel_gc_threads] != NULL,
-    "Could not create ParCompactionManager");
-  assert(PSParallelCompact::gc_task_manager()->workers() != 0,
+  assert(ParallelScavengeHeap::heap()->workers().total_workers() != 0,
     "Not initialized?");
+
+  _shadow_region_array = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<size_t >(10, true);
+
+  _shadow_region_monitor = new Monitor(Mutex::barrier, "CompactionManager monitor",
+                                       Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);
 }
 
 void ParCompactionManager::reset_all_bitmap_query_caches() {
-  uint parallel_gc_threads = PSParallelCompact::gc_task_manager()->workers();
+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().total_workers();
   for (uint i=0; i<=parallel_gc_threads; i++) {
     _manager_array[i]->reset_bitmap_query_cache();
   }
 }
 
-bool ParCompactionManager::should_update() {
-  assert(action() != NotValid, "Action is not set");
-  return (action() == ParCompactionManager::Update) ||
-         (action() == ParCompactionManager::CopyAndUpdate) ||
-         (action() == ParCompactionManager::UpdateAndCopy);
-}
-
-bool ParCompactionManager::should_copy() {
-  assert(action() != NotValid, "Action is not set");
-  return (action() == ParCompactionManager::Copy) ||
-         (action() == ParCompactionManager::CopyAndUpdate) ||
-         (action() == ParCompactionManager::UpdateAndCopy);
-}
 
 ParCompactionManager*
 ParCompactionManager::gc_thread_compaction_manager(uint index) {
   assert(index < ParallelGCThreads, "index out of range");
   assert(_manager_array != NULL, "Sanity");
@@ -164,5 +148,35 @@
     while (region_stack()->pop_local(region_index)) {
       PSParallelCompact::fill_and_update_region(this, region_index);
     }
   } while (!region_stack()->is_empty());
 }
+
+size_t ParCompactionManager::pop_shadow_region_mt_safe(PSParallelCompact::RegionData* region_ptr) {
+  MonitorLocker ml(_shadow_region_monitor, Mutex::_no_safepoint_check_flag);
+  while (true) {
+    if (!_shadow_region_array->is_empty()) {
+      return _shadow_region_array->pop();
+    }
+    // Check if the corresponding heap region is available now.
+    // If so, we don't need to get a shadow region anymore, and
+    // we return InvalidShadow to indicate such a case.
+    if (region_ptr->claimed()) {
+      return InvalidShadow;
+    }
+    ml.wait(1);
+  }
+}
+
+void ParCompactionManager::push_shadow_region_mt_safe(size_t shadow_region) {
+  MonitorLocker ml(_shadow_region_monitor, Mutex::_no_safepoint_check_flag);
+  _shadow_region_array->push(shadow_region);
+  ml.notify();
+}
+
+void ParCompactionManager::push_shadow_region(size_t shadow_region) {
+  _shadow_region_array->push(shadow_region);
+}
+
+void ParCompactionManager::remove_all_shadow_regions() {
+  _shadow_region_array->clear();
+}

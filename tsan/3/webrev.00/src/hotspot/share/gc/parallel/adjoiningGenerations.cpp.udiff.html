<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../g1/vmStructs_g1.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adjoiningGenerations.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,33 +24,32 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
  #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  
  // If boundary moving is being used, create the young gen and old
  // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
  // the old behavior otherwise (with PSYoungGen and PSOldGen).
  
<span class="udiff-line-modified-removed">- AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs,</span>
<span class="udiff-line-modified-removed">-                                            GenerationSizer* policy,</span>
<span class="udiff-line-modified-removed">-                                            size_t alignment) :</span>
<span class="udiff-line-modified-removed">-   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, policy-&gt;min_old_size(),</span>
<span class="udiff-line-modified-removed">-                                              policy-&gt;min_young_size(), alignment)) {</span>
<span class="udiff-line-modified-removed">-   size_t init_low_byte_size = policy-&gt;initial_old_size();</span>
<span class="udiff-line-modified-removed">-   size_t min_low_byte_size = policy-&gt;min_old_size();</span>
<span class="udiff-line-modified-removed">-   size_t max_low_byte_size = policy-&gt;max_old_size();</span>
<span class="udiff-line-modified-removed">-   size_t init_high_byte_size = policy-&gt;initial_young_size();</span>
<span class="udiff-line-removed">-   size_t min_high_byte_size = policy-&gt;min_young_size();</span>
<span class="udiff-line-removed">-   size_t max_high_byte_size = policy-&gt;max_young_size();</span>
<span class="udiff-line-modified-added">+ AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs) :</span>
<span class="udiff-line-modified-added">+   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, MinOldSize,</span>
<span class="udiff-line-modified-added">+                                              MinNewSize, GenAlignment)) {</span>
<span class="udiff-line-modified-added">+   size_t init_low_byte_size = OldSize;</span>
<span class="udiff-line-modified-added">+   size_t min_low_byte_size = MinOldSize;</span>
<span class="udiff-line-modified-added">+   size_t max_low_byte_size = MaxOldSize;</span>
<span class="udiff-line-modified-added">+   size_t init_high_byte_size = NewSize;</span>
<span class="udiff-line-modified-added">+   size_t min_high_byte_size = MinNewSize;</span>
<span class="udiff-line-modified-added">+   size_t max_high_byte_size = MaxNewSize;</span>
  
    assert(min_low_byte_size &lt;= init_low_byte_size &amp;&amp;
           init_low_byte_size &lt;= max_low_byte_size, &quot;Parameter check&quot;);
    assert(min_high_byte_size &lt;= init_high_byte_size &amp;&amp;
           init_high_byte_size &lt;= max_high_byte_size, &quot;Parameter check&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,11 +92,11 @@</span>
    } else {
  
      // Layout the reserved space for the generations.
      // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
      ReservedSpace old_rs   =
<span class="udiff-line-modified-removed">-       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, policy-&gt;is_hetero_heap() /* split */);</span>
<span class="udiff-line-modified-added">+       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, ParallelArguments::is_heterogeneous_heap() /* split */);</span>
      ReservedSpace heap_rs  =
        virtual_spaces()-&gt;reserved_space().last_part(max_low_byte_size);
      ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
      assert(young_rs.size() == heap_rs.size(), &quot;Didn&#39;t reserve all of the heap&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,19 +108,19 @@</span>
                              min_low_byte_size,
                              max_low_byte_size,
                              &quot;old&quot;, 1);
  
      // The virtual spaces are created by the initialization of the gens.
<span class="udiff-line-modified-removed">-     _young_gen-&gt;initialize(young_rs, alignment);</span>
<span class="udiff-line-modified-added">+     _young_gen-&gt;initialize(young_rs, GenAlignment);</span>
      assert(young_gen()-&gt;gen_size_limit() == young_rs.size(),
        &quot;Consistency check&quot;);
<span class="udiff-line-modified-removed">-     _old_gen-&gt;initialize(old_rs, alignment, &quot;old&quot;, 1);</span>
<span class="udiff-line-modified-added">+     _old_gen-&gt;initialize(old_rs, GenAlignment, &quot;old&quot;, 1);</span>
      assert(old_gen()-&gt;gen_size_limit() == old_rs.size(), &quot;Consistency check&quot;);
    }
  }
  
<span class="udiff-line-modified-removed">- AdjoiningGenerations::AdjoiningGenerations() { }</span>
<span class="udiff-line-modified-added">+ AdjoiningGenerations::AdjoiningGenerations(): _young_gen(NULL), _old_gen(NULL), _virtual_spaces(NULL) { }</span>
  
  size_t AdjoiningGenerations::reserved_byte_size() {
    return virtual_spaces()-&gt;reserved_space().size();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -282,14 +281,12 @@</span>
        request_young_gen_expansion(desired_size - committed);
      }
    }
  }
  
<span class="udiff-line-modified-removed">- AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs,</span>
<span class="udiff-line-modified-removed">-                                                                          GenerationSizer* policy,</span>
<span class="udiff-line-modified-removed">-                                                                          size_t alignment) {</span>
<span class="udiff-line-removed">-   if (policy-&gt;is_hetero_heap() &amp;&amp; UseAdaptiveGCBoundary) {</span>
<span class="udiff-line-removed">-     return new AdjoiningGenerationsForHeteroHeap(old_young_rs, policy, alignment);</span>
<span class="udiff-line-modified-added">+ AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs) {</span>
<span class="udiff-line-modified-added">+   if (ParallelArguments::is_heterogeneous_heap() &amp;&amp; UseAdaptiveGCBoundary) {</span>
<span class="udiff-line-modified-added">+     return new AdjoiningGenerationsForHeteroHeap(old_young_rs);</span>
    } else {
<span class="udiff-line-modified-removed">-     return new AdjoiningGenerations(old_young_rs, policy, alignment);</span>
<span class="udiff-line-modified-added">+     return new AdjoiningGenerations(old_young_rs);</span>
    }
  }
</pre>
<center><a href="../g1/vmStructs_g1.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adjoiningGenerations.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
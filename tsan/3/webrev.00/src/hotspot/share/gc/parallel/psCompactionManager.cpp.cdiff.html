<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/psCompactionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psCardTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psCompactionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,11 ***</span>
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-removed">- #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
  #include &quot;gc/parallel/objectStartArray.hpp&quot;
  #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  #include &quot;gc/parallel/psOldGen.hpp&quot;
<span class="line-new-header">--- 22,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,24 ***</span>
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/instanceKlass.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-removed">- #include &quot;runtime/atomic.hpp&quot;</span>
  
<span class="line-modified">! PSOldGen*            ParCompactionManager::_old_gen = NULL;</span>
  ParCompactionManager**  ParCompactionManager::_manager_array = NULL;
  
<span class="line-modified">! OopTaskQueueSet*     ParCompactionManager::_stack_array = NULL;</span>
<span class="line-modified">! ParCompactionManager::ObjArrayTaskQueueSet*</span>
<span class="line-modified">!   ParCompactionManager::_objarray_queues = NULL;</span>
  ObjectStartArray*    ParCompactionManager::_start_array = NULL;
  ParMarkBitMap*       ParCompactionManager::_mark_bitmap = NULL;
<span class="line-modified">! RegionTaskQueueSet*  ParCompactionManager::_region_array = NULL;</span>
  
<span class="line-modified">! ParCompactionManager::ParCompactionManager() :</span>
<span class="line-removed">-     _action(CopyAndUpdate) {</span>
  
    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
  
    _old_gen = heap-&gt;old_gen();
    _start_array = old_gen()-&gt;start_array();
<span class="line-new-header">--- 37,24 ---</span>
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/instanceKlass.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  
<span class="line-modified">! PSOldGen*               ParCompactionManager::_old_gen = NULL;</span>
  ParCompactionManager**  ParCompactionManager::_manager_array = NULL;
  
<span class="line-modified">! ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = NULL;</span>
<span class="line-modified">! ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = NULL;</span>
<span class="line-modified">! ParCompactionManager::RegionTaskQueueSet*   ParCompactionManager::_region_task_queues = NULL;</span>
<span class="line-added">+ </span>
  ObjectStartArray*    ParCompactionManager::_start_array = NULL;
  ParMarkBitMap*       ParCompactionManager::_mark_bitmap = NULL;
<span class="line-modified">! GrowableArray&lt;size_t &gt;* ParCompactionManager::_shadow_region_array = NULL;</span>
<span class="line-added">+ Monitor*                ParCompactionManager::_shadow_region_monitor = NULL;</span>
  
<span class="line-modified">! ParCompactionManager::ParCompactionManager() {</span>
  
    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
  
    _old_gen = heap-&gt;old_gen();
    _start_array = old_gen()-&gt;start_array();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,66 ***</span>
  
    reset_bitmap_query_cache();
  }
  
  void ParCompactionManager::initialize(ParMarkBitMap* mbm) {
<span class="line-modified">!   assert(PSParallelCompact::gc_task_manager() != NULL,</span>
      &quot;Needed for initialization&quot;);
  
    _mark_bitmap = mbm;
  
<span class="line-modified">!   uint parallel_gc_threads = PSParallelCompact::gc_task_manager()-&gt;workers();</span>
  
    assert(_manager_array == NULL, &quot;Attempt to initialize twice&quot;);
    _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads+1, mtGC);
<span class="line-removed">-   guarantee(_manager_array != NULL, &quot;Could not allocate manager_array&quot;);</span>
  
<span class="line-modified">!   _stack_array = new OopTaskQueueSet(parallel_gc_threads);</span>
<span class="line-modified">!   guarantee(_stack_array != NULL, &quot;Could not allocate stack_array&quot;);</span>
<span class="line-modified">!   _objarray_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);</span>
<span class="line-removed">-   guarantee(_objarray_queues != NULL, &quot;Could not allocate objarray_queues&quot;);</span>
<span class="line-removed">-   _region_array = new RegionTaskQueueSet(parallel_gc_threads);</span>
<span class="line-removed">-   guarantee(_region_array != NULL, &quot;Could not allocate region_array&quot;);</span>
  
    // Create and register the ParCompactionManager(s) for the worker threads.
    for(uint i=0; i&lt;parallel_gc_threads; i++) {
      _manager_array[i] = new ParCompactionManager();
<span class="line-modified">!     guarantee(_manager_array[i] != NULL, &quot;Could not create ParCompactionManager&quot;);</span>
<span class="line-modified">!     stack_array()-&gt;register_queue(i, _manager_array[i]-&gt;marking_stack());</span>
<span class="line-modified">!     _objarray_queues-&gt;register_queue(i, &amp;_manager_array[i]-&gt;_objarray_stack);</span>
<span class="line-removed">-     region_array()-&gt;register_queue(i, _manager_array[i]-&gt;region_stack());</span>
    }
  
    // The VMThread gets its own ParCompactionManager, which is not available
    // for work stealing.
    _manager_array[parallel_gc_threads] = new ParCompactionManager();
<span class="line-modified">!   guarantee(_manager_array[parallel_gc_threads] != NULL,</span>
<span class="line-removed">-     &quot;Could not create ParCompactionManager&quot;);</span>
<span class="line-removed">-   assert(PSParallelCompact::gc_task_manager()-&gt;workers() != 0,</span>
      &quot;Not initialized?&quot;);
  }
  
  void ParCompactionManager::reset_all_bitmap_query_caches() {
<span class="line-modified">!   uint parallel_gc_threads = PSParallelCompact::gc_task_manager()-&gt;workers();</span>
    for (uint i=0; i&lt;=parallel_gc_threads; i++) {
      _manager_array[i]-&gt;reset_bitmap_query_cache();
    }
  }
  
<span class="line-removed">- bool ParCompactionManager::should_update() {</span>
<span class="line-removed">-   assert(action() != NotValid, &quot;Action is not set&quot;);</span>
<span class="line-removed">-   return (action() == ParCompactionManager::Update) ||</span>
<span class="line-removed">-          (action() == ParCompactionManager::CopyAndUpdate) ||</span>
<span class="line-removed">-          (action() == ParCompactionManager::UpdateAndCopy);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ParCompactionManager::should_copy() {</span>
<span class="line-removed">-   assert(action() != NotValid, &quot;Action is not set&quot;);</span>
<span class="line-removed">-   return (action() == ParCompactionManager::Copy) ||</span>
<span class="line-removed">-          (action() == ParCompactionManager::CopyAndUpdate) ||</span>
<span class="line-removed">-          (action() == ParCompactionManager::UpdateAndCopy);</span>
<span class="line-removed">- }</span>
  
  ParCompactionManager*
  ParCompactionManager::gc_thread_compaction_manager(uint index) {
    assert(index &lt; ParallelGCThreads, &quot;index out of range&quot;);
    assert(_manager_array != NULL, &quot;Sanity&quot;);
<span class="line-new-header">--- 65,51 ---</span>
  
    reset_bitmap_query_cache();
  }
  
  void ParCompactionManager::initialize(ParMarkBitMap* mbm) {
<span class="line-modified">!   assert(ParallelScavengeHeap::heap() != NULL,</span>
      &quot;Needed for initialization&quot;);
  
    _mark_bitmap = mbm;
  
<span class="line-modified">!   uint parallel_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().total_workers();</span>
  
    assert(_manager_array == NULL, &quot;Attempt to initialize twice&quot;);
    _manager_array = NEW_C_HEAP_ARRAY(ParCompactionManager*, parallel_gc_threads+1, mtGC);
  
<span class="line-modified">!   _oop_task_queues = new OopTaskQueueSet(parallel_gc_threads);</span>
<span class="line-modified">!   _objarray_task_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);</span>
<span class="line-modified">!   _region_task_queues = new RegionTaskQueueSet(parallel_gc_threads);</span>
  
    // Create and register the ParCompactionManager(s) for the worker threads.
    for(uint i=0; i&lt;parallel_gc_threads; i++) {
      _manager_array[i] = new ParCompactionManager();
<span class="line-modified">!     oop_task_queues()-&gt;register_queue(i, _manager_array[i]-&gt;marking_stack());</span>
<span class="line-modified">!     _objarray_task_queues-&gt;register_queue(i, &amp;_manager_array[i]-&gt;_objarray_stack);</span>
<span class="line-modified">!     region_task_queues()-&gt;register_queue(i, _manager_array[i]-&gt;region_stack());</span>
    }
  
    // The VMThread gets its own ParCompactionManager, which is not available
    // for work stealing.
    _manager_array[parallel_gc_threads] = new ParCompactionManager();
<span class="line-modified">!   assert(ParallelScavengeHeap::heap()-&gt;workers().total_workers() != 0,</span>
      &quot;Not initialized?&quot;);
<span class="line-added">+ </span>
<span class="line-added">+   _shadow_region_array = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;size_t &gt;(10, true);</span>
<span class="line-added">+ </span>
<span class="line-added">+   _shadow_region_monitor = new Monitor(Mutex::barrier, &quot;CompactionManager monitor&quot;,</span>
<span class="line-added">+                                        Mutex::_allow_vm_block_flag, Monitor::_safepoint_check_never);</span>
  }
  
  void ParCompactionManager::reset_all_bitmap_query_caches() {
<span class="line-modified">!   uint parallel_gc_threads = ParallelScavengeHeap::heap()-&gt;workers().total_workers();</span>
    for (uint i=0; i&lt;=parallel_gc_threads; i++) {
      _manager_array[i]-&gt;reset_bitmap_query_cache();
    }
  }
  
  
  ParCompactionManager*
  ParCompactionManager::gc_thread_compaction_manager(uint index) {
    assert(index &lt; ParallelGCThreads, &quot;index out of range&quot;);
    assert(_manager_array != NULL, &quot;Sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,5 ***</span>
<span class="line-new-header">--- 148,35 ---</span>
      while (region_stack()-&gt;pop_local(region_index)) {
        PSParallelCompact::fill_and_update_region(this, region_index);
      }
    } while (!region_stack()-&gt;is_empty());
  }
<span class="line-added">+ </span>
<span class="line-added">+ size_t ParCompactionManager::pop_shadow_region_mt_safe(PSParallelCompact::RegionData* region_ptr) {</span>
<span class="line-added">+   MonitorLocker ml(_shadow_region_monitor, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   while (true) {</span>
<span class="line-added">+     if (!_shadow_region_array-&gt;is_empty()) {</span>
<span class="line-added">+       return _shadow_region_array-&gt;pop();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Check if the corresponding heap region is available now.</span>
<span class="line-added">+     // If so, we don&#39;t need to get a shadow region anymore, and</span>
<span class="line-added">+     // we return InvalidShadow to indicate such a case.</span>
<span class="line-added">+     if (region_ptr-&gt;claimed()) {</span>
<span class="line-added">+       return InvalidShadow;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ml.wait(1);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParCompactionManager::push_shadow_region_mt_safe(size_t shadow_region) {</span>
<span class="line-added">+   MonitorLocker ml(_shadow_region_monitor, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">+   _shadow_region_array-&gt;push(shadow_region);</span>
<span class="line-added">+   ml.notify();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParCompactionManager::push_shadow_region(size_t shadow_region) {</span>
<span class="line-added">+   _shadow_region_array-&gt;push(shadow_region);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ParCompactionManager::remove_all_shadow_regions() {</span>
<span class="line-added">+   _shadow_region_array-&gt;clear();</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="psCardTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psCompactionManager.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
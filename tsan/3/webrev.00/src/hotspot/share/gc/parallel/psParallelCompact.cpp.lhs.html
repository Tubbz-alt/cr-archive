<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  33 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-removed">  36 #include &quot;gc/parallel/pcTasks.hpp&quot;</span>
  37 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  38 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  39 #include &quot;gc/parallel/psOldGen.hpp&quot;
  40 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  41 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
<a name="4" id="anc4"></a>
  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/referencePolicy.hpp&quot;
  53 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  54 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
<a name="5" id="anc5"></a><span class="line-modified">  55 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>

  56 #include &quot;gc/shared/weakProcessor.hpp&quot;
<a name="6" id="anc6"></a>

  57 #include &quot;logging/log.hpp&quot;
  58 #include &quot;memory/iterator.inline.hpp&quot;
  59 #include &quot;memory/resourceArea.hpp&quot;
<a name="7" id="anc7"></a>
  60 #include &quot;oops/access.inline.hpp&quot;
  61 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  62 #include &quot;oops/instanceKlass.inline.hpp&quot;
  63 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  64 #include &quot;oops/methodData.hpp&quot;
  65 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  66 #include &quot;oops/oop.inline.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/safepoint.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;services/management.hpp&quot;
  72 #include &quot;services/memTracker.hpp&quot;
  73 #include &quot;services/memoryService.hpp&quot;
  74 #include &quot;utilities/align.hpp&quot;
  75 #include &quot;utilities/debug.hpp&quot;
  76 #include &quot;utilities/events.hpp&quot;
  77 #include &quot;utilities/formatBuffer.hpp&quot;
  78 #include &quot;utilities/macros.hpp&quot;
  79 #include &quot;utilities/stack.inline.hpp&quot;
<a name="8" id="anc8"></a>


  80 
  81 #include &lt;math.h&gt;
  82 
  83 // All sizes are in HeapWords.
  84 const size_t ParallelCompactData::Log2RegionSize  = 16; // 64K words
  85 const size_t ParallelCompactData::RegionSize      = (size_t)1 &lt;&lt; Log2RegionSize;
  86 const size_t ParallelCompactData::RegionSizeBytes =
  87   RegionSize &lt;&lt; LogHeapWordSize;
  88 const size_t ParallelCompactData::RegionSizeOffsetMask = RegionSize - 1;
  89 const size_t ParallelCompactData::RegionAddrOffsetMask = RegionSizeBytes - 1;
  90 const size_t ParallelCompactData::RegionAddrMask       = ~RegionAddrOffsetMask;
  91 
  92 const size_t ParallelCompactData::Log2BlockSize   = 7; // 128 words
  93 const size_t ParallelCompactData::BlockSize       = (size_t)1 &lt;&lt; Log2BlockSize;
  94 const size_t ParallelCompactData::BlockSizeBytes  =
  95   BlockSize &lt;&lt; LogHeapWordSize;
  96 const size_t ParallelCompactData::BlockSizeOffsetMask = BlockSize - 1;
  97 const size_t ParallelCompactData::BlockAddrOffsetMask = BlockSizeBytes - 1;
  98 const size_t ParallelCompactData::BlockAddrMask       = ~BlockAddrOffsetMask;
  99 
 100 const size_t ParallelCompactData::BlocksPerRegion = RegionSize / BlockSize;
 101 const size_t ParallelCompactData::Log2BlocksPerRegion =
 102   Log2RegionSize - Log2BlockSize;
 103 
 104 const ParallelCompactData::RegionData::region_sz_t
 105 ParallelCompactData::RegionData::dc_shift = 27;
 106 
 107 const ParallelCompactData::RegionData::region_sz_t
 108 ParallelCompactData::RegionData::dc_mask = ~0U &lt;&lt; dc_shift;
 109 
 110 const ParallelCompactData::RegionData::region_sz_t
 111 ParallelCompactData::RegionData::dc_one = 0x1U &lt;&lt; dc_shift;
 112 
 113 const ParallelCompactData::RegionData::region_sz_t
 114 ParallelCompactData::RegionData::los_mask = ~dc_mask;
 115 
 116 const ParallelCompactData::RegionData::region_sz_t
 117 ParallelCompactData::RegionData::dc_claimed = 0x8U &lt;&lt; dc_shift;
 118 
 119 const ParallelCompactData::RegionData::region_sz_t
 120 ParallelCompactData::RegionData::dc_completed = 0xcU &lt;&lt; dc_shift;
 121 
 122 SpaceInfo PSParallelCompact::_space_info[PSParallelCompact::last_space_id];
 123 
 124 SpanSubjectToDiscoveryClosure PSParallelCompact::_span_based_discoverer;
 125 ReferenceProcessor* PSParallelCompact::_ref_processor = NULL;
 126 
 127 double PSParallelCompact::_dwl_mean;
 128 double PSParallelCompact::_dwl_std_dev;
 129 double PSParallelCompact::_dwl_first_term;
 130 double PSParallelCompact::_dwl_adjustment;
 131 #ifdef  ASSERT
 132 bool   PSParallelCompact::_dwl_initialized = false;
 133 #endif  // #ifdef ASSERT
 134 
 135 void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,
 136                        HeapWord* destination)
 137 {
 138   assert(src_region_idx != 0, &quot;invalid src_region_idx&quot;);
 139   assert(partial_obj_size != 0, &quot;invalid partial_obj_size argument&quot;);
 140   assert(destination != NULL, &quot;invalid destination argument&quot;);
 141 
 142   _src_region_idx = src_region_idx;
 143   _partial_obj_size = partial_obj_size;
 144   _destination = destination;
 145 
 146   // These fields may not be updated below, so make sure they&#39;re clear.
 147   assert(_dest_region_addr == NULL, &quot;should have been cleared&quot;);
 148   assert(_first_src_addr == NULL, &quot;should have been cleared&quot;);
 149 
 150   // Determine the number of destination regions for the partial object.
 151   HeapWord* const last_word = destination + partial_obj_size - 1;
 152   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
 153   HeapWord* const beg_region_addr = sd.region_align_down(destination);
 154   HeapWord* const end_region_addr = sd.region_align_down(last_word);
 155 
 156   if (beg_region_addr == end_region_addr) {
 157     // One destination region.
 158     _destination_count = 1;
 159     if (end_region_addr == destination) {
 160       // The destination falls on a region boundary, thus the first word of the
 161       // partial object will be the first word copied to the destination region.
 162       _dest_region_addr = end_region_addr;
 163       _first_src_addr = sd.region_to_addr(src_region_idx);
 164     }
 165   } else {
 166     // Two destination regions.  When copied, the partial object will cross a
 167     // destination region boundary, so a word somewhere within the partial
 168     // object will be the first word copied to the second destination region.
 169     _destination_count = 2;
 170     _dest_region_addr = end_region_addr;
 171     const size_t ofs = pointer_delta(end_region_addr, destination);
 172     assert(ofs &lt; _partial_obj_size, &quot;sanity&quot;);
 173     _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;
 174   }
 175 }
 176 
 177 void SplitInfo::clear()
 178 {
 179   _src_region_idx = 0;
 180   _partial_obj_size = 0;
 181   _destination = NULL;
 182   _destination_count = 0;
 183   _dest_region_addr = NULL;
 184   _first_src_addr = NULL;
 185   assert(!is_valid(), &quot;sanity&quot;);
 186 }
 187 
 188 #ifdef  ASSERT
 189 void SplitInfo::verify_clear()
 190 {
 191   assert(_src_region_idx == 0, &quot;not clear&quot;);
 192   assert(_partial_obj_size == 0, &quot;not clear&quot;);
 193   assert(_destination == NULL, &quot;not clear&quot;);
 194   assert(_destination_count == 0, &quot;not clear&quot;);
 195   assert(_dest_region_addr == NULL, &quot;not clear&quot;);
 196   assert(_first_src_addr == NULL, &quot;not clear&quot;);
 197 }
 198 #endif  // #ifdef ASSERT
 199 
 200 
 201 void PSParallelCompact::print_on_error(outputStream* st) {
 202   _mark_bitmap.print_on_error(st);
 203 }
 204 
 205 #ifndef PRODUCT
 206 const char* PSParallelCompact::space_names[] = {
 207   &quot;old &quot;, &quot;eden&quot;, &quot;from&quot;, &quot;to  &quot;
 208 };
 209 
 210 void PSParallelCompact::print_region_ranges() {
 211   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 212     return;
 213   }
 214   Log(gc, compaction) log;
 215   ResourceMark rm;
 216   LogStream ls(log.trace());
 217   Universe::print_on(&amp;ls);
 218   log.trace(&quot;space  bottom     top        end        new_top&quot;);
 219   log.trace(&quot;------ ---------- ---------- ---------- ----------&quot;);
 220 
 221   for (unsigned int id = 0; id &lt; last_space_id; ++id) {
 222     const MutableSpace* space = _space_info[id].space();
 223     log.trace(&quot;%u %s &quot;
 224               SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10) &quot; &quot;
 225               SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10) &quot; &quot;,
 226               id, space_names[id],
 227               summary_data().addr_to_region_idx(space-&gt;bottom()),
 228               summary_data().addr_to_region_idx(space-&gt;top()),
 229               summary_data().addr_to_region_idx(space-&gt;end()),
 230               summary_data().addr_to_region_idx(_space_info[id].new_top()));
 231   }
 232 }
 233 
 234 void
 235 print_generic_summary_region(size_t i, const ParallelCompactData::RegionData* c)
 236 {
 237 #define REGION_IDX_FORMAT        SIZE_FORMAT_W(7)
 238 #define REGION_DATA_FORMAT       SIZE_FORMAT_W(5)
 239 
 240   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
 241   size_t dci = c-&gt;destination() ? sd.addr_to_region_idx(c-&gt;destination()) : 0;
 242   log_develop_trace(gc, compaction)(
 243       REGION_IDX_FORMAT &quot; &quot; PTR_FORMAT &quot; &quot;
 244       REGION_IDX_FORMAT &quot; &quot; PTR_FORMAT &quot; &quot;
 245       REGION_DATA_FORMAT &quot; &quot; REGION_DATA_FORMAT &quot; &quot;
 246       REGION_DATA_FORMAT &quot; &quot; REGION_IDX_FORMAT &quot; %d&quot;,
 247       i, p2i(c-&gt;data_location()), dci, p2i(c-&gt;destination()),
 248       c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 249       c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 250 
 251 #undef  REGION_IDX_FORMAT
 252 #undef  REGION_DATA_FORMAT
 253 }
 254 
 255 void
 256 print_generic_summary_data(ParallelCompactData&amp; summary_data,
 257                            HeapWord* const beg_addr,
 258                            HeapWord* const end_addr)
 259 {
 260   size_t total_words = 0;
 261   size_t i = summary_data.addr_to_region_idx(beg_addr);
 262   const size_t last = summary_data.addr_to_region_idx(end_addr);
 263   HeapWord* pdest = 0;
 264 
 265   while (i &lt; last) {
 266     ParallelCompactData::RegionData* c = summary_data.region(i);
 267     if (c-&gt;data_size() != 0 || c-&gt;destination() != pdest) {
 268       print_generic_summary_region(i, c);
 269       total_words += c-&gt;data_size();
 270       pdest = c-&gt;destination();
 271     }
 272     ++i;
 273   }
 274 
 275   log_develop_trace(gc, compaction)(&quot;summary_data_bytes=&quot; SIZE_FORMAT, total_words * HeapWordSize);
 276 }
 277 
 278 void
 279 PSParallelCompact::print_generic_summary_data(ParallelCompactData&amp; summary_data,
 280                                               HeapWord* const beg_addr,
 281                                               HeapWord* const end_addr) {
 282   ::print_generic_summary_data(summary_data,beg_addr, end_addr);
 283 }
 284 
 285 void
 286 print_generic_summary_data(ParallelCompactData&amp; summary_data,
 287                            SpaceInfo* space_info)
 288 {
 289   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 290     return;
 291   }
 292 
 293   for (unsigned int id = 0; id &lt; PSParallelCompact::last_space_id; ++id) {
 294     const MutableSpace* space = space_info[id].space();
 295     print_generic_summary_data(summary_data, space-&gt;bottom(),
 296                                MAX2(space-&gt;top(), space_info[id].new_top()));
 297   }
 298 }
 299 
 300 void
 301 print_initial_summary_data(ParallelCompactData&amp; summary_data,
 302                            const MutableSpace* space) {
 303   if (space-&gt;top() == space-&gt;bottom()) {
 304     return;
 305   }
 306 
 307   const size_t region_size = ParallelCompactData::RegionSize;
 308   typedef ParallelCompactData::RegionData RegionData;
 309   HeapWord* const top_aligned_up = summary_data.region_align_up(space-&gt;top());
 310   const size_t end_region = summary_data.addr_to_region_idx(top_aligned_up);
 311   const RegionData* c = summary_data.region(end_region - 1);
 312   HeapWord* end_addr = c-&gt;destination() + c-&gt;data_size();
 313   const size_t live_in_space = pointer_delta(end_addr, space-&gt;bottom());
 314 
 315   // Print (and count) the full regions at the beginning of the space.
 316   size_t full_region_count = 0;
 317   size_t i = summary_data.addr_to_region_idx(space-&gt;bottom());
 318   while (i &lt; end_region &amp;&amp; summary_data.region(i)-&gt;data_size() == region_size) {
 319     ParallelCompactData::RegionData* c = summary_data.region(i);
 320     log_develop_trace(gc, compaction)(
 321         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;,
 322         i, p2i(c-&gt;destination()),
 323         c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 324         c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 325     ++full_region_count;
 326     ++i;
 327   }
 328 
 329   size_t live_to_right = live_in_space - full_region_count * region_size;
 330 
 331   double max_reclaimed_ratio = 0.0;
 332   size_t max_reclaimed_ratio_region = 0;
 333   size_t max_dead_to_right = 0;
 334   size_t max_live_to_right = 0;
 335 
 336   // Print the &#39;reclaimed ratio&#39; for regions while there is something live in
 337   // the region or to the right of it.  The remaining regions are empty (and
 338   // uninteresting), and computing the ratio will result in division by 0.
 339   while (i &lt; end_region &amp;&amp; live_to_right &gt; 0) {
 340     c = summary_data.region(i);
 341     HeapWord* const region_addr = summary_data.region_to_addr(i);
 342     const size_t used_to_right = pointer_delta(space-&gt;top(), region_addr);
 343     const size_t dead_to_right = used_to_right - live_to_right;
 344     const double reclaimed_ratio = double(dead_to_right) / live_to_right;
 345 
 346     if (reclaimed_ratio &gt; max_reclaimed_ratio) {
 347             max_reclaimed_ratio = reclaimed_ratio;
 348             max_reclaimed_ratio_region = i;
 349             max_dead_to_right = dead_to_right;
 350             max_live_to_right = live_to_right;
 351     }
 352 
 353     ParallelCompactData::RegionData* c = summary_data.region(i);
 354     log_develop_trace(gc, compaction)(
 355         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;
 356         &quot;%12.10f &quot; SIZE_FORMAT_W(10) &quot; &quot; SIZE_FORMAT_W(10),
 357         i, p2i(c-&gt;destination()),
 358         c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 359         c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count(),
 360         reclaimed_ratio, dead_to_right, live_to_right);
 361 
 362 
 363     live_to_right -= c-&gt;data_size();
 364     ++i;
 365   }
 366 
 367   // Any remaining regions are empty.  Print one more if there is one.
 368   if (i &lt; end_region) {
 369     ParallelCompactData::RegionData* c = summary_data.region(i);
 370     log_develop_trace(gc, compaction)(
 371         SIZE_FORMAT_W(5) &quot; &quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; &quot; SIZE_FORMAT_W(5) &quot; %d&quot;,
 372          i, p2i(c-&gt;destination()),
 373          c-&gt;partial_obj_size(), c-&gt;live_obj_size(),
 374          c-&gt;data_size(), c-&gt;source_region(), c-&gt;destination_count());
 375   }
 376 
 377   log_develop_trace(gc, compaction)(&quot;max:  &quot; SIZE_FORMAT_W(4) &quot; d2r=&quot; SIZE_FORMAT_W(10) &quot; l2r=&quot; SIZE_FORMAT_W(10) &quot; max_ratio=%14.12f&quot;,
 378                                     max_reclaimed_ratio_region, max_dead_to_right, max_live_to_right, max_reclaimed_ratio);
 379 }
 380 
 381 void
 382 print_initial_summary_data(ParallelCompactData&amp; summary_data,
 383                            SpaceInfo* space_info) {
 384   if (!log_develop_is_enabled(Trace, gc, compaction)) {
 385     return;
 386   }
 387 
 388   unsigned int id = PSParallelCompact::old_space_id;
 389   const MutableSpace* space;
 390   do {
 391     space = space_info[id].space();
 392     print_initial_summary_data(summary_data, space);
 393   } while (++id &lt; PSParallelCompact::eden_space_id);
 394 
 395   do {
 396     space = space_info[id].space();
 397     print_generic_summary_data(summary_data, space-&gt;bottom(), space-&gt;top());
 398   } while (++id &lt; PSParallelCompact::last_space_id);
 399 }
 400 #endif  // #ifndef PRODUCT
 401 
 402 #ifdef  ASSERT
 403 size_t add_obj_count;
 404 size_t add_obj_size;
 405 size_t mark_bitmap_count;
 406 size_t mark_bitmap_size;
 407 #endif  // #ifdef ASSERT
 408 
<a name="9" id="anc9"></a><span class="line-modified"> 409 ParallelCompactData::ParallelCompactData()</span>
<span class="line-modified"> 410 {</span>
<span class="line-modified"> 411   _region_start = 0;</span>
<span class="line-modified"> 412 </span>
<span class="line-modified"> 413   _region_vspace = 0;</span>
<span class="line-modified"> 414   _reserved_byte_size = 0;</span>
<span class="line-modified"> 415   _region_data = 0;</span>
<span class="line-modified"> 416   _region_count = 0;</span>
<span class="line-modified"> 417 </span>
<span class="line-modified"> 418   _block_vspace = 0;</span>
<span class="line-removed"> 419   _block_data = 0;</span>
<span class="line-removed"> 420   _block_count = 0;</span>
<span class="line-removed"> 421 }</span>
 422 
 423 bool ParallelCompactData::initialize(MemRegion covered_region)
 424 {
 425   _region_start = covered_region.start();
 426   const size_t region_size = covered_region.word_size();
 427   DEBUG_ONLY(_region_end = _region_start + region_size;)
 428 
 429   assert(region_align_down(_region_start) == _region_start,
 430          &quot;region start not aligned&quot;);
 431   assert((region_size &amp; RegionSizeOffsetMask) == 0,
 432          &quot;region size not a multiple of RegionSize&quot;);
 433 
 434   bool result = initialize_region_data(region_size) &amp;&amp; initialize_block_data();
 435   return result;
 436 }
 437 
 438 PSVirtualSpace*
 439 ParallelCompactData::create_vspace(size_t count, size_t element_size)
 440 {
 441   const size_t raw_bytes = count * element_size;
 442   const size_t page_sz = os::page_size_for_region_aligned(raw_bytes, 10);
 443   const size_t granularity = os::vm_allocation_granularity();
 444   _reserved_byte_size = align_up(raw_bytes, MAX2(page_sz, granularity));
 445 
 446   const size_t rs_align = page_sz == (size_t) os::vm_page_size() ? 0 :
 447     MAX2(page_sz, granularity);
 448   ReservedSpace rs(_reserved_byte_size, rs_align, rs_align &gt; 0);
 449   os::trace_page_sizes(&quot;Parallel Compact Data&quot;, raw_bytes, raw_bytes, page_sz, rs.base(),
 450                        rs.size());
 451 
 452   MemTracker::record_virtual_memory_type((address)rs.base(), mtGC);
 453 
 454   PSVirtualSpace* vspace = new PSVirtualSpace(rs, page_sz);
 455   if (vspace != 0) {
 456     if (vspace-&gt;expand_by(_reserved_byte_size)) {
 457       return vspace;
 458     }
 459     delete vspace;
 460     // Release memory reserved in the space.
 461     rs.release();
 462   }
 463 
 464   return 0;
 465 }
 466 
 467 bool ParallelCompactData::initialize_region_data(size_t region_size)
 468 {
 469   const size_t count = (region_size + RegionSizeOffsetMask) &gt;&gt; Log2RegionSize;
 470   _region_vspace = create_vspace(count, sizeof(RegionData));
 471   if (_region_vspace != 0) {
 472     _region_data = (RegionData*)_region_vspace-&gt;reserved_low_addr();
 473     _region_count = count;
 474     return true;
 475   }
 476   return false;
 477 }
 478 
 479 bool ParallelCompactData::initialize_block_data()
 480 {
 481   assert(_region_count != 0, &quot;region data must be initialized first&quot;);
 482   const size_t count = _region_count &lt;&lt; Log2BlocksPerRegion;
 483   _block_vspace = create_vspace(count, sizeof(BlockData));
 484   if (_block_vspace != 0) {
 485     _block_data = (BlockData*)_block_vspace-&gt;reserved_low_addr();
 486     _block_count = count;
 487     return true;
 488   }
 489   return false;
 490 }
 491 
 492 void ParallelCompactData::clear()
 493 {
 494   memset(_region_data, 0, _region_vspace-&gt;committed_size());
 495   memset(_block_data, 0, _block_vspace-&gt;committed_size());
 496 }
 497 
 498 void ParallelCompactData::clear_range(size_t beg_region, size_t end_region) {
 499   assert(beg_region &lt;= _region_count, &quot;beg_region out of range&quot;);
 500   assert(end_region &lt;= _region_count, &quot;end_region out of range&quot;);
 501   assert(RegionSize % BlockSize == 0, &quot;RegionSize not a multiple of BlockSize&quot;);
 502 
 503   const size_t region_cnt = end_region - beg_region;
 504   memset(_region_data + beg_region, 0, region_cnt * sizeof(RegionData));
 505 
 506   const size_t beg_block = beg_region * BlocksPerRegion;
 507   const size_t block_cnt = region_cnt * BlocksPerRegion;
 508   memset(_block_data + beg_block, 0, block_cnt * sizeof(BlockData));
 509 }
 510 
 511 HeapWord* ParallelCompactData::partial_obj_end(size_t region_idx) const
 512 {
 513   const RegionData* cur_cp = region(region_idx);
 514   const RegionData* const end_cp = region(region_count() - 1);
 515 
 516   HeapWord* result = region_to_addr(region_idx);
 517   if (cur_cp &lt; end_cp) {
 518     do {
 519       result += cur_cp-&gt;partial_obj_size();
 520     } while (cur_cp-&gt;partial_obj_size() == RegionSize &amp;&amp; ++cur_cp &lt; end_cp);
 521   }
 522   return result;
 523 }
 524 
 525 void ParallelCompactData::add_obj(HeapWord* addr, size_t len)
 526 {
 527   const size_t obj_ofs = pointer_delta(addr, _region_start);
 528   const size_t beg_region = obj_ofs &gt;&gt; Log2RegionSize;
 529   const size_t end_region = (obj_ofs + len - 1) &gt;&gt; Log2RegionSize;
 530 
 531   DEBUG_ONLY(Atomic::inc(&amp;add_obj_count);)
<a name="10" id="anc10"></a><span class="line-modified"> 532   DEBUG_ONLY(Atomic::add(len, &amp;add_obj_size);)</span>
 533 
 534   if (beg_region == end_region) {
 535     // All in one region.
 536     _region_data[beg_region].add_live_obj(len);
 537     return;
 538   }
 539 
 540   // First region.
 541   const size_t beg_ofs = region_offset(addr);
 542   _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);
 543 
 544   Klass* klass = ((oop)addr)-&gt;klass();
 545   // Middle regions--completely spanned by this object.
 546   for (size_t region = beg_region + 1; region &lt; end_region; ++region) {
 547     _region_data[region].set_partial_obj_size(RegionSize);
 548     _region_data[region].set_partial_obj_addr(addr);
 549   }
 550 
 551   // Last region.
 552   const size_t end_ofs = region_offset(addr + len - 1);
 553   _region_data[end_region].set_partial_obj_size(end_ofs + 1);
 554   _region_data[end_region].set_partial_obj_addr(addr);
 555 }
 556 
 557 void
 558 ParallelCompactData::summarize_dense_prefix(HeapWord* beg, HeapWord* end)
 559 {
 560   assert(region_offset(beg) == 0, &quot;not RegionSize aligned&quot;);
 561   assert(region_offset(end) == 0, &quot;not RegionSize aligned&quot;);
 562 
 563   size_t cur_region = addr_to_region_idx(beg);
 564   const size_t end_region = addr_to_region_idx(end);
 565   HeapWord* addr = beg;
 566   while (cur_region &lt; end_region) {
 567     _region_data[cur_region].set_destination(addr);
 568     _region_data[cur_region].set_destination_count(0);
 569     _region_data[cur_region].set_source_region(cur_region);
 570     _region_data[cur_region].set_data_location(addr);
 571 
 572     // Update live_obj_size so the region appears completely full.
 573     size_t live_size = RegionSize - _region_data[cur_region].partial_obj_size();
 574     _region_data[cur_region].set_live_obj_size(live_size);
 575 
 576     ++cur_region;
 577     addr += RegionSize;
 578   }
 579 }
 580 
 581 // Find the point at which a space can be split and, if necessary, record the
 582 // split point.
 583 //
 584 // If the current src region (which overflowed the destination space) doesn&#39;t
 585 // have a partial object, the split point is at the beginning of the current src
 586 // region (an &quot;easy&quot; split, no extra bookkeeping required).
 587 //
 588 // If the current src region has a partial object, the split point is in the
 589 // region where that partial object starts (call it the split_region).  If
 590 // split_region has a partial object, then the split point is just after that
 591 // partial object (a &quot;hard&quot; split where we have to record the split data and
 592 // zero the partial_obj_size field).  With a &quot;hard&quot; split, we know that the
 593 // partial_obj ends within split_region because the partial object that caused
 594 // the overflow starts in split_region.  If split_region doesn&#39;t have a partial
 595 // obj, then the split is at the beginning of split_region (another &quot;easy&quot;
 596 // split).
 597 HeapWord*
 598 ParallelCompactData::summarize_split_space(size_t src_region,
 599                                            SplitInfo&amp; split_info,
 600                                            HeapWord* destination,
 601                                            HeapWord* target_end,
 602                                            HeapWord** target_next)
 603 {
 604   assert(destination &lt;= target_end, &quot;sanity&quot;);
 605   assert(destination + _region_data[src_region].data_size() &gt; target_end,
 606     &quot;region should not fit into target space&quot;);
 607   assert(is_region_aligned(target_end), &quot;sanity&quot;);
 608 
 609   size_t split_region = src_region;
 610   HeapWord* split_destination = destination;
 611   size_t partial_obj_size = _region_data[src_region].partial_obj_size();
 612 
 613   if (destination + partial_obj_size &gt; target_end) {
 614     // The split point is just after the partial object (if any) in the
 615     // src_region that contains the start of the object that overflowed the
 616     // destination space.
 617     //
 618     // Find the start of the &quot;overflow&quot; object and set split_region to the
 619     // region containing it.
 620     HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();
 621     split_region = addr_to_region_idx(overflow_obj);
 622 
 623     // Clear the source_region field of all destination regions whose first word
 624     // came from data after the split point (a non-null source_region field
 625     // implies a region must be filled).
 626     //
 627     // An alternative to the simple loop below:  clear during post_compact(),
 628     // which uses memcpy instead of individual stores, and is easy to
 629     // parallelize.  (The downside is that it clears the entire RegionData
 630     // object as opposed to just one field.)
 631     //
 632     // post_compact() would have to clear the summary data up to the highest
 633     // address that was written during the summary phase, which would be
 634     //
 635     //         max(top, max(new_top, clear_top))
 636     //
 637     // where clear_top is a new field in SpaceInfo.  Would have to set clear_top
 638     // to target_end.
 639     const RegionData* const sr = region(split_region);
 640     const size_t beg_idx =
 641       addr_to_region_idx(region_align_up(sr-&gt;destination() +
 642                                          sr-&gt;partial_obj_size()));
 643     const size_t end_idx = addr_to_region_idx(target_end);
 644 
 645     log_develop_trace(gc, compaction)(&quot;split:  clearing source_region field in [&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;)&quot;, beg_idx, end_idx);
 646     for (size_t idx = beg_idx; idx &lt; end_idx; ++idx) {
 647       _region_data[idx].set_source_region(0);
 648     }
 649 
 650     // Set split_destination and partial_obj_size to reflect the split region.
 651     split_destination = sr-&gt;destination();
 652     partial_obj_size = sr-&gt;partial_obj_size();
 653   }
 654 
 655   // The split is recorded only if a partial object extends onto the region.
 656   if (partial_obj_size != 0) {
 657     _region_data[split_region].set_partial_obj_size(0);
 658     split_info.record(split_region, partial_obj_size, split_destination);
 659   }
 660 
 661   // Setup the continuation addresses.
 662   *target_next = split_destination + partial_obj_size;
 663   HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;
 664 
 665   if (log_develop_is_enabled(Trace, gc, compaction)) {
 666     const char * split_type = partial_obj_size == 0 ? &quot;easy&quot; : &quot;hard&quot;;
 667     log_develop_trace(gc, compaction)(&quot;%s split:  src=&quot; PTR_FORMAT &quot; src_c=&quot; SIZE_FORMAT &quot; pos=&quot; SIZE_FORMAT,
 668                                       split_type, p2i(source_next), split_region, partial_obj_size);
 669     log_develop_trace(gc, compaction)(&quot;%s split:  dst=&quot; PTR_FORMAT &quot; dst_c=&quot; SIZE_FORMAT &quot; tn=&quot; PTR_FORMAT,
 670                                       split_type, p2i(split_destination),
 671                                       addr_to_region_idx(split_destination),
 672                                       p2i(*target_next));
 673 
 674     if (partial_obj_size != 0) {
 675       HeapWord* const po_beg = split_info.destination();
 676       HeapWord* const po_end = po_beg + split_info.partial_obj_size();
 677       log_develop_trace(gc, compaction)(&quot;%s split:  po_beg=&quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT &quot; po_end=&quot; PTR_FORMAT &quot; &quot; SIZE_FORMAT,
 678                                         split_type,
 679                                         p2i(po_beg), addr_to_region_idx(po_beg),
 680                                         p2i(po_end), addr_to_region_idx(po_end));
 681     }
 682   }
 683 
 684   return source_next;
 685 }
 686 
 687 bool ParallelCompactData::summarize(SplitInfo&amp; split_info,
 688                                     HeapWord* source_beg, HeapWord* source_end,
 689                                     HeapWord** source_next,
 690                                     HeapWord* target_beg, HeapWord* target_end,
 691                                     HeapWord** target_next)
 692 {
 693   HeapWord* const source_next_val = source_next == NULL ? NULL : *source_next;
 694   log_develop_trace(gc, compaction)(
 695       &quot;sb=&quot; PTR_FORMAT &quot; se=&quot; PTR_FORMAT &quot; sn=&quot; PTR_FORMAT
 696       &quot;tb=&quot; PTR_FORMAT &quot; te=&quot; PTR_FORMAT &quot; tn=&quot; PTR_FORMAT,
 697       p2i(source_beg), p2i(source_end), p2i(source_next_val),
 698       p2i(target_beg), p2i(target_end), p2i(*target_next));
 699 
 700   size_t cur_region = addr_to_region_idx(source_beg);
 701   const size_t end_region = addr_to_region_idx(region_align_up(source_end));
 702 
 703   HeapWord *dest_addr = target_beg;
 704   while (cur_region &lt; end_region) {
 705     // The destination must be set even if the region has no data.
 706     _region_data[cur_region].set_destination(dest_addr);
 707 
 708     size_t words = _region_data[cur_region].data_size();
 709     if (words &gt; 0) {
 710       // If cur_region does not fit entirely into the target space, find a point
 711       // at which the source space can be &#39;split&#39; so that part is copied to the
 712       // target space and the rest is copied elsewhere.
 713       if (dest_addr + words &gt; target_end) {
 714         assert(source_next != NULL, &quot;source_next is NULL when splitting&quot;);
 715         *source_next = summarize_split_space(cur_region, split_info, dest_addr,
 716                                              target_end, target_next);
 717         return false;
 718       }
 719 
 720       // Compute the destination_count for cur_region, and if necessary, update
 721       // source_region for a destination region.  The source_region field is
 722       // updated if cur_region is the first (left-most) region to be copied to a
 723       // destination region.
 724       //
 725       // The destination_count calculation is a bit subtle.  A region that has
 726       // data that compacts into itself does not count itself as a destination.
 727       // This maintains the invariant that a zero count means the region is
 728       // available and can be claimed and then filled.
 729       uint destination_count = 0;
 730       if (split_info.is_split(cur_region)) {
 731         // The current region has been split:  the partial object will be copied
 732         // to one destination space and the remaining data will be copied to
 733         // another destination space.  Adjust the initial destination_count and,
 734         // if necessary, set the source_region field if the partial object will
 735         // cross a destination region boundary.
 736         destination_count = split_info.destination_count();
 737         if (destination_count == 2) {
 738           size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());
 739           _region_data[dest_idx].set_source_region(cur_region);
 740         }
 741       }
 742 
 743       HeapWord* const last_addr = dest_addr + words - 1;
 744       const size_t dest_region_1 = addr_to_region_idx(dest_addr);
 745       const size_t dest_region_2 = addr_to_region_idx(last_addr);
 746 
 747       // Initially assume that the destination regions will be the same and
 748       // adjust the value below if necessary.  Under this assumption, if
 749       // cur_region == dest_region_2, then cur_region will be compacted
 750       // completely into itself.
 751       destination_count += cur_region == dest_region_2 ? 0 : 1;
 752       if (dest_region_1 != dest_region_2) {
 753         // Destination regions differ; adjust destination_count.
 754         destination_count += 1;
 755         // Data from cur_region will be copied to the start of dest_region_2.
 756         _region_data[dest_region_2].set_source_region(cur_region);
 757       } else if (region_offset(dest_addr) == 0) {
 758         // Data from cur_region will be copied to the start of the destination
 759         // region.
 760         _region_data[dest_region_1].set_source_region(cur_region);
 761       }
 762 
 763       _region_data[cur_region].set_destination_count(destination_count);
 764       _region_data[cur_region].set_data_location(region_to_addr(cur_region));
 765       dest_addr += words;
 766     }
 767 
 768     ++cur_region;
 769   }
 770 
 771   *target_next = dest_addr;
 772   return true;
 773 }
 774 
 775 HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) {
 776   assert(addr != NULL, &quot;Should detect NULL oop earlier&quot;);
 777   assert(ParallelScavengeHeap::heap()-&gt;is_in(addr), &quot;not in heap&quot;);
 778   assert(PSParallelCompact::mark_bitmap()-&gt;is_marked(addr), &quot;not marked&quot;);
 779 
 780   // Region covering the object.
 781   RegionData* const region_ptr = addr_to_region_ptr(addr);
 782   HeapWord* result = region_ptr-&gt;destination();
 783 
 784   // If the entire Region is live, the new location is region-&gt;destination + the
 785   // offset of the object within in the Region.
 786 
 787   // Run some performance tests to determine if this special case pays off.  It
 788   // is worth it for pointers into the dense prefix.  If the optimization to
 789   // avoid pointer updates in regions that only point to the dense prefix is
 790   // ever implemented, this should be revisited.
 791   if (region_ptr-&gt;data_size() == RegionSize) {
 792     result += region_offset(addr);
 793     return result;
 794   }
 795 
 796   // Otherwise, the new location is region-&gt;destination + block offset + the
 797   // number of live words in the Block that are (a) to the left of addr and (b)
 798   // due to objects that start in the Block.
 799 
 800   // Fill in the block table if necessary.  This is unsynchronized, so multiple
 801   // threads may fill the block table for a region (harmless, since it is
 802   // idempotent).
 803   if (!region_ptr-&gt;blocks_filled()) {
 804     PSParallelCompact::fill_blocks(addr_to_region_idx(addr));
 805     region_ptr-&gt;set_blocks_filled();
 806   }
 807 
 808   HeapWord* const search_start = block_align_down(addr);
 809   const size_t block_offset = addr_to_block_ptr(addr)-&gt;offset();
 810 
 811   const ParMarkBitMap* bitmap = PSParallelCompact::mark_bitmap();
 812   const size_t live = bitmap-&gt;live_words_in_range(cm, search_start, oop(addr));
 813   result += block_offset + live;
 814   DEBUG_ONLY(PSParallelCompact::check_new_location(addr, result));
 815   return result;
 816 }
 817 
 818 #ifdef ASSERT
 819 void ParallelCompactData::verify_clear(const PSVirtualSpace* vspace)
 820 {
 821   const size_t* const beg = (const size_t*)vspace-&gt;committed_low_addr();
 822   const size_t* const end = (const size_t*)vspace-&gt;committed_high_addr();
 823   for (const size_t* p = beg; p &lt; end; ++p) {
 824     assert(*p == 0, &quot;not zero&quot;);
 825   }
 826 }
 827 
 828 void ParallelCompactData::verify_clear()
 829 {
 830   verify_clear(_region_vspace);
 831   verify_clear(_block_vspace);
 832 }
 833 #endif  // #ifdef ASSERT
 834 
 835 STWGCTimer          PSParallelCompact::_gc_timer;
 836 ParallelOldTracer   PSParallelCompact::_gc_tracer;
 837 elapsedTimer        PSParallelCompact::_accumulated_time;
 838 unsigned int        PSParallelCompact::_total_invocations = 0;
 839 unsigned int        PSParallelCompact::_maximum_compaction_gc_num = 0;
 840 jlong               PSParallelCompact::_time_of_last_gc = 0;
 841 CollectorCounters*  PSParallelCompact::_counters = NULL;
 842 ParMarkBitMap       PSParallelCompact::_mark_bitmap;
 843 ParallelCompactData PSParallelCompact::_summary_data;
 844 
 845 PSParallelCompact::IsAliveClosure PSParallelCompact::_is_alive_closure;
 846 
 847 bool PSParallelCompact::IsAliveClosure::do_object_b(oop p) { return mark_bitmap()-&gt;is_marked(p); }
 848 
 849 class PCReferenceProcessor: public ReferenceProcessor {
 850 public:
 851   PCReferenceProcessor(
 852     BoolObjectClosure* is_subject_to_discovery,
 853     BoolObjectClosure* is_alive_non_header) :
 854       ReferenceProcessor(is_subject_to_discovery,
 855       ParallelRefProcEnabled &amp;&amp; (ParallelGCThreads &gt; 1), // mt processing
 856       ParallelGCThreads,   // mt processing degree
 857       true,                // mt discovery
 858       ParallelGCThreads,   // mt discovery degree
 859       true,                // atomic_discovery
 860       is_alive_non_header) {
 861   }
 862 
 863   template&lt;typename T&gt; bool discover(oop obj, ReferenceType type) {
 864     T* referent_addr = (T*) java_lang_ref_Reference::referent_addr_raw(obj);
 865     T heap_oop = RawAccess&lt;&gt;::oop_load(referent_addr);
 866     oop referent = CompressedOops::decode_not_null(heap_oop);
 867     return PSParallelCompact::mark_bitmap()-&gt;is_unmarked(referent)
 868         &amp;&amp; ReferenceProcessor::discover_reference(obj, type);
 869   }
 870   virtual bool discover_reference(oop obj, ReferenceType type) {
 871     if (UseCompressedOops) {
 872       return discover&lt;narrowOop&gt;(obj, type);
 873     } else {
 874       return discover&lt;oop&gt;(obj, type);
 875     }
 876   }
 877 };
 878 
 879 void PSParallelCompact::post_initialize() {
 880   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 881   _span_based_discoverer.set_span(heap-&gt;reserved_region());
 882   _ref_processor =
 883     new PCReferenceProcessor(&amp;_span_based_discoverer,
 884                              &amp;_is_alive_closure); // non-header is alive closure
 885 
 886   _counters = new CollectorCounters(&quot;Parallel full collection pauses&quot;, 1);
 887 
 888   // Initialize static fields in ParCompactionManager.
 889   ParCompactionManager::initialize(mark_bitmap());
 890 }
 891 
 892 bool PSParallelCompact::initialize() {
 893   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 894   MemRegion mr = heap-&gt;reserved_region();
 895 
 896   // Was the old gen get allocated successfully?
 897   if (!heap-&gt;old_gen()-&gt;is_allocated()) {
 898     return false;
 899   }
 900 
 901   initialize_space_info();
 902   initialize_dead_wood_limiter();
 903 
 904   if (!_mark_bitmap.initialize(mr)) {
 905     vm_shutdown_during_initialization(
 906       err_msg(&quot;Unable to allocate &quot; SIZE_FORMAT &quot;KB bitmaps for parallel &quot;
 907       &quot;garbage collection for the requested &quot; SIZE_FORMAT &quot;KB heap.&quot;,
 908       _mark_bitmap.reserved_byte_size()/K, mr.byte_size()/K));
 909     return false;
 910   }
 911 
 912   if (!_summary_data.initialize(mr)) {
 913     vm_shutdown_during_initialization(
 914       err_msg(&quot;Unable to allocate &quot; SIZE_FORMAT &quot;KB card tables for parallel &quot;
 915       &quot;garbage collection for the requested &quot; SIZE_FORMAT &quot;KB heap.&quot;,
 916       _summary_data.reserved_byte_size()/K, mr.byte_size()/K));
 917     return false;
 918   }
 919 
 920   return true;
 921 }
 922 
 923 void PSParallelCompact::initialize_space_info()
 924 {
 925   memset(&amp;_space_info, 0, sizeof(_space_info));
 926 
 927   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 928   PSYoungGen* young_gen = heap-&gt;young_gen();
 929 
 930   _space_info[old_space_id].set_space(heap-&gt;old_gen()-&gt;object_space());
 931   _space_info[eden_space_id].set_space(young_gen-&gt;eden_space());
 932   _space_info[from_space_id].set_space(young_gen-&gt;from_space());
 933   _space_info[to_space_id].set_space(young_gen-&gt;to_space());
 934 
 935   _space_info[old_space_id].set_start_array(heap-&gt;old_gen()-&gt;start_array());
 936 }
 937 
 938 void PSParallelCompact::initialize_dead_wood_limiter()
 939 {
 940   const size_t max = 100;
 941   _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) / 100.0;
 942   _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) / 100.0;
 943   _dwl_first_term = 1.0 / (sqrt(2.0 * M_PI) * _dwl_std_dev);
 944   DEBUG_ONLY(_dwl_initialized = true;)
 945   _dwl_adjustment = normal_distribution(1.0);
 946 }
 947 
 948 void
 949 PSParallelCompact::clear_data_covering_space(SpaceId id)
 950 {
 951   // At this point, top is the value before GC, new_top() is the value that will
 952   // be set at the end of GC.  The marking bitmap is cleared to top; nothing
 953   // should be marked above top.  The summary data is cleared to the larger of
 954   // top &amp; new_top.
 955   MutableSpace* const space = _space_info[id].space();
 956   HeapWord* const bot = space-&gt;bottom();
 957   HeapWord* const top = space-&gt;top();
 958   HeapWord* const max_top = MAX2(top, _space_info[id].new_top());
 959 
 960   const idx_t beg_bit = _mark_bitmap.addr_to_bit(bot);
<a name="11" id="anc11"></a><span class="line-modified"> 961   const idx_t end_bit = BitMap::word_align_up(_mark_bitmap.addr_to_bit(top));</span>
 962   _mark_bitmap.clear_range(beg_bit, end_bit);
 963 
 964   const size_t beg_region = _summary_data.addr_to_region_idx(bot);
 965   const size_t end_region =
 966     _summary_data.addr_to_region_idx(_summary_data.region_align_up(max_top));
 967   _summary_data.clear_range(beg_region, end_region);
 968 
 969   // Clear the data used to &#39;split&#39; regions.
 970   SplitInfo&amp; split_info = _space_info[id].split_info();
 971   if (split_info.is_valid()) {
 972     split_info.clear();
 973   }
 974   DEBUG_ONLY(split_info.verify_clear();)
 975 }
 976 
 977 void PSParallelCompact::pre_compact()
 978 {
 979   // Update the from &amp; to space pointers in space_info, since they are swapped
 980   // at each young gen gc.  Do the update unconditionally (even though a
 981   // promotion failure does not swap spaces) because an unknown number of young
 982   // collections will have swapped the spaces an unknown number of times.
 983   GCTraceTime(Debug, gc, phases) tm(&quot;Pre Compact&quot;, &amp;_gc_timer);
 984   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 985   _space_info[from_space_id].set_space(heap-&gt;young_gen()-&gt;from_space());
 986   _space_info[to_space_id].set_space(heap-&gt;young_gen()-&gt;to_space());
 987 
 988   DEBUG_ONLY(add_obj_count = add_obj_size = 0;)
 989   DEBUG_ONLY(mark_bitmap_count = mark_bitmap_size = 0;)
 990 
 991   // Increment the invocation count
 992   heap-&gt;increment_total_collections(true);
 993 
 994   // We need to track unique mark sweep invocations as well.
 995   _total_invocations++;
 996 
 997   heap-&gt;print_heap_before_gc();
 998   heap-&gt;trace_heap_before_gc(&amp;_gc_tracer);
 999 
1000   // Fill in TLABs
1001   heap-&gt;ensure_parsability(true);  // retire TLABs
1002 
1003   if (VerifyBeforeGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1004     HandleMark hm;  // Discard invalid handles created during verification
1005     Universe::verify(&quot;Before GC&quot;);
1006   }
1007 
1008   // Verify object start arrays
1009   if (VerifyObjectStartArray &amp;&amp;
1010       VerifyBeforeGC) {
1011     heap-&gt;old_gen()-&gt;verify_object_start_array();
1012   }
1013 
1014   DEBUG_ONLY(mark_bitmap()-&gt;verify_clear();)
1015   DEBUG_ONLY(summary_data().verify_clear();)
1016 
<a name="12" id="anc12"></a><span class="line-removed">1017   // Have worker threads release resources the next time they run a task.</span>
<span class="line-removed">1018   gc_task_manager()-&gt;release_all_resources();</span>
<span class="line-removed">1019 </span>
1020   ParCompactionManager::reset_all_bitmap_query_caches();
1021 }
1022 
1023 void PSParallelCompact::post_compact()
1024 {
1025   GCTraceTime(Info, gc, phases) tm(&quot;Post Compact&quot;, &amp;_gc_timer);
<a name="13" id="anc13"></a>
1026 
1027   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1028     // Clear the marking bitmap, summary data and split info.
1029     clear_data_covering_space(SpaceId(id));
1030     // Update top().  Must be done after clearing the bitmap and summary data.
1031     _space_info[id].publish_new_top();
1032   }
1033 
1034   MutableSpace* const eden_space = _space_info[eden_space_id].space();
1035   MutableSpace* const from_space = _space_info[from_space_id].space();
1036   MutableSpace* const to_space   = _space_info[to_space_id].space();
1037 
1038   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1039   bool eden_empty = eden_space-&gt;is_empty();
1040   if (!eden_empty) {
1041     eden_empty = absorb_live_data_from_eden(heap-&gt;size_policy(),
1042                                             heap-&gt;young_gen(), heap-&gt;old_gen());
1043   }
1044 
1045   // Update heap occupancy information which is used as input to the soft ref
1046   // clearing policy at the next gc.
1047   Universe::update_heap_info_at_gc();
1048 
1049   bool young_gen_empty = eden_empty &amp;&amp; from_space-&gt;is_empty() &amp;&amp;
1050     to_space-&gt;is_empty();
1051 
1052   PSCardTable* ct = heap-&gt;card_table();
1053   MemRegion old_mr = heap-&gt;old_gen()-&gt;reserved();
1054   if (young_gen_empty) {
1055     ct-&gt;clear(MemRegion(old_mr.start(), old_mr.end()));
1056   } else {
1057     ct-&gt;invalidate(MemRegion(old_mr.start(), old_mr.end()));
1058   }
1059 
1060   // Delete metaspaces for unloaded class loaders and clean up loader_data graph
1061   ClassLoaderDataGraph::purge();
1062   MetaspaceUtils::verify_metrics();
1063 
<a name="14" id="anc14"></a><span class="line-modified">1064   heap-&gt;prune_nmethods();</span>
<span class="line-removed">1065   JvmtiExport::gc_epilogue();</span>
1066 
1067 #if COMPILER2_OR_JVMCI
1068   DerivedPointerTable::update_pointers();
1069 #endif
1070 
1071   if (ZapUnusedHeapArea) {
1072     heap-&gt;gen_mangle_unused_area();
1073   }
1074 
1075   // Update time of last GC
1076   reset_millis_since_last_gc();
1077 }
1078 
1079 HeapWord*
1080 PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,
1081                                                     bool maximum_compaction)
1082 {
1083   const size_t region_size = ParallelCompactData::RegionSize;
1084   const ParallelCompactData&amp; sd = summary_data();
1085 
1086   const MutableSpace* const space = _space_info[id].space();
1087   HeapWord* const top_aligned_up = sd.region_align_up(space-&gt;top());
1088   const RegionData* const beg_cp = sd.addr_to_region_ptr(space-&gt;bottom());
1089   const RegionData* const end_cp = sd.addr_to_region_ptr(top_aligned_up);
1090 
1091   // Skip full regions at the beginning of the space--they are necessarily part
1092   // of the dense prefix.
1093   size_t full_count = 0;
1094   const RegionData* cp;
1095   for (cp = beg_cp; cp &lt; end_cp &amp;&amp; cp-&gt;data_size() == region_size; ++cp) {
1096     ++full_count;
1097   }
1098 
1099   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1100   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1101   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1102   if (maximum_compaction || cp == end_cp || interval_ended) {
1103     _maximum_compaction_gc_num = total_invocations();
1104     return sd.region_to_addr(cp);
1105   }
1106 
1107   HeapWord* const new_top = _space_info[id].new_top();
1108   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1109   const size_t space_used = space-&gt;used_in_words();
1110   const size_t space_capacity = space-&gt;capacity_in_words();
1111 
1112   const double cur_density = double(space_live) / space_capacity;
1113   const double deadwood_density =
1114     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1115   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1116 
<a name="15" id="anc15"></a><span class="line-modified">1117   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1118     tty-&gt;print_cr(&quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1119                   cur_density, deadwood_density, deadwood_goal);</span>
<span class="line-modified">1120     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1121                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1122                   space_live, space_used,</span>
<span class="line-modified">1123                   space_capacity);</span>
<span class="line-modified">1124   }</span>
1125 
1126   // XXX - Use binary search?
1127   HeapWord* dense_prefix = sd.region_to_addr(cp);
1128   const RegionData* full_cp = cp;
1129   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1130   while (cp &lt; end_cp) {
1131     HeapWord* region_destination = cp-&gt;destination();
1132     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
<a name="16" id="anc16"></a><span class="line-modified">1133     if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1134       tty-&gt;print_cr(&quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;</span>
<span class="line-modified">1135                     &quot;dp=&quot; PTR_FORMAT &quot; &quot; &quot;cdw=&quot; SIZE_FORMAT_W(8),</span>
<span class="line-modified">1136                     sd.region(cp), p2i(region_destination),</span>
<span class="line-modified">1137                     p2i(dense_prefix), cur_deadwood);</span>
<span class="line-modified">1138     }</span>
1139 
1140     if (cur_deadwood &gt;= deadwood_goal) {
1141       // Found the region that has the correct amount of deadwood to the left.
1142       // This typically occurs after crossing a fairly sparse set of regions, so
1143       // iterate backwards over those sparse regions, looking for the region
1144       // that has the lowest density of live objects &#39;to the right.&#39;
1145       size_t space_to_left = sd.region(cp) * region_size;
1146       size_t live_to_left = space_to_left - cur_deadwood;
1147       size_t space_to_right = space_capacity - space_to_left;
1148       size_t live_to_right = space_live - live_to_left;
1149       double density_to_right = double(live_to_right) / space_to_right;
1150       while (cp &gt; full_cp) {
1151         --cp;
1152         const size_t prev_region_live_to_right = live_to_right -
1153           cp-&gt;data_size();
1154         const size_t prev_region_space_to_right = space_to_right + region_size;
1155         double prev_region_density_to_right =
1156           double(prev_region_live_to_right) / prev_region_space_to_right;
1157         if (density_to_right &lt;= prev_region_density_to_right) {
1158           return dense_prefix;
1159         }
<a name="17" id="anc17"></a><span class="line-modified">1160         if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1161           tty-&gt;print_cr(&quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;</span>
<span class="line-modified">1162                         &quot;pc_d2r=%10.8f&quot;, sd.region(cp), density_to_right,</span>
<span class="line-modified">1163                         prev_region_density_to_right);</span>
<span class="line-modified">1164         }</span>


1165         dense_prefix -= region_size;
1166         live_to_right = prev_region_live_to_right;
1167         space_to_right = prev_region_space_to_right;
1168         density_to_right = prev_region_density_to_right;
1169       }
1170       return dense_prefix;
1171     }
1172 
1173     dense_prefix += region_size;
1174     ++cp;
1175   }
1176 
1177   return dense_prefix;
1178 }
1179 
1180 #ifndef PRODUCT
1181 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1182                                                  const SpaceId id,
1183                                                  const bool maximum_compaction,
1184                                                  HeapWord* const addr)
1185 {
1186   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1187   RegionData* const cp = summary_data().region(region_idx);
1188   const MutableSpace* const space = _space_info[id].space();
1189   HeapWord* const new_top = _space_info[id].new_top();
1190 
1191   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1192   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1193   const size_t space_cap = space-&gt;capacity_in_words();
1194   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1195   const size_t live_to_right = new_top - cp-&gt;destination();
1196   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1197 
<a name="18" id="anc18"></a><span class="line-modified">1198   tty-&gt;print_cr(&quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;</span>
<span class="line-modified">1199                 &quot;spl=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1200                 &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;</span>
<span class="line-modified">1201                 &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT</span>
<span class="line-modified">1202                 &quot; ratio=%10.8f&quot;,</span>
<span class="line-modified">1203                 algorithm, p2i(addr), region_idx,</span>
<span class="line-modified">1204                 space_live,</span>
<span class="line-modified">1205                 dead_to_left, dead_to_left_pct,</span>
<span class="line-modified">1206                 dead_to_right, live_to_right,</span>
<span class="line-modified">1207                 double(dead_to_right) / live_to_right);</span>

1208 }
1209 #endif  // #ifndef PRODUCT
1210 
1211 // Return a fraction indicating how much of the generation can be treated as
1212 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1213 // based on the density of live objects in the generation to determine a limit,
1214 // which is then adjusted so the return value is min_percent when the density is
1215 // 1.
1216 //
1217 // The following table shows some return values for a different values of the
1218 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1219 // min_percent is 1.
1220 //
1221 //                          fraction allowed as dead wood
1222 //         -----------------------------------------------------------------
1223 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1224 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1225 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1226 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1227 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
1228 // 0.15000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066
1229 // 0.20000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975
1230 // 0.25000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313
1231 // 0.30000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132
1232 // 0.35000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289
1233 // 0.40000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500
1234 // 0.45000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386
1235 // 0.50000 0.13832410 0.11599237 0.09847664 0.08456518 0.07338887 0.06431510
1236 // 0.55000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386
1237 // 0.60000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500
1238 // 0.65000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289
1239 // 0.70000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132
1240 // 0.75000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313
1241 // 0.80000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975
1242 // 0.85000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066
1243 // 0.90000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
1244 // 0.95000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1245 // 1.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1246 
1247 double PSParallelCompact::dead_wood_limiter(double density, size_t min_percent)
1248 {
1249   assert(_dwl_initialized, &quot;uninitialized&quot;);
1250 
1251   // The raw limit is the value of the normal distribution at x = density.
1252   const double raw_limit = normal_distribution(density);
1253 
1254   // Adjust the raw limit so it becomes the minimum when the density is 1.
1255   //
1256   // First subtract the adjustment value (which is simply the precomputed value
1257   // normal_distribution(1.0)); this yields a value of 0 when the density is 1.
1258   // Then add the minimum value, so the minimum is returned when the density is
1259   // 1.  Finally, prevent negative values, which occur when the mean is not 0.5.
1260   const double min = double(min_percent) / 100.0;
1261   const double limit = raw_limit - _dwl_adjustment + min;
1262   return MAX2(limit, 0.0);
1263 }
1264 
1265 ParallelCompactData::RegionData*
1266 PSParallelCompact::first_dead_space_region(const RegionData* beg,
1267                                            const RegionData* end)
1268 {
1269   const size_t region_size = ParallelCompactData::RegionSize;
1270   ParallelCompactData&amp; sd = summary_data();
1271   size_t left = sd.region(beg);
1272   size_t right = end &gt; beg ? sd.region(end) - 1 : left;
1273 
1274   // Binary search.
1275   while (left &lt; right) {
1276     // Equivalent to (left + right) / 2, but does not overflow.
1277     const size_t middle = left + (right - left) / 2;
1278     RegionData* const middle_ptr = sd.region(middle);
1279     HeapWord* const dest = middle_ptr-&gt;destination();
1280     HeapWord* const addr = sd.region_to_addr(middle);
1281     assert(dest != NULL, &quot;sanity&quot;);
1282     assert(dest &lt;= addr, &quot;must move left&quot;);
1283 
1284     if (middle &gt; left &amp;&amp; dest &lt; addr) {
1285       right = middle - 1;
1286     } else if (middle &lt; right &amp;&amp; middle_ptr-&gt;data_size() == region_size) {
1287       left = middle + 1;
1288     } else {
1289       return middle_ptr;
1290     }
1291   }
1292   return sd.region(left);
1293 }
1294 
1295 ParallelCompactData::RegionData*
1296 PSParallelCompact::dead_wood_limit_region(const RegionData* beg,
1297                                           const RegionData* end,
1298                                           size_t dead_words)
1299 {
1300   ParallelCompactData&amp; sd = summary_data();
1301   size_t left = sd.region(beg);
1302   size_t right = end &gt; beg ? sd.region(end) - 1 : left;
1303 
1304   // Binary search.
1305   while (left &lt; right) {
1306     // Equivalent to (left + right) / 2, but does not overflow.
1307     const size_t middle = left + (right - left) / 2;
1308     RegionData* const middle_ptr = sd.region(middle);
1309     HeapWord* const dest = middle_ptr-&gt;destination();
1310     HeapWord* const addr = sd.region_to_addr(middle);
1311     assert(dest != NULL, &quot;sanity&quot;);
1312     assert(dest &lt;= addr, &quot;must move left&quot;);
1313 
1314     const size_t dead_to_left = pointer_delta(addr, dest);
1315     if (middle &gt; left &amp;&amp; dead_to_left &gt; dead_words) {
1316       right = middle - 1;
1317     } else if (middle &lt; right &amp;&amp; dead_to_left &lt; dead_words) {
1318       left = middle + 1;
1319     } else {
1320       return middle_ptr;
1321     }
1322   }
1323   return sd.region(left);
1324 }
1325 
1326 // The result is valid during the summary phase, after the initial summarization
1327 // of each space into itself, and before final summarization.
1328 inline double
1329 PSParallelCompact::reclaimed_ratio(const RegionData* const cp,
1330                                    HeapWord* const bottom,
1331                                    HeapWord* const top,
1332                                    HeapWord* const new_top)
1333 {
1334   ParallelCompactData&amp; sd = summary_data();
1335 
1336   assert(cp != NULL, &quot;sanity&quot;);
1337   assert(bottom != NULL, &quot;sanity&quot;);
1338   assert(top != NULL, &quot;sanity&quot;);
1339   assert(new_top != NULL, &quot;sanity&quot;);
1340   assert(top &gt;= new_top, &quot;summary data problem?&quot;);
1341   assert(new_top &gt; bottom, &quot;space is empty; should not be here&quot;);
1342   assert(new_top &gt;= cp-&gt;destination(), &quot;sanity&quot;);
1343   assert(top &gt;= sd.region_to_addr(cp), &quot;sanity&quot;);
1344 
1345   HeapWord* const destination = cp-&gt;destination();
1346   const size_t dense_prefix_live  = pointer_delta(destination, bottom);
1347   const size_t compacted_region_live = pointer_delta(new_top, destination);
1348   const size_t compacted_region_used = pointer_delta(top,
1349                                                      sd.region_to_addr(cp));
1350   const size_t reclaimable = compacted_region_used - compacted_region_live;
1351 
1352   const double divisor = dense_prefix_live + 1.25 * compacted_region_live;
1353   return double(reclaimable) / divisor;
1354 }
1355 
1356 // Return the address of the end of the dense prefix, a.k.a. the start of the
1357 // compacted region.  The address is always on a region boundary.
1358 //
1359 // Completely full regions at the left are skipped, since no compaction can
1360 // occur in those regions.  Then the maximum amount of dead wood to allow is
1361 // computed, based on the density (amount live / capacity) of the generation;
1362 // the region with approximately that amount of dead space to the left is
1363 // identified as the limit region.  Regions between the last completely full
1364 // region and the limit region are scanned and the one that has the best
1365 // (maximum) reclaimed_ratio() is selected.
1366 HeapWord*
1367 PSParallelCompact::compute_dense_prefix(const SpaceId id,
1368                                         bool maximum_compaction)
1369 {
1370   const size_t region_size = ParallelCompactData::RegionSize;
1371   const ParallelCompactData&amp; sd = summary_data();
1372 
1373   const MutableSpace* const space = _space_info[id].space();
1374   HeapWord* const top = space-&gt;top();
1375   HeapWord* const top_aligned_up = sd.region_align_up(top);
1376   HeapWord* const new_top = _space_info[id].new_top();
1377   HeapWord* const new_top_aligned_up = sd.region_align_up(new_top);
1378   HeapWord* const bottom = space-&gt;bottom();
1379   const RegionData* const beg_cp = sd.addr_to_region_ptr(bottom);
1380   const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);
1381   const RegionData* const new_top_cp =
1382     sd.addr_to_region_ptr(new_top_aligned_up);
1383 
1384   // Skip full regions at the beginning of the space--they are necessarily part
1385   // of the dense prefix.
1386   const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);
1387   assert(full_cp-&gt;destination() == sd.region_to_addr(full_cp) ||
1388          space-&gt;is_empty(), &quot;no dead space allowed to the left&quot;);
1389   assert(full_cp-&gt;data_size() &lt; region_size || full_cp == new_top_cp - 1,
1390          &quot;region must have dead space&quot;);
1391 
1392   // The gc number is saved whenever a maximum compaction is done, and used to
1393   // determine when the maximum compaction interval has expired.  This avoids
1394   // successive max compactions for different reasons.
1395   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1396   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1397   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1398     total_invocations() == HeapFirstMaximumCompactionCount;
1399   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1400     _maximum_compaction_gc_num = total_invocations();
1401     return sd.region_to_addr(full_cp);
1402   }
1403 
1404   const size_t space_live = pointer_delta(new_top, bottom);
1405   const size_t space_used = space-&gt;used_in_words();
1406   const size_t space_capacity = space-&gt;capacity_in_words();
1407 
1408   const double density = double(space_live) / double(space_capacity);
1409   const size_t min_percent_free = MarkSweepDeadRatio;
1410   const double limiter = dead_wood_limiter(density, min_percent_free);
1411   const size_t dead_wood_max = space_used - space_live;
1412   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1413                                       dead_wood_max);
1414 
<a name="19" id="anc19"></a><span class="line-modified">1415   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1416     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1417                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1418                   space_live, space_used,</span>
<span class="line-modified">1419                   space_capacity);</span>
<span class="line-modified">1420     tty-&gt;print_cr(&quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;</span>
<span class="line-modified">1421                   &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1422                   density, min_percent_free, limiter,</span>
<span class="line-modified">1423                   dead_wood_max, dead_wood_limit);</span>
<span class="line-modified">1424   }</span>
1425 
1426   // Locate the region with the desired amount of dead space to the left.
1427   const RegionData* const limit_cp =
1428     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1429 
1430   // Scan from the first region with dead space to the limit region and find the
1431   // one with the best (largest) reclaimed ratio.
1432   double best_ratio = 0.0;
1433   const RegionData* best_cp = full_cp;
1434   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1435     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1436     if (tmp_ratio &gt; best_ratio) {
1437       best_cp = cp;
1438       best_ratio = tmp_ratio;
1439     }
1440   }
1441 
1442   return sd.region_to_addr(best_cp);
1443 }
1444 
1445 void PSParallelCompact::summarize_spaces_quick()
1446 {
1447   for (unsigned int i = 0; i &lt; last_space_id; ++i) {
1448     const MutableSpace* space = _space_info[i].space();
1449     HeapWord** nta = _space_info[i].new_top_addr();
1450     bool result = _summary_data.summarize(_space_info[i].split_info(),
1451                                           space-&gt;bottom(), space-&gt;top(), NULL,
1452                                           space-&gt;bottom(), space-&gt;end(), nta);
1453     assert(result, &quot;space must fit into itself&quot;);
1454     _space_info[i].set_dense_prefix(space-&gt;bottom());
1455   }
1456 }
1457 
1458 void PSParallelCompact::fill_dense_prefix_end(SpaceId id)
1459 {
1460   HeapWord* const dense_prefix_end = dense_prefix(id);
1461   const RegionData* region = _summary_data.addr_to_region_ptr(dense_prefix_end);
1462   const idx_t dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);
1463   if (dead_space_crosses_boundary(region, dense_prefix_bit)) {
1464     // Only enough dead space is filled so that any remaining dead space to the
1465     // left is larger than the minimum filler object.  (The remainder is filled
1466     // during the copy/update phase.)
1467     //
1468     // The size of the dead space to the right of the boundary is not a
1469     // concern, since compaction will be able to use whatever space is
1470     // available.
1471     //
1472     // Here &#39;||&#39; is the boundary, &#39;x&#39; represents a don&#39;t care bit and a box
1473     // surrounds the space to be filled with an object.
1474     //
1475     // In the 32-bit VM, each bit represents two 32-bit words:
1476     //                              +---+
1477     // a) beg_bits:  ...  x   x   x | 0 | ||   0   x  x  ...
1478     //    end_bits:  ...  x   x   x | 0 | ||   0   x  x  ...
1479     //                              +---+
1480     //
1481     // In the 64-bit VM, each bit represents one 64-bit word:
1482     //                              +------------+
1483     // b) beg_bits:  ...  x   x   x | 0   ||   0 | x  x  ...
1484     //    end_bits:  ...  x   x   1 | 0   ||   0 | x  x  ...
1485     //                              +------------+
1486     //                          +-------+
1487     // c) beg_bits:  ...  x   x | 0   0 | ||   0   x  x  ...
1488     //    end_bits:  ...  x   1 | 0   0 | ||   0   x  x  ...
1489     //                          +-------+
1490     //                      +-----------+
1491     // d) beg_bits:  ...  x | 0   0   0 | ||   0   x  x  ...
1492     //    end_bits:  ...  1 | 0   0   0 | ||   0   x  x  ...
1493     //                      +-----------+
1494     //                          +-------+
1495     // e) beg_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...
1496     //    end_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...
1497     //                          +-------+
1498 
1499     // Initially assume case a, c or e will apply.
1500     size_t obj_len = CollectedHeap::min_fill_size();
1501     HeapWord* obj_beg = dense_prefix_end - obj_len;
1502 
1503 #ifdef  _LP64
1504     if (MinObjAlignment &gt; 1) { // object alignment &gt; heap word size
1505       // Cases a, c or e.
1506     } else if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {
1507       // Case b above.
1508       obj_beg = dense_prefix_end - 1;
1509     } else if (!_mark_bitmap.is_obj_end(dense_prefix_bit - 3) &amp;&amp;
1510                _mark_bitmap.is_obj_end(dense_prefix_bit - 4)) {
1511       // Case d above.
1512       obj_beg = dense_prefix_end - 3;
1513       obj_len = 3;
1514     }
1515 #endif  // #ifdef _LP64
1516 
1517     CollectedHeap::fill_with_object(obj_beg, obj_len);
1518     _mark_bitmap.mark_obj(obj_beg, obj_len);
1519     _summary_data.add_obj(obj_beg, obj_len);
1520     assert(start_array(id) != NULL, &quot;sanity&quot;);
1521     start_array(id)-&gt;allocate_block(obj_beg);
1522   }
1523 }
1524 
1525 void
1526 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1527 {
1528   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1529   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1530          &quot;should have been reset in summarize_spaces_quick()&quot;);
1531 
1532   const MutableSpace* space = _space_info[id].space();
1533   if (_space_info[id].new_top() != space-&gt;bottom()) {
1534     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1535     _space_info[id].set_dense_prefix(dense_prefix_end);
1536 
1537 #ifndef PRODUCT
<a name="20" id="anc20"></a><span class="line-modified">1538     if (TraceParallelOldGCDensePrefix) {</span>
1539       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1540                                dense_prefix_end);
1541       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1542       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1543     }
1544 #endif  // #ifndef PRODUCT
1545 
1546     // Recompute the summary data, taking into account the dense prefix.  If
1547     // every last byte will be reclaimed, then the existing summary data which
1548     // compacts everything can be left in place.
1549     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1550       // If dead space crosses the dense prefix boundary, it is (at least
1551       // partially) filled with a dummy object, marked live and added to the
1552       // summary data.  This simplifies the copy/update phase and must be done
1553       // before the final locations of objects are determined, to prevent
1554       // leaving a fragment of dead space that is too small to fill.
1555       fill_dense_prefix_end(id);
1556 
1557       // Compute the destination of each Region, and thus each object.
1558       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
1559       _summary_data.summarize(_space_info[id].split_info(),
1560                               dense_prefix_end, space-&gt;top(), NULL,
1561                               dense_prefix_end, space-&gt;end(),
1562                               _space_info[id].new_top_addr());
1563     }
1564   }
1565 
1566   if (log_develop_is_enabled(Trace, gc, compaction)) {
1567     const size_t region_size = ParallelCompactData::RegionSize;
1568     HeapWord* const dense_prefix_end = _space_info[id].dense_prefix();
1569     const size_t dp_region = _summary_data.addr_to_region_idx(dense_prefix_end);
1570     const size_t dp_words = pointer_delta(dense_prefix_end, space-&gt;bottom());
1571     HeapWord* const new_top = _space_info[id].new_top();
1572     const HeapWord* nt_aligned_up = _summary_data.region_align_up(new_top);
1573     const size_t cr_words = pointer_delta(nt_aligned_up, dense_prefix_end);
1574     log_develop_trace(gc, compaction)(
1575         &quot;id=%d cap=&quot; SIZE_FORMAT &quot; dp=&quot; PTR_FORMAT &quot; &quot;
1576         &quot;dp_region=&quot; SIZE_FORMAT &quot; &quot; &quot;dp_count=&quot; SIZE_FORMAT &quot; &quot;
1577         &quot;cr_count=&quot; SIZE_FORMAT &quot; &quot; &quot;nt=&quot; PTR_FORMAT,
1578         id, space-&gt;capacity_in_words(), p2i(dense_prefix_end),
1579         dp_region, dp_words / region_size,
1580         cr_words / region_size, p2i(new_top));
1581   }
1582 }
1583 
1584 #ifndef PRODUCT
1585 void PSParallelCompact::summary_phase_msg(SpaceId dst_space_id,
1586                                           HeapWord* dst_beg, HeapWord* dst_end,
1587                                           SpaceId src_space_id,
1588                                           HeapWord* src_beg, HeapWord* src_end)
1589 {
1590   log_develop_trace(gc, compaction)(
1591       &quot;Summarizing %d [%s] into %d [%s]:  &quot;
1592       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1593       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1594       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1595       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1596       src_space_id, space_names[src_space_id],
1597       dst_space_id, space_names[dst_space_id],
1598       p2i(src_beg), p2i(src_end),
1599       _summary_data.addr_to_region_idx(src_beg),
1600       _summary_data.addr_to_region_idx(src_end),
1601       p2i(dst_beg), p2i(dst_end),
1602       _summary_data.addr_to_region_idx(dst_beg),
1603       _summary_data.addr_to_region_idx(dst_end));
1604 }
1605 #endif  // #ifndef PRODUCT
1606 
1607 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1608                                       bool maximum_compaction)
1609 {
1610   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1611 
<a name="21" id="anc21"></a><span class="line-modified">1612 #ifdef  ASSERT</span>
<span class="line-modified">1613   if (TraceParallelOldGCMarkingPhase) {</span>
<span class="line-modified">1614     tty-&gt;print_cr(&quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1615                   &quot;add_obj_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1616                   add_obj_count, add_obj_size * HeapWordSize);</span>
<span class="line-modified">1617     tty-&gt;print_cr(&quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1618                   &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1619                   mark_bitmap_count, mark_bitmap_size * HeapWordSize);</span>
<span class="line-modified">1620   }</span>
<span class="line-modified">1621 #endif  // #ifdef ASSERT</span>
1622 
1623   // Quick summarization of each space into itself, to see how much is live.
1624   summarize_spaces_quick();
1625 
1626   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1627   NOT_PRODUCT(print_region_ranges());
1628   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1629 
1630   // The amount of live data that will end up in old space (assuming it fits).
1631   size_t old_space_total_live = 0;
1632   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1633     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1634                                           _space_info[id].space()-&gt;bottom());
1635   }
1636 
1637   MutableSpace* const old_space = _space_info[old_space_id].space();
1638   const size_t old_capacity = old_space-&gt;capacity_in_words();
1639   if (old_space_total_live &gt; old_capacity) {
1640     // XXX - should also try to expand
1641     maximum_compaction = true;
1642   }
1643 
1644   // Old generations.
1645   summarize_space(old_space_id, maximum_compaction);
1646 
1647   // Summarize the remaining spaces in the young gen.  The initial target space
1648   // is the old gen.  If a space does not fit entirely into the target, then the
1649   // remainder is compacted into the space itself and that space becomes the new
1650   // target.
1651   SpaceId dst_space_id = old_space_id;
1652   HeapWord* dst_space_end = old_space-&gt;end();
1653   HeapWord** new_top_addr = _space_info[dst_space_id].new_top_addr();
1654   for (unsigned int id = eden_space_id; id &lt; last_space_id; ++id) {
1655     const MutableSpace* space = _space_info[id].space();
1656     const size_t live = pointer_delta(_space_info[id].new_top(),
1657                                       space-&gt;bottom());
1658     const size_t available = pointer_delta(dst_space_end, *new_top_addr);
1659 
1660     NOT_PRODUCT(summary_phase_msg(dst_space_id, *new_top_addr, dst_space_end,
1661                                   SpaceId(id), space-&gt;bottom(), space-&gt;top());)
1662     if (live &gt; 0 &amp;&amp; live &lt;= available) {
1663       // All the live data will fit.
1664       bool done = _summary_data.summarize(_space_info[id].split_info(),
1665                                           space-&gt;bottom(), space-&gt;top(),
1666                                           NULL,
1667                                           *new_top_addr, dst_space_end,
1668                                           new_top_addr);
1669       assert(done, &quot;space must fit into old gen&quot;);
1670 
1671       // Reset the new_top value for the space.
1672       _space_info[id].set_new_top(space-&gt;bottom());
1673     } else if (live &gt; 0) {
1674       // Attempt to fit part of the source space into the target space.
1675       HeapWord* next_src_addr = NULL;
1676       bool done = _summary_data.summarize(_space_info[id].split_info(),
1677                                           space-&gt;bottom(), space-&gt;top(),
1678                                           &amp;next_src_addr,
1679                                           *new_top_addr, dst_space_end,
1680                                           new_top_addr);
1681       assert(!done, &quot;space should not fit into old gen&quot;);
1682       assert(next_src_addr != NULL, &quot;sanity&quot;);
1683 
1684       // The source space becomes the new target, so the remainder is compacted
1685       // within the space itself.
1686       dst_space_id = SpaceId(id);
1687       dst_space_end = space-&gt;end();
1688       new_top_addr = _space_info[id].new_top_addr();
1689       NOT_PRODUCT(summary_phase_msg(dst_space_id,
1690                                     space-&gt;bottom(), dst_space_end,
1691                                     SpaceId(id), next_src_addr, space-&gt;top());)
1692       done = _summary_data.summarize(_space_info[id].split_info(),
1693                                      next_src_addr, space-&gt;top(),
1694                                      NULL,
1695                                      space-&gt;bottom(), dst_space_end,
1696                                      new_top_addr);
1697       assert(done, &quot;space must fit when compacted into itself&quot;);
1698       assert(*new_top_addr &lt;= space-&gt;top(), &quot;usage should not grow&quot;);
1699     }
1700   }
1701 
1702   log_develop_trace(gc, compaction)(&quot;Summary_phase:  after final summarization&quot;);
1703   NOT_PRODUCT(print_region_ranges());
1704   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1705 }
1706 
1707 // This method should contain all heap-specific policy for invoking a full
1708 // collection.  invoke_no_policy() will only attempt to compact the heap; it
1709 // will do nothing further.  If we need to bail out for policy reasons, scavenge
1710 // before full gc, or any other specialized behavior, it needs to be added here.
1711 //
1712 // Note that this method should only be called from the vm_thread while at a
1713 // safepoint.
1714 //
<a name="22" id="anc22"></a><span class="line-modified">1715 // Note that the all_soft_refs_clear flag in the collector policy</span>
1716 // may be true because this method can be called without intervening
1717 // activity.  For example when the heap space is tight and full measure
1718 // are being taken to free space.
1719 void PSParallelCompact::invoke(bool maximum_heap_compaction) {
1720   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
1721   assert(Thread::current() == (Thread*)VMThread::vm_thread(),
1722          &quot;should be in vm thread&quot;);
1723 
1724   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1725   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1726   assert(!heap-&gt;is_gc_active(), &quot;not reentrant&quot;);
1727 
1728   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
1729   IsGCActiveMark mark;
1730 
1731   if (ScavengeBeforeFullGC) {
1732     PSScavenge::invoke_no_policy();
1733   }
1734 
1735   const bool clear_all_soft_refs =
1736     heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs();
1737 
1738   PSParallelCompact::invoke_no_policy(clear_all_soft_refs ||
1739                                       maximum_heap_compaction);
1740 }
1741 
1742 // This method contains no policy. You should probably
1743 // be calling invoke() instead.
1744 bool PSParallelCompact::invoke_no_policy(bool maximum_heap_compaction) {
1745   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at a safepoint&quot;);
1746   assert(ref_processor() != NULL, &quot;Sanity&quot;);
1747 
1748   if (GCLocker::check_active_before_gc()) {
1749     return false;
1750   }
1751 
1752   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
1753 
1754   GCIdMark gc_id_mark;
1755   _gc_timer.register_gc_start();
1756   _gc_tracer.report_gc_start(heap-&gt;gc_cause(), _gc_timer.gc_start());
1757 
1758   TimeStamp marking_start;
1759   TimeStamp compaction_start;
1760   TimeStamp collection_exit;
1761 
1762   GCCause::Cause gc_cause = heap-&gt;gc_cause();
1763   PSYoungGen* young_gen = heap-&gt;young_gen();
1764   PSOldGen* old_gen = heap-&gt;old_gen();
1765   PSAdaptiveSizePolicy* size_policy = heap-&gt;size_policy();
1766 
1767   // The scope of casr should end after code that can change
<a name="23" id="anc23"></a><span class="line-modified">1768   // CollectorPolicy::_should_clear_all_soft_refs.</span>
1769   ClearedAllSoftRefs casr(maximum_heap_compaction,
1770                           heap-&gt;soft_ref_policy());
1771 
1772   if (ZapUnusedHeapArea) {
1773     // Save information needed to minimize mangling
1774     heap-&gt;record_gen_tops_before_GC();
1775   }
1776 
1777   // Make sure data structures are sane, make the heap parsable, and do other
1778   // miscellaneous bookkeeping.
1779   pre_compact();
1780 
<a name="24" id="anc24"></a><span class="line-modified">1781   PreGCValues pre_gc_values(heap);</span>
1782 
1783   // Get the compaction manager reserved for the VM thread.
1784   ParCompactionManager* const vmthread_cm =
<a name="25" id="anc25"></a><span class="line-modified">1785     ParCompactionManager::manager_array(gc_task_manager()-&gt;workers());</span>
1786 
1787   {
1788     ResourceMark rm;
1789     HandleMark hm;
1790 
<a name="26" id="anc26"></a><span class="line-modified">1791     // Set the number of GC threads to be used in this collection</span>
<span class="line-modified">1792     gc_task_manager()-&gt;set_active_gang();</span>
<span class="line-modified">1793     gc_task_manager()-&gt;task_idle_workers();</span>


1794 
1795     GCTraceCPUTime tcpu;
1796     GCTraceTime(Info, gc) tm(&quot;Pause Full&quot;, NULL, gc_cause, true);
1797 
1798     heap-&gt;pre_full_gc_dump(&amp;_gc_timer);
1799 
1800     TraceCollectorStats tcs(counters());
1801     TraceMemoryManagerStats tms(heap-&gt;old_gc_manager(), gc_cause);
1802 
1803     if (log_is_enabled(Debug, gc, heap, exit)) {
1804       accumulated_time()-&gt;start();
1805     }
1806 
1807     // Let the size policy know we&#39;re starting
1808     size_policy-&gt;major_collection_begin();
1809 
1810 #if COMPILER2_OR_JVMCI
1811     DerivedPointerTable::clear();
1812 #endif
1813 
1814     ref_processor()-&gt;enable_discovery();
1815     ref_processor()-&gt;setup_policy(maximum_heap_compaction);
1816 
1817     bool marked_for_unloading = false;
1818 
1819     marking_start.update();
1820     marking_phase(vmthread_cm, maximum_heap_compaction, &amp;_gc_tracer);
1821 
1822     bool max_on_system_gc = UseMaximumCompactionOnSystemGC
1823       &amp;&amp; GCCause::is_user_requested_gc(gc_cause);
1824     summary_phase(vmthread_cm, maximum_heap_compaction || max_on_system_gc);
1825 
1826 #if COMPILER2_OR_JVMCI
1827     assert(DerivedPointerTable::is_active(), &quot;Sanity&quot;);
1828     DerivedPointerTable::set_active(false);
1829 #endif
1830 
1831     // adjust_roots() updates Universe::_intArrayKlassObj which is
1832     // needed by the compaction for filling holes in the dense prefix.
1833     adjust_roots(vmthread_cm);
1834 
1835     compaction_start.update();
1836     compact();
1837 
1838     // Reset the mark bitmap, summary data, and do other bookkeeping.  Must be
1839     // done before resizing.
1840     post_compact();
1841 
1842     // Let the size policy know we&#39;re done
1843     size_policy-&gt;major_collection_end(old_gen-&gt;used_in_bytes(), gc_cause);
1844 
1845     if (UseAdaptiveSizePolicy) {
1846       log_debug(gc, ergo)(&quot;AdaptiveSizeStart: collection: %d &quot;, heap-&gt;total_collections());
1847       log_trace(gc, ergo)(&quot;old_gen_capacity: &quot; SIZE_FORMAT &quot; young_gen_capacity: &quot; SIZE_FORMAT,
1848                           old_gen-&gt;capacity_in_bytes(), young_gen-&gt;capacity_in_bytes());
1849 
1850       // Don&#39;t check if the size_policy is ready here.  Let
1851       // the size_policy check that internally.
1852       if (UseAdaptiveGenerationSizePolicyAtMajorCollection &amp;&amp;
1853           AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {
1854         // Swap the survivor spaces if from_space is empty. The
1855         // resize_young_gen() called below is normally used after
1856         // a successful young GC and swapping of survivor spaces;
1857         // otherwise, it will fail to resize the young gen with
1858         // the current implementation.
1859         if (young_gen-&gt;from_space()-&gt;is_empty()) {
1860           young_gen-&gt;from_space()-&gt;clear(SpaceDecorator::Mangle);
1861           young_gen-&gt;swap_spaces();
1862         }
1863 
1864         // Calculate optimal free space amounts
1865         assert(young_gen-&gt;max_size() &gt;
1866           young_gen-&gt;from_space()-&gt;capacity_in_bytes() +
1867           young_gen-&gt;to_space()-&gt;capacity_in_bytes(),
1868           &quot;Sizes of space in young gen are out-of-bounds&quot;);
1869 
1870         size_t young_live = young_gen-&gt;used_in_bytes();
1871         size_t eden_live = young_gen-&gt;eden_space()-&gt;used_in_bytes();
1872         size_t old_live = old_gen-&gt;used_in_bytes();
1873         size_t cur_eden = young_gen-&gt;eden_space()-&gt;capacity_in_bytes();
1874         size_t max_old_gen_size = old_gen-&gt;max_gen_size();
1875         size_t max_eden_size = young_gen-&gt;max_size() -
1876           young_gen-&gt;from_space()-&gt;capacity_in_bytes() -
1877           young_gen-&gt;to_space()-&gt;capacity_in_bytes();
1878 
1879         // Used for diagnostics
1880         size_policy-&gt;clear_generation_free_space_flags();
1881 
1882         size_policy-&gt;compute_generations_free_space(young_live,
1883                                                     eden_live,
1884                                                     old_live,
1885                                                     cur_eden,
1886                                                     max_old_gen_size,
1887                                                     max_eden_size,
1888                                                     true /* full gc*/);
1889 
1890         size_policy-&gt;check_gc_overhead_limit(eden_live,
1891                                              max_old_gen_size,
1892                                              max_eden_size,
1893                                              true /* full gc*/,
1894                                              gc_cause,
1895                                              heap-&gt;soft_ref_policy());
1896 
1897         size_policy-&gt;decay_supplemental_growth(true /* full gc*/);
1898 
1899         heap-&gt;resize_old_gen(
1900           size_policy-&gt;calculated_old_free_size_in_bytes());
1901 
1902         heap-&gt;resize_young_gen(size_policy-&gt;calculated_eden_size_in_bytes(),
1903                                size_policy-&gt;calculated_survivor_size_in_bytes());
1904       }
1905 
1906       log_debug(gc, ergo)(&quot;AdaptiveSizeStop: collection: %d &quot;, heap-&gt;total_collections());
1907     }
1908 
1909     if (UsePerfData) {
1910       PSGCAdaptivePolicyCounters* const counters = heap-&gt;gc_policy_counters();
1911       counters-&gt;update_counters();
1912       counters-&gt;update_old_capacity(old_gen-&gt;capacity_in_bytes());
1913       counters-&gt;update_young_capacity(young_gen-&gt;capacity_in_bytes());
1914     }
1915 
1916     heap-&gt;resize_all_tlabs();
1917 
1918     // Resize the metaspace capacity after a collection
1919     MetaspaceGC::compute_new_size();
1920 
1921     if (log_is_enabled(Debug, gc, heap, exit)) {
1922       accumulated_time()-&gt;stop();
1923     }
1924 
<a name="27" id="anc27"></a><span class="line-modified">1925     young_gen-&gt;print_used_change(pre_gc_values.young_gen_used());</span>
<span class="line-removed">1926     old_gen-&gt;print_used_change(pre_gc_values.old_gen_used());</span>
<span class="line-removed">1927     MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());</span>
1928 
1929     // Track memory usage and detect low memory
1930     MemoryService::track_memory_usage();
1931     heap-&gt;update_counters();
<a name="28" id="anc28"></a><span class="line-removed">1932     gc_task_manager()-&gt;release_idle_workers();</span>
1933 
1934     heap-&gt;post_full_gc_dump(&amp;_gc_timer);
1935   }
1936 
1937 #ifdef ASSERT
1938   for (size_t i = 0; i &lt; ParallelGCThreads + 1; ++i) {
1939     ParCompactionManager* const cm =
1940       ParCompactionManager::manager_array(int(i));
1941     assert(cm-&gt;marking_stack()-&gt;is_empty(),       &quot;should be empty&quot;);
1942     assert(cm-&gt;region_stack()-&gt;is_empty(), &quot;Region stack &quot; SIZE_FORMAT &quot; is not empty&quot;, i);
1943   }
1944 #endif // ASSERT
1945 
1946   if (VerifyAfterGC &amp;&amp; heap-&gt;total_collections() &gt;= VerifyGCStartAt) {
1947     HandleMark hm;  // Discard invalid handles created during verification
1948     Universe::verify(&quot;After GC&quot;);
1949   }
1950 
1951   // Re-verify object start arrays
1952   if (VerifyObjectStartArray &amp;&amp;
1953       VerifyAfterGC) {
1954     old_gen-&gt;verify_object_start_array();
1955   }
1956 
1957   if (ZapUnusedHeapArea) {
1958     old_gen-&gt;object_space()-&gt;check_mangled_unused_area_complete();
1959   }
1960 
1961   NOT_PRODUCT(ref_processor()-&gt;verify_no_references_recorded());
1962 
1963   collection_exit.update();
1964 
1965   heap-&gt;print_heap_after_gc();
1966   heap-&gt;trace_heap_after_gc(&amp;_gc_tracer);
1967 
1968   log_debug(gc, task, time)(&quot;VM-Thread &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT &quot; &quot; JLONG_FORMAT,
1969                          marking_start.ticks(), compaction_start.ticks(),
1970                          collection_exit.ticks());
<a name="29" id="anc29"></a><span class="line-removed">1971   gc_task_manager()-&gt;print_task_time_stamps();</span>
<span class="line-removed">1972 </span>
<span class="line-removed">1973 #ifdef TRACESPINNING</span>
<span class="line-removed">1974   ParallelTaskTerminator::print_termination_counts();</span>
<span class="line-removed">1975 #endif</span>
1976 
1977   AdaptiveSizePolicyOutput::print(size_policy, heap-&gt;total_collections());
1978 
1979   _gc_timer.register_gc_end();
1980 
1981   _gc_tracer.report_dense_prefix(dense_prefix(old_space_id));
1982   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
1983 
1984   return true;
1985 }
1986 
1987 bool PSParallelCompact::absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1988                                              PSYoungGen* young_gen,
1989                                              PSOldGen* old_gen) {
1990   MutableSpace* const eden_space = young_gen-&gt;eden_space();
1991   assert(!eden_space-&gt;is_empty(), &quot;eden must be non-empty&quot;);
1992   assert(young_gen-&gt;virtual_space()-&gt;alignment() ==
1993          old_gen-&gt;virtual_space()-&gt;alignment(), &quot;alignments do not match&quot;);
1994 
<a name="30" id="anc30"></a><span class="line-modified">1995   // We also return false when it&#39;s a heterogenous heap because old generation cannot absorb data from eden</span>
1996   // when it is allocated on different memory (example, nv-dimm) than young.
1997   if (!(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary) ||
<a name="31" id="anc31"></a><span class="line-modified">1998       ParallelScavengeHeap::heap()-&gt;ps_collector_policy()-&gt;is_hetero_heap()) {</span>
1999     return false;
2000   }
2001 
2002   // Both generations must be completely committed.
2003   if (young_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2004     return false;
2005   }
2006   if (old_gen-&gt;virtual_space()-&gt;uncommitted_size() != 0) {
2007     return false;
2008   }
2009 
2010   // Figure out how much to take from eden.  Include the average amount promoted
2011   // in the total; otherwise the next young gen GC will simply bail out to a
2012   // full GC.
2013   const size_t alignment = old_gen-&gt;virtual_space()-&gt;alignment();
2014   const size_t eden_used = eden_space-&gt;used_in_bytes();
2015   const size_t promoted = (size_t)size_policy-&gt;avg_promoted()-&gt;padded_average();
2016   const size_t absorb_size = align_up(eden_used + promoted, alignment);
2017   const size_t eden_capacity = eden_space-&gt;capacity_in_bytes();
2018 
2019   if (absorb_size &gt;= eden_capacity) {
2020     return false; // Must leave some space in eden.
2021   }
2022 
2023   const size_t new_young_size = young_gen-&gt;capacity_in_bytes() - absorb_size;
2024   if (new_young_size &lt; young_gen-&gt;min_gen_size()) {
2025     return false; // Respect young gen minimum size.
2026   }
2027 
2028   log_trace(gc, ergo, heap)(&quot; absorbing &quot; SIZE_FORMAT &quot;K:  &quot;
2029                             &quot;eden &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K &quot;
2030                             &quot;from &quot; SIZE_FORMAT &quot;K, to &quot; SIZE_FORMAT &quot;K &quot;
2031                             &quot;young_gen &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K &quot;,
2032                             absorb_size / K,
2033                             eden_capacity / K, (eden_capacity - absorb_size) / K,
2034                             young_gen-&gt;from_space()-&gt;used_in_bytes() / K,
2035                             young_gen-&gt;to_space()-&gt;used_in_bytes() / K,
2036                             young_gen-&gt;capacity_in_bytes() / K, new_young_size / K);
2037 
2038   // Fill the unused part of the old gen.
2039   MutableSpace* const old_space = old_gen-&gt;object_space();
2040   HeapWord* const unused_start = old_space-&gt;top();
2041   size_t const unused_words = pointer_delta(old_space-&gt;end(), unused_start);
2042 
2043   if (unused_words &gt; 0) {
2044     if (unused_words &lt; CollectedHeap::min_fill_size()) {
2045       return false;  // If the old gen cannot be filled, must give up.
2046     }
2047     CollectedHeap::fill_with_objects(unused_start, unused_words);
2048   }
2049 
2050   // Take the live data from eden and set both top and end in the old gen to
2051   // eden top.  (Need to set end because reset_after_change() mangles the region
2052   // from end to virtual_space-&gt;high() in debug builds).
2053   HeapWord* const new_top = eden_space-&gt;top();
2054   old_gen-&gt;virtual_space()-&gt;expand_into(young_gen-&gt;virtual_space(),
2055                                         absorb_size);
2056   young_gen-&gt;reset_after_change();
2057   old_space-&gt;set_top(new_top);
2058   old_space-&gt;set_end(new_top);
2059   old_gen-&gt;reset_after_change();
2060 
2061   // Update the object start array for the filler object and the data from eden.
2062   ObjectStartArray* const start_array = old_gen-&gt;start_array();
2063   for (HeapWord* p = unused_start; p &lt; new_top; p += oop(p)-&gt;size()) {
2064     start_array-&gt;allocate_block(p);
2065   }
2066 
2067   // Could update the promoted average here, but it is not typically updated at
2068   // full GCs and the value to use is unclear.  Something like
2069   //
2070   // cur_promoted_avg + absorb_size / number_of_scavenges_since_last_full_gc.
2071 
2072   size_policy-&gt;set_bytes_absorbed_from_eden(absorb_size);
2073   return true;
2074 }
2075 
<a name="32" id="anc32"></a><span class="line-removed">2076 GCTaskManager* const PSParallelCompact::gc_task_manager() {</span>
<span class="line-removed">2077   assert(ParallelScavengeHeap::gc_task_manager() != NULL,</span>
<span class="line-removed">2078     &quot;shouldn&#39;t return NULL&quot;);</span>
<span class="line-removed">2079   return ParallelScavengeHeap::gc_task_manager();</span>
<span class="line-removed">2080 }</span>
<span class="line-removed">2081 </span>
2082 class PCAddThreadRootsMarkingTaskClosure : public ThreadClosure {
2083 private:
<a name="33" id="anc33"></a><span class="line-modified">2084   GCTaskQueue* _q;</span>
2085 
2086 public:
<a name="34" id="anc34"></a><span class="line-modified">2087   PCAddThreadRootsMarkingTaskClosure(GCTaskQueue* q) : _q(q) { }</span>
<span class="line-modified">2088   void do_thread(Thread* t) {</span>
<span class="line-modified">2089     _q-&gt;enqueue(new ThreadRootsMarkingTask(t));</span>
































































































































































2090   }
2091 };
2092 
2093 void PSParallelCompact::marking_phase(ParCompactionManager* cm,
2094                                       bool maximum_heap_compaction,
2095                                       ParallelOldTracer *gc_tracer) {
2096   // Recursively traverse all live objects and mark them
2097   GCTraceTime(Info, gc, phases) tm(&quot;Marking Phase&quot;, &amp;_gc_timer);
2098 
2099   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<a name="35" id="anc35"></a><span class="line-modified">2100   uint parallel_gc_threads = heap-&gt;gc_task_manager()-&gt;workers();</span>
<span class="line-removed">2101   uint active_gc_threads = heap-&gt;gc_task_manager()-&gt;active_workers();</span>
<span class="line-removed">2102   TaskQueueSetSuper* qset = ParCompactionManager::stack_array();</span>
<span class="line-removed">2103   TaskTerminator terminator(active_gc_threads, qset);</span>
2104 
2105   PCMarkAndPushClosure mark_and_push_closure(cm);
2106   ParCompactionManager::FollowStackClosure follow_stack_closure(cm);
2107 
2108   // Need new claim bits before marking starts.
2109   ClassLoaderDataGraph::clear_claimed_marks();
2110 
2111   {
2112     GCTraceTime(Debug, gc, phases) tm(&quot;Par Mark&quot;, &amp;_gc_timer);
2113 
<a name="36" id="anc36"></a><span class="line-modified">2114     ParallelScavengeHeap::ParStrongRootsScope psrs;</span>
<span class="line-modified">2115 </span>
<span class="line-removed">2116     GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::universe));</span>
<span class="line-removed">2119     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::jni_handles));</span>
<span class="line-removed">2120     // We scan the thread roots in parallel</span>
<span class="line-removed">2121     PCAddThreadRootsMarkingTaskClosure cl(q);</span>
<span class="line-removed">2122     Threads::java_threads_and_vm_thread_do(&amp;cl);</span>
<span class="line-removed">2123     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::object_synchronizer));</span>
<span class="line-removed">2124     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::management));</span>
<span class="line-removed">2125     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::system_dictionary));</span>
<span class="line-removed">2126     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::class_loader_data));</span>
<span class="line-removed">2127     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::jvmti));</span>
<span class="line-removed">2128     q-&gt;enqueue(new MarkFromRootsTask(MarkFromRootsTask::code_cache));</span>
<span class="line-removed">2129 </span>
<span class="line-removed">2130     if (active_gc_threads &gt; 1) {</span>
<span class="line-removed">2131       for (uint j = 0; j &lt; active_gc_threads; j++) {</span>
<span class="line-removed">2132         q-&gt;enqueue(new StealMarkingTask(terminator.terminator()));</span>
<span class="line-removed">2133       }</span>
<span class="line-removed">2134     }</span>
<span class="line-removed">2135 </span>
<span class="line-removed">2136     gc_task_manager()-&gt;execute_and_wait(q);</span>
2137   }
2138 
2139   // Process reference objects found during marking
2140   {
2141     GCTraceTime(Debug, gc, phases) tm(&quot;Reference Processing&quot;, &amp;_gc_timer);
2142 
2143     ReferenceProcessorStats stats;
2144     ReferenceProcessorPhaseTimes pt(&amp;_gc_timer, ref_processor()-&gt;max_num_queues());
2145 
2146     if (ref_processor()-&gt;processing_is_mt()) {
2147       ref_processor()-&gt;set_active_mt_degree(active_gc_threads);
2148 
2149       RefProcTaskExecutor task_executor;
2150       stats = ref_processor()-&gt;process_discovered_references(
2151         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure,
2152         &amp;task_executor, &amp;pt);
2153     } else {
2154       stats = ref_processor()-&gt;process_discovered_references(
2155         is_alive_closure(), &amp;mark_and_push_closure, &amp;follow_stack_closure, NULL,
2156         &amp;pt);
2157     }
2158 
2159     gc_tracer-&gt;report_gc_reference_stats(stats);
2160     pt.print_all_references();
2161   }
2162 
2163   // This is the point where the entire marking should have completed.
2164   assert(cm-&gt;marking_stacks_empty(), &quot;Marking should have completed&quot;);
2165 
2166   {
2167     GCTraceTime(Debug, gc, phases) tm(&quot;Weak Processing&quot;, &amp;_gc_timer);
2168     WeakProcessor::weak_oops_do(is_alive_closure(), &amp;do_nothing_cl);
2169   }
2170 
2171   {
2172     GCTraceTime(Debug, gc, phases) tm_m(&quot;Class Unloading&quot;, &amp;_gc_timer);
2173 
2174     // Follow system dictionary roots and unload classes.
2175     bool purged_class = SystemDictionary::do_unloading(&amp;_gc_timer);
2176 
2177     // Unload nmethods.
2178     CodeCache::do_unloading(is_alive_closure(), purged_class);
2179 
2180     // Prune dead klasses from subklass/sibling/implementor lists.
2181     Klass::clean_weak_klass_links(purged_class);
<a name="37" id="anc37"></a>


2182   }
2183 
2184   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2185 }
2186 
2187 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2188   // Adjust the pointers to reflect the new locations
2189   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2190 
2191   // Need new claim bits when tracing through and adjusting pointers.
2192   ClassLoaderDataGraph::clear_claimed_marks();
2193 
2194   PCAdjustPointerClosure oop_closure(cm);
2195 
2196   // General strong roots.
2197   Universe::oops_do(&amp;oop_closure);
2198   JNIHandles::oops_do(&amp;oop_closure);   // Global (strong) JNI handles
2199   Threads::oops_do(&amp;oop_closure, NULL);
2200   ObjectSynchronizer::oops_do(&amp;oop_closure);
2201   Management::oops_do(&amp;oop_closure);
2202   JvmtiExport::oops_do(&amp;oop_closure);
2203   SystemDictionary::oops_do(&amp;oop_closure);
2204   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2205   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2206 
2207   // Now adjust pointers in remaining weak roots.  (All of which should
2208   // have been cleared if they pointed to non-surviving objects.)
2209   WeakProcessor::oops_do(&amp;oop_closure);
2210 
2211   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2212   CodeCache::blobs_do(&amp;adjust_from_blobs);
<a name="38" id="anc38"></a><span class="line-modified">2213   AOTLoader::oops_do(&amp;oop_closure);</span>

2214   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2215   // Roots were visited so references into the young gen in roots
2216   // may have been scanned.  Process them also.
2217   // Should the reference processor have a span that excludes
2218   // young gen objects?
2219   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2220 }
2221 
2222 // Helper class to print 8 region numbers per line and then print the total at the end.
2223 class FillableRegionLogger : public StackObj {
2224 private:
2225   Log(gc, compaction) log;
2226   static const int LineLength = 8;
2227   size_t _regions[LineLength];
2228   int _next_index;
2229   bool _enabled;
2230   size_t _total_regions;
2231 public:
2232   FillableRegionLogger() : _next_index(0), _enabled(log_develop_is_enabled(Trace, gc, compaction)), _total_regions(0) { }
2233   ~FillableRegionLogger() {
2234     log.trace(SIZE_FORMAT &quot; initially fillable regions&quot;, _total_regions);
2235   }
2236 
2237   void print_line() {
2238     if (!_enabled || _next_index == 0) {
2239       return;
2240     }
2241     FormatBuffer&lt;&gt; line(&quot;Fillable: &quot;);
2242     for (int i = 0; i &lt; _next_index; i++) {
2243       line.append(&quot; &quot; SIZE_FORMAT_W(7), _regions[i]);
2244     }
2245     log.trace(&quot;%s&quot;, line.buffer());
2246     _next_index = 0;
2247   }
2248 
2249   void handle(size_t region) {
2250     if (!_enabled) {
2251       return;
2252     }
2253     _regions[_next_index++] = region;
2254     if (_next_index == LineLength) {
2255       print_line();
2256     }
2257     _total_regions++;
2258   }
2259 };
2260 
<a name="39" id="anc39"></a><span class="line-modified">2261 void PSParallelCompact::prepare_region_draining_tasks(GCTaskQueue* q,</span>
<span class="line-removed">2262                                                       uint parallel_gc_threads)</span>
2263 {
2264   GCTraceTime(Trace, gc, phases) tm(&quot;Drain Task Setup&quot;, &amp;_gc_timer);
2265 
2266   // Find the threads that are active
<a name="40" id="anc40"></a><span class="line-modified">2267   unsigned int which = 0;</span>
2268 
2269   // Find all regions that are available (can be filled immediately) and
2270   // distribute them to the thread stacks.  The iteration is done in reverse
2271   // order (high to low) so the regions will be removed in ascending order.
2272 
2273   const ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2274 
<a name="41" id="anc41"></a><span class="line-removed">2275   which = 0;</span>
2276   // id + 1 is used to test termination so unsigned  can
2277   // be used with an old_space_id == 0.
2278   FillableRegionLogger region_logger;
2279   for (unsigned int id = to_space_id; id + 1 &gt; old_space_id; --id) {
2280     SpaceInfo* const space_info = _space_info + id;
2281     MutableSpace* const space = space_info-&gt;space();
2282     HeapWord* const new_top = space_info-&gt;new_top();
2283 
2284     const size_t beg_region = sd.addr_to_region_idx(space_info-&gt;dense_prefix());
2285     const size_t end_region =
2286       sd.addr_to_region_idx(sd.region_align_up(new_top));
2287 
2288     for (size_t cur = end_region - 1; cur + 1 &gt; beg_region; --cur) {
2289       if (sd.region(cur)-&gt;claim_unsafe()) {
<a name="42" id="anc42"></a><span class="line-modified">2290         ParCompactionManager* cm = ParCompactionManager::manager_array(which);</span>


2291         cm-&gt;region_stack()-&gt;push(cur);
2292         region_logger.handle(cur);
2293         // Assign regions to tasks in round-robin fashion.
<a name="43" id="anc43"></a><span class="line-modified">2294         if (++which == parallel_gc_threads) {</span>
<span class="line-modified">2295           which = 0;</span>
2296         }
2297       }
2298     }
2299     region_logger.print_line();
2300   }
2301 }
2302 
<a name="44" id="anc44"></a>





























2303 #define PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING 4
2304 
<a name="45" id="anc45"></a><span class="line-modified">2305 void PSParallelCompact::enqueue_dense_prefix_tasks(GCTaskQueue* q,</span>
<span class="line-modified">2306                                                     uint parallel_gc_threads) {</span>
2307   GCTraceTime(Trace, gc, phases) tm(&quot;Dense Prefix Task Setup&quot;, &amp;_gc_timer);
2308 
2309   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2310 
2311   // Iterate over all the spaces adding tasks for updating
2312   // regions in the dense prefix.  Assume that 1 gc thread
2313   // will work on opening the gaps and the remaining gc threads
2314   // will work on the dense prefix.
2315   unsigned int space_id;
2316   for (space_id = old_space_id; space_id &lt; last_space_id; ++ space_id) {
2317     HeapWord* const dense_prefix_end = _space_info[space_id].dense_prefix();
2318     const MutableSpace* const space = _space_info[space_id].space();
2319 
2320     if (dense_prefix_end == space-&gt;bottom()) {
2321       // There is no dense prefix for this space.
2322       continue;
2323     }
2324 
2325     // The dense prefix is before this region.
2326     size_t region_index_end_dense_prefix =
2327         sd.addr_to_region_idx(dense_prefix_end);
2328     RegionData* const dense_prefix_cp =
2329       sd.region(region_index_end_dense_prefix);
2330     assert(dense_prefix_end == space-&gt;end() ||
2331            dense_prefix_cp-&gt;available() ||
2332            dense_prefix_cp-&gt;claimed(),
2333            &quot;The region after the dense prefix should always be ready to fill&quot;);
2334 
2335     size_t region_index_start = sd.addr_to_region_idx(space-&gt;bottom());
2336 
2337     // Is there dense prefix work?
2338     size_t total_dense_prefix_regions =
2339       region_index_end_dense_prefix - region_index_start;
2340     // How many regions of the dense prefix should be given to
2341     // each thread?
2342     if (total_dense_prefix_regions &gt; 0) {
2343       uint tasks_for_dense_prefix = 1;
2344       if (total_dense_prefix_regions &lt;=
2345           (parallel_gc_threads * PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING)) {
2346         // Don&#39;t over partition.  This assumes that
2347         // PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING is a small integer value
2348         // so there are not many regions to process.
2349         tasks_for_dense_prefix = parallel_gc_threads;
2350       } else {
2351         // Over partition
2352         tasks_for_dense_prefix = parallel_gc_threads *
2353           PAR_OLD_DENSE_PREFIX_OVER_PARTITIONING;
2354       }
2355       size_t regions_per_thread = total_dense_prefix_regions /
2356         tasks_for_dense_prefix;
2357       // Give each thread at least 1 region.
2358       if (regions_per_thread == 0) {
2359         regions_per_thread = 1;
2360       }
2361 
2362       for (uint k = 0; k &lt; tasks_for_dense_prefix; k++) {
2363         if (region_index_start &gt;= region_index_end_dense_prefix) {
2364           break;
2365         }
2366         // region_index_end is not processed
2367         size_t region_index_end = MIN2(region_index_start + regions_per_thread,
2368                                        region_index_end_dense_prefix);
<a name="46" id="anc46"></a><span class="line-modified">2369         q-&gt;enqueue(new UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2370                                              region_index_start,</span>
<span class="line-modified">2371                                              region_index_end));</span>
2372         region_index_start = region_index_end;
2373       }
2374     }
2375     // This gets any part of the dense prefix that did not
2376     // fit evenly.
2377     if (region_index_start &lt; region_index_end_dense_prefix) {
<a name="47" id="anc47"></a><span class="line-modified">2378       q-&gt;enqueue(new UpdateDensePrefixTask(SpaceId(space_id),</span>
<span class="line-modified">2379                                            region_index_start,</span>
<span class="line-modified">2380                                            region_index_end_dense_prefix));</span>
2381     }
2382   }
2383 }
2384 
<a name="48" id="anc48"></a><span class="line-removed">2385 void PSParallelCompact::enqueue_region_stealing_tasks(</span>
<span class="line-removed">2386                                      GCTaskQueue* q,</span>
<span class="line-removed">2387                                      ParallelTaskTerminator* terminator_ptr,</span>
<span class="line-removed">2388                                      uint parallel_gc_threads) {</span>
<span class="line-removed">2389   GCTraceTime(Trace, gc, phases) tm(&quot;Steal Task Setup&quot;, &amp;_gc_timer);</span>
<span class="line-removed">2390 </span>
<span class="line-removed">2391   // Once a thread has drained it&#39;s stack, it should try to steal regions from</span>
<span class="line-removed">2392   // other threads.</span>
<span class="line-removed">2393   for (uint j = 0; j &lt; parallel_gc_threads; j++) {</span>
<span class="line-removed">2394     q-&gt;enqueue(new CompactionWithStealingTask(terminator_ptr));</span>
<span class="line-removed">2395   }</span>
<span class="line-removed">2396 }</span>
<span class="line-removed">2397 </span>
2398 #ifdef ASSERT
2399 // Write a histogram of the number of times the block table was filled for a
2400 // region.
2401 void PSParallelCompact::write_block_fill_histogram()
2402 {
2403   if (!log_develop_is_enabled(Trace, gc, compaction)) {
2404     return;
2405   }
2406 
2407   Log(gc, compaction) log;
2408   ResourceMark rm;
2409   LogStream ls(log.trace());
2410   outputStream* out = &amp;ls;
2411 
2412   typedef ParallelCompactData::RegionData rd_t;
2413   ParallelCompactData&amp; sd = summary_data();
2414 
2415   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2416     MutableSpace* const spc = _space_info[id].space();
2417     if (spc-&gt;bottom() != spc-&gt;top()) {
2418       const rd_t* const beg = sd.addr_to_region_ptr(spc-&gt;bottom());
2419       HeapWord* const top_aligned_up = sd.region_align_up(spc-&gt;top());
2420       const rd_t* const end = sd.addr_to_region_ptr(top_aligned_up);
2421 
2422       size_t histo[5] = { 0, 0, 0, 0, 0 };
2423       const size_t histo_len = sizeof(histo) / sizeof(size_t);
2424       const size_t region_cnt = pointer_delta(end, beg, sizeof(rd_t));
2425 
2426       for (const rd_t* cur = beg; cur &lt; end; ++cur) {
2427         ++histo[MIN2(cur-&gt;blocks_filled_count(), histo_len - 1)];
2428       }
2429       out-&gt;print(&quot;Block fill histogram: %u %-4s&quot; SIZE_FORMAT_W(5), id, space_names[id], region_cnt);
2430       for (size_t i = 0; i &lt; histo_len; ++i) {
2431         out-&gt;print(&quot; &quot; SIZE_FORMAT_W(5) &quot; %5.1f%%&quot;,
2432                    histo[i], 100.0 * histo[i] / region_cnt);
2433       }
2434       out-&gt;cr();
2435     }
2436   }
2437 }
2438 #endif // #ifdef ASSERT
2439 
<a name="49" id="anc49"></a>





























































2440 void PSParallelCompact::compact() {
2441   GCTraceTime(Info, gc, phases) tm(&quot;Compaction Phase&quot;, &amp;_gc_timer);
2442 
2443   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
2444   PSOldGen* old_gen = heap-&gt;old_gen();
2445   old_gen-&gt;start_array()-&gt;reset();
<a name="50" id="anc50"></a><span class="line-modified">2446   uint parallel_gc_threads = heap-&gt;gc_task_manager()-&gt;workers();</span>
<span class="line-removed">2447   uint active_gc_threads = heap-&gt;gc_task_manager()-&gt;active_workers();</span>
<span class="line-removed">2448   TaskQueueSetSuper* qset = ParCompactionManager::region_array();</span>
<span class="line-removed">2449   TaskTerminator terminator(active_gc_threads, qset);</span>
2450 
<a name="51" id="anc51"></a><span class="line-modified">2451   GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-modified">2452   prepare_region_draining_tasks(q, active_gc_threads);</span>
<span class="line-modified">2453   enqueue_dense_prefix_tasks(q, active_gc_threads);</span>
<span class="line-modified">2454   enqueue_region_stealing_tasks(q, terminator.terminator(), active_gc_threads);</span>






2455 
2456   {
2457     GCTraceTime(Trace, gc, phases) tm(&quot;Par Compact&quot;, &amp;_gc_timer);
2458 
<a name="52" id="anc52"></a><span class="line-modified">2459     gc_task_manager()-&gt;execute_and_wait(q);</span>

2460 
2461 #ifdef  ASSERT
2462     // Verify that all regions have been processed before the deferred updates.
2463     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2464       verify_complete(SpaceId(id));
2465     }
2466 #endif
2467   }
2468 
2469   {
2470     // Update the deferred objects, if any.  Any compaction manager can be used.
2471     GCTraceTime(Trace, gc, phases) tm(&quot;Deferred Updates&quot;, &amp;_gc_timer);
2472     ParCompactionManager* cm = ParCompactionManager::manager_array(0);
2473     for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2474       update_deferred_objects(cm, SpaceId(id));
2475     }
2476   }
2477 
2478   DEBUG_ONLY(write_block_fill_histogram());
2479 }
2480 
2481 #ifdef  ASSERT
2482 void PSParallelCompact::verify_complete(SpaceId space_id) {
2483   // All Regions between space bottom() to new_top() should be marked as filled
2484   // and all Regions between new_top() and top() should be available (i.e.,
2485   // should have been emptied).
2486   ParallelCompactData&amp; sd = summary_data();
2487   SpaceInfo si = _space_info[space_id];
2488   HeapWord* new_top_addr = sd.region_align_up(si.new_top());
2489   HeapWord* old_top_addr = sd.region_align_up(si.space()-&gt;top());
2490   const size_t beg_region = sd.addr_to_region_idx(si.space()-&gt;bottom());
2491   const size_t new_top_region = sd.addr_to_region_idx(new_top_addr);
2492   const size_t old_top_region = sd.addr_to_region_idx(old_top_addr);
2493 
2494   bool issued_a_warning = false;
2495 
2496   size_t cur_region;
2497   for (cur_region = beg_region; cur_region &lt; new_top_region; ++cur_region) {
2498     const RegionData* const c = sd.region(cur_region);
2499     if (!c-&gt;completed()) {
2500       log_warning(gc)(&quot;region &quot; SIZE_FORMAT &quot; not filled: destination_count=%u&quot;,
2501                       cur_region, c-&gt;destination_count());
2502       issued_a_warning = true;
2503     }
2504   }
2505 
2506   for (cur_region = new_top_region; cur_region &lt; old_top_region; ++cur_region) {
2507     const RegionData* const c = sd.region(cur_region);
2508     if (!c-&gt;available()) {
2509       log_warning(gc)(&quot;region &quot; SIZE_FORMAT &quot; not empty: destination_count=%u&quot;,
2510                       cur_region, c-&gt;destination_count());
2511       issued_a_warning = true;
2512     }
2513   }
2514 
2515   if (issued_a_warning) {
2516     print_region_ranges();
2517   }
2518 }
2519 #endif  // #ifdef ASSERT
2520 
2521 inline void UpdateOnlyClosure::do_addr(HeapWord* addr) {
2522   _start_array-&gt;allocate_block(addr);
2523   compaction_manager()-&gt;update_contents(oop(addr));
2524 }
2525 
2526 // Update interior oops in the ranges of regions [beg_region, end_region).
2527 void
2528 PSParallelCompact::update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,
2529                                                        SpaceId space_id,
2530                                                        size_t beg_region,
2531                                                        size_t end_region) {
2532   ParallelCompactData&amp; sd = summary_data();
2533   ParMarkBitMap* const mbm = mark_bitmap();
2534 
2535   HeapWord* beg_addr = sd.region_to_addr(beg_region);
2536   HeapWord* const end_addr = sd.region_to_addr(end_region);
2537   assert(beg_region &lt;= end_region, &quot;bad region range&quot;);
2538   assert(end_addr &lt;= dense_prefix(space_id), &quot;not in the dense prefix&quot;);
2539 
2540 #ifdef  ASSERT
2541   // Claim the regions to avoid triggering an assert when they are marked as
2542   // filled.
2543   for (size_t claim_region = beg_region; claim_region &lt; end_region; ++claim_region) {
2544     assert(sd.region(claim_region)-&gt;claim_unsafe(), &quot;claim() failed&quot;);
2545   }
2546 #endif  // #ifdef ASSERT
2547 
2548   if (beg_addr != space(space_id)-&gt;bottom()) {
2549     // Find the first live object or block of dead space that *starts* in this
2550     // range of regions.  If a partial object crosses onto the region, skip it;
2551     // it will be marked for &#39;deferred update&#39; when the object head is
2552     // processed.  If dead space crosses onto the region, it is also skipped; it
2553     // will be filled when the prior region is processed.  If neither of those
2554     // apply, the first word in the region is the start of a live object or dead
2555     // space.
2556     assert(beg_addr &gt; space(space_id)-&gt;bottom(), &quot;sanity&quot;);
2557     const RegionData* const cp = sd.region(beg_region);
2558     if (cp-&gt;partial_obj_size() != 0) {
2559       beg_addr = sd.partial_obj_end(beg_region);
2560     } else if (dead_space_crosses_boundary(cp, mbm-&gt;addr_to_bit(beg_addr))) {
2561       beg_addr = mbm-&gt;find_obj_beg(beg_addr, end_addr);
2562     }
2563   }
2564 
2565   if (beg_addr &lt; end_addr) {
2566     // A live object or block of dead space starts in this range of Regions.
2567      HeapWord* const dense_prefix_end = dense_prefix(space_id);
2568 
2569     // Create closures and iterate.
2570     UpdateOnlyClosure update_closure(mbm, cm, space_id);
2571     FillClosure fill_closure(cm, space_id);
2572     ParMarkBitMap::IterationStatus status;
2573     status = mbm-&gt;iterate(&amp;update_closure, &amp;fill_closure, beg_addr, end_addr,
2574                           dense_prefix_end);
2575     if (status == ParMarkBitMap::incomplete) {
2576       update_closure.do_addr(update_closure.source());
2577     }
2578   }
2579 
2580   // Mark the regions as filled.
2581   RegionData* const beg_cp = sd.region(beg_region);
2582   RegionData* const end_cp = sd.region(end_region);
2583   for (RegionData* cp = beg_cp; cp &lt; end_cp; ++cp) {
2584     cp-&gt;set_completed();
2585   }
2586 }
2587 
2588 // Return the SpaceId for the space containing addr.  If addr is not in the
2589 // heap, last_space_id is returned.  In debug mode it expects the address to be
2590 // in the heap and asserts such.
2591 PSParallelCompact::SpaceId PSParallelCompact::space_id(HeapWord* addr) {
2592   assert(ParallelScavengeHeap::heap()-&gt;is_in_reserved(addr), &quot;addr not in the heap&quot;);
2593 
2594   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
2595     if (_space_info[id].space()-&gt;contains(addr)) {
2596       return SpaceId(id);
2597     }
2598   }
2599 
2600   assert(false, &quot;no space contains the addr&quot;);
2601   return last_space_id;
2602 }
2603 
2604 void PSParallelCompact::update_deferred_objects(ParCompactionManager* cm,
2605                                                 SpaceId id) {
2606   assert(id &lt; last_space_id, &quot;bad space id&quot;);
2607 
2608   ParallelCompactData&amp; sd = summary_data();
2609   const SpaceInfo* const space_info = _space_info + id;
2610   ObjectStartArray* const start_array = space_info-&gt;start_array();
2611 
2612   const MutableSpace* const space = space_info-&gt;space();
2613   assert(space_info-&gt;dense_prefix() &gt;= space-&gt;bottom(), &quot;dense_prefix not set&quot;);
2614   HeapWord* const beg_addr = space_info-&gt;dense_prefix();
2615   HeapWord* const end_addr = sd.region_align_up(space_info-&gt;new_top());
2616 
2617   const RegionData* const beg_region = sd.addr_to_region_ptr(beg_addr);
2618   const RegionData* const end_region = sd.addr_to_region_ptr(end_addr);
2619   const RegionData* cur_region;
2620   for (cur_region = beg_region; cur_region &lt; end_region; ++cur_region) {
2621     HeapWord* const addr = cur_region-&gt;deferred_obj_addr();
2622     if (addr != NULL) {
2623       if (start_array != NULL) {
2624         start_array-&gt;allocate_block(addr);
2625       }
2626       cm-&gt;update_contents(oop(addr));
2627       assert(oopDesc::is_oop_or_null(oop(addr)), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(oop(addr)));
2628     }
2629   }
2630 }
2631 
2632 // Skip over count live words starting from beg, and return the address of the
2633 // next live word.  Unless marked, the word corresponding to beg is assumed to
2634 // be dead.  Callers must either ensure beg does not correspond to the middle of
2635 // an object, or account for those live words in some other way.  Callers must
2636 // also ensure that there are enough live words in the range [beg, end) to skip.
2637 HeapWord*
2638 PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)
2639 {
2640   assert(count &gt; 0, &quot;sanity&quot;);
2641 
2642   ParMarkBitMap* m = mark_bitmap();
2643   idx_t bits_to_skip = m-&gt;words_to_bits(count);
2644   idx_t cur_beg = m-&gt;addr_to_bit(beg);
<a name="53" id="anc53"></a><span class="line-modified">2645   const idx_t search_end = BitMap::word_align_up(m-&gt;addr_to_bit(end));</span>
2646 
2647   do {
2648     cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2649     idx_t cur_end = m-&gt;find_obj_end(cur_beg, search_end);
2650     const size_t obj_bits = cur_end - cur_beg + 1;
2651     if (obj_bits &gt; bits_to_skip) {
2652       return m-&gt;bit_to_addr(cur_beg + bits_to_skip);
2653     }
2654     bits_to_skip -= obj_bits;
2655     cur_beg = cur_end + 1;
2656   } while (bits_to_skip &gt; 0);
2657 
2658   // Skipping the desired number of words landed just past the end of an object.
2659   // Find the start of the next object.
2660   cur_beg = m-&gt;find_obj_beg(cur_beg, search_end);
2661   assert(cur_beg &lt; m-&gt;addr_to_bit(end), &quot;not enough live words to skip&quot;);
2662   return m-&gt;bit_to_addr(cur_beg);
2663 }
2664 
2665 HeapWord* PSParallelCompact::first_src_addr(HeapWord* const dest_addr,
2666                                             SpaceId src_space_id,
2667                                             size_t src_region_idx)
2668 {
2669   assert(summary_data().is_region_aligned(dest_addr), &quot;not aligned&quot;);
2670 
2671   const SplitInfo&amp; split_info = _space_info[src_space_id].split_info();
2672   if (split_info.dest_region_addr() == dest_addr) {
2673     // The partial object ending at the split point contains the first word to
2674     // be copied to dest_addr.
2675     return split_info.first_src_addr();
2676   }
2677 
2678   const ParallelCompactData&amp; sd = summary_data();
2679   ParMarkBitMap* const bitmap = mark_bitmap();
2680   const size_t RegionSize = ParallelCompactData::RegionSize;
2681 
2682   assert(sd.is_region_aligned(dest_addr), &quot;not aligned&quot;);
2683   const RegionData* const src_region_ptr = sd.region(src_region_idx);
2684   const size_t partial_obj_size = src_region_ptr-&gt;partial_obj_size();
2685   HeapWord* const src_region_destination = src_region_ptr-&gt;destination();
2686 
2687   assert(dest_addr &gt;= src_region_destination, &quot;wrong src region&quot;);
2688   assert(src_region_ptr-&gt;data_size() &gt; 0, &quot;src region cannot be empty&quot;);
2689 
2690   HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);
2691   HeapWord* const src_region_end = src_region_beg + RegionSize;
2692 
2693   HeapWord* addr = src_region_beg;
2694   if (dest_addr == src_region_destination) {
2695     // Return the first live word in the source region.
2696     if (partial_obj_size == 0) {
2697       addr = bitmap-&gt;find_obj_beg(addr, src_region_end);
2698       assert(addr &lt; src_region_end, &quot;no objects start in src region&quot;);
2699     }
2700     return addr;
2701   }
2702 
2703   // Must skip some live data.
2704   size_t words_to_skip = dest_addr - src_region_destination;
2705   assert(src_region_ptr-&gt;data_size() &gt; words_to_skip, &quot;wrong src region&quot;);
2706 
2707   if (partial_obj_size &gt;= words_to_skip) {
2708     // All the live words to skip are part of the partial object.
2709     addr += words_to_skip;
2710     if (partial_obj_size == words_to_skip) {
2711       // Find the first live word past the partial object.
2712       addr = bitmap-&gt;find_obj_beg(addr, src_region_end);
2713       assert(addr &lt; src_region_end, &quot;wrong src region&quot;);
2714     }
2715     return addr;
2716   }
2717 
2718   // Skip over the partial object (if any).
2719   if (partial_obj_size != 0) {
2720     words_to_skip -= partial_obj_size;
2721     addr += partial_obj_size;
2722   }
2723 
2724   // Skip over live words due to objects that start in the region.
2725   addr = skip_live_words(addr, src_region_end, words_to_skip);
2726   assert(addr &lt; src_region_end, &quot;wrong src region&quot;);
2727   return addr;
2728 }
2729 
2730 void PSParallelCompact::decrement_destination_counts(ParCompactionManager* cm,
2731                                                      SpaceId src_space_id,
2732                                                      size_t beg_region,
2733                                                      HeapWord* end_addr)
2734 {
2735   ParallelCompactData&amp; sd = summary_data();
2736 
2737 #ifdef ASSERT
2738   MutableSpace* const src_space = _space_info[src_space_id].space();
2739   HeapWord* const beg_addr = sd.region_to_addr(beg_region);
2740   assert(src_space-&gt;contains(beg_addr) || beg_addr == src_space-&gt;end(),
2741          &quot;src_space_id does not match beg_addr&quot;);
2742   assert(src_space-&gt;contains(end_addr) || end_addr == src_space-&gt;end(),
2743          &quot;src_space_id does not match end_addr&quot;);
2744 #endif // #ifdef ASSERT
2745 
2746   RegionData* const beg = sd.region(beg_region);
2747   RegionData* const end = sd.addr_to_region_ptr(sd.region_align_up(end_addr));
2748 
2749   // Regions up to new_top() are enqueued if they become available.
2750   HeapWord* const new_top = _space_info[src_space_id].new_top();
2751   RegionData* const enqueue_end =
2752     sd.addr_to_region_ptr(sd.region_align_up(new_top));
2753 
2754   for (RegionData* cur = beg; cur &lt; end; ++cur) {
2755     assert(cur-&gt;data_size() &gt; 0, &quot;region must have live data&quot;);
2756     cur-&gt;decrement_destination_count();
2757     if (cur &lt; enqueue_end &amp;&amp; cur-&gt;available() &amp;&amp; cur-&gt;claim()) {
<a name="54" id="anc54"></a><span class="line-modified">2758       cm-&gt;push_region(sd.region(cur));</span>










2759     }
2760   }
2761 }
2762 
2763 size_t PSParallelCompact::next_src_region(MoveAndUpdateClosure&amp; closure,
2764                                           SpaceId&amp; src_space_id,
2765                                           HeapWord*&amp; src_space_top,
2766                                           HeapWord* end_addr)
2767 {
2768   typedef ParallelCompactData::RegionData RegionData;
2769 
2770   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
2771   const size_t region_size = ParallelCompactData::RegionSize;
2772 
2773   size_t src_region_idx = 0;
2774 
2775   // Skip empty regions (if any) up to the top of the space.
2776   HeapWord* const src_aligned_up = sd.region_align_up(end_addr);
2777   RegionData* src_region_ptr = sd.addr_to_region_ptr(src_aligned_up);
2778   HeapWord* const top_aligned_up = sd.region_align_up(src_space_top);
2779   const RegionData* const top_region_ptr =
2780     sd.addr_to_region_ptr(top_aligned_up);
2781   while (src_region_ptr &lt; top_region_ptr &amp;&amp; src_region_ptr-&gt;data_size() == 0) {
2782     ++src_region_ptr;
2783   }
2784 
2785   if (src_region_ptr &lt; top_region_ptr) {
2786     // The next source region is in the current space.  Update src_region_idx
2787     // and the source address to match src_region_ptr.
2788     src_region_idx = sd.region(src_region_ptr);
2789     HeapWord* const src_region_addr = sd.region_to_addr(src_region_idx);
2790     if (src_region_addr &gt; closure.source()) {
2791       closure.set_source(src_region_addr);
2792     }
2793     return src_region_idx;
2794   }
2795 
2796   // Switch to a new source space and find the first non-empty region.
2797   unsigned int space_id = src_space_id + 1;
2798   assert(space_id &lt; last_space_id, &quot;not enough spaces&quot;);
2799 
2800   HeapWord* const destination = closure.destination();
2801 
2802   do {
2803     MutableSpace* space = _space_info[space_id].space();
2804     HeapWord* const bottom = space-&gt;bottom();
2805     const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);
2806 
2807     // Iterate over the spaces that do not compact into themselves.
2808     if (bottom_cp-&gt;destination() != bottom) {
2809       HeapWord* const top_aligned_up = sd.region_align_up(space-&gt;top());
2810       const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);
2811 
2812       for (const RegionData* src_cp = bottom_cp; src_cp &lt; top_cp; ++src_cp) {
2813         if (src_cp-&gt;live_obj_size() &gt; 0) {
2814           // Found it.
2815           assert(src_cp-&gt;destination() == destination,
2816                  &quot;first live obj in the space must match the destination&quot;);
2817           assert(src_cp-&gt;partial_obj_size() == 0,
2818                  &quot;a space cannot begin with a partial obj&quot;);
2819 
2820           src_space_id = SpaceId(space_id);
2821           src_space_top = space-&gt;top();
2822           const size_t src_region_idx = sd.region(src_cp);
2823           closure.set_source(sd.region_to_addr(src_region_idx));
2824           return src_region_idx;
2825         } else {
2826           assert(src_cp-&gt;data_size() == 0, &quot;sanity&quot;);
2827         }
2828       }
2829     }
2830   } while (++space_id &lt; last_space_id);
2831 
2832   assert(false, &quot;no source region was found&quot;);
2833   return 0;
2834 }
2835 
<a name="55" id="anc55"></a><span class="line-modified">2836 void PSParallelCompact::fill_region(ParCompactionManager* cm, size_t region_idx)</span>
2837 {
2838   typedef ParMarkBitMap::IterationStatus IterationStatus;
<a name="56" id="anc56"></a><span class="line-removed">2839   const size_t RegionSize = ParallelCompactData::RegionSize;</span>
2840   ParMarkBitMap* const bitmap = mark_bitmap();
2841   ParallelCompactData&amp; sd = summary_data();
2842   RegionData* const region_ptr = sd.region(region_idx);
2843 
<a name="57" id="anc57"></a><span class="line-removed">2844   // Get the items needed to construct the closure.</span>
<span class="line-removed">2845   HeapWord* dest_addr = sd.region_to_addr(region_idx);</span>
<span class="line-removed">2846   SpaceId dest_space_id = space_id(dest_addr);</span>
<span class="line-removed">2847   ObjectStartArray* start_array = _space_info[dest_space_id].start_array();</span>
<span class="line-removed">2848   HeapWord* new_top = _space_info[dest_space_id].new_top();</span>
<span class="line-removed">2849   assert(dest_addr &lt; new_top, &quot;sanity&quot;);</span>
<span class="line-removed">2850   const size_t words = MIN2(pointer_delta(new_top, dest_addr), RegionSize);</span>
<span class="line-removed">2851 </span>
2852   // Get the source region and related info.
2853   size_t src_region_idx = region_ptr-&gt;source_region();
2854   SpaceId src_space_id = space_id(sd.region_to_addr(src_region_idx));
2855   HeapWord* src_space_top = _space_info[src_space_id].space()-&gt;top();
<a name="58" id="anc58"></a>
2856 
<a name="59" id="anc59"></a><span class="line-removed">2857   MoveAndUpdateClosure closure(bitmap, cm, start_array, dest_addr, words);</span>
2858   closure.set_source(first_src_addr(dest_addr, src_space_id, src_region_idx));
2859 
2860   // Adjust src_region_idx to prepare for decrementing destination counts (the
2861   // destination count is not decremented when a region is copied to itself).
2862   if (src_region_idx == region_idx) {
2863     src_region_idx += 1;
2864   }
2865 
2866   if (bitmap-&gt;is_unmarked(closure.source())) {
2867     // The first source word is in the middle of an object; copy the remainder
2868     // of the object or as much as will fit.  The fact that pointer updates were
2869     // deferred will be noted when the object header is processed.
2870     HeapWord* const old_src_addr = closure.source();
2871     closure.copy_partial_obj();
2872     if (closure.is_full()) {
2873       decrement_destination_counts(cm, src_space_id, src_region_idx,
2874                                    closure.source());
2875       region_ptr-&gt;set_deferred_obj_addr(NULL);
<a name="60" id="anc60"></a><span class="line-modified">2876       region_ptr-&gt;set_completed();</span>
2877       return;
2878     }
2879 
2880     HeapWord* const end_addr = sd.region_align_down(closure.source());
2881     if (sd.region_align_down(old_src_addr) != end_addr) {
2882       // The partial object was copied from more than one source region.
2883       decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
2884 
2885       // Move to the next source region, possibly switching spaces as well.  All
2886       // args except end_addr may be modified.
2887       src_region_idx = next_src_region(closure, src_space_id, src_space_top,
2888                                        end_addr);
2889     }
2890   }
2891 
2892   do {
2893     HeapWord* const cur_addr = closure.source();
2894     HeapWord* const end_addr = MIN2(sd.region_align_up(cur_addr + 1),
2895                                     src_space_top);
2896     IterationStatus status = bitmap-&gt;iterate(&amp;closure, cur_addr, end_addr);
2897 
2898     if (status == ParMarkBitMap::incomplete) {
2899       // The last obj that starts in the source region does not end in the
2900       // region.
2901       assert(closure.source() &lt; end_addr, &quot;sanity&quot;);
2902       HeapWord* const obj_beg = closure.source();
2903       HeapWord* const range_end = MIN2(obj_beg + closure.words_remaining(),
2904                                        src_space_top);
2905       HeapWord* const obj_end = bitmap-&gt;find_obj_end(obj_beg, range_end);
2906       if (obj_end &lt; range_end) {
2907         // The end was found; the entire object will fit.
2908         status = closure.do_addr(obj_beg, bitmap-&gt;obj_size(obj_beg, obj_end));
2909         assert(status != ParMarkBitMap::would_overflow, &quot;sanity&quot;);
2910       } else {
2911         // The end was not found; the object will not fit.
2912         assert(range_end &lt; src_space_top, &quot;obj cannot cross space boundary&quot;);
2913         status = ParMarkBitMap::would_overflow;
2914       }
2915     }
2916 
2917     if (status == ParMarkBitMap::would_overflow) {
2918       // The last object did not fit.  Note that interior oop updates were
2919       // deferred, then copy enough of the object to fill the region.
2920       region_ptr-&gt;set_deferred_obj_addr(closure.destination());
2921       status = closure.copy_until_full(); // copies from closure.source()
2922 
2923       decrement_destination_counts(cm, src_space_id, src_region_idx,
2924                                    closure.source());
<a name="61" id="anc61"></a><span class="line-modified">2925       region_ptr-&gt;set_completed();</span>
2926       return;
2927     }
2928 
2929     if (status == ParMarkBitMap::full) {
2930       decrement_destination_counts(cm, src_space_id, src_region_idx,
2931                                    closure.source());
2932       region_ptr-&gt;set_deferred_obj_addr(NULL);
<a name="62" id="anc62"></a><span class="line-modified">2933       region_ptr-&gt;set_completed();</span>
2934       return;
2935     }
2936 
2937     decrement_destination_counts(cm, src_space_id, src_region_idx, end_addr);
2938 
2939     // Move to the next source region, possibly switching spaces as well.  All
2940     // args except end_addr may be modified.
2941     src_region_idx = next_src_region(closure, src_space_id, src_space_top,
2942                                      end_addr);
2943   } while (true);
2944 }
2945 
<a name="63" id="anc63"></a>

























































































2946 void PSParallelCompact::fill_blocks(size_t region_idx)
2947 {
2948   // Fill in the block table elements for the specified region.  Each block
2949   // table element holds the number of live words in the region that are to the
2950   // left of the first object that starts in the block.  Thus only blocks in
2951   // which an object starts need to be filled.
2952   //
2953   // The algorithm scans the section of the bitmap that corresponds to the
2954   // region, keeping a running total of the live words.  When an object start is
2955   // found, if it&#39;s the first to start in the block that contains it, the
2956   // current total is written to the block table element.
2957   const size_t Log2BlockSize = ParallelCompactData::Log2BlockSize;
2958   const size_t Log2RegionSize = ParallelCompactData::Log2RegionSize;
2959   const size_t RegionSize = ParallelCompactData::RegionSize;
2960 
2961   ParallelCompactData&amp; sd = summary_data();
2962   const size_t partial_obj_size = sd.region(region_idx)-&gt;partial_obj_size();
2963   if (partial_obj_size &gt;= RegionSize) {
2964     return; // No objects start in this region.
2965   }
2966 
2967   // Ensure the first loop iteration decides that the block has changed.
2968   size_t cur_block = sd.block_count();
2969 
2970   const ParMarkBitMap* const bitmap = mark_bitmap();
2971 
2972   const size_t Log2BitsPerBlock = Log2BlockSize - LogMinObjAlignment;
2973   assert((size_t)1 &lt;&lt; Log2BitsPerBlock ==
2974          bitmap-&gt;words_to_bits(ParallelCompactData::BlockSize), &quot;sanity&quot;);
2975 
2976   size_t beg_bit = bitmap-&gt;words_to_bits(region_idx &lt;&lt; Log2RegionSize);
2977   const size_t range_end = beg_bit + bitmap-&gt;words_to_bits(RegionSize);
2978   size_t live_bits = bitmap-&gt;words_to_bits(partial_obj_size);
2979   beg_bit = bitmap-&gt;find_obj_beg(beg_bit + live_bits, range_end);
2980   while (beg_bit &lt; range_end) {
2981     const size_t new_block = beg_bit &gt;&gt; Log2BitsPerBlock;
2982     if (new_block != cur_block) {
2983       cur_block = new_block;
2984       sd.block(cur_block)-&gt;set_offset(bitmap-&gt;bits_to_words(live_bits));
2985     }
2986 
2987     const size_t end_bit = bitmap-&gt;find_obj_end(beg_bit, range_end);
2988     if (end_bit &lt; range_end - 1) {
2989       live_bits += end_bit - beg_bit + 1;
2990       beg_bit = bitmap-&gt;find_obj_beg(end_bit + 1, range_end);
2991     } else {
2992       return;
2993     }
2994   }
2995 }
2996 
<a name="64" id="anc64"></a><span class="line-removed">2997 void</span>
<span class="line-removed">2998 PSParallelCompact::move_and_update(ParCompactionManager* cm, SpaceId space_id) {</span>
<span class="line-removed">2999   const MutableSpace* sp = space(space_id);</span>
<span class="line-removed">3000   if (sp-&gt;is_empty()) {</span>
<span class="line-removed">3001     return;</span>
<span class="line-removed">3002   }</span>
<span class="line-removed">3003 </span>
<span class="line-removed">3004   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();</span>
<span class="line-removed">3005   ParMarkBitMap* const bitmap = mark_bitmap();</span>
<span class="line-removed">3006   HeapWord* const dp_addr = dense_prefix(space_id);</span>
<span class="line-removed">3007   HeapWord* beg_addr = sp-&gt;bottom();</span>
<span class="line-removed">3008   HeapWord* end_addr = sp-&gt;top();</span>
<span class="line-removed">3009 </span>
<span class="line-removed">3010   assert(beg_addr &lt;= dp_addr &amp;&amp; dp_addr &lt;= end_addr, &quot;bad dense prefix&quot;);</span>
<span class="line-removed">3011 </span>
<span class="line-removed">3012   const size_t beg_region = sd.addr_to_region_idx(beg_addr);</span>
<span class="line-removed">3013   const size_t dp_region = sd.addr_to_region_idx(dp_addr);</span>
<span class="line-removed">3014   if (beg_region &lt; dp_region) {</span>
<span class="line-removed">3015     update_and_deadwood_in_dense_prefix(cm, space_id, beg_region, dp_region);</span>
<span class="line-removed">3016   }</span>
<span class="line-removed">3017 </span>
<span class="line-removed">3018   // The destination of the first live object that starts in the region is one</span>
<span class="line-removed">3019   // past the end of the partial object entering the region (if any).</span>
<span class="line-removed">3020   HeapWord* const dest_addr = sd.partial_obj_end(dp_region);</span>
<span class="line-removed">3021   HeapWord* const new_top = _space_info[space_id].new_top();</span>
<span class="line-removed">3022   assert(new_top &gt;= dest_addr, &quot;bad new_top value&quot;);</span>
<span class="line-removed">3023   const size_t words = pointer_delta(new_top, dest_addr);</span>
<span class="line-removed">3024 </span>
<span class="line-removed">3025   if (words &gt; 0) {</span>
<span class="line-removed">3026     ObjectStartArray* start_array = _space_info[space_id].start_array();</span>
<span class="line-removed">3027     MoveAndUpdateClosure closure(bitmap, cm, start_array, dest_addr, words);</span>
<span class="line-removed">3028 </span>
<span class="line-removed">3029     ParMarkBitMap::IterationStatus status;</span>
<span class="line-removed">3030     status = bitmap-&gt;iterate(&amp;closure, dest_addr, end_addr);</span>
<span class="line-removed">3031     assert(status == ParMarkBitMap::full, &quot;iteration not complete&quot;);</span>
<span class="line-removed">3032     assert(bitmap-&gt;find_obj_beg(closure.source(), end_addr) == end_addr,</span>
<span class="line-removed">3033            &quot;live objects skipped because closure is full&quot;);</span>
<span class="line-removed">3034   }</span>
<span class="line-removed">3035 }</span>
<span class="line-removed">3036 </span>
3037 jlong PSParallelCompact::millis_since_last_gc() {
3038   // We need a monotonically non-decreasing time in ms but
3039   // os::javaTimeMillis() does not guarantee monotonicity.
3040   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3041   jlong ret_val = now - _time_of_last_gc;
3042   // XXX See note in genCollectedHeap::millis_since_last_gc().
3043   if (ret_val &lt; 0) {
3044     NOT_PRODUCT(log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT, ret_val);)
3045     return 0;
3046   }
3047   return ret_val;
3048 }
3049 
3050 void PSParallelCompact::reset_millis_since_last_gc() {
3051   // We need a monotonically non-decreasing time in ms but
3052   // os::javaTimeMillis() does not guarantee monotonicity.
3053   _time_of_last_gc = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
3054 }
3055 
3056 ParMarkBitMap::IterationStatus MoveAndUpdateClosure::copy_until_full()
3057 {
<a name="65" id="anc65"></a><span class="line-modified">3058   if (source() != destination()) {</span>
3059     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<a name="66" id="anc66"></a><span class="line-modified">3060     Copy::aligned_conjoint_words(source(), destination(), words_remaining());</span>
3061   }
3062   update_state(words_remaining());
3063   assert(is_full(), &quot;sanity&quot;);
3064   return ParMarkBitMap::full;
3065 }
3066 
3067 void MoveAndUpdateClosure::copy_partial_obj()
3068 {
3069   size_t words = words_remaining();
3070 
3071   HeapWord* const range_end = MIN2(source() + words, bitmap()-&gt;region_end());
3072   HeapWord* const end_addr = bitmap()-&gt;find_obj_end(source(), range_end);
3073   if (end_addr &lt; range_end) {
3074     words = bitmap()-&gt;obj_size(source(), end_addr);
3075   }
3076 
3077   // This test is necessary; if omitted, the pointer updates to a partial object
3078   // that crosses the dense prefix boundary could be overwritten.
<a name="67" id="anc67"></a><span class="line-modified">3079   if (source() != destination()) {</span>
3080     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<a name="68" id="anc68"></a><span class="line-modified">3081     Copy::aligned_conjoint_words(source(), destination(), words);</span>
3082   }
3083   update_state(words);
3084 }
3085 
<a name="69" id="anc69"></a>





3086 ParMarkBitMapClosure::IterationStatus
3087 MoveAndUpdateClosure::do_addr(HeapWord* addr, size_t words) {
3088   assert(destination() != NULL, &quot;sanity&quot;);
3089   assert(bitmap()-&gt;obj_size(addr) == words, &quot;bad size&quot;);
3090 
3091   _source = addr;
3092   assert(PSParallelCompact::summary_data().calc_new_pointer(source(), compaction_manager()) ==
3093          destination(), &quot;wrong destination&quot;);
3094 
3095   if (words &gt; words_remaining()) {
3096     return ParMarkBitMap::would_overflow;
3097   }
3098 
3099   // The start_array must be updated even if the object is not moving.
3100   if (_start_array != NULL) {
3101     _start_array-&gt;allocate_block(destination());
3102   }
3103 
<a name="70" id="anc70"></a><span class="line-modified">3104   if (destination() != source()) {</span>
3105     DEBUG_ONLY(PSParallelCompact::check_new_location(source(), destination());)
<a name="71" id="anc71"></a><span class="line-modified">3106     Copy::aligned_conjoint_words(source(), destination(), words);</span>
3107   }
3108 
<a name="72" id="anc72"></a><span class="line-modified">3109   oop moved_oop = (oop) destination();</span>
3110   compaction_manager()-&gt;update_contents(moved_oop);
3111   assert(oopDesc::is_oop_or_null(moved_oop), &quot;Expected an oop or NULL at &quot; PTR_FORMAT, p2i(moved_oop));
3112 
3113   update_state(words);
<a name="73" id="anc73"></a><span class="line-modified">3114   assert(destination() == (HeapWord*)moved_oop + moved_oop-&gt;size(), &quot;sanity&quot;);</span>
3115   return is_full() ? ParMarkBitMap::full : ParMarkBitMap::incomplete;
3116 }
3117 
<a name="74" id="anc74"></a>


















3118 UpdateOnlyClosure::UpdateOnlyClosure(ParMarkBitMap* mbm,
3119                                      ParCompactionManager* cm,
3120                                      PSParallelCompact::SpaceId space_id) :
3121   ParMarkBitMapClosure(mbm, cm),
3122   _space_id(space_id),
3123   _start_array(PSParallelCompact::start_array(space_id))
3124 {
3125 }
3126 
3127 // Updates the references in the object to their new values.
3128 ParMarkBitMapClosure::IterationStatus
3129 UpdateOnlyClosure::do_addr(HeapWord* addr, size_t words) {
3130   do_addr(addr);
3131   return ParMarkBitMap::incomplete;
3132 }
3133 
3134 FillClosure::FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id) :
3135   ParMarkBitMapClosure(PSParallelCompact::mark_bitmap(), cm),
3136   _start_array(PSParallelCompact::start_array(space_id))
3137 {
3138   assert(space_id == PSParallelCompact::old_space_id,
3139          &quot;cannot use FillClosure in the young gen&quot;);
3140 }
3141 
3142 ParMarkBitMapClosure::IterationStatus
3143 FillClosure::do_addr(HeapWord* addr, size_t size) {
3144   CollectedHeap::fill_with_objects(addr, size);
3145   HeapWord* const end = addr + size;
3146   do {
3147     _start_array-&gt;allocate_block(addr);
3148     addr += oop(addr)-&gt;size();
3149   } while (addr &lt; end);
3150   return ParMarkBitMap::incomplete;
3151 }
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>
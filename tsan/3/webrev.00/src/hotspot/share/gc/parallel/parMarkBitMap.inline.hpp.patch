diff a/src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp b/src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp
--- a/src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp
+++ b/src/hotspot/share/gc/parallel/parMarkBitMap.inline.hpp
@@ -24,10 +24,11 @@
 
 #ifndef SHARE_GC_PARALLEL_PARMARKBITMAP_INLINE_HPP
 #define SHARE_GC_PARALLEL_PARMARKBITMAP_INLINE_HPP
 
 #include "gc/parallel/parMarkBitMap.hpp"
+#include "utilities/align.hpp"
 #include "utilities/bitMap.inline.hpp"
 
 inline ParMarkBitMap::ParMarkBitMap():
   _region_start(NULL), _region_size(0), _beg_bits(), _end_bits(), _virtual_space(NULL), _reserved_byte_size(0)
 { }
@@ -78,11 +79,11 @@
 inline bool ParMarkBitMap::is_marked(HeapWord* addr) const {
   return is_marked(addr_to_bit(addr));
 }
 
 inline bool ParMarkBitMap::is_marked(oop obj) const {
-  return is_marked((HeapWord*)obj);
+  return is_marked(cast_from_oop<HeapWord*>(obj));
 }
 
 inline bool ParMarkBitMap::is_unmarked(idx_t bit) const {
   return !is_marked(bit);
 }
@@ -141,23 +142,29 @@
                  addr_to_bit(range_beg), addr_to_bit(range_end),
                  addr_to_bit(dead_range_end));
 }
 
 inline bool ParMarkBitMap::mark_obj(oop obj, int size) {
-  return mark_obj((HeapWord*)obj, (size_t)size);
+  return mark_obj(cast_from_oop<HeapWord*>(obj), (size_t)size);
 }
 
-inline BitMap::idx_t ParMarkBitMap::addr_to_bit(HeapWord* addr) const {
+inline ParMarkBitMap::idx_t ParMarkBitMap::addr_to_bit(HeapWord* addr) const {
   DEBUG_ONLY(verify_addr(addr);)
   return words_to_bits(pointer_delta(addr, region_start()));
 }
 
 inline HeapWord* ParMarkBitMap::bit_to_addr(idx_t bit) const {
   DEBUG_ONLY(verify_bit(bit);)
   return region_start() + bits_to_words(bit);
 }
 
+inline ParMarkBitMap::idx_t ParMarkBitMap::align_range_end(idx_t range_end) const {
+  // size is aligned, so if range_end <= size then so is aligned result.
+  assert(range_end <= size(), "range end out of range");
+  return align_up(range_end, BitsPerWord);
+}
+
 inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_beg(idx_t beg, idx_t end) const {
   return _beg_bits.get_next_one_offset_aligned_right(beg, end);
 }
 
 inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_end(idx_t beg, idx_t end) const {
@@ -165,19 +172,19 @@
 }
 
 inline HeapWord* ParMarkBitMap::find_obj_beg(HeapWord* beg, HeapWord* end) const {
   const idx_t beg_bit = addr_to_bit(beg);
   const idx_t end_bit = addr_to_bit(end);
-  const idx_t search_end = BitMap::word_align_up(end_bit);
+  const idx_t search_end = align_range_end(end_bit);
   const idx_t res_bit = MIN2(find_obj_beg(beg_bit, search_end), end_bit);
   return bit_to_addr(res_bit);
 }
 
 inline HeapWord* ParMarkBitMap::find_obj_end(HeapWord* beg, HeapWord* end) const {
   const idx_t beg_bit = addr_to_bit(beg);
   const idx_t end_bit = addr_to_bit(end);
-  const idx_t search_end = BitMap::word_align_up(end_bit);
+  const idx_t search_end = align_range_end(end_bit);
   const idx_t res_bit = MIN2(find_obj_end(beg_bit, search_end), end_bit);
   return bit_to_addr(res_bit);
 }
 
 #ifdef  ASSERT

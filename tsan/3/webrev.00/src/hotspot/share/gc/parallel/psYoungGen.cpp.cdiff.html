<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psVirtualspace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psYoungGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,26 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="line-removed">- #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
  #include &quot;gc/parallel/psScavenge.hpp&quot;
  #include &quot;gc/parallel/psYoungGen.hpp&quot;
  #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
<span class="line-modified">! PSYoungGen::PSYoungGen(size_t        initial_size,</span>
<span class="line-modified">!                        size_t        min_size,</span>
<span class="line-modified">!                        size_t        max_size) :</span>
    _init_gen_size(initial_size),
    _min_gen_size(min_size),
<span class="line-modified">!   _max_gen_size(max_size)</span>
  {}
  
  void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
    assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
    _virtual_space = new PSVirtualSpace(rs, alignment);
<span class="line-new-header">--- 23,33 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  #include &quot;gc/parallel/psScavenge.hpp&quot;
  #include &quot;gc/parallel/psYoungGen.hpp&quot;
  #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
<span class="line-modified">! PSYoungGen::PSYoungGen(size_t initial_size, size_t min_size, size_t max_size) :</span>
<span class="line-modified">!   _reserved(),</span>
<span class="line-modified">!   _virtual_space(NULL),</span>
<span class="line-added">+   _eden_space(NULL),</span>
<span class="line-added">+   _from_space(NULL),</span>
<span class="line-added">+   _to_space(NULL),</span>
    _init_gen_size(initial_size),
    _min_gen_size(min_size),
<span class="line-modified">!   _max_gen_size(max_size),</span>
<span class="line-added">+   _gen_counters(NULL),</span>
<span class="line-added">+   _eden_counters(NULL),</span>
<span class="line-added">+   _from_counters(NULL),</span>
<span class="line-added">+   _to_counters(NULL)</span>
  {}
  
  void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
    assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
    _virtual_space = new PSVirtualSpace(rs, alignment);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,36 ***</span>
      _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
    }
    _from_space = new MutableSpace(virtual_space()-&gt;alignment());
    _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
  
<span class="line-removed">-   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not allocate a young gen space&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Allocate the mark sweep views of spaces</span>
<span class="line-removed">-   _eden_mark_sweep =</span>
<span class="line-removed">-       new PSMarkSweepDecorator(_eden_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed">-   _from_mark_sweep =</span>
<span class="line-removed">-       new PSMarkSweepDecorator(_from_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed">-   _to_mark_sweep =</span>
<span class="line-removed">-       new PSMarkSweepDecorator(_to_space, NULL, MarkSweepDeadRatio);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (_eden_mark_sweep == NULL ||</span>
<span class="line-removed">-       _from_mark_sweep == NULL ||</span>
<span class="line-removed">-       _to_mark_sweep == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not complete allocation&quot;</span>
<span class="line-removed">-                                   &quot; of the young generation&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // Generation Counters - generation 0, 3 subspaces
    _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
                                             _max_gen_size, _virtual_space);
  
    // Compute maximum space sizes for performance counters
<span class="line-modified">!   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">-   size_t alignment = heap-&gt;space_alignment();</span>
    size_t size = virtual_space()-&gt;reserved_size();
  
    size_t max_survivor_size;
    size_t max_eden_size;
  
<span class="line-new-header">--- 86,16 ---</span>
      _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
    }
    _from_space = new MutableSpace(virtual_space()-&gt;alignment());
    _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
  
    // Generation Counters - generation 0, 3 subspaces
    _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
                                             _max_gen_size, _virtual_space);
  
    // Compute maximum space sizes for performance counters
<span class="line-modified">!   size_t alignment = SpaceAlignment;</span>
    size_t size = virtual_space()-&gt;reserved_size();
  
    size_t max_survivor_size;
    size_t max_eden_size;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,21 ***</span>
  
    compute_initial_space_boundaries();
  }
  
  void PSYoungGen::compute_initial_space_boundaries() {
<span class="line-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">- </span>
    // Compute sizes
<span class="line-removed">-   size_t alignment = heap-&gt;space_alignment();</span>
    size_t size = virtual_space()-&gt;committed_size();
<span class="line-modified">!   assert(size &gt;= 3 * alignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);</span>
  
    size_t survivor_size = size / InitialSurvivorRatio;
<span class="line-modified">!   survivor_size = align_down(survivor_size, alignment);</span>
    // ... but never less than an alignment
<span class="line-modified">!   survivor_size = MAX2(survivor_size, alignment);</span>
  
    // Young generation is eden + 2 survivor spaces
    size_t eden_size = size - (2 * survivor_size);
  
    // Now go ahead and set &#39;em.
<span class="line-new-header">--- 140,18 ---</span>
  
    compute_initial_space_boundaries();
  }
  
  void PSYoungGen::compute_initial_space_boundaries() {
    // Compute sizes
    size_t size = virtual_space()-&gt;committed_size();
<span class="line-modified">!   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);</span>
  
    size_t survivor_size = size / InitialSurvivorRatio;
<span class="line-modified">!   survivor_size = align_down(survivor_size, SpaceAlignment);</span>
    // ... but never less than an alignment
<span class="line-modified">!   survivor_size = MAX2(survivor_size, SpaceAlignment);</span>
  
    // Young generation is eden + 2 survivor spaces
    size_t eden_size = size - (2 * survivor_size);
  
    // Now go ahead and set &#39;em.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,17 ***</span>
    from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
  }
  
  #ifndef PRODUCT
  void PSYoungGen::space_invariants() {
<span class="line-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">-   const size_t alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">- </span>
    // Currently, our eden size cannot shrink to zero
<span class="line-modified">!   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;eden too small&quot;);</span>
<span class="line-modified">!   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;from too small&quot;);</span>
<span class="line-modified">!   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= alignment, &quot;to too small&quot;);</span>
  
    // Relationship of spaces to each other
    char* eden_start = (char*)eden_space()-&gt;bottom();
    char* eden_end   = (char*)eden_space()-&gt;end();
    char* from_start = (char*)from_space()-&gt;bottom();
<span class="line-new-header">--- 191,14 ---</span>
    from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
  }
  
  #ifndef PRODUCT
  void PSYoungGen::space_invariants() {
    // Currently, our eden size cannot shrink to zero
<span class="line-modified">!   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);</span>
<span class="line-modified">!   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);</span>
<span class="line-modified">!   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);</span>
  
    // Relationship of spaces to each other
    char* eden_start = (char*)eden_space()-&gt;bottom();
    char* eden_end   = (char*)eden_space()-&gt;end();
    char* from_start = (char*)from_space()-&gt;bottom();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,12 ***</span>
    assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
  
    // Adjust new generation size
    const size_t eden_plus_survivors =
            align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">!   size_t desired_size = MAX2(MIN2(eden_plus_survivors, max_size()),</span>
<span class="line-removed">-                              min_gen_size());</span>
    assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
  
    if (desired_size &gt; orig_size) {
      // Grow the generation
      size_t change = desired_size - orig_size;
<span class="line-new-header">--- 275,11 ---</span>
    assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
  
    // Adjust new generation size
    const size_t eden_plus_survivors =
            align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">!   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());</span>
    assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
  
    if (desired_size &gt; orig_size) {
      // Grow the generation
      size_t change = desired_size - orig_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,12 ***</span>
    char* from_start = (char*)from_space()-&gt;bottom();
    char* from_end   = (char*)from_space()-&gt;end();
    char* to_start   = (char*)to_space()-&gt;bottom();
    char* to_end     = (char*)to_space()-&gt;end();
  
<span class="line-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">-   const size_t alignment = heap-&gt;space_alignment();</span>
    const bool maintain_minimum =
      (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
  
    bool eden_from_to_order = from_start &lt; to_start;
    // Check whether from space is below to space
<span class="line-new-header">--- 450,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,13 ***</span>
        // Calculate the minimum offset possible for from_end
        size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
  
        // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
        if (from_size == 0) {
<span class="line-modified">!         from_size = alignment;</span>
        } else {
<span class="line-modified">!         from_size = align_up(from_size, alignment);</span>
        }
  
        from_end = from_start + from_size;
        assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
  
<span class="line-new-header">--- 503,13 ---</span>
        // Calculate the minimum offset possible for from_end
        size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
  
        // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
        if (from_size == 0) {
<span class="line-modified">!         from_size = SpaceAlignment;</span>
        } else {
<span class="line-modified">!         from_size = align_up(from_size, SpaceAlignment);</span>
        }
  
        from_end = from_start + from_size;
        assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,11 ***</span>
      to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
                                      sizeof(char));
      // if the space sizes are to be increased by several times then
      // &#39;to_start&#39; will point beyond the young generation. In this case
      // &#39;to_start&#39; should be adjusted.
<span class="line-modified">!     to_start = MAX2(to_start, eden_start + alignment);</span>
  
      // Compute how big eden can be, then adjust end.
      // See  comments above on calculating eden_end.
      size_t eden_size;
      if (maintain_minimum) {
<span class="line-new-header">--- 548,11 ---</span>
      to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
                                      sizeof(char));
      // if the space sizes are to be increased by several times then
      // &#39;to_start&#39; will point beyond the young generation. In this case
      // &#39;to_start&#39; should be adjusted.
<span class="line-modified">!     to_start = MAX2(to_start, eden_start + SpaceAlignment);</span>
  
      // Compute how big eden can be, then adjust end.
      // See  comments above on calculating eden_end.
      size_t eden_size;
      if (maintain_minimum) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,11 ***</span>
  
      // Could choose to not let eden shrink
      // to_start = MAX2(to_start, eden_end);
  
      // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">!     eden_end = MAX2(eden_end, eden_start + alignment);</span>
      to_start = MAX2(to_start, eden_end);
  
      log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
                          p2i(eden_start),
                          p2i(eden_end),
<span class="line-new-header">--- 566,11 ---</span>
  
      // Could choose to not let eden shrink
      // to_start = MAX2(to_start, eden_end);
  
      // Don&#39;t let eden shrink down to 0 or less.
<span class="line-modified">!     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);</span>
      to_start = MAX2(to_start, eden_end);
  
      log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
                          p2i(eden_start),
                          p2i(eden_end),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,18 ***</span>
  
  void PSYoungGen::swap_spaces() {
    MutableSpace* s    = from_space();
    _from_space        = to_space();
    _to_space          = s;
<span class="line-removed">- </span>
<span class="line-removed">-   // Now update the decorators.</span>
<span class="line-removed">-   PSMarkSweepDecorator* md = from_mark_sweep();</span>
<span class="line-removed">-   _from_mark_sweep           = to_mark_sweep();</span>
<span class="line-removed">-   _to_mark_sweep             = md;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(from_mark_sweep()-&gt;space() == from_space(), &quot;Sanity&quot;);</span>
<span class="line-removed">-   assert(to_mark_sweep()-&gt;space() == to_space(), &quot;Sanity&quot;);</span>
  }
  
  size_t PSYoungGen::capacity_in_bytes() const {
    return eden_space()-&gt;capacity_in_bytes()
         + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
<span class="line-new-header">--- 656,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,33 ***</span>
    eden_space()-&gt;object_iterate(blk);
    from_space()-&gt;object_iterate(blk);
    to_space()-&gt;object_iterate(blk);
  }
  
<span class="line-removed">- #if INCLUDE_SERIALGC</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PSYoungGen::precompact() {</span>
<span class="line-removed">-   eden_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">-   from_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">-   to_mark_sweep()-&gt;precompact();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PSYoungGen::adjust_pointers() {</span>
<span class="line-removed">-   eden_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">-   from_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">-   to_mark_sweep()-&gt;adjust_pointers();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PSYoungGen::compact() {</span>
<span class="line-removed">-   eden_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">-   from_mark_sweep()-&gt;compact(ZapUnusedHeapArea);</span>
<span class="line-removed">-   // Mark sweep stores preserved markOops in to space, don&#39;t disturb!</span>
<span class="line-removed">-   to_mark_sweep()-&gt;compact(false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif // INCLUDE_SERIALGC</span>
<span class="line-removed">- </span>
  void PSYoungGen::print() const { print_on(tty); }
  void PSYoungGen::print_on(outputStream* st) const {
    st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
    st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
               capacity_in_bytes()/K, used_in_bytes()/K);
<span class="line-new-header">--- 698,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,16 ***</span>
    st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
    st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
    st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
  }
  
<span class="line-removed">- // Note that a space is not printed before the [NAME:</span>
<span class="line-removed">- void PSYoungGen::print_used_change(size_t prev_used) const {</span>
<span class="line-removed">-   log_info(gc, heap)(&quot;%s: &quot;  SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-removed">-       name(), prev_used / K, used_in_bytes() / K, capacity_in_bytes() / K);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  size_t PSYoungGen::available_for_expansion() {
    ShouldNotReachHere();
    return 0;
  }
  
<span class="line-new-header">--- 709,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,14 ***</span>
  // This method assumes that from-space has live data and that
  // any shrinkage of the young gen is limited by location of
  // from-space.
  size_t PSYoungGen::available_to_live() {
    size_t delta_in_survivor = 0;
<span class="line-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="line-removed">-   const size_t space_alignment = heap-&gt;space_alignment();</span>
<span class="line-removed">-   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
<span class="line-removed">- </span>
    MutableSpace* space_shrinking = NULL;
    if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
      space_shrinking = from_space();
    } else {
      space_shrinking = to_space();
<span class="line-new-header">--- 729,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 808,21 ***</span>
    size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
      space_shrinking-&gt;end(), sizeof(char));
  
    if (space_shrinking-&gt;is_empty()) {
      // Don&#39;t let the space shrink to 0
<span class="line-modified">!     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= space_alignment,</span>
        &quot;Space is too small&quot;);
<span class="line-modified">!     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - space_alignment;</span>
    } else {
      delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
                                        space_shrinking-&gt;top(),
                                        sizeof(char));
    }
  
    size_t delta_in_bytes = unused_committed + delta_in_survivor;
<span class="line-modified">!   delta_in_bytes = align_down(delta_in_bytes, gen_alignment);</span>
    return delta_in_bytes;
  }
  
  // Return the number of bytes available for resizing down the young
  // generation.  This is the minimum of
<span class="line-new-header">--- 745,21 ---</span>
    size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
      space_shrinking-&gt;end(), sizeof(char));
  
    if (space_shrinking-&gt;is_empty()) {
      // Don&#39;t let the space shrink to 0
<span class="line-modified">!     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,</span>
        &quot;Space is too small&quot;);
<span class="line-modified">!     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;</span>
    } else {
      delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
                                        space_shrinking-&gt;top(),
                                        sizeof(char));
    }
  
    size_t delta_in_bytes = unused_committed + delta_in_survivor;
<span class="line-modified">!   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);</span>
    return delta_in_bytes;
  }
  
  // Return the number of bytes available for resizing down the young
  // generation.  This is the minimum of
</pre>
<center><a href="psVirtualspace.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/parallel/psPromotionManager.hpp b/src/hotspot/share/gc/parallel/psPromotionManager.hpp
--- a/src/hotspot/share/gc/parallel/psPromotionManager.hpp
+++ b/src/hotspot/share/gc/parallel/psPromotionManager.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -49,12 +49,18 @@
 class PSOldGen;
 class ParCompactionManager;
 
 class PSPromotionManager {
   friend class PSScavenge;
+  friend class ScavengeRootsTask;
   friend class PSRefProcTaskExecutor;
+  friend class PSRefProcTask;
+
  private:
+  typedef OverflowTaskQueue<StarTask, mtGC>           OopStarTaskQueue;
+  typedef GenericTaskQueueSet<OopStarTaskQueue, mtGC> OopStarTaskQueueSet;
+
   static PaddedEnd<PSPromotionManager>* _manager_array;
   static OopStarTaskQueueSet*           _stack_array_depth;
   static PreservedMarksSet*             _preserved_marks_set;
   static PSOldGen*                      _old_gen;
   static MutableSpace*                  _young_space;
@@ -97,12 +103,11 @@
 
   // On the task queues we push reference locations as well as
   // partially-scanned arrays (in the latter case, we push an oop to
   // the from-space image of the array and the length on the
   // from-space image indicates how many entries on the array we still
-  // need to scan; this is basically how ParNew does partial array
-  // scanning too). To be able to distinguish between reference
+  // need to scan. To be able to distinguish between reference
   // locations and partially-scanned array oops we simply mask the
   // latter oops with 0x01. The next three methods do the masking,
   // unmasking, and checking whether the oop is masked or not. Notice
   // that the signature of the mask and unmask methods looks a bit
   // strange, as they accept and return different types (oop and
@@ -120,22 +125,22 @@
     return (((intptr_t)(oop*)p) & PS_CHUNKED_ARRAY_OOP_MASK) ==
                                   PS_CHUNKED_ARRAY_OOP_MASK;
   }
 
   oop* mask_chunked_array_oop(oop obj) {
-    assert(!is_oop_masked((oop*) obj), "invariant");
+    assert(!is_oop_masked(cast_from_oop<oop*>(obj)), "invariant");
     oop* ret = (oop*) (cast_from_oop<uintptr_t>(obj) | PS_CHUNKED_ARRAY_OOP_MASK);
     assert(is_oop_masked(ret), "invariant");
     return ret;
   }
 
   oop unmask_chunked_array_oop(StarTask p) {
     assert(is_oop_masked(p), "invariant");
     assert(!p.is_narrow(), "chunked array oops cannot be narrow");
     oop *chunk = (oop*)p;  // cast p to oop (uses conversion operator)
     oop ret = oop((oop*)((uintptr_t)chunk & ~PS_CHUNKED_ARRAY_OOP_MASK));
-    assert(!is_oop_masked((oop*) ret), "invariant");
+    assert(!is_oop_masked(cast_from_oop<oop*>(ret)), "invariant");
     return ret;
   }
 
   template <class T> void  process_array_chunk_work(oop obj,
                                                     int start, int end);
@@ -173,11 +178,11 @@
   bool old_gen_is_full()               { return _old_gen_is_full; }
   void set_old_gen_is_full(bool state) { _old_gen_is_full = state; }
 
   // Promotion methods
   template<bool promote_immediately> oop copy_to_survivor_space(oop o);
-  oop oop_promotion_failed(oop obj, markOop obj_mark);
+  oop oop_promotion_failed(oop obj, markWord obj_mark);
 
   void reset();
   void register_preserved_marks(PreservedMarks* preserved_marks);
   static void restore_preserved_marks();
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/parallel/asPSYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="asPSOldGen.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsParallel.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/asPSYoungGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,15 +23,15 @@</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/parallel/asPSYoungGen.hpp&quot;
  #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
  #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
  #include &quot;gc/parallel/psYoungGen.hpp&quot;
  #include &quot;gc/shared/gcUtil.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  
  ASPSYoungGen::ASPSYoungGen(size_t init_byte_size,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58,12 +58,11 @@</span>
  void ASPSYoungGen::initialize_virtual_space(ReservedSpace rs,
                                              size_t alignment) {
    assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
    _virtual_space = new PSVirtualSpaceHighToLow(rs, alignment);
    if (!_virtual_space-&gt;expand_by(_init_gen_size)) {
<span class="udiff-line-modified-removed">-     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;</span>
<span class="udiff-line-removed">-                                   &quot;object heap&quot;);</span>
<span class="udiff-line-modified-added">+     vm_exit_during_initialization(&quot;Could not reserve enough space for object heap&quot;);</span>
    }
  }
  
  void ASPSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
    initialize_virtual_space(rs, alignment);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,13 +71,13 @@</span>
  
  size_t ASPSYoungGen::available_for_expansion() {
    size_t current_committed_size = virtual_space()-&gt;committed_size();
    assert((gen_size_limit() &gt;= current_committed_size),
      &quot;generation size limit is wrong&quot;);
<span class="udiff-line-modified-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="udiff-line-modified-added">+ </span>
    size_t result =  gen_size_limit() - current_committed_size;
<span class="udiff-line-modified-removed">-   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
<span class="udiff-line-modified-added">+   size_t result_aligned = align_down(result, GenAlignment);</span>
    return result_aligned;
  }
  
  // Return the number of bytes the young gen is willing give up.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,17 +90,16 @@</span>
    }
  
    if (eden_space()-&gt;is_empty()) {
      // Respect the minimum size for eden and for the young gen as a whole.
      ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="udiff-line-modified-removed">-     const size_t eden_alignment = heap-&gt;space_alignment();</span>
<span class="udiff-line-removed">-     const size_t gen_alignment = heap-&gt;generation_alignment();</span>
<span class="udiff-line-modified-added">+     const size_t eden_alignment = SpaceAlignment;</span>
  
      assert(eden_space()-&gt;capacity_in_bytes() &gt;= eden_alignment,
        &quot;Alignment is wrong&quot;);
      size_t eden_avail = eden_space()-&gt;capacity_in_bytes() - eden_alignment;
<span class="udiff-line-modified-removed">-     eden_avail = align_down(eden_avail, gen_alignment);</span>
<span class="udiff-line-modified-added">+     eden_avail = align_down(eden_avail, GenAlignment);</span>
  
      assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(),
        &quot;minimum gen size is wrong&quot;);
      size_t gen_avail = virtual_space()-&gt;committed_size() - min_gen_size();
      assert(virtual_space()-&gt;is_aligned(gen_avail), &quot;not aligned&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,11 +107,11 @@</span>
      const size_t max_contraction = MIN2(eden_avail, gen_avail);
      // See comment for ASPSOldGen::available_for_contraction()
      // for reasons the &quot;increment&quot; fraction is used.
      PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
      size_t result = policy-&gt;eden_increment_aligned_down(max_contraction);
<span class="udiff-line-modified-removed">-     size_t result_aligned = align_down(result, gen_alignment);</span>
<span class="udiff-line-modified-added">+     size_t result_aligned = align_down(result, GenAlignment);</span>
  
      log_trace(gc, ergo)(&quot;ASPSYoungGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K&quot;, result_aligned/K);
      log_trace(gc, ergo)(&quot;  max_contraction &quot; SIZE_FORMAT &quot; K&quot;, max_contraction/K);
      log_trace(gc, ergo)(&quot;  eden_avail &quot; SIZE_FORMAT &quot; K&quot;, eden_avail/K);
      log_trace(gc, ergo)(&quot;  gen_avail &quot; SIZE_FORMAT &quot; K&quot;, gen_avail/K);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,12 +124,11 @@</span>
  
  // The current implementation only considers to the end of eden.
  // If to_space is below from_space, to_space is not considered.
  // to_space can be.
  size_t ASPSYoungGen::available_to_live() {
<span class="udiff-line-modified-removed">-   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
<span class="udiff-line-removed">-   const size_t alignment = heap-&gt;space_alignment();</span>
<span class="udiff-line-modified-added">+   const size_t alignment = SpaceAlignment;</span>
  
    // Include any space that is committed but is not in eden.
    size_t available = pointer_delta(eden_space()-&gt;bottom(),
                                     virtual_space()-&gt;low(),
                                     sizeof(char));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,12 +163,11 @@</span>
           &quot;just checking&quot;);
  
    // Adjust new generation size
    const size_t eden_plus_survivors =
      align_up(eden_size + 2 * survivor_size, alignment);
<span class="udiff-line-modified-removed">-   size_t desired_size = MAX2(MIN2(eden_plus_survivors, gen_size_limit()),</span>
<span class="udiff-line-removed">-                              min_gen_size());</span>
<span class="udiff-line-modified-added">+   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), gen_size_limit());</span>
    assert(desired_size &lt;= gen_size_limit(), &quot;just checking&quot;);
  
    if (desired_size &gt; orig_size) {
      // Grow the generation
      size_t change = desired_size - orig_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,11 +269,10 @@</span>
    char* to_end     = (char*)to_space()-&gt;end();
  
    assert(eden_start &lt; from_start, &quot;Cannot push into from_space&quot;);
  
    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<span class="udiff-line-removed">-   const size_t alignment = heap-&gt;space_alignment();</span>
    const bool maintain_minimum =
      (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
  
    bool eden_from_to_order = from_start &lt; to_start;
    // Check whether from space is below to space
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -329,13 +324,13 @@</span>
        size_t from_size =
          pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
  
        // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
        if (from_size == 0) {
<span class="udiff-line-modified-removed">-         from_size = alignment;</span>
<span class="udiff-line-modified-added">+         from_size = SpaceAlignment;</span>
        } else {
<span class="udiff-line-modified-removed">-         from_size = align_up(from_size, alignment);</span>
<span class="udiff-line-modified-added">+         from_size = align_up(from_size, SpaceAlignment);</span>
        }
  
        from_end = from_start + from_size;
        assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,11 +373,11 @@</span>
      to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
                                      sizeof(char));
      // if the space sizes are to be increased by several times then
      // &#39;to_start&#39; will point beyond the young generation. In this case
      // &#39;to_start&#39; should be adjusted.
<span class="udiff-line-modified-removed">-     to_start = MAX2(to_start, eden_start + alignment);</span>
<span class="udiff-line-modified-added">+     to_start = MAX2(to_start, eden_start + SpaceAlignment);</span>
  
      // Compute how big eden can be, then adjust end.
      // See  comments above on calculating eden_end.
      size_t eden_size;
      if (maintain_minimum) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,11 +388,11 @@</span>
      }
      eden_end = eden_start + eden_size;
      assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
  
      // Don&#39;t let eden shrink down to 0 or less.
<span class="udiff-line-modified-removed">-     eden_end = MAX2(eden_end, eden_start + alignment);</span>
<span class="udiff-line-modified-added">+     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);</span>
      to_start = MAX2(to_start, eden_end);
  
      log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): &quot;
                          &quot;[&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
                          p2i(eden_start),
</pre>
<center><a href="asPSOldGen.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsParallel.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
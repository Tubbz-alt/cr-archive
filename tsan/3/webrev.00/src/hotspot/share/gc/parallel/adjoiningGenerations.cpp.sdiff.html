<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../g1/vmStructs_g1.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adjoiningGenerations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/adjoiningGenerations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/parallel/generationSizer.hpp&quot;</span>
 30 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;


 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;utilities/align.hpp&quot;
 35 #include &quot;utilities/ostream.hpp&quot;
 36 
 37 // If boundary moving is being used, create the young gen and old
 38 // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
 39 // the old behavior otherwise (with PSYoungGen and PSOldGen).
 40 
<span class="line-modified"> 41 AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs,</span>
<span class="line-modified"> 42                                            GenerationSizer* policy,</span>
<span class="line-modified"> 43                                            size_t alignment) :</span>
<span class="line-modified"> 44   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, policy-&gt;min_old_size(),</span>
<span class="line-modified"> 45                                              policy-&gt;min_young_size(), alignment)) {</span>
<span class="line-modified"> 46   size_t init_low_byte_size = policy-&gt;initial_old_size();</span>
<span class="line-modified"> 47   size_t min_low_byte_size = policy-&gt;min_old_size();</span>
<span class="line-modified"> 48   size_t max_low_byte_size = policy-&gt;max_old_size();</span>
<span class="line-modified"> 49   size_t init_high_byte_size = policy-&gt;initial_young_size();</span>
<span class="line-removed"> 50   size_t min_high_byte_size = policy-&gt;min_young_size();</span>
<span class="line-removed"> 51   size_t max_high_byte_size = policy-&gt;max_young_size();</span>
 52 
 53   assert(min_low_byte_size &lt;= init_low_byte_size &amp;&amp;
 54          init_low_byte_size &lt;= max_low_byte_size, &quot;Parameter check&quot;);
 55   assert(min_high_byte_size &lt;= init_high_byte_size &amp;&amp;
 56          init_high_byte_size &lt;= max_high_byte_size, &quot;Parameter check&quot;);
 57   // Create the generations differently based on the option to
 58   // move the boundary.
 59   if (UseAdaptiveGCBoundary) {
 60     // Initialize the adjoining virtual spaces.  Then pass the
 61     // a virtual to each generation for initialization of the
 62     // generation.
 63 
 64     // Does the actual creation of the virtual spaces
 65     _virtual_spaces-&gt;initialize(max_low_byte_size,
 66                                 init_low_byte_size,
 67                                 init_high_byte_size);
 68 
 69     // Place the young gen at the high end.  Passes in the virtual space.
 70     _young_gen = new ASPSYoungGen(_virtual_spaces-&gt;high(),
 71                                   _virtual_spaces-&gt;high()-&gt;committed_size(),
</pre>
<hr />
<pre>
 78                               min_low_byte_size,
 79                               _virtual_spaces-&gt;low_byte_size_limit(),
 80                               &quot;old&quot;, 1);
 81 
 82     young_gen()-&gt;initialize_work();
 83     assert(young_gen()-&gt;reserved().byte_size() &lt;= young_gen()-&gt;gen_size_limit(),
 84      &quot;Consistency check&quot;);
 85     assert(old_young_rs.size() &gt;= young_gen()-&gt;gen_size_limit(),
 86      &quot;Consistency check&quot;);
 87 
 88     old_gen()-&gt;initialize_work(&quot;old&quot;, 1);
 89     assert(old_gen()-&gt;reserved().byte_size() &lt;= old_gen()-&gt;gen_size_limit(),
 90      &quot;Consistency check&quot;);
 91     assert(old_young_rs.size() &gt;= old_gen()-&gt;gen_size_limit(),
 92      &quot;Consistency check&quot;);
 93   } else {
 94 
 95     // Layout the reserved space for the generations.
 96     // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
 97     ReservedSpace old_rs   =
<span class="line-modified"> 98       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, policy-&gt;is_hetero_heap() /* split */);</span>
 99     ReservedSpace heap_rs  =
100       virtual_spaces()-&gt;reserved_space().last_part(max_low_byte_size);
101     ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
102     assert(young_rs.size() == heap_rs.size(), &quot;Didn&#39;t reserve all of the heap&quot;);
103 
104     // Create the generations.  Virtual spaces are not passed in.
105     _young_gen = new PSYoungGen(init_high_byte_size,
106                                 min_high_byte_size,
107                                 max_high_byte_size);
108     _old_gen = new PSOldGen(init_low_byte_size,
109                             min_low_byte_size,
110                             max_low_byte_size,
111                             &quot;old&quot;, 1);
112 
113     // The virtual spaces are created by the initialization of the gens.
<span class="line-modified">114     _young_gen-&gt;initialize(young_rs, alignment);</span>
115     assert(young_gen()-&gt;gen_size_limit() == young_rs.size(),
116       &quot;Consistency check&quot;);
<span class="line-modified">117     _old_gen-&gt;initialize(old_rs, alignment, &quot;old&quot;, 1);</span>
118     assert(old_gen()-&gt;gen_size_limit() == old_rs.size(), &quot;Consistency check&quot;);
119   }
120 }
121 
<span class="line-modified">122 AdjoiningGenerations::AdjoiningGenerations() { }</span>
123 
124 size_t AdjoiningGenerations::reserved_byte_size() {
125   return virtual_spaces()-&gt;reserved_space().size();
126 }
127 
128 void log_before_expansion(bool old, size_t expand_in_bytes, size_t change_in_bytes, size_t max_size) {
129   Log(gc, ergo, heap) log;
130   if (!log.is_debug()) {
131    return;
132   }
133   log.debug(&quot;Before expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
134   log.debug(&quot;  Requested change: &quot; SIZE_FORMAT_HEX &quot;  Attempted change: &quot; SIZE_FORMAT_HEX,
135                         expand_in_bytes, change_in_bytes);
136   ResourceMark rm;
137   LogStream ls(log.debug());
138   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
139   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
140 }
141 
142 void log_after_expansion(bool old, size_t max_size) {
</pre>
<hr />
<pre>
267     size_t survivor_size) {
268 
269   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
270 
271   // Stress testing.
272   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 0) {
273     request_young_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
274     eden_size = young_gen()-&gt;eden_space()-&gt;capacity_in_bytes();
275   }
276 
277   // Expand only if the entire generation is already committed.
278   if (young_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
279     size_t desired_size = eden_size + 2 * survivor_size;
280     const size_t committed = young_gen()-&gt;virtual_space()-&gt;committed_size();
281     if (desired_size &gt; committed) {
282       request_young_gen_expansion(desired_size - committed);
283     }
284   }
285 }
286 
<span class="line-modified">287 AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs,</span>
<span class="line-modified">288                                                                          GenerationSizer* policy,</span>
<span class="line-modified">289                                                                          size_t alignment) {</span>
<span class="line-removed">290   if (policy-&gt;is_hetero_heap() &amp;&amp; UseAdaptiveGCBoundary) {</span>
<span class="line-removed">291     return new AdjoiningGenerationsForHeteroHeap(old_young_rs, policy, alignment);</span>
292   } else {
<span class="line-modified">293     return new AdjoiningGenerations(old_young_rs, policy, alignment);</span>
294   }
295 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 27 #include &quot;gc/parallel/adjoiningGenerationsForHeteroHeap.hpp&quot;
 28 #include &quot;gc/parallel/adjoiningVirtualSpaces.hpp&quot;

 29 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/parallel/parallelArguments.hpp&quot;</span>
<span class="line-added"> 31 #include &quot;gc/shared/genArguments.hpp&quot;</span>
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;logging/logStream.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;utilities/align.hpp&quot;
 36 #include &quot;utilities/ostream.hpp&quot;
 37 
 38 // If boundary moving is being used, create the young gen and old
 39 // gen with ASPSYoungGen and ASPSOldGen, respectively.  Revert to
 40 // the old behavior otherwise (with PSYoungGen and PSOldGen).
 41 
<span class="line-modified"> 42 AdjoiningGenerations::AdjoiningGenerations(ReservedSpace old_young_rs) :</span>
<span class="line-modified"> 43   _virtual_spaces(new AdjoiningVirtualSpaces(old_young_rs, MinOldSize,</span>
<span class="line-modified"> 44                                              MinNewSize, GenAlignment)) {</span>
<span class="line-modified"> 45   size_t init_low_byte_size = OldSize;</span>
<span class="line-modified"> 46   size_t min_low_byte_size = MinOldSize;</span>
<span class="line-modified"> 47   size_t max_low_byte_size = MaxOldSize;</span>
<span class="line-modified"> 48   size_t init_high_byte_size = NewSize;</span>
<span class="line-modified"> 49   size_t min_high_byte_size = MinNewSize;</span>
<span class="line-modified"> 50   size_t max_high_byte_size = MaxNewSize;</span>


 51 
 52   assert(min_low_byte_size &lt;= init_low_byte_size &amp;&amp;
 53          init_low_byte_size &lt;= max_low_byte_size, &quot;Parameter check&quot;);
 54   assert(min_high_byte_size &lt;= init_high_byte_size &amp;&amp;
 55          init_high_byte_size &lt;= max_high_byte_size, &quot;Parameter check&quot;);
 56   // Create the generations differently based on the option to
 57   // move the boundary.
 58   if (UseAdaptiveGCBoundary) {
 59     // Initialize the adjoining virtual spaces.  Then pass the
 60     // a virtual to each generation for initialization of the
 61     // generation.
 62 
 63     // Does the actual creation of the virtual spaces
 64     _virtual_spaces-&gt;initialize(max_low_byte_size,
 65                                 init_low_byte_size,
 66                                 init_high_byte_size);
 67 
 68     // Place the young gen at the high end.  Passes in the virtual space.
 69     _young_gen = new ASPSYoungGen(_virtual_spaces-&gt;high(),
 70                                   _virtual_spaces-&gt;high()-&gt;committed_size(),
</pre>
<hr />
<pre>
 77                               min_low_byte_size,
 78                               _virtual_spaces-&gt;low_byte_size_limit(),
 79                               &quot;old&quot;, 1);
 80 
 81     young_gen()-&gt;initialize_work();
 82     assert(young_gen()-&gt;reserved().byte_size() &lt;= young_gen()-&gt;gen_size_limit(),
 83      &quot;Consistency check&quot;);
 84     assert(old_young_rs.size() &gt;= young_gen()-&gt;gen_size_limit(),
 85      &quot;Consistency check&quot;);
 86 
 87     old_gen()-&gt;initialize_work(&quot;old&quot;, 1);
 88     assert(old_gen()-&gt;reserved().byte_size() &lt;= old_gen()-&gt;gen_size_limit(),
 89      &quot;Consistency check&quot;);
 90     assert(old_young_rs.size() &gt;= old_gen()-&gt;gen_size_limit(),
 91      &quot;Consistency check&quot;);
 92   } else {
 93 
 94     // Layout the reserved space for the generations.
 95     // If OldGen is allocated on nv-dimm, we need to split the reservation (this is required for windows).
 96     ReservedSpace old_rs   =
<span class="line-modified"> 97       virtual_spaces()-&gt;reserved_space().first_part(max_low_byte_size, ParallelArguments::is_heterogeneous_heap() /* split */);</span>
 98     ReservedSpace heap_rs  =
 99       virtual_spaces()-&gt;reserved_space().last_part(max_low_byte_size);
100     ReservedSpace young_rs = heap_rs.first_part(max_high_byte_size);
101     assert(young_rs.size() == heap_rs.size(), &quot;Didn&#39;t reserve all of the heap&quot;);
102 
103     // Create the generations.  Virtual spaces are not passed in.
104     _young_gen = new PSYoungGen(init_high_byte_size,
105                                 min_high_byte_size,
106                                 max_high_byte_size);
107     _old_gen = new PSOldGen(init_low_byte_size,
108                             min_low_byte_size,
109                             max_low_byte_size,
110                             &quot;old&quot;, 1);
111 
112     // The virtual spaces are created by the initialization of the gens.
<span class="line-modified">113     _young_gen-&gt;initialize(young_rs, GenAlignment);</span>
114     assert(young_gen()-&gt;gen_size_limit() == young_rs.size(),
115       &quot;Consistency check&quot;);
<span class="line-modified">116     _old_gen-&gt;initialize(old_rs, GenAlignment, &quot;old&quot;, 1);</span>
117     assert(old_gen()-&gt;gen_size_limit() == old_rs.size(), &quot;Consistency check&quot;);
118   }
119 }
120 
<span class="line-modified">121 AdjoiningGenerations::AdjoiningGenerations(): _young_gen(NULL), _old_gen(NULL), _virtual_spaces(NULL) { }</span>
122 
123 size_t AdjoiningGenerations::reserved_byte_size() {
124   return virtual_spaces()-&gt;reserved_space().size();
125 }
126 
127 void log_before_expansion(bool old, size_t expand_in_bytes, size_t change_in_bytes, size_t max_size) {
128   Log(gc, ergo, heap) log;
129   if (!log.is_debug()) {
130    return;
131   }
132   log.debug(&quot;Before expansion of %s gen with boundary move&quot;, old ? &quot;old&quot; : &quot;young&quot;);
133   log.debug(&quot;  Requested change: &quot; SIZE_FORMAT_HEX &quot;  Attempted change: &quot; SIZE_FORMAT_HEX,
134                         expand_in_bytes, change_in_bytes);
135   ResourceMark rm;
136   LogStream ls(log.debug());
137   ParallelScavengeHeap::heap()-&gt;print_on(&amp;ls);
138   log.debug(&quot;  PS%sGen max size: &quot; SIZE_FORMAT &quot;K&quot;, old ? &quot;Old&quot; : &quot;Young&quot;, max_size/K);
139 }
140 
141 void log_after_expansion(bool old, size_t max_size) {
</pre>
<hr />
<pre>
266     size_t survivor_size) {
267 
268   assert(UseAdaptiveSizePolicy &amp;&amp; UseAdaptiveGCBoundary, &quot;runtime check&quot;);
269 
270   // Stress testing.
271   if (PSAdaptiveSizePolicyResizeVirtualSpaceAlot == 0) {
272     request_young_gen_expansion(virtual_spaces()-&gt;alignment() * 3 / 2);
273     eden_size = young_gen()-&gt;eden_space()-&gt;capacity_in_bytes();
274   }
275 
276   // Expand only if the entire generation is already committed.
277   if (young_gen()-&gt;virtual_space()-&gt;uncommitted_size() == 0) {
278     size_t desired_size = eden_size + 2 * survivor_size;
279     const size_t committed = young_gen()-&gt;virtual_space()-&gt;committed_size();
280     if (desired_size &gt; committed) {
281       request_young_gen_expansion(desired_size - committed);
282     }
283   }
284 }
285 
<span class="line-modified">286 AdjoiningGenerations* AdjoiningGenerations::create_adjoining_generations(ReservedSpace old_young_rs) {</span>
<span class="line-modified">287   if (ParallelArguments::is_heterogeneous_heap() &amp;&amp; UseAdaptiveGCBoundary) {</span>
<span class="line-modified">288     return new AdjoiningGenerationsForHeteroHeap(old_young_rs);</span>


289   } else {
<span class="line-modified">290     return new AdjoiningGenerations(old_young_rs);</span>
291   }
292 }
</pre>
</td>
</tr>
</table>
<center><a href="../g1/vmStructs_g1.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adjoiningGenerations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
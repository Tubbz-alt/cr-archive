<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/asPSOldGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/asPSOldGen.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 29 #include &quot;gc/parallel/psMarkSweepDecorator.hpp&quot;</span>
 30 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
<a name="3" id="anc3"></a>
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 
 35 // Whereas PSOldGen takes the maximum size of the generation
 36 // (which doesn&#39;t change in the case of PSOldGen) as a parameter,
 37 // ASPSOldGen takes the upper limit on the size of
 38 // the generation as a parameter.  In ASPSOldGen the
 39 // maximum size of the generation can change as the boundary
 40 // moves.  The &quot;maximum size of the generation&quot; is still a valid
 41 // concept since the generation can grow and shrink within that
 42 // maximum.  There are lots of useful checks that use that
 43 // maximum.  In PSOldGen the method max_gen_size() returns
 44 // _max_gen_size (as set by the PSOldGen constructor).  This
 45 // is how it always worked.  In ASPSOldGen max_gen_size()
 46 // returned the size of the reserved space for the generation.
 47 // That can change as the boundary moves.  Below the limit of
 48 // the size of the generation is passed to the PSOldGen constructor
 49 // for &quot;_max_gen_size&quot; (have to pass something) but it is not used later.
 50 //
 51 ASPSOldGen::ASPSOldGen(size_t initial_size,
 52                        size_t min_size,
 53                        size_t size_limit,
 54                        const char* gen_name,
 55                        int level) :
 56   PSOldGen(initial_size, min_size, size_limit, gen_name, level),
 57   _gen_size_limit(size_limit)
 58 {}
 59 
 60 ASPSOldGen::ASPSOldGen(PSVirtualSpace* vs,
 61                        size_t initial_size,
 62                        size_t min_size,
 63                        size_t size_limit,
 64                        const char* gen_name,
 65                        int level) :
 66   PSOldGen(initial_size, min_size, size_limit, gen_name, level),
 67   _gen_size_limit(size_limit)
 68 {
 69   _virtual_space = vs;
 70 }
 71 
 72 void ASPSOldGen::initialize_work(const char* perf_data_name, int level) {
 73   PSOldGen::initialize_work(perf_data_name, level);
 74 
 75   // The old gen can grow to gen_size_limit().  _reserve reflects only
 76   // the current maximum that can be committed.
 77   assert(_reserved.byte_size() &lt;= gen_size_limit(), &quot;Consistency check&quot;);
 78 
 79   initialize_performance_counters(perf_data_name, level);
 80 }
 81 
 82 void ASPSOldGen::reset_after_change() {
 83   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 84                         (HeapWord*)virtual_space()-&gt;high_boundary());
 85   post_resize();
 86 }
 87 
 88 
 89 size_t ASPSOldGen::available_for_expansion() {
 90   assert(virtual_space()-&gt;is_aligned(gen_size_limit()), &quot;not aligned&quot;);
 91   assert(gen_size_limit() &gt;= virtual_space()-&gt;committed_size(), &quot;bad gen size&quot;);
 92 
<a name="4" id="anc4"></a><span class="line-removed"> 93   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();</span>
 94   size_t result =  gen_size_limit() - virtual_space()-&gt;committed_size();
<a name="5" id="anc5"></a><span class="line-modified"> 95   size_t result_aligned = align_down(result, heap-&gt;generation_alignment());</span>
 96   return result_aligned;
 97 }
 98 
 99 size_t ASPSOldGen::available_for_contraction() {
100   size_t uncommitted_bytes = virtual_space()-&gt;uncommitted_size();
101   if (uncommitted_bytes != 0) {
102     return uncommitted_bytes;
103   }
104 
105   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
<a name="6" id="anc6"></a><span class="line-removed">106   const size_t gen_alignment = heap-&gt;generation_alignment();</span>
107   PSAdaptiveSizePolicy* policy = heap-&gt;size_policy();
108   const size_t working_size =
109     used_in_bytes() + (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
<a name="7" id="anc7"></a><span class="line-modified">110   const size_t working_aligned = align_up(working_size, gen_alignment);</span>
111   const size_t working_or_min = MAX2(working_aligned, min_gen_size());
112   if (working_or_min &gt; reserved().byte_size()) {
113     // If the used or minimum gen size (aligned up) is greater
114     // than the total reserved size, then the space available
115     // for contraction should (after proper alignment) be 0
116     return 0;
117   }
118   const size_t max_contraction =
119     reserved().byte_size() - working_or_min;
120 
121   // Use the &quot;increment&quot; fraction instead of the &quot;decrement&quot; fraction
122   // to allow the other gen to expand more aggressively.  The
123   // &quot;decrement&quot; fraction is conservative because its intent is to
124   // only reduce the footprint.
125 
126   size_t result = policy-&gt;promo_increment_aligned_down(max_contraction);
127   // Also adjust for inter-generational alignment
<a name="8" id="anc8"></a><span class="line-modified">128   size_t result_aligned = align_down(result, gen_alignment);</span>
129 
130   Log(gc, ergo) log;
131   if (log.is_trace()) {
132     size_t working_promoted = (size_t) policy-&gt;avg_promoted()-&gt;padded_average();
133     size_t promo_increment = policy-&gt;promo_increment(max_contraction);
134     log.trace(&quot;ASPSOldGen::available_for_contraction: &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, result_aligned/K, result_aligned);
135     log.trace(&quot; reserved().byte_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, reserved().byte_size()/K, reserved().byte_size());
136     log.trace(&quot; padded promoted &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, working_promoted/K, working_promoted);
137     log.trace(&quot; used &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, used_in_bytes()/K, used_in_bytes());
138     log.trace(&quot; min_gen_size() &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, min_gen_size()/K, min_gen_size());
139     log.trace(&quot; max_contraction &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, max_contraction/K, max_contraction);
140     log.trace(&quot;    without alignment &quot; SIZE_FORMAT &quot; K / &quot; SIZE_FORMAT_HEX, promo_increment/K, promo_increment);
<a name="9" id="anc9"></a><span class="line-modified">141     log.trace(&quot; alignment &quot; SIZE_FORMAT_HEX, gen_alignment);</span>
142   }
143 
144   assert(result_aligned &lt;= max_contraction, &quot;arithmetic is wrong&quot;);
145   return result_aligned;
146 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
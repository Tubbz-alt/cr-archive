<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/parallelArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
<a name="2" id="anc2"></a>
 27 #include &quot;gc/parallel/parallelArguments.hpp&quot;
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 30 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
<span class="line-modified"> 31 #include &quot;gc/shared/genArguments.hpp&quot;</span>
 32 #include &quot;gc/shared/workerPolicy.hpp&quot;
<a name="4" id="anc4"></a><span class="line-added"> 33 #include &quot;logging/log.hpp&quot;</span>
 34 #include &quot;runtime/globals.hpp&quot;
 35 #include &quot;runtime/globals_extension.hpp&quot;
 36 #include &quot;runtime/java.hpp&quot;
 37 #include &quot;utilities/defaultStream.hpp&quot;
<a name="5" id="anc5"></a><span class="line-added"> 38 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 static const double MaxRamFractionForYoung = 0.8;</span>
 41 
 42 size_t ParallelArguments::conservative_max_heap_alignment() {
<a name="6" id="anc6"></a><span class="line-modified"> 43   return compute_heap_alignment();</span>
 44 }
 45 
 46 void ParallelArguments::initialize() {
 47   GCArguments::initialize();
<a name="7" id="anc7"></a><span class="line-modified"> 48   assert(UseParallelGC, &quot;Error&quot;);</span>





 49 
 50   // If no heap maximum was requested explicitly, use some reasonable fraction
 51   // of the physical memory, up to a maximum of 1GB.
 52   FLAG_SET_DEFAULT(ParallelGCThreads,
 53                    WorkerPolicy::parallel_worker_threads());
 54   if (ParallelGCThreads == 0) {
 55     jio_fprintf(defaultStream::error_stream(),
 56         &quot;The Parallel GC can not be combined with -XX:ParallelGCThreads=0\n&quot;);
 57     vm_exit(1);
 58   }
 59 
 60   if (UseAdaptiveSizePolicy) {
 61     // We don&#39;t want to limit adaptive heap sizing&#39;s freedom to adjust the heap
 62     // unless the user actually sets these flags.
 63     if (FLAG_IS_DEFAULT(MinHeapFreeRatio)) {
 64       FLAG_SET_DEFAULT(MinHeapFreeRatio, 0);
 65     }
 66     if (FLAG_IS_DEFAULT(MaxHeapFreeRatio)) {
 67       FLAG_SET_DEFAULT(MaxHeapFreeRatio, 100);
 68     }
 69   }
 70 
 71   // If InitialSurvivorRatio or MinSurvivorRatio were not specified, but the
 72   // SurvivorRatio has been set, reset their default values to SurvivorRatio +
 73   // 2.  By doing this we make SurvivorRatio also work for Parallel Scavenger.
 74   // See CR 6362902 for details.
 75   if (!FLAG_IS_DEFAULT(SurvivorRatio)) {
 76     if (FLAG_IS_DEFAULT(InitialSurvivorRatio)) {
 77        FLAG_SET_DEFAULT(InitialSurvivorRatio, SurvivorRatio + 2);
 78     }
 79     if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
 80       FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
 81     }
 82   }
 83 
<a name="8" id="anc8"></a><span class="line-modified"> 84   // Par compact uses lower default values since they are treated as</span>
<span class="line-modified"> 85   // minimums.  These are different defaults because of the different</span>
<span class="line-modified"> 86   // interpretation and are not ergonomically set.</span>
<span class="line-modified"> 87   if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {</span>
<span class="line-modified"> 88     FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);</span>


 89   }
 90 }
 91 
<a name="9" id="anc9"></a><span class="line-modified"> 92 // The alignment used for boundary between young gen and old gen</span>
<span class="line-modified"> 93 static size_t default_gen_alignment() {</span>
<span class="line-modified"> 94   return 64 * K * HeapWordSize;</span>
<span class="line-added"> 95 }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 void ParallelArguments::initialize_alignments() {</span>
<span class="line-added"> 98   SpaceAlignment = GenAlignment = default_gen_alignment();</span>
<span class="line-added"> 99   HeapAlignment = compute_heap_alignment();</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
<span class="line-added">102 void ParallelArguments::initialize_heap_flags_and_sizes_one_pass() {</span>
<span class="line-added">103   // Do basic sizing work</span>
<span class="line-added">104   GenArguments::initialize_heap_flags_and_sizes();</span>
<span class="line-added">105 </span>
<span class="line-added">106   // The survivor ratio&#39;s are calculated &quot;raw&quot;, unlike the</span>
<span class="line-added">107   // default gc, which adds 2 to the ratio value. We need to</span>
<span class="line-added">108   // make sure the values are valid before using them.</span>
<span class="line-added">109   if (MinSurvivorRatio &lt; 3) {</span>
<span class="line-added">110     FLAG_SET_ERGO(MinSurvivorRatio, 3);</span>
<span class="line-added">111   }</span>
<span class="line-added">112 </span>
<span class="line-added">113   if (InitialSurvivorRatio &lt; 3) {</span>
<span class="line-added">114     FLAG_SET_ERGO(InitialSurvivorRatio, 3);</span>
<span class="line-added">115   }</span>
<span class="line-added">116 }</span>
<span class="line-added">117 </span>
<span class="line-added">118 void ParallelArguments::initialize_heap_flags_and_sizes() {</span>
<span class="line-added">119   if (is_heterogeneous_heap()) {</span>
<span class="line-added">120     initialize_heterogeneous();</span>
<span class="line-added">121   }</span>
<span class="line-added">122 </span>
<span class="line-added">123   initialize_heap_flags_and_sizes_one_pass();</span>
<span class="line-added">124 </span>
<span class="line-added">125   const size_t max_page_sz = os::page_size_for_region_aligned(MaxHeapSize, 8);</span>
<span class="line-added">126   const size_t min_pages = 4; // 1 for eden + 1 for each survivor + 1 for old</span>
<span class="line-added">127   const size_t min_page_sz = os::page_size_for_region_aligned(MinHeapSize, min_pages);</span>
<span class="line-added">128   const size_t page_sz = MIN2(max_page_sz, min_page_sz);</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Can a page size be something else than a power of two?</span>
<span class="line-added">131   assert(is_power_of_2((intptr_t)page_sz), &quot;must be a power of 2&quot;);</span>
<span class="line-added">132   size_t new_alignment = align_up(page_sz, GenAlignment);</span>
<span class="line-added">133   if (new_alignment != GenAlignment) {</span>
<span class="line-added">134     GenAlignment = new_alignment;</span>
<span class="line-added">135     SpaceAlignment = new_alignment;</span>
<span class="line-added">136     // Redo everything from the start</span>
<span class="line-added">137     initialize_heap_flags_and_sizes_one_pass();</span>
<span class="line-added">138   }</span>
<span class="line-added">139 }</span>
<span class="line-added">140 </span>
<span class="line-added">141 // Check the available dram memory to limit NewSize and MaxNewSize before</span>
<span class="line-added">142 // calling base class initialize_flags().</span>
<span class="line-added">143 void ParallelArguments::initialize_heterogeneous() {</span>
<span class="line-added">144   FormatBuffer&lt;100&gt; calc_str(&quot;&quot;);</span>
<span class="line-added">145 </span>
<span class="line-added">146   julong phys_mem;</span>
<span class="line-added">147   // If MaxRam is specified, we use that as maximum physical memory available.</span>
<span class="line-added">148   if (FLAG_IS_DEFAULT(MaxRAM)) {</span>
<span class="line-added">149     phys_mem = os::physical_memory();</span>
<span class="line-added">150     calc_str.append(&quot;Physical_Memory&quot;);</span>
151   } else {
<a name="10" id="anc10"></a><span class="line-modified">152     phys_mem = (julong)MaxRAM;</span>
<span class="line-added">153     calc_str.append(&quot;MaxRAM&quot;);</span>
154   }
<a name="11" id="anc11"></a><span class="line-added">155 </span>
<span class="line-added">156   julong reasonable_max = phys_mem;</span>
<span class="line-added">157 </span>
<span class="line-added">158   // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate</span>
<span class="line-added">159   // reasonable max size of young generation.</span>
<span class="line-added">160   if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {</span>
<span class="line-added">161     reasonable_max = (julong)(phys_mem / MaxRAMFraction);</span>
<span class="line-added">162     calc_str.append(&quot; / MaxRAMFraction&quot;);</span>
<span class="line-added">163   } else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {</span>
<span class="line-added">164     reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);</span>
<span class="line-added">165     calc_str.append(&quot; * MaxRAMPercentage / 100&quot;);</span>
<span class="line-added">166   } else {</span>
<span class="line-added">167     // We use our own fraction to calculate max size of young generation.</span>
<span class="line-added">168     reasonable_max = phys_mem * MaxRamFractionForYoung;</span>
<span class="line-added">169     calc_str.append(&quot; * %0.2f&quot;, MaxRamFractionForYoung);</span>
<span class="line-added">170   }</span>
<span class="line-added">171   reasonable_max = align_up(reasonable_max, GenAlignment);</span>
<span class="line-added">172 </span>
<span class="line-added">173   if (MaxNewSize &gt; reasonable_max) {</span>
<span class="line-added">174     if (FLAG_IS_CMDLINE(MaxNewSize)) {</span>
<span class="line-added">175       log_warning(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">176                             (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">177     } else {</span>
<span class="line-added">178       log_info(gc, ergo)(&quot;Setting MaxNewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s)). &quot;</span>
<span class="line-added">179                          &quot;Dram usage can be lowered by setting MaxNewSize to a lower value&quot;, (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">180     }</span>
<span class="line-added">181     MaxNewSize = reasonable_max;</span>
<span class="line-added">182   }</span>
<span class="line-added">183   if (NewSize &gt; reasonable_max) {</span>
<span class="line-added">184     if (FLAG_IS_CMDLINE(NewSize)) {</span>
<span class="line-added">185       log_warning(gc, ergo)(&quot;Setting NewSize to &quot; SIZE_FORMAT &quot; based on dram available (calculation = align(%s))&quot;,</span>
<span class="line-added">186                             (size_t)reasonable_max, calc_str.buffer());</span>
<span class="line-added">187     }</span>
<span class="line-added">188     NewSize = reasonable_max;</span>
<span class="line-added">189   }</span>
<span class="line-added">190 }</span>
<span class="line-added">191 </span>
<span class="line-added">192 bool ParallelArguments::is_heterogeneous_heap() {</span>
<span class="line-added">193   return AllocateOldGenAt != NULL;</span>
<span class="line-added">194 }</span>
<span class="line-added">195 </span>
<span class="line-added">196 size_t ParallelArguments::heap_reserved_size_bytes() {</span>
<span class="line-added">197   if (!is_heterogeneous_heap() || !UseAdaptiveGCBoundary) {</span>
<span class="line-added">198     return MaxHeapSize;</span>
<span class="line-added">199   }</span>
<span class="line-added">200 </span>
<span class="line-added">201   // Heterogeneous heap and adaptive size gc boundary</span>
<span class="line-added">202 </span>
<span class="line-added">203   // This is the size that young gen can grow to, when UseAdaptiveGCBoundary is true.</span>
<span class="line-added">204   size_t max_yg_size = MaxHeapSize - MinOldSize;</span>
<span class="line-added">205   // This is the size that old gen can grow to, when UseAdaptiveGCBoundary is true.</span>
<span class="line-added">206   size_t max_old_size = MaxHeapSize - MinNewSize;</span>
<span class="line-added">207 </span>
<span class="line-added">208   return max_yg_size + max_old_size;</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 size_t ParallelArguments::heap_max_size_bytes() {</span>
<span class="line-added">212   return MaxHeapSize;</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
<span class="line-added">215 CollectedHeap* ParallelArguments::create_heap() {</span>
<span class="line-added">216   return new ParallelScavengeHeap();</span>
217 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
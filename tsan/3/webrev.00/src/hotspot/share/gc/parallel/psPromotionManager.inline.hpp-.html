<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/psPromotionManager.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSPROMOTIONMANAGER_INLINE_HPP
 26 #define SHARE_GC_PARALLEL_PSPROMOTIONMANAGER_INLINE_HPP
 27 
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
 30 #include &quot;gc/parallel/psOldGen.hpp&quot;
 31 #include &quot;gc/parallel/psPromotionLAB.inline.hpp&quot;
 32 #include &quot;gc/parallel/psPromotionManager.hpp&quot;
 33 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/iterator.inline.hpp&quot;
 37 #include &quot;oops/access.inline.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 
 40 inline PSPromotionManager* PSPromotionManager::manager_array(uint index) {
 41   assert(_manager_array != NULL, &quot;access of NULL manager_array&quot;);
 42   assert(index &lt;= ParallelGCThreads, &quot;out of range manager_array access&quot;);
 43   return &amp;_manager_array[index];
 44 }
 45 
 46 template &lt;class T&gt;
 47 inline void PSPromotionManager::push_depth(T* p) {
 48   claimed_stack_depth()-&gt;push(p);
 49 }
 50 
 51 template &lt;class T&gt;
 52 inline void PSPromotionManager::claim_or_forward_internal_depth(T* p) {
 53   if (p != NULL) { // XXX: error if p != NULL here
 54     oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
 55     if (o-&gt;is_forwarded()) {
 56       o = o-&gt;forwardee();
 57       // Card mark
 58       if (PSScavenge::is_obj_in_young(o)) {
 59         PSScavenge::card_table()-&gt;inline_write_ref_field_gc(p, o);
 60       }
 61       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, o);
 62     } else {
 63       push_depth(p);
 64     }
 65   }
 66 }
 67 
 68 template &lt;class T&gt;
 69 inline void PSPromotionManager::claim_or_forward_depth(T* p) {
 70   assert(should_scavenge(p, true), &quot;revisiting object?&quot;);
 71   assert(ParallelScavengeHeap::heap()-&gt;is_in(p), &quot;pointer outside heap&quot;);
 72 
 73   claim_or_forward_internal_depth(p);
 74 }
 75 
 76 inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj,
 77                                                       size_t obj_size,
 78                                                       uint age, bool tenured,
 79                                                       const PSPromotionLAB* lab) {
 80   // Skip if memory allocation failed
 81   if (new_obj != NULL) {
 82     const ParallelScavengeTracer* gc_tracer = PSScavenge::gc_tracer();
 83 
 84     if (lab != NULL) {
 85       // Promotion of object through newly allocated PLAB
 86       if (gc_tracer-&gt;should_report_promotion_in_new_plab_event()) {
 87         size_t obj_bytes = obj_size * HeapWordSize;
 88         size_t lab_size = lab-&gt;capacity();
 89         gc_tracer-&gt;report_promotion_in_new_plab_event(old_obj-&gt;klass(), obj_bytes,
 90                                                       age, tenured, lab_size);
 91       }
 92     } else {
 93       // Promotion of object directly to heap
 94       if (gc_tracer-&gt;should_report_promotion_outside_plab_event()) {
 95         size_t obj_bytes = obj_size * HeapWordSize;
 96         gc_tracer-&gt;report_promotion_outside_plab_event(old_obj-&gt;klass(), obj_bytes,
 97                                                        age, tenured);
 98       }
 99     }
100   }
101 }
102 
103 class PSPushContentsClosure: public BasicOopIterateClosure {
104   PSPromotionManager* _pm;
105  public:
106   PSPushContentsClosure(PSPromotionManager* pm) : BasicOopIterateClosure(PSScavenge::reference_processor()), _pm(pm) {}
107 
108   template &lt;typename T&gt; void do_oop_nv(T* p) {
109     if (PSScavenge::should_scavenge(p)) {
110       _pm-&gt;claim_or_forward_depth(p);
111     }
112   }
113 
114   virtual void do_oop(oop* p)       { do_oop_nv(p); }
115   virtual void do_oop(narrowOop* p) { do_oop_nv(p); }
116 
117   // Don&#39;t use the oop verification code in the oop_oop_iterate framework.
118   debug_only(virtual bool should_verify_oops() { return false; })
119 };
120 
121 //
122 // This closure specialization will override the one that is defined in
123 // instanceRefKlass.inline.cpp. It swaps the order of oop_oop_iterate and
124 // oop_oop_iterate_ref_processing. Unfortunately G1 and Parallel behaves
125 // significantly better (especially in the Derby benchmark) using opposite
126 // order of these function calls.
127 //
128 template &lt;&gt;
129 inline void InstanceRefKlass::oop_oop_iterate_reverse&lt;oop, PSPushContentsClosure&gt;(oop obj, PSPushContentsClosure* closure) {
130   oop_oop_iterate_ref_processing&lt;oop&gt;(obj, closure);
131   InstanceKlass::oop_oop_iterate_reverse&lt;oop&gt;(obj, closure);
132 }
133 
134 template &lt;&gt;
135 inline void InstanceRefKlass::oop_oop_iterate_reverse&lt;narrowOop, PSPushContentsClosure&gt;(oop obj, PSPushContentsClosure* closure) {
136   oop_oop_iterate_ref_processing&lt;narrowOop&gt;(obj, closure);
137   InstanceKlass::oop_oop_iterate_reverse&lt;narrowOop&gt;(obj, closure);
138 }
139 
140 inline void PSPromotionManager::push_contents(oop obj) {
141   if (!obj-&gt;klass()-&gt;is_typeArray_klass()) {
142     PSPushContentsClosure pcc(this);
143     obj-&gt;oop_iterate_backwards(&amp;pcc);
144   }
145 }
146 //
147 // This method is pretty bulky. It would be nice to split it up
148 // into smaller submethods, but we need to be careful not to hurt
149 // performance.
150 //
151 template&lt;bool promote_immediately&gt;
152 inline oop PSPromotionManager::copy_to_survivor_space(oop o) {
153   assert(should_scavenge(&amp;o), &quot;Sanity&quot;);
154 
155   oop new_obj = NULL;
156 
157   // NOTE! We must be very careful with any methods that access the mark
158   // in o. There may be multiple threads racing on it, and it may be forwarded
159   // at any time. Do not use oop methods for accessing the mark!
160   markOop test_mark = o-&gt;mark_raw();
161 
162   // The same test as &quot;o-&gt;is_forwarded()&quot;
163   if (!test_mark-&gt;is_marked()) {
164     bool new_obj_is_tenured = false;
165     size_t new_obj_size = o-&gt;size();
166 
167     // Find the objects age, MT safe.
168     uint age = (test_mark-&gt;has_displaced_mark_helper() /* o-&gt;has_displaced_mark() */) ?
169       test_mark-&gt;displaced_mark_helper()-&gt;age() : test_mark-&gt;age();
170 
171     if (!promote_immediately) {
172       // Try allocating obj in to-space (unless too old)
173       if (age &lt; PSScavenge::tenuring_threshold()) {
174         new_obj = (oop) _young_lab.allocate(new_obj_size);
175         if (new_obj == NULL &amp;&amp; !_young_gen_is_full) {
176           // Do we allocate directly, or flush and refill?
177           if (new_obj_size &gt; (YoungPLABSize / 2)) {
178             // Allocate this object directly
179             new_obj = (oop)young_space()-&gt;cas_allocate(new_obj_size);
180             promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);
181           } else {
182             // Flush and fill
183             _young_lab.flush();
184 
185             HeapWord* lab_base = young_space()-&gt;cas_allocate(YoungPLABSize);
186             if (lab_base != NULL) {
187               _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));
188               // Try the young lab allocation again.
189               new_obj = (oop) _young_lab.allocate(new_obj_size);
190               promotion_trace_event(new_obj, o, new_obj_size, age, false, &amp;_young_lab);
191             } else {
192               _young_gen_is_full = true;
193             }
194           }
195         }
196       }
197     }
198 
199     // Otherwise try allocating obj tenured
200     if (new_obj == NULL) {
201 #ifndef PRODUCT
202       if (ParallelScavengeHeap::heap()-&gt;promotion_should_fail()) {
203         return oop_promotion_failed(o, test_mark);
204       }
205 #endif  // #ifndef PRODUCT
206 
207       new_obj = (oop) _old_lab.allocate(new_obj_size);
208       new_obj_is_tenured = true;
209 
210       if (new_obj == NULL) {
211         if (!_old_gen_is_full) {
212           // Do we allocate directly, or flush and refill?
213           if (new_obj_size &gt; (OldPLABSize / 2)) {
214             // Allocate this object directly
215             new_obj = (oop)old_gen()-&gt;cas_allocate(new_obj_size);
216             promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);
217           } else {
218             // Flush and fill
219             _old_lab.flush();
220 
221             HeapWord* lab_base = old_gen()-&gt;cas_allocate(OldPLABSize);
222             if(lab_base != NULL) {
223 #ifdef ASSERT
224               // Delay the initialization of the promotion lab (plab).
225               // This exposes uninitialized plabs to card table processing.
226               if (GCWorkerDelayMillis &gt; 0) {
227                 os::sleep(Thread::current(), GCWorkerDelayMillis, false);
228               }
229 #endif
230               _old_lab.initialize(MemRegion(lab_base, OldPLABSize));
231               // Try the old lab allocation again.
232               new_obj = (oop) _old_lab.allocate(new_obj_size);
233               promotion_trace_event(new_obj, o, new_obj_size, age, true, &amp;_old_lab);
234             }
235           }
236         }
237 
238         // This is the promotion failed test, and code handling.
239         // The code belongs here for two reasons. It is slightly
240         // different than the code below, and cannot share the
241         // CAS testing code. Keeping the code here also minimizes
242         // the impact on the common case fast path code.
243 
244         if (new_obj == NULL) {
245           _old_gen_is_full = true;
246           return oop_promotion_failed(o, test_mark);
247         }
248       }
249     }
250 
251     assert(new_obj != NULL, &quot;allocation should have succeeded&quot;);
252 
253     // Copy obj
254     Copy::aligned_disjoint_words((HeapWord*)o, (HeapWord*)new_obj, new_obj_size);
255 
256     // Now we have to CAS in the header.
257     // Make copy visible to threads reading the forwardee.
258     if (o-&gt;cas_forward_to(new_obj, test_mark, memory_order_release)) {
259       // We won any races, we &quot;own&quot; this object.
260       assert(new_obj == o-&gt;forwardee(), &quot;Sanity&quot;);
261 
262       // Increment age if obj still in new generation. Now that
263       // we&#39;re dealing with a markOop that cannot change, it is
264       // okay to use the non mt safe oop methods.
265       if (!new_obj_is_tenured) {
266         new_obj-&gt;incr_age();
267         assert(young_space()-&gt;contains(new_obj), &quot;Attempt to push non-promoted obj&quot;);
268       }
269 
270       // Do the size comparison first with new_obj_size, which we
271       // already have. Hopefully, only a few objects are larger than
272       // _min_array_size_for_chunking, and most of them will be arrays.
273       // So, the is-&gt;objArray() test would be very infrequent.
274       if (new_obj_size &gt; _min_array_size_for_chunking &amp;&amp;
275           new_obj-&gt;is_objArray() &amp;&amp;
276           PSChunkLargeArrays) {
277         // we&#39;ll chunk it
278         oop* const masked_o = mask_chunked_array_oop(o);
279         push_depth(masked_o);
280         TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_masked_pushes);
281       } else {
282         // we&#39;ll just push its contents
283         push_contents(new_obj);
284       }
285     }  else {
286       // We lost, someone else &quot;owns&quot; this object
287       guarantee(o-&gt;is_forwarded(), &quot;Object must be forwarded if the cas failed.&quot;);
288 
289       // Try to deallocate the space.  If it was directly allocated we cannot
290       // deallocate it, so we have to test.  If the deallocation fails,
291       // overwrite with a filler object.
292       if (new_obj_is_tenured) {
293         if (!_old_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {
294           CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);
295         }
296       } else if (!_young_lab.unallocate_object((HeapWord*) new_obj, new_obj_size)) {
297         CollectedHeap::fill_with_object((HeapWord*) new_obj, new_obj_size);
298       }
299 
300       // don&#39;t update this before the unallocation!
301       // Using acquire though consume would be accurate for accessing new_obj.
302       new_obj = o-&gt;forwardee_acquire();
303     }
304   } else {
305     assert(o-&gt;is_forwarded(), &quot;Sanity&quot;);
306     new_obj = o-&gt;forwardee_acquire();
307   }
308 
309   // This code must come after the CAS test, or it will print incorrect
310   // information.
311   log_develop_trace(gc, scavenge)(&quot;{%s %s &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot; (%d)}&quot;,
312                                   should_scavenge(&amp;new_obj) ? &quot;copying&quot; : &quot;tenuring&quot;,
313                                   new_obj-&gt;klass()-&gt;internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj-&gt;size());
314 
315   return new_obj;
316 }
317 
318 // Attempt to &quot;claim&quot; oop at p via CAS, push the new obj if successful
319 // This version tests the oop* to make sure it is within the heap before
320 // attempting marking.
321 template &lt;class T, bool promote_immediately&gt;
322 inline void PSPromotionManager::copy_and_push_safe_barrier(T* p) {
323   assert(should_scavenge(p, true), &quot;revisiting object?&quot;);
324 
325   oop o = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
326   oop new_obj = o-&gt;is_forwarded()
327         ? o-&gt;forwardee()
328         : copy_to_survivor_space&lt;promote_immediately&gt;(o);
329 
330   // This code must come after the CAS test, or it will print incorrect
331   // information.
332   if (log_develop_is_enabled(Trace, gc, scavenge) &amp;&amp; o-&gt;is_forwarded()) {
333     log_develop_trace(gc, scavenge)(&quot;{%s %s &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot; (%d)}&quot;,
334                       &quot;forwarding&quot;,
335                       new_obj-&gt;klass()-&gt;internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj-&gt;size());
336   }
337 
338   RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
339 
340   // We cannot mark without test, as some code passes us pointers
341   // that are outside the heap. These pointers are either from roots
342   // or from metadata.
343   if ((!PSScavenge::is_obj_in_young((HeapWord*)p)) &amp;&amp;
344       ParallelScavengeHeap::heap()-&gt;is_in_reserved(p)) {
345     if (PSScavenge::is_obj_in_young(new_obj)) {
346       PSScavenge::card_table()-&gt;inline_write_ref_field_gc(p, new_obj);
347     }
348   }
349 }
350 
351 inline void PSPromotionManager::process_popped_location_depth(StarTask p) {
352   if (is_oop_masked(p)) {
353     assert(PSChunkLargeArrays, &quot;invariant&quot;);
354     oop const old = unmask_chunked_array_oop(p);
355     process_array_chunk(old);
356   } else {
357     if (p.is_narrow()) {
358       assert(UseCompressedOops, &quot;Error&quot;);
359       copy_and_push_safe_barrier&lt;narrowOop, /*promote_immediately=*/false&gt;(p);
360     } else {
361       copy_and_push_safe_barrier&lt;oop, /*promote_immediately=*/false&gt;(p);
362     }
363   }
364 }
365 
366 inline bool PSPromotionManager::steal_depth(int queue_num, StarTask&amp; t) {
367   return stack_array_depth()-&gt;steal(queue_num, t);
368 }
369 
370 #if TASKQUEUE_STATS
371 void PSPromotionManager::record_steal(StarTask&amp; p) {
372   if (is_oop_masked(p)) {
373     ++_masked_steals;
374   }
375 }
376 #endif // TASKQUEUE_STATS
377 
378 #endif // SHARE_GC_PARALLEL_PSPROMOTIONMANAGER_INLINE_HPP
    </pre>
  </body>
</html>
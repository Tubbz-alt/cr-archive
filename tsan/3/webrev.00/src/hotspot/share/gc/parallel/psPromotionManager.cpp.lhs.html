<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psPromotionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 27 #include &quot;gc/parallel/gcTaskManager.hpp&quot;</span>
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 30 #include &quot;gc/parallel/psOldGen.hpp&quot;
 31 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 32 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 33 #include &quot;gc/shared/gcTrace.hpp&quot;
 34 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
 35 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 36 #include &quot;logging/log.hpp&quot;
 37 #include &quot;logging/logStream.hpp&quot;
 38 #include &quot;memory/allocation.inline.hpp&quot;
 39 #include &quot;memory/iterator.inline.hpp&quot;
 40 #include &quot;memory/memRegion.hpp&quot;
 41 #include &quot;memory/padded.inline.hpp&quot;
 42 #include &quot;memory/resourceArea.hpp&quot;
 43 #include &quot;oops/access.inline.hpp&quot;
 44 #include &quot;oops/compressedOops.inline.hpp&quot;
 45 
 46 PaddedEnd&lt;PSPromotionManager&gt;* PSPromotionManager::_manager_array = NULL;
<a name="3" id="anc3"></a><span class="line-modified"> 47 OopStarTaskQueueSet*           PSPromotionManager::_stack_array_depth = NULL;</span>
 48 PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;
 49 PSOldGen*                      PSPromotionManager::_old_gen = NULL;
 50 MutableSpace*                  PSPromotionManager::_young_space = NULL;
 51 
 52 void PSPromotionManager::initialize() {
 53   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 54 
 55   _old_gen = heap-&gt;old_gen();
 56   _young_space = heap-&gt;young_gen()-&gt;to_space();
 57 
 58   const uint promotion_manager_num = ParallelGCThreads + 1;
 59 
 60   // To prevent false sharing, we pad the PSPromotionManagers
 61   // and make sure that the first instance starts at a cache line.
 62   assert(_manager_array == NULL, &quot;Attempt to initialize twice&quot;);
 63   _manager_array = PaddedArray&lt;PSPromotionManager, mtGC&gt;::create_unfreeable(promotion_manager_num);
<a name="4" id="anc4"></a><span class="line-removed"> 64   guarantee(_manager_array != NULL, &quot;Could not initialize promotion manager&quot;);</span>
 65 
 66   _stack_array_depth = new OopStarTaskQueueSet(ParallelGCThreads);
<a name="5" id="anc5"></a><span class="line-removed"> 67   guarantee(_stack_array_depth != NULL, &quot;Could not initialize promotion manager&quot;);</span>
 68 
 69   // Create and register the PSPromotionManager(s) for the worker threads.
 70   for(uint i=0; i&lt;ParallelGCThreads; i++) {
 71     stack_array_depth()-&gt;register_queue(i, _manager_array[i].claimed_stack_depth());
 72   }
 73   // The VMThread gets its own PSPromotionManager, which is not available
 74   // for work stealing.
 75 
 76   assert(_preserved_marks_set == NULL, &quot;Attempt to initialize twice&quot;);
 77   _preserved_marks_set = new PreservedMarksSet(true /* in_c_heap */);
<a name="6" id="anc6"></a><span class="line-removed"> 78   guarantee(_preserved_marks_set != NULL, &quot;Could not initialize preserved marks set&quot;);</span>
 79   _preserved_marks_set-&gt;init(promotion_manager_num);
 80   for (uint i = 0; i &lt; promotion_manager_num; i += 1) {
 81     _manager_array[i].register_preserved_marks(_preserved_marks_set-&gt;get(i));
 82   }
 83 }
 84 
 85 // Helper functions to get around the circular dependency between
 86 // psScavenge.inline.hpp and psPromotionManager.inline.hpp.
 87 bool PSPromotionManager::should_scavenge(oop* p, bool check_to_space) {
 88   return PSScavenge::should_scavenge(p, check_to_space);
 89 }
 90 bool PSPromotionManager::should_scavenge(narrowOop* p, bool check_to_space) {
 91   return PSScavenge::should_scavenge(p, check_to_space);
 92 }
 93 
 94 PSPromotionManager* PSPromotionManager::gc_thread_promotion_manager(uint index) {
 95   assert(index &lt; ParallelGCThreads, &quot;index out of range&quot;);
 96   assert(_manager_array != NULL, &quot;Sanity&quot;);
 97   return &amp;_manager_array[index];
 98 }
 99 
100 PSPromotionManager* PSPromotionManager::vm_thread_promotion_manager() {
101   assert(_manager_array != NULL, &quot;Sanity&quot;);
102   return &amp;_manager_array[ParallelGCThreads];
103 }
104 
105 void PSPromotionManager::pre_scavenge() {
106   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
107 
108   _preserved_marks_set-&gt;assert_empty();
109   _young_space = heap-&gt;young_gen()-&gt;to_space();
110 
111   for(uint i=0; i&lt;ParallelGCThreads+1; i++) {
112     manager_array(i)-&gt;reset();
113   }
114 }
115 
116 bool PSPromotionManager::post_scavenge(YoungGCTracer&amp; gc_tracer) {
117   bool promotion_failure_occurred = false;
118 
119   TASKQUEUE_STATS_ONLY(print_taskqueue_stats());
120   for (uint i = 0; i &lt; ParallelGCThreads + 1; i++) {
121     PSPromotionManager* manager = manager_array(i);
122     assert(manager-&gt;claimed_stack_depth()-&gt;is_empty(), &quot;should be empty&quot;);
123     if (manager-&gt;_promotion_failed_info.has_failed()) {
124       gc_tracer.report_promotion_failed(manager-&gt;_promotion_failed_info);
125       promotion_failure_occurred = true;
126     }
127     manager-&gt;flush_labs();
128   }
129   if (!promotion_failure_occurred) {
130     // If there was no promotion failure, the preserved mark stacks
131     // should be empty.
132     _preserved_marks_set-&gt;assert_empty();
133   }
134   return promotion_failure_occurred;
135 }
136 
137 #if TASKQUEUE_STATS
138 void
139 PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {
140   #define FMT &quot; &quot; SIZE_FORMAT_W(10)
141   out-&gt;print_cr(&quot;%3u&quot; FMT FMT FMT FMT, i, _masked_pushes, _masked_steals,
142                 _arrays_chunked, _array_chunks_processed);
143   #undef FMT
144 }
145 
146 static const char* const pm_stats_hdr[] = {
147   &quot;    --------masked-------     arrays      array&quot;,
148   &quot;thr       push      steal    chunked     chunks&quot;,
149   &quot;--- ---------- ---------- ---------- ----------&quot;
150 };
151 
152 void
153 PSPromotionManager::print_taskqueue_stats() {
154   if (!log_is_enabled(Trace, gc, task, stats)) {
155     return;
156   }
157   Log(gc, task, stats) log;
158   ResourceMark rm;
159   LogStream ls(log.trace());
160   outputStream* out = &amp;ls;
161   out-&gt;print_cr(&quot;== GC Tasks Stats, GC %3d&quot;,
162                 ParallelScavengeHeap::heap()-&gt;total_collections());
163 
164   TaskQueueStats totals;
165   out-&gt;print(&quot;thr &quot;); TaskQueueStats::print_header(1, out); out-&gt;cr();
166   out-&gt;print(&quot;--- &quot;); TaskQueueStats::print_header(2, out); out-&gt;cr();
167   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
168     TaskQueueStats&amp; next = manager_array(i)-&gt;_claimed_stack_depth.stats;
169     out-&gt;print(&quot;%3d &quot;, i); next.print(out); out-&gt;cr();
170     totals += next;
171   }
172   out-&gt;print(&quot;tot &quot;); totals.print(out); out-&gt;cr();
173 
174   const uint hlines = sizeof(pm_stats_hdr) / sizeof(pm_stats_hdr[0]);
175   for (uint i = 0; i &lt; hlines; ++i) out-&gt;print_cr(&quot;%s&quot;, pm_stats_hdr[i]);
176   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
177     manager_array(i)-&gt;print_local_stats(out, i);
178   }
179 }
180 
181 void
182 PSPromotionManager::reset_stats() {
183   claimed_stack_depth()-&gt;stats.reset();
184   _masked_pushes = _masked_steals = 0;
185   _arrays_chunked = _array_chunks_processed = 0;
186 }
187 #endif // TASKQUEUE_STATS
188 
189 PSPromotionManager::PSPromotionManager() {
190   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
191 
192   // We set the old lab&#39;s start array.
193   _old_lab.set_start_array(old_gen()-&gt;start_array());
194 
195   uint queue_size;
196   claimed_stack_depth()-&gt;initialize();
197   queue_size = claimed_stack_depth()-&gt;max_elems();
198 
199   _totally_drain = (ParallelGCThreads == 1) || (GCDrainStackTargetSize == 0);
200   if (_totally_drain) {
201     _target_stack_size = 0;
202   } else {
203     // don&#39;t let the target stack size to be more than 1/4 of the entries
204     _target_stack_size = (uint) MIN2((uint) GCDrainStackTargetSize,
205                                      (uint) (queue_size / 4));
206   }
207 
208   _array_chunk_size = ParGCArrayScanChunk;
209   // let&#39;s choose 1.5x the chunk size
210   _min_array_size_for_chunking = 3 * _array_chunk_size / 2;
211 
212   _preserved_marks = NULL;
213 
214   reset();
215 }
216 
217 void PSPromotionManager::reset() {
218   assert(stacks_empty(), &quot;reset of non-empty stack&quot;);
219 
220   // We need to get an assert in here to make sure the labs are always flushed.
221 
222   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
223 
224   // Do not prefill the LAB&#39;s, save heap wastage!
225   HeapWord* lab_base = young_space()-&gt;top();
226   _young_lab.initialize(MemRegion(lab_base, (size_t)0));
227   _young_gen_is_full = false;
228 
229   lab_base = old_gen()-&gt;object_space()-&gt;top();
230   _old_lab.initialize(MemRegion(lab_base, (size_t)0));
231   _old_gen_is_full = false;
232 
233   _promotion_failed_info.reset();
234 
235   TASKQUEUE_STATS_ONLY(reset_stats());
236 }
237 
238 void PSPromotionManager::register_preserved_marks(PreservedMarks* preserved_marks) {
239   assert(_preserved_marks == NULL, &quot;do not set it twice&quot;);
240   _preserved_marks = preserved_marks;
241 }
242 
<a name="7" id="anc7"></a><span class="line-removed">243 class ParRestoreGCTask : public GCTask {</span>
<span class="line-removed">244 private:</span>
<span class="line-removed">245   const uint _id;</span>
<span class="line-removed">246   PreservedMarksSet* const _preserved_marks_set;</span>
<span class="line-removed">247   volatile size_t* const _total_size_addr;</span>
<span class="line-removed">248 </span>
<span class="line-removed">249 public:</span>
<span class="line-removed">250   virtual char* name() {</span>
<span class="line-removed">251     return (char*) &quot;preserved mark restoration task&quot;;</span>
<span class="line-removed">252   }</span>
<span class="line-removed">253 </span>
<span class="line-removed">254   virtual void do_it(GCTaskManager* manager, uint which){</span>
<span class="line-removed">255     _preserved_marks_set-&gt;get(_id)-&gt;restore_and_increment(_total_size_addr);</span>
<span class="line-removed">256   }</span>
<span class="line-removed">257 </span>
<span class="line-removed">258   ParRestoreGCTask(uint id,</span>
<span class="line-removed">259                    PreservedMarksSet* preserved_marks_set,</span>
<span class="line-removed">260                    volatile size_t* total_size_addr)</span>
<span class="line-removed">261     : _id(id),</span>
<span class="line-removed">262       _preserved_marks_set(preserved_marks_set),</span>
<span class="line-removed">263       _total_size_addr(total_size_addr) { }</span>
<span class="line-removed">264 };</span>
<span class="line-removed">265 </span>
<span class="line-removed">266 class PSRestorePreservedMarksTaskExecutor : public RestorePreservedMarksTaskExecutor {</span>
<span class="line-removed">267 private:</span>
<span class="line-removed">268   GCTaskManager* _gc_task_manager;</span>
<span class="line-removed">269 </span>
<span class="line-removed">270 public:</span>
<span class="line-removed">271   PSRestorePreservedMarksTaskExecutor(GCTaskManager* gc_task_manager)</span>
<span class="line-removed">272       : _gc_task_manager(gc_task_manager) { }</span>
<span class="line-removed">273 </span>
<span class="line-removed">274   void restore(PreservedMarksSet* preserved_marks_set,</span>
<span class="line-removed">275                volatile size_t* total_size_addr) {</span>
<span class="line-removed">276     // GCTask / GCTaskQueue are ResourceObjs</span>
<span class="line-removed">277     ResourceMark rm;</span>
<span class="line-removed">278 </span>
<span class="line-removed">279     GCTaskQueue* q = GCTaskQueue::create();</span>
<span class="line-removed">280     for (uint i = 0; i &lt; preserved_marks_set-&gt;num(); i += 1) {</span>
<span class="line-removed">281       q-&gt;enqueue(new ParRestoreGCTask(i, preserved_marks_set, total_size_addr));</span>
<span class="line-removed">282     }</span>
<span class="line-removed">283     _gc_task_manager-&gt;execute_and_wait(q);</span>
<span class="line-removed">284   }</span>
<span class="line-removed">285 };</span>
<span class="line-removed">286 </span>
287 void PSPromotionManager::restore_preserved_marks() {
<a name="8" id="anc8"></a><span class="line-modified">288   PSRestorePreservedMarksTaskExecutor task_executor(PSScavenge::gc_task_manager());</span>
<span class="line-removed">289   _preserved_marks_set-&gt;restore(&amp;task_executor);</span>
290 }
291 
292 void PSPromotionManager::drain_stacks_depth(bool totally_drain) {
293   totally_drain = totally_drain || _totally_drain;
294 
295 #ifdef ASSERT
296   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
297   MutableSpace* to_space = heap-&gt;young_gen()-&gt;to_space();
298   MutableSpace* old_space = heap-&gt;old_gen()-&gt;object_space();
299 #endif /* ASSERT */
300 
301   OopStarTaskQueue* const tq = claimed_stack_depth();
302   do {
303     StarTask p;
304 
305     // Drain overflow stack first, so other threads can steal from
306     // claimed stack while we work.
307     while (tq-&gt;pop_overflow(p)) {
308       process_popped_location_depth(p);
309     }
310 
311     if (totally_drain) {
312       while (tq-&gt;pop_local(p)) {
313         process_popped_location_depth(p);
314       }
315     } else {
316       while (tq-&gt;size() &gt; _target_stack_size &amp;&amp; tq-&gt;pop_local(p)) {
317         process_popped_location_depth(p);
318       }
319     }
320   } while ((totally_drain &amp;&amp; !tq-&gt;taskqueue_empty()) || !tq-&gt;overflow_empty());
321 
322   assert(!totally_drain || tq-&gt;taskqueue_empty(), &quot;Sanity&quot;);
323   assert(totally_drain || tq-&gt;size() &lt;= _target_stack_size, &quot;Sanity&quot;);
324   assert(tq-&gt;overflow_empty(), &quot;Sanity&quot;);
325 }
326 
327 void PSPromotionManager::flush_labs() {
328   assert(stacks_empty(), &quot;Attempt to flush lab with live stack&quot;);
329 
330   // If either promotion lab fills up, we can flush the
331   // lab but not refill it, so check first.
332   assert(!_young_lab.is_flushed() || _young_gen_is_full, &quot;Sanity&quot;);
333   if (!_young_lab.is_flushed())
334     _young_lab.flush();
335 
336   assert(!_old_lab.is_flushed() || _old_gen_is_full, &quot;Sanity&quot;);
337   if (!_old_lab.is_flushed())
338     _old_lab.flush();
339 
340   // Let PSScavenge know if we overflowed
341   if (_young_gen_is_full) {
342     PSScavenge::set_survivor_overflow(true);
343   }
344 }
345 
346 template &lt;class T&gt; void PSPromotionManager::process_array_chunk_work(
347                                                  oop obj,
348                                                  int start, int end) {
349   assert(start &lt;= end, &quot;invariant&quot;);
350   T* const base      = (T*)objArrayOop(obj)-&gt;base();
351   T* p               = base + start;
352   T* const chunk_end = base + end;
353   while (p &lt; chunk_end) {
354     if (PSScavenge::should_scavenge(p)) {
355       claim_or_forward_depth(p);
356     }
357     ++p;
358   }
359 }
360 
361 void PSPromotionManager::process_array_chunk(oop old) {
362   assert(PSChunkLargeArrays, &quot;invariant&quot;);
363   assert(old-&gt;is_objArray(), &quot;invariant&quot;);
364   assert(old-&gt;is_forwarded(), &quot;invariant&quot;);
365 
366   TASKQUEUE_STATS_ONLY(++_array_chunks_processed);
367 
368   oop const obj = old-&gt;forwardee();
369 
370   int start;
371   int const end = arrayOop(old)-&gt;length();
372   if (end &gt; (int) _min_array_size_for_chunking) {
373     // we&#39;ll chunk more
374     start = end - _array_chunk_size;
375     assert(start &gt; 0, &quot;invariant&quot;);
376     arrayOop(old)-&gt;set_length(start);
377     push_depth(mask_chunked_array_oop(old));
378     TASKQUEUE_STATS_ONLY(++_masked_pushes);
379   } else {
380     // this is the final chunk for this array
381     start = 0;
382     int const actual_length = arrayOop(obj)-&gt;length();
383     arrayOop(old)-&gt;set_length(actual_length);
384   }
385 
386   if (UseCompressedOops) {
387     process_array_chunk_work&lt;narrowOop&gt;(obj, start, end);
388   } else {
389     process_array_chunk_work&lt;oop&gt;(obj, start, end);
390   }
391 }
392 
<a name="9" id="anc9"></a><span class="line-modified">393 oop PSPromotionManager::oop_promotion_failed(oop obj, markOop obj_mark) {</span>
394   assert(_old_gen_is_full || PromotionFailureALot, &quot;Sanity&quot;);
395 
396   // Attempt to CAS in the header.
397   // This tests if the header is still the same as when
398   // this started.  If it is the same (i.e., no forwarding
399   // pointer has been installed), then this thread owns
400   // it.
401   if (obj-&gt;cas_forward_to(obj, obj_mark)) {
402     // We won any races, we &quot;own&quot; this object.
403     assert(obj == obj-&gt;forwardee(), &quot;Sanity&quot;);
404 
405     _promotion_failed_info.register_copy_failure(obj-&gt;size());
406 
407     push_contents(obj);
408 
409     _preserved_marks-&gt;push_if_necessary(obj, obj_mark);
410   }  else {
411     // We lost, someone else &quot;owns&quot; this object
412     guarantee(obj-&gt;is_forwarded(), &quot;Object must be forwarded if the cas failed.&quot;);
413 
414     // No unallocation to worry about.
415     obj = obj-&gt;forwardee();
416   }
417 
418   log_develop_trace(gc, scavenge)(&quot;{promotion-failure %s &quot; PTR_FORMAT &quot; (%d)}&quot;, obj-&gt;klass()-&gt;internal_name(), p2i(obj), obj-&gt;size());
419 
420   return obj;
421 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/gc/parallel/parallelArguments.cpp b/src/hotspot/share/gc/parallel/parallelArguments.cpp
--- a/src/hotspot/share/gc/parallel/parallelArguments.cpp
+++ b/src/hotspot/share/gc/parallel/parallelArguments.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -22,34 +22,32 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
-#include "gc/parallel/heterogeneousGenerationSizer.hpp"
 #include "gc/parallel/parallelArguments.hpp"
 #include "gc/parallel/parallelScavengeHeap.hpp"
 #include "gc/shared/adaptiveSizePolicy.hpp"
-#include "gc/shared/collectorPolicy.hpp"
-#include "gc/shared/gcArguments.inline.hpp"
+#include "gc/shared/gcArguments.hpp"
+#include "gc/shared/genArguments.hpp"
 #include "gc/shared/workerPolicy.hpp"
+#include "logging/log.hpp"
 #include "runtime/globals.hpp"
 #include "runtime/globals_extension.hpp"
 #include "runtime/java.hpp"
 #include "utilities/defaultStream.hpp"
+#include "utilities/powerOfTwo.hpp"
+
+static const double MaxRamFractionForYoung = 0.8;
 
 size_t ParallelArguments::conservative_max_heap_alignment() {
-  return CollectorPolicy::compute_heap_alignment();
+  return compute_heap_alignment();
 }
 
 void ParallelArguments::initialize() {
   GCArguments::initialize();
-  assert(UseParallelGC || UseParallelOldGC, "Error");
-  // Enable ParallelOld unless it was explicitly disabled (cmd line or rc file).
-  if (FLAG_IS_DEFAULT(UseParallelOldGC)) {
-    FLAG_SET_DEFAULT(UseParallelOldGC, true);
-  }
-  FLAG_SET_DEFAULT(UseParallelGC, true);
+  assert(UseParallelGC, "Error");
 
   // If no heap maximum was requested explicitly, use some reasonable fraction
   // of the physical memory, up to a maximum of 1GB.
   FLAG_SET_DEFAULT(ParallelGCThreads,
                    WorkerPolicy::parallel_worker_threads());
@@ -81,22 +79,139 @@
     if (FLAG_IS_DEFAULT(MinSurvivorRatio)) {
       FLAG_SET_DEFAULT(MinSurvivorRatio, SurvivorRatio + 2);
     }
   }
 
-  if (UseParallelOldGC) {
-    // Par compact uses lower default values since they are treated as
-    // minimums.  These are different defaults because of the different
-    // interpretation and are not ergonomically set.
-    if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {
-      FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);
-    }
+  // Par compact uses lower default values since they are treated as
+  // minimums.  These are different defaults because of the different
+  // interpretation and are not ergonomically set.
+  if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {
+    FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);
   }
 }
 
-CollectedHeap* ParallelArguments::create_heap() {
-  if (AllocateOldGenAt != NULL) {
-    return create_heap_with_policy<ParallelScavengeHeap, HeterogeneousGenerationSizer>();
+// The alignment used for boundary between young gen and old gen
+static size_t default_gen_alignment() {
+  return 64 * K * HeapWordSize;
+}
+
+void ParallelArguments::initialize_alignments() {
+  SpaceAlignment = GenAlignment = default_gen_alignment();
+  HeapAlignment = compute_heap_alignment();
+}
+
+void ParallelArguments::initialize_heap_flags_and_sizes_one_pass() {
+  // Do basic sizing work
+  GenArguments::initialize_heap_flags_and_sizes();
+
+  // The survivor ratio's are calculated "raw", unlike the
+  // default gc, which adds 2 to the ratio value. We need to
+  // make sure the values are valid before using them.
+  if (MinSurvivorRatio < 3) {
+    FLAG_SET_ERGO(MinSurvivorRatio, 3);
+  }
+
+  if (InitialSurvivorRatio < 3) {
+    FLAG_SET_ERGO(InitialSurvivorRatio, 3);
+  }
+}
+
+void ParallelArguments::initialize_heap_flags_and_sizes() {
+  if (is_heterogeneous_heap()) {
+    initialize_heterogeneous();
+  }
+
+  initialize_heap_flags_and_sizes_one_pass();
+
+  const size_t max_page_sz = os::page_size_for_region_aligned(MaxHeapSize, 8);
+  const size_t min_pages = 4; // 1 for eden + 1 for each survivor + 1 for old
+  const size_t min_page_sz = os::page_size_for_region_aligned(MinHeapSize, min_pages);
+  const size_t page_sz = MIN2(max_page_sz, min_page_sz);
+
+  // Can a page size be something else than a power of two?
+  assert(is_power_of_2((intptr_t)page_sz), "must be a power of 2");
+  size_t new_alignment = align_up(page_sz, GenAlignment);
+  if (new_alignment != GenAlignment) {
+    GenAlignment = new_alignment;
+    SpaceAlignment = new_alignment;
+    // Redo everything from the start
+    initialize_heap_flags_and_sizes_one_pass();
+  }
+}
+
+// Check the available dram memory to limit NewSize and MaxNewSize before
+// calling base class initialize_flags().
+void ParallelArguments::initialize_heterogeneous() {
+  FormatBuffer<100> calc_str("");
+
+  julong phys_mem;
+  // If MaxRam is specified, we use that as maximum physical memory available.
+  if (FLAG_IS_DEFAULT(MaxRAM)) {
+    phys_mem = os::physical_memory();
+    calc_str.append("Physical_Memory");
   } else {
-    return create_heap_with_policy<ParallelScavengeHeap, GenerationSizer>();
+    phys_mem = (julong)MaxRAM;
+    calc_str.append("MaxRAM");
   }
+
+  julong reasonable_max = phys_mem;
+
+  // If either MaxRAMFraction or MaxRAMPercentage is specified, we use them to calculate
+  // reasonable max size of young generation.
+  if (!FLAG_IS_DEFAULT(MaxRAMFraction)) {
+    reasonable_max = (julong)(phys_mem / MaxRAMFraction);
+    calc_str.append(" / MaxRAMFraction");
+  } else if (!FLAG_IS_DEFAULT(MaxRAMPercentage)) {
+    reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
+    calc_str.append(" * MaxRAMPercentage / 100");
+  } else {
+    // We use our own fraction to calculate max size of young generation.
+    reasonable_max = phys_mem * MaxRamFractionForYoung;
+    calc_str.append(" * %0.2f", MaxRamFractionForYoung);
+  }
+  reasonable_max = align_up(reasonable_max, GenAlignment);
+
+  if (MaxNewSize > reasonable_max) {
+    if (FLAG_IS_CMDLINE(MaxNewSize)) {
+      log_warning(gc, ergo)("Setting MaxNewSize to " SIZE_FORMAT " based on dram available (calculation = align(%s))",
+                            (size_t)reasonable_max, calc_str.buffer());
+    } else {
+      log_info(gc, ergo)("Setting MaxNewSize to " SIZE_FORMAT " based on dram available (calculation = align(%s)). "
+                         "Dram usage can be lowered by setting MaxNewSize to a lower value", (size_t)reasonable_max, calc_str.buffer());
+    }
+    MaxNewSize = reasonable_max;
+  }
+  if (NewSize > reasonable_max) {
+    if (FLAG_IS_CMDLINE(NewSize)) {
+      log_warning(gc, ergo)("Setting NewSize to " SIZE_FORMAT " based on dram available (calculation = align(%s))",
+                            (size_t)reasonable_max, calc_str.buffer());
+    }
+    NewSize = reasonable_max;
+  }
+}
+
+bool ParallelArguments::is_heterogeneous_heap() {
+  return AllocateOldGenAt != NULL;
+}
+
+size_t ParallelArguments::heap_reserved_size_bytes() {
+  if (!is_heterogeneous_heap() || !UseAdaptiveGCBoundary) {
+    return MaxHeapSize;
+  }
+
+  // Heterogeneous heap and adaptive size gc boundary
+
+  // This is the size that young gen can grow to, when UseAdaptiveGCBoundary is true.
+  size_t max_yg_size = MaxHeapSize - MinOldSize;
+  // This is the size that old gen can grow to, when UseAdaptiveGCBoundary is true.
+  size_t max_old_size = MaxHeapSize - MinNewSize;
+
+  return max_yg_size + max_old_size;
+}
+
+size_t ParallelArguments::heap_max_size_bytes() {
+  return MaxHeapSize;
+}
+
+CollectedHeap* ParallelArguments::create_heap() {
+  return new ParallelScavengeHeap();
 }

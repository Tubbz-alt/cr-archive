<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/epsilon/epsilonHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="epsilonBarrierSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="epsilonHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/epsilon/epsilonHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.
<span class="line-added">+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,27 ***</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/epsilon/epsilonHeap.hpp&quot;
  #include &quot;gc/epsilon/epsilonMemoryPool.hpp&quot;
  #include &quot;gc/epsilon/epsilonThreadLocalData.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  
  jint EpsilonHeap::initialize() {
<span class="line-modified">!   size_t align = _policy-&gt;heap_alignment();</span>
<span class="line-modified">!   size_t init_byte_size = align_up(_policy-&gt;initial_heap_byte_size(), align);</span>
<span class="line-modified">!   size_t max_byte_size  = align_up(_policy-&gt;max_heap_byte_size(), align);</span>
  
    // Initialize backing storage
<span class="line-modified">!   ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, align);</span>
    _virtual_space.initialize(heap_rs, init_byte_size);
  
    MemRegion committed_region((HeapWord*)_virtual_space.low(),          (HeapWord*)_virtual_space.high());
    MemRegion  reserved_region((HeapWord*)_virtual_space.low_boundary(), (HeapWord*)_virtual_space.high_boundary());
  
<span class="line-modified">!   initialize_reserved_region(reserved_region.start(), reserved_region.end());</span>
  
    _space = new ContiguousSpace();
    _space-&gt;initialize(committed_region, /* clear_space = */ true, /* mangle_space = */ true);
  
    // Precompute hot fields
<span class="line-new-header">--- 24,32 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/epsilon/epsilonHeap.hpp&quot;
  #include &quot;gc/epsilon/epsilonMemoryPool.hpp&quot;
  #include &quot;gc/epsilon/epsilonThreadLocalData.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added">+ #include &quot;runtime/globals.hpp&quot;</span>
  
  jint EpsilonHeap::initialize() {
<span class="line-modified">!   size_t align = HeapAlignment;</span>
<span class="line-modified">!   size_t init_byte_size = align_up(InitialHeapSize, align);</span>
<span class="line-modified">!   size_t max_byte_size  = align_up(MaxHeapSize, align);</span>
  
    // Initialize backing storage
<span class="line-modified">!   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, align);</span>
    _virtual_space.initialize(heap_rs, init_byte_size);
  
    MemRegion committed_region((HeapWord*)_virtual_space.low(),          (HeapWord*)_virtual_space.high());
    MemRegion  reserved_region((HeapWord*)_virtual_space.low_boundary(), (HeapWord*)_virtual_space.high_boundary());
  
<span class="line-modified">!   initialize_reserved_region(heap_rs);</span>
  
    _space = new ContiguousSpace();
    _space-&gt;initialize(committed_region, /* clear_space = */ true, /* mangle_space = */ true);
  
    // Precompute hot fields
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,12 ***</span>
    return memory_pools;
  }
  
  size_t EpsilonHeap::unsafe_max_tlab_alloc(Thread* thr) const {
    // Return max allocatable TLAB size, and let allocation path figure out
<span class="line-modified">!   // the actual TLAB allocation size.</span>
<span class="line-modified">!   return _max_tlab_size;</span>
  }
  
  EpsilonHeap* EpsilonHeap::heap() {
    CollectedHeap* heap = Universe::heap();
    assert(heap != NULL, &quot;Uninitialized access to EpsilonHeap::heap()&quot;);
<span class="line-new-header">--- 110,12 ---</span>
    return memory_pools;
  }
  
  size_t EpsilonHeap::unsafe_max_tlab_alloc(Thread* thr) const {
    // Return max allocatable TLAB size, and let allocation path figure out
<span class="line-modified">!   // the actual allocation size. Note: result should be in bytes.</span>
<span class="line-modified">!   return _max_tlab_size * HeapWordSize;</span>
  }
  
  EpsilonHeap* EpsilonHeap::heap() {
    CollectedHeap* heap = Universe::heap();
    assert(heap != NULL, &quot;Uninitialized access to EpsilonHeap::heap()&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,11 ***</span>
  
    HeapWord* res = _space-&gt;par_allocate(size);
  
    while (res == NULL) {
      // Allocation failed, attempt expansion, and retry:
<span class="line-modified">!     MutexLockerEx ml(Heap_lock);</span>
  
      size_t space_left = max_capacity() - capacity();
      size_t want_space = MAX2(size, EpsilonMinHeapExpand);
  
      if (want_space &lt; space_left) {
<span class="line-new-header">--- 128,11 ---</span>
  
    HeapWord* res = _space-&gt;par_allocate(size);
  
    while (res == NULL) {
      // Allocation failed, attempt expansion, and retry:
<span class="line-modified">!     MutexLocker ml(Heap_lock);</span>
  
      size_t space_left = max_capacity() - capacity();
      size_t want_space = MAX2(size, EpsilonMinHeapExpand);
  
      if (want_space &lt; space_left) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,19 ***</span>
    size_t used = _space-&gt;used();
  
    // Allocation successful, update counters
    {
      size_t last = _last_counter_update;
<span class="line-modified">!     if ((used - last &gt;= _step_counter_update) &amp;&amp; Atomic::cmpxchg(used, &amp;_last_counter_update, last) == last) {</span>
        _monitoring_support-&gt;update_counters();
      }
    }
  
    // ...and print the occupancy line, if needed
    {
      size_t last = _last_heap_print;
<span class="line-modified">!     if ((used - last &gt;= _step_heap_print) &amp;&amp; Atomic::cmpxchg(used, &amp;_last_heap_print, last) == last) {</span>
        print_heap_info(used);
        print_metaspace_info();
      }
    }
  
<span class="line-new-header">--- 156,19 ---</span>
    size_t used = _space-&gt;used();
  
    // Allocation successful, update counters
    {
      size_t last = _last_counter_update;
<span class="line-modified">!     if ((used - last &gt;= _step_counter_update) &amp;&amp; Atomic::cmpxchg(&amp;_last_counter_update, last, used) == last) {</span>
        _monitoring_support-&gt;update_counters();
      }
    }
  
    // ...and print the occupancy line, if needed
    {
      size_t last = _last_heap_print;
<span class="line-modified">!     if ((used - last &gt;= _step_heap_print) &amp;&amp; Atomic::cmpxchg(&amp;_last_heap_print, last, used) == last) {</span>
        print_heap_info(used);
        print_metaspace_info();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,11 ***</span>
        size = (size_t) (ergo_tlab * EpsilonTLABElasticity);
      }
    }
  
    // Always honor boundaries
<span class="line-modified">!   size = MAX2(min_size, MIN2(_max_tlab_size, size));</span>
  
    // Always honor alignment
    size = align_up(size, MinObjAlignment);
  
    // Check that adjustments did not break local and global invariants
<span class="line-new-header">--- 212,11 ---</span>
        size = (size_t) (ergo_tlab * EpsilonTLABElasticity);
      }
    }
  
    // Always honor boundaries
<span class="line-modified">!   size = clamp(size, min_size, _max_tlab_size);</span>
  
    // Always honor alignment
    size = align_up(size, MinObjAlignment);
  
    // Check that adjustments did not break local and global invariants
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,12 ***</span>
  
  void EpsilonHeap::do_full_collection(bool clear_all_soft_refs) {
    collect(gc_cause());
  }
  
<span class="line-modified">! void EpsilonHeap::safe_object_iterate(ObjectClosure *cl) {</span>
<span class="line-modified">!   _space-&gt;safe_object_iterate(cl);</span>
  }
  
  void EpsilonHeap::print_on(outputStream *st) const {
    st-&gt;print_cr(&quot;Epsilon Heap&quot;);
  
<span class="line-new-header">--- 290,12 ---</span>
  
  void EpsilonHeap::do_full_collection(bool clear_all_soft_refs) {
    collect(gc_cause());
  }
  
<span class="line-modified">! void EpsilonHeap::object_iterate(ObjectClosure *cl) {</span>
<span class="line-modified">!   _space-&gt;object_iterate(cl);</span>
  }
  
  void EpsilonHeap::print_on(outputStream *st) const {
    st-&gt;print_cr(&quot;Epsilon Heap&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,10 ***</span>
<span class="line-new-header">--- 306,14 ---</span>
    _space-&gt;print_on(st);
  
    MetaspaceUtils::print_on(st);
  }
  
<span class="line-added">+ bool EpsilonHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">+   return BlockLocationPrinter&lt;EpsilonHeap&gt;::print_location(st, addr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void EpsilonHeap::print_tracing_info() const {
    print_heap_info(used());
    print_metaspace_info();
  }
  
</pre>
<center><a href="epsilonBarrierSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="epsilonHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
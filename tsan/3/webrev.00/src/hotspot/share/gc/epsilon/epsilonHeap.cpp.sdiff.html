<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/epsilon/epsilonHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="epsilonBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="epsilonHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/epsilon/epsilonHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.

  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.
  7  *
  8  * This code is distributed in the hope that it will be useful, but WITHOUT
  9  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 10  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 11  * version 2 for more details (a copy is included in the LICENSE file that
 12  * accompanied this code).
 13  *
 14  * You should have received a copy of the GNU General Public License version
 15  * 2 along with this work; if not, write to the Free Software Foundation,
 16  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 17  *
 18  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 19  * or visit www.oracle.com if you need additional information or have any
 20  * questions.
 21  *
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/epsilon/epsilonHeap.hpp&quot;
 26 #include &quot;gc/epsilon/epsilonMemoryPool.hpp&quot;
 27 #include &quot;gc/epsilon/epsilonThreadLocalData.hpp&quot;


 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/resourceArea.hpp&quot;



 31 
 32 jint EpsilonHeap::initialize() {
<span class="line-modified"> 33   size_t align = _policy-&gt;heap_alignment();</span>
<span class="line-modified"> 34   size_t init_byte_size = align_up(_policy-&gt;initial_heap_byte_size(), align);</span>
<span class="line-modified"> 35   size_t max_byte_size  = align_up(_policy-&gt;max_heap_byte_size(), align);</span>
 36 
 37   // Initialize backing storage
<span class="line-modified"> 38   ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, align);</span>
 39   _virtual_space.initialize(heap_rs, init_byte_size);
 40 
 41   MemRegion committed_region((HeapWord*)_virtual_space.low(),          (HeapWord*)_virtual_space.high());
 42   MemRegion  reserved_region((HeapWord*)_virtual_space.low_boundary(), (HeapWord*)_virtual_space.high_boundary());
 43 
<span class="line-modified"> 44   initialize_reserved_region(reserved_region.start(), reserved_region.end());</span>
 45 
 46   _space = new ContiguousSpace();
 47   _space-&gt;initialize(committed_region, /* clear_space = */ true, /* mangle_space = */ true);
 48 
 49   // Precompute hot fields
 50   _max_tlab_size = MIN2(CollectedHeap::max_tlab_size(), align_object_size(EpsilonMaxTLABSize / HeapWordSize));
 51   _step_counter_update = MIN2&lt;size_t&gt;(max_byte_size / 16, EpsilonUpdateCountersStep);
 52   _step_heap_print = (EpsilonPrintHeapSteps == 0) ? SIZE_MAX : (max_byte_size / EpsilonPrintHeapSteps);
 53   _decay_time_ns = (int64_t) EpsilonTLABDecayTime * NANOSECS_PER_MILLISEC;
 54 
 55   // Enable monitoring
 56   _monitoring_support = new EpsilonMonitoringSupport(this);
 57   _last_counter_update = 0;
 58   _last_heap_print = 0;
 59 
 60   // Install barrier set
 61   BarrierSet::set_barrier_set(new EpsilonBarrierSet());
 62 
 63   // All done, print out the configuration
 64   if (init_byte_size != max_byte_size) {
</pre>
<hr />
<pre>
 89 
 90 void EpsilonHeap::initialize_serviceability() {
 91   _pool = new EpsilonMemoryPool(this);
 92   _memory_manager.add_pool(_pool);
 93 }
 94 
 95 GrowableArray&lt;GCMemoryManager*&gt; EpsilonHeap::memory_managers() {
 96   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(1);
 97   memory_managers.append(&amp;_memory_manager);
 98   return memory_managers;
 99 }
100 
101 GrowableArray&lt;MemoryPool*&gt; EpsilonHeap::memory_pools() {
102   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
103   memory_pools.append(_pool);
104   return memory_pools;
105 }
106 
107 size_t EpsilonHeap::unsafe_max_tlab_alloc(Thread* thr) const {
108   // Return max allocatable TLAB size, and let allocation path figure out
<span class="line-modified">109   // the actual TLAB allocation size.</span>
<span class="line-modified">110   return _max_tlab_size;</span>
111 }
112 
113 EpsilonHeap* EpsilonHeap::heap() {
114   CollectedHeap* heap = Universe::heap();
115   assert(heap != NULL, &quot;Uninitialized access to EpsilonHeap::heap()&quot;);
116   assert(heap-&gt;kind() == CollectedHeap::Epsilon, &quot;Not an Epsilon heap&quot;);
117   return (EpsilonHeap*)heap;
118 }
119 
120 HeapWord* EpsilonHeap::allocate_work(size_t size) {
121   assert(is_object_aligned(size), &quot;Allocation size should be aligned: &quot; SIZE_FORMAT, size);
122 
123   HeapWord* res = _space-&gt;par_allocate(size);
124 
125   while (res == NULL) {
126     // Allocation failed, attempt expansion, and retry:
<span class="line-modified">127     MutexLockerEx ml(Heap_lock);</span>
128 
129     size_t space_left = max_capacity() - capacity();
130     size_t want_space = MAX2(size, EpsilonMinHeapExpand);
131 
132     if (want_space &lt; space_left) {
133       // Enough space to expand in bulk:
134       bool expand = _virtual_space.expand_by(want_space);
135       assert(expand, &quot;Should be able to expand&quot;);
136     } else if (size &lt; space_left) {
137       // No space to expand in bulk, and this allocation is still possible,
138       // take all the remaining space:
139       bool expand = _virtual_space.expand_by(space_left);
140       assert(expand, &quot;Should be able to expand&quot;);
141     } else {
142       // No space left:
143       return NULL;
144     }
145 
146     _space-&gt;set_end((HeapWord *) _virtual_space.high());
147     res = _space-&gt;par_allocate(size);
148   }
149 
150   size_t used = _space-&gt;used();
151 
152   // Allocation successful, update counters
153   {
154     size_t last = _last_counter_update;
<span class="line-modified">155     if ((used - last &gt;= _step_counter_update) &amp;&amp; Atomic::cmpxchg(used, &amp;_last_counter_update, last) == last) {</span>
156       _monitoring_support-&gt;update_counters();
157     }
158   }
159 
160   // ...and print the occupancy line, if needed
161   {
162     size_t last = _last_heap_print;
<span class="line-modified">163     if ((used - last &gt;= _step_heap_print) &amp;&amp; Atomic::cmpxchg(used, &amp;_last_heap_print, last) == last) {</span>
164       print_heap_info(used);
165       print_metaspace_info();
166     }
167   }
168 
169   assert(is_object_aligned(res), &quot;Object should be aligned: &quot; PTR_FORMAT, p2i(res));
170   return res;
171 }
172 
173 HeapWord* EpsilonHeap::allocate_new_tlab(size_t min_size,
174                                          size_t requested_size,
175                                          size_t* actual_size) {
176   Thread* thread = Thread::current();
177 
178   // Defaults in case elastic paths are not taken
179   bool fits = true;
180   size_t size = requested_size;
181   size_t ergo_tlab = requested_size;
182   int64_t time = 0;
183 
</pre>
<hr />
<pre>
191       assert(last_time &lt;= time, &quot;time should be monotonic&quot;);
192 
193       // If the thread had not allocated recently, retract the ergonomic size.
194       // This conserves memory when the thread had initial burst of allocations,
195       // and then started allocating only sporadically.
196       if (last_time != 0 &amp;&amp; (time - last_time &gt; _decay_time_ns)) {
197         ergo_tlab = 0;
198         EpsilonThreadLocalData::set_ergo_tlab_size(thread, 0);
199       }
200     }
201 
202     // If we can fit the allocation under current TLAB size, do so.
203     // Otherwise, we want to elastically increase the TLAB size.
204     fits = (requested_size &lt;= ergo_tlab);
205     if (!fits) {
206       size = (size_t) (ergo_tlab * EpsilonTLABElasticity);
207     }
208   }
209 
210   // Always honor boundaries
<span class="line-modified">211   size = MAX2(min_size, MIN2(_max_tlab_size, size));</span>
212 
213   // Always honor alignment
214   size = align_up(size, MinObjAlignment);
215 
216   // Check that adjustments did not break local and global invariants
217   assert(is_object_aligned(size),
218          &quot;Size honors object alignment: &quot; SIZE_FORMAT, size);
219   assert(min_size &lt;= size,
220          &quot;Size honors min size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, min_size, size);
221   assert(size &lt;= _max_tlab_size,
222          &quot;Size honors max size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, size, _max_tlab_size);
223   assert(size &lt;= CollectedHeap::max_tlab_size(),
224          &quot;Size honors global max size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, size, CollectedHeap::max_tlab_size());
225 
226   if (log_is_enabled(Trace, gc)) {
227     ResourceMark rm;
228     log_trace(gc)(&quot;TLAB size for \&quot;%s\&quot; (Requested: &quot; SIZE_FORMAT &quot;K, Min: &quot; SIZE_FORMAT
229                           &quot;K, Max: &quot; SIZE_FORMAT &quot;K, Ergo: &quot; SIZE_FORMAT &quot;K) -&gt; &quot; SIZE_FORMAT &quot;K&quot;,
230                   thread-&gt;name(),
231                   requested_size * HeapWordSize / K,
</pre>
<hr />
<pre>
269     case GCCause::_metadata_GC_clear_soft_refs:
270       // Receiving these causes means the VM itself entered the safepoint for metadata collection.
271       // While Epsilon does not do GC, it has to perform sizing adjustments, otherwise we would
272       // re-enter the safepoint again very soon.
273 
274       assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected at safepoint&quot;);
275       log_info(gc)(&quot;GC request for \&quot;%s\&quot; is handled&quot;, GCCause::to_string(cause));
276       MetaspaceGC::compute_new_size();
277       print_metaspace_info();
278       break;
279     default:
280       log_info(gc)(&quot;GC request for \&quot;%s\&quot; is ignored&quot;, GCCause::to_string(cause));
281   }
282   _monitoring_support-&gt;update_counters();
283 }
284 
285 void EpsilonHeap::do_full_collection(bool clear_all_soft_refs) {
286   collect(gc_cause());
287 }
288 
<span class="line-modified">289 void EpsilonHeap::safe_object_iterate(ObjectClosure *cl) {</span>
<span class="line-modified">290   _space-&gt;safe_object_iterate(cl);</span>
291 }
292 
293 void EpsilonHeap::print_on(outputStream *st) const {
294   st-&gt;print_cr(&quot;Epsilon Heap&quot;);
295 
296   // Cast away constness:
297   ((VirtualSpace)_virtual_space).print_on(st);
298 
299   st-&gt;print_cr(&quot;Allocation space:&quot;);
300   _space-&gt;print_on(st);
301 
302   MetaspaceUtils::print_on(st);
303 }
304 




305 void EpsilonHeap::print_tracing_info() const {
306   print_heap_info(used());
307   print_metaspace_info();
308 }
309 
310 void EpsilonHeap::print_heap_info(size_t used) const {
311   size_t reserved  = max_capacity();
312   size_t committed = capacity();
313 
314   if (reserved != 0) {
315     log_info(gc)(&quot;Heap: &quot; SIZE_FORMAT &quot;%s reserved, &quot; SIZE_FORMAT &quot;%s (%.2f%%) committed, &quot;
316                  SIZE_FORMAT &quot;%s (%.2f%%) used&quot;,
317             byte_size_in_proper_unit(reserved),  proper_unit_for_byte_size(reserved),
318             byte_size_in_proper_unit(committed), proper_unit_for_byte_size(committed),
319             committed * 100.0 / reserved,
320             byte_size_in_proper_unit(used),      proper_unit_for_byte_size(used),
321             used * 100.0 / reserved);
322   } else {
323     log_info(gc)(&quot;Heap: no reliable data&quot;);
324   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.
<span class="line-added">  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span>
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/epsilon/epsilonHeap.hpp&quot;
 27 #include &quot;gc/epsilon/epsilonMemoryPool.hpp&quot;
 28 #include &quot;gc/epsilon/epsilonThreadLocalData.hpp&quot;
<span class="line-added"> 29 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 34 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 35 #include &quot;runtime/atomic.hpp&quot;</span>
<span class="line-added"> 36 #include &quot;runtime/globals.hpp&quot;</span>
 37 
 38 jint EpsilonHeap::initialize() {
<span class="line-modified"> 39   size_t align = HeapAlignment;</span>
<span class="line-modified"> 40   size_t init_byte_size = align_up(InitialHeapSize, align);</span>
<span class="line-modified"> 41   size_t max_byte_size  = align_up(MaxHeapSize, align);</span>
 42 
 43   // Initialize backing storage
<span class="line-modified"> 44   ReservedHeapSpace heap_rs = Universe::reserve_heap(max_byte_size, align);</span>
 45   _virtual_space.initialize(heap_rs, init_byte_size);
 46 
 47   MemRegion committed_region((HeapWord*)_virtual_space.low(),          (HeapWord*)_virtual_space.high());
 48   MemRegion  reserved_region((HeapWord*)_virtual_space.low_boundary(), (HeapWord*)_virtual_space.high_boundary());
 49 
<span class="line-modified"> 50   initialize_reserved_region(heap_rs);</span>
 51 
 52   _space = new ContiguousSpace();
 53   _space-&gt;initialize(committed_region, /* clear_space = */ true, /* mangle_space = */ true);
 54 
 55   // Precompute hot fields
 56   _max_tlab_size = MIN2(CollectedHeap::max_tlab_size(), align_object_size(EpsilonMaxTLABSize / HeapWordSize));
 57   _step_counter_update = MIN2&lt;size_t&gt;(max_byte_size / 16, EpsilonUpdateCountersStep);
 58   _step_heap_print = (EpsilonPrintHeapSteps == 0) ? SIZE_MAX : (max_byte_size / EpsilonPrintHeapSteps);
 59   _decay_time_ns = (int64_t) EpsilonTLABDecayTime * NANOSECS_PER_MILLISEC;
 60 
 61   // Enable monitoring
 62   _monitoring_support = new EpsilonMonitoringSupport(this);
 63   _last_counter_update = 0;
 64   _last_heap_print = 0;
 65 
 66   // Install barrier set
 67   BarrierSet::set_barrier_set(new EpsilonBarrierSet());
 68 
 69   // All done, print out the configuration
 70   if (init_byte_size != max_byte_size) {
</pre>
<hr />
<pre>
 95 
 96 void EpsilonHeap::initialize_serviceability() {
 97   _pool = new EpsilonMemoryPool(this);
 98   _memory_manager.add_pool(_pool);
 99 }
100 
101 GrowableArray&lt;GCMemoryManager*&gt; EpsilonHeap::memory_managers() {
102   GrowableArray&lt;GCMemoryManager*&gt; memory_managers(1);
103   memory_managers.append(&amp;_memory_manager);
104   return memory_managers;
105 }
106 
107 GrowableArray&lt;MemoryPool*&gt; EpsilonHeap::memory_pools() {
108   GrowableArray&lt;MemoryPool*&gt; memory_pools(1);
109   memory_pools.append(_pool);
110   return memory_pools;
111 }
112 
113 size_t EpsilonHeap::unsafe_max_tlab_alloc(Thread* thr) const {
114   // Return max allocatable TLAB size, and let allocation path figure out
<span class="line-modified">115   // the actual allocation size. Note: result should be in bytes.</span>
<span class="line-modified">116   return _max_tlab_size * HeapWordSize;</span>
117 }
118 
119 EpsilonHeap* EpsilonHeap::heap() {
120   CollectedHeap* heap = Universe::heap();
121   assert(heap != NULL, &quot;Uninitialized access to EpsilonHeap::heap()&quot;);
122   assert(heap-&gt;kind() == CollectedHeap::Epsilon, &quot;Not an Epsilon heap&quot;);
123   return (EpsilonHeap*)heap;
124 }
125 
126 HeapWord* EpsilonHeap::allocate_work(size_t size) {
127   assert(is_object_aligned(size), &quot;Allocation size should be aligned: &quot; SIZE_FORMAT, size);
128 
129   HeapWord* res = _space-&gt;par_allocate(size);
130 
131   while (res == NULL) {
132     // Allocation failed, attempt expansion, and retry:
<span class="line-modified">133     MutexLocker ml(Heap_lock);</span>
134 
135     size_t space_left = max_capacity() - capacity();
136     size_t want_space = MAX2(size, EpsilonMinHeapExpand);
137 
138     if (want_space &lt; space_left) {
139       // Enough space to expand in bulk:
140       bool expand = _virtual_space.expand_by(want_space);
141       assert(expand, &quot;Should be able to expand&quot;);
142     } else if (size &lt; space_left) {
143       // No space to expand in bulk, and this allocation is still possible,
144       // take all the remaining space:
145       bool expand = _virtual_space.expand_by(space_left);
146       assert(expand, &quot;Should be able to expand&quot;);
147     } else {
148       // No space left:
149       return NULL;
150     }
151 
152     _space-&gt;set_end((HeapWord *) _virtual_space.high());
153     res = _space-&gt;par_allocate(size);
154   }
155 
156   size_t used = _space-&gt;used();
157 
158   // Allocation successful, update counters
159   {
160     size_t last = _last_counter_update;
<span class="line-modified">161     if ((used - last &gt;= _step_counter_update) &amp;&amp; Atomic::cmpxchg(&amp;_last_counter_update, last, used) == last) {</span>
162       _monitoring_support-&gt;update_counters();
163     }
164   }
165 
166   // ...and print the occupancy line, if needed
167   {
168     size_t last = _last_heap_print;
<span class="line-modified">169     if ((used - last &gt;= _step_heap_print) &amp;&amp; Atomic::cmpxchg(&amp;_last_heap_print, last, used) == last) {</span>
170       print_heap_info(used);
171       print_metaspace_info();
172     }
173   }
174 
175   assert(is_object_aligned(res), &quot;Object should be aligned: &quot; PTR_FORMAT, p2i(res));
176   return res;
177 }
178 
179 HeapWord* EpsilonHeap::allocate_new_tlab(size_t min_size,
180                                          size_t requested_size,
181                                          size_t* actual_size) {
182   Thread* thread = Thread::current();
183 
184   // Defaults in case elastic paths are not taken
185   bool fits = true;
186   size_t size = requested_size;
187   size_t ergo_tlab = requested_size;
188   int64_t time = 0;
189 
</pre>
<hr />
<pre>
197       assert(last_time &lt;= time, &quot;time should be monotonic&quot;);
198 
199       // If the thread had not allocated recently, retract the ergonomic size.
200       // This conserves memory when the thread had initial burst of allocations,
201       // and then started allocating only sporadically.
202       if (last_time != 0 &amp;&amp; (time - last_time &gt; _decay_time_ns)) {
203         ergo_tlab = 0;
204         EpsilonThreadLocalData::set_ergo_tlab_size(thread, 0);
205       }
206     }
207 
208     // If we can fit the allocation under current TLAB size, do so.
209     // Otherwise, we want to elastically increase the TLAB size.
210     fits = (requested_size &lt;= ergo_tlab);
211     if (!fits) {
212       size = (size_t) (ergo_tlab * EpsilonTLABElasticity);
213     }
214   }
215 
216   // Always honor boundaries
<span class="line-modified">217   size = clamp(size, min_size, _max_tlab_size);</span>
218 
219   // Always honor alignment
220   size = align_up(size, MinObjAlignment);
221 
222   // Check that adjustments did not break local and global invariants
223   assert(is_object_aligned(size),
224          &quot;Size honors object alignment: &quot; SIZE_FORMAT, size);
225   assert(min_size &lt;= size,
226          &quot;Size honors min size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, min_size, size);
227   assert(size &lt;= _max_tlab_size,
228          &quot;Size honors max size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, size, _max_tlab_size);
229   assert(size &lt;= CollectedHeap::max_tlab_size(),
230          &quot;Size honors global max size: &quot;  SIZE_FORMAT &quot; &lt;= &quot; SIZE_FORMAT, size, CollectedHeap::max_tlab_size());
231 
232   if (log_is_enabled(Trace, gc)) {
233     ResourceMark rm;
234     log_trace(gc)(&quot;TLAB size for \&quot;%s\&quot; (Requested: &quot; SIZE_FORMAT &quot;K, Min: &quot; SIZE_FORMAT
235                           &quot;K, Max: &quot; SIZE_FORMAT &quot;K, Ergo: &quot; SIZE_FORMAT &quot;K) -&gt; &quot; SIZE_FORMAT &quot;K&quot;,
236                   thread-&gt;name(),
237                   requested_size * HeapWordSize / K,
</pre>
<hr />
<pre>
275     case GCCause::_metadata_GC_clear_soft_refs:
276       // Receiving these causes means the VM itself entered the safepoint for metadata collection.
277       // While Epsilon does not do GC, it has to perform sizing adjustments, otherwise we would
278       // re-enter the safepoint again very soon.
279 
280       assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected at safepoint&quot;);
281       log_info(gc)(&quot;GC request for \&quot;%s\&quot; is handled&quot;, GCCause::to_string(cause));
282       MetaspaceGC::compute_new_size();
283       print_metaspace_info();
284       break;
285     default:
286       log_info(gc)(&quot;GC request for \&quot;%s\&quot; is ignored&quot;, GCCause::to_string(cause));
287   }
288   _monitoring_support-&gt;update_counters();
289 }
290 
291 void EpsilonHeap::do_full_collection(bool clear_all_soft_refs) {
292   collect(gc_cause());
293 }
294 
<span class="line-modified">295 void EpsilonHeap::object_iterate(ObjectClosure *cl) {</span>
<span class="line-modified">296   _space-&gt;object_iterate(cl);</span>
297 }
298 
299 void EpsilonHeap::print_on(outputStream *st) const {
300   st-&gt;print_cr(&quot;Epsilon Heap&quot;);
301 
302   // Cast away constness:
303   ((VirtualSpace)_virtual_space).print_on(st);
304 
305   st-&gt;print_cr(&quot;Allocation space:&quot;);
306   _space-&gt;print_on(st);
307 
308   MetaspaceUtils::print_on(st);
309 }
310 
<span class="line-added">311 bool EpsilonHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">312   return BlockLocationPrinter&lt;EpsilonHeap&gt;::print_location(st, addr);</span>
<span class="line-added">313 }</span>
<span class="line-added">314 </span>
315 void EpsilonHeap::print_tracing_info() const {
316   print_heap_info(used());
317   print_metaspace_info();
318 }
319 
320 void EpsilonHeap::print_heap_info(size_t used) const {
321   size_t reserved  = max_capacity();
322   size_t committed = capacity();
323 
324   if (reserved != 0) {
325     log_info(gc)(&quot;Heap: &quot; SIZE_FORMAT &quot;%s reserved, &quot; SIZE_FORMAT &quot;%s (%.2f%%) committed, &quot;
326                  SIZE_FORMAT &quot;%s (%.2f%%) used&quot;,
327             byte_size_in_proper_unit(reserved),  proper_unit_for_byte_size(reserved),
328             byte_size_in_proper_unit(committed), proper_unit_for_byte_size(committed),
329             committed * 100.0 / reserved,
330             byte_size_in_proper_unit(used),      proper_unit_for_byte_size(used),
331             used * 100.0 / reserved);
332   } else {
333     log_info(gc)(&quot;Heap: no reliable data&quot;);
334   }
</pre>
</td>
</tr>
</table>
<center><a href="epsilonBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="epsilonHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
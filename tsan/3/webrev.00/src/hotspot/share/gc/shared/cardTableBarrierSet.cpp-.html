<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/cardTableBarrierSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/cardTable.hpp&quot;
 27 #include &quot;gc/shared/cardTableBarrierSetAssembler.hpp&quot;
 28 #include &quot;gc/shared/cardTableBarrierSet.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/space.inline.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/virtualspace.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;services/memTracker.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;gc/shared/c1/cardTableBarrierSetC1.hpp&quot;
 40 #endif
 41 #ifdef COMPILER2
 42 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 43 #endif
 44 
 45 class CardTableBarrierSetC1;
 46 class CardTableBarrierSetC2;
 47 
 48 // This kind of &quot;BarrierSet&quot; allows a &quot;CollectedHeap&quot; to detect and
 49 // enumerate ref fields that have been modified (since the last
 50 // enumeration.)
 51 
 52 CardTableBarrierSet::CardTableBarrierSet(BarrierSetAssembler* barrier_set_assembler,
 53                                          BarrierSetC1* barrier_set_c1,
 54                                          BarrierSetC2* barrier_set_c2,
 55                                          CardTable* card_table,
 56                                          const BarrierSet::FakeRtti&amp; fake_rtti) :
 57   ModRefBarrierSet(barrier_set_assembler,
 58                    barrier_set_c1,
 59                    barrier_set_c2,
 60                    fake_rtti.add_tag(BarrierSet::CardTableBarrierSet)),
 61   _defer_initial_card_mark(false),
 62   _card_table(card_table)
 63 {}
 64 
 65 CardTableBarrierSet::CardTableBarrierSet(CardTable* card_table) :
 66   ModRefBarrierSet(make_barrier_set_assembler&lt;CardTableBarrierSetAssembler&gt;(),
 67                    make_barrier_set_c1&lt;CardTableBarrierSetC1&gt;(),
 68                    make_barrier_set_c2&lt;CardTableBarrierSetC2&gt;(),
 69                    BarrierSet::FakeRtti(BarrierSet::CardTableBarrierSet)),
 70   _defer_initial_card_mark(false),
 71   _card_table(card_table)
 72 {}
 73 
 74 void CardTableBarrierSet::initialize() {
 75   initialize_deferred_card_mark_barriers();
 76 }
 77 
 78 CardTableBarrierSet::~CardTableBarrierSet() {
 79   delete _card_table;
 80 }
 81 
 82 void CardTableBarrierSet::write_ref_array_work(MemRegion mr) {
 83   _card_table-&gt;dirty_MemRegion(mr);
 84 }
 85 
 86 void CardTableBarrierSet::invalidate(MemRegion mr) {
 87   _card_table-&gt;invalidate(mr);
 88 }
 89 
 90 void CardTableBarrierSet::print_on(outputStream* st) const {
 91   _card_table-&gt;print_on(st);
 92 }
 93 
 94 // Helper for ReduceInitialCardMarks. For performance,
 95 // compiled code may elide card-marks for initializing stores
 96 // to a newly allocated object along the fast-path. We
 97 // compensate for such elided card-marks as follows:
 98 // (a) Generational, non-concurrent collectors, such as
 99 //     GenCollectedHeap(ParNew,DefNew,Tenured) and
100 //     ParallelScavengeHeap(ParallelGC, ParallelOldGC)
101 //     need the card-mark if and only if the region is
102 //     in the old gen, and do not care if the card-mark
103 //     succeeds or precedes the initializing stores themselves,
104 //     so long as the card-mark is completed before the next
105 //     scavenge. For all these cases, we can do a card mark
106 //     at the point at which we do a slow path allocation
107 //     in the old gen, i.e. in this call.
108 // (b) GenCollectedHeap(ConcurrentMarkSweepGeneration) requires
109 //     in addition that the card-mark for an old gen allocated
110 //     object strictly follow any associated initializing stores.
111 //     In these cases, the memRegion remembered below is
112 //     used to card-mark the entire region either just before the next
113 //     slow-path allocation by this thread or just before the next scavenge or
114 //     CMS-associated safepoint, whichever of these events happens first.
115 //     (The implicit assumption is that the object has been fully
116 //     initialized by this point, a fact that we assert when doing the
117 //     card-mark.)
118 // (c) G1CollectedHeap(G1) uses two kinds of write barriers. When a
119 //     G1 concurrent marking is in progress an SATB (pre-write-)barrier
120 //     is used to remember the pre-value of any store. Initializing
121 //     stores will not need this barrier, so we need not worry about
122 //     compensating for the missing pre-barrier here. Turning now
123 //     to the post-barrier, we note that G1 needs a RS update barrier
124 //     which simply enqueues a (sequence of) dirty cards which may
125 //     optionally be refined by the concurrent update threads. Note
126 //     that this barrier need only be applied to a non-young write,
127 //     but, like in CMS, because of the presence of concurrent refinement
128 //     (much like CMS&#39; precleaning), must strictly follow the oop-store.
129 //     Thus, using the same protocol for maintaining the intended
130 //     invariants turns out, serendepitously, to be the same for both
131 //     G1 and CMS.
132 //
133 // For any future collector, this code should be reexamined with
134 // that specific collector in mind, and the documentation above suitably
135 // extended and updated.
136 void CardTableBarrierSet::on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {
137 #if COMPILER2_OR_JVMCI
138   if (!ReduceInitialCardMarks) {
139     return;
140   }
141   // If a previous card-mark was deferred, flush it now.
142   flush_deferred_card_mark_barrier(thread);
143   if (new_obj-&gt;is_typeArray() || _card_table-&gt;is_in_young(new_obj)) {
144     // Arrays of non-references don&#39;t need a post-barrier.
145     // The deferred_card_mark region should be empty
146     // following the flush above.
147     assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Error&quot;);
148   } else {
149     MemRegion mr((HeapWord*)new_obj, new_obj-&gt;size());
150     assert(!mr.is_empty(), &quot;Error&quot;);
151     if (_defer_initial_card_mark) {
152       // Defer the card mark
153       thread-&gt;set_deferred_card_mark(mr);
154     } else {
155       // Do the card mark
156       invalidate(mr);
157     }
158   }
159 #endif // COMPILER2_OR_JVMCI
160 }
161 
162 void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {
163   // Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);
164   // otherwise remains unused.
165 #if COMPILER2_OR_JVMCI
166   _defer_initial_card_mark = is_server_compilation_mode_vm() &amp;&amp; ReduceInitialCardMarks
167                              &amp;&amp; (DeferInitialCardMark || card_mark_must_follow_store());
168 #else
169   assert(_defer_initial_card_mark == false, &quot;Who would set it?&quot;);
170 #endif
171 }
172 
173 void CardTableBarrierSet::flush_deferred_card_mark_barrier(JavaThread* thread) {
174 #if COMPILER2_OR_JVMCI
175   MemRegion deferred = thread-&gt;deferred_card_mark();
176   if (!deferred.is_empty()) {
177     assert(_defer_initial_card_mark, &quot;Otherwise should be empty&quot;);
178     {
179       // Verify that the storage points to a parsable object in heap
180       DEBUG_ONLY(oop old_obj = oop(deferred.start());)
181       assert(!_card_table-&gt;is_in_young(old_obj),
182              &quot;Else should have been filtered in on_slowpath_allocation_exit()&quot;);
183       assert(oopDesc::is_oop(old_obj, true), &quot;Not an oop&quot;);
184       assert(deferred.word_size() == (size_t)(old_obj-&gt;size()),
185              &quot;Mismatch: multiple objects?&quot;);
186     }
187     write_region(deferred);
188     // &quot;Clear&quot; the deferred_card_mark field
189     thread-&gt;set_deferred_card_mark(MemRegion());
190   }
191   assert(thread-&gt;deferred_card_mark().is_empty(), &quot;invariant&quot;);
192 #else
193   assert(!_defer_initial_card_mark, &quot;Should be false&quot;);
194   assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Should be empty&quot;);
195 #endif
196 }
197 
198 void CardTableBarrierSet::on_thread_detach(Thread* thread) {
199   // The deferred store barriers must all have been flushed to the
200   // card-table (or other remembered set structure) before GC starts
201   // processing the card-table (or other remembered set).
202   if (thread-&gt;is_Java_thread()) { // Only relevant for Java threads.
203     flush_deferred_card_mark_barrier((JavaThread*)thread);
204   }
205 }
206 
207 bool CardTableBarrierSet::card_mark_must_follow_store() const {
208  return _card_table-&gt;scanned_concurrently();
209 }
    </pre>
  </body>
</html>
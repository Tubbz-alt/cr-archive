diff a/src/hotspot/share/gc/shared/concurrentGCPhaseManager.cpp b/src/hotspot/share/gc/shared/concurrentGCPhaseManager.cpp
--- a/src/hotspot/share/gc/shared/concurrentGCPhaseManager.cpp
+++ b/src/hotspot/share/gc/shared/concurrentGCPhaseManager.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -48,75 +48,75 @@
   _stack(stack)
 {
   assert_ConcurrentGC_thread();
   assert_not_enter_unconstrained(phase);
   assert(stack != NULL, "precondition");
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   if (stack->_top != NULL) {
     assert(stack->_top->_active, "precondition");
     _prev = stack->_top;
   }
   stack->_top = this;
   ml.notify_all();
 }
 
 ConcurrentGCPhaseManager::~ConcurrentGCPhaseManager() {
   assert_ConcurrentGC_thread();
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   assert_manager_is_tos(this, _stack, "This");
   wait_when_requested_impl();
   _stack->_top = _prev;
   ml.notify_all();
 }
 
 bool ConcurrentGCPhaseManager::is_requested() const {
   assert_ConcurrentGC_thread();
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   assert_manager_is_tos(this, _stack, "This");
   return _active && (_stack->_requested_phase == _phase);
 }
 
 bool ConcurrentGCPhaseManager::wait_when_requested_impl() const {
   assert_ConcurrentGC_thread();
   assert_lock_strong(CGCPhaseManager_lock);
   bool waited = false;
   while (_active && (_stack->_requested_phase == _phase)) {
     waited = true;
-    CGCPhaseManager_lock->wait(Mutex::_no_safepoint_check_flag);
+    CGCPhaseManager_lock->wait_without_safepoint_check();
   }
   return waited;
 }
 
 bool ConcurrentGCPhaseManager::wait_when_requested() const {
   assert_ConcurrentGC_thread();
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   assert_manager_is_tos(this, _stack, "This");
   return wait_when_requested_impl();
 }
 
 void ConcurrentGCPhaseManager::set_phase(int phase, bool force) {
   assert_ConcurrentGC_thread();
   assert_not_enter_unconstrained(phase);
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   assert_manager_is_tos(this, _stack, "This");
   if (!force) wait_when_requested_impl();
   _phase = phase;
   ml.notify_all();
 }
 
 void ConcurrentGCPhaseManager::deactivate() {
   assert_ConcurrentGC_thread();
-  MonitorLockerEx ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(CGCPhaseManager_lock, Mutex::_no_safepoint_check_flag);
   assert_manager_is_tos(this, _stack, "This");
   _active = false;
   ml.notify_all();
 }
 
 bool ConcurrentGCPhaseManager::wait_for_phase(int phase, Stack* stack) {
   assert(Thread::current()->is_Java_thread(), "precondition");
   assert(stack != NULL, "precondition");
-  MonitorLockerEx ml(CGCPhaseManager_lock);
+  MonitorLocker ml(CGCPhaseManager_lock);
   // Update request and notify service of change.
   if (stack->_requested_phase != phase) {
     stack->_requested_phase = phase;
     ml.notify_all();
   }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/oopStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="modRefBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/oopStorage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  27 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;logging/logStream.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;runtime/atomic.hpp&quot;
  32 #include &quot;runtime/globals.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  35 #include &quot;runtime/mutex.hpp&quot;
  36 #include &quot;runtime/mutexLocker.hpp&quot;
  37 #include &quot;runtime/orderAccess.hpp&quot;

  38 #include &quot;runtime/safepoint.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;runtime/thread.hpp&quot;
  41 #include &quot;utilities/align.hpp&quot;
  42 #include &quot;utilities/count_trailing_zeros.hpp&quot;
  43 #include &quot;utilities/debug.hpp&quot;
  44 #include &quot;utilities/globalDefinitions.hpp&quot;
  45 #include &quot;utilities/macros.hpp&quot;
  46 #include &quot;utilities/ostream.hpp&quot;

  47 
  48 OopStorage::AllocationListEntry::AllocationListEntry() : _prev(NULL), _next(NULL) {}
  49 
  50 OopStorage::AllocationListEntry::~AllocationListEntry() {
  51   assert(_prev == NULL, &quot;deleting attached block&quot;);
  52   assert(_next == NULL, &quot;deleting attached block&quot;);
  53 }
  54 
  55 OopStorage::AllocationList::AllocationList() : _head(NULL), _tail(NULL) {}
  56 
  57 OopStorage::AllocationList::~AllocationList() {
  58   // ~OopStorage() empties its lists before destroying them.
  59   assert(_head == NULL, &quot;deleting non-empty block list&quot;);
  60   assert(_tail == NULL, &quot;deleting non-empty block list&quot;);
  61 }
  62 
  63 void OopStorage::AllocationList::push_front(const Block&amp; block) {
  64   const Block* old = _head;
  65   if (old == NULL) {
  66     assert(_tail == NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 122   size_t size_in_bytes = blocks_offset() + sizeof(Block*) * size;
 123   void* mem = NEW_C_HEAP_ARRAY3(char, size_in_bytes, mtGC, CURRENT_PC, alloc_fail);
 124   if (mem == NULL) return NULL;
 125   return new (mem) ActiveArray(size);
 126 }
 127 
 128 void OopStorage::ActiveArray::destroy(ActiveArray* ba) {
 129   ba-&gt;~ActiveArray();
 130   FREE_C_HEAP_ARRAY(char, ba);
 131 }
 132 
 133 size_t OopStorage::ActiveArray::size() const {
 134   return _size;
 135 }
 136 
 137 size_t OopStorage::ActiveArray::block_count() const {
 138   return _block_count;
 139 }
 140 
 141 size_t OopStorage::ActiveArray::block_count_acquire() const {
<span class="line-modified"> 142   return OrderAccess::load_acquire(&amp;_block_count);</span>
 143 }
 144 
 145 void OopStorage::ActiveArray::increment_refcount() const {
<span class="line-modified"> 146   int new_value = Atomic::add(1, &amp;_refcount);</span>
 147   assert(new_value &gt;= 1, &quot;negative refcount %d&quot;, new_value - 1);
 148 }
 149 
 150 bool OopStorage::ActiveArray::decrement_refcount() const {
<span class="line-modified"> 151   int new_value = Atomic::sub(1, &amp;_refcount);</span>
 152   assert(new_value &gt;= 0, &quot;negative refcount %d&quot;, new_value);
 153   return new_value == 0;
 154 }
 155 
 156 bool OopStorage::ActiveArray::push(Block* block) {
 157   size_t index = _block_count;
 158   if (index &lt; _size) {
 159     block-&gt;set_active_index(index);
 160     *block_ptr(index) = block;
 161     // Use a release_store to ensure all the setup is complete before
 162     // making the block visible.
<span class="line-modified"> 163     OrderAccess::release_store(&amp;_block_count, index + 1);</span>
 164     return true;
 165   } else {
 166     return false;
 167   }
 168 }
 169 
 170 void OopStorage::ActiveArray::remove(Block* block) {
 171   assert(_block_count &gt; 0, &quot;array is empty&quot;);
 172   size_t index = block-&gt;active_index();
 173   assert(*block_ptr(index) == block, &quot;block not present&quot;);
 174   size_t last_index = _block_count - 1;
 175   Block* last_block = *block_ptr(last_index);
 176   last_block-&gt;set_active_index(index);
 177   *block_ptr(index) = last_block;
 178   _block_count = last_index;
 179 }
 180 
 181 void OopStorage::ActiveArray::copy_from(const ActiveArray* from) {
 182   assert(_block_count == 0, &quot;array must be empty&quot;);
 183   size_t count = from-&gt;_block_count;
</pre>
<hr />
<pre>
 190     *to_ptr++ = block;
 191   }
 192   _block_count = count;
 193 }
 194 
 195 // Blocks start with an array of BitsPerWord oop entries.  That array
 196 // is divided into conceptual BytesPerWord sections of BitsPerByte
 197 // entries.  Blocks are allocated aligned on section boundaries, for
 198 // the convenience of mapping from an entry to the containing block;
 199 // see block_for_ptr().  Aligning on section boundary rather than on
 200 // the full _data wastes a lot less space, but makes for a bit more
 201 // work in block_for_ptr().
 202 
 203 const unsigned section_size = BitsPerByte;
 204 const unsigned section_count = BytesPerWord;
 205 const unsigned block_alignment = sizeof(oop) * section_size;
 206 
 207 OopStorage::Block::Block(const OopStorage* owner, void* memory) :
 208   _data(),
 209   _allocated_bitmask(0),
<span class="line-modified"> 210   _owner(owner),</span>
 211   _memory(memory),
 212   _active_index(0),
 213   _allocation_list_entry(),
 214   _deferred_updates_next(NULL),
 215   _release_refcount(0)
 216 {
 217   STATIC_ASSERT(_data_pos == 0);
 218   STATIC_ASSERT(section_size * section_count == ARRAY_SIZE(_data));
 219   assert(offset_of(Block, _data) == _data_pos, &quot;invariant&quot;);
 220   assert(owner != NULL, &quot;NULL owner&quot;);
 221   assert(is_aligned(this, block_alignment), &quot;misaligned block&quot;);
 222 }
 223 
 224 OopStorage::Block::~Block() {
 225   assert(_release_refcount == 0, &quot;deleting block while releasing&quot;);
 226   assert(_deferred_updates_next == NULL, &quot;deleting block with deferred update&quot;);
 227   // Clear fields used by block_for_ptr and entry validation, which
 228   // might help catch bugs.  Volatile to prevent dead-store elimination.
 229   const_cast&lt;uintx volatile&amp;&gt;(_allocated_bitmask) = 0;
<span class="line-modified"> 230   const_cast&lt;OopStorage* volatile&amp;&gt;(_owner) = NULL;</span>
 231 }
 232 
 233 size_t OopStorage::Block::allocation_size() {
 234   // _data must be first member, so aligning Block aligns _data.
 235   STATIC_ASSERT(_data_pos == 0);
 236   return sizeof(Block) + block_alignment - sizeof(void*);
 237 }
 238 
 239 size_t OopStorage::Block::allocation_alignment_shift() {
 240   return exact_log2(block_alignment);
 241 }
 242 
 243 inline bool is_full_bitmask(uintx bitmask) { return ~bitmask == 0; }
 244 inline bool is_empty_bitmask(uintx bitmask) { return bitmask == 0; }
 245 
 246 bool OopStorage::Block::is_full() const {
 247   return is_full_bitmask(allocated_bitmask());
 248 }
 249 
 250 bool OopStorage::Block::is_empty() const {
 251   return is_empty_bitmask(allocated_bitmask());
 252 }
 253 
 254 uintx OopStorage::Block::bitmask_for_entry(const oop* ptr) const {
 255   return bitmask_for_index(get_index(ptr));
 256 }
 257 
 258 // An empty block is not yet deletable if either:
 259 // (1) There is a release() operation currently operating on it.
 260 // (2) It is in the deferred updates list.
 261 // For interaction with release(), these must follow the empty check,
 262 // and the order of these checks is important.
 263 bool OopStorage::Block::is_safe_to_delete() const {
 264   assert(is_empty(), &quot;precondition&quot;);
 265   OrderAccess::loadload();
<span class="line-modified"> 266   return (OrderAccess::load_acquire(&amp;_release_refcount) == 0) &amp;&amp;</span>
<span class="line-modified"> 267          (OrderAccess::load_acquire(&amp;_deferred_updates_next) == NULL);</span>
 268 }
 269 
 270 OopStorage::Block* OopStorage::Block::deferred_updates_next() const {
 271   return _deferred_updates_next;
 272 }
 273 
 274 void OopStorage::Block::set_deferred_updates_next(Block* block) {
 275   _deferred_updates_next = block;
 276 }
 277 
 278 bool OopStorage::Block::contains(const oop* ptr) const {
 279   const oop* base = get_pointer(0);
 280   return (base &lt;= ptr) &amp;&amp; (ptr &lt; (base + ARRAY_SIZE(_data)));
 281 }
 282 
 283 size_t OopStorage::Block::active_index() const {
 284   return _active_index;
 285 }
 286 
 287 void OopStorage::Block::set_active_index(size_t index) {
</pre>
<hr />
<pre>
 289 }
 290 
 291 size_t OopStorage::Block::active_index_safe(const Block* block) {
 292   STATIC_ASSERT(sizeof(intptr_t) == sizeof(block-&gt;_active_index));
 293   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 294   return SafeFetchN((intptr_t*)&amp;block-&gt;_active_index, 0);
 295 }
 296 
 297 unsigned OopStorage::Block::get_index(const oop* ptr) const {
 298   assert(contains(ptr), PTR_FORMAT &quot; not in block &quot; PTR_FORMAT, p2i(ptr), p2i(this));
 299   return static_cast&lt;unsigned&gt;(ptr - get_pointer(0));
 300 }
 301 
 302 oop* OopStorage::Block::allocate() {
 303   // Use CAS loop because release may change bitmask outside of lock.
 304   uintx allocated = allocated_bitmask();
 305   while (true) {
 306     assert(!is_full_bitmask(allocated), &quot;attempt to allocate from full block&quot;);
 307     unsigned index = count_trailing_zeros(~allocated);
 308     uintx new_value = allocated | bitmask_for_index(index);
<span class="line-modified"> 309     uintx fetched = Atomic::cmpxchg(new_value, &amp;_allocated_bitmask, allocated);</span>
 310     if (fetched == allocated) {
 311       return get_pointer(index); // CAS succeeded; return entry for index.
 312     }
 313     allocated = fetched;       // CAS failed; retry with latest value.
 314   }
 315 }
 316 
 317 OopStorage::Block* OopStorage::Block::new_block(const OopStorage* owner) {
 318   // _data must be first member: aligning block =&gt; aligning _data.
 319   STATIC_ASSERT(_data_pos == 0);
 320   size_t size_needed = allocation_size();
 321   void* memory = NEW_C_HEAP_ARRAY_RETURN_NULL(char, size_needed, mtGC);
 322   if (memory == NULL) {
 323     return NULL;
 324   }
 325   void* block_mem = align_up(memory, block_alignment);
 326   assert(sizeof(Block) + pointer_delta(block_mem, memory, 1) &lt;= size_needed,
 327          &quot;allocated insufficient space for aligned block&quot;);
 328   return ::new (block_mem) Block(owner, memory);
 329 }
</pre>
<hr />
<pre>
 338 // block.  For some uses, it is a precondition that ptr is valid,
 339 // e.g. contained in some block in owner&#39;s _active_array.  Other uses
 340 // require additional validation of the result.
 341 OopStorage::Block*
 342 OopStorage::Block::block_for_ptr(const OopStorage* owner, const oop* ptr) {
 343   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 344   STATIC_ASSERT(_data_pos == 0);
 345   // Const-ness of ptr is not related to const-ness of containing block.
 346   // Blocks are allocated section-aligned, so get the containing section.
 347   oop* section_start = align_down(const_cast&lt;oop*&gt;(ptr), block_alignment);
 348   // Start with a guess that the containing section is the last section,
 349   // so the block starts section_count-1 sections earlier.
 350   oop* section = section_start - (section_size * (section_count - 1));
 351   // Walk up through the potential block start positions, looking for
 352   // the owner in the expected location.  If we&#39;re below the actual block
 353   // start position, the value at the owner position will be some oop
 354   // (possibly NULL), which can never match the owner.
 355   intptr_t owner_addr = reinterpret_cast&lt;intptr_t&gt;(owner);
 356   for (unsigned i = 0; i &lt; section_count; ++i, section += section_size) {
 357     Block* candidate = reinterpret_cast&lt;Block*&gt;(section);
<span class="line-modified"> 358     intptr_t* candidate_owner_addr</span>
<span class="line-removed"> 359       = reinterpret_cast&lt;intptr_t*&gt;(&amp;candidate-&gt;_owner);</span>
<span class="line-removed"> 360     if (SafeFetchN(candidate_owner_addr, 0) == owner_addr) {</span>
 361       return candidate;
 362     }
 363   }
 364   return NULL;
 365 }
 366 
 367 //////////////////////////////////////////////////////////////////////////////
 368 // Allocation
 369 //
 370 // Allocation involves the _allocation_list, which contains a subset of the
 371 // blocks owned by a storage object.  This is a doubly-linked list, linked
 372 // through dedicated fields in the blocks.  Full blocks are removed from this
 373 // list, though they are still present in the _active_array.  Empty blocks are
 374 // kept at the end of the _allocation_list, to make it easy for empty block
 375 // deletion to find them.
 376 //
 377 // allocate(), and delete_empty_blocks() lock the
 378 // _allocation_mutex while performing any list and array modifications.
 379 //
 380 // allocate() and release() update a block&#39;s _allocated_bitmask using CAS
</pre>
<hr />
<pre>
 395 // avoiding iteration over the _active_array).  Once the block has been
 396 // determined, its _allocated_bitmask needs to be updated, and its position in
 397 // the _allocation_list may need to be updated.  There are two cases:
 398 //
 399 // (a) If the block is neither full nor would become empty with the release of
 400 // the entry, only its _allocated_bitmask needs to be updated.  But if the CAS
 401 // update fails, the applicable case may change for the retry.
 402 //
 403 // (b) Otherwise, the _allocation_list also needs to be modified.  This requires
 404 // locking the _allocation_mutex.  To keep the release() operation lock-free,
 405 // rather than updating the _allocation_list itself, it instead performs a
 406 // lock-free push of the block onto the _deferred_updates list.  Entries on
 407 // that list are processed by allocate() and delete_empty_blocks(), while
 408 // they already hold the necessary lock.  That processing makes the block&#39;s
 409 // list state consistent with its current _allocated_bitmask.  The block is
 410 // added to the _allocation_list if not already present and the bitmask is not
 411 // full.  The block is moved to the end of the _allocation_list if the bitmask
 412 // is empty, for ease of empty block deletion processing.
 413 
 414 oop* OopStorage::allocate() {
<span class="line-modified"> 415   MutexLockerEx ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 416 </span>
<span class="line-removed"> 417   // Note: Without this we might never perform cleanup.  As it is,</span>
<span class="line-removed"> 418   // cleanup is only requested here, when completing a concurrent</span>
<span class="line-removed"> 419   // iteration, or when someone entirely else wakes up the service</span>
<span class="line-removed"> 420   // thread, which isn&#39;t ideal.  But we can&#39;t notify in release().</span>
<span class="line-removed"> 421   if (reduce_deferred_updates()) {</span>
<span class="line-removed"> 422     notify_needs_cleanup();</span>
<span class="line-removed"> 423   }</span>
 424 
 425   Block* block = block_for_allocation();
 426   if (block == NULL) return NULL; // Block allocation failed.
 427   assert(!block-&gt;is_full(), &quot;invariant&quot;);
 428   if (block-&gt;is_empty()) {
 429     // Transitioning from empty to not empty.
<span class="line-modified"> 430     log_debug(oopstorage, blocks)(&quot;%s: block not empty &quot; PTR_FORMAT, name(), p2i(block));</span>
 431   }
 432   oop* result = block-&gt;allocate();
 433   assert(result != NULL, &quot;allocation failed&quot;);
 434   assert(!block-&gt;is_empty(), &quot;postcondition&quot;);
 435   Atomic::inc(&amp;_allocation_count); // release updates outside lock.
 436   if (block-&gt;is_full()) {
 437     // Transitioning from not full to full.
 438     // Remove full blocks from consideration by future allocates.
<span class="line-modified"> 439     log_debug(oopstorage, blocks)(&quot;%s: block full &quot; PTR_FORMAT, name(), p2i(block));</span>
 440     _allocation_list.unlink(*block);
 441   }
 442   log_trace(oopstorage, ref)(&quot;%s: allocated &quot; PTR_FORMAT, name(), p2i(result));
 443   return result;
 444 }
 445 
 446 bool OopStorage::try_add_block() {
 447   assert_lock_strong(_allocation_mutex);
 448   Block* block;
 449   {
<span class="line-modified"> 450     MutexUnlockerEx ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 451     block = Block::new_block(this);
 452   }
 453   if (block == NULL) return false;
 454 
 455   // Add new block to the _active_array, growing if needed.
 456   if (!_active_array-&gt;push(block)) {
 457     if (expand_active_array()) {
 458       guarantee(_active_array-&gt;push(block), &quot;push failed after expansion&quot;);
 459     } else {
 460       log_debug(oopstorage, blocks)(&quot;%s: failed active array expand&quot;, name());
 461       Block::delete_block(*block);
 462       return false;
 463     }
 464   }
 465   // Add to end of _allocation_list.  The mutex release allowed other
 466   // threads to add blocks to the _allocation_list.  We prefer to
 467   // allocate from non-empty blocks, to allow empty blocks to be
 468   // deleted.  But we don&#39;t bother notifying about the empty block
 469   // because we&#39;re (probably) about to allocate an entry from it.
 470   _allocation_list.push_back(*block);
 471   log_debug(oopstorage, blocks)(&quot;%s: new block &quot; PTR_FORMAT, name(), p2i(block));
 472   return true;
 473 }
 474 
 475 OopStorage::Block* OopStorage::block_for_allocation() {
 476   assert_lock_strong(_allocation_mutex);
<span class="line-removed"> 477 </span>
 478   while (true) {
 479     // Use the first block in _allocation_list for the allocation.
 480     Block* block = _allocation_list.head();
 481     if (block != NULL) {
 482       return block;
 483     } else if (reduce_deferred_updates()) {
<span class="line-modified"> 484       MutexUnlockerEx ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed"> 485       notify_needs_cleanup();</span>
 486     } else if (try_add_block()) {
<span class="line-modified"> 487       block = _allocation_list.head();</span>
<span class="line-modified"> 488       assert(block != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 489       return block;</span>
<span class="line-modified"> 490     } else if (reduce_deferred_updates()) { // Once more before failure.</span>
<span class="line-modified"> 491       MutexUnlockerEx ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified"> 492       notify_needs_cleanup();</span>
<span class="line-removed"> 493     } else {</span>
 494       // Attempt to add a block failed, no other thread added a block,
 495       // and no deferred updated added a block, then allocation failed.
<span class="line-modified"> 496       log_debug(oopstorage, blocks)(&quot;%s: failed block allocation&quot;, name());</span>
 497       return NULL;
 498     }
 499   }
 500 }
 501 
 502 // Create a new, larger, active array with the same content as the
 503 // current array, and then replace, relinquishing the old array.
 504 // Return true if the array was successfully expanded, false to
 505 // indicate allocation failure.
 506 bool OopStorage::expand_active_array() {
 507   assert_lock_strong(_allocation_mutex);
 508   ActiveArray* old_array = _active_array;
 509   size_t new_size = 2 * old_array-&gt;size();
 510   log_debug(oopstorage, blocks)(&quot;%s: expand active array &quot; SIZE_FORMAT,
 511                                 name(), new_size);
 512   ActiveArray* new_array = ActiveArray::create(new_size, AllocFailStrategy::RETURN_NULL);
 513   if (new_array == NULL) return false;
 514   new_array-&gt;copy_from(old_array);
 515   replace_active_array(new_array);
 516   relinquish_block_array(old_array);
 517   return true;
 518 }
 519 
 520 // Make new_array the _active_array.  Increments new_array&#39;s refcount
 521 // to account for the new reference.  The assignment is atomic wrto
 522 // obtain_active_array; once this function returns, it is safe for the
 523 // caller to relinquish the old array.
 524 void OopStorage::replace_active_array(ActiveArray* new_array) {
 525   // Caller has the old array that is the current value of _active_array.
 526   // Update new_array refcount to account for the new reference.
 527   new_array-&gt;increment_refcount();
 528   // Install new_array, ensuring its initialization is complete first.
<span class="line-modified"> 529   OrderAccess::release_store(&amp;_active_array, new_array);</span>
 530   // Wait for any readers that could read the old array from _active_array.
 531   // Can&#39;t use GlobalCounter here, because this is called from allocate(),
 532   // which may be called in the scope of a GlobalCounter critical section
 533   // when inserting a StringTable entry.
 534   _protect_active.synchronize();
 535   // All obtain critical sections that could see the old array have
 536   // completed, having incremented the refcount of the old array.  The
 537   // caller can now safely relinquish the old array.
 538 }
 539 
 540 // Atomically (wrto replace_active_array) get the active array and
 541 // increment its refcount.  This provides safe access to the array,
 542 // even if an allocate operation expands and replaces the value of
 543 // _active_array.  The caller must relinquish the array when done
 544 // using it.
 545 OopStorage::ActiveArray* OopStorage::obtain_active_array() const {
 546   SingleWriterSynchronizer::CriticalSection cs(&amp;_protect_active);
<span class="line-modified"> 547   ActiveArray* result = OrderAccess::load_acquire(&amp;_active_array);</span>
 548   result-&gt;increment_refcount();
 549   return result;
 550 }
 551 
 552 // Decrement refcount of array and destroy if refcount is zero.
 553 void OopStorage::relinquish_block_array(ActiveArray* array) const {
 554   if (array-&gt;decrement_refcount()) {
 555     assert(array != _active_array, &quot;invariant&quot;);
 556     ActiveArray::destroy(array);
 557   }
 558 }
 559 
 560 class OopStorage::WithActiveArray : public StackObj {
 561   const OopStorage* _storage;
 562   ActiveArray* _active_array;
 563 
 564 public:
 565   WithActiveArray(const OopStorage* storage) :
 566     _storage(storage),
 567     _active_array(storage-&gt;obtain_active_array())
 568   {}
 569 
 570   ~WithActiveArray() {
 571     _storage-&gt;relinquish_block_array(_active_array);
 572   }
 573 
 574   ActiveArray&amp; active_array() const {
 575     return *_active_array;
 576   }
 577 };
 578 
 579 OopStorage::Block* OopStorage::find_block_or_null(const oop* ptr) const {
 580   assert(ptr != NULL, &quot;precondition&quot;);
 581   return Block::block_for_ptr(this, ptr);
 582 }
 583 
 584 static void log_release_transitions(uintx releasing,
 585                                     uintx old_allocated,
 586                                     const OopStorage* owner,
 587                                     const void* block) {
<span class="line-modified"> 588   Log(oopstorage, blocks) log;</span>
<span class="line-modified"> 589   LogStream ls(log.debug());</span>
<span class="line-modified"> 590   if (is_full_bitmask(old_allocated)) {</span>
<span class="line-modified"> 591     ls.print_cr(&quot;%s: block not full &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));</span>
<span class="line-modified"> 592   }</span>
<span class="line-modified"> 593   if (releasing == old_allocated) {</span>
<span class="line-modified"> 594     ls.print_cr(&quot;%s: block empty &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));</span>


 595   }
 596 }
 597 
 598 void OopStorage::Block::release_entries(uintx releasing, OopStorage* owner) {
 599   assert(releasing != 0, &quot;preconditon&quot;);
 600   // Prevent empty block deletion when transitioning to empty.
 601   Atomic::inc(&amp;_release_refcount);
 602 
 603   // Atomically update allocated bitmask.
 604   uintx old_allocated = _allocated_bitmask;
 605   while (true) {
 606     assert((releasing &amp; ~old_allocated) == 0, &quot;releasing unallocated entries&quot;);
 607     uintx new_value = old_allocated ^ releasing;
<span class="line-modified"> 608     uintx fetched = Atomic::cmpxchg(new_value, &amp;_allocated_bitmask, old_allocated);</span>
 609     if (fetched == old_allocated) break; // Successful update.
 610     old_allocated = fetched;             // Retry with updated bitmask.
 611   }
 612 
 613   // Now that the bitmask has been updated, if we have a state transition
 614   // (updated bitmask is empty or old bitmask was full), atomically push
 615   // this block onto the deferred updates list.  Some future call to
 616   // reduce_deferred_updates will make any needed changes related to this
 617   // block and _allocation_list.  This deferral avoids _allocation_list
 618   // updates and the associated locking here.
 619   if ((releasing == old_allocated) || is_full_bitmask(old_allocated)) {
 620     // Log transitions.  Both transitions are possible in a single update.
<span class="line-modified"> 621     if (log_is_enabled(Debug, oopstorage, blocks)) {</span>
<span class="line-removed"> 622       log_release_transitions(releasing, old_allocated, _owner, this);</span>
<span class="line-removed"> 623     }</span>
 624     // Attempt to claim responsibility for adding this block to the deferred
 625     // list, by setting the link to non-NULL by self-looping.  If this fails,
 626     // then someone else has made such a claim and the deferred update has not
 627     // yet been processed and will include our change, so we don&#39;t need to do
 628     // anything further.
<span class="line-modified"> 629     if (Atomic::replace_if_null(this, &amp;_deferred_updates_next)) {</span>
 630       // Successfully claimed.  Push, with self-loop for end-of-list.
 631       Block* head = owner-&gt;_deferred_updates;
 632       while (true) {
 633         _deferred_updates_next = (head == NULL) ? this : head;
<span class="line-modified"> 634         Block* fetched = Atomic::cmpxchg(this, &amp;owner-&gt;_deferred_updates, head);</span>
 635         if (fetched == head) break; // Successful update.
 636         head = fetched;             // Retry with updated head.
 637       }
<span class="line-modified"> 638       owner-&gt;record_needs_cleanup();</span>
<span class="line-modified"> 639       log_debug(oopstorage, blocks)(&quot;%s: deferred update &quot; PTR_FORMAT,</span>
<span class="line-modified"> 640                                     _owner-&gt;name(), p2i(this));</span>







 641     }
 642   }
 643   // Release hold on empty block deletion.
 644   Atomic::dec(&amp;_release_refcount);
 645 }
 646 
 647 // Process one available deferred update.  Returns true if one was processed.
 648 bool OopStorage::reduce_deferred_updates() {
 649   assert_lock_strong(_allocation_mutex);
 650   // Atomically pop a block off the list, if any available.
 651   // No ABA issue because this is only called by one thread at a time.
 652   // The atomicity is wrto pushes by release().
<span class="line-modified"> 653   Block* block = OrderAccess::load_acquire(&amp;_deferred_updates);</span>
 654   while (true) {
 655     if (block == NULL) return false;
 656     // Try atomic pop of block from list.
 657     Block* tail = block-&gt;deferred_updates_next();
 658     if (block == tail) tail = NULL; // Handle self-loop end marker.
<span class="line-modified"> 659     Block* fetched = Atomic::cmpxchg(tail, &amp;_deferred_updates, block);</span>
 660     if (fetched == block) break; // Update successful.
 661     block = fetched;             // Retry with updated block.
 662   }
 663   block-&gt;set_deferred_updates_next(NULL); // Clear tail after updating head.
 664   // Ensure bitmask read after pop is complete, including clearing tail, for
 665   // ordering with release().  Without this, we may be processing a stale
 666   // bitmask state here while blocking a release() operation from recording
 667   // the deferred update needed for its bitmask change.
 668   OrderAccess::fence();
 669   // Process popped block.
 670   uintx allocated = block-&gt;allocated_bitmask();
 671 
 672   // Make membership in list consistent with bitmask state.
 673   if ((_allocation_list.ctail() != NULL) &amp;&amp;
 674       ((_allocation_list.ctail() == block) ||
 675        (_allocation_list.next(*block) != NULL))) {
 676     // Block is in the _allocation_list.
 677     assert(!is_full_bitmask(allocated), &quot;invariant&quot;);
 678   } else if (!is_full_bitmask(allocated)) {
 679     // Block is not in the _allocation_list, but now should be.
 680     _allocation_list.push_front(*block);
 681   } // Else block is full and not in list, which is correct.
 682 
 683   // Move empty block to end of list, for possible deletion.
 684   if (is_empty_bitmask(allocated)) {
 685     _allocation_list.unlink(*block);
 686     _allocation_list.push_back(*block);
<span class="line-removed"> 687     notify_needs_cleanup();</span>
 688   }
 689 
<span class="line-modified"> 690   log_debug(oopstorage, blocks)(&quot;%s: processed deferred update &quot; PTR_FORMAT,</span>
 691                                 name(), p2i(block));
 692   return true;              // Processed one pending update.
 693 }
 694 
 695 inline void check_release_entry(const oop* entry) {
 696   assert(entry != NULL, &quot;Releasing NULL&quot;);
 697   assert(*entry == NULL, &quot;Releasing uncleared entry: &quot; PTR_FORMAT, p2i(entry));
 698 }
 699 
 700 void OopStorage::release(const oop* ptr) {
 701   check_release_entry(ptr);
 702   Block* block = find_block_or_null(ptr);
 703   assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptr));
 704   log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptr));
 705   block-&gt;release_entries(block-&gt;bitmask_for_entry(ptr), this);
 706   Atomic::dec(&amp;_allocation_count);
 707 }
 708 
 709 void OopStorage::release(const oop* const* ptrs, size_t size) {
 710   size_t i = 0;
</pre>
<hr />
<pre>
 713     Block* block = find_block_or_null(ptrs[i]);
 714     assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 715     log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 716     size_t count = 0;
 717     uintx releasing = 0;
 718     for ( ; i &lt; size; ++i) {
 719       const oop* entry = ptrs[i];
 720       check_release_entry(entry);
 721       // If entry not in block, finish block and resume outer loop with entry.
 722       if (!block-&gt;contains(entry)) break;
 723       // Add entry to releasing bitmap.
 724       log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(entry));
 725       uintx entry_bitmask = block-&gt;bitmask_for_entry(entry);
 726       assert((releasing &amp; entry_bitmask) == 0,
 727              &quot;Duplicate entry: &quot; PTR_FORMAT, p2i(entry));
 728       releasing |= entry_bitmask;
 729       ++count;
 730     }
 731     // Release the contiguous entries that are in block.
 732     block-&gt;release_entries(releasing, this);
<span class="line-modified"> 733     Atomic::sub(count, &amp;_allocation_count);</span>
 734   }
 735 }
 736 
<span class="line-removed"> 737 const char* dup_name(const char* name) {</span>
<span class="line-removed"> 738   char* dup = NEW_C_HEAP_ARRAY(char, strlen(name) + 1, mtGC);</span>
<span class="line-removed"> 739   strcpy(dup, name);</span>
<span class="line-removed"> 740   return dup;</span>
<span class="line-removed"> 741 }</span>
<span class="line-removed"> 742 </span>
<span class="line-removed"> 743 // Possible values for OopStorage::_needs_cleanup.</span>
<span class="line-removed"> 744 const uint needs_cleanup_none = 0;     // No cleanup needed.</span>
<span class="line-removed"> 745 const uint needs_cleanup_marked = 1;   // Requested, but no notification made.</span>
<span class="line-removed"> 746 const uint needs_cleanup_notified = 2; // Requested and Service thread notified.</span>
<span class="line-removed"> 747 </span>
 748 const size_t initial_active_array_size = 8;
 749 
 750 OopStorage::OopStorage(const char* name,
 751                        Mutex* allocation_mutex,
 752                        Mutex* active_mutex) :
<span class="line-modified"> 753   _name(dup_name(name)),</span>
 754   _active_array(ActiveArray::create(initial_active_array_size)),
 755   _allocation_list(),
 756   _deferred_updates(NULL),
 757   _allocation_mutex(allocation_mutex),
 758   _active_mutex(active_mutex),
 759   _allocation_count(0),
 760   _concurrent_iteration_count(0),
<span class="line-modified"> 761   _needs_cleanup(needs_cleanup_none)</span>
 762 {
 763   _active_array-&gt;increment_refcount();
 764   assert(_active_mutex-&gt;rank() &lt; _allocation_mutex-&gt;rank(),
 765          &quot;%s: active_mutex must have lower rank than allocation_mutex&quot;, _name);
 766   assert(Service_lock-&gt;rank() &lt; _active_mutex-&gt;rank(),
 767          &quot;%s: active_mutex must have higher rank than Service_lock&quot;, _name);
<span class="line-modified"> 768   assert(_active_mutex-&gt;_safepoint_check_required != Mutex::_safepoint_check_always,</span>
<span class="line-modified"> 769          &quot;%s: active mutex requires safepoint check&quot;, _name);</span>
<span class="line-modified"> 770   assert(_allocation_mutex-&gt;_safepoint_check_required != Mutex::_safepoint_check_always,</span>
<span class="line-modified"> 771          &quot;%s: allocation mutex requires safepoint check&quot;, _name);</span>
 772 }
 773 
 774 void OopStorage::delete_empty_block(const Block&amp; block) {
 775   assert(block.is_empty(), &quot;discarding non-empty block&quot;);
 776   log_debug(oopstorage, blocks)(&quot;%s: delete empty block &quot; PTR_FORMAT, name(), p2i(&amp;block));
 777   Block::delete_block(block);
 778 }
 779 
 780 OopStorage::~OopStorage() {
 781   Block* block;
 782   while ((block = _deferred_updates) != NULL) {
 783     _deferred_updates = block-&gt;deferred_updates_next();
 784     block-&gt;set_deferred_updates_next(NULL);
 785   }
 786   while ((block = _allocation_list.head()) != NULL) {
 787     _allocation_list.unlink(*block);
 788   }
 789   bool unreferenced = _active_array-&gt;decrement_refcount();
 790   assert(unreferenced, &quot;deleting storage while _active_array is referenced&quot;);
 791   for (size_t i = _active_array-&gt;block_count(); 0 &lt; i; ) {
 792     block = _active_array-&gt;at(--i);
 793     Block::delete_block(*block);
 794   }
 795   ActiveArray::destroy(_active_array);
<span class="line-modified"> 796   FREE_C_HEAP_ARRAY(char, _name);</span>
 797 }
 798 
<span class="line-modified"> 799 // Called by service thread to check for pending work.</span>
<span class="line-modified"> 800 bool OopStorage::needs_delete_empty_blocks() const {</span>
<span class="line-modified"> 801   return Atomic::load(&amp;_needs_cleanup) != needs_cleanup_none;</span>












































 802 }
 803 
 804 // Record that cleanup is needed, without notifying the Service thread.
 805 // Used by release(), where we can&#39;t lock even Service_lock.
 806 void OopStorage::record_needs_cleanup() {
<span class="line-modified"> 807   Atomic::cmpxchg(needs_cleanup_marked, &amp;_needs_cleanup, needs_cleanup_none);</span>



 808 }
 809 
<span class="line-modified"> 810 // Record that cleanup is needed, and notify the Service thread.</span>
<span class="line-modified"> 811 void OopStorage::notify_needs_cleanup() {</span>
<span class="line-modified"> 812   // Avoid re-notification if already notified.</span>
<span class="line-modified"> 813   const uint notified = needs_cleanup_notified;</span>
<span class="line-modified"> 814   if (Atomic::xchg(notified, &amp;_needs_cleanup) != notified) {</span>
<span class="line-modified"> 815     MonitorLockerEx ml(Service_lock, Monitor::_no_safepoint_check_flag);</span>
<span class="line-modified"> 816     ml.notify_all();</span>
 817   }
<span class="line-removed"> 818 }</span>
 819 
<span class="line-modified"> 820 bool OopStorage::delete_empty_blocks() {</span>
<span class="line-removed"> 821   MutexLockerEx ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 822 
 823   // Clear the request before processing.
<span class="line-modified"> 824   Atomic::store(needs_cleanup_none, &amp;_needs_cleanup);</span>
<span class="line-removed"> 825   OrderAccess::fence();</span>
 826 
 827   // Other threads could be adding to the empty block count or the
 828   // deferred update list while we&#39;re working.  Set an upper bound on
 829   // how many updates we&#39;ll process and blocks we&#39;ll try to release,
 830   // so other threads can&#39;t cause an unbounded stay in this function.
<span class="line-modified"> 831   size_t limit = block_count();</span>
<span class="line-modified"> 832   if (limit == 0) return false; // Empty storage; nothing at all to do.</span>





 833 
 834   for (size_t i = 0; i &lt; limit; ++i) {
 835     // Process deferred updates, which might make empty blocks available.
 836     // Continue checking once deletion starts, since additional updates
 837     // might become available while we&#39;re working.
 838     if (reduce_deferred_updates()) {
 839       // Be safepoint-polite while looping.
<span class="line-modified"> 840       MutexUnlockerEx ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 841       ThreadBlockInVM tbiv(JavaThread::current());
 842     } else {
 843       Block* block = _allocation_list.tail();
 844       if ((block == NULL) || !block-&gt;is_empty()) {
 845         return false;
 846       } else if (!block-&gt;is_safe_to_delete()) {
 847         // Look for other work while waiting for block to be deletable.
 848         break;
 849       }
 850 
 851       // Try to delete the block.  First, try to remove from _active_array.
 852       {
<span class="line-modified"> 853         MutexLockerEx aml(_active_mutex, Mutex::_no_safepoint_check_flag);</span>
 854         // Don&#39;t interfere with an active concurrent iteration.
 855         // Instead, give up immediately.  There is more work to do,
 856         // but don&#39;t re-notify, to avoid useless spinning of the
 857         // service thread.  Instead, iteration completion notifies.
 858         if (_concurrent_iteration_count &gt; 0) return true;
 859         _active_array-&gt;remove(block);
 860       }
 861       // Remove block from _allocation_list and delete it.
 862       _allocation_list.unlink(*block);
 863       // Be safepoint-polite while deleting and looping.
<span class="line-modified"> 864       MutexUnlockerEx ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 865       delete_empty_block(*block);
 866       ThreadBlockInVM tbiv(JavaThread::current());
 867     }
 868   }
 869   // Exceeded work limit or can&#39;t delete last block.  This will
 870   // cause the service thread to loop, giving other subtasks an
 871   // opportunity to run too.  There&#39;s no need for a notification,
 872   // because we are part of the service thread (unless gtesting).
 873   record_needs_cleanup();
 874   return true;
 875 }
 876 
 877 OopStorage::EntryStatus OopStorage::allocation_status(const oop* ptr) const {
 878   const Block* block = find_block_or_null(ptr);
 879   if (block != NULL) {
 880     // Prevent block deletion and _active_array modification.
<span class="line-modified"> 881     MutexLockerEx ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 882     // Block could be a false positive, so get index carefully.
 883     size_t index = Block::active_index_safe(block);
 884     if ((index &lt; _active_array-&gt;block_count()) &amp;&amp;
 885         (block == _active_array-&gt;at(index)) &amp;&amp;
 886         block-&gt;contains(ptr)) {
 887       if ((block-&gt;allocated_bitmask() &amp; block-&gt;bitmask_for_entry(ptr)) != 0) {
 888         return ALLOCATED_ENTRY;
 889       } else {
 890         return UNALLOCATED_ENTRY;
 891       }
 892     }
 893   }
 894   return INVALID_ENTRY;
 895 }
 896 
 897 size_t OopStorage::allocation_count() const {
 898   return _allocation_count;
 899 }
 900 
 901 size_t OopStorage::block_count() const {
</pre>
<hr />
<pre>
 929   _storage(storage),
 930   _active_array(_storage-&gt;obtain_active_array()),
 931   _block_count(0),              // initialized properly below
 932   _next_block(0),
 933   _estimated_thread_count(estimated_thread_count),
 934   _concurrent(concurrent)
 935 {
 936   assert(estimated_thread_count &gt; 0, &quot;estimated thread count must be positive&quot;);
 937   update_concurrent_iteration_count(1);
 938   // Get the block count *after* iteration state updated, so concurrent
 939   // empty block deletion is suppressed and can&#39;t reduce the count.  But
 940   // ensure the count we use was written after the block with that count
 941   // was fully initialized; see ActiveArray::push.
 942   _block_count = _active_array-&gt;block_count_acquire();
 943 }
 944 
 945 OopStorage::BasicParState::~BasicParState() {
 946   _storage-&gt;relinquish_block_array(_active_array);
 947   update_concurrent_iteration_count(-1);
 948   if (_concurrent) {
<span class="line-modified"> 949     // We may have deferred some work.</span>
<span class="line-modified"> 950     const_cast&lt;OopStorage*&gt;(_storage)-&gt;notify_needs_cleanup();</span>
 951   }
 952 }
 953 
 954 void OopStorage::BasicParState::update_concurrent_iteration_count(int value) {
 955   if (_concurrent) {
<span class="line-modified"> 956     MutexLockerEx ml(_storage-&gt;_active_mutex, Mutex::_no_safepoint_check_flag);</span>
 957     _storage-&gt;_concurrent_iteration_count += value;
 958     assert(_storage-&gt;_concurrent_iteration_count &gt;= 0, &quot;invariant&quot;);
 959   }
 960 }
 961 
 962 bool OopStorage::BasicParState::claim_next_segment(IterationData* data) {
 963   data-&gt;_processed += data-&gt;_segment_end - data-&gt;_segment_start;
<span class="line-modified"> 964   size_t start = OrderAccess::load_acquire(&amp;_next_block);</span>
 965   if (start &gt;= _block_count) {
 966     return finish_iteration(data); // No more blocks available.
 967   }
 968   // Try to claim several at a time, but not *too* many.  We want to
 969   // avoid deciding there are many available and selecting a large
 970   // quantity, get delayed, and then end up claiming most or all of
 971   // the remaining largish amount of work, leaving nothing for other
 972   // threads to do.  But too small a step can lead to contention
 973   // over _next_block, esp. when the work per block is small.
 974   size_t max_step = 10;
 975   size_t remaining = _block_count - start;
 976   size_t step = MIN2(max_step, 1 + (remaining / _estimated_thread_count));
 977   // Atomic::add with possible overshoot.  This can perform better
 978   // than a CAS loop on some platforms when there is contention.
 979   // We can cope with the uncertainty by recomputing start/end from
 980   // the result of the add, and dealing with potential overshoot.
<span class="line-modified"> 981   size_t end = Atomic::add(step, &amp;_next_block);</span>
 982   // _next_block may have changed, so recompute start from result of add.
 983   start = end - step;
 984   // _next_block may have changed so much that end has overshot.
 985   end = MIN2(end, _block_count);
 986   // _next_block may have changed so much that even start has overshot.
 987   if (start &lt; _block_count) {
 988     // Record claimed segment for iteration.
 989     data-&gt;_segment_start = start;
 990     data-&gt;_segment_end = end;
 991     return true;                // Success.
 992   } else {
 993     // No more blocks to claim.
 994     return finish_iteration(data);
 995   }
 996 }
 997 
 998 bool OopStorage::BasicParState::finish_iteration(const IterationData* data) const {
 999   log_info(oopstorage, blocks, stats)
1000           (&quot;Parallel iteration on %s: blocks = &quot; SIZE_FORMAT
1001            &quot;, processed = &quot; SIZE_FORMAT &quot; (%2.f%%)&quot;,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  27 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;logging/logStream.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;runtime/atomic.hpp&quot;
  32 #include &quot;runtime/globals.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  35 #include &quot;runtime/mutex.hpp&quot;
  36 #include &quot;runtime/mutexLocker.hpp&quot;
  37 #include &quot;runtime/orderAccess.hpp&quot;
<span class="line-added">  38 #include &quot;runtime/os.hpp&quot;</span>
  39 #include &quot;runtime/safepoint.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/thread.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;utilities/count_trailing_zeros.hpp&quot;
  44 #include &quot;utilities/debug.hpp&quot;
  45 #include &quot;utilities/globalDefinitions.hpp&quot;
  46 #include &quot;utilities/macros.hpp&quot;
  47 #include &quot;utilities/ostream.hpp&quot;
<span class="line-added">  48 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  49 
  50 OopStorage::AllocationListEntry::AllocationListEntry() : _prev(NULL), _next(NULL) {}
  51 
  52 OopStorage::AllocationListEntry::~AllocationListEntry() {
  53   assert(_prev == NULL, &quot;deleting attached block&quot;);
  54   assert(_next == NULL, &quot;deleting attached block&quot;);
  55 }
  56 
  57 OopStorage::AllocationList::AllocationList() : _head(NULL), _tail(NULL) {}
  58 
  59 OopStorage::AllocationList::~AllocationList() {
  60   // ~OopStorage() empties its lists before destroying them.
  61   assert(_head == NULL, &quot;deleting non-empty block list&quot;);
  62   assert(_tail == NULL, &quot;deleting non-empty block list&quot;);
  63 }
  64 
  65 void OopStorage::AllocationList::push_front(const Block&amp; block) {
  66   const Block* old = _head;
  67   if (old == NULL) {
  68     assert(_tail == NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
 124   size_t size_in_bytes = blocks_offset() + sizeof(Block*) * size;
 125   void* mem = NEW_C_HEAP_ARRAY3(char, size_in_bytes, mtGC, CURRENT_PC, alloc_fail);
 126   if (mem == NULL) return NULL;
 127   return new (mem) ActiveArray(size);
 128 }
 129 
 130 void OopStorage::ActiveArray::destroy(ActiveArray* ba) {
 131   ba-&gt;~ActiveArray();
 132   FREE_C_HEAP_ARRAY(char, ba);
 133 }
 134 
 135 size_t OopStorage::ActiveArray::size() const {
 136   return _size;
 137 }
 138 
 139 size_t OopStorage::ActiveArray::block_count() const {
 140   return _block_count;
 141 }
 142 
 143 size_t OopStorage::ActiveArray::block_count_acquire() const {
<span class="line-modified"> 144   return Atomic::load_acquire(&amp;_block_count);</span>
 145 }
 146 
 147 void OopStorage::ActiveArray::increment_refcount() const {
<span class="line-modified"> 148   int new_value = Atomic::add(&amp;_refcount, 1);</span>
 149   assert(new_value &gt;= 1, &quot;negative refcount %d&quot;, new_value - 1);
 150 }
 151 
 152 bool OopStorage::ActiveArray::decrement_refcount() const {
<span class="line-modified"> 153   int new_value = Atomic::sub(&amp;_refcount, 1);</span>
 154   assert(new_value &gt;= 0, &quot;negative refcount %d&quot;, new_value);
 155   return new_value == 0;
 156 }
 157 
 158 bool OopStorage::ActiveArray::push(Block* block) {
 159   size_t index = _block_count;
 160   if (index &lt; _size) {
 161     block-&gt;set_active_index(index);
 162     *block_ptr(index) = block;
 163     // Use a release_store to ensure all the setup is complete before
 164     // making the block visible.
<span class="line-modified"> 165     Atomic::release_store(&amp;_block_count, index + 1);</span>
 166     return true;
 167   } else {
 168     return false;
 169   }
 170 }
 171 
 172 void OopStorage::ActiveArray::remove(Block* block) {
 173   assert(_block_count &gt; 0, &quot;array is empty&quot;);
 174   size_t index = block-&gt;active_index();
 175   assert(*block_ptr(index) == block, &quot;block not present&quot;);
 176   size_t last_index = _block_count - 1;
 177   Block* last_block = *block_ptr(last_index);
 178   last_block-&gt;set_active_index(index);
 179   *block_ptr(index) = last_block;
 180   _block_count = last_index;
 181 }
 182 
 183 void OopStorage::ActiveArray::copy_from(const ActiveArray* from) {
 184   assert(_block_count == 0, &quot;array must be empty&quot;);
 185   size_t count = from-&gt;_block_count;
</pre>
<hr />
<pre>
 192     *to_ptr++ = block;
 193   }
 194   _block_count = count;
 195 }
 196 
 197 // Blocks start with an array of BitsPerWord oop entries.  That array
 198 // is divided into conceptual BytesPerWord sections of BitsPerByte
 199 // entries.  Blocks are allocated aligned on section boundaries, for
 200 // the convenience of mapping from an entry to the containing block;
 201 // see block_for_ptr().  Aligning on section boundary rather than on
 202 // the full _data wastes a lot less space, but makes for a bit more
 203 // work in block_for_ptr().
 204 
 205 const unsigned section_size = BitsPerByte;
 206 const unsigned section_count = BytesPerWord;
 207 const unsigned block_alignment = sizeof(oop) * section_size;
 208 
 209 OopStorage::Block::Block(const OopStorage* owner, void* memory) :
 210   _data(),
 211   _allocated_bitmask(0),
<span class="line-modified"> 212   _owner_address(reinterpret_cast&lt;intptr_t&gt;(owner)),</span>
 213   _memory(memory),
 214   _active_index(0),
 215   _allocation_list_entry(),
 216   _deferred_updates_next(NULL),
 217   _release_refcount(0)
 218 {
 219   STATIC_ASSERT(_data_pos == 0);
 220   STATIC_ASSERT(section_size * section_count == ARRAY_SIZE(_data));
 221   assert(offset_of(Block, _data) == _data_pos, &quot;invariant&quot;);
 222   assert(owner != NULL, &quot;NULL owner&quot;);
 223   assert(is_aligned(this, block_alignment), &quot;misaligned block&quot;);
 224 }
 225 
 226 OopStorage::Block::~Block() {
 227   assert(_release_refcount == 0, &quot;deleting block while releasing&quot;);
 228   assert(_deferred_updates_next == NULL, &quot;deleting block with deferred update&quot;);
 229   // Clear fields used by block_for_ptr and entry validation, which
 230   // might help catch bugs.  Volatile to prevent dead-store elimination.
 231   const_cast&lt;uintx volatile&amp;&gt;(_allocated_bitmask) = 0;
<span class="line-modified"> 232   const_cast&lt;intptr_t volatile&amp;&gt;(_owner_address) = 0;</span>
 233 }
 234 
 235 size_t OopStorage::Block::allocation_size() {
 236   // _data must be first member, so aligning Block aligns _data.
 237   STATIC_ASSERT(_data_pos == 0);
 238   return sizeof(Block) + block_alignment - sizeof(void*);
 239 }
 240 
 241 size_t OopStorage::Block::allocation_alignment_shift() {
 242   return exact_log2(block_alignment);
 243 }
 244 
 245 inline bool is_full_bitmask(uintx bitmask) { return ~bitmask == 0; }
 246 inline bool is_empty_bitmask(uintx bitmask) { return bitmask == 0; }
 247 
 248 bool OopStorage::Block::is_full() const {
 249   return is_full_bitmask(allocated_bitmask());
 250 }
 251 
 252 bool OopStorage::Block::is_empty() const {
 253   return is_empty_bitmask(allocated_bitmask());
 254 }
 255 
 256 uintx OopStorage::Block::bitmask_for_entry(const oop* ptr) const {
 257   return bitmask_for_index(get_index(ptr));
 258 }
 259 
 260 // An empty block is not yet deletable if either:
 261 // (1) There is a release() operation currently operating on it.
 262 // (2) It is in the deferred updates list.
 263 // For interaction with release(), these must follow the empty check,
 264 // and the order of these checks is important.
 265 bool OopStorage::Block::is_safe_to_delete() const {
 266   assert(is_empty(), &quot;precondition&quot;);
 267   OrderAccess::loadload();
<span class="line-modified"> 268   return (Atomic::load_acquire(&amp;_release_refcount) == 0) &amp;&amp;</span>
<span class="line-modified"> 269          (Atomic::load_acquire(&amp;_deferred_updates_next) == NULL);</span>
 270 }
 271 
 272 OopStorage::Block* OopStorage::Block::deferred_updates_next() const {
 273   return _deferred_updates_next;
 274 }
 275 
 276 void OopStorage::Block::set_deferred_updates_next(Block* block) {
 277   _deferred_updates_next = block;
 278 }
 279 
 280 bool OopStorage::Block::contains(const oop* ptr) const {
 281   const oop* base = get_pointer(0);
 282   return (base &lt;= ptr) &amp;&amp; (ptr &lt; (base + ARRAY_SIZE(_data)));
 283 }
 284 
 285 size_t OopStorage::Block::active_index() const {
 286   return _active_index;
 287 }
 288 
 289 void OopStorage::Block::set_active_index(size_t index) {
</pre>
<hr />
<pre>
 291 }
 292 
 293 size_t OopStorage::Block::active_index_safe(const Block* block) {
 294   STATIC_ASSERT(sizeof(intptr_t) == sizeof(block-&gt;_active_index));
 295   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 296   return SafeFetchN((intptr_t*)&amp;block-&gt;_active_index, 0);
 297 }
 298 
 299 unsigned OopStorage::Block::get_index(const oop* ptr) const {
 300   assert(contains(ptr), PTR_FORMAT &quot; not in block &quot; PTR_FORMAT, p2i(ptr), p2i(this));
 301   return static_cast&lt;unsigned&gt;(ptr - get_pointer(0));
 302 }
 303 
 304 oop* OopStorage::Block::allocate() {
 305   // Use CAS loop because release may change bitmask outside of lock.
 306   uintx allocated = allocated_bitmask();
 307   while (true) {
 308     assert(!is_full_bitmask(allocated), &quot;attempt to allocate from full block&quot;);
 309     unsigned index = count_trailing_zeros(~allocated);
 310     uintx new_value = allocated | bitmask_for_index(index);
<span class="line-modified"> 311     uintx fetched = Atomic::cmpxchg(&amp;_allocated_bitmask, allocated, new_value);</span>
 312     if (fetched == allocated) {
 313       return get_pointer(index); // CAS succeeded; return entry for index.
 314     }
 315     allocated = fetched;       // CAS failed; retry with latest value.
 316   }
 317 }
 318 
 319 OopStorage::Block* OopStorage::Block::new_block(const OopStorage* owner) {
 320   // _data must be first member: aligning block =&gt; aligning _data.
 321   STATIC_ASSERT(_data_pos == 0);
 322   size_t size_needed = allocation_size();
 323   void* memory = NEW_C_HEAP_ARRAY_RETURN_NULL(char, size_needed, mtGC);
 324   if (memory == NULL) {
 325     return NULL;
 326   }
 327   void* block_mem = align_up(memory, block_alignment);
 328   assert(sizeof(Block) + pointer_delta(block_mem, memory, 1) &lt;= size_needed,
 329          &quot;allocated insufficient space for aligned block&quot;);
 330   return ::new (block_mem) Block(owner, memory);
 331 }
</pre>
<hr />
<pre>
 340 // block.  For some uses, it is a precondition that ptr is valid,
 341 // e.g. contained in some block in owner&#39;s _active_array.  Other uses
 342 // require additional validation of the result.
 343 OopStorage::Block*
 344 OopStorage::Block::block_for_ptr(const OopStorage* owner, const oop* ptr) {
 345   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 346   STATIC_ASSERT(_data_pos == 0);
 347   // Const-ness of ptr is not related to const-ness of containing block.
 348   // Blocks are allocated section-aligned, so get the containing section.
 349   oop* section_start = align_down(const_cast&lt;oop*&gt;(ptr), block_alignment);
 350   // Start with a guess that the containing section is the last section,
 351   // so the block starts section_count-1 sections earlier.
 352   oop* section = section_start - (section_size * (section_count - 1));
 353   // Walk up through the potential block start positions, looking for
 354   // the owner in the expected location.  If we&#39;re below the actual block
 355   // start position, the value at the owner position will be some oop
 356   // (possibly NULL), which can never match the owner.
 357   intptr_t owner_addr = reinterpret_cast&lt;intptr_t&gt;(owner);
 358   for (unsigned i = 0; i &lt; section_count; ++i, section += section_size) {
 359     Block* candidate = reinterpret_cast&lt;Block*&gt;(section);
<span class="line-modified"> 360     if (SafeFetchN(&amp;candidate-&gt;_owner_address, 0) == owner_addr) {</span>


 361       return candidate;
 362     }
 363   }
 364   return NULL;
 365 }
 366 
 367 //////////////////////////////////////////////////////////////////////////////
 368 // Allocation
 369 //
 370 // Allocation involves the _allocation_list, which contains a subset of the
 371 // blocks owned by a storage object.  This is a doubly-linked list, linked
 372 // through dedicated fields in the blocks.  Full blocks are removed from this
 373 // list, though they are still present in the _active_array.  Empty blocks are
 374 // kept at the end of the _allocation_list, to make it easy for empty block
 375 // deletion to find them.
 376 //
 377 // allocate(), and delete_empty_blocks() lock the
 378 // _allocation_mutex while performing any list and array modifications.
 379 //
 380 // allocate() and release() update a block&#39;s _allocated_bitmask using CAS
</pre>
<hr />
<pre>
 395 // avoiding iteration over the _active_array).  Once the block has been
 396 // determined, its _allocated_bitmask needs to be updated, and its position in
 397 // the _allocation_list may need to be updated.  There are two cases:
 398 //
 399 // (a) If the block is neither full nor would become empty with the release of
 400 // the entry, only its _allocated_bitmask needs to be updated.  But if the CAS
 401 // update fails, the applicable case may change for the retry.
 402 //
 403 // (b) Otherwise, the _allocation_list also needs to be modified.  This requires
 404 // locking the _allocation_mutex.  To keep the release() operation lock-free,
 405 // rather than updating the _allocation_list itself, it instead performs a
 406 // lock-free push of the block onto the _deferred_updates list.  Entries on
 407 // that list are processed by allocate() and delete_empty_blocks(), while
 408 // they already hold the necessary lock.  That processing makes the block&#39;s
 409 // list state consistent with its current _allocated_bitmask.  The block is
 410 // added to the _allocation_list if not already present and the bitmask is not
 411 // full.  The block is moved to the end of the _allocation_list if the bitmask
 412 // is empty, for ease of empty block deletion processing.
 413 
 414 oop* OopStorage::allocate() {
<span class="line-modified"> 415   MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>








 416 
 417   Block* block = block_for_allocation();
 418   if (block == NULL) return NULL; // Block allocation failed.
 419   assert(!block-&gt;is_full(), &quot;invariant&quot;);
 420   if (block-&gt;is_empty()) {
 421     // Transitioning from empty to not empty.
<span class="line-modified"> 422     log_trace(oopstorage, blocks)(&quot;%s: block not empty &quot; PTR_FORMAT, name(), p2i(block));</span>
 423   }
 424   oop* result = block-&gt;allocate();
 425   assert(result != NULL, &quot;allocation failed&quot;);
 426   assert(!block-&gt;is_empty(), &quot;postcondition&quot;);
 427   Atomic::inc(&amp;_allocation_count); // release updates outside lock.
 428   if (block-&gt;is_full()) {
 429     // Transitioning from not full to full.
 430     // Remove full blocks from consideration by future allocates.
<span class="line-modified"> 431     log_trace(oopstorage, blocks)(&quot;%s: block full &quot; PTR_FORMAT, name(), p2i(block));</span>
 432     _allocation_list.unlink(*block);
 433   }
 434   log_trace(oopstorage, ref)(&quot;%s: allocated &quot; PTR_FORMAT, name(), p2i(result));
 435   return result;
 436 }
 437 
 438 bool OopStorage::try_add_block() {
 439   assert_lock_strong(_allocation_mutex);
 440   Block* block;
 441   {
<span class="line-modified"> 442     MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 443     block = Block::new_block(this);
 444   }
 445   if (block == NULL) return false;
 446 
 447   // Add new block to the _active_array, growing if needed.
 448   if (!_active_array-&gt;push(block)) {
 449     if (expand_active_array()) {
 450       guarantee(_active_array-&gt;push(block), &quot;push failed after expansion&quot;);
 451     } else {
 452       log_debug(oopstorage, blocks)(&quot;%s: failed active array expand&quot;, name());
 453       Block::delete_block(*block);
 454       return false;
 455     }
 456   }
 457   // Add to end of _allocation_list.  The mutex release allowed other
 458   // threads to add blocks to the _allocation_list.  We prefer to
 459   // allocate from non-empty blocks, to allow empty blocks to be
 460   // deleted.  But we don&#39;t bother notifying about the empty block
 461   // because we&#39;re (probably) about to allocate an entry from it.
 462   _allocation_list.push_back(*block);
 463   log_debug(oopstorage, blocks)(&quot;%s: new block &quot; PTR_FORMAT, name(), p2i(block));
 464   return true;
 465 }
 466 
 467 OopStorage::Block* OopStorage::block_for_allocation() {
 468   assert_lock_strong(_allocation_mutex);

 469   while (true) {
 470     // Use the first block in _allocation_list for the allocation.
 471     Block* block = _allocation_list.head();
 472     if (block != NULL) {
 473       return block;
 474     } else if (reduce_deferred_updates()) {
<span class="line-modified"> 475       // Might have added a block to the _allocation_list, so retry.</span>

 476     } else if (try_add_block()) {
<span class="line-modified"> 477       // Successfully added a new block to the list, so retry.</span>
<span class="line-modified"> 478       assert(_allocation_list.chead() != NULL, &quot;invariant&quot;);</span>
<span class="line-modified"> 479     } else if (_allocation_list.chead() != NULL) {</span>
<span class="line-modified"> 480       // Trying to add a block failed, but some other thread added to the</span>
<span class="line-modified"> 481       // list while we&#39;d dropped the lock over the new block allocation.</span>
<span class="line-modified"> 482     } else if (!reduce_deferred_updates()) { // Once more before failure.</span>

 483       // Attempt to add a block failed, no other thread added a block,
 484       // and no deferred updated added a block, then allocation failed.
<span class="line-modified"> 485       log_info(oopstorage, blocks)(&quot;%s: failed block allocation&quot;, name());</span>
 486       return NULL;
 487     }
 488   }
 489 }
 490 
 491 // Create a new, larger, active array with the same content as the
 492 // current array, and then replace, relinquishing the old array.
 493 // Return true if the array was successfully expanded, false to
 494 // indicate allocation failure.
 495 bool OopStorage::expand_active_array() {
 496   assert_lock_strong(_allocation_mutex);
 497   ActiveArray* old_array = _active_array;
 498   size_t new_size = 2 * old_array-&gt;size();
 499   log_debug(oopstorage, blocks)(&quot;%s: expand active array &quot; SIZE_FORMAT,
 500                                 name(), new_size);
 501   ActiveArray* new_array = ActiveArray::create(new_size, AllocFailStrategy::RETURN_NULL);
 502   if (new_array == NULL) return false;
 503   new_array-&gt;copy_from(old_array);
 504   replace_active_array(new_array);
 505   relinquish_block_array(old_array);
 506   return true;
 507 }
 508 
 509 // Make new_array the _active_array.  Increments new_array&#39;s refcount
 510 // to account for the new reference.  The assignment is atomic wrto
 511 // obtain_active_array; once this function returns, it is safe for the
 512 // caller to relinquish the old array.
 513 void OopStorage::replace_active_array(ActiveArray* new_array) {
 514   // Caller has the old array that is the current value of _active_array.
 515   // Update new_array refcount to account for the new reference.
 516   new_array-&gt;increment_refcount();
 517   // Install new_array, ensuring its initialization is complete first.
<span class="line-modified"> 518   Atomic::release_store(&amp;_active_array, new_array);</span>
 519   // Wait for any readers that could read the old array from _active_array.
 520   // Can&#39;t use GlobalCounter here, because this is called from allocate(),
 521   // which may be called in the scope of a GlobalCounter critical section
 522   // when inserting a StringTable entry.
 523   _protect_active.synchronize();
 524   // All obtain critical sections that could see the old array have
 525   // completed, having incremented the refcount of the old array.  The
 526   // caller can now safely relinquish the old array.
 527 }
 528 
 529 // Atomically (wrto replace_active_array) get the active array and
 530 // increment its refcount.  This provides safe access to the array,
 531 // even if an allocate operation expands and replaces the value of
 532 // _active_array.  The caller must relinquish the array when done
 533 // using it.
 534 OopStorage::ActiveArray* OopStorage::obtain_active_array() const {
 535   SingleWriterSynchronizer::CriticalSection cs(&amp;_protect_active);
<span class="line-modified"> 536   ActiveArray* result = Atomic::load_acquire(&amp;_active_array);</span>
 537   result-&gt;increment_refcount();
 538   return result;
 539 }
 540 
 541 // Decrement refcount of array and destroy if refcount is zero.
 542 void OopStorage::relinquish_block_array(ActiveArray* array) const {
 543   if (array-&gt;decrement_refcount()) {
 544     assert(array != _active_array, &quot;invariant&quot;);
 545     ActiveArray::destroy(array);
 546   }
 547 }
 548 
 549 class OopStorage::WithActiveArray : public StackObj {
 550   const OopStorage* _storage;
 551   ActiveArray* _active_array;
 552 
 553 public:
 554   WithActiveArray(const OopStorage* storage) :
 555     _storage(storage),
 556     _active_array(storage-&gt;obtain_active_array())
 557   {}
 558 
 559   ~WithActiveArray() {
 560     _storage-&gt;relinquish_block_array(_active_array);
 561   }
 562 
 563   ActiveArray&amp; active_array() const {
 564     return *_active_array;
 565   }
 566 };
 567 
 568 OopStorage::Block* OopStorage::find_block_or_null(const oop* ptr) const {
 569   assert(ptr != NULL, &quot;precondition&quot;);
 570   return Block::block_for_ptr(this, ptr);
 571 }
 572 
 573 static void log_release_transitions(uintx releasing,
 574                                     uintx old_allocated,
 575                                     const OopStorage* owner,
 576                                     const void* block) {
<span class="line-modified"> 577   LogTarget(Trace, oopstorage, blocks) lt;</span>
<span class="line-modified"> 578   if (lt.is_enabled()) {</span>
<span class="line-modified"> 579     LogStream ls(lt);</span>
<span class="line-modified"> 580     if (is_full_bitmask(old_allocated)) {</span>
<span class="line-modified"> 581       ls.print_cr(&quot;%s: block not full &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));</span>
<span class="line-modified"> 582     }</span>
<span class="line-modified"> 583     if (releasing == old_allocated) {</span>
<span class="line-added"> 584       ls.print_cr(&quot;%s: block empty &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));</span>
<span class="line-added"> 585     }</span>
 586   }
 587 }
 588 
 589 void OopStorage::Block::release_entries(uintx releasing, OopStorage* owner) {
 590   assert(releasing != 0, &quot;preconditon&quot;);
 591   // Prevent empty block deletion when transitioning to empty.
 592   Atomic::inc(&amp;_release_refcount);
 593 
 594   // Atomically update allocated bitmask.
 595   uintx old_allocated = _allocated_bitmask;
 596   while (true) {
 597     assert((releasing &amp; ~old_allocated) == 0, &quot;releasing unallocated entries&quot;);
 598     uintx new_value = old_allocated ^ releasing;
<span class="line-modified"> 599     uintx fetched = Atomic::cmpxchg(&amp;_allocated_bitmask, old_allocated, new_value);</span>
 600     if (fetched == old_allocated) break; // Successful update.
 601     old_allocated = fetched;             // Retry with updated bitmask.
 602   }
 603 
 604   // Now that the bitmask has been updated, if we have a state transition
 605   // (updated bitmask is empty or old bitmask was full), atomically push
 606   // this block onto the deferred updates list.  Some future call to
 607   // reduce_deferred_updates will make any needed changes related to this
 608   // block and _allocation_list.  This deferral avoids _allocation_list
 609   // updates and the associated locking here.
 610   if ((releasing == old_allocated) || is_full_bitmask(old_allocated)) {
 611     // Log transitions.  Both transitions are possible in a single update.
<span class="line-modified"> 612     log_release_transitions(releasing, old_allocated, owner, this);</span>


 613     // Attempt to claim responsibility for adding this block to the deferred
 614     // list, by setting the link to non-NULL by self-looping.  If this fails,
 615     // then someone else has made such a claim and the deferred update has not
 616     // yet been processed and will include our change, so we don&#39;t need to do
 617     // anything further.
<span class="line-modified"> 618     if (Atomic::replace_if_null(&amp;_deferred_updates_next, this)) {</span>
 619       // Successfully claimed.  Push, with self-loop for end-of-list.
 620       Block* head = owner-&gt;_deferred_updates;
 621       while (true) {
 622         _deferred_updates_next = (head == NULL) ? this : head;
<span class="line-modified"> 623         Block* fetched = Atomic::cmpxchg(&amp;owner-&gt;_deferred_updates, head, this);</span>
 624         if (fetched == head) break; // Successful update.
 625         head = fetched;             // Retry with updated head.
 626       }
<span class="line-modified"> 627       // Only request cleanup for to-empty transitions, not for from-full.</span>
<span class="line-modified"> 628       // There isn&#39;t any rush to process from-full transitions.  Allocation</span>
<span class="line-modified"> 629       // will reduce deferrals before allocating new blocks, so may process</span>
<span class="line-added"> 630       // some.  And the service thread will drain the entire deferred list</span>
<span class="line-added"> 631       // if there are any pending to-empty transitions.</span>
<span class="line-added"> 632       if (releasing == old_allocated) {</span>
<span class="line-added"> 633         owner-&gt;record_needs_cleanup();</span>
<span class="line-added"> 634       }</span>
<span class="line-added"> 635       log_trace(oopstorage, blocks)(&quot;%s: deferred update &quot; PTR_FORMAT,</span>
<span class="line-added"> 636                                     owner-&gt;name(), p2i(this));</span>
 637     }
 638   }
 639   // Release hold on empty block deletion.
 640   Atomic::dec(&amp;_release_refcount);
 641 }
 642 
 643 // Process one available deferred update.  Returns true if one was processed.
 644 bool OopStorage::reduce_deferred_updates() {
 645   assert_lock_strong(_allocation_mutex);
 646   // Atomically pop a block off the list, if any available.
 647   // No ABA issue because this is only called by one thread at a time.
 648   // The atomicity is wrto pushes by release().
<span class="line-modified"> 649   Block* block = Atomic::load_acquire(&amp;_deferred_updates);</span>
 650   while (true) {
 651     if (block == NULL) return false;
 652     // Try atomic pop of block from list.
 653     Block* tail = block-&gt;deferred_updates_next();
 654     if (block == tail) tail = NULL; // Handle self-loop end marker.
<span class="line-modified"> 655     Block* fetched = Atomic::cmpxchg(&amp;_deferred_updates, block, tail);</span>
 656     if (fetched == block) break; // Update successful.
 657     block = fetched;             // Retry with updated block.
 658   }
 659   block-&gt;set_deferred_updates_next(NULL); // Clear tail after updating head.
 660   // Ensure bitmask read after pop is complete, including clearing tail, for
 661   // ordering with release().  Without this, we may be processing a stale
 662   // bitmask state here while blocking a release() operation from recording
 663   // the deferred update needed for its bitmask change.
 664   OrderAccess::fence();
 665   // Process popped block.
 666   uintx allocated = block-&gt;allocated_bitmask();
 667 
 668   // Make membership in list consistent with bitmask state.
 669   if ((_allocation_list.ctail() != NULL) &amp;&amp;
 670       ((_allocation_list.ctail() == block) ||
 671        (_allocation_list.next(*block) != NULL))) {
 672     // Block is in the _allocation_list.
 673     assert(!is_full_bitmask(allocated), &quot;invariant&quot;);
 674   } else if (!is_full_bitmask(allocated)) {
 675     // Block is not in the _allocation_list, but now should be.
 676     _allocation_list.push_front(*block);
 677   } // Else block is full and not in list, which is correct.
 678 
 679   // Move empty block to end of list, for possible deletion.
 680   if (is_empty_bitmask(allocated)) {
 681     _allocation_list.unlink(*block);
 682     _allocation_list.push_back(*block);

 683   }
 684 
<span class="line-modified"> 685   log_trace(oopstorage, blocks)(&quot;%s: processed deferred update &quot; PTR_FORMAT,</span>
 686                                 name(), p2i(block));
 687   return true;              // Processed one pending update.
 688 }
 689 
 690 inline void check_release_entry(const oop* entry) {
 691   assert(entry != NULL, &quot;Releasing NULL&quot;);
 692   assert(*entry == NULL, &quot;Releasing uncleared entry: &quot; PTR_FORMAT, p2i(entry));
 693 }
 694 
 695 void OopStorage::release(const oop* ptr) {
 696   check_release_entry(ptr);
 697   Block* block = find_block_or_null(ptr);
 698   assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptr));
 699   log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptr));
 700   block-&gt;release_entries(block-&gt;bitmask_for_entry(ptr), this);
 701   Atomic::dec(&amp;_allocation_count);
 702 }
 703 
 704 void OopStorage::release(const oop* const* ptrs, size_t size) {
 705   size_t i = 0;
</pre>
<hr />
<pre>
 708     Block* block = find_block_or_null(ptrs[i]);
 709     assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 710     log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 711     size_t count = 0;
 712     uintx releasing = 0;
 713     for ( ; i &lt; size; ++i) {
 714       const oop* entry = ptrs[i];
 715       check_release_entry(entry);
 716       // If entry not in block, finish block and resume outer loop with entry.
 717       if (!block-&gt;contains(entry)) break;
 718       // Add entry to releasing bitmap.
 719       log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(entry));
 720       uintx entry_bitmask = block-&gt;bitmask_for_entry(entry);
 721       assert((releasing &amp; entry_bitmask) == 0,
 722              &quot;Duplicate entry: &quot; PTR_FORMAT, p2i(entry));
 723       releasing |= entry_bitmask;
 724       ++count;
 725     }
 726     // Release the contiguous entries that are in block.
 727     block-&gt;release_entries(releasing, this);
<span class="line-modified"> 728     Atomic::sub(&amp;_allocation_count, count);</span>
 729   }
 730 }
 731 











 732 const size_t initial_active_array_size = 8;
 733 
 734 OopStorage::OopStorage(const char* name,
 735                        Mutex* allocation_mutex,
 736                        Mutex* active_mutex) :
<span class="line-modified"> 737   _name(os::strdup(name)),</span>
 738   _active_array(ActiveArray::create(initial_active_array_size)),
 739   _allocation_list(),
 740   _deferred_updates(NULL),
 741   _allocation_mutex(allocation_mutex),
 742   _active_mutex(active_mutex),
 743   _allocation_count(0),
 744   _concurrent_iteration_count(0),
<span class="line-modified"> 745   _needs_cleanup(false)</span>
 746 {
 747   _active_array-&gt;increment_refcount();
 748   assert(_active_mutex-&gt;rank() &lt; _allocation_mutex-&gt;rank(),
 749          &quot;%s: active_mutex must have lower rank than allocation_mutex&quot;, _name);
 750   assert(Service_lock-&gt;rank() &lt; _active_mutex-&gt;rank(),
 751          &quot;%s: active_mutex must have higher rank than Service_lock&quot;, _name);
<span class="line-modified"> 752   assert(_active_mutex-&gt;_safepoint_check_required == Mutex::_safepoint_check_never,</span>
<span class="line-modified"> 753          &quot;%s: active mutex requires never safepoint check&quot;, _name);</span>
<span class="line-modified"> 754   assert(_allocation_mutex-&gt;_safepoint_check_required == Mutex::_safepoint_check_never,</span>
<span class="line-modified"> 755          &quot;%s: allocation mutex requires never safepoint check&quot;, _name);</span>
 756 }
 757 
 758 void OopStorage::delete_empty_block(const Block&amp; block) {
 759   assert(block.is_empty(), &quot;discarding non-empty block&quot;);
 760   log_debug(oopstorage, blocks)(&quot;%s: delete empty block &quot; PTR_FORMAT, name(), p2i(&amp;block));
 761   Block::delete_block(block);
 762 }
 763 
 764 OopStorage::~OopStorage() {
 765   Block* block;
 766   while ((block = _deferred_updates) != NULL) {
 767     _deferred_updates = block-&gt;deferred_updates_next();
 768     block-&gt;set_deferred_updates_next(NULL);
 769   }
 770   while ((block = _allocation_list.head()) != NULL) {
 771     _allocation_list.unlink(*block);
 772   }
 773   bool unreferenced = _active_array-&gt;decrement_refcount();
 774   assert(unreferenced, &quot;deleting storage while _active_array is referenced&quot;);
 775   for (size_t i = _active_array-&gt;block_count(); 0 &lt; i; ) {
 776     block = _active_array-&gt;at(--i);
 777     Block::delete_block(*block);
 778   }
 779   ActiveArray::destroy(_active_array);
<span class="line-modified"> 780   os::free(const_cast&lt;char*&gt;(_name));</span>
 781 }
 782 
<span class="line-modified"> 783 // Managing service thread notifications.</span>
<span class="line-modified"> 784 //</span>
<span class="line-modified"> 785 // We don&#39;t want cleanup work to linger indefinitely, but we also don&#39;t want</span>
<span class="line-added"> 786 // to run the service thread too often.  We&#39;re also very limited in what we</span>
<span class="line-added"> 787 // can do in a release operation, where cleanup work is created.</span>
<span class="line-added"> 788 //</span>
<span class="line-added"> 789 // When a release operation changes a block&#39;s state to empty, it records the</span>
<span class="line-added"> 790 // need for cleanup in both the associated storage object and in the global</span>
<span class="line-added"> 791 // request state.  A safepoint cleanup task notifies the service thread when</span>
<span class="line-added"> 792 // there may be cleanup work for any storage object, based on the global</span>
<span class="line-added"> 793 // request state.  But that notification is deferred if the service thread</span>
<span class="line-added"> 794 // has run recently, and we also avoid duplicate notifications.  The service</span>
<span class="line-added"> 795 // thread updates the timestamp and resets the state flags on every iteration.</span>
<span class="line-added"> 796 </span>
<span class="line-added"> 797 // Global cleanup request state.</span>
<span class="line-added"> 798 static volatile bool needs_cleanup_requested = false;</span>
<span class="line-added"> 799 </span>
<span class="line-added"> 800 // Flag for avoiding duplicate notifications.</span>
<span class="line-added"> 801 static bool needs_cleanup_triggered = false;</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803 // Time after which a notification can be made.</span>
<span class="line-added"> 804 static jlong cleanup_trigger_permit_time = 0;</span>
<span class="line-added"> 805 </span>
<span class="line-added"> 806 // Minimum time since last service thread check before notification is</span>
<span class="line-added"> 807 // permitted.  The value of 500ms was an arbitrary choice; frequent, but not</span>
<span class="line-added"> 808 // too frequent.</span>
<span class="line-added"> 809 const jlong cleanup_trigger_defer_period = 500 * NANOSECS_PER_MILLISEC;</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 void OopStorage::trigger_cleanup_if_needed() {</span>
<span class="line-added"> 812   MonitorLocker ml(Service_lock, Monitor::_no_safepoint_check_flag);</span>
<span class="line-added"> 813   if (Atomic::load(&amp;needs_cleanup_requested) &amp;&amp;</span>
<span class="line-added"> 814       !needs_cleanup_triggered &amp;&amp;</span>
<span class="line-added"> 815       (os::javaTimeNanos() &gt; cleanup_trigger_permit_time)) {</span>
<span class="line-added"> 816     needs_cleanup_triggered = true;</span>
<span class="line-added"> 817     ml.notify_all();</span>
<span class="line-added"> 818   }</span>
<span class="line-added"> 819 }</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821 bool OopStorage::has_cleanup_work_and_reset() {</span>
<span class="line-added"> 822   assert_lock_strong(Service_lock);</span>
<span class="line-added"> 823   cleanup_trigger_permit_time =</span>
<span class="line-added"> 824     os::javaTimeNanos() + cleanup_trigger_defer_period;</span>
<span class="line-added"> 825   needs_cleanup_triggered = false;</span>
<span class="line-added"> 826   // Set the request flag false and return its old value.</span>
<span class="line-added"> 827   // Needs to be atomic to avoid dropping a concurrent request.</span>
<span class="line-added"> 828   // Can&#39;t use Atomic::xchg, which may not support bool.</span>
<span class="line-added"> 829   return Atomic::cmpxchg(&amp;needs_cleanup_requested, true, false);</span>
 830 }
 831 
 832 // Record that cleanup is needed, without notifying the Service thread.
 833 // Used by release(), where we can&#39;t lock even Service_lock.
 834 void OopStorage::record_needs_cleanup() {
<span class="line-modified"> 835   // Set local flag first, else service thread could wake up and miss</span>
<span class="line-added"> 836   // the request.  This order may instead (rarely) unnecessarily notify.</span>
<span class="line-added"> 837   Atomic::release_store(&amp;_needs_cleanup, true);</span>
<span class="line-added"> 838   Atomic::release_store_fence(&amp;needs_cleanup_requested, true);</span>
 839 }
 840 
<span class="line-modified"> 841 bool OopStorage::delete_empty_blocks() {</span>
<span class="line-modified"> 842   // Service thread might have oopstorage work, but not for this object.</span>
<span class="line-modified"> 843   // Check for deferred updates even though that&#39;s not a service thread</span>
<span class="line-modified"> 844   // trigger; since we&#39;re here, we might as well process them.</span>
<span class="line-modified"> 845   if (!Atomic::load_acquire(&amp;_needs_cleanup) &amp;&amp;</span>
<span class="line-modified"> 846       (Atomic::load_acquire(&amp;_deferred_updates) == NULL)) {</span>
<span class="line-modified"> 847     return false;</span>
 848   }

 849 
<span class="line-modified"> 850   MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>

 851 
 852   // Clear the request before processing.
<span class="line-modified"> 853   Atomic::release_store_fence(&amp;_needs_cleanup, false);</span>

 854 
 855   // Other threads could be adding to the empty block count or the
 856   // deferred update list while we&#39;re working.  Set an upper bound on
 857   // how many updates we&#39;ll process and blocks we&#39;ll try to release,
 858   // so other threads can&#39;t cause an unbounded stay in this function.
<span class="line-modified"> 859   // We add a bit of slop because the reduce_deferred_updates clause</span>
<span class="line-modified"> 860   // can cause blocks to be double counted.  If there are few blocks</span>
<span class="line-added"> 861   // and many of them are deferred and empty, we might hit the limit</span>
<span class="line-added"> 862   // and spin the caller without doing very much work.  Otherwise,</span>
<span class="line-added"> 863   // we don&#39;t normally hit the limit anyway, instead running out of</span>
<span class="line-added"> 864   // work to do.</span>
<span class="line-added"> 865   size_t limit = block_count() + 10;</span>
 866 
 867   for (size_t i = 0; i &lt; limit; ++i) {
 868     // Process deferred updates, which might make empty blocks available.
 869     // Continue checking once deletion starts, since additional updates
 870     // might become available while we&#39;re working.
 871     if (reduce_deferred_updates()) {
 872       // Be safepoint-polite while looping.
<span class="line-modified"> 873       MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 874       ThreadBlockInVM tbiv(JavaThread::current());
 875     } else {
 876       Block* block = _allocation_list.tail();
 877       if ((block == NULL) || !block-&gt;is_empty()) {
 878         return false;
 879       } else if (!block-&gt;is_safe_to_delete()) {
 880         // Look for other work while waiting for block to be deletable.
 881         break;
 882       }
 883 
 884       // Try to delete the block.  First, try to remove from _active_array.
 885       {
<span class="line-modified"> 886         MutexLocker aml(_active_mutex, Mutex::_no_safepoint_check_flag);</span>
 887         // Don&#39;t interfere with an active concurrent iteration.
 888         // Instead, give up immediately.  There is more work to do,
 889         // but don&#39;t re-notify, to avoid useless spinning of the
 890         // service thread.  Instead, iteration completion notifies.
 891         if (_concurrent_iteration_count &gt; 0) return true;
 892         _active_array-&gt;remove(block);
 893       }
 894       // Remove block from _allocation_list and delete it.
 895       _allocation_list.unlink(*block);
 896       // Be safepoint-polite while deleting and looping.
<span class="line-modified"> 897       MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 898       delete_empty_block(*block);
 899       ThreadBlockInVM tbiv(JavaThread::current());
 900     }
 901   }
 902   // Exceeded work limit or can&#39;t delete last block.  This will
 903   // cause the service thread to loop, giving other subtasks an
 904   // opportunity to run too.  There&#39;s no need for a notification,
 905   // because we are part of the service thread (unless gtesting).
 906   record_needs_cleanup();
 907   return true;
 908 }
 909 
 910 OopStorage::EntryStatus OopStorage::allocation_status(const oop* ptr) const {
 911   const Block* block = find_block_or_null(ptr);
 912   if (block != NULL) {
 913     // Prevent block deletion and _active_array modification.
<span class="line-modified"> 914     MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);</span>
 915     // Block could be a false positive, so get index carefully.
 916     size_t index = Block::active_index_safe(block);
 917     if ((index &lt; _active_array-&gt;block_count()) &amp;&amp;
 918         (block == _active_array-&gt;at(index)) &amp;&amp;
 919         block-&gt;contains(ptr)) {
 920       if ((block-&gt;allocated_bitmask() &amp; block-&gt;bitmask_for_entry(ptr)) != 0) {
 921         return ALLOCATED_ENTRY;
 922       } else {
 923         return UNALLOCATED_ENTRY;
 924       }
 925     }
 926   }
 927   return INVALID_ENTRY;
 928 }
 929 
 930 size_t OopStorage::allocation_count() const {
 931   return _allocation_count;
 932 }
 933 
 934 size_t OopStorage::block_count() const {
</pre>
<hr />
<pre>
 962   _storage(storage),
 963   _active_array(_storage-&gt;obtain_active_array()),
 964   _block_count(0),              // initialized properly below
 965   _next_block(0),
 966   _estimated_thread_count(estimated_thread_count),
 967   _concurrent(concurrent)
 968 {
 969   assert(estimated_thread_count &gt; 0, &quot;estimated thread count must be positive&quot;);
 970   update_concurrent_iteration_count(1);
 971   // Get the block count *after* iteration state updated, so concurrent
 972   // empty block deletion is suppressed and can&#39;t reduce the count.  But
 973   // ensure the count we use was written after the block with that count
 974   // was fully initialized; see ActiveArray::push.
 975   _block_count = _active_array-&gt;block_count_acquire();
 976 }
 977 
 978 OopStorage::BasicParState::~BasicParState() {
 979   _storage-&gt;relinquish_block_array(_active_array);
 980   update_concurrent_iteration_count(-1);
 981   if (_concurrent) {
<span class="line-modified"> 982     // We may have deferred some cleanup work.</span>
<span class="line-modified"> 983     const_cast&lt;OopStorage*&gt;(_storage)-&gt;record_needs_cleanup();</span>
 984   }
 985 }
 986 
 987 void OopStorage::BasicParState::update_concurrent_iteration_count(int value) {
 988   if (_concurrent) {
<span class="line-modified"> 989     MutexLocker ml(_storage-&gt;_active_mutex, Mutex::_no_safepoint_check_flag);</span>
 990     _storage-&gt;_concurrent_iteration_count += value;
 991     assert(_storage-&gt;_concurrent_iteration_count &gt;= 0, &quot;invariant&quot;);
 992   }
 993 }
 994 
 995 bool OopStorage::BasicParState::claim_next_segment(IterationData* data) {
 996   data-&gt;_processed += data-&gt;_segment_end - data-&gt;_segment_start;
<span class="line-modified"> 997   size_t start = Atomic::load_acquire(&amp;_next_block);</span>
 998   if (start &gt;= _block_count) {
 999     return finish_iteration(data); // No more blocks available.
1000   }
1001   // Try to claim several at a time, but not *too* many.  We want to
1002   // avoid deciding there are many available and selecting a large
1003   // quantity, get delayed, and then end up claiming most or all of
1004   // the remaining largish amount of work, leaving nothing for other
1005   // threads to do.  But too small a step can lead to contention
1006   // over _next_block, esp. when the work per block is small.
1007   size_t max_step = 10;
1008   size_t remaining = _block_count - start;
1009   size_t step = MIN2(max_step, 1 + (remaining / _estimated_thread_count));
1010   // Atomic::add with possible overshoot.  This can perform better
1011   // than a CAS loop on some platforms when there is contention.
1012   // We can cope with the uncertainty by recomputing start/end from
1013   // the result of the add, and dealing with potential overshoot.
<span class="line-modified">1014   size_t end = Atomic::add(&amp;_next_block, step);</span>
1015   // _next_block may have changed, so recompute start from result of add.
1016   start = end - step;
1017   // _next_block may have changed so much that end has overshot.
1018   end = MIN2(end, _block_count);
1019   // _next_block may have changed so much that even start has overshot.
1020   if (start &lt; _block_count) {
1021     // Record claimed segment for iteration.
1022     data-&gt;_segment_start = start;
1023     data-&gt;_segment_end = end;
1024     return true;                // Success.
1025   } else {
1026     // No more blocks to claim.
1027     return finish_iteration(data);
1028   }
1029 }
1030 
1031 bool OopStorage::BasicParState::finish_iteration(const IterationData* data) const {
1032   log_info(oopstorage, blocks, stats)
1033           (&quot;Parallel iteration on %s: blocks = &quot; SIZE_FORMAT
1034            &quot;, processed = &quot; SIZE_FORMAT &quot; (%2.f%%)&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="modRefBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
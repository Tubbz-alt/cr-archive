<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/generation.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="generation.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generationCounters.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/generation.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,11 ***</span>
  #include &quot;gc/shared/collectorCounters.hpp&quot;
  #include &quot;gc/shared/referenceProcessor.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/memRegion.hpp&quot;
<span class="line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;memory/virtualspace.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;runtime/perfData.hpp&quot;
  
  // A Generation models a heap area for similarly-aged objects.
<span class="line-new-header">--- 28,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,24 ***</span>
  //
  // The Generation class hierarchy:
  //
  // Generation                      - abstract base class
  // - DefNewGeneration              - allocation area (copy collected)
<span class="line-removed">- //   - ParNewGeneration            - a DefNewGeneration that is collected by</span>
<span class="line-removed">- //                                   several threads</span>
  // - CardGeneration                 - abstract class adding offset array behavior
  //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)
<span class="line-removed">- //   - ConcurrentMarkSweepGeneration - Mostly Concurrent Mark Sweep Generation</span>
<span class="line-removed">- //                                       (Detlefs-Printezis refinement of</span>
<span class="line-removed">- //                                       Boehm-Demers-Schenker)</span>
  //
<span class="line-modified">! // The system configurations currently allowed are:</span>
  //
  //   DefNewGeneration + TenuredGeneration
  //
<span class="line-removed">- //   ParNewGeneration + ConcurrentMarkSweepGeneration</span>
<span class="line-removed">- //</span>
  
  class DefNewGeneration;
  class GCMemoryManager;
  class GenerationSpec;
  class CompactibleSpace;
<span class="line-new-header">--- 39,17 ---</span>
  //
  // The Generation class hierarchy:
  //
  // Generation                      - abstract base class
  // - DefNewGeneration              - allocation area (copy collected)
  // - CardGeneration                 - abstract class adding offset array behavior
  //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)
  //
<span class="line-modified">! // The system configuration currently allowed is:</span>
  //
  //   DefNewGeneration + TenuredGeneration
  //
  
  class DefNewGeneration;
  class GCMemoryManager;
  class GenerationSpec;
  class CompactibleSpace;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,13 ***</span>
  
   public:
    // The set of possible generation kinds.
    enum Name {
      DefNew,
<span class="line-removed">-     ParNew,</span>
      MarkSweepCompact,
<span class="line-removed">-     ConcurrentMarkSweep,</span>
      Other
    };
  
    enum SomePublicConstants {
      // Generations are GenGrain-aligned and have size that are multiples of
<span class="line-new-header">--- 113,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,11 ***</span>
    // &quot;word_sz&quot;.  If possible, allocate space for &quot;obj&quot;, copy obj into it
    // (taking care to copy &quot;m&quot; into the mark word when done, since the mark
    // word of &quot;obj&quot; may have been overwritten with a forwarding pointer, and
    // also taking care to copy the klass pointer *last*.  Returns the new
    // object if successful, or else NULL.
<span class="line-modified">!   virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);</span>
  
    // Informs the current generation that all par_promote_alloc&#39;s in the
    // collection have been completed; any supporting data structures can be
    // reset.  Default is to do nothing.
    virtual void par_promote_alloc_done(int thread_num) {}
<span class="line-new-header">--- 289,11 ---</span>
    // &quot;word_sz&quot;.  If possible, allocate space for &quot;obj&quot;, copy obj into it
    // (taking care to copy &quot;m&quot; into the mark word when done, since the mark
    // word of &quot;obj&quot; may have been overwritten with a forwarding pointer, and
    // also taking care to copy the klass pointer *last*.  Returns the new
    // object if successful, or else NULL.
<span class="line-modified">!   virtual oop par_promote(int thread_num, oop obj, markWord m, size_t word_sz);</span>
  
    // Informs the current generation that all par_promote_alloc&#39;s in the
    // collection have been completed; any supporting data structures can be
    // reset.  Default is to do nothing.
    virtual void par_promote_alloc_done(int thread_num) {}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,15 ***</span>
  
    // Iterate over all objects in the generation, calling &quot;cl.do_object&quot; on
    // each.
    virtual void object_iterate(ObjectClosure* cl);
  
<span class="line-removed">-   // Iterate over all safe objects in the generation, calling &quot;cl.do_object&quot; on</span>
<span class="line-removed">-   // each.  An object is safe if its references point to other objects in</span>
<span class="line-removed">-   // the heap.  This defaults to object_iterate() unless overridden.</span>
<span class="line-removed">-   virtual void safe_object_iterate(ObjectClosure* cl);</span>
<span class="line-removed">- </span>
    // Apply &quot;cl-&gt;do_oop&quot; to (the address of) all and only all the ref fields
    // in the current generation that contain pointers to objects in younger
    // generations. Objects allocated since the last &quot;save_marks&quot; call are
    // excluded.
    virtual void younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) = 0;
<span class="line-new-header">--- 468,10 ---</span>
</pre>
<center><a href="generation.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generationCounters.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/gcArguments.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="concurrentGCThread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcArguments.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcArguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2017, Red Hat, Inc. and/or its affiliates.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,39 ***</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shared/gcArguments.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  void GCArguments::initialize() {
    if (FullGCALot &amp;&amp; FLAG_IS_DEFAULT(MarkSweepAlwaysCompactCount)) {
      MarkSweepAlwaysCompactCount = 1;  // Move objects every gc.
    }
  
<span class="line-modified">!   if (!(UseParallelGC || UseParallelOldGC) &amp;&amp; FLAG_IS_DEFAULT(ScavengeBeforeFullGC)) {</span>
      FLAG_SET_DEFAULT(ScavengeBeforeFullGC, false);
    }
  
    if (GCTimeLimit == 100) {
      // Turn off gc-overhead-limit-exceeded checks
      FLAG_SET_DEFAULT(UseGCOverheadLimit, false);
    }
  
    if (MinHeapFreeRatio == 100) {
      // Keeping the heap 100% free is hard ;-) so limit it to 99%.
<span class="line-modified">!     FLAG_SET_ERGO(uintx, MinHeapFreeRatio, 99);</span>
    }
  
    if (!ClassUnloading) {
      // If class unloading is disabled, also disable concurrent class unloading.
<span class="line-modified">!     FLAG_SET_CMDLINE(bool, ClassUnloadingWithConcurrentMark, false);</span>
    }
  
    if (!FLAG_IS_DEFAULT(AllocateOldGenAt)) {
      // CompressedOops not supported when AllocateOldGenAt is set.
      LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
<span class="line-new-header">--- 22,44 ---</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/cardTableRS.hpp&quot;</span>
  #include &quot;gc/shared/gcArguments.hpp&quot;
<span class="line-added">+ #include &quot;logging/log.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;utilities/defaultStream.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
<span class="line-added">+ size_t HeapAlignment = 0;</span>
<span class="line-added">+ size_t SpaceAlignment = 0;</span>
<span class="line-added">+ </span>
  void GCArguments::initialize() {
    if (FullGCALot &amp;&amp; FLAG_IS_DEFAULT(MarkSweepAlwaysCompactCount)) {
      MarkSweepAlwaysCompactCount = 1;  // Move objects every gc.
    }
  
<span class="line-modified">!   if (!UseParallelGC &amp;&amp; FLAG_IS_DEFAULT(ScavengeBeforeFullGC)) {</span>
      FLAG_SET_DEFAULT(ScavengeBeforeFullGC, false);
    }
  
    if (GCTimeLimit == 100) {
      // Turn off gc-overhead-limit-exceeded checks
      FLAG_SET_DEFAULT(UseGCOverheadLimit, false);
    }
  
    if (MinHeapFreeRatio == 100) {
      // Keeping the heap 100% free is hard ;-) so limit it to 99%.
<span class="line-modified">!     FLAG_SET_ERGO(MinHeapFreeRatio, 99);</span>
    }
  
    if (!ClassUnloading) {
      // If class unloading is disabled, also disable concurrent class unloading.
<span class="line-modified">!     FLAG_SET_CMDLINE(ClassUnloadingWithConcurrentMark, false);</span>
    }
  
    if (!FLAG_IS_DEFAULT(AllocateOldGenAt)) {
      // CompressedOops not supported when AllocateOldGenAt is set.
      LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,19 ***</span>
      // Only young gen which is allocated in dram can use large pages, but we currently don&#39;t support that.
      FLAG_SET_DEFAULT(UseLargePages, false);
    }
  }
  
  bool GCArguments::check_args_consistency() {
    bool status = true;
    if (!FLAG_IS_DEFAULT(AllocateHeapAt) &amp;&amp; !FLAG_IS_DEFAULT(AllocateOldGenAt)) {
      jio_fprintf(defaultStream::error_stream(),
        &quot;AllocateHeapAt and AllocateOldGenAt cannot be used together.\n&quot;);
      status = false;
    }
<span class="line-modified">!   if (!FLAG_IS_DEFAULT(AllocateOldGenAt) &amp;&amp; (UseSerialGC || UseConcMarkSweepGC || UseEpsilonGC || UseZGC)) {</span>
      jio_fprintf(defaultStream::error_stream(),
        &quot;AllocateOldGenAt is not supported for selected GC.\n&quot;);
      status = false;
    }
    return status;
  }
<span class="line-new-header">--- 68,132 ---</span>
      // Only young gen which is allocated in dram can use large pages, but we currently don&#39;t support that.
      FLAG_SET_DEFAULT(UseLargePages, false);
    }
  }
  
<span class="line-added">+ void GCArguments::initialize_heap_sizes() {</span>
<span class="line-added">+   initialize_alignments();</span>
<span class="line-added">+   initialize_heap_flags_and_sizes();</span>
<span class="line-added">+   initialize_size_info();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t GCArguments::compute_heap_alignment() {</span>
<span class="line-added">+   // The card marking array and the offset arrays for old generations are</span>
<span class="line-added">+   // committed in os pages as well. Make sure they are entirely full (to</span>
<span class="line-added">+   // avoid partial page problems), e.g. if 512 bytes heap corresponds to 1</span>
<span class="line-added">+   // byte entry and the os page size is 4096, the maximum heap size should</span>
<span class="line-added">+   // be 512*4096 = 2MB aligned.</span>
<span class="line-added">+ </span>
<span class="line-added">+   size_t alignment = CardTableRS::ct_max_alignment_constraint();</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (UseLargePages) {</span>
<span class="line-added">+       // In presence of large pages we have to make sure that our</span>
<span class="line-added">+       // alignment is large page aware.</span>
<span class="line-added">+       alignment = lcm(os::large_page_size(), alignment);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return alignment;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool GCArguments::check_args_consistency() {
    bool status = true;
    if (!FLAG_IS_DEFAULT(AllocateHeapAt) &amp;&amp; !FLAG_IS_DEFAULT(AllocateOldGenAt)) {
      jio_fprintf(defaultStream::error_stream(),
        &quot;AllocateHeapAt and AllocateOldGenAt cannot be used together.\n&quot;);
      status = false;
    }
<span class="line-modified">!   if (!FLAG_IS_DEFAULT(AllocateOldGenAt) &amp;&amp; (UseSerialGC || UseEpsilonGC || UseZGC)) {</span>
      jio_fprintf(defaultStream::error_stream(),
        &quot;AllocateOldGenAt is not supported for selected GC.\n&quot;);
      status = false;
    }
    return status;
  }
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ void GCArguments::assert_flags() {</span>
<span class="line-added">+   assert(InitialHeapSize &lt;= MaxHeapSize, &quot;Ergonomics decided on incompatible initial and maximum heap sizes&quot;);</span>
<span class="line-added">+   assert(InitialHeapSize % HeapAlignment == 0, &quot;InitialHeapSize alignment&quot;);</span>
<span class="line-added">+   assert(MaxHeapSize % HeapAlignment == 0, &quot;MaxHeapSize alignment&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void GCArguments::assert_size_info() {</span>
<span class="line-added">+   assert(MaxHeapSize &gt;= MinHeapSize, &quot;Ergonomics decided on incompatible minimum and maximum heap sizes&quot;);</span>
<span class="line-added">+   assert(InitialHeapSize &gt;= MinHeapSize, &quot;Ergonomics decided on incompatible initial and minimum heap sizes&quot;);</span>
<span class="line-added">+   assert(MaxHeapSize &gt;= InitialHeapSize, &quot;Ergonomics decided on incompatible initial and maximum heap sizes&quot;);</span>
<span class="line-added">+   assert(MinHeapSize % HeapAlignment == 0, &quot;MinHeapSize alignment&quot;);</span>
<span class="line-added">+   assert(InitialHeapSize % HeapAlignment == 0, &quot;InitialHeapSize alignment&quot;);</span>
<span class="line-added">+   assert(MaxHeapSize % HeapAlignment == 0, &quot;MaxHeapSize alignment&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // ASSERT</span>
<span class="line-added">+ </span>
<span class="line-added">+ void GCArguments::initialize_size_info() {</span>
<span class="line-added">+   log_debug(gc, heap)(&quot;Minimum heap &quot; SIZE_FORMAT &quot;  Initial heap &quot; SIZE_FORMAT &quot;  Maximum heap &quot; SIZE_FORMAT,</span>
<span class="line-added">+                       MinHeapSize, InitialHeapSize, MaxHeapSize);</span>
<span class="line-added">+ </span>
<span class="line-added">+   DEBUG_ONLY(assert_size_info();)</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void GCArguments::initialize_heap_flags_and_sizes() {</span>
<span class="line-added">+   assert(SpaceAlignment != 0, &quot;Space alignment not set up properly&quot;);</span>
<span class="line-added">+   assert(HeapAlignment != 0, &quot;Heap alignment not set up properly&quot;);</span>
<span class="line-added">+   assert(HeapAlignment &gt;= SpaceAlignment,</span>
<span class="line-added">+          &quot;HeapAlignment: &quot; SIZE_FORMAT &quot; less than SpaceAlignment: &quot; SIZE_FORMAT,</span>
<span class="line-added">+          HeapAlignment, SpaceAlignment);</span>
<span class="line-added">+   assert(HeapAlignment % SpaceAlignment == 0,</span>
<span class="line-added">+          &quot;HeapAlignment: &quot; SIZE_FORMAT &quot; not aligned by SpaceAlignment: &quot; SIZE_FORMAT,</span>
<span class="line-added">+          HeapAlignment, SpaceAlignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (FLAG_IS_CMDLINE(MaxHeapSize)) {</span>
<span class="line-added">+     if (FLAG_IS_CMDLINE(InitialHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {</span>
<span class="line-added">+       vm_exit_during_initialization(&quot;Initial heap size set to a larger value than the maximum heap size&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (FLAG_IS_CMDLINE(MinHeapSize) &amp;&amp; MaxHeapSize &lt; MinHeapSize) {</span>
<span class="line-added">+       vm_exit_during_initialization(&quot;Incompatible minimum and maximum heap sizes specified&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Check heap parameter properties</span>
<span class="line-added">+   if (MaxHeapSize &lt; 2 * M) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Too small maximum heap&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (InitialHeapSize &lt; M) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Too small initial heap&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (MinHeapSize &lt; M) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Too small minimum heap&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // User inputs from -Xmx and -Xms must be aligned</span>
<span class="line-added">+   // Write back to flags if the values changed</span>
<span class="line-added">+   if (!is_aligned(MinHeapSize, HeapAlignment)) {</span>
<span class="line-added">+     FLAG_SET_ERGO(MinHeapSize, align_up(MinHeapSize, HeapAlignment));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!is_aligned(InitialHeapSize, HeapAlignment)) {</span>
<span class="line-added">+     FLAG_SET_ERGO(InitialHeapSize, align_up(InitialHeapSize, HeapAlignment));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (!is_aligned(MaxHeapSize, HeapAlignment)) {</span>
<span class="line-added">+     FLAG_SET_ERGO(MaxHeapSize, align_up(MaxHeapSize, HeapAlignment));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (FLAG_IS_CMDLINE(InitialHeapSize) &amp;&amp; FLAG_IS_CMDLINE(MinHeapSize) &amp;&amp;</span>
<span class="line-added">+       InitialHeapSize &lt; MinHeapSize) {</span>
<span class="line-added">+     vm_exit_during_initialization(&quot;Incompatible minimum and initial heap sizes specified&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!FLAG_IS_DEFAULT(InitialHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {</span>
<span class="line-added">+     FLAG_SET_ERGO(MaxHeapSize, InitialHeapSize);</span>
<span class="line-added">+   } else if (!FLAG_IS_DEFAULT(MaxHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {</span>
<span class="line-added">+     FLAG_SET_ERGO(InitialHeapSize, MaxHeapSize);</span>
<span class="line-added">+     if (InitialHeapSize &lt; MinHeapSize) {</span>
<span class="line-added">+       FLAG_SET_ERGO(MinHeapSize, InitialHeapSize);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (FLAG_IS_DEFAULT(SoftMaxHeapSize)) {</span>
<span class="line-added">+     FLAG_SET_ERGO(SoftMaxHeapSize, MaxHeapSize);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   FLAG_SET_ERGO(MinHeapDeltaBytes, align_up(MinHeapDeltaBytes, SpaceAlignment));</span>
<span class="line-added">+ </span>
<span class="line-added">+   DEBUG_ONLY(assert_flags();)</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="concurrentGCThread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcArguments.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
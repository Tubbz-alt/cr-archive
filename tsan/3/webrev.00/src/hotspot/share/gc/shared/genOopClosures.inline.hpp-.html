<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/genOopClosures.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP
 26 #define SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP
 27 
 28 #include &quot;gc/shared/cardTableRS.hpp&quot;
 29 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 30 #include &quot;gc/shared/genOopClosures.hpp&quot;
 31 #include &quot;gc/shared/generation.hpp&quot;
 32 #include &quot;gc/shared/space.hpp&quot;
 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/compressedOops.inline.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #if INCLUDE_SERIALGC
 37 #include &quot;gc/serial/defNewGeneration.inline.hpp&quot;
 38 #endif
 39 
 40 inline OopsInGenClosure::OopsInGenClosure(Generation* gen) :
 41   OopIterateClosure(gen-&gt;ref_processor()), _orig_gen(gen), _rs(NULL) {
 42   set_generation(gen);
 43 }
 44 
 45 inline void OopsInGenClosure::set_generation(Generation* gen) {
 46   _gen = gen;
 47   _gen_boundary = _gen-&gt;reserved().start();
 48   // Barrier set for the heap, must be set after heap is initialized
 49   if (_rs == NULL) {
 50     _rs = GenCollectedHeap::heap()-&gt;rem_set();
 51   }
 52 }
 53 
 54 template &lt;class T&gt; inline void OopsInGenClosure::do_barrier(T* p) {
 55   assert(generation()-&gt;is_in_reserved(p), &quot;expected ref in generation&quot;);
 56   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 57   assert(!CompressedOops::is_null(heap_oop), &quot;expected non-null oop&quot;);
 58   oop obj = CompressedOops::decode_not_null(heap_oop);
 59   // If p points to a younger generation, mark the card.
 60   if ((HeapWord*)obj &lt; _gen_boundary) {
 61     _rs-&gt;inline_write_ref_field_gc(p, obj);
 62   }
 63 }
 64 
 65 template &lt;class T&gt; inline void OopsInGenClosure::par_do_barrier(T* p) {
 66   assert(generation()-&gt;is_in_reserved(p), &quot;expected ref in generation&quot;);
 67   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 68   assert(!CompressedOops::is_null(heap_oop), &quot;expected non-null oop&quot;);
 69   oop obj = CompressedOops::decode_not_null(heap_oop);
 70   // If p points to a younger generation, mark the card.
 71   if ((HeapWord*)obj &lt; gen_boundary()) {
 72     rs()-&gt;write_ref_field_gc_par(p, obj);
 73   }
 74 }
 75 
 76 inline BasicOopsInGenClosure::BasicOopsInGenClosure(Generation* gen) : OopsInGenClosure(gen) {
 77 }
 78 
 79 inline void OopsInClassLoaderDataOrGenClosure::do_cld_barrier() {
 80   assert(_scanned_cld != NULL, &quot;Must be&quot;);
 81   if (!_scanned_cld-&gt;has_modified_oops()) {
 82     _scanned_cld-&gt;record_modified_oops();
 83   }
 84 }
 85 
 86 #if INCLUDE_SERIALGC
 87 
 88 // NOTE! Any changes made here should also be made
 89 // in FastScanClosure::do_oop_work()
 90 template &lt;class T&gt; inline void ScanClosure::do_oop_work(T* p) {
 91   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 92   // Should we copy the obj?
 93   if (!CompressedOops::is_null(heap_oop)) {
 94     oop obj = CompressedOops::decode_not_null(heap_oop);
 95     if ((HeapWord*)obj &lt; _boundary) {
 96       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
 97       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
 98                                         : _g-&gt;copy_to_survivor_space(obj);
 99       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
100     }
101 
102     if (is_scanning_a_cld()) {
103       do_cld_barrier();
104     } else if (_gc_barrier) {
105       // Now call parent closure
106       do_barrier(p);
107     }
108   }
109 }
110 
111 inline void ScanClosure::do_oop(oop* p)       { ScanClosure::do_oop_work(p); }
112 inline void ScanClosure::do_oop(narrowOop* p) { ScanClosure::do_oop_work(p); }
113 
114 // NOTE! Any changes made here should also be made
115 // in ScanClosure::do_oop_work()
116 template &lt;class T&gt; inline void FastScanClosure::do_oop_work(T* p) {
117   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
118   // Should we copy the obj?
119   if (!CompressedOops::is_null(heap_oop)) {
120     oop obj = CompressedOops::decode_not_null(heap_oop);
121     if ((HeapWord*)obj &lt; _boundary) {
122       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
123       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
124                                         : _g-&gt;copy_to_survivor_space(obj);
125       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
126       if (is_scanning_a_cld()) {
127         do_cld_barrier();
128       } else if (_gc_barrier) {
129         // Now call parent closure
130         do_barrier(p);
131       }
132     }
133   }
134 }
135 
136 inline void FastScanClosure::do_oop(oop* p)       { FastScanClosure::do_oop_work(p); }
137 inline void FastScanClosure::do_oop(narrowOop* p) { FastScanClosure::do_oop_work(p); }
138 
139 #endif // INCLUDE_SERIALGC
140 
141 template &lt;class T&gt; void FilteringClosure::do_oop_work(T* p) {
142   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
143   if (!CompressedOops::is_null(heap_oop)) {
144     oop obj = CompressedOops::decode_not_null(heap_oop);
145     if ((HeapWord*)obj &lt; _boundary) {
146       _cl-&gt;do_oop(p);
147     }
148   }
149 }
150 
151 inline void FilteringClosure::do_oop(oop* p)       { FilteringClosure::do_oop_work(p); }
152 inline void FilteringClosure::do_oop(narrowOop* p) { FilteringClosure::do_oop_work(p); }
153 
154 #if INCLUDE_SERIALGC
155 
156 // Note similarity to ScanClosure; the difference is that
157 // the barrier set is taken care of outside this closure.
158 template &lt;class T&gt; inline void ScanWeakRefClosure::do_oop_work(T* p) {
159   oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
160   // weak references are sometimes scanned twice; must check
161   // that to-space doesn&#39;t already contain this object
162   if ((HeapWord*)obj &lt; _boundary &amp;&amp; !_g-&gt;to()-&gt;is_in_reserved(obj)) {
163     oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
164                                       : _g-&gt;copy_to_survivor_space(obj);
165     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
166   }
167 }
168 
169 inline void ScanWeakRefClosure::do_oop(oop* p)       { ScanWeakRefClosure::do_oop_work(p); }
170 inline void ScanWeakRefClosure::do_oop(narrowOop* p) { ScanWeakRefClosure::do_oop_work(p); }
171 
172 #endif // INCLUDE_SERIALGC
173 
174 #endif // SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP
    </pre>
  </body>
</html>
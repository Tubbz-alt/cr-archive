<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/weakProcessorPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="weakProcessor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="weakProcessorPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/weakProcessorPhaseTimes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 27 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 28 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/ticks.hpp&quot;
 34 
<span class="line-modified"> 35 static uint phase_index(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 36   return WeakProcessorPhases::index(phase);</span>
 37 }
 38 
 39 static bool is_serial_phase(WeakProcessorPhase phase) {
 40   return WeakProcessorPhases::is_serial(phase);
 41 }
 42 
<span class="line-modified"> 43 static void assert_oop_storage_phase(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 44   assert(WeakProcessorPhases::is_oop_storage(phase),</span>
<span class="line-modified"> 45          &quot;Not an oop_storage phase %u&quot;, phase_index(phase));</span>





 46 }
 47 
 48 const double uninitialized_time = -1.0;
 49 
 50 #ifdef ASSERT
 51 static bool is_initialized_time(double t) { return t &gt;= 0.0; }
 52 static bool is_initialized_items(size_t i) { return i != 0; }
 53 #endif // ASSERT
 54 
 55 static void reset_times(double* times, size_t ntimes) {
 56   for (size_t i = 0; i &lt; ntimes; ++i) {
 57     times[i] = uninitialized_time;
 58   }
 59 }
 60 
 61 static void reset_items(size_t* items, size_t nitems) {
 62   for (size_t i = 0; i &lt; nitems; ++i) {
 63     items[i] = 0;
 64   }
 65 }
 66 






 67 WeakProcessorPhaseTimes::WeakProcessorPhaseTimes(uint max_threads) :
 68   _max_threads(max_threads),
 69   _active_workers(0),
 70   _total_time_sec(uninitialized_time),
<span class="line-modified"> 71   _worker_data(),</span>
<span class="line-removed"> 72   _worker_dead_items(),</span>
<span class="line-removed"> 73   _worker_total_items()</span>
 74 {
 75   assert(_max_threads &gt; 0, &quot;max_threads must not be zero&quot;);
 76 
<span class="line-modified"> 77   reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));</span>
<span class="line-modified"> 78   reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));</span>
<span class="line-modified"> 79   reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));</span>
<span class="line-modified"> 80 </span>
<span class="line-modified"> 81   if (_max_threads &gt; 1) {</span>
<span class="line-modified"> 82     WorkerDataArray&lt;double&gt;** wpt = _worker_data;</span>
<span class="line-modified"> 83     FOR_EACH_WEAK_PROCESSOR_OOP_STORAGE_PHASE(phase) {</span>
<span class="line-modified"> 84       const char* description = WeakProcessorPhases::description(phase);</span>
<span class="line-modified"> 85       *wpt = new WorkerDataArray&lt;double&gt;(_max_threads, description);</span>
<span class="line-modified"> 86       (*wpt)-&gt;link_thread_work_items(new WorkerDataArray&lt;size_t&gt;(_max_threads, &quot;Dead&quot;), DeadItems);</span>
<span class="line-modified"> 87       (*wpt)-&gt;link_thread_work_items(new WorkerDataArray&lt;size_t&gt;(_max_threads, &quot;Total&quot;), TotalItems);</span>
<span class="line-removed"> 88       wpt++;</span>
<span class="line-removed"> 89     }</span>
 90   }

 91 }
 92 
 93 WeakProcessorPhaseTimes::~WeakProcessorPhaseTimes() {
 94   for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {
 95     delete _worker_data[i];
<span class="line-removed"> 96     delete _worker_dead_items[i];</span>
<span class="line-removed"> 97     delete _worker_total_items[i];</span>
 98   }
 99 }
100 
101 uint WeakProcessorPhaseTimes::max_threads() const { return _max_threads; }
102 
103 uint WeakProcessorPhaseTimes::active_workers() const {
104   assert(_active_workers != 0, &quot;active workers not set&quot;);
105   return _active_workers;
106 }
107 
108 void WeakProcessorPhaseTimes::set_active_workers(uint n) {
109   assert(_active_workers == 0, &quot;active workers already set&quot;);
110   assert(n &gt; 0, &quot;active workers must be non-zero&quot;);
111   assert(n &lt;= _max_threads, &quot;active workers must not exceed max threads&quot;);
112   _active_workers = n;
113 }
114 
115 void WeakProcessorPhaseTimes::reset() {
116   _active_workers = 0;
117   _total_time_sec = uninitialized_time;
<span class="line-modified">118   reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));</span>
<span class="line-modified">119   reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));</span>
<span class="line-modified">120   reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));</span>
<span class="line-removed">121   if (_max_threads &gt; 1) {</span>
<span class="line-removed">122     for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {</span>
<span class="line-removed">123       _worker_data[i]-&gt;reset();</span>
<span class="line-removed">124     }</span>
125   }
126 }
127 
128 double WeakProcessorPhaseTimes::total_time_sec() const {
129   assert(is_initialized_time(_total_time_sec), &quot;Total time not set&quot;);
130   return _total_time_sec;
131 }
132 
133 void WeakProcessorPhaseTimes::record_total_time_sec(double time_sec) {
134   assert(!is_initialized_time(_total_time_sec), &quot;Already set total time&quot;);
135   _total_time_sec = time_sec;
136 }
137 
138 double WeakProcessorPhaseTimes::phase_time_sec(WeakProcessorPhase phase) const {
<span class="line-modified">139   assert(is_initialized_time(_phase_times_sec[phase_index(phase)]),</span>
<span class="line-modified">140          &quot;phase time not set %u&quot;, phase_index(phase));</span>
<span class="line-modified">141   return _phase_times_sec[phase_index(phase)];</span>

142 }
143 
144 void WeakProcessorPhaseTimes::record_phase_time_sec(WeakProcessorPhase phase, double time_sec) {
<span class="line-modified">145   assert(!is_initialized_time(_phase_times_sec[phase_index(phase)]),</span>
<span class="line-modified">146          &quot;Already set time for phase %u&quot;, phase_index(phase));</span>
<span class="line-modified">147   _phase_times_sec[phase_index(phase)] = time_sec;</span>

148 }
149 
150 void WeakProcessorPhaseTimes::record_phase_items(WeakProcessorPhase phase, size_t num_dead, size_t num_total) {
<span class="line-modified">151   uint p = phase_index(phase);</span>

152   assert(!is_initialized_items(_phase_dead_items[p]),
153          &quot;Already set dead items for phase %u&quot;, p);
154   assert(!is_initialized_items(_phase_total_items[p]),
155          &quot;Already set total items for phase %u&quot;, p);
156   _phase_dead_items[p] = num_dead;
157   _phase_total_items[p] = num_total;
158 }
159 
160 WorkerDataArray&lt;double&gt;* WeakProcessorPhaseTimes::worker_data(WeakProcessorPhase phase) const {
<span class="line-modified">161   assert_oop_storage_phase(phase);</span>
<span class="line-modified">162   assert(active_workers() &gt; 1, &quot;No worker data when single-threaded&quot;);</span>
<span class="line-removed">163   return _worker_data[WeakProcessorPhases::oop_storage_index(phase)];</span>
164 }
165 
166 double WeakProcessorPhaseTimes::worker_time_sec(uint worker_id, WeakProcessorPhase phase) const {
167   assert(worker_id &lt; active_workers(),
168          &quot;invalid worker id %u for %u&quot;, worker_id, active_workers());
<span class="line-modified">169   if (active_workers() == 1) {</span>
<span class="line-removed">170     return phase_time_sec(phase);</span>
<span class="line-removed">171   } else {</span>
<span class="line-removed">172     return worker_data(phase)-&gt;get(worker_id);</span>
<span class="line-removed">173   }</span>
174 }
175 
176 void WeakProcessorPhaseTimes::record_worker_time_sec(uint worker_id,
177                                                      WeakProcessorPhase phase,
178                                                      double time_sec) {
<span class="line-modified">179   if (active_workers() == 1) {</span>
<span class="line-removed">180     record_phase_time_sec(phase, time_sec);</span>
<span class="line-removed">181   } else {</span>
<span class="line-removed">182     worker_data(phase)-&gt;set(worker_id, time_sec);</span>
<span class="line-removed">183   }</span>
184 }
185 
186 void WeakProcessorPhaseTimes::record_worker_items(uint worker_id,
187                                                   WeakProcessorPhase phase,
188                                                   size_t num_dead,
189                                                   size_t num_total) {
<span class="line-modified">190   if (active_workers() == 1) {</span>
<span class="line-modified">191     record_phase_items(phase, num_dead, num_total);</span>
<span class="line-modified">192   } else {</span>
<span class="line-removed">193     worker_data(phase)-&gt;set_or_add_thread_work_item(worker_id, num_dead, DeadItems);</span>
<span class="line-removed">194     worker_data(phase)-&gt;set_or_add_thread_work_item(worker_id, num_total, TotalItems);</span>
<span class="line-removed">195   }</span>
196 }
197 
198 static double elapsed_time_sec(Ticks start_time, Ticks end_time) {
199   return (end_time - start_time).seconds();
200 }
201 
202 WeakProcessorTimeTracker::WeakProcessorTimeTracker(WeakProcessorPhaseTimes* times) :
203   _times(times),
204   _start_time(Ticks::now())
205 {}
206 
207 WeakProcessorTimeTracker::~WeakProcessorTimeTracker() {
208   if (_times != NULL) {
209     Ticks end_time = Ticks::now();
210     _times-&gt;record_total_time_sec(elapsed_time_sec(_start_time, end_time));
211   }
212 }
213 
214 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
215                                                              WeakProcessorPhase phase,
216                                                              uint worker_id) :
217   _times(times),
218   _phase(phase),
219   _worker_id(worker_id),
220   _start_time(Ticks::now())
221 {
<span class="line-modified">222   assert_oop_storage_phase(_phase);</span>
223   assert(_times == NULL || worker_id &lt; _times-&gt;active_workers(),
224          &quot;Invalid worker_id %u&quot;, worker_id);
225 }
226 
227 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
228                                                              WeakProcessorPhase phase) :
229   _times(times),
230   _phase(phase),
231   _worker_id(0),
232   _start_time(Ticks::now())
233 {
<span class="line-modified">234   assert(is_serial_phase(phase), &quot;Not a serial phase %u&quot;, phase_index(phase));</span>
235 }
236 
237 WeakProcessorPhaseTimeTracker::~WeakProcessorPhaseTimeTracker() {
238   if (_times != NULL) {
239     double time_sec = elapsed_time_sec(_start_time, Ticks::now());
240     if (is_serial_phase(_phase)) {
241       _times-&gt;record_phase_time_sec(_phase, time_sec);
242     } else {
243       _times-&gt;record_worker_time_sec(_worker_id, _phase, time_sec);
244     }
245   }
246 }
247 
248 //////////////////////////////////////////////////////////////////////////////
249 // Printing times
250 
251 const char* const indents[] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;};
252 const size_t max_indents_index = ARRAY_SIZE(indents) - 1;
253 
254 static const char* indent_str(size_t i) {
255   return indents[MIN2(i, max_indents_index)];
256 }
257 
258 #define TIME_FORMAT &quot;%.1lfms&quot;
259 
260 void WeakProcessorPhaseTimes::log_st_phase(WeakProcessorPhase phase,
261                                            uint indent) const {

262   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
263                         indent_str(indent),
264                         WeakProcessorPhases::description(phase),
265                         phase_time_sec(phase) * MILLIUNITS);
266 
267   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
268                         indent_str(indent + 1),
269                         &quot;Dead&quot;,
<span class="line-modified">270                         _phase_dead_items[phase_index(phase)]);</span>
271 
272   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
273                         indent_str(indent + 1),
274                         &quot;Total&quot;,
<span class="line-modified">275                         _phase_total_items[phase_index(phase)]);</span>
276 }
277 
278 void WeakProcessorPhaseTimes::log_mt_phase_summary(WeakProcessorPhase phase,
279                                                    uint indent) const {
280   LogTarget(Debug, gc, phases) lt;
281   LogStream ls(lt);
282   ls.print(&quot;%s&quot;, indents[indent]);
283   worker_data(phase)-&gt;print_summary_on(&amp;ls, true);
284   log_mt_phase_details(worker_data(phase), indent + 1);
285 
286   for (uint i = 0; i &lt; worker_data(phase)-&gt;MaxThreadWorkItems; i++) {
287     WorkerDataArray&lt;size_t&gt;* work_items = worker_data(phase)-&gt;thread_work_items(i);
288     if (work_items != NULL) {
289       ls.print(&quot;%s&quot;, indents[indent + 1]);
290       work_items-&gt;print_summary_on(&amp;ls, true);
291       log_mt_phase_details(work_items, indent + 1);
292     }
293   }
294 }
295 
296 template &lt;typename T&gt;
297 void WeakProcessorPhaseTimes::log_mt_phase_details(WorkerDataArray&lt;T&gt;* data,
298                                                    uint indent) const {
299   LogTarget(Trace, gc, phases) lt;
300   if (lt.is_enabled()) {
301     LogStream ls(lt);
302     ls.print(&quot;%s&quot;, indents[indent]);
303     data-&gt;print_details_on(&amp;ls);
304   }
305 }
306 
307 void WeakProcessorPhaseTimes::log_print_phases(uint indent) const {
308   if (log_is_enabled(Debug, gc, phases)) {
<span class="line-modified">309     FOR_EACH_WEAK_PROCESSOR_PHASE(phase) {</span>
<span class="line-modified">310       if (is_serial_phase(phase) || (active_workers() == 1)) {</span>
<span class="line-modified">311         log_st_phase(phase, indent);</span>
<span class="line-modified">312       } else {</span>
<span class="line-modified">313         log_mt_phase_summary(phase, indent);</span>
<span class="line-modified">314       }</span>
315     }
316   }
317 }
318 
319 void WeakProcessorPhaseTimes::log_print(uint indent) const {
320   if (log_is_enabled(Debug, gc, phases)) {
321     log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
322                           indent_str(indent),
323                           &quot;Weak Processing&quot;,
324                           total_time_sec() * MILLIUNITS);
325     log_print_phases(indent + 1);
326   }
327 }
</pre>
</td>
<td>
<hr />
<pre>
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;gc/shared/oopStorage.hpp&quot;</span>
 27 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 28 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 29 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/globalDefinitions.hpp&quot;
 34 #include &quot;utilities/ticks.hpp&quot;
 35 
<span class="line-modified"> 36 static uint serial_phase_index(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 37   return WeakProcessorPhases::serial_index(phase);</span>
 38 }
 39 
 40 static bool is_serial_phase(WeakProcessorPhase phase) {
 41   return WeakProcessorPhases::is_serial(phase);
 42 }
 43 
<span class="line-modified"> 44 static void assert_serial_phase(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 45   assert(is_serial_phase(phase),</span>
<span class="line-modified"> 46          &quot;Not a serial phase %u&quot;, static_cast&lt;uint&gt;(phase));</span>
<span class="line-added"> 47 }</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 static void assert_oopstorage_phase(WeakProcessorPhase phase) {</span>
<span class="line-added"> 50   assert(WeakProcessorPhases::is_oopstorage(phase),</span>
<span class="line-added"> 51          &quot;Not an oopstorage phase %u&quot;, static_cast&lt;uint&gt;(phase));</span>
 52 }
 53 
 54 const double uninitialized_time = -1.0;
 55 
 56 #ifdef ASSERT
 57 static bool is_initialized_time(double t) { return t &gt;= 0.0; }
 58 static bool is_initialized_items(size_t i) { return i != 0; }
 59 #endif // ASSERT
 60 
 61 static void reset_times(double* times, size_t ntimes) {
 62   for (size_t i = 0; i &lt; ntimes; ++i) {
 63     times[i] = uninitialized_time;
 64   }
 65 }
 66 
 67 static void reset_items(size_t* items, size_t nitems) {
 68   for (size_t i = 0; i &lt; nitems; ++i) {
 69     items[i] = 0;
 70   }
 71 }
 72 
<span class="line-added"> 73 void WeakProcessorPhaseTimes::reset_phase_data() {</span>
<span class="line-added"> 74   reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));</span>
<span class="line-added"> 75   reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));</span>
<span class="line-added"> 76   reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));</span>
<span class="line-added"> 77 }</span>
<span class="line-added"> 78 </span>
 79 WeakProcessorPhaseTimes::WeakProcessorPhaseTimes(uint max_threads) :
 80   _max_threads(max_threads),
 81   _active_workers(0),
 82   _total_time_sec(uninitialized_time),
<span class="line-modified"> 83   _worker_data()</span>


 84 {
 85   assert(_max_threads &gt; 0, &quot;max_threads must not be zero&quot;);
 86 
<span class="line-modified"> 87   reset_phase_data();</span>
<span class="line-modified"> 88 </span>
<span class="line-modified"> 89   WorkerDataArray&lt;double&gt;** wpt = _worker_data;</span>
<span class="line-modified"> 90   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified"> 91   for ( ; !it.is_end(); ++it) {</span>
<span class="line-modified"> 92     assert(size_t(wpt - _worker_data) &lt; ARRAY_SIZE(_worker_data), &quot;invariant&quot;);</span>
<span class="line-modified"> 93     const char* description = it-&gt;name();</span>
<span class="line-modified"> 94     *wpt = new WorkerDataArray&lt;double&gt;(description, _max_threads);</span>
<span class="line-modified"> 95     (*wpt)-&gt;create_thread_work_items(&quot;Dead&quot;, DeadItems);</span>
<span class="line-modified"> 96     (*wpt)-&gt;create_thread_work_items(&quot;Total&quot;, TotalItems);</span>
<span class="line-modified"> 97     wpt++;</span>


 98   }
<span class="line-added"> 99   assert(size_t(wpt - _worker_data) == ARRAY_SIZE(_worker_data), &quot;invariant&quot;);</span>
100 }
101 
102 WeakProcessorPhaseTimes::~WeakProcessorPhaseTimes() {
103   for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {
104     delete _worker_data[i];


105   }
106 }
107 
108 uint WeakProcessorPhaseTimes::max_threads() const { return _max_threads; }
109 
110 uint WeakProcessorPhaseTimes::active_workers() const {
111   assert(_active_workers != 0, &quot;active workers not set&quot;);
112   return _active_workers;
113 }
114 
115 void WeakProcessorPhaseTimes::set_active_workers(uint n) {
116   assert(_active_workers == 0, &quot;active workers already set&quot;);
117   assert(n &gt; 0, &quot;active workers must be non-zero&quot;);
118   assert(n &lt;= _max_threads, &quot;active workers must not exceed max threads&quot;);
119   _active_workers = n;
120 }
121 
122 void WeakProcessorPhaseTimes::reset() {
123   _active_workers = 0;
124   _total_time_sec = uninitialized_time;
<span class="line-modified">125   reset_phase_data();</span>
<span class="line-modified">126   for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {</span>
<span class="line-modified">127     _worker_data[i]-&gt;reset();</span>




128   }
129 }
130 
131 double WeakProcessorPhaseTimes::total_time_sec() const {
132   assert(is_initialized_time(_total_time_sec), &quot;Total time not set&quot;);
133   return _total_time_sec;
134 }
135 
136 void WeakProcessorPhaseTimes::record_total_time_sec(double time_sec) {
137   assert(!is_initialized_time(_total_time_sec), &quot;Already set total time&quot;);
138   _total_time_sec = time_sec;
139 }
140 
141 double WeakProcessorPhaseTimes::phase_time_sec(WeakProcessorPhase phase) const {
<span class="line-modified">142   assert_serial_phase(phase);</span>
<span class="line-modified">143   assert(is_initialized_time(_phase_times_sec[serial_phase_index(phase)]),</span>
<span class="line-modified">144          &quot;phase time not set %u&quot;, serial_phase_index(phase));</span>
<span class="line-added">145   return _phase_times_sec[serial_phase_index(phase)];</span>
146 }
147 
148 void WeakProcessorPhaseTimes::record_phase_time_sec(WeakProcessorPhase phase, double time_sec) {
<span class="line-modified">149   assert_serial_phase(phase);</span>
<span class="line-modified">150   assert(!is_initialized_time(_phase_times_sec[serial_phase_index(phase)]),</span>
<span class="line-modified">151          &quot;Already set time for phase %u&quot;, serial_phase_index(phase));</span>
<span class="line-added">152   _phase_times_sec[serial_phase_index(phase)] = time_sec;</span>
153 }
154 
155 void WeakProcessorPhaseTimes::record_phase_items(WeakProcessorPhase phase, size_t num_dead, size_t num_total) {
<span class="line-modified">156   assert_serial_phase(phase);</span>
<span class="line-added">157   uint p = serial_phase_index(phase);</span>
158   assert(!is_initialized_items(_phase_dead_items[p]),
159          &quot;Already set dead items for phase %u&quot;, p);
160   assert(!is_initialized_items(_phase_total_items[p]),
161          &quot;Already set total items for phase %u&quot;, p);
162   _phase_dead_items[p] = num_dead;
163   _phase_total_items[p] = num_total;
164 }
165 
166 WorkerDataArray&lt;double&gt;* WeakProcessorPhaseTimes::worker_data(WeakProcessorPhase phase) const {
<span class="line-modified">167   assert_oopstorage_phase(phase);</span>
<span class="line-modified">168   return _worker_data[WeakProcessorPhases::oopstorage_index(phase)];</span>

169 }
170 
171 double WeakProcessorPhaseTimes::worker_time_sec(uint worker_id, WeakProcessorPhase phase) const {
172   assert(worker_id &lt; active_workers(),
173          &quot;invalid worker id %u for %u&quot;, worker_id, active_workers());
<span class="line-modified">174   return worker_data(phase)-&gt;get(worker_id);</span>




175 }
176 
177 void WeakProcessorPhaseTimes::record_worker_time_sec(uint worker_id,
178                                                      WeakProcessorPhase phase,
179                                                      double time_sec) {
<span class="line-modified">180   worker_data(phase)-&gt;set(worker_id, time_sec);</span>




181 }
182 
183 void WeakProcessorPhaseTimes::record_worker_items(uint worker_id,
184                                                   WeakProcessorPhase phase,
185                                                   size_t num_dead,
186                                                   size_t num_total) {
<span class="line-modified">187   WorkerDataArray&lt;double&gt;* phase_data = worker_data(phase);</span>
<span class="line-modified">188   phase_data-&gt;set_or_add_thread_work_item(worker_id, num_dead, DeadItems);</span>
<span class="line-modified">189   phase_data-&gt;set_or_add_thread_work_item(worker_id, num_total, TotalItems);</span>



190 }
191 
192 static double elapsed_time_sec(Ticks start_time, Ticks end_time) {
193   return (end_time - start_time).seconds();
194 }
195 
196 WeakProcessorTimeTracker::WeakProcessorTimeTracker(WeakProcessorPhaseTimes* times) :
197   _times(times),
198   _start_time(Ticks::now())
199 {}
200 
201 WeakProcessorTimeTracker::~WeakProcessorTimeTracker() {
202   if (_times != NULL) {
203     Ticks end_time = Ticks::now();
204     _times-&gt;record_total_time_sec(elapsed_time_sec(_start_time, end_time));
205   }
206 }
207 
208 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
209                                                              WeakProcessorPhase phase,
210                                                              uint worker_id) :
211   _times(times),
212   _phase(phase),
213   _worker_id(worker_id),
214   _start_time(Ticks::now())
215 {
<span class="line-modified">216   assert_oopstorage_phase(_phase);</span>
217   assert(_times == NULL || worker_id &lt; _times-&gt;active_workers(),
218          &quot;Invalid worker_id %u&quot;, worker_id);
219 }
220 
221 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
222                                                              WeakProcessorPhase phase) :
223   _times(times),
224   _phase(phase),
225   _worker_id(0),
226   _start_time(Ticks::now())
227 {
<span class="line-modified">228   assert_serial_phase(phase);</span>
229 }
230 
231 WeakProcessorPhaseTimeTracker::~WeakProcessorPhaseTimeTracker() {
232   if (_times != NULL) {
233     double time_sec = elapsed_time_sec(_start_time, Ticks::now());
234     if (is_serial_phase(_phase)) {
235       _times-&gt;record_phase_time_sec(_phase, time_sec);
236     } else {
237       _times-&gt;record_worker_time_sec(_worker_id, _phase, time_sec);
238     }
239   }
240 }
241 
242 //////////////////////////////////////////////////////////////////////////////
243 // Printing times
244 
245 const char* const indents[] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;};
246 const size_t max_indents_index = ARRAY_SIZE(indents) - 1;
247 
248 static const char* indent_str(size_t i) {
249   return indents[MIN2(i, max_indents_index)];
250 }
251 
252 #define TIME_FORMAT &quot;%.1lfms&quot;
253 
254 void WeakProcessorPhaseTimes::log_st_phase(WeakProcessorPhase phase,
255                                            uint indent) const {
<span class="line-added">256   assert_serial_phase(phase);</span>
257   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
258                         indent_str(indent),
259                         WeakProcessorPhases::description(phase),
260                         phase_time_sec(phase) * MILLIUNITS);
261 
262   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
263                         indent_str(indent + 1),
264                         &quot;Dead&quot;,
<span class="line-modified">265                         _phase_dead_items[serial_phase_index(phase)]);</span>
266 
267   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
268                         indent_str(indent + 1),
269                         &quot;Total&quot;,
<span class="line-modified">270                         _phase_total_items[serial_phase_index(phase)]);</span>
271 }
272 
273 void WeakProcessorPhaseTimes::log_mt_phase_summary(WeakProcessorPhase phase,
274                                                    uint indent) const {
275   LogTarget(Debug, gc, phases) lt;
276   LogStream ls(lt);
277   ls.print(&quot;%s&quot;, indents[indent]);
278   worker_data(phase)-&gt;print_summary_on(&amp;ls, true);
279   log_mt_phase_details(worker_data(phase), indent + 1);
280 
281   for (uint i = 0; i &lt; worker_data(phase)-&gt;MaxThreadWorkItems; i++) {
282     WorkerDataArray&lt;size_t&gt;* work_items = worker_data(phase)-&gt;thread_work_items(i);
283     if (work_items != NULL) {
284       ls.print(&quot;%s&quot;, indents[indent + 1]);
285       work_items-&gt;print_summary_on(&amp;ls, true);
286       log_mt_phase_details(work_items, indent + 1);
287     }
288   }
289 }
290 
291 template &lt;typename T&gt;
292 void WeakProcessorPhaseTimes::log_mt_phase_details(WorkerDataArray&lt;T&gt;* data,
293                                                    uint indent) const {
294   LogTarget(Trace, gc, phases) lt;
295   if (lt.is_enabled()) {
296     LogStream ls(lt);
297     ls.print(&quot;%s&quot;, indents[indent]);
298     data-&gt;print_details_on(&amp;ls);
299   }
300 }
301 
302 void WeakProcessorPhaseTimes::log_print_phases(uint indent) const {
303   if (log_is_enabled(Debug, gc, phases)) {
<span class="line-modified">304     typedef WeakProcessorPhases::Iterator Iterator;</span>
<span class="line-modified">305     for (Iterator it = WeakProcessorPhases::serial_iterator(); !it.is_end(); ++it) {</span>
<span class="line-modified">306       log_st_phase(*it, indent);</span>
<span class="line-modified">307     }</span>
<span class="line-modified">308     for (Iterator it = WeakProcessorPhases::oopstorage_iterator(); !it.is_end(); ++it) {</span>
<span class="line-modified">309       log_mt_phase_summary(*it, indent);</span>
310     }
311   }
312 }
313 
314 void WeakProcessorPhaseTimes::log_print(uint indent) const {
315   if (log_is_enabled(Debug, gc, phases)) {
316     log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
317                           indent_str(indent),
318                           &quot;Weak Processing&quot;,
319                           total_time_sec() * MILLIUNITS);
320     log_print_phases(indent + 1);
321   }
322 }
</pre>
</td>
</tr>
</table>
<center><a href="weakProcessor.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="weakProcessorPhaseTimes.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
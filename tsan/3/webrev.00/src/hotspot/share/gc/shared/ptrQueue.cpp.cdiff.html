<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/ptrQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="preservedMarks.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ptrQueue.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/ptrQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,28 ***</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/globalCounter.inline.hpp&quot;
  
  #include &lt;new&gt;
  
<span class="line-modified">! PtrQueue::PtrQueue(PtrQueueSet* qset, bool permanent, bool active) :</span>
    _qset(qset),
    _active(active),
<span class="line-removed">-   _permanent(permanent),</span>
    _index(0),
<span class="line-modified">!   _capacity_in_bytes(0),</span>
<span class="line-modified">!   _buf(NULL),</span>
<span class="line-removed">-   _lock(NULL)</span>
  {}
  
  PtrQueue::~PtrQueue() {
<span class="line-modified">!   assert(_permanent || (_buf == NULL), &quot;queue must be flushed before delete&quot;);</span>
  }
  
  void PtrQueue::flush_impl() {
    if (_buf != NULL) {
      BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());
<span class="line-new-header">--- 28,25 ---</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/mutex.hpp&quot;
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/globalCounter.inline.hpp&quot;
  
  #include &lt;new&gt;
  
<span class="line-modified">! PtrQueue::PtrQueue(PtrQueueSet* qset, bool active) :</span>
    _qset(qset),
    _active(active),
    _index(0),
<span class="line-modified">!   _capacity_in_bytes(index_to_byte_index(qset-&gt;buffer_size())),</span>
<span class="line-modified">!   _buf(NULL)</span>
  {}
  
  PtrQueue::~PtrQueue() {
<span class="line-modified">!   assert(_buf == NULL, &quot;queue must be flushed before delete&quot;);</span>
  }
  
  void PtrQueue::flush_impl() {
    if (_buf != NULL) {
      BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
      _buf = NULL;
      set_index(0);
    }
  }
  
<span class="line-removed">- </span>
  void PtrQueue::enqueue_known_active(void* ptr) {
    while (_index == 0) {
      handle_zero_index();
    }
  
<span class="line-new-header">--- 59,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,10 ***</span>
<span class="line-new-header">--- 71,32 ---</span>
    assert(index() &lt;= capacity(), &quot;invariant&quot;);
    _index -= _element_size;
    _buf[index()] = ptr;
  }
  
<span class="line-added">+ void PtrQueue::handle_zero_index() {</span>
<span class="line-added">+   assert(index() == 0, &quot;precondition&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_buf != NULL) {</span>
<span class="line-added">+     handle_completed_buffer();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     allocate_buffer();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void PtrQueue::allocate_buffer() {</span>
<span class="line-added">+   _buf = qset()-&gt;allocate_buffer();</span>
<span class="line-added">+   reset();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void PtrQueue::enqueue_completed_buffer() {</span>
<span class="line-added">+   assert(_buf != NULL, &quot;precondition&quot;);</span>
<span class="line-added">+   BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());</span>
<span class="line-added">+   qset()-&gt;enqueue_completed_buffer(node);</span>
<span class="line-added">+   allocate_buffer();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  BufferNode* BufferNode::allocate(size_t size) {
    size_t byte_size = size * sizeof(void*);
    void* data = NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);
    return new (data) BufferNode;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,11 ***</span>
    _free_list(),
    _pending_count(0),
    _free_count(0),
    _transfer_lock(false)
  {
<span class="line-modified">!   strncpy(_name, name, sizeof(_name));</span>
    _name[sizeof(_name) - 1] = &#39;\0&#39;;
  }
  
  BufferNode::Allocator::~Allocator() {
    delete_list(_free_list.pop_all());
<span class="line-new-header">--- 112,11 ---</span>
    _free_list(),
    _pending_count(0),
    _free_count(0),
    _transfer_lock(false)
  {
<span class="line-modified">!   strncpy(_name, name, sizeof(_name) - 1);</span>
    _name[sizeof(_name) - 1] = &#39;\0&#39;;
  }
  
  BufferNode::Allocator::~Allocator() {
    delete_list(_free_list.pop_all());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,11 ***</span>
      node = BufferNode::allocate(_buffer_size);
    } else {
      // Decrement count after getting buffer from free list.  This, along
      // with incrementing count before adding to free list, ensures count
      // never underflows.
<span class="line-modified">!     size_t count = Atomic::sub(1u, &amp;_free_count);</span>
      assert((count + 1) != 0, &quot;_free_count underflow&quot;);
    }
    return node;
  }
  
<span class="line-new-header">--- 147,11 ---</span>
      node = BufferNode::allocate(_buffer_size);
    } else {
      // Decrement count after getting buffer from free list.  This, along
      // with incrementing count before adding to free list, ensures count
      // never underflows.
<span class="line-modified">!     size_t count = Atomic::sub(&amp;_free_count, 1u);</span>
      assert((count + 1) != 0, &quot;_free_count underflow&quot;);
    }
    return node;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,11 ***</span>
    // the allocation rate and the release rate are going to be fairly
    // similar, due to how the buffers are used.
    const size_t trigger_transfer = 10;
  
    // Add to pending list. Update count first so no underflow in transfer.
<span class="line-modified">!   size_t pending_count = Atomic::add(1u, &amp;_pending_count);</span>
    _pending_list.push(*node);
    if (pending_count &gt; trigger_transfer) {
      try_transfer_pending();
    }
  }
<span class="line-new-header">--- 179,11 ---</span>
    // the allocation rate and the release rate are going to be fairly
    // similar, due to how the buffers are used.
    const size_t trigger_transfer = 10;
  
    // Add to pending list. Update count first so no underflow in transfer.
<span class="line-modified">!   size_t pending_count = Atomic::add(&amp;_pending_count, 1u);</span>
    _pending_list.push(*node);
    if (pending_count &gt; trigger_transfer) {
      try_transfer_pending();
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
  // transfer, false if blocked from doing so by some other thread&#39;s
  // in-progress transfer.
  bool BufferNode::Allocator::try_transfer_pending() {
    // Attempt to claim the lock.
    if (Atomic::load(&amp;_transfer_lock) || // Skip CAS if likely to fail.
<span class="line-modified">!       Atomic::cmpxchg(true, &amp;_transfer_lock, false)) {</span>
      return false;
    }
    // Have the lock; perform the transfer.
  
    // Claim all the pending nodes.
<span class="line-new-header">--- 194,11 ---</span>
  // transfer, false if blocked from doing so by some other thread&#39;s
  // in-progress transfer.
  bool BufferNode::Allocator::try_transfer_pending() {
    // Attempt to claim the lock.
    if (Atomic::load(&amp;_transfer_lock) || // Skip CAS if likely to fail.
<span class="line-modified">!       Atomic::cmpxchg(&amp;_transfer_lock, false, true)) {</span>
      return false;
    }
    // Have the lock; perform the transfer.
  
    // Claim all the pending nodes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,23 ***</span>
      size_t count = 1;
      for (BufferNode* next = first-&gt;next(); next != NULL; next = next-&gt;next()) {
        last = next;
        ++count;
      }
<span class="line-modified">!     Atomic::sub(count, &amp;_pending_count);</span>
  
      // Wait for any in-progress pops, to avoid ABA for them.
      GlobalCounter::write_synchronize();
  
      // Add synchronized nodes to _free_list.
      // Update count first so no underflow in allocate().
<span class="line-modified">!     Atomic::add(count, &amp;_free_count);</span>
      _free_list.prepend(*first, *last);
      log_trace(gc, ptrqueue, freelist)
               (&quot;Transferred %s pending to free: &quot; SIZE_FORMAT, name(), count);
    }
<span class="line-modified">!   OrderAccess::release_store(&amp;_transfer_lock, false);</span>
    return true;
  }
  
  size_t BufferNode::Allocator::reduce_free_list(size_t remove_goal) {
    try_transfer_pending();
<span class="line-new-header">--- 209,23 ---</span>
      size_t count = 1;
      for (BufferNode* next = first-&gt;next(); next != NULL; next = next-&gt;next()) {
        last = next;
        ++count;
      }
<span class="line-modified">!     Atomic::sub(&amp;_pending_count, count);</span>
  
      // Wait for any in-progress pops, to avoid ABA for them.
      GlobalCounter::write_synchronize();
  
      // Add synchronized nodes to _free_list.
      // Update count first so no underflow in allocate().
<span class="line-modified">!     Atomic::add(&amp;_free_count, count);</span>
      _free_list.prepend(*first, *last);
      log_trace(gc, ptrqueue, freelist)
               (&quot;Transferred %s pending to free: &quot; SIZE_FORMAT, name(), count);
    }
<span class="line-modified">!   Atomic::release_store(&amp;_transfer_lock, false);</span>
    return true;
  }
  
  size_t BufferNode::Allocator::reduce_free_list(size_t remove_goal) {
    try_transfer_pending();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,222 ***</span>
    for ( ; removed &lt; remove_goal; ++removed) {
      BufferNode* node = _free_list.pop();
      if (node == NULL) break;
      BufferNode::deallocate(node);
    }
<span class="line-modified">!   size_t new_count = Atomic::sub(removed, &amp;_free_count);</span>
    log_debug(gc, ptrqueue, freelist)
             (&quot;Reduced %s free list by &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT,
              name(), removed, new_count);
    return removed;
  }
  
<span class="line-modified">! PtrQueueSet::PtrQueueSet(bool notify_when_complete) :</span>
<span class="line-modified">!   _allocator(NULL),</span>
<span class="line-removed">-   _cbl_mon(NULL),</span>
<span class="line-removed">-   _completed_buffers_head(NULL),</span>
<span class="line-removed">-   _completed_buffers_tail(NULL),</span>
<span class="line-removed">-   _n_completed_buffers(0),</span>
<span class="line-removed">-   _process_completed_buffers_threshold(ProcessCompletedBuffersThresholdNever),</span>
<span class="line-removed">-   _process_completed_buffers(false),</span>
<span class="line-removed">-   _notify_when_complete(notify_when_complete),</span>
<span class="line-removed">-   _max_completed_buffers(MaxCompletedBuffersUnlimited),</span>
<span class="line-removed">-   _completed_buffers_padding(0),</span>
    _all_active(false)
  {}
  
<span class="line-modified">! PtrQueueSet::~PtrQueueSet() {</span>
<span class="line-removed">-   // There are presently only a couple (derived) instances ever</span>
<span class="line-removed">-   // created, and they are permanent, so no harm currently done by</span>
<span class="line-removed">-   // doing nothing here.</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueueSet::initialize(Monitor* cbl_mon,</span>
<span class="line-removed">-                              BufferNode::Allocator* allocator) {</span>
<span class="line-removed">-   assert(cbl_mon != NULL &amp;&amp; allocator != NULL, &quot;Init order issue?&quot;);</span>
<span class="line-removed">-   _cbl_mon = cbl_mon;</span>
<span class="line-removed">-   _allocator = allocator;</span>
<span class="line-removed">- }</span>
  
  void** PtrQueueSet::allocate_buffer() {
    BufferNode* node = _allocator-&gt;allocate();
    return BufferNode::make_buffer_from_node(node);
  }
  
  void PtrQueueSet::deallocate_buffer(BufferNode* node) {
    _allocator-&gt;release(node);
  }
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueue::handle_zero_index() {</span>
<span class="line-removed">-   assert(index() == 0, &quot;precondition&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // This thread records the full buffer and allocates a new one (while</span>
<span class="line-removed">-   // holding the lock if there is one).</span>
<span class="line-removed">-   if (_buf != NULL) {</span>
<span class="line-removed">-     if (!should_enqueue_buffer()) {</span>
<span class="line-removed">-       assert(index() &gt; 0, &quot;the buffer can only be re-used if it&#39;s not full&quot;);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (_lock) {</span>
<span class="line-removed">-       assert(_lock-&gt;owned_by_self(), &quot;Required.&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());</span>
<span class="line-removed">-       _buf = NULL;         // clear shared _buf field</span>
<span class="line-removed">- </span>
<span class="line-removed">-       qset()-&gt;enqueue_completed_buffer(node);</span>
<span class="line-removed">-       assert(_buf == NULL, &quot;multiple enqueuers appear to be racing&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());</span>
<span class="line-removed">-       if (qset()-&gt;process_or_enqueue_completed_buffer(node)) {</span>
<span class="line-removed">-         // Recycle the buffer. No allocation.</span>
<span class="line-removed">-         assert(_buf == BufferNode::make_buffer_from_node(node), &quot;invariant&quot;);</span>
<span class="line-removed">-         assert(capacity() == qset()-&gt;buffer_size(), &quot;invariant&quot;);</span>
<span class="line-removed">-         reset();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // Set capacity in case this is the first allocation.</span>
<span class="line-removed">-   set_capacity(qset()-&gt;buffer_size());</span>
<span class="line-removed">-   // Allocate a new buffer.</span>
<span class="line-removed">-   _buf = qset()-&gt;allocate_buffer();</span>
<span class="line-removed">-   reset();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool PtrQueueSet::process_or_enqueue_completed_buffer(BufferNode* node) {</span>
<span class="line-removed">-   if (Thread::current()-&gt;is_Java_thread()) {</span>
<span class="line-removed">-     // If the number of buffers exceeds the limit, make this Java</span>
<span class="line-removed">-     // thread do the processing itself.  We don&#39;t lock to access</span>
<span class="line-removed">-     // buffer count or padding; it is fine to be imprecise here.  The</span>
<span class="line-removed">-     // add of padding could overflow, which is treated as unlimited.</span>
<span class="line-removed">-     size_t limit = _max_completed_buffers + _completed_buffers_padding;</span>
<span class="line-removed">-     if ((_n_completed_buffers &gt; limit) &amp;&amp; (limit &gt;= _max_completed_buffers)) {</span>
<span class="line-removed">-       if (mut_process_buffer(node)) {</span>
<span class="line-removed">-         // Successfully processed; return true to allow buffer reuse.</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   // The buffer will be enqueued. The caller will have to get a new one.</span>
<span class="line-removed">-   enqueue_completed_buffer(node);</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueueSet::enqueue_completed_buffer(BufferNode* cbn) {</span>
<span class="line-removed">-   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-   cbn-&gt;set_next(NULL);</span>
<span class="line-removed">-   if (_completed_buffers_tail == NULL) {</span>
<span class="line-removed">-     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="line-removed">-     _completed_buffers_head = cbn;</span>
<span class="line-removed">-     _completed_buffers_tail = cbn;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     _completed_buffers_tail-&gt;set_next(cbn);</span>
<span class="line-removed">-     _completed_buffers_tail = cbn;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _n_completed_buffers++;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!_process_completed_buffers &amp;&amp;</span>
<span class="line-removed">-       (_n_completed_buffers &gt; _process_completed_buffers_threshold)) {</span>
<span class="line-removed">-     _process_completed_buffers = true;</span>
<span class="line-removed">-     if (_notify_when_complete) {</span>
<span class="line-removed">-       _cbl_mon-&gt;notify();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- BufferNode* PtrQueueSet::get_completed_buffer(size_t stop_at) {</span>
<span class="line-removed">-   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (_n_completed_buffers &lt;= stop_at) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(_n_completed_buffers &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(_completed_buffers_head != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">-   assert(_completed_buffers_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BufferNode* bn = _completed_buffers_head;</span>
<span class="line-removed">-   _n_completed_buffers--;</span>
<span class="line-removed">-   _completed_buffers_head = bn-&gt;next();</span>
<span class="line-removed">-   if (_completed_buffers_head == NULL) {</span>
<span class="line-removed">-     assert(_n_completed_buffers == 0, &quot;invariant&quot;);</span>
<span class="line-removed">-     _completed_buffers_tail = NULL;</span>
<span class="line-removed">-     _process_completed_buffers = false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">-   bn-&gt;set_next(NULL);</span>
<span class="line-removed">-   return bn;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueueSet::abandon_completed_buffers() {</span>
<span class="line-removed">-   BufferNode* buffers_to_delete = NULL;</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-     buffers_to_delete = _completed_buffers_head;</span>
<span class="line-removed">-     _completed_buffers_head = NULL;</span>
<span class="line-removed">-     _completed_buffers_tail = NULL;</span>
<span class="line-removed">-     _n_completed_buffers = 0;</span>
<span class="line-removed">-     _process_completed_buffers = false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   while (buffers_to_delete != NULL) {</span>
<span class="line-removed">-     BufferNode* bn = buffers_to_delete;</span>
<span class="line-removed">-     buffers_to_delete = bn-&gt;next();</span>
<span class="line-removed">-     bn-&gt;set_next(NULL);</span>
<span class="line-removed">-     deallocate_buffer(bn);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueueSet::assert_completed_buffers_list_len_correct_locked() {</span>
<span class="line-removed">-   assert_lock_strong(_cbl_mon);</span>
<span class="line-removed">-   size_t n = 0;</span>
<span class="line-removed">-   for (BufferNode* bn = _completed_buffers_head; bn != NULL; bn = bn-&gt;next()) {</span>
<span class="line-removed">-     ++n;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   assert(n == _n_completed_buffers,</span>
<span class="line-removed">-          &quot;Completed buffer length is wrong: counted: &quot; SIZE_FORMAT</span>
<span class="line-removed">-          &quot;, expected: &quot; SIZE_FORMAT, n, _n_completed_buffers);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif // ASSERT</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Merge lists of buffers. Notify the processing threads.</span>
<span class="line-removed">- // The source queue is emptied as a result. The queues</span>
<span class="line-removed">- // must share the monitor.</span>
<span class="line-removed">- void PtrQueueSet::merge_bufferlists(PtrQueueSet *src) {</span>
<span class="line-removed">-   assert(_cbl_mon == src-&gt;_cbl_mon, &quot;Should share the same lock&quot;);</span>
<span class="line-removed">-   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-   if (_completed_buffers_tail == NULL) {</span>
<span class="line-removed">-     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="line-removed">-     _completed_buffers_head = src-&gt;_completed_buffers_head;</span>
<span class="line-removed">-     _completed_buffers_tail = src-&gt;_completed_buffers_tail;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     assert(_completed_buffers_head != NULL, &quot;Well formedness&quot;);</span>
<span class="line-removed">-     if (src-&gt;_completed_buffers_head != NULL) {</span>
<span class="line-removed">-       _completed_buffers_tail-&gt;set_next(src-&gt;_completed_buffers_head);</span>
<span class="line-removed">-       _completed_buffers_tail = src-&gt;_completed_buffers_tail;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   _n_completed_buffers += src-&gt;_n_completed_buffers;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   src-&gt;_n_completed_buffers = 0;</span>
<span class="line-removed">-   src-&gt;_completed_buffers_head = NULL;</span>
<span class="line-removed">-   src-&gt;_completed_buffers_tail = NULL;</span>
<span class="line-removed">-   src-&gt;_process_completed_buffers = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(_completed_buffers_head == NULL &amp;&amp; _completed_buffers_tail == NULL ||</span>
<span class="line-removed">-          _completed_buffers_head != NULL &amp;&amp; _completed_buffers_tail != NULL,</span>
<span class="line-removed">-          &quot;Sanity&quot;);</span>
<span class="line-removed">-   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void PtrQueueSet::notify_if_necessary() {</span>
<span class="line-removed">-   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">-   if (_n_completed_buffers &gt; _process_completed_buffers_threshold) {</span>
<span class="line-removed">-     _process_completed_buffers = true;</span>
<span class="line-removed">-     if (_notify_when_complete)</span>
<span class="line-removed">-       _cbl_mon-&gt;notify();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 233,27 ---</span>
    for ( ; removed &lt; remove_goal; ++removed) {
      BufferNode* node = _free_list.pop();
      if (node == NULL) break;
      BufferNode::deallocate(node);
    }
<span class="line-modified">!   size_t new_count = Atomic::sub(&amp;_free_count, removed);</span>
    log_debug(gc, ptrqueue, freelist)
             (&quot;Reduced %s free list by &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT,
              name(), removed, new_count);
    return removed;
  }
  
<span class="line-modified">! PtrQueueSet::PtrQueueSet(BufferNode::Allocator* allocator) :</span>
<span class="line-modified">!   _allocator(allocator),</span>
    _all_active(false)
  {}
  
<span class="line-modified">! PtrQueueSet::~PtrQueueSet() {}</span>
  
  void** PtrQueueSet::allocate_buffer() {
    BufferNode* node = _allocator-&gt;allocate();
    return BufferNode::make_buffer_from_node(node);
  }
  
  void PtrQueueSet::deallocate_buffer(BufferNode* node) {
    _allocator-&gt;release(node);
  }
</pre>
<center><a href="preservedMarks.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ptrQueue.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
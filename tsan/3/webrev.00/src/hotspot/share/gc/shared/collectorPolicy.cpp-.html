<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/collectorPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
 27 #include &quot;gc/shared/cardTableRS.hpp&quot;
 28 #include &quot;gc/shared/collectorPolicy.hpp&quot;
 29 #include &quot;gc/shared/gcLocker.hpp&quot;
 30 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
 31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 32 #include &quot;gc/shared/generationSpec.hpp&quot;
 33 #include &quot;gc/shared/space.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;runtime/arguments.hpp&quot;
 37 #include &quot;runtime/globals_extension.hpp&quot;
 38 #include &quot;runtime/handles.inline.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/thread.inline.hpp&quot;
 41 #include &quot;runtime/vmThread.hpp&quot;
 42 #include &quot;utilities/align.hpp&quot;
 43 #include &quot;utilities/macros.hpp&quot;
 44 
 45 // CollectorPolicy methods
 46 
 47 CollectorPolicy::CollectorPolicy() :
 48     _initial_heap_byte_size(InitialHeapSize),
 49     _max_heap_byte_size(MaxHeapSize),
 50     _min_heap_byte_size(Arguments::min_heap_size()),
 51     _space_alignment(0),
 52     _heap_alignment(0)
 53 {}
 54 
 55 #ifdef ASSERT
 56 void CollectorPolicy::assert_flags() {
 57   assert(InitialHeapSize &lt;= MaxHeapSize, &quot;Ergonomics decided on incompatible initial and maximum heap sizes&quot;);
 58   assert(InitialHeapSize % _heap_alignment == 0, &quot;InitialHeapSize alignment&quot;);
 59   assert(MaxHeapSize % _heap_alignment == 0, &quot;MaxHeapSize alignment&quot;);
 60 }
 61 
 62 void CollectorPolicy::assert_size_info() {
 63   assert(InitialHeapSize == _initial_heap_byte_size, &quot;Discrepancy between InitialHeapSize flag and local storage&quot;);
 64   assert(MaxHeapSize == _max_heap_byte_size, &quot;Discrepancy between MaxHeapSize flag and local storage&quot;);
 65   assert(_max_heap_byte_size &gt;= _min_heap_byte_size, &quot;Ergonomics decided on incompatible minimum and maximum heap sizes&quot;);
 66   assert(_initial_heap_byte_size &gt;= _min_heap_byte_size, &quot;Ergonomics decided on incompatible initial and minimum heap sizes&quot;);
 67   assert(_max_heap_byte_size &gt;= _initial_heap_byte_size, &quot;Ergonomics decided on incompatible initial and maximum heap sizes&quot;);
 68   assert(_min_heap_byte_size % _heap_alignment == 0, &quot;min_heap_byte_size alignment&quot;);
 69   assert(_initial_heap_byte_size % _heap_alignment == 0, &quot;initial_heap_byte_size alignment&quot;);
 70   assert(_max_heap_byte_size % _heap_alignment == 0, &quot;max_heap_byte_size alignment&quot;);
 71 }
 72 #endif // ASSERT
 73 
 74 void CollectorPolicy::initialize_flags() {
 75   assert(_space_alignment != 0, &quot;Space alignment not set up properly&quot;);
 76   assert(_heap_alignment != 0, &quot;Heap alignment not set up properly&quot;);
 77   assert(_heap_alignment &gt;= _space_alignment,
 78          &quot;heap_alignment: &quot; SIZE_FORMAT &quot; less than space_alignment: &quot; SIZE_FORMAT,
 79          _heap_alignment, _space_alignment);
 80   assert(_heap_alignment % _space_alignment == 0,
 81          &quot;heap_alignment: &quot; SIZE_FORMAT &quot; not aligned by space_alignment: &quot; SIZE_FORMAT,
 82          _heap_alignment, _space_alignment);
 83 
 84   if (FLAG_IS_CMDLINE(MaxHeapSize)) {
 85     if (FLAG_IS_CMDLINE(InitialHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {
 86       vm_exit_during_initialization(&quot;Initial heap size set to a larger value than the maximum heap size&quot;);
 87     }
 88     if (_min_heap_byte_size != 0 &amp;&amp; MaxHeapSize &lt; _min_heap_byte_size) {
 89       vm_exit_during_initialization(&quot;Incompatible minimum and maximum heap sizes specified&quot;);
 90     }
 91   }
 92 
 93   // Check heap parameter properties
 94   if (MaxHeapSize &lt; 2 * M) {
 95     vm_exit_during_initialization(&quot;Too small maximum heap&quot;);
 96   }
 97   if (InitialHeapSize &lt; M) {
 98     vm_exit_during_initialization(&quot;Too small initial heap&quot;);
 99   }
100   if (_min_heap_byte_size &lt; M) {
101     vm_exit_during_initialization(&quot;Too small minimum heap&quot;);
102   }
103 
104   // User inputs from -Xmx and -Xms must be aligned
105   _min_heap_byte_size = align_up(_min_heap_byte_size, _heap_alignment);
106   size_t aligned_initial_heap_size = align_up(InitialHeapSize, _heap_alignment);
107   size_t aligned_max_heap_size = align_up(MaxHeapSize, _heap_alignment);
108 
109   // Write back to flags if the values changed
110   if (aligned_initial_heap_size != InitialHeapSize) {
111     FLAG_SET_ERGO(size_t, InitialHeapSize, aligned_initial_heap_size);
112   }
113   if (aligned_max_heap_size != MaxHeapSize) {
114     FLAG_SET_ERGO(size_t, MaxHeapSize, aligned_max_heap_size);
115   }
116 
117   if (FLAG_IS_CMDLINE(InitialHeapSize) &amp;&amp; _min_heap_byte_size != 0 &amp;&amp;
118       InitialHeapSize &lt; _min_heap_byte_size) {
119     vm_exit_during_initialization(&quot;Incompatible minimum and initial heap sizes specified&quot;);
120   }
121   if (!FLAG_IS_DEFAULT(InitialHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {
122     FLAG_SET_ERGO(size_t, MaxHeapSize, InitialHeapSize);
123   } else if (!FLAG_IS_DEFAULT(MaxHeapSize) &amp;&amp; InitialHeapSize &gt; MaxHeapSize) {
124     FLAG_SET_ERGO(size_t, InitialHeapSize, MaxHeapSize);
125     if (InitialHeapSize &lt; _min_heap_byte_size) {
126       _min_heap_byte_size = InitialHeapSize;
127     }
128   }
129 
130   _initial_heap_byte_size = InitialHeapSize;
131   _max_heap_byte_size = MaxHeapSize;
132 
133   FLAG_SET_ERGO(size_t, MinHeapDeltaBytes, align_up(MinHeapDeltaBytes, _space_alignment));
134 
135   DEBUG_ONLY(CollectorPolicy::assert_flags();)
136 }
137 
138 void CollectorPolicy::initialize_size_info() {
139   log_debug(gc, heap)(&quot;Minimum heap &quot; SIZE_FORMAT &quot;  Initial heap &quot; SIZE_FORMAT &quot;  Maximum heap &quot; SIZE_FORMAT,
140                       _min_heap_byte_size, _initial_heap_byte_size, _max_heap_byte_size);
141 
142   DEBUG_ONLY(CollectorPolicy::assert_size_info();)
143 }
144 
145 size_t CollectorPolicy::compute_heap_alignment() {
146   // The card marking array and the offset arrays for old generations are
147   // committed in os pages as well. Make sure they are entirely full (to
148   // avoid partial page problems), e.g. if 512 bytes heap corresponds to 1
149   // byte entry and the os page size is 4096, the maximum heap size should
150   // be 512*4096 = 2MB aligned.
151 
152   size_t alignment = CardTableRS::ct_max_alignment_constraint();
153 
154   if (UseLargePages) {
155       // In presence of large pages we have to make sure that our
156       // alignment is large page aware.
157       alignment = lcm(os::large_page_size(), alignment);
158   }
159 
160   return alignment;
161 }
162 
163 // GenCollectorPolicy methods
164 
165 GenCollectorPolicy::GenCollectorPolicy() :
166     _min_young_size(0),
167     _initial_young_size(0),
168     _max_young_size(0),
169     _min_old_size(0),
170     _initial_old_size(0),
171     _max_old_size(0),
172     _gen_alignment(0)
173 {}
174 
175 size_t GenCollectorPolicy::scale_by_NewRatio_aligned(size_t base_size) {
176   return align_down_bounded(base_size / (NewRatio + 1), _gen_alignment);
177 }
178 
179 size_t GenCollectorPolicy::bound_minus_alignment(size_t desired_size,
180                                                  size_t maximum_size) {
181   size_t max_minus = maximum_size - _gen_alignment;
182   return desired_size &lt; max_minus ? desired_size : max_minus;
183 }
184 
185 size_t GenCollectorPolicy::young_gen_size_lower_bound() {
186   // The young generation must be aligned and have room for eden + two survivors
187   return align_up(3 * _space_alignment, _gen_alignment);
188 }
189 
190 size_t GenCollectorPolicy::old_gen_size_lower_bound() {
191   return align_up(_space_alignment, _gen_alignment);
192 }
193 
194 #ifdef ASSERT
195 void GenCollectorPolicy::assert_flags() {
196   CollectorPolicy::assert_flags();
197   assert(NewSize &gt;= _min_young_size, &quot;Ergonomics decided on a too small young gen size&quot;);
198   assert(NewSize &lt;= MaxNewSize, &quot;Ergonomics decided on incompatible initial and maximum young gen sizes&quot;);
199   assert(FLAG_IS_DEFAULT(MaxNewSize) || MaxNewSize &lt; MaxHeapSize, &quot;Ergonomics decided on incompatible maximum young gen and heap sizes&quot;);
200   assert(NewSize % _gen_alignment == 0, &quot;NewSize alignment&quot;);
201   assert(FLAG_IS_DEFAULT(MaxNewSize) || MaxNewSize % _gen_alignment == 0, &quot;MaxNewSize alignment&quot;);
202   assert(OldSize + NewSize &lt;= MaxHeapSize, &quot;Ergonomics decided on incompatible generation and heap sizes&quot;);
203   assert(OldSize % _gen_alignment == 0, &quot;OldSize alignment&quot;);
204 }
205 
206 void GenCollectorPolicy::assert_size_info() {
207   CollectorPolicy::assert_size_info();
208   // GenCollectorPolicy::initialize_size_info may update the MaxNewSize
209   assert(MaxNewSize &lt; MaxHeapSize, &quot;Ergonomics decided on incompatible maximum young and heap sizes&quot;);
210   assert(NewSize == _initial_young_size, &quot;Discrepancy between NewSize flag and local storage&quot;);
211   assert(MaxNewSize == _max_young_size, &quot;Discrepancy between MaxNewSize flag and local storage&quot;);
212   assert(OldSize == _initial_old_size, &quot;Discrepancy between OldSize flag and local storage&quot;);
213   assert(_min_young_size &lt;= _initial_young_size, &quot;Ergonomics decided on incompatible minimum and initial young gen sizes&quot;);
214   assert(_initial_young_size &lt;= _max_young_size, &quot;Ergonomics decided on incompatible initial and maximum young gen sizes&quot;);
215   assert(_min_young_size % _gen_alignment == 0, &quot;_min_young_size alignment&quot;);
216   assert(_initial_young_size % _gen_alignment == 0, &quot;_initial_young_size alignment&quot;);
217   assert(_max_young_size % _gen_alignment == 0, &quot;_max_young_size alignment&quot;);
218   assert(_min_young_size &lt;= bound_minus_alignment(_min_young_size, _min_heap_byte_size),
219       &quot;Ergonomics made minimum young generation larger than minimum heap&quot;);
220   assert(_initial_young_size &lt;=  bound_minus_alignment(_initial_young_size, _initial_heap_byte_size),
221       &quot;Ergonomics made initial young generation larger than initial heap&quot;);
222   assert(_max_young_size &lt;= bound_minus_alignment(_max_young_size, _max_heap_byte_size),
223       &quot;Ergonomics made maximum young generation lager than maximum heap&quot;);
224   assert(_min_old_size &lt;= _initial_old_size, &quot;Ergonomics decided on incompatible minimum and initial old gen sizes&quot;);
225   assert(_initial_old_size &lt;= _max_old_size, &quot;Ergonomics decided on incompatible initial and maximum old gen sizes&quot;);
226   assert(_max_old_size % _gen_alignment == 0, &quot;_max_old_size alignment&quot;);
227   assert(_initial_old_size % _gen_alignment == 0, &quot;_initial_old_size alignment&quot;);
228   assert(_max_heap_byte_size &lt;= (_max_young_size + _max_old_size), &quot;Total maximum heap sizes must be sum of generation maximum sizes&quot;);
229   assert(_min_young_size + _min_old_size &lt;= _min_heap_byte_size, &quot;Minimum generation sizes exceed minimum heap size&quot;);
230   assert(_initial_young_size + _initial_old_size == _initial_heap_byte_size, &quot;Initial generation sizes should match initial heap size&quot;);
231   assert(_max_young_size + _max_old_size == _max_heap_byte_size, &quot;Maximum generation sizes should match maximum heap size&quot;);
232 }
233 #endif // ASSERT
234 
235 void GenCollectorPolicy::initialize_flags() {
236   CollectorPolicy::initialize_flags();
237 
238   assert(_gen_alignment != 0, &quot;Generation alignment not set up properly&quot;);
239   assert(_heap_alignment &gt;= _gen_alignment,
240          &quot;heap_alignment: &quot; SIZE_FORMAT &quot; less than gen_alignment: &quot; SIZE_FORMAT,
241          _heap_alignment, _gen_alignment);
242   assert(_gen_alignment % _space_alignment == 0,
243          &quot;gen_alignment: &quot; SIZE_FORMAT &quot; not aligned by space_alignment: &quot; SIZE_FORMAT,
244          _gen_alignment, _space_alignment);
245   assert(_heap_alignment % _gen_alignment == 0,
246          &quot;heap_alignment: &quot; SIZE_FORMAT &quot; not aligned by gen_alignment: &quot; SIZE_FORMAT,
247          _heap_alignment, _gen_alignment);
248 
249   // All generational heaps have a young gen; handle those flags here
250 
251   // Make sure the heap is large enough for two generations
252   size_t smallest_new_size = young_gen_size_lower_bound();
253   size_t smallest_heap_size = align_up(smallest_new_size + old_gen_size_lower_bound(),
254                                            _heap_alignment);
255   if (MaxHeapSize &lt; smallest_heap_size) {
256     FLAG_SET_ERGO(size_t, MaxHeapSize, smallest_heap_size);
257     _max_heap_byte_size = MaxHeapSize;
258   }
259   // If needed, synchronize _min_heap_byte size and _initial_heap_byte_size
260   if (_min_heap_byte_size &lt; smallest_heap_size) {
261     _min_heap_byte_size = smallest_heap_size;
262     if (InitialHeapSize &lt; _min_heap_byte_size) {
263       FLAG_SET_ERGO(size_t, InitialHeapSize, smallest_heap_size);
264       _initial_heap_byte_size = smallest_heap_size;
265     }
266   }
267 
268   // Make sure NewSize allows an old generation to fit even if set on the command line
269   if (FLAG_IS_CMDLINE(NewSize) &amp;&amp; NewSize &gt;= _initial_heap_byte_size) {
270     log_warning(gc, ergo)(&quot;NewSize was set larger than initial heap size, will use initial heap size.&quot;);
271     FLAG_SET_ERGO(size_t, NewSize, bound_minus_alignment(NewSize, _initial_heap_byte_size));
272   }
273 
274   // Now take the actual NewSize into account. We will silently increase NewSize
275   // if the user specified a smaller or unaligned value.
276   size_t bounded_new_size = bound_minus_alignment(NewSize, MaxHeapSize);
277   bounded_new_size = MAX2(smallest_new_size, align_down(bounded_new_size, _gen_alignment));
278   if (bounded_new_size != NewSize) {
279     FLAG_SET_ERGO(size_t, NewSize, bounded_new_size);
280   }
281   _min_young_size = smallest_new_size;
282   _initial_young_size = NewSize;
283 
284   if (!FLAG_IS_DEFAULT(MaxNewSize)) {
285     if (MaxNewSize &gt;= MaxHeapSize) {
286       // Make sure there is room for an old generation
287       size_t smaller_max_new_size = MaxHeapSize - _gen_alignment;
288       if (FLAG_IS_CMDLINE(MaxNewSize)) {
289         log_warning(gc, ergo)(&quot;MaxNewSize (&quot; SIZE_FORMAT &quot;k) is equal to or greater than the entire &quot;
290                               &quot;heap (&quot; SIZE_FORMAT &quot;k).  A new max generation size of &quot; SIZE_FORMAT &quot;k will be used.&quot;,
291                               MaxNewSize/K, MaxHeapSize/K, smaller_max_new_size/K);
292       }
293       FLAG_SET_ERGO(size_t, MaxNewSize, smaller_max_new_size);
294       if (NewSize &gt; MaxNewSize) {
295         FLAG_SET_ERGO(size_t, NewSize, MaxNewSize);
296         _initial_young_size = NewSize;
297       }
298     } else if (MaxNewSize &lt; _initial_young_size) {
299       FLAG_SET_ERGO(size_t, MaxNewSize, _initial_young_size);
300     } else if (!is_aligned(MaxNewSize, _gen_alignment)) {
301       FLAG_SET_ERGO(size_t, MaxNewSize, align_down(MaxNewSize, _gen_alignment));
302     }
303     _max_young_size = MaxNewSize;
304   }
305 
306   if (NewSize &gt; MaxNewSize) {
307     // At this point this should only happen if the user specifies a large NewSize and/or
308     // a small (but not too small) MaxNewSize.
309     if (FLAG_IS_CMDLINE(MaxNewSize)) {
310       log_warning(gc, ergo)(&quot;NewSize (&quot; SIZE_FORMAT &quot;k) is greater than the MaxNewSize (&quot; SIZE_FORMAT &quot;k). &quot;
311                             &quot;A new max generation size of &quot; SIZE_FORMAT &quot;k will be used.&quot;,
312                             NewSize/K, MaxNewSize/K, NewSize/K);
313     }
314     FLAG_SET_ERGO(size_t, MaxNewSize, NewSize);
315     _max_young_size = MaxNewSize;
316   }
317 
318   if (SurvivorRatio &lt; 1 || NewRatio &lt; 1) {
319     vm_exit_during_initialization(&quot;Invalid young gen ratio specified&quot;);
320   }
321 
322   if (OldSize &lt; old_gen_size_lower_bound()) {
323     FLAG_SET_ERGO(size_t, OldSize, old_gen_size_lower_bound());
324   }
325   if (!is_aligned(OldSize, _gen_alignment)) {
326     FLAG_SET_ERGO(size_t, OldSize, align_down(OldSize, _gen_alignment));
327   }
328 
329   if (FLAG_IS_CMDLINE(OldSize) &amp;&amp; FLAG_IS_DEFAULT(MaxHeapSize)) {
330     // NewRatio will be used later to set the young generation size so we use
331     // it to calculate how big the heap should be based on the requested OldSize
332     // and NewRatio.
333     assert(NewRatio &gt; 0, &quot;NewRatio should have been set up earlier&quot;);
334     size_t calculated_heapsize = (OldSize / NewRatio) * (NewRatio + 1);
335 
336     calculated_heapsize = align_up(calculated_heapsize, _heap_alignment);
337     FLAG_SET_ERGO(size_t, MaxHeapSize, calculated_heapsize);
338     _max_heap_byte_size = MaxHeapSize;
339     FLAG_SET_ERGO(size_t, InitialHeapSize, calculated_heapsize);
340     _initial_heap_byte_size = InitialHeapSize;
341   }
342 
343   // Adjust NewSize and OldSize or MaxHeapSize to match each other
344   if (NewSize + OldSize &gt; MaxHeapSize) {
345     if (FLAG_IS_CMDLINE(MaxHeapSize)) {
346       // Somebody has set a maximum heap size with the intention that we should not
347       // exceed it. Adjust New/OldSize as necessary.
348       size_t calculated_size = NewSize + OldSize;
349       double shrink_factor = (double) MaxHeapSize / calculated_size;
350       size_t smaller_new_size = align_down((size_t)(NewSize * shrink_factor), _gen_alignment);
351       FLAG_SET_ERGO(size_t, NewSize, MAX2(young_gen_size_lower_bound(), smaller_new_size));
352       _initial_young_size = NewSize;
353 
354       // OldSize is already aligned because above we aligned MaxHeapSize to
355       // _heap_alignment, and we just made sure that NewSize is aligned to
356       // _gen_alignment. In initialize_flags() we verified that _heap_alignment
357       // is a multiple of _gen_alignment.
358       FLAG_SET_ERGO(size_t, OldSize, MaxHeapSize - NewSize);
359     } else {
360       FLAG_SET_ERGO(size_t, MaxHeapSize, align_up(NewSize + OldSize, _heap_alignment));
361       _max_heap_byte_size = MaxHeapSize;
362     }
363   }
364 
365   // Update NewSize, if possible, to avoid sizing the young gen too small when only
366   // OldSize is set on the command line.
367   if (FLAG_IS_CMDLINE(OldSize) &amp;&amp; !FLAG_IS_CMDLINE(NewSize)) {
368     if (OldSize &lt; _initial_heap_byte_size) {
369       size_t new_size = _initial_heap_byte_size - OldSize;
370       // Need to compare against the flag value for max since _max_young_size
371       // might not have been set yet.
372       if (new_size &gt;= _min_young_size &amp;&amp; new_size &lt;= MaxNewSize) {
373         FLAG_SET_ERGO(size_t, NewSize, new_size);
374         _initial_young_size = NewSize;
375       }
376     }
377   }
378 
379   always_do_update_barrier = UseConcMarkSweepGC;
380 
381   DEBUG_ONLY(GenCollectorPolicy::assert_flags();)
382 }
383 
384 // Values set on the command line win over any ergonomically
385 // set command line parameters.
386 // Ergonomic choice of parameters are done before this
387 // method is called.  Values for command line parameters such as NewSize
388 // and MaxNewSize feed those ergonomic choices into this method.
389 // This method makes the final generation sizings consistent with
390 // themselves and with overall heap sizings.
391 // In the absence of explicitly set command line flags, policies
392 // such as the use of NewRatio are used to size the generation.
393 
394 // Minimum sizes of the generations may be different than
395 // the initial sizes.  An inconsistency is permitted here
396 // in the total size that can be specified explicitly by
397 // command line specification of OldSize and NewSize and
398 // also a command line specification of -Xms.  Issue a warning
399 // but allow the values to pass.
400 void GenCollectorPolicy::initialize_size_info() {
401   CollectorPolicy::initialize_size_info();
402 
403   _initial_young_size = NewSize;
404   _max_young_size = MaxNewSize;
405   _initial_old_size = OldSize;
406 
407   // Determine maximum size of the young generation.
408 
409   if (FLAG_IS_DEFAULT(MaxNewSize)) {
410     _max_young_size = scale_by_NewRatio_aligned(_max_heap_byte_size);
411     // Bound the maximum size by NewSize below (since it historically
412     // would have been NewSize and because the NewRatio calculation could
413     // yield a size that is too small) and bound it by MaxNewSize above.
414     // Ergonomics plays here by previously calculating the desired
415     // NewSize and MaxNewSize.
416     _max_young_size = MIN2(MAX2(_max_young_size, _initial_young_size), MaxNewSize);
417   }
418 
419   // Given the maximum young size, determine the initial and
420   // minimum young sizes.
421 
422   if (_max_heap_byte_size == _initial_heap_byte_size) {
423     // The maximum and initial heap sizes are the same so the generation&#39;s
424     // initial size must be the same as it maximum size. Use NewSize as the
425     // size if set on command line.
426     _max_young_size = FLAG_IS_CMDLINE(NewSize) ? NewSize : _max_young_size;
427     _initial_young_size = _max_young_size;
428 
429     // Also update the minimum size if min == initial == max.
430     if (_max_heap_byte_size == _min_heap_byte_size) {
431       _min_young_size = _max_young_size;
432     }
433   } else {
434     if (FLAG_IS_CMDLINE(NewSize)) {
435       // If NewSize is set on the command line, we should use it as
436       // the initial size, but make sure it is within the heap bounds.
437       _initial_young_size =
438         MIN2(_max_young_size, bound_minus_alignment(NewSize, _initial_heap_byte_size));
439       _min_young_size = bound_minus_alignment(_initial_young_size, _min_heap_byte_size);
440     } else {
441       // For the case where NewSize is not set on the command line, use
442       // NewRatio to size the initial generation size. Use the current
443       // NewSize as the floor, because if NewRatio is overly large, the resulting
444       // size can be too small.
445       _initial_young_size =
446         MIN2(_max_young_size, MAX2(scale_by_NewRatio_aligned(_initial_heap_byte_size), NewSize));
447     }
448   }
449 
450   log_trace(gc, heap)(&quot;1: Minimum young &quot; SIZE_FORMAT &quot;  Initial young &quot; SIZE_FORMAT &quot;  Maximum young &quot; SIZE_FORMAT,
451                       _min_young_size, _initial_young_size, _max_young_size);
452 
453   // At this point the minimum, initial and maximum sizes
454   // of the overall heap and of the young generation have been determined.
455   // The maximum old size can be determined from the maximum young
456   // and maximum heap size since no explicit flags exist
457   // for setting the old generation maximum.
458   _max_old_size = MAX2(_max_heap_byte_size - _max_young_size, _gen_alignment);
459 
460   // If no explicit command line flag has been set for the
461   // old generation size, use what is left.
462   if (!FLAG_IS_CMDLINE(OldSize)) {
463     // The user has not specified any value but the ergonomics
464     // may have chosen a value (which may or may not be consistent
465     // with the overall heap size).  In either case make
466     // the minimum, maximum and initial sizes consistent
467     // with the young sizes and the overall heap sizes.
468     _min_old_size = _gen_alignment;
469     _initial_old_size = MIN2(_max_old_size, MAX2(_initial_heap_byte_size - _initial_young_size, _min_old_size));
470     // _max_old_size has already been made consistent above.
471   } else {
472     // OldSize has been explicitly set on the command line. Use it
473     // for the initial size but make sure the minimum allow a young
474     // generation to fit as well.
475     // If the user has explicitly set an OldSize that is inconsistent
476     // with other command line flags, issue a warning.
477     // The generation minimums and the overall heap minimum should
478     // be within one generation alignment.
479     if (_initial_old_size &gt; _max_old_size) {
480       log_warning(gc, ergo)(&quot;Inconsistency between maximum heap size and maximum &quot;
481                             &quot;generation sizes: using maximum heap = &quot; SIZE_FORMAT
482                             &quot;, -XX:OldSize flag is being ignored&quot;,
483                             _max_heap_byte_size);
484       _initial_old_size = _max_old_size;
485     }
486 
487     _min_old_size = MIN2(_initial_old_size, _min_heap_byte_size - _min_young_size);
488   }
489 
490   // The initial generation sizes should match the initial heap size,
491   // if not issue a warning and resize the generations. This behavior
492   // differs from JDK8 where the generation sizes have higher priority
493   // than the initial heap size.
494   if ((_initial_old_size + _initial_young_size) != _initial_heap_byte_size) {
495     log_warning(gc, ergo)(&quot;Inconsistency between generation sizes and heap size, resizing &quot;
496                           &quot;the generations to fit the heap.&quot;);
497 
498     size_t desired_young_size = _initial_heap_byte_size - _initial_old_size;
499     if (_initial_heap_byte_size &lt; _initial_old_size) {
500       // Old want all memory, use minimum for young and rest for old
501       _initial_young_size = _min_young_size;
502       _initial_old_size = _initial_heap_byte_size - _min_young_size;
503     } else if (desired_young_size &gt; _max_young_size) {
504       // Need to increase both young and old generation
505       _initial_young_size = _max_young_size;
506       _initial_old_size = _initial_heap_byte_size - _max_young_size;
507     } else if (desired_young_size &lt; _min_young_size) {
508       // Need to decrease both young and old generation
509       _initial_young_size = _min_young_size;
510       _initial_old_size = _initial_heap_byte_size - _min_young_size;
511     } else {
512       // The young generation boundaries allow us to only update the
513       // young generation.
514       _initial_young_size = desired_young_size;
515     }
516 
517     log_trace(gc, heap)(&quot;2: Minimum young &quot; SIZE_FORMAT &quot;  Initial young &quot; SIZE_FORMAT &quot;  Maximum young &quot; SIZE_FORMAT,
518                     _min_young_size, _initial_young_size, _max_young_size);
519   }
520 
521   // Write back to flags if necessary.
522   if (NewSize != _initial_young_size) {
523     FLAG_SET_ERGO(size_t, NewSize, _initial_young_size);
524   }
525 
526   if (MaxNewSize != _max_young_size) {
527     FLAG_SET_ERGO(size_t, MaxNewSize, _max_young_size);
528   }
529 
530   if (OldSize != _initial_old_size) {
531     FLAG_SET_ERGO(size_t, OldSize, _initial_old_size);
532   }
533 
534   log_trace(gc, heap)(&quot;Minimum old &quot; SIZE_FORMAT &quot;  Initial old &quot; SIZE_FORMAT &quot;  Maximum old &quot; SIZE_FORMAT,
535                   _min_old_size, _initial_old_size, _max_old_size);
536 
537   DEBUG_ONLY(GenCollectorPolicy::assert_size_info();)
538 }
539 
540 //
541 // MarkSweepPolicy methods
542 //
543 
544 void MarkSweepPolicy::initialize_alignments() {
545   _space_alignment = _gen_alignment = (size_t)Generation::GenGrain;
546   _heap_alignment = compute_heap_alignment();
547 }
    </pre>
  </body>
</html>
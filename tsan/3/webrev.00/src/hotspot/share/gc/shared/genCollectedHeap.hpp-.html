<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/genCollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 26 #define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 27 
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;
 29 #include &quot;gc/shared/collectorPolicy.hpp&quot;
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/oopStorageParState.hpp&quot;
 32 #include &quot;gc/shared/softRefGenPolicy.hpp&quot;
 33 
 34 class AdaptiveSizePolicy;
 35 class GCPolicyCounters;
 36 class GenerationSpec;
 37 class StrongRootsScope;
 38 class SubTasksDone;
 39 class WorkGang;
 40 
 41 // A &quot;GenCollectedHeap&quot; is a CollectedHeap that uses generational
 42 // collection.  It has two generations, young and old.
 43 class GenCollectedHeap : public CollectedHeap {
 44   friend class GenCollectorPolicy;
 45   friend class Generation;
 46   friend class DefNewGeneration;
 47   friend class TenuredGeneration;
 48   friend class ConcurrentMarkSweepGeneration;
 49   friend class CMSCollector;
 50   friend class GenMarkSweep;
 51   friend class VM_GenCollectForAllocation;
 52   friend class VM_GenCollectFull;
 53   friend class VM_GenCollectFullConcurrent;
 54   friend class VM_GC_HeapInspection;
 55   friend class VM_HeapDumper;
 56   friend class HeapInspection;
 57   friend class GCCauseSetter;
 58   friend class VMStructs;
 59 public:
 60   friend class VM_PopulateDumpSharedSpace;
 61 
 62   enum GenerationType {
 63     YoungGen,
 64     OldGen
 65   };
 66 
 67 protected:
 68   Generation* _young_gen;
 69   Generation* _old_gen;
 70 
 71 private:
 72   GenerationSpec* _young_gen_spec;
 73   GenerationSpec* _old_gen_spec;
 74 
 75   // The singleton CardTable Remembered Set.
 76   CardTableRS* _rem_set;
 77 
 78   // The generational collector policy.
 79   GenCollectorPolicy* _gen_policy;
 80 
 81   SoftRefGenPolicy _soft_ref_gen_policy;
 82 
 83   // The sizing of the heap is controlled by a sizing policy.
 84   AdaptiveSizePolicy* _size_policy;
 85 
 86   GCPolicyCounters* _gc_policy_counters;
 87 
 88   // Indicates that the most recent previous incremental collection failed.
 89   // The flag is cleared when an action is taken that might clear the
 90   // condition that caused that incremental collection to fail.
 91   bool _incremental_collection_failed;
 92 
 93   // In support of ExplicitGCInvokesConcurrent functionality
 94   unsigned int _full_collections_completed;
 95 
 96   // Collects the given generation.
 97   void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,
 98                           bool run_verification, bool clear_soft_refs,
 99                           bool restore_marks_for_biased_locking);
100 
101   // Reserve aligned space for the heap as needed by the contained generations.
102   char* allocate(size_t alignment, ReservedSpace* heap_rs);
103 
104   // Initialize (&quot;weak&quot;) refs processing support
105   void ref_processing_init();
106 
107 protected:
108 
109   // The set of potentially parallel tasks in root scanning.
110   enum GCH_strong_roots_tasks {
111     GCH_PS_Universe_oops_do,
112     GCH_PS_JNIHandles_oops_do,
113     GCH_PS_ObjectSynchronizer_oops_do,
114     GCH_PS_FlatProfiler_oops_do,
115     GCH_PS_Management_oops_do,
116     GCH_PS_SystemDictionary_oops_do,
117     GCH_PS_ClassLoaderDataGraph_oops_do,
118     GCH_PS_jvmti_oops_do,
119     GCH_PS_CodeCache_oops_do,
120     GCH_PS_aot_oops_do,
121     GCH_PS_younger_gens,
122     // Leave this one last.
123     GCH_PS_NumElements
124   };
125 
126   // Data structure for claiming the (potentially) parallel tasks in
127   // (gen-specific) roots processing.
128   SubTasksDone* _process_strong_tasks;
129 
130   GCMemoryManager* _young_manager;
131   GCMemoryManager* _old_manager;
132 
133   // Helper functions for allocation
134   HeapWord* attempt_allocation(size_t size,
135                                bool   is_tlab,
136                                bool   first_only);
137 
138   // Helper function for two callbacks below.
139   // Considers collection of the first max_level+1 generations.
140   void do_collection(bool           full,
141                      bool           clear_all_soft_refs,
142                      size_t         size,
143                      bool           is_tlab,
144                      GenerationType max_generation);
145 
146   // Callback from VM_GenCollectForAllocation operation.
147   // This function does everything necessary/possible to satisfy an
148   // allocation request that failed in the youngest generation that should
149   // have handled it (including collection, expansion, etc.)
150   HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);
151 
152   // Callback from VM_GenCollectFull operation.
153   // Perform a full collection of the first max_level+1 generations.
154   virtual void do_full_collection(bool clear_all_soft_refs);
155   void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);
156 
157   // Does the &quot;cause&quot; of GC indicate that
158   // we absolutely __must__ clear soft refs?
159   bool must_clear_all_soft_refs();
160 
161   GenCollectedHeap(GenCollectorPolicy *policy,
162                    Generation::Name young,
163                    Generation::Name old,
164                    const char* policy_counters_name);
165 
166 public:
167 
168   // Returns JNI_OK on success
169   virtual jint initialize();
170   virtual CardTableRS* create_rem_set(const MemRegion&amp; reserved_region);
171 
172   void initialize_size_policy(size_t init_eden_size,
173                               size_t init_promo_size,
174                               size_t init_survivor_size);
175 
176   // Does operations required after initialization has been done.
177   void post_initialize();
178 
179   Generation* young_gen() const { return _young_gen; }
180   Generation* old_gen()   const { return _old_gen; }
181 
182   bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }
183   bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }
184 
185   GenerationSpec* young_gen_spec() const;
186   GenerationSpec* old_gen_spec() const;
187 
188   // The generational collector policy.
189   GenCollectorPolicy* gen_policy() const { return _gen_policy; }
190 
191   virtual CollectorPolicy* collector_policy() const { return gen_policy(); }
192 
193   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_gen_policy; }
194 
195   // Adaptive size policy
196   virtual AdaptiveSizePolicy* size_policy() {
197     return _size_policy;
198   }
199 
200   // Performance Counter support
201   GCPolicyCounters* counters()     { return _gc_policy_counters; }
202 
203   // Return the (conservative) maximum heap alignment
204   static size_t conservative_max_heap_alignment() {
205     return Generation::GenGrain;
206   }
207 
208   size_t capacity() const;
209   size_t used() const;
210 
211   // Save the &quot;used_region&quot; for both generations.
212   void save_used_regions();
213 
214   size_t max_capacity() const;
215 
216   HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);
217 
218   // We may support a shared contiguous allocation area, if the youngest
219   // generation does.
220   bool supports_inline_contig_alloc() const;
221   HeapWord* volatile* top_addr() const;
222   HeapWord** end_addr() const;
223 
224   // Perform a full collection of the heap; intended for use in implementing
225   // &quot;System.gc&quot;. This implies as full a collection as the CollectedHeap
226   // supports. Caller does not hold the Heap_lock on entry.
227   virtual void collect(GCCause::Cause cause);
228 
229   // The same as above but assume that the caller holds the Heap_lock.
230   void collect_locked(GCCause::Cause cause);
231 
232   // Perform a full collection of generations up to and including max_generation.
233   // Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.
234   void collect(GCCause::Cause cause, GenerationType max_generation);
235 
236   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
237   // The methods is_in(), is_in_closed_subset() and is_in_youngest() may
238   // be expensive to compute in general, so, to prevent
239   // their inadvertent use in product jvm&#39;s, we restrict their use to
240   // assertion checking or verification only.
241   bool is_in(const void* p) const;
242 
243   // Returns true if the reference is to an object in the reserved space
244   // for the young generation.
245   // Assumes the the young gen address range is less than that of the old gen.
246   bool is_in_young(oop p);
247 
248 #ifdef ASSERT
249   bool is_in_partial_collection(const void* p);
250 #endif
251 
252   // Optimized nmethod scanning support routines
253   virtual void register_nmethod(nmethod* nm);
254   virtual void unregister_nmethod(nmethod* nm);
255   virtual void verify_nmethod(nmethod* nm);
256   virtual void flush_nmethod(nmethod* nm);
257 
258   void prune_nmethods();
259 
260   // Iteration functions.
261   void oop_iterate(OopIterateClosure* cl);
262   void object_iterate(ObjectClosure* cl);
263   void safe_object_iterate(ObjectClosure* cl);
264   Space* space_containing(const void* addr) const;
265 
266   // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,
267   // each address in the (reserved) heap is a member of exactly
268   // one block.  The defining characteristic of a block is that it is
269   // possible to find its size, and thus to progress forward to the next
270   // block.  (Blocks may be of different sizes.)  Thus, blocks may
271   // represent Java objects, or they might be free blocks in a
272   // free-list-based heap (or subheap), as long as the two kinds are
273   // distinguishable and the size of each is determinable.
274 
275   // Returns the address of the start of the &quot;block&quot; that contains the
276   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
277   // may not pack objects densely; a chunk may either be an object or a
278   // non-object.
279   virtual HeapWord* block_start(const void* addr) const;
280 
281   // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
282   // the block is an object. Assumes (and verifies in non-product
283   // builds) that addr is in the allocated part of the heap and is
284   // the start of a chunk.
285   virtual bool block_is_obj(const HeapWord* addr) const;
286 
287   // Section on TLAB&#39;s.
288   virtual bool supports_tlab_allocation() const;
289   virtual size_t tlab_capacity(Thread* thr) const;
290   virtual size_t tlab_used(Thread* thr) const;
291   virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;
292   virtual HeapWord* allocate_new_tlab(size_t min_size,
293                                       size_t requested_size,
294                                       size_t* actual_size);
295 
296   // The &quot;requestor&quot; generation is performing some garbage collection
297   // action for which it would be useful to have scratch space.  The
298   // requestor promises to allocate no more than &quot;max_alloc_words&quot; in any
299   // older generation (via promotion say.)   Any blocks of space that can
300   // be provided are returned as a list of ScratchBlocks, sorted by
301   // decreasing size.
302   ScratchBlock* gather_scratch(Generation* requestor, size_t max_alloc_words);
303   // Allow each generation to reset any scratch space that it has
304   // contributed as it needs.
305   void release_scratch();
306 
307   // Ensure parsability: override
308   virtual void ensure_parsability(bool retire_tlabs);
309 
310   // Time in ms since the longest time a collector ran in
311   // in any generation.
312   virtual jlong millis_since_last_gc();
313 
314   // Total number of full collections completed.
315   unsigned int total_full_collections_completed() {
316     assert(_full_collections_completed &lt;= _total_full_collections,
317            &quot;Can&#39;t complete more collections than were started&quot;);
318     return _full_collections_completed;
319   }
320 
321   // Update above counter, as appropriate, at the end of a stop-world GC cycle
322   unsigned int update_full_collections_completed();
323   // Update above counter, as appropriate, at the end of a concurrent GC cycle
324   unsigned int update_full_collections_completed(unsigned int count);
325 
326   // Update &quot;time of last gc&quot; for all generations to &quot;now&quot;.
327   void update_time_of_last_gc(jlong now) {
328     _young_gen-&gt;update_time_of_last_gc(now);
329     _old_gen-&gt;update_time_of_last_gc(now);
330   }
331 
332   // Update the gc statistics for each generation.
333   void update_gc_stats(Generation* current_generation, bool full) {
334     _old_gen-&gt;update_gc_stats(current_generation, full);
335   }
336 
337   bool no_gc_in_progress() { return !is_gc_active(); }
338 
339   // Override.
340   void prepare_for_verify();
341 
342   // Override.
343   void verify(VerifyOption option);
344 
345   // Override.
346   virtual void print_on(outputStream* st) const;
347   virtual void print_gc_threads_on(outputStream* st) const;
348   virtual void gc_threads_do(ThreadClosure* tc) const;
349   virtual void print_tracing_info() const;
350 
351   void print_heap_change(size_t young_prev_used, size_t old_prev_used) const;
352 
353   // The functions below are helper functions that a subclass of
354   // &quot;CollectedHeap&quot; can use in the implementation of its virtual
355   // functions.
356 
357   class GenClosure : public StackObj {
358    public:
359     virtual void do_generation(Generation* gen) = 0;
360   };
361 
362   // Apply &quot;cl.do_generation&quot; to all generations in the heap
363   // If &quot;old_to_young&quot; determines the order.
364   void generation_iterate(GenClosure* cl, bool old_to_young);
365 
366   // Return &quot;true&quot; if all generations have reached the
367   // maximal committed limit that they can reach, without a garbage
368   // collection.
369   virtual bool is_maximal_no_gc() const;
370 
371   // This function returns the CardTableRS object that allows us to scan
372   // generations in a fully generational heap.
373   CardTableRS* rem_set() { return _rem_set; }
374 
375   // Convenience function to be used in situations where the heap type can be
376   // asserted to be this type.
377   static GenCollectedHeap* heap();
378 
379   // The ScanningOption determines which of the roots
380   // the closure is applied to:
381   // &quot;SO_None&quot; does none;
382   enum ScanningOption {
383     SO_None                =  0x0,
384     SO_AllCodeCache        =  0x8,
385     SO_ScavengeCodeCache   = 0x10
386   };
387 
388  protected:
389   void process_roots(StrongRootsScope* scope,
390                      ScanningOption so,
391                      OopClosure* strong_roots,
392                      CLDClosure* strong_cld_closure,
393                      CLDClosure* weak_cld_closure,
394                      CodeBlobToOopClosure* code_roots);
395 
396   // Accessor for memory state verification support
397   NOT_PRODUCT(
398     virtual size_t skip_header_HeapWords() { return 0; }
399   )
400 
401   virtual void gc_prologue(bool full);
402   virtual void gc_epilogue(bool full);
403 
404  public:
405   void young_process_roots(StrongRootsScope* scope,
406                            OopsInGenClosure* root_closure,
407                            OopsInGenClosure* old_gen_closure,
408                            CLDClosure* cld_closure);
409 
410   void full_process_roots(StrongRootsScope* scope,
411                           bool is_adjust_phase,
412                           ScanningOption so,
413                           bool only_strong_roots,
414                           OopsInGenClosure* root_closure,
415                           CLDClosure* cld_closure);
416 
417   // Apply &quot;root_closure&quot; to all the weak roots of the system.
418   // These include JNI weak roots, string table,
419   // and referents of reachable weak refs.
420   void gen_process_weak_roots(OopClosure* root_closure);
421 
422   // Set the saved marks of generations, if that makes sense.
423   // In particular, if any generation might iterate over the oops
424   // in other generations, it should call this method.
425   void save_marks();
426 
427   // Returns &quot;true&quot; iff no allocations have occurred since the last
428   // call to &quot;save_marks&quot;.
429   bool no_allocs_since_save_marks();
430 
431   // Returns true if an incremental collection is likely to fail.
432   // We optionally consult the young gen, if asked to do so;
433   // otherwise we base our answer on whether the previous incremental
434   // collection attempt failed with no corrective action as of yet.
435   bool incremental_collection_will_fail(bool consult_young) {
436     // The first disjunct remembers if an incremental collection failed, even
437     // when we thought (second disjunct) that it would not.
438     return incremental_collection_failed() ||
439            (consult_young &amp;&amp; !_young_gen-&gt;collection_attempt_is_safe());
440   }
441 
442   // If a generation bails out of an incremental collection,
443   // it sets this flag.
444   bool incremental_collection_failed() const {
445     return _incremental_collection_failed;
446   }
447   void set_incremental_collection_failed() {
448     _incremental_collection_failed = true;
449   }
450   void clear_incremental_collection_failed() {
451     _incremental_collection_failed = false;
452   }
453 
454   // Promotion of obj into gen failed.  Try to promote obj to higher
455   // gens in ascending order; return the new location of obj if successful.
456   // Otherwise, try expand-and-allocate for obj in both the young and old
457   // generation; return the new location of obj if successful.  Otherwise, return NULL.
458   oop handle_failed_promotion(Generation* old_gen,
459                               oop obj,
460                               size_t obj_size);
461 
462 
463 private:
464   // Return true if an allocation should be attempted in the older generation
465   // if it fails in the younger generation.  Return false, otherwise.
466   bool should_try_older_generation_allocation(size_t word_size) const;
467 
468   // Try to allocate space by expanding the heap.
469   HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);
470 
471   HeapWord* mem_allocate_work(size_t size,
472                               bool is_tlab,
473                               bool* gc_overhead_limit_was_exceeded);
474 
475   // Override
476   void check_for_non_bad_heap_word_value(HeapWord* addr,
477     size_t size) PRODUCT_RETURN;
478 
479 #if INCLUDE_SERIALGC
480   // For use by mark-sweep.  As implemented, mark-sweep-compact is global
481   // in an essential way: compaction is performed across generations, by
482   // iterating over spaces.
483   void prepare_for_compaction();
484 #endif
485 
486   // Perform a full collection of the generations up to and including max_generation.
487   // This is the low level interface used by the public versions of
488   // collect() and collect_locked(). Caller holds the Heap_lock on entry.
489   void collect_locked(GCCause::Cause cause, GenerationType max_generation);
490 
491   // Save the tops of the spaces in all generations
492   void record_gen_tops_before_GC() PRODUCT_RETURN;
493 
494   // Return true if we need to perform full collection.
495   bool should_do_full_collection(size_t size, bool full,
496                                  bool is_tlab, GenerationType max_gen) const;
497 };
498 
499 #endif // SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
    </pre>
  </body>
</html>
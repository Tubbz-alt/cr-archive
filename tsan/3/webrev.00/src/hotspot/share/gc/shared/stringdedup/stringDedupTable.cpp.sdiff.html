<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="stringDedupQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="stringDedupTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/altHashing.hpp&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;gc/shared/stringdedup/stringDedup.hpp&quot;
 29 #include &quot;gc/shared/stringdedup/stringDedupTable.hpp&quot;
 30 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/padded.inline.hpp&quot;

 33 #include &quot;oops/access.inline.hpp&quot;
 34 #include &quot;oops/arrayOop.inline.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;oops/typeArrayOop.hpp&quot;

 37 #include &quot;runtime/mutexLocker.hpp&quot;
 38 #include &quot;runtime/safepointVerifiers.hpp&quot;

 39 
 40 //
 41 // List of deduplication table entries. Links table
 42 // entries together using their _next fields.
 43 //
 44 class StringDedupEntryList : public CHeapObj&lt;mtGC&gt; {
 45 private:
 46   StringDedupEntry*   _list;
 47   size_t              _length;
 48 
 49 public:
 50   StringDedupEntryList() :
 51     _list(NULL),
 52     _length(0) {
 53   }
 54 
 55   void add(StringDedupEntry* entry) {
 56     entry-&gt;set_next(_list);
 57     _list = entry;
 58     _length++;
</pre>
<hr />
<pre>
196     }
197   }
198 
199   double end = os::elapsedTime();
200   log_trace(gc, stringdedup)(&quot;Deleted &quot; UINTX_FORMAT &quot; entries, &quot; STRDEDUP_TIME_FORMAT_MS,
201                              count, STRDEDUP_TIME_PARAM_MS(end - start));
202 }
203 
204 StringDedupTable*        StringDedupTable::_table = NULL;
205 StringDedupEntryCache*   StringDedupTable::_entry_cache = NULL;
206 
207 const size_t             StringDedupTable::_min_size = (1 &lt;&lt; 10);   // 1024
208 const size_t             StringDedupTable::_max_size = (1 &lt;&lt; 24);   // 16777216
209 const double             StringDedupTable::_grow_load_factor = 2.0; // Grow table at 200% load
210 const double             StringDedupTable::_shrink_load_factor = _grow_load_factor / 3.0; // Shrink table at 67% load
211 const double             StringDedupTable::_max_cache_factor = 0.1; // Cache a maximum of 10% of the table size
212 const uintx              StringDedupTable::_rehash_multiple = 60;   // Hash bucket has 60 times more collisions than expected
213 const uintx              StringDedupTable::_rehash_threshold = (uintx)(_rehash_multiple * _grow_load_factor);
214 
215 uintx                    StringDedupTable::_entries_added = 0;
<span class="line-modified">216 uintx                    StringDedupTable::_entries_removed = 0;</span>
217 uintx                    StringDedupTable::_resize_count = 0;
218 uintx                    StringDedupTable::_rehash_count = 0;
219 
220 StringDedupTable*        StringDedupTable::_resized_table = NULL;
221 StringDedupTable*        StringDedupTable::_rehashed_table = NULL;
222 volatile size_t          StringDedupTable::_claimed_index = 0;
223 
224 StringDedupTable::StringDedupTable(size_t size, jint hash_seed) :
225   _size(size),
226   _entries(0),
227   _shrink_threshold((uintx)(size * _shrink_load_factor)),
228   _grow_threshold((uintx)(size * _grow_load_factor)),
229   _rehash_needed(false),
230   _hash_seed(hash_seed) {
231   assert(is_power_of_2(size), &quot;Table size must be a power of 2&quot;);
232   _buckets = NEW_C_HEAP_ARRAY(StringDedupEntry*, _size, mtGC);
233   memset(_buckets, 0, _size * sizeof(StringDedupEntry*));
234 }
235 
236 StringDedupTable::~StringDedupTable() {
<span class="line-modified">237   FREE_C_HEAP_ARRAY(G1StringDedupEntry*, _buckets);</span>
238 }
239 
240 void StringDedupTable::create() {
241   assert(_table == NULL, &quot;One string deduplication table allowed&quot;);
242   _entry_cache = new StringDedupEntryCache(_min_size * _max_cache_factor);
243   _table = new StringDedupTable(_min_size);
244 }
245 
246 void StringDedupTable::add(typeArrayOop value, bool latin1, unsigned int hash, StringDedupEntry** list) {
247   StringDedupEntry* entry = _entry_cache-&gt;alloc();
248   entry-&gt;set_obj(value);
249   entry-&gt;set_hash(hash);
250   entry-&gt;set_latin1(latin1);
251   entry-&gt;set_next(*list);
252   *list = entry;
253   _entries++;
254 }
255 
256 void StringDedupTable::remove(StringDedupEntry** pentry, uint worker_id) {
257   StringDedupEntry* entry = *pentry;
</pre>
<hr />
<pre>
334   return hash;
335 }
336 
337 void StringDedupTable::deduplicate(oop java_string, StringDedupStat* stat) {
338   assert(java_lang_String::is_instance(java_string), &quot;Must be a string&quot;);
339   NoSafepointVerifier nsv;
340 
341   stat-&gt;inc_inspected();
342 
343   typeArrayOop value = java_lang_String::value(java_string);
344   if (value == NULL) {
345     // String has no value
346     stat-&gt;inc_skipped();
347     return;
348   }
349 
350   bool latin1 = java_lang_String::is_latin1(java_string);
351   unsigned int hash = 0;
352 
353   if (use_java_hash()) {
<span class="line-modified">354     // Get hash code from cache</span>
<span class="line-modified">355     hash = java_lang_String::hash(java_string);</span>
<span class="line-modified">356   }</span>
<span class="line-modified">357 </span>
<span class="line-modified">358   if (hash == 0) {</span>
359     // Compute hash
360     hash = hash_code(value, latin1);
361     stat-&gt;inc_hashed();
<span class="line-removed">362 </span>
<span class="line-removed">363     if (use_java_hash() &amp;&amp; hash != 0) {</span>
<span class="line-removed">364       // Store hash code in cache</span>
<span class="line-removed">365       java_lang_String::set_hash(java_string, hash);</span>
<span class="line-removed">366     }</span>
367   }
368 
369   typeArrayOop existing_value = lookup_or_add(value, latin1, hash);
<span class="line-modified">370   if (oopDesc::equals_raw(existing_value, value)) {</span>
371     // Same value, already known
372     stat-&gt;inc_known();
373     return;
374   }
375 
376   // Get size of value array
377   uintx size_in_bytes = value-&gt;size() * HeapWordSize;
378   stat-&gt;inc_new(size_in_bytes);
379 
380   if (existing_value != NULL) {
381     // Existing value found, deduplicate string
382     java_lang_String::set_value(java_string, existing_value);
383     stat-&gt;deduped(value, size_in_bytes);
384   }
385 }
386 
387 bool StringDedupTable::is_resizing() {
388   return _resized_table != NULL;
389 }
390 
</pre>
<hr />
<pre>
463   size_t partition_size = MIN2(table_half, os::vm_page_size() / sizeof(StringDedupEntry*));
464   assert(table_half % partition_size == 0, &quot;Invalid partition size&quot;);
465 
466   // Number of entries removed during the scan
467   uintx removed = 0;
468 
469   for (;;) {
470     // Grab next partition to scan
471     size_t partition_begin = claim_table_partition(partition_size);
472     size_t partition_end = partition_begin + partition_size;
473     if (partition_begin &gt;= table_half) {
474       // End of table
475       break;
476     }
477 
478     // Scan the partition followed by the sibling partition in the second half of the table
479     removed += unlink_or_oops_do(cl, partition_begin, partition_end, worker_id);
480     removed += unlink_or_oops_do(cl, table_half + partition_begin, table_half + partition_end, worker_id);
481   }
482 
<span class="line-modified">483   // Delayed update to avoid contention on the table lock</span>


484   if (removed &gt; 0) {
<span class="line-modified">485     MutexLockerEx ml(StringDedupTable_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-modified">486     _table-&gt;_entries -= removed;</span>
<span class="line-modified">487     _entries_removed += removed;</span>
488   }
489 }
490 
491 uintx StringDedupTable::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl,
492                                           size_t partition_begin,
493                                           size_t partition_end,
494                                           uint worker_id) {
495   uintx removed = 0;
496   for (size_t bucket = partition_begin; bucket &lt; partition_end; bucket++) {
497     StringDedupEntry** entry = _table-&gt;bucket(bucket);
498     while (*entry != NULL) {
499       oop* p = (oop*)(*entry)-&gt;obj_addr();
500       if (cl-&gt;is_alive(*p)) {
501         cl-&gt;keep_alive(p);
502         if (is_resizing()) {
503           // We are resizing the table, transfer entry to the new table
504           _table-&gt;transfer(entry, _resized_table);
505         } else {
506           if (is_rehashing()) {
507             // We are rehashing the table, rehash the entry but keep it
</pre>
<hr />
<pre>
576   assert(rehashed_table != NULL, &quot;Invalid table&quot;);
577 
578   // Move all newly rehashed entries into the correct buckets in the new table
579   for (size_t bucket = 0; bucket &lt; _table-&gt;_size; bucket++) {
580     StringDedupEntry** entry = _table-&gt;bucket(bucket);
581     while (*entry != NULL) {
582       _table-&gt;transfer(entry, rehashed_table);
583     }
584   }
585 
586   rehashed_table-&gt;_entries = _table-&gt;_entries;
587 
588   // Free old table
589   delete _table;
590 
591   // Install new table
592   _table = rehashed_table;
593 }
594 
595 size_t StringDedupTable::claim_table_partition(size_t partition_size) {
<span class="line-modified">596   return Atomic::add(partition_size, &amp;_claimed_index) - partition_size;</span>
597 }
598 
599 void StringDedupTable::verify() {
600   for (size_t bucket = 0; bucket &lt; _table-&gt;_size; bucket++) {
601     // Verify entries
602     StringDedupEntry** entry = _table-&gt;bucket(bucket);
603     while (*entry != NULL) {
604       typeArrayOop value = (*entry)-&gt;obj();
605       guarantee(value != NULL, &quot;Object must not be NULL&quot;);
<span class="line-modified">606       guarantee(Universe::heap()-&gt;is_in_reserved(value), &quot;Object must be on the heap&quot;);</span>
607       guarantee(!value-&gt;is_forwarded(), &quot;Object must not be forwarded&quot;);
608       guarantee(value-&gt;is_typeArray(), &quot;Object must be a typeArrayOop&quot;);
609       bool latin1 = (*entry)-&gt;latin1();
610       unsigned int hash = hash_code(value, latin1);
611       guarantee((*entry)-&gt;hash() == hash, &quot;Table entry has inorrect hash&quot;);
612       guarantee(_table-&gt;hash_to_index(hash) == bucket, &quot;Table entry has incorrect index&quot;);
613       entry = (*entry)-&gt;next_addr();
614     }
615 
616     // Verify that we do not have entries with identical oops or identical arrays.
617     // We only need to compare entries in the same bucket. If the same oop or an
618     // identical array has been inserted more than once into different/incorrect
619     // buckets the verification step above will catch that.
620     StringDedupEntry** entry1 = _table-&gt;bucket(bucket);
621     while (*entry1 != NULL) {
622       typeArrayOop value1 = (*entry1)-&gt;obj();
623       bool latin1_1 = (*entry1)-&gt;latin1();
624       StringDedupEntry** entry2 = (*entry1)-&gt;next_addr();
625       while (*entry2 != NULL) {
626         typeArrayOop value2 = (*entry2)-&gt;obj();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/altHashing.hpp&quot;
 27 #include &quot;classfile/javaClasses.inline.hpp&quot;
 28 #include &quot;gc/shared/stringdedup/stringDedup.hpp&quot;
 29 #include &quot;gc/shared/stringdedup/stringDedupTable.hpp&quot;
 30 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/padded.inline.hpp&quot;
<span class="line-added"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;oops/access.inline.hpp&quot;
 35 #include &quot;oops/arrayOop.inline.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/typeArrayOop.hpp&quot;
<span class="line-added"> 38 #include &quot;runtime/atomic.hpp&quot;</span>
 39 #include &quot;runtime/mutexLocker.hpp&quot;
 40 #include &quot;runtime/safepointVerifiers.hpp&quot;
<span class="line-added"> 41 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 42 
 43 //
 44 // List of deduplication table entries. Links table
 45 // entries together using their _next fields.
 46 //
 47 class StringDedupEntryList : public CHeapObj&lt;mtGC&gt; {
 48 private:
 49   StringDedupEntry*   _list;
 50   size_t              _length;
 51 
 52 public:
 53   StringDedupEntryList() :
 54     _list(NULL),
 55     _length(0) {
 56   }
 57 
 58   void add(StringDedupEntry* entry) {
 59     entry-&gt;set_next(_list);
 60     _list = entry;
 61     _length++;
</pre>
<hr />
<pre>
199     }
200   }
201 
202   double end = os::elapsedTime();
203   log_trace(gc, stringdedup)(&quot;Deleted &quot; UINTX_FORMAT &quot; entries, &quot; STRDEDUP_TIME_FORMAT_MS,
204                              count, STRDEDUP_TIME_PARAM_MS(end - start));
205 }
206 
207 StringDedupTable*        StringDedupTable::_table = NULL;
208 StringDedupEntryCache*   StringDedupTable::_entry_cache = NULL;
209 
210 const size_t             StringDedupTable::_min_size = (1 &lt;&lt; 10);   // 1024
211 const size_t             StringDedupTable::_max_size = (1 &lt;&lt; 24);   // 16777216
212 const double             StringDedupTable::_grow_load_factor = 2.0; // Grow table at 200% load
213 const double             StringDedupTable::_shrink_load_factor = _grow_load_factor / 3.0; // Shrink table at 67% load
214 const double             StringDedupTable::_max_cache_factor = 0.1; // Cache a maximum of 10% of the table size
215 const uintx              StringDedupTable::_rehash_multiple = 60;   // Hash bucket has 60 times more collisions than expected
216 const uintx              StringDedupTable::_rehash_threshold = (uintx)(_rehash_multiple * _grow_load_factor);
217 
218 uintx                    StringDedupTable::_entries_added = 0;
<span class="line-modified">219 volatile uintx           StringDedupTable::_entries_removed = 0;</span>
220 uintx                    StringDedupTable::_resize_count = 0;
221 uintx                    StringDedupTable::_rehash_count = 0;
222 
223 StringDedupTable*        StringDedupTable::_resized_table = NULL;
224 StringDedupTable*        StringDedupTable::_rehashed_table = NULL;
225 volatile size_t          StringDedupTable::_claimed_index = 0;
226 
227 StringDedupTable::StringDedupTable(size_t size, jint hash_seed) :
228   _size(size),
229   _entries(0),
230   _shrink_threshold((uintx)(size * _shrink_load_factor)),
231   _grow_threshold((uintx)(size * _grow_load_factor)),
232   _rehash_needed(false),
233   _hash_seed(hash_seed) {
234   assert(is_power_of_2(size), &quot;Table size must be a power of 2&quot;);
235   _buckets = NEW_C_HEAP_ARRAY(StringDedupEntry*, _size, mtGC);
236   memset(_buckets, 0, _size * sizeof(StringDedupEntry*));
237 }
238 
239 StringDedupTable::~StringDedupTable() {
<span class="line-modified">240   FREE_C_HEAP_ARRAY(StringDedupEntry*, _buckets);</span>
241 }
242 
243 void StringDedupTable::create() {
244   assert(_table == NULL, &quot;One string deduplication table allowed&quot;);
245   _entry_cache = new StringDedupEntryCache(_min_size * _max_cache_factor);
246   _table = new StringDedupTable(_min_size);
247 }
248 
249 void StringDedupTable::add(typeArrayOop value, bool latin1, unsigned int hash, StringDedupEntry** list) {
250   StringDedupEntry* entry = _entry_cache-&gt;alloc();
251   entry-&gt;set_obj(value);
252   entry-&gt;set_hash(hash);
253   entry-&gt;set_latin1(latin1);
254   entry-&gt;set_next(*list);
255   *list = entry;
256   _entries++;
257 }
258 
259 void StringDedupTable::remove(StringDedupEntry** pentry, uint worker_id) {
260   StringDedupEntry* entry = *pentry;
</pre>
<hr />
<pre>
337   return hash;
338 }
339 
340 void StringDedupTable::deduplicate(oop java_string, StringDedupStat* stat) {
341   assert(java_lang_String::is_instance(java_string), &quot;Must be a string&quot;);
342   NoSafepointVerifier nsv;
343 
344   stat-&gt;inc_inspected();
345 
346   typeArrayOop value = java_lang_String::value(java_string);
347   if (value == NULL) {
348     // String has no value
349     stat-&gt;inc_skipped();
350     return;
351   }
352 
353   bool latin1 = java_lang_String::is_latin1(java_string);
354   unsigned int hash = 0;
355 
356   if (use_java_hash()) {
<span class="line-modified">357     if (!java_lang_String::hash_is_set(java_string)) {</span>
<span class="line-modified">358       stat-&gt;inc_hashed();</span>
<span class="line-modified">359     }</span>
<span class="line-modified">360     hash = java_lang_String::hash_code(java_string);</span>
<span class="line-modified">361   } else {</span>
362     // Compute hash
363     hash = hash_code(value, latin1);
364     stat-&gt;inc_hashed();





365   }
366 
367   typeArrayOop existing_value = lookup_or_add(value, latin1, hash);
<span class="line-modified">368   if (existing_value == value) {</span>
369     // Same value, already known
370     stat-&gt;inc_known();
371     return;
372   }
373 
374   // Get size of value array
375   uintx size_in_bytes = value-&gt;size() * HeapWordSize;
376   stat-&gt;inc_new(size_in_bytes);
377 
378   if (existing_value != NULL) {
379     // Existing value found, deduplicate string
380     java_lang_String::set_value(java_string, existing_value);
381     stat-&gt;deduped(value, size_in_bytes);
382   }
383 }
384 
385 bool StringDedupTable::is_resizing() {
386   return _resized_table != NULL;
387 }
388 
</pre>
<hr />
<pre>
461   size_t partition_size = MIN2(table_half, os::vm_page_size() / sizeof(StringDedupEntry*));
462   assert(table_half % partition_size == 0, &quot;Invalid partition size&quot;);
463 
464   // Number of entries removed during the scan
465   uintx removed = 0;
466 
467   for (;;) {
468     // Grab next partition to scan
469     size_t partition_begin = claim_table_partition(partition_size);
470     size_t partition_end = partition_begin + partition_size;
471     if (partition_begin &gt;= table_half) {
472       // End of table
473       break;
474     }
475 
476     // Scan the partition followed by the sibling partition in the second half of the table
477     removed += unlink_or_oops_do(cl, partition_begin, partition_end, worker_id);
478     removed += unlink_or_oops_do(cl, table_half + partition_begin, table_half + partition_end, worker_id);
479   }
480 
<span class="line-modified">481   // Do atomic update here instead of taking StringDedupTable_lock. This allows concurrent</span>
<span class="line-added">482   // cleanup when multiple workers are cleaning up the table, while the mutators are blocked</span>
<span class="line-added">483   // on StringDedupTable_lock.</span>
484   if (removed &gt; 0) {
<span class="line-modified">485     assert_locked_or_safepoint_weak(StringDedupTable_lock);</span>
<span class="line-modified">486     Atomic::sub(&amp;_table-&gt;_entries, removed);</span>
<span class="line-modified">487     Atomic::add(&amp;_entries_removed, removed);</span>
488   }
489 }
490 
491 uintx StringDedupTable::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl,
492                                           size_t partition_begin,
493                                           size_t partition_end,
494                                           uint worker_id) {
495   uintx removed = 0;
496   for (size_t bucket = partition_begin; bucket &lt; partition_end; bucket++) {
497     StringDedupEntry** entry = _table-&gt;bucket(bucket);
498     while (*entry != NULL) {
499       oop* p = (oop*)(*entry)-&gt;obj_addr();
500       if (cl-&gt;is_alive(*p)) {
501         cl-&gt;keep_alive(p);
502         if (is_resizing()) {
503           // We are resizing the table, transfer entry to the new table
504           _table-&gt;transfer(entry, _resized_table);
505         } else {
506           if (is_rehashing()) {
507             // We are rehashing the table, rehash the entry but keep it
</pre>
<hr />
<pre>
576   assert(rehashed_table != NULL, &quot;Invalid table&quot;);
577 
578   // Move all newly rehashed entries into the correct buckets in the new table
579   for (size_t bucket = 0; bucket &lt; _table-&gt;_size; bucket++) {
580     StringDedupEntry** entry = _table-&gt;bucket(bucket);
581     while (*entry != NULL) {
582       _table-&gt;transfer(entry, rehashed_table);
583     }
584   }
585 
586   rehashed_table-&gt;_entries = _table-&gt;_entries;
587 
588   // Free old table
589   delete _table;
590 
591   // Install new table
592   _table = rehashed_table;
593 }
594 
595 size_t StringDedupTable::claim_table_partition(size_t partition_size) {
<span class="line-modified">596   return Atomic::fetch_and_add(&amp;_claimed_index, partition_size);</span>
597 }
598 
599 void StringDedupTable::verify() {
600   for (size_t bucket = 0; bucket &lt; _table-&gt;_size; bucket++) {
601     // Verify entries
602     StringDedupEntry** entry = _table-&gt;bucket(bucket);
603     while (*entry != NULL) {
604       typeArrayOop value = (*entry)-&gt;obj();
605       guarantee(value != NULL, &quot;Object must not be NULL&quot;);
<span class="line-modified">606       guarantee(Universe::heap()-&gt;is_in(value), &quot;Object must be on the heap&quot;);</span>
607       guarantee(!value-&gt;is_forwarded(), &quot;Object must not be forwarded&quot;);
608       guarantee(value-&gt;is_typeArray(), &quot;Object must be a typeArrayOop&quot;);
609       bool latin1 = (*entry)-&gt;latin1();
610       unsigned int hash = hash_code(value, latin1);
611       guarantee((*entry)-&gt;hash() == hash, &quot;Table entry has inorrect hash&quot;);
612       guarantee(_table-&gt;hash_to_index(hash) == bucket, &quot;Table entry has incorrect index&quot;);
613       entry = (*entry)-&gt;next_addr();
614     }
615 
616     // Verify that we do not have entries with identical oops or identical arrays.
617     // We only need to compare entries in the same bucket. If the same oop or an
618     // identical array has been inserted more than once into different/incorrect
619     // buckets the verification step above will catch that.
620     StringDedupEntry** entry1 = _table-&gt;bucket(bucket);
621     while (*entry1 != NULL) {
622       typeArrayOop value1 = (*entry1)-&gt;obj();
623       bool latin1_1 = (*entry1)-&gt;latin1();
624       StringDedupEntry** entry2 = (*entry1)-&gt;next_addr();
625       while (*entry2 != NULL) {
626         typeArrayOop value2 = (*entry2)-&gt;obj();
</pre>
</td>
</tr>
</table>
<center><a href="stringDedupQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="stringDedupTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
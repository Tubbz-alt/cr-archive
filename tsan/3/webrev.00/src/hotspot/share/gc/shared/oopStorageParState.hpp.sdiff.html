<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/oopStorageParState.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="oopStorage.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelCleaning.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/oopStorageParState.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 26 #define SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 27 
 28 #include &quot;gc/shared/oopStorage.hpp&quot;
<span class="line-modified"> 29 #include &quot;utilities/macros.hpp&quot;</span>
 30 
 31 //////////////////////////////////////////////////////////////////////////////
 32 // Support for parallel and optionally concurrent state iteration.
 33 //
 34 // Concurrent Iteration
 35 //
 36 // Iteration involves the _active_array (an ActiveArray), which contains all
 37 // of the blocks owned by a storage object.
 38 //
 39 // A concurrent ParState increments the associated storage&#39;s
 40 // _concurrent_iteration_count when the state is constructed, and
 41 // decrements it when the state is destroyed.  These assignments are made with
 42 // _active_mutex locked.  Meanwhile, empty block deletion is not done while
 43 // _concurrent_iteration_count is non-zero.  The counter check and the dependent
 44 // removal of a block from the _active_array is performed with _active_mutex
 45 // locked.  This prevents concurrent iteration and empty block deletion from
 46 // interfering with with each other.
 47 //
 48 // Both allocate() and delete_empty_blocks() lock the
 49 // _allocation_mutex while performing their respective list and array
</pre>
<hr />
<pre>
117 //   the use of is-alive closures and OopClosures for iteration.
118 //   Assume p is of type oop*.  Then
119 //
120 //   - cl-&gt;do_oop(p) must be a valid expression whose value is ignored.
121 //
122 //   - is_alive-&gt;do_object_b(*p) must be a valid expression whose value
123 //   is convertible to bool.
124 //
125 //   If *p == NULL then neither is_alive nor cl will be invoked for p.
126 //   If is_alive-&gt;do_object_b(*p) is false, then cl will not be
127 //   invoked on p.
128 
129 class OopStorage::BasicParState {
130   const OopStorage* _storage;
131   ActiveArray* _active_array;
132   size_t _block_count;
133   volatile size_t _next_block;
134   uint _estimated_thread_count;
135   bool _concurrent;
136 
<span class="line-modified">137   // Noncopyable.</span>
<span class="line-removed">138   BasicParState(const BasicParState&amp;);</span>
<span class="line-removed">139   BasicParState&amp; operator=(const BasicParState&amp;);</span>
140 
141   struct IterationData;
142 
143   void update_concurrent_iteration_count(int value);
144   bool claim_next_segment(IterationData* data);
145   bool finish_iteration(const IterationData* data) const;
146 
147   // Wrapper for iteration handler; ignore handler result and return true.
148   template&lt;typename F&gt; class AlwaysTrueFn;
149 
150 public:
151   BasicParState(const OopStorage* storage,
152                 uint estimated_thread_count,
153                 bool concurrent);
154   ~BasicParState();
155 


156   template&lt;bool is_const, typename F&gt; void iterate(F f);
157 
158   static uint default_estimated_thread_count(bool concurrent);
159 };
160 
161 template&lt;bool concurrent, bool is_const&gt;
162 class OopStorage::ParState {
163   BasicParState _basic_state;
164 
165   typedef typename Conditional&lt;is_const,
166                                const OopStorage*,
167                                OopStorage*&gt;::type StoragePtr;
168 
169 public:
170   ParState(StoragePtr storage,
171            uint estimated_thread_count = BasicParState::default_estimated_thread_count(concurrent)) :
172     _basic_state(storage, estimated_thread_count, concurrent)
173   {}
174 

175   template&lt;typename F&gt; void iterate(F f);
176   template&lt;typename Closure&gt; void oops_do(Closure* cl);
177 };
178 
179 template&lt;&gt;
180 class OopStorage::ParState&lt;false, false&gt; {
181   BasicParState _basic_state;
182 
183 public:
184   ParState(OopStorage* storage,
185            uint estimated_thread_count = BasicParState::default_estimated_thread_count(false)) :
186     _basic_state(storage, estimated_thread_count, false)
187   {}
188 

189   template&lt;typename F&gt; void iterate(F f);
190   template&lt;typename Closure&gt; void oops_do(Closure* cl);
191   template&lt;typename Closure&gt; void weak_oops_do(Closure* cl);
192   template&lt;typename IsAliveClosure, typename Closure&gt;
193   void weak_oops_do(IsAliveClosure* is_alive, Closure* cl);
194 };
195 
196 #endif // SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 26 #define SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 27 
 28 #include &quot;gc/shared/oopStorage.hpp&quot;
<span class="line-modified"> 29 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
 30 
 31 //////////////////////////////////////////////////////////////////////////////
 32 // Support for parallel and optionally concurrent state iteration.
 33 //
 34 // Concurrent Iteration
 35 //
 36 // Iteration involves the _active_array (an ActiveArray), which contains all
 37 // of the blocks owned by a storage object.
 38 //
 39 // A concurrent ParState increments the associated storage&#39;s
 40 // _concurrent_iteration_count when the state is constructed, and
 41 // decrements it when the state is destroyed.  These assignments are made with
 42 // _active_mutex locked.  Meanwhile, empty block deletion is not done while
 43 // _concurrent_iteration_count is non-zero.  The counter check and the dependent
 44 // removal of a block from the _active_array is performed with _active_mutex
 45 // locked.  This prevents concurrent iteration and empty block deletion from
 46 // interfering with with each other.
 47 //
 48 // Both allocate() and delete_empty_blocks() lock the
 49 // _allocation_mutex while performing their respective list and array
</pre>
<hr />
<pre>
117 //   the use of is-alive closures and OopClosures for iteration.
118 //   Assume p is of type oop*.  Then
119 //
120 //   - cl-&gt;do_oop(p) must be a valid expression whose value is ignored.
121 //
122 //   - is_alive-&gt;do_object_b(*p) must be a valid expression whose value
123 //   is convertible to bool.
124 //
125 //   If *p == NULL then neither is_alive nor cl will be invoked for p.
126 //   If is_alive-&gt;do_object_b(*p) is false, then cl will not be
127 //   invoked on p.
128 
129 class OopStorage::BasicParState {
130   const OopStorage* _storage;
131   ActiveArray* _active_array;
132   size_t _block_count;
133   volatile size_t _next_block;
134   uint _estimated_thread_count;
135   bool _concurrent;
136 
<span class="line-modified">137   NONCOPYABLE(BasicParState);</span>


138 
139   struct IterationData;
140 
141   void update_concurrent_iteration_count(int value);
142   bool claim_next_segment(IterationData* data);
143   bool finish_iteration(const IterationData* data) const;
144 
145   // Wrapper for iteration handler; ignore handler result and return true.
146   template&lt;typename F&gt; class AlwaysTrueFn;
147 
148 public:
149   BasicParState(const OopStorage* storage,
150                 uint estimated_thread_count,
151                 bool concurrent);
152   ~BasicParState();
153 
<span class="line-added">154   const OopStorage* storage() const { return _storage; }</span>
<span class="line-added">155 </span>
156   template&lt;bool is_const, typename F&gt; void iterate(F f);
157 
158   static uint default_estimated_thread_count(bool concurrent);
159 };
160 
161 template&lt;bool concurrent, bool is_const&gt;
162 class OopStorage::ParState {
163   BasicParState _basic_state;
164 
165   typedef typename Conditional&lt;is_const,
166                                const OopStorage*,
167                                OopStorage*&gt;::type StoragePtr;
168 
169 public:
170   ParState(StoragePtr storage,
171            uint estimated_thread_count = BasicParState::default_estimated_thread_count(concurrent)) :
172     _basic_state(storage, estimated_thread_count, concurrent)
173   {}
174 
<span class="line-added">175   const OopStorage* storage() const { return _basic_state.storage(); }</span>
176   template&lt;typename F&gt; void iterate(F f);
177   template&lt;typename Closure&gt; void oops_do(Closure* cl);
178 };
179 
180 template&lt;&gt;
181 class OopStorage::ParState&lt;false, false&gt; {
182   BasicParState _basic_state;
183 
184 public:
185   ParState(OopStorage* storage,
186            uint estimated_thread_count = BasicParState::default_estimated_thread_count(false)) :
187     _basic_state(storage, estimated_thread_count, false)
188   {}
189 
<span class="line-added">190   const OopStorage* storage() const { return _basic_state.storage(); }</span>
191   template&lt;typename F&gt; void iterate(F f);
192   template&lt;typename Closure&gt; void oops_do(Closure* cl);
193   template&lt;typename Closure&gt; void weak_oops_do(Closure* cl);
194   template&lt;typename IsAliveClosure, typename Closure&gt;
195   void weak_oops_do(IsAliveClosure* is_alive, Closure* cl);
196 };
197 
198 #endif // SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="oopStorage.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelCleaning.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
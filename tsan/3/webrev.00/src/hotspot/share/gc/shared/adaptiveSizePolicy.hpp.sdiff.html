<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/adaptiveSizePolicy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="adaptiveSizePolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ageTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/adaptiveSizePolicy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_ADAPTIVESIZEPOLICY_HPP
 26 #define SHARE_GC_SHARED_ADAPTIVESIZEPOLICY_HPP
 27 
 28 #include &quot;gc/shared/gcCause.hpp&quot;
 29 #include &quot;gc/shared/gcOverheadChecker.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 
 33 // This class keeps statistical information and computes the
 34 // size of the heap.
 35 
 36 // Forward decls
 37 class elapsedTimer;
 38 
 39 class AdaptiveSizePolicy : public CHeapObj&lt;mtGC&gt; {
 40  friend class GCAdaptivePolicyCounters;
 41  friend class PSGCAdaptivePolicyCounters;
<span class="line-removed"> 42  friend class CMSGCAdaptivePolicyCounters;</span>
 43  protected:
 44 
 45   enum GCPolicyKind {
 46     _gc_adaptive_size_policy,
<span class="line-modified"> 47     _gc_ps_adaptive_size_policy,</span>
<span class="line-removed"> 48     _gc_cms_adaptive_size_policy</span>
 49   };
 50   virtual GCPolicyKind kind() const { return _gc_adaptive_size_policy; }
 51 
 52   enum SizePolicyTrueValues {
 53     decrease_old_gen_for_throughput_true = -7,
 54     decrease_young_gen_for_througput_true = -6,
 55 
 56     increase_old_gen_for_min_pauses_true = -5,
 57     decrease_old_gen_for_min_pauses_true = -4,
 58     decrease_young_gen_for_maj_pauses_true = -3,
 59     increase_young_gen_for_min_pauses_true = -2,
 60     increase_old_gen_for_maj_pauses_true = -1,
 61 
 62     decrease_young_gen_for_min_pauses_true = 1,
 63     decrease_old_gen_for_maj_pauses_true = 2,
 64     increase_young_gen_for_maj_pauses_true = 3,
 65 
 66     increase_old_gen_for_throughput_true = 4,
 67     increase_young_gen_for_througput_true = 5,
 68 
 69     decrease_young_gen_for_footprint_true = 6,
 70     decrease_old_gen_for_footprint_true = 7,
 71     decide_at_full_gc_true = 8
 72   };
 73 
 74   // Goal for the fraction of the total time during which application
 75   // threads run
 76   const double _throughput_goal;
 77 
 78   // Last calculated sizes, in bytes, and aligned
 79   size_t _eden_size;        // calculated eden free space in bytes
<span class="line-modified"> 80   size_t _promo_size;       // calculated cms gen free space in bytes</span>
 81 
 82   size_t _survivor_size;    // calculated survivor size in bytes
 83 
 84   // Support for UseGCOverheadLimit
 85   GCOverheadChecker _overhead_checker;
 86 
 87   // Minor collection timers used to determine both
 88   // pause and interval times for collections
 89   static elapsedTimer _minor_timer;
 90 
 91   // Major collection timers, used to determine both
 92   // pause and interval times for collections
 93   static elapsedTimer _major_timer;
 94 
 95   // Time statistics
 96   AdaptivePaddedAverage*   _avg_minor_pause;
 97   AdaptiveWeightedAverage* _avg_minor_interval;
 98   AdaptiveWeightedAverage* _avg_minor_gc_cost;
 99 
100   AdaptiveWeightedAverage* _avg_major_interval;
</pre>
<hr />
<pre>
105   AdaptiveWeightedAverage* _avg_eden_live;
106   AdaptiveWeightedAverage* _avg_old_live;
107 
108   // Statistics for survivor space calculation for young generation
109   AdaptivePaddedAverage*   _avg_survived;
110 
111   // Objects that have been directly allocated in the old generation
112   AdaptivePaddedNoZeroDevAverage*   _avg_pretenured;
113 
114   // Variable for estimating the major and minor pause times.
115   // These variables represent linear least-squares fits of
116   // the data.
117   //   minor pause time vs. old gen size
118   LinearLeastSquareFit* _minor_pause_old_estimator;
119   //   minor pause time vs. young gen size
120   LinearLeastSquareFit* _minor_pause_young_estimator;
121 
122   // Variables for estimating the major and minor collection costs
123   //   minor collection time vs. young gen size
124   LinearLeastSquareFit* _minor_collection_estimator;
<span class="line-modified">125   //   major collection time vs. cms gen size</span>
126   LinearLeastSquareFit* _major_collection_estimator;
127 
128   // These record the most recent collection times.  They
129   // are available as an alternative to using the averages
130   // for making ergonomic decisions.
131   double _latest_minor_mutator_interval_seconds;
132 
133   // Allowed difference between major and minor GC times, used
134   // for computing tenuring_threshold
135   const double _threshold_tolerance_percent;
136 
137   const double _gc_pause_goal_sec; // Goal for maximum GC pause
138 
139   // Flag indicating that the adaptive policy is ready to use
140   bool _young_gen_policy_is_ready;
141 
142   // Decrease/increase the young generation for minor pause time
143   int _change_young_gen_for_min_pauses;
144 
145   // Decrease/increase the old generation for major pause time
</pre>
<hr />
<pre>
309   }
310   void set_increment_tenuring_threshold_for_gc_cost(bool v) {
311     _increment_tenuring_threshold_for_gc_cost = v;
312   }
313   bool decrement_tenuring_threshold_for_survivor_limit() const {
314     return _decrement_tenuring_threshold_for_survivor_limit;
315   }
316   void set_decrement_tenuring_threshold_for_survivor_limit(bool v) {
317     _decrement_tenuring_threshold_for_survivor_limit = v;
318   }
319   // Return true if the policy suggested a change.
320   bool tenuring_threshold_change() const;
321 
322  public:
323   AdaptiveSizePolicy(size_t init_eden_size,
324                      size_t init_promo_size,
325                      size_t init_survivor_size,
326                      double gc_pause_goal_sec,
327                      uint gc_cost_ratio);
328 
<span class="line-removed">329   bool is_gc_cms_adaptive_size_policy() {</span>
<span class="line-removed">330     return kind() == _gc_cms_adaptive_size_policy;</span>
<span class="line-removed">331   }</span>
332   bool is_gc_ps_adaptive_size_policy() {
333     return kind() == _gc_ps_adaptive_size_policy;
334   }
335 
336   AdaptivePaddedAverage*   avg_minor_pause() const { return _avg_minor_pause; }
337   AdaptiveWeightedAverage* avg_minor_interval() const {
338     return _avg_minor_interval;
339   }
340   AdaptiveWeightedAverage* avg_minor_gc_cost() const {
341     return _avg_minor_gc_cost;
342   }
343 
344   AdaptiveWeightedAverage* avg_major_gc_cost() const {
345     return _avg_major_gc_cost;
346   }
347 
348   AdaptiveWeightedAverage* avg_young_live() const { return _avg_young_live; }
349   AdaptiveWeightedAverage* avg_eden_live() const { return _avg_eden_live; }
350   AdaptiveWeightedAverage* avg_old_live() const { return _avg_old_live; }
351 
</pre>
</td>
<td>
<hr />
<pre>
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_ADAPTIVESIZEPOLICY_HPP
 26 #define SHARE_GC_SHARED_ADAPTIVESIZEPOLICY_HPP
 27 
 28 #include &quot;gc/shared/gcCause.hpp&quot;
 29 #include &quot;gc/shared/gcOverheadChecker.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 
 33 // This class keeps statistical information and computes the
 34 // size of the heap.
 35 
 36 // Forward decls
 37 class elapsedTimer;
 38 
 39 class AdaptiveSizePolicy : public CHeapObj&lt;mtGC&gt; {
 40  friend class GCAdaptivePolicyCounters;
 41  friend class PSGCAdaptivePolicyCounters;

 42  protected:
 43 
 44   enum GCPolicyKind {
 45     _gc_adaptive_size_policy,
<span class="line-modified"> 46     _gc_ps_adaptive_size_policy</span>

 47   };
 48   virtual GCPolicyKind kind() const { return _gc_adaptive_size_policy; }
 49 
 50   enum SizePolicyTrueValues {
 51     decrease_old_gen_for_throughput_true = -7,
 52     decrease_young_gen_for_througput_true = -6,
 53 
 54     increase_old_gen_for_min_pauses_true = -5,
 55     decrease_old_gen_for_min_pauses_true = -4,
 56     decrease_young_gen_for_maj_pauses_true = -3,
 57     increase_young_gen_for_min_pauses_true = -2,
 58     increase_old_gen_for_maj_pauses_true = -1,
 59 
 60     decrease_young_gen_for_min_pauses_true = 1,
 61     decrease_old_gen_for_maj_pauses_true = 2,
 62     increase_young_gen_for_maj_pauses_true = 3,
 63 
 64     increase_old_gen_for_throughput_true = 4,
 65     increase_young_gen_for_througput_true = 5,
 66 
 67     decrease_young_gen_for_footprint_true = 6,
 68     decrease_old_gen_for_footprint_true = 7,
 69     decide_at_full_gc_true = 8
 70   };
 71 
 72   // Goal for the fraction of the total time during which application
 73   // threads run
 74   const double _throughput_goal;
 75 
 76   // Last calculated sizes, in bytes, and aligned
 77   size_t _eden_size;        // calculated eden free space in bytes
<span class="line-modified"> 78   size_t _promo_size;       // calculated promoted free space in bytes</span>
 79 
 80   size_t _survivor_size;    // calculated survivor size in bytes
 81 
 82   // Support for UseGCOverheadLimit
 83   GCOverheadChecker _overhead_checker;
 84 
 85   // Minor collection timers used to determine both
 86   // pause and interval times for collections
 87   static elapsedTimer _minor_timer;
 88 
 89   // Major collection timers, used to determine both
 90   // pause and interval times for collections
 91   static elapsedTimer _major_timer;
 92 
 93   // Time statistics
 94   AdaptivePaddedAverage*   _avg_minor_pause;
 95   AdaptiveWeightedAverage* _avg_minor_interval;
 96   AdaptiveWeightedAverage* _avg_minor_gc_cost;
 97 
 98   AdaptiveWeightedAverage* _avg_major_interval;
</pre>
<hr />
<pre>
103   AdaptiveWeightedAverage* _avg_eden_live;
104   AdaptiveWeightedAverage* _avg_old_live;
105 
106   // Statistics for survivor space calculation for young generation
107   AdaptivePaddedAverage*   _avg_survived;
108 
109   // Objects that have been directly allocated in the old generation
110   AdaptivePaddedNoZeroDevAverage*   _avg_pretenured;
111 
112   // Variable for estimating the major and minor pause times.
113   // These variables represent linear least-squares fits of
114   // the data.
115   //   minor pause time vs. old gen size
116   LinearLeastSquareFit* _minor_pause_old_estimator;
117   //   minor pause time vs. young gen size
118   LinearLeastSquareFit* _minor_pause_young_estimator;
119 
120   // Variables for estimating the major and minor collection costs
121   //   minor collection time vs. young gen size
122   LinearLeastSquareFit* _minor_collection_estimator;
<span class="line-modified">123   //   major collection time vs. old gen size</span>
124   LinearLeastSquareFit* _major_collection_estimator;
125 
126   // These record the most recent collection times.  They
127   // are available as an alternative to using the averages
128   // for making ergonomic decisions.
129   double _latest_minor_mutator_interval_seconds;
130 
131   // Allowed difference between major and minor GC times, used
132   // for computing tenuring_threshold
133   const double _threshold_tolerance_percent;
134 
135   const double _gc_pause_goal_sec; // Goal for maximum GC pause
136 
137   // Flag indicating that the adaptive policy is ready to use
138   bool _young_gen_policy_is_ready;
139 
140   // Decrease/increase the young generation for minor pause time
141   int _change_young_gen_for_min_pauses;
142 
143   // Decrease/increase the old generation for major pause time
</pre>
<hr />
<pre>
307   }
308   void set_increment_tenuring_threshold_for_gc_cost(bool v) {
309     _increment_tenuring_threshold_for_gc_cost = v;
310   }
311   bool decrement_tenuring_threshold_for_survivor_limit() const {
312     return _decrement_tenuring_threshold_for_survivor_limit;
313   }
314   void set_decrement_tenuring_threshold_for_survivor_limit(bool v) {
315     _decrement_tenuring_threshold_for_survivor_limit = v;
316   }
317   // Return true if the policy suggested a change.
318   bool tenuring_threshold_change() const;
319 
320  public:
321   AdaptiveSizePolicy(size_t init_eden_size,
322                      size_t init_promo_size,
323                      size_t init_survivor_size,
324                      double gc_pause_goal_sec,
325                      uint gc_cost_ratio);
326 



327   bool is_gc_ps_adaptive_size_policy() {
328     return kind() == _gc_ps_adaptive_size_policy;
329   }
330 
331   AdaptivePaddedAverage*   avg_minor_pause() const { return _avg_minor_pause; }
332   AdaptiveWeightedAverage* avg_minor_interval() const {
333     return _avg_minor_interval;
334   }
335   AdaptiveWeightedAverage* avg_minor_gc_cost() const {
336     return _avg_minor_gc_cost;
337   }
338 
339   AdaptiveWeightedAverage* avg_major_gc_cost() const {
340     return _avg_major_gc_cost;
341   }
342 
343   AdaptiveWeightedAverage* avg_young_live() const { return _avg_young_live; }
344   AdaptiveWeightedAverage* avg_eden_live() const { return _avg_eden_live; }
345   AdaptiveWeightedAverage* avg_old_live() const { return _avg_old_live; }
346 
</pre>
</td>
</tr>
</table>
<center><a href="adaptiveSizePolicy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ageTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/oopStorage.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="oopStorage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/oopStorage.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
135   //
136   // - is_alive-&gt;do_object_b(*p) must be a valid expression whose value is
137   // convertible to bool.
138   //
139   // For weak_oops_do, if *p == NULL then neither is_alive nor closure will be
140   // invoked for p.  If is_alive-&gt;do_object_b(*p) is false, then closure will
141   // not be invoked on p, and *p will be set to NULL.
142 
143   template&lt;typename Closure&gt; inline void oops_do(Closure* closure);
144   template&lt;typename Closure&gt; inline void oops_do(Closure* closure) const;
145   template&lt;typename Closure&gt; inline void weak_oops_do(Closure* closure);
146 
147   template&lt;typename IsAliveClosure, typename Closure&gt;
148   inline void weak_oops_do(IsAliveClosure* is_alive, Closure* closure);
149 
150   // Parallel iteration is for the exclusive use of the GC.
151   // Other clients must use serial iteration.
152   template&lt;bool concurrent, bool is_const&gt; class ParState;
153 
154   // Service thread cleanup support.
<span class="line-modified">155   // Stops deleting if there is an in-progress concurrent iteration.</span>
<span class="line-modified">156   // Locks both the _allocation_mutex and the _active_mutex, and may</span>
<span class="line-modified">157   // safepoint.  Deletion may be throttled, with only some available</span>
<span class="line-modified">158   // work performed, in order to allow other Service thread subtasks</span>
<span class="line-modified">159   // to run.  Returns true if there may be more work to do, false if</span>
<span class="line-modified">160   // nothing to do.</span>


161   bool delete_empty_blocks();
162 
<span class="line-modified">163   // Service thread cleanup support.</span>
<span class="line-modified">164   // Called by the service thread (while holding Service_lock) to test</span>
<span class="line-modified">165   // whether a call to delete_empty_blocks should be made.</span>
<span class="line-modified">166   bool needs_delete_empty_blocks() const;</span>






167 
168   // Debugging and logging support.
169   const char* name() const;
170   void print_on(outputStream* st) const PRODUCT_RETURN;
171 
172   // Provides access to storage internals, for unit testing.
173   // Declare, but not define, the public class OopStorage::TestAccess.
174   // That class is defined as part of the unit-test. It &quot;exports&quot; the needed
175   // private types by providing public typedefs for them.
176   class TestAccess;
177 
<span class="line-modified">178   // xlC on AIX can&#39;t compile test_oopStorage.cpp with following private</span>
<span class="line-removed">179   // classes. C++03 introduced access for nested classes with DR45, but xlC</span>
<span class="line-removed">180   // version 12 rejects it.</span>
<span class="line-removed">181 NOT_AIX( private: )</span>
182   class Block;                  // Fixed-size array of oops, plus bookkeeping.
183   class ActiveArray;            // Array of Blocks, plus bookkeeping.
184   class AllocationListEntry;    // Provides AllocationList links in a Block.
185 
186   // Doubly-linked list of Blocks.
187   class AllocationList {
188     const Block* _head;
189     const Block* _tail;
190 
<span class="line-modified">191     // Noncopyable.</span>
<span class="line-removed">192     AllocationList(const AllocationList&amp;);</span>
<span class="line-removed">193     AllocationList&amp; operator=(const AllocationList&amp;);</span>
194 
195   public:
196     AllocationList();
197     ~AllocationList();
198 
199     Block* head();
200     Block* tail();
201     const Block* chead() const;
202     const Block* ctail() const;
203 
204     Block* prev(Block&amp; block);
205     Block* next(Block&amp; block);
206 
207     const Block* prev(const Block&amp; block) const;
208     const Block* next(const Block&amp; block) const;
209 
210     void push_front(const Block&amp; block);
211     void push_back(const Block&amp; block);
212     void unlink(const Block&amp; block);
213   };
214 
215 private:
216   const char* _name;
217   ActiveArray* _active_array;
218   AllocationList _allocation_list;
<span class="line-removed">219 AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
220   Block* volatile _deferred_updates;
<span class="line-removed">221 AIX_ONLY(private:)</span>
<span class="line-removed">222 </span>
223   Mutex* _allocation_mutex;
224   Mutex* _active_mutex;
225 
226   // Volatile for racy unlocked accesses.
227   volatile size_t _allocation_count;
228 
229   // Protection for _active_array.
230   mutable SingleWriterSynchronizer _protect_active;
231 
232   // mutable because this gets set even for const iteration.
233   mutable int _concurrent_iteration_count;
234 
<span class="line-modified">235   volatile uint _needs_cleanup;</span>
236 
237   bool try_add_block();
238   Block* block_for_allocation();
239 
240   Block* find_block_or_null(const oop* ptr) const;
241   void delete_empty_block(const Block&amp; block);
242   bool reduce_deferred_updates();
<span class="line-removed">243   void notify_needs_cleanup();</span>
<span class="line-removed">244 AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
245   void record_needs_cleanup();
<span class="line-removed">246 AIX_ONLY(private:)</span>
247 
248   // Managing _active_array.
249   bool expand_active_array();
250   void replace_active_array(ActiveArray* new_array);
251   ActiveArray* obtain_active_array() const;
252   void relinquish_block_array(ActiveArray* array) const;
253   class WithActiveArray;        // RAII helper for active array access.
254 
255   template&lt;typename F, typename Storage&gt;
256   static bool iterate_impl(F f, Storage* storage);
257 
258   // Implementation support for parallel iteration
259   class BasicParState;
260 
261   // Wrapper for OopClosure-style function, so it can be used with
262   // iterate.  Assume p is of type oop*.  Then cl-&gt;do_oop(p) must be a
263   // valid expression whose value may be ignored.
264   template&lt;typename Closure&gt; class OopFn;
265   template&lt;typename Closure&gt; static OopFn&lt;Closure&gt; oop_fn(Closure* cl);
266 
</pre>
</td>
<td>
<hr />
<pre>
135   //
136   // - is_alive-&gt;do_object_b(*p) must be a valid expression whose value is
137   // convertible to bool.
138   //
139   // For weak_oops_do, if *p == NULL then neither is_alive nor closure will be
140   // invoked for p.  If is_alive-&gt;do_object_b(*p) is false, then closure will
141   // not be invoked on p, and *p will be set to NULL.
142 
143   template&lt;typename Closure&gt; inline void oops_do(Closure* closure);
144   template&lt;typename Closure&gt; inline void oops_do(Closure* closure) const;
145   template&lt;typename Closure&gt; inline void weak_oops_do(Closure* closure);
146 
147   template&lt;typename IsAliveClosure, typename Closure&gt;
148   inline void weak_oops_do(IsAliveClosure* is_alive, Closure* closure);
149 
150   // Parallel iteration is for the exclusive use of the GC.
151   // Other clients must use serial iteration.
152   template&lt;bool concurrent, bool is_const&gt; class ParState;
153 
154   // Service thread cleanup support.
<span class="line-modified">155 </span>
<span class="line-modified">156   // Called by the service thread to process any pending cleanups for this</span>
<span class="line-modified">157   // storage object.  Drains the _deferred_updates list, and deletes empty</span>
<span class="line-modified">158   // blocks.  Stops deleting if there is an in-progress concurrent</span>
<span class="line-modified">159   // iteration.  Locks both the _allocation_mutex and the _active_mutex, and</span>
<span class="line-modified">160   // may safepoint.  Deletion may be throttled, with only some available</span>
<span class="line-added">161   // work performed, in order to allow other Service thread subtasks to run.</span>
<span class="line-added">162   // Returns true if there may be more work to do, false if nothing to do.</span>
163   bool delete_empty_blocks();
164 
<span class="line-modified">165   // Called by safepoint cleanup to notify the service thread (via</span>
<span class="line-modified">166   // Service_lock) that there may be some OopStorage objects with pending</span>
<span class="line-modified">167   // cleanups to process.</span>
<span class="line-modified">168   static void trigger_cleanup_if_needed();</span>
<span class="line-added">169 </span>
<span class="line-added">170   // Called by the service thread (while holding Service_lock) to to test</span>
<span class="line-added">171   // for pending cleanup requests, and resets the request state to allow</span>
<span class="line-added">172   // recognition of new requests.  Returns true if there was a pending</span>
<span class="line-added">173   // request.</span>
<span class="line-added">174   static bool has_cleanup_work_and_reset();</span>
175 
176   // Debugging and logging support.
177   const char* name() const;
178   void print_on(outputStream* st) const PRODUCT_RETURN;
179 
180   // Provides access to storage internals, for unit testing.
181   // Declare, but not define, the public class OopStorage::TestAccess.
182   // That class is defined as part of the unit-test. It &quot;exports&quot; the needed
183   // private types by providing public typedefs for them.
184   class TestAccess;
185 
<span class="line-modified">186 private:</span>



187   class Block;                  // Fixed-size array of oops, plus bookkeeping.
188   class ActiveArray;            // Array of Blocks, plus bookkeeping.
189   class AllocationListEntry;    // Provides AllocationList links in a Block.
190 
191   // Doubly-linked list of Blocks.
192   class AllocationList {
193     const Block* _head;
194     const Block* _tail;
195 
<span class="line-modified">196     NONCOPYABLE(AllocationList);</span>


197 
198   public:
199     AllocationList();
200     ~AllocationList();
201 
202     Block* head();
203     Block* tail();
204     const Block* chead() const;
205     const Block* ctail() const;
206 
207     Block* prev(Block&amp; block);
208     Block* next(Block&amp; block);
209 
210     const Block* prev(const Block&amp; block) const;
211     const Block* next(const Block&amp; block) const;
212 
213     void push_front(const Block&amp; block);
214     void push_back(const Block&amp; block);
215     void unlink(const Block&amp; block);
216   };
217 
218 private:
219   const char* _name;
220   ActiveArray* _active_array;
221   AllocationList _allocation_list;

222   Block* volatile _deferred_updates;


223   Mutex* _allocation_mutex;
224   Mutex* _active_mutex;
225 
226   // Volatile for racy unlocked accesses.
227   volatile size_t _allocation_count;
228 
229   // Protection for _active_array.
230   mutable SingleWriterSynchronizer _protect_active;
231 
232   // mutable because this gets set even for const iteration.
233   mutable int _concurrent_iteration_count;
234 
<span class="line-modified">235   volatile bool _needs_cleanup;</span>
236 
237   bool try_add_block();
238   Block* block_for_allocation();
239 
240   Block* find_block_or_null(const oop* ptr) const;
241   void delete_empty_block(const Block&amp; block);
242   bool reduce_deferred_updates();


243   void record_needs_cleanup();

244 
245   // Managing _active_array.
246   bool expand_active_array();
247   void replace_active_array(ActiveArray* new_array);
248   ActiveArray* obtain_active_array() const;
249   void relinquish_block_array(ActiveArray* array) const;
250   class WithActiveArray;        // RAII helper for active array access.
251 
252   template&lt;typename F, typename Storage&gt;
253   static bool iterate_impl(F f, Storage* storage);
254 
255   // Implementation support for parallel iteration
256   class BasicParState;
257 
258   // Wrapper for OopClosure-style function, so it can be used with
259   // iterate.  Assume p is of type oop*.  Then cl-&gt;do_oop(p) must be a
260   // valid expression whose value may be ignored.
261   template&lt;typename Closure&gt; class OopFn;
262   template&lt;typename Closure&gt; static OopFn&lt;Closure&gt; oop_fn(Closure* cl);
263 
</pre>
</td>
</tr>
</table>
<center><a href="oopStorage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
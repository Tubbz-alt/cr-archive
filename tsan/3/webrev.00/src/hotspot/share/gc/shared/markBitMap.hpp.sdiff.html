<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/markBitMap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="markBitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="markBitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/markBitMap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 70 
 71   // Read marks
 72   bool is_marked(oop obj) const;
 73   bool is_marked(HeapWord* addr) const {
 74     assert(_covered.contains(addr),
 75            &quot;Address &quot; PTR_FORMAT &quot; is outside underlying space from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT,
 76            p2i(addr), p2i(_covered.start()), p2i(_covered.end()));
 77     return _bm.at(addr_to_offset(addr));
 78   }
 79 
 80   // Return the address corresponding to the next marked bit at or after
 81   // &quot;addr&quot;, and before &quot;limit&quot;, if &quot;limit&quot; is non-NULL.  If there is no
 82   // such bit, returns &quot;limit&quot; if that is non-NULL, or else &quot;endWord()&quot;.
 83   inline HeapWord* get_next_marked_addr(const HeapWord* addr,
 84                                         const HeapWord* limit) const;
 85 
 86   void print_on_error(outputStream* st, const char* prefix) const;
 87 
 88   // Write marks.
 89   inline void mark(HeapWord* addr);

 90   inline void clear(HeapWord* addr);
 91   inline void clear(oop obj);
 92   inline bool par_mark(HeapWord* addr);
 93   inline bool par_mark(oop obj);
 94 
 95   // Clear bitmap.
 96   void clear()                         { do_clear(_covered, true); }
 97   void clear_range(MemRegion mr)       { do_clear(mr, false);      }
 98   void clear_range_large(MemRegion mr) { do_clear(mr, true);       }
 99 };
100 
101 #endif // SHARE_GC_SHARED_MARKBITMAP_HPP
</pre>
</td>
<td>
<hr />
<pre>
 70 
 71   // Read marks
 72   bool is_marked(oop obj) const;
 73   bool is_marked(HeapWord* addr) const {
 74     assert(_covered.contains(addr),
 75            &quot;Address &quot; PTR_FORMAT &quot; is outside underlying space from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT,
 76            p2i(addr), p2i(_covered.start()), p2i(_covered.end()));
 77     return _bm.at(addr_to_offset(addr));
 78   }
 79 
 80   // Return the address corresponding to the next marked bit at or after
 81   // &quot;addr&quot;, and before &quot;limit&quot;, if &quot;limit&quot; is non-NULL.  If there is no
 82   // such bit, returns &quot;limit&quot; if that is non-NULL, or else &quot;endWord()&quot;.
 83   inline HeapWord* get_next_marked_addr(const HeapWord* addr,
 84                                         const HeapWord* limit) const;
 85 
 86   void print_on_error(outputStream* st, const char* prefix) const;
 87 
 88   // Write marks.
 89   inline void mark(HeapWord* addr);
<span class="line-added"> 90   inline void mark(oop obj);</span>
 91   inline void clear(HeapWord* addr);
 92   inline void clear(oop obj);
 93   inline bool par_mark(HeapWord* addr);
 94   inline bool par_mark(oop obj);
 95 
 96   // Clear bitmap.
 97   void clear()                         { do_clear(_covered, true); }
 98   void clear_range(MemRegion mr)       { do_clear(mr, false);      }
 99   void clear_range_large(MemRegion mr) { do_clear(mr, true);       }
100 };
101 
102 #endif // SHARE_GC_SHARED_MARKBITMAP_HPP
</pre>
</td>
</tr>
</table>
<center><a href="markBitMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="markBitMap.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
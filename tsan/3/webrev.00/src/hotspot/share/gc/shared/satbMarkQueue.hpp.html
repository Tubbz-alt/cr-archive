<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/satbMarkQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 26 #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 27 
 28 #include &quot;gc/shared/ptrQueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/padded.hpp&quot;
 31 
 32 class Thread;
 33 class Monitor;
 34 class SATBMarkQueueSet;
 35 
 36 // Base class for processing the contents of a SATB buffer.
 37 class SATBBufferClosure : public StackObj {
 38 protected:
 39   ~SATBBufferClosure() { }
 40 
 41 public:
 42   // Process the SATB entries in the designated buffer range.
 43   virtual void do_buffer(void** buffer, size_t size) = 0;
 44 };
 45 
 46 // A PtrQueue whose elements are (possibly stale) pointers to object heads.
 47 class SATBMarkQueue: public PtrQueue {
 48   friend class SATBMarkQueueSet;
 49 
 50 private:
 51   // Filter out unwanted entries from the buffer.
 52   inline void filter();
 53 
 54   // Removes entries from the buffer that are no longer needed.
 55   template&lt;typename Filter&gt;
 56   inline void apply_filter(Filter filter_out);
 57 
 58 protected:
 59   virtual void handle_completed_buffer();
 60 
 61 public:
 62   SATBMarkQueue(SATBMarkQueueSet* qset);
 63 
 64   // Process queue entries and free resources.
 65   void flush();
 66 
 67   inline SATBMarkQueueSet* satb_qset() const;
 68 
 69   // Apply cl to the active part of the buffer.
 70   // Prerequisite: Must be at a safepoint.
 71   void apply_closure_and_empty(SATBBufferClosure* cl);
 72 
 73 #ifndef PRODUCT
 74   // Helpful for debugging
 75   void print(const char* name);
 76 #endif // PRODUCT
 77 
 78   // Compiler support.
 79   static ByteSize byte_offset_of_index() {
 80     return PtrQueue::byte_offset_of_index&lt;SATBMarkQueue&gt;();
 81   }
 82   using PtrQueue::byte_width_of_index;
 83 
 84   static ByteSize byte_offset_of_buf() {
 85     return PtrQueue::byte_offset_of_buf&lt;SATBMarkQueue&gt;();
 86   }
 87   using PtrQueue::byte_width_of_buf;
 88 
 89   static ByteSize byte_offset_of_active() {
 90     return PtrQueue::byte_offset_of_active&lt;SATBMarkQueue&gt;();
 91   }
 92   using PtrQueue::byte_width_of_active;
 93 
 94 };
 95 
 96 class SATBMarkQueueSet: public PtrQueueSet {
 97 
 98   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);
 99   PaddedEnd&lt;BufferNode::Stack&gt; _list;
100   volatile size_t _count_and_process_flag;
101   // These are rarely (if ever) changed, so same cache line as count.
102   size_t _process_completed_buffers_threshold;
103   size_t _buffer_enqueue_threshold;
104   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 3 * sizeof(size_t));
105 
106   BufferNode* get_completed_buffer();
107   void abandon_completed_buffers();
108 
109 #ifdef ASSERT
110   void dump_active_states(bool expected_active);
111   void verify_active_states(bool expected_active);
112 #endif // ASSERT
113 
114 protected:
115   SATBMarkQueueSet(BufferNode::Allocator* allocator);
116   ~SATBMarkQueueSet();
117 
118   template&lt;typename Filter&gt;
119   void apply_filter(Filter filter, SATBMarkQueue* queue) {
120     queue-&gt;apply_filter(filter);
121   }
122 
123 public:
124   virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
125 
126   // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
127   // called only with the world stopped. The method will assert that the
128   // SATB queues of all threads it visits, as well as the SATB queue
129   // set itself, has an active value same as expected_active.
130   void set_active_all_threads(bool active, bool expected_active);
131 
132   void set_process_completed_buffers_threshold(size_t value);
133 
134   size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
135   void set_buffer_enqueue_threshold_percentage(uint value);
136 
137   virtual void filter(SATBMarkQueue* queue) = 0;
138 
139   // If there exists some completed buffer, pop and process it, and
140   // return true.  Otherwise return false.  Processing a buffer
141   // consists of applying the closure to the active range of the
142   // buffer; the leading entries may be excluded due to filtering.
143   bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
144 
145   virtual void enqueue_completed_buffer(BufferNode* node);
146 
147   // The number of buffers in the list.  Racy and not updated atomically
148   // with the set of completed buffers.
149   size_t completed_buffers_num() const {
150     return _count_and_process_flag &gt;&gt; 1;
151   }
152 
153   // Return true if completed buffers should be processed.
154   bool process_completed_buffers() const {
155     return (_count_and_process_flag &amp; 1) != 0;
156   }
157 
158 #ifndef PRODUCT
159   // Helpful for debugging
160   void print_all(const char* msg);
161 #endif // PRODUCT
162 
163   // If a marking is being abandoned, reset any unprocessed log buffers.
164   void abandon_partial_marking();
165 };
166 
167 inline SATBMarkQueueSet* SATBMarkQueue::satb_qset() const {
168   return static_cast&lt;SATBMarkQueueSet*&gt;(qset());
169 }
170 
171 inline void SATBMarkQueue::filter() {
172   satb_qset()-&gt;filter(this);
173 }
174 
175 // Removes entries from the buffer that are no longer needed, as
176 // determined by filter. If e is a void* entry in the buffer,
177 // filter_out(e) must be a valid expression whose value is convertible
178 // to bool. Entries are removed (filtered out) if the result is true,
179 // retained if false.
180 template&lt;typename Filter&gt;
181 inline void SATBMarkQueue::apply_filter(Filter filter_out) {
182   void** buf = this-&gt;_buf;
183 
184   if (buf == NULL) {
185     // nothing to do
186     return;
187   }
188 
189   // Two-fingered compaction toward the end.
190   void** src = &amp;buf[this-&gt;index()];
191   void** dst = &amp;buf[this-&gt;capacity()];
192   assert(src &lt;= dst, &quot;invariant&quot;);
193   for ( ; src &lt; dst; ++src) {
194     // Search low to high for an entry to keep.
195     void* entry = *src;
196     if (!filter_out(entry)) {
197       // Found keeper.  Search high to low for an entry to discard.
198       while (src &lt; --dst) {
199         if (filter_out(*dst)) {
200           *dst = entry;         // Replace discard with keeper.
201           break;
202         }
203       }
204       // If discard search failed (src == dst), the outer loop will also end.
205     }
206   }
207   // dst points to the lowest retained entry, or the end of the buffer
208   // if all the entries were filtered out.
209   this-&gt;set_index(dst - buf);
210 }
211 
212 #endif // SHARE_GC_SHARED_SATBMARKQUEUE_HPP
    </pre>
  </body>
</html>
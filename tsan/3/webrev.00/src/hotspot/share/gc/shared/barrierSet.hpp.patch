diff a/src/hotspot/share/gc/shared/barrierSet.hpp b/src/hotspot/share/gc/shared/barrierSet.hpp
--- a/src/hotspot/share/gc/shared/barrierSet.hpp
+++ b/src/hotspot/share/gc/shared/barrierSet.hpp
@@ -128,17 +128,23 @@
   // is redone until it succeeds. This can e.g. prevent allocations from the slow path
   // to be in old.
   virtual void on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {}
   virtual void on_thread_create(Thread* thread) {}
   virtual void on_thread_destroy(Thread* thread) {}
+
+  // These perform BarrierSet-related initialization/cleanup before the thread
+  // is added to or removed from the corresponding set of threads. The
+  // argument thread is the current thread. These are called either holding
+  // the Threads_lock (for a JavaThread) and so not at a safepoint, or holding
+  // the NonJavaThreadsList_lock (for a NonJavaThread) locked by the
+  // caller. That locking ensures the operation is "atomic" with the list
+  // modification wrto operations that hold the NJTList_lock and either also
+  // hold the Threads_lock or are at a safepoint.
   virtual void on_thread_attach(Thread* thread) {}
   virtual void on_thread_detach(Thread* thread) {}
-  virtual void make_parsable(JavaThread* thread) {}
 
-#ifdef CHECK_UNHANDLED_OOPS
-  virtual bool oop_equals_operator_allowed() { return true; }
-#endif
+  virtual void make_parsable(JavaThread* thread) {}
 
 public:
   // Print a description of the memory for the barrier set
   virtual void print_on(outputStream* st) const = 0;
 
@@ -203,27 +209,27 @@
     static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {
       Raw::store_at(base, offset, value);
     }
 
     template <typename T>
-    static T atomic_cmpxchg_in_heap(T new_value, T* addr, T compare_value) {
-      return Raw::atomic_cmpxchg(new_value, addr, compare_value);
+    static T atomic_cmpxchg_in_heap(T* addr, T compare_value, T new_value) {
+      return Raw::atomic_cmpxchg(addr, compare_value, new_value);
     }
 
     template <typename T>
-    static T atomic_cmpxchg_in_heap_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {
-      return Raw::atomic_cmpxchg_at(new_value, base, offset, compare_value);
+    static T atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {
+      return Raw::atomic_cmpxchg_at(base, offset, compare_value, new_value);
     }
 
     template <typename T>
-    static T atomic_xchg_in_heap(T new_value, T* addr) {
-      return Raw::atomic_xchg(new_value, addr);
+    static T atomic_xchg_in_heap(T* addr, T new_value) {
+      return Raw::atomic_xchg(addr, new_value);
     }
 
     template <typename T>
-    static T atomic_xchg_in_heap_at(T new_value, oop base, ptrdiff_t offset) {
-      return Raw::atomic_xchg_at(new_value, base, offset);
+    static T atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, T new_value) {
+      return Raw::atomic_xchg_at(base, offset, new_value);
     }
 
     template <typename T>
     static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                   arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
@@ -253,25 +259,25 @@
     static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {
       Raw::oop_store_at(base, offset, value);
     }
 
     template <typename T>
-    static oop oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {
-      return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);
+    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {
+      return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);
     }
 
-    static oop oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {
-      return Raw::oop_atomic_cmpxchg_at(new_value, base, offset, compare_value);
+    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {
+      return Raw::oop_atomic_cmpxchg_at(base, offset, compare_value, new_value);
     }
 
     template <typename T>
-    static oop oop_atomic_xchg_in_heap(oop new_value, T* addr) {
-      return Raw::oop_atomic_xchg(new_value, addr);
+    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value) {
+      return Raw::oop_atomic_xchg(addr, new_value);
     }
 
-    static oop oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {
-      return Raw::oop_atomic_xchg_at(new_value, base, offset);
+    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {
+      return Raw::oop_atomic_xchg_at(base, offset, new_value);
     }
 
     template <typename T>
     static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
@@ -289,31 +295,27 @@
     static void oop_store_not_in_heap(T* addr, oop value) {
       Raw::oop_store(addr, value);
     }
 
     template <typename T>
-    static oop oop_atomic_cmpxchg_not_in_heap(oop new_value, T* addr, oop compare_value) {
-      return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);
+    static oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {
+      return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);
     }
 
     template <typename T>
-    static oop oop_atomic_xchg_not_in_heap(oop new_value, T* addr) {
-      return Raw::oop_atomic_xchg(new_value, addr);
+    static oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {
+      return Raw::oop_atomic_xchg(addr, new_value);
     }
 
     // Clone barrier support
     static void clone_in_heap(oop src, oop dst, size_t size) {
       Raw::clone(src, dst, size);
     }
 
     static oop resolve(oop obj) {
       return Raw::resolve(obj);
     }
-
-    static bool equals(oop o1, oop o2) {
-      return Raw::equals(o1, o2);
-    }
   };
 };
 
 template<typename T>
 inline T* barrier_set_cast(BarrierSet* bs) {

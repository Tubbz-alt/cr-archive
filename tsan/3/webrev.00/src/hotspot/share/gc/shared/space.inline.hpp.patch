diff a/src/hotspot/share/gc/shared/space.inline.hpp b/src/hotspot/share/gc/shared/space.inline.hpp
--- a/src/hotspot/share/gc/shared/space.inline.hpp
+++ b/src/hotspot/share/gc/shared/space.inline.hpp
@@ -28,11 +28,10 @@
 #include "gc/shared/blockOffsetTable.inline.hpp"
 #include "gc/shared/collectedHeap.hpp"
 #include "gc/shared/generation.hpp"
 #include "gc/shared/space.hpp"
 #include "gc/shared/spaceDecorator.hpp"
-#include "memory/universe.hpp"
 #include "oops/oopsHierarchy.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/prefetch.inline.hpp"
 #include "runtime/safepoint.hpp"
 #if INCLUDE_SERIALGC
@@ -116,11 +115,11 @@
     size_t dead_length = pointer_delta(dead_end, dead_start);
     if (_allowed_deadspace_words >= dead_length) {
       _allowed_deadspace_words -= dead_length;
       CollectedHeap::fill_with_object(dead_start, dead_length);
       oop obj = oop(dead_start);
-      obj->set_mark_raw(obj->mark_raw()->set_marked());
+      obj->set_mark_raw(obj->mark_raw().set_marked());
 
       assert(dead_length == (size_t)obj->size(), "bad filler object size");
       log_develop_trace(gc, compaction)("Inserting object to dead space: " PTR_FORMAT ", " PTR_FORMAT ", " SIZE_FORMAT "b",
           p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);
 
@@ -163,12 +162,12 @@
   HeapWord* cur_obj = space->bottom();
   HeapWord* scan_limit = space->scan_limit();
 
   while (cur_obj < scan_limit) {
     assert(!space->scanned_block_is_obj(cur_obj) ||
-           oop(cur_obj)->mark_raw()->is_marked() || oop(cur_obj)->mark_raw()->is_unlocked() ||
-           oop(cur_obj)->mark_raw()->has_bias_pattern(),
+           oop(cur_obj)->mark_raw().is_marked() || oop(cur_obj)->mark_raw().is_unlocked() ||
+           oop(cur_obj)->mark_raw().has_bias_pattern(),
            "these are the only valid states during a mark sweep");
     if (space->scanned_block_is_obj(cur_obj) && oop(cur_obj)->is_gc_marked()) {
       // prefetch beyond cur_obj
       Prefetch::write(cur_obj, interval);
       size_t size = space->scanned_block_size(cur_obj);
@@ -331,11 +330,11 @@
       // prefetch beyond q
       Prefetch::read(cur_obj, scan_interval);
 
       // size and destination
       size_t size = space->obj_size(cur_obj);
-      HeapWord* compaction_top = (HeapWord*)oop(cur_obj)->forwardee();
+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(oop(cur_obj)->forwardee());
 
       // prefetch beyond compaction_top
       Prefetch::write(compaction_top, copy_interval);
 
       // copy object and reinit its mark
@@ -376,16 +375,6 @@
   } while (t < top());
 
   set_saved_mark_word(p);
 }
 
-template <typename OopClosureType>
-void ContiguousSpace::par_oop_iterate(MemRegion mr, OopClosureType* blk) {
-  HeapWord* obj_addr = mr.start();
-  HeapWord* limit = mr.end();
-  while (obj_addr < limit) {
-    assert(oopDesc::is_oop(oop(obj_addr)), "Should be an oop");
-    obj_addr += oop(obj_addr)->oop_iterate_size(blk);
-  }
-}
-
 #endif // SHARE_GC_SHARED_SPACE_INLINE_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/cardTableRS.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cardTableBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableRS.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardTableRS.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
122 }
123 
124 inline bool ClearNoncleanCardWrapper::clear_card(CardValue* entry) {
125   if (_is_par) {
126     return clear_card_parallel(entry);
127   } else {
128     return clear_card_serial(entry);
129   }
130 }
131 
132 inline bool ClearNoncleanCardWrapper::clear_card_parallel(CardValue* entry) {
133   while (true) {
134     // In the parallel case, we may have to do this several times.
135     CardValue entry_val = *entry;
136     assert(entry_val != CardTableRS::clean_card_val(),
137            &quot;We shouldn&#39;t be looking at clean cards, and this should &quot;
138            &quot;be the only place they get cleaned.&quot;);
139     if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)
140         || _ct-&gt;is_prev_youngergen_card_val(entry_val)) {
141       CardValue res =
<span class="line-modified">142         Atomic::cmpxchg(CardTableRS::clean_card_val(), entry, entry_val);</span>
143       if (res == entry_val) {
144         break;
145       } else {
146         assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,
147                &quot;The CAS above should only fail if another thread did &quot;
148                &quot;a GC write barrier.&quot;);
149       }
150     } else if (entry_val ==
151                CardTableRS::cur_youngergen_and_prev_nonclean_card) {
152       // Parallelism shouldn&#39;t matter in this case.  Only the thread
153       // assigned to scan the card should change this value.
154       *entry = _ct-&gt;cur_youngergen_card_val();
155       break;
156     } else {
157       assert(entry_val == _ct-&gt;cur_youngergen_card_val(),
158              &quot;Should be the only possibility.&quot;);
159       // In this case, the card was clean before, and become
160       // cur_youngergen only because of processing of a promoted object.
161       // We don&#39;t have to look at the card.
162       return false;
</pre>
<hr />
<pre>
227       // new dirty window.
228       end_of_non_clean = cur_hw;
229       start_of_non_clean = cur_hw;
230     }
231     // Note that &quot;cur_entry&quot; leads &quot;start_of_non_clean&quot; in
232     // its leftward excursion after this point
233     // in the loop and, when we hit the left end of &quot;mr&quot;,
234     // will point off of the left end of the card-table
235     // for &quot;mr&quot;.
236     cur_entry--;
237   }
238   // If the first card of &quot;mr&quot; was dirty, we will have
239   // been left with a dirty window, co-initial with &quot;mr&quot;,
240   // which we now process.
241   if (start_of_non_clean &lt; end_of_non_clean) {
242     const MemRegion mrd(start_of_non_clean, end_of_non_clean);
243     _dirty_card_closure-&gt;do_MemRegion(mrd);
244   }
245 }
246 
<span class="line-removed">247 // clean (by dirty-&gt;clean before) ==&gt; cur_younger_gen</span>
<span class="line-removed">248 // dirty                          ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">249 // precleaned                     ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">250 // prev-younger-gen               ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">251 // cur-younger-gen                ==&gt; cur_younger_gen</span>
<span class="line-removed">252 // cur_youngergen_and_prev_nonclean_card ==&gt; no change.</span>
<span class="line-removed">253 void CardTableRS::write_ref_field_gc_par(void* field, oop new_val) {</span>
<span class="line-removed">254   volatile CardValue* entry = byte_for(field);</span>
<span class="line-removed">255   do {</span>
<span class="line-removed">256     CardValue entry_val = *entry;</span>
<span class="line-removed">257     // We put this first because it&#39;s probably the most common case.</span>
<span class="line-removed">258     if (entry_val == clean_card_val()) {</span>
<span class="line-removed">259       // No threat of contention with cleaning threads.</span>
<span class="line-removed">260       *entry = cur_youngergen_card_val();</span>
<span class="line-removed">261       return;</span>
<span class="line-removed">262     } else if (card_is_dirty_wrt_gen_iter(entry_val)</span>
<span class="line-removed">263                || is_prev_youngergen_card_val(entry_val)) {</span>
<span class="line-removed">264       // Mark it as both cur and prev youngergen; card cleaning thread will</span>
<span class="line-removed">265       // eventually remove the previous stuff.</span>
<span class="line-removed">266       CardValue new_val = cur_youngergen_and_prev_nonclean_card;</span>
<span class="line-removed">267       CardValue res = Atomic::cmpxchg(new_val, entry, entry_val);</span>
<span class="line-removed">268       // Did the CAS succeed?</span>
<span class="line-removed">269       if (res == entry_val) return;</span>
<span class="line-removed">270       // Otherwise, retry, to see the new value.</span>
<span class="line-removed">271       continue;</span>
<span class="line-removed">272     } else {</span>
<span class="line-removed">273       assert(entry_val == cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">274              || entry_val == cur_youngergen_card_val(),</span>
<span class="line-removed">275              &quot;should be only possibilities.&quot;);</span>
<span class="line-removed">276       return;</span>
<span class="line-removed">277     }</span>
<span class="line-removed">278   } while (true);</span>
<span class="line-removed">279 }</span>
<span class="line-removed">280 </span>
281 void CardTableRS::younger_refs_in_space_iterate(Space* sp,
282                                                 OopsInGenClosure* cl,
283                                                 uint n_threads) {
284   verify_used_region_at_save_marks(sp);
285 
286   const MemRegion urasm = sp-&gt;used_region_at_save_marks();
287   non_clean_card_iterate_possibly_parallel(sp, urasm, cl, this, n_threads);
288 }
289 
290 #ifdef ASSERT
291 void CardTableRS::verify_used_region_at_save_marks(Space* sp) const {
292   MemRegion ur    = sp-&gt;used_region();
293   MemRegion urasm = sp-&gt;used_region_at_save_marks();
294 
295   assert(ur.contains(urasm),
296          &quot;Did you forget to call save_marks()? &quot;
297          &quot;[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) is not contained in &quot;
298          &quot;[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
299          p2i(urasm.start()), p2i(urasm.end()), p2i(ur.start()), p2i(ur.end()));
300 }
</pre>
<hr />
<pre>
326   if (!to_be_cleared_mr.is_empty()) {
327     clear(to_be_cleared_mr);
328   }
329   invalidate(used_mr);
330 }
331 
332 
333 class VerifyCleanCardClosure: public BasicOopIterateClosure {
334 private:
335   HeapWord* _boundary;
336   HeapWord* _begin;
337   HeapWord* _end;
338 protected:
339   template &lt;class T&gt; void do_oop_work(T* p) {
340     HeapWord* jp = (HeapWord*)p;
341     assert(jp &gt;= _begin &amp;&amp; jp &lt; _end,
342            &quot;Error: jp &quot; PTR_FORMAT &quot; should be within &quot;
343            &quot;[_begin, _end) = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,
344            p2i(jp), p2i(_begin), p2i(_end));
345     oop obj = RawAccess&lt;&gt;::oop_load(p);
<span class="line-modified">346     guarantee(obj == NULL || (HeapWord*)obj &gt;= _boundary,</span>
347               &quot;pointer &quot; PTR_FORMAT &quot; at &quot; PTR_FORMAT &quot; on &quot;
348               &quot;clean card crosses boundary&quot; PTR_FORMAT,
349               p2i(obj), p2i(jp), p2i(_boundary));
350   }
351 
352 public:
353   VerifyCleanCardClosure(HeapWord* b, HeapWord* begin, HeapWord* end) :
354     _boundary(b), _begin(begin), _end(end) {
355     assert(b &lt;= begin,
356            &quot;Error: boundary &quot; PTR_FORMAT &quot; should be at or below begin &quot; PTR_FORMAT,
357            p2i(b), p2i(begin));
358     assert(begin &lt;= end,
359            &quot;Error: begin &quot; PTR_FORMAT &quot; should be strictly below end &quot; PTR_FORMAT,
360            p2i(begin), p2i(end));
361   }
362 
363   virtual void do_oop(oop* p)       { VerifyCleanCardClosure::do_oop_work(p); }
364   virtual void do_oop(narrowOop* p) { VerifyCleanCardClosure::do_oop_work(p); }
365 };
366 
</pre>
<hr />
<pre>
596 void CardTableRS::verify() {
597   // At present, we only know how to verify the card table RS for
598   // generational heaps.
599   VerifyCTGenClosure blk(this);
600   GenCollectedHeap::heap()-&gt;generation_iterate(&amp;blk, false);
601   CardTable::verify();
602 }
603 
604 CardTableRS::CardTableRS(MemRegion whole_heap, bool scanned_concurrently) :
605   CardTable(whole_heap, scanned_concurrently),
606   _cur_youngergen_card_val(youngergenP1_card),
607   // LNC functionality
608   _lowest_non_clean(NULL),
609   _lowest_non_clean_chunk_size(NULL),
610   _lowest_non_clean_base_chunk_index(NULL),
611   _last_LNC_resizing_collection(NULL)
612 {
613   // max_gens is really GenCollectedHeap::heap()-&gt;gen_policy()-&gt;number_of_generations()
614   // (which is always 2, young &amp; old), but GenCollectedHeap has not been initialized yet.
615   uint max_gens = 2;
<span class="line-modified">616   _last_cur_val_in_gen = NEW_C_HEAP_ARRAY3(CardValue, max_gens + 1,</span>
<span class="line-removed">617                          mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);</span>
<span class="line-removed">618   if (_last_cur_val_in_gen == NULL) {</span>
<span class="line-removed">619     vm_exit_during_initialization(&quot;Could not create last_cur_val_in_gen array.&quot;);</span>
<span class="line-removed">620   }</span>
621   for (uint i = 0; i &lt; max_gens + 1; i++) {
622     _last_cur_val_in_gen[i] = clean_card_val();
623   }
624 }
625 
626 CardTableRS::~CardTableRS() {
<span class="line-modified">627   if (_last_cur_val_in_gen) {</span>
<span class="line-modified">628     FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);</span>
<span class="line-modified">629     _last_cur_val_in_gen = NULL;</span>
<span class="line-modified">630   }</span>
<span class="line-modified">631   if (_lowest_non_clean) {</span>
<span class="line-removed">632     FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);</span>
<span class="line-removed">633     _lowest_non_clean = NULL;</span>
<span class="line-removed">634   }</span>
<span class="line-removed">635   if (_lowest_non_clean_chunk_size) {</span>
<span class="line-removed">636     FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);</span>
<span class="line-removed">637     _lowest_non_clean_chunk_size = NULL;</span>
<span class="line-removed">638   }</span>
<span class="line-removed">639   if (_lowest_non_clean_base_chunk_index) {</span>
<span class="line-removed">640     FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);</span>
<span class="line-removed">641     _lowest_non_clean_base_chunk_index = NULL;</span>
<span class="line-removed">642   }</span>
<span class="line-removed">643   if (_last_LNC_resizing_collection) {</span>
<span class="line-removed">644     FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);</span>
<span class="line-removed">645     _last_LNC_resizing_collection = NULL;</span>
<span class="line-removed">646   }</span>
647 }
648 
649 void CardTableRS::initialize() {
650   CardTable::initialize();
651   _lowest_non_clean =
652     NEW_C_HEAP_ARRAY(CardArr, _max_covered_regions, mtGC);
653   _lowest_non_clean_chunk_size =
654     NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
655   _lowest_non_clean_base_chunk_index =
656     NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
657   _last_LNC_resizing_collection =
658     NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);
<span class="line-modified">659   if (_lowest_non_clean == NULL</span>
<span class="line-removed">660       || _lowest_non_clean_chunk_size == NULL</span>
<span class="line-removed">661       || _lowest_non_clean_base_chunk_index == NULL</span>
<span class="line-removed">662       || _last_LNC_resizing_collection == NULL)</span>
<span class="line-removed">663     vm_exit_during_initialization(&quot;couldn&#39;t allocate an LNC array.&quot;);</span>
664   for (int i = 0; i &lt; _max_covered_regions; i++) {
665     _lowest_non_clean[i] = NULL;
666     _lowest_non_clean_chunk_size[i] = 0;
667     _last_LNC_resizing_collection[i] = -1;
668   }
669 }
670 
671 bool CardTableRS::card_will_be_scanned(CardValue cv) {
672   return card_is_dirty_wrt_gen_iter(cv) || is_prev_nonclean_card_val(cv);
673 }
674 
675 bool CardTableRS::card_may_have_been_dirty(CardValue cv) {
676   return
677     cv != clean_card &amp;&amp;
678     (card_is_dirty_wrt_gen_iter(cv) ||
679      CardTableRS::youngergen_may_have_been_dirty(cv));
680 }
681 
682 void CardTableRS::non_clean_card_iterate_possibly_parallel(
683   Space* sp,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
122 }
123 
124 inline bool ClearNoncleanCardWrapper::clear_card(CardValue* entry) {
125   if (_is_par) {
126     return clear_card_parallel(entry);
127   } else {
128     return clear_card_serial(entry);
129   }
130 }
131 
132 inline bool ClearNoncleanCardWrapper::clear_card_parallel(CardValue* entry) {
133   while (true) {
134     // In the parallel case, we may have to do this several times.
135     CardValue entry_val = *entry;
136     assert(entry_val != CardTableRS::clean_card_val(),
137            &quot;We shouldn&#39;t be looking at clean cards, and this should &quot;
138            &quot;be the only place they get cleaned.&quot;);
139     if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)
140         || _ct-&gt;is_prev_youngergen_card_val(entry_val)) {
141       CardValue res =
<span class="line-modified">142         Atomic::cmpxchg(entry, entry_val, CardTableRS::clean_card_val());</span>
143       if (res == entry_val) {
144         break;
145       } else {
146         assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,
147                &quot;The CAS above should only fail if another thread did &quot;
148                &quot;a GC write barrier.&quot;);
149       }
150     } else if (entry_val ==
151                CardTableRS::cur_youngergen_and_prev_nonclean_card) {
152       // Parallelism shouldn&#39;t matter in this case.  Only the thread
153       // assigned to scan the card should change this value.
154       *entry = _ct-&gt;cur_youngergen_card_val();
155       break;
156     } else {
157       assert(entry_val == _ct-&gt;cur_youngergen_card_val(),
158              &quot;Should be the only possibility.&quot;);
159       // In this case, the card was clean before, and become
160       // cur_youngergen only because of processing of a promoted object.
161       // We don&#39;t have to look at the card.
162       return false;
</pre>
<hr />
<pre>
227       // new dirty window.
228       end_of_non_clean = cur_hw;
229       start_of_non_clean = cur_hw;
230     }
231     // Note that &quot;cur_entry&quot; leads &quot;start_of_non_clean&quot; in
232     // its leftward excursion after this point
233     // in the loop and, when we hit the left end of &quot;mr&quot;,
234     // will point off of the left end of the card-table
235     // for &quot;mr&quot;.
236     cur_entry--;
237   }
238   // If the first card of &quot;mr&quot; was dirty, we will have
239   // been left with a dirty window, co-initial with &quot;mr&quot;,
240   // which we now process.
241   if (start_of_non_clean &lt; end_of_non_clean) {
242     const MemRegion mrd(start_of_non_clean, end_of_non_clean);
243     _dirty_card_closure-&gt;do_MemRegion(mrd);
244   }
245 }
246 


































247 void CardTableRS::younger_refs_in_space_iterate(Space* sp,
248                                                 OopsInGenClosure* cl,
249                                                 uint n_threads) {
250   verify_used_region_at_save_marks(sp);
251 
252   const MemRegion urasm = sp-&gt;used_region_at_save_marks();
253   non_clean_card_iterate_possibly_parallel(sp, urasm, cl, this, n_threads);
254 }
255 
256 #ifdef ASSERT
257 void CardTableRS::verify_used_region_at_save_marks(Space* sp) const {
258   MemRegion ur    = sp-&gt;used_region();
259   MemRegion urasm = sp-&gt;used_region_at_save_marks();
260 
261   assert(ur.contains(urasm),
262          &quot;Did you forget to call save_marks()? &quot;
263          &quot;[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) is not contained in &quot;
264          &quot;[&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
265          p2i(urasm.start()), p2i(urasm.end()), p2i(ur.start()), p2i(ur.end()));
266 }
</pre>
<hr />
<pre>
292   if (!to_be_cleared_mr.is_empty()) {
293     clear(to_be_cleared_mr);
294   }
295   invalidate(used_mr);
296 }
297 
298 
299 class VerifyCleanCardClosure: public BasicOopIterateClosure {
300 private:
301   HeapWord* _boundary;
302   HeapWord* _begin;
303   HeapWord* _end;
304 protected:
305   template &lt;class T&gt; void do_oop_work(T* p) {
306     HeapWord* jp = (HeapWord*)p;
307     assert(jp &gt;= _begin &amp;&amp; jp &lt; _end,
308            &quot;Error: jp &quot; PTR_FORMAT &quot; should be within &quot;
309            &quot;[_begin, _end) = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,
310            p2i(jp), p2i(_begin), p2i(_end));
311     oop obj = RawAccess&lt;&gt;::oop_load(p);
<span class="line-modified">312     guarantee(obj == NULL || cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= _boundary,</span>
313               &quot;pointer &quot; PTR_FORMAT &quot; at &quot; PTR_FORMAT &quot; on &quot;
314               &quot;clean card crosses boundary&quot; PTR_FORMAT,
315               p2i(obj), p2i(jp), p2i(_boundary));
316   }
317 
318 public:
319   VerifyCleanCardClosure(HeapWord* b, HeapWord* begin, HeapWord* end) :
320     _boundary(b), _begin(begin), _end(end) {
321     assert(b &lt;= begin,
322            &quot;Error: boundary &quot; PTR_FORMAT &quot; should be at or below begin &quot; PTR_FORMAT,
323            p2i(b), p2i(begin));
324     assert(begin &lt;= end,
325            &quot;Error: begin &quot; PTR_FORMAT &quot; should be strictly below end &quot; PTR_FORMAT,
326            p2i(begin), p2i(end));
327   }
328 
329   virtual void do_oop(oop* p)       { VerifyCleanCardClosure::do_oop_work(p); }
330   virtual void do_oop(narrowOop* p) { VerifyCleanCardClosure::do_oop_work(p); }
331 };
332 
</pre>
<hr />
<pre>
562 void CardTableRS::verify() {
563   // At present, we only know how to verify the card table RS for
564   // generational heaps.
565   VerifyCTGenClosure blk(this);
566   GenCollectedHeap::heap()-&gt;generation_iterate(&amp;blk, false);
567   CardTable::verify();
568 }
569 
570 CardTableRS::CardTableRS(MemRegion whole_heap, bool scanned_concurrently) :
571   CardTable(whole_heap, scanned_concurrently),
572   _cur_youngergen_card_val(youngergenP1_card),
573   // LNC functionality
574   _lowest_non_clean(NULL),
575   _lowest_non_clean_chunk_size(NULL),
576   _lowest_non_clean_base_chunk_index(NULL),
577   _last_LNC_resizing_collection(NULL)
578 {
579   // max_gens is really GenCollectedHeap::heap()-&gt;gen_policy()-&gt;number_of_generations()
580   // (which is always 2, young &amp; old), but GenCollectedHeap has not been initialized yet.
581   uint max_gens = 2;
<span class="line-modified">582   _last_cur_val_in_gen = NEW_C_HEAP_ARRAY(CardValue, max_gens + 1, mtGC);</span>




583   for (uint i = 0; i &lt; max_gens + 1; i++) {
584     _last_cur_val_in_gen[i] = clean_card_val();
585   }
586 }
587 
588 CardTableRS::~CardTableRS() {
<span class="line-modified">589   FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);</span>
<span class="line-modified">590   FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);</span>
<span class="line-modified">591   FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);</span>
<span class="line-modified">592   FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);</span>
<span class="line-modified">593   FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);</span>















594 }
595 
596 void CardTableRS::initialize() {
597   CardTable::initialize();
598   _lowest_non_clean =
599     NEW_C_HEAP_ARRAY(CardArr, _max_covered_regions, mtGC);
600   _lowest_non_clean_chunk_size =
601     NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
602   _lowest_non_clean_base_chunk_index =
603     NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
604   _last_LNC_resizing_collection =
605     NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);
<span class="line-modified">606 </span>




607   for (int i = 0; i &lt; _max_covered_regions; i++) {
608     _lowest_non_clean[i] = NULL;
609     _lowest_non_clean_chunk_size[i] = 0;
610     _last_LNC_resizing_collection[i] = -1;
611   }
612 }
613 
614 bool CardTableRS::card_will_be_scanned(CardValue cv) {
615   return card_is_dirty_wrt_gen_iter(cv) || is_prev_nonclean_card_val(cv);
616 }
617 
618 bool CardTableRS::card_may_have_been_dirty(CardValue cv) {
619   return
620     cv != clean_card &amp;&amp;
621     (card_is_dirty_wrt_gen_iter(cv) ||
622      CardTableRS::youngergen_may_have_been_dirty(cv));
623 }
624 
625 void CardTableRS::non_clean_card_iterate_possibly_parallel(
626   Space* sp,
</pre>
</td>
</tr>
</table>
<center><a href="cardTableBarrierSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableRS.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/generation.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENERATION_HPP
 26 #define SHARE_GC_SHARED_GENERATION_HPP
 27 
 28 #include &quot;gc/shared/collectorCounters.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/memRegion.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;memory/virtualspace.hpp&quot;
 35 #include &quot;runtime/mutex.hpp&quot;
 36 #include &quot;runtime/perfData.hpp&quot;
 37 
 38 // A Generation models a heap area for similarly-aged objects.
 39 // It will contain one ore more spaces holding the actual objects.
 40 //
 41 // The Generation class hierarchy:
 42 //
 43 // Generation                      - abstract base class
 44 // - DefNewGeneration              - allocation area (copy collected)
<a name="2" id="anc2"></a><span class="line-removed"> 45 //   - ParNewGeneration            - a DefNewGeneration that is collected by</span>
<span class="line-removed"> 46 //                                   several threads</span>
 47 // - CardGeneration                 - abstract class adding offset array behavior
 48 //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)
<a name="3" id="anc3"></a><span class="line-removed"> 49 //   - ConcurrentMarkSweepGeneration - Mostly Concurrent Mark Sweep Generation</span>
<span class="line-removed"> 50 //                                       (Detlefs-Printezis refinement of</span>
<span class="line-removed"> 51 //                                       Boehm-Demers-Schenker)</span>
 52 //
<a name="4" id="anc4"></a><span class="line-modified"> 53 // The system configurations currently allowed are:</span>
 54 //
 55 //   DefNewGeneration + TenuredGeneration
 56 //
<a name="5" id="anc5"></a><span class="line-removed"> 57 //   ParNewGeneration + ConcurrentMarkSweepGeneration</span>
<span class="line-removed"> 58 //</span>
 59 
 60 class DefNewGeneration;
 61 class GCMemoryManager;
 62 class GenerationSpec;
 63 class CompactibleSpace;
 64 class ContiguousSpace;
 65 class CompactPoint;
 66 class OopsInGenClosure;
 67 class OopClosure;
 68 class ScanClosure;
 69 class FastScanClosure;
 70 class GenCollectedHeap;
 71 class GCStats;
 72 
 73 // A &quot;ScratchBlock&quot; represents a block of memory in one generation usable by
 74 // another.  It represents &quot;num_words&quot; free words, starting at and including
 75 // the address of &quot;this&quot;.
 76 struct ScratchBlock {
 77   ScratchBlock* next;
 78   size_t num_words;
 79   HeapWord scratch_space[1];  // Actually, of size &quot;num_words-2&quot; (assuming
 80                               // first two fields are word-sized.)
 81 };
 82 
 83 class Generation: public CHeapObj&lt;mtGC&gt; {
 84   friend class VMStructs;
 85  private:
 86   jlong _time_of_last_gc; // time when last gc on this generation happened (ms)
 87   MemRegion _prev_used_region; // for collectors that want to &quot;remember&quot; a value for
 88                                // used region at some specific point during collection.
 89 
 90   GCMemoryManager* _gc_manager;
 91 
 92  protected:
 93   // Minimum and maximum addresses for memory reserved (not necessarily
 94   // committed) for generation.
 95   // Used by card marking code. Must not overlap with address ranges of
 96   // other generations.
 97   MemRegion _reserved;
 98 
 99   // Memory area reserved for generation
100   VirtualSpace _virtual_space;
101 
102   // (&quot;Weak&quot;) Reference processing support
103   SpanSubjectToDiscoveryClosure _span_based_discoverer;
104   ReferenceProcessor* _ref_processor;
105 
106   // Performance Counters
107   CollectorCounters* _gc_counters;
108 
109   // Statistics for garbage collection
110   GCStats* _gc_stats;
111 
112   // Initialize the generation.
113   Generation(ReservedSpace rs, size_t initial_byte_size);
114 
115   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) (exactly) all the ref fields in
116   // &quot;sp&quot; that point into younger generations.
117   // The iteration is only over objects allocated at the start of the
118   // iterations; objects allocated as a result of applying the closure are
119   // not included.
120   void younger_refs_in_space_iterate(Space* sp, OopsInGenClosure* cl, uint n_threads);
121 
122  public:
123   // The set of possible generation kinds.
124   enum Name {
125     DefNew,
<a name="6" id="anc6"></a><span class="line-removed">126     ParNew,</span>
127     MarkSweepCompact,
<a name="7" id="anc7"></a><span class="line-removed">128     ConcurrentMarkSweep,</span>
129     Other
130   };
131 
132   enum SomePublicConstants {
133     // Generations are GenGrain-aligned and have size that are multiples of
134     // GenGrain.
135     // Note: on ARM we add 1 bit for card_table_base to be properly aligned
136     // (we expect its low byte to be zero - see implementation of post_barrier)
137     LogOfGenGrain = 16 ARM32_ONLY(+1),
138     GenGrain = 1 &lt;&lt; LogOfGenGrain
139   };
140 
141   // allocate and initialize (&quot;weak&quot;) refs processing support
142   virtual void ref_processor_init();
143   void set_ref_processor(ReferenceProcessor* rp) {
144     assert(_ref_processor == NULL, &quot;clobbering existing _ref_processor&quot;);
145     _ref_processor = rp;
146   }
147 
148   virtual Generation::Name kind() { return Generation::Other; }
149 
150   // This properly belongs in the collector, but for now this
151   // will do.
152   virtual bool refs_discovery_is_atomic() const { return true;  }
153   virtual bool refs_discovery_is_mt()     const { return false; }
154 
155   // Space inquiries (results in bytes)
156   size_t initial_size();
157   virtual size_t capacity() const = 0;  // The maximum number of object bytes the
158                                         // generation can currently hold.
159   virtual size_t used() const = 0;      // The number of used bytes in the gen.
160   virtual size_t free() const = 0;      // The number of free bytes in the gen.
161 
162   // Support for java.lang.Runtime.maxMemory(); see CollectedHeap.
163   // Returns the total number of bytes  available in a generation
164   // for the allocation of objects.
165   virtual size_t max_capacity() const;
166 
167   // If this is a young generation, the maximum number of bytes that can be
168   // allocated in this generation before a GC is triggered.
169   virtual size_t capacity_before_gc() const { return 0; }
170 
171   // The largest number of contiguous free bytes in the generation,
172   // including expansion  (Assumes called at a safepoint.)
173   virtual size_t contiguous_available() const = 0;
174   // The largest number of contiguous free bytes in this or any higher generation.
175   virtual size_t max_contiguous_available() const;
176 
177   // Returns true if promotions of the specified amount are
178   // likely to succeed without a promotion failure.
179   // Promotion of the full amount is not guaranteed but
180   // might be attempted in the worst case.
181   virtual bool promotion_attempt_is_safe(size_t max_promotion_in_bytes) const;
182 
183   // For a non-young generation, this interface can be used to inform a
184   // generation that a promotion attempt into that generation failed.
185   // Typically used to enable diagnostic output for post-mortem analysis,
186   // but other uses of the interface are not ruled out.
187   virtual void promotion_failure_occurred() { /* does nothing */ }
188 
189   // Return an estimate of the maximum allocation that could be performed
190   // in the generation without triggering any collection or expansion
191   // activity.  It is &quot;unsafe&quot; because no locks are taken; the result
192   // should be treated as an approximation, not a guarantee, for use in
193   // heuristic resizing decisions.
194   virtual size_t unsafe_max_alloc_nogc() const = 0;
195 
196   // Returns true if this generation cannot be expanded further
197   // without a GC. Override as appropriate.
198   virtual bool is_maximal_no_gc() const {
199     return _virtual_space.uncommitted_size() == 0;
200   }
201 
202   MemRegion reserved() const { return _reserved; }
203 
204   // Returns a region guaranteed to contain all the objects in the
205   // generation.
206   virtual MemRegion used_region() const { return _reserved; }
207 
208   MemRegion prev_used_region() const { return _prev_used_region; }
209   virtual void  save_used_region()   { _prev_used_region = used_region(); }
210 
211   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas in the generation.
212   // For some kinds of generations, this may be an expensive operation.
213   // To avoid performance problems stemming from its inadvertent use in
214   // product jvm&#39;s, we restrict its use to assertion checking or
215   // verification only.
216   virtual bool is_in(const void* p) const;
217 
218   /* Returns &quot;TRUE&quot; iff &quot;p&quot; points into the reserved area of the generation. */
219   bool is_in_reserved(const void* p) const {
220     return _reserved.contains(p);
221   }
222 
223   // If some space in the generation contains the given &quot;addr&quot;, return a
224   // pointer to that space, else return &quot;NULL&quot;.
225   virtual Space* space_containing(const void* addr) const;
226 
227   // Iteration - do not use for time critical operations
228   virtual void space_iterate(SpaceClosure* blk, bool usedOnly = false) = 0;
229 
230   // Returns the first space, if any, in the generation that can participate
231   // in compaction, or else &quot;NULL&quot;.
232   virtual CompactibleSpace* first_compaction_space() const = 0;
233 
234   // Returns &quot;true&quot; iff this generation should be used to allocate an
235   // object of the given size.  Young generations might
236   // wish to exclude very large objects, for example, since, if allocated
237   // often, they would greatly increase the frequency of young-gen
238   // collection.
239   virtual bool should_allocate(size_t word_size, bool is_tlab) {
240     bool result = false;
241     size_t overflow_limit = (size_t)1 &lt;&lt; (BitsPerSize_t - LogHeapWordSize);
242     if (!is_tlab || supports_tlab_allocation()) {
243       result = (word_size &gt; 0) &amp;&amp; (word_size &lt; overflow_limit);
244     }
245     return result;
246   }
247 
248   // Allocate and returns a block of the requested size, or returns &quot;NULL&quot;.
249   // Assumes the caller has done any necessary locking.
250   virtual HeapWord* allocate(size_t word_size, bool is_tlab) = 0;
251 
252   // Like &quot;allocate&quot;, but performs any necessary locking internally.
253   virtual HeapWord* par_allocate(size_t word_size, bool is_tlab) = 0;
254 
255   // Some generation may offer a region for shared, contiguous allocation,
256   // via inlined code (by exporting the address of the top and end fields
257   // defining the extent of the contiguous allocation region.)
258 
259   // This function returns &quot;true&quot; iff the heap supports this kind of
260   // allocation.  (More precisely, this means the style of allocation that
261   // increments *top_addr()&quot; with a CAS.) (Default is &quot;no&quot;.)
262   // A generation that supports this allocation style must use lock-free
263   // allocation for *all* allocation, since there are times when lock free
264   // allocation will be concurrent with plain &quot;allocate&quot; calls.
265   virtual bool supports_inline_contig_alloc() const { return false; }
266 
267   // These functions return the addresses of the fields that define the
268   // boundaries of the contiguous allocation area.  (These fields should be
269   // physically near to one another.)
270   virtual HeapWord* volatile* top_addr() const { return NULL; }
271   virtual HeapWord** end_addr() const { return NULL; }
272 
273   // Thread-local allocation buffers
274   virtual bool supports_tlab_allocation() const { return false; }
275   virtual size_t tlab_capacity() const {
276     guarantee(false, &quot;Generation doesn&#39;t support thread local allocation buffers&quot;);
277     return 0;
278   }
279   virtual size_t tlab_used() const {
280     guarantee(false, &quot;Generation doesn&#39;t support thread local allocation buffers&quot;);
281     return 0;
282   }
283   virtual size_t unsafe_max_tlab_alloc() const {
284     guarantee(false, &quot;Generation doesn&#39;t support thread local allocation buffers&quot;);
285     return 0;
286   }
287 
288   // &quot;obj&quot; is the address of an object in a younger generation.  Allocate space
289   // for &quot;obj&quot; in the current (or some higher) generation, and copy &quot;obj&quot; into
290   // the newly allocated space, if possible, returning the result (or NULL if
291   // the allocation failed).
292   //
293   // The &quot;obj_size&quot; argument is just obj-&gt;size(), passed along so the caller can
294   // avoid repeating the virtual call to retrieve it.
295   virtual oop promote(oop obj, size_t obj_size);
296 
297   // Thread &quot;thread_num&quot; (0 &lt;= i &lt; ParalleGCThreads) wants to promote
298   // object &quot;obj&quot;, whose original mark word was &quot;m&quot;, and whose size is
299   // &quot;word_sz&quot;.  If possible, allocate space for &quot;obj&quot;, copy obj into it
300   // (taking care to copy &quot;m&quot; into the mark word when done, since the mark
301   // word of &quot;obj&quot; may have been overwritten with a forwarding pointer, and
302   // also taking care to copy the klass pointer *last*.  Returns the new
303   // object if successful, or else NULL.
<a name="8" id="anc8"></a><span class="line-modified">304   virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);</span>
305 
306   // Informs the current generation that all par_promote_alloc&#39;s in the
307   // collection have been completed; any supporting data structures can be
308   // reset.  Default is to do nothing.
309   virtual void par_promote_alloc_done(int thread_num) {}
310 
311   // Informs the current generation that all oop_since_save_marks_iterates
312   // performed by &quot;thread_num&quot; in the current collection, if any, have been
313   // completed; any supporting data structures can be reset.  Default is to
314   // do nothing.
315   virtual void par_oop_since_save_marks_iterate_done(int thread_num) {}
316 
317   // Returns &quot;true&quot; iff collect() should subsequently be called on this
318   // this generation. See comment below.
319   // This is a generic implementation which can be overridden.
320   //
321   // Note: in the current (1.4) implementation, when genCollectedHeap&#39;s
322   // incremental_collection_will_fail flag is set, all allocations are
323   // slow path (the only fast-path place to allocate is DefNew, which
324   // will be full if the flag is set).
325   // Thus, older generations which collect younger generations should
326   // test this flag and collect if it is set.
327   virtual bool should_collect(bool   full,
328                               size_t word_size,
329                               bool   is_tlab) {
330     return (full || should_allocate(word_size, is_tlab));
331   }
332 
333   // Returns true if the collection is likely to be safely
334   // completed. Even if this method returns true, a collection
335   // may not be guaranteed to succeed, and the system should be
336   // able to safely unwind and recover from that failure, albeit
337   // at some additional cost.
338   virtual bool collection_attempt_is_safe() {
339     guarantee(false, &quot;Are you sure you want to call this method?&quot;);
340     return true;
341   }
342 
343   // Perform a garbage collection.
344   // If full is true attempt a full garbage collection of this generation.
345   // Otherwise, attempting to (at least) free enough space to support an
346   // allocation of the given &quot;word_size&quot;.
347   virtual void collect(bool   full,
348                        bool   clear_all_soft_refs,
349                        size_t word_size,
350                        bool   is_tlab) = 0;
351 
352   // Perform a heap collection, attempting to create (at least) enough
353   // space to support an allocation of the given &quot;word_size&quot;.  If
354   // successful, perform the allocation and return the resulting
355   // &quot;oop&quot; (initializing the allocated block). If the allocation is
356   // still unsuccessful, return &quot;NULL&quot;.
357   virtual HeapWord* expand_and_allocate(size_t word_size,
358                                         bool is_tlab,
359                                         bool parallel = false) = 0;
360 
361   // Some generations may require some cleanup or preparation actions before
362   // allowing a collection.  The default is to do nothing.
363   virtual void gc_prologue(bool full) {}
364 
365   // Some generations may require some cleanup actions after a collection.
366   // The default is to do nothing.
367   virtual void gc_epilogue(bool full) {}
368 
369   // Save the high water marks for the used space in a generation.
370   virtual void record_spaces_top() {}
371 
372   // Some generations may need to be &quot;fixed-up&quot; after some allocation
373   // activity to make them parsable again. The default is to do nothing.
374   virtual void ensure_parsability() {}
375 
376   // Time (in ms) when we were last collected or now if a collection is
377   // in progress.
378   virtual jlong time_of_last_gc(jlong now) {
379     // Both _time_of_last_gc and now are set using a time source
380     // that guarantees monotonically non-decreasing values provided
381     // the underlying platform provides such a source. So we still
382     // have to guard against non-monotonicity.
383     NOT_PRODUCT(
384       if (now &lt; _time_of_last_gc) {
385         log_warning(gc)(&quot;time warp: &quot; JLONG_FORMAT &quot; to &quot; JLONG_FORMAT, _time_of_last_gc, now);
386       }
387     )
388     return _time_of_last_gc;
389   }
390 
391   virtual void update_time_of_last_gc(jlong now)  {
392     _time_of_last_gc = now;
393   }
394 
395   // Generations may keep statistics about collection. This method
396   // updates those statistics. current_generation is the generation
397   // that was most recently collected. This allows the generation to
398   // decide what statistics are valid to collect. For example, the
399   // generation can decide to gather the amount of promoted data if
400   // the collection of the young generation has completed.
401   GCStats* gc_stats() const { return _gc_stats; }
402   virtual void update_gc_stats(Generation* current_generation, bool full) {}
403 
404 #if INCLUDE_SERIALGC
405   // Mark sweep support phase2
406   virtual void prepare_for_compaction(CompactPoint* cp);
407   // Mark sweep support phase3
408   virtual void adjust_pointers();
409   // Mark sweep support phase4
410   virtual void compact();
411   virtual void post_compact() { ShouldNotReachHere(); }
412 #endif
413 
414   // Support for CMS&#39;s rescan. In this general form we return a pointer
415   // to an abstract object that can be used, based on specific previously
416   // decided protocols, to exchange information between generations,
417   // information that may be useful for speeding up certain types of
418   // garbage collectors. A NULL value indicates to the client that
419   // no data recording is expected by the provider. The data-recorder is
420   // expected to be GC worker thread-local, with the worker index
421   // indicated by &quot;thr_num&quot;.
422   virtual void* get_data_recorder(int thr_num) { return NULL; }
423   virtual void sample_eden_chunk() {}
424 
425   // Some generations may require some cleanup actions before allowing
426   // a verification.
427   virtual void prepare_for_verify() {}
428 
429   // Accessing &quot;marks&quot;.
430 
431   // This function gives a generation a chance to note a point between
432   // collections.  For example, a contiguous generation might note the
433   // beginning allocation point post-collection, which might allow some later
434   // operations to be optimized.
435   virtual void save_marks() {}
436 
437   // This function allows generations to initialize any &quot;saved marks&quot;.  That
438   // is, should only be called when the generation is empty.
439   virtual void reset_saved_marks() {}
440 
441   // This function is &quot;true&quot; iff any no allocations have occurred in the
442   // generation since the last call to &quot;save_marks&quot;.
443   virtual bool no_allocs_since_save_marks() = 0;
444 
445   // The &quot;requestor&quot; generation is performing some garbage collection
446   // action for which it would be useful to have scratch space.  If
447   // the target is not the requestor, no gc actions will be required
448   // of the target.  The requestor promises to allocate no more than
449   // &quot;max_alloc_words&quot; in the target generation (via promotion say,
450   // if the requestor is a young generation and the target is older).
451   // If the target generation can provide any scratch space, it adds
452   // it to &quot;list&quot;, leaving &quot;list&quot; pointing to the head of the
453   // augmented list.  The default is to offer no space.
454   virtual void contribute_scratch(ScratchBlock*&amp; list, Generation* requestor,
455                                   size_t max_alloc_words) {}
456 
457   // Give each generation an opportunity to do clean up for any
458   // contributed scratch.
459   virtual void reset_scratch() {}
460 
461   // When an older generation has been collected, and perhaps resized,
462   // this method will be invoked on all younger generations (from older to
463   // younger), allowing them to resize themselves as appropriate.
464   virtual void compute_new_size() = 0;
465 
466   // Printing
467   virtual const char* name() const = 0;
468   virtual const char* short_name() const = 0;
469 
470   // Reference Processing accessor
471   ReferenceProcessor* const ref_processor() { return _ref_processor; }
472 
473   // Iteration.
474 
475   // Iterate over all the ref-containing fields of all objects in the
476   // generation, calling &quot;cl.do_oop&quot; on each.
477   virtual void oop_iterate(OopIterateClosure* cl);
478 
479   // Iterate over all objects in the generation, calling &quot;cl.do_object&quot; on
480   // each.
481   virtual void object_iterate(ObjectClosure* cl);
482 
<a name="9" id="anc9"></a><span class="line-removed">483   // Iterate over all safe objects in the generation, calling &quot;cl.do_object&quot; on</span>
<span class="line-removed">484   // each.  An object is safe if its references point to other objects in</span>
<span class="line-removed">485   // the heap.  This defaults to object_iterate() unless overridden.</span>
<span class="line-removed">486   virtual void safe_object_iterate(ObjectClosure* cl);</span>
<span class="line-removed">487 </span>
488   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) all and only all the ref fields
489   // in the current generation that contain pointers to objects in younger
490   // generations. Objects allocated since the last &quot;save_marks&quot; call are
491   // excluded.
492   virtual void younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) = 0;
493 
494   // Inform a generation that it longer contains references to objects
495   // in any younger generation.    [e.g. Because younger gens are empty,
496   // clear the card table.]
497   virtual void clear_remembered_set() { }
498 
499   // Inform a generation that some of its objects have moved.  [e.g. The
500   // generation&#39;s spaces were compacted, invalidating the card table.]
501   virtual void invalidate_remembered_set() { }
502 
503   // Block abstraction.
504 
505   // Returns the address of the start of the &quot;block&quot; that contains the
506   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
507   // may not pack objects densely; a chunk may either be an object or a
508   // non-object.
509   virtual HeapWord* block_start(const void* addr) const;
510 
511   // Requires &quot;addr&quot; to be the start of a chunk, and returns its size.
512   // &quot;addr + size&quot; is required to be the start of a new chunk, or the end
513   // of the active area of the heap.
514   virtual size_t block_size(const HeapWord* addr) const ;
515 
516   // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
517   // the block is an object.
518   virtual bool block_is_obj(const HeapWord* addr) const;
519 
520   void print_heap_change(size_t prev_used) const;
521 
522   virtual void print() const;
523   virtual void print_on(outputStream* st) const;
524 
525   virtual void verify() = 0;
526 
527   struct StatRecord {
528     int invocations;
529     elapsedTimer accumulated_time;
530     StatRecord() :
531       invocations(0),
532       accumulated_time(elapsedTimer()) {}
533   };
534 private:
535   StatRecord _stat_record;
536 public:
537   StatRecord* stat_record() { return &amp;_stat_record; }
538 
539   virtual void print_summary_info_on(outputStream* st);
540 
541   // Performance Counter support
542   virtual void update_counters() = 0;
543   virtual CollectorCounters* counters() { return _gc_counters; }
544 
545   GCMemoryManager* gc_manager() const {
546     assert(_gc_manager != NULL, &quot;not initialized yet&quot;);
547     return _gc_manager;
548   }
549 
550   void set_gc_manager(GCMemoryManager* gc_manager) {
551     _gc_manager = gc_manager;
552   }
553 
554 };
555 
556 #endif // SHARE_GC_SHARED_GENERATION_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/satbMarkQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
<a name="1" id="anc1"></a>
 31 #include &quot;runtime/mutexLocker.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/threadSMR.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;
<a name="2" id="anc2"></a>
 37 
<a name="3" id="anc3"></a><span class="line-modified"> 38 SATBMarkQueue::SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent) :</span>
 39   // SATB queues are only active during marking cycles. We create
 40   // them with their active field set to false. If a thread is
 41   // created during a cycle and its SATB queue needs to be activated
 42   // before the thread starts running, we&#39;ll need to set its active
 43   // field to true. This must be done in the collector-specific
 44   // BarrierSet thread attachment protocol.
<a name="4" id="anc4"></a><span class="line-modified"> 45   PtrQueue(qset, permanent, false /* active */)</span>
 46 { }
 47 
 48 void SATBMarkQueue::flush() {
 49   // Filter now to possibly save work later.  If filtering empties the
 50   // buffer then flush_impl can deallocate the buffer.
 51   filter();
 52   flush_impl();
 53 }
 54 
 55 // This method will first apply filtering to the buffer. If filtering
 56 // retains a small enough collection in the buffer, we can continue to
 57 // use the buffer as-is, instead of enqueueing and replacing it.
 58 
<a name="5" id="anc5"></a><span class="line-modified"> 59 bool SATBMarkQueue::should_enqueue_buffer() {</span>
 60   // This method should only be called if there is a non-NULL buffer
 61   // that is full.
 62   assert(index() == 0, &quot;pre-condition&quot;);
 63   assert(_buf != NULL, &quot;pre-condition&quot;);
 64 
 65   filter();
 66 
<a name="6" id="anc6"></a><span class="line-modified"> 67   SATBMarkQueueSet* satb_qset = static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="line-removed"> 68   size_t threshold = satb_qset-&gt;buffer_enqueue_threshold();</span>
 69   // Ensure we&#39;ll enqueue completely full buffers.
 70   assert(threshold &gt; 0, &quot;enqueue threshold = 0&quot;);
 71   // Ensure we won&#39;t enqueue empty buffers.
 72   assert(threshold &lt;= capacity(),
 73          &quot;enqueue threshold &quot; SIZE_FORMAT &quot; exceeds capacity &quot; SIZE_FORMAT,
 74          threshold, capacity());
<a name="7" id="anc7"></a><span class="line-modified"> 75   return index() &lt; threshold;</span>




 76 }
 77 
 78 void SATBMarkQueue::apply_closure_and_empty(SATBBufferClosure* cl) {
 79   assert(SafepointSynchronize::is_at_safepoint(),
 80          &quot;SATB queues must only be processed at safepoints&quot;);
 81   if (_buf != NULL) {
 82     cl-&gt;do_buffer(&amp;_buf[index()], size());
 83     reset();
 84   }
 85 }
 86 
 87 #ifndef PRODUCT
 88 // Helpful for debugging
 89 
 90 static void print_satb_buffer(const char* name,
 91                               void** buf,
 92                               size_t index,
 93                               size_t capacity) {
 94   tty-&gt;print_cr(&quot;  SATB BUFFER [%s] buf: &quot; PTR_FORMAT &quot; index: &quot; SIZE_FORMAT
 95                 &quot; capacity: &quot; SIZE_FORMAT,
 96                 name, p2i(buf), index, capacity);
 97 }
 98 
 99 void SATBMarkQueue::print(const char* name) {
100   print_satb_buffer(name, _buf, index(), capacity());
101 }
102 
103 #endif // PRODUCT
104 
<a name="8" id="anc8"></a><span class="line-modified">105 SATBMarkQueueSet::SATBMarkQueueSet() :</span>
<span class="line-modified">106   PtrQueueSet(),</span>



107   _buffer_enqueue_threshold(0)
108 {}
109 
<a name="9" id="anc9"></a><span class="line-modified">110 void SATBMarkQueueSet::initialize(Monitor* cbl_mon,</span>
<span class="line-modified">111                                   BufferNode::Allocator* allocator,</span>
<span class="line-modified">112                                   size_t process_completed_buffers_threshold,</span>
<span class="line-modified">113                                   uint buffer_enqueue_threshold_percentage) {</span>
<span class="line-modified">114   PtrQueueSet::initialize(cbl_mon, allocator);</span>
<span class="line-modified">115   set_process_completed_buffers_threshold(process_completed_buffers_threshold);</span>
<span class="line-modified">116   assert(buffer_size() != 0, &quot;buffer size not initialized&quot;);</span>










































117   // Minimum threshold of 1 ensures enqueuing of completely full buffers.
118   size_t size = buffer_size();
<a name="10" id="anc10"></a><span class="line-modified">119   size_t enqueue_qty = (size * buffer_enqueue_threshold_percentage) / 100;</span>
120   _buffer_enqueue_threshold = MAX2(size - enqueue_qty, (size_t)1);
121 }
122 
123 #ifdef ASSERT
124 void SATBMarkQueueSet::dump_active_states(bool expected_active) {
125   log_error(gc, verify)(&quot;Expected SATB active state: %s&quot;, expected_active ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
126   log_error(gc, verify)(&quot;Actual SATB active states:&quot;);
127   log_error(gc, verify)(&quot;  Queue set: %s&quot;, is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
128 
129   class DumpThreadStateClosure : public ThreadClosure {
130     SATBMarkQueueSet* _qset;
131   public:
132     DumpThreadStateClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
133     virtual void do_thread(Thread* t) {
134       SATBMarkQueue&amp; queue = _qset-&gt;satb_queue_for_thread(t);
135       log_error(gc, verify)(&quot;  Thread \&quot;%s\&quot; queue: %s&quot;,
136                             t-&gt;name(),
137                             queue.is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
138     }
139   } closure(this);
140   Threads::threads_do(&amp;closure);
141 }
142 
143 void SATBMarkQueueSet::verify_active_states(bool expected_active) {
144   // Verify queue set state
145   if (is_active() != expected_active) {
146     dump_active_states(expected_active);
147     fatal(&quot;SATB queue set has an unexpected active state&quot;);
148   }
149 
150   // Verify thread queue states
151   class VerifyThreadStatesClosure : public ThreadClosure {
152     SATBMarkQueueSet* _qset;
153     bool _expected_active;
154   public:
155     VerifyThreadStatesClosure(SATBMarkQueueSet* qset, bool expected_active) :
156       _qset(qset), _expected_active(expected_active) {}
157     virtual void do_thread(Thread* t) {
158       if (_qset-&gt;satb_queue_for_thread(t).is_active() != _expected_active) {
159         _qset-&gt;dump_active_states(_expected_active);
160         fatal(&quot;Thread SATB queue has an unexpected active state&quot;);
161       }
162     }
163   } closure(this, expected_active);
164   Threads::threads_do(&amp;closure);
165 }
166 #endif // ASSERT
167 
168 void SATBMarkQueueSet::set_active_all_threads(bool active, bool expected_active) {
169   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
170 #ifdef ASSERT
171   verify_active_states(expected_active);
172 #endif // ASSERT
<a name="11" id="anc11"></a><span class="line-modified">173   _all_active = active;</span>




174 
175   class SetThreadActiveClosure : public ThreadClosure {
176     SATBMarkQueueSet* _qset;
177     bool _active;
178   public:
179     SetThreadActiveClosure(SATBMarkQueueSet* qset, bool active) :
180       _qset(qset), _active(active) {}
181     virtual void do_thread(Thread* t) {
182       _qset-&gt;satb_queue_for_thread(t).set_active(_active);
183     }
184   } closure(this, active);
185   Threads::threads_do(&amp;closure);
186 }
187 
<a name="12" id="anc12"></a><span class="line-removed">188 void SATBMarkQueueSet::filter_thread_buffers() {</span>
<span class="line-removed">189   class FilterThreadBufferClosure : public ThreadClosure {</span>
<span class="line-removed">190     SATBMarkQueueSet* _qset;</span>
<span class="line-removed">191   public:</span>
<span class="line-removed">192     FilterThreadBufferClosure(SATBMarkQueueSet* qset) : _qset(qset) {}</span>
<span class="line-removed">193     virtual void do_thread(Thread* t) {</span>
<span class="line-removed">194       _qset-&gt;satb_queue_for_thread(t).filter();</span>
<span class="line-removed">195     }</span>
<span class="line-removed">196   } closure(this);</span>
<span class="line-removed">197   Threads::threads_do(&amp;closure);</span>
<span class="line-removed">198 }</span>
<span class="line-removed">199 </span>
200 bool SATBMarkQueueSet::apply_closure_to_completed_buffer(SATBBufferClosure* cl) {
201   BufferNode* nd = get_completed_buffer();
202   if (nd != NULL) {
203     void **buf = BufferNode::make_buffer_from_node(nd);
204     size_t index = nd-&gt;index();
205     size_t size = buffer_size();
206     assert(index &lt;= size, &quot;invariant&quot;);
207     cl-&gt;do_buffer(buf + index, size - index);
208     deallocate_buffer(nd);
209     return true;
210   } else {
211     return false;
212   }
213 }
214 
<a name="13" id="anc13"></a>































215 #ifndef PRODUCT
216 // Helpful for debugging
217 
218 #define SATB_PRINTER_BUFFER_SIZE 256
219 
220 void SATBMarkQueueSet::print_all(const char* msg) {
221   char buffer[SATB_PRINTER_BUFFER_SIZE];
222   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
223 
224   tty-&gt;cr();
225   tty-&gt;print_cr(&quot;SATB BUFFERS [%s]&quot;, msg);
226 
<a name="14" id="anc14"></a><span class="line-modified">227   BufferNode* nd = completed_buffers_head();</span>
228   int i = 0;
229   while (nd != NULL) {
230     void** buf = BufferNode::make_buffer_from_node(nd);
231     os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Enqueued: %d&quot;, i);
232     print_satb_buffer(buffer, buf, nd-&gt;index(), buffer_size());
233     nd = nd-&gt;next();
234     i += 1;
235   }
236 
237   class PrintThreadClosure : public ThreadClosure {
238     SATBMarkQueueSet* _qset;
239     char* _buffer;
240 
241   public:
242     PrintThreadClosure(SATBMarkQueueSet* qset, char* buffer) :
243       _qset(qset), _buffer(buffer) {}
244 
245     virtual void do_thread(Thread* t) {
246       os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Thread: %s&quot;, t-&gt;name());
247       _qset-&gt;satb_queue_for_thread(t).print(_buffer);
248     }
249   } closure(this, buffer);
250   Threads::threads_do(&amp;closure);
251 
252   tty-&gt;cr();
253 }
254 #endif // PRODUCT
255 
<a name="15" id="anc15"></a>










256 void SATBMarkQueueSet::abandon_partial_marking() {
257   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
258   abandon_completed_buffers();
259 
260   class AbandonThreadQueueClosure : public ThreadClosure {
261     SATBMarkQueueSet* _qset;
262   public:
263     AbandonThreadQueueClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
264     virtual void do_thread(Thread* t) {
265       _qset-&gt;satb_queue_for_thread(t).reset();
266     }
267   } closure(this);
268   Threads::threads_do(&amp;closure);
269 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
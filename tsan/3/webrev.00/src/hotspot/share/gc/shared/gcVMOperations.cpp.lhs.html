<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/gcVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoader.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;gc/shared/allocTracer.hpp&quot;
 29 #include &quot;gc/shared/gcId.hpp&quot;
 30 #include &quot;gc/shared/gcLocker.hpp&quot;
 31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;interpreter/oopMapCache.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;
<a name="2" id="anc2"></a>
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/init.hpp&quot;
 38 #include &quot;utilities/dtrace.hpp&quot;
 39 #include &quot;utilities/macros.hpp&quot;
 40 #include &quot;utilities/preserveException.hpp&quot;
 41 #if INCLUDE_G1GC
 42 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 43 #include &quot;gc/g1/g1Policy.hpp&quot;
 44 #endif // INCLUDE_G1GC
 45 
 46 VM_GC_Operation::~VM_GC_Operation() {
 47   CollectedHeap* ch = Universe::heap();
 48   ch-&gt;soft_ref_policy()-&gt;set_all_soft_refs_clear(false);
 49 }
 50 
 51 // The same dtrace probe can&#39;t be inserted in two different files, so we
 52 // have to call it here, so it&#39;s only in one file.  Can&#39;t create new probes
 53 // for the other file anymore.   The dtrace probes have to remain stable.
 54 void VM_GC_Operation::notify_gc_begin(bool full) {
 55   HOTSPOT_GC_BEGIN(
 56                    full);
 57   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
 58 }
 59 
 60 void VM_GC_Operation::notify_gc_end() {
 61   HOTSPOT_GC_END();
 62   HS_DTRACE_WORKAROUND_TAIL_CALL_BUG();
 63 }
 64 
 65 // Allocations may fail in several threads at about the same time,
 66 // resulting in multiple gc requests.  We only want to do one of them.
 67 // In case a GC locker is active and the need for a GC is already signaled,
 68 // we want to skip this GC attempt altogether, without doing a futile
 69 // safepoint operation.
 70 bool VM_GC_Operation::skip_operation() const {
 71   bool skip = (_gc_count_before != Universe::heap()-&gt;total_collections());
 72   if (_full &amp;&amp; skip) {
 73     skip = (_full_gc_count_before != Universe::heap()-&gt;total_full_collections());
 74   }
 75   if (!skip &amp;&amp; GCLocker::is_active_and_needs_gc()) {
 76     skip = Universe::heap()-&gt;is_maximal_no_gc();
 77     assert(!(skip &amp;&amp; (_gc_cause == GCCause::_gc_locker)),
 78            &quot;GCLocker cannot be active when initiating GC&quot;);
 79   }
 80   return skip;
 81 }
 82 
 83 bool VM_GC_Operation::doit_prologue() {
 84   assert(((_gc_cause != GCCause::_no_gc) &amp;&amp;
 85           (_gc_cause != GCCause::_no_cause_specified)), &quot;Illegal GCCause&quot;);
 86 
 87   // To be able to handle a GC the VM initialization needs to be completed.
 88   if (!is_init_completed()) {
 89     vm_exit_during_initialization(
 90       err_msg(&quot;GC triggered before VM initialization completed. Try increasing &quot;
 91               &quot;NewSize, current value &quot; SIZE_FORMAT &quot;%s.&quot;,
 92               byte_size_in_proper_unit(NewSize),
 93               proper_unit_for_byte_size(NewSize)));
 94   }
 95 
 96   // If the GC count has changed someone beat us to the collection
 97   Heap_lock-&gt;lock();
 98 
 99   // Check invocations
100   if (skip_operation()) {
101     // skip collection
102     Heap_lock-&gt;unlock();
103     _prologue_succeeded = false;
104   } else {
105     _prologue_succeeded = true;
106   }
107   return _prologue_succeeded;
108 }
109 
110 
111 void VM_GC_Operation::doit_epilogue() {
112   // Clean up old interpreter OopMap entries that were replaced
113   // during the GC thread root traversal.
114   OopMapCache::cleanup_old_entries();
115   if (Universe::has_reference_pending_list()) {
116     Heap_lock-&gt;notify_all();
117   }
118   Heap_lock-&gt;unlock();
119 }
120 
121 bool VM_GC_HeapInspection::skip_operation() const {
122   return false;
123 }
124 
125 bool VM_GC_HeapInspection::collect() {
126   if (GCLocker::is_active()) {
127     return false;
128   }
129   Universe::heap()-&gt;collect_as_vm_thread(GCCause::_heap_inspection);
130   return true;
131 }
132 
133 void VM_GC_HeapInspection::doit() {
134   HandleMark hm;
135   Universe::heap()-&gt;ensure_parsability(false); // must happen, even if collection does
136                                                // not happen (e.g. due to GCLocker)
137                                                // or _full_gc being false
138   if (_full_gc) {
139     if (!collect()) {
140       // The collection attempt was skipped because the gc locker is held.
141       // The following dump may then be a tad misleading to someone expecting
142       // only live objects to show up in the dump (see CR 6944195). Just issue
143       // a suitable warning in that case and do not attempt to do a collection.
144       // The latter is a subtle point, because even a failed attempt
145       // to GC will, in fact, induce one in the future, which we
146       // probably want to avoid in this case because the GC that we may
147       // be about to attempt holds value for us only
148       // if it happens now and not if it happens in the eventual
149       // future.
150       log_warning(gc)(&quot;GC locker is held; pre-dump GC was skipped&quot;);
151     }
152   }
<a name="3" id="anc3"></a><span class="line-modified">153   HeapInspection inspect(_csv_format, _print_help, _print_class_stats,</span>
<span class="line-removed">154                          _columns);</span>
155   inspect.heap_inspection(_out);
156 }
157 
158 
159 void VM_GenCollectForAllocation::doit() {
160   SvcGCMarker sgcm(SvcGCMarker::MINOR);
161 
162   GenCollectedHeap* gch = GenCollectedHeap::heap();
163   GCCauseSetter gccs(gch, _gc_cause);
164   _result = gch-&gt;satisfy_failed_allocation(_word_size, _tlab);
<a name="4" id="anc4"></a><span class="line-modified">165   assert(gch-&gt;is_in_reserved_or_null(_result), &quot;result not in heap&quot;);</span>
166 
167   if (_result == NULL &amp;&amp; GCLocker::is_active_and_needs_gc()) {
168     set_gc_locked();
169   }
170 }
171 
172 void VM_GenCollectFull::doit() {
173   SvcGCMarker sgcm(SvcGCMarker::FULL);
174 
175   GenCollectedHeap* gch = GenCollectedHeap::heap();
176   GCCauseSetter gccs(gch, _gc_cause);
177   gch-&gt;do_full_collection(gch-&gt;must_clear_all_soft_refs(), _max_generation);
178 }
179 
180 VM_CollectForMetadataAllocation::VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
181                                                                  size_t size,
182                                                                  Metaspace::MetadataType mdtype,
183                                                                  uint gc_count_before,
184                                                                  uint full_gc_count_before,
185                                                                  GCCause::Cause gc_cause)
186     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
187       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
188   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
189   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
190 }
191 
192 // Returns true iff concurrent GCs unloads metadata.
193 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
<a name="5" id="anc5"></a><span class="line-removed">194 #if INCLUDE_CMSGC</span>
<span class="line-removed">195   if (UseConcMarkSweepGC &amp;&amp; CMSClassUnloadingEnabled) {</span>
<span class="line-removed">196     MetaspaceGC::set_should_concurrent_collect(true);</span>
<span class="line-removed">197     return true;</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199 #endif</span>
<span class="line-removed">200 </span>
201 #if INCLUDE_G1GC
202   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
203     G1CollectedHeap* g1h = G1CollectedHeap::heap();
204     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
205 
206     GCCauseSetter x(g1h, _gc_cause);
207 
208     // At this point we are supposed to start a concurrent cycle. We
209     // will do so if one is not already in progress.
210     bool should_start = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);
211 
212     if (should_start) {
213       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
214       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
215     }
216     return true;
217   }
218 #endif
219 
220   return false;
221 }
222 
223 void VM_CollectForMetadataAllocation::doit() {
224   SvcGCMarker sgcm(SvcGCMarker::FULL);
225 
226   CollectedHeap* heap = Universe::heap();
227   GCCauseSetter gccs(heap, _gc_cause);
228 
229   // Check again if the space is available.  Another thread
230   // may have similarly failed a metadata allocation and induced
231   // a GC that freed space for the allocation.
232   if (!MetadataAllocationFailALot) {
233     _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
234     if (_result != NULL) {
235       return;
236     }
237   }
238 
239   if (initiate_concurrent_GC()) {
<a name="6" id="anc6"></a><span class="line-modified">240     // For CMS and G1 expand since the collection is going to be concurrent.</span>
241     _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
242     if (_result != NULL) {
243       return;
244     }
245 
<a name="7" id="anc7"></a><span class="line-modified">246     log_debug(gc)(&quot;%s full GC for Metaspace&quot;, UseConcMarkSweepGC ? &quot;CMS&quot; : &quot;G1&quot;);</span>
247   }
248 
249   // Don&#39;t clear the soft refs yet.
250   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_threshold);
251   // After a GC try to allocate without expanding.  Could fail
252   // and expansion will be tried below.
253   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
254   if (_result != NULL) {
255     return;
256   }
257 
258   // If still failing, allow the Metaspace to expand.
259   // See delta_capacity_until_GC() for explanation of the
260   // amount of the expansion.
261   // This should work unless there really is no more space
262   // or a MaxMetaspaceSize has been specified on the command line.
263   _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
264   if (_result != NULL) {
265     return;
266   }
267 
268   // If expansion failed, do a collection clearing soft references.
269   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_clear_soft_refs);
270   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
271   if (_result != NULL) {
272     return;
273   }
274 
275   log_debug(gc)(&quot;After Metaspace GC failed to allocate size &quot; SIZE_FORMAT, _size);
276 
277   if (GCLocker::is_active_and_needs_gc()) {
278     set_gc_locked();
279   }
280 }
281 
282 VM_CollectForAllocation::VM_CollectForAllocation(size_t word_size, uint gc_count_before, GCCause::Cause cause)
283     : VM_GC_Operation(gc_count_before, cause), _word_size(word_size), _result(NULL) {
284   // Only report if operation was really caused by an allocation.
285   if (_word_size != 0) {
286     AllocTracer::send_allocation_requiring_gc_event(_word_size * HeapWordSize, GCId::peek());
287   }
288 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/suspendibleThreadSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="strongRootsScope.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/suspendibleThreadSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46,21 +46,21 @@</span>
    return _nthreads_stopped == _nthreads;
  }
  
  void SuspendibleThreadSet::join() {
    assert(!Thread::current()-&gt;is_suspendible_thread(), &quot;Thread already joined&quot;);
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
    while (_suspend_all) {
<span class="udiff-line-modified-removed">-     ml.wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     ml.wait();</span>
    }
    _nthreads++;
    DEBUG_ONLY(Thread::current()-&gt;set_suspendible_thread();)
  }
  
  void SuspendibleThreadSet::leave() {
    assert(Thread::current()-&gt;is_suspendible_thread(), &quot;Thread not joined&quot;);
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(_nthreads &gt; 0, &quot;Invalid&quot;);
    DEBUG_ONLY(Thread::current()-&gt;clear_suspendible_thread();)
    _nthreads--;
    if (_suspend_all &amp;&amp; is_synchronized()) {
      // This leave completes a request, so inform the requestor.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,11 +68,11 @@</span>
    }
  }
  
  void SuspendibleThreadSet::yield() {
    assert(Thread::current()-&gt;is_suspendible_thread(), &quot;Must have joined&quot;);
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
    if (_suspend_all) {
      _nthreads_stopped++;
      if (is_synchronized()) {
        if (ConcGCYieldTimeout &gt; 0) {
          double now = os::elapsedTime();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80,11 +80,11 @@</span>
        }
        // This yield completes the request, so inform the requestor.
        _synchronize_wakeup-&gt;signal();
      }
      while (_suspend_all) {
<span class="udiff-line-modified-removed">-       ml.wait(Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+       ml.wait();</span>
      }
      assert(_nthreads_stopped &gt; 0, &quot;Invalid&quot;);
      _nthreads_stopped--;
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,11 +93,11 @@</span>
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Must be the VM thread&quot;);
    if (ConcGCYieldTimeout &gt; 0) {
      _suspend_all_start = os::elapsedTime();
    }
    {
<span class="udiff-line-modified-removed">-     MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
      assert(!_suspend_all, &quot;Only one at a time&quot;);
      _suspend_all = true;
      if (is_synchronized()) {
        return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,19 +116,19 @@</span>
    // synchronize call.  Hence, there is no need to re-check for
    // is_synchronized after the wait; it will always be true there.
    _synchronize_wakeup-&gt;wait();
  
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(_suspend_all, &quot;STS not synchronizing&quot;);
    assert(is_synchronized(), &quot;STS not synchronized&quot;);
  #endif
  }
  
  void SuspendibleThreadSet::desynchronize() {
    assert(Thread::current()-&gt;is_VM_thread(), &quot;Must be the VM thread&quot;);
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(_suspend_all, &quot;STS not synchronizing&quot;);
    assert(is_synchronized(), &quot;STS not synchronized&quot;);
    _suspend_all = false;
    ml.notify_all();
  }
</pre>
<center><a href="strongRootsScope.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="taskqueue.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/gcTraceSend.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 27 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 28 #include &quot;gc/shared/gcTimer.hpp&quot;
 29 #include &quot;gc/shared/gcTrace.hpp&quot;
 30 #include &quot;gc/shared/gcWhen.hpp&quot;
 31 #include &quot;jfr/jfrEvents.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 34 #if INCLUDE_G1GC</span>
<span class="line-removed"> 35 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;gc/g1/g1YCTypes.hpp&quot;</span>
<span class="line-removed"> 37 #endif</span>
 38 
 39 // All GC dependencies against the trace framework is contained within this file.
 40 
 41 typedef uintptr_t TraceAddress;
 42 
 43 void GCTracer::send_garbage_collection_event() const {
 44   EventGarbageCollection event(UNTIMED);
 45   if (event.should_commit()) {
 46     event.set_gcId(GCId::current());
 47     event.set_name(_shared_gc_info.name());
 48     event.set_cause((u2) _shared_gc_info.cause());
 49     event.set_sumOfPauses(_shared_gc_info.sum_of_pauses());
 50     event.set_longestPause(_shared_gc_info.longest_pause());
 51     event.set_starttime(_shared_gc_info.start_timestamp());
 52     event.set_endtime(_shared_gc_info.end_timestamp());
 53     event.commit();
 54   }
 55 }
 56 
 57 void GCTracer::send_reference_stats_event(ReferenceType type, size_t count) const {
 58   EventGCReferenceStatistics e;
 59   if (e.should_commit()) {
 60       e.set_gcId(GCId::current());
 61       e.set_type((u1)type);
 62       e.set_count(count);
 63       e.commit();
 64   }
 65 }
 66 
 67 void GCTracer::send_metaspace_chunk_free_list_summary(GCWhen::Type when, Metaspace::MetadataType mdtype,
 68                                                       const MetaspaceChunkFreeListSummary&amp; summary) const {
 69   EventMetaspaceChunkFreeListSummary e;
 70   if (e.should_commit()) {
 71     e.set_gcId(GCId::current());
 72     e.set_when(when);
 73     e.set_metadataType(mdtype);
 74 
 75     e.set_specializedChunks(summary.num_specialized_chunks());
 76     e.set_specializedChunksTotalSize(summary.specialized_chunks_size_in_bytes());
 77 
 78     e.set_smallChunks(summary.num_small_chunks());
 79     e.set_smallChunksTotalSize(summary.small_chunks_size_in_bytes());
 80 
 81     e.set_mediumChunks(summary.num_medium_chunks());
 82     e.set_mediumChunksTotalSize(summary.medium_chunks_size_in_bytes());
 83 
 84     e.set_humongousChunks(summary.num_humongous_chunks());
 85     e.set_humongousChunksTotalSize(summary.humongous_chunks_size_in_bytes());
 86 
 87     e.commit();
 88   }
 89 }
 90 
 91 void ParallelOldTracer::send_parallel_old_event() const {
 92   EventParallelOldGarbageCollection e(UNTIMED);
 93   if (e.should_commit()) {
 94     e.set_gcId(GCId::current());
 95     e.set_densePrefix((TraceAddress)_parallel_old_gc_info.dense_prefix());
 96     e.set_starttime(_shared_gc_info.start_timestamp());
 97     e.set_endtime(_shared_gc_info.end_timestamp());
 98     e.commit();
 99   }
100 }
101 
102 void YoungGCTracer::send_young_gc_event() const {
103   EventYoungGarbageCollection e(UNTIMED);
104   if (e.should_commit()) {
105     e.set_gcId(GCId::current());
106     e.set_tenuringThreshold(_tenuring_threshold);
107     e.set_starttime(_shared_gc_info.start_timestamp());
108     e.set_endtime(_shared_gc_info.end_timestamp());
109     e.commit();
110   }
111 }
112 
113 bool YoungGCTracer::should_send_promotion_in_new_plab_event() const {
114   return EventPromoteObjectInNewPLAB::is_enabled();
115 }
116 
117 bool YoungGCTracer::should_send_promotion_outside_plab_event() const {
118   return EventPromoteObjectOutsidePLAB::is_enabled();
119 }
120 
121 void YoungGCTracer::send_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
122                                                      uint age, bool tenured,
123                                                      size_t plab_size) const {
124 
125   EventPromoteObjectInNewPLAB event;
126   if (event.should_commit()) {
127     event.set_gcId(GCId::current());
128     event.set_objectClass(klass);
129     event.set_objectSize(obj_size);
130     event.set_tenured(tenured);
131     event.set_tenuringAge(age);
132     event.set_plabSize(plab_size);
133     event.commit();
134   }
135 }
136 
137 void YoungGCTracer::send_promotion_outside_plab_event(Klass* klass, size_t obj_size,
138                                                       uint age, bool tenured) const {
139 
140   EventPromoteObjectOutsidePLAB event;
141   if (event.should_commit()) {
142     event.set_gcId(GCId::current());
143     event.set_objectClass(klass);
144     event.set_objectSize(obj_size);
145     event.set_tenured(tenured);
146     event.set_tenuringAge(age);
147     event.commit();
148   }
149 }
150 
151 void OldGCTracer::send_old_gc_event() const {
152   EventOldGarbageCollection e(UNTIMED);
153   if (e.should_commit()) {
154     e.set_gcId(GCId::current());
155     e.set_starttime(_shared_gc_info.start_timestamp());
156     e.set_endtime(_shared_gc_info.end_timestamp());
157     e.commit();
158   }
159 }
160 
161 static JfrStructCopyFailed to_struct(const CopyFailedInfo&amp; cf_info) {
162   JfrStructCopyFailed failed_info;
163   failed_info.set_objectCount(cf_info.failed_count());
164   failed_info.set_firstSize(cf_info.first_size());
165   failed_info.set_smallestSize(cf_info.smallest_size());
166   failed_info.set_totalSize(cf_info.total_size());
167   return failed_info;
168 }
169 
170 void YoungGCTracer::send_promotion_failed_event(const PromotionFailedInfo&amp; pf_info) const {
171   EventPromotionFailed e;
172   if (e.should_commit()) {
173     e.set_gcId(GCId::current());
174     e.set_promotionFailed(to_struct(pf_info));
175     e.set_thread(pf_info.thread_trace_id());
176     e.commit();
177   }
178 }
179 
<a name="3" id="anc3"></a><span class="line-modified">180 // Common to CMS and G1</span>
181 void OldGCTracer::send_concurrent_mode_failure_event() {
182   EventConcurrentModeFailure e;
183   if (e.should_commit()) {
184     e.set_gcId(GCId::current());
185     e.commit();
186   }
187 }
188 
<a name="4" id="anc4"></a><span class="line-removed">189 #if INCLUDE_G1GC</span>
<span class="line-removed">190 void G1NewTracer::send_g1_young_gc_event() {</span>
<span class="line-removed">191   EventG1GarbageCollection e(UNTIMED);</span>
<span class="line-removed">192   if (e.should_commit()) {</span>
<span class="line-removed">193     e.set_gcId(GCId::current());</span>
<span class="line-removed">194     e.set_type(_g1_young_gc_info.type());</span>
<span class="line-removed">195     e.set_starttime(_shared_gc_info.start_timestamp());</span>
<span class="line-removed">196     e.set_endtime(_shared_gc_info.end_timestamp());</span>
<span class="line-removed">197     e.commit();</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199 }</span>
<span class="line-removed">200 </span>
<span class="line-removed">201 void G1MMUTracer::send_g1_mmu_event(double time_slice_ms, double gc_time_ms, double max_time_ms) {</span>
<span class="line-removed">202   EventG1MMU e;</span>
<span class="line-removed">203   if (e.should_commit()) {</span>
<span class="line-removed">204     e.set_gcId(GCId::current());</span>
<span class="line-removed">205     e.set_timeSlice(time_slice_ms);</span>
<span class="line-removed">206     e.set_gcTime(gc_time_ms);</span>
<span class="line-removed">207     e.set_pauseTarget(max_time_ms);</span>
<span class="line-removed">208     e.commit();</span>
<span class="line-removed">209   }</span>
<span class="line-removed">210 }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212 void G1NewTracer::send_evacuation_info_event(G1EvacuationInfo* info) {</span>
<span class="line-removed">213   EventEvacuationInformation e;</span>
<span class="line-removed">214   if (e.should_commit()) {</span>
<span class="line-removed">215     e.set_gcId(GCId::current());</span>
<span class="line-removed">216     e.set_cSetRegions(info-&gt;collectionset_regions());</span>
<span class="line-removed">217     e.set_cSetUsedBefore(info-&gt;collectionset_used_before());</span>
<span class="line-removed">218     e.set_cSetUsedAfter(info-&gt;collectionset_used_after());</span>
<span class="line-removed">219     e.set_allocationRegions(info-&gt;allocation_regions());</span>
<span class="line-removed">220     e.set_allocationRegionsUsedBefore(info-&gt;alloc_regions_used_before());</span>
<span class="line-removed">221     e.set_allocationRegionsUsedAfter(info-&gt;alloc_regions_used_before() + info-&gt;bytes_copied());</span>
<span class="line-removed">222     e.set_bytesCopied(info-&gt;bytes_copied());</span>
<span class="line-removed">223     e.set_regionsFreed(info-&gt;regions_freed());</span>
<span class="line-removed">224     e.commit();</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226 }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228 void G1NewTracer::send_evacuation_failed_event(const EvacuationFailedInfo&amp; ef_info) const {</span>
<span class="line-removed">229   EventEvacuationFailed e;</span>
<span class="line-removed">230   if (e.should_commit()) {</span>
<span class="line-removed">231     e.set_gcId(GCId::current());</span>
<span class="line-removed">232     e.set_evacuationFailed(to_struct(ef_info));</span>
<span class="line-removed">233     e.commit();</span>
<span class="line-removed">234   }</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 static JfrStructG1EvacuationStatistics</span>
<span class="line-removed">238 create_g1_evacstats(unsigned gcid, const G1EvacSummary&amp; summary) {</span>
<span class="line-removed">239   JfrStructG1EvacuationStatistics s;</span>
<span class="line-removed">240   s.set_gcId(gcid);</span>
<span class="line-removed">241   s.set_allocated(summary.allocated() * HeapWordSize);</span>
<span class="line-removed">242   s.set_wasted(summary.wasted() * HeapWordSize);</span>
<span class="line-removed">243   s.set_used(summary.used() * HeapWordSize);</span>
<span class="line-removed">244   s.set_undoWaste(summary.undo_wasted() * HeapWordSize);</span>
<span class="line-removed">245   s.set_regionEndWaste(summary.region_end_waste() * HeapWordSize);</span>
<span class="line-removed">246   s.set_regionsRefilled(summary.regions_filled());</span>
<span class="line-removed">247   s.set_directAllocated(summary.direct_allocated() * HeapWordSize);</span>
<span class="line-removed">248   s.set_failureUsed(summary.failure_used() * HeapWordSize);</span>
<span class="line-removed">249   s.set_failureWaste(summary.failure_waste() * HeapWordSize);</span>
<span class="line-removed">250   return s;</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 void G1NewTracer::send_young_evacuation_statistics(const G1EvacSummary&amp; summary) const {</span>
<span class="line-removed">254   EventG1EvacuationYoungStatistics surv_evt;</span>
<span class="line-removed">255   if (surv_evt.should_commit()) {</span>
<span class="line-removed">256     surv_evt.set_statistics(create_g1_evacstats(GCId::current(), summary));</span>
<span class="line-removed">257     surv_evt.commit();</span>
<span class="line-removed">258   }</span>
<span class="line-removed">259 }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261 void G1NewTracer::send_old_evacuation_statistics(const G1EvacSummary&amp; summary) const {</span>
<span class="line-removed">262   EventG1EvacuationOldStatistics old_evt;</span>
<span class="line-removed">263   if (old_evt.should_commit()) {</span>
<span class="line-removed">264     old_evt.set_statistics(create_g1_evacstats(GCId::current(), summary));</span>
<span class="line-removed">265     old_evt.commit();</span>
<span class="line-removed">266   }</span>
<span class="line-removed">267 }</span>
<span class="line-removed">268 </span>
<span class="line-removed">269 void G1NewTracer::send_basic_ihop_statistics(size_t threshold,</span>
<span class="line-removed">270                                              size_t target_occupancy,</span>
<span class="line-removed">271                                              size_t current_occupancy,</span>
<span class="line-removed">272                                              size_t last_allocation_size,</span>
<span class="line-removed">273                                              double last_allocation_duration,</span>
<span class="line-removed">274                                              double last_marking_length) {</span>
<span class="line-removed">275   EventG1BasicIHOP evt;</span>
<span class="line-removed">276   if (evt.should_commit()) {</span>
<span class="line-removed">277     evt.set_gcId(GCId::current());</span>
<span class="line-removed">278     evt.set_threshold(threshold);</span>
<span class="line-removed">279     evt.set_targetOccupancy(target_occupancy);</span>
<span class="line-removed">280     evt.set_thresholdPercentage(target_occupancy &gt; 0 ? ((double)threshold / target_occupancy) : 0.0);</span>
<span class="line-removed">281     evt.set_currentOccupancy(current_occupancy);</span>
<span class="line-removed">282     evt.set_recentMutatorAllocationSize(last_allocation_size);</span>
<span class="line-removed">283     evt.set_recentMutatorDuration(last_allocation_duration * MILLIUNITS);</span>
<span class="line-removed">284     evt.set_recentAllocationRate(last_allocation_duration != 0.0 ? last_allocation_size / last_allocation_duration : 0.0);</span>
<span class="line-removed">285     evt.set_lastMarkingDuration(last_marking_length * MILLIUNITS);</span>
<span class="line-removed">286     evt.commit();</span>
<span class="line-removed">287   }</span>
<span class="line-removed">288 }</span>
<span class="line-removed">289 </span>
<span class="line-removed">290 void G1NewTracer::send_adaptive_ihop_statistics(size_t threshold,</span>
<span class="line-removed">291                                                 size_t internal_target_occupancy,</span>
<span class="line-removed">292                                                 size_t current_occupancy,</span>
<span class="line-removed">293                                                 size_t additional_buffer_size,</span>
<span class="line-removed">294                                                 double predicted_allocation_rate,</span>
<span class="line-removed">295                                                 double predicted_marking_length,</span>
<span class="line-removed">296                                                 bool prediction_active) {</span>
<span class="line-removed">297   EventG1AdaptiveIHOP evt;</span>
<span class="line-removed">298   if (evt.should_commit()) {</span>
<span class="line-removed">299     evt.set_gcId(GCId::current());</span>
<span class="line-removed">300     evt.set_threshold(threshold);</span>
<span class="line-removed">301     evt.set_thresholdPercentage(internal_target_occupancy &gt; 0 ? ((double)threshold / internal_target_occupancy) : 0.0);</span>
<span class="line-removed">302     evt.set_ihopTargetOccupancy(internal_target_occupancy);</span>
<span class="line-removed">303     evt.set_currentOccupancy(current_occupancy);</span>
<span class="line-removed">304     evt.set_additionalBufferSize(additional_buffer_size);</span>
<span class="line-removed">305     evt.set_predictedAllocationRate(predicted_allocation_rate);</span>
<span class="line-removed">306     evt.set_predictedMarkingDuration(predicted_marking_length * MILLIUNITS);</span>
<span class="line-removed">307     evt.set_predictionActive(prediction_active);</span>
<span class="line-removed">308     evt.commit();</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310 }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312 #endif // INCLUDE_G1GC</span>
<span class="line-removed">313 </span>
314 static JfrStructVirtualSpace to_struct(const VirtualSpaceSummary&amp; summary) {
315   JfrStructVirtualSpace space;
316   space.set_start((TraceAddress)summary.start());
317   space.set_committedEnd((TraceAddress)summary.committed_end());
318   space.set_committedSize(summary.committed_size());
319   space.set_reservedEnd((TraceAddress)summary.reserved_end());
320   space.set_reservedSize(summary.reserved_size());
321   return space;
322 }
323 
324 static JfrStructObjectSpace to_struct(const SpaceSummary&amp; summary) {
325   JfrStructObjectSpace space;
326   space.set_start((TraceAddress)summary.start());
327   space.set_end((TraceAddress)summary.end());
328   space.set_used(summary.used());
329   space.set_size(summary.size());
330   return space;
331 }
332 
333 class GCHeapSummaryEventSender : public GCHeapSummaryVisitor {
334   GCWhen::Type _when;
335  public:
336   GCHeapSummaryEventSender(GCWhen::Type when) : _when(when) {}
337 
338   void visit(const GCHeapSummary* heap_summary) const {
339     const VirtualSpaceSummary&amp; heap_space = heap_summary-&gt;heap();
340 
341     EventGCHeapSummary e;
342     if (e.should_commit()) {
343       e.set_gcId(GCId::current());
344       e.set_when((u1)_when);
345       e.set_heapSpace(to_struct(heap_space));
346       e.set_heapUsed(heap_summary-&gt;used());
347       e.commit();
348     }
349   }
350 
351   void visit(const G1HeapSummary* g1_heap_summary) const {
352     visit((GCHeapSummary*)g1_heap_summary);
353 
354     EventG1HeapSummary e;
355     if (e.should_commit()) {
356       e.set_gcId(GCId::current());
357       e.set_when((u1)_when);
358       e.set_edenUsedSize(g1_heap_summary-&gt;edenUsed());
359       e.set_edenTotalSize(g1_heap_summary-&gt;edenCapacity());
360       e.set_survivorUsedSize(g1_heap_summary-&gt;survivorUsed());
361       e.set_numberOfRegions(g1_heap_summary-&gt;numberOfRegions());
362       e.commit();
363     }
364   }
365 
366   void visit(const PSHeapSummary* ps_heap_summary) const {
367     visit((GCHeapSummary*)ps_heap_summary);
368 
369     const VirtualSpaceSummary&amp; old_summary = ps_heap_summary-&gt;old();
370     const SpaceSummary&amp; old_space = ps_heap_summary-&gt;old_space();
371     const VirtualSpaceSummary&amp; young_summary = ps_heap_summary-&gt;young();
372     const SpaceSummary&amp; eden_space = ps_heap_summary-&gt;eden();
373     const SpaceSummary&amp; from_space = ps_heap_summary-&gt;from();
374     const SpaceSummary&amp; to_space = ps_heap_summary-&gt;to();
375 
376     EventPSHeapSummary e;
377     if (e.should_commit()) {
378       e.set_gcId(GCId::current());
379       e.set_when((u1)_when);
380 
381       e.set_oldSpace(to_struct(ps_heap_summary-&gt;old()));
382       e.set_oldObjectSpace(to_struct(ps_heap_summary-&gt;old_space()));
383       e.set_youngSpace(to_struct(ps_heap_summary-&gt;young()));
384       e.set_edenSpace(to_struct(ps_heap_summary-&gt;eden()));
385       e.set_fromSpace(to_struct(ps_heap_summary-&gt;from()));
386       e.set_toSpace(to_struct(ps_heap_summary-&gt;to()));
387       e.commit();
388     }
389   }
390 };
391 
392 void GCTracer::send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const {
393   GCHeapSummaryEventSender visitor(when);
394   heap_summary.accept(&amp;visitor);
395 }
396 
397 static JfrStructMetaspaceSizes to_struct(const MetaspaceSizes&amp; sizes) {
398   JfrStructMetaspaceSizes meta_sizes;
399 
400   meta_sizes.set_committed(sizes.committed());
401   meta_sizes.set_used(sizes.used());
402   meta_sizes.set_reserved(sizes.reserved());
403 
404   return meta_sizes;
405 }
406 
407 void GCTracer::send_meta_space_summary_event(GCWhen::Type when, const MetaspaceSummary&amp; meta_space_summary) const {
408   EventMetaspaceSummary e;
409   if (e.should_commit()) {
410     e.set_gcId(GCId::current());
411     e.set_when((u1) when);
412     e.set_gcThreshold(meta_space_summary.capacity_until_GC());
413     e.set_metaspace(to_struct(meta_space_summary.meta_space()));
414     e.set_dataSpace(to_struct(meta_space_summary.data_space()));
415     e.set_classSpace(to_struct(meta_space_summary.class_space()));
416     e.commit();
417   }
418 }
419 
420 class PhaseSender : public PhaseVisitor {
421   void visit_pause(GCPhase* phase) {
422     assert(phase-&gt;level() &lt; PhasesStack::PHASE_LEVELS, &quot;Need more event types for PausePhase&quot;);
423 
424     switch (phase-&gt;level()) {
425       case 0: send_phase&lt;EventGCPhasePause&gt;(phase); break;
426       case 1: send_phase&lt;EventGCPhasePauseLevel1&gt;(phase); break;
427       case 2: send_phase&lt;EventGCPhasePauseLevel2&gt;(phase); break;
428       case 3: send_phase&lt;EventGCPhasePauseLevel3&gt;(phase); break;
429       case 4: send_phase&lt;EventGCPhasePauseLevel4&gt;(phase); break;
430       default: /* Ignore sending this phase */ break;
431     }
432   }
433 
434   void visit_concurrent(GCPhase* phase) {
435     assert(phase-&gt;level() &lt; 1, &quot;There is only one level for ConcurrentPhase&quot;);
436 
437     switch (phase-&gt;level()) {
438       case 0: send_phase&lt;EventGCPhaseConcurrent&gt;(phase); break;
439       default: /* Ignore sending this phase */ break;
440     }
441   }
442 
443  public:
444   template&lt;typename T&gt;
445   void send_phase(GCPhase* phase) {
446     T event(UNTIMED);
447     if (event.should_commit()) {
448       event.set_gcId(GCId::current());
449       event.set_name(phase-&gt;name());
450       event.set_starttime(phase-&gt;start());
451       event.set_endtime(phase-&gt;end());
452       event.commit();
453     }
454   }
455 
456   void visit(GCPhase* phase) {
457     if (phase-&gt;type() == GCPhase::PausePhaseType) {
458       visit_pause(phase);
459     } else {
460       assert(phase-&gt;type() == GCPhase::ConcurrentPhaseType, &quot;Should be ConcurrentPhaseType&quot;);
461       visit_concurrent(phase);
462     }
463   }
464 };
465 
466 void GCTracer::send_phase_events(TimePartitions* time_partitions) const {
467   PhaseSender phase_reporter;
468 
469   TimePartitionPhasesIterator iter(time_partitions);
470   while (iter.has_next()) {
471     GCPhase* phase = iter.next();
472     phase-&gt;accept(&amp;phase_reporter);
473   }
474 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
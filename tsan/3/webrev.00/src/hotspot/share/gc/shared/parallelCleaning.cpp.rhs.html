<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/parallelCleaning.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/stringTable.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/parallelCleaning.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;runtime/atomic.hpp&quot;</span>
 34 
 35 StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,
 36                                                  OopClosure* keep_alive,
 37                                                  bool resize_table) :
 38   AbstractGangTask(&quot;String Dedup Cleaning&quot;),
 39   _dedup_closure(is_alive, keep_alive) {
 40 
 41   if (StringDedup::is_enabled()) {
 42     StringDedup::gc_prologue(resize_table);
 43   }
 44 }
 45 
 46 StringDedupCleaningTask::~StringDedupCleaningTask() {
 47   if (StringDedup::is_enabled()) {
 48     StringDedup::gc_epilogue();
 49   }
 50 }
 51 
 52 void StringDedupCleaningTask::work(uint worker_id) {
 53   if (StringDedup::is_enabled()) {
 54     StringDedup::parallel_unlink(&amp;_dedup_closure, worker_id);
 55   }
 56 }
 57 
 58 CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred) :
 59   _unloading_scope(is_alive),
 60   _unloading_occurred(unloading_occurred),
 61   _num_workers(num_workers),
 62   _first_nmethod(NULL),
 63   _claimed_nmethod(NULL) {
 64   // Get first alive nmethod
 65   CompiledMethodIterator iter(CompiledMethodIterator::only_alive);
 66   if(iter.next()) {
 67     _first_nmethod = iter.method();
 68   }
 69   _claimed_nmethod = _first_nmethod;
 70 }
 71 
 72 CodeCacheUnloadingTask::~CodeCacheUnloadingTask() {
 73   CodeCache::verify_clean_inline_caches();
 74   CodeCache::verify_icholder_relocations();
 75 }
 76 
 77 void CodeCacheUnloadingTask::claim_nmethods(CompiledMethod** claimed_nmethods, int *num_claimed_nmethods) {
 78   CompiledMethod* first;
 79   CompiledMethodIterator last(CompiledMethodIterator::only_alive);
 80 
 81   do {
 82     *num_claimed_nmethods = 0;
 83 
 84     first = _claimed_nmethod;
 85     last = CompiledMethodIterator(CompiledMethodIterator::only_alive, first);
 86 
 87     if (first != NULL) {
 88 
 89       for (int i = 0; i &lt; MaxClaimNmethods; i++) {
 90         if (!last.next()) {
 91           break;
 92         }
 93         claimed_nmethods[i] = last.method();
 94         (*num_claimed_nmethods)++;
 95       }
 96     }
 97 
<a name="2" id="anc2"></a><span class="line-modified"> 98   } while (Atomic::cmpxchg(&amp;_claimed_nmethod, first, last.method()) != first);</span>
 99 }
100 
101 void CodeCacheUnloadingTask::work(uint worker_id) {
102   // The first nmethods is claimed by the first worker.
103   if (worker_id == 0 &amp;&amp; _first_nmethod != NULL) {
104     _first_nmethod-&gt;do_unloading(_unloading_occurred);
105     _first_nmethod = NULL;
106   }
107 
108   int num_claimed_nmethods;
109   CompiledMethod* claimed_nmethods[MaxClaimNmethods];
110 
111   while (true) {
112     claim_nmethods(claimed_nmethods, &amp;num_claimed_nmethods);
113 
114     if (num_claimed_nmethods == 0) {
115       break;
116     }
117 
118     for (int i = 0; i &lt; num_claimed_nmethods; i++) {
119       claimed_nmethods[i]-&gt;do_unloading(_unloading_occurred);
120     }
121   }
122 }
123 
124 KlassCleaningTask::KlassCleaningTask() :
125   _clean_klass_tree_claimed(0),
126   _klass_iterator() {
127 }
128 
129 bool KlassCleaningTask::claim_clean_klass_tree_task() {
130   if (_clean_klass_tree_claimed) {
131     return false;
132   }
133 
<a name="3" id="anc3"></a><span class="line-modified">134   return Atomic::cmpxchg(&amp;_clean_klass_tree_claimed, 0, 1) == 0;</span>
135 }
136 
137 InstanceKlass* KlassCleaningTask::claim_next_klass() {
138   Klass* klass;
139   do {
140     klass =_klass_iterator.next_klass();
141   } while (klass != NULL &amp;&amp; !klass-&gt;is_instance_klass());
142 
143   // this can be null so don&#39;t call InstanceKlass::cast
144   return static_cast&lt;InstanceKlass*&gt;(klass);
145 }
146 
147 void KlassCleaningTask::work() {
148   ResourceMark rm;
149 
150   // One worker will clean the subklass/sibling klass tree.
151   if (claim_clean_klass_tree_task()) {
152     Klass::clean_subklass_tree();
153   }
154 
155   // All workers will help cleaning the classes,
156   InstanceKlass* klass;
157   while ((klass = claim_next_klass()) != NULL) {
158     clean_klass(klass);
159   }
160 }
<a name="4" id="anc4"></a>


























<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
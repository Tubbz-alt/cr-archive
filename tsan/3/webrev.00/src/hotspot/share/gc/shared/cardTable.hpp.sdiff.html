<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/cardTable.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cardTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardTable.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 86   // Returns the leftmost end of a committed region corresponding to a
 87   // covered region before covered region &quot;ind&quot;, or else &quot;NULL&quot; if &quot;ind&quot; is
 88   // the first covered region.
 89   HeapWord* largest_prev_committed_end(int ind) const;
 90 
 91   // Returns the part of the region mr that doesn&#39;t intersect with
 92   // any committed region other than self.  Used to prevent uncommitting
 93   // regions that are also committed by other regions.  Also protects
 94   // against uncommitting the guard region.
 95   MemRegion committed_unique_to_self(int self, MemRegion mr) const;
 96 
 97   // Some barrier sets create tables whose elements correspond to parts of
 98   // the heap; the CardTableBarrierSet is an example.  Such barrier sets will
 99   // normally reserve space for such tables, and commit parts of the table
100   // &quot;covering&quot; parts of the heap that are committed. At most one covered
101   // region per generation is needed.
102   static const int _max_covered_regions = 2;
103 
104   enum CardValues {
105     clean_card                  = (CardValue)-1,
<span class="line-removed">106     // The mask contains zeros in places for all other values.</span>
<span class="line-removed">107     clean_card_mask             = clean_card - 31,</span>
108 
109     dirty_card                  =  0,
110     precleaned_card             =  1,
<span class="line-modified">111     claimed_card                =  2,</span>
<span class="line-modified">112     deferred_card               =  4,</span>
<span class="line-removed">113     last_card                   =  8,</span>
<span class="line-removed">114     CT_MR_BS_last_reserved      = 16</span>
115   };
116 
117   // a word&#39;s worth (row) of clean card values
118   static const intptr_t clean_card_row = (intptr_t)(-1);
119 
120 public:
121   CardTable(MemRegion whole_heap, bool conc_scan);
122   virtual ~CardTable();
123   virtual void initialize();
124 
125   // The kinds of precision a CardTable may offer.
126   enum PrecisionStyle {
127     Precise,
128     ObjHeadPreciseArray
129   };
130 
131   // Tells what style of precision this card table offers.
132   PrecisionStyle precision() {
133     return ObjHeadPreciseArray; // Only one supported for now.
134   }
</pre>
<hr />
<pre>
225 
226   // Apply closure &quot;cl&quot; to the dirty cards containing some part of
227   // MemRegion &quot;mr&quot;.
228   void dirty_card_iterate(MemRegion mr, MemRegionClosure* cl);
229 
230   // Return the MemRegion corresponding to the first maximal run
231   // of dirty cards lying completely within MemRegion mr.
232   // If reset is &quot;true&quot;, then sets those card table entries to the given
233   // value.
234   MemRegion dirty_card_range_after_reset(MemRegion mr, bool reset,
235                                          int reset_val);
236 
237   // Constants
238   enum SomePublicConstants {
239     card_shift                  = 9,
240     card_size                   = 1 &lt;&lt; card_shift,
241     card_size_in_words          = card_size / sizeof(HeapWord)
242   };
243 
244   static CardValue clean_card_val()          { return clean_card; }
<span class="line-removed">245   static CardValue clean_card_mask_val()     { return clean_card_mask; }</span>
246   static CardValue dirty_card_val()          { return dirty_card; }
<span class="line-removed">247   static CardValue claimed_card_val()        { return claimed_card; }</span>
248   static CardValue precleaned_card_val()     { return precleaned_card; }
<span class="line-removed">249   static CardValue deferred_card_val()       { return deferred_card; }</span>
250   static intptr_t clean_card_row_val()   { return clean_card_row; }
251 
252   // Card marking array base (adjusted for heap low boundary)
253   // This would be the 0th element of _byte_map, if the heap started at 0x0.
254   // But since the heap starts at some higher address, this points to somewhere
255   // before the beginning of the actual _byte_map.
256   CardValue* byte_map_base() const { return _byte_map_base; }
257   bool scanned_concurrently() const { return _scanned_concurrently; }
258 
259   virtual bool is_in_young(oop obj) const = 0;
260 
261   // Print a description of the memory for the card table
262   virtual void print_on(outputStream* st) const;
263 
264   void verify();
265   void verify_guard();
266 
267   // val_equals -&gt; it will check that all cards covered by mr equal val
268   // !val_equals -&gt; it will check that all cards covered by mr do not equal val
269   void verify_region(MemRegion mr, CardValue val, bool val_equals) PRODUCT_RETURN;
</pre>
</td>
<td>
<hr />
<pre>
 86   // Returns the leftmost end of a committed region corresponding to a
 87   // covered region before covered region &quot;ind&quot;, or else &quot;NULL&quot; if &quot;ind&quot; is
 88   // the first covered region.
 89   HeapWord* largest_prev_committed_end(int ind) const;
 90 
 91   // Returns the part of the region mr that doesn&#39;t intersect with
 92   // any committed region other than self.  Used to prevent uncommitting
 93   // regions that are also committed by other regions.  Also protects
 94   // against uncommitting the guard region.
 95   MemRegion committed_unique_to_self(int self, MemRegion mr) const;
 96 
 97   // Some barrier sets create tables whose elements correspond to parts of
 98   // the heap; the CardTableBarrierSet is an example.  Such barrier sets will
 99   // normally reserve space for such tables, and commit parts of the table
100   // &quot;covering&quot; parts of the heap that are committed. At most one covered
101   // region per generation is needed.
102   static const int _max_covered_regions = 2;
103 
104   enum CardValues {
105     clean_card                  = (CardValue)-1,


106 
107     dirty_card                  =  0,
108     precleaned_card             =  1,
<span class="line-modified">109     last_card                   =  2,</span>
<span class="line-modified">110     CT_MR_BS_last_reserved      =  4</span>


111   };
112 
113   // a word&#39;s worth (row) of clean card values
114   static const intptr_t clean_card_row = (intptr_t)(-1);
115 
116 public:
117   CardTable(MemRegion whole_heap, bool conc_scan);
118   virtual ~CardTable();
119   virtual void initialize();
120 
121   // The kinds of precision a CardTable may offer.
122   enum PrecisionStyle {
123     Precise,
124     ObjHeadPreciseArray
125   };
126 
127   // Tells what style of precision this card table offers.
128   PrecisionStyle precision() {
129     return ObjHeadPreciseArray; // Only one supported for now.
130   }
</pre>
<hr />
<pre>
221 
222   // Apply closure &quot;cl&quot; to the dirty cards containing some part of
223   // MemRegion &quot;mr&quot;.
224   void dirty_card_iterate(MemRegion mr, MemRegionClosure* cl);
225 
226   // Return the MemRegion corresponding to the first maximal run
227   // of dirty cards lying completely within MemRegion mr.
228   // If reset is &quot;true&quot;, then sets those card table entries to the given
229   // value.
230   MemRegion dirty_card_range_after_reset(MemRegion mr, bool reset,
231                                          int reset_val);
232 
233   // Constants
234   enum SomePublicConstants {
235     card_shift                  = 9,
236     card_size                   = 1 &lt;&lt; card_shift,
237     card_size_in_words          = card_size / sizeof(HeapWord)
238   };
239 
240   static CardValue clean_card_val()          { return clean_card; }

241   static CardValue dirty_card_val()          { return dirty_card; }

242   static CardValue precleaned_card_val()     { return precleaned_card; }

243   static intptr_t clean_card_row_val()   { return clean_card_row; }
244 
245   // Card marking array base (adjusted for heap low boundary)
246   // This would be the 0th element of _byte_map, if the heap started at 0x0.
247   // But since the heap starts at some higher address, this points to somewhere
248   // before the beginning of the actual _byte_map.
249   CardValue* byte_map_base() const { return _byte_map_base; }
250   bool scanned_concurrently() const { return _scanned_concurrently; }
251 
252   virtual bool is_in_young(oop obj) const = 0;
253 
254   // Print a description of the memory for the card table
255   virtual void print_on(outputStream* st) const;
256 
257   void verify();
258   void verify_guard();
259 
260   // val_equals -&gt; it will check that all cards covered by mr equal val
261   // !val_equals -&gt; it will check that all cards covered by mr do not equal val
262   void verify_region(MemRegion mr, CardValue val, bool val_equals) PRODUCT_RETURN;
</pre>
</td>
</tr>
</table>
<center><a href="cardTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcTraceSend.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcVMOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoader.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;gc/shared/allocTracer.hpp&quot;
 29 #include &quot;gc/shared/gcId.hpp&quot;
 30 #include &quot;gc/shared/gcLocker.hpp&quot;
 31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;interpreter/oopMapCache.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;

 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/init.hpp&quot;
 38 #include &quot;utilities/dtrace.hpp&quot;
 39 #include &quot;utilities/macros.hpp&quot;
 40 #include &quot;utilities/preserveException.hpp&quot;
 41 #if INCLUDE_G1GC
 42 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 43 #include &quot;gc/g1/g1Policy.hpp&quot;
 44 #endif // INCLUDE_G1GC
 45 
 46 VM_GC_Operation::~VM_GC_Operation() {
 47   CollectedHeap* ch = Universe::heap();
 48   ch-&gt;soft_ref_policy()-&gt;set_all_soft_refs_clear(false);
 49 }
 50 
 51 // The same dtrace probe can&#39;t be inserted in two different files, so we
 52 // have to call it here, so it&#39;s only in one file.  Can&#39;t create new probes
 53 // for the other file anymore.   The dtrace probes have to remain stable.
 54 void VM_GC_Operation::notify_gc_begin(bool full) {
 55   HOTSPOT_GC_BEGIN(
</pre>
<hr />
<pre>
133 void VM_GC_HeapInspection::doit() {
134   HandleMark hm;
135   Universe::heap()-&gt;ensure_parsability(false); // must happen, even if collection does
136                                                // not happen (e.g. due to GCLocker)
137                                                // or _full_gc being false
138   if (_full_gc) {
139     if (!collect()) {
140       // The collection attempt was skipped because the gc locker is held.
141       // The following dump may then be a tad misleading to someone expecting
142       // only live objects to show up in the dump (see CR 6944195). Just issue
143       // a suitable warning in that case and do not attempt to do a collection.
144       // The latter is a subtle point, because even a failed attempt
145       // to GC will, in fact, induce one in the future, which we
146       // probably want to avoid in this case because the GC that we may
147       // be about to attempt holds value for us only
148       // if it happens now and not if it happens in the eventual
149       // future.
150       log_warning(gc)(&quot;GC locker is held; pre-dump GC was skipped&quot;);
151     }
152   }
<span class="line-modified">153   HeapInspection inspect(_csv_format, _print_help, _print_class_stats,</span>
<span class="line-removed">154                          _columns);</span>
155   inspect.heap_inspection(_out);
156 }
157 
158 
159 void VM_GenCollectForAllocation::doit() {
160   SvcGCMarker sgcm(SvcGCMarker::MINOR);
161 
162   GenCollectedHeap* gch = GenCollectedHeap::heap();
163   GCCauseSetter gccs(gch, _gc_cause);
164   _result = gch-&gt;satisfy_failed_allocation(_word_size, _tlab);
<span class="line-modified">165   assert(gch-&gt;is_in_reserved_or_null(_result), &quot;result not in heap&quot;);</span>
166 
167   if (_result == NULL &amp;&amp; GCLocker::is_active_and_needs_gc()) {
168     set_gc_locked();
169   }
170 }
171 
172 void VM_GenCollectFull::doit() {
173   SvcGCMarker sgcm(SvcGCMarker::FULL);
174 
175   GenCollectedHeap* gch = GenCollectedHeap::heap();
176   GCCauseSetter gccs(gch, _gc_cause);
177   gch-&gt;do_full_collection(gch-&gt;must_clear_all_soft_refs(), _max_generation);
178 }
179 
180 VM_CollectForMetadataAllocation::VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
181                                                                  size_t size,
182                                                                  Metaspace::MetadataType mdtype,
183                                                                  uint gc_count_before,
184                                                                  uint full_gc_count_before,
185                                                                  GCCause::Cause gc_cause)
186     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
187       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
188   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
189   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
190 }
191 
192 // Returns true iff concurrent GCs unloads metadata.
193 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
<span class="line-removed">194 #if INCLUDE_CMSGC</span>
<span class="line-removed">195   if (UseConcMarkSweepGC &amp;&amp; CMSClassUnloadingEnabled) {</span>
<span class="line-removed">196     MetaspaceGC::set_should_concurrent_collect(true);</span>
<span class="line-removed">197     return true;</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199 #endif</span>
<span class="line-removed">200 </span>
201 #if INCLUDE_G1GC
202   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
203     G1CollectedHeap* g1h = G1CollectedHeap::heap();
204     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
205 
206     GCCauseSetter x(g1h, _gc_cause);
207 
208     // At this point we are supposed to start a concurrent cycle. We
209     // will do so if one is not already in progress.
210     bool should_start = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);
211 
212     if (should_start) {
213       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
214       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
215     }
216     return true;
217   }
218 #endif
219 
220   return false;
221 }
222 
223 void VM_CollectForMetadataAllocation::doit() {
224   SvcGCMarker sgcm(SvcGCMarker::FULL);
225 
226   CollectedHeap* heap = Universe::heap();
227   GCCauseSetter gccs(heap, _gc_cause);
228 
229   // Check again if the space is available.  Another thread
230   // may have similarly failed a metadata allocation and induced
231   // a GC that freed space for the allocation.
232   if (!MetadataAllocationFailALot) {
233     _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
234     if (_result != NULL) {
235       return;
236     }
237   }
238 
239   if (initiate_concurrent_GC()) {
<span class="line-modified">240     // For CMS and G1 expand since the collection is going to be concurrent.</span>
241     _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
242     if (_result != NULL) {
243       return;
244     }
245 
<span class="line-modified">246     log_debug(gc)(&quot;%s full GC for Metaspace&quot;, UseConcMarkSweepGC ? &quot;CMS&quot; : &quot;G1&quot;);</span>
247   }
248 
249   // Don&#39;t clear the soft refs yet.
250   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_threshold);
251   // After a GC try to allocate without expanding.  Could fail
252   // and expansion will be tried below.
253   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
254   if (_result != NULL) {
255     return;
256   }
257 
258   // If still failing, allow the Metaspace to expand.
259   // See delta_capacity_until_GC() for explanation of the
260   // amount of the expansion.
261   // This should work unless there really is no more space
262   // or a MaxMetaspaceSize has been specified on the command line.
263   _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
264   if (_result != NULL) {
265     return;
266   }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoader.hpp&quot;
 27 #include &quot;classfile/javaClasses.hpp&quot;
 28 #include &quot;gc/shared/allocTracer.hpp&quot;
 29 #include &quot;gc/shared/gcId.hpp&quot;
 30 #include &quot;gc/shared/gcLocker.hpp&quot;
 31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;interpreter/oopMapCache.hpp&quot;
 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/oopFactory.hpp&quot;
<span class="line-added"> 36 #include &quot;memory/universe.hpp&quot;</span>
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/init.hpp&quot;
 39 #include &quot;utilities/dtrace.hpp&quot;
 40 #include &quot;utilities/macros.hpp&quot;
 41 #include &quot;utilities/preserveException.hpp&quot;
 42 #if INCLUDE_G1GC
 43 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 44 #include &quot;gc/g1/g1Policy.hpp&quot;
 45 #endif // INCLUDE_G1GC
 46 
 47 VM_GC_Operation::~VM_GC_Operation() {
 48   CollectedHeap* ch = Universe::heap();
 49   ch-&gt;soft_ref_policy()-&gt;set_all_soft_refs_clear(false);
 50 }
 51 
 52 // The same dtrace probe can&#39;t be inserted in two different files, so we
 53 // have to call it here, so it&#39;s only in one file.  Can&#39;t create new probes
 54 // for the other file anymore.   The dtrace probes have to remain stable.
 55 void VM_GC_Operation::notify_gc_begin(bool full) {
 56   HOTSPOT_GC_BEGIN(
</pre>
<hr />
<pre>
134 void VM_GC_HeapInspection::doit() {
135   HandleMark hm;
136   Universe::heap()-&gt;ensure_parsability(false); // must happen, even if collection does
137                                                // not happen (e.g. due to GCLocker)
138                                                // or _full_gc being false
139   if (_full_gc) {
140     if (!collect()) {
141       // The collection attempt was skipped because the gc locker is held.
142       // The following dump may then be a tad misleading to someone expecting
143       // only live objects to show up in the dump (see CR 6944195). Just issue
144       // a suitable warning in that case and do not attempt to do a collection.
145       // The latter is a subtle point, because even a failed attempt
146       // to GC will, in fact, induce one in the future, which we
147       // probably want to avoid in this case because the GC that we may
148       // be about to attempt holds value for us only
149       // if it happens now and not if it happens in the eventual
150       // future.
151       log_warning(gc)(&quot;GC locker is held; pre-dump GC was skipped&quot;);
152     }
153   }
<span class="line-modified">154   HeapInspection inspect;</span>

155   inspect.heap_inspection(_out);
156 }
157 
158 
159 void VM_GenCollectForAllocation::doit() {
160   SvcGCMarker sgcm(SvcGCMarker::MINOR);
161 
162   GenCollectedHeap* gch = GenCollectedHeap::heap();
163   GCCauseSetter gccs(gch, _gc_cause);
164   _result = gch-&gt;satisfy_failed_allocation(_word_size, _tlab);
<span class="line-modified">165   assert(_result == NULL || gch-&gt;is_in_reserved(_result), &quot;result not in heap&quot;);</span>
166 
167   if (_result == NULL &amp;&amp; GCLocker::is_active_and_needs_gc()) {
168     set_gc_locked();
169   }
170 }
171 
172 void VM_GenCollectFull::doit() {
173   SvcGCMarker sgcm(SvcGCMarker::FULL);
174 
175   GenCollectedHeap* gch = GenCollectedHeap::heap();
176   GCCauseSetter gccs(gch, _gc_cause);
177   gch-&gt;do_full_collection(gch-&gt;must_clear_all_soft_refs(), _max_generation);
178 }
179 
180 VM_CollectForMetadataAllocation::VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
181                                                                  size_t size,
182                                                                  Metaspace::MetadataType mdtype,
183                                                                  uint gc_count_before,
184                                                                  uint full_gc_count_before,
185                                                                  GCCause::Cause gc_cause)
186     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true),
187       _result(NULL), _size(size), _mdtype(mdtype), _loader_data(loader_data) {
188   assert(_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
189   AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
190 }
191 
192 // Returns true iff concurrent GCs unloads metadata.
193 bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {







194 #if INCLUDE_G1GC
195   if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
196     G1CollectedHeap* g1h = G1CollectedHeap::heap();
197     g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
198 
199     GCCauseSetter x(g1h, _gc_cause);
200 
201     // At this point we are supposed to start a concurrent cycle. We
202     // will do so if one is not already in progress.
203     bool should_start = g1h-&gt;policy()-&gt;force_initial_mark_if_outside_cycle(_gc_cause);
204 
205     if (should_start) {
206       double pause_target = g1h-&gt;policy()-&gt;max_pause_time_ms();
207       g1h-&gt;do_collection_pause_at_safepoint(pause_target);
208     }
209     return true;
210   }
211 #endif
212 
213   return false;
214 }
215 
216 void VM_CollectForMetadataAllocation::doit() {
217   SvcGCMarker sgcm(SvcGCMarker::FULL);
218 
219   CollectedHeap* heap = Universe::heap();
220   GCCauseSetter gccs(heap, _gc_cause);
221 
222   // Check again if the space is available.  Another thread
223   // may have similarly failed a metadata allocation and induced
224   // a GC that freed space for the allocation.
225   if (!MetadataAllocationFailALot) {
226     _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
227     if (_result != NULL) {
228       return;
229     }
230   }
231 
232   if (initiate_concurrent_GC()) {
<span class="line-modified">233     // For G1 expand since the collection is going to be concurrent.</span>
234     _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
235     if (_result != NULL) {
236       return;
237     }
238 
<span class="line-modified">239     log_debug(gc)(&quot;G1 full GC for Metaspace&quot;);</span>
240   }
241 
242   // Don&#39;t clear the soft refs yet.
243   heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_threshold);
244   // After a GC try to allocate without expanding.  Could fail
245   // and expansion will be tried below.
246   _result = _loader_data-&gt;metaspace_non_null()-&gt;allocate(_size, _mdtype);
247   if (_result != NULL) {
248     return;
249   }
250 
251   // If still failing, allow the Metaspace to expand.
252   // See delta_capacity_until_GC() for explanation of the
253   // amount of the expansion.
254   // This should work unless there really is no more space
255   // or a MaxMetaspaceSize has been specified on the command line.
256   _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
257   if (_result != NULL) {
258     return;
259   }
</pre>
</td>
</tr>
</table>
<center><a href="gcTraceSend.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
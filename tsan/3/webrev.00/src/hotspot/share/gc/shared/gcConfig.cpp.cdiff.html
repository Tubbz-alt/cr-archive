<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/gcConfig.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcCause.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcConfig.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcConfig.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,13 ***</span>
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-removed">- #if INCLUDE_CMSGC</span>
<span class="line-removed">- #include &quot;gc/cms/cmsArguments.hpp&quot;</span>
<span class="line-removed">- #endif</span>
  #if INCLUDE_EPSILONGC
  #include &quot;gc/epsilon/epsilonArguments.hpp&quot;
  #endif
  #if INCLUDE_G1GC
  #include &quot;gc/g1/g1Arguments.hpp&quot;
<span class="line-new-header">--- 26,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,43 ***</span>
  #endif
  #if INCLUDE_ZGC
  #include &quot;gc/z/zArguments.hpp&quot;
  #endif
  
<span class="line-modified">! struct SupportedGC {</span>
    bool&amp;               _flag;
    CollectedHeap::Name _name;
    GCArguments&amp;        _arguments;
    const char*         _hs_err_name;
  
<span class="line-modified">!   SupportedGC(bool&amp; flag, CollectedHeap::Name name, GCArguments&amp; arguments, const char* hs_err_name) :</span>
        _flag(flag), _name(name), _arguments(arguments), _hs_err_name(hs_err_name) {}
  };
  
<span class="line-modified">!        CMSGC_ONLY(static CMSArguments      cmsArguments;)</span>
<span class="line-modified">!    EPSILONGC_ONLY(static EpsilonArguments  epsilonArguments;)</span>
<span class="line-modified">!         G1GC_ONLY(static G1Arguments       g1Arguments;)</span>
<span class="line-modified">!   PARALLELGC_ONLY(static ParallelArguments parallelArguments;)</span>
<span class="line-removed">-     SERIALGC_ONLY(static SerialArguments   serialArguments;)</span>
  SHENANDOAHGC_ONLY(static ShenandoahArguments shenandoahArguments;)
<span class="line-modified">!          ZGC_ONLY(static ZArguments        zArguments;)</span>
  
<span class="line-modified">! // Table of supported GCs, for translating between command</span>
  // line flag, CollectedHeap::Name and GCArguments instance.
<span class="line-modified">! static const SupportedGC SupportedGCs[] = {</span>
<span class="line-modified">!        CMSGC_ONLY_ARG(SupportedGC(UseConcMarkSweepGC, CollectedHeap::CMS,        cmsArguments,        &quot;concurrent mark sweep gc&quot;))</span>
<span class="line-modified">!    EPSILONGC_ONLY_ARG(SupportedGC(UseEpsilonGC,       CollectedHeap::Epsilon,    epsilonArguments,    &quot;epsilon gc&quot;))</span>
<span class="line-modified">!         G1GC_ONLY_ARG(SupportedGC(UseG1GC,            CollectedHeap::G1,         g1Arguments,         &quot;g1 gc&quot;))</span>
<span class="line-modified">!   PARALLELGC_ONLY_ARG(SupportedGC(UseParallelGC,      CollectedHeap::Parallel,   parallelArguments,   &quot;parallel gc&quot;))</span>
<span class="line-modified">!   PARALLELGC_ONLY_ARG(SupportedGC(UseParallelOldGC,   CollectedHeap::Parallel,   parallelArguments,   &quot;parallel gc&quot;))</span>
<span class="line-modified">!     SERIALGC_ONLY_ARG(SupportedGC(UseSerialGC,        CollectedHeap::Serial,     serialArguments,     &quot;serial gc&quot;))</span>
<span class="line-removed">- SHENANDOAHGC_ONLY_ARG(SupportedGC(UseShenandoahGC,    CollectedHeap::Shenandoah, shenandoahArguments, &quot;shenandoah gc&quot;))</span>
<span class="line-removed">-          ZGC_ONLY_ARG(SupportedGC(UseZGC,             CollectedHeap::Z,          zArguments,          &quot;z gc&quot;))</span>
  };
  
<span class="line-modified">! #define FOR_EACH_SUPPORTED_GC(var)                                          \</span>
<span class="line-modified">!   for (const SupportedGC* var = &amp;SupportedGCs[0]; var &lt; &amp;SupportedGCs[ARRAY_SIZE(SupportedGCs)]; var++)</span>
  
  #define FAIL_IF_SELECTED(option, enabled)                                   \
    if (option == enabled &amp;&amp; FLAG_IS_CMDLINE(option)) {                       \
      vm_exit_during_initialization(enabled ?                                 \
                                    &quot;Option -XX:+&quot; #option &quot; not supported&quot; : \
<span class="line-new-header">--- 45,40 ---</span>
  #endif
  #if INCLUDE_ZGC
  #include &quot;gc/z/zArguments.hpp&quot;
  #endif
  
<span class="line-modified">! struct IncludedGC {</span>
    bool&amp;               _flag;
    CollectedHeap::Name _name;
    GCArguments&amp;        _arguments;
    const char*         _hs_err_name;
  
<span class="line-modified">!   IncludedGC(bool&amp; flag, CollectedHeap::Name name, GCArguments&amp; arguments, const char* hs_err_name) :</span>
        _flag(flag), _name(name), _arguments(arguments), _hs_err_name(hs_err_name) {}
  };
  
<span class="line-modified">!    EPSILONGC_ONLY(static EpsilonArguments    epsilonArguments;)</span>
<span class="line-modified">!         G1GC_ONLY(static G1Arguments         g1Arguments;)</span>
<span class="line-modified">!   PARALLELGC_ONLY(static ParallelArguments   parallelArguments;)</span>
<span class="line-modified">!     SERIALGC_ONLY(static SerialArguments     serialArguments;)</span>
  SHENANDOAHGC_ONLY(static ShenandoahArguments shenandoahArguments;)
<span class="line-modified">!          ZGC_ONLY(static ZArguments          zArguments;)</span>
  
<span class="line-modified">! // Table of included GCs, for translating between command</span>
  // line flag, CollectedHeap::Name and GCArguments instance.
<span class="line-modified">! static const IncludedGC IncludedGCs[] = {</span>
<span class="line-modified">!    EPSILONGC_ONLY_ARG(IncludedGC(UseEpsilonGC,       CollectedHeap::Epsilon,    epsilonArguments,    &quot;epsilon gc&quot;))</span>
<span class="line-modified">!         G1GC_ONLY_ARG(IncludedGC(UseG1GC,            CollectedHeap::G1,         g1Arguments,         &quot;g1 gc&quot;))</span>
<span class="line-modified">!   PARALLELGC_ONLY_ARG(IncludedGC(UseParallelGC,      CollectedHeap::Parallel,   parallelArguments,   &quot;parallel gc&quot;))</span>
<span class="line-modified">!     SERIALGC_ONLY_ARG(IncludedGC(UseSerialGC,        CollectedHeap::Serial,     serialArguments,     &quot;serial gc&quot;))</span>
<span class="line-modified">! SHENANDOAHGC_ONLY_ARG(IncludedGC(UseShenandoahGC,    CollectedHeap::Shenandoah, shenandoahArguments, &quot;shenandoah gc&quot;))</span>
<span class="line-modified">!          ZGC_ONLY_ARG(IncludedGC(UseZGC,             CollectedHeap::Z,          zArguments,          &quot;z gc&quot;))</span>
  };
  
<span class="line-modified">! #define FOR_EACH_INCLUDED_GC(var)                                            \</span>
<span class="line-modified">!   for (const IncludedGC* var = &amp;IncludedGCs[0]; var &lt; &amp;IncludedGCs[ARRAY_SIZE(IncludedGCs)]; var++)</span>
  
  #define FAIL_IF_SELECTED(option, enabled)                                   \
    if (option == enabled &amp;&amp; FLAG_IS_CMDLINE(option)) {                       \
      vm_exit_during_initialization(enabled ?                                 \
                                    &quot;Option -XX:+&quot; #option &quot; not supported&quot; : \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,40 ***</span>
    }
  
  GCArguments* GCConfig::_arguments = NULL;
  bool GCConfig::_gc_selected_ergonomically = false;
  
<span class="line-modified">! void GCConfig::fail_if_unsupported_gc_is_selected() {</span>
<span class="line-removed">-   NOT_CMSGC(       FAIL_IF_SELECTED(UseConcMarkSweepGC, true));</span>
    NOT_EPSILONGC(   FAIL_IF_SELECTED(UseEpsilonGC,       true));
    NOT_G1GC(        FAIL_IF_SELECTED(UseG1GC,            true));
    NOT_PARALLELGC(  FAIL_IF_SELECTED(UseParallelGC,      true));
<span class="line-removed">-   NOT_PARALLELGC(  FAIL_IF_SELECTED(UseParallelOldGC,   true));</span>
    NOT_SERIALGC(    FAIL_IF_SELECTED(UseSerialGC,        true));
<span class="line-removed">-   NOT_SERIALGC(    FAIL_IF_SELECTED(UseParallelOldGC,   false));</span>
    NOT_SHENANDOAHGC(FAIL_IF_SELECTED(UseShenandoahGC,    true));
    NOT_ZGC(         FAIL_IF_SELECTED(UseZGC,             true));
  }
  
  void GCConfig::select_gc_ergonomically() {
    if (os::is_server_class_machine()) {
  #if INCLUDE_G1GC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(bool, UseG1GC, true);</span>
  #elif INCLUDE_PARALLELGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(bool, UseParallelGC, true);</span>
  #elif INCLUDE_SERIALGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(bool, UseSerialGC, true);</span>
  #endif
    } else {
  #if INCLUDE_SERIALGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(bool, UseSerialGC, true);</span>
  #endif
    }
  }
  
  bool GCConfig::is_no_gc_selected() {
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        return false;
      }
    }
  
<span class="line-new-header">--- 86,37 ---</span>
    }
  
  GCArguments* GCConfig::_arguments = NULL;
  bool GCConfig::_gc_selected_ergonomically = false;
  
<span class="line-modified">! void GCConfig::fail_if_non_included_gc_is_selected() {</span>
    NOT_EPSILONGC(   FAIL_IF_SELECTED(UseEpsilonGC,       true));
    NOT_G1GC(        FAIL_IF_SELECTED(UseG1GC,            true));
    NOT_PARALLELGC(  FAIL_IF_SELECTED(UseParallelGC,      true));
    NOT_SERIALGC(    FAIL_IF_SELECTED(UseSerialGC,        true));
    NOT_SHENANDOAHGC(FAIL_IF_SELECTED(UseShenandoahGC,    true));
    NOT_ZGC(         FAIL_IF_SELECTED(UseZGC,             true));
  }
  
  void GCConfig::select_gc_ergonomically() {
    if (os::is_server_class_machine()) {
  #if INCLUDE_G1GC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(UseG1GC, true);</span>
  #elif INCLUDE_PARALLELGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(UseParallelGC, true);</span>
  #elif INCLUDE_SERIALGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(UseSerialGC, true);</span>
  #endif
    } else {
  #if INCLUDE_SERIALGC
<span class="line-modified">!     FLAG_SET_ERGO_IF_DEFAULT(UseSerialGC, true);</span>
  #endif
    }
  }
  
  bool GCConfig::is_no_gc_selected() {
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        return false;
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
  }
  
  bool GCConfig::is_exactly_one_gc_selected() {
    CollectedHeap::Name selected = CollectedHeap::None;
  
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        if (gc-&gt;_name == selected || selected == CollectedHeap::None) {
          // Selected
          selected = gc-&gt;_name;
        } else {
<span class="line-new-header">--- 124,11 ---</span>
  }
  
  bool GCConfig::is_exactly_one_gc_selected() {
    CollectedHeap::Name selected = CollectedHeap::None;
  
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        if (gc-&gt;_name == selected || selected == CollectedHeap::None) {
          // Selected
          selected = gc-&gt;_name;
        } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,11 ***</span>
    return selected != CollectedHeap::None;
  }
  
  GCArguments* GCConfig::select_gc() {
    // Fail immediately if an unsupported GC is selected
<span class="line-modified">!   fail_if_unsupported_gc_is_selected();</span>
  
    if (is_no_gc_selected()) {
      // Try select GC ergonomically
      select_gc_ergonomically();
  
<span class="line-new-header">--- 141,11 ---</span>
    return selected != CollectedHeap::None;
  }
  
  GCArguments* GCConfig::select_gc() {
    // Fail immediately if an unsupported GC is selected
<span class="line-modified">!   fail_if_non_included_gc_is_selected();</span>
  
    if (is_no_gc_selected()) {
      // Try select GC ergonomically
      select_gc_ergonomically();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,11 ***</span>
      // More than one GC selected
      vm_exit_during_initialization(&quot;Multiple garbage collectors selected&quot;, NULL);
    }
  
    // Exactly one GC selected
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        return &amp;gc-&gt;_arguments;
      }
    }
  
<span class="line-new-header">--- 163,11 ---</span>
      // More than one GC selected
      vm_exit_during_initialization(&quot;Multiple garbage collectors selected&quot;, NULL);
    }
  
    // Exactly one GC selected
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
      if (gc-&gt;_flag) {
        return &amp;gc-&gt;_arguments;
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,23 ***</span>
    assert(_arguments == NULL, &quot;Already initialized&quot;);
    _arguments = select_gc();
  }
  
  bool GCConfig::is_gc_supported(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
<span class="line-modified">!     if (gc-&gt;_name == name) {</span>
        // Supported
        return true;
      }
    }
  
    // Not supported
    return false;
  }
  
  bool GCConfig::is_gc_selected(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
      if (gc-&gt;_name == name &amp;&amp; gc-&gt;_flag) {
        // Selected
        return true;
      }
    }
<span class="line-new-header">--- 180,23 ---</span>
    assert(_arguments == NULL, &quot;Already initialized&quot;);
    _arguments = select_gc();
  }
  
  bool GCConfig::is_gc_supported(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
<span class="line-modified">!     if (gc-&gt;_name == name &amp;&amp; gc-&gt;_arguments.is_supported()) {</span>
        // Supported
        return true;
      }
    }
  
    // Not supported
    return false;
  }
  
  bool GCConfig::is_gc_selected(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
      if (gc-&gt;_name == name &amp;&amp; gc-&gt;_flag) {
        // Selected
        return true;
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,11 ***</span>
  }
  
  const char* GCConfig::hs_err_name() {
    if (is_exactly_one_gc_selected()) {
      // Exacly one GC selected
<span class="line-modified">!     FOR_EACH_SUPPORTED_GC(gc) {</span>
        if (gc-&gt;_flag) {
          return gc-&gt;_hs_err_name;
        }
      }
    }
<span class="line-new-header">--- 210,11 ---</span>
  }
  
  const char* GCConfig::hs_err_name() {
    if (is_exactly_one_gc_selected()) {
      // Exacly one GC selected
<span class="line-modified">!     FOR_EACH_INCLUDED_GC(gc) {</span>
        if (gc-&gt;_flag) {
          return gc-&gt;_hs_err_name;
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,11 ***</span>
    // Zero or more than one GC selected
    return &quot;unknown gc&quot;;
  }
  
  const char* GCConfig::hs_err_name(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_SUPPORTED_GC(gc) {</span>
      if (gc-&gt;_name == name) {
        return gc-&gt;_hs_err_name;
      }
    }
    return &quot;unknown gc&quot;;
<span class="line-new-header">--- 222,11 ---</span>
    // Zero or more than one GC selected
    return &quot;unknown gc&quot;;
  }
  
  const char* GCConfig::hs_err_name(CollectedHeap::Name name) {
<span class="line-modified">!   FOR_EACH_INCLUDED_GC(gc) {</span>
      if (gc-&gt;_name == name) {
        return gc-&gt;_hs_err_name;
      }
    }
    return &quot;unknown gc&quot;;
</pre>
<center><a href="gcCause.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcConfig.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/blockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetNMethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="blockOffsetTable.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/blockOffsetTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -242,14 +242,14 @@</span>
  // Action_verify - BOT verification.
  void
  BlockOffsetArray::do_block_internal(HeapWord* blk_start,
                                      HeapWord* blk_end,
                                      Action action, bool reducing) {
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved(blk_start),</span>
<span class="udiff-line-modified-removed">-          &quot;reference must be into the heap&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved(blk_end-1),</span>
<span class="udiff-line-modified-removed">-          &quot;limit must be within the heap&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_sp-&gt;is_in_reserved(blk_start),</span>
<span class="udiff-line-modified-added">+          &quot;reference must be into the space&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_sp-&gt;is_in_reserved(blk_end-1),</span>
<span class="udiff-line-modified-added">+          &quot;limit must be within the space&quot;);</span>
    // This is optimized to make the test fast, assuming we only rarely
    // cross boundaries.
    uintptr_t end_ui = (uintptr_t)(blk_end - 1);
    uintptr_t start_ui = (uintptr_t)blk_start;
    // Calculate the last card boundary preceding end of blk
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,310 +349,10 @@</span>
      last_start = start;
      last_o = o;
    }
  }
  
<span class="udiff-line-removed">- //////////////////////////////////////////////////////////////////////</span>
<span class="udiff-line-removed">- // BlockOffsetArrayNonContigSpace</span>
<span class="udiff-line-removed">- //////////////////////////////////////////////////////////////////////</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // The block [blk_start, blk_end) has been allocated;</span>
<span class="udiff-line-removed">- // adjust the block offset table to represent this information;</span>
<span class="udiff-line-removed">- // NOTE: Clients of BlockOffsetArrayNonContigSpace: consider using</span>
<span class="udiff-line-removed">- // the somewhat more lightweight split_block() or</span>
<span class="udiff-line-removed">- // (when init_to_zero()) mark_block() wherever possible.</span>
<span class="udiff-line-removed">- // right-open interval: [blk_start, blk_end)</span>
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- BlockOffsetArrayNonContigSpace::alloc_block(HeapWord* blk_start,</span>
<span class="udiff-line-removed">-                                             HeapWord* blk_end) {</span>
<span class="udiff-line-removed">-   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,</span>
<span class="udiff-line-removed">-          &quot;phantom block&quot;);</span>
<span class="udiff-line-removed">-   single_block(blk_start, blk_end);</span>
<span class="udiff-line-removed">-   allocated(blk_start, blk_end);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Adjust BOT to show that a previously whole block has been split</span>
<span class="udiff-line-removed">- // into two.  We verify the BOT for the first part (prefix) and</span>
<span class="udiff-line-removed">- // update the  BOT for the second part (suffix).</span>
<span class="udiff-line-removed">- //      blk is the start of the block</span>
<span class="udiff-line-removed">- //      blk_size is the size of the original block</span>
<span class="udiff-line-removed">- //      left_blk_size is the size of the first part of the split</span>
<span class="udiff-line-removed">- void BlockOffsetArrayNonContigSpace::split_block(HeapWord* blk,</span>
<span class="udiff-line-removed">-                                                  size_t blk_size,</span>
<span class="udiff-line-removed">-                                                  size_t left_blk_size) {</span>
<span class="udiff-line-removed">-   // Verify that the BOT shows [blk, blk + blk_size) to be one block.</span>
<span class="udiff-line-removed">-   verify_single_block(blk, blk_size);</span>
<span class="udiff-line-removed">-   // Update the BOT to indicate that [blk + left_blk_size, blk + blk_size)</span>
<span class="udiff-line-removed">-   // is one single block.</span>
<span class="udiff-line-removed">-   assert(blk_size &gt; 0, &quot;Should be positive&quot;);</span>
<span class="udiff-line-removed">-   assert(left_blk_size &gt; 0, &quot;Should be positive&quot;);</span>
<span class="udiff-line-removed">-   assert(left_blk_size &lt; blk_size, &quot;Not a split&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Start addresses of prefix block and suffix block.</span>
<span class="udiff-line-removed">-   HeapWord* pref_addr = blk;</span>
<span class="udiff-line-removed">-   HeapWord* suff_addr = blk + left_blk_size;</span>
<span class="udiff-line-removed">-   HeapWord* end_addr  = blk + blk_size;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Indices for starts of prefix block and suffix block.</span>
<span class="udiff-line-removed">-   size_t pref_index = _array-&gt;index_for(pref_addr);</span>
<span class="udiff-line-removed">-   if (_array-&gt;address_for_index(pref_index) != pref_addr) {</span>
<span class="udiff-line-removed">-     // pref_addr does not begin pref_index</span>
<span class="udiff-line-removed">-     pref_index++;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t suff_index = _array-&gt;index_for(suff_addr);</span>
<span class="udiff-line-removed">-   if (_array-&gt;address_for_index(suff_index) != suff_addr) {</span>
<span class="udiff-line-removed">-     // suff_addr does not begin suff_index</span>
<span class="udiff-line-removed">-     suff_index++;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Definition: A block B, denoted [B_start, B_end) __starts__</span>
<span class="udiff-line-removed">-   //     a card C, denoted [C_start, C_end), where C_start and C_end</span>
<span class="udiff-line-removed">-   //     are the heap addresses that card C covers, iff</span>
<span class="udiff-line-removed">-   //     B_start &lt;= C_start &lt; B_end.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   //     We say that a card C &quot;is started by&quot; a block B, iff</span>
<span class="udiff-line-removed">-   //     B &quot;starts&quot; C.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   //     Note that the cardinality of the set of cards {C}</span>
<span class="udiff-line-removed">-   //     started by a block B can be 0, 1, or more.</span>
<span class="udiff-line-removed">-   //</span>
<span class="udiff-line-removed">-   // Below, pref_index and suff_index are, respectively, the</span>
<span class="udiff-line-removed">-   // first (least) card indices that the prefix and suffix of</span>
<span class="udiff-line-removed">-   // the split start; end_index is one more than the index of</span>
<span class="udiff-line-removed">-   // the last (greatest) card that blk starts.</span>
<span class="udiff-line-removed">-   size_t end_index  = _array-&gt;index_for(end_addr - 1) + 1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Calculate the # cards that the prefix and suffix affect.</span>
<span class="udiff-line-removed">-   size_t num_pref_cards = suff_index - pref_index;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t num_suff_cards = end_index  - suff_index;</span>
<span class="udiff-line-removed">-   // Change the cards that need changing</span>
<span class="udiff-line-removed">-   if (num_suff_cards &gt; 0) {</span>
<span class="udiff-line-removed">-     HeapWord* boundary = _array-&gt;address_for_index(suff_index);</span>
<span class="udiff-line-removed">-     // Set the offset card for suffix block</span>
<span class="udiff-line-removed">-     _array-&gt;set_offset_array(suff_index, boundary, suff_addr, true /* reducing */);</span>
<span class="udiff-line-removed">-     // Change any further cards that need changing in the suffix</span>
<span class="udiff-line-removed">-     if (num_pref_cards &gt; 0) {</span>
<span class="udiff-line-removed">-       if (num_pref_cards &gt;= num_suff_cards) {</span>
<span class="udiff-line-removed">-         // Unilaterally fix all of the suffix cards: closed card</span>
<span class="udiff-line-removed">-         // index interval in args below.</span>
<span class="udiff-line-removed">-         set_remainder_to_point_to_start_incl(suff_index + 1, end_index - 1, true /* reducing */);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         // Unilaterally fix the first (num_pref_cards - 1) following</span>
<span class="udiff-line-removed">-         // the &quot;offset card&quot; in the suffix block.</span>
<span class="udiff-line-removed">-         const size_t right_most_fixed_index = suff_index + num_pref_cards - 1;</span>
<span class="udiff-line-removed">-         set_remainder_to_point_to_start_incl(suff_index + 1,</span>
<span class="udiff-line-removed">-           right_most_fixed_index, true /* reducing */);</span>
<span class="udiff-line-removed">-         // Fix the appropriate cards in the remainder of the</span>
<span class="udiff-line-removed">-         // suffix block -- these are the last num_pref_cards</span>
<span class="udiff-line-removed">-         // cards in each power block of the &quot;new&quot; range plumbed</span>
<span class="udiff-line-removed">-         // from suff_addr.</span>
<span class="udiff-line-removed">-         bool more = true;</span>
<span class="udiff-line-removed">-         uint i = 1;</span>
<span class="udiff-line-removed">-         // Fix the first power block with  back_by &gt; num_pref_cards.</span>
<span class="udiff-line-removed">-         while (more &amp;&amp; (i &lt; BOTConstants::N_powers)) {</span>
<span class="udiff-line-removed">-           size_t back_by = BOTConstants::power_to_cards_back(i);</span>
<span class="udiff-line-removed">-           size_t right_index = suff_index + back_by - 1;</span>
<span class="udiff-line-removed">-           size_t left_index  = right_index - num_pref_cards + 1;</span>
<span class="udiff-line-removed">-           if (right_index &gt;= end_index - 1) { // last iteration</span>
<span class="udiff-line-removed">-             right_index = end_index - 1;</span>
<span class="udiff-line-removed">-             more = false;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           if (left_index &lt;= right_most_fixed_index) {</span>
<span class="udiff-line-removed">-                 left_index = right_most_fixed_index + 1;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           if (back_by &gt; num_pref_cards) {</span>
<span class="udiff-line-removed">-             // Fill in the remainder of this &quot;power block&quot;, if it</span>
<span class="udiff-line-removed">-             // is non-null.</span>
<span class="udiff-line-removed">-             if (left_index &lt;= right_index) {</span>
<span class="udiff-line-removed">-               _array-&gt;set_offset_array(left_index, right_index,</span>
<span class="udiff-line-removed">-                                        BOTConstants::N_words + i - 1, true /* reducing */);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-               more = false; // we are done</span>
<span class="udiff-line-removed">-               assert((end_index - 1) == right_index, &quot;Must be at the end.&quot;);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             i++;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           i++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         // Fix the rest of the power blocks.</span>
<span class="udiff-line-removed">-         while (more &amp;&amp; (i &lt; BOTConstants::N_powers)) {</span>
<span class="udiff-line-removed">-           size_t back_by = BOTConstants::power_to_cards_back(i);</span>
<span class="udiff-line-removed">-           size_t right_index = suff_index + back_by - 1;</span>
<span class="udiff-line-removed">-           size_t left_index  = right_index - num_pref_cards + 1;</span>
<span class="udiff-line-removed">-           if (right_index &gt;= end_index - 1) { // last iteration</span>
<span class="udiff-line-removed">-             right_index = end_index - 1;</span>
<span class="udiff-line-removed">-             if (left_index &gt; right_index) {</span>
<span class="udiff-line-removed">-               break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             more  = false;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-           assert(left_index &lt;= right_index, &quot;Error&quot;);</span>
<span class="udiff-line-removed">-           _array-&gt;set_offset_array(left_index, right_index, BOTConstants::N_words + i - 1, true /* reducing */);</span>
<span class="udiff-line-removed">-           i++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     } // else no more cards to fix in suffix</span>
<span class="udiff-line-removed">-   } // else nothing needs to be done</span>
<span class="udiff-line-removed">-   // Verify that we did the right thing</span>
<span class="udiff-line-removed">-   verify_single_block(pref_addr, left_blk_size);</span>
<span class="udiff-line-removed">-   verify_single_block(suff_addr, blk_size - left_blk_size);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Mark the BOT such that if [blk_start, blk_end) straddles a card</span>
<span class="udiff-line-removed">- // boundary, the card following the first such boundary is marked</span>
<span class="udiff-line-removed">- // with the appropriate offset.</span>
<span class="udiff-line-removed">- // NOTE: this method does _not_ adjust _unallocated_block or</span>
<span class="udiff-line-removed">- // any cards subsequent to the first one.</span>
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- BlockOffsetArrayNonContigSpace::mark_block(HeapWord* blk_start,</span>
<span class="udiff-line-removed">-                                            HeapWord* blk_end, bool reducing) {</span>
<span class="udiff-line-removed">-   do_block_internal(blk_start, blk_end, Action_mark, reducing);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- HeapWord* BlockOffsetArrayNonContigSpace::block_start_unsafe(</span>
<span class="udiff-line-removed">-   const void* addr) const {</span>
<span class="udiff-line-removed">-   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);</span>
<span class="udiff-line-removed">-   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,</span>
<span class="udiff-line-removed">-          &quot;addr must be covered by this Array&quot;);</span>
<span class="udiff-line-removed">-   // Must read this exactly once because it can be modified by parallel</span>
<span class="udiff-line-removed">-   // allocation.</span>
<span class="udiff-line-removed">-   HeapWord* ub = _unallocated_block;</span>
<span class="udiff-line-removed">-   if (BlockOffsetArrayUseUnallocatedBlock &amp;&amp; addr &gt;= ub) {</span>
<span class="udiff-line-removed">-     assert(ub &lt; _end, &quot;tautology (see above)&quot;);</span>
<span class="udiff-line-removed">-     return ub;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Otherwise, find the block start using the table.</span>
<span class="udiff-line-removed">-   size_t index = _array-&gt;index_for(addr);</span>
<span class="udiff-line-removed">-   HeapWord* q = _array-&gt;address_for_index(index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   uint offset = _array-&gt;offset_array(index);    // Extend u_char to uint.</span>
<span class="udiff-line-removed">-   while (offset &gt;= BOTConstants::N_words) {</span>
<span class="udiff-line-removed">-     // The excess of the offset from N_words indicates a power of Base</span>
<span class="udiff-line-removed">-     // to go back by.</span>
<span class="udiff-line-removed">-     size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);</span>
<span class="udiff-line-removed">-     q -= (BOTConstants::N_words * n_cards_back);</span>
<span class="udiff-line-removed">-     assert(q &gt;= _sp-&gt;bottom(),</span>
<span class="udiff-line-removed">-            &quot;q = &quot; PTR_FORMAT &quot; crossed below bottom = &quot; PTR_FORMAT,</span>
<span class="udiff-line-removed">-            p2i(q), p2i(_sp-&gt;bottom()));</span>
<span class="udiff-line-removed">-     assert(q &lt; _sp-&gt;end(),</span>
<span class="udiff-line-removed">-            &quot;q = &quot; PTR_FORMAT &quot; crossed above end = &quot; PTR_FORMAT,</span>
<span class="udiff-line-removed">-            p2i(q), p2i(_sp-&gt;end()));</span>
<span class="udiff-line-removed">-     index -= n_cards_back;</span>
<span class="udiff-line-removed">-     offset = _array-&gt;offset_array(index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(offset &lt; BOTConstants::N_words, &quot;offset too large&quot;);</span>
<span class="udiff-line-removed">-   index--;</span>
<span class="udiff-line-removed">-   q -= offset;</span>
<span class="udiff-line-removed">-   assert(q &gt;= _sp-&gt;bottom(),</span>
<span class="udiff-line-removed">-          &quot;q = &quot; PTR_FORMAT &quot; crossed below bottom = &quot; PTR_FORMAT,</span>
<span class="udiff-line-removed">-          p2i(q), p2i(_sp-&gt;bottom()));</span>
<span class="udiff-line-removed">-   assert(q &lt; _sp-&gt;end(),</span>
<span class="udiff-line-removed">-          &quot;q = &quot; PTR_FORMAT &quot; crossed above end = &quot; PTR_FORMAT,</span>
<span class="udiff-line-removed">-          p2i(q), p2i(_sp-&gt;end()));</span>
<span class="udiff-line-removed">-   HeapWord* n = q;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   while (n &lt;= addr) {</span>
<span class="udiff-line-removed">-     debug_only(HeapWord* last = q);   // for debugging</span>
<span class="udiff-line-removed">-     q = n;</span>
<span class="udiff-line-removed">-     n += _sp-&gt;block_size(n);</span>
<span class="udiff-line-removed">-     assert(n &gt; q,</span>
<span class="udiff-line-removed">-            &quot;Looping at n = &quot; PTR_FORMAT &quot; with last = &quot; PTR_FORMAT &quot;,&quot;</span>
<span class="udiff-line-removed">-            &quot; while querying blk_start(&quot; PTR_FORMAT &quot;)&quot;</span>
<span class="udiff-line-removed">-            &quot; on _sp = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-removed">-            p2i(n), p2i(last), p2i(addr), p2i(_sp-&gt;bottom()), p2i(_sp-&gt;end()));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(q &lt;= addr,</span>
<span class="udiff-line-removed">-          &quot;wrong order for current (&quot; INTPTR_FORMAT &quot;)&quot; &quot; &lt;= arg (&quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-removed">-          p2i(q), p2i(addr));</span>
<span class="udiff-line-removed">-   assert(addr &lt;= n,</span>
<span class="udiff-line-removed">-          &quot;wrong order for arg (&quot; INTPTR_FORMAT &quot;) &lt;= next (&quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-removed">-          p2i(addr), p2i(n));</span>
<span class="udiff-line-removed">-   return q;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- HeapWord* BlockOffsetArrayNonContigSpace::block_start_careful(</span>
<span class="udiff-line-removed">-   const void* addr) const {</span>
<span class="udiff-line-removed">-   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,</span>
<span class="udiff-line-removed">-          &quot;addr must be covered by this Array&quot;);</span>
<span class="udiff-line-removed">-   // Must read this exactly once because it can be modified by parallel</span>
<span class="udiff-line-removed">-   // allocation.</span>
<span class="udiff-line-removed">-   HeapWord* ub = _unallocated_block;</span>
<span class="udiff-line-removed">-   if (BlockOffsetArrayUseUnallocatedBlock &amp;&amp; addr &gt;= ub) {</span>
<span class="udiff-line-removed">-     assert(ub &lt; _end, &quot;tautology (see above)&quot;);</span>
<span class="udiff-line-removed">-     return ub;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Otherwise, find the block start using the table, but taking</span>
<span class="udiff-line-removed">-   // care (cf block_start_unsafe() above) not to parse any objects/blocks</span>
<span class="udiff-line-removed">-   // on the cards themselves.</span>
<span class="udiff-line-removed">-   size_t index = _array-&gt;index_for(addr);</span>
<span class="udiff-line-removed">-   assert(_array-&gt;address_for_index(index) == addr,</span>
<span class="udiff-line-removed">-          &quot;arg should be start of card&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   HeapWord* q = (HeapWord*)addr;</span>
<span class="udiff-line-removed">-   uint offset;</span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-removed">-     offset = _array-&gt;offset_array(index);</span>
<span class="udiff-line-removed">-     if (offset &lt; BOTConstants::N_words) {</span>
<span class="udiff-line-removed">-       q -= offset;</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);</span>
<span class="udiff-line-removed">-       q -= (n_cards_back * BOTConstants::N_words);</span>
<span class="udiff-line-removed">-       index -= n_cards_back;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } while (offset &gt;= BOTConstants::N_words);</span>
<span class="udiff-line-removed">-   assert(q &lt;= addr, &quot;block start should be to left of arg&quot;);</span>
<span class="udiff-line-removed">-   return q;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- // Verification &amp; debugging - ensure that the offset table reflects the fact</span>
<span class="udiff-line-removed">- // that the block [blk_start, blk_end) or [blk, blk + size) is a</span>
<span class="udiff-line-removed">- // single block of storage. NOTE: can&#39;t const this because of</span>
<span class="udiff-line-removed">- // call to non-const do_block_internal() below.</span>
<span class="udiff-line-removed">- void BlockOffsetArrayNonContigSpace::verify_single_block(</span>
<span class="udiff-line-removed">-   HeapWord* blk_start, HeapWord* blk_end) {</span>
<span class="udiff-line-removed">-   if (VerifyBlockOffsetArray) {</span>
<span class="udiff-line-removed">-     do_block_internal(blk_start, blk_end, Action_check);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void BlockOffsetArrayNonContigSpace::verify_single_block(</span>
<span class="udiff-line-removed">-   HeapWord* blk, size_t size) {</span>
<span class="udiff-line-removed">-   verify_single_block(blk, blk + size);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Verify that the given block is before _unallocated_block</span>
<span class="udiff-line-removed">- void BlockOffsetArrayNonContigSpace::verify_not_unallocated(</span>
<span class="udiff-line-removed">-   HeapWord* blk_start, HeapWord* blk_end) const {</span>
<span class="udiff-line-removed">-   if (BlockOffsetArrayUseUnallocatedBlock) {</span>
<span class="udiff-line-removed">-     assert(blk_start &lt; blk_end, &quot;Block inconsistency?&quot;);</span>
<span class="udiff-line-removed">-     assert(blk_end &lt;= _unallocated_block, &quot;_unallocated_block problem&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void BlockOffsetArrayNonContigSpace::verify_not_unallocated(</span>
<span class="udiff-line-removed">-   HeapWord* blk, size_t size) const {</span>
<span class="udiff-line-removed">-   verify_not_unallocated(blk, blk + size);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif // PRODUCT</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- size_t BlockOffsetArrayNonContigSpace::last_active_index() const {</span>
<span class="udiff-line-removed">-   if (_unallocated_block == _bottom) {</span>
<span class="udiff-line-removed">-     return 0;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     return _array-&gt;index_for(_unallocated_block - 1);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //////////////////////////////////////////////////////////////////////
  // BlockOffsetArrayContigSpace
  //////////////////////////////////////////////////////////////////////
  
  HeapWord* BlockOffsetArrayContigSpace::block_start_unsafe(const void* addr) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -716,14 +416,14 @@</span>
           &quot;should be past threshold&quot;);
    assert(blk_start &lt;= _next_offset_threshold,
           &quot;blk_start should be at or before threshold&quot;);
    assert(pointer_delta(_next_offset_threshold, blk_start) &lt;= BOTConstants::N_words,
           &quot;offset should be &lt;= BlockOffsetSharedArray::N&quot;);
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved(blk_start),</span>
<span class="udiff-line-modified-removed">-          &quot;reference must be into the heap&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(Universe::heap()-&gt;is_in_reserved(blk_end-1),</span>
<span class="udiff-line-modified-removed">-          &quot;limit must be within the heap&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_sp-&gt;is_in_reserved(blk_start),</span>
<span class="udiff-line-modified-added">+          &quot;reference must be into the space&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_sp-&gt;is_in_reserved(blk_end-1),</span>
<span class="udiff-line-modified-added">+          &quot;limit must be within the space&quot;);</span>
    assert(_next_offset_threshold ==
           _array-&gt;_reserved.start() + _next_offset_index*BOTConstants::N_words,
           &quot;index must agree with threshold&quot;);
  
    debug_only(size_t orig_next_offset_index = _next_offset_index;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -773,22 +473,18 @@</span>
    }
  #endif
  }
  
  HeapWord* BlockOffsetArrayContigSpace::initialize_threshold() {
<span class="udiff-line-removed">-   assert(!Universe::heap()-&gt;is_in_reserved(_array-&gt;_offset_array),</span>
<span class="udiff-line-removed">-          &quot;just checking&quot;);</span>
    _next_offset_index = _array-&gt;index_for(_bottom);
    _next_offset_index++;
    _next_offset_threshold =
      _array-&gt;address_for_index(_next_offset_index);
    return _next_offset_threshold;
  }
  
  void BlockOffsetArrayContigSpace::zero_bottom_entry() {
<span class="udiff-line-removed">-   assert(!Universe::heap()-&gt;is_in_reserved(_array-&gt;_offset_array),</span>
<span class="udiff-line-removed">-          &quot;just checking&quot;);</span>
    size_t bottom_index = _array-&gt;index_for(_bottom);
    _array-&gt;set_offset_array(bottom_index, 0);
  }
  
  size_t BlockOffsetArrayContigSpace::last_active_index() const {
</pre>
<center><a href="barrierSetNMethod.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="blockOffsetTable.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
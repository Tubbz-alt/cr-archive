<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/ptrQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/ptrQueue.hpp&quot;
 27 #include &quot;logging/log.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/mutex.hpp&quot;
 32 #include &quot;runtime/mutexLocker.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 33 #include &quot;runtime/orderAccess.hpp&quot;</span>
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 #include &quot;utilities/globalCounter.inline.hpp&quot;
 36 
 37 #include &lt;new&gt;
 38 
<a name="2" id="anc2"></a><span class="line-modified"> 39 PtrQueue::PtrQueue(PtrQueueSet* qset, bool permanent, bool active) :</span>
 40   _qset(qset),
 41   _active(active),
<a name="3" id="anc3"></a><span class="line-removed"> 42   _permanent(permanent),</span>
 43   _index(0),
<a name="4" id="anc4"></a><span class="line-modified"> 44   _capacity_in_bytes(0),</span>
<span class="line-modified"> 45   _buf(NULL),</span>
<span class="line-removed"> 46   _lock(NULL)</span>
 47 {}
 48 
 49 PtrQueue::~PtrQueue() {
<a name="5" id="anc5"></a><span class="line-modified"> 50   assert(_permanent || (_buf == NULL), &quot;queue must be flushed before delete&quot;);</span>
 51 }
 52 
 53 void PtrQueue::flush_impl() {
 54   if (_buf != NULL) {
 55     BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());
 56     if (is_empty()) {
 57       // No work to do.
 58       qset()-&gt;deallocate_buffer(node);
 59     } else {
 60       qset()-&gt;enqueue_completed_buffer(node);
 61     }
 62     _buf = NULL;
 63     set_index(0);
 64   }
 65 }
 66 
<a name="6" id="anc6"></a><span class="line-removed"> 67 </span>
 68 void PtrQueue::enqueue_known_active(void* ptr) {
 69   while (_index == 0) {
 70     handle_zero_index();
 71   }
 72 
 73   assert(_buf != NULL, &quot;postcondition&quot;);
 74   assert(index() &gt; 0, &quot;postcondition&quot;);
 75   assert(index() &lt;= capacity(), &quot;invariant&quot;);
 76   _index -= _element_size;
 77   _buf[index()] = ptr;
 78 }
 79 
<a name="7" id="anc7"></a>





















 80 BufferNode* BufferNode::allocate(size_t size) {
 81   size_t byte_size = size * sizeof(void*);
 82   void* data = NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);
 83   return new (data) BufferNode;
 84 }
 85 
 86 void BufferNode::deallocate(BufferNode* node) {
 87   node-&gt;~BufferNode();
 88   FREE_C_HEAP_ARRAY(char, node);
 89 }
 90 
 91 BufferNode::Allocator::Allocator(const char* name, size_t buffer_size) :
 92   _buffer_size(buffer_size),
 93   _pending_list(),
 94   _free_list(),
 95   _pending_count(0),
 96   _free_count(0),
 97   _transfer_lock(false)
 98 {
<a name="8" id="anc8"></a><span class="line-modified"> 99   strncpy(_name, name, sizeof(_name));</span>
100   _name[sizeof(_name) - 1] = &#39;\0&#39;;
101 }
102 
103 BufferNode::Allocator::~Allocator() {
104   delete_list(_free_list.pop_all());
105   delete_list(_pending_list.pop_all());
106 }
107 
108 void BufferNode::Allocator::delete_list(BufferNode* list) {
109   while (list != NULL) {
110     BufferNode* next = list-&gt;next();
111     DEBUG_ONLY(list-&gt;set_next(NULL);)
112     BufferNode::deallocate(list);
113     list = next;
114   }
115 }
116 
117 size_t BufferNode::Allocator::free_count() const {
118   return Atomic::load(&amp;_free_count);
119 }
120 
121 BufferNode* BufferNode::Allocator::allocate() {
122   BufferNode* node;
123   {
124     // Protect against ABA; see release().
125     GlobalCounter::CriticalSection cs(Thread::current());
126     node = _free_list.pop();
127   }
128   if (node == NULL) {
129     node = BufferNode::allocate(_buffer_size);
130   } else {
131     // Decrement count after getting buffer from free list.  This, along
132     // with incrementing count before adding to free list, ensures count
133     // never underflows.
<a name="9" id="anc9"></a><span class="line-modified">134     size_t count = Atomic::sub(1u, &amp;_free_count);</span>
135     assert((count + 1) != 0, &quot;_free_count underflow&quot;);
136   }
137   return node;
138 }
139 
140 // To solve the ABA problem for lock-free stack pop, allocate does the
141 // pop inside a critical section, and release synchronizes on the
142 // critical sections before adding to the _free_list.  But we don&#39;t
143 // want to make every release have to do a synchronize.  Instead, we
144 // initially place released nodes on the _pending_list, and transfer
145 // them to the _free_list in batches.  Only one transfer at a time is
146 // permitted, with a lock bit to control access to that phase.  A
147 // transfer takes all the nodes from the _pending_list, synchronizes on
148 // the _free_list pops, and then adds the former pending nodes to the
149 // _free_list.  While that&#39;s happening, other threads might be adding
150 // other nodes to the _pending_list, to be dealt with by some later
151 // transfer.
152 void BufferNode::Allocator::release(BufferNode* node) {
153   assert(node != NULL, &quot;precondition&quot;);
154   assert(node-&gt;next() == NULL, &quot;precondition&quot;);
155 
156   // Desired minimum transfer batch size.  There is relatively little
157   // importance to the specific number.  It shouldn&#39;t be too big, else
158   // we&#39;re wasting space when the release rate is low.  If the release
159   // rate is high, we might accumulate more than this before being
160   // able to start a new transfer, but that&#39;s okay.  Also note that
161   // the allocation rate and the release rate are going to be fairly
162   // similar, due to how the buffers are used.
163   const size_t trigger_transfer = 10;
164 
165   // Add to pending list. Update count first so no underflow in transfer.
<a name="10" id="anc10"></a><span class="line-modified">166   size_t pending_count = Atomic::add(1u, &amp;_pending_count);</span>
167   _pending_list.push(*node);
168   if (pending_count &gt; trigger_transfer) {
169     try_transfer_pending();
170   }
171 }
172 
173 // Try to transfer nodes from _pending_list to _free_list, with a
174 // synchronization delay for any in-progress pops from the _free_list,
175 // to solve ABA there.  Return true if performed a (possibly empty)
176 // transfer, false if blocked from doing so by some other thread&#39;s
177 // in-progress transfer.
178 bool BufferNode::Allocator::try_transfer_pending() {
179   // Attempt to claim the lock.
180   if (Atomic::load(&amp;_transfer_lock) || // Skip CAS if likely to fail.
<a name="11" id="anc11"></a><span class="line-modified">181       Atomic::cmpxchg(true, &amp;_transfer_lock, false)) {</span>
182     return false;
183   }
184   // Have the lock; perform the transfer.
185 
186   // Claim all the pending nodes.
187   BufferNode* first = _pending_list.pop_all();
188   if (first != NULL) {
189     // Prepare to add the claimed nodes, and update _pending_count.
190     BufferNode* last = first;
191     size_t count = 1;
192     for (BufferNode* next = first-&gt;next(); next != NULL; next = next-&gt;next()) {
193       last = next;
194       ++count;
195     }
<a name="12" id="anc12"></a><span class="line-modified">196     Atomic::sub(count, &amp;_pending_count);</span>
197 
198     // Wait for any in-progress pops, to avoid ABA for them.
199     GlobalCounter::write_synchronize();
200 
201     // Add synchronized nodes to _free_list.
202     // Update count first so no underflow in allocate().
<a name="13" id="anc13"></a><span class="line-modified">203     Atomic::add(count, &amp;_free_count);</span>
204     _free_list.prepend(*first, *last);
205     log_trace(gc, ptrqueue, freelist)
206              (&quot;Transferred %s pending to free: &quot; SIZE_FORMAT, name(), count);
207   }
<a name="14" id="anc14"></a><span class="line-modified">208   OrderAccess::release_store(&amp;_transfer_lock, false);</span>
209   return true;
210 }
211 
212 size_t BufferNode::Allocator::reduce_free_list(size_t remove_goal) {
213   try_transfer_pending();
214   size_t removed = 0;
215   for ( ; removed &lt; remove_goal; ++removed) {
216     BufferNode* node = _free_list.pop();
217     if (node == NULL) break;
218     BufferNode::deallocate(node);
219   }
<a name="15" id="anc15"></a><span class="line-modified">220   size_t new_count = Atomic::sub(removed, &amp;_free_count);</span>
221   log_debug(gc, ptrqueue, freelist)
222            (&quot;Reduced %s free list by &quot; SIZE_FORMAT &quot; to &quot; SIZE_FORMAT,
223             name(), removed, new_count);
224   return removed;
225 }
226 
<a name="16" id="anc16"></a><span class="line-modified">227 PtrQueueSet::PtrQueueSet(bool notify_when_complete) :</span>
<span class="line-modified">228   _allocator(NULL),</span>
<span class="line-removed">229   _cbl_mon(NULL),</span>
<span class="line-removed">230   _completed_buffers_head(NULL),</span>
<span class="line-removed">231   _completed_buffers_tail(NULL),</span>
<span class="line-removed">232   _n_completed_buffers(0),</span>
<span class="line-removed">233   _process_completed_buffers_threshold(ProcessCompletedBuffersThresholdNever),</span>
<span class="line-removed">234   _process_completed_buffers(false),</span>
<span class="line-removed">235   _notify_when_complete(notify_when_complete),</span>
<span class="line-removed">236   _max_completed_buffers(MaxCompletedBuffersUnlimited),</span>
<span class="line-removed">237   _completed_buffers_padding(0),</span>
238   _all_active(false)
239 {}
240 
<a name="17" id="anc17"></a><span class="line-modified">241 PtrQueueSet::~PtrQueueSet() {</span>
<span class="line-removed">242   // There are presently only a couple (derived) instances ever</span>
<span class="line-removed">243   // created, and they are permanent, so no harm currently done by</span>
<span class="line-removed">244   // doing nothing here.</span>
<span class="line-removed">245 }</span>
<span class="line-removed">246 </span>
<span class="line-removed">247 void PtrQueueSet::initialize(Monitor* cbl_mon,</span>
<span class="line-removed">248                              BufferNode::Allocator* allocator) {</span>
<span class="line-removed">249   assert(cbl_mon != NULL &amp;&amp; allocator != NULL, &quot;Init order issue?&quot;);</span>
<span class="line-removed">250   _cbl_mon = cbl_mon;</span>
<span class="line-removed">251   _allocator = allocator;</span>
<span class="line-removed">252 }</span>
253 
254 void** PtrQueueSet::allocate_buffer() {
255   BufferNode* node = _allocator-&gt;allocate();
256   return BufferNode::make_buffer_from_node(node);
257 }
258 
259 void PtrQueueSet::deallocate_buffer(BufferNode* node) {
260   _allocator-&gt;release(node);
261 }
<a name="18" id="anc18"></a><span class="line-removed">262 </span>
<span class="line-removed">263 void PtrQueue::handle_zero_index() {</span>
<span class="line-removed">264   assert(index() == 0, &quot;precondition&quot;);</span>
<span class="line-removed">265 </span>
<span class="line-removed">266   // This thread records the full buffer and allocates a new one (while</span>
<span class="line-removed">267   // holding the lock if there is one).</span>
<span class="line-removed">268   if (_buf != NULL) {</span>
<span class="line-removed">269     if (!should_enqueue_buffer()) {</span>
<span class="line-removed">270       assert(index() &gt; 0, &quot;the buffer can only be re-used if it&#39;s not full&quot;);</span>
<span class="line-removed">271       return;</span>
<span class="line-removed">272     }</span>
<span class="line-removed">273 </span>
<span class="line-removed">274     if (_lock) {</span>
<span class="line-removed">275       assert(_lock-&gt;owned_by_self(), &quot;Required.&quot;);</span>
<span class="line-removed">276 </span>
<span class="line-removed">277       BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());</span>
<span class="line-removed">278       _buf = NULL;         // clear shared _buf field</span>
<span class="line-removed">279 </span>
<span class="line-removed">280       qset()-&gt;enqueue_completed_buffer(node);</span>
<span class="line-removed">281       assert(_buf == NULL, &quot;multiple enqueuers appear to be racing&quot;);</span>
<span class="line-removed">282     } else {</span>
<span class="line-removed">283       BufferNode* node = BufferNode::make_node_from_buffer(_buf, index());</span>
<span class="line-removed">284       if (qset()-&gt;process_or_enqueue_completed_buffer(node)) {</span>
<span class="line-removed">285         // Recycle the buffer. No allocation.</span>
<span class="line-removed">286         assert(_buf == BufferNode::make_buffer_from_node(node), &quot;invariant&quot;);</span>
<span class="line-removed">287         assert(capacity() == qset()-&gt;buffer_size(), &quot;invariant&quot;);</span>
<span class="line-removed">288         reset();</span>
<span class="line-removed">289         return;</span>
<span class="line-removed">290       }</span>
<span class="line-removed">291     }</span>
<span class="line-removed">292   }</span>
<span class="line-removed">293   // Set capacity in case this is the first allocation.</span>
<span class="line-removed">294   set_capacity(qset()-&gt;buffer_size());</span>
<span class="line-removed">295   // Allocate a new buffer.</span>
<span class="line-removed">296   _buf = qset()-&gt;allocate_buffer();</span>
<span class="line-removed">297   reset();</span>
<span class="line-removed">298 }</span>
<span class="line-removed">299 </span>
<span class="line-removed">300 bool PtrQueueSet::process_or_enqueue_completed_buffer(BufferNode* node) {</span>
<span class="line-removed">301   if (Thread::current()-&gt;is_Java_thread()) {</span>
<span class="line-removed">302     // If the number of buffers exceeds the limit, make this Java</span>
<span class="line-removed">303     // thread do the processing itself.  We don&#39;t lock to access</span>
<span class="line-removed">304     // buffer count or padding; it is fine to be imprecise here.  The</span>
<span class="line-removed">305     // add of padding could overflow, which is treated as unlimited.</span>
<span class="line-removed">306     size_t limit = _max_completed_buffers + _completed_buffers_padding;</span>
<span class="line-removed">307     if ((_n_completed_buffers &gt; limit) &amp;&amp; (limit &gt;= _max_completed_buffers)) {</span>
<span class="line-removed">308       if (mut_process_buffer(node)) {</span>
<span class="line-removed">309         // Successfully processed; return true to allow buffer reuse.</span>
<span class="line-removed">310         return true;</span>
<span class="line-removed">311       }</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313   }</span>
<span class="line-removed">314   // The buffer will be enqueued. The caller will have to get a new one.</span>
<span class="line-removed">315   enqueue_completed_buffer(node);</span>
<span class="line-removed">316   return false;</span>
<span class="line-removed">317 }</span>
<span class="line-removed">318 </span>
<span class="line-removed">319 void PtrQueueSet::enqueue_completed_buffer(BufferNode* cbn) {</span>
<span class="line-removed">320   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">321   cbn-&gt;set_next(NULL);</span>
<span class="line-removed">322   if (_completed_buffers_tail == NULL) {</span>
<span class="line-removed">323     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="line-removed">324     _completed_buffers_head = cbn;</span>
<span class="line-removed">325     _completed_buffers_tail = cbn;</span>
<span class="line-removed">326   } else {</span>
<span class="line-removed">327     _completed_buffers_tail-&gt;set_next(cbn);</span>
<span class="line-removed">328     _completed_buffers_tail = cbn;</span>
<span class="line-removed">329   }</span>
<span class="line-removed">330   _n_completed_buffers++;</span>
<span class="line-removed">331 </span>
<span class="line-removed">332   if (!_process_completed_buffers &amp;&amp;</span>
<span class="line-removed">333       (_n_completed_buffers &gt; _process_completed_buffers_threshold)) {</span>
<span class="line-removed">334     _process_completed_buffers = true;</span>
<span class="line-removed">335     if (_notify_when_complete) {</span>
<span class="line-removed">336       _cbl_mon-&gt;notify();</span>
<span class="line-removed">337     }</span>
<span class="line-removed">338   }</span>
<span class="line-removed">339   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">340 }</span>
<span class="line-removed">341 </span>
<span class="line-removed">342 BufferNode* PtrQueueSet::get_completed_buffer(size_t stop_at) {</span>
<span class="line-removed">343   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">344 </span>
<span class="line-removed">345   if (_n_completed_buffers &lt;= stop_at) {</span>
<span class="line-removed">346     return NULL;</span>
<span class="line-removed">347   }</span>
<span class="line-removed">348 </span>
<span class="line-removed">349   assert(_n_completed_buffers &gt; 0, &quot;invariant&quot;);</span>
<span class="line-removed">350   assert(_completed_buffers_head != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">351   assert(_completed_buffers_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">352 </span>
<span class="line-removed">353   BufferNode* bn = _completed_buffers_head;</span>
<span class="line-removed">354   _n_completed_buffers--;</span>
<span class="line-removed">355   _completed_buffers_head = bn-&gt;next();</span>
<span class="line-removed">356   if (_completed_buffers_head == NULL) {</span>
<span class="line-removed">357     assert(_n_completed_buffers == 0, &quot;invariant&quot;);</span>
<span class="line-removed">358     _completed_buffers_tail = NULL;</span>
<span class="line-removed">359     _process_completed_buffers = false;</span>
<span class="line-removed">360   }</span>
<span class="line-removed">361   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">362   bn-&gt;set_next(NULL);</span>
<span class="line-removed">363   return bn;</span>
<span class="line-removed">364 }</span>
<span class="line-removed">365 </span>
<span class="line-removed">366 void PtrQueueSet::abandon_completed_buffers() {</span>
<span class="line-removed">367   BufferNode* buffers_to_delete = NULL;</span>
<span class="line-removed">368   {</span>
<span class="line-removed">369     MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">370     buffers_to_delete = _completed_buffers_head;</span>
<span class="line-removed">371     _completed_buffers_head = NULL;</span>
<span class="line-removed">372     _completed_buffers_tail = NULL;</span>
<span class="line-removed">373     _n_completed_buffers = 0;</span>
<span class="line-removed">374     _process_completed_buffers = false;</span>
<span class="line-removed">375   }</span>
<span class="line-removed">376   while (buffers_to_delete != NULL) {</span>
<span class="line-removed">377     BufferNode* bn = buffers_to_delete;</span>
<span class="line-removed">378     buffers_to_delete = bn-&gt;next();</span>
<span class="line-removed">379     bn-&gt;set_next(NULL);</span>
<span class="line-removed">380     deallocate_buffer(bn);</span>
<span class="line-removed">381   }</span>
<span class="line-removed">382 }</span>
<span class="line-removed">383 </span>
<span class="line-removed">384 #ifdef ASSERT</span>
<span class="line-removed">385 </span>
<span class="line-removed">386 void PtrQueueSet::assert_completed_buffers_list_len_correct_locked() {</span>
<span class="line-removed">387   assert_lock_strong(_cbl_mon);</span>
<span class="line-removed">388   size_t n = 0;</span>
<span class="line-removed">389   for (BufferNode* bn = _completed_buffers_head; bn != NULL; bn = bn-&gt;next()) {</span>
<span class="line-removed">390     ++n;</span>
<span class="line-removed">391   }</span>
<span class="line-removed">392   assert(n == _n_completed_buffers,</span>
<span class="line-removed">393          &quot;Completed buffer length is wrong: counted: &quot; SIZE_FORMAT</span>
<span class="line-removed">394          &quot;, expected: &quot; SIZE_FORMAT, n, _n_completed_buffers);</span>
<span class="line-removed">395 }</span>
<span class="line-removed">396 </span>
<span class="line-removed">397 #endif // ASSERT</span>
<span class="line-removed">398 </span>
<span class="line-removed">399 // Merge lists of buffers. Notify the processing threads.</span>
<span class="line-removed">400 // The source queue is emptied as a result. The queues</span>
<span class="line-removed">401 // must share the monitor.</span>
<span class="line-removed">402 void PtrQueueSet::merge_bufferlists(PtrQueueSet *src) {</span>
<span class="line-removed">403   assert(_cbl_mon == src-&gt;_cbl_mon, &quot;Should share the same lock&quot;);</span>
<span class="line-removed">404   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">405   if (_completed_buffers_tail == NULL) {</span>
<span class="line-removed">406     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="line-removed">407     _completed_buffers_head = src-&gt;_completed_buffers_head;</span>
<span class="line-removed">408     _completed_buffers_tail = src-&gt;_completed_buffers_tail;</span>
<span class="line-removed">409   } else {</span>
<span class="line-removed">410     assert(_completed_buffers_head != NULL, &quot;Well formedness&quot;);</span>
<span class="line-removed">411     if (src-&gt;_completed_buffers_head != NULL) {</span>
<span class="line-removed">412       _completed_buffers_tail-&gt;set_next(src-&gt;_completed_buffers_head);</span>
<span class="line-removed">413       _completed_buffers_tail = src-&gt;_completed_buffers_tail;</span>
<span class="line-removed">414     }</span>
<span class="line-removed">415   }</span>
<span class="line-removed">416   _n_completed_buffers += src-&gt;_n_completed_buffers;</span>
<span class="line-removed">417 </span>
<span class="line-removed">418   src-&gt;_n_completed_buffers = 0;</span>
<span class="line-removed">419   src-&gt;_completed_buffers_head = NULL;</span>
<span class="line-removed">420   src-&gt;_completed_buffers_tail = NULL;</span>
<span class="line-removed">421   src-&gt;_process_completed_buffers = false;</span>
<span class="line-removed">422 </span>
<span class="line-removed">423   assert(_completed_buffers_head == NULL &amp;&amp; _completed_buffers_tail == NULL ||</span>
<span class="line-removed">424          _completed_buffers_head != NULL &amp;&amp; _completed_buffers_tail != NULL,</span>
<span class="line-removed">425          &quot;Sanity&quot;);</span>
<span class="line-removed">426   assert_completed_buffers_list_len_correct_locked();</span>
<span class="line-removed">427 }</span>
<span class="line-removed">428 </span>
<span class="line-removed">429 void PtrQueueSet::notify_if_necessary() {</span>
<span class="line-removed">430   MutexLockerEx x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="line-removed">431   if (_n_completed_buffers &gt; _process_completed_buffers_threshold) {</span>
<span class="line-removed">432     _process_completed_buffers = true;</span>
<span class="line-removed">433     if (_notify_when_complete)</span>
<span class="line-removed">434       _cbl_mon-&gt;notify();</span>
<span class="line-removed">435   }</span>
<span class="line-removed">436 }</span>
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
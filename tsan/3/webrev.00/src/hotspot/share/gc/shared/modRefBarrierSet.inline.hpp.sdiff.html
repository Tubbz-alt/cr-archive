<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/modRefBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="modRefBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/modRefBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50   HeapWord* aligned_end   = align_up  (end,   HeapWordSize);
 51   // If compressed oops were not being used, these should already be aligned
 52   assert(UseCompressedOops || (aligned_start == start &amp;&amp; aligned_end == end),
 53          &quot;Expected heap word alignment of start and end&quot;);
 54   write_ref_array_work(MemRegion(aligned_start, aligned_end));
 55 }
 56 
 57 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 58 template &lt;typename T&gt;
 59 inline void ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
 60 oop_store_in_heap(T* addr, oop value) {
 61   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 62   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
 63   Raw::oop_store(addr, value);
 64   bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, value);
 65 }
 66 
 67 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 68 template &lt;typename T&gt;
 69 inline oop ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
<span class="line-modified"> 70 oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
 71   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 72   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
<span class="line-modified"> 73   oop result = Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
 74   if (result == compare_value) {
 75     bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, new_value);
 76   }
 77   return result;
 78 }
 79 
 80 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 81 template &lt;typename T&gt;
 82 inline oop ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
<span class="line-modified"> 83 oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
 84   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 85   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
<span class="line-modified"> 86   oop result = Raw::oop_atomic_xchg(new_value, addr);</span>
 87   bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, new_value);
 88   return result;
 89 }
 90 
 91 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 92 template &lt;typename T&gt;
 93 inline bool ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
 94 oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 95                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 96                       size_t length) {
 97   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 98 
 99   src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
100   dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
101 
102   if (!HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value) {
103     // Optimized covariant case
104     bs-&gt;write_ref_array_pre(dst_raw, length,
105                             HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value);
106     Raw::oop_arraycopy(NULL, 0, src_raw, NULL, 0, dst_raw, length);
</pre>
</td>
<td>
<hr />
<pre>
 50   HeapWord* aligned_end   = align_up  (end,   HeapWordSize);
 51   // If compressed oops were not being used, these should already be aligned
 52   assert(UseCompressedOops || (aligned_start == start &amp;&amp; aligned_end == end),
 53          &quot;Expected heap word alignment of start and end&quot;);
 54   write_ref_array_work(MemRegion(aligned_start, aligned_end));
 55 }
 56 
 57 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 58 template &lt;typename T&gt;
 59 inline void ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
 60 oop_store_in_heap(T* addr, oop value) {
 61   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 62   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
 63   Raw::oop_store(addr, value);
 64   bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, value);
 65 }
 66 
 67 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 68 template &lt;typename T&gt;
 69 inline oop ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
<span class="line-modified"> 70 oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
 71   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 72   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
<span class="line-modified"> 73   oop result = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
 74   if (result == compare_value) {
 75     bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, new_value);
 76   }
 77   return result;
 78 }
 79 
 80 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 81 template &lt;typename T&gt;
 82 inline oop ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
<span class="line-modified"> 83 oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
 84   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 85   bs-&gt;template write_ref_field_pre&lt;decorators&gt;(addr);
<span class="line-modified"> 86   oop result = Raw::oop_atomic_xchg(addr, new_value);</span>
 87   bs-&gt;template write_ref_field_post&lt;decorators&gt;(addr, new_value);
 88   return result;
 89 }
 90 
 91 template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
 92 template &lt;typename T&gt;
 93 inline bool ModRefBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::
 94 oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
 95                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
 96                       size_t length) {
 97   BarrierSetT *bs = barrier_set_cast&lt;BarrierSetT&gt;(barrier_set());
 98 
 99   src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);
100   dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);
101 
102   if (!HasDecorator&lt;decorators, ARRAYCOPY_CHECKCAST&gt;::value) {
103     // Optimized covariant case
104     bs-&gt;write_ref_array_pre(dst_raw, length,
105                             HasDecorator&lt;decorators, IS_DEST_UNINITIALIZED&gt;::value);
106     Raw::oop_arraycopy(NULL, 0, src_raw, NULL, 0, dst_raw, length);
</pre>
</td>
</tr>
</table>
<center><a href="modRefBarrierSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
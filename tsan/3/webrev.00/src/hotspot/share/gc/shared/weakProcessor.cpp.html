<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/weakProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
 28 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
 29 #include &quot;gc/shared/oopStorageSet.hpp&quot;
 30 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 31 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 32 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/iterator.hpp&quot;
 35 #include &quot;prims/resolvedMethodTable.hpp&quot;
 36 #include &quot;runtime/globals.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
 39 template &lt;typename Container&gt;
 40 class OopsDoAndReportCounts {
 41 public:
 42   void operator()(BoolObjectClosure* is_alive, OopClosure* keep_alive, OopStorage* storage) {
 43     Container::reset_dead_counter();
 44 
 45     CountingSkippedIsAliveClosure&lt;BoolObjectClosure, OopClosure&gt; cl(is_alive, keep_alive);
 46     storage-&gt;oops_do(&amp;cl);
 47 
 48     Container::inc_dead_counter(cl.num_dead() + cl.num_skipped());
 49     Container::finish_dead_counter();
 50   }
 51 };
 52 
 53 void WeakProcessor::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive) {
 54   WeakProcessorPhases::Iterator pit = WeakProcessorPhases::serial_iterator();
 55   for ( ; !pit.is_end(); ++pit) {
 56     WeakProcessorPhases::processor(*pit)(is_alive, keep_alive);
 57   }
 58 
 59   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();
 60   for ( ; !it.is_end(); ++it) {
 61     if (OopStorageSet::string_table_weak() == *it) {
 62       OopsDoAndReportCounts&lt;StringTable&gt;()(is_alive, keep_alive, *it);
 63     } else if (OopStorageSet::resolved_method_table_weak() == *it) {
 64       OopsDoAndReportCounts&lt;ResolvedMethodTable&gt;()(is_alive, keep_alive, *it);
 65     } else {
 66       it-&gt;weak_oops_do(is_alive, keep_alive);
 67     }
 68   }
 69 }
 70 
 71 void WeakProcessor::oops_do(OopClosure* closure) {
 72   AlwaysTrueClosure always_true;
 73   weak_oops_do(&amp;always_true, closure);
 74 }
 75 
 76 uint WeakProcessor::ergo_workers(uint max_workers) {
 77   // Ignore ParallelRefProcEnabled; that&#39;s for j.l.r.Reference processing.
 78   if (ReferencesPerThread == 0) {
 79     // Configuration says always use all the threads.
 80     return max_workers;
 81   }
 82 
 83   // One thread per ReferencesPerThread references (or fraction thereof)
 84   // in the various OopStorage objects, bounded by max_threads.
 85   //
 86   // Serial phases are ignored in this calculation, because of the
 87   // cost of running unnecessary threads.  These phases are normally
 88   // small or empty (assuming they are configured to exist at all),
 89   // and development oriented, so not allocating any threads
 90   // specifically for them is okay.
 91   size_t ref_count = 0;
 92   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();
 93   for ( ; !it.is_end(); ++it) {
 94     ref_count += it-&gt;allocation_count();
 95   }
 96 
 97   // +1 to (approx) round up the ref per thread division.
 98   size_t nworkers = 1 + (ref_count / ReferencesPerThread);
 99   nworkers = MIN2(nworkers, static_cast&lt;size_t&gt;(max_workers));
100   return static_cast&lt;uint&gt;(nworkers);
101 }
102 
103 void WeakProcessor::Task::initialize() {
104   assert(_nworkers != 0, &quot;must be&quot;);
105   assert(_phase_times == NULL || _nworkers &lt;= _phase_times-&gt;max_threads(),
106          &quot;nworkers (%u) exceeds max threads (%u)&quot;,
107          _nworkers, _phase_times-&gt;max_threads());
108 
109   if (_phase_times) {
110     _phase_times-&gt;set_active_workers(_nworkers);
111   }
112 
113   uint storage_count = WeakProcessorPhases::oopstorage_phase_count;
114   _storage_states = NEW_C_HEAP_ARRAY(StorageState, storage_count, mtGC);
115 
116   StorageState* cur_state = _storage_states;
117   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();
118   for ( ; !it.is_end(); ++it, ++cur_state) {
119     assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) &lt; storage_count, &quot;invariant&quot;);
120     new (cur_state) StorageState(*it, _nworkers);
121   }
122   assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) == storage_count, &quot;invariant&quot;);
123   StringTable::reset_dead_counter();
124   ResolvedMethodTable::reset_dead_counter();
125 }
126 
127 WeakProcessor::Task::Task(uint nworkers) :
128   _phase_times(NULL),
129   _nworkers(nworkers),
130   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
131   _storage_states(NULL)
132 {
133   initialize();
134 }
135 
136 WeakProcessor::Task::Task(WeakProcessorPhaseTimes* phase_times, uint nworkers) :
137   _phase_times(phase_times),
138   _nworkers(nworkers),
139   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
140   _storage_states(NULL)
141 {
142   initialize();
143 }
144 
145 WeakProcessor::Task::~Task() {
146   if (_storage_states != NULL) {
147     StorageState* states = _storage_states;
148     for (uint i = 0; i &lt; WeakProcessorPhases::oopstorage_phase_count; ++i) {
149       states-&gt;StorageState::~StorageState();
150       ++states;
151     }
152     FREE_C_HEAP_ARRAY(StorageState, _storage_states);
153   }
154   StringTable::finish_dead_counter();
155   ResolvedMethodTable::finish_dead_counter();
156 }
157 
158 void WeakProcessor::GangTask::work(uint worker_id) {
159   _erased_do_work(this, worker_id);
160 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/c1/barrierSetC1.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../blockOffsetTable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../c2/barrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c1/barrierSetC1.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83     _resolved_addr(NULL),
 84     _patch_emit_info(patch_emit_info),
 85     _access_emit_info(access_emit_info) {}
 86 
 87   void load_base()   { _base.item().load_item(); }
 88   void load_offset() { _offset.item().load_nonconstant(); }
 89 
 90   void load_address() {
 91     load_base();
 92     load_offset();
 93   }
 94 
 95   LIRGenerator* gen() const              { return _gen; }
 96   CodeEmitInfo*&amp; patch_emit_info()       { return _patch_emit_info; }
 97   CodeEmitInfo*&amp; access_emit_info()      { return _access_emit_info; }
 98   LIRAddressOpr&amp; base()                  { return _base; }
 99   LIRAddressOpr&amp; offset()                { return _offset; }
100   BasicType type() const                 { return _type; }
101   LIR_Opr resolved_addr() const          { return _resolved_addr; }
102   void set_resolved_addr(LIR_Opr addr)   { _resolved_addr = addr; }
<span class="line-modified">103   bool is_oop() const                    { return _type == T_ARRAY || _type == T_OBJECT; }</span>
104   DecoratorSet decorators() const        { return _decorators; }
105   void clear_decorators(DecoratorSet ds) { _decorators &amp;= ~ds; }
106   bool is_raw() const                    { return (_decorators &amp; AS_RAW) != 0; }
107 };
108 
109 // The BarrierSetC1 class is the main entry point for the GC backend of the Access API in C1.
110 // It is called by the LIRGenerator::access_* functions, which is the main entry poing for
111 // access calls in C1.
112 
113 class BarrierSetC1: public CHeapObj&lt;mtGC&gt; {
114 protected:
115   virtual LIR_Opr resolve_address(LIRAccess&amp; access, bool resolve_in_register);
116 
117   virtual void generate_referent_check(LIRAccess&amp; access, LabelObj* cont);
118 
119   // Accesses with resolved address
120   virtual void store_at_resolved(LIRAccess&amp; access, LIR_Opr value);
121   virtual void load_at_resolved(LIRAccess&amp; access, LIR_Opr result);
122 
123   virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
124 
125   virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; value);
126   virtual LIR_Opr atomic_add_at_resolved(LIRAccess&amp; access, LIRItem&amp; value);
127 
128 public:
129   virtual void store_at(LIRAccess&amp; access, LIR_Opr value);
130   virtual void load_at(LIRAccess&amp; access, LIR_Opr result);
131   virtual void load(LIRAccess&amp; access, LIR_Opr result);
132 
133   virtual LIR_Opr atomic_cmpxchg_at(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
134 
135   virtual LIR_Opr atomic_xchg_at(LIRAccess&amp; access, LIRItem&amp; value);
136   virtual LIR_Opr atomic_add_at(LIRAccess&amp; access, LIRItem&amp; value);
137 
138   virtual LIR_Opr resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj);
139 


140   virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob) {}
141 };
142 
143 #endif // SHARE_GC_SHARED_C1_BARRIERSETC1_HPP
</pre>
</td>
<td>
<hr />
<pre>
 83     _resolved_addr(NULL),
 84     _patch_emit_info(patch_emit_info),
 85     _access_emit_info(access_emit_info) {}
 86 
 87   void load_base()   { _base.item().load_item(); }
 88   void load_offset() { _offset.item().load_nonconstant(); }
 89 
 90   void load_address() {
 91     load_base();
 92     load_offset();
 93   }
 94 
 95   LIRGenerator* gen() const              { return _gen; }
 96   CodeEmitInfo*&amp; patch_emit_info()       { return _patch_emit_info; }
 97   CodeEmitInfo*&amp; access_emit_info()      { return _access_emit_info; }
 98   LIRAddressOpr&amp; base()                  { return _base; }
 99   LIRAddressOpr&amp; offset()                { return _offset; }
100   BasicType type() const                 { return _type; }
101   LIR_Opr resolved_addr() const          { return _resolved_addr; }
102   void set_resolved_addr(LIR_Opr addr)   { _resolved_addr = addr; }
<span class="line-modified">103   bool is_oop() const                    { return is_reference_type(_type); }</span>
104   DecoratorSet decorators() const        { return _decorators; }
105   void clear_decorators(DecoratorSet ds) { _decorators &amp;= ~ds; }
106   bool is_raw() const                    { return (_decorators &amp; AS_RAW) != 0; }
107 };
108 
109 // The BarrierSetC1 class is the main entry point for the GC backend of the Access API in C1.
110 // It is called by the LIRGenerator::access_* functions, which is the main entry poing for
111 // access calls in C1.
112 
113 class BarrierSetC1: public CHeapObj&lt;mtGC&gt; {
114 protected:
115   virtual LIR_Opr resolve_address(LIRAccess&amp; access, bool resolve_in_register);
116 
117   virtual void generate_referent_check(LIRAccess&amp; access, LabelObj* cont);
118 
119   // Accesses with resolved address
120   virtual void store_at_resolved(LIRAccess&amp; access, LIR_Opr value);
121   virtual void load_at_resolved(LIRAccess&amp; access, LIR_Opr result);
122 
123   virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
124 
125   virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess&amp; access, LIRItem&amp; value);
126   virtual LIR_Opr atomic_add_at_resolved(LIRAccess&amp; access, LIRItem&amp; value);
127 
128 public:
129   virtual void store_at(LIRAccess&amp; access, LIR_Opr value);
130   virtual void load_at(LIRAccess&amp; access, LIR_Opr result);
131   virtual void load(LIRAccess&amp; access, LIR_Opr result);
132 
133   virtual LIR_Opr atomic_cmpxchg_at(LIRAccess&amp; access, LIRItem&amp; cmp_value, LIRItem&amp; new_value);
134 
135   virtual LIR_Opr atomic_xchg_at(LIRAccess&amp; access, LIRItem&amp; value);
136   virtual LIR_Opr atomic_add_at(LIRAccess&amp; access, LIRItem&amp; value);
137 
138   virtual LIR_Opr resolve(LIRGenerator* gen, DecoratorSet decorators, LIR_Opr obj);
139 
<span class="line-added">140   virtual const char* rtcall_name_for_address(address entry) { return NULL; }</span>
<span class="line-added">141 </span>
142   virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob) {}
143 };
144 
145 #endif // SHARE_GC_SHARED_C1_BARRIERSETC1_HPP
</pre>
</td>
</tr>
</table>
<center><a href="../blockOffsetTable.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../c2/barrierSetC2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcLocker.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcLocker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcLocker.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GCLOCKER_HPP
 26 #define SHARE_GC_SHARED_GCLOCKER_HPP
 27 

 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 #include &quot;utilities/macros.hpp&quot;
 31 
 32 class JavaThread;
 33 
 34 // The direct lock/unlock calls do not force a collection if an unlock
 35 // decrements the count to zero. Avoid calling these if at all possible.
 36 
 37 class GCLocker: public AllStatic {
 38  private:
 39   // The _jni_lock_count keeps track of the number of threads that are
 40   // currently in a critical region.  It&#39;s only kept up to date when
 41   // _needs_gc is true.  The current value is computed during
 42   // safepointing and decremented during the slow path of GCLocker
 43   // unlocking.
 44   static volatile jint _jni_lock_count;  // number of jni active instances.
 45   static volatile bool _needs_gc;        // heap is filling, we need a GC
 46                                          // note: bool is typedef&#39;d as jint
 47   static volatile bool _doing_gc;        // unlock_critical() is doing a GC

 48 
 49 #ifdef ASSERT
 50   // This lock count is updated for all operations and is used to
 51   // validate the jni_lock_count that is computed during safepoints.
 52   static volatile jint _debug_jni_lock_count;
 53 #endif
 54 
 55   // At a safepoint, visit all threads and count the number of active
 56   // critical sections.  This is used to ensure that all active
 57   // critical sections are exited before a new one is started.
 58   static void verify_critical_count() NOT_DEBUG_RETURN;
 59 
 60   static void jni_lock(JavaThread* thread);
 61   static void jni_unlock(JavaThread* thread);
 62 
 63   static bool is_active_internal() {
 64     verify_critical_count();
 65     return _jni_lock_count &gt; 0;
 66   }
 67 
</pre>
<hr />
<pre>
 81   static bool is_active_and_needs_gc() {
 82     // Use is_active_internal since _needs_gc can change from true to
 83     // false outside of a safepoint, triggering the assert in
 84     // is_active.
 85     return needs_gc() &amp;&amp; is_active_internal();
 86   }
 87 
 88   // In debug mode track the locking state at all times
 89   static void increment_debug_jni_lock_count() NOT_DEBUG_RETURN;
 90   static void decrement_debug_jni_lock_count() NOT_DEBUG_RETURN;
 91 
 92   // Set the current lock count
 93   static void set_jni_lock_count(int count) {
 94     _jni_lock_count = count;
 95     verify_critical_count();
 96   }
 97 
 98   // Sets _needs_gc if is_active() is true. Returns is_active().
 99   static bool check_active_before_gc();
100 






101   // Stalls the caller (who should not be in a jni critical section)
102   // until needs_gc() clears. Note however that needs_gc() may be
103   // set at a subsequent safepoint and/or cleared under the
104   // JNICritical_lock, so the caller may not safely assert upon
105   // return from this method that &quot;!needs_gc()&quot; since that is
106   // not a stable predicate.
107   static void stall_until_clear();
108 
109   // The following two methods are used for JNI critical regions.
110   // If we find that we failed to perform a GC because the GCLocker
111   // was active, arrange for one as soon as possible by allowing
112   // all threads in critical regions to complete, but not allowing
113   // other critical regions to be entered. The reasons for that are:
114   // 1) a GC request won&#39;t be starved by overlapping JNI critical
115   //    region activities, which can cause unnecessary OutOfMemory errors.
116   // 2) even if allocation requests can still be satisfied before GC locker
117   //    becomes inactive, for example, in tenured generation possibly with
118   //    heap expansion, those allocations can trigger lots of safepointing
119   //    attempts (ineffective GC attempts) and require Heap_lock which
120   //    slow down allocations tremendously.
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GCLOCKER_HPP
 26 #define SHARE_GC_SHARED_GCLOCKER_HPP
 27 
<span class="line-added"> 28 #include &quot;gc/shared/gcCause.hpp&quot;</span>
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 
 33 class JavaThread;
 34 
 35 // The direct lock/unlock calls do not force a collection if an unlock
 36 // decrements the count to zero. Avoid calling these if at all possible.
 37 
 38 class GCLocker: public AllStatic {
 39  private:
 40   // The _jni_lock_count keeps track of the number of threads that are
 41   // currently in a critical region.  It&#39;s only kept up to date when
 42   // _needs_gc is true.  The current value is computed during
 43   // safepointing and decremented during the slow path of GCLocker
 44   // unlocking.
 45   static volatile jint _jni_lock_count;  // number of jni active instances.
 46   static volatile bool _needs_gc;        // heap is filling, we need a GC
 47                                          // note: bool is typedef&#39;d as jint
 48   static volatile bool _doing_gc;        // unlock_critical() is doing a GC
<span class="line-added"> 49   static uint _total_collections;        // value for _gc_locker collection</span>
 50 
 51 #ifdef ASSERT
 52   // This lock count is updated for all operations and is used to
 53   // validate the jni_lock_count that is computed during safepoints.
 54   static volatile jint _debug_jni_lock_count;
 55 #endif
 56 
 57   // At a safepoint, visit all threads and count the number of active
 58   // critical sections.  This is used to ensure that all active
 59   // critical sections are exited before a new one is started.
 60   static void verify_critical_count() NOT_DEBUG_RETURN;
 61 
 62   static void jni_lock(JavaThread* thread);
 63   static void jni_unlock(JavaThread* thread);
 64 
 65   static bool is_active_internal() {
 66     verify_critical_count();
 67     return _jni_lock_count &gt; 0;
 68   }
 69 
</pre>
<hr />
<pre>
 83   static bool is_active_and_needs_gc() {
 84     // Use is_active_internal since _needs_gc can change from true to
 85     // false outside of a safepoint, triggering the assert in
 86     // is_active.
 87     return needs_gc() &amp;&amp; is_active_internal();
 88   }
 89 
 90   // In debug mode track the locking state at all times
 91   static void increment_debug_jni_lock_count() NOT_DEBUG_RETURN;
 92   static void decrement_debug_jni_lock_count() NOT_DEBUG_RETURN;
 93 
 94   // Set the current lock count
 95   static void set_jni_lock_count(int count) {
 96     _jni_lock_count = count;
 97     verify_critical_count();
 98   }
 99 
100   // Sets _needs_gc if is_active() is true. Returns is_active().
101   static bool check_active_before_gc();
102 
<span class="line-added">103   // Return true if the designated collection is a GCLocker request</span>
<span class="line-added">104   // that should be discarded.  Returns true if cause == GCCause::_gc_locker</span>
<span class="line-added">105   // and the given total collection value indicates a collection has been</span>
<span class="line-added">106   // done since the GCLocker request was made.</span>
<span class="line-added">107   static bool should_discard(GCCause::Cause cause, uint total_collections);</span>
<span class="line-added">108 </span>
109   // Stalls the caller (who should not be in a jni critical section)
110   // until needs_gc() clears. Note however that needs_gc() may be
111   // set at a subsequent safepoint and/or cleared under the
112   // JNICritical_lock, so the caller may not safely assert upon
113   // return from this method that &quot;!needs_gc()&quot; since that is
114   // not a stable predicate.
115   static void stall_until_clear();
116 
117   // The following two methods are used for JNI critical regions.
118   // If we find that we failed to perform a GC because the GCLocker
119   // was active, arrange for one as soon as possible by allowing
120   // all threads in critical regions to complete, but not allowing
121   // other critical regions to be entered. The reasons for that are:
122   // 1) a GC request won&#39;t be starved by overlapping JNI critical
123   //    region activities, which can cause unnecessary OutOfMemory errors.
124   // 2) even if allocation requests can still be satisfied before GC locker
125   //    becomes inactive, for example, in tenured generation possibly with
126   //    heap expansion, those allocations can trigger lots of safepointing
127   //    attempts (ineffective GC attempts) and require Heap_lock which
128   //    slow down allocations tremendously.
</pre>
</td>
</tr>
</table>
<center><a href="gcLocker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
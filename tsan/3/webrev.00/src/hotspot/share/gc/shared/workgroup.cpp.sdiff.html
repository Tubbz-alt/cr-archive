<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/workgroup.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="workerPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workgroup.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/workgroup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/gcId.hpp&quot;
 27 #include &quot;gc/shared/workgroup.hpp&quot;
 28 #include &quot;gc/shared/workerManager.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;

 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/semaphore.hpp&quot;
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 
 36 // Definitions of WorkGang methods.
 37 
 38 // The current implementation will exit if the allocation
 39 // of any worker fails.
 40 void  AbstractWorkGang::initialize_workers() {
 41   log_develop_trace(gc, workgang)(&quot;Constructing work gang %s with %u threads&quot;, name(), total_workers());
 42   _workers = NEW_C_HEAP_ARRAY(AbstractGangWorker*, total_workers(), mtInternal);
<span class="line-removed"> 43   if (_workers == NULL) {</span>
<span class="line-removed"> 44     vm_exit_out_of_memory(0, OOM_MALLOC_ERROR, &quot;Cannot create GangWorker array.&quot;);</span>
<span class="line-removed"> 45   }</span>
<span class="line-removed"> 46 </span>
 47   add_workers(true);
 48 }
 49 
 50 
 51 AbstractGangWorker* AbstractWorkGang::install_worker(uint worker_id) {
 52   AbstractGangWorker* new_worker = allocate_worker(worker_id);
 53   set_thread(worker_id, new_worker);
 54   return new_worker;
 55 }
 56 
 57 void AbstractWorkGang::add_workers(bool initializing) {
 58   add_workers(_active_workers, initializing);
 59 }
 60 
 61 void AbstractWorkGang::add_workers(uint active_workers, bool initializing) {
 62 
 63   os::ThreadType worker_type;
 64   if (are_ConcurrentGC_threads()) {
 65     worker_type = os::cgc_thread;
 66   } else {
</pre>
<hr />
<pre>
140     _task         = task;
141     _not_finished = num_workers;
142 
143     // Dispatch &#39;num_workers&#39; number of tasks.
144     _start_semaphore-&gt;signal(num_workers);
145 
146     // Wait for the last worker to signal the coordinator.
147     _end_semaphore-&gt;wait();
148 
149     // No workers are allowed to read the state variables after the coordinator has been signaled.
150     assert(_not_finished == 0, &quot;%d not finished workers?&quot;, _not_finished);
151     _task    = NULL;
152     _started = 0;
153 
154   }
155 
156   WorkData worker_wait_for_task() {
157     // Wait for the coordinator to dispatch a task.
158     _start_semaphore-&gt;wait();
159 
<span class="line-modified">160     uint num_started = Atomic::add(1u, &amp;_started);</span>
161 
162     // Subtract one to get a zero-indexed worker id.
163     uint worker_id = num_started - 1;
164 
165     return WorkData(_task, worker_id);
166   }
167 
168   void worker_done_with_task() {
169     // Mark that the worker is done with the task.
170     // The worker is not allowed to read the state variables after this line.
<span class="line-modified">171     uint not_finished = Atomic::sub(1u, &amp;_not_finished);</span>
172 
173     // The last worker signals to the coordinator that all work is completed.
174     if (not_finished == 0) {
175       _end_semaphore-&gt;signal();
176     }
177   }
178 };
179 
180 class MutexGangTaskDispatcher : public GangTaskDispatcher {
181   AbstractGangTask* _task;
182 
183   volatile uint _started;
184   volatile uint _finished;
185   volatile uint _num_workers;
186 
187   Monitor* _monitor;
188 
189  public:
190   MutexGangTaskDispatcher() :
191     _task(NULL),
192     _started(0),
193     _finished(0),
194     _num_workers(0),
195     _monitor(new Monitor(Monitor::leaf, &quot;WorkGang dispatcher lock&quot;, false, Monitor::_safepoint_check_never)) {
196   }
197 
198   ~MutexGangTaskDispatcher() {
199     delete _monitor;
200   }
201 
202   void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {
<span class="line-modified">203     MutexLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
204 
205     _task        = task;
206     _num_workers = num_workers;
207 
208     // Tell the workers to get to work.
209     _monitor-&gt;notify_all();
210 
211     // Wait for them to finish.
212     while (_finished &lt; _num_workers) {
<span class="line-modified">213       _monitor-&gt;wait(/* no_safepoint_check */ true);</span>
214     }
215 
216     _task        = NULL;
217     _num_workers = 0;
218     _started     = 0;
219     _finished    = 0;
220   }
221 
222   WorkData worker_wait_for_task() {
<span class="line-modified">223     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
224 
225     while (_num_workers == 0 || _started == _num_workers) {
<span class="line-modified">226       _monitor-&gt;wait(/* no_safepoint_check */ true);</span>
227     }
228 
229     _started++;
230 
231     // Subtract one to get a zero-indexed worker id.
232     uint worker_id = _started - 1;
233 
234     return WorkData(_task, worker_id);
235   }
236 
237   void worker_done_with_task() {
<span class="line-modified">238     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
239 
240     _finished++;
241 
242     if (_finished == _num_workers) {
243       // This will wake up all workers and not only the coordinator.
244       _monitor-&gt;notify_all();
245     }
246   }
247 };
248 
249 static GangTaskDispatcher* create_dispatcher() {
250   if (UseSemaphoreGCThreadsSynchronization) {
251     return new SemaphoreGangTaskDispatcher();
252   }
253 
254   return new MutexGangTaskDispatcher();
255 }
256 
257 WorkGang::WorkGang(const char* name,
258                    uint  workers,
</pre>
<hr />
<pre>
283   update_active_workers(num_workers);
284   _dispatcher-&gt;coordinator_execute_on_workers(task, num_workers);
285   update_active_workers(old_num_workers);
286 }
287 
288 AbstractGangWorker::AbstractGangWorker(AbstractWorkGang* gang, uint id) {
289   _gang = gang;
290   set_id(id);
291   set_name(&quot;%s#%d&quot;, gang-&gt;name(), id);
292 }
293 
294 void AbstractGangWorker::run() {
295   initialize();
296   loop();
297 }
298 
299 void AbstractGangWorker::initialize() {
300   assert(_gang != NULL, &quot;No gang to run in&quot;);
301   os::set_priority(this, NearMaxPriority);
302   log_develop_trace(gc, workgang)(&quot;Running gang worker for gang %s id %u&quot;, gang()-&gt;name(), id());
<span class="line-removed">303   // The VM thread should not execute here because MutexLocker&#39;s are used</span>
<span class="line-removed">304   // as (opposed to MutexLockerEx&#39;s).</span>
305   assert(!Thread::current()-&gt;is_VM_thread(), &quot;VM thread should not be part&quot;
306          &quot; of a work gang&quot;);
307 }
308 
309 bool AbstractGangWorker::is_GC_task_thread() const {
310   return gang()-&gt;are_GC_task_threads();
311 }
312 
313 bool AbstractGangWorker::is_ConcurrentGC_thread() const {
314   return gang()-&gt;are_ConcurrentGC_threads();
315 }
316 
317 void AbstractGangWorker::print_on(outputStream* st) const {
318   st-&gt;print(&quot;\&quot;%s\&quot; &quot;, name());
319   Thread::print_on(st);
320   st-&gt;cr();
321 }
322 


323 WorkData GangWorker::wait_for_task() {
324   return gang()-&gt;dispatcher()-&gt;worker_wait_for_task();
325 }
326 
327 void GangWorker::signal_task_done() {
328   gang()-&gt;dispatcher()-&gt;worker_done_with_task();
329 }
330 
331 void GangWorker::run_task(WorkData data) {
332   GCIdMark gc_id_mark(data._task-&gt;gc_id());
333   log_develop_trace(gc, workgang)(&quot;Running work gang: %s task: %s worker: %u&quot;, name(), data._task-&gt;name(), data._worker_id);
334 
335   data._task-&gt;work(data._worker_id);
336 
337   log_develop_trace(gc, workgang)(&quot;Finished work gang: %s task: %s worker: %u thread: &quot; PTR_FORMAT,
338                                   name(), data._task-&gt;name(), data._worker_id, p2i(Thread::current()));
339 }
340 
341 void GangWorker::loop() {
342   while (true) {
</pre>
<hr />
<pre>
352 
353 WorkGangBarrierSync::WorkGangBarrierSync()
354   : _monitor(Mutex::safepoint, &quot;work gang barrier sync&quot;, true,
355              Monitor::_safepoint_check_never),
356     _n_workers(0), _n_completed(0), _should_reset(false), _aborted(false) {
357 }
358 
359 WorkGangBarrierSync::WorkGangBarrierSync(uint n_workers, const char* name)
360   : _monitor(Mutex::safepoint, name, true, Monitor::_safepoint_check_never),
361     _n_workers(n_workers), _n_completed(0), _should_reset(false), _aborted(false) {
362 }
363 
364 void WorkGangBarrierSync::set_n_workers(uint n_workers) {
365   _n_workers    = n_workers;
366   _n_completed  = 0;
367   _should_reset = false;
368   _aborted      = false;
369 }
370 
371 bool WorkGangBarrierSync::enter() {
<span class="line-modified">372   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);</span>
373   if (should_reset()) {
374     // The should_reset() was set and we are the first worker to enter
375     // the sync barrier. We will zero the n_completed() count which
376     // effectively resets the barrier.
377     zero_completed();
378     set_should_reset(false);
379   }
380   inc_completed();
381   if (n_completed() == n_workers()) {
382     // At this point we would like to reset the barrier to be ready in
383     // case it is used again. However, we cannot set n_completed() to
384     // 0, even after the notify_all(), given that some other workers
385     // might still be waiting for n_completed() to become ==
386     // n_workers(). So, if we set n_completed() to 0, those workers
387     // will get stuck (as they will wake up, see that n_completed() !=
388     // n_workers() and go back to sleep). Instead, we raise the
389     // should_reset() flag and the barrier will be reset the first
390     // time a worker enters it again.
391     set_should_reset(true);
<span class="line-modified">392     monitor()-&gt;notify_all();</span>
393   } else {
394     while (n_completed() != n_workers() &amp;&amp; !aborted()) {
<span class="line-modified">395       monitor()-&gt;wait(/* no_safepoint_check */ true);</span>
396     }
397   }
398   return !aborted();
399 }
400 
401 void WorkGangBarrierSync::abort() {
<span class="line-modified">402   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);</span>
403   set_aborted();
404   monitor()-&gt;notify_all();
405 }
406 
407 // SubTasksDone functions.
408 
409 SubTasksDone::SubTasksDone(uint n) :
410   _tasks(NULL), _n_tasks(n), _threads_completed(0) {
411   _tasks = NEW_C_HEAP_ARRAY(uint, n, mtInternal);
<span class="line-removed">412   guarantee(_tasks != NULL, &quot;alloc failure&quot;);</span>
413   clear();
414 }
415 
416 bool SubTasksDone::valid() {
417   return _tasks != NULL;
418 }
419 
420 void SubTasksDone::clear() {
421   for (uint i = 0; i &lt; _n_tasks; i++) {
422     _tasks[i] = 0;
423   }
424   _threads_completed = 0;
425 #ifdef ASSERT
426   _claimed = 0;
427 #endif
428 }
429 
430 bool SubTasksDone::try_claim_task(uint t) {
431   assert(t &lt; _n_tasks, &quot;bad task id.&quot;);
432   uint old = _tasks[t];
433   if (old == 0) {
<span class="line-modified">434     old = Atomic::cmpxchg(1u, &amp;_tasks[t], 0u);</span>
435   }
<span class="line-removed">436   assert(_tasks[t] == 1, &quot;What else?&quot;);</span>
437   bool res = old == 0;
438 #ifdef ASSERT
439   if (res) {
440     assert(_claimed &lt; _n_tasks, &quot;Too many tasks claimed; missing clear?&quot;);
441     Atomic::inc(&amp;_claimed);
442   }
443 #endif
444   return res;
445 }
446 
447 void SubTasksDone::all_tasks_completed(uint n_threads) {
448   uint observed = _threads_completed;
449   uint old;
450   do {
451     old = observed;
<span class="line-modified">452     observed = Atomic::cmpxchg(old+1, &amp;_threads_completed, old);</span>
453   } while (observed != old);
454   // If this was the last thread checking in, clear the tasks.
455   uint adjusted_thread_count = (n_threads == 0 ? 1 : n_threads);
456   if (observed + 1 == adjusted_thread_count) {
457     clear();
458   }
459 }
460 
461 
462 SubTasksDone::~SubTasksDone() {
<span class="line-modified">463   if (_tasks != NULL) FREE_C_HEAP_ARRAY(uint, _tasks);</span>
464 }
465 
466 // *** SequentialSubTasksDone
467 
468 void SequentialSubTasksDone::clear() {
469   _n_tasks   = _n_claimed   = 0;
470   _n_threads = _n_completed = 0;
471 }
472 
473 bool SequentialSubTasksDone::valid() {
474   return _n_threads &gt; 0;
475 }
476 
477 bool SequentialSubTasksDone::try_claim_task(uint&amp; t) {
478   t = _n_claimed;
479   while (t &lt; _n_tasks) {
<span class="line-modified">480     uint res = Atomic::cmpxchg(t+1, &amp;_n_claimed, t);</span>
481     if (res == t) {
482       return true;
483     }
484     t = res;
485   }
486   return false;
487 }
488 
489 bool SequentialSubTasksDone::all_tasks_completed() {
490   uint complete = _n_completed;
491   while (true) {
<span class="line-modified">492     uint res = Atomic::cmpxchg(complete+1, &amp;_n_completed, complete);</span>
493     if (res == complete) {
494       break;
495     }
496     complete = res;
497   }
498   if (complete+1 == _n_threads) {
499     clear();
500     return true;
501   }
502   return false;
503 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/gcId.hpp&quot;
 27 #include &quot;gc/shared/workgroup.hpp&quot;
 28 #include &quot;gc/shared/workerManager.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;memory/iterator.hpp&quot;</span>
 32 #include &quot;runtime/atomic.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/semaphore.hpp&quot;
 35 #include &quot;runtime/thread.inline.hpp&quot;
 36 
 37 // Definitions of WorkGang methods.
 38 
 39 // The current implementation will exit if the allocation
 40 // of any worker fails.
 41 void  AbstractWorkGang::initialize_workers() {
 42   log_develop_trace(gc, workgang)(&quot;Constructing work gang %s with %u threads&quot;, name(), total_workers());
 43   _workers = NEW_C_HEAP_ARRAY(AbstractGangWorker*, total_workers(), mtInternal);




 44   add_workers(true);
 45 }
 46 
 47 
 48 AbstractGangWorker* AbstractWorkGang::install_worker(uint worker_id) {
 49   AbstractGangWorker* new_worker = allocate_worker(worker_id);
 50   set_thread(worker_id, new_worker);
 51   return new_worker;
 52 }
 53 
 54 void AbstractWorkGang::add_workers(bool initializing) {
 55   add_workers(_active_workers, initializing);
 56 }
 57 
 58 void AbstractWorkGang::add_workers(uint active_workers, bool initializing) {
 59 
 60   os::ThreadType worker_type;
 61   if (are_ConcurrentGC_threads()) {
 62     worker_type = os::cgc_thread;
 63   } else {
</pre>
<hr />
<pre>
137     _task         = task;
138     _not_finished = num_workers;
139 
140     // Dispatch &#39;num_workers&#39; number of tasks.
141     _start_semaphore-&gt;signal(num_workers);
142 
143     // Wait for the last worker to signal the coordinator.
144     _end_semaphore-&gt;wait();
145 
146     // No workers are allowed to read the state variables after the coordinator has been signaled.
147     assert(_not_finished == 0, &quot;%d not finished workers?&quot;, _not_finished);
148     _task    = NULL;
149     _started = 0;
150 
151   }
152 
153   WorkData worker_wait_for_task() {
154     // Wait for the coordinator to dispatch a task.
155     _start_semaphore-&gt;wait();
156 
<span class="line-modified">157     uint num_started = Atomic::add(&amp;_started, 1u);</span>
158 
159     // Subtract one to get a zero-indexed worker id.
160     uint worker_id = num_started - 1;
161 
162     return WorkData(_task, worker_id);
163   }
164 
165   void worker_done_with_task() {
166     // Mark that the worker is done with the task.
167     // The worker is not allowed to read the state variables after this line.
<span class="line-modified">168     uint not_finished = Atomic::sub(&amp;_not_finished, 1u);</span>
169 
170     // The last worker signals to the coordinator that all work is completed.
171     if (not_finished == 0) {
172       _end_semaphore-&gt;signal();
173     }
174   }
175 };
176 
177 class MutexGangTaskDispatcher : public GangTaskDispatcher {
178   AbstractGangTask* _task;
179 
180   volatile uint _started;
181   volatile uint _finished;
182   volatile uint _num_workers;
183 
184   Monitor* _monitor;
185 
186  public:
187   MutexGangTaskDispatcher() :
188     _task(NULL),
189     _started(0),
190     _finished(0),
191     _num_workers(0),
192     _monitor(new Monitor(Monitor::leaf, &quot;WorkGang dispatcher lock&quot;, false, Monitor::_safepoint_check_never)) {
193   }
194 
195   ~MutexGangTaskDispatcher() {
196     delete _monitor;
197   }
198 
199   void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {
<span class="line-modified">200     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
201 
202     _task        = task;
203     _num_workers = num_workers;
204 
205     // Tell the workers to get to work.
206     _monitor-&gt;notify_all();
207 
208     // Wait for them to finish.
209     while (_finished &lt; _num_workers) {
<span class="line-modified">210       ml.wait();</span>
211     }
212 
213     _task        = NULL;
214     _num_workers = 0;
215     _started     = 0;
216     _finished    = 0;
217   }
218 
219   WorkData worker_wait_for_task() {
<span class="line-modified">220     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
221 
222     while (_num_workers == 0 || _started == _num_workers) {
<span class="line-modified">223       _monitor-&gt;wait();</span>
224     }
225 
226     _started++;
227 
228     // Subtract one to get a zero-indexed worker id.
229     uint worker_id = _started - 1;
230 
231     return WorkData(_task, worker_id);
232   }
233 
234   void worker_done_with_task() {
<span class="line-modified">235     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
236 
237     _finished++;
238 
239     if (_finished == _num_workers) {
240       // This will wake up all workers and not only the coordinator.
241       _monitor-&gt;notify_all();
242     }
243   }
244 };
245 
246 static GangTaskDispatcher* create_dispatcher() {
247   if (UseSemaphoreGCThreadsSynchronization) {
248     return new SemaphoreGangTaskDispatcher();
249   }
250 
251   return new MutexGangTaskDispatcher();
252 }
253 
254 WorkGang::WorkGang(const char* name,
255                    uint  workers,
</pre>
<hr />
<pre>
280   update_active_workers(num_workers);
281   _dispatcher-&gt;coordinator_execute_on_workers(task, num_workers);
282   update_active_workers(old_num_workers);
283 }
284 
285 AbstractGangWorker::AbstractGangWorker(AbstractWorkGang* gang, uint id) {
286   _gang = gang;
287   set_id(id);
288   set_name(&quot;%s#%d&quot;, gang-&gt;name(), id);
289 }
290 
291 void AbstractGangWorker::run() {
292   initialize();
293   loop();
294 }
295 
296 void AbstractGangWorker::initialize() {
297   assert(_gang != NULL, &quot;No gang to run in&quot;);
298   os::set_priority(this, NearMaxPriority);
299   log_develop_trace(gc, workgang)(&quot;Running gang worker for gang %s id %u&quot;, gang()-&gt;name(), id());


300   assert(!Thread::current()-&gt;is_VM_thread(), &quot;VM thread should not be part&quot;
301          &quot; of a work gang&quot;);
302 }
303 
304 bool AbstractGangWorker::is_GC_task_thread() const {
305   return gang()-&gt;are_GC_task_threads();
306 }
307 
308 bool AbstractGangWorker::is_ConcurrentGC_thread() const {
309   return gang()-&gt;are_ConcurrentGC_threads();
310 }
311 
312 void AbstractGangWorker::print_on(outputStream* st) const {
313   st-&gt;print(&quot;\&quot;%s\&quot; &quot;, name());
314   Thread::print_on(st);
315   st-&gt;cr();
316 }
317 
<span class="line-added">318 void AbstractGangWorker::print() const { print_on(tty); }</span>
<span class="line-added">319 </span>
320 WorkData GangWorker::wait_for_task() {
321   return gang()-&gt;dispatcher()-&gt;worker_wait_for_task();
322 }
323 
324 void GangWorker::signal_task_done() {
325   gang()-&gt;dispatcher()-&gt;worker_done_with_task();
326 }
327 
328 void GangWorker::run_task(WorkData data) {
329   GCIdMark gc_id_mark(data._task-&gt;gc_id());
330   log_develop_trace(gc, workgang)(&quot;Running work gang: %s task: %s worker: %u&quot;, name(), data._task-&gt;name(), data._worker_id);
331 
332   data._task-&gt;work(data._worker_id);
333 
334   log_develop_trace(gc, workgang)(&quot;Finished work gang: %s task: %s worker: %u thread: &quot; PTR_FORMAT,
335                                   name(), data._task-&gt;name(), data._worker_id, p2i(Thread::current()));
336 }
337 
338 void GangWorker::loop() {
339   while (true) {
</pre>
<hr />
<pre>
349 
350 WorkGangBarrierSync::WorkGangBarrierSync()
351   : _monitor(Mutex::safepoint, &quot;work gang barrier sync&quot;, true,
352              Monitor::_safepoint_check_never),
353     _n_workers(0), _n_completed(0), _should_reset(false), _aborted(false) {
354 }
355 
356 WorkGangBarrierSync::WorkGangBarrierSync(uint n_workers, const char* name)
357   : _monitor(Mutex::safepoint, name, true, Monitor::_safepoint_check_never),
358     _n_workers(n_workers), _n_completed(0), _should_reset(false), _aborted(false) {
359 }
360 
361 void WorkGangBarrierSync::set_n_workers(uint n_workers) {
362   _n_workers    = n_workers;
363   _n_completed  = 0;
364   _should_reset = false;
365   _aborted      = false;
366 }
367 
368 bool WorkGangBarrierSync::enter() {
<span class="line-modified">369   MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);</span>
370   if (should_reset()) {
371     // The should_reset() was set and we are the first worker to enter
372     // the sync barrier. We will zero the n_completed() count which
373     // effectively resets the barrier.
374     zero_completed();
375     set_should_reset(false);
376   }
377   inc_completed();
378   if (n_completed() == n_workers()) {
379     // At this point we would like to reset the barrier to be ready in
380     // case it is used again. However, we cannot set n_completed() to
381     // 0, even after the notify_all(), given that some other workers
382     // might still be waiting for n_completed() to become ==
383     // n_workers(). So, if we set n_completed() to 0, those workers
384     // will get stuck (as they will wake up, see that n_completed() !=
385     // n_workers() and go back to sleep). Instead, we raise the
386     // should_reset() flag and the barrier will be reset the first
387     // time a worker enters it again.
388     set_should_reset(true);
<span class="line-modified">389     ml.notify_all();</span>
390   } else {
391     while (n_completed() != n_workers() &amp;&amp; !aborted()) {
<span class="line-modified">392       ml.wait();</span>
393     }
394   }
395   return !aborted();
396 }
397 
398 void WorkGangBarrierSync::abort() {
<span class="line-modified">399   MutexLocker x(monitor(), Mutex::_no_safepoint_check_flag);</span>
400   set_aborted();
401   monitor()-&gt;notify_all();
402 }
403 
404 // SubTasksDone functions.
405 
406 SubTasksDone::SubTasksDone(uint n) :
407   _tasks(NULL), _n_tasks(n), _threads_completed(0) {
408   _tasks = NEW_C_HEAP_ARRAY(uint, n, mtInternal);

409   clear();
410 }
411 
412 bool SubTasksDone::valid() {
413   return _tasks != NULL;
414 }
415 
416 void SubTasksDone::clear() {
417   for (uint i = 0; i &lt; _n_tasks; i++) {
418     _tasks[i] = 0;
419   }
420   _threads_completed = 0;
421 #ifdef ASSERT
422   _claimed = 0;
423 #endif
424 }
425 
426 bool SubTasksDone::try_claim_task(uint t) {
427   assert(t &lt; _n_tasks, &quot;bad task id.&quot;);
428   uint old = _tasks[t];
429   if (old == 0) {
<span class="line-modified">430     old = Atomic::cmpxchg(&amp;_tasks[t], 0u, 1u);</span>
431   }

432   bool res = old == 0;
433 #ifdef ASSERT
434   if (res) {
435     assert(_claimed &lt; _n_tasks, &quot;Too many tasks claimed; missing clear?&quot;);
436     Atomic::inc(&amp;_claimed);
437   }
438 #endif
439   return res;
440 }
441 
442 void SubTasksDone::all_tasks_completed(uint n_threads) {
443   uint observed = _threads_completed;
444   uint old;
445   do {
446     old = observed;
<span class="line-modified">447     observed = Atomic::cmpxchg(&amp;_threads_completed, old, old+1);</span>
448   } while (observed != old);
449   // If this was the last thread checking in, clear the tasks.
450   uint adjusted_thread_count = (n_threads == 0 ? 1 : n_threads);
451   if (observed + 1 == adjusted_thread_count) {
452     clear();
453   }
454 }
455 
456 
457 SubTasksDone::~SubTasksDone() {
<span class="line-modified">458   FREE_C_HEAP_ARRAY(uint, _tasks);</span>
459 }
460 
461 // *** SequentialSubTasksDone
462 
463 void SequentialSubTasksDone::clear() {
464   _n_tasks   = _n_claimed   = 0;
465   _n_threads = _n_completed = 0;
466 }
467 
468 bool SequentialSubTasksDone::valid() {
469   return _n_threads &gt; 0;
470 }
471 
472 bool SequentialSubTasksDone::try_claim_task(uint&amp; t) {
473   t = _n_claimed;
474   while (t &lt; _n_tasks) {
<span class="line-modified">475     uint res = Atomic::cmpxchg(&amp;_n_claimed, t, t+1);</span>
476     if (res == t) {
477       return true;
478     }
479     t = res;
480   }
481   return false;
482 }
483 
484 bool SequentialSubTasksDone::all_tasks_completed() {
485   uint complete = _n_completed;
486   while (true) {
<span class="line-modified">487     uint res = Atomic::cmpxchg(&amp;_n_completed, complete, complete+1);</span>
488     if (res == complete) {
489       break;
490     }
491     complete = res;
492   }
493   if (complete+1 == _n_threads) {
494     clear();
495     return true;
496   }
497   return false;
498 }
</pre>
</td>
</tr>
</table>
<center><a href="workerPolicy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workgroup.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
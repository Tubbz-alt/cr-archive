<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/jvmFlagConstraintsGC.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="isGCActiveMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsGC.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/jvmFlagConstraintsGC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;

 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 27 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 28 #include &quot;gc/shared/gcConfig.hpp&quot;
 29 #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
 30 #include &quot;gc/shared/plab.hpp&quot;
 31 #include &quot;gc/shared/threadLocalAllocBuffer.hpp&quot;
 32 #include &quot;runtime/arguments.hpp&quot;
 33 #include &quot;runtime/globals.hpp&quot;
 34 #include &quot;runtime/globals_extension.hpp&quot;
 35 #include &quot;runtime/thread.inline.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified"> 38 #if INCLUDE_CMSGC</span>
<span class="line-removed"> 39 #include &quot;gc/cms/jvmFlagConstraintsCMS.hpp&quot;</span>
<span class="line-removed"> 40 #endif</span>
 41 #if INCLUDE_G1GC
 42 #include &quot;gc/g1/jvmFlagConstraintsG1.hpp&quot;
 43 #endif
 44 #if INCLUDE_PARALLELGC
 45 #include &quot;gc/parallel/jvmFlagConstraintsParallel.hpp&quot;
 46 #endif
<span class="line-removed"> 47 #ifdef COMPILER1</span>
<span class="line-removed"> 48 #include &quot;c1/c1_globals.hpp&quot;</span>
<span class="line-removed"> 49 #endif // COMPILER1</span>
<span class="line-removed"> 50 #ifdef COMPILER2</span>
<span class="line-removed"> 51 #include &quot;opto/c2_globals.hpp&quot;</span>
<span class="line-removed"> 52 #endif // COMPILER2</span>
 53 
 54 // Some flags that have default values that indicate that the
 55 // JVM should automatically determine an appropriate value
 56 // for that flag.  In those cases it is only appropriate for the
 57 // constraint checking to be done if the user has specified the
 58 // value(s) of the flag(s) on the command line.  In the constraint
 59 // checking functions,  FLAG_IS_CMDLINE() is used to check if
 60 // the flag has been set by the user and so should be checked.
 61 
 62 // As ParallelGCThreads differs among GC modes, we need constraint function.
 63 JVMFlag::Error ParallelGCThreadsConstraintFunc(uint value, bool verbose) {
 64   JVMFlag::Error status = JVMFlag::SUCCESS;
 65 
 66 #if INCLUDE_PARALLELGC
 67   status = ParallelGCThreadsConstraintFuncParallel(value, verbose);
 68   if (status != JVMFlag::SUCCESS) {
 69     return status;
 70   }
 71 #endif
 72 
<span class="line-removed"> 73 #if INCLUDE_CMSGC</span>
<span class="line-removed"> 74   status = ParallelGCThreadsConstraintFuncCMS(value, verbose);</span>
<span class="line-removed"> 75   if (status != JVMFlag::SUCCESS) {</span>
<span class="line-removed"> 76     return status;</span>
<span class="line-removed"> 77   }</span>
<span class="line-removed"> 78 #endif</span>
<span class="line-removed"> 79 </span>
 80   return status;
 81 }
 82 
 83 // As ConcGCThreads should be smaller than ParallelGCThreads,
 84 // we need constraint function.
 85 JVMFlag::Error ConcGCThreadsConstraintFunc(uint value, bool verbose) {
<span class="line-modified"> 86   // CMS and G1 GCs use ConcGCThreads.</span>
<span class="line-modified"> 87   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="line-removed"> 88        GCConfig::is_gc_selected(CollectedHeap::G1)) &amp;&amp; (value &gt; ParallelGCThreads)) {</span>
 89     JVMFlag::printError(verbose,
 90                         &quot;ConcGCThreads (&quot; UINT32_FORMAT &quot;) must be &quot;
 91                         &quot;less than or equal to ParallelGCThreads (&quot; UINT32_FORMAT &quot;)\n&quot;,
 92                         value, ParallelGCThreads);
 93     return JVMFlag::VIOLATES_CONSTRAINT;
 94   }
 95 
 96   return JVMFlag::SUCCESS;
 97 }
 98 
 99 static JVMFlag::Error MinPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="line-modified">100   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="line-modified">101        GCConfig::is_gc_selected(CollectedHeap::G1)  ||</span>
<span class="line-removed">102        GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp; (value &lt; PLAB::min_size())) {</span>
103     JVMFlag::printError(verbose,
104                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
105                         &quot;greater than or equal to ergonomic PLAB minimum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
106                         name, value, PLAB::min_size());
107     return JVMFlag::VIOLATES_CONSTRAINT;
108   }
109 
110   return JVMFlag::SUCCESS;
111 }
112 
113 JVMFlag::Error MaxPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="line-modified">114   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="line-removed">115        GCConfig::is_gc_selected(CollectedHeap::G1)  ||</span>
116        GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp; (value &gt; PLAB::max_size())) {
117     JVMFlag::printError(verbose,
118                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
119                         &quot;less than or equal to ergonomic PLAB maximum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
120                         name, value, PLAB::max_size());
121     return JVMFlag::VIOLATES_CONSTRAINT;
122   }
123 
124   return JVMFlag::SUCCESS;
125 }
126 
127 static JVMFlag::Error MinMaxPLABSizeBounds(const char* name, size_t value, bool verbose) {
128   JVMFlag::Error status = MinPLABSizeBounds(name, value, verbose);
129 
130   if (status == JVMFlag::SUCCESS) {
131     return MaxPLABSizeBounds(name, value, verbose);
132   }
133   return status;
134 }
135 
136 JVMFlag::Error YoungPLABSizeConstraintFunc(size_t value, bool verbose) {
137   return MinMaxPLABSizeBounds(&quot;YoungPLABSize&quot;, value, verbose);
138 }
139 
140 JVMFlag::Error OldPLABSizeConstraintFunc(size_t value, bool verbose) {
141   JVMFlag::Error status = JVMFlag::SUCCESS;
142 
<span class="line-removed">143 #if INCLUDE_CMSGC</span>
<span class="line-removed">144   if (UseConcMarkSweepGC) {</span>
<span class="line-removed">145     return OldPLABSizeConstraintFuncCMS(value, verbose);</span>
<span class="line-removed">146   } else</span>
<span class="line-removed">147 #endif</span>
148   {
149     status = MinMaxPLABSizeBounds(&quot;OldPLABSize&quot;, value, verbose);
150   }
151 
152   return status;
153 }
154 
155 JVMFlag::Error MinHeapFreeRatioConstraintFunc(uintx value, bool verbose) {
156   if (value &gt; MaxHeapFreeRatio) {
157     JVMFlag::printError(verbose,
158                         &quot;MinHeapFreeRatio (&quot; UINTX_FORMAT &quot;) must be &quot;
159                         &quot;less than or equal to MaxHeapFreeRatio (&quot; UINTX_FORMAT &quot;)\n&quot;,
160                         value, MaxHeapFreeRatio);
161     return JVMFlag::VIOLATES_CONSTRAINT;
162   } else {
163     return JVMFlag::SUCCESS;
164   }
165 }
166 
167 JVMFlag::Error MaxHeapFreeRatioConstraintFunc(uintx value, bool verbose) {
</pre>
<hr />
<pre>
296 }
297 
298 // To avoid an overflow by &#39;align_up(value, alignment)&#39;.
299 static JVMFlag::Error MaxSizeForAlignment(const char* name, size_t value, size_t alignment, bool verbose) {
300   size_t aligned_max = ((max_uintx - alignment) &amp; ~(alignment-1));
301   if (value &gt; aligned_max) {
302     JVMFlag::printError(verbose,
303                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
304                         &quot;less than or equal to aligned maximum value (&quot; SIZE_FORMAT &quot;)\n&quot;,
305                         name, value, aligned_max);
306     return JVMFlag::VIOLATES_CONSTRAINT;
307   }
308   return JVMFlag::SUCCESS;
309 }
310 
311 static JVMFlag::Error MaxSizeForHeapAlignment(const char* name, size_t value, bool verbose) {
312   size_t heap_alignment;
313 
314 #if INCLUDE_G1GC
315   if (UseG1GC) {
<span class="line-modified">316     // For G1 GC, we don&#39;t know until G1CollectorPolicy is created.</span>
317     heap_alignment = MaxSizeForHeapAlignmentG1();
318   } else
319 #endif
320   {
<span class="line-modified">321     heap_alignment = CollectorPolicy::compute_heap_alignment();</span>
322   }
323 
324   return MaxSizeForAlignment(name, value, heap_alignment, verbose);
325 }
326 




327 JVMFlag::Error InitialHeapSizeConstraintFunc(size_t value, bool verbose) {
328   return MaxSizeForHeapAlignment(&quot;InitialHeapSize&quot;, value, verbose);
329 }
330 
331 JVMFlag::Error MaxHeapSizeConstraintFunc(size_t value, bool verbose) {
332   JVMFlag::Error status = MaxSizeForHeapAlignment(&quot;MaxHeapSize&quot;, value, verbose);
333 
334   if (status == JVMFlag::SUCCESS) {
335     status = CheckMaxHeapSizeAndSoftRefLRUPolicyMSPerMB(value, SoftRefLRUPolicyMSPerMB, verbose);
336   }
337   return status;
338 }
339 









340 JVMFlag::Error HeapBaseMinAddressConstraintFunc(size_t value, bool verbose) {
341   // If an overflow happened in Arguments::set_heap_size(), MaxHeapSize will have too large a value.
342   // Check for this by ensuring that MaxHeapSize plus the requested min base address still fit within max_uintx.
343   if (UseCompressedOops &amp;&amp; FLAG_IS_ERGO(MaxHeapSize) &amp;&amp; (value &gt; (max_uintx - MaxHeapSize))) {
344     JVMFlag::printError(verbose,
345                         &quot;HeapBaseMinAddress (&quot; SIZE_FORMAT &quot;) or MaxHeapSize (&quot; SIZE_FORMAT &quot;) is too large. &quot;
346                         &quot;Sum of them must be less than or equal to maximum of size_t (&quot; SIZE_FORMAT &quot;)\n&quot;,
347                         value, MaxHeapSize, max_uintx);
348     return JVMFlag::VIOLATES_CONSTRAINT;
349   }
350 
351   return MaxSizeForHeapAlignment(&quot;HeapBaseMinAddress&quot;, value, verbose);
352 }
353 
354 JVMFlag::Error NewSizeConstraintFunc(size_t value, bool verbose) {
355 #if INCLUDE_G1GC
356   JVMFlag::Error status = NewSizeConstraintFuncG1(value, verbose);
357   if (status != JVMFlag::SUCCESS) {
358     return status;
359   }
</pre>
<hr />
<pre>
405 // We will protect overflow from ThreadLocalAllocBuffer::record_slow_allocation(),
406 // so AfterMemoryInit type is enough to check.
407 JVMFlag::Error TLABWasteIncrementConstraintFunc(uintx value, bool verbose) {
408   if (UseTLAB) {
409     size_t refill_waste_limit = Thread::current()-&gt;tlab().refill_waste_limit();
410 
411     // Compare with &#39;max_uintx&#39; as ThreadLocalAllocBuffer::_refill_waste_limit is &#39;size_t&#39;.
412     if (refill_waste_limit &gt; (max_uintx - value)) {
413       JVMFlag::printError(verbose,
414                           &quot;TLABWasteIncrement (&quot; UINTX_FORMAT &quot;) must be &quot;
415                           &quot;less than or equal to ergonomic TLAB waste increment maximum size(&quot; SIZE_FORMAT &quot;)\n&quot;,
416                           value, (max_uintx - refill_waste_limit));
417       return JVMFlag::VIOLATES_CONSTRAINT;
418     }
419   }
420   return JVMFlag::SUCCESS;
421 }
422 
423 JVMFlag::Error SurvivorRatioConstraintFunc(uintx value, bool verbose) {
424   if (FLAG_IS_CMDLINE(SurvivorRatio) &amp;&amp;
<span class="line-modified">425       (value &gt; (MaxHeapSize / Universe::heap()-&gt;collector_policy()-&gt;space_alignment()))) {</span>
426     JVMFlag::printError(verbose,
427                         &quot;SurvivorRatio (&quot; UINTX_FORMAT &quot;) must be &quot;
428                         &quot;less than or equal to ergonomic SurvivorRatio maximum (&quot; SIZE_FORMAT &quot;)\n&quot;,
429                         value,
<span class="line-modified">430                         (MaxHeapSize / Universe::heap()-&gt;collector_policy()-&gt;space_alignment()));</span>
431     return JVMFlag::VIOLATES_CONSTRAINT;
432   } else {
433     return JVMFlag::SUCCESS;
434   }
435 }
436 
437 JVMFlag::Error MetaspaceSizeConstraintFunc(size_t value, bool verbose) {
438   if (value &gt; MaxMetaspaceSize) {
439     JVMFlag::printError(verbose,
440                         &quot;MetaspaceSize (&quot; SIZE_FORMAT &quot;) must be &quot;
441                         &quot;less than or equal to MaxMetaspaceSize (&quot; SIZE_FORMAT &quot;)\n&quot;,
442                         value, MaxMetaspaceSize);
443     return JVMFlag::VIOLATES_CONSTRAINT;
444   } else {
445     return JVMFlag::SUCCESS;
446   }
447 }
448 
449 JVMFlag::Error MaxMetaspaceSizeConstraintFunc(size_t value, bool verbose) {
450   if (value &lt; MetaspaceSize) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<span class="line-added"> 26 #include &quot;gc/shared/cardTableRS.hpp&quot;</span>
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/shared/gcArguments.hpp&quot;</span>
 29 #include &quot;gc/shared/gcConfig.hpp&quot;
 30 #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
 31 #include &quot;gc/shared/plab.hpp&quot;
 32 #include &quot;gc/shared/threadLocalAllocBuffer.hpp&quot;
 33 #include &quot;runtime/arguments.hpp&quot;
 34 #include &quot;runtime/globals.hpp&quot;
 35 #include &quot;runtime/globals_extension.hpp&quot;
 36 #include &quot;runtime/thread.inline.hpp&quot;
 37 #include &quot;utilities/align.hpp&quot;
 38 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified"> 39 #include &quot;utilities/powerOfTwo.hpp&quot;</span>


 40 #if INCLUDE_G1GC
 41 #include &quot;gc/g1/jvmFlagConstraintsG1.hpp&quot;
 42 #endif
 43 #if INCLUDE_PARALLELGC
 44 #include &quot;gc/parallel/jvmFlagConstraintsParallel.hpp&quot;
 45 #endif






 46 
 47 // Some flags that have default values that indicate that the
 48 // JVM should automatically determine an appropriate value
 49 // for that flag.  In those cases it is only appropriate for the
 50 // constraint checking to be done if the user has specified the
 51 // value(s) of the flag(s) on the command line.  In the constraint
 52 // checking functions,  FLAG_IS_CMDLINE() is used to check if
 53 // the flag has been set by the user and so should be checked.
 54 
 55 // As ParallelGCThreads differs among GC modes, we need constraint function.
 56 JVMFlag::Error ParallelGCThreadsConstraintFunc(uint value, bool verbose) {
 57   JVMFlag::Error status = JVMFlag::SUCCESS;
 58 
 59 #if INCLUDE_PARALLELGC
 60   status = ParallelGCThreadsConstraintFuncParallel(value, verbose);
 61   if (status != JVMFlag::SUCCESS) {
 62     return status;
 63   }
 64 #endif
 65 







 66   return status;
 67 }
 68 
 69 // As ConcGCThreads should be smaller than ParallelGCThreads,
 70 // we need constraint function.
 71 JVMFlag::Error ConcGCThreadsConstraintFunc(uint value, bool verbose) {
<span class="line-modified"> 72   // G1 GC use ConcGCThreads.</span>
<span class="line-modified"> 73   if (GCConfig::is_gc_selected(CollectedHeap::G1) &amp;&amp; (value &gt; ParallelGCThreads)) {</span>

 74     JVMFlag::printError(verbose,
 75                         &quot;ConcGCThreads (&quot; UINT32_FORMAT &quot;) must be &quot;
 76                         &quot;less than or equal to ParallelGCThreads (&quot; UINT32_FORMAT &quot;)\n&quot;,
 77                         value, ParallelGCThreads);
 78     return JVMFlag::VIOLATES_CONSTRAINT;
 79   }
 80 
 81   return JVMFlag::SUCCESS;
 82 }
 83 
 84 static JVMFlag::Error MinPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="line-modified"> 85   if ((GCConfig::is_gc_selected(CollectedHeap::G1) || GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp;</span>
<span class="line-modified"> 86       (value &lt; PLAB::min_size())) {</span>

 87     JVMFlag::printError(verbose,
 88                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
 89                         &quot;greater than or equal to ergonomic PLAB minimum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
 90                         name, value, PLAB::min_size());
 91     return JVMFlag::VIOLATES_CONSTRAINT;
 92   }
 93 
 94   return JVMFlag::SUCCESS;
 95 }
 96 
 97 JVMFlag::Error MaxPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="line-modified"> 98   if ((GCConfig::is_gc_selected(CollectedHeap::G1) ||</span>

 99        GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp; (value &gt; PLAB::max_size())) {
100     JVMFlag::printError(verbose,
101                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
102                         &quot;less than or equal to ergonomic PLAB maximum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
103                         name, value, PLAB::max_size());
104     return JVMFlag::VIOLATES_CONSTRAINT;
105   }
106 
107   return JVMFlag::SUCCESS;
108 }
109 
110 static JVMFlag::Error MinMaxPLABSizeBounds(const char* name, size_t value, bool verbose) {
111   JVMFlag::Error status = MinPLABSizeBounds(name, value, verbose);
112 
113   if (status == JVMFlag::SUCCESS) {
114     return MaxPLABSizeBounds(name, value, verbose);
115   }
116   return status;
117 }
118 
119 JVMFlag::Error YoungPLABSizeConstraintFunc(size_t value, bool verbose) {
120   return MinMaxPLABSizeBounds(&quot;YoungPLABSize&quot;, value, verbose);
121 }
122 
123 JVMFlag::Error OldPLABSizeConstraintFunc(size_t value, bool verbose) {
124   JVMFlag::Error status = JVMFlag::SUCCESS;
125 





126   {
127     status = MinMaxPLABSizeBounds(&quot;OldPLABSize&quot;, value, verbose);
128   }
129 
130   return status;
131 }
132 
133 JVMFlag::Error MinHeapFreeRatioConstraintFunc(uintx value, bool verbose) {
134   if (value &gt; MaxHeapFreeRatio) {
135     JVMFlag::printError(verbose,
136                         &quot;MinHeapFreeRatio (&quot; UINTX_FORMAT &quot;) must be &quot;
137                         &quot;less than or equal to MaxHeapFreeRatio (&quot; UINTX_FORMAT &quot;)\n&quot;,
138                         value, MaxHeapFreeRatio);
139     return JVMFlag::VIOLATES_CONSTRAINT;
140   } else {
141     return JVMFlag::SUCCESS;
142   }
143 }
144 
145 JVMFlag::Error MaxHeapFreeRatioConstraintFunc(uintx value, bool verbose) {
</pre>
<hr />
<pre>
274 }
275 
276 // To avoid an overflow by &#39;align_up(value, alignment)&#39;.
277 static JVMFlag::Error MaxSizeForAlignment(const char* name, size_t value, size_t alignment, bool verbose) {
278   size_t aligned_max = ((max_uintx - alignment) &amp; ~(alignment-1));
279   if (value &gt; aligned_max) {
280     JVMFlag::printError(verbose,
281                         &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
282                         &quot;less than or equal to aligned maximum value (&quot; SIZE_FORMAT &quot;)\n&quot;,
283                         name, value, aligned_max);
284     return JVMFlag::VIOLATES_CONSTRAINT;
285   }
286   return JVMFlag::SUCCESS;
287 }
288 
289 static JVMFlag::Error MaxSizeForHeapAlignment(const char* name, size_t value, bool verbose) {
290   size_t heap_alignment;
291 
292 #if INCLUDE_G1GC
293   if (UseG1GC) {
<span class="line-modified">294     // For G1 GC, we don&#39;t know until G1CollectedHeap is created.</span>
295     heap_alignment = MaxSizeForHeapAlignmentG1();
296   } else
297 #endif
298   {
<span class="line-modified">299     heap_alignment = GCArguments::compute_heap_alignment();</span>
300   }
301 
302   return MaxSizeForAlignment(name, value, heap_alignment, verbose);
303 }
304 
<span class="line-added">305 JVMFlag::Error MinHeapSizeConstraintFunc(size_t value, bool verbose) {</span>
<span class="line-added">306   return MaxSizeForHeapAlignment(&quot;MinHeapSize&quot;, value, verbose);</span>
<span class="line-added">307 }</span>
<span class="line-added">308 </span>
309 JVMFlag::Error InitialHeapSizeConstraintFunc(size_t value, bool verbose) {
310   return MaxSizeForHeapAlignment(&quot;InitialHeapSize&quot;, value, verbose);
311 }
312 
313 JVMFlag::Error MaxHeapSizeConstraintFunc(size_t value, bool verbose) {
314   JVMFlag::Error status = MaxSizeForHeapAlignment(&quot;MaxHeapSize&quot;, value, verbose);
315 
316   if (status == JVMFlag::SUCCESS) {
317     status = CheckMaxHeapSizeAndSoftRefLRUPolicyMSPerMB(value, SoftRefLRUPolicyMSPerMB, verbose);
318   }
319   return status;
320 }
321 
<span class="line-added">322 JVMFlag::Error SoftMaxHeapSizeConstraintFunc(size_t value, bool verbose) {</span>
<span class="line-added">323   if (value &gt; MaxHeapSize) {</span>
<span class="line-added">324     JVMFlag::printError(verbose, &quot;SoftMaxHeapSize must be less than or equal to the maximum heap size\n&quot;);</span>
<span class="line-added">325     return JVMFlag::VIOLATES_CONSTRAINT;</span>
<span class="line-added">326   }</span>
<span class="line-added">327 </span>
<span class="line-added">328   return JVMFlag::SUCCESS;</span>
<span class="line-added">329 }</span>
<span class="line-added">330 </span>
331 JVMFlag::Error HeapBaseMinAddressConstraintFunc(size_t value, bool verbose) {
332   // If an overflow happened in Arguments::set_heap_size(), MaxHeapSize will have too large a value.
333   // Check for this by ensuring that MaxHeapSize plus the requested min base address still fit within max_uintx.
334   if (UseCompressedOops &amp;&amp; FLAG_IS_ERGO(MaxHeapSize) &amp;&amp; (value &gt; (max_uintx - MaxHeapSize))) {
335     JVMFlag::printError(verbose,
336                         &quot;HeapBaseMinAddress (&quot; SIZE_FORMAT &quot;) or MaxHeapSize (&quot; SIZE_FORMAT &quot;) is too large. &quot;
337                         &quot;Sum of them must be less than or equal to maximum of size_t (&quot; SIZE_FORMAT &quot;)\n&quot;,
338                         value, MaxHeapSize, max_uintx);
339     return JVMFlag::VIOLATES_CONSTRAINT;
340   }
341 
342   return MaxSizeForHeapAlignment(&quot;HeapBaseMinAddress&quot;, value, verbose);
343 }
344 
345 JVMFlag::Error NewSizeConstraintFunc(size_t value, bool verbose) {
346 #if INCLUDE_G1GC
347   JVMFlag::Error status = NewSizeConstraintFuncG1(value, verbose);
348   if (status != JVMFlag::SUCCESS) {
349     return status;
350   }
</pre>
<hr />
<pre>
396 // We will protect overflow from ThreadLocalAllocBuffer::record_slow_allocation(),
397 // so AfterMemoryInit type is enough to check.
398 JVMFlag::Error TLABWasteIncrementConstraintFunc(uintx value, bool verbose) {
399   if (UseTLAB) {
400     size_t refill_waste_limit = Thread::current()-&gt;tlab().refill_waste_limit();
401 
402     // Compare with &#39;max_uintx&#39; as ThreadLocalAllocBuffer::_refill_waste_limit is &#39;size_t&#39;.
403     if (refill_waste_limit &gt; (max_uintx - value)) {
404       JVMFlag::printError(verbose,
405                           &quot;TLABWasteIncrement (&quot; UINTX_FORMAT &quot;) must be &quot;
406                           &quot;less than or equal to ergonomic TLAB waste increment maximum size(&quot; SIZE_FORMAT &quot;)\n&quot;,
407                           value, (max_uintx - refill_waste_limit));
408       return JVMFlag::VIOLATES_CONSTRAINT;
409     }
410   }
411   return JVMFlag::SUCCESS;
412 }
413 
414 JVMFlag::Error SurvivorRatioConstraintFunc(uintx value, bool verbose) {
415   if (FLAG_IS_CMDLINE(SurvivorRatio) &amp;&amp;
<span class="line-modified">416       (value &gt; (MaxHeapSize / SpaceAlignment))) {</span>
417     JVMFlag::printError(verbose,
418                         &quot;SurvivorRatio (&quot; UINTX_FORMAT &quot;) must be &quot;
419                         &quot;less than or equal to ergonomic SurvivorRatio maximum (&quot; SIZE_FORMAT &quot;)\n&quot;,
420                         value,
<span class="line-modified">421                         (MaxHeapSize / SpaceAlignment));</span>
422     return JVMFlag::VIOLATES_CONSTRAINT;
423   } else {
424     return JVMFlag::SUCCESS;
425   }
426 }
427 
428 JVMFlag::Error MetaspaceSizeConstraintFunc(size_t value, bool verbose) {
429   if (value &gt; MaxMetaspaceSize) {
430     JVMFlag::printError(verbose,
431                         &quot;MetaspaceSize (&quot; SIZE_FORMAT &quot;) must be &quot;
432                         &quot;less than or equal to MaxMetaspaceSize (&quot; SIZE_FORMAT &quot;)\n&quot;,
433                         value, MaxMetaspaceSize);
434     return JVMFlag::VIOLATES_CONSTRAINT;
435   } else {
436     return JVMFlag::SUCCESS;
437   }
438 }
439 
440 JVMFlag::Error MaxMetaspaceSizeConstraintFunc(size_t value, bool verbose) {
441   if (value &lt; MetaspaceSize) {
</pre>
</td>
</tr>
</table>
<center><a href="isGCActiveMark.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsGC.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
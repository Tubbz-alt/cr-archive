<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/space.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 30 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 31 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 32 #include &quot;gc/shared/space.hpp&quot;
 33 #include &quot;gc/shared/space.inline.hpp&quot;
 34 #include &quot;gc/shared/spaceDecorator.hpp&quot;
 35 #include &quot;memory/iterator.inline.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/atomic.hpp&quot;
 39 #include &quot;runtime/java.hpp&quot;
 40 #include &quot;runtime/orderAccess.hpp&quot;
 41 #include &quot;runtime/prefetch.inline.hpp&quot;
 42 #include &quot;runtime/safepoint.hpp&quot;
 43 #include &quot;utilities/align.hpp&quot;
 44 #include &quot;utilities/copy.hpp&quot;
 45 #include &quot;utilities/globalDefinitions.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 #if INCLUDE_SERIALGC
 48 #include &quot;gc/serial/defNewGeneration.hpp&quot;
 49 #endif
 50 
 51 HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,
 52                                                 HeapWord* top_obj) {
 53   if (top_obj != NULL) {
 54     if (_sp-&gt;block_is_obj(top_obj)) {
 55       if (_precision == CardTable::ObjHeadPreciseArray) {
 56         if (oop(top_obj)-&gt;is_objArray() || oop(top_obj)-&gt;is_typeArray()) {
 57           // An arrayOop is starting on the dirty card - since we do exact
 58           // store checks for objArrays we are done.
 59         } else {
 60           // Otherwise, it is possible that the object starting on the dirty
 61           // card spans the entire card, and that the store happened on a
 62           // later card.  Figure out where the object ends.
 63           // Use the block_size() method of the space over which
 64           // the iteration is being done.  That space (e.g. CMS) may have
 65           // specific requirements on object sizes which will
 66           // be reflected in the block_size() method.
 67           top = top_obj + oop(top_obj)-&gt;size();
 68         }
 69       }
 70     } else {
 71       top = top_obj;
 72     }
 73   } else {
 74     assert(top == _sp-&gt;end(), &quot;only case where top_obj == NULL&quot;);
 75   }
 76   return top;
 77 }
 78 
 79 void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,
 80                                             HeapWord* bottom,
 81                                             HeapWord* top) {
 82   // 1. Blocks may or may not be objects.
 83   // 2. Even when a block_is_obj(), it may not entirely
 84   //    occupy the block if the block quantum is larger than
 85   //    the object size.
 86   // We can and should try to optimize by calling the non-MemRegion
 87   // version of oop_iterate() for all but the extremal objects
 88   // (for which we need to call the MemRegion version of
 89   // oop_iterate()) To be done post-beta XXX
 90   for (; bottom &lt; top; bottom += _sp-&gt;block_size(bottom)) {
 91     // As in the case of contiguous space above, we&#39;d like to
 92     // just use the value returned by oop_iterate to increment the
 93     // current pointer; unfortunately, that won&#39;t work in CMS because
 94     // we&#39;d need an interface change (it seems) to have the space
 95     // &quot;adjust the object size&quot; (for instance pad it up to its
 96     // block alignment or minimum block size restrictions. XXX
 97     if (_sp-&gt;block_is_obj(bottom) &amp;&amp;
 98         !_sp-&gt;obj_allocated_since_save_marks(oop(bottom))) {
 99       oop(bottom)-&gt;oop_iterate(_cl, mr);
100     }
101   }
102 }
103 
104 // We get called with &quot;mr&quot; representing the dirty region
105 // that we want to process. Because of imprecise marking,
106 // we may need to extend the incoming &quot;mr&quot; to the right,
107 // and scan more. However, because we may already have
108 // scanned some of that extended region, we may need to
109 // trim its right-end back some so we do not scan what
110 // we (or another worker thread) may already have scanned
111 // or planning to scan.
112 void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {
113 
114   // Some collectors need to do special things whenever their dirty
115   // cards are processed. For instance, CMS must remember mutator updates
116   // (i.e. dirty cards) so as to re-scan mutated objects.
117   // Such work can be piggy-backed here on dirty card scanning, so as to make
118   // it slightly more efficient than doing a complete non-destructive pre-scan
119   // of the card table.
120   MemRegionClosure* pCl = _sp-&gt;preconsumptionDirtyCardClosure();
121   if (pCl != NULL) {
122     pCl-&gt;do_MemRegion(mr);
123   }
124 
125   HeapWord* bottom = mr.start();
126   HeapWord* last = mr.last();
127   HeapWord* top = mr.end();
128   HeapWord* bottom_obj;
129   HeapWord* top_obj;
130 
131   assert(_precision == CardTable::ObjHeadPreciseArray ||
132          _precision == CardTable::Precise,
133          &quot;Only ones we deal with for now.&quot;);
134 
135   assert(_precision != CardTable::ObjHeadPreciseArray ||
136          _last_bottom == NULL || top &lt;= _last_bottom,
137          &quot;Not decreasing&quot;);
138   NOT_PRODUCT(_last_bottom = mr.start());
139 
140   bottom_obj = _sp-&gt;block_start(bottom);
141   top_obj    = _sp-&gt;block_start(last);
142 
143   assert(bottom_obj &lt;= bottom, &quot;just checking&quot;);
144   assert(top_obj    &lt;= top,    &quot;just checking&quot;);
145 
146   // Given what we think is the top of the memory region and
147   // the start of the object at the top, get the actual
148   // value of the top.
149   top = get_actual_top(top, top_obj);
150 
151   // If the previous call did some part of this region, don&#39;t redo.
152   if (_precision == CardTable::ObjHeadPreciseArray &amp;&amp;
153       _min_done != NULL &amp;&amp;
154       _min_done &lt; top) {
155     top = _min_done;
156   }
157 
158   // Top may have been reset, and in fact may be below bottom,
159   // e.g. the dirty card region is entirely in a now free object
160   // -- something that could happen with a concurrent sweeper.
161   bottom = MIN2(bottom, top);
162   MemRegion extended_mr = MemRegion(bottom, top);
163   assert(bottom &lt;= top &amp;&amp;
164          (_precision != CardTable::ObjHeadPreciseArray ||
165           _min_done == NULL ||
166           top &lt;= _min_done),
167          &quot;overlap!&quot;);
168 
169   // Walk the region if it is not empty; otherwise there is nothing to do.
170   if (!extended_mr.is_empty()) {
171     walk_mem_region(extended_mr, bottom_obj, top);
172   }
173 
174   _min_done = bottom;
175 }
176 
177 DirtyCardToOopClosure* Space::new_dcto_cl(OopIterateClosure* cl,
178                                           CardTable::PrecisionStyle precision,
179                                           HeapWord* boundary,
180                                           bool parallel) {
181   return new DirtyCardToOopClosure(this, cl, precision, boundary);
182 }
183 
184 HeapWord* ContiguousSpaceDCTOC::get_actual_top(HeapWord* top,
185                                                HeapWord* top_obj) {
186   if (top_obj != NULL &amp;&amp; top_obj &lt; (_sp-&gt;toContiguousSpace())-&gt;top()) {
187     if (_precision == CardTable::ObjHeadPreciseArray) {
188       if (oop(top_obj)-&gt;is_objArray() || oop(top_obj)-&gt;is_typeArray()) {
189         // An arrayOop is starting on the dirty card - since we do exact
190         // store checks for objArrays we are done.
191       } else {
192         // Otherwise, it is possible that the object starting on the dirty
193         // card spans the entire card, and that the store happened on a
194         // later card.  Figure out where the object ends.
195         assert(_sp-&gt;block_size(top_obj) == (size_t) oop(top_obj)-&gt;size(),
196           &quot;Block size and object size mismatch&quot;);
197         top = top_obj + oop(top_obj)-&gt;size();
198       }
199     }
200   } else {
201     top = (_sp-&gt;toContiguousSpace())-&gt;top();
202   }
203   return top;
204 }
205 
206 void FilteringDCTOC::walk_mem_region(MemRegion mr,
207                                      HeapWord* bottom,
208                                      HeapWord* top) {
209   // Note that this assumption won&#39;t hold if we have a concurrent
210   // collector in this space, which may have freed up objects after
211   // they were dirtied and before the stop-the-world GC that is
212   // examining cards here.
213   assert(bottom &lt; top, &quot;ought to be at least one obj on a dirty card.&quot;);
214 
215   if (_boundary != NULL) {
216     // We have a boundary outside of which we don&#39;t want to look
217     // at objects, so create a filtering closure around the
218     // oop closure before walking the region.
219     FilteringClosure filter(_boundary, _cl);
220     walk_mem_region_with_cl(mr, bottom, top, &amp;filter);
221   } else {
222     // No boundary, simply walk the heap with the oop closure.
223     walk_mem_region_with_cl(mr, bottom, top, _cl);
224   }
225 
226 }
227 
228 // We must replicate this so that the static type of &quot;FilteringClosure&quot;
229 // (see above) is apparent at the oop_iterate calls.
230 #define ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(ClosureType) \
231 void ContiguousSpaceDCTOC::walk_mem_region_with_cl(MemRegion mr,        \
232                                                    HeapWord* bottom,    \
233                                                    HeapWord* top,       \
234                                                    ClosureType* cl) {   \
235   bottom += oop(bottom)-&gt;oop_iterate_size(cl, mr);                      \
236   if (bottom &lt; top) {                                                   \
237     HeapWord* next_obj = bottom + oop(bottom)-&gt;size();                  \
238     while (next_obj &lt; top) {                                            \
239       /* Bottom lies entirely below top, so we can call the */          \
240       /* non-memRegion version of oop_iterate below. */                 \
241       oop(bottom)-&gt;oop_iterate(cl);                                     \
242       bottom = next_obj;                                                \
243       next_obj = bottom + oop(bottom)-&gt;size();                          \
244     }                                                                   \
245     /* Last object. */                                                  \
246     oop(bottom)-&gt;oop_iterate(cl, mr);                                   \
247   }                                                                     \
248 }
249 
250 // (There are only two of these, rather than N, because the split is due
251 // only to the introduction of the FilteringClosure, a local part of the
252 // impl of this abstraction.)
253 ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(OopIterateClosure)
254 ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(FilteringClosure)
255 
256 DirtyCardToOopClosure*
257 ContiguousSpace::new_dcto_cl(OopIterateClosure* cl,
258                              CardTable::PrecisionStyle precision,
259                              HeapWord* boundary,
260                              bool parallel) {
261   return new ContiguousSpaceDCTOC(this, cl, precision, boundary);
262 }
263 
264 void Space::initialize(MemRegion mr,
265                        bool clear_space,
266                        bool mangle_space) {
267   HeapWord* bottom = mr.start();
268   HeapWord* end    = mr.end();
269   assert(Universe::on_page_boundary(bottom) &amp;&amp; Universe::on_page_boundary(end),
270          &quot;invalid space boundaries&quot;);
271   set_bottom(bottom);
272   set_end(end);
273   if (clear_space) clear(mangle_space);
274 }
275 
276 void Space::clear(bool mangle_space) {
277   if (ZapUnusedHeapArea &amp;&amp; mangle_space) {
278     mangle_unused_area();
279   }
280 }
281 
282 ContiguousSpace::ContiguousSpace(): CompactibleSpace(), _top(NULL),
283     _concurrent_iteration_safe_limit(NULL) {
284   _mangler = new GenSpaceMangler(this);
285 }
286 
287 ContiguousSpace::~ContiguousSpace() {
288   delete _mangler;
289 }
290 
291 void ContiguousSpace::initialize(MemRegion mr,
292                                  bool clear_space,
293                                  bool mangle_space)
294 {
295   CompactibleSpace::initialize(mr, clear_space, mangle_space);
296   set_concurrent_iteration_safe_limit(top());
297 }
298 
299 void ContiguousSpace::clear(bool mangle_space) {
300   set_top(bottom());
301   set_saved_mark();
302   CompactibleSpace::clear(mangle_space);
303 }
304 
305 bool ContiguousSpace::is_free_block(const HeapWord* p) const {
306   return p &gt;= _top;
307 }
308 
309 void OffsetTableContigSpace::clear(bool mangle_space) {
310   ContiguousSpace::clear(mangle_space);
311   _offsets.initialize_threshold();
312 }
313 
314 void OffsetTableContigSpace::set_bottom(HeapWord* new_bottom) {
315   Space::set_bottom(new_bottom);
316   _offsets.set_bottom(new_bottom);
317 }
318 
319 void OffsetTableContigSpace::set_end(HeapWord* new_end) {
320   // Space should not advertise an increase in size
321   // until after the underlying offset table has been enlarged.
322   _offsets.resize(pointer_delta(new_end, bottom()));
323   Space::set_end(new_end);
324 }
325 
326 #ifndef PRODUCT
327 
328 void ContiguousSpace::set_top_for_allocations(HeapWord* v) {
329   mangler()-&gt;set_top_for_allocations(v);
330 }
331 void ContiguousSpace::set_top_for_allocations() {
332   mangler()-&gt;set_top_for_allocations(top());
333 }
334 void ContiguousSpace::check_mangled_unused_area(HeapWord* limit) {
335   mangler()-&gt;check_mangled_unused_area(limit);
336 }
337 
338 void ContiguousSpace::check_mangled_unused_area_complete() {
339   mangler()-&gt;check_mangled_unused_area_complete();
340 }
341 
342 // Mangled only the unused space that has not previously
343 // been mangled and that has not been allocated since being
344 // mangled.
345 void ContiguousSpace::mangle_unused_area() {
346   mangler()-&gt;mangle_unused_area();
347 }
348 void ContiguousSpace::mangle_unused_area_complete() {
349   mangler()-&gt;mangle_unused_area_complete();
350 }
351 #endif  // NOT_PRODUCT
352 
353 void CompactibleSpace::initialize(MemRegion mr,
354                                   bool clear_space,
355                                   bool mangle_space) {
356   Space::initialize(mr, clear_space, mangle_space);
357   set_compaction_top(bottom());
358   _next_compaction_space = NULL;
359 }
360 
361 void CompactibleSpace::clear(bool mangle_space) {
362   Space::clear(mangle_space);
363   _compaction_top = bottom();
364 }
365 
366 HeapWord* CompactibleSpace::forward(oop q, size_t size,
367                                     CompactPoint* cp, HeapWord* compact_top) {
368   // q is alive
369   // First check if we should switch compaction space
370   assert(this == cp-&gt;space, &quot;&#39;this&#39; should be current compaction space.&quot;);
371   size_t compaction_max_size = pointer_delta(end(), compact_top);
372   while (size &gt; compaction_max_size) {
373     // switch to next compaction space
374     cp-&gt;space-&gt;set_compaction_top(compact_top);
375     cp-&gt;space = cp-&gt;space-&gt;next_compaction_space();
376     if (cp-&gt;space == NULL) {
377       cp-&gt;gen = GenCollectedHeap::heap()-&gt;young_gen();
378       assert(cp-&gt;gen != NULL, &quot;compaction must succeed&quot;);
379       cp-&gt;space = cp-&gt;gen-&gt;first_compaction_space();
380       assert(cp-&gt;space != NULL, &quot;generation must have a first compaction space&quot;);
381     }
382     compact_top = cp-&gt;space-&gt;bottom();
383     cp-&gt;space-&gt;set_compaction_top(compact_top);
384     cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
385     compaction_max_size = pointer_delta(cp-&gt;space-&gt;end(), compact_top);
386   }
387 
388   // store the forwarding pointer into the mark word
389   if ((HeapWord*)q != compact_top) {
390     q-&gt;forward_to(oop(compact_top));
391     assert(q-&gt;is_gc_marked(), &quot;encoding the pointer should preserve the mark&quot;);
392   } else {
393     // if the object isn&#39;t moving we can just set the mark to the default
394     // mark and handle it specially later on.
395     q-&gt;init_mark_raw();
396     assert(q-&gt;forwardee() == NULL, &quot;should be forwarded to NULL&quot;);
397   }
398 
399   compact_top += size;
400 
401   // we need to update the offset table so that the beginnings of objects can be
402   // found during scavenge.  Note that we are updating the offset table based on
403   // where the object will be once the compaction phase finishes.
404   if (compact_top &gt; cp-&gt;threshold)
405     cp-&gt;threshold =
406       cp-&gt;space-&gt;cross_threshold(compact_top - size, compact_top);
407   return compact_top;
408 }
409 
410 #if INCLUDE_SERIALGC
411 
412 void ContiguousSpace::prepare_for_compaction(CompactPoint* cp) {
413   scan_and_forward(this, cp);
414 }
415 
416 void CompactibleSpace::adjust_pointers() {
417   // Check first is there is any work to do.
418   if (used() == 0) {
419     return;   // Nothing to do.
420   }
421 
422   scan_and_adjust_pointers(this);
423 }
424 
425 void CompactibleSpace::compact() {
426   scan_and_compact(this);
427 }
428 
429 #endif // INCLUDE_SERIALGC
430 
431 void Space::print_short() const { print_short_on(tty); }
432 
433 void Space::print_short_on(outputStream* st) const {
434   st-&gt;print(&quot; space &quot; SIZE_FORMAT &quot;K, %3d%% used&quot;, capacity() / K,
435               (int) ((double) used() * 100 / capacity()));
436 }
437 
438 void Space::print() const { print_on(tty); }
439 
440 void Space::print_on(outputStream* st) const {
441   print_short_on(st);
442   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
443                 p2i(bottom()), p2i(end()));
444 }
445 
446 void ContiguousSpace::print_on(outputStream* st) const {
447   print_short_on(st);
448   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
449                 p2i(bottom()), p2i(top()), p2i(end()));
450 }
451 
452 void OffsetTableContigSpace::print_on(outputStream* st) const {
453   print_short_on(st);
454   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot;
455                 INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
456               p2i(bottom()), p2i(top()), p2i(_offsets.threshold()), p2i(end()));
457 }
458 
459 void ContiguousSpace::verify() const {
460   HeapWord* p = bottom();
461   HeapWord* t = top();
462   HeapWord* prev_p = NULL;
463   while (p &lt; t) {
464     oopDesc::verify(oop(p));
465     prev_p = p;
466     p += oop(p)-&gt;size();
467   }
468   guarantee(p == top(), &quot;end of last object must match end of space&quot;);
469   if (top() != end()) {
470     guarantee(top() == block_start_const(end()-1) &amp;&amp;
471               top() == block_start_const(top()),
472               &quot;top should be start of unallocated block, if it exists&quot;);
473   }
474 }
475 
476 void Space::oop_iterate(OopIterateClosure* blk) {
477   ObjectToOopClosure blk2(blk);
478   object_iterate(&amp;blk2);
479 }
480 
481 bool Space::obj_is_alive(const HeapWord* p) const {
482   assert (block_is_obj(p), &quot;The address should point to an object&quot;);
483   return true;
484 }
485 
486 void ContiguousSpace::oop_iterate(OopIterateClosure* blk) {
487   if (is_empty()) return;
488   HeapWord* obj_addr = bottom();
489   HeapWord* t = top();
490   // Could call objects iterate, but this is easier.
491   while (obj_addr &lt; t) {
492     obj_addr += oop(obj_addr)-&gt;oop_iterate_size(blk);
493   }
494 }
495 
496 void ContiguousSpace::object_iterate(ObjectClosure* blk) {
497   if (is_empty()) return;
498   object_iterate_from(bottom(), blk);
499 }
500 
501 // For a ContiguousSpace object_iterate() and safe_object_iterate()
502 // are the same.
503 void ContiguousSpace::safe_object_iterate(ObjectClosure* blk) {
504   object_iterate(blk);
505 }
506 
507 void ContiguousSpace::object_iterate_from(HeapWord* mark, ObjectClosure* blk) {
508   while (mark &lt; top()) {
509     blk-&gt;do_object(oop(mark));
510     mark += oop(mark)-&gt;size();
511   }
512 }
513 
514 HeapWord*
515 ContiguousSpace::object_iterate_careful(ObjectClosureCareful* blk) {
516   HeapWord * limit = concurrent_iteration_safe_limit();
517   assert(limit &lt;= top(), &quot;sanity check&quot;);
518   for (HeapWord* p = bottom(); p &lt; limit;) {
519     size_t size = blk-&gt;do_object_careful(oop(p));
520     if (size == 0) {
521       return p;  // failed at p
522     } else {
523       p += size;
524     }
525   }
526   return NULL; // all done
527 }
528 
529 // Very general, slow implementation.
530 HeapWord* ContiguousSpace::block_start_const(const void* p) const {
531   assert(MemRegion(bottom(), end()).contains(p),
532          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
533          p2i(p), p2i(bottom()), p2i(end()));
534   if (p &gt;= top()) {
535     return top();
536   } else {
537     HeapWord* last = bottom();
538     HeapWord* cur = last;
539     while (cur &lt;= p) {
540       last = cur;
541       cur += oop(cur)-&gt;size();
542     }
543     assert(oopDesc::is_oop(oop(last)), PTR_FORMAT &quot; should be an object start&quot;, p2i(last));
544     return last;
545   }
546 }
547 
548 size_t ContiguousSpace::block_size(const HeapWord* p) const {
549   assert(MemRegion(bottom(), end()).contains(p),
550          &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
551          p2i(p), p2i(bottom()), p2i(end()));
552   HeapWord* current_top = top();
553   assert(p &lt;= current_top,
554          &quot;p &gt; current top - p: &quot; PTR_FORMAT &quot;, current top: &quot; PTR_FORMAT,
555          p2i(p), p2i(current_top));
556   assert(p == current_top || oopDesc::is_oop(oop(p)),
557          &quot;p (&quot; PTR_FORMAT &quot;) is not a block start - &quot;
558          &quot;current_top: &quot; PTR_FORMAT &quot;, is_oop: %s&quot;,
559          p2i(p), p2i(current_top), BOOL_TO_STR(oopDesc::is_oop(oop(p))));
560   if (p &lt; current_top) {
561     return oop(p)-&gt;size();
562   } else {
563     assert(p == current_top, &quot;just checking&quot;);
564     return pointer_delta(end(), (HeapWord*) p);
565   }
566 }
567 
568 // This version requires locking.
569 inline HeapWord* ContiguousSpace::allocate_impl(size_t size) {
570   assert(Heap_lock-&gt;owned_by_self() ||
571          (SafepointSynchronize::is_at_safepoint() &amp;&amp; Thread::current()-&gt;is_VM_thread()),
572          &quot;not locked&quot;);
573   HeapWord* obj = top();
574   if (pointer_delta(end(), obj) &gt;= size) {
575     HeapWord* new_top = obj + size;
576     set_top(new_top);
577     assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);
578     return obj;
579   } else {
580     return NULL;
581   }
582 }
583 
584 // This version is lock-free.
585 inline HeapWord* ContiguousSpace::par_allocate_impl(size_t size) {
586   do {
587     HeapWord* obj = top();
588     if (pointer_delta(end(), obj) &gt;= size) {
589       HeapWord* new_top = obj + size;
590       HeapWord* result = Atomic::cmpxchg(new_top, top_addr(), obj);
591       // result can be one of two:
592       //  the old top value: the exchange succeeded
593       //  otherwise: the new value of the top is returned.
594       if (result == obj) {
595         assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);
596         return obj;
597       }
598     } else {
599       return NULL;
600     }
601   } while (true);
602 }
603 
604 HeapWord* ContiguousSpace::allocate_aligned(size_t size) {
605   assert(Heap_lock-&gt;owned_by_self() || (SafepointSynchronize::is_at_safepoint() &amp;&amp; Thread::current()-&gt;is_VM_thread()), &quot;not locked&quot;);
606   HeapWord* end_value = end();
607 
608   HeapWord* obj = CollectedHeap::align_allocation_or_fail(top(), end_value, SurvivorAlignmentInBytes);
609   if (obj == NULL) {
610     return NULL;
611   }
612 
613   if (pointer_delta(end_value, obj) &gt;= size) {
614     HeapWord* new_top = obj + size;
615     set_top(new_top);
616     assert(::is_aligned(obj, SurvivorAlignmentInBytes) &amp;&amp; is_aligned(new_top),
617       &quot;checking alignment&quot;);
618     return obj;
619   } else {
620     set_top(obj);
621     return NULL;
622   }
623 }
624 
625 // Requires locking.
626 HeapWord* ContiguousSpace::allocate(size_t size) {
627   return allocate_impl(size);
628 }
629 
630 // Lock-free.
631 HeapWord* ContiguousSpace::par_allocate(size_t size) {
632   return par_allocate_impl(size);
633 }
634 
635 void ContiguousSpace::allocate_temporary_filler(int factor) {
636   // allocate temporary type array decreasing free size with factor &#39;factor&#39;
637   assert(factor &gt;= 0, &quot;just checking&quot;);
638   size_t size = pointer_delta(end(), top());
639 
640   // if space is full, return
641   if (size == 0) return;
642 
643   if (factor &gt; 0) {
644     size -= size/factor;
645   }
646   size = align_object_size(size);
647 
648   const size_t array_header_size = typeArrayOopDesc::header_size(T_INT);
649   if (size &gt;= align_object_size(array_header_size)) {
650     size_t length = (size - array_header_size) * (HeapWordSize / sizeof(jint));
651     // allocate uninitialized int array
652     typeArrayOop t = (typeArrayOop) allocate(size);
653     assert(t != NULL, &quot;allocation should succeed&quot;);
654     t-&gt;set_mark_raw(markOopDesc::prototype());
655     t-&gt;set_klass(Universe::intArrayKlassObj());
656     t-&gt;set_length((int)length);
657   } else {
658     assert(size == CollectedHeap::min_fill_size(),
659            &quot;size for smallest fake object doesn&#39;t match&quot;);
660     instanceOop obj = (instanceOop) allocate(size);
661     obj-&gt;set_mark_raw(markOopDesc::prototype());
662     obj-&gt;set_klass_gap(0);
663     obj-&gt;set_klass(SystemDictionary::Object_klass());
664   }
665 }
666 
667 HeapWord* OffsetTableContigSpace::initialize_threshold() {
668   return _offsets.initialize_threshold();
669 }
670 
671 HeapWord* OffsetTableContigSpace::cross_threshold(HeapWord* start, HeapWord* end) {
672   _offsets.alloc_block(start, end);
673   return _offsets.threshold();
674 }
675 
676 OffsetTableContigSpace::OffsetTableContigSpace(BlockOffsetSharedArray* sharedOffsetArray,
677                                                MemRegion mr) :
678   _offsets(sharedOffsetArray, mr),
679   _par_alloc_lock(Mutex::leaf, &quot;OffsetTableContigSpace par alloc lock&quot;, true)
680 {
681   _offsets.set_contig_space(this);
682   initialize(mr, SpaceDecorator::Clear, SpaceDecorator::Mangle);
683 }
684 
685 #define OBJ_SAMPLE_INTERVAL 0
686 #define BLOCK_SAMPLE_INTERVAL 100
687 
688 void OffsetTableContigSpace::verify() const {
689   HeapWord* p = bottom();
690   HeapWord* prev_p = NULL;
691   int objs = 0;
692   int blocks = 0;
693 
694   if (VerifyObjectStartArray) {
695     _offsets.verify();
696   }
697 
698   while (p &lt; top()) {
699     size_t size = oop(p)-&gt;size();
700     // For a sampling of objects in the space, find it using the
701     // block offset table.
702     if (blocks == BLOCK_SAMPLE_INTERVAL) {
703       guarantee(p == block_start_const(p + (size/2)),
704                 &quot;check offset computation&quot;);
705       blocks = 0;
706     } else {
707       blocks++;
708     }
709 
710     if (objs == OBJ_SAMPLE_INTERVAL) {
711       oopDesc::verify(oop(p));
712       objs = 0;
713     } else {
714       objs++;
715     }
716     prev_p = p;
717     p += size;
718   }
719   guarantee(p == top(), &quot;end of last object must match end of space&quot;);
720 }
721 
722 
723 size_t TenuredSpace::allowed_dead_ratio() const {
724   return MarkSweepDeadRatio;
725 }
    </pre>
  </body>
</html>
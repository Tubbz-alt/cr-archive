<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/gcTrace.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GCTRACE_HPP
 26 #define SHARE_GC_SHARED_GCTRACE_HPP
 27 
 28 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcId.hpp&quot;
 31 #include &quot;gc/shared/gcName.hpp&quot;
 32 #include &quot;gc/shared/gcWhen.hpp&quot;
 33 #include &quot;memory/metaspace.hpp&quot;
 34 #include &quot;memory/referenceType.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #include &quot;utilities/ticks.hpp&quot;
 37 #if INCLUDE_G1GC
 38 #include &quot;gc/g1/g1YCTypes.hpp&quot;
 39 #endif
 40 
 41 class G1EvacuationInfo;
 42 class GCHeapSummary;
 43 class MetaspaceChunkFreeListSummary;
 44 class MetaspaceSummary;
 45 class PSHeapSummary;
 46 class G1HeapSummary;
 47 class G1EvacSummary;
 48 class ReferenceProcessorStats;
 49 class TimePartitions;
 50 class BoolObjectClosure;
 51 
 52 class SharedGCInfo {
 53  private:
 54   GCName _name;
 55   GCCause::Cause _cause;
 56   Ticks     _start_timestamp;
 57   Ticks     _end_timestamp;
 58   Tickspan  _sum_of_pauses;
 59   Tickspan  _longest_pause;
 60 
 61  public:
 62   SharedGCInfo(GCName name) :
 63     _name(name),
 64     _cause(GCCause::_last_gc_cause),
 65     _start_timestamp(),
 66     _end_timestamp(),
 67     _sum_of_pauses(),
 68     _longest_pause() {
 69   }
 70 
 71   void set_start_timestamp(const Ticks&amp; timestamp) { _start_timestamp = timestamp; }
 72   const Ticks start_timestamp() const { return _start_timestamp; }
 73 
 74   void set_end_timestamp(const Ticks&amp; timestamp) { _end_timestamp = timestamp; }
 75   const Ticks end_timestamp() const { return _end_timestamp; }
 76 
 77   void set_name(GCName name) { _name = name; }
 78   GCName name() const { return _name; }
 79 
 80   void set_cause(GCCause::Cause cause) { _cause = cause; }
 81   GCCause::Cause cause() const { return _cause; }
 82 
 83   void set_sum_of_pauses(const Tickspan&amp; duration) { _sum_of_pauses = duration; }
 84   const Tickspan sum_of_pauses() const { return _sum_of_pauses; }
 85 
 86   void set_longest_pause(const Tickspan&amp; duration) { _longest_pause = duration; }
 87   const Tickspan longest_pause() const { return _longest_pause; }
 88 };
 89 
 90 class ParallelOldGCInfo {
 91   void* _dense_prefix;
 92  public:
 93   ParallelOldGCInfo() : _dense_prefix(NULL) {}
 94   void report_dense_prefix(void* addr) {
 95     _dense_prefix = addr;
 96   }
 97   void* dense_prefix() const { return _dense_prefix; }
 98 };
 99 
100 #if INCLUDE_G1GC
101 
102 class G1YoungGCInfo {
103   G1YCType _type;
104  public:
105   G1YoungGCInfo() : _type(G1YCTypeEndSentinel) {}
106   void set_type(G1YCType type) {
107     _type = type;
108   }
109   G1YCType type() const { return _type; }
110 };
111 
112 #endif // INCLUDE_G1GC
113 
114 class GCTracer : public ResourceObj {
115  protected:
116   SharedGCInfo _shared_gc_info;
117 
118  public:
119   void report_gc_start(GCCause::Cause cause, const Ticks&amp; timestamp);
120   void report_gc_end(const Ticks&amp; timestamp, TimePartitions* time_partitions);
121   void report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const;
122   void report_metaspace_summary(GCWhen::Type when, const MetaspaceSummary&amp; metaspace_summary) const;
123   void report_gc_reference_stats(const ReferenceProcessorStats&amp; rp) const;
124   void report_object_count_after_gc(BoolObjectClosure* object_filter) NOT_SERVICES_RETURN;
125 
126  protected:
127   GCTracer(GCName name) : _shared_gc_info(name) {}
128   virtual void report_gc_start_impl(GCCause::Cause cause, const Ticks&amp; timestamp);
129   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
130 
131  private:
132   void send_garbage_collection_event() const;
133   void send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const;
134   void send_meta_space_summary_event(GCWhen::Type when, const MetaspaceSummary&amp; meta_space_summary) const;
135   void send_metaspace_chunk_free_list_summary(GCWhen::Type when, Metaspace::MetadataType mdtype, const MetaspaceChunkFreeListSummary&amp; summary) const;
136   void send_reference_stats_event(ReferenceType type, size_t count) const;
137   void send_phase_events(TimePartitions* time_partitions) const;
138 };
139 
140 class YoungGCTracer : public GCTracer {
141   static const uint UNSET_TENURING_THRESHOLD = (uint) -1;
142 
143   uint _tenuring_threshold;
144 
145  protected:
146   YoungGCTracer(GCName name) : GCTracer(name), _tenuring_threshold(UNSET_TENURING_THRESHOLD) {}
147   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
148 
149  public:
150   void report_promotion_failed(const PromotionFailedInfo&amp; pf_info) const;
151   void report_tenuring_threshold(const uint tenuring_threshold);
152 
153   /*
154    * Methods for reporting Promotion in new or outside PLAB Events.
155    *
156    * The object age is always required as it is not certain that the mark word
157    * of the oop can be trusted at this stage.
158    *
159    * obj_size is the size of the promoted object in bytes.
160    *
161    * tenured should be true if the object has been promoted to the old
162    * space during this GC, if the object is copied to survivor space
163    * from young space or survivor space (aging) tenured should be false.
164    *
165    * plab_size is the size of the newly allocated PLAB in bytes.
166    */
167   bool should_report_promotion_events() const;
168   bool should_report_promotion_in_new_plab_event() const;
169   bool should_report_promotion_outside_plab_event() const;
170   void report_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
171                                           uint age, bool tenured,
172                                           size_t plab_size) const;
173   void report_promotion_outside_plab_event(Klass* klass, size_t obj_size,
174                                            uint age, bool tenured) const;
175 
176  private:
177   void send_young_gc_event() const;
178   void send_promotion_failed_event(const PromotionFailedInfo&amp; pf_info) const;
179   bool should_send_promotion_in_new_plab_event() const;
180   bool should_send_promotion_outside_plab_event() const;
181   void send_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
182                                         uint age, bool tenured,
183                                         size_t plab_size) const;
184   void send_promotion_outside_plab_event(Klass* klass, size_t obj_size,
185                                          uint age, bool tenured) const;
186 };
187 
188 class OldGCTracer : public GCTracer {
189  protected:
190   OldGCTracer(GCName name) : GCTracer(name) {}
191   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
192 
193  public:
194   void report_concurrent_mode_failure();
195 
196  private:
197   void send_old_gc_event() const;
198   void send_concurrent_mode_failure_event();
199 };
200 
201 class ParallelOldTracer : public OldGCTracer {
202   ParallelOldGCInfo _parallel_old_gc_info;
203 
204  public:
205   ParallelOldTracer() : OldGCTracer(ParallelOld) {}
206   void report_dense_prefix(void* dense_prefix);
207 
208  protected:
209   void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
210 
211  private:
212   void send_parallel_old_event() const;
213 };
214 
215 class SerialOldTracer : public OldGCTracer {
216  public:
217   SerialOldTracer() : OldGCTracer(SerialOld) {}
218 };
219 
220 class ParallelScavengeTracer : public YoungGCTracer {
221  public:
222   ParallelScavengeTracer() : YoungGCTracer(ParallelScavenge) {}
223 };
224 
225 class DefNewTracer : public YoungGCTracer {
226  public:
227   DefNewTracer() : YoungGCTracer(DefNew) {}
228 };
229 
230 class ParNewTracer : public YoungGCTracer {
231  public:
232   ParNewTracer() : YoungGCTracer(ParNew) {}
233 };
234 
235 #if INCLUDE_G1GC
236 class G1MMUTracer : public AllStatic {
237   static void send_g1_mmu_event(double time_slice_ms, double gc_time_ms, double max_time_ms);
238 
239  public:
240   static void report_mmu(double time_slice_sec, double gc_time_sec, double max_time_sec);
241 };
242 
243 class G1NewTracer : public YoungGCTracer {
244   G1YoungGCInfo _g1_young_gc_info;
245 
246  public:
247   G1NewTracer() : YoungGCTracer(G1New) {}
248 
249   void report_yc_type(G1YCType type);
250   void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
251   void report_evacuation_info(G1EvacuationInfo* info);
252   void report_evacuation_failed(EvacuationFailedInfo&amp; ef_info);
253 
254   void report_evacuation_statistics(const G1EvacSummary&amp; young_summary, const G1EvacSummary&amp; old_summary) const;
255 
256   void report_basic_ihop_statistics(size_t threshold,
257                                     size_t target_occupancy,
258                                     size_t current_occupancy,
259                                     size_t last_allocation_size,
260                                     double last_allocation_duration,
261                                     double last_marking_length);
262   void report_adaptive_ihop_statistics(size_t threshold,
263                                        size_t internal_target_occupancy,
264                                        size_t current_occupancy,
265                                        size_t additional_buffer_size,
266                                        double predicted_allocation_rate,
267                                        double predicted_marking_length,
268                                        bool prediction_active);
269  private:
270   void send_g1_young_gc_event();
271   void send_evacuation_info_event(G1EvacuationInfo* info);
272   void send_evacuation_failed_event(const EvacuationFailedInfo&amp; ef_info) const;
273 
274   void send_young_evacuation_statistics(const G1EvacSummary&amp; summary) const;
275   void send_old_evacuation_statistics(const G1EvacSummary&amp; summary) const;
276 
277   void send_basic_ihop_statistics(size_t threshold,
278                                   size_t target_occupancy,
279                                   size_t current_occupancy,
280                                   size_t last_allocation_size,
281                                   double last_allocation_duration,
282                                   double last_marking_length);
283   void send_adaptive_ihop_statistics(size_t threshold,
284                                      size_t internal_target_occupancy,
285                                      size_t current_occupancy,
286                                      size_t additional_buffer_size,
287                                      double predicted_allocation_rate,
288                                      double predicted_marking_length,
289                                      bool prediction_active);
290 };
291 
292 class G1FullGCTracer : public OldGCTracer {
293  public:
294   G1FullGCTracer() : OldGCTracer(G1Full) {}
295 };
296 
297 #endif // INCLUDE_G1GC
298 
299 class CMSTracer : public OldGCTracer {
300  public:
301   CMSTracer() : OldGCTracer(ConcurrentMarkSweep) {}
302 };
303 
304 class G1OldTracer : public OldGCTracer {
305  protected:
306   void report_gc_start_impl(GCCause::Cause cause, const Ticks&amp; timestamp);
307  public:
308   G1OldTracer() : OldGCTracer(G1Old) {}
309   void set_gc_cause(GCCause::Cause cause);
310 };
311 
312 #endif // SHARE_GC_SHARED_GCTRACE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/oopStorage.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_OOPSTORAGE_INLINE_HPP
 26 #define SHARE_GC_SHARED_OOPSTORAGE_INLINE_HPP
 27 
 28 #include &quot;gc/shared/oopStorage.hpp&quot;
 29 #include &quot;metaprogramming/conditional.hpp&quot;
 30 #include &quot;metaprogramming/isConst.hpp&quot;
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 
 38 // Array of all active blocks.  Refcounted for lock-free reclaim of
 39 // old array when a new array is allocated for expansion.
 40 class OopStorage::ActiveArray {
 41   friend class OopStorage::TestAccess;
 42 
 43   size_t _size;
 44   volatile size_t _block_count;
 45   mutable volatile int _refcount;
 46   // Block* _blocks[1];            // Pseudo flexible array member.
 47 
 48   ActiveArray(size_t size);
 49   ~ActiveArray();
 50 
<a name="1" id="anc1"></a><span class="line-modified"> 51   NONCOPYABLE(ActiveArray);</span>


 52 
 53   static size_t blocks_offset();
 54   Block* const* base_ptr() const;
 55 
 56   Block* const* block_ptr(size_t index) const;
 57   Block** block_ptr(size_t index);
 58 
 59 public:
 60   static ActiveArray* create(size_t size, AllocFailType alloc_fail = AllocFailStrategy::EXIT_OOM);
 61   static void destroy(ActiveArray* ba);
 62 
 63   inline Block* at(size_t i) const;
 64 
 65   size_t size() const;
 66   size_t block_count() const;
 67   size_t block_count_acquire() const;
 68   void increment_refcount() const;
 69   bool decrement_refcount() const; // Return true if zero, otherwise false
 70 
 71   // Support for OopStorage::allocate.
 72   // Add block to the end of the array.  Updates block count at the
 73   // end of the operation, with a release_store. Returns true if the
 74   // block was added, false if there was no room available.
 75   // precondition: owner&#39;s _allocation_mutex is locked, or at safepoint.
 76   bool push(Block* block);
 77 
 78   // Support OopStorage::delete_empty_blocks_xxx operations.
 79   // Remove block from the array.
 80   // precondition: block must be present at its active_index element.
 81   void remove(Block* block);
 82 
 83   void copy_from(const ActiveArray* from);
 84 };
 85 
 86 inline size_t OopStorage::ActiveArray::blocks_offset() {
 87   return align_up(sizeof(ActiveArray), sizeof(Block*));
 88 }
 89 
 90 inline OopStorage::Block* const* OopStorage::ActiveArray::base_ptr() const {
 91   const void* ptr = reinterpret_cast&lt;const char*&gt;(this) + blocks_offset();
 92   return reinterpret_cast&lt;Block* const*&gt;(ptr);
 93 }
 94 
 95 inline OopStorage::Block* const* OopStorage::ActiveArray::block_ptr(size_t index) const {
 96   return base_ptr() + index;
 97 }
 98 
 99 inline OopStorage::Block** OopStorage::ActiveArray::block_ptr(size_t index) {
100   return const_cast&lt;Block**&gt;(base_ptr() + index);
101 }
102 
103 inline OopStorage::Block* OopStorage::ActiveArray::at(size_t index) const {
104   assert(index &lt; _block_count, &quot;precondition&quot;);
105   return *block_ptr(index);
106 }
107 
108 // A Block has an embedded AllocationListEntry to provide the links between
109 // Blocks in an AllocationList.
110 class OopStorage::AllocationListEntry {
111   friend class OopStorage::AllocationList;
112 
113   // Members are mutable, and we deal exclusively with pointers to
114   // const, to make const blocks easier to use; a block being const
115   // doesn&#39;t prevent modifying its list state.
116   mutable const Block* _prev;
117   mutable const Block* _next;
118 
<a name="2" id="anc2"></a><span class="line-modified">119   NONCOPYABLE(AllocationListEntry);</span>


120 
121 public:
122   AllocationListEntry();
123   ~AllocationListEntry();
124 };
125 
126 // Fixed-sized array of oops, plus bookkeeping data.
127 // All blocks are in the storage&#39;s _active_array, at the block&#39;s _active_index.
128 // Non-full blocks are in the storage&#39;s _allocation_list, linked through the
129 // block&#39;s _allocation_list_entry.  Empty blocks are at the end of that list.
130 class OopStorage::Block /* No base class, to avoid messing up alignment. */ {
131   // _data must be the first non-static data member, for alignment.
132   oop _data[BitsPerWord];
133   static const unsigned _data_pos = 0; // Position of _data.
134 
135   volatile uintx _allocated_bitmask; // One bit per _data element.
<a name="3" id="anc3"></a><span class="line-modified">136   intptr_t _owner_address;</span>
137   void* _memory;              // Unaligned storage containing block.
138   size_t _active_index;
139   AllocationListEntry _allocation_list_entry;
140   Block* volatile _deferred_updates_next;
141   volatile uintx _release_refcount;
142 
143   Block(const OopStorage* owner, void* memory);
144   ~Block();
145 
146   void check_index(unsigned index) const;
147   unsigned get_index(const oop* ptr) const;
148 
149   template&lt;typename F, typename BlockPtr&gt;
150   static bool iterate_impl(F f, BlockPtr b);
151 
<a name="4" id="anc4"></a><span class="line-modified">152   NONCOPYABLE(Block);</span>


153 
154 public:
155   const AllocationListEntry&amp; allocation_list_entry() const;
156 
157   static size_t allocation_size();
158   static size_t allocation_alignment_shift();
159 
160   oop* get_pointer(unsigned index);
161   const oop* get_pointer(unsigned index) const;
162 
163   uintx bitmask_for_index(unsigned index) const;
164   uintx bitmask_for_entry(const oop* ptr) const;
165 
166   // Allocation bitmask accessors are racy.
167   bool is_full() const;
168   bool is_empty() const;
169   uintx allocated_bitmask() const;
170 
171   bool is_safe_to_delete() const;
172 
173   Block* deferred_updates_next() const;
174   void set_deferred_updates_next(Block* new_next);
175 
176   bool contains(const oop* ptr) const;
177 
178   size_t active_index() const;
179   void set_active_index(size_t index);
180   static size_t active_index_safe(const Block* block); // Returns 0 if access fails.
181 
182   // Returns NULL if ptr is not in a block or not allocated in that block.
183   static Block* block_for_ptr(const OopStorage* owner, const oop* ptr);
184 
185   oop* allocate();
186   static Block* new_block(const OopStorage* owner);
187   static void delete_block(const Block&amp; block);
188 
189   void release_entries(uintx releasing, OopStorage* owner);
190 
191   template&lt;typename F&gt; bool iterate(F f);
192   template&lt;typename F&gt; bool iterate(F f) const;
193 }; // class Block
194 
195 inline OopStorage::Block* OopStorage::AllocationList::head() {
196   return const_cast&lt;Block*&gt;(_head);
197 }
198 
199 inline OopStorage::Block* OopStorage::AllocationList::tail() {
200   return const_cast&lt;Block*&gt;(_tail);
201 }
202 
203 inline const OopStorage::Block* OopStorage::AllocationList::chead() const {
204   return _head;
205 }
206 
207 inline const OopStorage::Block* OopStorage::AllocationList::ctail() const {
208   return _tail;
209 }
210 
211 inline OopStorage::Block* OopStorage::AllocationList::prev(Block&amp; block) {
212   return const_cast&lt;Block*&gt;(block.allocation_list_entry()._prev);
213 }
214 
215 inline OopStorage::Block* OopStorage::AllocationList::next(Block&amp; block) {
216   return const_cast&lt;Block*&gt;(block.allocation_list_entry()._next);
217 }
218 
219 inline const OopStorage::Block* OopStorage::AllocationList::prev(const Block&amp; block) const {
220   return block.allocation_list_entry()._prev;
221 }
222 
223 inline const OopStorage::Block* OopStorage::AllocationList::next(const Block&amp; block) const {
224   return block.allocation_list_entry()._next;
225 }
226 
227 template&lt;typename Closure&gt;
228 class OopStorage::OopFn {
229 public:
230   explicit OopFn(Closure* cl) : _cl(cl) {}
231 
232   template&lt;typename OopPtr&gt;     // [const] oop*
233   bool operator()(OopPtr ptr) const {
234     _cl-&gt;do_oop(ptr);
235     return true;
236   }
237 
238 private:
239   Closure* _cl;
240 };
241 
242 template&lt;typename Closure&gt;
243 inline OopStorage::OopFn&lt;Closure&gt; OopStorage::oop_fn(Closure* cl) {
244   return OopFn&lt;Closure&gt;(cl);
245 }
246 
247 template&lt;typename IsAlive, typename F&gt;
248 class OopStorage::IfAliveFn {
249 public:
250   IfAliveFn(IsAlive* is_alive, F f) : _is_alive(is_alive), _f(f) {}
251 
252   bool operator()(oop* ptr) const {
253     bool result = true;
254     oop v = *ptr;
255     if (v != NULL) {
256       if (_is_alive-&gt;do_object_b(v)) {
257         result = _f(ptr);
258       } else {
259         *ptr = NULL;            // Clear dead value.
260       }
261     }
262     return result;
263   }
264 
265 private:
266   IsAlive* _is_alive;
267   F _f;
268 };
269 
270 template&lt;typename IsAlive, typename F&gt;
271 inline OopStorage::IfAliveFn&lt;IsAlive, F&gt; OopStorage::if_alive_fn(IsAlive* is_alive, F f) {
272   return IfAliveFn&lt;IsAlive, F&gt;(is_alive, f);
273 }
274 
275 template&lt;typename F&gt;
276 class OopStorage::SkipNullFn {
277 public:
278   SkipNullFn(F f) : _f(f) {}
279 
280   template&lt;typename OopPtr&gt;     // [const] oop*
281   bool operator()(OopPtr ptr) const {
282     return (*ptr != NULL) ? _f(ptr) : true;
283   }
284 
285 private:
286   F _f;
287 };
288 
289 template&lt;typename F&gt;
290 inline OopStorage::SkipNullFn&lt;F&gt; OopStorage::skip_null_fn(F f) {
291   return SkipNullFn&lt;F&gt;(f);
292 }
293 
294 // Inline Block accesses for use in iteration loops.
295 
296 inline const OopStorage::AllocationListEntry&amp; OopStorage::Block::allocation_list_entry() const {
297   return _allocation_list_entry;
298 }
299 
300 inline void OopStorage::Block::check_index(unsigned index) const {
301   assert(index &lt; ARRAY_SIZE(_data), &quot;Index out of bounds: %u&quot;, index);
302 }
303 
304 inline oop* OopStorage::Block::get_pointer(unsigned index) {
305   check_index(index);
306   return &amp;_data[index];
307 }
308 
309 inline const oop* OopStorage::Block::get_pointer(unsigned index) const {
310   check_index(index);
311   return &amp;_data[index];
312 }
313 
314 inline uintx OopStorage::Block::allocated_bitmask() const {
315   return _allocated_bitmask;
316 }
317 
318 inline uintx OopStorage::Block::bitmask_for_index(unsigned index) const {
319   check_index(index);
320   return uintx(1) &lt;&lt; index;
321 }
322 
323 // Provide const or non-const iteration, depending on whether BlockPtr
324 // is const Block* or Block*, respectively.
325 template&lt;typename F, typename BlockPtr&gt; // BlockPtr := [const] Block*
326 inline bool OopStorage::Block::iterate_impl(F f, BlockPtr block) {
327   uintx bitmask = block-&gt;allocated_bitmask();
328   while (bitmask != 0) {
329     unsigned index = count_trailing_zeros(bitmask);
330     bitmask ^= block-&gt;bitmask_for_index(index);
331     if (!f(block-&gt;get_pointer(index))) {
332       return false;
333     }
334   }
335   return true;
336 }
337 
338 template&lt;typename F&gt;
339 inline bool OopStorage::Block::iterate(F f) {
340   return iterate_impl(f, this);
341 }
342 
343 template&lt;typename F&gt;
344 inline bool OopStorage::Block::iterate(F f) const {
345   return iterate_impl(f, this);
346 }
347 
348 //////////////////////////////////////////////////////////////////////////////
349 // Support for serial iteration, always at a safepoint.
350 
351 // Provide const or non-const iteration, depending on whether Storage is
352 // const OopStorage* or OopStorage*, respectively.
353 template&lt;typename F, typename Storage&gt; // Storage := [const] OopStorage
354 inline bool OopStorage::iterate_impl(F f, Storage* storage) {
355   assert_at_safepoint();
356   // Propagate const/non-const iteration to the block layer, by using
357   // const or non-const blocks as corresponding to Storage.
358   typedef typename Conditional&lt;IsConst&lt;Storage&gt;::value, const Block*, Block*&gt;::type BlockPtr;
359   ActiveArray* blocks = storage-&gt;_active_array;
360   size_t limit = blocks-&gt;block_count();
361   for (size_t i = 0; i &lt; limit; ++i) {
362     BlockPtr block = blocks-&gt;at(i);
363     if (!block-&gt;iterate(f)) {
364       return false;
365     }
366   }
367   return true;
368 }
369 
370 template&lt;typename F&gt;
371 inline bool OopStorage::iterate_safepoint(F f) {
372   return iterate_impl(f, this);
373 }
374 
375 template&lt;typename F&gt;
376 inline bool OopStorage::iterate_safepoint(F f) const {
377   return iterate_impl(f, this);
378 }
379 
380 template&lt;typename Closure&gt;
381 inline void OopStorage::oops_do(Closure* cl) {
382   iterate_safepoint(oop_fn(cl));
383 }
384 
385 template&lt;typename Closure&gt;
386 inline void OopStorage::oops_do(Closure* cl) const {
387   iterate_safepoint(oop_fn(cl));
388 }
389 
390 template&lt;typename Closure&gt;
391 inline void OopStorage::weak_oops_do(Closure* cl) {
392   iterate_safepoint(skip_null_fn(oop_fn(cl)));
393 }
394 
395 template&lt;typename IsAliveClosure, typename Closure&gt;
396 inline void OopStorage::weak_oops_do(IsAliveClosure* is_alive, Closure* cl) {
397   iterate_safepoint(if_alive_fn(is_alive, oop_fn(cl)));
398 }
399 
400 #endif // SHARE_GC_SHARED_OOPSTORAGE_INLINE_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
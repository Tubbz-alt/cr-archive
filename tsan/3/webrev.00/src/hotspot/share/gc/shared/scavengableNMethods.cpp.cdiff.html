<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/scavengableNMethods.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="satbMarkQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/scavengableNMethods.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,17 ***</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
<span class="line-removed">- #include &quot;compiler/compileTask.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
  #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<span class="line-modified">! #include &quot;logging/log.hpp&quot;</span>
<span class="line-removed">- #include &quot;logging/logStream.hpp&quot;</span>
<span class="line-removed">- #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  
  static ScavengableNMethodsData gc_data(nmethod* nm) {
    return ScavengableNMethodsData(nm);
  }
<span class="line-new-header">--- 23,13 ---</span>
   */
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;code/codeCache.hpp&quot;
  #include &quot;code/nmethod.hpp&quot;
  #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<span class="line-modified">! #include &quot;runtime/mutexLocker.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  
  static ScavengableNMethodsData gc_data(nmethod* nm) {
    return ScavengableNMethodsData(nm);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,16 ***</span>
  
    data.set_on_list();
    data.set_next(_head);
  
    _head = nm;
<span class="line-removed">- </span>
<span class="line-removed">-   CodeCache::print_trace(&quot;register_nmethod&quot;, nm);</span>
  }
  
  void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<span class="line-modified">!   // Do nothing. Unlinking is currently delayed until the purge phase.</span>
  }
  
  #ifndef PRODUCT
  
  class DebugScavengableOops: public OopClosure {
<span class="line-new-header">--- 54,25 ---</span>
  
    data.set_on_list();
    data.set_next(_head);
  
    _head = nm;
  }
  
  void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<span class="line-modified">!   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (gc_data(nm).on_list()) {</span>
<span class="line-added">+     nmethod* prev = NULL;</span>
<span class="line-added">+     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-added">+       if (cur == nm) {</span>
<span class="line-added">+         unlist_nmethod(cur, prev);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       prev = cur;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  }
  
  #ifndef PRODUCT
  
  class DebugScavengableOops: public OopClosure {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,133 ***</span>
    }
    assert(gc_data(nm).not_marked(), &quot;&quot;);
  #endif // PRODUCT
  }
  
<span class="line-removed">- void ScavengableNMethods::flush_nmethod(nmethod* nm) {</span>
<span class="line-removed">-   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // TODO: Should be done in unregister_nmethod, during the &quot;unlink&quot; phase.</span>
<span class="line-removed">-   if (gc_data(nm).on_list()) {</span>
<span class="line-removed">-     CodeCache::print_trace(&quot;flush_nmethod&quot;, nm);</span>
<span class="line-removed">-     nmethod* prev = NULL;</span>
<span class="line-removed">-     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-removed">-       if (cur == nm) {</span>
<span class="line-removed">-         unlist_nmethod(cur, prev);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       prev = cur;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  class HasScavengableOops: public OopClosure {
    BoolObjectClosure* _is_scavengable;
    bool               _found;
<span class="line-removed">-   nmethod*           _print_nm;</span>
  public:
    HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
        _is_scavengable(is_scavengable),
<span class="line-modified">!       _found(false),</span>
<span class="line-removed">-       _print_nm(nm) {}</span>
  
    bool found() { return _found; }
    virtual void do_oop(oop* p) {
<span class="line-modified">!     if (*p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>
<span class="line-removed">-       NOT_PRODUCT(maybe_print(p));</span>
        _found = true;
      }
    }
    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-   void maybe_print(oop* p) {</span>
<span class="line-removed">-     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">-     if (lt.is_enabled()) {</span>
<span class="line-removed">-       LogStream ls(lt);</span>
<span class="line-removed">-       if (!_found) {</span>
<span class="line-removed">-         CompileTask::print(&amp;ls, _print_nm, &quot;new scavengable oop&quot;, /*short_form:*/ true);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       ls.print(&quot;&quot; PTR_FORMAT &quot;[offset=%d] found scavengable oop &quot; PTR_FORMAT &quot; (found at &quot; PTR_FORMAT &quot;) &quot;,</span>
<span class="line-removed">-                p2i(_print_nm), (int)((intptr_t)p - (intptr_t)_print_nm),</span>
<span class="line-removed">-                p2i(*p), p2i(p));</span>
<span class="line-removed">-       ls.cr();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif //PRODUCT</span>
  };
  
  bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
    HasScavengableOops cl(_is_scavengable, nm);
    nm-&gt;oops_do(&amp;cl);
    return cl.found();
  }
  
  // Walk the list of methods which might contain oops to the java heap.
<span class="line-modified">! void ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure* f) {</span>
    assert_locked_or_safepoint(CodeCache_lock);
  
<span class="line-removed">-   const bool fix_relocations = f-&gt;fix_relocations();</span>
    debug_only(mark_on_list_nmethods());
  
    nmethod* prev = NULL;
    nmethod* cur = _head;
    while (cur != NULL) {
      ScavengableNMethodsData data = gc_data(cur);
      debug_only(data.clear_marked());
<span class="line-removed">-     assert(data.not_marked(), &quot;&quot;);</span>
      assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
  
<span class="line-modified">!     bool is_live = (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded());</span>
<span class="line-modified">!     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">-     if (lt.is_enabled()) {</span>
<span class="line-removed">-       LogStream ls(lt);</span>
<span class="line-removed">-       CompileTask::print(&amp;ls, cur,</span>
<span class="line-removed">-         is_live ? &quot;scavengable root &quot; : &quot;dead scavengable root&quot;, /*short_form:*/ true);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (is_live) {</span>
<span class="line-removed">-       // Perform cur-&gt;oops_do(f), maybe just once per nmethod.</span>
<span class="line-removed">-       f-&gt;do_code_blob(cur);</span>
      }
      nmethod* const next = data.next();
<span class="line-modified">!     // The scavengable nmethod list must contain all methods with scavengable</span>
<span class="line-modified">!     // oops. It is safe to include more nmethod on the list, but we do not</span>
<span class="line-modified">!     // expect any live non-scavengable nmethods on the list.</span>
<span class="line-modified">!     if (fix_relocations) {</span>
<span class="line-modified">!       if (!is_live || !has_scavengable_oops(cur)) {</span>
<span class="line-removed">-         unlist_nmethod(cur, prev);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         prev = cur;</span>
<span class="line-removed">-       }</span>
      }
      cur = next;
    }
  
    // Check for stray marks.
    debug_only(verify_unlisted_nmethods(NULL));
  }
  
  #ifndef PRODUCT
<span class="line-modified">! void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* f) {</span>
    // While we are here, verify the integrity of the list.
    mark_on_list_nmethods();
    for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
      assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
      gc_data(cur).clear_marked();
    }
<span class="line-modified">!   verify_unlisted_nmethods(f);</span>
  }
  #endif // PRODUCT
  
  void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
    assert_locked_or_safepoint(CodeCache_lock);
  
    assert((prev == NULL &amp;&amp; _head == nm) ||
           (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
  
<span class="line-removed">-   CodeCache::print_trace(&quot;unlist_nmethod&quot;, nm);</span>
<span class="line-removed">- </span>
    ScavengableNMethodsData data = gc_data(nm);
  
    if (prev == NULL) {
      _head = data.next();
    } else {
<span class="line-new-header">--- 115,94 ---</span>
    }
    assert(gc_data(nm).not_marked(), &quot;&quot;);
  #endif // PRODUCT
  }
  
  class HasScavengableOops: public OopClosure {
    BoolObjectClosure* _is_scavengable;
    bool               _found;
  public:
    HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
        _is_scavengable(is_scavengable),
<span class="line-modified">!       _found(false) {}</span>
  
    bool found() { return _found; }
    virtual void do_oop(oop* p) {
<span class="line-modified">!     if (!_found &amp;&amp; *p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>
        _found = true;
      }
    }
    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
  };
  
  bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
    HasScavengableOops cl(_is_scavengable, nm);
    nm-&gt;oops_do(&amp;cl);
    return cl.found();
  }
  
  // Walk the list of methods which might contain oops to the java heap.
<span class="line-modified">! void ScavengableNMethods::nmethods_do_and_prune(CodeBlobToOopClosure* cl) {</span>
    assert_locked_or_safepoint(CodeCache_lock);
  
    debug_only(mark_on_list_nmethods());
  
    nmethod* prev = NULL;
    nmethod* cur = _head;
    while (cur != NULL) {
<span class="line-added">+     assert(cur-&gt;is_alive(), &quot;Must be&quot;);</span>
<span class="line-added">+ </span>
      ScavengableNMethodsData data = gc_data(cur);
      debug_only(data.clear_marked());
      assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
  
<span class="line-modified">!     if (cl != NULL) {</span>
<span class="line-modified">!       cl-&gt;do_code_blob(cur);</span>
      }
<span class="line-added">+ </span>
      nmethod* const next = data.next();
<span class="line-modified">! </span>
<span class="line-modified">!     if (!has_scavengable_oops(cur)) {</span>
<span class="line-modified">!       unlist_nmethod(cur, prev);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       prev = cur;</span>
      }
<span class="line-added">+ </span>
      cur = next;
    }
  
    // Check for stray marks.
    debug_only(verify_unlisted_nmethods(NULL));
  }
  
<span class="line-added">+ void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-added">+   nmethods_do_and_prune(NULL /* No closure */);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Walk the list of methods which might contain oops to the java heap.</span>
<span class="line-added">+ void ScavengableNMethods::nmethods_do(CodeBlobToOopClosure* cl) {</span>
<span class="line-added">+   nmethods_do_and_prune(cl);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
<span class="line-modified">! void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) {</span>
    // While we are here, verify the integrity of the list.
    mark_on_list_nmethods();
    for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
      assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
      gc_data(cur).clear_marked();
    }
<span class="line-modified">!   verify_unlisted_nmethods(cl);</span>
  }
  #endif // PRODUCT
  
  void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
    assert_locked_or_safepoint(CodeCache_lock);
  
    assert((prev == NULL &amp;&amp; _head == nm) ||
           (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
  
    ScavengableNMethodsData data = gc_data(nm);
  
    if (prev == NULL) {
      _head = data.next();
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,37 ***</span>
    }
    data.set_next(NULL);
    data.clear_on_list();
  }
  
<span class="line-removed">- void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-removed">-   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   debug_only(mark_on_list_nmethods());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   nmethod* last = NULL;</span>
<span class="line-removed">-   nmethod* cur = _head;</span>
<span class="line-removed">-   while (cur != NULL) {</span>
<span class="line-removed">-     nmethod* next = gc_data(cur).next();</span>
<span class="line-removed">-     debug_only(gc_data(cur).clear_marked());</span>
<span class="line-removed">-     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded() &amp;&amp; has_scavengable_oops(cur)) {</span>
<span class="line-removed">-       // Keep it.  Advance &#39;last&#39; to prevent deletion.</span>
<span class="line-removed">-       last = cur;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       // Prune it from the list, so we don&#39;t have to look at it any more.</span>
<span class="line-removed">-       CodeCache::print_trace(&quot;prune_nmethods&quot;, cur);</span>
<span class="line-removed">-       unlist_nmethod(cur, last);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     cur = next;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check for stray marks.</span>
<span class="line-removed">-   debug_only(verify_unlisted_nmethods(NULL));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #ifndef PRODUCT
  // Temporarily mark nmethods that are claimed to be on the scavenge list.
  void ScavengableNMethods::mark_on_list_nmethods() {
    NMethodIterator iter(NMethodIterator::only_alive);
    while(iter.next()) {
<span class="line-new-header">--- 210,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,19 ***</span>
    }
  }
  
  // If the closure is given, run it on the unlisted nmethods.
  // Also make sure that the effects of mark_on_list_nmethods is gone.
<span class="line-modified">! void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* f_or_null) {</span>
    NMethodIterator iter(NMethodIterator::only_alive);
    while(iter.next()) {
      nmethod* nm = iter.method();
  
      verify_nmethod(nm);
  
<span class="line-modified">!     if (f_or_null != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">!       f_or_null-&gt;do_code_blob(nm);</span>
      }
    }
  }
  
  #endif //PRODUCT
<span class="line-new-header">--- 225,19 ---</span>
    }
  }
  
  // If the closure is given, run it on the unlisted nmethods.
  // Also make sure that the effects of mark_on_list_nmethods is gone.
<span class="line-modified">! void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* cl) {</span>
    NMethodIterator iter(NMethodIterator::only_alive);
    while(iter.next()) {
      nmethod* nm = iter.method();
  
      verify_nmethod(nm);
  
<span class="line-modified">!     if (cl != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">!       cl-&gt;do_code_blob(nm);</span>
      }
    }
  }
  
  #endif //PRODUCT
</pre>
<center><a href="satbMarkQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
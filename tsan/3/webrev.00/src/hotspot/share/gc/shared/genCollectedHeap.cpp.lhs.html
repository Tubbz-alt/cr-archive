<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;gc/serial/defNewGeneration.hpp&quot;
  35 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  36 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  37 #include &quot;gc/shared/cardTableRS.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  39 #include &quot;gc/shared/collectorCounters.hpp&quot;
  40 #include &quot;gc/shared/gcId.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.hpp&quot;
  42 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  43 #include &quot;gc/shared/gcTrace.hpp&quot;
  44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<a name="2" id="anc2"></a>
  45 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  46 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  47 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  48 #include &quot;gc/shared/generationSpec.hpp&quot;
<a name="3" id="anc3"></a>
  49 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  50 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  51 #include &quot;gc/shared/space.hpp&quot;
  52 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  53 #include &quot;gc/shared/weakProcessor.hpp&quot;
  54 #include &quot;gc/shared/workgroup.hpp&quot;
  55 #include &quot;memory/filemap.hpp&quot;
<a name="4" id="anc4"></a>
  56 #include &quot;memory/metaspaceCounters.hpp&quot;
  57 #include &quot;memory/resourceArea.hpp&quot;
<a name="5" id="anc5"></a>
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;runtime/biasedLocking.hpp&quot;
  60 #include &quot;runtime/flags/flagSetting.hpp&quot;
  61 #include &quot;runtime/handles.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/vmThread.hpp&quot;
  65 #include &quot;services/management.hpp&quot;
  66 #include &quot;services/memoryService.hpp&quot;
  67 #include &quot;utilities/debug.hpp&quot;
  68 #include &quot;utilities/formatBuffer.hpp&quot;
  69 #include &quot;utilities/macros.hpp&quot;
  70 #include &quot;utilities/stack.inline.hpp&quot;
  71 #include &quot;utilities/vmError.hpp&quot;
<a name="6" id="anc6"></a>


  72 
<a name="7" id="anc7"></a><span class="line-modified">  73 GenCollectedHeap::GenCollectedHeap(GenCollectorPolicy *policy,</span>
<span class="line-removed">  74                                    Generation::Name young,</span>
  75                                    Generation::Name old,
  76                                    const char* policy_counters_name) :
  77   CollectedHeap(),
  78   _young_gen_spec(new GenerationSpec(young,
<a name="8" id="anc8"></a><span class="line-modified">  79                                      policy-&gt;initial_young_size(),</span>
<span class="line-modified">  80                                      policy-&gt;max_young_size(),</span>
<span class="line-modified">  81                                      policy-&gt;gen_alignment())),</span>
  82   _old_gen_spec(new GenerationSpec(old,
<a name="9" id="anc9"></a><span class="line-modified">  83                                    policy-&gt;initial_old_size(),</span>
<span class="line-modified">  84                                    policy-&gt;max_old_size(),</span>
<span class="line-modified">  85                                    policy-&gt;gen_alignment())),</span>
  86   _rem_set(NULL),
<a name="10" id="anc10"></a><span class="line-removed">  87   _gen_policy(policy),</span>
  88   _soft_ref_gen_policy(),
  89   _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),
  90   _full_collections_completed(0),
  91   _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)) {
  92 }
  93 
  94 jint GenCollectedHeap::initialize() {
  95   // While there are no constraints in the GC code that HeapWordSize
  96   // be any particular value, there are multiple other areas in the
  97   // system which believe this to be true (e.g. oop-&gt;object_size in some
  98   // cases incorrectly returns the size in wordSize units rather than
  99   // HeapWordSize).
 100   guarantee(HeapWordSize == wordSize, &quot;HeapWordSize must equal wordSize&quot;);
 101 
 102   // Allocate space for the heap.
 103 
<a name="11" id="anc11"></a><span class="line-modified"> 104   char* heap_address;</span>
<span class="line-removed"> 105   ReservedSpace heap_rs;</span>
<span class="line-removed"> 106 </span>
<span class="line-removed"> 107   size_t heap_alignment = collector_policy()-&gt;heap_alignment();</span>
<span class="line-removed"> 108 </span>
<span class="line-removed"> 109   heap_address = allocate(heap_alignment, &amp;heap_rs);</span>
 110 
 111   if (!heap_rs.is_reserved()) {
 112     vm_shutdown_during_initialization(
 113       &quot;Could not reserve enough space for object heap&quot;);
 114     return JNI_ENOMEM;
 115   }
 116 
<a name="12" id="anc12"></a><span class="line-modified"> 117   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size()));</span>
 118 
<a name="13" id="anc13"></a><span class="line-modified"> 119   _rem_set = create_rem_set(reserved_region());</span>
 120   _rem_set-&gt;initialize();
 121   CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
 122   bs-&gt;initialize();
 123   BarrierSet::set_barrier_set(bs);
 124 
 125   ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec-&gt;max_size(), false, false);
 126   _young_gen = _young_gen_spec-&gt;init(young_rs, rem_set());
<a name="14" id="anc14"></a><span class="line-modified"> 127   heap_rs = heap_rs.last_part(_young_gen_spec-&gt;max_size());</span>
 128 
<a name="15" id="anc15"></a><span class="line-modified"> 129   ReservedSpace old_rs = heap_rs.first_part(_old_gen_spec-&gt;max_size(), false, false);</span>
 130   _old_gen = _old_gen_spec-&gt;init(old_rs, rem_set());
 131   clear_incremental_collection_failed();
 132 
 133   return JNI_OK;
 134 }
 135 
 136 CardTableRS* GenCollectedHeap::create_rem_set(const MemRegion&amp; reserved_region) {
 137   return new CardTableRS(reserved_region, false /* scan_concurrently */);
 138 }
 139 
 140 void GenCollectedHeap::initialize_size_policy(size_t init_eden_size,
 141                                               size_t init_promo_size,
 142                                               size_t init_survivor_size) {
 143   const double max_gc_pause_sec = ((double) MaxGCPauseMillis) / 1000.0;
 144   _size_policy = new AdaptiveSizePolicy(init_eden_size,
 145                                         init_promo_size,
 146                                         init_survivor_size,
 147                                         max_gc_pause_sec,
 148                                         GCTimeRatio);
 149 }
 150 
<a name="16" id="anc16"></a><span class="line-modified"> 151 char* GenCollectedHeap::allocate(size_t alignment,</span>
<span class="line-removed"> 152                                  ReservedSpace* heap_rs){</span>
 153   // Now figure out the total size.
 154   const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();
 155   assert(alignment % pageSize == 0, &quot;Must be&quot;);
 156 
 157   // Check for overflow.
 158   size_t total_reserved = _young_gen_spec-&gt;max_size() + _old_gen_spec-&gt;max_size();
 159   if (total_reserved &lt; _young_gen_spec-&gt;max_size()) {
 160     vm_exit_during_initialization(&quot;The size of the object heap + VM data exceeds &quot;
 161                                   &quot;the maximum representable size&quot;);
 162   }
 163   assert(total_reserved % alignment == 0,
 164          &quot;Gen size; total_reserved=&quot; SIZE_FORMAT &quot;, alignment=&quot;
 165          SIZE_FORMAT, total_reserved, alignment);
 166 
<a name="17" id="anc17"></a><span class="line-modified"> 167   *heap_rs = Universe::reserve_heap(total_reserved, alignment);</span>
 168 
 169   os::trace_page_sizes(&quot;Heap&quot;,
<a name="18" id="anc18"></a><span class="line-modified"> 170                        collector_policy()-&gt;min_heap_byte_size(),</span>
 171                        total_reserved,
 172                        alignment,
<a name="19" id="anc19"></a><span class="line-modified"> 173                        heap_rs-&gt;base(),</span>
<span class="line-modified"> 174                        heap_rs-&gt;size());</span>
 175 
<a name="20" id="anc20"></a><span class="line-modified"> 176   return heap_rs-&gt;base();</span>
 177 }
 178 
 179 class GenIsScavengable : public BoolObjectClosure {
 180 public:
 181   bool do_object_b(oop obj) {
 182     return GenCollectedHeap::heap()-&gt;is_in_young(obj);
 183   }
 184 };
 185 
 186 static GenIsScavengable _is_scavengable;
 187 
 188 void GenCollectedHeap::post_initialize() {
 189   CollectedHeap::post_initialize();
 190   ref_processing_init();
 191 
 192   DefNewGeneration* def_new_gen = (DefNewGeneration*)_young_gen;
 193 
 194   initialize_size_policy(def_new_gen-&gt;eden()-&gt;capacity(),
 195                          _old_gen-&gt;capacity(),
 196                          def_new_gen-&gt;from()-&gt;capacity());
 197 
 198   MarkSweep::initialize();
 199 
 200   ScavengableNMethods::initialize(&amp;_is_scavengable);
 201 }
 202 
 203 void GenCollectedHeap::ref_processing_init() {
 204   _young_gen-&gt;ref_processor_init();
 205   _old_gen-&gt;ref_processor_init();
 206 }
 207 
<a name="21" id="anc21"></a>












 208 GenerationSpec* GenCollectedHeap::young_gen_spec() const {
 209   return _young_gen_spec;
 210 }
 211 
 212 GenerationSpec* GenCollectedHeap::old_gen_spec() const {
 213   return _old_gen_spec;
 214 }
 215 
 216 size_t GenCollectedHeap::capacity() const {
 217   return _young_gen-&gt;capacity() + _old_gen-&gt;capacity();
 218 }
 219 
 220 size_t GenCollectedHeap::used() const {
 221   return _young_gen-&gt;used() + _old_gen-&gt;used();
 222 }
 223 
 224 void GenCollectedHeap::save_used_regions() {
 225   _old_gen-&gt;save_used_region();
 226   _young_gen-&gt;save_used_region();
 227 }
 228 
 229 size_t GenCollectedHeap::max_capacity() const {
 230   return _young_gen-&gt;max_capacity() + _old_gen-&gt;max_capacity();
 231 }
 232 
 233 // Update the _full_collections_completed counter
 234 // at the end of a stop-world full GC.
 235 unsigned int GenCollectedHeap::update_full_collections_completed() {
<a name="22" id="anc22"></a><span class="line-modified"> 236   MonitorLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
 237   assert(_full_collections_completed &lt;= _total_full_collections,
 238          &quot;Can&#39;t complete more collections than were started&quot;);
 239   _full_collections_completed = _total_full_collections;
 240   ml.notify_all();
 241   return _full_collections_completed;
 242 }
 243 
 244 // Update the _full_collections_completed counter, as appropriate,
 245 // at the end of a concurrent GC cycle. Note the conditional update
 246 // below to allow this method to be called by a concurrent collector
 247 // without synchronizing in any manner with the VM thread (which
 248 // may already have initiated a STW full collection &quot;concurrently&quot;).
 249 unsigned int GenCollectedHeap::update_full_collections_completed(unsigned int count) {
<a name="23" id="anc23"></a><span class="line-modified"> 250   MonitorLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
 251   assert((_full_collections_completed &lt;= _total_full_collections) &amp;&amp;
 252          (count &lt;= _total_full_collections),
 253          &quot;Can&#39;t complete more collections than were started&quot;);
 254   if (count &gt; _full_collections_completed) {
 255     _full_collections_completed = count;
 256     ml.notify_all();
 257   }
 258   return _full_collections_completed;
 259 }
 260 
 261 // Return true if any of the following is true:
 262 // . the allocation won&#39;t fit into the current young gen heap
 263 // . gc locker is occupied (jni critical section)
 264 // . heap memory is tight -- the most recent previous collection
 265 //   was a full collection because a partial collection (would
 266 //   have) failed and is likely to fail again
 267 bool GenCollectedHeap::should_try_older_generation_allocation(size_t word_size) const {
 268   size_t young_capacity = _young_gen-&gt;capacity_before_gc();
 269   return    (word_size &gt; heap_word_size(young_capacity))
 270          || GCLocker::is_active_and_needs_gc()
 271          || incremental_collection_failed();
 272 }
 273 
 274 HeapWord* GenCollectedHeap::expand_heap_and_allocate(size_t size, bool   is_tlab) {
 275   HeapWord* result = NULL;
 276   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 277     result = _old_gen-&gt;expand_and_allocate(size, is_tlab);
 278   }
 279   if (result == NULL) {
 280     if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 281       result = _young_gen-&gt;expand_and_allocate(size, is_tlab);
 282     }
 283   }
 284   assert(result == NULL || is_in_reserved(result), &quot;result not in heap&quot;);
 285   return result;
 286 }
 287 
 288 HeapWord* GenCollectedHeap::mem_allocate_work(size_t size,
 289                                               bool is_tlab,
 290                                               bool* gc_overhead_limit_was_exceeded) {
 291   // In general gc_overhead_limit_was_exceeded should be false so
 292   // set it so here and reset it to true only if the gc time
 293   // limit is being exceeded as checked below.
 294   *gc_overhead_limit_was_exceeded = false;
 295 
 296   HeapWord* result = NULL;
 297 
 298   // Loop until the allocation is satisfied, or unsatisfied after GC.
 299   for (uint try_count = 1, gclocker_stalled_count = 0; /* return or throw */; try_count += 1) {
 300     HandleMark hm; // Discard any handles allocated in each iteration.
 301 
 302     // First allocation attempt is lock-free.
 303     Generation *young = _young_gen;
 304     assert(young-&gt;supports_inline_contig_alloc(),
 305       &quot;Otherwise, must do alloc within heap lock&quot;);
 306     if (young-&gt;should_allocate(size, is_tlab)) {
 307       result = young-&gt;par_allocate(size, is_tlab);
 308       if (result != NULL) {
 309         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 310         return result;
 311       }
 312     }
 313     uint gc_count_before;  // Read inside the Heap_lock locked region.
 314     {
 315       MutexLocker ml(Heap_lock);
 316       log_trace(gc, alloc)(&quot;GenCollectedHeap::mem_allocate_work: attempting locked slow path allocation&quot;);
 317       // Note that only large objects get a shot at being
 318       // allocated in later generations.
 319       bool first_only = !should_try_older_generation_allocation(size);
 320 
 321       result = attempt_allocation(size, is_tlab, first_only);
 322       if (result != NULL) {
 323         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 324         return result;
 325       }
 326 
 327       if (GCLocker::is_active_and_needs_gc()) {
 328         if (is_tlab) {
 329           return NULL;  // Caller will retry allocating individual object.
 330         }
 331         if (!is_maximal_no_gc()) {
 332           // Try and expand heap to satisfy request.
 333           result = expand_heap_and_allocate(size, is_tlab);
 334           // Result could be null if we are out of space.
 335           if (result != NULL) {
 336             return result;
 337           }
 338         }
 339 
 340         if (gclocker_stalled_count &gt; GCLockerRetryAllocationCount) {
 341           return NULL; // We didn&#39;t get to do a GC and we didn&#39;t get any memory.
 342         }
 343 
 344         // If this thread is not in a jni critical section, we stall
 345         // the requestor until the critical section has cleared and
 346         // GC allowed. When the critical section clears, a GC is
 347         // initiated by the last thread exiting the critical section; so
 348         // we retry the allocation sequence from the beginning of the loop,
 349         // rather than causing more, now probably unnecessary, GC attempts.
 350         JavaThread* jthr = JavaThread::current();
 351         if (!jthr-&gt;in_critical()) {
 352           MutexUnlocker mul(Heap_lock);
 353           // Wait for JNI critical section to be exited
 354           GCLocker::stall_until_clear();
 355           gclocker_stalled_count += 1;
 356           continue;
 357         } else {
 358           if (CheckJNICalls) {
 359             fatal(&quot;Possible deadlock due to allocating while&quot;
 360                   &quot; in jni critical section&quot;);
 361           }
 362           return NULL;
 363         }
 364       }
 365 
 366       // Read the gc count while the heap lock is held.
 367       gc_count_before = total_collections();
 368     }
 369 
 370     VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);
 371     VMThread::execute(&amp;op);
 372     if (op.prologue_succeeded()) {
 373       result = op.result();
 374       if (op.gc_locked()) {
 375          assert(result == NULL, &quot;must be NULL if gc_locked() is true&quot;);
 376          continue;  // Retry and/or stall as necessary.
 377       }
 378 
 379       // Allocation has failed and a collection
 380       // has been done.  If the gc time limit was exceeded the
 381       // this time, return NULL so that an out-of-memory
 382       // will be thrown.  Clear gc_overhead_limit_exceeded
 383       // so that the overhead exceeded does not persist.
 384 
 385       const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded();
 386       const bool softrefs_clear = soft_ref_policy()-&gt;all_soft_refs_clear();
 387 
 388       if (limit_exceeded &amp;&amp; softrefs_clear) {
 389         *gc_overhead_limit_was_exceeded = true;
 390         size_policy()-&gt;set_gc_overhead_limit_exceeded(false);
 391         if (op.result() != NULL) {
 392           CollectedHeap::fill_with_object(op.result(), size);
 393         }
 394         return NULL;
 395       }
 396       assert(result == NULL || is_in_reserved(result),
 397              &quot;result not in heap&quot;);
 398       return result;
 399     }
 400 
 401     // Give a warning if we seem to be looping forever.
 402     if ((QueuedAllocationWarningCount &gt; 0) &amp;&amp;
 403         (try_count % QueuedAllocationWarningCount == 0)) {
 404           log_warning(gc, ergo)(&quot;GenCollectedHeap::mem_allocate_work retries %d times,&quot;
 405                                 &quot; size=&quot; SIZE_FORMAT &quot; %s&quot;, try_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);
 406     }
 407   }
 408 }
 409 
<a name="24" id="anc24"></a><span class="line-removed"> 410 #ifndef PRODUCT</span>
<span class="line-removed"> 411 // Override of memory state checking method in CollectedHeap:</span>
<span class="line-removed"> 412 // Some collectors (CMS for example) can&#39;t have badHeapWordVal written</span>
<span class="line-removed"> 413 // in the first two words of an object. (For instance , in the case of</span>
<span class="line-removed"> 414 // CMS these words hold state used to synchronize between certain</span>
<span class="line-removed"> 415 // (concurrent) GC steps and direct allocating mutators.)</span>
<span class="line-removed"> 416 // The skip_header_HeapWords() method below, allows us to skip</span>
<span class="line-removed"> 417 // over the requisite number of HeapWord&#39;s. Note that (for</span>
<span class="line-removed"> 418 // generational collectors) this means that those many words are</span>
<span class="line-removed"> 419 // skipped in each object, irrespective of the generation in which</span>
<span class="line-removed"> 420 // that object lives. The resultant loss of precision seems to be</span>
<span class="line-removed"> 421 // harmless and the pain of avoiding that imprecision appears somewhat</span>
<span class="line-removed"> 422 // higher than we are prepared to pay for such rudimentary debugging</span>
<span class="line-removed"> 423 // support.</span>
<span class="line-removed"> 424 void GenCollectedHeap::check_for_non_bad_heap_word_value(HeapWord* addr,</span>
<span class="line-removed"> 425                                                          size_t size) {</span>
<span class="line-removed"> 426   if (CheckMemoryInitialization &amp;&amp; ZapUnusedHeapArea) {</span>
<span class="line-removed"> 427     // We are asked to check a size in HeapWords,</span>
<span class="line-removed"> 428     // but the memory is mangled in juint words.</span>
<span class="line-removed"> 429     juint* start = (juint*) (addr + skip_header_HeapWords());</span>
<span class="line-removed"> 430     juint* end   = (juint*) (addr + size);</span>
<span class="line-removed"> 431     for (juint* slot = start; slot &lt; end; slot += 1) {</span>
<span class="line-removed"> 432       assert(*slot == badHeapWordVal,</span>
<span class="line-removed"> 433              &quot;Found non badHeapWordValue in pre-allocation check&quot;);</span>
<span class="line-removed"> 434     }</span>
<span class="line-removed"> 435   }</span>
<span class="line-removed"> 436 }</span>
<span class="line-removed"> 437 #endif</span>
<span class="line-removed"> 438 </span>
 439 HeapWord* GenCollectedHeap::attempt_allocation(size_t size,
 440                                                bool is_tlab,
 441                                                bool first_only) {
 442   HeapWord* res = NULL;
 443 
 444   if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 445     res = _young_gen-&gt;allocate(size, is_tlab);
 446     if (res != NULL || first_only) {
 447       return res;
 448     }
 449   }
 450 
 451   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 452     res = _old_gen-&gt;allocate(size, is_tlab);
 453   }
 454 
 455   return res;
 456 }
 457 
 458 HeapWord* GenCollectedHeap::mem_allocate(size_t size,
 459                                          bool* gc_overhead_limit_was_exceeded) {
 460   return mem_allocate_work(size,
 461                            false /* is_tlab */,
 462                            gc_overhead_limit_was_exceeded);
 463 }
 464 
 465 bool GenCollectedHeap::must_clear_all_soft_refs() {
 466   return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||
 467          _gc_cause == GCCause::_wb_full_gc;
 468 }
 469 
 470 void GenCollectedHeap::collect_generation(Generation* gen, bool full, size_t size,
 471                                           bool is_tlab, bool run_verification, bool clear_soft_refs,
 472                                           bool restore_marks_for_biased_locking) {
 473   FormatBuffer&lt;&gt; title(&quot;Collect gen: %s&quot;, gen-&gt;short_name());
 474   GCTraceTime(Trace, gc, phases) t1(title);
 475   TraceCollectorStats tcs(gen-&gt;counters());
 476   TraceMemoryManagerStats tmms(gen-&gt;gc_manager(), gc_cause());
 477 
 478   gen-&gt;stat_record()-&gt;invocations++;
 479   gen-&gt;stat_record()-&gt;accumulated_time.start();
 480 
 481   // Must be done anew before each collection because
 482   // a previous collection will do mangling and will
 483   // change top of some spaces.
 484   record_gen_tops_before_GC();
 485 
 486   log_trace(gc)(&quot;%s invoke=%d size=&quot; SIZE_FORMAT, heap()-&gt;is_young_gen(gen) ? &quot;Young&quot; : &quot;Old&quot;, gen-&gt;stat_record()-&gt;invocations, size * HeapWordSize);
 487 
 488   if (run_verification &amp;&amp; VerifyBeforeGC) {
 489     HandleMark hm;  // Discard invalid handles created during verification
 490     Universe::verify(&quot;Before GC&quot;);
 491   }
<a name="25" id="anc25"></a><span class="line-modified"> 492   COMPILER2_PRESENT(DerivedPointerTable::clear());</span>
 493 
 494   if (restore_marks_for_biased_locking) {
 495     // We perform this mark word preservation work lazily
 496     // because it&#39;s only at this point that we know whether we
 497     // absolutely have to do it; we want to avoid doing it for
 498     // scavenge-only collections where it&#39;s unnecessary
 499     BiasedLocking::preserve_marks();
 500   }
 501 
 502   // Do collection work
 503   {
 504     // Note on ref discovery: For what appear to be historical reasons,
 505     // GCH enables and disabled (by enqueing) refs discovery.
 506     // In the future this should be moved into the generation&#39;s
 507     // collect method so that ref discovery and enqueueing concerns
 508     // are local to a generation. The collect method could return
 509     // an appropriate indication in the case that notification on
 510     // the ref lock was needed. This will make the treatment of
 511     // weak refs more uniform (and indeed remove such concerns
 512     // from GCH). XXX
 513 
 514     HandleMark hm;  // Discard invalid handles created during gc
 515     save_marks();   // save marks for all gens
 516     // We want to discover references, but not process them yet.
 517     // This mode is disabled in process_discovered_references if the
 518     // generation does some collection work, or in
 519     // enqueue_discovered_references if the generation returns
 520     // without doing any work.
 521     ReferenceProcessor* rp = gen-&gt;ref_processor();
 522     // If the discovery of (&quot;weak&quot;) refs in this generation is
 523     // atomic wrt other collectors in this configuration, we
 524     // are guaranteed to have empty discovered ref lists.
 525     if (rp-&gt;discovery_is_atomic()) {
 526       rp-&gt;enable_discovery();
 527       rp-&gt;setup_policy(clear_soft_refs);
 528     } else {
 529       // collect() below will enable discovery as appropriate
 530     }
 531     gen-&gt;collect(full, clear_soft_refs, size, is_tlab);
 532     if (!rp-&gt;enqueuing_is_done()) {
 533       rp-&gt;disable_discovery();
 534     } else {
 535       rp-&gt;set_enqueuing_is_done(false);
 536     }
 537     rp-&gt;verify_no_references_recorded();
 538   }
 539 
<a name="26" id="anc26"></a><span class="line-modified"> 540   COMPILER2_PRESENT(DerivedPointerTable::update_pointers());</span>
 541 
 542   gen-&gt;stat_record()-&gt;accumulated_time.stop();
 543 
 544   update_gc_stats(gen, full);
 545 
 546   if (run_verification &amp;&amp; VerifyAfterGC) {
 547     HandleMark hm;  // Discard invalid handles created during verification
 548     Universe::verify(&quot;After GC&quot;);
 549   }
 550 }
 551 
 552 void GenCollectedHeap::do_collection(bool           full,
 553                                      bool           clear_all_soft_refs,
 554                                      size_t         size,
 555                                      bool           is_tlab,
 556                                      GenerationType max_generation) {
 557   ResourceMark rm;
 558   DEBUG_ONLY(Thread* my_thread = Thread::current();)
 559 
 560   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
 561   assert(my_thread-&gt;is_VM_thread() ||
 562          my_thread-&gt;is_ConcurrentGC_thread(),
 563          &quot;incorrect thread type capability&quot;);
 564   assert(Heap_lock-&gt;is_locked(),
 565          &quot;the requesting thread should have the Heap_lock&quot;);
 566   guarantee(!is_gc_active(), &quot;collection is not reentrant&quot;);
 567 
 568   if (GCLocker::check_active_before_gc()) {
 569     return; // GC is disabled (e.g. JNI GetXXXCritical operation)
 570   }
 571 
 572   const bool do_clear_all_soft_refs = clear_all_soft_refs ||
 573                           soft_ref_policy()-&gt;should_clear_all_soft_refs();
 574 
 575   ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());
 576 
<a name="27" id="anc27"></a><span class="line-removed"> 577   const size_t metadata_prev_used = MetaspaceUtils::used_bytes();</span>
<span class="line-removed"> 578 </span>
<span class="line-removed"> 579 </span>
 580   FlagSetting fl(_is_gc_active, true);
 581 
 582   bool complete = full &amp;&amp; (max_generation == OldGen);
 583   bool old_collects_young = complete &amp;&amp; !ScavengeBeforeFullGC;
 584   bool do_young_collection = !old_collects_young &amp;&amp; _young_gen-&gt;should_collect(full, size, is_tlab);
 585 
<a name="28" id="anc28"></a><span class="line-modified"> 586   size_t young_prev_used = _young_gen-&gt;used();</span>
<span class="line-removed"> 587   size_t old_prev_used = _old_gen-&gt;used();</span>
 588 
 589   bool run_verification = total_collections() &gt;= VerifyGCStartAt;
 590   bool prepared_for_verification = false;
 591   bool do_full_collection = false;
 592 
 593   if (do_young_collection) {
 594     GCIdMark gc_id_mark;
 595     GCTraceCPUTime tcpu;
 596     GCTraceTime(Info, gc) t(&quot;Pause Young&quot;, NULL, gc_cause(), true);
 597 
 598     print_heap_before_gc();
 599 
 600     if (run_verification &amp;&amp; VerifyGCLevel &lt;= 0 &amp;&amp; VerifyBeforeGC) {
 601       prepare_for_verify();
 602       prepared_for_verification = true;
 603     }
 604 
 605     gc_prologue(complete);
 606     increment_total_collections(complete);
 607 
 608     collect_generation(_young_gen,
 609                        full,
 610                        size,
 611                        is_tlab,
 612                        run_verification &amp;&amp; VerifyGCLevel &lt;= 0,
 613                        do_clear_all_soft_refs,
 614                        false);
 615 
 616     if (size &gt; 0 &amp;&amp; (!is_tlab || _young_gen-&gt;supports_tlab_allocation()) &amp;&amp;
 617         size * HeapWordSize &lt;= _young_gen-&gt;unsafe_max_alloc_nogc()) {
 618       // Allocation request was met by young GC.
 619       size = 0;
 620     }
 621 
 622     // Ask if young collection is enough. If so, do the final steps for young collection,
 623     // and fallthrough to the end.
 624     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 625     if (!do_full_collection) {
 626       // Adjust generation sizes.
 627       _young_gen-&gt;compute_new_size();
 628 
<a name="29" id="anc29"></a><span class="line-modified"> 629       print_heap_change(young_prev_used, old_prev_used);</span>
<span class="line-removed"> 630       MetaspaceUtils::print_metaspace_change(metadata_prev_used);</span>
 631 
 632       // Track memory usage and detect low memory after GC finishes
 633       MemoryService::track_memory_usage();
 634 
 635       gc_epilogue(complete);
 636     }
 637 
 638     print_heap_after_gc();
 639 
 640   } else {
 641     // No young collection, ask if we need to perform Full collection.
 642     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 643   }
 644 
 645   if (do_full_collection) {
 646     GCIdMark gc_id_mark;
 647     GCTraceCPUTime tcpu;
 648     GCTraceTime(Info, gc) t(&quot;Pause Full&quot;, NULL, gc_cause(), true);
 649 
 650     print_heap_before_gc();
 651 
 652     if (!prepared_for_verification &amp;&amp; run_verification &amp;&amp;
 653         VerifyGCLevel &lt;= 1 &amp;&amp; VerifyBeforeGC) {
 654       prepare_for_verify();
 655     }
 656 
 657     if (!do_young_collection) {
 658       gc_prologue(complete);
 659       increment_total_collections(complete);
 660     }
 661 
 662     // Accounting quirk: total full collections would be incremented when &quot;complete&quot;
 663     // is set, by calling increment_total_collections above. However, we also need to
 664     // account Full collections that had &quot;complete&quot; unset.
 665     if (!complete) {
 666       increment_total_full_collections();
 667     }
 668 
 669     collect_generation(_old_gen,
 670                        full,
 671                        size,
 672                        is_tlab,
 673                        run_verification &amp;&amp; VerifyGCLevel &lt;= 1,
 674                        do_clear_all_soft_refs,
 675                        true);
 676 
 677     // Adjust generation sizes.
 678     _old_gen-&gt;compute_new_size();
 679     _young_gen-&gt;compute_new_size();
 680 
 681     // Delete metaspaces for unloaded class loaders and clean up loader_data graph
 682     ClassLoaderDataGraph::purge();
 683     MetaspaceUtils::verify_metrics();
 684     // Resize the metaspace capacity after full collections
 685     MetaspaceGC::compute_new_size();
 686     update_full_collections_completed();
 687 
<a name="30" id="anc30"></a><span class="line-modified"> 688     print_heap_change(young_prev_used, old_prev_used);</span>
<span class="line-removed"> 689     MetaspaceUtils::print_metaspace_change(metadata_prev_used);</span>
 690 
 691     // Track memory usage and detect low memory after GC finishes
 692     MemoryService::track_memory_usage();
 693 
 694     // Need to tell the epilogue code we are done with Full GC, regardless what was
 695     // the initial value for &quot;complete&quot; flag.
 696     gc_epilogue(true);
 697 
 698     BiasedLocking::restore_marks();
 699 
 700     print_heap_after_gc();
 701   }
<a name="31" id="anc31"></a><span class="line-removed"> 702 </span>
<span class="line-removed"> 703 #ifdef TRACESPINNING</span>
<span class="line-removed"> 704   ParallelTaskTerminator::print_termination_counts();</span>
<span class="line-removed"> 705 #endif</span>
 706 }
 707 
 708 bool GenCollectedHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,
 709                                                  GenCollectedHeap::GenerationType max_gen) const {
 710   return max_gen == OldGen &amp;&amp; _old_gen-&gt;should_collect(full, size, is_tlab);
 711 }
 712 
 713 void GenCollectedHeap::register_nmethod(nmethod* nm) {
 714   ScavengableNMethods::register_nmethod(nm);
 715 }
 716 
 717 void GenCollectedHeap::unregister_nmethod(nmethod* nm) {
 718   ScavengableNMethods::unregister_nmethod(nm);
 719 }
 720 
 721 void GenCollectedHeap::verify_nmethod(nmethod* nm) {
 722   ScavengableNMethods::verify_nmethod(nm);
 723 }
 724 
 725 void GenCollectedHeap::flush_nmethod(nmethod* nm) {
<a name="32" id="anc32"></a><span class="line-modified"> 726   ScavengableNMethods::flush_nmethod(nm);</span>
 727 }
 728 
<a name="33" id="anc33"></a><span class="line-modified"> 729 void GenCollectedHeap::prune_nmethods() {</span>
 730   ScavengableNMethods::prune_nmethods();
 731 }
 732 
 733 HeapWord* GenCollectedHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {
 734   GCCauseSetter x(this, GCCause::_allocation_failure);
 735   HeapWord* result = NULL;
 736 
 737   assert(size != 0, &quot;Precondition violated&quot;);
 738   if (GCLocker::is_active_and_needs_gc()) {
 739     // GC locker is active; instead of a collection we will attempt
 740     // to expand the heap, if there&#39;s room for expansion.
 741     if (!is_maximal_no_gc()) {
 742       result = expand_heap_and_allocate(size, is_tlab);
 743     }
 744     return result;   // Could be null if we are out of space.
 745   } else if (!incremental_collection_will_fail(false /* don&#39;t consult_young */)) {
 746     // Do an incremental collection.
 747     do_collection(false,                     // full
 748                   false,                     // clear_all_soft_refs
 749                   size,                      // size
 750                   is_tlab,                   // is_tlab
 751                   GenCollectedHeap::OldGen); // max_generation
 752   } else {
 753     log_trace(gc)(&quot; :: Trying full because partial may fail :: &quot;);
 754     // Try a full collection; see delta for bug id 6266275
 755     // for the original code and why this has been simplified
 756     // with from-space allocation criteria modified and
 757     // such allocation moved out of the safepoint path.
 758     do_collection(true,                      // full
 759                   false,                     // clear_all_soft_refs
 760                   size,                      // size
 761                   is_tlab,                   // is_tlab
 762                   GenCollectedHeap::OldGen); // max_generation
 763   }
 764 
 765   result = attempt_allocation(size, is_tlab, false /*first_only*/);
 766 
 767   if (result != NULL) {
 768     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 769     return result;
 770   }
 771 
 772   // OK, collection failed, try expansion.
 773   result = expand_heap_and_allocate(size, is_tlab);
 774   if (result != NULL) {
 775     return result;
 776   }
 777 
 778   // If we reach this point, we&#39;re really out of memory. Try every trick
 779   // we can to reclaim memory. Force collection of soft references. Force
 780   // a complete compaction of the heap. Any additional methods for finding
 781   // free memory should be here, especially if they are expensive. If this
 782   // attempt fails, an OOM exception will be thrown.
 783   {
 784     UIntFlagSetting flag_change(MarkSweepAlwaysCompactCount, 1); // Make sure the heap is fully compacted
 785 
 786     do_collection(true,                      // full
 787                   true,                      // clear_all_soft_refs
 788                   size,                      // size
 789                   is_tlab,                   // is_tlab
 790                   GenCollectedHeap::OldGen); // max_generation
 791   }
 792 
 793   result = attempt_allocation(size, is_tlab, false /* first_only */);
 794   if (result != NULL) {
 795     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 796     return result;
 797   }
 798 
 799   assert(!soft_ref_policy()-&gt;should_clear_all_soft_refs(),
 800     &quot;Flag should have been handled and cleared prior to this point&quot;);
 801 
 802   // What else?  We might try synchronous finalization later.  If the total
 803   // space available is large enough for the allocation, then a more
 804   // complete compaction phase than we&#39;ve tried so far might be
 805   // appropriate.
 806   return NULL;
 807 }
 808 
 809 #ifdef ASSERT
 810 class AssertNonScavengableClosure: public OopClosure {
 811 public:
 812   virtual void do_oop(oop* p) {
 813     assert(!GenCollectedHeap::heap()-&gt;is_in_partial_collection(*p),
 814       &quot;Referent should not be scavengable.&quot;);  }
 815   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
 816 };
 817 static AssertNonScavengableClosure assert_is_non_scavengable_closure;
 818 #endif
 819 
 820 void GenCollectedHeap::process_roots(StrongRootsScope* scope,
 821                                      ScanningOption so,
 822                                      OopClosure* strong_roots,
 823                                      CLDClosure* strong_cld_closure,
 824                                      CLDClosure* weak_cld_closure,
 825                                      CodeBlobToOopClosure* code_roots) {
 826   // General roots.
<a name="34" id="anc34"></a><span class="line-removed"> 827   assert(Threads::thread_claim_parity() != 0, &quot;must have called prologue code&quot;);</span>
 828   assert(code_roots != NULL, &quot;code root closure should always be set&quot;);
 829   // _n_termination for _process_strong_tasks should be set up stream
 830   // in a method not running in a GC worker.  Otherwise the GC worker
 831   // could be trying to change the termination condition while the task
 832   // is executing in another GC worker.
 833 
 834   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ClassLoaderDataGraph_oops_do)) {
 835     ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);
 836   }
 837 
 838   // Only process code roots from thread stacks if we aren&#39;t visiting the entire CodeCache anyway
 839   CodeBlobToOopClosure* roots_from_code_p = (so &amp; SO_AllCodeCache) ? NULL : code_roots;
 840 
 841   bool is_par = scope-&gt;n_threads() &gt; 1;
 842   Threads::possibly_parallel_oops_do(is_par, strong_roots, roots_from_code_p);
 843 
 844   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Universe_oops_do)) {
 845     Universe::oops_do(strong_roots);
 846   }
 847   // Global (strong) JNI handles
 848   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_JNIHandles_oops_do)) {
 849     JNIHandles::oops_do(strong_roots);
 850   }
 851 
 852   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ObjectSynchronizer_oops_do)) {
 853     ObjectSynchronizer::oops_do(strong_roots);
 854   }
 855   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Management_oops_do)) {
 856     Management::oops_do(strong_roots);
 857   }
 858   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_jvmti_oops_do)) {
 859     JvmtiExport::oops_do(strong_roots);
 860   }
<a name="35" id="anc35"></a>
 861   if (UseAOT &amp;&amp; _process_strong_tasks-&gt;try_claim_task(GCH_PS_aot_oops_do)) {
 862     AOTLoader::oops_do(strong_roots);
 863   }
<a name="36" id="anc36"></a><span class="line-modified"> 864 </span>
 865   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_SystemDictionary_oops_do)) {
 866     SystemDictionary::oops_do(strong_roots);
 867   }
 868 
 869   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_CodeCache_oops_do)) {
 870     if (so &amp; SO_ScavengeCodeCache) {
 871       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 872 
 873       // We only visit parts of the CodeCache when scavenging.
<a name="37" id="anc37"></a><span class="line-modified"> 874       ScavengableNMethods::scavengable_nmethods_do(code_roots);</span>
 875     }
 876     if (so &amp; SO_AllCodeCache) {
 877       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 878 
 879       // CMSCollector uses this to do intermediate-strength collections.
 880       // We scan the entire code cache, since CodeCache::do_unloading is not called.
 881       CodeCache::blobs_do(code_roots);
 882     }
 883     // Verify that the code cache contents are not subject to
 884     // movement by a scavenging collection.
 885     DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&amp;assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));
 886     DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&amp;assert_code_is_non_scavengable));
 887   }
 888 }
 889 
 890 void GenCollectedHeap::young_process_roots(StrongRootsScope* scope,
 891                                            OopsInGenClosure* root_closure,
 892                                            OopsInGenClosure* old_gen_closure,
 893                                            CLDClosure* cld_closure) {
 894   MarkingCodeBlobClosure mark_code_closure(root_closure, CodeBlobToOopClosure::FixRelocations);
 895 
 896   process_roots(scope, SO_ScavengeCodeCache, root_closure,
 897                 cld_closure, cld_closure, &amp;mark_code_closure);
 898 
 899   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_younger_gens)) {
 900     root_closure-&gt;reset_generation();
 901   }
 902 
 903   // When collection is parallel, all threads get to cooperate to do
 904   // old generation scanning.
 905   old_gen_closure-&gt;set_generation(_old_gen);
 906   rem_set()-&gt;younger_refs_iterate(_old_gen, old_gen_closure, scope-&gt;n_threads());
 907   old_gen_closure-&gt;reset_generation();
 908 
 909   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 910 }
 911 
 912 void GenCollectedHeap::full_process_roots(StrongRootsScope* scope,
 913                                           bool is_adjust_phase,
 914                                           ScanningOption so,
 915                                           bool only_strong_roots,
 916                                           OopsInGenClosure* root_closure,
 917                                           CLDClosure* cld_closure) {
 918   MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase);
 919   CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;
 920 
 921   process_roots(scope, so, root_closure, cld_closure, weak_cld_closure, &amp;mark_code_closure);
 922   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 923 }
 924 
 925 void GenCollectedHeap::gen_process_weak_roots(OopClosure* root_closure) {
 926   WeakProcessor::oops_do(root_closure);
 927   _young_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 928   _old_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 929 }
 930 
 931 bool GenCollectedHeap::no_allocs_since_save_marks() {
 932   return _young_gen-&gt;no_allocs_since_save_marks() &amp;&amp;
 933          _old_gen-&gt;no_allocs_since_save_marks();
 934 }
 935 
 936 bool GenCollectedHeap::supports_inline_contig_alloc() const {
 937   return _young_gen-&gt;supports_inline_contig_alloc();
 938 }
 939 
 940 HeapWord* volatile* GenCollectedHeap::top_addr() const {
 941   return _young_gen-&gt;top_addr();
 942 }
 943 
 944 HeapWord** GenCollectedHeap::end_addr() const {
 945   return _young_gen-&gt;end_addr();
 946 }
 947 
 948 // public collection interfaces
 949 
 950 void GenCollectedHeap::collect(GCCause::Cause cause) {
<a name="38" id="anc38"></a><span class="line-modified"> 951   if (cause == GCCause::_wb_young_gc) {</span>
<span class="line-modified"> 952     // Young collection for the WhiteBox API.</span>

 953     collect(cause, YoungGen);
 954   } else {
 955 #ifdef ASSERT
 956   if (cause == GCCause::_scavenge_alot) {
 957     // Young collection only.
 958     collect(cause, YoungGen);
 959   } else {
 960     // Stop-the-world full collection.
 961     collect(cause, OldGen);
 962   }
 963 #else
 964     // Stop-the-world full collection.
 965     collect(cause, OldGen);
 966 #endif
 967   }
 968 }
 969 
 970 void GenCollectedHeap::collect(GCCause::Cause cause, GenerationType max_generation) {
 971   // The caller doesn&#39;t have the Heap_lock
 972   assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);
 973   MutexLocker ml(Heap_lock);
 974   collect_locked(cause, max_generation);
 975 }
 976 
 977 void GenCollectedHeap::collect_locked(GCCause::Cause cause) {
 978   // The caller has the Heap_lock
 979   assert(Heap_lock-&gt;owned_by_self(), &quot;this thread should own the Heap_lock&quot;);
 980   collect_locked(cause, OldGen);
 981 }
 982 
 983 // this is the private collection interface
 984 // The Heap_lock is expected to be held on entry.
 985 
 986 void GenCollectedHeap::collect_locked(GCCause::Cause cause, GenerationType max_generation) {
 987   // Read the GC count while holding the Heap_lock
 988   unsigned int gc_count_before      = total_collections();
 989   unsigned int full_gc_count_before = total_full_collections();
<a name="39" id="anc39"></a>




 990   {
 991     MutexUnlocker mu(Heap_lock);  // give up heap lock, execute gets it back
 992     VM_GenCollectFull op(gc_count_before, full_gc_count_before,
 993                          cause, max_generation);
 994     VMThread::execute(&amp;op);
 995   }
 996 }
 997 
 998 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
 999    do_full_collection(clear_all_soft_refs, OldGen);
1000 }
1001 
1002 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs,
1003                                           GenerationType last_generation) {
<a name="40" id="anc40"></a><span class="line-removed">1004   GenerationType local_last_generation;</span>
<span class="line-removed">1005   if (!incremental_collection_will_fail(false /* don&#39;t consult_young */) &amp;&amp;</span>
<span class="line-removed">1006       gc_cause() == GCCause::_gc_locker) {</span>
<span class="line-removed">1007     local_last_generation = YoungGen;</span>
<span class="line-removed">1008   } else {</span>
<span class="line-removed">1009     local_last_generation = last_generation;</span>
<span class="line-removed">1010   }</span>
<span class="line-removed">1011 </span>
1012   do_collection(true,                   // full
1013                 clear_all_soft_refs,    // clear_all_soft_refs
1014                 0,                      // size
1015                 false,                  // is_tlab
<a name="41" id="anc41"></a><span class="line-modified">1016                 local_last_generation); // last_generation</span>
1017   // Hack XXX FIX ME !!!
1018   // A scavenge may not have been attempted, or may have
1019   // been attempted and failed, because the old gen was too full
<a name="42" id="anc42"></a><span class="line-modified">1020   if (local_last_generation == YoungGen &amp;&amp; gc_cause() == GCCause::_gc_locker &amp;&amp;</span>
<span class="line-removed">1021       incremental_collection_will_fail(false /* don&#39;t consult_young */)) {</span>
1022     log_debug(gc, jni)(&quot;GC locker: Trying a full collection because scavenge failed&quot;);
1023     // This time allow the old gen to be collected as well
1024     do_collection(true,                // full
1025                   clear_all_soft_refs, // clear_all_soft_refs
1026                   0,                   // size
1027                   false,               // is_tlab
1028                   OldGen);             // last_generation
1029   }
1030 }
1031 
1032 bool GenCollectedHeap::is_in_young(oop p) {
<a name="43" id="anc43"></a><span class="line-modified">1033   bool result = ((HeapWord*)p) &lt; _old_gen-&gt;reserved().start();</span>
1034   assert(result == _young_gen-&gt;is_in_reserved(p),
1035          &quot;incorrect test - result=%d, p=&quot; INTPTR_FORMAT, result, p2i((void*)p));
1036   return result;
1037 }
1038 
1039 // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
1040 bool GenCollectedHeap::is_in(const void* p) const {
1041   return _young_gen-&gt;is_in(p) || _old_gen-&gt;is_in(p);
1042 }
1043 
1044 #ifdef ASSERT
1045 // Don&#39;t implement this by using is_in_young().  This method is used
1046 // in some cases to check that is_in_young() is correct.
1047 bool GenCollectedHeap::is_in_partial_collection(const void* p) {
1048   assert(is_in_reserved(p) || p == NULL,
1049     &quot;Does not work if address is non-null and outside of the heap&quot;);
1050   return p &lt; _young_gen-&gt;reserved().end() &amp;&amp; p != NULL;
1051 }
1052 #endif
1053 
1054 void GenCollectedHeap::oop_iterate(OopIterateClosure* cl) {
1055   _young_gen-&gt;oop_iterate(cl);
1056   _old_gen-&gt;oop_iterate(cl);
1057 }
1058 
1059 void GenCollectedHeap::object_iterate(ObjectClosure* cl) {
1060   _young_gen-&gt;object_iterate(cl);
1061   _old_gen-&gt;object_iterate(cl);
1062 }
1063 
<a name="44" id="anc44"></a><span class="line-removed">1064 void GenCollectedHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-removed">1065   _young_gen-&gt;safe_object_iterate(cl);</span>
<span class="line-removed">1066   _old_gen-&gt;safe_object_iterate(cl);</span>
<span class="line-removed">1067 }</span>
<span class="line-removed">1068 </span>
1069 Space* GenCollectedHeap::space_containing(const void* addr) const {
1070   Space* res = _young_gen-&gt;space_containing(addr);
1071   if (res != NULL) {
1072     return res;
1073   }
1074   res = _old_gen-&gt;space_containing(addr);
1075   assert(res != NULL, &quot;Could not find containing space&quot;);
1076   return res;
1077 }
1078 
1079 HeapWord* GenCollectedHeap::block_start(const void* addr) const {
1080   assert(is_in_reserved(addr), &quot;block_start of address outside of heap&quot;);
1081   if (_young_gen-&gt;is_in_reserved(addr)) {
1082     assert(_young_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1083     return _young_gen-&gt;block_start(addr);
1084   }
1085 
1086   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1087   assert(_old_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1088   return _old_gen-&gt;block_start(addr);
1089 }
1090 
1091 bool GenCollectedHeap::block_is_obj(const HeapWord* addr) const {
1092   assert(is_in_reserved(addr), &quot;block_is_obj of address outside of heap&quot;);
1093   assert(block_start(addr) == addr, &quot;addr must be a block start&quot;);
1094   if (_young_gen-&gt;is_in_reserved(addr)) {
1095     return _young_gen-&gt;block_is_obj(addr);
1096   }
1097 
1098   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1099   return _old_gen-&gt;block_is_obj(addr);
1100 }
1101 
1102 bool GenCollectedHeap::supports_tlab_allocation() const {
1103   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1104   return _young_gen-&gt;supports_tlab_allocation();
1105 }
1106 
1107 size_t GenCollectedHeap::tlab_capacity(Thread* thr) const {
1108   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1109   if (_young_gen-&gt;supports_tlab_allocation()) {
1110     return _young_gen-&gt;tlab_capacity();
1111   }
1112   return 0;
1113 }
1114 
1115 size_t GenCollectedHeap::tlab_used(Thread* thr) const {
1116   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1117   if (_young_gen-&gt;supports_tlab_allocation()) {
1118     return _young_gen-&gt;tlab_used();
1119   }
1120   return 0;
1121 }
1122 
1123 size_t GenCollectedHeap::unsafe_max_tlab_alloc(Thread* thr) const {
1124   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1125   if (_young_gen-&gt;supports_tlab_allocation()) {
1126     return _young_gen-&gt;unsafe_max_tlab_alloc();
1127   }
1128   return 0;
1129 }
1130 
1131 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1132                                               size_t requested_size,
1133                                               size_t* actual_size) {
1134   bool gc_overhead_limit_was_exceeded;
1135   HeapWord* result = mem_allocate_work(requested_size /* size */,
1136                                        true /* is_tlab */,
1137                                        &amp;gc_overhead_limit_was_exceeded);
1138   if (result != NULL) {
1139     *actual_size = requested_size;
1140   }
1141 
1142   return result;
1143 }
1144 
1145 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1146 // from the list headed by &quot;*prev_ptr&quot;.
1147 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1148   bool first = true;
1149   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
1150   ScratchBlock **smallest_ptr, *smallest;
1151   ScratchBlock  *cur = *prev_ptr;
1152   while (cur) {
1153     assert(*prev_ptr == cur, &quot;just checking&quot;);
1154     if (first || cur-&gt;num_words &lt; min_size) {
1155       smallest_ptr = prev_ptr;
1156       smallest     = cur;
1157       min_size     = smallest-&gt;num_words;
1158       first        = false;
1159     }
1160     prev_ptr = &amp;cur-&gt;next;
1161     cur     =  cur-&gt;next;
1162   }
1163   smallest      = *smallest_ptr;
1164   *smallest_ptr = smallest-&gt;next;
1165   return smallest;
1166 }
1167 
1168 // Sort the scratch block list headed by res into decreasing size order,
1169 // and set &quot;res&quot; to the result.
1170 static void sort_scratch_list(ScratchBlock*&amp; list) {
1171   ScratchBlock* sorted = NULL;
1172   ScratchBlock* unsorted = list;
1173   while (unsorted) {
1174     ScratchBlock *smallest = removeSmallestScratch(&amp;unsorted);
1175     smallest-&gt;next  = sorted;
1176     sorted          = smallest;
1177   }
1178   list = sorted;
1179 }
1180 
1181 ScratchBlock* GenCollectedHeap::gather_scratch(Generation* requestor,
1182                                                size_t max_alloc_words) {
1183   ScratchBlock* res = NULL;
1184   _young_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1185   _old_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1186   sort_scratch_list(res);
1187   return res;
1188 }
1189 
1190 void GenCollectedHeap::release_scratch() {
1191   _young_gen-&gt;reset_scratch();
1192   _old_gen-&gt;reset_scratch();
1193 }
1194 
1195 class GenPrepareForVerifyClosure: public GenCollectedHeap::GenClosure {
1196   void do_generation(Generation* gen) {
1197     gen-&gt;prepare_for_verify();
1198   }
1199 };
1200 
1201 void GenCollectedHeap::prepare_for_verify() {
1202   ensure_parsability(false);        // no need to retire TLABs
1203   GenPrepareForVerifyClosure blk;
1204   generation_iterate(&amp;blk, false);
1205 }
1206 
1207 void GenCollectedHeap::generation_iterate(GenClosure* cl,
1208                                           bool old_to_young) {
1209   if (old_to_young) {
1210     cl-&gt;do_generation(_old_gen);
1211     cl-&gt;do_generation(_young_gen);
1212   } else {
1213     cl-&gt;do_generation(_young_gen);
1214     cl-&gt;do_generation(_old_gen);
1215   }
1216 }
1217 
1218 bool GenCollectedHeap::is_maximal_no_gc() const {
1219   return _young_gen-&gt;is_maximal_no_gc() &amp;&amp; _old_gen-&gt;is_maximal_no_gc();
1220 }
1221 
1222 void GenCollectedHeap::save_marks() {
1223   _young_gen-&gt;save_marks();
1224   _old_gen-&gt;save_marks();
1225 }
1226 
1227 GenCollectedHeap* GenCollectedHeap::heap() {
1228   CollectedHeap* heap = Universe::heap();
1229   assert(heap != NULL, &quot;Uninitialized access to GenCollectedHeap::heap()&quot;);
<a name="45" id="anc45"></a><span class="line-modified">1230   assert(heap-&gt;kind() == CollectedHeap::Serial ||</span>
<span class="line-removed">1231          heap-&gt;kind() == CollectedHeap::CMS, &quot;Invalid name&quot;);</span>
1232   return (GenCollectedHeap*) heap;
1233 }
1234 
1235 #if INCLUDE_SERIALGC
1236 void GenCollectedHeap::prepare_for_compaction() {
1237   // Start by compacting into same gen.
1238   CompactPoint cp(_old_gen);
1239   _old_gen-&gt;prepare_for_compaction(&amp;cp);
1240   _young_gen-&gt;prepare_for_compaction(&amp;cp);
1241 }
1242 #endif // INCLUDE_SERIALGC
1243 
1244 void GenCollectedHeap::verify(VerifyOption option /* ignored */) {
1245   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1246   _old_gen-&gt;verify();
1247 
1248   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1249   _young_gen-&gt;verify();
1250 
1251   log_debug(gc, verify)(&quot;RemSet&quot;);
1252   rem_set()-&gt;verify();
1253 }
1254 
1255 void GenCollectedHeap::print_on(outputStream* st) const {
1256   _young_gen-&gt;print_on(st);
1257   _old_gen-&gt;print_on(st);
1258   MetaspaceUtils::print_on(st);
1259 }
1260 
1261 void GenCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
1262 }
1263 
1264 void GenCollectedHeap::print_gc_threads_on(outputStream* st) const {
1265 }
1266 
<a name="46" id="anc46"></a>



1267 void GenCollectedHeap::print_tracing_info() const {
1268   if (log_is_enabled(Debug, gc, heap, exit)) {
1269     LogStreamHandle(Debug, gc, heap, exit) lsh;
1270     _young_gen-&gt;print_summary_info_on(&amp;lsh);
1271     _old_gen-&gt;print_summary_info_on(&amp;lsh);
1272   }
1273 }
1274 
<a name="47" id="anc47"></a><span class="line-modified">1275 void GenCollectedHeap::print_heap_change(size_t young_prev_used, size_t old_prev_used) const {</span>
<span class="line-modified">1276   log_info(gc, heap)(&quot;%s: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-modified">1277                      _young_gen-&gt;short_name(), young_prev_used / K, _young_gen-&gt;used() /K, _young_gen-&gt;capacity() /K);</span>
<span class="line-modified">1278   log_info(gc, heap)(&quot;%s: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="line-modified">1279                      _old_gen-&gt;short_name(), old_prev_used / K, _old_gen-&gt;used() /K, _old_gen-&gt;capacity() /K);</span>























1280 }
1281 
1282 class GenGCPrologueClosure: public GenCollectedHeap::GenClosure {
1283  private:
1284   bool _full;
1285  public:
1286   void do_generation(Generation* gen) {
1287     gen-&gt;gc_prologue(_full);
1288   }
1289   GenGCPrologueClosure(bool full) : _full(full) {};
1290 };
1291 
1292 void GenCollectedHeap::gc_prologue(bool full) {
1293   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
1294 
1295   // Fill TLAB&#39;s and such
1296   ensure_parsability(true);   // retire TLABs
1297 
1298   // Walk generations
1299   GenGCPrologueClosure blk(full);
1300   generation_iterate(&amp;blk, false);  // not old-to-young.
1301 };
1302 
1303 class GenGCEpilogueClosure: public GenCollectedHeap::GenClosure {
1304  private:
1305   bool _full;
1306  public:
1307   void do_generation(Generation* gen) {
1308     gen-&gt;gc_epilogue(_full);
1309   }
1310   GenGCEpilogueClosure(bool full) : _full(full) {};
1311 };
1312 
1313 void GenCollectedHeap::gc_epilogue(bool full) {
1314 #if COMPILER2_OR_JVMCI
1315   assert(DerivedPointerTable::is_empty(), &quot;derived pointer present&quot;);
1316   size_t actual_gap = pointer_delta((HeapWord*) (max_uintx-3), *(end_addr()));
1317   guarantee(is_client_compilation_mode_vm() || actual_gap &gt; (size_t)FastAllocateSizeLimit, &quot;inline allocation wraps&quot;);
1318 #endif // COMPILER2_OR_JVMCI
1319 
1320   resize_all_tlabs();
1321 
1322   GenGCEpilogueClosure blk(full);
1323   generation_iterate(&amp;blk, false);  // not old-to-young.
1324 
1325   if (!CleanChunkPoolAsync) {
1326     Chunk::clean_chunk_pool();
1327   }
1328 
1329   MetaspaceCounters::update_performance_counters();
1330   CompressedClassSpaceCounters::update_performance_counters();
1331 };
1332 
1333 #ifndef PRODUCT
1334 class GenGCSaveTopsBeforeGCClosure: public GenCollectedHeap::GenClosure {
1335  private:
1336  public:
1337   void do_generation(Generation* gen) {
1338     gen-&gt;record_spaces_top();
1339   }
1340 };
1341 
1342 void GenCollectedHeap::record_gen_tops_before_GC() {
1343   if (ZapUnusedHeapArea) {
1344     GenGCSaveTopsBeforeGCClosure blk;
1345     generation_iterate(&amp;blk, false);  // not old-to-young.
1346   }
1347 }
1348 #endif  // not PRODUCT
1349 
1350 class GenEnsureParsabilityClosure: public GenCollectedHeap::GenClosure {
1351  public:
1352   void do_generation(Generation* gen) {
1353     gen-&gt;ensure_parsability();
1354   }
1355 };
1356 
1357 void GenCollectedHeap::ensure_parsability(bool retire_tlabs) {
1358   CollectedHeap::ensure_parsability(retire_tlabs);
1359   GenEnsureParsabilityClosure ep_cl;
1360   generation_iterate(&amp;ep_cl, false);
1361 }
1362 
1363 oop GenCollectedHeap::handle_failed_promotion(Generation* old_gen,
1364                                               oop obj,
1365                                               size_t obj_size) {
1366   guarantee(old_gen == _old_gen, &quot;We only get here with an old generation&quot;);
1367   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
1368   HeapWord* result = NULL;
1369 
1370   result = old_gen-&gt;expand_and_allocate(obj_size, false);
1371 
1372   if (result != NULL) {
<a name="48" id="anc48"></a><span class="line-modified">1373     Copy::aligned_disjoint_words((HeapWord*)obj, result, obj_size);</span>
1374   }
1375   return oop(result);
1376 }
1377 
1378 class GenTimeOfLastGCClosure: public GenCollectedHeap::GenClosure {
1379   jlong _time;   // in ms
1380   jlong _now;    // in ms
1381 
1382  public:
1383   GenTimeOfLastGCClosure(jlong now) : _time(now), _now(now) { }
1384 
1385   jlong time() { return _time; }
1386 
1387   void do_generation(Generation* gen) {
1388     _time = MIN2(_time, gen-&gt;time_of_last_gc(_now));
1389   }
1390 };
1391 
1392 jlong GenCollectedHeap::millis_since_last_gc() {
1393   // javaTimeNanos() is guaranteed to be monotonically non-decreasing
1394   // provided the underlying platform provides such a time source
1395   // (and it is bug free). So we still have to guard against getting
1396   // back a time later than &#39;now&#39;.
1397   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
1398   GenTimeOfLastGCClosure tolgc_cl(now);
1399   // iterate over generations getting the oldest
1400   // time that a generation was collected
1401   generation_iterate(&amp;tolgc_cl, false);
1402 
1403   jlong retVal = now - tolgc_cl.time();
1404   if (retVal &lt; 0) {
1405     log_warning(gc)(&quot;millis_since_last_gc() would return : &quot; JLONG_FORMAT
1406        &quot;. returning zero instead.&quot;, retVal);
1407     return 0;
1408   }
1409   return retVal;
1410 }
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
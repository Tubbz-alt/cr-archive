<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/cardTableBarrierSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cardTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardTableBarrierSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79   delete _card_table;
 80 }
 81 
 82 void CardTableBarrierSet::write_ref_array_work(MemRegion mr) {
 83   _card_table-&gt;dirty_MemRegion(mr);
 84 }
 85 
 86 void CardTableBarrierSet::invalidate(MemRegion mr) {
 87   _card_table-&gt;invalidate(mr);
 88 }
 89 
 90 void CardTableBarrierSet::print_on(outputStream* st) const {
 91   _card_table-&gt;print_on(st);
 92 }
 93 
 94 // Helper for ReduceInitialCardMarks. For performance,
 95 // compiled code may elide card-marks for initializing stores
 96 // to a newly allocated object along the fast-path. We
 97 // compensate for such elided card-marks as follows:
 98 // (a) Generational, non-concurrent collectors, such as
<span class="line-modified"> 99 //     GenCollectedHeap(ParNew,DefNew,Tenured) and</span>
100 //     ParallelScavengeHeap(ParallelGC, ParallelOldGC)
101 //     need the card-mark if and only if the region is
102 //     in the old gen, and do not care if the card-mark
103 //     succeeds or precedes the initializing stores themselves,
104 //     so long as the card-mark is completed before the next
105 //     scavenge. For all these cases, we can do a card mark
106 //     at the point at which we do a slow path allocation
107 //     in the old gen, i.e. in this call.
<span class="line-modified">108 // (b) GenCollectedHeap(ConcurrentMarkSweepGeneration) requires</span>
<span class="line-removed">109 //     in addition that the card-mark for an old gen allocated</span>
<span class="line-removed">110 //     object strictly follow any associated initializing stores.</span>
<span class="line-removed">111 //     In these cases, the memRegion remembered below is</span>
<span class="line-removed">112 //     used to card-mark the entire region either just before the next</span>
<span class="line-removed">113 //     slow-path allocation by this thread or just before the next scavenge or</span>
<span class="line-removed">114 //     CMS-associated safepoint, whichever of these events happens first.</span>
<span class="line-removed">115 //     (The implicit assumption is that the object has been fully</span>
<span class="line-removed">116 //     initialized by this point, a fact that we assert when doing the</span>
<span class="line-removed">117 //     card-mark.)</span>
<span class="line-removed">118 // (c) G1CollectedHeap(G1) uses two kinds of write barriers. When a</span>
119 //     G1 concurrent marking is in progress an SATB (pre-write-)barrier
120 //     is used to remember the pre-value of any store. Initializing
121 //     stores will not need this barrier, so we need not worry about
122 //     compensating for the missing pre-barrier here. Turning now
123 //     to the post-barrier, we note that G1 needs a RS update barrier
124 //     which simply enqueues a (sequence of) dirty cards which may
125 //     optionally be refined by the concurrent update threads. Note
126 //     that this barrier need only be applied to a non-young write,
<span class="line-modified">127 //     but, like in CMS, because of the presence of concurrent refinement</span>
<span class="line-modified">128 //     (much like CMS&#39; precleaning), must strictly follow the oop-store.</span>
<span class="line-removed">129 //     Thus, using the same protocol for maintaining the intended</span>
<span class="line-removed">130 //     invariants turns out, serendepitously, to be the same for both</span>
<span class="line-removed">131 //     G1 and CMS.</span>
132 //
133 // For any future collector, this code should be reexamined with
134 // that specific collector in mind, and the documentation above suitably
135 // extended and updated.
136 void CardTableBarrierSet::on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {
137 #if COMPILER2_OR_JVMCI
138   if (!ReduceInitialCardMarks) {
139     return;
140   }
141   // If a previous card-mark was deferred, flush it now.
142   flush_deferred_card_mark_barrier(thread);
143   if (new_obj-&gt;is_typeArray() || _card_table-&gt;is_in_young(new_obj)) {
144     // Arrays of non-references don&#39;t need a post-barrier.
145     // The deferred_card_mark region should be empty
146     // following the flush above.
147     assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Error&quot;);
148   } else {
<span class="line-modified">149     MemRegion mr((HeapWord*)new_obj, new_obj-&gt;size());</span>
150     assert(!mr.is_empty(), &quot;Error&quot;);
151     if (_defer_initial_card_mark) {
152       // Defer the card mark
153       thread-&gt;set_deferred_card_mark(mr);
154     } else {
155       // Do the card mark
156       invalidate(mr);
157     }
158   }
159 #endif // COMPILER2_OR_JVMCI
160 }
161 
162 void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {
163   // Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);
164   // otherwise remains unused.
165 #if COMPILER2_OR_JVMCI
166   _defer_initial_card_mark = is_server_compilation_mode_vm() &amp;&amp; ReduceInitialCardMarks
167                              &amp;&amp; (DeferInitialCardMark || card_mark_must_follow_store());
168 #else
169   assert(_defer_initial_card_mark == false, &quot;Who would set it?&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 79   delete _card_table;
 80 }
 81 
 82 void CardTableBarrierSet::write_ref_array_work(MemRegion mr) {
 83   _card_table-&gt;dirty_MemRegion(mr);
 84 }
 85 
 86 void CardTableBarrierSet::invalidate(MemRegion mr) {
 87   _card_table-&gt;invalidate(mr);
 88 }
 89 
 90 void CardTableBarrierSet::print_on(outputStream* st) const {
 91   _card_table-&gt;print_on(st);
 92 }
 93 
 94 // Helper for ReduceInitialCardMarks. For performance,
 95 // compiled code may elide card-marks for initializing stores
 96 // to a newly allocated object along the fast-path. We
 97 // compensate for such elided card-marks as follows:
 98 // (a) Generational, non-concurrent collectors, such as
<span class="line-modified"> 99 //     GenCollectedHeap(DefNew,Tenured) and</span>
100 //     ParallelScavengeHeap(ParallelGC, ParallelOldGC)
101 //     need the card-mark if and only if the region is
102 //     in the old gen, and do not care if the card-mark
103 //     succeeds or precedes the initializing stores themselves,
104 //     so long as the card-mark is completed before the next
105 //     scavenge. For all these cases, we can do a card mark
106 //     at the point at which we do a slow path allocation
107 //     in the old gen, i.e. in this call.
<span class="line-modified">108 // (b) G1CollectedHeap(G1) uses two kinds of write barriers. When a</span>










109 //     G1 concurrent marking is in progress an SATB (pre-write-)barrier
110 //     is used to remember the pre-value of any store. Initializing
111 //     stores will not need this barrier, so we need not worry about
112 //     compensating for the missing pre-barrier here. Turning now
113 //     to the post-barrier, we note that G1 needs a RS update barrier
114 //     which simply enqueues a (sequence of) dirty cards which may
115 //     optionally be refined by the concurrent update threads. Note
116 //     that this barrier need only be applied to a non-young write,
<span class="line-modified">117 //     but, because of the presence of concurrent refinement,</span>
<span class="line-modified">118 //     must strictly follow the oop-store.</span>



119 //
120 // For any future collector, this code should be reexamined with
121 // that specific collector in mind, and the documentation above suitably
122 // extended and updated.
123 void CardTableBarrierSet::on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {
124 #if COMPILER2_OR_JVMCI
125   if (!ReduceInitialCardMarks) {
126     return;
127   }
128   // If a previous card-mark was deferred, flush it now.
129   flush_deferred_card_mark_barrier(thread);
130   if (new_obj-&gt;is_typeArray() || _card_table-&gt;is_in_young(new_obj)) {
131     // Arrays of non-references don&#39;t need a post-barrier.
132     // The deferred_card_mark region should be empty
133     // following the flush above.
134     assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Error&quot;);
135   } else {
<span class="line-modified">136     MemRegion mr(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj-&gt;size());</span>
137     assert(!mr.is_empty(), &quot;Error&quot;);
138     if (_defer_initial_card_mark) {
139       // Defer the card mark
140       thread-&gt;set_deferred_card_mark(mr);
141     } else {
142       // Do the card mark
143       invalidate(mr);
144     }
145   }
146 #endif // COMPILER2_OR_JVMCI
147 }
148 
149 void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {
150   // Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);
151   // otherwise remains unused.
152 #if COMPILER2_OR_JVMCI
153   _defer_initial_card_mark = is_server_compilation_mode_vm() &amp;&amp; ReduceInitialCardMarks
154                              &amp;&amp; (DeferInitialCardMark || card_mark_must_follow_store());
155 #else
156   assert(_defer_initial_card_mark == false, &quot;Who would set it?&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="cardTable.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
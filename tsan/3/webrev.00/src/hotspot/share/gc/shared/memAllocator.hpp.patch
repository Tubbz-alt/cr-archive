diff a/src/hotspot/share/gc/shared/memAllocator.hpp b/src/hotspot/share/gc/shared/memAllocator.hpp
--- a/src/hotspot/share/gc/shared/memAllocator.hpp
+++ b/src/hotspot/share/gc/shared/memAllocator.hpp
@@ -35,11 +35,10 @@
 
 class MemAllocator: StackObj {
 protected:
   class Allocation;
 
-  CollectedHeap* const _heap;
   Thread* const        _thread;
   Klass* const         _klass;
   const size_t         _word_size;
 
 private:
@@ -48,31 +47,28 @@
   HeapWord* allocate_inside_tlab_slow(Allocation& allocation) const;
   HeapWord* allocate_outside_tlab(Allocation& allocation) const;
 
 protected:
   MemAllocator(Klass* klass, size_t word_size, Thread* thread)
-    : _heap(Universe::heap()),
-      _thread(thread),
+    : _thread(thread),
       _klass(klass),
       _word_size(word_size)
   { }
 
   // This function clears the memory of the object
   void mem_clear(HeapWord* mem) const;
   // This finish constructing an oop by installing the mark word and the Klass* pointer
   // last. At the point when the Klass pointer is initialized, this is a constructed object
   // that must be parseable as an oop by concurrent collectors.
-  oop finish(HeapWord* mem) const;
+  virtual oop finish(HeapWord* mem) const;
 
-  // Raw memory allocation. This may or may not use TLAB allocations to satisfy the
-  // allocation. A GC implementation may override this function to satisfy the allocation
-  // in any way. But the default is to try a TLAB allocation, and otherwise perform
-  // mem_allocate.
-  virtual HeapWord* mem_allocate(Allocation& allocation) const;
+  // Raw memory allocation. This will try to do a TLAB allocation, and otherwise fall
+  // back to calling CollectedHeap::mem_allocate().
+  HeapWord* mem_allocate(Allocation& allocation) const;
 
   virtual MemRegion obj_memory_range(oop obj) const {
-    return MemRegion((HeapWord*)obj, _word_size);
+    return MemRegion(cast_from_oop<HeapWord*>(obj), _word_size);
   }
 
 public:
   oop allocate() const;
   virtual oop initialize(HeapWord* mem) const = 0;

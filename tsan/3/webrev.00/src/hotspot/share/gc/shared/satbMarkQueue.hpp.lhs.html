<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/satbMarkQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 26 #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 27 
 28 #include &quot;gc/shared/ptrQueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
<a name="1" id="anc1"></a>
 30 
 31 class Thread;
 32 class Monitor;
 33 class SATBMarkQueueSet;
 34 
 35 // Base class for processing the contents of a SATB buffer.
 36 class SATBBufferClosure : public StackObj {
 37 protected:
 38   ~SATBBufferClosure() { }
 39 
 40 public:
 41   // Process the SATB entries in the designated buffer range.
 42   virtual void do_buffer(void** buffer, size_t size) = 0;
 43 };
 44 
 45 // A PtrQueue whose elements are (possibly stale) pointers to object heads.
 46 class SATBMarkQueue: public PtrQueue {
 47   friend class SATBMarkQueueSet;
 48 
 49 private:
 50   // Filter out unwanted entries from the buffer.
 51   inline void filter();
 52 
 53   // Removes entries from the buffer that are no longer needed.
 54   template&lt;typename Filter&gt;
 55   inline void apply_filter(Filter filter_out);
 56 
<a name="2" id="anc2"></a>


 57 public:
<a name="3" id="anc3"></a><span class="line-modified"> 58   SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent = false);</span>
 59 
 60   // Process queue entries and free resources.
 61   void flush();
 62 
<a name="4" id="anc4"></a>

 63   // Apply cl to the active part of the buffer.
 64   // Prerequisite: Must be at a safepoint.
 65   void apply_closure_and_empty(SATBBufferClosure* cl);
 66 
<a name="5" id="anc5"></a><span class="line-removed"> 67   // Overrides PtrQueue::should_enqueue_buffer(). See the method&#39;s</span>
<span class="line-removed"> 68   // definition for more information.</span>
<span class="line-removed"> 69   virtual bool should_enqueue_buffer();</span>
<span class="line-removed"> 70 </span>
 71 #ifndef PRODUCT
 72   // Helpful for debugging
 73   void print(const char* name);
 74 #endif // PRODUCT
 75 
 76   // Compiler support.
 77   static ByteSize byte_offset_of_index() {
 78     return PtrQueue::byte_offset_of_index&lt;SATBMarkQueue&gt;();
 79   }
 80   using PtrQueue::byte_width_of_index;
 81 
 82   static ByteSize byte_offset_of_buf() {
 83     return PtrQueue::byte_offset_of_buf&lt;SATBMarkQueue&gt;();
 84   }
 85   using PtrQueue::byte_width_of_buf;
 86 
 87   static ByteSize byte_offset_of_active() {
 88     return PtrQueue::byte_offset_of_active&lt;SATBMarkQueue&gt;();
 89   }
 90   using PtrQueue::byte_width_of_active;
 91 
 92 };
 93 
 94 class SATBMarkQueueSet: public PtrQueueSet {
<a name="6" id="anc6"></a>





 95   size_t _buffer_enqueue_threshold;
<a name="7" id="anc7"></a>



 96 
 97 #ifdef ASSERT
 98   void dump_active_states(bool expected_active);
 99   void verify_active_states(bool expected_active);
100 #endif // ASSERT
101 
102 protected:
<a name="8" id="anc8"></a><span class="line-modified">103   SATBMarkQueueSet();</span>
<span class="line-modified">104   ~SATBMarkQueueSet() {}</span>
105 
106   template&lt;typename Filter&gt;
107   void apply_filter(Filter filter, SATBMarkQueue* queue) {
108     queue-&gt;apply_filter(filter);
109   }
110 
<a name="9" id="anc9"></a><span class="line-removed">111   void initialize(Monitor* cbl_mon,</span>
<span class="line-removed">112                   BufferNode::Allocator* allocator,</span>
<span class="line-removed">113                   size_t process_completed_buffers_threshold,</span>
<span class="line-removed">114                   uint buffer_enqueue_threshold_percentage);</span>
<span class="line-removed">115 </span>
116 public:
117   virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
118 
119   // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
120   // called only with the world stopped. The method will assert that the
121   // SATB queues of all threads it visits, as well as the SATB queue
122   // set itself, has an active value same as expected_active.
123   void set_active_all_threads(bool active, bool expected_active);
124 
<a name="10" id="anc10"></a>

125   size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<a name="11" id="anc11"></a><span class="line-modified">126   virtual void filter(SATBMarkQueue* queue) = 0;</span>
127 
<a name="12" id="anc12"></a><span class="line-modified">128   // Filter all the currently-active SATB buffers.</span>
<span class="line-removed">129   void filter_thread_buffers();</span>
130 
131   // If there exists some completed buffer, pop and process it, and
132   // return true.  Otherwise return false.  Processing a buffer
133   // consists of applying the closure to the active range of the
134   // buffer; the leading entries may be excluded due to filtering.
135   bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
136 
<a name="13" id="anc13"></a>












137 #ifndef PRODUCT
138   // Helpful for debugging
139   void print_all(const char* msg);
140 #endif // PRODUCT
141 
142   // If a marking is being abandoned, reset any unprocessed log buffers.
143   void abandon_partial_marking();
144 };
145 
<a name="14" id="anc14"></a>



146 inline void SATBMarkQueue::filter() {
<a name="15" id="anc15"></a><span class="line-modified">147   static_cast&lt;SATBMarkQueueSet*&gt;(qset())-&gt;filter(this);</span>
148 }
149 
150 // Removes entries from the buffer that are no longer needed, as
151 // determined by filter. If e is a void* entry in the buffer,
152 // filter_out(e) must be a valid expression whose value is convertible
153 // to bool. Entries are removed (filtered out) if the result is true,
154 // retained if false.
155 template&lt;typename Filter&gt;
156 inline void SATBMarkQueue::apply_filter(Filter filter_out) {
157   void** buf = this-&gt;_buf;
158 
159   if (buf == NULL) {
160     // nothing to do
161     return;
162   }
163 
164   // Two-fingered compaction toward the end.
165   void** src = &amp;buf[this-&gt;index()];
166   void** dst = &amp;buf[this-&gt;capacity()];
167   assert(src &lt;= dst, &quot;invariant&quot;);
168   for ( ; src &lt; dst; ++src) {
169     // Search low to high for an entry to keep.
170     void* entry = *src;
171     if (!filter_out(entry)) {
172       // Found keeper.  Search high to low for an entry to discard.
173       while (src &lt; --dst) {
174         if (filter_out(*dst)) {
175           *dst = entry;         // Replace discard with keeper.
176           break;
177         }
178       }
179       // If discard search failed (src == dst), the outer loop will also end.
180     }
181   }
182   // dst points to the lowest retained entry, or the end of the buffer
183   // if all the entries were filtered out.
184   this-&gt;set_index(dst - buf);
185 }
186 
187 #endif // SHARE_GC_SHARED_SATBMARKQUEUE_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
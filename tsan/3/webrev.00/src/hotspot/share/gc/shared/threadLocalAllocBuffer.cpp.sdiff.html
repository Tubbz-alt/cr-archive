<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="taskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
115   if (end() != NULL) {
116     invariants();
117     thread()-&gt;incr_allocated_bytes(used_bytes());
118     insert_filler();
119     initialize(NULL, NULL, NULL);
120   }
121 }
122 
123 void ThreadLocalAllocBuffer::retire_before_allocation() {
124   _slow_refill_waste += (unsigned int)remaining();
125   retire();
126 }
127 
128 void ThreadLocalAllocBuffer::resize() {
129   // Compute the next tlab size using expected allocation amount
130   assert(ResizeTLAB, &quot;Should not call this otherwise&quot;);
131   size_t alloc = (size_t)(_allocation_fraction.average() *
132                           (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize));
133   size_t new_size = alloc / _target_refills;
134 
<span class="line-modified">135   new_size = MIN2(MAX2(new_size, min_size()), max_size());</span>
136 
137   size_t aligned_new_size = align_object_size(new_size);
138 
139   log_trace(gc, tlab)(&quot;TLAB new size: thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
140                       &quot; refills %d  alloc: %8.6f desired_size: &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,
141                       p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),
142                       _target_refills, _allocation_fraction.average(), desired_size(), aligned_new_size);
143 
144   set_desired_size(aligned_new_size);
145   set_refill_waste_limit(initial_refill_waste_limit());
146 }
147 
148 void ThreadLocalAllocBuffer::reset_statistics() {
149   _number_of_refills = 0;
150   _fast_refill_waste = 0;
151   _slow_refill_waste = 0;
152   _gc_waste          = 0;
153   _slow_allocations  = 0;
154   _allocated_size    = 0;
155 }
</pre>
<hr />
<pre>
234   guarantee(Thread::current()-&gt;is_Java_thread(), &quot;tlab initialization thread not Java thread&quot;);
235   Thread::current()-&gt;tlab().initialize();
236 
237   log_develop_trace(gc, tlab)(&quot;TLAB min: &quot; SIZE_FORMAT &quot; initial: &quot; SIZE_FORMAT &quot; max: &quot; SIZE_FORMAT,
238                                min_size(), Thread::current()-&gt;tlab().initial_desired_size(), max_size());
239 }
240 
241 size_t ThreadLocalAllocBuffer::initial_desired_size() {
242   size_t init_sz = 0;
243 
244   if (TLABSize &gt; 0) {
245     init_sz = TLABSize / HeapWordSize;
246   } else {
247     // Initial size is a function of the average number of allocating threads.
248     unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();
249 
250     init_sz  = (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize) /
251                       (nof_threads * target_refills());
252     init_sz = align_object_size(init_sz);
253   }




254   init_sz = MIN2(MAX2(init_sz, min_size()), max_size());
255   return init_sz;
256 }
257 
258 void ThreadLocalAllocBuffer::print_stats(const char* tag) {
259   Log(gc, tlab) log;
260   if (!log.is_trace()) {
261     return;
262   }
263 
264   Thread* thrd = thread();
265   size_t waste = _gc_waste + _slow_refill_waste + _fast_refill_waste;
266   double waste_percent = percent_of(waste, _allocated_size);
267   size_t tlab_used  = Universe::heap()-&gt;tlab_used(thrd);
268   log.trace(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
269             &quot; desired_size: &quot; SIZE_FORMAT &quot;KB&quot;
270             &quot; slow allocs: %d  refill waste: &quot; SIZE_FORMAT &quot;B&quot;
271             &quot; alloc:%8.5f %8.0fKB refills: %d waste %4.1f%% gc: %dB&quot;
272             &quot; slow: %dB fast: %dB&quot;,
273             tag, p2i(thrd), thrd-&gt;osthread()-&gt;thread_id(),
274             _desired_size / (K / HeapWordSize),
275             _slow_allocations, _refill_waste_limit * HeapWordSize,
276             _allocation_fraction.average(),
277             _allocation_fraction.average() * tlab_used / K,
278             _number_of_refills, waste_percent,
279             _gc_waste * HeapWordSize,
280             _slow_refill_waste * HeapWordSize,
281             _fast_refill_waste * HeapWordSize);
282 }
283 
<span class="line-modified">284 void ThreadLocalAllocBuffer::set_sample_end() {</span>
285   size_t heap_words_remaining = pointer_delta(_end, _top);
286   size_t bytes_until_sample = thread()-&gt;heap_sampler().bytes_until_sample();
287   size_t words_until_sample = bytes_until_sample / HeapWordSize;
288 




289   if (heap_words_remaining &gt; words_until_sample) {
290     HeapWord* new_end = _top + words_until_sample;
291     set_end(new_end);
<span class="line-modified">292     _bytes_since_last_sample_point = bytes_until_sample;</span>
293   } else {
<span class="line-modified">294     _bytes_since_last_sample_point = heap_words_remaining * HeapWordSize;</span>
295   }
296 }
297 
298 Thread* ThreadLocalAllocBuffer::thread() {
299   return (Thread*)(((char*)this) + in_bytes(start_offset()) - in_bytes(Thread::tlab_start_offset()));
300 }
301 
302 void ThreadLocalAllocBuffer::set_back_allocation_end() {
303   _end = _allocation_end;
304 }
305 
306 HeapWord* ThreadLocalAllocBuffer::hard_end() {
307   return _allocation_end + alignment_reserve();
308 }
309 
310 PerfVariable* ThreadLocalAllocStats::_perf_allocating_threads;
311 PerfVariable* ThreadLocalAllocStats::_perf_total_refills;
312 PerfVariable* ThreadLocalAllocStats::_perf_max_refills;
313 PerfVariable* ThreadLocalAllocStats::_perf_total_allocations;
314 PerfVariable* ThreadLocalAllocStats::_perf_total_gc_waste;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
115   if (end() != NULL) {
116     invariants();
117     thread()-&gt;incr_allocated_bytes(used_bytes());
118     insert_filler();
119     initialize(NULL, NULL, NULL);
120   }
121 }
122 
123 void ThreadLocalAllocBuffer::retire_before_allocation() {
124   _slow_refill_waste += (unsigned int)remaining();
125   retire();
126 }
127 
128 void ThreadLocalAllocBuffer::resize() {
129   // Compute the next tlab size using expected allocation amount
130   assert(ResizeTLAB, &quot;Should not call this otherwise&quot;);
131   size_t alloc = (size_t)(_allocation_fraction.average() *
132                           (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize));
133   size_t new_size = alloc / _target_refills;
134 
<span class="line-modified">135   new_size = clamp(new_size, min_size(), max_size());</span>
136 
137   size_t aligned_new_size = align_object_size(new_size);
138 
139   log_trace(gc, tlab)(&quot;TLAB new size: thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
140                       &quot; refills %d  alloc: %8.6f desired_size: &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,
141                       p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),
142                       _target_refills, _allocation_fraction.average(), desired_size(), aligned_new_size);
143 
144   set_desired_size(aligned_new_size);
145   set_refill_waste_limit(initial_refill_waste_limit());
146 }
147 
148 void ThreadLocalAllocBuffer::reset_statistics() {
149   _number_of_refills = 0;
150   _fast_refill_waste = 0;
151   _slow_refill_waste = 0;
152   _gc_waste          = 0;
153   _slow_allocations  = 0;
154   _allocated_size    = 0;
155 }
</pre>
<hr />
<pre>
234   guarantee(Thread::current()-&gt;is_Java_thread(), &quot;tlab initialization thread not Java thread&quot;);
235   Thread::current()-&gt;tlab().initialize();
236 
237   log_develop_trace(gc, tlab)(&quot;TLAB min: &quot; SIZE_FORMAT &quot; initial: &quot; SIZE_FORMAT &quot; max: &quot; SIZE_FORMAT,
238                                min_size(), Thread::current()-&gt;tlab().initial_desired_size(), max_size());
239 }
240 
241 size_t ThreadLocalAllocBuffer::initial_desired_size() {
242   size_t init_sz = 0;
243 
244   if (TLABSize &gt; 0) {
245     init_sz = TLABSize / HeapWordSize;
246   } else {
247     // Initial size is a function of the average number of allocating threads.
248     unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();
249 
250     init_sz  = (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize) /
251                       (nof_threads * target_refills());
252     init_sz = align_object_size(init_sz);
253   }
<span class="line-added">254   // We can&#39;t use clamp() between min_size() and max_size() here because some</span>
<span class="line-added">255   // options based on them may still be inconsistent and so it may assert;</span>
<span class="line-added">256   // inconsistencies between those will be caught by following AfterMemoryInit</span>
<span class="line-added">257   // constraint checking.</span>
258   init_sz = MIN2(MAX2(init_sz, min_size()), max_size());
259   return init_sz;
260 }
261 
262 void ThreadLocalAllocBuffer::print_stats(const char* tag) {
263   Log(gc, tlab) log;
264   if (!log.is_trace()) {
265     return;
266   }
267 
268   Thread* thrd = thread();
269   size_t waste = _gc_waste + _slow_refill_waste + _fast_refill_waste;
270   double waste_percent = percent_of(waste, _allocated_size);
271   size_t tlab_used  = Universe::heap()-&gt;tlab_used(thrd);
272   log.trace(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
273             &quot; desired_size: &quot; SIZE_FORMAT &quot;KB&quot;
274             &quot; slow allocs: %d  refill waste: &quot; SIZE_FORMAT &quot;B&quot;
275             &quot; alloc:%8.5f %8.0fKB refills: %d waste %4.1f%% gc: %dB&quot;
276             &quot; slow: %dB fast: %dB&quot;,
277             tag, p2i(thrd), thrd-&gt;osthread()-&gt;thread_id(),
278             _desired_size / (K / HeapWordSize),
279             _slow_allocations, _refill_waste_limit * HeapWordSize,
280             _allocation_fraction.average(),
281             _allocation_fraction.average() * tlab_used / K,
282             _number_of_refills, waste_percent,
283             _gc_waste * HeapWordSize,
284             _slow_refill_waste * HeapWordSize,
285             _fast_refill_waste * HeapWordSize);
286 }
287 
<span class="line-modified">288 void ThreadLocalAllocBuffer::set_sample_end(bool reset_byte_accumulation) {</span>
289   size_t heap_words_remaining = pointer_delta(_end, _top);
290   size_t bytes_until_sample = thread()-&gt;heap_sampler().bytes_until_sample();
291   size_t words_until_sample = bytes_until_sample / HeapWordSize;
292 
<span class="line-added">293   if (reset_byte_accumulation) {</span>
<span class="line-added">294     _bytes_since_last_sample_point = 0;</span>
<span class="line-added">295   }</span>
<span class="line-added">296 </span>
297   if (heap_words_remaining &gt; words_until_sample) {
298     HeapWord* new_end = _top + words_until_sample;
299     set_end(new_end);
<span class="line-modified">300     _bytes_since_last_sample_point += bytes_until_sample;</span>
301   } else {
<span class="line-modified">302     _bytes_since_last_sample_point += heap_words_remaining * HeapWordSize;</span>
303   }
304 }
305 
306 Thread* ThreadLocalAllocBuffer::thread() {
307   return (Thread*)(((char*)this) + in_bytes(start_offset()) - in_bytes(Thread::tlab_start_offset()));
308 }
309 
310 void ThreadLocalAllocBuffer::set_back_allocation_end() {
311   _end = _allocation_end;
312 }
313 
314 HeapWord* ThreadLocalAllocBuffer::hard_end() {
315   return _allocation_end + alignment_reserve();
316 }
317 
318 PerfVariable* ThreadLocalAllocStats::_perf_allocating_threads;
319 PerfVariable* ThreadLocalAllocStats::_perf_total_refills;
320 PerfVariable* ThreadLocalAllocStats::_perf_max_refills;
321 PerfVariable* ThreadLocalAllocStats::_perf_total_allocations;
322 PerfVariable* ThreadLocalAllocStats::_perf_total_gc_waste;
</pre>
</td>
</tr>
</table>
<center><a href="taskqueue.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
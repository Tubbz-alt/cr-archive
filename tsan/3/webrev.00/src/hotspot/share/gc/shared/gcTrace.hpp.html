<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/gcTrace.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GCTRACE_HPP
 26 #define SHARE_GC_SHARED_GCTRACE_HPP
 27 
 28 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 29 #include &quot;gc/shared/gcCause.hpp&quot;
 30 #include &quot;gc/shared/gcId.hpp&quot;
 31 #include &quot;gc/shared/gcName.hpp&quot;
 32 #include &quot;gc/shared/gcWhen.hpp&quot;
 33 #include &quot;memory/metaspace.hpp&quot;
 34 #include &quot;memory/referenceType.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 #include &quot;utilities/ticks.hpp&quot;
 37 
 38 class GCHeapSummary;
 39 class MetaspaceChunkFreeListSummary;
 40 class MetaspaceSummary;
 41 class PSHeapSummary;
 42 class ReferenceProcessorStats;
 43 class TimePartitions;
 44 class BoolObjectClosure;
 45 
 46 class SharedGCInfo {
 47  private:
 48   GCName _name;
 49   GCCause::Cause _cause;
 50   Ticks     _start_timestamp;
 51   Ticks     _end_timestamp;
 52   Tickspan  _sum_of_pauses;
 53   Tickspan  _longest_pause;
 54 
 55  public:
 56   SharedGCInfo(GCName name) :
 57     _name(name),
 58     _cause(GCCause::_last_gc_cause),
 59     _start_timestamp(),
 60     _end_timestamp(),
 61     _sum_of_pauses(),
 62     _longest_pause() {
 63   }
 64 
 65   void set_start_timestamp(const Ticks&amp; timestamp) { _start_timestamp = timestamp; }
 66   const Ticks start_timestamp() const { return _start_timestamp; }
 67 
 68   void set_end_timestamp(const Ticks&amp; timestamp) { _end_timestamp = timestamp; }
 69   const Ticks end_timestamp() const { return _end_timestamp; }
 70 
 71   void set_name(GCName name) { _name = name; }
 72   GCName name() const { return _name; }
 73 
 74   void set_cause(GCCause::Cause cause) { _cause = cause; }
 75   GCCause::Cause cause() const { return _cause; }
 76 
 77   void set_sum_of_pauses(const Tickspan&amp; duration) { _sum_of_pauses = duration; }
 78   const Tickspan sum_of_pauses() const { return _sum_of_pauses; }
 79 
 80   void set_longest_pause(const Tickspan&amp; duration) { _longest_pause = duration; }
 81   const Tickspan longest_pause() const { return _longest_pause; }
 82 };
 83 
 84 class ParallelOldGCInfo {
 85   void* _dense_prefix;
 86  public:
 87   ParallelOldGCInfo() : _dense_prefix(NULL) {}
 88   void report_dense_prefix(void* addr) {
 89     _dense_prefix = addr;
 90   }
 91   void* dense_prefix() const { return _dense_prefix; }
 92 };
 93 
 94 class GCTracer : public ResourceObj {
 95  protected:
 96   SharedGCInfo _shared_gc_info;
 97 
 98  public:
 99   void report_gc_start(GCCause::Cause cause, const Ticks&amp; timestamp);
100   void report_gc_end(const Ticks&amp; timestamp, TimePartitions* time_partitions);
101   void report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const;
102   void report_metaspace_summary(GCWhen::Type when, const MetaspaceSummary&amp; metaspace_summary) const;
103   void report_gc_reference_stats(const ReferenceProcessorStats&amp; rp) const;
104   void report_object_count_after_gc(BoolObjectClosure* object_filter) NOT_SERVICES_RETURN;
105 
106  protected:
107   GCTracer(GCName name) : _shared_gc_info(name) {}
108   virtual void report_gc_start_impl(GCCause::Cause cause, const Ticks&amp; timestamp);
109   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
110 
111  private:
112   void send_garbage_collection_event() const;
113   void send_gc_heap_summary_event(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const;
114   void send_meta_space_summary_event(GCWhen::Type when, const MetaspaceSummary&amp; meta_space_summary) const;
115   void send_metaspace_chunk_free_list_summary(GCWhen::Type when, Metaspace::MetadataType mdtype, const MetaspaceChunkFreeListSummary&amp; summary) const;
116   void send_reference_stats_event(ReferenceType type, size_t count) const;
117   void send_phase_events(TimePartitions* time_partitions) const;
118 };
119 
120 class YoungGCTracer : public GCTracer {
121   static const uint UNSET_TENURING_THRESHOLD = (uint) -1;
122 
123   uint _tenuring_threshold;
124 
125  protected:
126   YoungGCTracer(GCName name) : GCTracer(name), _tenuring_threshold(UNSET_TENURING_THRESHOLD) {}
127   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
128 
129  public:
130   void report_promotion_failed(const PromotionFailedInfo&amp; pf_info) const;
131   void report_tenuring_threshold(const uint tenuring_threshold);
132 
133   /*
134    * Methods for reporting Promotion in new or outside PLAB Events.
135    *
136    * The object age is always required as it is not certain that the mark word
137    * of the oop can be trusted at this stage.
138    *
139    * obj_size is the size of the promoted object in bytes.
140    *
141    * tenured should be true if the object has been promoted to the old
142    * space during this GC, if the object is copied to survivor space
143    * from young space or survivor space (aging) tenured should be false.
144    *
145    * plab_size is the size of the newly allocated PLAB in bytes.
146    */
147   bool should_report_promotion_events() const;
148   bool should_report_promotion_in_new_plab_event() const;
149   bool should_report_promotion_outside_plab_event() const;
150   void report_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
151                                           uint age, bool tenured,
152                                           size_t plab_size) const;
153   void report_promotion_outside_plab_event(Klass* klass, size_t obj_size,
154                                            uint age, bool tenured) const;
155 
156  private:
157   void send_young_gc_event() const;
158   void send_promotion_failed_event(const PromotionFailedInfo&amp; pf_info) const;
159   bool should_send_promotion_in_new_plab_event() const;
160   bool should_send_promotion_outside_plab_event() const;
161   void send_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
162                                         uint age, bool tenured,
163                                         size_t plab_size) const;
164   void send_promotion_outside_plab_event(Klass* klass, size_t obj_size,
165                                          uint age, bool tenured) const;
166 };
167 
168 class OldGCTracer : public GCTracer {
169  protected:
170   OldGCTracer(GCName name) : GCTracer(name) {}
171   virtual void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
172 
173  public:
174   void report_concurrent_mode_failure();
175 
176  private:
177   void send_old_gc_event() const;
178   void send_concurrent_mode_failure_event();
179 };
180 
181 class ParallelOldTracer : public OldGCTracer {
182   ParallelOldGCInfo _parallel_old_gc_info;
183 
184  public:
185   ParallelOldTracer() : OldGCTracer(ParallelOld) {}
186   void report_dense_prefix(void* dense_prefix);
187 
188  protected:
189   void report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions);
190 
191  private:
192   void send_parallel_old_event() const;
193 };
194 
195 class SerialOldTracer : public OldGCTracer {
196  public:
197   SerialOldTracer() : OldGCTracer(SerialOld) {}
198 };
199 
200 class ParallelScavengeTracer : public YoungGCTracer {
201  public:
202   ParallelScavengeTracer() : YoungGCTracer(ParallelScavenge) {}
203 };
204 
205 class DefNewTracer : public YoungGCTracer {
206  public:
207   DefNewTracer() : YoungGCTracer(DefNew) {}
208 };
209 
210 #endif // SHARE_GC_SHARED_GCTRACE_HPP
    </pre>
  </body>
</html>
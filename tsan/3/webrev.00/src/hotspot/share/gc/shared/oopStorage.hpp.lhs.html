<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/oopStorage.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_OOPSTORAGE_HPP
 26 #define SHARE_GC_SHARED_OOPSTORAGE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/oop.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 #include &quot;utilities/singleWriterSynchronizer.hpp&quot;
 33 
 34 class Mutex;
 35 class outputStream;
 36 
 37 // OopStorage supports management of off-heap references to objects allocated
 38 // in the Java heap.  An OopStorage object provides a set of Java object
 39 // references (oop values), which clients refer to via oop* handles to the
 40 // associated OopStorage entries.  Clients allocate entries to create a
 41 // (possibly weak) reference to a Java object, use that reference, and release
 42 // the reference when no longer needed.
 43 //
 44 // The garbage collector must know about all OopStorage objects and their
 45 // reference strength.  OopStorage provides the garbage collector with support
 46 // for iteration over all the allocated entries.
 47 //
 48 // There are several categories of interaction with an OopStorage object.
 49 //
 50 // (1) allocation and release of entries, by the mutator or the VM.
 51 // (2) iteration by the garbage collector, possibly concurrent with mutator.
 52 // (3) iteration by other, non-GC, tools (only at safepoints).
 53 // (4) cleanup of unused internal storage, possibly concurrent with mutator.
 54 //
 55 // A goal of OopStorage is to make these interactions thread-safe, while
 56 // minimizing potential lock contention issues within and between these
 57 // categories.  In particular, support for concurrent iteration by the garbage
 58 // collector, under certain restrictions, is required.  Further, it must not
 59 // block nor be blocked by other operations for long periods.
 60 //
 61 // Internally, OopStorage is a set of Block objects, from which entries are
 62 // allocated and released.  A block contains an oop[] and a bitmask indicating
 63 // which entries are in use (have been allocated and not yet released).  New
 64 // blocks are constructed and added to the storage object when an entry
 65 // allocation request is made and there are no blocks with unused entries.
 66 // Blocks may be removed and deleted when empty.
 67 //
 68 // There are two important (and somewhat intertwined) protocols governing
 69 // concurrent access to a storage object.  These are the Concurrent Iteration
 70 // Protocol and the Allocation Protocol.  See the ParState class for a
 71 // discussion of concurrent iteration and the management of thread
 72 // interactions for this protocol.  Similarly, see the allocate() function for
 73 // a discussion of allocation.
 74 
 75 class OopStorage : public CHeapObj&lt;mtGC&gt; {
 76 public:
 77   OopStorage(const char* name, Mutex* allocation_mutex, Mutex* active_mutex);
 78   ~OopStorage();
 79 
 80   // These count and usage accessors are racy unless at a safepoint.
 81 
 82   // The number of allocated and not yet released entries.
 83   size_t allocation_count() const;
 84 
 85   // The number of blocks of entries.  Useful for sizing parallel iteration.
 86   size_t block_count() const;
 87 
 88   // Total number of blocks * memory allocation per block, plus
 89   // bookkeeping overhead, including this storage object.
 90   size_t total_memory_usage() const;
 91 
 92   enum EntryStatus {
 93     INVALID_ENTRY,
 94     UNALLOCATED_ENTRY,
 95     ALLOCATED_ENTRY
 96   };
 97 
 98   // Locks _allocation_mutex.
 99   // precondition: ptr != NULL.
100   EntryStatus allocation_status(const oop* ptr) const;
101 
102   // Allocates and returns a new entry.  Returns NULL if memory allocation
103   // failed.  Locks _allocation_mutex.
104   // postcondition: *result == NULL.
105   oop* allocate();
106 
107   // Deallocates ptr.  No locking.
108   // precondition: ptr is a valid allocated entry.
109   // precondition: *ptr == NULL.
110   void release(const oop* ptr);
111 
112   // Releases all the ptrs.  Possibly faster than individual calls to
113   // release(oop*).  Best if ptrs is sorted by address.  No locking.
114   // precondition: All elements of ptrs are valid allocated entries.
115   // precondition: *ptrs[i] == NULL, for i in [0,size).
116   void release(const oop* const* ptrs, size_t size);
117 
118   // Applies f to each allocated entry&#39;s location.  f must be a function or
119   // function object.  Assume p is either a const oop* or an oop*, depending
120   // on whether the associated storage is const or non-const, respectively.
121   // Then f(p) must be a valid expression.  The result of invoking f(p) must
122   // be implicitly convertible to bool.  Iteration terminates and returns
123   // false if any invocation of f returns false.  Otherwise, the result of
124   // iteration is true.
125   // precondition: at safepoint.
126   template&lt;typename F&gt; inline bool iterate_safepoint(F f);
127   template&lt;typename F&gt; inline bool iterate_safepoint(F f) const;
128 
129   // oops_do and weak_oops_do are wrappers around iterate_safepoint, providing
130   // an adaptation layer allowing the use of existing is-alive closures and
131   // OopClosures.  Assume p is either const oop* or oop*, depending on whether
132   // the associated storage is const or non-const, respectively.  Then
133   //
134   // - closure-&gt;do_oop(p) must be a valid expression whose value is ignored.
135   //
136   // - is_alive-&gt;do_object_b(*p) must be a valid expression whose value is
137   // convertible to bool.
138   //
139   // For weak_oops_do, if *p == NULL then neither is_alive nor closure will be
140   // invoked for p.  If is_alive-&gt;do_object_b(*p) is false, then closure will
141   // not be invoked on p, and *p will be set to NULL.
142 
143   template&lt;typename Closure&gt; inline void oops_do(Closure* closure);
144   template&lt;typename Closure&gt; inline void oops_do(Closure* closure) const;
145   template&lt;typename Closure&gt; inline void weak_oops_do(Closure* closure);
146 
147   template&lt;typename IsAliveClosure, typename Closure&gt;
148   inline void weak_oops_do(IsAliveClosure* is_alive, Closure* closure);
149 
150   // Parallel iteration is for the exclusive use of the GC.
151   // Other clients must use serial iteration.
152   template&lt;bool concurrent, bool is_const&gt; class ParState;
153 
154   // Service thread cleanup support.
<a name="1" id="anc1"></a><span class="line-modified">155   // Stops deleting if there is an in-progress concurrent iteration.</span>
<span class="line-modified">156   // Locks both the _allocation_mutex and the _active_mutex, and may</span>
<span class="line-modified">157   // safepoint.  Deletion may be throttled, with only some available</span>
<span class="line-modified">158   // work performed, in order to allow other Service thread subtasks</span>
<span class="line-modified">159   // to run.  Returns true if there may be more work to do, false if</span>
<span class="line-modified">160   // nothing to do.</span>


161   bool delete_empty_blocks();
162 
<a name="2" id="anc2"></a><span class="line-modified">163   // Service thread cleanup support.</span>
<span class="line-modified">164   // Called by the service thread (while holding Service_lock) to test</span>
<span class="line-modified">165   // whether a call to delete_empty_blocks should be made.</span>
<span class="line-modified">166   bool needs_delete_empty_blocks() const;</span>






167 
168   // Debugging and logging support.
169   const char* name() const;
170   void print_on(outputStream* st) const PRODUCT_RETURN;
171 
172   // Provides access to storage internals, for unit testing.
173   // Declare, but not define, the public class OopStorage::TestAccess.
174   // That class is defined as part of the unit-test. It &quot;exports&quot; the needed
175   // private types by providing public typedefs for them.
176   class TestAccess;
177 
<a name="3" id="anc3"></a><span class="line-modified">178   // xlC on AIX can&#39;t compile test_oopStorage.cpp with following private</span>
<span class="line-removed">179   // classes. C++03 introduced access for nested classes with DR45, but xlC</span>
<span class="line-removed">180   // version 12 rejects it.</span>
<span class="line-removed">181 NOT_AIX( private: )</span>
182   class Block;                  // Fixed-size array of oops, plus bookkeeping.
183   class ActiveArray;            // Array of Blocks, plus bookkeeping.
184   class AllocationListEntry;    // Provides AllocationList links in a Block.
185 
186   // Doubly-linked list of Blocks.
187   class AllocationList {
188     const Block* _head;
189     const Block* _tail;
190 
<a name="4" id="anc4"></a><span class="line-modified">191     // Noncopyable.</span>
<span class="line-removed">192     AllocationList(const AllocationList&amp;);</span>
<span class="line-removed">193     AllocationList&amp; operator=(const AllocationList&amp;);</span>
194 
195   public:
196     AllocationList();
197     ~AllocationList();
198 
199     Block* head();
200     Block* tail();
201     const Block* chead() const;
202     const Block* ctail() const;
203 
204     Block* prev(Block&amp; block);
205     Block* next(Block&amp; block);
206 
207     const Block* prev(const Block&amp; block) const;
208     const Block* next(const Block&amp; block) const;
209 
210     void push_front(const Block&amp; block);
211     void push_back(const Block&amp; block);
212     void unlink(const Block&amp; block);
213   };
214 
215 private:
216   const char* _name;
217   ActiveArray* _active_array;
218   AllocationList _allocation_list;
<a name="5" id="anc5"></a><span class="line-removed">219 AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
220   Block* volatile _deferred_updates;
<a name="6" id="anc6"></a><span class="line-removed">221 AIX_ONLY(private:)</span>
<span class="line-removed">222 </span>
223   Mutex* _allocation_mutex;
224   Mutex* _active_mutex;
225 
226   // Volatile for racy unlocked accesses.
227   volatile size_t _allocation_count;
228 
229   // Protection for _active_array.
230   mutable SingleWriterSynchronizer _protect_active;
231 
232   // mutable because this gets set even for const iteration.
233   mutable int _concurrent_iteration_count;
234 
<a name="7" id="anc7"></a><span class="line-modified">235   volatile uint _needs_cleanup;</span>
236 
237   bool try_add_block();
238   Block* block_for_allocation();
239 
240   Block* find_block_or_null(const oop* ptr) const;
241   void delete_empty_block(const Block&amp; block);
242   bool reduce_deferred_updates();
<a name="8" id="anc8"></a><span class="line-removed">243   void notify_needs_cleanup();</span>
<span class="line-removed">244 AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
245   void record_needs_cleanup();
<a name="9" id="anc9"></a><span class="line-removed">246 AIX_ONLY(private:)</span>
247 
248   // Managing _active_array.
249   bool expand_active_array();
250   void replace_active_array(ActiveArray* new_array);
251   ActiveArray* obtain_active_array() const;
252   void relinquish_block_array(ActiveArray* array) const;
253   class WithActiveArray;        // RAII helper for active array access.
254 
255   template&lt;typename F, typename Storage&gt;
256   static bool iterate_impl(F f, Storage* storage);
257 
258   // Implementation support for parallel iteration
259   class BasicParState;
260 
261   // Wrapper for OopClosure-style function, so it can be used with
262   // iterate.  Assume p is of type oop*.  Then cl-&gt;do_oop(p) must be a
263   // valid expression whose value may be ignored.
264   template&lt;typename Closure&gt; class OopFn;
265   template&lt;typename Closure&gt; static OopFn&lt;Closure&gt; oop_fn(Closure* cl);
266 
267   // Wrapper for BoolObjectClosure + iteration handler pair, so they
268   // can be used with iterate.
269   template&lt;typename IsAlive, typename F&gt; class IfAliveFn;
270   template&lt;typename IsAlive, typename F&gt;
271   static IfAliveFn&lt;IsAlive, F&gt; if_alive_fn(IsAlive* is_alive, F f);
272 
273   // Wrapper for iteration handler, automatically skipping NULL entries.
274   template&lt;typename F&gt; class SkipNullFn;
275   template&lt;typename F&gt; static SkipNullFn&lt;F&gt; skip_null_fn(F f);
276 };
277 
278 #endif // SHARE_GC_SHARED_OOPSTORAGE_HPP
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/markBitMap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_MARKBITMAP_HPP
 26 #define SHARE_GC_SHARED_MARKBITMAP_HPP
 27 
 28 #include &quot;memory/memRegion.hpp&quot;
 29 #include &quot;oops/oopsHierarchy.hpp&quot;
 30 #include &quot;utilities/bitMap.hpp&quot;
 31 
 32 // A generic mark bitmap for concurrent marking.  This is essentially a wrapper
 33 // around the BitMap class that is based on HeapWords, with one bit per (1 &lt;&lt; _shifter) HeapWords.
 34 class MarkBitMap {
 35 protected:
 36   MemRegion _covered;    // The heap area covered by this bitmap.
 37 
 38   const int _shifter;    // Shift amount from heap index to bit index in the bitmap.
 39 
 40   BitMapView _bm;        // The actual bitmap.
 41 
 42   virtual void check_mark(HeapWord* addr) NOT_DEBUG_RETURN;
 43 
 44   // Convert from bit offset to address.
 45   HeapWord* offset_to_addr(size_t offset) const {
 46     return _covered.start() + (offset &lt;&lt; _shifter);
 47   }
 48   // Convert from address to bit offset.
 49   size_t addr_to_offset(const HeapWord* addr) const {
 50     return pointer_delta(addr, _covered.start()) &gt;&gt; _shifter;
 51   }
 52 
 53   // Clear bitmap range
 54   void do_clear(MemRegion mr, bool large);
 55 
 56 public:
 57   static size_t compute_size(size_t heap_size);
 58   // Returns the amount of bytes on the heap between two marks in the bitmap.
 59   static size_t mark_distance();
 60   // Returns how many bytes (or bits) of the heap a single byte (or bit) of the
 61   // mark bitmap corresponds to. This is the same as the mark distance above.
 62   static size_t heap_map_factor() {
 63     return mark_distance();
 64   }
 65 
 66   MarkBitMap() : _covered(), _shifter(LogMinObjAlignment), _bm() {}
 67 
 68   // Initializes the underlying BitMap to cover the given area.
 69   void initialize(MemRegion heap, MemRegion storage);
 70 
 71   // Read marks
 72   bool is_marked(oop obj) const;
 73   bool is_marked(HeapWord* addr) const {
 74     assert(_covered.contains(addr),
 75            &quot;Address &quot; PTR_FORMAT &quot; is outside underlying space from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT,
 76            p2i(addr), p2i(_covered.start()), p2i(_covered.end()));
 77     return _bm.at(addr_to_offset(addr));
 78   }
 79 
 80   // Return the address corresponding to the next marked bit at or after
 81   // &quot;addr&quot;, and before &quot;limit&quot;, if &quot;limit&quot; is non-NULL.  If there is no
 82   // such bit, returns &quot;limit&quot; if that is non-NULL, or else &quot;endWord()&quot;.
 83   inline HeapWord* get_next_marked_addr(const HeapWord* addr,
 84                                         const HeapWord* limit) const;
 85 
 86   void print_on_error(outputStream* st, const char* prefix) const;
 87 
 88   // Write marks.
 89   inline void mark(HeapWord* addr);
<a name="1" id="anc1"></a><span class="line-added"> 90   inline void mark(oop obj);</span>
 91   inline void clear(HeapWord* addr);
 92   inline void clear(oop obj);
 93   inline bool par_mark(HeapWord* addr);
 94   inline bool par_mark(oop obj);
 95 
 96   // Clear bitmap.
 97   void clear()                         { do_clear(_covered, true); }
 98   void clear_range(MemRegion mr)       { do_clear(mr, false);      }
 99   void clear_range_large(MemRegion mr) { do_clear(mr, true);       }
100 };
101 
102 #endif // SHARE_GC_SHARED_MARKBITMAP_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/scavengableNMethods.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="satbMarkQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/scavengableNMethods.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;
<span class="line-removed"> 28 #include &quot;compiler/compileTask.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
 30 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 31 #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<span class="line-modified"> 32 #include &quot;logging/log.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;logging/logStream.hpp&quot;</span>
<span class="line-removed"> 34 #include &quot;memory/universe.hpp&quot;</span>
 35 #include &quot;utilities/debug.hpp&quot;
 36 
 37 static ScavengableNMethodsData gc_data(nmethod* nm) {
 38   return ScavengableNMethodsData(nm);
 39 }
 40 
 41 nmethod* ScavengableNMethods::_head = NULL;
 42 BoolObjectClosure* ScavengableNMethods::_is_scavengable = NULL;
 43 
 44 void ScavengableNMethods::initialize(BoolObjectClosure* is_scavengable) {
 45   _is_scavengable = is_scavengable;
 46 }
 47 
 48 // Conditionally adds the nmethod to the list if it is
 49 // not already on the list and has a scavengeable root.
 50 void ScavengableNMethods::register_nmethod(nmethod* nm) {
 51   assert_locked_or_safepoint(CodeCache_lock);
 52 
 53   ScavengableNMethodsData data = gc_data(nm);
 54 
 55   if (data.on_list() || !has_scavengable_oops(nm)) {
 56     return;
 57   }
 58 
 59   data.set_on_list();
 60   data.set_next(_head);
 61 
 62   _head = nm;
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64   CodeCache::print_trace(&quot;register_nmethod&quot;, nm);</span>
 65 }
 66 
 67 void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<span class="line-modified"> 68   // Do nothing. Unlinking is currently delayed until the purge phase.</span>











 69 }
 70 
 71 #ifndef PRODUCT
 72 
 73 class DebugScavengableOops: public OopClosure {
 74   BoolObjectClosure* _is_scavengable;
 75   nmethod*           _nm;
 76   bool               _ok;
 77 public:
 78   DebugScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
 79       _is_scavengable(is_scavengable),
 80       _nm(nm),
 81       _ok(true) { }
 82 
 83   bool ok() { return _ok; }
 84   virtual void do_oop(oop* p) {
 85     if (*p == NULL || !_is_scavengable-&gt;do_object_b(*p)) {
 86       return;
 87     }
 88 
</pre>
<hr />
<pre>
 95     (*p)-&gt;print();
 96   }
 97   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
 98 };
 99 
100 #endif // PRODUCT
101 
102 void ScavengableNMethods::verify_nmethod(nmethod* nm) {
103 #ifndef PRODUCT
104   if (!gc_data(nm).on_list()) {
105     // Actually look inside, to verify the claim that it&#39;s clean.
106     DebugScavengableOops cl(_is_scavengable, nm);
107     nm-&gt;oops_do(&amp;cl);
108     if (!cl.ok())
109       fatal(&quot;found an unadvertised bad scavengable oop in the code cache&quot;);
110   }
111   assert(gc_data(nm).not_marked(), &quot;&quot;);
112 #endif // PRODUCT
113 }
114 
<span class="line-removed">115 void ScavengableNMethods::flush_nmethod(nmethod* nm) {</span>
<span class="line-removed">116   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">117 </span>
<span class="line-removed">118   // TODO: Should be done in unregister_nmethod, during the &quot;unlink&quot; phase.</span>
<span class="line-removed">119   if (gc_data(nm).on_list()) {</span>
<span class="line-removed">120     CodeCache::print_trace(&quot;flush_nmethod&quot;, nm);</span>
<span class="line-removed">121     nmethod* prev = NULL;</span>
<span class="line-removed">122     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-removed">123       if (cur == nm) {</span>
<span class="line-removed">124         unlist_nmethod(cur, prev);</span>
<span class="line-removed">125         return;</span>
<span class="line-removed">126       }</span>
<span class="line-removed">127       prev = cur;</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129   }</span>
<span class="line-removed">130 }</span>
<span class="line-removed">131 </span>
132 class HasScavengableOops: public OopClosure {
133   BoolObjectClosure* _is_scavengable;
134   bool               _found;
<span class="line-removed">135   nmethod*           _print_nm;</span>
136 public:
137   HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
138       _is_scavengable(is_scavengable),
<span class="line-modified">139       _found(false),</span>
<span class="line-removed">140       _print_nm(nm) {}</span>
141 
142   bool found() { return _found; }
143   virtual void do_oop(oop* p) {
<span class="line-modified">144     if (*p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>
<span class="line-removed">145       NOT_PRODUCT(maybe_print(p));</span>
146       _found = true;
147     }
148   }
149   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
<span class="line-removed">150 </span>
<span class="line-removed">151 #ifndef PRODUCT</span>
<span class="line-removed">152   void maybe_print(oop* p) {</span>
<span class="line-removed">153     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">154     if (lt.is_enabled()) {</span>
<span class="line-removed">155       LogStream ls(lt);</span>
<span class="line-removed">156       if (!_found) {</span>
<span class="line-removed">157         CompileTask::print(&amp;ls, _print_nm, &quot;new scavengable oop&quot;, /*short_form:*/ true);</span>
<span class="line-removed">158       }</span>
<span class="line-removed">159       ls.print(&quot;&quot; PTR_FORMAT &quot;[offset=%d] found scavengable oop &quot; PTR_FORMAT &quot; (found at &quot; PTR_FORMAT &quot;) &quot;,</span>
<span class="line-removed">160                p2i(_print_nm), (int)((intptr_t)p - (intptr_t)_print_nm),</span>
<span class="line-removed">161                p2i(*p), p2i(p));</span>
<span class="line-removed">162       ls.cr();</span>
<span class="line-removed">163     }</span>
<span class="line-removed">164   }</span>
<span class="line-removed">165 #endif //PRODUCT</span>
166 };
167 
168 bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
169   HasScavengableOops cl(_is_scavengable, nm);
170   nm-&gt;oops_do(&amp;cl);
171   return cl.found();
172 }
173 
174 // Walk the list of methods which might contain oops to the java heap.
<span class="line-modified">175 void ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure* f) {</span>
176   assert_locked_or_safepoint(CodeCache_lock);
177 
<span class="line-removed">178   const bool fix_relocations = f-&gt;fix_relocations();</span>
179   debug_only(mark_on_list_nmethods());
180 
181   nmethod* prev = NULL;
182   nmethod* cur = _head;
183   while (cur != NULL) {


184     ScavengableNMethodsData data = gc_data(cur);
185     debug_only(data.clear_marked());
<span class="line-removed">186     assert(data.not_marked(), &quot;&quot;);</span>
187     assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
188 
<span class="line-modified">189     bool is_live = (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded());</span>
<span class="line-modified">190     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">191     if (lt.is_enabled()) {</span>
<span class="line-removed">192       LogStream ls(lt);</span>
<span class="line-removed">193       CompileTask::print(&amp;ls, cur,</span>
<span class="line-removed">194         is_live ? &quot;scavengable root &quot; : &quot;dead scavengable root&quot;, /*short_form:*/ true);</span>
<span class="line-removed">195     }</span>
<span class="line-removed">196     if (is_live) {</span>
<span class="line-removed">197       // Perform cur-&gt;oops_do(f), maybe just once per nmethod.</span>
<span class="line-removed">198       f-&gt;do_code_blob(cur);</span>
199     }

200     nmethod* const next = data.next();
<span class="line-modified">201     // The scavengable nmethod list must contain all methods with scavengable</span>
<span class="line-modified">202     // oops. It is safe to include more nmethod on the list, but we do not</span>
<span class="line-modified">203     // expect any live non-scavengable nmethods on the list.</span>
<span class="line-modified">204     if (fix_relocations) {</span>
<span class="line-modified">205       if (!is_live || !has_scavengable_oops(cur)) {</span>
<span class="line-removed">206         unlist_nmethod(cur, prev);</span>
<span class="line-removed">207       } else {</span>
<span class="line-removed">208         prev = cur;</span>
<span class="line-removed">209       }</span>
210     }

211     cur = next;
212   }
213 
214   // Check for stray marks.
215   debug_only(verify_unlisted_nmethods(NULL));
216 }
217 









218 #ifndef PRODUCT
<span class="line-modified">219 void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* f) {</span>
220   // While we are here, verify the integrity of the list.
221   mark_on_list_nmethods();
222   for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
223     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
224     gc_data(cur).clear_marked();
225   }
<span class="line-modified">226   verify_unlisted_nmethods(f);</span>
227 }
228 #endif // PRODUCT
229 
230 void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
231   assert_locked_or_safepoint(CodeCache_lock);
232 
233   assert((prev == NULL &amp;&amp; _head == nm) ||
234          (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
235 
<span class="line-removed">236   CodeCache::print_trace(&quot;unlist_nmethod&quot;, nm);</span>
<span class="line-removed">237 </span>
238   ScavengableNMethodsData data = gc_data(nm);
239 
240   if (prev == NULL) {
241     _head = data.next();
242   } else {
243     gc_data(prev).set_next(data.next());
244   }
245   data.set_next(NULL);
246   data.clear_on_list();
247 }
248 
<span class="line-removed">249 void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-removed">250   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   debug_only(mark_on_list_nmethods());</span>
<span class="line-removed">253 </span>
<span class="line-removed">254   nmethod* last = NULL;</span>
<span class="line-removed">255   nmethod* cur = _head;</span>
<span class="line-removed">256   while (cur != NULL) {</span>
<span class="line-removed">257     nmethod* next = gc_data(cur).next();</span>
<span class="line-removed">258     debug_only(gc_data(cur).clear_marked());</span>
<span class="line-removed">259     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);</span>
<span class="line-removed">260 </span>
<span class="line-removed">261     if (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded() &amp;&amp; has_scavengable_oops(cur)) {</span>
<span class="line-removed">262       // Keep it.  Advance &#39;last&#39; to prevent deletion.</span>
<span class="line-removed">263       last = cur;</span>
<span class="line-removed">264     } else {</span>
<span class="line-removed">265       // Prune it from the list, so we don&#39;t have to look at it any more.</span>
<span class="line-removed">266       CodeCache::print_trace(&quot;prune_nmethods&quot;, cur);</span>
<span class="line-removed">267       unlist_nmethod(cur, last);</span>
<span class="line-removed">268     }</span>
<span class="line-removed">269     cur = next;</span>
<span class="line-removed">270   }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272   // Check for stray marks.</span>
<span class="line-removed">273   debug_only(verify_unlisted_nmethods(NULL));</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 #ifndef PRODUCT
277 // Temporarily mark nmethods that are claimed to be on the scavenge list.
278 void ScavengableNMethods::mark_on_list_nmethods() {
279   NMethodIterator iter(NMethodIterator::only_alive);
280   while(iter.next()) {
281     nmethod* nm = iter.method();
282     ScavengableNMethodsData data = gc_data(nm);
283     assert(data.not_marked(), &quot;clean state&quot;);
284     if (data.on_list())
285       data.set_marked();
286   }
287 }
288 
289 // If the closure is given, run it on the unlisted nmethods.
290 // Also make sure that the effects of mark_on_list_nmethods is gone.
<span class="line-modified">291 void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* f_or_null) {</span>
292   NMethodIterator iter(NMethodIterator::only_alive);
293   while(iter.next()) {
294     nmethod* nm = iter.method();
295 
296     verify_nmethod(nm);
297 
<span class="line-modified">298     if (f_or_null != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">299       f_or_null-&gt;do_code_blob(nm);</span>
300     }
301   }
302 }
303 
304 #endif //PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;


 28 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 29 #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<span class="line-modified"> 30 #include &quot;runtime/mutexLocker.hpp&quot;</span>


 31 #include &quot;utilities/debug.hpp&quot;
 32 
 33 static ScavengableNMethodsData gc_data(nmethod* nm) {
 34   return ScavengableNMethodsData(nm);
 35 }
 36 
 37 nmethod* ScavengableNMethods::_head = NULL;
 38 BoolObjectClosure* ScavengableNMethods::_is_scavengable = NULL;
 39 
 40 void ScavengableNMethods::initialize(BoolObjectClosure* is_scavengable) {
 41   _is_scavengable = is_scavengable;
 42 }
 43 
 44 // Conditionally adds the nmethod to the list if it is
 45 // not already on the list and has a scavengeable root.
 46 void ScavengableNMethods::register_nmethod(nmethod* nm) {
 47   assert_locked_or_safepoint(CodeCache_lock);
 48 
 49   ScavengableNMethodsData data = gc_data(nm);
 50 
 51   if (data.on_list() || !has_scavengable_oops(nm)) {
 52     return;
 53   }
 54 
 55   data.set_on_list();
 56   data.set_next(_head);
 57 
 58   _head = nm;


 59 }
 60 
 61 void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<span class="line-modified"> 62   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64   if (gc_data(nm).on_list()) {</span>
<span class="line-added"> 65     nmethod* prev = NULL;</span>
<span class="line-added"> 66     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-added"> 67       if (cur == nm) {</span>
<span class="line-added"> 68         unlist_nmethod(cur, prev);</span>
<span class="line-added"> 69         return;</span>
<span class="line-added"> 70       }</span>
<span class="line-added"> 71       prev = cur;</span>
<span class="line-added"> 72     }</span>
<span class="line-added"> 73   }</span>
 74 }
 75 
 76 #ifndef PRODUCT
 77 
 78 class DebugScavengableOops: public OopClosure {
 79   BoolObjectClosure* _is_scavengable;
 80   nmethod*           _nm;
 81   bool               _ok;
 82 public:
 83   DebugScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
 84       _is_scavengable(is_scavengable),
 85       _nm(nm),
 86       _ok(true) { }
 87 
 88   bool ok() { return _ok; }
 89   virtual void do_oop(oop* p) {
 90     if (*p == NULL || !_is_scavengable-&gt;do_object_b(*p)) {
 91       return;
 92     }
 93 
</pre>
<hr />
<pre>
100     (*p)-&gt;print();
101   }
102   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
103 };
104 
105 #endif // PRODUCT
106 
107 void ScavengableNMethods::verify_nmethod(nmethod* nm) {
108 #ifndef PRODUCT
109   if (!gc_data(nm).on_list()) {
110     // Actually look inside, to verify the claim that it&#39;s clean.
111     DebugScavengableOops cl(_is_scavengable, nm);
112     nm-&gt;oops_do(&amp;cl);
113     if (!cl.ok())
114       fatal(&quot;found an unadvertised bad scavengable oop in the code cache&quot;);
115   }
116   assert(gc_data(nm).not_marked(), &quot;&quot;);
117 #endif // PRODUCT
118 }
119 

















120 class HasScavengableOops: public OopClosure {
121   BoolObjectClosure* _is_scavengable;
122   bool               _found;

123 public:
124   HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
125       _is_scavengable(is_scavengable),
<span class="line-modified">126       _found(false) {}</span>

127 
128   bool found() { return _found; }
129   virtual void do_oop(oop* p) {
<span class="line-modified">130     if (!_found &amp;&amp; *p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>

131       _found = true;
132     }
133   }
134   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
















135 };
136 
137 bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
138   HasScavengableOops cl(_is_scavengable, nm);
139   nm-&gt;oops_do(&amp;cl);
140   return cl.found();
141 }
142 
143 // Walk the list of methods which might contain oops to the java heap.
<span class="line-modified">144 void ScavengableNMethods::nmethods_do_and_prune(CodeBlobToOopClosure* cl) {</span>
145   assert_locked_or_safepoint(CodeCache_lock);
146 

147   debug_only(mark_on_list_nmethods());
148 
149   nmethod* prev = NULL;
150   nmethod* cur = _head;
151   while (cur != NULL) {
<span class="line-added">152     assert(cur-&gt;is_alive(), &quot;Must be&quot;);</span>
<span class="line-added">153 </span>
154     ScavengableNMethodsData data = gc_data(cur);
155     debug_only(data.clear_marked());

156     assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
157 
<span class="line-modified">158     if (cl != NULL) {</span>
<span class="line-modified">159       cl-&gt;do_code_blob(cur);</span>








160     }
<span class="line-added">161 </span>
162     nmethod* const next = data.next();
<span class="line-modified">163 </span>
<span class="line-modified">164     if (!has_scavengable_oops(cur)) {</span>
<span class="line-modified">165       unlist_nmethod(cur, prev);</span>
<span class="line-modified">166     } else {</span>
<span class="line-modified">167       prev = cur;</span>




168     }
<span class="line-added">169 </span>
170     cur = next;
171   }
172 
173   // Check for stray marks.
174   debug_only(verify_unlisted_nmethods(NULL));
175 }
176 
<span class="line-added">177 void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-added">178   nmethods_do_and_prune(NULL /* No closure */);</span>
<span class="line-added">179 }</span>
<span class="line-added">180 </span>
<span class="line-added">181 // Walk the list of methods which might contain oops to the java heap.</span>
<span class="line-added">182 void ScavengableNMethods::nmethods_do(CodeBlobToOopClosure* cl) {</span>
<span class="line-added">183   nmethods_do_and_prune(cl);</span>
<span class="line-added">184 }</span>
<span class="line-added">185 </span>
186 #ifndef PRODUCT
<span class="line-modified">187 void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) {</span>
188   // While we are here, verify the integrity of the list.
189   mark_on_list_nmethods();
190   for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
191     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
192     gc_data(cur).clear_marked();
193   }
<span class="line-modified">194   verify_unlisted_nmethods(cl);</span>
195 }
196 #endif // PRODUCT
197 
198 void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
199   assert_locked_or_safepoint(CodeCache_lock);
200 
201   assert((prev == NULL &amp;&amp; _head == nm) ||
202          (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
203 


204   ScavengableNMethodsData data = gc_data(nm);
205 
206   if (prev == NULL) {
207     _head = data.next();
208   } else {
209     gc_data(prev).set_next(data.next());
210   }
211   data.set_next(NULL);
212   data.clear_on_list();
213 }
214 



























215 #ifndef PRODUCT
216 // Temporarily mark nmethods that are claimed to be on the scavenge list.
217 void ScavengableNMethods::mark_on_list_nmethods() {
218   NMethodIterator iter(NMethodIterator::only_alive);
219   while(iter.next()) {
220     nmethod* nm = iter.method();
221     ScavengableNMethodsData data = gc_data(nm);
222     assert(data.not_marked(), &quot;clean state&quot;);
223     if (data.on_list())
224       data.set_marked();
225   }
226 }
227 
228 // If the closure is given, run it on the unlisted nmethods.
229 // Also make sure that the effects of mark_on_list_nmethods is gone.
<span class="line-modified">230 void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* cl) {</span>
231   NMethodIterator iter(NMethodIterator::only_alive);
232   while(iter.next()) {
233     nmethod* nm = iter.method();
234 
235     verify_nmethod(nm);
236 
<span class="line-modified">237     if (cl != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">238       cl-&gt;do_code_blob(nm);</span>
239     }
240   }
241 }
242 
243 #endif //PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="satbMarkQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
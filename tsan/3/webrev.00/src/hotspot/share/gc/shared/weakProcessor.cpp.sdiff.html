<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/weakProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="vmStructs_gc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="weakProcessor.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/weakProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
 28 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;

 29 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 30 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 31 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/iterator.hpp&quot;

 34 #include &quot;runtime/globals.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 
<span class="line-modified"> 37 void WeakProcessor::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive) {</span>
<span class="line-modified"> 38   FOR_EACH_WEAK_PROCESSOR_PHASE(phase) {</span>
<span class="line-modified"> 39     if (WeakProcessorPhases::is_serial(phase)) {</span>
<span class="line-modified"> 40       WeakProcessorPhases::processor(phase)(is_alive, keep_alive);</span>
<span class="line-modified"> 41     } else {</span>
<span class="line-modified"> 42       if (WeakProcessorPhases::is_stringtable(phase)) {</span>
<span class="line-modified"> 43         StringTable::reset_dead_counter();</span>






 44 
<span class="line-modified"> 45         CountingSkippedIsAliveClosure&lt;BoolObjectClosure, OopClosure&gt; cl(is_alive, keep_alive);</span>
<span class="line-modified"> 46         WeakProcessorPhases::oop_storage(phase)-&gt;oops_do(&amp;cl);</span>



 47 
<span class="line-modified"> 48         StringTable::inc_dead_counter(cl.num_dead() + cl.num_skipped());</span>
<span class="line-modified"> 49         StringTable::finish_dead_counter();</span>
<span class="line-modified"> 50       } else {</span>
<span class="line-modified"> 51         WeakProcessorPhases::oop_storage(phase)-&gt;weak_oops_do(is_alive, keep_alive);</span>
<span class="line-modified"> 52       }</span>



 53     }
 54   }
 55 }
 56 
 57 void WeakProcessor::oops_do(OopClosure* closure) {
 58   AlwaysTrueClosure always_true;
 59   weak_oops_do(&amp;always_true, closure);
 60 }
 61 
 62 uint WeakProcessor::ergo_workers(uint max_workers) {
 63   // Ignore ParallelRefProcEnabled; that&#39;s for j.l.r.Reference processing.
 64   if (ReferencesPerThread == 0) {
 65     // Configuration says always use all the threads.
 66     return max_workers;
 67   }
 68 
 69   // One thread per ReferencesPerThread references (or fraction thereof)
 70   // in the various OopStorage objects, bounded by max_threads.
 71   //
 72   // Serial phases are ignored in this calculation, because of the
 73   // cost of running unnecessary threads.  These phases are normally
 74   // small or empty (assuming they are configured to exist at all),
 75   // and development oriented, so not allocating any threads
 76   // specifically for them is okay.
 77   size_t ref_count = 0;
<span class="line-modified"> 78   FOR_EACH_WEAK_PROCESSOR_OOP_STORAGE_PHASE(phase) {</span>
<span class="line-modified"> 79     ref_count += WeakProcessorPhases::oop_storage(phase)-&gt;allocation_count();</span>

 80   }
 81 
 82   // +1 to (approx) round up the ref per thread division.
 83   size_t nworkers = 1 + (ref_count / ReferencesPerThread);
 84   nworkers = MIN2(nworkers, static_cast&lt;size_t&gt;(max_workers));
 85   return static_cast&lt;uint&gt;(nworkers);
 86 }
 87 
 88 void WeakProcessor::Task::initialize() {
 89   assert(_nworkers != 0, &quot;must be&quot;);
 90   assert(_phase_times == NULL || _nworkers &lt;= _phase_times-&gt;max_threads(),
 91          &quot;nworkers (%u) exceeds max threads (%u)&quot;,
 92          _nworkers, _phase_times-&gt;max_threads());
 93 
 94   if (_phase_times) {
 95     _phase_times-&gt;set_active_workers(_nworkers);
 96   }
 97 
<span class="line-modified"> 98   uint storage_count = WeakProcessorPhases::oop_storage_phase_count;</span>
 99   _storage_states = NEW_C_HEAP_ARRAY(StorageState, storage_count, mtGC);
100 
<span class="line-modified">101   StorageState* states = _storage_states;</span>
<span class="line-modified">102   FOR_EACH_WEAK_PROCESSOR_OOP_STORAGE_PHASE(phase) {</span>
<span class="line-modified">103     OopStorage* storage = WeakProcessorPhases::oop_storage(phase);</span>
<span class="line-modified">104     new (states++) StorageState(storage, _nworkers);</span>

105   }

106   StringTable::reset_dead_counter();

107 }
108 
109 WeakProcessor::Task::Task(uint nworkers) :
110   _phase_times(NULL),
111   _nworkers(nworkers),
112   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
113   _storage_states(NULL)
114 {
115   initialize();
116 }
117 
118 WeakProcessor::Task::Task(WeakProcessorPhaseTimes* phase_times, uint nworkers) :
119   _phase_times(phase_times),
120   _nworkers(nworkers),
121   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
122   _storage_states(NULL)
123 {
124   initialize();
125 }
126 
127 WeakProcessor::Task::~Task() {
128   if (_storage_states != NULL) {
129     StorageState* states = _storage_states;
<span class="line-modified">130     FOR_EACH_WEAK_PROCESSOR_OOP_STORAGE_PHASE(phase) {</span>
131       states-&gt;StorageState::~StorageState();
132       ++states;
133     }
134     FREE_C_HEAP_ARRAY(StorageState, _storage_states);
135   }
136   StringTable::finish_dead_counter();

137 }
138 
139 void WeakProcessor::GangTask::work(uint worker_id) {
140   _erased_do_work(this, worker_id);
141 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
 28 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
<span class="line-added"> 29 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 30 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 31 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 32 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/iterator.hpp&quot;
<span class="line-added"> 35 #include &quot;prims/resolvedMethodTable.hpp&quot;</span>
 36 #include &quot;runtime/globals.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
<span class="line-modified"> 39 template &lt;typename Container&gt;</span>
<span class="line-modified"> 40 class OopsDoAndReportCounts {</span>
<span class="line-modified"> 41 public:</span>
<span class="line-modified"> 42   void operator()(BoolObjectClosure* is_alive, OopClosure* keep_alive, OopStorage* storage) {</span>
<span class="line-modified"> 43     Container::reset_dead_counter();</span>
<span class="line-modified"> 44 </span>
<span class="line-modified"> 45     CountingSkippedIsAliveClosure&lt;BoolObjectClosure, OopClosure&gt; cl(is_alive, keep_alive);</span>
<span class="line-added"> 46     storage-&gt;oops_do(&amp;cl);</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48     Container::inc_dead_counter(cl.num_dead() + cl.num_skipped());</span>
<span class="line-added"> 49     Container::finish_dead_counter();</span>
<span class="line-added"> 50   }</span>
<span class="line-added"> 51 };</span>
 52 
<span class="line-modified"> 53 void WeakProcessor::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive) {</span>
<span class="line-modified"> 54   WeakProcessorPhases::Iterator pit = WeakProcessorPhases::serial_iterator();</span>
<span class="line-added"> 55   for ( ; !pit.is_end(); ++pit) {</span>
<span class="line-added"> 56     WeakProcessorPhases::processor(*pit)(is_alive, keep_alive);</span>
<span class="line-added"> 57   }</span>
 58 
<span class="line-modified"> 59   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified"> 60   for ( ; !it.is_end(); ++it) {</span>
<span class="line-modified"> 61     if (OopStorageSet::string_table_weak() == *it) {</span>
<span class="line-modified"> 62       OopsDoAndReportCounts&lt;StringTable&gt;()(is_alive, keep_alive, *it);</span>
<span class="line-modified"> 63     } else if (OopStorageSet::resolved_method_table_weak() == *it) {</span>
<span class="line-added"> 64       OopsDoAndReportCounts&lt;ResolvedMethodTable&gt;()(is_alive, keep_alive, *it);</span>
<span class="line-added"> 65     } else {</span>
<span class="line-added"> 66       it-&gt;weak_oops_do(is_alive, keep_alive);</span>
 67     }
 68   }
 69 }
 70 
 71 void WeakProcessor::oops_do(OopClosure* closure) {
 72   AlwaysTrueClosure always_true;
 73   weak_oops_do(&amp;always_true, closure);
 74 }
 75 
 76 uint WeakProcessor::ergo_workers(uint max_workers) {
 77   // Ignore ParallelRefProcEnabled; that&#39;s for j.l.r.Reference processing.
 78   if (ReferencesPerThread == 0) {
 79     // Configuration says always use all the threads.
 80     return max_workers;
 81   }
 82 
 83   // One thread per ReferencesPerThread references (or fraction thereof)
 84   // in the various OopStorage objects, bounded by max_threads.
 85   //
 86   // Serial phases are ignored in this calculation, because of the
 87   // cost of running unnecessary threads.  These phases are normally
 88   // small or empty (assuming they are configured to exist at all),
 89   // and development oriented, so not allocating any threads
 90   // specifically for them is okay.
 91   size_t ref_count = 0;
<span class="line-modified"> 92   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified"> 93   for ( ; !it.is_end(); ++it) {</span>
<span class="line-added"> 94     ref_count += it-&gt;allocation_count();</span>
 95   }
 96 
 97   // +1 to (approx) round up the ref per thread division.
 98   size_t nworkers = 1 + (ref_count / ReferencesPerThread);
 99   nworkers = MIN2(nworkers, static_cast&lt;size_t&gt;(max_workers));
100   return static_cast&lt;uint&gt;(nworkers);
101 }
102 
103 void WeakProcessor::Task::initialize() {
104   assert(_nworkers != 0, &quot;must be&quot;);
105   assert(_phase_times == NULL || _nworkers &lt;= _phase_times-&gt;max_threads(),
106          &quot;nworkers (%u) exceeds max threads (%u)&quot;,
107          _nworkers, _phase_times-&gt;max_threads());
108 
109   if (_phase_times) {
110     _phase_times-&gt;set_active_workers(_nworkers);
111   }
112 
<span class="line-modified">113   uint storage_count = WeakProcessorPhases::oopstorage_phase_count;</span>
114   _storage_states = NEW_C_HEAP_ARRAY(StorageState, storage_count, mtGC);
115 
<span class="line-modified">116   StorageState* cur_state = _storage_states;</span>
<span class="line-modified">117   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified">118   for ( ; !it.is_end(); ++it, ++cur_state) {</span>
<span class="line-modified">119     assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) &lt; storage_count, &quot;invariant&quot;);</span>
<span class="line-added">120     new (cur_state) StorageState(*it, _nworkers);</span>
121   }
<span class="line-added">122   assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) == storage_count, &quot;invariant&quot;);</span>
123   StringTable::reset_dead_counter();
<span class="line-added">124   ResolvedMethodTable::reset_dead_counter();</span>
125 }
126 
127 WeakProcessor::Task::Task(uint nworkers) :
128   _phase_times(NULL),
129   _nworkers(nworkers),
130   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
131   _storage_states(NULL)
132 {
133   initialize();
134 }
135 
136 WeakProcessor::Task::Task(WeakProcessorPhaseTimes* phase_times, uint nworkers) :
137   _phase_times(phase_times),
138   _nworkers(nworkers),
139   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
140   _storage_states(NULL)
141 {
142   initialize();
143 }
144 
145 WeakProcessor::Task::~Task() {
146   if (_storage_states != NULL) {
147     StorageState* states = _storage_states;
<span class="line-modified">148     for (uint i = 0; i &lt; WeakProcessorPhases::oopstorage_phase_count; ++i) {</span>
149       states-&gt;StorageState::~StorageState();
150       ++states;
151     }
152     FREE_C_HEAP_ARRAY(StorageState, _storage_states);
153   }
154   StringTable::finish_dead_counter();
<span class="line-added">155   ResolvedMethodTable::finish_dead_counter();</span>
156 }
157 
158 void WeakProcessor::GangTask::work(uint worker_id) {
159   _erased_do_work(this, worker_id);
160 }
</pre>
</td>
</tr>
</table>
<center><a href="vmStructs_gc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="weakProcessor.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
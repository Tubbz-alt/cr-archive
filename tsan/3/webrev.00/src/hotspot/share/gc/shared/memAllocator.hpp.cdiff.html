<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/memAllocator.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="memAllocator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="modRefBarrierSet.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/memAllocator.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,11 ***</span>
  
  class MemAllocator: StackObj {
  protected:
    class Allocation;
  
<span class="line-removed">-   CollectedHeap* const _heap;</span>
    Thread* const        _thread;
    Klass* const         _klass;
    const size_t         _word_size;
  
  private:
<span class="line-new-header">--- 35,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,31 ***</span>
    HeapWord* allocate_inside_tlab_slow(Allocation&amp; allocation) const;
    HeapWord* allocate_outside_tlab(Allocation&amp; allocation) const;
  
  protected:
    MemAllocator(Klass* klass, size_t word_size, Thread* thread)
<span class="line-modified">!     : _heap(Universe::heap()),</span>
<span class="line-removed">-       _thread(thread),</span>
        _klass(klass),
        _word_size(word_size)
    { }
  
    // This function clears the memory of the object
    void mem_clear(HeapWord* mem) const;
    // This finish constructing an oop by installing the mark word and the Klass* pointer
    // last. At the point when the Klass pointer is initialized, this is a constructed object
    // that must be parseable as an oop by concurrent collectors.
<span class="line-modified">!   oop finish(HeapWord* mem) const;</span>
  
<span class="line-modified">!   // Raw memory allocation. This may or may not use TLAB allocations to satisfy the</span>
<span class="line-modified">!   // allocation. A GC implementation may override this function to satisfy the allocation</span>
<span class="line-modified">!   // in any way. But the default is to try a TLAB allocation, and otherwise perform</span>
<span class="line-removed">-   // mem_allocate.</span>
<span class="line-removed">-   virtual HeapWord* mem_allocate(Allocation&amp; allocation) const;</span>
  
    virtual MemRegion obj_memory_range(oop obj) const {
<span class="line-modified">!     return MemRegion((HeapWord*)obj, _word_size);</span>
    }
  
  public:
    oop allocate() const;
    virtual oop initialize(HeapWord* mem) const = 0;
<span class="line-new-header">--- 47,28 ---</span>
    HeapWord* allocate_inside_tlab_slow(Allocation&amp; allocation) const;
    HeapWord* allocate_outside_tlab(Allocation&amp; allocation) const;
  
  protected:
    MemAllocator(Klass* klass, size_t word_size, Thread* thread)
<span class="line-modified">!     : _thread(thread),</span>
        _klass(klass),
        _word_size(word_size)
    { }
  
    // This function clears the memory of the object
    void mem_clear(HeapWord* mem) const;
    // This finish constructing an oop by installing the mark word and the Klass* pointer
    // last. At the point when the Klass pointer is initialized, this is a constructed object
    // that must be parseable as an oop by concurrent collectors.
<span class="line-modified">!   virtual oop finish(HeapWord* mem) const;</span>
  
<span class="line-modified">!   // Raw memory allocation. This will try to do a TLAB allocation, and otherwise fall</span>
<span class="line-modified">!   // back to calling CollectedHeap::mem_allocate().</span>
<span class="line-modified">!   HeapWord* mem_allocate(Allocation&amp; allocation) const;</span>
  
    virtual MemRegion obj_memory_range(oop obj) const {
<span class="line-modified">!     return MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj), _word_size);</span>
    }
  
  public:
    oop allocate() const;
    virtual oop initialize(HeapWord* mem) const = 0;
</pre>
<center><a href="memAllocator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="modRefBarrierSet.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
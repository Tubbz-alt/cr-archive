<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/gcVMOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcTraceSend.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcVMOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -31,10 +31,11 @@</span>
  #include &quot;gc/shared/gcVMOperations.hpp&quot;
  #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  #include &quot;interpreter/oopMapCache.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/init.hpp&quot;
  #include &quot;utilities/dtrace.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/preserveException.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,23 +149,22 @@</span>
        // if it happens now and not if it happens in the eventual
        // future.
        log_warning(gc)(&quot;GC locker is held; pre-dump GC was skipped&quot;);
      }
    }
<span class="udiff-line-modified-removed">-   HeapInspection inspect(_csv_format, _print_help, _print_class_stats,</span>
<span class="udiff-line-removed">-                          _columns);</span>
<span class="udiff-line-modified-added">+   HeapInspection inspect;</span>
    inspect.heap_inspection(_out);
  }
  
  
  void VM_GenCollectForAllocation::doit() {
    SvcGCMarker sgcm(SvcGCMarker::MINOR);
  
    GenCollectedHeap* gch = GenCollectedHeap::heap();
    GCCauseSetter gccs(gch, _gc_cause);
    _result = gch-&gt;satisfy_failed_allocation(_word_size, _tlab);
<span class="udiff-line-modified-removed">-   assert(gch-&gt;is_in_reserved_or_null(_result), &quot;result not in heap&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_result == NULL || gch-&gt;is_in_reserved(_result), &quot;result not in heap&quot;);</span>
  
    if (_result == NULL &amp;&amp; GCLocker::is_active_and_needs_gc()) {
      set_gc_locked();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,17 +189,10 @@</span>
    AllocTracer::send_allocation_requiring_gc_event(_size * HeapWordSize, GCId::peek());
  }
  
  // Returns true iff concurrent GCs unloads metadata.
  bool VM_CollectForMetadataAllocation::initiate_concurrent_GC() {
<span class="udiff-line-removed">- #if INCLUDE_CMSGC</span>
<span class="udiff-line-removed">-   if (UseConcMarkSweepGC &amp;&amp; CMSClassUnloadingEnabled) {</span>
<span class="udiff-line-removed">-     MetaspaceGC::set_should_concurrent_collect(true);</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  #if INCLUDE_G1GC
    if (UseG1GC &amp;&amp; ClassUnloadingWithConcurrentMark) {
      G1CollectedHeap* g1h = G1CollectedHeap::heap();
      g1h-&gt;policy()-&gt;collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -235,17 +228,17 @@</span>
        return;
      }
    }
  
    if (initiate_concurrent_GC()) {
<span class="udiff-line-modified-removed">-     // For CMS and G1 expand since the collection is going to be concurrent.</span>
<span class="udiff-line-modified-added">+     // For G1 expand since the collection is going to be concurrent.</span>
      _result = _loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(_size, _mdtype);
      if (_result != NULL) {
        return;
      }
  
<span class="udiff-line-modified-removed">-     log_debug(gc)(&quot;%s full GC for Metaspace&quot;, UseConcMarkSweepGC ? &quot;CMS&quot; : &quot;G1&quot;);</span>
<span class="udiff-line-modified-added">+     log_debug(gc)(&quot;G1 full GC for Metaspace&quot;);</span>
    }
  
    // Don&#39;t clear the soft refs yet.
    heap-&gt;collect_as_vm_thread(GCCause::_metadata_GC_threshold);
    // After a GC try to allocate without expanding.  Could fail
</pre>
<center><a href="gcTraceSend.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
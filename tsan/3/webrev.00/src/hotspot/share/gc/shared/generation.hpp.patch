diff a/src/hotspot/share/gc/shared/generation.hpp b/src/hotspot/share/gc/shared/generation.hpp
--- a/src/hotspot/share/gc/shared/generation.hpp
+++ b/src/hotspot/share/gc/shared/generation.hpp
@@ -28,11 +28,10 @@
 #include "gc/shared/collectorCounters.hpp"
 #include "gc/shared/referenceProcessor.hpp"
 #include "logging/log.hpp"
 #include "memory/allocation.hpp"
 #include "memory/memRegion.hpp"
-#include "memory/universe.hpp"
 #include "memory/virtualspace.hpp"
 #include "runtime/mutex.hpp"
 #include "runtime/perfData.hpp"
 
 // A Generation models a heap area for similarly-aged objects.
@@ -40,24 +39,17 @@
 //
 // The Generation class hierarchy:
 //
 // Generation                      - abstract base class
 // - DefNewGeneration              - allocation area (copy collected)
-//   - ParNewGeneration            - a DefNewGeneration that is collected by
-//                                   several threads
 // - CardGeneration                 - abstract class adding offset array behavior
 //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)
-//   - ConcurrentMarkSweepGeneration - Mostly Concurrent Mark Sweep Generation
-//                                       (Detlefs-Printezis refinement of
-//                                       Boehm-Demers-Schenker)
 //
-// The system configurations currently allowed are:
+// The system configuration currently allowed is:
 //
 //   DefNewGeneration + TenuredGeneration
 //
-//   ParNewGeneration + ConcurrentMarkSweepGeneration
-//
 
 class DefNewGeneration;
 class GCMemoryManager;
 class GenerationSpec;
 class CompactibleSpace;
@@ -121,13 +113,11 @@
 
  public:
   // The set of possible generation kinds.
   enum Name {
     DefNew,
-    ParNew,
     MarkSweepCompact,
-    ConcurrentMarkSweep,
     Other
   };
 
   enum SomePublicConstants {
     // Generations are GenGrain-aligned and have size that are multiples of
@@ -299,11 +289,11 @@
   // "word_sz".  If possible, allocate space for "obj", copy obj into it
   // (taking care to copy "m" into the mark word when done, since the mark
   // word of "obj" may have been overwritten with a forwarding pointer, and
   // also taking care to copy the klass pointer *last*.  Returns the new
   // object if successful, or else NULL.
-  virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);
+  virtual oop par_promote(int thread_num, oop obj, markWord m, size_t word_sz);
 
   // Informs the current generation that all par_promote_alloc's in the
   // collection have been completed; any supporting data structures can be
   // reset.  Default is to do nothing.
   virtual void par_promote_alloc_done(int thread_num) {}
@@ -478,15 +468,10 @@
 
   // Iterate over all objects in the generation, calling "cl.do_object" on
   // each.
   virtual void object_iterate(ObjectClosure* cl);
 
-  // Iterate over all safe objects in the generation, calling "cl.do_object" on
-  // each.  An object is safe if its references point to other objects in
-  // the heap.  This defaults to object_iterate() unless overridden.
-  virtual void safe_object_iterate(ObjectClosure* cl);
-
   // Apply "cl->do_oop" to (the address of) all and only all the ref fields
   // in the current generation that contain pointers to objects in younger
   // generations. Objects allocated since the last "save_marks" call are
   // excluded.
   virtual void younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) = 0;

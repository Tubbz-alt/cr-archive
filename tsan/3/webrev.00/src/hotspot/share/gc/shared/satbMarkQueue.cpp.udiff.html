<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/satbMarkQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="referenceProcessorPhaseTimes.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/satbMarkQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,25 +26,27 @@</span>
  #include &quot;gc/shared/satbMarkQueue.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/mutexLocker.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/globalCounter.inline.hpp&quot;</span>
  
<span class="udiff-line-modified-removed">- SATBMarkQueue::SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent) :</span>
<span class="udiff-line-modified-added">+ SATBMarkQueue::SATBMarkQueue(SATBMarkQueueSet* qset) :</span>
    // SATB queues are only active during marking cycles. We create
    // them with their active field set to false. If a thread is
    // created during a cycle and its SATB queue needs to be activated
    // before the thread starts running, we&#39;ll need to set its active
    // field to true. This must be done in the collector-specific
    // BarrierSet thread attachment protocol.
<span class="udiff-line-modified-removed">-   PtrQueue(qset, permanent, false /* active */)</span>
<span class="udiff-line-modified-added">+   PtrQueue(qset, false /* active */)</span>
  { }
  
  void SATBMarkQueue::flush() {
    // Filter now to possibly save work later.  If filtering empties the
    // buffer then flush_impl can deallocate the buffer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54,27 +56,30 @@</span>
  
  // This method will first apply filtering to the buffer. If filtering
  // retains a small enough collection in the buffer, we can continue to
  // use the buffer as-is, instead of enqueueing and replacing it.
  
<span class="udiff-line-modified-removed">- bool SATBMarkQueue::should_enqueue_buffer() {</span>
<span class="udiff-line-modified-added">+ void SATBMarkQueue::handle_completed_buffer() {</span>
    // This method should only be called if there is a non-NULL buffer
    // that is full.
    assert(index() == 0, &quot;pre-condition&quot;);
    assert(_buf != NULL, &quot;pre-condition&quot;);
  
    filter();
  
<span class="udiff-line-modified-removed">-   SATBMarkQueueSet* satb_qset = static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="udiff-line-removed">-   size_t threshold = satb_qset-&gt;buffer_enqueue_threshold();</span>
<span class="udiff-line-modified-added">+   size_t threshold = satb_qset()-&gt;buffer_enqueue_threshold();</span>
    // Ensure we&#39;ll enqueue completely full buffers.
    assert(threshold &gt; 0, &quot;enqueue threshold = 0&quot;);
    // Ensure we won&#39;t enqueue empty buffers.
    assert(threshold &lt;= capacity(),
           &quot;enqueue threshold &quot; SIZE_FORMAT &quot; exceeds capacity &quot; SIZE_FORMAT,
           threshold, capacity());
<span class="udiff-line-modified-removed">-   return index() &lt; threshold;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (index() &lt; threshold) {</span>
<span class="udiff-line-added">+     // Buffer is sufficiently full; enqueue and allocate a new one.</span>
<span class="udiff-line-added">+     enqueue_completed_buffer();</span>
<span class="udiff-line-added">+   } // Else continue to accumulate in buffer.</span>
  }
  
  void SATBMarkQueue::apply_closure_and_empty(SATBBufferClosure* cl) {
    assert(SafepointSynchronize::is_at_safepoint(),
           &quot;SATB queues must only be processed at safepoints&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -100,25 +105,70 @@</span>
    print_satb_buffer(name, _buf, index(), capacity());
  }
  
  #endif // PRODUCT
  
<span class="udiff-line-modified-removed">- SATBMarkQueueSet::SATBMarkQueueSet() :</span>
<span class="udiff-line-modified-removed">-   PtrQueueSet(),</span>
<span class="udiff-line-modified-added">+ SATBMarkQueueSet::SATBMarkQueueSet(BufferNode::Allocator* allocator) :</span>
<span class="udiff-line-modified-added">+   PtrQueueSet(allocator),</span>
<span class="udiff-line-added">+   _list(),</span>
<span class="udiff-line-added">+   _count_and_process_flag(0),</span>
<span class="udiff-line-added">+   _process_completed_buffers_threshold(SIZE_MAX),</span>
    _buffer_enqueue_threshold(0)
  {}
  
<span class="udiff-line-modified-removed">- void SATBMarkQueueSet::initialize(Monitor* cbl_mon,</span>
<span class="udiff-line-modified-removed">-                                   BufferNode::Allocator* allocator,</span>
<span class="udiff-line-modified-removed">-                                   size_t process_completed_buffers_threshold,</span>
<span class="udiff-line-modified-removed">-                                   uint buffer_enqueue_threshold_percentage) {</span>
<span class="udiff-line-modified-removed">-   PtrQueueSet::initialize(cbl_mon, allocator);</span>
<span class="udiff-line-modified-removed">-   set_process_completed_buffers_threshold(process_completed_buffers_threshold);</span>
<span class="udiff-line-modified-removed">-   assert(buffer_size() != 0, &quot;buffer size not initialized&quot;);</span>
<span class="udiff-line-modified-added">+ SATBMarkQueueSet::~SATBMarkQueueSet() {</span>
<span class="udiff-line-modified-added">+   abandon_completed_buffers();</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ // _count_and_process_flag has flag in least significant bit, count in</span>
<span class="udiff-line-modified-added">+ // remaining bits.  _process_completed_buffers_threshold is scaled</span>
<span class="udiff-line-modified-added">+ // accordingly, with the lsbit set, so a _count_and_process_flag value</span>
<span class="udiff-line-added">+ // is directly comparable with the recorded threshold value.  The</span>
<span class="udiff-line-added">+ // process flag is set whenever the count exceeds the threshold, and</span>
<span class="udiff-line-added">+ // remains set until the count is reduced to zero.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Increment count.  If count &gt; threshold, set flag, else maintain flag.</span>
<span class="udiff-line-added">+ static void increment_count(volatile size_t* cfptr, size_t threshold) {</span>
<span class="udiff-line-added">+   size_t old;</span>
<span class="udiff-line-added">+   size_t value = Atomic::load(cfptr);</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     old = value;</span>
<span class="udiff-line-added">+     value += 2;</span>
<span class="udiff-line-added">+     assert(value &gt; old, &quot;overflow&quot;);</span>
<span class="udiff-line-added">+     if (value &gt; threshold) value |= 1;</span>
<span class="udiff-line-added">+     value = Atomic::cmpxchg(cfptr, old, value);</span>
<span class="udiff-line-added">+   } while (value != old);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Decrement count.  If count == 0, clear flag, else maintain flag.</span>
<span class="udiff-line-added">+ static void decrement_count(volatile size_t* cfptr) {</span>
<span class="udiff-line-added">+   size_t old;</span>
<span class="udiff-line-added">+   size_t value = Atomic::load(cfptr);</span>
<span class="udiff-line-added">+   do {</span>
<span class="udiff-line-added">+     assert((value &gt;&gt; 1) != 0, &quot;underflow&quot;);</span>
<span class="udiff-line-added">+     old = value;</span>
<span class="udiff-line-added">+     value -= 2;</span>
<span class="udiff-line-added">+     if (value &lt;= 1) value = 0;</span>
<span class="udiff-line-added">+     value = Atomic::cmpxchg(cfptr, old, value);</span>
<span class="udiff-line-added">+   } while (value != old);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SATBMarkQueueSet::set_process_completed_buffers_threshold(size_t value) {</span>
<span class="udiff-line-added">+   // Scale requested threshold to align with count field.  If scaling</span>
<span class="udiff-line-added">+   // overflows, just use max value.  Set process flag field to make</span>
<span class="udiff-line-added">+   // comparison in increment_count exact.</span>
<span class="udiff-line-added">+   size_t scaled_value = value &lt;&lt; 1;</span>
<span class="udiff-line-added">+   if ((scaled_value &gt;&gt; 1) != value) {</span>
<span class="udiff-line-added">+     scaled_value = SIZE_MAX;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _process_completed_buffers_threshold = scaled_value | 1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SATBMarkQueueSet::set_buffer_enqueue_threshold_percentage(uint value) {</span>
    // Minimum threshold of 1 ensures enqueuing of completely full buffers.
    size_t size = buffer_size();
<span class="udiff-line-modified-removed">-   size_t enqueue_qty = (size * buffer_enqueue_threshold_percentage) / 100;</span>
<span class="udiff-line-modified-added">+   size_t enqueue_qty = (size * value) / 100;</span>
    _buffer_enqueue_threshold = MAX2(size - enqueue_qty, (size_t)1);
  }
  
  #ifdef ASSERT
  void SATBMarkQueueSet::dump_active_states(bool expected_active) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,11 +218,15 @@</span>
  void SATBMarkQueueSet::set_active_all_threads(bool active, bool expected_active) {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
  #ifdef ASSERT
    verify_active_states(expected_active);
  #endif // ASSERT
<span class="udiff-line-modified-removed">-   _all_active = active;</span>
<span class="udiff-line-modified-added">+   // Update the global state, synchronized with threads list management.</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-added">+     _all_active = active;</span>
<span class="udiff-line-added">+   }</span>
  
    class SetThreadActiveClosure : public ThreadClosure {
      SATBMarkQueueSet* _qset;
      bool _active;
    public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -183,22 +237,10 @@</span>
      }
    } closure(this, active);
    Threads::threads_do(&amp;closure);
  }
  
<span class="udiff-line-removed">- void SATBMarkQueueSet::filter_thread_buffers() {</span>
<span class="udiff-line-removed">-   class FilterThreadBufferClosure : public ThreadClosure {</span>
<span class="udiff-line-removed">-     SATBMarkQueueSet* _qset;</span>
<span class="udiff-line-removed">-   public:</span>
<span class="udiff-line-removed">-     FilterThreadBufferClosure(SATBMarkQueueSet* qset) : _qset(qset) {}</span>
<span class="udiff-line-removed">-     virtual void do_thread(Thread* t) {</span>
<span class="udiff-line-removed">-       _qset-&gt;satb_queue_for_thread(t).filter();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } closure(this);</span>
<span class="udiff-line-removed">-   Threads::threads_do(&amp;closure);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool SATBMarkQueueSet::apply_closure_to_completed_buffer(SATBBufferClosure* cl) {
    BufferNode* nd = get_completed_buffer();
    if (nd != NULL) {
      void **buf = BufferNode::make_buffer_from_node(nd);
      size_t index = nd-&gt;index();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -210,10 +252,42 @@</span>
    } else {
      return false;
    }
  }
  
<span class="udiff-line-added">+ // SATB buffer life-cycle - Per-thread queues obtain buffers from the</span>
<span class="udiff-line-added">+ // qset&#39;s buffer allocator, fill them, and push them onto the qset&#39;s</span>
<span class="udiff-line-added">+ // list.  The GC concurrently pops buffers from the qset, processes</span>
<span class="udiff-line-added">+ // them, and returns them to the buffer allocator for re-use.  Both</span>
<span class="udiff-line-added">+ // the allocator and the qset use lock-free stacks.  The ABA problem</span>
<span class="udiff-line-added">+ // is solved by having both allocation pops and GC pops performed</span>
<span class="udiff-line-added">+ // within GlobalCounter critical sections, while the return of buffers</span>
<span class="udiff-line-added">+ // to the allocator performs a GlobalCounter synchronize before</span>
<span class="udiff-line-added">+ // pushing onto the allocator&#39;s list.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SATBMarkQueueSet::enqueue_completed_buffer(BufferNode* node) {</span>
<span class="udiff-line-added">+   assert(node != NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   // Increment count and update flag appropriately.  Done before</span>
<span class="udiff-line-added">+   // pushing buffer so count is always at least the actual number in</span>
<span class="udiff-line-added">+   // the list, and decrement never underflows.</span>
<span class="udiff-line-added">+   increment_count(&amp;_count_and_process_flag, _process_completed_buffers_threshold);</span>
<span class="udiff-line-added">+   _list.push(*node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ BufferNode* SATBMarkQueueSet::get_completed_buffer() {</span>
<span class="udiff-line-added">+   BufferNode* node;</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     GlobalCounter::CriticalSection cs(Thread::current());</span>
<span class="udiff-line-added">+     node = _list.pop();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (node != NULL) {</span>
<span class="udiff-line-added">+     // Got a buffer so decrement count and update flag appropriately.</span>
<span class="udiff-line-added">+     decrement_count(&amp;_count_and_process_flag);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return node;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #ifndef PRODUCT
  // Helpful for debugging
  
  #define SATB_PRINTER_BUFFER_SIZE 256
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,11 +296,11 @@</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
  
    tty-&gt;cr();
    tty-&gt;print_cr(&quot;SATB BUFFERS [%s]&quot;, msg);
  
<span class="udiff-line-modified-removed">-   BufferNode* nd = completed_buffers_head();</span>
<span class="udiff-line-modified-added">+   BufferNode* nd = _list.top();</span>
    int i = 0;
    while (nd != NULL) {
      void** buf = BufferNode::make_buffer_from_node(nd);
      os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Enqueued: %d&quot;, i);
      print_satb_buffer(buffer, buf, nd-&gt;index(), buffer_size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -251,10 +325,21 @@</span>
  
    tty-&gt;cr();
  }
  #endif // PRODUCT
  
<span class="udiff-line-added">+ void SATBMarkQueueSet::abandon_completed_buffers() {</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_count_and_process_flag, size_t(0));</span>
<span class="udiff-line-added">+   BufferNode* buffers_to_delete = _list.pop_all();</span>
<span class="udiff-line-added">+   while (buffers_to_delete != NULL) {</span>
<span class="udiff-line-added">+     BufferNode* bn = buffers_to_delete;</span>
<span class="udiff-line-added">+     buffers_to_delete = bn-&gt;next();</span>
<span class="udiff-line-added">+     bn-&gt;set_next(NULL);</span>
<span class="udiff-line-added">+     deallocate_buffer(bn);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void SATBMarkQueueSet::abandon_partial_marking() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
    abandon_completed_buffers();
  
    class AbandonThreadQueueClosure : public ThreadClosure {
</pre>
<center><a href="referenceProcessorPhaseTimes.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
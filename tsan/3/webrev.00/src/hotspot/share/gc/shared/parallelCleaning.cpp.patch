diff a/src/hotspot/share/gc/shared/parallelCleaning.cpp b/src/hotspot/share/gc/shared/parallelCleaning.cpp
--- a/src/hotspot/share/gc/shared/parallelCleaning.cpp
+++ b/src/hotspot/share/gc/shared/parallelCleaning.cpp
@@ -28,10 +28,11 @@
 #include "code/codeCache.hpp"
 #include "gc/shared/parallelCleaning.hpp"
 #include "logging/log.hpp"
 #include "memory/resourceArea.hpp"
 #include "logging/log.hpp"
+#include "runtime/atomic.hpp"
 
 StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,
                                                  OopClosure* keep_alive,
                                                  bool resize_table) :
   AbstractGangTask("String Dedup Cleaning"),
@@ -92,11 +93,11 @@
         claimed_nmethods[i] = last.method();
         (*num_claimed_nmethods)++;
       }
     }
 
-  } while (Atomic::cmpxchg(last.method(), &_claimed_nmethod, first) != first);
+  } while (Atomic::cmpxchg(&_claimed_nmethod, first, last.method()) != first);
 }
 
 void CodeCacheUnloadingTask::work(uint worker_id) {
   // The first nmethods is claimed by the first worker.
   if (worker_id == 0 && _first_nmethod != NULL) {
@@ -128,11 +129,11 @@
 bool KlassCleaningTask::claim_clean_klass_tree_task() {
   if (_clean_klass_tree_claimed) {
     return false;
   }
 
-  return Atomic::cmpxchg(1, &_clean_klass_tree_claimed, 0) == 0;
+  return Atomic::cmpxchg(&_clean_klass_tree_claimed, 0, 1) == 0;
 }
 
 InstanceKlass* KlassCleaningTask::claim_next_klass() {
   Klass* klass;
   do {
@@ -155,32 +156,5 @@
   InstanceKlass* klass;
   while ((klass = claim_next_klass()) != NULL) {
     clean_klass(klass);
   }
 }
-
-ParallelCleaningTask::ParallelCleaningTask(BoolObjectClosure* is_alive,
-                                           uint num_workers,
-                                           bool unloading_occurred,
-                                           bool resize_dedup_table) :
-  AbstractGangTask("Parallel Cleaning"),
-  _unloading_occurred(unloading_occurred),
-  _string_dedup_task(is_alive, NULL, resize_dedup_table),
-  _code_cache_task(num_workers, is_alive, unloading_occurred),
-  _klass_cleaning_task() {
-}
-
-// The parallel work done by all worker threads.
-void ParallelCleaningTask::work(uint worker_id) {
-  // Do first pass of code cache cleaning.
-  _code_cache_task.work(worker_id);
-
-  // Clean the string dedup data structures.
-  _string_dedup_task.work(worker_id);
-
-  // Clean all klasses that were not unloaded.
-  // The weak metadata in klass doesn't need to be
-  // processed if there was no unloading.
-  if (_unloading_occurred) {
-    _klass_cleaning_task.work();
-  }
-}

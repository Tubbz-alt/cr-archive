<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/workgroup.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="workgroup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c1/shenandoahBarrierSetC1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/workgroup.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
 36 // Task class hierarchy:
 37 //   AbstractGangTask
 38 //
 39 // Gang/Group class hierarchy:
 40 //   AbstractWorkGang
 41 //     WorkGang
 42 //     YieldingFlexibleWorkGang (defined in another file)
 43 //
 44 // Worker class hierarchy:
 45 //   AbstractGangWorker (subclass of WorkerThread)
 46 //     GangWorker
 47 //     YieldingFlexibleGangWorker   (defined in another file)
 48 
 49 // Forward declarations of classes defined here
 50 
 51 class AbstractGangWorker;
 52 class Semaphore;

 53 class WorkGang;
 54 
 55 // An abstract task to be worked on by a gang.
 56 // You subclass this to supply your own work() method
 57 class AbstractGangTask {
 58   const char* _name;
 59   const uint _gc_id;
 60 
 61  public:
 62   explicit AbstractGangTask(const char* name) :
 63     _name(name),
 64     _gc_id(GCId::current_or_undefined())
 65   {}
 66 
 67   // The abstract work method.
 68   // The argument tells you which member of the gang you are.
 69   virtual void work(uint worker_id) = 0;
 70 
 71   // Debugging accessor for the name.
 72   const char* name() const { return _name; }
</pre>
<hr />
<pre>
222   // active workers.  Additional workers may be created if an insufficient
223   // number currently exists.
224   void run_task(AbstractGangTask* task, uint num_workers);
225 
226 protected:
227   virtual AbstractGangWorker* allocate_worker(uint which);
228 };
229 
230 // Several instances of this class run in parallel as workers for a gang.
231 class AbstractGangWorker: public WorkerThread {
232 public:
233   AbstractGangWorker(AbstractWorkGang* gang, uint id);
234 
235   // The only real method: run a task for the gang.
236   virtual void run();
237   // Predicate for Thread
238   virtual bool is_GC_task_thread() const;
239   virtual bool is_ConcurrentGC_thread() const;
240   // Printing
241   void print_on(outputStream* st) const;
<span class="line-modified">242   virtual void print() const { print_on(tty); }</span>
243 
244 protected:
245   AbstractWorkGang* _gang;
246 
247   virtual void initialize();
248   virtual void loop() = 0;
249 
250   AbstractWorkGang* gang() const { return _gang; }
251 };
252 
253 class GangWorker: public AbstractGangWorker {
254 public:
255   GangWorker(WorkGang* gang, uint id) : AbstractGangWorker(gang, id) {}
256 
257 protected:
258   virtual void loop();
259 
260 private:
261   WorkData wait_for_task();
262   void run_task(WorkData work);
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
 36 // Task class hierarchy:
 37 //   AbstractGangTask
 38 //
 39 // Gang/Group class hierarchy:
 40 //   AbstractWorkGang
 41 //     WorkGang
 42 //     YieldingFlexibleWorkGang (defined in another file)
 43 //
 44 // Worker class hierarchy:
 45 //   AbstractGangWorker (subclass of WorkerThread)
 46 //     GangWorker
 47 //     YieldingFlexibleGangWorker   (defined in another file)
 48 
 49 // Forward declarations of classes defined here
 50 
 51 class AbstractGangWorker;
 52 class Semaphore;
<span class="line-added"> 53 class ThreadClosure;</span>
 54 class WorkGang;
 55 
 56 // An abstract task to be worked on by a gang.
 57 // You subclass this to supply your own work() method
 58 class AbstractGangTask {
 59   const char* _name;
 60   const uint _gc_id;
 61 
 62  public:
 63   explicit AbstractGangTask(const char* name) :
 64     _name(name),
 65     _gc_id(GCId::current_or_undefined())
 66   {}
 67 
 68   // The abstract work method.
 69   // The argument tells you which member of the gang you are.
 70   virtual void work(uint worker_id) = 0;
 71 
 72   // Debugging accessor for the name.
 73   const char* name() const { return _name; }
</pre>
<hr />
<pre>
223   // active workers.  Additional workers may be created if an insufficient
224   // number currently exists.
225   void run_task(AbstractGangTask* task, uint num_workers);
226 
227 protected:
228   virtual AbstractGangWorker* allocate_worker(uint which);
229 };
230 
231 // Several instances of this class run in parallel as workers for a gang.
232 class AbstractGangWorker: public WorkerThread {
233 public:
234   AbstractGangWorker(AbstractWorkGang* gang, uint id);
235 
236   // The only real method: run a task for the gang.
237   virtual void run();
238   // Predicate for Thread
239   virtual bool is_GC_task_thread() const;
240   virtual bool is_ConcurrentGC_thread() const;
241   // Printing
242   void print_on(outputStream* st) const;
<span class="line-modified">243   virtual void print() const;</span>
244 
245 protected:
246   AbstractWorkGang* _gang;
247 
248   virtual void initialize();
249   virtual void loop() = 0;
250 
251   AbstractWorkGang* gang() const { return _gang; }
252 };
253 
254 class GangWorker: public AbstractGangWorker {
255 public:
256   GangWorker(WorkGang* gang, uint id) : AbstractGangWorker(gang, id) {}
257 
258 protected:
259   virtual void loop();
260 
261 private:
262   WorkData wait_for_task();
263   void run_task(WorkData work);
</pre>
</td>
</tr>
</table>
<center><a href="workgroup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c1/shenandoahBarrierSetC1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
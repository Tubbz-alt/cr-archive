<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/workerDataArray.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="workerDataArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workerPolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/workerDataArray.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 26 #define SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 27 
 28 #include &quot;gc/shared/workerDataArray.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 template &lt;typename T&gt;
<span class="line-modified"> 33 WorkerDataArray&lt;T&gt;::WorkerDataArray(uint length, const char* title) :</span>
 34  _data(NULL),
 35  _length(length),
<span class="line-modified"> 36  _title(title) {</span>

 37   assert(length &gt; 0, &quot;Must have some workers to store data for&quot;);

 38   _data = NEW_C_HEAP_ARRAY(T, _length, mtGC);
 39   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 40     _thread_work_items[i] = NULL;
 41   }
 42   reset();
 43 }
 44 
 45 template &lt;typename T&gt;
 46 void WorkerDataArray&lt;T&gt;::set(uint worker_i, T value) {
 47   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 48   assert(_data[worker_i] == uninitialized(), &quot;Overwriting data for worker %d in %s&quot;, worker_i, _title);
 49   _data[worker_i] = value;
 50 }
 51 
 52 template &lt;typename T&gt;
 53 T WorkerDataArray&lt;T&gt;::get(uint worker_i) const {
 54   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 55   return _data[worker_i];
 56 }
 57 
 58 template &lt;typename T&gt;
 59 WorkerDataArray&lt;T&gt;::~WorkerDataArray() {



 60   FREE_C_HEAP_ARRAY(T, _data);
 61 }
 62 
 63 template &lt;typename T&gt;
<span class="line-modified"> 64 void WorkerDataArray&lt;T&gt;::link_thread_work_items(WorkerDataArray&lt;size_t&gt;* thread_work_items, uint index) {</span>
 65   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
<span class="line-modified"> 66   _thread_work_items[index] = thread_work_items;</span>


 67 }
 68 
 69 template &lt;typename T&gt;
 70 void WorkerDataArray&lt;T&gt;::set_thread_work_item(uint worker_i, size_t value, uint index) {
 71   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 72   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 73   _thread_work_items[index]-&gt;set(worker_i, value);
 74 }
 75 
 76 template &lt;typename T&gt;
 77 void WorkerDataArray&lt;T&gt;::add_thread_work_item(uint worker_i, size_t value, uint index) {
 78   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 79   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 80   _thread_work_items[index]-&gt;add(worker_i, value);
 81 }
 82 
 83 template &lt;typename T&gt;
 84 void WorkerDataArray&lt;T&gt;::set_or_add_thread_work_item(uint worker_i, size_t value, uint index) {
 85   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 86   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 87   if (_thread_work_items[index]-&gt;get(worker_i) == _thread_work_items[index]-&gt;uninitialized()) {
 88     _thread_work_items[index]-&gt;set(worker_i, value);
 89   } else {
 90     _thread_work_items[index]-&gt;add(worker_i, value);
 91   }
 92 }
 93 







 94 template &lt;typename T&gt;
 95 void WorkerDataArray&lt;T&gt;::add(uint worker_i, T value) {
 96   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
<span class="line-modified"> 97   assert(_data[worker_i] != uninitialized(), &quot;No data to add to for worker %d&quot;, worker_i);</span>
 98   _data[worker_i] += value;
 99 }
100 
101 template &lt;typename T&gt;
102 double WorkerDataArray&lt;T&gt;::average() const {
103   uint contributing_threads = 0;
104   for (uint i = 0; i &lt; _length; ++i) {
105     if (get(i) != uninitialized()) {
106       contributing_threads++;
107     }
108   }
109   if (contributing_threads == 0) {
110     return 0.0;
111   }
112   return sum() / (double) contributing_threads;
113 }
114 
115 template &lt;typename T&gt;
116 T WorkerDataArray&lt;T&gt;::sum() const {
117   T s = 0;
118   for (uint i = 0; i &lt; _length; ++i) {
119     if (get(i) != uninitialized()) {
120       s += get(i);
121     }
122   }
123   return s;
124 }
125 
126 template &lt;typename T&gt;
127 void WorkerDataArray&lt;T&gt;::set_all(T value) {
128   for (uint i = 0; i &lt; _length; i++) {
129     _data[i] = value;
130   }
131 }
132 
133 template &lt;class T&gt;
134 void WorkerDataArray&lt;T&gt;::print_summary_on(outputStream* out, bool print_sum) const {
<span class="line-modified">135   out-&gt;print(&quot;%-25s&quot;, title());</span>





136   uint start = 0;
137   while (start &lt; _length &amp;&amp; get(start) == uninitialized()) {
138     start++;
139   }
140   if (start &lt; _length) {
<span class="line-modified">141     T min = get(start);</span>
<span class="line-modified">142     T max = min;</span>
<span class="line-modified">143     T sum = 0;</span>
<span class="line-modified">144     uint contributing_threads = 0;</span>
<span class="line-modified">145     for (uint i = start; i &lt; _length; ++i) {</span>
<span class="line-modified">146       T value = get(i);</span>
<span class="line-modified">147       if (value != uninitialized()) {</span>
<span class="line-modified">148         max = MAX2(max, value);</span>
<span class="line-modified">149         min = MIN2(min, value);</span>
<span class="line-modified">150         sum += value;</span>
<span class="line-modified">151         contributing_threads++;</span>




152       }





153     }
<span class="line-removed">154     T diff = max - min;</span>
<span class="line-removed">155     assert(contributing_threads != 0, &quot;Must be since we found a used value for the start index&quot;);</span>
<span class="line-removed">156     double avg = sum / (double) contributing_threads;</span>
<span class="line-removed">157     WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);</span>
<span class="line-removed">158     out-&gt;print_cr(&quot;, Workers: %d&quot;, contributing_threads);</span>
159   } else {
160     // No data for this phase.
161     out-&gt;print_cr(&quot; skipped&quot;);
162   }
163 }
164 
165 template &lt;class T&gt;
166 void WorkerDataArray&lt;T&gt;::print_details_on(outputStream* out) const {
167   WDAPrinter::details(this, out);
168 }
169 
170 template &lt;typename T&gt;
171 void WorkerDataArray&lt;T&gt;::reset() {
172   set_all(uninitialized());
173   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
174     if (_thread_work_items[i] != NULL) {
175       _thread_work_items[i]-&gt;reset();
176     }
177   }
178 }
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 26 #define SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 27 
 28 #include &quot;gc/shared/workerDataArray.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 template &lt;typename T&gt;
<span class="line-modified"> 33 WorkerDataArray&lt;T&gt;::WorkerDataArray(const char* title, uint length, bool is_serial) :</span>
 34  _data(NULL),
 35  _length(length),
<span class="line-modified"> 36  _title(title),</span>
<span class="line-added"> 37  _is_serial(is_serial) {</span>
 38   assert(length &gt; 0, &quot;Must have some workers to store data for&quot;);
<span class="line-added"> 39   assert(!is_serial || length == 1, &quot;Serial phase must only have a single entry.&quot;);</span>
 40   _data = NEW_C_HEAP_ARRAY(T, _length, mtGC);
 41   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 42     _thread_work_items[i] = NULL;
 43   }
 44   reset();
 45 }
 46 
 47 template &lt;typename T&gt;
 48 void WorkerDataArray&lt;T&gt;::set(uint worker_i, T value) {
 49   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 50   assert(_data[worker_i] == uninitialized(), &quot;Overwriting data for worker %d in %s&quot;, worker_i, _title);
 51   _data[worker_i] = value;
 52 }
 53 
 54 template &lt;typename T&gt;
 55 T WorkerDataArray&lt;T&gt;::get(uint worker_i) const {
 56   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 57   return _data[worker_i];
 58 }
 59 
 60 template &lt;typename T&gt;
 61 WorkerDataArray&lt;T&gt;::~WorkerDataArray() {
<span class="line-added"> 62   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {</span>
<span class="line-added"> 63     delete _thread_work_items[i];</span>
<span class="line-added"> 64   }</span>
 65   FREE_C_HEAP_ARRAY(T, _data);
 66 }
 67 
 68 template &lt;typename T&gt;
<span class="line-modified"> 69 void WorkerDataArray&lt;T&gt;::create_thread_work_items(const char* title, uint index, uint length_override) {</span>
 70   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
<span class="line-modified"> 71   assert(_thread_work_items[index] == NULL, &quot;Tried to overwrite existing thread work item&quot;);</span>
<span class="line-added"> 72   uint length = length_override != 0 ? length_override : _length;</span>
<span class="line-added"> 73   _thread_work_items[index] = new WorkerDataArray&lt;size_t&gt;(title, length);</span>
 74 }
 75 
 76 template &lt;typename T&gt;
 77 void WorkerDataArray&lt;T&gt;::set_thread_work_item(uint worker_i, size_t value, uint index) {
 78   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 79   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 80   _thread_work_items[index]-&gt;set(worker_i, value);
 81 }
 82 
 83 template &lt;typename T&gt;
 84 void WorkerDataArray&lt;T&gt;::add_thread_work_item(uint worker_i, size_t value, uint index) {
 85   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 86   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 87   _thread_work_items[index]-&gt;add(worker_i, value);
 88 }
 89 
 90 template &lt;typename T&gt;
 91 void WorkerDataArray&lt;T&gt;::set_or_add_thread_work_item(uint worker_i, size_t value, uint index) {
 92   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 93   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 94   if (_thread_work_items[index]-&gt;get(worker_i) == _thread_work_items[index]-&gt;uninitialized()) {
 95     _thread_work_items[index]-&gt;set(worker_i, value);
 96   } else {
 97     _thread_work_items[index]-&gt;add(worker_i, value);
 98   }
 99 }
100 
<span class="line-added">101 template &lt;typename T&gt;</span>
<span class="line-added">102 size_t WorkerDataArray&lt;T&gt;::get_thread_work_item(uint worker_i, uint index) {</span>
<span class="line-added">103   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);</span>
<span class="line-added">104   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);</span>
<span class="line-added">105   return _thread_work_items[index]-&gt;get(worker_i);</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
108 template &lt;typename T&gt;
109 void WorkerDataArray&lt;T&gt;::add(uint worker_i, T value) {
110   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
<span class="line-modified">111   assert(_data[worker_i] != uninitialized(), &quot;No data to add to %s for worker %d&quot;, _title, worker_i);</span>
112   _data[worker_i] += value;
113 }
114 
115 template &lt;typename T&gt;
116 double WorkerDataArray&lt;T&gt;::average() const {
117   uint contributing_threads = 0;
118   for (uint i = 0; i &lt; _length; ++i) {
119     if (get(i) != uninitialized()) {
120       contributing_threads++;
121     }
122   }
123   if (contributing_threads == 0) {
124     return 0.0;
125   }
126   return sum() / (double) contributing_threads;
127 }
128 
129 template &lt;typename T&gt;
130 T WorkerDataArray&lt;T&gt;::sum() const {
131   T s = 0;
132   for (uint i = 0; i &lt; _length; ++i) {
133     if (get(i) != uninitialized()) {
134       s += get(i);
135     }
136   }
137   return s;
138 }
139 
140 template &lt;typename T&gt;
141 void WorkerDataArray&lt;T&gt;::set_all(T value) {
142   for (uint i = 0; i &lt; _length; i++) {
143     _data[i] = value;
144   }
145 }
146 
147 template &lt;class T&gt;
148 void WorkerDataArray&lt;T&gt;::print_summary_on(outputStream* out, bool print_sum) const {
<span class="line-modified">149   if (_is_serial) {</span>
<span class="line-added">150     out-&gt;print(&quot;%s:&quot;, title());</span>
<span class="line-added">151   } else {</span>
<span class="line-added">152     out-&gt;print(&quot;%-25s&quot;, title());</span>
<span class="line-added">153   }</span>
<span class="line-added">154 </span>
155   uint start = 0;
156   while (start &lt; _length &amp;&amp; get(start) == uninitialized()) {
157     start++;
158   }
159   if (start &lt; _length) {
<span class="line-modified">160     if (_is_serial) {</span>
<span class="line-modified">161       WDAPrinter::summary(out, get(0));</span>
<span class="line-modified">162     } else {</span>
<span class="line-modified">163       T min = get(start);</span>
<span class="line-modified">164       T max = min;</span>
<span class="line-modified">165       T sum = 0;</span>
<span class="line-modified">166       uint contributing_threads = 0;</span>
<span class="line-modified">167       for (uint i = start; i &lt; _length; ++i) {</span>
<span class="line-modified">168         T value = get(i);</span>
<span class="line-modified">169         if (value != uninitialized()) {</span>
<span class="line-modified">170           max = MAX2(max, value);</span>
<span class="line-added">171           min = MIN2(min, value);</span>
<span class="line-added">172           sum += value;</span>
<span class="line-added">173           contributing_threads++;</span>
<span class="line-added">174         }</span>
175       }
<span class="line-added">176       T diff = max - min;</span>
<span class="line-added">177       assert(contributing_threads != 0, &quot;Must be since we found a used value for the start index&quot;);</span>
<span class="line-added">178       double avg = sum / (double) contributing_threads;</span>
<span class="line-added">179       WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);</span>
<span class="line-added">180       out-&gt;print_cr(&quot;, Workers: %d&quot;, contributing_threads);</span>
181     }





182   } else {
183     // No data for this phase.
184     out-&gt;print_cr(&quot; skipped&quot;);
185   }
186 }
187 
188 template &lt;class T&gt;
189 void WorkerDataArray&lt;T&gt;::print_details_on(outputStream* out) const {
190   WDAPrinter::details(this, out);
191 }
192 
193 template &lt;typename T&gt;
194 void WorkerDataArray&lt;T&gt;::reset() {
195   set_all(uninitialized());
196   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
197     if (_thread_work_items[i] != NULL) {
198       _thread_work_items[i]-&gt;reset();
199     }
200   }
201 }
</pre>
</td>
</tr>
</table>
<center><a href="workerDataArray.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workerPolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/genCollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genCollectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genCollectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,31 ***</span>
  
  #ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
  #define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
  #include &quot;gc/shared/generation.hpp&quot;
  #include &quot;gc/shared/oopStorageParState.hpp&quot;
  #include &quot;gc/shared/softRefGenPolicy.hpp&quot;
  
  class AdaptiveSizePolicy;
  class GCPolicyCounters;
  class GenerationSpec;
  class StrongRootsScope;
  class SubTasksDone;
  class WorkGang;
  
  // A &quot;GenCollectedHeap&quot; is a CollectedHeap that uses generational
  // collection.  It has two generations, young and old.
  class GenCollectedHeap : public CollectedHeap {
<span class="line-removed">-   friend class GenCollectorPolicy;</span>
    friend class Generation;
    friend class DefNewGeneration;
    friend class TenuredGeneration;
<span class="line-removed">-   friend class ConcurrentMarkSweepGeneration;</span>
<span class="line-removed">-   friend class CMSCollector;</span>
    friend class GenMarkSweep;
    friend class VM_GenCollectForAllocation;
    friend class VM_GenCollectFull;
    friend class VM_GenCollectFullConcurrent;
    friend class VM_GC_HeapInspection;
<span class="line-new-header">--- 24,29 ---</span>
  
  #ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
  #define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
  
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/generation.hpp&quot;
  #include &quot;gc/shared/oopStorageParState.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/preGCValues.hpp&quot;</span>
  #include &quot;gc/shared/softRefGenPolicy.hpp&quot;
  
  class AdaptiveSizePolicy;
<span class="line-added">+ class CardTableRS;</span>
  class GCPolicyCounters;
  class GenerationSpec;
  class StrongRootsScope;
  class SubTasksDone;
  class WorkGang;
  
  // A &quot;GenCollectedHeap&quot; is a CollectedHeap that uses generational
  // collection.  It has two generations, young and old.
  class GenCollectedHeap : public CollectedHeap {
    friend class Generation;
    friend class DefNewGeneration;
    friend class TenuredGeneration;
    friend class GenMarkSweep;
    friend class VM_GenCollectForAllocation;
    friend class VM_GenCollectFull;
    friend class VM_GenCollectFullConcurrent;
    friend class VM_GC_HeapInspection;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,13 ***</span>
    GenerationSpec* _old_gen_spec;
  
    // The singleton CardTable Remembered Set.
    CardTableRS* _rem_set;
  
<span class="line-removed">-   // The generational collector policy.</span>
<span class="line-removed">-   GenCollectorPolicy* _gen_policy;</span>
<span class="line-removed">- </span>
    SoftRefGenPolicy _soft_ref_gen_policy;
  
    // The sizing of the heap is controlled by a sizing policy.
    AdaptiveSizePolicy* _size_policy;
  
<span class="line-new-header">--- 71,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,15 ***</span>
    void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,
                            bool run_verification, bool clear_soft_refs,
                            bool restore_marks_for_biased_locking);
  
    // Reserve aligned space for the heap as needed by the contained generations.
<span class="line-modified">!   char* allocate(size_t alignment, ReservedSpace* heap_rs);</span>
  
    // Initialize (&quot;weak&quot;) refs processing support
    void ref_processing_init();
  
  protected:
  
    // The set of potentially parallel tasks in root scanning.
    enum GCH_strong_roots_tasks {
      GCH_PS_Universe_oops_do,
<span class="line-new-header">--- 92,17 ---</span>
    void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,
                            bool run_verification, bool clear_soft_refs,
                            bool restore_marks_for_biased_locking);
  
    // Reserve aligned space for the heap as needed by the contained generations.
<span class="line-modified">!   ReservedHeapSpace allocate(size_t alignment);</span>
  
    // Initialize (&quot;weak&quot;) refs processing support
    void ref_processing_init();
  
<span class="line-added">+   PreGenGCValues get_pre_gc_values() const;</span>
<span class="line-added">+ </span>
  protected:
  
    // The set of potentially parallel tasks in root scanning.
    enum GCH_strong_roots_tasks {
      GCH_PS_Universe_oops_do,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,11 ***</span>
      GCH_PS_Management_oops_do,
      GCH_PS_SystemDictionary_oops_do,
      GCH_PS_ClassLoaderDataGraph_oops_do,
      GCH_PS_jvmti_oops_do,
      GCH_PS_CodeCache_oops_do,
<span class="line-modified">!     GCH_PS_aot_oops_do,</span>
      GCH_PS_younger_gens,
      // Leave this one last.
      GCH_PS_NumElements
    };
  
<span class="line-new-header">--- 112,11 ---</span>
      GCH_PS_Management_oops_do,
      GCH_PS_SystemDictionary_oops_do,
      GCH_PS_ClassLoaderDataGraph_oops_do,
      GCH_PS_jvmti_oops_do,
      GCH_PS_CodeCache_oops_do,
<span class="line-modified">!     AOT_ONLY(GCH_PS_aot_oops_do COMMA)</span>
      GCH_PS_younger_gens,
      // Leave this one last.
      GCH_PS_NumElements
    };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,12 ***</span>
  
    // Does the &quot;cause&quot; of GC indicate that
    // we absolutely __must__ clear soft refs?
    bool must_clear_all_soft_refs();
  
<span class="line-modified">!   GenCollectedHeap(GenCollectorPolicy *policy,</span>
<span class="line-removed">-                    Generation::Name young,</span>
                     Generation::Name old,
                     const char* policy_counters_name);
  
  public:
  
<span class="line-new-header">--- 153,11 ---</span>
  
    // Does the &quot;cause&quot; of GC indicate that
    // we absolutely __must__ clear soft refs?
    bool must_clear_all_soft_refs();
  
<span class="line-modified">!   GenCollectedHeap(Generation::Name young,</span>
                     Generation::Name old,
                     const char* policy_counters_name);
  
  public:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,33 ***</span>
    Generation* old_gen()   const { return _old_gen; }
  
    bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }
    bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }
  
    GenerationSpec* young_gen_spec() const;
    GenerationSpec* old_gen_spec() const;
  
<span class="line-removed">-   // The generational collector policy.</span>
<span class="line-removed">-   GenCollectorPolicy* gen_policy() const { return _gen_policy; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual CollectorPolicy* collector_policy() const { return gen_policy(); }</span>
<span class="line-removed">- </span>
    virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_gen_policy; }
  
    // Adaptive size policy
    virtual AdaptiveSizePolicy* size_policy() {
      return _size_policy;
    }
  
    // Performance Counter support
    GCPolicyCounters* counters()     { return _gc_policy_counters; }
  
<span class="line-removed">-   // Return the (conservative) maximum heap alignment</span>
<span class="line-removed">-   static size_t conservative_max_heap_alignment() {</span>
<span class="line-removed">-     return Generation::GenGrain;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    size_t capacity() const;
    size_t used() const;
  
    // Save the &quot;used_region&quot; for both generations.
    void save_used_regions();
<span class="line-new-header">--- 176,26 ---</span>
    Generation* old_gen()   const { return _old_gen; }
  
    bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }
    bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }
  
<span class="line-added">+   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-added">+   bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }</span>
<span class="line-added">+ </span>
    GenerationSpec* young_gen_spec() const;
    GenerationSpec* old_gen_spec() const;
  
    virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_gen_policy; }
  
    // Adaptive size policy
    virtual AdaptiveSizePolicy* size_policy() {
      return _size_policy;
    }
  
    // Performance Counter support
    GCPolicyCounters* counters()     { return _gc_policy_counters; }
  
    size_t capacity() const;
    size_t used() const;
  
    // Save the &quot;used_region&quot; for both generations.
    void save_used_regions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,14 ***</span>
    // Perform a full collection of generations up to and including max_generation.
    // Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.
    void collect(GCCause::Cause cause, GenerationType max_generation);
  
    // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
<span class="line-modified">!   // The methods is_in(), is_in_closed_subset() and is_in_youngest() may</span>
<span class="line-modified">!   // be expensive to compute in general, so, to prevent</span>
<span class="line-modified">!   // their inadvertent use in product jvm&#39;s, we restrict their use to</span>
<span class="line-removed">-   // assertion checking or verification only.</span>
    bool is_in(const void* p) const;
  
    // Returns true if the reference is to an object in the reserved space
    // for the young generation.
    // Assumes the the young gen address range is less than that of the old gen.
<span class="line-new-header">--- 221,13 ---</span>
    // Perform a full collection of generations up to and including max_generation.
    // Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.
    void collect(GCCause::Cause cause, GenerationType max_generation);
  
    // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
<span class="line-modified">!   // The methods is_in() and is_in_youngest() may be expensive to compute</span>
<span class="line-modified">!   // in general, so, to prevent their inadvertent use in product jvm&#39;s, we</span>
<span class="line-modified">!   // restrict their use to assertion checking or verification only.</span>
    bool is_in(const void* p) const;
  
    // Returns true if the reference is to an object in the reserved space
    // for the young generation.
    // Assumes the the young gen address range is less than that of the old gen.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,16 ***</span>
    virtual void register_nmethod(nmethod* nm);
    virtual void unregister_nmethod(nmethod* nm);
    virtual void verify_nmethod(nmethod* nm);
    virtual void flush_nmethod(nmethod* nm);
  
<span class="line-modified">!   void prune_nmethods();</span>
  
    // Iteration functions.
    void oop_iterate(OopIterateClosure* cl);
    void object_iterate(ObjectClosure* cl);
<span class="line-removed">-   void safe_object_iterate(ObjectClosure* cl);</span>
    Space* space_containing(const void* addr) const;
  
    // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,
    // each address in the (reserved) heap is a member of exactly
    // one block.  The defining characteristic of a block is that it is
<span class="line-new-header">--- 241,15 ---</span>
    virtual void register_nmethod(nmethod* nm);
    virtual void unregister_nmethod(nmethod* nm);
    virtual void verify_nmethod(nmethod* nm);
    virtual void flush_nmethod(nmethod* nm);
  
<span class="line-modified">!   void prune_scavengable_nmethods();</span>
  
    // Iteration functions.
    void oop_iterate(OopIterateClosure* cl);
    void object_iterate(ObjectClosure* cl);
    Space* space_containing(const void* addr) const;
  
    // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,
    // each address in the (reserved) heap is a member of exactly
    // one block.  The defining characteristic of a block is that it is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,17 ***</span>
  
    // Returns the address of the start of the &quot;block&quot; that contains the
    // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
    // may not pack objects densely; a chunk may either be an object or a
    // non-object.
<span class="line-modified">!   virtual HeapWord* block_start(const void* addr) const;</span>
  
    // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
    // the block is an object. Assumes (and verifies in non-product
    // builds) that addr is in the allocated part of the heap and is
    // the start of a chunk.
<span class="line-modified">!   virtual bool block_is_obj(const HeapWord* addr) const;</span>
  
    // Section on TLAB&#39;s.
    virtual bool supports_tlab_allocation() const;
    virtual size_t tlab_capacity(Thread* thr) const;
    virtual size_t tlab_used(Thread* thr) const;
<span class="line-new-header">--- 261,17 ---</span>
  
    // Returns the address of the start of the &quot;block&quot; that contains the
    // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
    // may not pack objects densely; a chunk may either be an object or a
    // non-object.
<span class="line-modified">!   HeapWord* block_start(const void* addr) const;</span>
  
    // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
    // the block is an object. Assumes (and verifies in non-product
    // builds) that addr is in the allocated part of the heap and is
    // the start of a chunk.
<span class="line-modified">!   bool block_is_obj(const HeapWord* addr) const;</span>
  
    // Section on TLAB&#39;s.
    virtual bool supports_tlab_allocation() const;
    virtual size_t tlab_capacity(Thread* thr) const;
    virtual size_t tlab_used(Thread* thr) const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,11 ***</span>
    virtual void print_on(outputStream* st) const;
    virtual void print_gc_threads_on(outputStream* st) const;
    virtual void gc_threads_do(ThreadClosure* tc) const;
    virtual void print_tracing_info() const;
  
<span class="line-modified">!   void print_heap_change(size_t young_prev_used, size_t old_prev_used) const;</span>
  
    // The functions below are helper functions that a subclass of
    // &quot;CollectedHeap&quot; can use in the implementation of its virtual
    // functions.
  
<span class="line-new-header">--- 333,14 ---</span>
    virtual void print_on(outputStream* st) const;
    virtual void print_gc_threads_on(outputStream* st) const;
    virtual void gc_threads_do(ThreadClosure* tc) const;
    virtual void print_tracing_info() const;
  
<span class="line-modified">!   // Used to print information about locations in the hs_err file.</span>
<span class="line-added">+   virtual bool print_location(outputStream* st, void* addr) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   void print_heap_change(const PreGenGCValues&amp; pre_gc_values) const;</span>
  
    // The functions below are helper functions that a subclass of
    // &quot;CollectedHeap&quot; can use in the implementation of its virtual
    // functions.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,15 ***</span>
                       OopClosure* strong_roots,
                       CLDClosure* strong_cld_closure,
                       CLDClosure* weak_cld_closure,
                       CodeBlobToOopClosure* code_roots);
  
<span class="line-removed">-   // Accessor for memory state verification support</span>
<span class="line-removed">-   NOT_PRODUCT(</span>
<span class="line-removed">-     virtual size_t skip_header_HeapWords() { return 0; }</span>
<span class="line-removed">-   )</span>
<span class="line-removed">- </span>
    virtual void gc_prologue(bool full);
    virtual void gc_epilogue(bool full);
  
   public:
    void young_process_roots(StrongRootsScope* scope,
<span class="line-new-header">--- 381,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,14 ***</span>
  
    HeapWord* mem_allocate_work(size_t size,
                                bool is_tlab,
                                bool* gc_overhead_limit_was_exceeded);
  
<span class="line-removed">-   // Override</span>
<span class="line-removed">-   void check_for_non_bad_heap_word_value(HeapWord* addr,</span>
<span class="line-removed">-     size_t size) PRODUCT_RETURN;</span>
<span class="line-removed">- </span>
  #if INCLUDE_SERIALGC
    // For use by mark-sweep.  As implemented, mark-sweep-compact is global
    // in an essential way: compaction is performed across generations, by
    // iterating over spaces.
    void prepare_for_compaction();
<span class="line-new-header">--- 455,10 ---</span>
</pre>
<center><a href="genCollectedHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
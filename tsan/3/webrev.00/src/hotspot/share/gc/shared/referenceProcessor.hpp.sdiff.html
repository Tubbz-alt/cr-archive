<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/referenceProcessor.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="referenceProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessorPhaseTimes.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/referenceProcessor.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
126       _keep_alive-&gt;do_oop((narrowOop*)_referent_addr);
127     } else {
128       _keep_alive-&gt;do_oop((oop*)_referent_addr);
129     }
130   }
131 
132   // Do enqueuing work, i.e. notifying the GC about the changed discovered pointers.
133   void enqueue();
134 
135   // Move enqueued references to the reference pending list.
136   void complete_enqueue();
137 
138   // NULL out referent pointer.
139   void clear_referent();
140 
141   // Statistics
142   inline size_t processed() const { return _processed; }
143   inline size_t removed() const { return _removed; }
144 
145   inline void move_to_next() {
<span class="line-modified">146     if (oopDesc::equals_raw(_current_discovered, _next_discovered)) {</span>
147       // End of the list.
148       _current_discovered = NULL;
149     } else {
150       _current_discovered = _next_discovered;
151     }
<span class="line-modified">152     assert(!oopDesc::equals_raw(_current_discovered, _first_seen), &quot;cyclic ref_list found&quot;);</span>
153     _processed++;
154   }
155 };
156 
157 // The ReferenceProcessor class encapsulates the per-&quot;collector&quot; processing
158 // of java.lang.Reference objects for GC. The interface is useful for supporting
159 // a generational abstraction, in particular when there are multiple
160 // generations that are being independently collected -- possibly
161 // concurrently and/or incrementally.
162 // ReferenceProcessor class abstracts away from a generational setting
163 // by using a closure that determines whether a given reference or referent are
164 // subject to this ReferenceProcessor&#39;s discovery, thus allowing its use in a
165 // straightforward manner in a general, non-generational, non-contiguous generation
166 // (or heap) setting.
167 class ReferenceProcessor : public ReferenceDiscoverer {
168   friend class RefProcPhase1Task;
169   friend class RefProcPhase2Task;
170   friend class RefProcPhase3Task;
171   friend class RefProcPhase4Task;
172 public:
</pre>
<hr />
<pre>
200 
201   BoolObjectClosure* _is_subject_to_discovery; // determines whether a given oop is subject
202                                                // to this ReferenceProcessor&#39;s discovery
203                                                // (and further processing).
204 
205   bool        _discovering_refs;        // true when discovery enabled
206   bool        _discovery_is_atomic;     // if discovery is atomic wrt
207                                         // other collectors in configuration
208   bool        _discovery_is_mt;         // true if reference discovery is MT.
209 
210   bool        _enqueuing_is_done;       // true if all weak references enqueued
211   bool        _processing_is_mt;        // true during phases when
212                                         // reference processing is MT.
213   uint        _next_id;                 // round-robin mod _num_queues counter in
214                                         // support of work distribution
215 
216   bool        _adjust_no_of_processing_threads; // allow dynamic adjustment of processing threads
217   // For collectors that do not keep GC liveness information
218   // in the object header, this field holds a closure that
219   // helps the reference processor determine the reachability
<span class="line-modified">220   // of an oop. It is currently initialized to NULL for all</span>
<span class="line-removed">221   // collectors except for CMS and G1.</span>
222   BoolObjectClosure* _is_alive_non_header;
223 
224   // Soft ref clearing policies
225   // . the default policy
226   static ReferencePolicy*   _default_soft_ref_policy;
227   // . the &quot;clear all&quot; policy
228   static ReferencePolicy*   _always_clear_soft_ref_policy;
229   // . the current policy below is either one of the above
230   ReferencePolicy*          _current_soft_ref_policy;
231 
232   // The discovered ref lists themselves
233 
234   // The active MT&#39;ness degree of the queues below
235   uint            _num_queues;
236   // The maximum MT&#39;ness degree of the queues below
237   uint            _max_num_queues;
238 
239   // Master array of discovered oops
240   DiscoveredList* _discovered_refs;
241 
</pre>
</td>
<td>
<hr />
<pre>
126       _keep_alive-&gt;do_oop((narrowOop*)_referent_addr);
127     } else {
128       _keep_alive-&gt;do_oop((oop*)_referent_addr);
129     }
130   }
131 
132   // Do enqueuing work, i.e. notifying the GC about the changed discovered pointers.
133   void enqueue();
134 
135   // Move enqueued references to the reference pending list.
136   void complete_enqueue();
137 
138   // NULL out referent pointer.
139   void clear_referent();
140 
141   // Statistics
142   inline size_t processed() const { return _processed; }
143   inline size_t removed() const { return _removed; }
144 
145   inline void move_to_next() {
<span class="line-modified">146     if (_current_discovered == _next_discovered) {</span>
147       // End of the list.
148       _current_discovered = NULL;
149     } else {
150       _current_discovered = _next_discovered;
151     }
<span class="line-modified">152     assert(_current_discovered != _first_seen, &quot;cyclic ref_list found&quot;);</span>
153     _processed++;
154   }
155 };
156 
157 // The ReferenceProcessor class encapsulates the per-&quot;collector&quot; processing
158 // of java.lang.Reference objects for GC. The interface is useful for supporting
159 // a generational abstraction, in particular when there are multiple
160 // generations that are being independently collected -- possibly
161 // concurrently and/or incrementally.
162 // ReferenceProcessor class abstracts away from a generational setting
163 // by using a closure that determines whether a given reference or referent are
164 // subject to this ReferenceProcessor&#39;s discovery, thus allowing its use in a
165 // straightforward manner in a general, non-generational, non-contiguous generation
166 // (or heap) setting.
167 class ReferenceProcessor : public ReferenceDiscoverer {
168   friend class RefProcPhase1Task;
169   friend class RefProcPhase2Task;
170   friend class RefProcPhase3Task;
171   friend class RefProcPhase4Task;
172 public:
</pre>
<hr />
<pre>
200 
201   BoolObjectClosure* _is_subject_to_discovery; // determines whether a given oop is subject
202                                                // to this ReferenceProcessor&#39;s discovery
203                                                // (and further processing).
204 
205   bool        _discovering_refs;        // true when discovery enabled
206   bool        _discovery_is_atomic;     // if discovery is atomic wrt
207                                         // other collectors in configuration
208   bool        _discovery_is_mt;         // true if reference discovery is MT.
209 
210   bool        _enqueuing_is_done;       // true if all weak references enqueued
211   bool        _processing_is_mt;        // true during phases when
212                                         // reference processing is MT.
213   uint        _next_id;                 // round-robin mod _num_queues counter in
214                                         // support of work distribution
215 
216   bool        _adjust_no_of_processing_threads; // allow dynamic adjustment of processing threads
217   // For collectors that do not keep GC liveness information
218   // in the object header, this field holds a closure that
219   // helps the reference processor determine the reachability
<span class="line-modified">220   // of an oop.</span>

221   BoolObjectClosure* _is_alive_non_header;
222 
223   // Soft ref clearing policies
224   // . the default policy
225   static ReferencePolicy*   _default_soft_ref_policy;
226   // . the &quot;clear all&quot; policy
227   static ReferencePolicy*   _always_clear_soft_ref_policy;
228   // . the current policy below is either one of the above
229   ReferencePolicy*          _current_soft_ref_policy;
230 
231   // The discovered ref lists themselves
232 
233   // The active MT&#39;ness degree of the queues below
234   uint            _num_queues;
235   // The maximum MT&#39;ness degree of the queues below
236   uint            _max_num_queues;
237 
238   // Master array of discovered oops
239   DiscoveredList* _discovered_refs;
240 
</pre>
</td>
</tr>
</table>
<center><a href="referenceProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessorPhaseTimes.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
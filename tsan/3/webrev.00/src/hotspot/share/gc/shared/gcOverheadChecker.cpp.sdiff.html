<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcOverheadChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcName.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcOverheadChecker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcOverheadChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51 
 52   bool print_gc_overhead_limit_would_be_exceeded = false;
 53   if (is_full_gc) {
 54     if (time_overhead-&gt;is_exceeded() &amp;&amp; space_overhead-&gt;is_exceeded()) {
 55       // Collections, on average, are taking too much time, and
 56       // we have too little space available after a full gc.
 57       // At this point the GC overhead limit is being exceeded.
 58       _gc_overhead_limit_count++;
 59       if (UseGCOverheadLimit) {
 60         if (_gc_overhead_limit_count &gt;= GCOverheadLimitThreshold){
 61           // All conditions have been met for throwing an out-of-memory
 62           set_gc_overhead_limit_exceeded(true);
 63           // Avoid consecutive OOM due to the gc time limit by resetting
 64           // the counter.
 65           reset_gc_overhead_limit_count();
 66         } else {
 67           // The required consecutive collections which exceed the
 68           // GC time limit may or may not have been reached. We
 69           // are approaching that condition and so as not to
 70           // throw an out-of-memory before all SoftRef&#39;s have been
<span class="line-modified"> 71           // cleared, set _should_clear_all_soft_refs in CollectorPolicy.</span>
 72           // The clearing will be done on the next GC.
 73           bool near_limit = gc_overhead_limit_near();
 74           if (near_limit) {
 75             soft_ref_policy-&gt;set_should_clear_all_soft_refs(true);
 76             log_trace(gc, ergo)(&quot;Nearing GC overhead limit, will be clearing all SoftReference&quot;);
 77           }
 78         }
 79       }
 80       // Set this even when the overhead limit will not
 81       // cause an out-of-memory.  Diagnostic message indicating
 82       // that the overhead limit is being exceeded is sometimes
 83       // printed.
 84       print_gc_overhead_limit_would_be_exceeded = true;
 85 
 86     } else {
 87       // Did not exceed overhead limits
 88       reset_gc_overhead_limit_count();
 89     }
 90   }
 91 
</pre>
</td>
<td>
<hr />
<pre>
 51 
 52   bool print_gc_overhead_limit_would_be_exceeded = false;
 53   if (is_full_gc) {
 54     if (time_overhead-&gt;is_exceeded() &amp;&amp; space_overhead-&gt;is_exceeded()) {
 55       // Collections, on average, are taking too much time, and
 56       // we have too little space available after a full gc.
 57       // At this point the GC overhead limit is being exceeded.
 58       _gc_overhead_limit_count++;
 59       if (UseGCOverheadLimit) {
 60         if (_gc_overhead_limit_count &gt;= GCOverheadLimitThreshold){
 61           // All conditions have been met for throwing an out-of-memory
 62           set_gc_overhead_limit_exceeded(true);
 63           // Avoid consecutive OOM due to the gc time limit by resetting
 64           // the counter.
 65           reset_gc_overhead_limit_count();
 66         } else {
 67           // The required consecutive collections which exceed the
 68           // GC time limit may or may not have been reached. We
 69           // are approaching that condition and so as not to
 70           // throw an out-of-memory before all SoftRef&#39;s have been
<span class="line-modified"> 71           // cleared, set _should_clear_all_soft_refs in SoftRefPolicy.</span>
 72           // The clearing will be done on the next GC.
 73           bool near_limit = gc_overhead_limit_near();
 74           if (near_limit) {
 75             soft_ref_policy-&gt;set_should_clear_all_soft_refs(true);
 76             log_trace(gc, ergo)(&quot;Nearing GC overhead limit, will be clearing all SoftReference&quot;);
 77           }
 78         }
 79       }
 80       // Set this even when the overhead limit will not
 81       // cause an out-of-memory.  Diagnostic message indicating
 82       // that the overhead limit is being exceeded is sometimes
 83       // printed.
 84       print_gc_overhead_limit_would_be_exceeded = true;
 85 
 86     } else {
 87       // Did not exceed overhead limits
 88       reset_gc_overhead_limit_count();
 89     }
 90   }
 91 
</pre>
</td>
</tr>
</table>
<center><a href="gcName.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcOverheadChecker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/shared/cardTableRS.cpp b/src/hotspot/share/gc/shared/cardTableRS.cpp
--- a/src/hotspot/share/gc/shared/cardTableRS.cpp
+++ b/src/hotspot/share/gc/shared/cardTableRS.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -137,11 +137,11 @@
            "We shouldn't be looking at clean cards, and this should "
            "be the only place they get cleaned.");
     if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)
         || _ct->is_prev_youngergen_card_val(entry_val)) {
       CardValue res =
-        Atomic::cmpxchg(CardTableRS::clean_card_val(), entry, entry_val);
+        Atomic::cmpxchg(entry, entry_val, CardTableRS::clean_card_val());
       if (res == entry_val) {
         break;
       } else {
         assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,
                "The CAS above should only fail if another thread did "
@@ -242,44 +242,10 @@
     const MemRegion mrd(start_of_non_clean, end_of_non_clean);
     _dirty_card_closure->do_MemRegion(mrd);
   }
 }
 
-// clean (by dirty->clean before) ==> cur_younger_gen
-// dirty                          ==> cur_youngergen_and_prev_nonclean_card
-// precleaned                     ==> cur_youngergen_and_prev_nonclean_card
-// prev-younger-gen               ==> cur_youngergen_and_prev_nonclean_card
-// cur-younger-gen                ==> cur_younger_gen
-// cur_youngergen_and_prev_nonclean_card ==> no change.
-void CardTableRS::write_ref_field_gc_par(void* field, oop new_val) {
-  volatile CardValue* entry = byte_for(field);
-  do {
-    CardValue entry_val = *entry;
-    // We put this first because it's probably the most common case.
-    if (entry_val == clean_card_val()) {
-      // No threat of contention with cleaning threads.
-      *entry = cur_youngergen_card_val();
-      return;
-    } else if (card_is_dirty_wrt_gen_iter(entry_val)
-               || is_prev_youngergen_card_val(entry_val)) {
-      // Mark it as both cur and prev youngergen; card cleaning thread will
-      // eventually remove the previous stuff.
-      CardValue new_val = cur_youngergen_and_prev_nonclean_card;
-      CardValue res = Atomic::cmpxchg(new_val, entry, entry_val);
-      // Did the CAS succeed?
-      if (res == entry_val) return;
-      // Otherwise, retry, to see the new value.
-      continue;
-    } else {
-      assert(entry_val == cur_youngergen_and_prev_nonclean_card
-             || entry_val == cur_youngergen_card_val(),
-             "should be only possibilities.");
-      return;
-    }
-  } while (true);
-}
-
 void CardTableRS::younger_refs_in_space_iterate(Space* sp,
                                                 OopsInGenClosure* cl,
                                                 uint n_threads) {
   verify_used_region_at_save_marks(sp);
 
@@ -341,11 +307,11 @@
     assert(jp >= _begin && jp < _end,
            "Error: jp " PTR_FORMAT " should be within "
            "[_begin, _end) = [" PTR_FORMAT "," PTR_FORMAT ")",
            p2i(jp), p2i(_begin), p2i(_end));
     oop obj = RawAccess<>::oop_load(p);
-    guarantee(obj == NULL || (HeapWord*)obj >= _boundary,
+    guarantee(obj == NULL || cast_from_oop<HeapWord*>(obj) >= _boundary,
               "pointer " PTR_FORMAT " at " PTR_FORMAT " on "
               "clean card crosses boundary" PTR_FORMAT,
               p2i(obj), p2i(jp), p2i(_boundary));
   }
 
@@ -611,41 +577,22 @@
   _last_LNC_resizing_collection(NULL)
 {
   // max_gens is really GenCollectedHeap::heap()->gen_policy()->number_of_generations()
   // (which is always 2, young & old), but GenCollectedHeap has not been initialized yet.
   uint max_gens = 2;
-  _last_cur_val_in_gen = NEW_C_HEAP_ARRAY3(CardValue, max_gens + 1,
-                         mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);
-  if (_last_cur_val_in_gen == NULL) {
-    vm_exit_during_initialization("Could not create last_cur_val_in_gen array.");
-  }
+  _last_cur_val_in_gen = NEW_C_HEAP_ARRAY(CardValue, max_gens + 1, mtGC);
   for (uint i = 0; i < max_gens + 1; i++) {
     _last_cur_val_in_gen[i] = clean_card_val();
   }
 }
 
 CardTableRS::~CardTableRS() {
-  if (_last_cur_val_in_gen) {
-    FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);
-    _last_cur_val_in_gen = NULL;
-  }
-  if (_lowest_non_clean) {
-    FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);
-    _lowest_non_clean = NULL;
-  }
-  if (_lowest_non_clean_chunk_size) {
-    FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);
-    _lowest_non_clean_chunk_size = NULL;
-  }
-  if (_lowest_non_clean_base_chunk_index) {
-    FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);
-    _lowest_non_clean_base_chunk_index = NULL;
-  }
-  if (_last_LNC_resizing_collection) {
-    FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);
-    _last_LNC_resizing_collection = NULL;
-  }
+  FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);
+  FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);
+  FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);
+  FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);
+  FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);
 }
 
 void CardTableRS::initialize() {
   CardTable::initialize();
   _lowest_non_clean =
@@ -654,15 +601,11 @@
     NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
   _lowest_non_clean_base_chunk_index =
     NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
   _last_LNC_resizing_collection =
     NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);
-  if (_lowest_non_clean == NULL
-      || _lowest_non_clean_chunk_size == NULL
-      || _lowest_non_clean_base_chunk_index == NULL
-      || _last_LNC_resizing_collection == NULL)
-    vm_exit_during_initialization("couldn't allocate an LNC array.");
+
   for (int i = 0; i < _max_covered_regions; i++) {
     _lowest_non_clean[i] = NULL;
     _lowest_non_clean_chunk_size[i] = 0;
     _last_LNC_resizing_collection[i] = -1;
   }

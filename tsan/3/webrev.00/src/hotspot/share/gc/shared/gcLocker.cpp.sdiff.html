<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcLocker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcConfiguration.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcLocker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/gcLocker.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;

 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;runtime/thread.inline.hpp&quot;
 33 #include &quot;runtime/threadSMR.hpp&quot;
 34 
 35 volatile jint GCLocker::_jni_lock_count = 0;
 36 volatile bool GCLocker::_needs_gc       = false;
 37 volatile bool GCLocker::_doing_gc       = false;

 38 
 39 #ifdef ASSERT
 40 volatile jint GCLocker::_debug_jni_lock_count = 0;
 41 #endif
 42 
 43 
 44 #ifdef ASSERT
 45 void GCLocker::verify_critical_count() {
 46   if (SafepointSynchronize::is_at_safepoint()) {
 47     assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, &quot;must agree&quot;);
 48     int count = 0;
 49     // Count the number of threads with critical operations in progress
 50     JavaThreadIteratorWithHandle jtiwh;
 51     for (; JavaThread *thr = jtiwh.next(); ) {
 52       if (thr-&gt;in_critical()) {
 53         count++;
 54       }
 55     }
 56     if (_jni_lock_count != count) {
 57       log_error(gc, verify)(&quot;critical counts don&#39;t match: %d != %d&quot;, _jni_lock_count, count);
</pre>
<hr />
<pre>
 85     log.debug(&quot;%s Thread \&quot;%s\&quot; %d locked.&quot;, msg, Thread::current()-&gt;name(), _jni_lock_count);
 86   }
 87 }
 88 
 89 bool GCLocker::is_at_safepoint() {
 90   return SafepointSynchronize::is_at_safepoint();
 91 }
 92 
 93 bool GCLocker::check_active_before_gc() {
 94   assert(SafepointSynchronize::is_at_safepoint(), &quot;only read at safepoint&quot;);
 95   if (is_active() &amp;&amp; !_needs_gc) {
 96     verify_critical_count();
 97     _needs_gc = true;
 98     log_debug_jni(&quot;Setting _needs_gc.&quot;);
 99   }
100   return is_active();
101 }
102 
103 void GCLocker::stall_until_clear() {
104   assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
<span class="line-modified">105   MutexLocker   ml(JNICritical_lock);</span>
106 
107   if (needs_gc()) {
108     log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
109   }
110 
111   // Wait for _needs_gc  to be cleared
112   while (needs_gc()) {
<span class="line-modified">113     JNICritical_lock-&gt;wait();</span>
114   }
115 }
116 





117 void GCLocker::jni_lock(JavaThread* thread) {
118   assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
<span class="line-modified">119   MutexLocker mu(JNICritical_lock);</span>
120   // Block entering threads if we know at least one thread is in a
121   // JNI critical region and we need a GC.
122   // We check that at least one thread is in a critical region before
123   // blocking because blocked threads are woken up by a thread exiting
124   // a JNI critical region.
125   while (is_active_and_needs_gc() || _doing_gc) {
<span class="line-modified">126     JNICritical_lock-&gt;wait();</span>
127   }
128   thread-&gt;enter_critical();
129   _jni_lock_count++;
130   increment_debug_jni_lock_count();
131 }
132 
133 void GCLocker::jni_unlock(JavaThread* thread) {
134   assert(thread-&gt;in_last_critical(), &quot;should be exiting critical region&quot;);
135   MutexLocker mu(JNICritical_lock);
136   _jni_lock_count--;
137   decrement_debug_jni_lock_count();
138   thread-&gt;exit_critical();
139   if (needs_gc() &amp;&amp; !is_active_internal()) {
<span class="line-modified">140     // We&#39;re the last thread out. Cause a GC to occur.</span>






141     _doing_gc = true;
142     {
143       // Must give up the lock while at a safepoint
144       MutexUnlocker munlock(JNICritical_lock);
145       log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
146       Universe::heap()-&gt;collect(GCCause::_gc_locker);
147     }
148     _doing_gc = false;
149     _needs_gc = false;
150     JNICritical_lock-&gt;notify_all();
151   }
152 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/gcLocker.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 29 #include &quot;memory/universe.hpp&quot;</span>
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/thread.inline.hpp&quot;
 34 #include &quot;runtime/threadSMR.hpp&quot;
 35 
 36 volatile jint GCLocker::_jni_lock_count = 0;
 37 volatile bool GCLocker::_needs_gc       = false;
 38 volatile bool GCLocker::_doing_gc       = false;
<span class="line-added"> 39 unsigned int GCLocker::_total_collections = 0;</span>
 40 
 41 #ifdef ASSERT
 42 volatile jint GCLocker::_debug_jni_lock_count = 0;
 43 #endif
 44 
 45 
 46 #ifdef ASSERT
 47 void GCLocker::verify_critical_count() {
 48   if (SafepointSynchronize::is_at_safepoint()) {
 49     assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, &quot;must agree&quot;);
 50     int count = 0;
 51     // Count the number of threads with critical operations in progress
 52     JavaThreadIteratorWithHandle jtiwh;
 53     for (; JavaThread *thr = jtiwh.next(); ) {
 54       if (thr-&gt;in_critical()) {
 55         count++;
 56       }
 57     }
 58     if (_jni_lock_count != count) {
 59       log_error(gc, verify)(&quot;critical counts don&#39;t match: %d != %d&quot;, _jni_lock_count, count);
</pre>
<hr />
<pre>
 87     log.debug(&quot;%s Thread \&quot;%s\&quot; %d locked.&quot;, msg, Thread::current()-&gt;name(), _jni_lock_count);
 88   }
 89 }
 90 
 91 bool GCLocker::is_at_safepoint() {
 92   return SafepointSynchronize::is_at_safepoint();
 93 }
 94 
 95 bool GCLocker::check_active_before_gc() {
 96   assert(SafepointSynchronize::is_at_safepoint(), &quot;only read at safepoint&quot;);
 97   if (is_active() &amp;&amp; !_needs_gc) {
 98     verify_critical_count();
 99     _needs_gc = true;
100     log_debug_jni(&quot;Setting _needs_gc.&quot;);
101   }
102   return is_active();
103 }
104 
105 void GCLocker::stall_until_clear() {
106   assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
<span class="line-modified">107   MonitorLocker ml(JNICritical_lock);</span>
108 
109   if (needs_gc()) {
110     log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
111   }
112 
113   // Wait for _needs_gc  to be cleared
114   while (needs_gc()) {
<span class="line-modified">115     ml.wait();</span>
116   }
117 }
118 
<span class="line-added">119 bool GCLocker::should_discard(GCCause::Cause cause, uint total_collections) {</span>
<span class="line-added">120   return (cause == GCCause::_gc_locker) &amp;&amp;</span>
<span class="line-added">121          (_total_collections != total_collections);</span>
<span class="line-added">122 }</span>
<span class="line-added">123 </span>
124 void GCLocker::jni_lock(JavaThread* thread) {
125   assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
<span class="line-modified">126   MonitorLocker ml(JNICritical_lock);</span>
127   // Block entering threads if we know at least one thread is in a
128   // JNI critical region and we need a GC.
129   // We check that at least one thread is in a critical region before
130   // blocking because blocked threads are woken up by a thread exiting
131   // a JNI critical region.
132   while (is_active_and_needs_gc() || _doing_gc) {
<span class="line-modified">133     ml.wait();</span>
134   }
135   thread-&gt;enter_critical();
136   _jni_lock_count++;
137   increment_debug_jni_lock_count();
138 }
139 
140 void GCLocker::jni_unlock(JavaThread* thread) {
141   assert(thread-&gt;in_last_critical(), &quot;should be exiting critical region&quot;);
142   MutexLocker mu(JNICritical_lock);
143   _jni_lock_count--;
144   decrement_debug_jni_lock_count();
145   thread-&gt;exit_critical();
146   if (needs_gc() &amp;&amp; !is_active_internal()) {
<span class="line-modified">147     // We&#39;re the last thread out. Request a GC.</span>
<span class="line-added">148     // Capture the current total collections, to allow detection of</span>
<span class="line-added">149     // other collections that make this one unnecessary.  The value of</span>
<span class="line-added">150     // total_collections() is only changed at a safepoint, so there</span>
<span class="line-added">151     // must not be a safepoint between the lock becoming inactive and</span>
<span class="line-added">152     // getting the count, else there may be unnecessary GCLocker GCs.</span>
<span class="line-added">153     _total_collections = Universe::heap()-&gt;total_collections();</span>
154     _doing_gc = true;
155     {
156       // Must give up the lock while at a safepoint
157       MutexUnlocker munlock(JNICritical_lock);
158       log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
159       Universe::heap()-&gt;collect(GCCause::_gc_locker);
160     }
161     _doing_gc = false;
162     _needs_gc = false;
163     JNICritical_lock-&gt;notify_all();
164   }
165 }
</pre>
</td>
</tr>
</table>
<center><a href="gcConfiguration.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
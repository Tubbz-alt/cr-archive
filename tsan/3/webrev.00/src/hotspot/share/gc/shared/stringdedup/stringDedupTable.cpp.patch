diff a/src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp b/src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp
--- a/src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp
+++ b/src/hotspot/share/gc/shared/stringdedup/stringDedupTable.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -28,16 +28,19 @@
 #include "gc/shared/stringdedup/stringDedup.hpp"
 #include "gc/shared/stringdedup/stringDedupTable.hpp"
 #include "gc/shared/suspendibleThreadSet.hpp"
 #include "logging/log.hpp"
 #include "memory/padded.inline.hpp"
+#include "memory/universe.hpp"
 #include "oops/access.inline.hpp"
 #include "oops/arrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/typeArrayOop.hpp"
+#include "runtime/atomic.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "runtime/safepointVerifiers.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 //
 // List of deduplication table entries. Links table
 // entries together using their _next fields.
 //
@@ -211,11 +214,11 @@
 const double             StringDedupTable::_max_cache_factor = 0.1; // Cache a maximum of 10% of the table size
 const uintx              StringDedupTable::_rehash_multiple = 60;   // Hash bucket has 60 times more collisions than expected
 const uintx              StringDedupTable::_rehash_threshold = (uintx)(_rehash_multiple * _grow_load_factor);
 
 uintx                    StringDedupTable::_entries_added = 0;
-uintx                    StringDedupTable::_entries_removed = 0;
+volatile uintx           StringDedupTable::_entries_removed = 0;
 uintx                    StringDedupTable::_resize_count = 0;
 uintx                    StringDedupTable::_rehash_count = 0;
 
 StringDedupTable*        StringDedupTable::_resized_table = NULL;
 StringDedupTable*        StringDedupTable::_rehashed_table = NULL;
@@ -232,11 +235,11 @@
   _buckets = NEW_C_HEAP_ARRAY(StringDedupEntry*, _size, mtGC);
   memset(_buckets, 0, _size * sizeof(StringDedupEntry*));
 }
 
 StringDedupTable::~StringDedupTable() {
-  FREE_C_HEAP_ARRAY(G1StringDedupEntry*, _buckets);
+  FREE_C_HEAP_ARRAY(StringDedupEntry*, _buckets);
 }
 
 void StringDedupTable::create() {
   assert(_table == NULL, "One string deduplication table allowed");
   _entry_cache = new StringDedupEntryCache(_min_size * _max_cache_factor);
@@ -349,27 +352,22 @@
 
   bool latin1 = java_lang_String::is_latin1(java_string);
   unsigned int hash = 0;
 
   if (use_java_hash()) {
-    // Get hash code from cache
-    hash = java_lang_String::hash(java_string);
-  }
-
-  if (hash == 0) {
+    if (!java_lang_String::hash_is_set(java_string)) {
+      stat->inc_hashed();
+    }
+    hash = java_lang_String::hash_code(java_string);
+  } else {
     // Compute hash
     hash = hash_code(value, latin1);
     stat->inc_hashed();
-
-    if (use_java_hash() && hash != 0) {
-      // Store hash code in cache
-      java_lang_String::set_hash(java_string, hash);
-    }
   }
 
   typeArrayOop existing_value = lookup_or_add(value, latin1, hash);
-  if (oopDesc::equals_raw(existing_value, value)) {
+  if (existing_value == value) {
     // Same value, already known
     stat->inc_known();
     return;
   }
 
@@ -478,15 +476,17 @@
     // Scan the partition followed by the sibling partition in the second half of the table
     removed += unlink_or_oops_do(cl, partition_begin, partition_end, worker_id);
     removed += unlink_or_oops_do(cl, table_half + partition_begin, table_half + partition_end, worker_id);
   }
 
-  // Delayed update to avoid contention on the table lock
+  // Do atomic update here instead of taking StringDedupTable_lock. This allows concurrent
+  // cleanup when multiple workers are cleaning up the table, while the mutators are blocked
+  // on StringDedupTable_lock.
   if (removed > 0) {
-    MutexLockerEx ml(StringDedupTable_lock, Mutex::_no_safepoint_check_flag);
-    _table->_entries -= removed;
-    _entries_removed += removed;
+    assert_locked_or_safepoint_weak(StringDedupTable_lock);
+    Atomic::sub(&_table->_entries, removed);
+    Atomic::add(&_entries_removed, removed);
   }
 }
 
 uintx StringDedupTable::unlink_or_oops_do(StringDedupUnlinkOrOopsDoClosure* cl,
                                           size_t partition_begin,
@@ -591,21 +591,21 @@
   // Install new table
   _table = rehashed_table;
 }
 
 size_t StringDedupTable::claim_table_partition(size_t partition_size) {
-  return Atomic::add(partition_size, &_claimed_index) - partition_size;
+  return Atomic::fetch_and_add(&_claimed_index, partition_size);
 }
 
 void StringDedupTable::verify() {
   for (size_t bucket = 0; bucket < _table->_size; bucket++) {
     // Verify entries
     StringDedupEntry** entry = _table->bucket(bucket);
     while (*entry != NULL) {
       typeArrayOop value = (*entry)->obj();
       guarantee(value != NULL, "Object must not be NULL");
-      guarantee(Universe::heap()->is_in_reserved(value), "Object must be on the heap");
+      guarantee(Universe::heap()->is_in(value), "Object must be on the heap");
       guarantee(!value->is_forwarded(), "Object must not be forwarded");
       guarantee(value->is_typeArray(), "Object must be a typeArrayOop");
       bool latin1 = (*entry)->latin1();
       unsigned int hash = hash_code(value, latin1);
       guarantee((*entry)->hash() == hash, "Table entry has inorrect hash");

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/space.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SPACE_INLINE_HPP
 26 #define SHARE_GC_SHARED_SPACE_INLINE_HPP
 27 
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/space.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;oops/oopsHierarchy.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/prefetch.inline.hpp&quot;
 37 #include &quot;runtime/safepoint.hpp&quot;
 38 #if INCLUDE_SERIALGC
 39 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 40 #endif
 41 
 42 inline HeapWord* Space::block_start(const void* p) {
 43   return block_start_const(p);
 44 }
 45 
 46 inline HeapWord* OffsetTableContigSpace::allocate(size_t size) {
 47   HeapWord* res = ContiguousSpace::allocate(size);
 48   if (res != NULL) {
 49     _offsets.alloc_block(res, size);
 50   }
 51   return res;
 52 }
 53 
 54 // Because of the requirement of keeping &quot;_offsets&quot; up to date with the
 55 // allocations, we sequentialize these with a lock.  Therefore, best if
 56 // this is used for larger LAB allocations only.
 57 inline HeapWord* OffsetTableContigSpace::par_allocate(size_t size) {
 58   MutexLocker x(&amp;_par_alloc_lock);
 59   // This ought to be just &quot;allocate&quot;, because of the lock above, but that
 60   // ContiguousSpace::allocate asserts that either the allocating thread
 61   // holds the heap lock or it is the VM thread and we&#39;re at a safepoint.
 62   // The best I (dld) could figure was to put a field in ContiguousSpace
 63   // meaning &quot;locking at safepoint taken care of&quot;, and set/reset that
 64   // here.  But this will do for now, especially in light of the comment
 65   // above.  Perhaps in the future some lock-free manner of keeping the
 66   // coordination.
 67   HeapWord* res = ContiguousSpace::par_allocate(size);
 68   if (res != NULL) {
 69     _offsets.alloc_block(res, size);
 70   }
 71   return res;
 72 }
 73 
 74 inline HeapWord*
 75 OffsetTableContigSpace::block_start_const(const void* p) const {
 76   return _offsets.block_start(p);
 77 }
 78 
 79 size_t CompactibleSpace::obj_size(const HeapWord* addr) const {
 80   return oop(addr)-&gt;size();
 81 }
 82 
 83 #if INCLUDE_SERIALGC
 84 
 85 class DeadSpacer : StackObj {
 86   size_t _allowed_deadspace_words;
 87   bool _active;
 88   CompactibleSpace* _space;
 89 
 90 public:
 91   DeadSpacer(CompactibleSpace* space) : _allowed_deadspace_words(0), _space(space) {
 92     size_t ratio = _space-&gt;allowed_dead_ratio();
 93     _active = ratio &gt; 0;
 94 
 95     if (_active) {
 96       assert(!UseG1GC, &quot;G1 should not be using dead space&quot;);
 97 
 98       // We allow some amount of garbage towards the bottom of the space, so
 99       // we don&#39;t start compacting before there is a significant gain to be made.
100       // Occasionally, we want to ensure a full compaction, which is determined
101       // by the MarkSweepAlwaysCompactCount parameter.
102       if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {
103         _allowed_deadspace_words = (space-&gt;capacity() * ratio / 100) / HeapWordSize;
104       } else {
105         _active = false;
106       }
107     }
108   }
109 
110 
111   bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {
112     if (!_active) {
113       return false;
114     }
115 
116     size_t dead_length = pointer_delta(dead_end, dead_start);
117     if (_allowed_deadspace_words &gt;= dead_length) {
118       _allowed_deadspace_words -= dead_length;
119       CollectedHeap::fill_with_object(dead_start, dead_length);
120       oop obj = oop(dead_start);
<a name="2" id="anc2"></a><span class="line-modified">121       obj-&gt;set_mark_raw(obj-&gt;mark_raw()-&gt;set_marked());</span>
122 
123       assert(dead_length == (size_t)obj-&gt;size(), &quot;bad filler object size&quot;);
124       log_develop_trace(gc, compaction)(&quot;Inserting object to dead space: &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT &quot;b&quot;,
125           p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);
126 
127       return true;
128     } else {
129       _active = false;
130       return false;
131     }
132   }
133 
134 };
135 
136 template &lt;class SpaceType&gt;
137 inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
138   // Compute the new addresses for the live objects and store it in the mark
139   // Used by universe::mark_sweep_phase2()
140 
141   // We&#39;re sure to be here before any objects are compacted into this
142   // space, so this is a good time to initialize this:
143   space-&gt;set_compaction_top(space-&gt;bottom());
144 
145   if (cp-&gt;space == NULL) {
146     assert(cp-&gt;gen != NULL, &quot;need a generation&quot;);
147     assert(cp-&gt;threshold == NULL, &quot;just checking&quot;);
148     assert(cp-&gt;gen-&gt;first_compaction_space() == space, &quot;just checking&quot;);
149     cp-&gt;space = cp-&gt;gen-&gt;first_compaction_space();
150     cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
151     cp-&gt;space-&gt;set_compaction_top(cp-&gt;space-&gt;bottom());
152   }
153 
154   HeapWord* compact_top = cp-&gt;space-&gt;compaction_top(); // This is where we are currently compacting to.
155 
156   DeadSpacer dead_spacer(space);
157 
158   HeapWord*  end_of_live = space-&gt;bottom();  // One byte beyond the last byte of the last live object.
159   HeapWord*  first_dead = NULL; // The first dead object.
160 
161   const intx interval = PrefetchScanIntervalInBytes;
162 
163   HeapWord* cur_obj = space-&gt;bottom();
164   HeapWord* scan_limit = space-&gt;scan_limit();
165 
166   while (cur_obj &lt; scan_limit) {
167     assert(!space-&gt;scanned_block_is_obj(cur_obj) ||
<a name="3" id="anc3"></a><span class="line-modified">168            oop(cur_obj)-&gt;mark_raw()-&gt;is_marked() || oop(cur_obj)-&gt;mark_raw()-&gt;is_unlocked() ||</span>
<span class="line-modified">169            oop(cur_obj)-&gt;mark_raw()-&gt;has_bias_pattern(),</span>
170            &quot;these are the only valid states during a mark sweep&quot;);
171     if (space-&gt;scanned_block_is_obj(cur_obj) &amp;&amp; oop(cur_obj)-&gt;is_gc_marked()) {
172       // prefetch beyond cur_obj
173       Prefetch::write(cur_obj, interval);
174       size_t size = space-&gt;scanned_block_size(cur_obj);
175       compact_top = cp-&gt;space-&gt;forward(oop(cur_obj), size, cp, compact_top);
176       cur_obj += size;
177       end_of_live = cur_obj;
178     } else {
179       // run over all the contiguous dead objects
180       HeapWord* end = cur_obj;
181       do {
182         // prefetch beyond end
183         Prefetch::write(end, interval);
184         end += space-&gt;scanned_block_size(end);
185       } while (end &lt; scan_limit &amp;&amp; (!space-&gt;scanned_block_is_obj(end) || !oop(end)-&gt;is_gc_marked()));
186 
187       // see if we might want to pretend this object is alive so that
188       // we don&#39;t have to compact quite as often.
189       if (cur_obj == compact_top &amp;&amp; dead_spacer.insert_deadspace(cur_obj, end)) {
190         oop obj = oop(cur_obj);
191         compact_top = cp-&gt;space-&gt;forward(obj, obj-&gt;size(), cp, compact_top);
192         end_of_live = end;
193       } else {
194         // otherwise, it really is a free region.
195 
196         // cur_obj is a pointer to a dead object. Use this dead memory to store a pointer to the next live object.
197         *(HeapWord**)cur_obj = end;
198 
199         // see if this is the first dead region.
200         if (first_dead == NULL) {
201           first_dead = cur_obj;
202         }
203       }
204 
205       // move on to the next object
206       cur_obj = end;
207     }
208   }
209 
210   assert(cur_obj == scan_limit, &quot;just checking&quot;);
211   space-&gt;_end_of_live = end_of_live;
212   if (first_dead != NULL) {
213     space-&gt;_first_dead = first_dead;
214   } else {
215     space-&gt;_first_dead = end_of_live;
216   }
217 
218   // save the compaction_top of the compaction space.
219   cp-&gt;space-&gt;set_compaction_top(compact_top);
220 }
221 
222 template &lt;class SpaceType&gt;
223 inline void CompactibleSpace::scan_and_adjust_pointers(SpaceType* space) {
224   // adjust all the interior pointers to point at the new locations of objects
225   // Used by MarkSweep::mark_sweep_phase3()
226 
227   HeapWord* cur_obj = space-&gt;bottom();
228   HeapWord* const end_of_live = space-&gt;_end_of_live;  // Established by &quot;scan_and_forward&quot;.
229   HeapWord* const first_dead = space-&gt;_first_dead;    // Established by &quot;scan_and_forward&quot;.
230 
231   assert(first_dead &lt;= end_of_live, &quot;Stands to reason, no?&quot;);
232 
233   const intx interval = PrefetchScanIntervalInBytes;
234 
235   debug_only(HeapWord* prev_obj = NULL);
236   while (cur_obj &lt; end_of_live) {
237     Prefetch::write(cur_obj, interval);
238     if (cur_obj &lt; first_dead || oop(cur_obj)-&gt;is_gc_marked()) {
239       // cur_obj is alive
240       // point all the oops to the new location
241       size_t size = MarkSweep::adjust_pointers(oop(cur_obj));
242       size = space-&gt;adjust_obj_size(size);
243       debug_only(prev_obj = cur_obj);
244       cur_obj += size;
245     } else {
246       debug_only(prev_obj = cur_obj);
247       // cur_obj is not a live object, instead it points at the next live object
248       cur_obj = *(HeapWord**)cur_obj;
249       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory, cur_obj: &quot; PTR_FORMAT &quot;, prev_obj: &quot; PTR_FORMAT, p2i(cur_obj), p2i(prev_obj));
250     }
251   }
252 
253   assert(cur_obj == end_of_live, &quot;just checking&quot;);
254 }
255 
256 #ifdef ASSERT
257 template &lt;class SpaceType&gt;
258 inline void CompactibleSpace::verify_up_to_first_dead(SpaceType* space) {
259   HeapWord* cur_obj = space-&gt;bottom();
260 
261   if (cur_obj &lt; space-&gt;_end_of_live &amp;&amp; space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
262      // we have a chunk of the space which hasn&#39;t moved and we&#39;ve reinitialized
263      // the mark word during the previous pass, so we can&#39;t use is_gc_marked for
264      // the traversal.
265      HeapWord* prev_obj = NULL;
266 
267      while (cur_obj &lt; space-&gt;_first_dead) {
268        size_t size = space-&gt;obj_size(cur_obj);
269        assert(!oop(cur_obj)-&gt;is_gc_marked(), &quot;should be unmarked (special dense prefix handling)&quot;);
270        prev_obj = cur_obj;
271        cur_obj += size;
272      }
273   }
274 }
275 #endif
276 
277 template &lt;class SpaceType&gt;
278 inline void CompactibleSpace::clear_empty_region(SpaceType* space) {
279   // Let&#39;s remember if we were empty before we did the compaction.
280   bool was_empty = space-&gt;used_region().is_empty();
281   // Reset space after compaction is complete
282   space-&gt;reset_after_compaction();
283   // We do this clear, below, since it has overloaded meanings for some
284   // space subtypes.  For example, OffsetTableContigSpace&#39;s that were
285   // compacted into will have had their offset table thresholds updated
286   // continuously, but those that weren&#39;t need to have their thresholds
287   // re-initialized.  Also mangles unused area for debugging.
288   if (space-&gt;used_region().is_empty()) {
289     if (!was_empty) space-&gt;clear(SpaceDecorator::Mangle);
290   } else {
291     if (ZapUnusedHeapArea) space-&gt;mangle_unused_area();
292   }
293 }
294 
295 template &lt;class SpaceType&gt;
296 inline void CompactibleSpace::scan_and_compact(SpaceType* space) {
297   // Copy all live objects to their new location
298   // Used by MarkSweep::mark_sweep_phase4()
299 
300   verify_up_to_first_dead(space);
301 
302   HeapWord* const bottom = space-&gt;bottom();
303   HeapWord* const end_of_live = space-&gt;_end_of_live;
304 
305   assert(space-&gt;_first_dead &lt;= end_of_live, &quot;Invariant. _first_dead: &quot; PTR_FORMAT &quot; &lt;= end_of_live: &quot; PTR_FORMAT, p2i(space-&gt;_first_dead), p2i(end_of_live));
306   if (space-&gt;_first_dead == end_of_live &amp;&amp; (bottom == end_of_live || !oop(bottom)-&gt;is_gc_marked())) {
307     // Nothing to compact. The space is either empty or all live object should be left in place.
308     clear_empty_region(space);
309     return;
310   }
311 
312   const intx scan_interval = PrefetchScanIntervalInBytes;
313   const intx copy_interval = PrefetchCopyIntervalInBytes;
314 
315   assert(bottom &lt; end_of_live, &quot;bottom: &quot; PTR_FORMAT &quot; should be &lt; end_of_live: &quot; PTR_FORMAT, p2i(bottom), p2i(end_of_live));
316   HeapWord* cur_obj = bottom;
317   if (space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
318     // All object before _first_dead can be skipped. They should not be moved.
319     // A pointer to the first live object is stored at the memory location for _first_dead.
320     cur_obj = *(HeapWord**)(space-&gt;_first_dead);
321   }
322 
323   debug_only(HeapWord* prev_obj = NULL);
324   while (cur_obj &lt; end_of_live) {
325     if (!oop(cur_obj)-&gt;is_gc_marked()) {
326       debug_only(prev_obj = cur_obj);
327       // The first word of the dead object contains a pointer to the next live object or end of space.
328       cur_obj = *(HeapWord**)cur_obj;
329       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory&quot;);
330     } else {
331       // prefetch beyond q
332       Prefetch::read(cur_obj, scan_interval);
333 
334       // size and destination
335       size_t size = space-&gt;obj_size(cur_obj);
<a name="4" id="anc4"></a><span class="line-modified">336       HeapWord* compaction_top = (HeapWord*)oop(cur_obj)-&gt;forwardee();</span>
337 
338       // prefetch beyond compaction_top
339       Prefetch::write(compaction_top, copy_interval);
340 
341       // copy object and reinit its mark
342       assert(cur_obj != compaction_top, &quot;everything in this pass should be moving&quot;);
343       Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
344       oop(compaction_top)-&gt;init_mark_raw();
345       assert(oop(compaction_top)-&gt;klass() != NULL, &quot;should have a class&quot;);
346 
347       debug_only(prev_obj = cur_obj);
348       cur_obj += size;
349     }
350   }
351 
352   clear_empty_region(space);
353 }
354 
355 #endif // INCLUDE_SERIALGC
356 
357 size_t ContiguousSpace::scanned_block_size(const HeapWord* addr) const {
358   return oop(addr)-&gt;size();
359 }
360 
361 template &lt;typename OopClosureType&gt;
362 void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {
363   HeapWord* t;
364   HeapWord* p = saved_mark_word();
365   assert(p != NULL, &quot;expected saved mark&quot;);
366 
367   const intx interval = PrefetchScanIntervalInBytes;
368   do {
369     t = top();
370     while (p &lt; t) {
371       Prefetch::write(p, interval);
372       debug_only(HeapWord* prev = p);
373       oop m = oop(p);
374       p += m-&gt;oop_iterate_size(blk);
375     }
376   } while (t &lt; top());
377 
378   set_saved_mark_word(p);
379 }
380 
<a name="5" id="anc5"></a><span class="line-removed">381 template &lt;typename OopClosureType&gt;</span>
<span class="line-removed">382 void ContiguousSpace::par_oop_iterate(MemRegion mr, OopClosureType* blk) {</span>
<span class="line-removed">383   HeapWord* obj_addr = mr.start();</span>
<span class="line-removed">384   HeapWord* limit = mr.end();</span>
<span class="line-removed">385   while (obj_addr &lt; limit) {</span>
<span class="line-removed">386     assert(oopDesc::is_oop(oop(obj_addr)), &quot;Should be an oop&quot;);</span>
<span class="line-removed">387     obj_addr += oop(obj_addr)-&gt;oop_iterate_size(blk);</span>
<span class="line-removed">388   }</span>
<span class="line-removed">389 }</span>
<span class="line-removed">390 </span>
391 #endif // SHARE_GC_SHARED_SPACE_INLINE_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
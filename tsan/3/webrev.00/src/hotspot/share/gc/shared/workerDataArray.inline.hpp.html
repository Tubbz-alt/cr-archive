<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/workerDataArray.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 26 #define SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 27 
 28 #include &quot;gc/shared/workerDataArray.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 template &lt;typename T&gt;
 33 WorkerDataArray&lt;T&gt;::WorkerDataArray(const char* title, uint length, bool is_serial) :
 34  _data(NULL),
 35  _length(length),
 36  _title(title),
 37  _is_serial(is_serial) {
 38   assert(length &gt; 0, &quot;Must have some workers to store data for&quot;);
 39   assert(!is_serial || length == 1, &quot;Serial phase must only have a single entry.&quot;);
 40   _data = NEW_C_HEAP_ARRAY(T, _length, mtGC);
 41   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 42     _thread_work_items[i] = NULL;
 43   }
 44   reset();
 45 }
 46 
 47 template &lt;typename T&gt;
 48 void WorkerDataArray&lt;T&gt;::set(uint worker_i, T value) {
 49   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 50   assert(_data[worker_i] == uninitialized(), &quot;Overwriting data for worker %d in %s&quot;, worker_i, _title);
 51   _data[worker_i] = value;
 52 }
 53 
 54 template &lt;typename T&gt;
 55 T WorkerDataArray&lt;T&gt;::get(uint worker_i) const {
 56   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 57   return _data[worker_i];
 58 }
 59 
 60 template &lt;typename T&gt;
 61 WorkerDataArray&lt;T&gt;::~WorkerDataArray() {
 62   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 63     delete _thread_work_items[i];
 64   }
 65   FREE_C_HEAP_ARRAY(T, _data);
 66 }
 67 
 68 template &lt;typename T&gt;
 69 void WorkerDataArray&lt;T&gt;::create_thread_work_items(const char* title, uint index, uint length_override) {
 70   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 71   assert(_thread_work_items[index] == NULL, &quot;Tried to overwrite existing thread work item&quot;);
 72   uint length = length_override != 0 ? length_override : _length;
 73   _thread_work_items[index] = new WorkerDataArray&lt;size_t&gt;(title, length);
 74 }
 75 
 76 template &lt;typename T&gt;
 77 void WorkerDataArray&lt;T&gt;::set_thread_work_item(uint worker_i, size_t value, uint index) {
 78   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 79   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 80   _thread_work_items[index]-&gt;set(worker_i, value);
 81 }
 82 
 83 template &lt;typename T&gt;
 84 void WorkerDataArray&lt;T&gt;::add_thread_work_item(uint worker_i, size_t value, uint index) {
 85   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 86   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 87   _thread_work_items[index]-&gt;add(worker_i, value);
 88 }
 89 
 90 template &lt;typename T&gt;
 91 void WorkerDataArray&lt;T&gt;::set_or_add_thread_work_item(uint worker_i, size_t value, uint index) {
 92   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 93   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 94   if (_thread_work_items[index]-&gt;get(worker_i) == _thread_work_items[index]-&gt;uninitialized()) {
 95     _thread_work_items[index]-&gt;set(worker_i, value);
 96   } else {
 97     _thread_work_items[index]-&gt;add(worker_i, value);
 98   }
 99 }
100 
101 template &lt;typename T&gt;
102 size_t WorkerDataArray&lt;T&gt;::get_thread_work_item(uint worker_i, uint index) {
103   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
104   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
105   return _thread_work_items[index]-&gt;get(worker_i);
106 }
107 
108 template &lt;typename T&gt;
109 void WorkerDataArray&lt;T&gt;::add(uint worker_i, T value) {
110   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
111   assert(_data[worker_i] != uninitialized(), &quot;No data to add to %s for worker %d&quot;, _title, worker_i);
112   _data[worker_i] += value;
113 }
114 
115 template &lt;typename T&gt;
116 double WorkerDataArray&lt;T&gt;::average() const {
117   uint contributing_threads = 0;
118   for (uint i = 0; i &lt; _length; ++i) {
119     if (get(i) != uninitialized()) {
120       contributing_threads++;
121     }
122   }
123   if (contributing_threads == 0) {
124     return 0.0;
125   }
126   return sum() / (double) contributing_threads;
127 }
128 
129 template &lt;typename T&gt;
130 T WorkerDataArray&lt;T&gt;::sum() const {
131   T s = 0;
132   for (uint i = 0; i &lt; _length; ++i) {
133     if (get(i) != uninitialized()) {
134       s += get(i);
135     }
136   }
137   return s;
138 }
139 
140 template &lt;typename T&gt;
141 void WorkerDataArray&lt;T&gt;::set_all(T value) {
142   for (uint i = 0; i &lt; _length; i++) {
143     _data[i] = value;
144   }
145 }
146 
147 template &lt;class T&gt;
148 void WorkerDataArray&lt;T&gt;::print_summary_on(outputStream* out, bool print_sum) const {
149   if (_is_serial) {
150     out-&gt;print(&quot;%s:&quot;, title());
151   } else {
152     out-&gt;print(&quot;%-25s&quot;, title());
153   }
154 
155   uint start = 0;
156   while (start &lt; _length &amp;&amp; get(start) == uninitialized()) {
157     start++;
158   }
159   if (start &lt; _length) {
160     if (_is_serial) {
161       WDAPrinter::summary(out, get(0));
162     } else {
163       T min = get(start);
164       T max = min;
165       T sum = 0;
166       uint contributing_threads = 0;
167       for (uint i = start; i &lt; _length; ++i) {
168         T value = get(i);
169         if (value != uninitialized()) {
170           max = MAX2(max, value);
171           min = MIN2(min, value);
172           sum += value;
173           contributing_threads++;
174         }
175       }
176       T diff = max - min;
177       assert(contributing_threads != 0, &quot;Must be since we found a used value for the start index&quot;);
178       double avg = sum / (double) contributing_threads;
179       WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);
180       out-&gt;print_cr(&quot;, Workers: %d&quot;, contributing_threads);
181     }
182   } else {
183     // No data for this phase.
184     out-&gt;print_cr(&quot; skipped&quot;);
185   }
186 }
187 
188 template &lt;class T&gt;
189 void WorkerDataArray&lt;T&gt;::print_details_on(outputStream* out) const {
190   WDAPrinter::details(this, out);
191 }
192 
193 template &lt;typename T&gt;
194 void WorkerDataArray&lt;T&gt;::reset() {
195   set_all(uninitialized());
196   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
197     if (_thread_work_items[i] != NULL) {
198       _thread_work_items[i]-&gt;reset();
199     }
200   }
201 }
202 
203 #endif // SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
    </pre>
  </body>
</html>
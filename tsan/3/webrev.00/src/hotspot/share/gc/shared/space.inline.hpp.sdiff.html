<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/space.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="space.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="spaceDecorator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/space.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SPACE_INLINE_HPP
 26 #define SHARE_GC_SHARED_SPACE_INLINE_HPP
 27 
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/space.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;
<span class="line-removed"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;oops/oopsHierarchy.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;runtime/prefetch.inline.hpp&quot;
 37 #include &quot;runtime/safepoint.hpp&quot;
 38 #if INCLUDE_SERIALGC
 39 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 40 #endif
 41 
 42 inline HeapWord* Space::block_start(const void* p) {
 43   return block_start_const(p);
 44 }
 45 
 46 inline HeapWord* OffsetTableContigSpace::allocate(size_t size) {
 47   HeapWord* res = ContiguousSpace::allocate(size);
 48   if (res != NULL) {
 49     _offsets.alloc_block(res, size);
 50   }
 51   return res;
 52 }
 53 
</pre>
<hr />
<pre>
101       // by the MarkSweepAlwaysCompactCount parameter.
102       if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {
103         _allowed_deadspace_words = (space-&gt;capacity() * ratio / 100) / HeapWordSize;
104       } else {
105         _active = false;
106       }
107     }
108   }
109 
110 
111   bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {
112     if (!_active) {
113       return false;
114     }
115 
116     size_t dead_length = pointer_delta(dead_end, dead_start);
117     if (_allowed_deadspace_words &gt;= dead_length) {
118       _allowed_deadspace_words -= dead_length;
119       CollectedHeap::fill_with_object(dead_start, dead_length);
120       oop obj = oop(dead_start);
<span class="line-modified">121       obj-&gt;set_mark_raw(obj-&gt;mark_raw()-&gt;set_marked());</span>
122 
123       assert(dead_length == (size_t)obj-&gt;size(), &quot;bad filler object size&quot;);
124       log_develop_trace(gc, compaction)(&quot;Inserting object to dead space: &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT &quot;b&quot;,
125           p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);
126 
127       return true;
128     } else {
129       _active = false;
130       return false;
131     }
132   }
133 
134 };
135 
136 template &lt;class SpaceType&gt;
137 inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
138   // Compute the new addresses for the live objects and store it in the mark
139   // Used by universe::mark_sweep_phase2()
140 
141   // We&#39;re sure to be here before any objects are compacted into this
</pre>
<hr />
<pre>
148     assert(cp-&gt;gen-&gt;first_compaction_space() == space, &quot;just checking&quot;);
149     cp-&gt;space = cp-&gt;gen-&gt;first_compaction_space();
150     cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
151     cp-&gt;space-&gt;set_compaction_top(cp-&gt;space-&gt;bottom());
152   }
153 
154   HeapWord* compact_top = cp-&gt;space-&gt;compaction_top(); // This is where we are currently compacting to.
155 
156   DeadSpacer dead_spacer(space);
157 
158   HeapWord*  end_of_live = space-&gt;bottom();  // One byte beyond the last byte of the last live object.
159   HeapWord*  first_dead = NULL; // The first dead object.
160 
161   const intx interval = PrefetchScanIntervalInBytes;
162 
163   HeapWord* cur_obj = space-&gt;bottom();
164   HeapWord* scan_limit = space-&gt;scan_limit();
165 
166   while (cur_obj &lt; scan_limit) {
167     assert(!space-&gt;scanned_block_is_obj(cur_obj) ||
<span class="line-modified">168            oop(cur_obj)-&gt;mark_raw()-&gt;is_marked() || oop(cur_obj)-&gt;mark_raw()-&gt;is_unlocked() ||</span>
<span class="line-modified">169            oop(cur_obj)-&gt;mark_raw()-&gt;has_bias_pattern(),</span>
170            &quot;these are the only valid states during a mark sweep&quot;);
171     if (space-&gt;scanned_block_is_obj(cur_obj) &amp;&amp; oop(cur_obj)-&gt;is_gc_marked()) {
172       // prefetch beyond cur_obj
173       Prefetch::write(cur_obj, interval);
174       size_t size = space-&gt;scanned_block_size(cur_obj);
175       compact_top = cp-&gt;space-&gt;forward(oop(cur_obj), size, cp, compact_top);
176       cur_obj += size;
177       end_of_live = cur_obj;
178     } else {
179       // run over all the contiguous dead objects
180       HeapWord* end = cur_obj;
181       do {
182         // prefetch beyond end
183         Prefetch::write(end, interval);
184         end += space-&gt;scanned_block_size(end);
185       } while (end &lt; scan_limit &amp;&amp; (!space-&gt;scanned_block_is_obj(end) || !oop(end)-&gt;is_gc_marked()));
186 
187       // see if we might want to pretend this object is alive so that
188       // we don&#39;t have to compact quite as often.
189       if (cur_obj == compact_top &amp;&amp; dead_spacer.insert_deadspace(cur_obj, end)) {
</pre>
<hr />
<pre>
316   HeapWord* cur_obj = bottom;
317   if (space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
318     // All object before _first_dead can be skipped. They should not be moved.
319     // A pointer to the first live object is stored at the memory location for _first_dead.
320     cur_obj = *(HeapWord**)(space-&gt;_first_dead);
321   }
322 
323   debug_only(HeapWord* prev_obj = NULL);
324   while (cur_obj &lt; end_of_live) {
325     if (!oop(cur_obj)-&gt;is_gc_marked()) {
326       debug_only(prev_obj = cur_obj);
327       // The first word of the dead object contains a pointer to the next live object or end of space.
328       cur_obj = *(HeapWord**)cur_obj;
329       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory&quot;);
330     } else {
331       // prefetch beyond q
332       Prefetch::read(cur_obj, scan_interval);
333 
334       // size and destination
335       size_t size = space-&gt;obj_size(cur_obj);
<span class="line-modified">336       HeapWord* compaction_top = (HeapWord*)oop(cur_obj)-&gt;forwardee();</span>
337 
338       // prefetch beyond compaction_top
339       Prefetch::write(compaction_top, copy_interval);
340 
341       // copy object and reinit its mark
342       assert(cur_obj != compaction_top, &quot;everything in this pass should be moving&quot;);
343       Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
344       oop(compaction_top)-&gt;init_mark_raw();
345       assert(oop(compaction_top)-&gt;klass() != NULL, &quot;should have a class&quot;);
346 
347       debug_only(prev_obj = cur_obj);
348       cur_obj += size;
349     }
350   }
351 
352   clear_empty_region(space);
353 }
354 
355 #endif // INCLUDE_SERIALGC
356 
</pre>
<hr />
<pre>
361 template &lt;typename OopClosureType&gt;
362 void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {
363   HeapWord* t;
364   HeapWord* p = saved_mark_word();
365   assert(p != NULL, &quot;expected saved mark&quot;);
366 
367   const intx interval = PrefetchScanIntervalInBytes;
368   do {
369     t = top();
370     while (p &lt; t) {
371       Prefetch::write(p, interval);
372       debug_only(HeapWord* prev = p);
373       oop m = oop(p);
374       p += m-&gt;oop_iterate_size(blk);
375     }
376   } while (t &lt; top());
377 
378   set_saved_mark_word(p);
379 }
380 
<span class="line-removed">381 template &lt;typename OopClosureType&gt;</span>
<span class="line-removed">382 void ContiguousSpace::par_oop_iterate(MemRegion mr, OopClosureType* blk) {</span>
<span class="line-removed">383   HeapWord* obj_addr = mr.start();</span>
<span class="line-removed">384   HeapWord* limit = mr.end();</span>
<span class="line-removed">385   while (obj_addr &lt; limit) {</span>
<span class="line-removed">386     assert(oopDesc::is_oop(oop(obj_addr)), &quot;Should be an oop&quot;);</span>
<span class="line-removed">387     obj_addr += oop(obj_addr)-&gt;oop_iterate_size(blk);</span>
<span class="line-removed">388   }</span>
<span class="line-removed">389 }</span>
<span class="line-removed">390 </span>
391 #endif // SHARE_GC_SHARED_SPACE_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SPACE_INLINE_HPP
 26 #define SHARE_GC_SHARED_SPACE_INLINE_HPP
 27 
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/space.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;

 33 #include &quot;oops/oopsHierarchy.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;runtime/safepoint.hpp&quot;
 37 #if INCLUDE_SERIALGC
 38 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 39 #endif
 40 
 41 inline HeapWord* Space::block_start(const void* p) {
 42   return block_start_const(p);
 43 }
 44 
 45 inline HeapWord* OffsetTableContigSpace::allocate(size_t size) {
 46   HeapWord* res = ContiguousSpace::allocate(size);
 47   if (res != NULL) {
 48     _offsets.alloc_block(res, size);
 49   }
 50   return res;
 51 }
 52 
</pre>
<hr />
<pre>
100       // by the MarkSweepAlwaysCompactCount parameter.
101       if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {
102         _allowed_deadspace_words = (space-&gt;capacity() * ratio / 100) / HeapWordSize;
103       } else {
104         _active = false;
105       }
106     }
107   }
108 
109 
110   bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {
111     if (!_active) {
112       return false;
113     }
114 
115     size_t dead_length = pointer_delta(dead_end, dead_start);
116     if (_allowed_deadspace_words &gt;= dead_length) {
117       _allowed_deadspace_words -= dead_length;
118       CollectedHeap::fill_with_object(dead_start, dead_length);
119       oop obj = oop(dead_start);
<span class="line-modified">120       obj-&gt;set_mark_raw(obj-&gt;mark_raw().set_marked());</span>
121 
122       assert(dead_length == (size_t)obj-&gt;size(), &quot;bad filler object size&quot;);
123       log_develop_trace(gc, compaction)(&quot;Inserting object to dead space: &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT &quot;b&quot;,
124           p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);
125 
126       return true;
127     } else {
128       _active = false;
129       return false;
130     }
131   }
132 
133 };
134 
135 template &lt;class SpaceType&gt;
136 inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
137   // Compute the new addresses for the live objects and store it in the mark
138   // Used by universe::mark_sweep_phase2()
139 
140   // We&#39;re sure to be here before any objects are compacted into this
</pre>
<hr />
<pre>
147     assert(cp-&gt;gen-&gt;first_compaction_space() == space, &quot;just checking&quot;);
148     cp-&gt;space = cp-&gt;gen-&gt;first_compaction_space();
149     cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
150     cp-&gt;space-&gt;set_compaction_top(cp-&gt;space-&gt;bottom());
151   }
152 
153   HeapWord* compact_top = cp-&gt;space-&gt;compaction_top(); // This is where we are currently compacting to.
154 
155   DeadSpacer dead_spacer(space);
156 
157   HeapWord*  end_of_live = space-&gt;bottom();  // One byte beyond the last byte of the last live object.
158   HeapWord*  first_dead = NULL; // The first dead object.
159 
160   const intx interval = PrefetchScanIntervalInBytes;
161 
162   HeapWord* cur_obj = space-&gt;bottom();
163   HeapWord* scan_limit = space-&gt;scan_limit();
164 
165   while (cur_obj &lt; scan_limit) {
166     assert(!space-&gt;scanned_block_is_obj(cur_obj) ||
<span class="line-modified">167            oop(cur_obj)-&gt;mark_raw().is_marked() || oop(cur_obj)-&gt;mark_raw().is_unlocked() ||</span>
<span class="line-modified">168            oop(cur_obj)-&gt;mark_raw().has_bias_pattern(),</span>
169            &quot;these are the only valid states during a mark sweep&quot;);
170     if (space-&gt;scanned_block_is_obj(cur_obj) &amp;&amp; oop(cur_obj)-&gt;is_gc_marked()) {
171       // prefetch beyond cur_obj
172       Prefetch::write(cur_obj, interval);
173       size_t size = space-&gt;scanned_block_size(cur_obj);
174       compact_top = cp-&gt;space-&gt;forward(oop(cur_obj), size, cp, compact_top);
175       cur_obj += size;
176       end_of_live = cur_obj;
177     } else {
178       // run over all the contiguous dead objects
179       HeapWord* end = cur_obj;
180       do {
181         // prefetch beyond end
182         Prefetch::write(end, interval);
183         end += space-&gt;scanned_block_size(end);
184       } while (end &lt; scan_limit &amp;&amp; (!space-&gt;scanned_block_is_obj(end) || !oop(end)-&gt;is_gc_marked()));
185 
186       // see if we might want to pretend this object is alive so that
187       // we don&#39;t have to compact quite as often.
188       if (cur_obj == compact_top &amp;&amp; dead_spacer.insert_deadspace(cur_obj, end)) {
</pre>
<hr />
<pre>
315   HeapWord* cur_obj = bottom;
316   if (space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
317     // All object before _first_dead can be skipped. They should not be moved.
318     // A pointer to the first live object is stored at the memory location for _first_dead.
319     cur_obj = *(HeapWord**)(space-&gt;_first_dead);
320   }
321 
322   debug_only(HeapWord* prev_obj = NULL);
323   while (cur_obj &lt; end_of_live) {
324     if (!oop(cur_obj)-&gt;is_gc_marked()) {
325       debug_only(prev_obj = cur_obj);
326       // The first word of the dead object contains a pointer to the next live object or end of space.
327       cur_obj = *(HeapWord**)cur_obj;
328       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory&quot;);
329     } else {
330       // prefetch beyond q
331       Prefetch::read(cur_obj, scan_interval);
332 
333       // size and destination
334       size_t size = space-&gt;obj_size(cur_obj);
<span class="line-modified">335       HeapWord* compaction_top = cast_from_oop&lt;HeapWord*&gt;(oop(cur_obj)-&gt;forwardee());</span>
336 
337       // prefetch beyond compaction_top
338       Prefetch::write(compaction_top, copy_interval);
339 
340       // copy object and reinit its mark
341       assert(cur_obj != compaction_top, &quot;everything in this pass should be moving&quot;);
342       Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
343       oop(compaction_top)-&gt;init_mark_raw();
344       assert(oop(compaction_top)-&gt;klass() != NULL, &quot;should have a class&quot;);
345 
346       debug_only(prev_obj = cur_obj);
347       cur_obj += size;
348     }
349   }
350 
351   clear_empty_region(space);
352 }
353 
354 #endif // INCLUDE_SERIALGC
355 
</pre>
<hr />
<pre>
360 template &lt;typename OopClosureType&gt;
361 void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {
362   HeapWord* t;
363   HeapWord* p = saved_mark_word();
364   assert(p != NULL, &quot;expected saved mark&quot;);
365 
366   const intx interval = PrefetchScanIntervalInBytes;
367   do {
368     t = top();
369     while (p &lt; t) {
370       Prefetch::write(p, interval);
371       debug_only(HeapWord* prev = p);
372       oop m = oop(p);
373       p += m-&gt;oop_iterate_size(blk);
374     }
375   } while (t &lt; top());
376 
377   set_saved_mark_word(p);
378 }
379 










380 #endif // SHARE_GC_SHARED_SPACE_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="space.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="spaceDecorator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
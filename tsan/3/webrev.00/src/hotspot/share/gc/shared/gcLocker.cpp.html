<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/gcLocker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/gcLocker.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;memory/universe.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;runtime/thread.inline.hpp&quot;
 34 #include &quot;runtime/threadSMR.hpp&quot;
 35 
 36 volatile jint GCLocker::_jni_lock_count = 0;
 37 volatile bool GCLocker::_needs_gc       = false;
 38 volatile bool GCLocker::_doing_gc       = false;
 39 unsigned int GCLocker::_total_collections = 0;
 40 
 41 #ifdef ASSERT
 42 volatile jint GCLocker::_debug_jni_lock_count = 0;
 43 #endif
 44 
 45 
 46 #ifdef ASSERT
 47 void GCLocker::verify_critical_count() {
 48   if (SafepointSynchronize::is_at_safepoint()) {
 49     assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, &quot;must agree&quot;);
 50     int count = 0;
 51     // Count the number of threads with critical operations in progress
 52     JavaThreadIteratorWithHandle jtiwh;
 53     for (; JavaThread *thr = jtiwh.next(); ) {
 54       if (thr-&gt;in_critical()) {
 55         count++;
 56       }
 57     }
 58     if (_jni_lock_count != count) {
 59       log_error(gc, verify)(&quot;critical counts don&#39;t match: %d != %d&quot;, _jni_lock_count, count);
 60       jtiwh.rewind();
 61       for (; JavaThread *thr = jtiwh.next(); ) {
 62         if (thr-&gt;in_critical()) {
 63           log_error(gc, verify)(INTPTR_FORMAT &quot; in_critical %d&quot;, p2i(thr), thr-&gt;in_critical());
 64         }
 65       }
 66     }
 67     assert(_jni_lock_count == count, &quot;must be equal&quot;);
 68   }
 69 }
 70 
 71 // In debug mode track the locking state at all times
 72 void GCLocker::increment_debug_jni_lock_count() {
 73   assert(_debug_jni_lock_count &gt;= 0, &quot;bad value&quot;);
 74   Atomic::inc(&amp;_debug_jni_lock_count);
 75 }
 76 
 77 void GCLocker::decrement_debug_jni_lock_count() {
 78   assert(_debug_jni_lock_count &gt; 0, &quot;bad value&quot;);
 79   Atomic::dec(&amp;_debug_jni_lock_count);
 80 }
 81 #endif
 82 
 83 void GCLocker::log_debug_jni(const char* msg) {
 84   Log(gc, jni) log;
 85   if (log.is_debug()) {
 86     ResourceMark rm; // JavaThread::name() allocates to convert to UTF8
 87     log.debug(&quot;%s Thread \&quot;%s\&quot; %d locked.&quot;, msg, Thread::current()-&gt;name(), _jni_lock_count);
 88   }
 89 }
 90 
 91 bool GCLocker::is_at_safepoint() {
 92   return SafepointSynchronize::is_at_safepoint();
 93 }
 94 
 95 bool GCLocker::check_active_before_gc() {
 96   assert(SafepointSynchronize::is_at_safepoint(), &quot;only read at safepoint&quot;);
 97   if (is_active() &amp;&amp; !_needs_gc) {
 98     verify_critical_count();
 99     _needs_gc = true;
100     log_debug_jni(&quot;Setting _needs_gc.&quot;);
101   }
102   return is_active();
103 }
104 
105 void GCLocker::stall_until_clear() {
106   assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
107   MonitorLocker ml(JNICritical_lock);
108 
109   if (needs_gc()) {
110     log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
111   }
112 
113   // Wait for _needs_gc  to be cleared
114   while (needs_gc()) {
115     ml.wait();
116   }
117 }
118 
119 bool GCLocker::should_discard(GCCause::Cause cause, uint total_collections) {
120   return (cause == GCCause::_gc_locker) &amp;&amp;
121          (_total_collections != total_collections);
122 }
123 
124 void GCLocker::jni_lock(JavaThread* thread) {
125   assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
126   MonitorLocker ml(JNICritical_lock);
127   // Block entering threads if we know at least one thread is in a
128   // JNI critical region and we need a GC.
129   // We check that at least one thread is in a critical region before
130   // blocking because blocked threads are woken up by a thread exiting
131   // a JNI critical region.
132   while (is_active_and_needs_gc() || _doing_gc) {
133     ml.wait();
134   }
135   thread-&gt;enter_critical();
136   _jni_lock_count++;
137   increment_debug_jni_lock_count();
138 }
139 
140 void GCLocker::jni_unlock(JavaThread* thread) {
141   assert(thread-&gt;in_last_critical(), &quot;should be exiting critical region&quot;);
142   MutexLocker mu(JNICritical_lock);
143   _jni_lock_count--;
144   decrement_debug_jni_lock_count();
145   thread-&gt;exit_critical();
146   if (needs_gc() &amp;&amp; !is_active_internal()) {
147     // We&#39;re the last thread out. Request a GC.
148     // Capture the current total collections, to allow detection of
149     // other collections that make this one unnecessary.  The value of
150     // total_collections() is only changed at a safepoint, so there
151     // must not be a safepoint between the lock becoming inactive and
152     // getting the count, else there may be unnecessary GCLocker GCs.
153     _total_collections = Universe::heap()-&gt;total_collections();
154     _doing_gc = true;
155     {
156       // Must give up the lock while at a safepoint
157       MutexUnlocker munlock(JNICritical_lock);
158       log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
159       Universe::heap()-&gt;collect(GCCause::_gc_locker);
160     }
161     _doing_gc = false;
162     _needs_gc = false;
163     JNICritical_lock-&gt;notify_all();
164   }
165 }
    </pre>
  </body>
</html>
diff a/src/hotspot/share/gc/shared/gcCause.hpp b/src/hotspot/share/gc/shared/gcCause.hpp
--- a/src/hotspot/share/gc/shared/gcCause.hpp
+++ b/src/hotspot/share/gc/shared/gcCause.hpp
@@ -63,15 +63,10 @@
 
     _tenured_generation_full,
     _metadata_GC_threshold,
     _metadata_GC_clear_soft_refs,
 
-    _cms_generation_full,
-    _cms_initial_mark,
-    _cms_final_remark,
-    _cms_concurrent_mark,
-
     _old_generation_expanded_on_last_scavenge,
     _old_generation_too_full_to_scavenge,
     _adaptive_size_policy,
 
     _g1_inc_collection_pause,
@@ -89,10 +84,11 @@
     _z_timer,
     _z_warmup,
     _z_allocation_rate,
     _z_allocation_stall,
     _z_proactive,
+    _z_high_usage,
 
     _last_gc_cause
   };
 
   inline static bool is_user_requested_gc(GCCause::Cause cause) {
@@ -111,17 +107,16 @@
   inline static bool is_tenured_allocation_failure_gc(GCCause::Cause cause) {
     assert(cause != GCCause::_old_generation_too_full_to_scavenge &&
            cause != GCCause::_old_generation_expanded_on_last_scavenge,
            "This GCCause may be correct but is not expected yet: %s",
            to_string(cause));
-    // _tenured_generation_full or _cms_generation_full for full tenured generations
+    // _tenured_generation_full for full tenured generations
     // _adaptive_size_policy for a full collection after a young GC
     // _allocation_failure is the generic cause a collection which could result
     // in the collection of the tenured generation if there is not enough space
     // in the tenured generation to support a young GC.
     return (cause == GCCause::_tenured_generation_full ||
-            cause == GCCause::_cms_generation_full ||
             cause == GCCause::_adaptive_size_policy ||
             cause == GCCause::_allocation_failure);
   }
 
   // Causes for collection of the young generation

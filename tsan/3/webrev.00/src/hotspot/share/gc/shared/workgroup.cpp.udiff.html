<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/workgroup.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="workerPolicy.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workgroup.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/workgroup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  #include &quot;gc/shared/workerManager.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/semaphore.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,14 +39,10 @@</span>
  // The current implementation will exit if the allocation
  // of any worker fails.
  void  AbstractWorkGang::initialize_workers() {
    log_develop_trace(gc, workgang)(&quot;Constructing work gang %s with %u threads&quot;, name(), total_workers());
    _workers = NEW_C_HEAP_ARRAY(AbstractGangWorker*, total_workers(), mtInternal);
<span class="udiff-line-removed">-   if (_workers == NULL) {</span>
<span class="udiff-line-removed">-     vm_exit_out_of_memory(0, OOM_MALLOC_ERROR, &quot;Cannot create GangWorker array.&quot;);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    add_workers(true);
  }
  
  
  AbstractGangWorker* AbstractWorkGang::install_worker(uint worker_id) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,22 +152,22 @@</span>
  
    WorkData worker_wait_for_task() {
      // Wait for the coordinator to dispatch a task.
      _start_semaphore-&gt;wait();
  
<span class="udiff-line-modified-removed">-     uint num_started = Atomic::add(1u, &amp;_started);</span>
<span class="udiff-line-modified-added">+     uint num_started = Atomic::add(&amp;_started, 1u);</span>
  
      // Subtract one to get a zero-indexed worker id.
      uint worker_id = num_started - 1;
  
      return WorkData(_task, worker_id);
    }
  
    void worker_done_with_task() {
      // Mark that the worker is done with the task.
      // The worker is not allowed to read the state variables after this line.
<span class="udiff-line-modified-removed">-     uint not_finished = Atomic::sub(1u, &amp;_not_finished);</span>
<span class="udiff-line-modified-added">+     uint not_finished = Atomic::sub(&amp;_not_finished, 1u);</span>
  
      // The last worker signals to the coordinator that all work is completed.
      if (not_finished == 0) {
        _end_semaphore-&gt;signal();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -198,34 +195,34 @@</span>
    ~MutexGangTaskDispatcher() {
      delete _monitor;
    }
  
    void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {
<span class="udiff-line-modified-removed">-     MutexLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
  
      _task        = task;
      _num_workers = num_workers;
  
      // Tell the workers to get to work.
      _monitor-&gt;notify_all();
  
      // Wait for them to finish.
      while (_finished &lt; _num_workers) {
<span class="udiff-line-modified-removed">-       _monitor-&gt;wait(/* no_safepoint_check */ true);</span>
<span class="udiff-line-modified-added">+       ml.wait();</span>
      }
  
      _task        = NULL;
      _num_workers = 0;
      _started     = 0;
      _finished    = 0;
    }
  
    WorkData worker_wait_for_task() {
<span class="udiff-line-modified-removed">-     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
  
      while (_num_workers == 0 || _started == _num_workers) {
<span class="udiff-line-modified-removed">-       _monitor-&gt;wait(/* no_safepoint_check */ true);</span>
<span class="udiff-line-modified-added">+       _monitor-&gt;wait();</span>
      }
  
      _started++;
  
      // Subtract one to get a zero-indexed worker id.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -233,11 +230,11 @@</span>
  
      return WorkData(_task, worker_id);
    }
  
    void worker_done_with_task() {
<span class="udiff-line-modified-removed">-     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+     MonitorLocker ml(_monitor, Mutex::_no_safepoint_check_flag);</span>
  
      _finished++;
  
      if (_finished == _num_workers) {
        // This will wake up all workers and not only the coordinator.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,12 +295,10 @@</span>
  
  void AbstractGangWorker::initialize() {
    assert(_gang != NULL, &quot;No gang to run in&quot;);
    os::set_priority(this, NearMaxPriority);
    log_develop_trace(gc, workgang)(&quot;Running gang worker for gang %s id %u&quot;, gang()-&gt;name(), id());
<span class="udiff-line-removed">-   // The VM thread should not execute here because MutexLocker&#39;s are used</span>
<span class="udiff-line-removed">-   // as (opposed to MutexLockerEx&#39;s).</span>
    assert(!Thread::current()-&gt;is_VM_thread(), &quot;VM thread should not be part&quot;
           &quot; of a work gang&quot;);
  }
  
  bool AbstractGangWorker::is_GC_task_thread() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -318,10 +313,12 @@</span>
    st-&gt;print(&quot;\&quot;%s\&quot; &quot;, name());
    Thread::print_on(st);
    st-&gt;cr();
  }
  
<span class="udiff-line-added">+ void AbstractGangWorker::print() const { print_on(tty); }</span>
<span class="udiff-line-added">+ </span>
  WorkData GangWorker::wait_for_task() {
    return gang()-&gt;dispatcher()-&gt;worker_wait_for_task();
  }
  
  void GangWorker::signal_task_done() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,11 +364,11 @@</span>
    _should_reset = false;
    _aborted      = false;
  }
  
  bool WorkGangBarrierSync::enter() {
<span class="udiff-line-modified-removed">-   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(monitor(), Mutex::_no_safepoint_check_flag);</span>
    if (should_reset()) {
      // The should_reset() was set and we are the first worker to enter
      // the sync barrier. We will zero the n_completed() count which
      // effectively resets the barrier.
      zero_completed();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -387,31 +384,30 @@</span>
      // will get stuck (as they will wake up, see that n_completed() !=
      // n_workers() and go back to sleep). Instead, we raise the
      // should_reset() flag and the barrier will be reset the first
      // time a worker enters it again.
      set_should_reset(true);
<span class="udiff-line-modified-removed">-     monitor()-&gt;notify_all();</span>
<span class="udiff-line-modified-added">+     ml.notify_all();</span>
    } else {
      while (n_completed() != n_workers() &amp;&amp; !aborted()) {
<span class="udiff-line-modified-removed">-       monitor()-&gt;wait(/* no_safepoint_check */ true);</span>
<span class="udiff-line-modified-added">+       ml.wait();</span>
      }
    }
    return !aborted();
  }
  
  void WorkGangBarrierSync::abort() {
<span class="udiff-line-modified-removed">-   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MutexLocker x(monitor(), Mutex::_no_safepoint_check_flag);</span>
    set_aborted();
    monitor()-&gt;notify_all();
  }
  
  // SubTasksDone functions.
  
  SubTasksDone::SubTasksDone(uint n) :
    _tasks(NULL), _n_tasks(n), _threads_completed(0) {
    _tasks = NEW_C_HEAP_ARRAY(uint, n, mtInternal);
<span class="udiff-line-removed">-   guarantee(_tasks != NULL, &quot;alloc failure&quot;);</span>
    clear();
  }
  
  bool SubTasksDone::valid() {
    return _tasks != NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -429,13 +425,12 @@</span>
  
  bool SubTasksDone::try_claim_task(uint t) {
    assert(t &lt; _n_tasks, &quot;bad task id.&quot;);
    uint old = _tasks[t];
    if (old == 0) {
<span class="udiff-line-modified-removed">-     old = Atomic::cmpxchg(1u, &amp;_tasks[t], 0u);</span>
<span class="udiff-line-modified-added">+     old = Atomic::cmpxchg(&amp;_tasks[t], 0u, 1u);</span>
    }
<span class="udiff-line-removed">-   assert(_tasks[t] == 1, &quot;What else?&quot;);</span>
    bool res = old == 0;
  #ifdef ASSERT
    if (res) {
      assert(_claimed &lt; _n_tasks, &quot;Too many tasks claimed; missing clear?&quot;);
      Atomic::inc(&amp;_claimed);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -447,22 +442,22 @@</span>
  void SubTasksDone::all_tasks_completed(uint n_threads) {
    uint observed = _threads_completed;
    uint old;
    do {
      old = observed;
<span class="udiff-line-modified-removed">-     observed = Atomic::cmpxchg(old+1, &amp;_threads_completed, old);</span>
<span class="udiff-line-modified-added">+     observed = Atomic::cmpxchg(&amp;_threads_completed, old, old+1);</span>
    } while (observed != old);
    // If this was the last thread checking in, clear the tasks.
    uint adjusted_thread_count = (n_threads == 0 ? 1 : n_threads);
    if (observed + 1 == adjusted_thread_count) {
      clear();
    }
  }
  
  
  SubTasksDone::~SubTasksDone() {
<span class="udiff-line-modified-removed">-   if (_tasks != NULL) FREE_C_HEAP_ARRAY(uint, _tasks);</span>
<span class="udiff-line-modified-added">+   FREE_C_HEAP_ARRAY(uint, _tasks);</span>
  }
  
  // *** SequentialSubTasksDone
  
  void SequentialSubTasksDone::clear() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -475,11 +470,11 @@</span>
  }
  
  bool SequentialSubTasksDone::try_claim_task(uint&amp; t) {
    t = _n_claimed;
    while (t &lt; _n_tasks) {
<span class="udiff-line-modified-removed">-     uint res = Atomic::cmpxchg(t+1, &amp;_n_claimed, t);</span>
<span class="udiff-line-modified-added">+     uint res = Atomic::cmpxchg(&amp;_n_claimed, t, t+1);</span>
      if (res == t) {
        return true;
      }
      t = res;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -487,11 +482,11 @@</span>
  }
  
  bool SequentialSubTasksDone::all_tasks_completed() {
    uint complete = _n_completed;
    while (true) {
<span class="udiff-line-modified-removed">-     uint res = Atomic::cmpxchg(complete+1, &amp;_n_completed, complete);</span>
<span class="udiff-line-modified-added">+     uint res = Atomic::cmpxchg(&amp;_n_completed, complete, complete+1);</span>
      if (res == complete) {
        break;
      }
      complete = res;
    }
</pre>
<center><a href="workerPolicy.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="workgroup.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
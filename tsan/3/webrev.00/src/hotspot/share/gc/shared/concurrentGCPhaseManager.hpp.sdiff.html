<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/concurrentGCPhaseManager.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="concurrentGCPhaseManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="concurrentGCThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/concurrentGCPhaseManager.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 92   // manager from the stack and allocate a new one.  Before changing
 93   // phases, if is_requested() is true and force is false, wait until
 94   // the request is changed.  After changing phases, notifies callers
 95   // of wait_for_phase of the phase change.
 96   //
 97   // Preconditions:
 98   // - Calling thread must be a ConcurrentGC thread
 99   // - phase != UNCONSTRAINED_PHASE
100   // - this must be the current top of manager stack
101   void set_phase(int phase, bool force);
102 
103   // Deactivate the manager.  An inactive manager no longer blocks
104   // transitions out of the associated phase when that phase has been
105   // requested.
106   //
107   // Preconditions:
108   // - Calling thread must be a ConcurrentGC thread
109   // - this must be the current top of manager stack
110   void deactivate();
111 
<span class="line-modified">112   // Used to implement CollectorPolicy::request_concurrent_phase().</span>
113   // Updates request to the new phase, and notifies threads blocked on
114   // the old request of the change.  Returns true if the phase is
115   // UNCONSTRAINED_PHASE.  Otherwise, waits until an active phase is
116   // the requested phase (returning true) or IDLE_PHASE (returning
117   // false if not also the requested phase).
118   //
119   // Preconditions:
120   // - Calling thread must be a Java thread
121   // - stack must be non-NULL
122   static bool wait_for_phase(int phase, Stack* stack);
123 
124 private:
125   int _phase;
126   bool _active;
127   ConcurrentGCPhaseManager* _prev;
128   Stack* _stack;
129 
130   // Non-copyable - never defined.
131   ConcurrentGCPhaseManager(const ConcurrentGCPhaseManager&amp;);
132   ConcurrentGCPhaseManager&amp; operator=(const ConcurrentGCPhaseManager&amp;);
</pre>
</td>
<td>
<hr />
<pre>
 92   // manager from the stack and allocate a new one.  Before changing
 93   // phases, if is_requested() is true and force is false, wait until
 94   // the request is changed.  After changing phases, notifies callers
 95   // of wait_for_phase of the phase change.
 96   //
 97   // Preconditions:
 98   // - Calling thread must be a ConcurrentGC thread
 99   // - phase != UNCONSTRAINED_PHASE
100   // - this must be the current top of manager stack
101   void set_phase(int phase, bool force);
102 
103   // Deactivate the manager.  An inactive manager no longer blocks
104   // transitions out of the associated phase when that phase has been
105   // requested.
106   //
107   // Preconditions:
108   // - Calling thread must be a ConcurrentGC thread
109   // - this must be the current top of manager stack
110   void deactivate();
111 
<span class="line-modified">112   // Used to implement CollectedHeap::request_concurrent_phase().</span>
113   // Updates request to the new phase, and notifies threads blocked on
114   // the old request of the change.  Returns true if the phase is
115   // UNCONSTRAINED_PHASE.  Otherwise, waits until an active phase is
116   // the requested phase (returning true) or IDLE_PHASE (returning
117   // false if not also the requested phase).
118   //
119   // Preconditions:
120   // - Calling thread must be a Java thread
121   // - stack must be non-NULL
122   static bool wait_for_phase(int phase, Stack* stack);
123 
124 private:
125   int _phase;
126   bool _active;
127   ConcurrentGCPhaseManager* _prev;
128   Stack* _stack;
129 
130   // Non-copyable - never defined.
131   ConcurrentGCPhaseManager(const ConcurrentGCPhaseManager&amp;);
132   ConcurrentGCPhaseManager&amp; operator=(const ConcurrentGCPhaseManager&amp;);
</pre>
</td>
</tr>
</table>
<center><a href="concurrentGCPhaseManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="concurrentGCThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
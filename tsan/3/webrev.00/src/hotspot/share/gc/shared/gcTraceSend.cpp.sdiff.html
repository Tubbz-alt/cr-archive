<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcTraceSend.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcTrace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcTraceSend.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 27 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 28 #include &quot;gc/shared/gcTimer.hpp&quot;
 29 #include &quot;gc/shared/gcTrace.hpp&quot;
 30 #include &quot;gc/shared/gcWhen.hpp&quot;
 31 #include &quot;jfr/jfrEvents.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
<span class="line-removed"> 34 #if INCLUDE_G1GC</span>
<span class="line-removed"> 35 #include &quot;gc/g1/g1EvacuationInfo.hpp&quot;</span>
<span class="line-removed"> 36 #include &quot;gc/g1/g1YCTypes.hpp&quot;</span>
<span class="line-removed"> 37 #endif</span>
 38 
 39 // All GC dependencies against the trace framework is contained within this file.
 40 
 41 typedef uintptr_t TraceAddress;
 42 
 43 void GCTracer::send_garbage_collection_event() const {
 44   EventGarbageCollection event(UNTIMED);
 45   if (event.should_commit()) {
 46     event.set_gcId(GCId::current());
 47     event.set_name(_shared_gc_info.name());
 48     event.set_cause((u2) _shared_gc_info.cause());
 49     event.set_sumOfPauses(_shared_gc_info.sum_of_pauses());
 50     event.set_longestPause(_shared_gc_info.longest_pause());
 51     event.set_starttime(_shared_gc_info.start_timestamp());
 52     event.set_endtime(_shared_gc_info.end_timestamp());
 53     event.commit();
 54   }
 55 }
 56 
 57 void GCTracer::send_reference_stats_event(ReferenceType type, size_t count) const {
</pre>
<hr />
<pre>
160 
161 static JfrStructCopyFailed to_struct(const CopyFailedInfo&amp; cf_info) {
162   JfrStructCopyFailed failed_info;
163   failed_info.set_objectCount(cf_info.failed_count());
164   failed_info.set_firstSize(cf_info.first_size());
165   failed_info.set_smallestSize(cf_info.smallest_size());
166   failed_info.set_totalSize(cf_info.total_size());
167   return failed_info;
168 }
169 
170 void YoungGCTracer::send_promotion_failed_event(const PromotionFailedInfo&amp; pf_info) const {
171   EventPromotionFailed e;
172   if (e.should_commit()) {
173     e.set_gcId(GCId::current());
174     e.set_promotionFailed(to_struct(pf_info));
175     e.set_thread(pf_info.thread_trace_id());
176     e.commit();
177   }
178 }
179 
<span class="line-modified">180 // Common to CMS and G1</span>
181 void OldGCTracer::send_concurrent_mode_failure_event() {
182   EventConcurrentModeFailure e;
183   if (e.should_commit()) {
184     e.set_gcId(GCId::current());
185     e.commit();
186   }
187 }
188 
<span class="line-removed">189 #if INCLUDE_G1GC</span>
<span class="line-removed">190 void G1NewTracer::send_g1_young_gc_event() {</span>
<span class="line-removed">191   EventG1GarbageCollection e(UNTIMED);</span>
<span class="line-removed">192   if (e.should_commit()) {</span>
<span class="line-removed">193     e.set_gcId(GCId::current());</span>
<span class="line-removed">194     e.set_type(_g1_young_gc_info.type());</span>
<span class="line-removed">195     e.set_starttime(_shared_gc_info.start_timestamp());</span>
<span class="line-removed">196     e.set_endtime(_shared_gc_info.end_timestamp());</span>
<span class="line-removed">197     e.commit();</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199 }</span>
<span class="line-removed">200 </span>
<span class="line-removed">201 void G1MMUTracer::send_g1_mmu_event(double time_slice_ms, double gc_time_ms, double max_time_ms) {</span>
<span class="line-removed">202   EventG1MMU e;</span>
<span class="line-removed">203   if (e.should_commit()) {</span>
<span class="line-removed">204     e.set_gcId(GCId::current());</span>
<span class="line-removed">205     e.set_timeSlice(time_slice_ms);</span>
<span class="line-removed">206     e.set_gcTime(gc_time_ms);</span>
<span class="line-removed">207     e.set_pauseTarget(max_time_ms);</span>
<span class="line-removed">208     e.commit();</span>
<span class="line-removed">209   }</span>
<span class="line-removed">210 }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212 void G1NewTracer::send_evacuation_info_event(G1EvacuationInfo* info) {</span>
<span class="line-removed">213   EventEvacuationInformation e;</span>
<span class="line-removed">214   if (e.should_commit()) {</span>
<span class="line-removed">215     e.set_gcId(GCId::current());</span>
<span class="line-removed">216     e.set_cSetRegions(info-&gt;collectionset_regions());</span>
<span class="line-removed">217     e.set_cSetUsedBefore(info-&gt;collectionset_used_before());</span>
<span class="line-removed">218     e.set_cSetUsedAfter(info-&gt;collectionset_used_after());</span>
<span class="line-removed">219     e.set_allocationRegions(info-&gt;allocation_regions());</span>
<span class="line-removed">220     e.set_allocationRegionsUsedBefore(info-&gt;alloc_regions_used_before());</span>
<span class="line-removed">221     e.set_allocationRegionsUsedAfter(info-&gt;alloc_regions_used_before() + info-&gt;bytes_copied());</span>
<span class="line-removed">222     e.set_bytesCopied(info-&gt;bytes_copied());</span>
<span class="line-removed">223     e.set_regionsFreed(info-&gt;regions_freed());</span>
<span class="line-removed">224     e.commit();</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226 }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228 void G1NewTracer::send_evacuation_failed_event(const EvacuationFailedInfo&amp; ef_info) const {</span>
<span class="line-removed">229   EventEvacuationFailed e;</span>
<span class="line-removed">230   if (e.should_commit()) {</span>
<span class="line-removed">231     e.set_gcId(GCId::current());</span>
<span class="line-removed">232     e.set_evacuationFailed(to_struct(ef_info));</span>
<span class="line-removed">233     e.commit();</span>
<span class="line-removed">234   }</span>
<span class="line-removed">235 }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237 static JfrStructG1EvacuationStatistics</span>
<span class="line-removed">238 create_g1_evacstats(unsigned gcid, const G1EvacSummary&amp; summary) {</span>
<span class="line-removed">239   JfrStructG1EvacuationStatistics s;</span>
<span class="line-removed">240   s.set_gcId(gcid);</span>
<span class="line-removed">241   s.set_allocated(summary.allocated() * HeapWordSize);</span>
<span class="line-removed">242   s.set_wasted(summary.wasted() * HeapWordSize);</span>
<span class="line-removed">243   s.set_used(summary.used() * HeapWordSize);</span>
<span class="line-removed">244   s.set_undoWaste(summary.undo_wasted() * HeapWordSize);</span>
<span class="line-removed">245   s.set_regionEndWaste(summary.region_end_waste() * HeapWordSize);</span>
<span class="line-removed">246   s.set_regionsRefilled(summary.regions_filled());</span>
<span class="line-removed">247   s.set_directAllocated(summary.direct_allocated() * HeapWordSize);</span>
<span class="line-removed">248   s.set_failureUsed(summary.failure_used() * HeapWordSize);</span>
<span class="line-removed">249   s.set_failureWaste(summary.failure_waste() * HeapWordSize);</span>
<span class="line-removed">250   return s;</span>
<span class="line-removed">251 }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253 void G1NewTracer::send_young_evacuation_statistics(const G1EvacSummary&amp; summary) const {</span>
<span class="line-removed">254   EventG1EvacuationYoungStatistics surv_evt;</span>
<span class="line-removed">255   if (surv_evt.should_commit()) {</span>
<span class="line-removed">256     surv_evt.set_statistics(create_g1_evacstats(GCId::current(), summary));</span>
<span class="line-removed">257     surv_evt.commit();</span>
<span class="line-removed">258   }</span>
<span class="line-removed">259 }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261 void G1NewTracer::send_old_evacuation_statistics(const G1EvacSummary&amp; summary) const {</span>
<span class="line-removed">262   EventG1EvacuationOldStatistics old_evt;</span>
<span class="line-removed">263   if (old_evt.should_commit()) {</span>
<span class="line-removed">264     old_evt.set_statistics(create_g1_evacstats(GCId::current(), summary));</span>
<span class="line-removed">265     old_evt.commit();</span>
<span class="line-removed">266   }</span>
<span class="line-removed">267 }</span>
<span class="line-removed">268 </span>
<span class="line-removed">269 void G1NewTracer::send_basic_ihop_statistics(size_t threshold,</span>
<span class="line-removed">270                                              size_t target_occupancy,</span>
<span class="line-removed">271                                              size_t current_occupancy,</span>
<span class="line-removed">272                                              size_t last_allocation_size,</span>
<span class="line-removed">273                                              double last_allocation_duration,</span>
<span class="line-removed">274                                              double last_marking_length) {</span>
<span class="line-removed">275   EventG1BasicIHOP evt;</span>
<span class="line-removed">276   if (evt.should_commit()) {</span>
<span class="line-removed">277     evt.set_gcId(GCId::current());</span>
<span class="line-removed">278     evt.set_threshold(threshold);</span>
<span class="line-removed">279     evt.set_targetOccupancy(target_occupancy);</span>
<span class="line-removed">280     evt.set_thresholdPercentage(target_occupancy &gt; 0 ? ((double)threshold / target_occupancy) : 0.0);</span>
<span class="line-removed">281     evt.set_currentOccupancy(current_occupancy);</span>
<span class="line-removed">282     evt.set_recentMutatorAllocationSize(last_allocation_size);</span>
<span class="line-removed">283     evt.set_recentMutatorDuration(last_allocation_duration * MILLIUNITS);</span>
<span class="line-removed">284     evt.set_recentAllocationRate(last_allocation_duration != 0.0 ? last_allocation_size / last_allocation_duration : 0.0);</span>
<span class="line-removed">285     evt.set_lastMarkingDuration(last_marking_length * MILLIUNITS);</span>
<span class="line-removed">286     evt.commit();</span>
<span class="line-removed">287   }</span>
<span class="line-removed">288 }</span>
<span class="line-removed">289 </span>
<span class="line-removed">290 void G1NewTracer::send_adaptive_ihop_statistics(size_t threshold,</span>
<span class="line-removed">291                                                 size_t internal_target_occupancy,</span>
<span class="line-removed">292                                                 size_t current_occupancy,</span>
<span class="line-removed">293                                                 size_t additional_buffer_size,</span>
<span class="line-removed">294                                                 double predicted_allocation_rate,</span>
<span class="line-removed">295                                                 double predicted_marking_length,</span>
<span class="line-removed">296                                                 bool prediction_active) {</span>
<span class="line-removed">297   EventG1AdaptiveIHOP evt;</span>
<span class="line-removed">298   if (evt.should_commit()) {</span>
<span class="line-removed">299     evt.set_gcId(GCId::current());</span>
<span class="line-removed">300     evt.set_threshold(threshold);</span>
<span class="line-removed">301     evt.set_thresholdPercentage(internal_target_occupancy &gt; 0 ? ((double)threshold / internal_target_occupancy) : 0.0);</span>
<span class="line-removed">302     evt.set_ihopTargetOccupancy(internal_target_occupancy);</span>
<span class="line-removed">303     evt.set_currentOccupancy(current_occupancy);</span>
<span class="line-removed">304     evt.set_additionalBufferSize(additional_buffer_size);</span>
<span class="line-removed">305     evt.set_predictedAllocationRate(predicted_allocation_rate);</span>
<span class="line-removed">306     evt.set_predictedMarkingDuration(predicted_marking_length * MILLIUNITS);</span>
<span class="line-removed">307     evt.set_predictionActive(prediction_active);</span>
<span class="line-removed">308     evt.commit();</span>
<span class="line-removed">309   }</span>
<span class="line-removed">310 }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312 #endif // INCLUDE_G1GC</span>
<span class="line-removed">313 </span>
314 static JfrStructVirtualSpace to_struct(const VirtualSpaceSummary&amp; summary) {
315   JfrStructVirtualSpace space;
316   space.set_start((TraceAddress)summary.start());
317   space.set_committedEnd((TraceAddress)summary.committed_end());
318   space.set_committedSize(summary.committed_size());
319   space.set_reservedEnd((TraceAddress)summary.reserved_end());
320   space.set_reservedSize(summary.reserved_size());
321   return space;
322 }
323 
324 static JfrStructObjectSpace to_struct(const SpaceSummary&amp; summary) {
325   JfrStructObjectSpace space;
326   space.set_start((TraceAddress)summary.start());
327   space.set_end((TraceAddress)summary.end());
328   space.set_used(summary.used());
329   space.set_size(summary.size());
330   return space;
331 }
332 
333 class GCHeapSummaryEventSender : public GCHeapSummaryVisitor {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 27 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 28 #include &quot;gc/shared/gcTimer.hpp&quot;
 29 #include &quot;gc/shared/gcTrace.hpp&quot;
 30 #include &quot;gc/shared/gcWhen.hpp&quot;
 31 #include &quot;jfr/jfrEvents.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;




 34 
 35 // All GC dependencies against the trace framework is contained within this file.
 36 
 37 typedef uintptr_t TraceAddress;
 38 
 39 void GCTracer::send_garbage_collection_event() const {
 40   EventGarbageCollection event(UNTIMED);
 41   if (event.should_commit()) {
 42     event.set_gcId(GCId::current());
 43     event.set_name(_shared_gc_info.name());
 44     event.set_cause((u2) _shared_gc_info.cause());
 45     event.set_sumOfPauses(_shared_gc_info.sum_of_pauses());
 46     event.set_longestPause(_shared_gc_info.longest_pause());
 47     event.set_starttime(_shared_gc_info.start_timestamp());
 48     event.set_endtime(_shared_gc_info.end_timestamp());
 49     event.commit();
 50   }
 51 }
 52 
 53 void GCTracer::send_reference_stats_event(ReferenceType type, size_t count) const {
</pre>
<hr />
<pre>
156 
157 static JfrStructCopyFailed to_struct(const CopyFailedInfo&amp; cf_info) {
158   JfrStructCopyFailed failed_info;
159   failed_info.set_objectCount(cf_info.failed_count());
160   failed_info.set_firstSize(cf_info.first_size());
161   failed_info.set_smallestSize(cf_info.smallest_size());
162   failed_info.set_totalSize(cf_info.total_size());
163   return failed_info;
164 }
165 
166 void YoungGCTracer::send_promotion_failed_event(const PromotionFailedInfo&amp; pf_info) const {
167   EventPromotionFailed e;
168   if (e.should_commit()) {
169     e.set_gcId(GCId::current());
170     e.set_promotionFailed(to_struct(pf_info));
171     e.set_thread(pf_info.thread_trace_id());
172     e.commit();
173   }
174 }
175 
<span class="line-modified">176 // G1</span>
177 void OldGCTracer::send_concurrent_mode_failure_event() {
178   EventConcurrentModeFailure e;
179   if (e.should_commit()) {
180     e.set_gcId(GCId::current());
181     e.commit();
182   }
183 }
184 





























































































































185 static JfrStructVirtualSpace to_struct(const VirtualSpaceSummary&amp; summary) {
186   JfrStructVirtualSpace space;
187   space.set_start((TraceAddress)summary.start());
188   space.set_committedEnd((TraceAddress)summary.committed_end());
189   space.set_committedSize(summary.committed_size());
190   space.set_reservedEnd((TraceAddress)summary.reserved_end());
191   space.set_reservedSize(summary.reserved_size());
192   return space;
193 }
194 
195 static JfrStructObjectSpace to_struct(const SpaceSummary&amp; summary) {
196   JfrStructObjectSpace space;
197   space.set_start((TraceAddress)summary.start());
198   space.set_end((TraceAddress)summary.end());
199   space.set_used(summary.used());
200   space.set_size(summary.size());
201   return space;
202 }
203 
204 class GCHeapSummaryEventSender : public GCHeapSummaryVisitor {
</pre>
</td>
</tr>
</table>
<center><a href="gcTrace.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcVMOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
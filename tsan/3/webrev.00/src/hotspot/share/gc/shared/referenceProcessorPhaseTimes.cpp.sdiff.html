<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/referenceProcessorPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="referenceProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/referenceProcessorPhaseTimes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/gcTimer.hpp&quot;
 27 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 28 #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
 29 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;

 33 
 34 #define ASSERT_REF_TYPE(ref_type) assert((ref_type) &gt;= REF_SOFT &amp;&amp; (ref_type) &lt;= REF_PHANTOM, \
 35                                          &quot;Invariant (%d)&quot;, (int)ref_type)
 36 
 37 #define ASSERT_PHASE(phase) assert((phase) &gt;= ReferenceProcessor::RefPhase1 &amp;&amp; \
 38                                    (phase) &lt; ReferenceProcessor::RefPhaseMax,  \
 39                                    &quot;Invariant (%d)&quot;, (int)phase);
 40 
 41 #define ASSERT_SUB_PHASE(phase) assert((phase) &gt;= ReferenceProcessor::SoftRefSubPhase1 &amp;&amp; \
 42                                        (phase) &lt; ReferenceProcessor::RefSubPhaseMax, \
 43                                        &quot;Invariant (%d)&quot;, (int)phase);
 44 
 45 static const char* SubPhasesParWorkTitle[ReferenceProcessor::RefSubPhaseMax] = {
 46        &quot;SoftRef (ms):&quot;,
 47        &quot;SoftRef (ms):&quot;,
 48        &quot;WeakRef (ms):&quot;,
 49        &quot;FinalRef (ms):&quot;,
 50        &quot;FinalRef (ms):&quot;,
 51        &quot;PhantomRef (ms):&quot;
 52        };
</pre>
<hr />
<pre>
159 RefProcPhaseTimeTracker::~RefProcPhaseTimeTracker() {
160   double elapsed = elapsed_time();
161   phase_times()-&gt;set_phase_time_ms(_phase_number, elapsed);
162 }
163 
164 RefProcTotalPhaseTimesTracker::RefProcTotalPhaseTimesTracker(ReferenceProcessor::RefProcPhases phase_number,
165                                                              ReferenceProcessorPhaseTimes* phase_times,
166                                                              ReferenceProcessor* rp) :
167   RefProcPhaseTimeBaseTracker(phase_enum_2_phase_string(phase_number), phase_number, phase_times), _rp(rp) {
168 }
169 
170 RefProcTotalPhaseTimesTracker::~RefProcTotalPhaseTimesTracker() {
171   double elapsed = elapsed_time();
172   phase_times()-&gt;set_phase_time_ms(_phase_number, elapsed);
173 }
174 
175 ReferenceProcessorPhaseTimes::ReferenceProcessorPhaseTimes(GCTimer* gc_timer, uint max_gc_threads) :
176   _processing_is_mt(false), _gc_timer(gc_timer) {
177 
178   for (uint i = 0; i &lt; ReferenceProcessor::RefSubPhaseMax; i++) {
<span class="line-modified">179     _sub_phases_worker_time_sec[i] = new WorkerDataArray&lt;double&gt;(max_gc_threads, SubPhasesParWorkTitle[i]);</span>
180   }
<span class="line-modified">181   _phase2_worker_time_sec = new WorkerDataArray&lt;double&gt;(max_gc_threads, Phase2ParWorkTitle);</span>
182 
183   reset();
184 }
185 
186 inline int ref_type_2_index(ReferenceType ref_type) {
187   return ref_type - REF_SOFT;
188 }
189 
190 WorkerDataArray&lt;double&gt;* ReferenceProcessorPhaseTimes::sub_phase_worker_time_sec(ReferenceProcessor::RefProcSubPhases sub_phase) const {
191   ASSERT_SUB_PHASE(sub_phase);
192   return _sub_phases_worker_time_sec[sub_phase];
193 }
194 
195 double ReferenceProcessorPhaseTimes::phase_time_ms(ReferenceProcessor::RefProcPhases phase) const {
196   ASSERT_PHASE(phase);
197   return _phases_time_ms[phase];
198 }
199 
200 void ReferenceProcessorPhaseTimes::set_phase_time_ms(ReferenceProcessor::RefProcPhases phase,
201                                                      double phase_time_ms) {
</pre>
<hr />
<pre>
229 ReferenceProcessorPhaseTimes::~ReferenceProcessorPhaseTimes() {
230   for (int i = 0; i &lt; ReferenceProcessor::RefSubPhaseMax; i++) {
231     delete _sub_phases_worker_time_sec[i];
232   }
233   delete _phase2_worker_time_sec;
234 }
235 
236 double ReferenceProcessorPhaseTimes::sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const {
237   ASSERT_SUB_PHASE(sub_phase);
238   return _sub_phases_total_time_ms[sub_phase];
239 }
240 
241 void ReferenceProcessorPhaseTimes::set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase,
242                                                                      double time_ms) {
243   ASSERT_SUB_PHASE(sub_phase);
244   _sub_phases_total_time_ms[sub_phase] = time_ms;
245 }
246 
247 void ReferenceProcessorPhaseTimes::add_ref_cleared(ReferenceType ref_type, size_t count) {
248   ASSERT_REF_TYPE(ref_type);
<span class="line-modified">249   Atomic::add(count, &amp;_ref_cleared[ref_type_2_index(ref_type)]);</span>
250 }
251 
252 void ReferenceProcessorPhaseTimes::set_ref_discovered(ReferenceType ref_type, size_t count) {
253   ASSERT_REF_TYPE(ref_type);
254   _ref_discovered[ref_type_2_index(ref_type)] = count;
255 }
256 
257 double ReferenceProcessorPhaseTimes::balance_queues_time_ms(ReferenceProcessor::RefProcPhases phase) const {
258   ASSERT_PHASE(phase);
259   return _balance_queues_time_ms[phase];
260 }
261 
262 void ReferenceProcessorPhaseTimes::set_balance_queues_time_ms(ReferenceProcessor::RefProcPhases phase, double time_ms) {
263   ASSERT_PHASE(phase);
264   _balance_queues_time_ms[phase] = time_ms;
265 }
266 
267 #define TIME_FORMAT &quot;%.1lfms&quot;
268 
269 void ReferenceProcessorPhaseTimes::print_all_references(uint base_indent, bool print_total) const {
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/gcTimer.hpp&quot;
 27 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 28 #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
 29 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/atomic.hpp&quot;</span>
 34 
 35 #define ASSERT_REF_TYPE(ref_type) assert((ref_type) &gt;= REF_SOFT &amp;&amp; (ref_type) &lt;= REF_PHANTOM, \
 36                                          &quot;Invariant (%d)&quot;, (int)ref_type)
 37 
 38 #define ASSERT_PHASE(phase) assert((phase) &gt;= ReferenceProcessor::RefPhase1 &amp;&amp; \
 39                                    (phase) &lt; ReferenceProcessor::RefPhaseMax,  \
 40                                    &quot;Invariant (%d)&quot;, (int)phase);
 41 
 42 #define ASSERT_SUB_PHASE(phase) assert((phase) &gt;= ReferenceProcessor::SoftRefSubPhase1 &amp;&amp; \
 43                                        (phase) &lt; ReferenceProcessor::RefSubPhaseMax, \
 44                                        &quot;Invariant (%d)&quot;, (int)phase);
 45 
 46 static const char* SubPhasesParWorkTitle[ReferenceProcessor::RefSubPhaseMax] = {
 47        &quot;SoftRef (ms):&quot;,
 48        &quot;SoftRef (ms):&quot;,
 49        &quot;WeakRef (ms):&quot;,
 50        &quot;FinalRef (ms):&quot;,
 51        &quot;FinalRef (ms):&quot;,
 52        &quot;PhantomRef (ms):&quot;
 53        };
</pre>
<hr />
<pre>
160 RefProcPhaseTimeTracker::~RefProcPhaseTimeTracker() {
161   double elapsed = elapsed_time();
162   phase_times()-&gt;set_phase_time_ms(_phase_number, elapsed);
163 }
164 
165 RefProcTotalPhaseTimesTracker::RefProcTotalPhaseTimesTracker(ReferenceProcessor::RefProcPhases phase_number,
166                                                              ReferenceProcessorPhaseTimes* phase_times,
167                                                              ReferenceProcessor* rp) :
168   RefProcPhaseTimeBaseTracker(phase_enum_2_phase_string(phase_number), phase_number, phase_times), _rp(rp) {
169 }
170 
171 RefProcTotalPhaseTimesTracker::~RefProcTotalPhaseTimesTracker() {
172   double elapsed = elapsed_time();
173   phase_times()-&gt;set_phase_time_ms(_phase_number, elapsed);
174 }
175 
176 ReferenceProcessorPhaseTimes::ReferenceProcessorPhaseTimes(GCTimer* gc_timer, uint max_gc_threads) :
177   _processing_is_mt(false), _gc_timer(gc_timer) {
178 
179   for (uint i = 0; i &lt; ReferenceProcessor::RefSubPhaseMax; i++) {
<span class="line-modified">180     _sub_phases_worker_time_sec[i] = new WorkerDataArray&lt;double&gt;(SubPhasesParWorkTitle[i], max_gc_threads);</span>
181   }
<span class="line-modified">182   _phase2_worker_time_sec = new WorkerDataArray&lt;double&gt;(Phase2ParWorkTitle, max_gc_threads);</span>
183 
184   reset();
185 }
186 
187 inline int ref_type_2_index(ReferenceType ref_type) {
188   return ref_type - REF_SOFT;
189 }
190 
191 WorkerDataArray&lt;double&gt;* ReferenceProcessorPhaseTimes::sub_phase_worker_time_sec(ReferenceProcessor::RefProcSubPhases sub_phase) const {
192   ASSERT_SUB_PHASE(sub_phase);
193   return _sub_phases_worker_time_sec[sub_phase];
194 }
195 
196 double ReferenceProcessorPhaseTimes::phase_time_ms(ReferenceProcessor::RefProcPhases phase) const {
197   ASSERT_PHASE(phase);
198   return _phases_time_ms[phase];
199 }
200 
201 void ReferenceProcessorPhaseTimes::set_phase_time_ms(ReferenceProcessor::RefProcPhases phase,
202                                                      double phase_time_ms) {
</pre>
<hr />
<pre>
230 ReferenceProcessorPhaseTimes::~ReferenceProcessorPhaseTimes() {
231   for (int i = 0; i &lt; ReferenceProcessor::RefSubPhaseMax; i++) {
232     delete _sub_phases_worker_time_sec[i];
233   }
234   delete _phase2_worker_time_sec;
235 }
236 
237 double ReferenceProcessorPhaseTimes::sub_phase_total_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase) const {
238   ASSERT_SUB_PHASE(sub_phase);
239   return _sub_phases_total_time_ms[sub_phase];
240 }
241 
242 void ReferenceProcessorPhaseTimes::set_sub_phase_total_phase_time_ms(ReferenceProcessor::RefProcSubPhases sub_phase,
243                                                                      double time_ms) {
244   ASSERT_SUB_PHASE(sub_phase);
245   _sub_phases_total_time_ms[sub_phase] = time_ms;
246 }
247 
248 void ReferenceProcessorPhaseTimes::add_ref_cleared(ReferenceType ref_type, size_t count) {
249   ASSERT_REF_TYPE(ref_type);
<span class="line-modified">250   Atomic::add(&amp;_ref_cleared[ref_type_2_index(ref_type)], count);</span>
251 }
252 
253 void ReferenceProcessorPhaseTimes::set_ref_discovered(ReferenceType ref_type, size_t count) {
254   ASSERT_REF_TYPE(ref_type);
255   _ref_discovered[ref_type_2_index(ref_type)] = count;
256 }
257 
258 double ReferenceProcessorPhaseTimes::balance_queues_time_ms(ReferenceProcessor::RefProcPhases phase) const {
259   ASSERT_PHASE(phase);
260   return _balance_queues_time_ms[phase];
261 }
262 
263 void ReferenceProcessorPhaseTimes::set_balance_queues_time_ms(ReferenceProcessor::RefProcPhases phase, double time_ms) {
264   ASSERT_PHASE(phase);
265   _balance_queues_time_ms[phase] = time_ms;
266 }
267 
268 #define TIME_FORMAT &quot;%.1lfms&quot;
269 
270 void ReferenceProcessorPhaseTimes::print_all_references(uint base_indent, bool print_total) const {
</pre>
</td>
</tr>
</table>
<center><a href="referenceProcessor.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
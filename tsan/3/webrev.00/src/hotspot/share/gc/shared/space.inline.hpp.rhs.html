<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/space.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SPACE_INLINE_HPP
 26 #define SHARE_GC_SHARED_SPACE_INLINE_HPP
 27 
 28 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/space.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.hpp&quot;
<a name="1" id="anc1"></a>
 33 #include &quot;oops/oopsHierarchy.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/prefetch.inline.hpp&quot;
 36 #include &quot;runtime/safepoint.hpp&quot;
 37 #if INCLUDE_SERIALGC
 38 #include &quot;gc/serial/markSweep.inline.hpp&quot;
 39 #endif
 40 
 41 inline HeapWord* Space::block_start(const void* p) {
 42   return block_start_const(p);
 43 }
 44 
 45 inline HeapWord* OffsetTableContigSpace::allocate(size_t size) {
 46   HeapWord* res = ContiguousSpace::allocate(size);
 47   if (res != NULL) {
 48     _offsets.alloc_block(res, size);
 49   }
 50   return res;
 51 }
 52 
 53 // Because of the requirement of keeping &quot;_offsets&quot; up to date with the
 54 // allocations, we sequentialize these with a lock.  Therefore, best if
 55 // this is used for larger LAB allocations only.
 56 inline HeapWord* OffsetTableContigSpace::par_allocate(size_t size) {
 57   MutexLocker x(&amp;_par_alloc_lock);
 58   // This ought to be just &quot;allocate&quot;, because of the lock above, but that
 59   // ContiguousSpace::allocate asserts that either the allocating thread
 60   // holds the heap lock or it is the VM thread and we&#39;re at a safepoint.
 61   // The best I (dld) could figure was to put a field in ContiguousSpace
 62   // meaning &quot;locking at safepoint taken care of&quot;, and set/reset that
 63   // here.  But this will do for now, especially in light of the comment
 64   // above.  Perhaps in the future some lock-free manner of keeping the
 65   // coordination.
 66   HeapWord* res = ContiguousSpace::par_allocate(size);
 67   if (res != NULL) {
 68     _offsets.alloc_block(res, size);
 69   }
 70   return res;
 71 }
 72 
 73 inline HeapWord*
 74 OffsetTableContigSpace::block_start_const(const void* p) const {
 75   return _offsets.block_start(p);
 76 }
 77 
 78 size_t CompactibleSpace::obj_size(const HeapWord* addr) const {
 79   return oop(addr)-&gt;size();
 80 }
 81 
 82 #if INCLUDE_SERIALGC
 83 
 84 class DeadSpacer : StackObj {
 85   size_t _allowed_deadspace_words;
 86   bool _active;
 87   CompactibleSpace* _space;
 88 
 89 public:
 90   DeadSpacer(CompactibleSpace* space) : _allowed_deadspace_words(0), _space(space) {
 91     size_t ratio = _space-&gt;allowed_dead_ratio();
 92     _active = ratio &gt; 0;
 93 
 94     if (_active) {
 95       assert(!UseG1GC, &quot;G1 should not be using dead space&quot;);
 96 
 97       // We allow some amount of garbage towards the bottom of the space, so
 98       // we don&#39;t start compacting before there is a significant gain to be made.
 99       // Occasionally, we want to ensure a full compaction, which is determined
100       // by the MarkSweepAlwaysCompactCount parameter.
101       if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {
102         _allowed_deadspace_words = (space-&gt;capacity() * ratio / 100) / HeapWordSize;
103       } else {
104         _active = false;
105       }
106     }
107   }
108 
109 
110   bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {
111     if (!_active) {
112       return false;
113     }
114 
115     size_t dead_length = pointer_delta(dead_end, dead_start);
116     if (_allowed_deadspace_words &gt;= dead_length) {
117       _allowed_deadspace_words -= dead_length;
118       CollectedHeap::fill_with_object(dead_start, dead_length);
119       oop obj = oop(dead_start);
<a name="2" id="anc2"></a><span class="line-modified">120       obj-&gt;set_mark_raw(obj-&gt;mark_raw().set_marked());</span>
121 
122       assert(dead_length == (size_t)obj-&gt;size(), &quot;bad filler object size&quot;);
123       log_develop_trace(gc, compaction)(&quot;Inserting object to dead space: &quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;, &quot; SIZE_FORMAT &quot;b&quot;,
124           p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);
125 
126       return true;
127     } else {
128       _active = false;
129       return false;
130     }
131   }
132 
133 };
134 
135 template &lt;class SpaceType&gt;
136 inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
137   // Compute the new addresses for the live objects and store it in the mark
138   // Used by universe::mark_sweep_phase2()
139 
140   // We&#39;re sure to be here before any objects are compacted into this
141   // space, so this is a good time to initialize this:
142   space-&gt;set_compaction_top(space-&gt;bottom());
143 
144   if (cp-&gt;space == NULL) {
145     assert(cp-&gt;gen != NULL, &quot;need a generation&quot;);
146     assert(cp-&gt;threshold == NULL, &quot;just checking&quot;);
147     assert(cp-&gt;gen-&gt;first_compaction_space() == space, &quot;just checking&quot;);
148     cp-&gt;space = cp-&gt;gen-&gt;first_compaction_space();
149     cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
150     cp-&gt;space-&gt;set_compaction_top(cp-&gt;space-&gt;bottom());
151   }
152 
153   HeapWord* compact_top = cp-&gt;space-&gt;compaction_top(); // This is where we are currently compacting to.
154 
155   DeadSpacer dead_spacer(space);
156 
157   HeapWord*  end_of_live = space-&gt;bottom();  // One byte beyond the last byte of the last live object.
158   HeapWord*  first_dead = NULL; // The first dead object.
159 
160   const intx interval = PrefetchScanIntervalInBytes;
161 
162   HeapWord* cur_obj = space-&gt;bottom();
163   HeapWord* scan_limit = space-&gt;scan_limit();
164 
165   while (cur_obj &lt; scan_limit) {
166     assert(!space-&gt;scanned_block_is_obj(cur_obj) ||
<a name="3" id="anc3"></a><span class="line-modified">167            oop(cur_obj)-&gt;mark_raw().is_marked() || oop(cur_obj)-&gt;mark_raw().is_unlocked() ||</span>
<span class="line-modified">168            oop(cur_obj)-&gt;mark_raw().has_bias_pattern(),</span>
169            &quot;these are the only valid states during a mark sweep&quot;);
170     if (space-&gt;scanned_block_is_obj(cur_obj) &amp;&amp; oop(cur_obj)-&gt;is_gc_marked()) {
171       // prefetch beyond cur_obj
172       Prefetch::write(cur_obj, interval);
173       size_t size = space-&gt;scanned_block_size(cur_obj);
174       compact_top = cp-&gt;space-&gt;forward(oop(cur_obj), size, cp, compact_top);
175       cur_obj += size;
176       end_of_live = cur_obj;
177     } else {
178       // run over all the contiguous dead objects
179       HeapWord* end = cur_obj;
180       do {
181         // prefetch beyond end
182         Prefetch::write(end, interval);
183         end += space-&gt;scanned_block_size(end);
184       } while (end &lt; scan_limit &amp;&amp; (!space-&gt;scanned_block_is_obj(end) || !oop(end)-&gt;is_gc_marked()));
185 
186       // see if we might want to pretend this object is alive so that
187       // we don&#39;t have to compact quite as often.
188       if (cur_obj == compact_top &amp;&amp; dead_spacer.insert_deadspace(cur_obj, end)) {
189         oop obj = oop(cur_obj);
190         compact_top = cp-&gt;space-&gt;forward(obj, obj-&gt;size(), cp, compact_top);
191         end_of_live = end;
192       } else {
193         // otherwise, it really is a free region.
194 
195         // cur_obj is a pointer to a dead object. Use this dead memory to store a pointer to the next live object.
196         *(HeapWord**)cur_obj = end;
197 
198         // see if this is the first dead region.
199         if (first_dead == NULL) {
200           first_dead = cur_obj;
201         }
202       }
203 
204       // move on to the next object
205       cur_obj = end;
206     }
207   }
208 
209   assert(cur_obj == scan_limit, &quot;just checking&quot;);
210   space-&gt;_end_of_live = end_of_live;
211   if (first_dead != NULL) {
212     space-&gt;_first_dead = first_dead;
213   } else {
214     space-&gt;_first_dead = end_of_live;
215   }
216 
217   // save the compaction_top of the compaction space.
218   cp-&gt;space-&gt;set_compaction_top(compact_top);
219 }
220 
221 template &lt;class SpaceType&gt;
222 inline void CompactibleSpace::scan_and_adjust_pointers(SpaceType* space) {
223   // adjust all the interior pointers to point at the new locations of objects
224   // Used by MarkSweep::mark_sweep_phase3()
225 
226   HeapWord* cur_obj = space-&gt;bottom();
227   HeapWord* const end_of_live = space-&gt;_end_of_live;  // Established by &quot;scan_and_forward&quot;.
228   HeapWord* const first_dead = space-&gt;_first_dead;    // Established by &quot;scan_and_forward&quot;.
229 
230   assert(first_dead &lt;= end_of_live, &quot;Stands to reason, no?&quot;);
231 
232   const intx interval = PrefetchScanIntervalInBytes;
233 
234   debug_only(HeapWord* prev_obj = NULL);
235   while (cur_obj &lt; end_of_live) {
236     Prefetch::write(cur_obj, interval);
237     if (cur_obj &lt; first_dead || oop(cur_obj)-&gt;is_gc_marked()) {
238       // cur_obj is alive
239       // point all the oops to the new location
240       size_t size = MarkSweep::adjust_pointers(oop(cur_obj));
241       size = space-&gt;adjust_obj_size(size);
242       debug_only(prev_obj = cur_obj);
243       cur_obj += size;
244     } else {
245       debug_only(prev_obj = cur_obj);
246       // cur_obj is not a live object, instead it points at the next live object
247       cur_obj = *(HeapWord**)cur_obj;
248       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory, cur_obj: &quot; PTR_FORMAT &quot;, prev_obj: &quot; PTR_FORMAT, p2i(cur_obj), p2i(prev_obj));
249     }
250   }
251 
252   assert(cur_obj == end_of_live, &quot;just checking&quot;);
253 }
254 
255 #ifdef ASSERT
256 template &lt;class SpaceType&gt;
257 inline void CompactibleSpace::verify_up_to_first_dead(SpaceType* space) {
258   HeapWord* cur_obj = space-&gt;bottom();
259 
260   if (cur_obj &lt; space-&gt;_end_of_live &amp;&amp; space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
261      // we have a chunk of the space which hasn&#39;t moved and we&#39;ve reinitialized
262      // the mark word during the previous pass, so we can&#39;t use is_gc_marked for
263      // the traversal.
264      HeapWord* prev_obj = NULL;
265 
266      while (cur_obj &lt; space-&gt;_first_dead) {
267        size_t size = space-&gt;obj_size(cur_obj);
268        assert(!oop(cur_obj)-&gt;is_gc_marked(), &quot;should be unmarked (special dense prefix handling)&quot;);
269        prev_obj = cur_obj;
270        cur_obj += size;
271      }
272   }
273 }
274 #endif
275 
276 template &lt;class SpaceType&gt;
277 inline void CompactibleSpace::clear_empty_region(SpaceType* space) {
278   // Let&#39;s remember if we were empty before we did the compaction.
279   bool was_empty = space-&gt;used_region().is_empty();
280   // Reset space after compaction is complete
281   space-&gt;reset_after_compaction();
282   // We do this clear, below, since it has overloaded meanings for some
283   // space subtypes.  For example, OffsetTableContigSpace&#39;s that were
284   // compacted into will have had their offset table thresholds updated
285   // continuously, but those that weren&#39;t need to have their thresholds
286   // re-initialized.  Also mangles unused area for debugging.
287   if (space-&gt;used_region().is_empty()) {
288     if (!was_empty) space-&gt;clear(SpaceDecorator::Mangle);
289   } else {
290     if (ZapUnusedHeapArea) space-&gt;mangle_unused_area();
291   }
292 }
293 
294 template &lt;class SpaceType&gt;
295 inline void CompactibleSpace::scan_and_compact(SpaceType* space) {
296   // Copy all live objects to their new location
297   // Used by MarkSweep::mark_sweep_phase4()
298 
299   verify_up_to_first_dead(space);
300 
301   HeapWord* const bottom = space-&gt;bottom();
302   HeapWord* const end_of_live = space-&gt;_end_of_live;
303 
304   assert(space-&gt;_first_dead &lt;= end_of_live, &quot;Invariant. _first_dead: &quot; PTR_FORMAT &quot; &lt;= end_of_live: &quot; PTR_FORMAT, p2i(space-&gt;_first_dead), p2i(end_of_live));
305   if (space-&gt;_first_dead == end_of_live &amp;&amp; (bottom == end_of_live || !oop(bottom)-&gt;is_gc_marked())) {
306     // Nothing to compact. The space is either empty or all live object should be left in place.
307     clear_empty_region(space);
308     return;
309   }
310 
311   const intx scan_interval = PrefetchScanIntervalInBytes;
312   const intx copy_interval = PrefetchCopyIntervalInBytes;
313 
314   assert(bottom &lt; end_of_live, &quot;bottom: &quot; PTR_FORMAT &quot; should be &lt; end_of_live: &quot; PTR_FORMAT, p2i(bottom), p2i(end_of_live));
315   HeapWord* cur_obj = bottom;
316   if (space-&gt;_first_dead &gt; cur_obj &amp;&amp; !oop(cur_obj)-&gt;is_gc_marked()) {
317     // All object before _first_dead can be skipped. They should not be moved.
318     // A pointer to the first live object is stored at the memory location for _first_dead.
319     cur_obj = *(HeapWord**)(space-&gt;_first_dead);
320   }
321 
322   debug_only(HeapWord* prev_obj = NULL);
323   while (cur_obj &lt; end_of_live) {
324     if (!oop(cur_obj)-&gt;is_gc_marked()) {
325       debug_only(prev_obj = cur_obj);
326       // The first word of the dead object contains a pointer to the next live object or end of space.
327       cur_obj = *(HeapWord**)cur_obj;
328       assert(cur_obj &gt; prev_obj, &quot;we should be moving forward through memory&quot;);
329     } else {
330       // prefetch beyond q
331       Prefetch::read(cur_obj, scan_interval);
332 
333       // size and destination
334       size_t size = space-&gt;obj_size(cur_obj);
<a name="4" id="anc4"></a><span class="line-modified">335       HeapWord* compaction_top = cast_from_oop&lt;HeapWord*&gt;(oop(cur_obj)-&gt;forwardee());</span>
336 
337       // prefetch beyond compaction_top
338       Prefetch::write(compaction_top, copy_interval);
339 
340       // copy object and reinit its mark
341       assert(cur_obj != compaction_top, &quot;everything in this pass should be moving&quot;);
342       Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
343       oop(compaction_top)-&gt;init_mark_raw();
344       assert(oop(compaction_top)-&gt;klass() != NULL, &quot;should have a class&quot;);
345 
346       debug_only(prev_obj = cur_obj);
347       cur_obj += size;
348     }
349   }
350 
351   clear_empty_region(space);
352 }
353 
354 #endif // INCLUDE_SERIALGC
355 
356 size_t ContiguousSpace::scanned_block_size(const HeapWord* addr) const {
357   return oop(addr)-&gt;size();
358 }
359 
360 template &lt;typename OopClosureType&gt;
361 void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {
362   HeapWord* t;
363   HeapWord* p = saved_mark_word();
364   assert(p != NULL, &quot;expected saved mark&quot;);
365 
366   const intx interval = PrefetchScanIntervalInBytes;
367   do {
368     t = top();
369     while (p &lt; t) {
370       Prefetch::write(p, interval);
371       debug_only(HeapWord* prev = p);
372       oop m = oop(p);
373       p += m-&gt;oop_iterate_size(blk);
374     }
375   } while (t &lt; top());
376 
377   set_saved_mark_word(p);
378 }
379 
<a name="5" id="anc5"></a>









380 #endif // SHARE_GC_SHARED_SPACE_INLINE_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
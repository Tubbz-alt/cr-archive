<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/cardTableRS.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_CARDTABLERS_HPP
 26 #define SHARE_GC_SHARED_CARDTABLERS_HPP
 27 
 28 #include &quot;gc/shared/cardTable.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/oop.hpp&quot;
 31 
 32 class DirtyCardToOopClosure;
 33 class Generation;
 34 class Space;
 35 class OopsInGenClosure;
 36 
 37 // Helper to remember modified oops in all clds.
 38 class CLDRemSet {
 39   bool _accumulate_modified_oops;
 40  public:
 41   CLDRemSet() : _accumulate_modified_oops(false) {}
 42   void set_accumulate_modified_oops(bool value) { _accumulate_modified_oops = value; }
 43   bool accumulate_modified_oops() { return _accumulate_modified_oops; }
 44   bool mod_union_is_clear();
 45   void clear_mod_union();
 46 };
 47 
 48 // This RemSet uses a card table both as shared data structure
 49 // for a mod ref barrier set and for the rem set information.
 50 
 51 class CardTableRS: public CardTable {
 52   friend class VMStructs;
 53   // Below are private classes used in impl.
 54   friend class VerifyCTSpaceClosure;
 55   friend class ClearNoncleanCardWrapper;
 56 
 57   CLDRemSet _cld_rem_set;
 58 
 59   void verify_space(Space* s, HeapWord* gen_start);
 60 
 61   enum ExtendedCardValue {
 62     youngergen_card   = CT_MR_BS_last_reserved + 1,
 63     // These are for parallel collection.
 64     // There are three P (parallel) youngergen card values.  In general, this
 65     // needs to be more than the number of generations (including the perm
 66     // gen) that might have younger_refs_do invoked on them separately.  So
 67     // if we add more gens, we have to add more values.
 68     youngergenP1_card  = CT_MR_BS_last_reserved + 2,
 69     youngergenP2_card  = CT_MR_BS_last_reserved + 3,
 70     youngergenP3_card  = CT_MR_BS_last_reserved + 4,
 71     cur_youngergen_and_prev_nonclean_card =
 72       CT_MR_BS_last_reserved + 5
 73   };
 74 
 75   // An array that contains, for each generation, the card table value last
 76   // used as the current value for a younger_refs_do iteration of that
 77   // portion of the table. The perm gen is index 0. The young gen is index 1,
 78   // but will always have the value &quot;clean_card&quot;. The old gen is index 2.
 79   CardValue* _last_cur_val_in_gen;
 80 
 81   CardValue _cur_youngergen_card_val;
 82 
 83   // Number of generations, plus one for lingering PermGen issues in CardTableRS.
 84   static const int _regions_to_iterate = 3;
 85 
 86   CardValue cur_youngergen_card_val() {
 87     return _cur_youngergen_card_val;
 88   }
 89   void set_cur_youngergen_card_val(CardValue v) {
 90     _cur_youngergen_card_val = v;
 91   }
 92   bool is_prev_youngergen_card_val(CardValue v) {
 93     return
 94       youngergen_card &lt;= v &amp;&amp;
 95       v &lt; cur_youngergen_and_prev_nonclean_card &amp;&amp;
 96       v != _cur_youngergen_card_val;
 97   }
 98   // Return a youngergen_card_value that is not currently in use.
 99   CardValue find_unused_youngergenP_card_value();
100 
101 public:
102   CardTableRS(MemRegion whole_heap, bool scanned_concurrently);
103   ~CardTableRS();
104 
105   CLDRemSet* cld_rem_set() { return &amp;_cld_rem_set; }
106 
107   void younger_refs_in_space_iterate(Space* sp, OopsInGenClosure* cl, uint n_threads);
108 
109   virtual void verify_used_region_at_save_marks(Space* sp) const NOT_DEBUG_RETURN;
110 
111   // Override.
112   void prepare_for_younger_refs_iterate(bool parallel);
113 
114   // Card table entries are cleared before application; &quot;blk&quot; is
115   // responsible for dirtying if the oop is still older-to-younger after
116   // closure application.
117   void younger_refs_iterate(Generation* g, OopsInGenClosure* blk, uint n_threads);
118 
119   void inline_write_ref_field_gc(void* field, oop new_val) {
120     CardValue* byte = byte_for(field);
121     *byte = youngergen_card;
122   }
123   void write_ref_field_gc_work(void* field, oop new_val) {
124     inline_write_ref_field_gc(field, new_val);
125   }
126 
127   // Override.  Might want to devirtualize this in the same fashion as
128   // above.  Ensures that the value of the card for field says that it&#39;s
129   // a younger card in the current collection.
130   virtual void write_ref_field_gc_par(void* field, oop new_val);
131 
132   bool is_aligned(HeapWord* addr) {
133     return is_card_aligned(addr);
134   }
135 
136   void verify();
137   void initialize();
138 
139   void clear_into_younger(Generation* old_gen);
140 
141   void invalidate_or_clear(Generation* old_gen);
142 
143   bool is_prev_nonclean_card_val(CardValue v) {
144     return
145       youngergen_card &lt;= v &amp;&amp;
146       v &lt;= cur_youngergen_and_prev_nonclean_card &amp;&amp;
147       v != _cur_youngergen_card_val;
148   }
149 
150   static bool youngergen_may_have_been_dirty(CardValue cv) {
151     return cv == CardTableRS::cur_youngergen_and_prev_nonclean_card;
152   }
153 
154   // *** Support for parallel card scanning.
155 
156   // dirty and precleaned are equivalent wrt younger_refs_iter.
157   static bool card_is_dirty_wrt_gen_iter(CardValue cv) {
158     return cv == dirty_card || cv == precleaned_card;
159   }
160 
161   // Returns &quot;true&quot; iff the value &quot;cv&quot; will cause the card containing it
162   // to be scanned in the current traversal.  May be overridden by
163   // subtypes.
164   bool card_will_be_scanned(CardValue cv);
165 
166   // Returns &quot;true&quot; iff the value &quot;cv&quot; may have represented a dirty card at
167   // some point.
168   bool card_may_have_been_dirty(CardValue cv);
169 
170   // Iterate over the portion of the card-table which covers the given
171   // region mr in the given space and apply cl to any dirty sub-regions
172   // of mr. Clears the dirty cards as they are processed.
173   void non_clean_card_iterate_possibly_parallel(Space* sp, MemRegion mr,
174                                                 OopsInGenClosure* cl, CardTableRS* ct,
175                                                 uint n_threads);
176 
177   // Work method used to implement non_clean_card_iterate_possibly_parallel()
178   // above in the parallel case.
179   virtual void non_clean_card_iterate_parallel_work(Space* sp, MemRegion mr,
180                                                     OopsInGenClosure* cl, CardTableRS* ct,
181                                                     uint n_threads);
182 
183   // This is an array, one element per covered region of the card table.
184   // Each entry is itself an array, with one element per chunk in the
185   // covered region.  Each entry of these arrays is the lowest non-clean
186   // card of the corresponding chunk containing part of an object from the
187   // previous chunk, or else NULL.
188   typedef CardValue* CardPtr;
189   typedef CardPtr* CardArr;
190   CardArr* _lowest_non_clean;
191   size_t*  _lowest_non_clean_chunk_size;
192   uintptr_t* _lowest_non_clean_base_chunk_index;
193   volatile int* _last_LNC_resizing_collection;
194 
195   virtual bool is_in_young(oop obj) const;
196 };
197 
198 class ClearNoncleanCardWrapper: public MemRegionClosure {
199   DirtyCardToOopClosure* _dirty_card_closure;
200   CardTableRS* _ct;
201   bool _is_par;
202 
203 public:
204 
205   typedef CardTable::CardValue CardValue;
206 private:
207   // Clears the given card, return true if the corresponding card should be
208   // processed.
209   inline bool clear_card(CardValue* entry);
210   // Work methods called by the clear_card()
211   inline bool clear_card_serial(CardValue* entry);
212   inline bool clear_card_parallel(CardValue* entry);
213   // check alignment of pointer
214   bool is_word_aligned(CardValue* entry);
215 
216 public:
217   ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct, bool is_par);
218   void do_MemRegion(MemRegion mr);
219 };
220 
221 #endif // SHARE_GC_SHARED_CARDTABLERS_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/taskqueue.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51 inline void GenericTaskQueue&lt;E, F, N&gt;::initialize() {
 52   _elems = ArrayAllocator&lt;E&gt;::allocate(N, F);
 53 }
 54 
 55 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 56 inline GenericTaskQueue&lt;E, F, N&gt;::~GenericTaskQueue() {
 57   ArrayAllocator&lt;E&gt;::free(const_cast&lt;E*&gt;(_elems), N);
 58 }
 59 
 60 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 61 bool GenericTaskQueue&lt;E, F, N&gt;::push_slow(E t, uint dirty_n_elems) {
 62   if (dirty_n_elems == N - 1) {
 63     // Actually means 0, so do the push.
 64     uint localBot = _bottom;
 65     // g++ complains if the volatile result of the assignment is
 66     // unused, so we cast the volatile away.  We cannot cast directly
 67     // to void, because gcc treats that as not using the result of the
 68     // assignment.  However, casting to E&amp; means that we trigger an
 69     // unused-value warning.  So, we cast the E&amp; to void.
 70     (void)const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified"> 71     OrderAccess::release_store(&amp;_bottom, increment_index(localBot));</span>
 72     TASKQUEUE_STATS_ONLY(stats.record_push());
 73     return true;
 74   }
 75   return false;
 76 }
 77 
 78 template&lt;class E, MEMFLAGS F, unsigned int N&gt; inline bool
 79 GenericTaskQueue&lt;E, F, N&gt;::push(E t) {
 80   uint localBot = _bottom;
 81   assert(localBot &lt; N, &quot;_bottom out of range.&quot;);
 82   idx_t top = _age.top();
 83   uint dirty_n_elems = dirty_size(localBot, top);
 84   assert(dirty_n_elems &lt; N, &quot;n_elems out of range.&quot;);
 85   if (dirty_n_elems &lt; max_elems()) {
 86     // g++ complains if the volatile result of the assignment is
 87     // unused, so we cast the volatile away.  We cannot cast directly
 88     // to void, because gcc treats that as not using the result of the
 89     // assignment.  However, casting to E&amp; means that we trigger an
 90     // unused-value warning.  So, we cast the E&amp; to void.
 91     (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified"> 92     OrderAccess::release_store(&amp;_bottom, increment_index(localBot));</span>
 93     TASKQUEUE_STATS_ONLY(stats.record_push());
 94     return true;
 95   } else {
 96     return push_slow(t, dirty_n_elems);
 97   }
 98 }
 99 
100 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
101 inline bool OverflowTaskQueue&lt;E, F, N&gt;::push(E t)
102 {
103   if (!taskqueue_t::push(t)) {
104     overflow_stack()-&gt;push(t);
105     TASKQUEUE_STATS_ONLY(stats.record_overflow(overflow_stack()-&gt;size()));
106   }
107   return true;
108 }
109 
110 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
111 inline bool OverflowTaskQueue&lt;E, F, N&gt;::try_push_to_taskqueue(E t) {
112   return taskqueue_t::push(t);
</pre>
<hr />
<pre>
167   // before the store just above.
168   OrderAccess::fence();
169   // g++ complains if the volatile result of the assignment is
170   // unused, so we cast the volatile away.  We cannot cast directly
171   // to void, because gcc treats that as not using the result of the
172   // assignment.  However, casting to E&amp; means that we trigger an
173   // unused-value warning.  So, we cast the E&amp; to void.
174   (void) const_cast&lt;E&amp;&gt;(t = _elems[localBot]);
175   // This is a second read of &quot;age&quot;; the &quot;size()&quot; above is the first.
176   // If there&#39;s still at least one element in the queue, based on the
177   // &quot;_bottom&quot; and &quot;age&quot; we&#39;ve read, then there can be no interference with
178   // a &quot;pop_global&quot; operation, and we&#39;re done.
179   idx_t tp = _age.top();    // XXX
180   if (size(localBot, tp) &gt; 0) {
181     assert(dirty_size(localBot, tp) != N - 1, &quot;sanity&quot;);
182     TASKQUEUE_STATS_ONLY(stats.record_pop());
183     return true;
184   } else {
185     // Otherwise, the queue contained exactly one element; we take the slow
186     // path.





187     return pop_local_slow(localBot, _age.get());
188   }
189 }
190 
191 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
192 bool OverflowTaskQueue&lt;E, F, N&gt;::pop_overflow(E&amp; t)
193 {
194   if (overflow_empty()) return false;
195   t = overflow_stack()-&gt;pop();
196   return true;
197 }
198 
199 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
200 bool GenericTaskQueue&lt;E, F, N&gt;::pop_global(volatile E&amp; t) {
201   Age oldAge = _age.get();
<span class="line-modified">202   // Architectures with weak memory model require a barrier here</span>
<span class="line-modified">203   // to guarantee that bottom is not older than age,</span>

204   // which is crucial for the correctness of the algorithm.
<span class="line-modified">205 #if !(defined SPARC || defined IA32 || defined AMD64)</span>









206   OrderAccess::fence();




207 #endif
<span class="line-modified">208   uint localBot = OrderAccess::load_acquire(&amp;_bottom);</span>
209   uint n_elems = size(localBot, oldAge.top());
210   if (n_elems == 0) {
211     return false;
212   }
213 
214   // g++ complains if the volatile result of the assignment is
215   // unused, so we cast the volatile away.  We cannot cast directly
216   // to void, because gcc treats that as not using the result of the
217   // assignment.  However, casting to E&amp; means that we trigger an
218   // unused-value warning.  So, we cast the E&amp; to void.
219   (void) const_cast&lt;E&amp;&gt;(t = _elems[oldAge.top()]);
220   Age newAge(oldAge);
221   newAge.increment();
222   Age resAge = _age.cmpxchg(newAge, oldAge);
223 
224   // Note that using &quot;_bottom&quot; here might fail, since a pop_local might
225   // have decremented it.
226   assert(dirty_size(localBot, newAge.top()) != N - 1, &quot;sanity&quot;);
227   return resAge == oldAge;
228 }
</pre>
<hr />
<pre>
299   } else {
300     assert(_n == 1, &quot;can&#39;t be zero.&quot;);
301     return false;
302   }
303 }
304 
305 template&lt;class T, MEMFLAGS F&gt; bool
306 GenericTaskQueueSet&lt;T, F&gt;::steal(uint queue_num, E&amp; t) {
307   for (uint i = 0; i &lt; 2 * _n; i++) {
308     TASKQUEUE_STATS_ONLY(queue(queue_num)-&gt;stats.record_steal_attempt());
309     if (steal_best_of_2(queue_num, t)) {
310       TASKQUEUE_STATS_ONLY(queue(queue_num)-&gt;stats.record_steal());
311       return true;
312     }
313   }
314   return false;
315 }
316 
317 template &lt;unsigned int N, MEMFLAGS F&gt;
318 inline typename TaskQueueSuper&lt;N, F&gt;::Age TaskQueueSuper&lt;N, F&gt;::Age::cmpxchg(const Age new_age, const Age old_age) volatile {
<span class="line-modified">319   return Atomic::cmpxchg(new_age._data, &amp;_data, old_age._data);</span>
320 }
321 
322 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
323 template&lt;class Fn&gt;
324 inline void GenericTaskQueue&lt;E, F, N&gt;::iterate(Fn fn) {
325   uint iters = size();
326   uint index = _bottom;
327   for (uint i = 0; i &lt; iters; ++i) {
328     index = decrement_index(index);
329     fn(const_cast&lt;E&amp;&gt;(_elems[index])); // cast away volatility
330   }
331 }
332 
333 
334 #endif // SHARE_GC_SHARED_TASKQUEUE_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 51 inline void GenericTaskQueue&lt;E, F, N&gt;::initialize() {
 52   _elems = ArrayAllocator&lt;E&gt;::allocate(N, F);
 53 }
 54 
 55 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 56 inline GenericTaskQueue&lt;E, F, N&gt;::~GenericTaskQueue() {
 57   ArrayAllocator&lt;E&gt;::free(const_cast&lt;E*&gt;(_elems), N);
 58 }
 59 
 60 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
 61 bool GenericTaskQueue&lt;E, F, N&gt;::push_slow(E t, uint dirty_n_elems) {
 62   if (dirty_n_elems == N - 1) {
 63     // Actually means 0, so do the push.
 64     uint localBot = _bottom;
 65     // g++ complains if the volatile result of the assignment is
 66     // unused, so we cast the volatile away.  We cannot cast directly
 67     // to void, because gcc treats that as not using the result of the
 68     // assignment.  However, casting to E&amp; means that we trigger an
 69     // unused-value warning.  So, we cast the E&amp; to void.
 70     (void)const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified"> 71     Atomic::release_store(&amp;_bottom, increment_index(localBot));</span>
 72     TASKQUEUE_STATS_ONLY(stats.record_push());
 73     return true;
 74   }
 75   return false;
 76 }
 77 
 78 template&lt;class E, MEMFLAGS F, unsigned int N&gt; inline bool
 79 GenericTaskQueue&lt;E, F, N&gt;::push(E t) {
 80   uint localBot = _bottom;
 81   assert(localBot &lt; N, &quot;_bottom out of range.&quot;);
 82   idx_t top = _age.top();
 83   uint dirty_n_elems = dirty_size(localBot, top);
 84   assert(dirty_n_elems &lt; N, &quot;n_elems out of range.&quot;);
 85   if (dirty_n_elems &lt; max_elems()) {
 86     // g++ complains if the volatile result of the assignment is
 87     // unused, so we cast the volatile away.  We cannot cast directly
 88     // to void, because gcc treats that as not using the result of the
 89     // assignment.  However, casting to E&amp; means that we trigger an
 90     // unused-value warning.  So, we cast the E&amp; to void.
 91     (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified"> 92     Atomic::release_store(&amp;_bottom, increment_index(localBot));</span>
 93     TASKQUEUE_STATS_ONLY(stats.record_push());
 94     return true;
 95   } else {
 96     return push_slow(t, dirty_n_elems);
 97   }
 98 }
 99 
100 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
101 inline bool OverflowTaskQueue&lt;E, F, N&gt;::push(E t)
102 {
103   if (!taskqueue_t::push(t)) {
104     overflow_stack()-&gt;push(t);
105     TASKQUEUE_STATS_ONLY(stats.record_overflow(overflow_stack()-&gt;size()));
106   }
107   return true;
108 }
109 
110 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
111 inline bool OverflowTaskQueue&lt;E, F, N&gt;::try_push_to_taskqueue(E t) {
112   return taskqueue_t::push(t);
</pre>
<hr />
<pre>
167   // before the store just above.
168   OrderAccess::fence();
169   // g++ complains if the volatile result of the assignment is
170   // unused, so we cast the volatile away.  We cannot cast directly
171   // to void, because gcc treats that as not using the result of the
172   // assignment.  However, casting to E&amp; means that we trigger an
173   // unused-value warning.  So, we cast the E&amp; to void.
174   (void) const_cast&lt;E&amp;&gt;(t = _elems[localBot]);
175   // This is a second read of &quot;age&quot;; the &quot;size()&quot; above is the first.
176   // If there&#39;s still at least one element in the queue, based on the
177   // &quot;_bottom&quot; and &quot;age&quot; we&#39;ve read, then there can be no interference with
178   // a &quot;pop_global&quot; operation, and we&#39;re done.
179   idx_t tp = _age.top();    // XXX
180   if (size(localBot, tp) &gt; 0) {
181     assert(dirty_size(localBot, tp) != N - 1, &quot;sanity&quot;);
182     TASKQUEUE_STATS_ONLY(stats.record_pop());
183     return true;
184   } else {
185     // Otherwise, the queue contained exactly one element; we take the slow
186     // path.
<span class="line-added">187 </span>
<span class="line-added">188     // The barrier is required to prevent reordering the two reads of _age:</span>
<span class="line-added">189     // one is the _age.get() below, and the other is _age.top() above the if-stmt.</span>
<span class="line-added">190     // The algorithm may fail if _age.get() reads an older value than _age.top().</span>
<span class="line-added">191     OrderAccess::loadload();</span>
192     return pop_local_slow(localBot, _age.get());
193   }
194 }
195 
196 template &lt;class E, MEMFLAGS F, unsigned int N&gt;
197 bool OverflowTaskQueue&lt;E, F, N&gt;::pop_overflow(E&amp; t)
198 {
199   if (overflow_empty()) return false;
200   t = overflow_stack()-&gt;pop();
201   return true;
202 }
203 
204 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
205 bool GenericTaskQueue&lt;E, F, N&gt;::pop_global(volatile E&amp; t) {
206   Age oldAge = _age.get();
<span class="line-modified">207 #ifndef CPU_MULTI_COPY_ATOMIC</span>
<span class="line-modified">208   // Architectures with non-multi-copy-atomic memory model require a</span>
<span class="line-added">209   // full fence here to guarantee that bottom is not older than age,</span>
210   // which is crucial for the correctness of the algorithm.
<span class="line-modified">211   //</span>
<span class="line-added">212   // We need a full fence here for this case:</span>
<span class="line-added">213   //</span>
<span class="line-added">214   // Thread1: set bottom (push)</span>
<span class="line-added">215   // Thread2: read age, read bottom, set age (pop_global)</span>
<span class="line-added">216   // Thread3: read age, read bottom (pop_global)</span>
<span class="line-added">217   //</span>
<span class="line-added">218   // The requirement is that Thread3 must never read an older bottom</span>
<span class="line-added">219   // value than Thread2 after Thread3 has seen the age value from</span>
<span class="line-added">220   // Thread2.</span>
221   OrderAccess::fence();
<span class="line-added">222 #else</span>
<span class="line-added">223   // Everyone else can make do with a LoadLoad barrier to keep reads</span>
<span class="line-added">224   // from _age and _bottom in order.</span>
<span class="line-added">225   OrderAccess::loadload();</span>
226 #endif
<span class="line-modified">227   uint localBot = Atomic::load_acquire(&amp;_bottom);</span>
228   uint n_elems = size(localBot, oldAge.top());
229   if (n_elems == 0) {
230     return false;
231   }
232 
233   // g++ complains if the volatile result of the assignment is
234   // unused, so we cast the volatile away.  We cannot cast directly
235   // to void, because gcc treats that as not using the result of the
236   // assignment.  However, casting to E&amp; means that we trigger an
237   // unused-value warning.  So, we cast the E&amp; to void.
238   (void) const_cast&lt;E&amp;&gt;(t = _elems[oldAge.top()]);
239   Age newAge(oldAge);
240   newAge.increment();
241   Age resAge = _age.cmpxchg(newAge, oldAge);
242 
243   // Note that using &quot;_bottom&quot; here might fail, since a pop_local might
244   // have decremented it.
245   assert(dirty_size(localBot, newAge.top()) != N - 1, &quot;sanity&quot;);
246   return resAge == oldAge;
247 }
</pre>
<hr />
<pre>
318   } else {
319     assert(_n == 1, &quot;can&#39;t be zero.&quot;);
320     return false;
321   }
322 }
323 
324 template&lt;class T, MEMFLAGS F&gt; bool
325 GenericTaskQueueSet&lt;T, F&gt;::steal(uint queue_num, E&amp; t) {
326   for (uint i = 0; i &lt; 2 * _n; i++) {
327     TASKQUEUE_STATS_ONLY(queue(queue_num)-&gt;stats.record_steal_attempt());
328     if (steal_best_of_2(queue_num, t)) {
329       TASKQUEUE_STATS_ONLY(queue(queue_num)-&gt;stats.record_steal());
330       return true;
331     }
332   }
333   return false;
334 }
335 
336 template &lt;unsigned int N, MEMFLAGS F&gt;
337 inline typename TaskQueueSuper&lt;N, F&gt;::Age TaskQueueSuper&lt;N, F&gt;::Age::cmpxchg(const Age new_age, const Age old_age) volatile {
<span class="line-modified">338   return Atomic::cmpxchg(&amp;_data, old_age._data, new_age._data);</span>
339 }
340 
341 template&lt;class E, MEMFLAGS F, unsigned int N&gt;
342 template&lt;class Fn&gt;
343 inline void GenericTaskQueue&lt;E, F, N&gt;::iterate(Fn fn) {
344   uint iters = size();
345   uint index = _bottom;
346   for (uint i = 0; i &lt; iters; ++i) {
347     index = decrement_index(index);
348     fn(const_cast&lt;E&amp;&gt;(_elems[index])); // cast away volatility
349   }
350 }
351 
352 
353 #endif // SHARE_GC_SHARED_TASKQUEUE_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/ptrQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ptrQueue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/ptrQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #define SHARE_GC_SHARED_PTRQUEUE_HPP
  
  #include &quot;memory/padded.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  #include &quot;utilities/lockFreeStack.hpp&quot;
  #include &quot;utilities/sizes.hpp&quot;
  
  class Mutex;
  class Monitor;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,25 +43,18 @@</span>
  class BufferNode;
  class PtrQueueSet;
  class PtrQueue {
    friend class VMStructs;
  
<span class="udiff-line-modified-removed">-   // Noncopyable - not defined.</span>
<span class="udiff-line-removed">-   PtrQueue(const PtrQueue&amp;);</span>
<span class="udiff-line-removed">-   PtrQueue&amp; operator=(const PtrQueue&amp;);</span>
<span class="udiff-line-modified-added">+   NONCOPYABLE(PtrQueue);</span>
  
    // The ptr queue set to which this queue belongs.
    PtrQueueSet* const _qset;
  
    // Whether updates should be logged.
    bool _active;
  
<span class="udiff-line-removed">-   // If true, the queue is permanent, and doesn&#39;t need to deallocate</span>
<span class="udiff-line-removed">-   // its buffer in the destructor (since that obtains a lock which may not</span>
<span class="udiff-line-removed">-   // be legally locked by then.</span>
<span class="udiff-line-removed">-   const bool _permanent;</span>
<span class="udiff-line-removed">- </span>
    // The (byte) index at which an object was last enqueued.  Starts at
    // capacity_in_bytes (indicating an empty buffer) and goes towards zero.
    // Value is always pointer-size aligned.
    size_t _index;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74,18 +68,10 @@</span>
    size_t capacity_in_bytes() const {
      assert(_capacity_in_bytes &gt; 0, &quot;capacity not set&quot;);
      return _capacity_in_bytes;
    }
  
<span class="udiff-line-removed">-   void set_capacity(size_t entries) {</span>
<span class="udiff-line-removed">-     size_t byte_capacity = index_to_byte_index(entries);</span>
<span class="udiff-line-removed">-     assert(_capacity_in_bytes == 0 || _capacity_in_bytes == byte_capacity,</span>
<span class="udiff-line-removed">-            &quot;changing capacity &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,</span>
<span class="udiff-line-removed">-            _capacity_in_bytes, byte_capacity);</span>
<span class="udiff-line-removed">-     _capacity_in_bytes = byte_capacity;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    static size_t byte_index_to_index(size_t ind) {
      assert(is_aligned(ind, _element_size), &quot;precondition&quot;);
      return ind / _element_size;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,31 +95,33 @@</span>
  
    size_t capacity() const {
      return byte_index_to_index(capacity_in_bytes());
    }
  
<span class="udiff-line-modified-removed">-   // If there is a lock associated with this buffer, this is that lock.</span>
<span class="udiff-line-removed">-   Mutex* _lock;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   PtrQueueSet* qset() { return _qset; }</span>
<span class="udiff-line-removed">-   bool is_permanent() const { return _permanent; }</span>
<span class="udiff-line-modified-added">+   PtrQueueSet* qset() const { return _qset; }</span>
  
    // Process queue entries and release resources.
    void flush_impl();
  
<span class="udiff-line-added">+   // Process (some of) the buffer and leave it in place for further use,</span>
<span class="udiff-line-added">+   // or enqueue the buffer and allocate a new one.</span>
<span class="udiff-line-added">+   virtual void handle_completed_buffer() = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   void allocate_buffer();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Enqueue the current buffer in the qset and allocate a new buffer.</span>
<span class="udiff-line-added">+   void enqueue_completed_buffer();</span>
<span class="udiff-line-added">+ </span>
    // Initialize this queue to contain a null buffer, and be part of the
    // given PtrQueueSet.
<span class="udiff-line-modified-removed">-   PtrQueue(PtrQueueSet* qset, bool permanent = false, bool active = false);</span>
<span class="udiff-line-modified-added">+   PtrQueue(PtrQueueSet* qset, bool active = false);</span>
  
<span class="udiff-line-modified-removed">-   // Requires queue flushed or permanent.</span>
<span class="udiff-line-modified-added">+   // Requires queue flushed.</span>
    ~PtrQueue();
  
  public:
  
<span class="udiff-line-removed">-   // Associate a lock with a ptr queue.</span>
<span class="udiff-line-removed">-   void set_lock(Mutex* lock) { _lock = lock; }</span>
<span class="udiff-line-removed">- </span>
    // Forcibly set empty.
    void reset() {
      if (_buf != NULL) {
        _index = capacity_in_bytes();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -147,18 +135,10 @@</span>
    void enqueue(void* ptr) {
      if (!_active) return;
      else enqueue_known_active(ptr);
    }
  
<span class="udiff-line-removed">-   // This method is called when we&#39;re doing the zero index handling</span>
<span class="udiff-line-removed">-   // and gives a chance to the queues to do any pre-enqueueing</span>
<span class="udiff-line-removed">-   // processing they might want to do on the buffer. It should return</span>
<span class="udiff-line-removed">-   // true if the buffer should be enqueued, or false if enough</span>
<span class="udiff-line-removed">-   // entries were cleared from it so that it can be re-used. It should</span>
<span class="udiff-line-removed">-   // not return false if the buffer is still full (otherwise we can</span>
<span class="udiff-line-removed">-   // get into an infinite loop).</span>
<span class="udiff-line-removed">-   virtual bool should_enqueue_buffer() { return true; }</span>
    void handle_zero_index();
  
    void enqueue_known_active(void* ptr);
  
    // Return the size of the in-use region.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,24 +202,24 @@</span>
    void* _buffer[1];             // Pseudo flexible array member.
  
    BufferNode() : _index(0), _next(NULL) { }
    ~BufferNode() { }
  
<span class="udiff-line-added">+   NONCOPYABLE(BufferNode);</span>
<span class="udiff-line-added">+ </span>
    static size_t buffer_offset() {
      return offset_of(BufferNode, _buffer);
    }
  
<span class="udiff-line-removed">-   static BufferNode* volatile* next_ptr(BufferNode&amp; bn) { return &amp;bn._next; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
    // Allocate a new BufferNode with the &quot;buffer&quot; having size elements.
    static BufferNode* allocate(size_t size);
  
    // Free a BufferNode.
    static void deallocate(BufferNode* node);
  
  public:
<span class="udiff-line-added">+   static BufferNode* volatile* next_ptr(BufferNode&amp; bn) { return &amp;bn._next; }</span>
    typedef LockFreeStack&lt;BufferNode, &amp;next_ptr&gt; Stack;
  
    BufferNode* next() const     { return _next;  }
    void set_next(BufferNode* n) { _next = n;     }
    size_t index() const         { return _index; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,10 +271,12 @@</span>
  #undef DECLARE_PADDED_MEMBER
  
    void delete_list(BufferNode* list);
    bool try_transfer_pending();
  
<span class="udiff-line-added">+   NONCOPYABLE(Allocator);</span>
<span class="udiff-line-added">+ </span>
  public:
    Allocator(const char* name, size_t buffer_size);
    ~Allocator();
  
    const char* name() const { return _name; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -313,55 +295,24 @@</span>
  // In particular, the individual queues allocate buffers from this shared
  // set, and return completed buffers to the set.
  class PtrQueueSet {
    BufferNode::Allocator* _allocator;
  
<span class="udiff-line-modified-removed">-   Monitor* _cbl_mon;  // Protects the fields below.</span>
<span class="udiff-line-removed">-   BufferNode* _completed_buffers_head;</span>
<span class="udiff-line-removed">-   BufferNode* _completed_buffers_tail;</span>
<span class="udiff-line-removed">-   size_t _n_completed_buffers;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t _process_completed_buffers_threshold;</span>
<span class="udiff-line-removed">-   volatile bool _process_completed_buffers;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If true, notify_all on _cbl_mon when the threshold is reached.</span>
<span class="udiff-line-removed">-   bool _notify_when_complete;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Maximum number of elements allowed on completed queue: after that,</span>
<span class="udiff-line-removed">-   // enqueuer does the work itself.</span>
<span class="udiff-line-removed">-   size_t _max_completed_buffers;</span>
<span class="udiff-line-removed">-   size_t _completed_buffers_padding;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void assert_completed_buffers_list_len_correct_locked() NOT_DEBUG_RETURN;</span>
<span class="udiff-line-modified-added">+   NONCOPYABLE(PtrQueueSet);</span>
  
  protected:
    bool _all_active;
  
<span class="udiff-line-removed">-   // A mutator thread does the the work of processing a buffer.</span>
<span class="udiff-line-removed">-   // Returns &quot;true&quot; iff the work is complete (and the buffer may be</span>
<span class="udiff-line-removed">-   // deallocated).</span>
<span class="udiff-line-removed">-   virtual bool mut_process_buffer(BufferNode* node) {</span>
<span class="udiff-line-removed">-     ShouldNotReachHere();</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    // Create an empty ptr queue set.
<span class="udiff-line-modified-removed">-   PtrQueueSet(bool notify_when_complete = false);</span>
<span class="udiff-line-modified-added">+   PtrQueueSet(BufferNode::Allocator* allocator);</span>
    ~PtrQueueSet();
  
<span class="udiff-line-removed">-   // Because of init-order concerns, we can&#39;t pass these as constructor</span>
<span class="udiff-line-removed">-   // arguments.</span>
<span class="udiff-line-removed">-   void initialize(Monitor* cbl_mon, BufferNode::Allocator* allocator);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // For (unlocked!) iteration over the completed buffers.</span>
<span class="udiff-line-removed">-   BufferNode* completed_buffers_head() const { return _completed_buffers_head; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Deallocate all of the completed buffers.</span>
<span class="udiff-line-removed">-   void abandon_completed_buffers();</span>
<span class="udiff-line-removed">- </span>
  public:
  
<span class="udiff-line-added">+   // Return the associated BufferNode allocator.</span>
<span class="udiff-line-added">+   BufferNode::Allocator* allocator() const { return _allocator; }</span>
<span class="udiff-line-added">+ </span>
    // Return the buffer for a BufferNode of size buffer_size().
    void** allocate_buffer();
  
    // Return an empty buffer to the free list.  The node is required
    // to have been allocated with a size of buffer_size().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -369,58 +320,15 @@</span>
  
    // A completed buffer is a buffer the mutator is finished with, and
    // is ready to be processed by the collector.  It need not be full.
  
    // Adds node to the completed buffer list.
<span class="udiff-line-modified-removed">-   void enqueue_completed_buffer(BufferNode* node);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // If the number of completed buffers is &gt; stop_at, then remove and</span>
<span class="udiff-line-removed">-   // return a completed buffer from the list.  Otherwise, return NULL.</span>
<span class="udiff-line-removed">-   BufferNode* get_completed_buffer(size_t stop_at = 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // To be invoked by the mutator.</span>
<span class="udiff-line-removed">-   bool process_or_enqueue_completed_buffer(BufferNode* node);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bool process_completed_buffers() { return _process_completed_buffers; }</span>
<span class="udiff-line-removed">-   void set_process_completed_buffers(bool x) { _process_completed_buffers = x; }</span>
<span class="udiff-line-modified-added">+   virtual void enqueue_completed_buffer(BufferNode* node) = 0;</span>
  
    bool is_active() { return _all_active; }
  
    size_t buffer_size() const {
      return _allocator-&gt;buffer_size();
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Get/Set the number of completed buffers that triggers log processing.</span>
<span class="udiff-line-removed">-   // Log processing should be done when the number of buffers exceeds the</span>
<span class="udiff-line-removed">-   // threshold.</span>
<span class="udiff-line-removed">-   void set_process_completed_buffers_threshold(size_t sz) {</span>
<span class="udiff-line-removed">-     _process_completed_buffers_threshold = sz;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   size_t process_completed_buffers_threshold() const {</span>
<span class="udiff-line-removed">-     return _process_completed_buffers_threshold;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static const size_t ProcessCompletedBuffersThresholdNever = ~size_t(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t completed_buffers_num() const { return _n_completed_buffers; }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void merge_bufferlists(PtrQueueSet* src);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_max_completed_buffers(size_t m) {</span>
<span class="udiff-line-removed">-     _max_completed_buffers = m;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   size_t max_completed_buffers() const {</span>
<span class="udiff-line-removed">-     return _max_completed_buffers;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   static const size_t MaxCompletedBuffersUnlimited = ~size_t(0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_completed_buffers_padding(size_t padding) {</span>
<span class="udiff-line-removed">-     _completed_buffers_padding = padding;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   size_t completed_buffers_padding() const {</span>
<span class="udiff-line-removed">-     return _completed_buffers_padding;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   // Notify the consumer if the number of buffers crossed the threshold</span>
<span class="udiff-line-removed">-   void notify_if_necessary();</span>
  };
  
  #endif // SHARE_GC_SHARED_PTRQUEUE_HPP
</pre>
<center><a href="ptrQueue.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
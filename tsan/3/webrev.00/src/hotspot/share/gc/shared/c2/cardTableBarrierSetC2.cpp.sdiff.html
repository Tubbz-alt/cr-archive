<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/c2/cardTableBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cardGeneration.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c2/cardTableBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 28 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 29 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 30 #include &quot;opto/arraycopynode.hpp&quot;
 31 #include &quot;opto/graphKit.hpp&quot;
 32 #include &quot;opto/idealKit.hpp&quot;
 33 #include &quot;opto/macro.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 #define __ ideal.
 37 
 38 Node* CardTableBarrierSetC2::byte_map_base_node(GraphKit* kit) const {
 39   // Get base of card map
 40   CardTable::CardValue* card_table_base = ci_card_table_address();
 41    if (card_table_base != NULL) {
 42      return kit-&gt;makecon(TypeRawPtr::make((address)card_table_base));
 43    } else {
 44      return kit-&gt;null();
 45    }
 46 }
 47 
<span class="line-modified"> 48 // vanilla/CMS post barrier</span>
 49 // Insert a write-barrier store.  This is to let generational GC work; we have
 50 // to flag all oop-stores before the next GC point.
 51 void CardTableBarrierSetC2::post_barrier(GraphKit* kit,
 52                                          Node* ctl,
 53                                          Node* oop_store,
 54                                          Node* obj,
 55                                          Node* adr,
 56                                          uint  adr_idx,
 57                                          Node* val,
 58                                          BasicType bt,
 59                                          bool use_precise) const {
 60   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
 61   CardTable* ct = ctbs-&gt;card_table();
 62   // No store check needed if we&#39;re storing a NULL or an old object
 63   // (latter case is probably a string constant). The concurrent
 64   // mark sweep garbage collector, however, needs to have all nonNull
 65   // oop updates flagged via card-marks.
 66   if (val != NULL &amp;&amp; val-&gt;is_Con()) {
 67     // must be either an oop or NULL
 68     const Type* t = val-&gt;bottom_type();
</pre>
<hr />
<pre>
170 
171 void CardTableBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {
172   assert(node-&gt;Opcode() == Op_CastP2X, &quot;ConvP2XNode required&quot;);
173   Node *shift = node-&gt;unique_out();
174   Node *addp = shift-&gt;unique_out();
175   for (DUIterator_Last jmin, j = addp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
176     Node *mem = addp-&gt;last_out(j);
177     if (UseCondCardMark &amp;&amp; mem-&gt;is_Load()) {
178       assert(mem-&gt;Opcode() == Op_LoadB, &quot;unexpected code shape&quot;);
179       // The load is checking if the card has been written so
180       // replace it with zero to fold the test.
181       macro-&gt;replace_node(mem, macro-&gt;intcon(0));
182       continue;
183     }
184     assert(mem-&gt;is_Store(), &quot;store required&quot;);
185     macro-&gt;replace_node(mem, mem-&gt;in(MemNode::Memory));
186   }
187 }
188 
189 bool CardTableBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
<span class="line-modified">190   bool is_oop = type == T_OBJECT || type == T_ARRAY;</span>
191   return is_oop &amp;&amp; (!tightly_coupled_alloc || !use_ReduceInitialCardMarks());
192 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 28 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 29 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 30 #include &quot;opto/arraycopynode.hpp&quot;
 31 #include &quot;opto/graphKit.hpp&quot;
 32 #include &quot;opto/idealKit.hpp&quot;
 33 #include &quot;opto/macro.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 #define __ ideal.
 37 
 38 Node* CardTableBarrierSetC2::byte_map_base_node(GraphKit* kit) const {
 39   // Get base of card map
 40   CardTable::CardValue* card_table_base = ci_card_table_address();
 41    if (card_table_base != NULL) {
 42      return kit-&gt;makecon(TypeRawPtr::make((address)card_table_base));
 43    } else {
 44      return kit-&gt;null();
 45    }
 46 }
 47 
<span class="line-modified"> 48 // vanilla post barrier</span>
 49 // Insert a write-barrier store.  This is to let generational GC work; we have
 50 // to flag all oop-stores before the next GC point.
 51 void CardTableBarrierSetC2::post_barrier(GraphKit* kit,
 52                                          Node* ctl,
 53                                          Node* oop_store,
 54                                          Node* obj,
 55                                          Node* adr,
 56                                          uint  adr_idx,
 57                                          Node* val,
 58                                          BasicType bt,
 59                                          bool use_precise) const {
 60   CardTableBarrierSet* ctbs = barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
 61   CardTable* ct = ctbs-&gt;card_table();
 62   // No store check needed if we&#39;re storing a NULL or an old object
 63   // (latter case is probably a string constant). The concurrent
 64   // mark sweep garbage collector, however, needs to have all nonNull
 65   // oop updates flagged via card-marks.
 66   if (val != NULL &amp;&amp; val-&gt;is_Con()) {
 67     // must be either an oop or NULL
 68     const Type* t = val-&gt;bottom_type();
</pre>
<hr />
<pre>
170 
171 void CardTableBarrierSetC2::eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const {
172   assert(node-&gt;Opcode() == Op_CastP2X, &quot;ConvP2XNode required&quot;);
173   Node *shift = node-&gt;unique_out();
174   Node *addp = shift-&gt;unique_out();
175   for (DUIterator_Last jmin, j = addp-&gt;last_outs(jmin); j &gt;= jmin; --j) {
176     Node *mem = addp-&gt;last_out(j);
177     if (UseCondCardMark &amp;&amp; mem-&gt;is_Load()) {
178       assert(mem-&gt;Opcode() == Op_LoadB, &quot;unexpected code shape&quot;);
179       // The load is checking if the card has been written so
180       // replace it with zero to fold the test.
181       macro-&gt;replace_node(mem, macro-&gt;intcon(0));
182       continue;
183     }
184     assert(mem-&gt;is_Store(), &quot;store required&quot;);
185     macro-&gt;replace_node(mem, mem-&gt;in(MemNode::Memory));
186   }
187 }
188 
189 bool CardTableBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {
<span class="line-modified">190   bool is_oop = is_reference_type(type);</span>
191   return is_oop &amp;&amp; (!tightly_coupled_alloc || !use_ReduceInitialCardMarks());
192 }
</pre>
</td>
</tr>
</table>
<center><a href="barrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../cardGeneration.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
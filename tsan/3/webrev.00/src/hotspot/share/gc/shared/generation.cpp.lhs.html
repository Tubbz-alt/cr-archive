<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/generation.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/shared/cardTableRS.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcLocker.hpp&quot;
 30 #include &quot;gc/shared/gcTimer.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;gc/shared/genOopClosures.hpp&quot;
 34 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 35 #include &quot;gc/shared/generation.hpp&quot;
<a name="2" id="anc2"></a>
 36 #include &quot;gc/shared/space.inline.hpp&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 37 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
 38 #include &quot;logging/log.hpp&quot;
 39 #include &quot;memory/allocation.inline.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;runtime/java.hpp&quot;
 42 #include &quot;utilities/copy.hpp&quot;
 43 #include &quot;utilities/events.hpp&quot;
 44 
 45 Generation::Generation(ReservedSpace rs, size_t initial_size) :
 46   _gc_manager(NULL),
 47   _ref_processor(NULL) {
 48   if (!_virtual_space.initialize(rs, initial_size)) {
 49     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 50                     &quot;object heap&quot;);
 51   }
 52   // Mangle all of the the initial generation.
 53   if (ZapUnusedHeapArea) {
 54     MemRegion mangle_region((HeapWord*)_virtual_space.low(),
 55       (HeapWord*)_virtual_space.high());
 56     SpaceMangler::mangle_region(mangle_region);
 57   }
 58   _reserved = MemRegion((HeapWord*)_virtual_space.low_boundary(),
 59           (HeapWord*)_virtual_space.high_boundary());
 60 }
 61 
 62 size_t Generation::initial_size() {
 63   GenCollectedHeap* gch = GenCollectedHeap::heap();
 64   if (gch-&gt;is_young_gen(this)) {
 65     return gch-&gt;young_gen_spec()-&gt;init_size();
 66   }
 67   return gch-&gt;old_gen_spec()-&gt;init_size();
 68 }
 69 
 70 size_t Generation::max_capacity() const {
 71   return reserved().byte_size();
 72 }
 73 
 74 // By default we get a single threaded default reference processor;
 75 // generations needing multi-threaded refs processing or discovery override this method.
 76 void Generation::ref_processor_init() {
 77   assert(_ref_processor == NULL, &quot;a reference processor already exists&quot;);
 78   assert(!_reserved.is_empty(), &quot;empty generation?&quot;);
 79   _span_based_discoverer.set_span(_reserved);
 80   _ref_processor = new ReferenceProcessor(&amp;_span_based_discoverer);    // a vanilla reference processor
<a name="4" id="anc4"></a><span class="line-removed"> 81   if (_ref_processor == NULL) {</span>
<span class="line-removed"> 82     vm_exit_during_initialization(&quot;Could not allocate ReferenceProcessor object&quot;);</span>
<span class="line-removed"> 83   }</span>
 84 }
 85 
 86 void Generation::print() const { print_on(tty); }
 87 
 88 void Generation::print_on(outputStream* st)  const {
 89   st-&gt;print(&quot; %-20s&quot;, name());
 90   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
 91              capacity()/K, used()/K);
 92   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
 93               p2i(_virtual_space.low_boundary()),
 94               p2i(_virtual_space.high()),
 95               p2i(_virtual_space.high_boundary()));
 96 }
 97 
 98 void Generation::print_summary_info_on(outputStream* st) {
 99   StatRecord* sr = stat_record();
100   double time = sr-&gt;accumulated_time.seconds();
101   st-&gt;print_cr(&quot;Accumulated %s generation GC time %3.7f secs, &quot;
102                &quot;%u GC&#39;s, avg GC time %3.7f&quot;,
103                GenCollectedHeap::heap()-&gt;is_young_gen(this) ? &quot;young&quot; : &quot;old&quot; ,
104                time,
105                sr-&gt;invocations,
106                sr-&gt;invocations &gt; 0 ? time / sr-&gt;invocations : 0.0);
107 }
108 
109 // Utility iterator classes
110 
111 class GenerationIsInReservedClosure : public SpaceClosure {
112  public:
113   const void* _p;
114   Space* sp;
115   virtual void do_space(Space* s) {
116     if (sp == NULL) {
117       if (s-&gt;is_in_reserved(_p)) sp = s;
118     }
119   }
120   GenerationIsInReservedClosure(const void* p) : _p(p), sp(NULL) {}
121 };
122 
123 class GenerationIsInClosure : public SpaceClosure {
124  public:
125   const void* _p;
126   Space* sp;
127   virtual void do_space(Space* s) {
128     if (sp == NULL) {
129       if (s-&gt;is_in(_p)) sp = s;
130     }
131   }
132   GenerationIsInClosure(const void* p) : _p(p), sp(NULL) {}
133 };
134 
135 bool Generation::is_in(const void* p) const {
136   GenerationIsInClosure blk(p);
137   ((Generation*)this)-&gt;space_iterate(&amp;blk);
138   return blk.sp != NULL;
139 }
140 
141 size_t Generation::max_contiguous_available() const {
142   // The largest number of contiguous free words in this or any higher generation.
143   size_t avail = contiguous_available();
144   size_t old_avail = 0;
145   if (GenCollectedHeap::heap()-&gt;is_young_gen(this)) {
146     old_avail = GenCollectedHeap::heap()-&gt;old_gen()-&gt;contiguous_available();
147   }
148   return MAX2(avail, old_avail);
149 }
150 
151 bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {
152   size_t available = max_contiguous_available();
153   bool   res = (available &gt;= max_promotion_in_bytes);
154   log_trace(gc)(&quot;Generation: promo attempt is%s safe: available(&quot; SIZE_FORMAT &quot;) %s max_promo(&quot; SIZE_FORMAT &quot;)&quot;,
155                 res? &quot;&quot;:&quot; not&quot;, available, res? &quot;&gt;=&quot;:&quot;&lt;&quot;, max_promotion_in_bytes);
156   return res;
157 }
158 
159 // Ignores &quot;ref&quot; and calls allocate().
160 oop Generation::promote(oop obj, size_t obj_size) {
161   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
162 
163 #ifndef PRODUCT
164   if (GenCollectedHeap::heap()-&gt;promotion_should_fail()) {
165     return NULL;
166   }
167 #endif  // #ifndef PRODUCT
168 
169   HeapWord* result = allocate(obj_size, false);
170   if (result != NULL) {
<a name="5" id="anc5"></a><span class="line-modified">171     Copy::aligned_disjoint_words((HeapWord*)obj, result, obj_size);</span>
172     return oop(result);
173   } else {
174     GenCollectedHeap* gch = GenCollectedHeap::heap();
175     return gch-&gt;handle_failed_promotion(this, obj, obj_size);
176   }
177 }
178 
179 oop Generation::par_promote(int thread_num,
<a name="6" id="anc6"></a><span class="line-modified">180                             oop obj, markOop m, size_t word_sz) {</span>
181   // Could do a bad general impl here that gets a lock.  But no.
182   ShouldNotCallThis();
183   return NULL;
184 }
185 
186 Space* Generation::space_containing(const void* p) const {
187   GenerationIsInReservedClosure blk(p);
188   // Cast away const
189   ((Generation*)this)-&gt;space_iterate(&amp;blk);
190   return blk.sp;
191 }
192 
193 // Some of these are mediocre general implementations.  Should be
194 // overridden to get better performance.
195 
196 class GenerationBlockStartClosure : public SpaceClosure {
197  public:
198   const void* _p;
199   HeapWord* _start;
200   virtual void do_space(Space* s) {
201     if (_start == NULL &amp;&amp; s-&gt;is_in_reserved(_p)) {
202       _start = s-&gt;block_start(_p);
203     }
204   }
205   GenerationBlockStartClosure(const void* p) { _p = p; _start = NULL; }
206 };
207 
208 HeapWord* Generation::block_start(const void* p) const {
209   GenerationBlockStartClosure blk(p);
210   // Cast away const
211   ((Generation*)this)-&gt;space_iterate(&amp;blk);
212   return blk._start;
213 }
214 
215 class GenerationBlockSizeClosure : public SpaceClosure {
216  public:
217   const HeapWord* _p;
218   size_t size;
219   virtual void do_space(Space* s) {
220     if (size == 0 &amp;&amp; s-&gt;is_in_reserved(_p)) {
221       size = s-&gt;block_size(_p);
222     }
223   }
224   GenerationBlockSizeClosure(const HeapWord* p) { _p = p; size = 0; }
225 };
226 
227 size_t Generation::block_size(const HeapWord* p) const {
228   GenerationBlockSizeClosure blk(p);
229   // Cast away const
230   ((Generation*)this)-&gt;space_iterate(&amp;blk);
231   assert(blk.size &gt; 0, &quot;seems reasonable&quot;);
232   return blk.size;
233 }
234 
235 class GenerationBlockIsObjClosure : public SpaceClosure {
236  public:
237   const HeapWord* _p;
238   bool is_obj;
239   virtual void do_space(Space* s) {
240     if (!is_obj &amp;&amp; s-&gt;is_in_reserved(_p)) {
241       is_obj |= s-&gt;block_is_obj(_p);
242     }
243   }
244   GenerationBlockIsObjClosure(const HeapWord* p) { _p = p; is_obj = false; }
245 };
246 
247 bool Generation::block_is_obj(const HeapWord* p) const {
248   GenerationBlockIsObjClosure blk(p);
249   // Cast away const
250   ((Generation*)this)-&gt;space_iterate(&amp;blk);
251   return blk.is_obj;
252 }
253 
254 class GenerationOopIterateClosure : public SpaceClosure {
255  public:
256   OopIterateClosure* _cl;
257   virtual void do_space(Space* s) {
258     s-&gt;oop_iterate(_cl);
259   }
260   GenerationOopIterateClosure(OopIterateClosure* cl) :
261     _cl(cl) {}
262 };
263 
264 void Generation::oop_iterate(OopIterateClosure* cl) {
265   GenerationOopIterateClosure blk(cl);
266   space_iterate(&amp;blk);
267 }
268 
269 void Generation::younger_refs_in_space_iterate(Space* sp,
270                                                OopsInGenClosure* cl,
271                                                uint n_threads) {
272   CardTableRS* rs = GenCollectedHeap::heap()-&gt;rem_set();
273   rs-&gt;younger_refs_in_space_iterate(sp, cl, n_threads);
274 }
275 
276 class GenerationObjIterateClosure : public SpaceClosure {
277  private:
278   ObjectClosure* _cl;
279  public:
280   virtual void do_space(Space* s) {
281     s-&gt;object_iterate(_cl);
282   }
283   GenerationObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}
284 };
285 
286 void Generation::object_iterate(ObjectClosure* cl) {
287   GenerationObjIterateClosure blk(cl);
288   space_iterate(&amp;blk);
289 }
290 
<a name="7" id="anc7"></a><span class="line-removed">291 class GenerationSafeObjIterateClosure : public SpaceClosure {</span>
<span class="line-removed">292  private:</span>
<span class="line-removed">293   ObjectClosure* _cl;</span>
<span class="line-removed">294  public:</span>
<span class="line-removed">295   virtual void do_space(Space* s) {</span>
<span class="line-removed">296     s-&gt;safe_object_iterate(_cl);</span>
<span class="line-removed">297   }</span>
<span class="line-removed">298   GenerationSafeObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}</span>
<span class="line-removed">299 };</span>
<span class="line-removed">300 </span>
<span class="line-removed">301 void Generation::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-removed">302   GenerationSafeObjIterateClosure blk(cl);</span>
<span class="line-removed">303   space_iterate(&amp;blk);</span>
<span class="line-removed">304 }</span>
<span class="line-removed">305 </span>
306 #if INCLUDE_SERIALGC
307 
308 void Generation::prepare_for_compaction(CompactPoint* cp) {
309   // Generic implementation, can be specialized
310   CompactibleSpace* space = first_compaction_space();
311   while (space != NULL) {
312     space-&gt;prepare_for_compaction(cp);
313     space = space-&gt;next_compaction_space();
314   }
315 }
316 
317 class AdjustPointersClosure: public SpaceClosure {
318  public:
319   void do_space(Space* sp) {
320     sp-&gt;adjust_pointers();
321   }
322 };
323 
324 void Generation::adjust_pointers() {
325   // Note that this is done over all spaces, not just the compactible
326   // ones.
327   AdjustPointersClosure blk;
328   space_iterate(&amp;blk, true);
329 }
330 
331 void Generation::compact() {
332   CompactibleSpace* sp = first_compaction_space();
333   while (sp != NULL) {
334     sp-&gt;compact();
335     sp = sp-&gt;next_compaction_space();
336   }
337 }
338 
339 #endif // INCLUDE_SERIALGC
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/scavengableNMethods.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;
<a name="1" id="anc1"></a>

 28 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 29 #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 30 #include &quot;runtime/mutexLocker.hpp&quot;</span>


 31 #include &quot;utilities/debug.hpp&quot;
 32 
 33 static ScavengableNMethodsData gc_data(nmethod* nm) {
 34   return ScavengableNMethodsData(nm);
 35 }
 36 
 37 nmethod* ScavengableNMethods::_head = NULL;
 38 BoolObjectClosure* ScavengableNMethods::_is_scavengable = NULL;
 39 
 40 void ScavengableNMethods::initialize(BoolObjectClosure* is_scavengable) {
 41   _is_scavengable = is_scavengable;
 42 }
 43 
 44 // Conditionally adds the nmethod to the list if it is
 45 // not already on the list and has a scavengeable root.
 46 void ScavengableNMethods::register_nmethod(nmethod* nm) {
 47   assert_locked_or_safepoint(CodeCache_lock);
 48 
 49   ScavengableNMethodsData data = gc_data(nm);
 50 
 51   if (data.on_list() || !has_scavengable_oops(nm)) {
 52     return;
 53   }
 54 
 55   data.set_on_list();
 56   data.set_next(_head);
 57 
 58   _head = nm;
<a name="3" id="anc3"></a>

 59 }
 60 
 61 void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<a name="4" id="anc4"></a><span class="line-modified"> 62   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64   if (gc_data(nm).on_list()) {</span>
<span class="line-added"> 65     nmethod* prev = NULL;</span>
<span class="line-added"> 66     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-added"> 67       if (cur == nm) {</span>
<span class="line-added"> 68         unlist_nmethod(cur, prev);</span>
<span class="line-added"> 69         return;</span>
<span class="line-added"> 70       }</span>
<span class="line-added"> 71       prev = cur;</span>
<span class="line-added"> 72     }</span>
<span class="line-added"> 73   }</span>
 74 }
 75 
 76 #ifndef PRODUCT
 77 
 78 class DebugScavengableOops: public OopClosure {
 79   BoolObjectClosure* _is_scavengable;
 80   nmethod*           _nm;
 81   bool               _ok;
 82 public:
 83   DebugScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
 84       _is_scavengable(is_scavengable),
 85       _nm(nm),
 86       _ok(true) { }
 87 
 88   bool ok() { return _ok; }
 89   virtual void do_oop(oop* p) {
 90     if (*p == NULL || !_is_scavengable-&gt;do_object_b(*p)) {
 91       return;
 92     }
 93 
 94     if (_ok) {
 95       _nm-&gt;print_nmethod(true);
 96       _ok = false;
 97     }
 98     tty-&gt;print_cr(&quot;*** scavengable oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,
 99                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));
100     (*p)-&gt;print();
101   }
102   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
103 };
104 
105 #endif // PRODUCT
106 
107 void ScavengableNMethods::verify_nmethod(nmethod* nm) {
108 #ifndef PRODUCT
109   if (!gc_data(nm).on_list()) {
110     // Actually look inside, to verify the claim that it&#39;s clean.
111     DebugScavengableOops cl(_is_scavengable, nm);
112     nm-&gt;oops_do(&amp;cl);
113     if (!cl.ok())
114       fatal(&quot;found an unadvertised bad scavengable oop in the code cache&quot;);
115   }
116   assert(gc_data(nm).not_marked(), &quot;&quot;);
117 #endif // PRODUCT
118 }
119 
<a name="5" id="anc5"></a>
















120 class HasScavengableOops: public OopClosure {
121   BoolObjectClosure* _is_scavengable;
122   bool               _found;
<a name="6" id="anc6"></a>
123 public:
124   HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
125       _is_scavengable(is_scavengable),
<a name="7" id="anc7"></a><span class="line-modified">126       _found(false) {}</span>

127 
128   bool found() { return _found; }
129   virtual void do_oop(oop* p) {
<a name="8" id="anc8"></a><span class="line-modified">130     if (!_found &amp;&amp; *p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>

131       _found = true;
132     }
133   }
134   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
<a name="9" id="anc9"></a>















135 };
136 
137 bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
138   HasScavengableOops cl(_is_scavengable, nm);
139   nm-&gt;oops_do(&amp;cl);
140   return cl.found();
141 }
142 
143 // Walk the list of methods which might contain oops to the java heap.
<a name="10" id="anc10"></a><span class="line-modified">144 void ScavengableNMethods::nmethods_do_and_prune(CodeBlobToOopClosure* cl) {</span>
145   assert_locked_or_safepoint(CodeCache_lock);
146 
<a name="11" id="anc11"></a>
147   debug_only(mark_on_list_nmethods());
148 
149   nmethod* prev = NULL;
150   nmethod* cur = _head;
151   while (cur != NULL) {
<a name="12" id="anc12"></a><span class="line-added">152     assert(cur-&gt;is_alive(), &quot;Must be&quot;);</span>
<span class="line-added">153 </span>
154     ScavengableNMethodsData data = gc_data(cur);
155     debug_only(data.clear_marked());
<a name="13" id="anc13"></a>
156     assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
157 
<a name="14" id="anc14"></a><span class="line-modified">158     if (cl != NULL) {</span>
<span class="line-modified">159       cl-&gt;do_code_blob(cur);</span>








160     }
<a name="15" id="anc15"></a><span class="line-added">161 </span>
162     nmethod* const next = data.next();
<a name="16" id="anc16"></a><span class="line-modified">163 </span>
<span class="line-modified">164     if (!has_scavengable_oops(cur)) {</span>
<span class="line-modified">165       unlist_nmethod(cur, prev);</span>
<span class="line-modified">166     } else {</span>
<span class="line-modified">167       prev = cur;</span>




168     }
<a name="17" id="anc17"></a><span class="line-added">169 </span>
170     cur = next;
171   }
172 
173   // Check for stray marks.
174   debug_only(verify_unlisted_nmethods(NULL));
175 }
176 
<a name="18" id="anc18"></a><span class="line-added">177 void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-added">178   nmethods_do_and_prune(NULL /* No closure */);</span>
<span class="line-added">179 }</span>
<span class="line-added">180 </span>
<span class="line-added">181 // Walk the list of methods which might contain oops to the java heap.</span>
<span class="line-added">182 void ScavengableNMethods::nmethods_do(CodeBlobToOopClosure* cl) {</span>
<span class="line-added">183   nmethods_do_and_prune(cl);</span>
<span class="line-added">184 }</span>
<span class="line-added">185 </span>
186 #ifndef PRODUCT
<a name="19" id="anc19"></a><span class="line-modified">187 void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* cl) {</span>
188   // While we are here, verify the integrity of the list.
189   mark_on_list_nmethods();
190   for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
191     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
192     gc_data(cur).clear_marked();
193   }
<a name="20" id="anc20"></a><span class="line-modified">194   verify_unlisted_nmethods(cl);</span>
195 }
196 #endif // PRODUCT
197 
198 void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
199   assert_locked_or_safepoint(CodeCache_lock);
200 
201   assert((prev == NULL &amp;&amp; _head == nm) ||
202          (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
203 
<a name="21" id="anc21"></a>

204   ScavengableNMethodsData data = gc_data(nm);
205 
206   if (prev == NULL) {
207     _head = data.next();
208   } else {
209     gc_data(prev).set_next(data.next());
210   }
211   data.set_next(NULL);
212   data.clear_on_list();
213 }
214 
<a name="22" id="anc22"></a>


























215 #ifndef PRODUCT
216 // Temporarily mark nmethods that are claimed to be on the scavenge list.
217 void ScavengableNMethods::mark_on_list_nmethods() {
218   NMethodIterator iter(NMethodIterator::only_alive);
219   while(iter.next()) {
220     nmethod* nm = iter.method();
221     ScavengableNMethodsData data = gc_data(nm);
222     assert(data.not_marked(), &quot;clean state&quot;);
223     if (data.on_list())
224       data.set_marked();
225   }
226 }
227 
228 // If the closure is given, run it on the unlisted nmethods.
229 // Also make sure that the effects of mark_on_list_nmethods is gone.
<a name="23" id="anc23"></a><span class="line-modified">230 void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* cl) {</span>
231   NMethodIterator iter(NMethodIterator::only_alive);
232   while(iter.next()) {
233     nmethod* nm = iter.method();
234 
235     verify_nmethod(nm);
236 
<a name="24" id="anc24"></a><span class="line-modified">237     if (cl != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">238       cl-&gt;do_code_blob(nm);</span>
239     }
240   }
241 }
242 
243 #endif //PRODUCT
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/referenceProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ptrQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/referenceProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
  #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/access.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  
  ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,13 ***</span>
    if (is_server_compilation_mode_vm()) {
      _default_soft_ref_policy = new LRUMaxHeapPolicy();
    } else {
      _default_soft_ref_policy = new LRUCurrentHeapPolicy();
    }
<span class="line-removed">-   if (_always_clear_soft_ref_policy == NULL || _default_soft_ref_policy == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not allocate reference policy object&quot;);</span>
<span class="line-removed">-   }</span>
    guarantee(RefDiscoveryPolicy == ReferenceBasedDiscovery ||
              RefDiscoveryPolicy == ReferentBasedDiscovery,
              &quot;Unrecognized RefDiscoveryPolicy&quot;);
  }
  
<span class="line-new-header">--- 62,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,13 ***</span>
    _num_queues          = MAX2(1U, mt_processing_degree);
    _max_num_queues      = MAX2(_num_queues, mt_discovery_degree);
    _discovered_refs     = NEW_C_HEAP_ARRAY(DiscoveredList,
              _max_num_queues * number_of_subclasses_of_ref(), mtGC);
  
<span class="line-removed">-   if (_discovered_refs == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not allocated RefProc Array&quot;);</span>
<span class="line-removed">-   }</span>
    _discoveredSoftRefs    = &amp;_discovered_refs[0];
    _discoveredWeakRefs    = &amp;_discoveredSoftRefs[_max_num_queues];
    _discoveredFinalRefs   = &amp;_discoveredWeakRefs[_max_num_queues];
    _discoveredPhantomRefs = &amp;_discoveredFinalRefs[_max_num_queues];
  
<span class="line-new-header">--- 114,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,11 ***</span>
           &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
    _next_discovered = discovered;
  
    _referent_addr = java_lang_ref_Reference::referent_addr_raw(_current_discovered);
    _referent = java_lang_ref_Reference::referent(_current_discovered);
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_reserved_or_null(_referent),</span>
           &quot;Wrong oop found in java.lang.Reference object&quot;);
    assert(allow_null_referent ?
               oopDesc::is_oop_or_null(_referent)
             : oopDesc::is_oop(_referent),
           &quot;Expected an oop%s for referent field at &quot; PTR_FORMAT,
<span class="line-new-header">--- 261,11 ---</span>
           &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
    _next_discovered = discovered;
  
    _referent_addr = java_lang_ref_Reference::referent_addr_raw(_current_discovered);
    _referent = java_lang_ref_Reference::referent(_current_discovered);
<span class="line-modified">!   assert(Universe::heap()-&gt;is_in_or_null(_referent),</span>
           &quot;Wrong oop found in java.lang.Reference object&quot;);
    assert(allow_null_referent ?
               oopDesc::is_oop_or_null(_referent)
             : oopDesc::is_oop(_referent),
           &quot;Expected an oop%s for referent field at &quot; PTR_FORMAT,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,11 ***</span>
    assert(oopDesc::is_oop(_current_discovered), &quot;Dropping a bad reference&quot;);
    RawAccess&lt;&gt;::oop_store(_current_discovered_addr, oop(NULL));
  
    // First _prev_next ref actually points into DiscoveredList (gross).
    oop new_next;
<span class="line-modified">!   if (oopDesc::equals_raw(_next_discovered, _current_discovered)) {</span>
      // At the end of the list, we should make _prev point to itself.
      // If _ref is the first ref, then _prev_next will be in the DiscoveredList,
      // and _prev will be NULL.
      new_next = _prev_discovered;
    } else {
<span class="line-new-header">--- 277,11 ---</span>
    assert(oopDesc::is_oop(_current_discovered), &quot;Dropping a bad reference&quot;);
    RawAccess&lt;&gt;::oop_store(_current_discovered_addr, oop(NULL));
  
    // First _prev_next ref actually points into DiscoveredList (gross).
    oop new_next;
<span class="line-modified">!   if (_next_discovered == _current_discovered) {</span>
      // At the end of the list, we should make _prev point to itself.
      // If _ref is the first ref, then _prev_next will be in the DiscoveredList,
      // and _prev will be NULL.
      new_next = _prev_discovered;
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,11 ***</span>
    if (log_develop_is_enabled(Trace, gc, ref)) {
      ResourceMark rm;
      log_develop_trace(gc, ref)(&quot;Enqueue %s reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
                                 reason, p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
    }
<span class="line-modified">!   assert(oopDesc::is_oop(iter.obj(), UseConcMarkSweepGC), &quot;Adding a bad reference&quot;);</span>
  }
  
  size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&amp;    refs_list,
                                                              ReferencePolicy*   policy,
                                                              BoolObjectClosure* is_alive,
<span class="line-new-header">--- 328,11 ---</span>
    if (log_develop_is_enabled(Trace, gc, ref)) {
      ResourceMark rm;
      log_develop_trace(gc, ref)(&quot;Enqueue %s reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
                                 reason, p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
    }
<span class="line-modified">!   assert(oopDesc::is_oop(iter.obj()), &quot;Adding a bad reference&quot;);</span>
  }
  
  size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&amp;    refs_list,
                                                              ReferencePolicy*   policy,
                                                              BoolObjectClosure* is_alive,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,11 ***</span>
  
  void
  ReferenceProcessor::clear_discovered_references(DiscoveredList&amp; refs_list) {
    oop obj = NULL;
    oop next = refs_list.head();
<span class="line-modified">!   while (!oopDesc::equals_raw(next, obj)) {</span>
      obj = next;
      next = java_lang_ref_Reference::discovered(obj);
      java_lang_ref_Reference::set_discovered_raw(obj, NULL);
    }
    refs_list.clear();
<span class="line-new-header">--- 467,11 ---</span>
  
  void
  ReferenceProcessor::clear_discovered_references(DiscoveredList&amp; refs_list) {
    oop obj = NULL;
    oop next = refs_list.head();
<span class="line-modified">!   while (next != obj) {</span>
      obj = next;
      next = java_lang_ref_Reference::discovered(obj);
      java_lang_ref_Reference::set_discovered_raw(obj, NULL);
    }
    refs_list.clear();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 744,11 ***</span>
          }
          ref_lists[to_idx].set_head(move_head);
          ref_lists[to_idx].inc_length(refs_to_move);
  
          // Remove the chain from the from list.
<span class="line-modified">!         if (oopDesc::equals_raw(move_tail, new_head)) {</span>
            // We found the end of the from list.
            ref_lists[from_idx].set_head(NULL);
          } else {
            ref_lists[from_idx].set_head(new_head);
          }
<span class="line-new-header">--- 739,11 ---</span>
          }
          ref_lists[to_idx].set_head(move_head);
          ref_lists[to_idx].inc_length(refs_to_move);
  
          // Remove the chain from the from list.
<span class="line-modified">!         if (move_tail == new_head) {</span>
            // We found the end of the from list.
            ref_lists[from_idx].set_head(NULL);
          } else {
            ref_lists[from_idx].set_head(new_head);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1031,11 ***</span>
    // discovered_addr.
    oop current_head = refs_list.head();
    // The last ref must have its discovered field pointing to itself.
    oop next_discovered = (current_head != NULL) ? current_head : obj;
  
<span class="line-modified">!   oop retest = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_atomic_cmpxchg(next_discovered, discovered_addr, oop(NULL));</span>
  
    if (retest == NULL) {
      // This thread just won the right to enqueue the object.
      // We have separate lists for enqueueing, so no synchronization
      // is necessary.
<span class="line-new-header">--- 1026,11 ---</span>
    // discovered_addr.
    oop current_head = refs_list.head();
    // The last ref must have its discovered field pointing to itself.
    oop next_discovered = (current_head != NULL) ? current_head : obj;
  
<span class="line-modified">!   oop retest = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);</span>
  
    if (retest == NULL) {
      // This thread just won the right to enqueue the object.
      // We have separate lists for enqueueing, so no synchronization
      // is necessary.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1154,11 ***</span>
        assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,
               &quot;Unrecognized policy&quot;);
        // Check assumption that an object is not potentially
        // discovered twice except by concurrent collectors that potentially
        // trace the same Reference object twice.
<span class="line-modified">!       assert(UseConcMarkSweepGC || UseG1GC || UseShenandoahGC,</span>
               &quot;Only possible with a concurrent marking collector&quot;);
        return true;
      }
    }
  
<span class="line-new-header">--- 1149,11 ---</span>
        assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,
               &quot;Unrecognized policy&quot;);
        // Check assumption that an object is not potentially
        // discovered twice except by concurrent collectors that potentially
        // trace the same Reference object twice.
<span class="line-modified">!       assert(UseG1GC || UseShenandoahGC,</span>
               &quot;Only possible with a concurrent marking collector&quot;);
        return true;
      }
    }
  
</pre>
<center><a href="ptrQueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
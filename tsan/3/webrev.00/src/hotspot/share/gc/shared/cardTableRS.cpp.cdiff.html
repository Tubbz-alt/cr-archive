<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/cardTableRS.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cardTableBarrierSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableRS.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardTableRS.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
             &quot;We shouldn&#39;t be looking at clean cards, and this should &quot;
             &quot;be the only place they get cleaned.&quot;);
      if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)
          || _ct-&gt;is_prev_youngergen_card_val(entry_val)) {
        CardValue res =
<span class="line-modified">!         Atomic::cmpxchg(CardTableRS::clean_card_val(), entry, entry_val);</span>
        if (res == entry_val) {
          break;
        } else {
          assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,
                 &quot;The CAS above should only fail if another thread did &quot;
<span class="line-new-header">--- 137,11 ---</span>
             &quot;We shouldn&#39;t be looking at clean cards, and this should &quot;
             &quot;be the only place they get cleaned.&quot;);
      if (CardTableRS::card_is_dirty_wrt_gen_iter(entry_val)
          || _ct-&gt;is_prev_youngergen_card_val(entry_val)) {
        CardValue res =
<span class="line-modified">!         Atomic::cmpxchg(entry, entry_val, CardTableRS::clean_card_val());</span>
        if (res == entry_val) {
          break;
        } else {
          assert(res == CardTableRS::cur_youngergen_and_prev_nonclean_card,
                 &quot;The CAS above should only fail if another thread did &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,44 ***</span>
      const MemRegion mrd(start_of_non_clean, end_of_non_clean);
      _dirty_card_closure-&gt;do_MemRegion(mrd);
    }
  }
  
<span class="line-removed">- // clean (by dirty-&gt;clean before) ==&gt; cur_younger_gen</span>
<span class="line-removed">- // dirty                          ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">- // precleaned                     ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">- // prev-younger-gen               ==&gt; cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">- // cur-younger-gen                ==&gt; cur_younger_gen</span>
<span class="line-removed">- // cur_youngergen_and_prev_nonclean_card ==&gt; no change.</span>
<span class="line-removed">- void CardTableRS::write_ref_field_gc_par(void* field, oop new_val) {</span>
<span class="line-removed">-   volatile CardValue* entry = byte_for(field);</span>
<span class="line-removed">-   do {</span>
<span class="line-removed">-     CardValue entry_val = *entry;</span>
<span class="line-removed">-     // We put this first because it&#39;s probably the most common case.</span>
<span class="line-removed">-     if (entry_val == clean_card_val()) {</span>
<span class="line-removed">-       // No threat of contention with cleaning threads.</span>
<span class="line-removed">-       *entry = cur_youngergen_card_val();</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     } else if (card_is_dirty_wrt_gen_iter(entry_val)</span>
<span class="line-removed">-                || is_prev_youngergen_card_val(entry_val)) {</span>
<span class="line-removed">-       // Mark it as both cur and prev youngergen; card cleaning thread will</span>
<span class="line-removed">-       // eventually remove the previous stuff.</span>
<span class="line-removed">-       CardValue new_val = cur_youngergen_and_prev_nonclean_card;</span>
<span class="line-removed">-       CardValue res = Atomic::cmpxchg(new_val, entry, entry_val);</span>
<span class="line-removed">-       // Did the CAS succeed?</span>
<span class="line-removed">-       if (res == entry_val) return;</span>
<span class="line-removed">-       // Otherwise, retry, to see the new value.</span>
<span class="line-removed">-       continue;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(entry_val == cur_youngergen_and_prev_nonclean_card</span>
<span class="line-removed">-              || entry_val == cur_youngergen_card_val(),</span>
<span class="line-removed">-              &quot;should be only possibilities.&quot;);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } while (true);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void CardTableRS::younger_refs_in_space_iterate(Space* sp,
                                                  OopsInGenClosure* cl,
                                                  uint n_threads) {
    verify_used_region_at_save_marks(sp);
  
<span class="line-new-header">--- 242,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
      assert(jp &gt;= _begin &amp;&amp; jp &lt; _end,
             &quot;Error: jp &quot; PTR_FORMAT &quot; should be within &quot;
             &quot;[_begin, _end) = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,
             p2i(jp), p2i(_begin), p2i(_end));
      oop obj = RawAccess&lt;&gt;::oop_load(p);
<span class="line-modified">!     guarantee(obj == NULL || (HeapWord*)obj &gt;= _boundary,</span>
                &quot;pointer &quot; PTR_FORMAT &quot; at &quot; PTR_FORMAT &quot; on &quot;
                &quot;clean card crosses boundary&quot; PTR_FORMAT,
                p2i(obj), p2i(jp), p2i(_boundary));
    }
  
<span class="line-new-header">--- 307,11 ---</span>
      assert(jp &gt;= _begin &amp;&amp; jp &lt; _end,
             &quot;Error: jp &quot; PTR_FORMAT &quot; should be within &quot;
             &quot;[_begin, _end) = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,
             p2i(jp), p2i(_begin), p2i(_end));
      oop obj = RawAccess&lt;&gt;::oop_load(p);
<span class="line-modified">!     guarantee(obj == NULL || cast_from_oop&lt;HeapWord*&gt;(obj) &gt;= _boundary,</span>
                &quot;pointer &quot; PTR_FORMAT &quot; at &quot; PTR_FORMAT &quot; on &quot;
                &quot;clean card crosses boundary&quot; PTR_FORMAT,
                p2i(obj), p2i(jp), p2i(_boundary));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,41 ***</span>
    _last_LNC_resizing_collection(NULL)
  {
    // max_gens is really GenCollectedHeap::heap()-&gt;gen_policy()-&gt;number_of_generations()
    // (which is always 2, young &amp; old), but GenCollectedHeap has not been initialized yet.
    uint max_gens = 2;
<span class="line-modified">!   _last_cur_val_in_gen = NEW_C_HEAP_ARRAY3(CardValue, max_gens + 1,</span>
<span class="line-removed">-                          mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);</span>
<span class="line-removed">-   if (_last_cur_val_in_gen == NULL) {</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;Could not create last_cur_val_in_gen array.&quot;);</span>
<span class="line-removed">-   }</span>
    for (uint i = 0; i &lt; max_gens + 1; i++) {
      _last_cur_val_in_gen[i] = clean_card_val();
    }
  }
  
  CardTableRS::~CardTableRS() {
<span class="line-modified">!   if (_last_cur_val_in_gen) {</span>
<span class="line-modified">!     FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);</span>
<span class="line-modified">!     _last_cur_val_in_gen = NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   if (_lowest_non_clean) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);</span>
<span class="line-removed">-     _lowest_non_clean = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (_lowest_non_clean_chunk_size) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);</span>
<span class="line-removed">-     _lowest_non_clean_chunk_size = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (_lowest_non_clean_base_chunk_index) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);</span>
<span class="line-removed">-     _lowest_non_clean_base_chunk_index = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (_last_LNC_resizing_collection) {</span>
<span class="line-removed">-     FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);</span>
<span class="line-removed">-     _last_LNC_resizing_collection = NULL;</span>
<span class="line-removed">-   }</span>
  }
  
  void CardTableRS::initialize() {
    CardTable::initialize();
    _lowest_non_clean =
<span class="line-new-header">--- 577,22 ---</span>
    _last_LNC_resizing_collection(NULL)
  {
    // max_gens is really GenCollectedHeap::heap()-&gt;gen_policy()-&gt;number_of_generations()
    // (which is always 2, young &amp; old), but GenCollectedHeap has not been initialized yet.
    uint max_gens = 2;
<span class="line-modified">!   _last_cur_val_in_gen = NEW_C_HEAP_ARRAY(CardValue, max_gens + 1, mtGC);</span>
    for (uint i = 0; i &lt; max_gens + 1; i++) {
      _last_cur_val_in_gen[i] = clean_card_val();
    }
  }
  
  CardTableRS::~CardTableRS() {
<span class="line-modified">!   FREE_C_HEAP_ARRAY(CardValue, _last_cur_val_in_gen);</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(CardArr, _lowest_non_clean);</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(size_t, _lowest_non_clean_chunk_size);</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(uintptr_t, _lowest_non_clean_base_chunk_index);</span>
<span class="line-modified">!   FREE_C_HEAP_ARRAY(int, _last_LNC_resizing_collection);</span>
  }
  
  void CardTableRS::initialize() {
    CardTable::initialize();
    _lowest_non_clean =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,15 ***</span>
      NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
    _lowest_non_clean_base_chunk_index =
      NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
    _last_LNC_resizing_collection =
      NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);
<span class="line-modified">!   if (_lowest_non_clean == NULL</span>
<span class="line-removed">-       || _lowest_non_clean_chunk_size == NULL</span>
<span class="line-removed">-       || _lowest_non_clean_base_chunk_index == NULL</span>
<span class="line-removed">-       || _last_LNC_resizing_collection == NULL)</span>
<span class="line-removed">-     vm_exit_during_initialization(&quot;couldn&#39;t allocate an LNC array.&quot;);</span>
    for (int i = 0; i &lt; _max_covered_regions; i++) {
      _lowest_non_clean[i] = NULL;
      _lowest_non_clean_chunk_size[i] = 0;
      _last_LNC_resizing_collection[i] = -1;
    }
<span class="line-new-header">--- 601,11 ---</span>
      NEW_C_HEAP_ARRAY(size_t, _max_covered_regions, mtGC);
    _lowest_non_clean_base_chunk_index =
      NEW_C_HEAP_ARRAY(uintptr_t, _max_covered_regions, mtGC);
    _last_LNC_resizing_collection =
      NEW_C_HEAP_ARRAY(int, _max_covered_regions, mtGC);
<span class="line-modified">! </span>
    for (int i = 0; i &lt; _max_covered_regions; i++) {
      _lowest_non_clean[i] = NULL;
      _lowest_non_clean_chunk_size[i] = 0;
      _last_LNC_resizing_collection[i] = -1;
    }
</pre>
<center><a href="cardTableBarrierSet.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableRS.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
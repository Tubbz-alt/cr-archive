<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/collectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;gc/shared/allocTracer.hpp&quot;
 28 #include &quot;gc/shared/barrierSet.hpp&quot;
 29 #include &quot;gc/shared/collectedHeap.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 31 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
 32 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 33 #include &quot;gc/shared/gcTrace.hpp&quot;
 34 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
 35 #include &quot;gc/shared/gcVMOperations.hpp&quot;
 36 #include &quot;gc/shared/gcWhen.hpp&quot;
 37 #include &quot;gc/shared/memAllocator.hpp&quot;
 38 #include &quot;logging/log.hpp&quot;
 39 #include &quot;memory/metaspace.hpp&quot;
 40 #include &quot;memory/resourceArea.hpp&quot;
<a name="1" id="anc1"></a>
 41 #include &quot;oops/instanceMirrorKlass.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;runtime/handles.inline.hpp&quot;
 44 #include &quot;runtime/init.hpp&quot;
 45 #include &quot;runtime/thread.inline.hpp&quot;
 46 #include &quot;runtime/threadSMR.hpp&quot;
 47 #include &quot;runtime/vmThread.hpp&quot;
 48 #include &quot;services/heapDumper.hpp&quot;
 49 #include &quot;utilities/align.hpp&quot;
 50 #include &quot;utilities/copy.hpp&quot;
 51 
 52 class ClassLoaderData;
 53 
 54 size_t CollectedHeap::_filler_array_max_size = 0;
 55 
 56 template &lt;&gt;
 57 void EventLogBase&lt;GCMessage&gt;::print(outputStream* st, GCMessage&amp; m) {
 58   st-&gt;print_cr(&quot;GC heap %s&quot;, m.is_before ? &quot;before&quot; : &quot;after&quot;);
 59   st-&gt;print_raw(m);
 60 }
 61 
 62 void GCHeapLog::log_heap(CollectedHeap* heap, bool before) {
 63   if (!should_log()) {
 64     return;
 65   }
 66 
 67   double timestamp = fetch_timestamp();
<a name="2" id="anc2"></a><span class="line-modified"> 68   MutexLockerEx ml(&amp;_mutex, Mutex::_no_safepoint_check_flag);</span>
 69   int index = compute_log_index();
 70   _records[index].thread = NULL; // Its the GC thread so it&#39;s not that interesting.
 71   _records[index].timestamp = timestamp;
 72   _records[index].data.is_before = before;
 73   stringStream st(_records[index].data.buffer(), _records[index].data.size());
 74 
 75   st.print_cr(&quot;{Heap %s GC invocations=%u (full %u):&quot;,
 76                  before ? &quot;before&quot; : &quot;after&quot;,
 77                  heap-&gt;total_collections(),
 78                  heap-&gt;total_full_collections());
 79 
 80   heap-&gt;print_on(&amp;st);
 81   st.print_cr(&quot;}&quot;);
 82 }
 83 
<a name="3" id="anc3"></a>




 84 VirtualSpaceSummary CollectedHeap::create_heap_space_summary() {
 85   size_t capacity_in_words = capacity() / HeapWordSize;
 86 
 87   return VirtualSpaceSummary(
<a name="4" id="anc4"></a><span class="line-modified"> 88     reserved_region().start(), reserved_region().start() + capacity_in_words, reserved_region().end());</span>
 89 }
 90 
 91 GCHeapSummary CollectedHeap::create_heap_summary() {
 92   VirtualSpaceSummary heap_space = create_heap_space_summary();
 93   return GCHeapSummary(heap_space, used());
 94 }
 95 
 96 MetaspaceSummary CollectedHeap::create_metaspace_summary() {
 97   const MetaspaceSizes meta_space(
 98       MetaspaceUtils::committed_bytes(),
 99       MetaspaceUtils::used_bytes(),
100       MetaspaceUtils::reserved_bytes());
101   const MetaspaceSizes data_space(
102       MetaspaceUtils::committed_bytes(Metaspace::NonClassType),
103       MetaspaceUtils::used_bytes(Metaspace::NonClassType),
104       MetaspaceUtils::reserved_bytes(Metaspace::NonClassType));
105   const MetaspaceSizes class_space(
106       MetaspaceUtils::committed_bytes(Metaspace::ClassType),
107       MetaspaceUtils::used_bytes(Metaspace::ClassType),
108       MetaspaceUtils::reserved_bytes(Metaspace::ClassType));
109 
110   const MetaspaceChunkFreeListSummary&amp; ms_chunk_free_list_summary =
111     MetaspaceUtils::chunk_free_list_summary(Metaspace::NonClassType);
112   const MetaspaceChunkFreeListSummary&amp; class_chunk_free_list_summary =
113     MetaspaceUtils::chunk_free_list_summary(Metaspace::ClassType);
114 
115   return MetaspaceSummary(MetaspaceGC::capacity_until_GC(), meta_space, data_space, class_space,
116                           ms_chunk_free_list_summary, class_chunk_free_list_summary);
117 }
118 
119 void CollectedHeap::print_heap_before_gc() {
120   Universe::print_heap_before_gc();
121   if (_gc_heap_log != NULL) {
122     _gc_heap_log-&gt;log_heap_before(this);
123   }
124 }
125 
126 void CollectedHeap::print_heap_after_gc() {
127   Universe::print_heap_after_gc();
128   if (_gc_heap_log != NULL) {
129     _gc_heap_log-&gt;log_heap_after(this);
130   }
131 }
132 
<a name="5" id="anc5"></a>

133 void CollectedHeap::print_on_error(outputStream* st) const {
134   st-&gt;print_cr(&quot;Heap:&quot;);
135   print_extended_on(st);
136   st-&gt;cr();
137 
138   BarrierSet::barrier_set()-&gt;print_on(st);
139 }
140 
141 void CollectedHeap::trace_heap(GCWhen::Type when, const GCTracer* gc_tracer) {
142   const GCHeapSummary&amp; heap_summary = create_heap_summary();
143   gc_tracer-&gt;report_gc_heap_summary(when, heap_summary);
144 
145   const MetaspaceSummary&amp; metaspace_summary = create_metaspace_summary();
146   gc_tracer-&gt;report_metaspace_summary(when, metaspace_summary);
147 }
148 
149 void CollectedHeap::trace_heap_before_gc(const GCTracer* gc_tracer) {
150   trace_heap(GCWhen::BeforeGC, gc_tracer);
151 }
152 
153 void CollectedHeap::trace_heap_after_gc(const GCTracer* gc_tracer) {
154   trace_heap(GCWhen::AfterGC, gc_tracer);
155 }
156 
157 // WhiteBox API support for concurrent collectors.  These are the
158 // default implementations, for collectors which don&#39;t support this
159 // feature.
160 bool CollectedHeap::supports_concurrent_phase_control() const {
161   return false;
162 }
163 
164 bool CollectedHeap::request_concurrent_phase(const char* phase) {
165   return false;
166 }
167 
168 bool CollectedHeap::is_oop(oop object) const {
<a name="6" id="anc6"></a><span class="line-modified">169   if (!check_obj_alignment(object)) {</span>
170     return false;
171   }
172 
<a name="7" id="anc7"></a><span class="line-modified">173   if (!is_in_reserved(object)) {</span>
174     return false;
175   }
176 
<a name="8" id="anc8"></a><span class="line-modified">177   if (is_in_reserved(object-&gt;klass_or_null())) {</span>
178     return false;
179   }
180 
181   return true;
182 }
183 
184 // Memory state functions.
185 
186 
187 CollectedHeap::CollectedHeap() :
188   _is_gc_active(false),
189   _total_collections(0),
190   _total_full_collections(0),
191   _gc_cause(GCCause::_no_gc),
192   _gc_lastcause(GCCause::_no_gc)
193 {
194   const size_t max_len = size_t(arrayOopDesc::max_array_length(T_INT));
195   const size_t elements_per_word = HeapWordSize / sizeof(jint);
196   _filler_array_max_size = align_object_size(filler_array_hdr_size() +
197                                              max_len / elements_per_word);
198 
199   NOT_PRODUCT(_promotion_failure_alot_count = 0;)
200   NOT_PRODUCT(_promotion_failure_alot_gc_number = 0;)
201 
202   if (UsePerfData) {
203     EXCEPTION_MARK;
204 
205     // create the gc cause jvmstat counters
206     _perf_gc_cause = PerfDataManager::create_string_variable(SUN_GC, &quot;cause&quot;,
207                              80, GCCause::to_string(_gc_cause), CHECK);
208 
209     _perf_gc_lastcause =
210                 PerfDataManager::create_string_variable(SUN_GC, &quot;lastCause&quot;,
211                              80, GCCause::to_string(_gc_lastcause), CHECK);
212   }
213 
214   // Create the ring log
215   if (LogEvents) {
216     _gc_heap_log = new GCHeapLog();
217   } else {
218     _gc_heap_log = NULL;
219   }
220 }
221 
222 // This interface assumes that it&#39;s being called by the
223 // vm thread. It collects the heap assuming that the
224 // heap lock is already held and that we are executing in
225 // the context of the vm thread.
226 void CollectedHeap::collect_as_vm_thread(GCCause::Cause cause) {
227   assert(Thread::current()-&gt;is_VM_thread(), &quot;Precondition#1&quot;);
228   assert(Heap_lock-&gt;is_locked(), &quot;Precondition#2&quot;);
229   GCCauseSetter gcs(this, cause);
230   switch (cause) {
231     case GCCause::_heap_inspection:
232     case GCCause::_heap_dump:
233     case GCCause::_metadata_GC_threshold : {
234       HandleMark hm;
235       do_full_collection(false);        // don&#39;t clear all soft refs
236       break;
237     }
238     case GCCause::_metadata_GC_clear_soft_refs: {
239       HandleMark hm;
240       do_full_collection(true);         // do clear all soft refs
241       break;
242     }
243     default:
244       ShouldNotReachHere(); // Unexpected use of this function
245   }
246 }
247 
248 MetaWord* CollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
249                                                             size_t word_size,
250                                                             Metaspace::MetadataType mdtype) {
251   uint loop_count = 0;
252   uint gc_count = 0;
253   uint full_gc_count = 0;
254 
255   assert(!Heap_lock-&gt;owned_by_self(), &quot;Should not be holding the Heap_lock&quot;);
256 
257   do {
258     MetaWord* result = loader_data-&gt;metaspace_non_null()-&gt;allocate(word_size, mdtype);
259     if (result != NULL) {
260       return result;
261     }
262 
263     if (GCLocker::is_active_and_needs_gc()) {
264       // If the GCLocker is active, just expand and allocate.
265       // If that does not succeed, wait if this thread is not
266       // in a critical section itself.
267       result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(word_size, mdtype);
268       if (result != NULL) {
269         return result;
270       }
271       JavaThread* jthr = JavaThread::current();
272       if (!jthr-&gt;in_critical()) {
273         // Wait for JNI critical section to be exited
274         GCLocker::stall_until_clear();
275         // The GC invoked by the last thread leaving the critical
276         // section will be a young collection and a full collection
277         // is (currently) needed for unloading classes so continue
278         // to the next iteration to get a full GC.
279         continue;
280       } else {
281         if (CheckJNICalls) {
282           fatal(&quot;Possible deadlock due to allocating while&quot;
283                 &quot; in jni critical section&quot;);
284         }
285         return NULL;
286       }
287     }
288 
289     {  // Need lock to get self consistent gc_count&#39;s
290       MutexLocker ml(Heap_lock);
291       gc_count      = Universe::heap()-&gt;total_collections();
292       full_gc_count = Universe::heap()-&gt;total_full_collections();
293     }
294 
295     // Generate a VM operation
296     VM_CollectForMetadataAllocation op(loader_data,
297                                        word_size,
298                                        mdtype,
299                                        gc_count,
300                                        full_gc_count,
301                                        GCCause::_metadata_GC_threshold);
302     VMThread::execute(&amp;op);
303 
304     // If GC was locked out, try again. Check before checking success because the
305     // prologue could have succeeded and the GC still have been locked out.
306     if (op.gc_locked()) {
307       continue;
308     }
309 
310     if (op.prologue_succeeded()) {
311       return op.result();
312     }
313     loop_count++;
314     if ((QueuedAllocationWarningCount &gt; 0) &amp;&amp;
315         (loop_count % QueuedAllocationWarningCount == 0)) {
316       log_warning(gc, ergo)(&quot;satisfy_failed_metadata_allocation() retries %d times,&quot;
317                             &quot; size=&quot; SIZE_FORMAT, loop_count, word_size);
318     }
319   } while (true);  // Until a GC is done
320 }
321 
322 MemoryUsage CollectedHeap::memory_usage() {
323   return MemoryUsage(InitialHeapSize, used(), capacity(), max_capacity());
324 }
325 
326 
327 #ifndef PRODUCT
328 void CollectedHeap::check_for_non_bad_heap_word_value(HeapWord* addr, size_t size) {
329   if (CheckMemoryInitialization &amp;&amp; ZapUnusedHeapArea) {
<a name="9" id="anc9"></a><span class="line-modified">330     for (size_t slot = 0; slot &lt; size; slot += 1) {</span>
<span class="line-modified">331       assert((*(intptr_t*) (addr + slot)) == ((intptr_t) badHeapWordVal),</span>
<span class="line-modified">332              &quot;Found non badHeapWordValue in pre-allocation check&quot;);</span>
333     }
334   }
335 }
336 #endif // PRODUCT
337 
338 size_t CollectedHeap::max_tlab_size() const {
339   // TLABs can&#39;t be bigger than we can fill with a int[Integer.MAX_VALUE].
340   // This restriction could be removed by enabling filling with multiple arrays.
341   // If we compute that the reasonable way as
342   //    header_size + ((sizeof(jint) * max_jint) / HeapWordSize)
343   // we&#39;ll overflow on the multiply, so we do the divide first.
344   // We actually lose a little by dividing first,
345   // but that just makes the TLAB  somewhat smaller than the biggest array,
346   // which is fine, since we&#39;ll be able to fill that.
347   size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +
348               sizeof(jint) *
349               ((juint) max_jint / (size_t) HeapWordSize);
350   return align_down(max_int_size, MinObjAlignment);
351 }
352 
353 size_t CollectedHeap::filler_array_hdr_size() {
354   return align_object_offset(arrayOopDesc::header_size(T_INT)); // align to Long
355 }
356 
357 size_t CollectedHeap::filler_array_min_size() {
358   return align_object_size(filler_array_hdr_size()); // align to MinObjAlignment
359 }
360 
361 #ifdef ASSERT
362 void CollectedHeap::fill_args_check(HeapWord* start, size_t words)
363 {
364   assert(words &gt;= min_fill_size(), &quot;too small to fill&quot;);
365   assert(is_object_aligned(words), &quot;unaligned size&quot;);
<a name="10" id="anc10"></a><span class="line-removed">366   assert(Universe::heap()-&gt;is_in_reserved(start), &quot;not in heap&quot;);</span>
<span class="line-removed">367   assert(Universe::heap()-&gt;is_in_reserved(start + words - 1), &quot;not in heap&quot;);</span>
368 }
369 
370 void CollectedHeap::zap_filler_array(HeapWord* start, size_t words, bool zap)
371 {
372   if (ZapFillerObjects &amp;&amp; zap) {
373     Copy::fill_to_words(start + filler_array_hdr_size(),
374                         words - filler_array_hdr_size(), 0XDEAFBABE);
375   }
376 }
377 #endif // ASSERT
378 
379 void
380 CollectedHeap::fill_with_array(HeapWord* start, size_t words, bool zap)
381 {
382   assert(words &gt;= filler_array_min_size(), &quot;too small for an array&quot;);
383   assert(words &lt;= filler_array_max_size(), &quot;too big for a single object&quot;);
384 
385   const size_t payload_size = words - filler_array_hdr_size();
386   const size_t len = payload_size * HeapWordSize / sizeof(jint);
387   assert((int)len &gt;= 0, &quot;size too large &quot; SIZE_FORMAT &quot; becomes %d&quot;, words, (int)len);
388 
389   ObjArrayAllocator allocator(Universe::intArrayKlassObj(), words, (int)len, /* do_zero */ false);
390   allocator.initialize(start);
391   DEBUG_ONLY(zap_filler_array(start, words, zap);)
392 }
393 
394 void
395 CollectedHeap::fill_with_object_impl(HeapWord* start, size_t words, bool zap)
396 {
397   assert(words &lt;= filler_array_max_size(), &quot;too big for a single object&quot;);
398 
399   if (words &gt;= filler_array_min_size()) {
400     fill_with_array(start, words, zap);
401   } else if (words &gt; 0) {
402     assert(words == min_fill_size(), &quot;unaligned size&quot;);
403     ObjAllocator allocator(SystemDictionary::Object_klass(), words);
404     allocator.initialize(start);
405   }
406 }
407 
408 void CollectedHeap::fill_with_object(HeapWord* start, size_t words, bool zap)
409 {
410   DEBUG_ONLY(fill_args_check(start, words);)
411   HandleMark hm;  // Free handles before leaving.
412   fill_with_object_impl(start, words, zap);
413 }
414 
415 void CollectedHeap::fill_with_objects(HeapWord* start, size_t words, bool zap)
416 {
417   DEBUG_ONLY(fill_args_check(start, words);)
418   HandleMark hm;  // Free handles before leaving.
419 
420   // Multiple objects may be required depending on the filler array maximum size. Fill
421   // the range up to that with objects that are filler_array_max_size sized. The
422   // remainder is filled with a single object.
423   const size_t min = min_fill_size();
424   const size_t max = filler_array_max_size();
425   while (words &gt; max) {
426     const size_t cur = (words - max) &gt;= min ? max : max - min;
427     fill_with_array(start, cur, zap);
428     start += cur;
429     words -= cur;
430   }
431 
432   fill_with_object_impl(start, words, zap);
433 }
434 
435 void CollectedHeap::fill_with_dummy_object(HeapWord* start, HeapWord* end, bool zap) {
436   CollectedHeap::fill_with_object(start, end, zap);
437 }
438 
439 size_t CollectedHeap::min_dummy_object_size() const {
440   return oopDesc::header_size();
441 }
442 
443 size_t CollectedHeap::tlab_alloc_reserve() const {
444   size_t min_size = min_dummy_object_size();
445   return min_size &gt; (size_t)MinObjAlignment ? align_object_size(min_size) : 0;
446 }
447 
448 HeapWord* CollectedHeap::allocate_new_tlab(size_t min_size,
449                                            size_t requested_size,
450                                            size_t* actual_size) {
451   guarantee(false, &quot;thread-local allocation buffers not supported&quot;);
452   return NULL;
453 }
454 
455 void CollectedHeap::ensure_parsability(bool retire_tlabs) {
456   assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),
457          &quot;Should only be called at a safepoint or at start-up&quot;);
458 
459   ThreadLocalAllocStats stats;
460 
461   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next();) {
462     BarrierSet::barrier_set()-&gt;make_parsable(thread);
463     if (UseTLAB) {
464       if (retire_tlabs) {
465         thread-&gt;tlab().retire(&amp;stats);
466       } else {
467         thread-&gt;tlab().make_parsable();
468       }
469     }
470   }
471 
472   stats.publish();
473 }
474 
475 void CollectedHeap::resize_all_tlabs() {
476   assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),
477          &quot;Should only resize tlabs at safepoint&quot;);
478 
479   if (UseTLAB &amp;&amp; ResizeTLAB) {
480     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
481       thread-&gt;tlab().resize();
482     }
483   }
484 }
485 
486 void CollectedHeap::full_gc_dump(GCTimer* timer, bool before) {
487   assert(timer != NULL, &quot;timer is null&quot;);
488   if ((HeapDumpBeforeFullGC &amp;&amp; before) || (HeapDumpAfterFullGC &amp;&amp; !before)) {
489     GCTraceTime(Info, gc) tm(before ? &quot;Heap Dump (before full gc)&quot; : &quot;Heap Dump (after full gc)&quot;, timer);
490     HeapDumper::dump_heap();
491   }
492 
493   LogTarget(Trace, gc, classhisto) lt;
494   if (lt.is_enabled()) {
495     GCTraceTime(Trace, gc, classhisto) tm(before ? &quot;Class Histogram (before full gc)&quot; : &quot;Class Histogram (after full gc)&quot;, timer);
496     ResourceMark rm;
497     LogStream ls(lt);
498     VM_GC_HeapInspection inspector(&amp;ls, false /* ! full gc */);
499     inspector.doit();
500   }
501 }
502 
503 void CollectedHeap::pre_full_gc_dump(GCTimer* timer) {
504   full_gc_dump(timer, true);
505 }
506 
507 void CollectedHeap::post_full_gc_dump(GCTimer* timer) {
508   full_gc_dump(timer, false);
509 }
510 
<a name="11" id="anc11"></a><span class="line-modified">511 void CollectedHeap::initialize_reserved_region(HeapWord *start, HeapWord *end) {</span>
512   // It is important to do this in a way such that concurrent readers can&#39;t
513   // temporarily think something is in the heap.  (Seen this happen in asserts.)
514   _reserved.set_word_size(0);
<a name="12" id="anc12"></a><span class="line-modified">515   _reserved.set_start(start);</span>
<span class="line-modified">516   _reserved.set_end(end);</span>
517 }
518 
519 void CollectedHeap::post_initialize() {
520   initialize_serviceability();
521 }
522 
523 #ifndef PRODUCT
524 
525 bool CollectedHeap::promotion_should_fail(volatile size_t* count) {
526   // Access to count is not atomic; the value does not have to be exact.
527   if (PromotionFailureALot) {
528     const size_t gc_num = total_collections();
529     const size_t elapsed_gcs = gc_num - _promotion_failure_alot_gc_number;
530     if (elapsed_gcs &gt;= PromotionFailureALotInterval) {
531       // Test for unsigned arithmetic wrap-around.
532       if (++*count &gt;= PromotionFailureALotCount) {
533         *count = 0;
534         return true;
535       }
536     }
537   }
538   return false;
539 }
540 
541 bool CollectedHeap::promotion_should_fail() {
542   return promotion_should_fail(&amp;_promotion_failure_alot_count);
543 }
544 
545 void CollectedHeap::reset_promotion_should_fail(volatile size_t* count) {
546   if (PromotionFailureALot) {
547     _promotion_failure_alot_gc_number = total_collections();
548     *count = 0;
549   }
550 }
551 
552 void CollectedHeap::reset_promotion_should_fail() {
553   reset_promotion_should_fail(&amp;_promotion_failure_alot_count);
554 }
555 
556 #endif  // #ifndef PRODUCT
557 
558 bool CollectedHeap::supports_object_pinning() const {
559   return false;
560 }
561 
562 oop CollectedHeap::pin_object(JavaThread* thread, oop obj) {
563   ShouldNotReachHere();
564   return NULL;
565 }
566 
567 void CollectedHeap::unpin_object(JavaThread* thread, oop obj) {
568   ShouldNotReachHere();
569 }
570 
571 void CollectedHeap::deduplicate_string(oop str) {
572   // Do nothing, unless overridden in subclass.
573 }
574 
575 size_t CollectedHeap::obj_size(oop obj) const {
576   return obj-&gt;size();
577 }
<a name="13" id="anc13"></a>




<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/adaptiveSizePolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../serial/tenuredGeneration.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adaptiveSizePolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/adaptiveSizePolicy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 
 32 elapsedTimer AdaptiveSizePolicy::_minor_timer;
 33 elapsedTimer AdaptiveSizePolicy::_major_timer;
 34 
 35 // The throughput goal is implemented as
 36 //      _throughput_goal = 1 - ( 1 / (1 + gc_cost_ratio))
 37 // gc_cost_ratio is the ratio
 38 //      application cost / gc cost
 39 // For example a gc_cost_ratio of 4 translates into a
 40 // throughput goal of .80
 41 
 42 AdaptiveSizePolicy::AdaptiveSizePolicy(size_t init_eden_size,
 43                                        size_t init_promo_size,
 44                                        size_t init_survivor_size,
 45                                        double gc_pause_goal_sec,
 46                                        uint gc_cost_ratio) :
 47     _throughput_goal(1.0 - double(1.0 / (1.0 + (double) gc_cost_ratio))),
 48     _eden_size(init_eden_size),
 49     _promo_size(init_promo_size),
 50     _survivor_size(init_survivor_size),














 51     _latest_minor_mutator_interval_seconds(0),
 52     _threshold_tolerance_percent(1.0 + ThresholdTolerance/100.0),
 53     _gc_pause_goal_sec(gc_pause_goal_sec),










 54     _young_gen_change_for_minor_throughput(0),
 55     _old_gen_change_for_major_throughput(0) {
<span class="line-removed"> 56   _avg_minor_pause    =</span>
<span class="line-removed"> 57     new AdaptivePaddedAverage(AdaptiveTimeWeight, PausePadding);</span>
<span class="line-removed"> 58   _avg_minor_interval = new AdaptiveWeightedAverage(AdaptiveTimeWeight);</span>
<span class="line-removed"> 59   _avg_minor_gc_cost  = new AdaptiveWeightedAverage(AdaptiveTimeWeight);</span>
<span class="line-removed"> 60   _avg_major_gc_cost  = new AdaptiveWeightedAverage(AdaptiveTimeWeight);</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62   _avg_young_live     = new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 63   _avg_old_live       = new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 64   _avg_eden_live      = new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66   _avg_survived       = new AdaptivePaddedAverage(AdaptiveSizePolicyWeight,</span>
<span class="line-removed"> 67                                                   SurvivorPadding);</span>
<span class="line-removed"> 68   _avg_pretenured     = new AdaptivePaddedNoZeroDevAverage(</span>
<span class="line-removed"> 69                                                   AdaptiveSizePolicyWeight,</span>
<span class="line-removed"> 70                                                   SurvivorPadding);</span>
<span class="line-removed"> 71 </span>
<span class="line-removed"> 72   _minor_pause_old_estimator =</span>
<span class="line-removed"> 73     new LinearLeastSquareFit(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 74   _minor_pause_young_estimator =</span>
<span class="line-removed"> 75     new LinearLeastSquareFit(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 76   _minor_collection_estimator =</span>
<span class="line-removed"> 77     new LinearLeastSquareFit(AdaptiveSizePolicyWeight);</span>
<span class="line-removed"> 78   _major_collection_estimator =</span>
<span class="line-removed"> 79     new LinearLeastSquareFit(AdaptiveSizePolicyWeight);</span>
 80 
 81   // Start the timers
 82   _minor_timer.start();
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84   _young_gen_policy_is_ready = false;</span>
 85 }
 86 
 87 bool AdaptiveSizePolicy::tenuring_threshold_change() const {
 88   return decrement_tenuring_threshold_for_gc_cost() ||
 89          increment_tenuring_threshold_for_gc_cost() ||
 90          decrement_tenuring_threshold_for_survivor_limit();
 91 }
 92 
 93 void AdaptiveSizePolicy::minor_collection_begin() {
 94   // Update the interval time
 95   _minor_timer.stop();
 96   // Save most recent collection time
 97   _latest_minor_mutator_interval_seconds = _minor_timer.seconds();
 98   _minor_timer.reset();
 99   _minor_timer.start();
100 }
101 
102 void AdaptiveSizePolicy::update_minor_pause_young_estimator(
103     double minor_pause_in_ms) {
104   double eden_size_in_mbytes = ((double)_eden_size)/((double)M);
</pre>
</td>
<td>
<hr />
<pre>
 31 
 32 elapsedTimer AdaptiveSizePolicy::_minor_timer;
 33 elapsedTimer AdaptiveSizePolicy::_major_timer;
 34 
 35 // The throughput goal is implemented as
 36 //      _throughput_goal = 1 - ( 1 / (1 + gc_cost_ratio))
 37 // gc_cost_ratio is the ratio
 38 //      application cost / gc cost
 39 // For example a gc_cost_ratio of 4 translates into a
 40 // throughput goal of .80
 41 
 42 AdaptiveSizePolicy::AdaptiveSizePolicy(size_t init_eden_size,
 43                                        size_t init_promo_size,
 44                                        size_t init_survivor_size,
 45                                        double gc_pause_goal_sec,
 46                                        uint gc_cost_ratio) :
 47     _throughput_goal(1.0 - double(1.0 / (1.0 + (double) gc_cost_ratio))),
 48     _eden_size(init_eden_size),
 49     _promo_size(init_promo_size),
 50     _survivor_size(init_survivor_size),
<span class="line-added"> 51     _avg_minor_pause(new AdaptivePaddedAverage(AdaptiveTimeWeight, PausePadding)),</span>
<span class="line-added"> 52     _avg_minor_interval(new AdaptiveWeightedAverage(AdaptiveTimeWeight)),</span>
<span class="line-added"> 53     _avg_minor_gc_cost(new AdaptiveWeightedAverage(AdaptiveTimeWeight)),</span>
<span class="line-added"> 54     _avg_major_interval(new AdaptiveWeightedAverage(AdaptiveTimeWeight)),</span>
<span class="line-added"> 55     _avg_major_gc_cost(new AdaptiveWeightedAverage(AdaptiveTimeWeight)),</span>
<span class="line-added"> 56     _avg_young_live(new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 57     _avg_eden_live(new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 58     _avg_old_live(new AdaptiveWeightedAverage(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 59     _avg_survived(new AdaptivePaddedAverage(AdaptiveSizePolicyWeight, SurvivorPadding)),</span>
<span class="line-added"> 60     _avg_pretenured(new AdaptivePaddedNoZeroDevAverage(AdaptiveSizePolicyWeight, SurvivorPadding)),</span>
<span class="line-added"> 61     _minor_pause_old_estimator(new LinearLeastSquareFit(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 62     _minor_pause_young_estimator(new LinearLeastSquareFit(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 63     _minor_collection_estimator(new LinearLeastSquareFit(AdaptiveSizePolicyWeight)),</span>
<span class="line-added"> 64     _major_collection_estimator(new LinearLeastSquareFit(AdaptiveSizePolicyWeight)),</span>
 65     _latest_minor_mutator_interval_seconds(0),
 66     _threshold_tolerance_percent(1.0 + ThresholdTolerance/100.0),
 67     _gc_pause_goal_sec(gc_pause_goal_sec),
<span class="line-added"> 68     _young_gen_policy_is_ready(false),</span>
<span class="line-added"> 69     _change_young_gen_for_min_pauses(0),</span>
<span class="line-added"> 70     _change_old_gen_for_maj_pauses(0),</span>
<span class="line-added"> 71     _change_old_gen_for_throughput(0),</span>
<span class="line-added"> 72     _change_young_gen_for_throughput(0),</span>
<span class="line-added"> 73     _increment_tenuring_threshold_for_gc_cost(false),</span>
<span class="line-added"> 74     _decrement_tenuring_threshold_for_gc_cost(false),</span>
<span class="line-added"> 75     _decrement_tenuring_threshold_for_survivor_limit(false),</span>
<span class="line-added"> 76     _decrease_for_footprint(0),</span>
<span class="line-added"> 77     _decide_at_full_gc(0),</span>
 78     _young_gen_change_for_minor_throughput(0),
 79     _old_gen_change_for_major_throughput(0) {
























 80 
 81   // Start the timers
 82   _minor_timer.start();


 83 }
 84 
 85 bool AdaptiveSizePolicy::tenuring_threshold_change() const {
 86   return decrement_tenuring_threshold_for_gc_cost() ||
 87          increment_tenuring_threshold_for_gc_cost() ||
 88          decrement_tenuring_threshold_for_survivor_limit();
 89 }
 90 
 91 void AdaptiveSizePolicy::minor_collection_begin() {
 92   // Update the interval time
 93   _minor_timer.stop();
 94   // Save most recent collection time
 95   _latest_minor_mutator_interval_seconds = _minor_timer.seconds();
 96   _minor_timer.reset();
 97   _minor_timer.start();
 98 }
 99 
100 void AdaptiveSizePolicy::update_minor_pause_young_estimator(
101     double minor_pause_in_ms) {
102   double eden_size_in_mbytes = ((double)_eden_size)/((double)M);
</pre>
</td>
</tr>
</table>
<center><a href="../serial/tenuredGeneration.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="adaptiveSizePolicy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
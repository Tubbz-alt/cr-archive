<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/genCollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genCollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genCollectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 26 #define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 27 
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-removed"> 29 #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
 30 #include &quot;gc/shared/generation.hpp&quot;
 31 #include &quot;gc/shared/oopStorageParState.hpp&quot;

 32 #include &quot;gc/shared/softRefGenPolicy.hpp&quot;
 33 
 34 class AdaptiveSizePolicy;

 35 class GCPolicyCounters;
 36 class GenerationSpec;
 37 class StrongRootsScope;
 38 class SubTasksDone;
 39 class WorkGang;
 40 
 41 // A &quot;GenCollectedHeap&quot; is a CollectedHeap that uses generational
 42 // collection.  It has two generations, young and old.
 43 class GenCollectedHeap : public CollectedHeap {
<span class="line-removed"> 44   friend class GenCollectorPolicy;</span>
 45   friend class Generation;
 46   friend class DefNewGeneration;
 47   friend class TenuredGeneration;
<span class="line-removed"> 48   friend class ConcurrentMarkSweepGeneration;</span>
<span class="line-removed"> 49   friend class CMSCollector;</span>
 50   friend class GenMarkSweep;
 51   friend class VM_GenCollectForAllocation;
 52   friend class VM_GenCollectFull;
 53   friend class VM_GenCollectFullConcurrent;
 54   friend class VM_GC_HeapInspection;
 55   friend class VM_HeapDumper;
 56   friend class HeapInspection;
 57   friend class GCCauseSetter;
 58   friend class VMStructs;
 59 public:
 60   friend class VM_PopulateDumpSharedSpace;
 61 
 62   enum GenerationType {
 63     YoungGen,
 64     OldGen
 65   };
 66 
 67 protected:
 68   Generation* _young_gen;
 69   Generation* _old_gen;
 70 
 71 private:
 72   GenerationSpec* _young_gen_spec;
 73   GenerationSpec* _old_gen_spec;
 74 
 75   // The singleton CardTable Remembered Set.
 76   CardTableRS* _rem_set;
 77 
<span class="line-removed"> 78   // The generational collector policy.</span>
<span class="line-removed"> 79   GenCollectorPolicy* _gen_policy;</span>
<span class="line-removed"> 80 </span>
 81   SoftRefGenPolicy _soft_ref_gen_policy;
 82 
 83   // The sizing of the heap is controlled by a sizing policy.
 84   AdaptiveSizePolicy* _size_policy;
 85 
 86   GCPolicyCounters* _gc_policy_counters;
 87 
 88   // Indicates that the most recent previous incremental collection failed.
 89   // The flag is cleared when an action is taken that might clear the
 90   // condition that caused that incremental collection to fail.
 91   bool _incremental_collection_failed;
 92 
 93   // In support of ExplicitGCInvokesConcurrent functionality
 94   unsigned int _full_collections_completed;
 95 
 96   // Collects the given generation.
 97   void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,
 98                           bool run_verification, bool clear_soft_refs,
 99                           bool restore_marks_for_biased_locking);
100 
101   // Reserve aligned space for the heap as needed by the contained generations.
<span class="line-modified">102   char* allocate(size_t alignment, ReservedSpace* heap_rs);</span>
103 
104   // Initialize (&quot;weak&quot;) refs processing support
105   void ref_processing_init();
106 


107 protected:
108 
109   // The set of potentially parallel tasks in root scanning.
110   enum GCH_strong_roots_tasks {
111     GCH_PS_Universe_oops_do,
112     GCH_PS_JNIHandles_oops_do,
113     GCH_PS_ObjectSynchronizer_oops_do,
114     GCH_PS_FlatProfiler_oops_do,
115     GCH_PS_Management_oops_do,
116     GCH_PS_SystemDictionary_oops_do,
117     GCH_PS_ClassLoaderDataGraph_oops_do,
118     GCH_PS_jvmti_oops_do,
119     GCH_PS_CodeCache_oops_do,
<span class="line-modified">120     GCH_PS_aot_oops_do,</span>
121     GCH_PS_younger_gens,
122     // Leave this one last.
123     GCH_PS_NumElements
124   };
125 
126   // Data structure for claiming the (potentially) parallel tasks in
127   // (gen-specific) roots processing.
128   SubTasksDone* _process_strong_tasks;
129 
130   GCMemoryManager* _young_manager;
131   GCMemoryManager* _old_manager;
132 
133   // Helper functions for allocation
134   HeapWord* attempt_allocation(size_t size,
135                                bool   is_tlab,
136                                bool   first_only);
137 
138   // Helper function for two callbacks below.
139   // Considers collection of the first max_level+1 generations.
140   void do_collection(bool           full,
141                      bool           clear_all_soft_refs,
142                      size_t         size,
143                      bool           is_tlab,
144                      GenerationType max_generation);
145 
146   // Callback from VM_GenCollectForAllocation operation.
147   // This function does everything necessary/possible to satisfy an
148   // allocation request that failed in the youngest generation that should
149   // have handled it (including collection, expansion, etc.)
150   HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);
151 
152   // Callback from VM_GenCollectFull operation.
153   // Perform a full collection of the first max_level+1 generations.
154   virtual void do_full_collection(bool clear_all_soft_refs);
155   void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);
156 
157   // Does the &quot;cause&quot; of GC indicate that
158   // we absolutely __must__ clear soft refs?
159   bool must_clear_all_soft_refs();
160 
<span class="line-modified">161   GenCollectedHeap(GenCollectorPolicy *policy,</span>
<span class="line-removed">162                    Generation::Name young,</span>
163                    Generation::Name old,
164                    const char* policy_counters_name);
165 
166 public:
167 
168   // Returns JNI_OK on success
169   virtual jint initialize();
170   virtual CardTableRS* create_rem_set(const MemRegion&amp; reserved_region);
171 
172   void initialize_size_policy(size_t init_eden_size,
173                               size_t init_promo_size,
174                               size_t init_survivor_size);
175 
176   // Does operations required after initialization has been done.
177   void post_initialize();
178 
179   Generation* young_gen() const { return _young_gen; }
180   Generation* old_gen()   const { return _old_gen; }
181 
182   bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }
183   bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }
184 



185   GenerationSpec* young_gen_spec() const;
186   GenerationSpec* old_gen_spec() const;
187 
<span class="line-removed">188   // The generational collector policy.</span>
<span class="line-removed">189   GenCollectorPolicy* gen_policy() const { return _gen_policy; }</span>
<span class="line-removed">190 </span>
<span class="line-removed">191   virtual CollectorPolicy* collector_policy() const { return gen_policy(); }</span>
<span class="line-removed">192 </span>
193   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_gen_policy; }
194 
195   // Adaptive size policy
196   virtual AdaptiveSizePolicy* size_policy() {
197     return _size_policy;
198   }
199 
200   // Performance Counter support
201   GCPolicyCounters* counters()     { return _gc_policy_counters; }
202 
<span class="line-removed">203   // Return the (conservative) maximum heap alignment</span>
<span class="line-removed">204   static size_t conservative_max_heap_alignment() {</span>
<span class="line-removed">205     return Generation::GenGrain;</span>
<span class="line-removed">206   }</span>
<span class="line-removed">207 </span>
208   size_t capacity() const;
209   size_t used() const;
210 
211   // Save the &quot;used_region&quot; for both generations.
212   void save_used_regions();
213 
214   size_t max_capacity() const;
215 
216   HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);
217 
218   // We may support a shared contiguous allocation area, if the youngest
219   // generation does.
220   bool supports_inline_contig_alloc() const;
221   HeapWord* volatile* top_addr() const;
222   HeapWord** end_addr() const;
223 
224   // Perform a full collection of the heap; intended for use in implementing
225   // &quot;System.gc&quot;. This implies as full a collection as the CollectedHeap
226   // supports. Caller does not hold the Heap_lock on entry.
227   virtual void collect(GCCause::Cause cause);
228 
229   // The same as above but assume that the caller holds the Heap_lock.
230   void collect_locked(GCCause::Cause cause);
231 
232   // Perform a full collection of generations up to and including max_generation.
233   // Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.
234   void collect(GCCause::Cause cause, GenerationType max_generation);
235 
236   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
<span class="line-modified">237   // The methods is_in(), is_in_closed_subset() and is_in_youngest() may</span>
<span class="line-modified">238   // be expensive to compute in general, so, to prevent</span>
<span class="line-modified">239   // their inadvertent use in product jvm&#39;s, we restrict their use to</span>
<span class="line-removed">240   // assertion checking or verification only.</span>
241   bool is_in(const void* p) const;
242 
243   // Returns true if the reference is to an object in the reserved space
244   // for the young generation.
245   // Assumes the the young gen address range is less than that of the old gen.
246   bool is_in_young(oop p);
247 
248 #ifdef ASSERT
249   bool is_in_partial_collection(const void* p);
250 #endif
251 
252   // Optimized nmethod scanning support routines
253   virtual void register_nmethod(nmethod* nm);
254   virtual void unregister_nmethod(nmethod* nm);
255   virtual void verify_nmethod(nmethod* nm);
256   virtual void flush_nmethod(nmethod* nm);
257 
<span class="line-modified">258   void prune_nmethods();</span>
259 
260   // Iteration functions.
261   void oop_iterate(OopIterateClosure* cl);
262   void object_iterate(ObjectClosure* cl);
<span class="line-removed">263   void safe_object_iterate(ObjectClosure* cl);</span>
264   Space* space_containing(const void* addr) const;
265 
266   // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,
267   // each address in the (reserved) heap is a member of exactly
268   // one block.  The defining characteristic of a block is that it is
269   // possible to find its size, and thus to progress forward to the next
270   // block.  (Blocks may be of different sizes.)  Thus, blocks may
271   // represent Java objects, or they might be free blocks in a
272   // free-list-based heap (or subheap), as long as the two kinds are
273   // distinguishable and the size of each is determinable.
274 
275   // Returns the address of the start of the &quot;block&quot; that contains the
276   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
277   // may not pack objects densely; a chunk may either be an object or a
278   // non-object.
<span class="line-modified">279   virtual HeapWord* block_start(const void* addr) const;</span>
280 
281   // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
282   // the block is an object. Assumes (and verifies in non-product
283   // builds) that addr is in the allocated part of the heap and is
284   // the start of a chunk.
<span class="line-modified">285   virtual bool block_is_obj(const HeapWord* addr) const;</span>
286 
287   // Section on TLAB&#39;s.
288   virtual bool supports_tlab_allocation() const;
289   virtual size_t tlab_capacity(Thread* thr) const;
290   virtual size_t tlab_used(Thread* thr) const;
291   virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;
292   virtual HeapWord* allocate_new_tlab(size_t min_size,
293                                       size_t requested_size,
294                                       size_t* actual_size);
295 
296   // The &quot;requestor&quot; generation is performing some garbage collection
297   // action for which it would be useful to have scratch space.  The
298   // requestor promises to allocate no more than &quot;max_alloc_words&quot; in any
299   // older generation (via promotion say.)   Any blocks of space that can
300   // be provided are returned as a list of ScratchBlocks, sorted by
301   // decreasing size.
302   ScratchBlock* gather_scratch(Generation* requestor, size_t max_alloc_words);
303   // Allow each generation to reset any scratch space that it has
304   // contributed as it needs.
305   void release_scratch();
</pre>
<hr />
<pre>
331 
332   // Update the gc statistics for each generation.
333   void update_gc_stats(Generation* current_generation, bool full) {
334     _old_gen-&gt;update_gc_stats(current_generation, full);
335   }
336 
337   bool no_gc_in_progress() { return !is_gc_active(); }
338 
339   // Override.
340   void prepare_for_verify();
341 
342   // Override.
343   void verify(VerifyOption option);
344 
345   // Override.
346   virtual void print_on(outputStream* st) const;
347   virtual void print_gc_threads_on(outputStream* st) const;
348   virtual void gc_threads_do(ThreadClosure* tc) const;
349   virtual void print_tracing_info() const;
350 
<span class="line-modified">351   void print_heap_change(size_t young_prev_used, size_t old_prev_used) const;</span>



352 
353   // The functions below are helper functions that a subclass of
354   // &quot;CollectedHeap&quot; can use in the implementation of its virtual
355   // functions.
356 
357   class GenClosure : public StackObj {
358    public:
359     virtual void do_generation(Generation* gen) = 0;
360   };
361 
362   // Apply &quot;cl.do_generation&quot; to all generations in the heap
363   // If &quot;old_to_young&quot; determines the order.
364   void generation_iterate(GenClosure* cl, bool old_to_young);
365 
366   // Return &quot;true&quot; if all generations have reached the
367   // maximal committed limit that they can reach, without a garbage
368   // collection.
369   virtual bool is_maximal_no_gc() const;
370 
371   // This function returns the CardTableRS object that allows us to scan
</pre>
<hr />
<pre>
376   // asserted to be this type.
377   static GenCollectedHeap* heap();
378 
379   // The ScanningOption determines which of the roots
380   // the closure is applied to:
381   // &quot;SO_None&quot; does none;
382   enum ScanningOption {
383     SO_None                =  0x0,
384     SO_AllCodeCache        =  0x8,
385     SO_ScavengeCodeCache   = 0x10
386   };
387 
388  protected:
389   void process_roots(StrongRootsScope* scope,
390                      ScanningOption so,
391                      OopClosure* strong_roots,
392                      CLDClosure* strong_cld_closure,
393                      CLDClosure* weak_cld_closure,
394                      CodeBlobToOopClosure* code_roots);
395 
<span class="line-removed">396   // Accessor for memory state verification support</span>
<span class="line-removed">397   NOT_PRODUCT(</span>
<span class="line-removed">398     virtual size_t skip_header_HeapWords() { return 0; }</span>
<span class="line-removed">399   )</span>
<span class="line-removed">400 </span>
401   virtual void gc_prologue(bool full);
402   virtual void gc_epilogue(bool full);
403 
404  public:
405   void young_process_roots(StrongRootsScope* scope,
406                            OopsInGenClosure* root_closure,
407                            OopsInGenClosure* old_gen_closure,
408                            CLDClosure* cld_closure);
409 
410   void full_process_roots(StrongRootsScope* scope,
411                           bool is_adjust_phase,
412                           ScanningOption so,
413                           bool only_strong_roots,
414                           OopsInGenClosure* root_closure,
415                           CLDClosure* cld_closure);
416 
417   // Apply &quot;root_closure&quot; to all the weak roots of the system.
418   // These include JNI weak roots, string table,
419   // and referents of reachable weak refs.
420   void gen_process_weak_roots(OopClosure* root_closure);
</pre>
<hr />
<pre>
455   // gens in ascending order; return the new location of obj if successful.
456   // Otherwise, try expand-and-allocate for obj in both the young and old
457   // generation; return the new location of obj if successful.  Otherwise, return NULL.
458   oop handle_failed_promotion(Generation* old_gen,
459                               oop obj,
460                               size_t obj_size);
461 
462 
463 private:
464   // Return true if an allocation should be attempted in the older generation
465   // if it fails in the younger generation.  Return false, otherwise.
466   bool should_try_older_generation_allocation(size_t word_size) const;
467 
468   // Try to allocate space by expanding the heap.
469   HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);
470 
471   HeapWord* mem_allocate_work(size_t size,
472                               bool is_tlab,
473                               bool* gc_overhead_limit_was_exceeded);
474 
<span class="line-removed">475   // Override</span>
<span class="line-removed">476   void check_for_non_bad_heap_word_value(HeapWord* addr,</span>
<span class="line-removed">477     size_t size) PRODUCT_RETURN;</span>
<span class="line-removed">478 </span>
479 #if INCLUDE_SERIALGC
480   // For use by mark-sweep.  As implemented, mark-sweep-compact is global
481   // in an essential way: compaction is performed across generations, by
482   // iterating over spaces.
483   void prepare_for_compaction();
484 #endif
485 
486   // Perform a full collection of the generations up to and including max_generation.
487   // This is the low level interface used by the public versions of
488   // collect() and collect_locked(). Caller holds the Heap_lock on entry.
489   void collect_locked(GCCause::Cause cause, GenerationType max_generation);
490 
491   // Save the tops of the spaces in all generations
492   void record_gen_tops_before_GC() PRODUCT_RETURN;
493 
494   // Return true if we need to perform full collection.
495   bool should_do_full_collection(size_t size, bool full,
496                                  bool is_tlab, GenerationType max_gen) const;
497 };
498 
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 26 #define SHARE_GC_SHARED_GENCOLLECTEDHEAP_HPP
 27 
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;

 29 #include &quot;gc/shared/generation.hpp&quot;
 30 #include &quot;gc/shared/oopStorageParState.hpp&quot;
<span class="line-added"> 31 #include &quot;gc/shared/preGCValues.hpp&quot;</span>
 32 #include &quot;gc/shared/softRefGenPolicy.hpp&quot;
 33 
 34 class AdaptiveSizePolicy;
<span class="line-added"> 35 class CardTableRS;</span>
 36 class GCPolicyCounters;
 37 class GenerationSpec;
 38 class StrongRootsScope;
 39 class SubTasksDone;
 40 class WorkGang;
 41 
 42 // A &quot;GenCollectedHeap&quot; is a CollectedHeap that uses generational
 43 // collection.  It has two generations, young and old.
 44 class GenCollectedHeap : public CollectedHeap {

 45   friend class Generation;
 46   friend class DefNewGeneration;
 47   friend class TenuredGeneration;


 48   friend class GenMarkSweep;
 49   friend class VM_GenCollectForAllocation;
 50   friend class VM_GenCollectFull;
 51   friend class VM_GenCollectFullConcurrent;
 52   friend class VM_GC_HeapInspection;
 53   friend class VM_HeapDumper;
 54   friend class HeapInspection;
 55   friend class GCCauseSetter;
 56   friend class VMStructs;
 57 public:
 58   friend class VM_PopulateDumpSharedSpace;
 59 
 60   enum GenerationType {
 61     YoungGen,
 62     OldGen
 63   };
 64 
 65 protected:
 66   Generation* _young_gen;
 67   Generation* _old_gen;
 68 
 69 private:
 70   GenerationSpec* _young_gen_spec;
 71   GenerationSpec* _old_gen_spec;
 72 
 73   // The singleton CardTable Remembered Set.
 74   CardTableRS* _rem_set;
 75 



 76   SoftRefGenPolicy _soft_ref_gen_policy;
 77 
 78   // The sizing of the heap is controlled by a sizing policy.
 79   AdaptiveSizePolicy* _size_policy;
 80 
 81   GCPolicyCounters* _gc_policy_counters;
 82 
 83   // Indicates that the most recent previous incremental collection failed.
 84   // The flag is cleared when an action is taken that might clear the
 85   // condition that caused that incremental collection to fail.
 86   bool _incremental_collection_failed;
 87 
 88   // In support of ExplicitGCInvokesConcurrent functionality
 89   unsigned int _full_collections_completed;
 90 
 91   // Collects the given generation.
 92   void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,
 93                           bool run_verification, bool clear_soft_refs,
 94                           bool restore_marks_for_biased_locking);
 95 
 96   // Reserve aligned space for the heap as needed by the contained generations.
<span class="line-modified"> 97   ReservedHeapSpace allocate(size_t alignment);</span>
 98 
 99   // Initialize (&quot;weak&quot;) refs processing support
100   void ref_processing_init();
101 
<span class="line-added">102   PreGenGCValues get_pre_gc_values() const;</span>
<span class="line-added">103 </span>
104 protected:
105 
106   // The set of potentially parallel tasks in root scanning.
107   enum GCH_strong_roots_tasks {
108     GCH_PS_Universe_oops_do,
109     GCH_PS_JNIHandles_oops_do,
110     GCH_PS_ObjectSynchronizer_oops_do,
111     GCH_PS_FlatProfiler_oops_do,
112     GCH_PS_Management_oops_do,
113     GCH_PS_SystemDictionary_oops_do,
114     GCH_PS_ClassLoaderDataGraph_oops_do,
115     GCH_PS_jvmti_oops_do,
116     GCH_PS_CodeCache_oops_do,
<span class="line-modified">117     AOT_ONLY(GCH_PS_aot_oops_do COMMA)</span>
118     GCH_PS_younger_gens,
119     // Leave this one last.
120     GCH_PS_NumElements
121   };
122 
123   // Data structure for claiming the (potentially) parallel tasks in
124   // (gen-specific) roots processing.
125   SubTasksDone* _process_strong_tasks;
126 
127   GCMemoryManager* _young_manager;
128   GCMemoryManager* _old_manager;
129 
130   // Helper functions for allocation
131   HeapWord* attempt_allocation(size_t size,
132                                bool   is_tlab,
133                                bool   first_only);
134 
135   // Helper function for two callbacks below.
136   // Considers collection of the first max_level+1 generations.
137   void do_collection(bool           full,
138                      bool           clear_all_soft_refs,
139                      size_t         size,
140                      bool           is_tlab,
141                      GenerationType max_generation);
142 
143   // Callback from VM_GenCollectForAllocation operation.
144   // This function does everything necessary/possible to satisfy an
145   // allocation request that failed in the youngest generation that should
146   // have handled it (including collection, expansion, etc.)
147   HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);
148 
149   // Callback from VM_GenCollectFull operation.
150   // Perform a full collection of the first max_level+1 generations.
151   virtual void do_full_collection(bool clear_all_soft_refs);
152   void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);
153 
154   // Does the &quot;cause&quot; of GC indicate that
155   // we absolutely __must__ clear soft refs?
156   bool must_clear_all_soft_refs();
157 
<span class="line-modified">158   GenCollectedHeap(Generation::Name young,</span>

159                    Generation::Name old,
160                    const char* policy_counters_name);
161 
162 public:
163 
164   // Returns JNI_OK on success
165   virtual jint initialize();
166   virtual CardTableRS* create_rem_set(const MemRegion&amp; reserved_region);
167 
168   void initialize_size_policy(size_t init_eden_size,
169                               size_t init_promo_size,
170                               size_t init_survivor_size);
171 
172   // Does operations required after initialization has been done.
173   void post_initialize();
174 
175   Generation* young_gen() const { return _young_gen; }
176   Generation* old_gen()   const { return _old_gen; }
177 
178   bool is_young_gen(const Generation* gen) const { return gen == _young_gen; }
179   bool is_old_gen(const Generation* gen) const { return gen == _old_gen; }
180 
<span class="line-added">181   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-added">182   bool is_in_reserved(const void* addr) const { return _reserved.contains(addr); }</span>
<span class="line-added">183 </span>
184   GenerationSpec* young_gen_spec() const;
185   GenerationSpec* old_gen_spec() const;
186 





187   virtual SoftRefPolicy* soft_ref_policy() { return &amp;_soft_ref_gen_policy; }
188 
189   // Adaptive size policy
190   virtual AdaptiveSizePolicy* size_policy() {
191     return _size_policy;
192   }
193 
194   // Performance Counter support
195   GCPolicyCounters* counters()     { return _gc_policy_counters; }
196 





197   size_t capacity() const;
198   size_t used() const;
199 
200   // Save the &quot;used_region&quot; for both generations.
201   void save_used_regions();
202 
203   size_t max_capacity() const;
204 
205   HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);
206 
207   // We may support a shared contiguous allocation area, if the youngest
208   // generation does.
209   bool supports_inline_contig_alloc() const;
210   HeapWord* volatile* top_addr() const;
211   HeapWord** end_addr() const;
212 
213   // Perform a full collection of the heap; intended for use in implementing
214   // &quot;System.gc&quot;. This implies as full a collection as the CollectedHeap
215   // supports. Caller does not hold the Heap_lock on entry.
216   virtual void collect(GCCause::Cause cause);
217 
218   // The same as above but assume that the caller holds the Heap_lock.
219   void collect_locked(GCCause::Cause cause);
220 
221   // Perform a full collection of generations up to and including max_generation.
222   // Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.
223   void collect(GCCause::Cause cause, GenerationType max_generation);
224 
225   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
<span class="line-modified">226   // The methods is_in() and is_in_youngest() may be expensive to compute</span>
<span class="line-modified">227   // in general, so, to prevent their inadvertent use in product jvm&#39;s, we</span>
<span class="line-modified">228   // restrict their use to assertion checking or verification only.</span>

229   bool is_in(const void* p) const;
230 
231   // Returns true if the reference is to an object in the reserved space
232   // for the young generation.
233   // Assumes the the young gen address range is less than that of the old gen.
234   bool is_in_young(oop p);
235 
236 #ifdef ASSERT
237   bool is_in_partial_collection(const void* p);
238 #endif
239 
240   // Optimized nmethod scanning support routines
241   virtual void register_nmethod(nmethod* nm);
242   virtual void unregister_nmethod(nmethod* nm);
243   virtual void verify_nmethod(nmethod* nm);
244   virtual void flush_nmethod(nmethod* nm);
245 
<span class="line-modified">246   void prune_scavengable_nmethods();</span>
247 
248   // Iteration functions.
249   void oop_iterate(OopIterateClosure* cl);
250   void object_iterate(ObjectClosure* cl);

251   Space* space_containing(const void* addr) const;
252 
253   // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,
254   // each address in the (reserved) heap is a member of exactly
255   // one block.  The defining characteristic of a block is that it is
256   // possible to find its size, and thus to progress forward to the next
257   // block.  (Blocks may be of different sizes.)  Thus, blocks may
258   // represent Java objects, or they might be free blocks in a
259   // free-list-based heap (or subheap), as long as the two kinds are
260   // distinguishable and the size of each is determinable.
261 
262   // Returns the address of the start of the &quot;block&quot; that contains the
263   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
264   // may not pack objects densely; a chunk may either be an object or a
265   // non-object.
<span class="line-modified">266   HeapWord* block_start(const void* addr) const;</span>
267 
268   // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff
269   // the block is an object. Assumes (and verifies in non-product
270   // builds) that addr is in the allocated part of the heap and is
271   // the start of a chunk.
<span class="line-modified">272   bool block_is_obj(const HeapWord* addr) const;</span>
273 
274   // Section on TLAB&#39;s.
275   virtual bool supports_tlab_allocation() const;
276   virtual size_t tlab_capacity(Thread* thr) const;
277   virtual size_t tlab_used(Thread* thr) const;
278   virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;
279   virtual HeapWord* allocate_new_tlab(size_t min_size,
280                                       size_t requested_size,
281                                       size_t* actual_size);
282 
283   // The &quot;requestor&quot; generation is performing some garbage collection
284   // action for which it would be useful to have scratch space.  The
285   // requestor promises to allocate no more than &quot;max_alloc_words&quot; in any
286   // older generation (via promotion say.)   Any blocks of space that can
287   // be provided are returned as a list of ScratchBlocks, sorted by
288   // decreasing size.
289   ScratchBlock* gather_scratch(Generation* requestor, size_t max_alloc_words);
290   // Allow each generation to reset any scratch space that it has
291   // contributed as it needs.
292   void release_scratch();
</pre>
<hr />
<pre>
318 
319   // Update the gc statistics for each generation.
320   void update_gc_stats(Generation* current_generation, bool full) {
321     _old_gen-&gt;update_gc_stats(current_generation, full);
322   }
323 
324   bool no_gc_in_progress() { return !is_gc_active(); }
325 
326   // Override.
327   void prepare_for_verify();
328 
329   // Override.
330   void verify(VerifyOption option);
331 
332   // Override.
333   virtual void print_on(outputStream* st) const;
334   virtual void print_gc_threads_on(outputStream* st) const;
335   virtual void gc_threads_do(ThreadClosure* tc) const;
336   virtual void print_tracing_info() const;
337 
<span class="line-modified">338   // Used to print information about locations in the hs_err file.</span>
<span class="line-added">339   virtual bool print_location(outputStream* st, void* addr) const;</span>
<span class="line-added">340 </span>
<span class="line-added">341   void print_heap_change(const PreGenGCValues&amp; pre_gc_values) const;</span>
342 
343   // The functions below are helper functions that a subclass of
344   // &quot;CollectedHeap&quot; can use in the implementation of its virtual
345   // functions.
346 
347   class GenClosure : public StackObj {
348    public:
349     virtual void do_generation(Generation* gen) = 0;
350   };
351 
352   // Apply &quot;cl.do_generation&quot; to all generations in the heap
353   // If &quot;old_to_young&quot; determines the order.
354   void generation_iterate(GenClosure* cl, bool old_to_young);
355 
356   // Return &quot;true&quot; if all generations have reached the
357   // maximal committed limit that they can reach, without a garbage
358   // collection.
359   virtual bool is_maximal_no_gc() const;
360 
361   // This function returns the CardTableRS object that allows us to scan
</pre>
<hr />
<pre>
366   // asserted to be this type.
367   static GenCollectedHeap* heap();
368 
369   // The ScanningOption determines which of the roots
370   // the closure is applied to:
371   // &quot;SO_None&quot; does none;
372   enum ScanningOption {
373     SO_None                =  0x0,
374     SO_AllCodeCache        =  0x8,
375     SO_ScavengeCodeCache   = 0x10
376   };
377 
378  protected:
379   void process_roots(StrongRootsScope* scope,
380                      ScanningOption so,
381                      OopClosure* strong_roots,
382                      CLDClosure* strong_cld_closure,
383                      CLDClosure* weak_cld_closure,
384                      CodeBlobToOopClosure* code_roots);
385 





386   virtual void gc_prologue(bool full);
387   virtual void gc_epilogue(bool full);
388 
389  public:
390   void young_process_roots(StrongRootsScope* scope,
391                            OopsInGenClosure* root_closure,
392                            OopsInGenClosure* old_gen_closure,
393                            CLDClosure* cld_closure);
394 
395   void full_process_roots(StrongRootsScope* scope,
396                           bool is_adjust_phase,
397                           ScanningOption so,
398                           bool only_strong_roots,
399                           OopsInGenClosure* root_closure,
400                           CLDClosure* cld_closure);
401 
402   // Apply &quot;root_closure&quot; to all the weak roots of the system.
403   // These include JNI weak roots, string table,
404   // and referents of reachable weak refs.
405   void gen_process_weak_roots(OopClosure* root_closure);
</pre>
<hr />
<pre>
440   // gens in ascending order; return the new location of obj if successful.
441   // Otherwise, try expand-and-allocate for obj in both the young and old
442   // generation; return the new location of obj if successful.  Otherwise, return NULL.
443   oop handle_failed_promotion(Generation* old_gen,
444                               oop obj,
445                               size_t obj_size);
446 
447 
448 private:
449   // Return true if an allocation should be attempted in the older generation
450   // if it fails in the younger generation.  Return false, otherwise.
451   bool should_try_older_generation_allocation(size_t word_size) const;
452 
453   // Try to allocate space by expanding the heap.
454   HeapWord* expand_heap_and_allocate(size_t size, bool is_tlab);
455 
456   HeapWord* mem_allocate_work(size_t size,
457                               bool is_tlab,
458                               bool* gc_overhead_limit_was_exceeded);
459 




460 #if INCLUDE_SERIALGC
461   // For use by mark-sweep.  As implemented, mark-sweep-compact is global
462   // in an essential way: compaction is performed across generations, by
463   // iterating over spaces.
464   void prepare_for_compaction();
465 #endif
466 
467   // Perform a full collection of the generations up to and including max_generation.
468   // This is the low level interface used by the public versions of
469   // collect() and collect_locked(). Caller holds the Heap_lock on entry.
470   void collect_locked(GCCause::Cause cause, GenerationType max_generation);
471 
472   // Save the tops of the spaces in all generations
473   void record_gen_tops_before_GC() PRODUCT_RETURN;
474 
475   // Return true if we need to perform full collection.
476   bool should_do_full_collection(size_t size, bool full,
477                                  bool is_tlab, GenerationType max_gen) const;
478 };
479 
</pre>
</td>
</tr>
</table>
<center><a href="genCollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
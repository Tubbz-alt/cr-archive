<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/taskqueue.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="taskqueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/taskqueue.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
      // unused, so we cast the volatile away.  We cannot cast directly
      // to void, because gcc treats that as not using the result of the
      // assignment.  However, casting to E&amp; means that we trigger an
      // unused-value warning.  So, we cast the E&amp; to void.
      (void)const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified">!     OrderAccess::release_store(&amp;_bottom, increment_index(localBot));</span>
      TASKQUEUE_STATS_ONLY(stats.record_push());
      return true;
    }
    return false;
  }
<span class="line-new-header">--- 66,11 ---</span>
      // unused, so we cast the volatile away.  We cannot cast directly
      // to void, because gcc treats that as not using the result of the
      // assignment.  However, casting to E&amp; means that we trigger an
      // unused-value warning.  So, we cast the E&amp; to void.
      (void)const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified">!     Atomic::release_store(&amp;_bottom, increment_index(localBot));</span>
      TASKQUEUE_STATS_ONLY(stats.record_push());
      return true;
    }
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,11 ***</span>
      // unused, so we cast the volatile away.  We cannot cast directly
      // to void, because gcc treats that as not using the result of the
      // assignment.  However, casting to E&amp; means that we trigger an
      // unused-value warning.  So, we cast the E&amp; to void.
      (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified">!     OrderAccess::release_store(&amp;_bottom, increment_index(localBot));</span>
      TASKQUEUE_STATS_ONLY(stats.record_push());
      return true;
    } else {
      return push_slow(t, dirty_n_elems);
    }
<span class="line-new-header">--- 87,11 ---</span>
      // unused, so we cast the volatile away.  We cannot cast directly
      // to void, because gcc treats that as not using the result of the
      // assignment.  However, casting to E&amp; means that we trigger an
      // unused-value warning.  So, we cast the E&amp; to void.
      (void) const_cast&lt;E&amp;&gt;(_elems[localBot] = t);
<span class="line-modified">!     Atomic::release_store(&amp;_bottom, increment_index(localBot));</span>
      TASKQUEUE_STATS_ONLY(stats.record_push());
      return true;
    } else {
      return push_slow(t, dirty_n_elems);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,10 ***</span>
<span class="line-new-header">--- 182,15 ---</span>
      TASKQUEUE_STATS_ONLY(stats.record_pop());
      return true;
    } else {
      // Otherwise, the queue contained exactly one element; we take the slow
      // path.
<span class="line-added">+ </span>
<span class="line-added">+     // The barrier is required to prevent reordering the two reads of _age:</span>
<span class="line-added">+     // one is the _age.get() below, and the other is _age.top() above the if-stmt.</span>
<span class="line-added">+     // The algorithm may fail if _age.get() reads an older value than _age.top().</span>
<span class="line-added">+     OrderAccess::loadload();</span>
      return pop_local_slow(localBot, _age.get());
    }
  }
  
  template &lt;class E, MEMFLAGS F, unsigned int N&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,17 ***</span>
  }
  
  template&lt;class E, MEMFLAGS F, unsigned int N&gt;
  bool GenericTaskQueue&lt;E, F, N&gt;::pop_global(volatile E&amp; t) {
    Age oldAge = _age.get();
<span class="line-modified">!   // Architectures with weak memory model require a barrier here</span>
<span class="line-modified">!   // to guarantee that bottom is not older than age,</span>
    // which is crucial for the correctness of the algorithm.
<span class="line-modified">! #if !(defined SPARC || defined IA32 || defined AMD64)</span>
    OrderAccess::fence();
  #endif
<span class="line-modified">!   uint localBot = OrderAccess::load_acquire(&amp;_bottom);</span>
    uint n_elems = size(localBot, oldAge.top());
    if (n_elems == 0) {
      return false;
    }
  
<span class="line-new-header">--- 202,31 ---</span>
  }
  
  template&lt;class E, MEMFLAGS F, unsigned int N&gt;
  bool GenericTaskQueue&lt;E, F, N&gt;::pop_global(volatile E&amp; t) {
    Age oldAge = _age.get();
<span class="line-modified">! #ifndef CPU_MULTI_COPY_ATOMIC</span>
<span class="line-modified">!   // Architectures with non-multi-copy-atomic memory model require a</span>
<span class="line-added">+   // full fence here to guarantee that bottom is not older than age,</span>
    // which is crucial for the correctness of the algorithm.
<span class="line-modified">!   //</span>
<span class="line-added">+   // We need a full fence here for this case:</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // Thread1: set bottom (push)</span>
<span class="line-added">+   // Thread2: read age, read bottom, set age (pop_global)</span>
<span class="line-added">+   // Thread3: read age, read bottom (pop_global)</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // The requirement is that Thread3 must never read an older bottom</span>
<span class="line-added">+   // value than Thread2 after Thread3 has seen the age value from</span>
<span class="line-added">+   // Thread2.</span>
    OrderAccess::fence();
<span class="line-added">+ #else</span>
<span class="line-added">+   // Everyone else can make do with a LoadLoad barrier to keep reads</span>
<span class="line-added">+   // from _age and _bottom in order.</span>
<span class="line-added">+   OrderAccess::loadload();</span>
  #endif
<span class="line-modified">!   uint localBot = Atomic::load_acquire(&amp;_bottom);</span>
    uint n_elems = size(localBot, oldAge.top());
    if (n_elems == 0) {
      return false;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,11 ***</span>
    return false;
  }
  
  template &lt;unsigned int N, MEMFLAGS F&gt;
  inline typename TaskQueueSuper&lt;N, F&gt;::Age TaskQueueSuper&lt;N, F&gt;::Age::cmpxchg(const Age new_age, const Age old_age) volatile {
<span class="line-modified">!   return Atomic::cmpxchg(new_age._data, &amp;_data, old_age._data);</span>
  }
  
  template&lt;class E, MEMFLAGS F, unsigned int N&gt;
  template&lt;class Fn&gt;
  inline void GenericTaskQueue&lt;E, F, N&gt;::iterate(Fn fn) {
<span class="line-new-header">--- 333,11 ---</span>
    return false;
  }
  
  template &lt;unsigned int N, MEMFLAGS F&gt;
  inline typename TaskQueueSuper&lt;N, F&gt;::Age TaskQueueSuper&lt;N, F&gt;::Age::cmpxchg(const Age new_age, const Age old_age) volatile {
<span class="line-modified">!   return Atomic::cmpxchg(&amp;_data, old_age._data, new_age._data);</span>
  }
  
  template&lt;class E, MEMFLAGS F, unsigned int N&gt;
  template&lt;class Fn&gt;
  inline void GenericTaskQueue&lt;E, F, N&gt;::iterate(Fn fn) {
</pre>
<center><a href="taskqueue.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="threadLocalAllocBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/scavengableNMethods.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/codeCache.hpp&quot;
 27 #include &quot;code/nmethod.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 28 #include &quot;compiler/compileTask.hpp&quot;</span>
<span class="line-removed"> 29 #include &quot;gc/shared/collectedHeap.hpp&quot;</span>
 30 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
 31 #include &quot;gc/shared/scavengableNMethodsData.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 32 #include &quot;logging/log.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;logging/logStream.hpp&quot;</span>
<span class="line-removed"> 34 #include &quot;memory/universe.hpp&quot;</span>
 35 #include &quot;utilities/debug.hpp&quot;
 36 
 37 static ScavengableNMethodsData gc_data(nmethod* nm) {
 38   return ScavengableNMethodsData(nm);
 39 }
 40 
 41 nmethod* ScavengableNMethods::_head = NULL;
 42 BoolObjectClosure* ScavengableNMethods::_is_scavengable = NULL;
 43 
 44 void ScavengableNMethods::initialize(BoolObjectClosure* is_scavengable) {
 45   _is_scavengable = is_scavengable;
 46 }
 47 
 48 // Conditionally adds the nmethod to the list if it is
 49 // not already on the list and has a scavengeable root.
 50 void ScavengableNMethods::register_nmethod(nmethod* nm) {
 51   assert_locked_or_safepoint(CodeCache_lock);
 52 
 53   ScavengableNMethodsData data = gc_data(nm);
 54 
 55   if (data.on_list() || !has_scavengable_oops(nm)) {
 56     return;
 57   }
 58 
 59   data.set_on_list();
 60   data.set_next(_head);
 61 
 62   _head = nm;
<a name="3" id="anc3"></a><span class="line-removed"> 63 </span>
<span class="line-removed"> 64   CodeCache::print_trace(&quot;register_nmethod&quot;, nm);</span>
 65 }
 66 
 67 void ScavengableNMethods::unregister_nmethod(nmethod* nm) {
<a name="4" id="anc4"></a><span class="line-modified"> 68   // Do nothing. Unlinking is currently delayed until the purge phase.</span>











 69 }
 70 
 71 #ifndef PRODUCT
 72 
 73 class DebugScavengableOops: public OopClosure {
 74   BoolObjectClosure* _is_scavengable;
 75   nmethod*           _nm;
 76   bool               _ok;
 77 public:
 78   DebugScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
 79       _is_scavengable(is_scavengable),
 80       _nm(nm),
 81       _ok(true) { }
 82 
 83   bool ok() { return _ok; }
 84   virtual void do_oop(oop* p) {
 85     if (*p == NULL || !_is_scavengable-&gt;do_object_b(*p)) {
 86       return;
 87     }
 88 
 89     if (_ok) {
 90       _nm-&gt;print_nmethod(true);
 91       _ok = false;
 92     }
 93     tty-&gt;print_cr(&quot;*** scavengable oop &quot; PTR_FORMAT &quot; found at &quot; PTR_FORMAT &quot; (offset %d)&quot;,
 94                   p2i(*p), p2i(p), (int)((intptr_t)p - (intptr_t)_nm));
 95     (*p)-&gt;print();
 96   }
 97   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
 98 };
 99 
100 #endif // PRODUCT
101 
102 void ScavengableNMethods::verify_nmethod(nmethod* nm) {
103 #ifndef PRODUCT
104   if (!gc_data(nm).on_list()) {
105     // Actually look inside, to verify the claim that it&#39;s clean.
106     DebugScavengableOops cl(_is_scavengable, nm);
107     nm-&gt;oops_do(&amp;cl);
108     if (!cl.ok())
109       fatal(&quot;found an unadvertised bad scavengable oop in the code cache&quot;);
110   }
111   assert(gc_data(nm).not_marked(), &quot;&quot;);
112 #endif // PRODUCT
113 }
114 
<a name="5" id="anc5"></a><span class="line-removed">115 void ScavengableNMethods::flush_nmethod(nmethod* nm) {</span>
<span class="line-removed">116   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">117 </span>
<span class="line-removed">118   // TODO: Should be done in unregister_nmethod, during the &quot;unlink&quot; phase.</span>
<span class="line-removed">119   if (gc_data(nm).on_list()) {</span>
<span class="line-removed">120     CodeCache::print_trace(&quot;flush_nmethod&quot;, nm);</span>
<span class="line-removed">121     nmethod* prev = NULL;</span>
<span class="line-removed">122     for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {</span>
<span class="line-removed">123       if (cur == nm) {</span>
<span class="line-removed">124         unlist_nmethod(cur, prev);</span>
<span class="line-removed">125         return;</span>
<span class="line-removed">126       }</span>
<span class="line-removed">127       prev = cur;</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129   }</span>
<span class="line-removed">130 }</span>
<span class="line-removed">131 </span>
132 class HasScavengableOops: public OopClosure {
133   BoolObjectClosure* _is_scavengable;
134   bool               _found;
<a name="6" id="anc6"></a><span class="line-removed">135   nmethod*           _print_nm;</span>
136 public:
137   HasScavengableOops(BoolObjectClosure* is_scavengable, nmethod* nm) :
138       _is_scavengable(is_scavengable),
<a name="7" id="anc7"></a><span class="line-modified">139       _found(false),</span>
<span class="line-removed">140       _print_nm(nm) {}</span>
141 
142   bool found() { return _found; }
143   virtual void do_oop(oop* p) {
<a name="8" id="anc8"></a><span class="line-modified">144     if (*p != NULL &amp;&amp; _is_scavengable-&gt;do_object_b(*p)) {</span>
<span class="line-removed">145       NOT_PRODUCT(maybe_print(p));</span>
146       _found = true;
147     }
148   }
149   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
<a name="9" id="anc9"></a><span class="line-removed">150 </span>
<span class="line-removed">151 #ifndef PRODUCT</span>
<span class="line-removed">152   void maybe_print(oop* p) {</span>
<span class="line-removed">153     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">154     if (lt.is_enabled()) {</span>
<span class="line-removed">155       LogStream ls(lt);</span>
<span class="line-removed">156       if (!_found) {</span>
<span class="line-removed">157         CompileTask::print(&amp;ls, _print_nm, &quot;new scavengable oop&quot;, /*short_form:*/ true);</span>
<span class="line-removed">158       }</span>
<span class="line-removed">159       ls.print(&quot;&quot; PTR_FORMAT &quot;[offset=%d] found scavengable oop &quot; PTR_FORMAT &quot; (found at &quot; PTR_FORMAT &quot;) &quot;,</span>
<span class="line-removed">160                p2i(_print_nm), (int)((intptr_t)p - (intptr_t)_print_nm),</span>
<span class="line-removed">161                p2i(*p), p2i(p));</span>
<span class="line-removed">162       ls.cr();</span>
<span class="line-removed">163     }</span>
<span class="line-removed">164   }</span>
<span class="line-removed">165 #endif //PRODUCT</span>
166 };
167 
168 bool ScavengableNMethods::has_scavengable_oops(nmethod* nm) {
169   HasScavengableOops cl(_is_scavengable, nm);
170   nm-&gt;oops_do(&amp;cl);
171   return cl.found();
172 }
173 
174 // Walk the list of methods which might contain oops to the java heap.
<a name="10" id="anc10"></a><span class="line-modified">175 void ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure* f) {</span>
176   assert_locked_or_safepoint(CodeCache_lock);
177 
<a name="11" id="anc11"></a><span class="line-removed">178   const bool fix_relocations = f-&gt;fix_relocations();</span>
179   debug_only(mark_on_list_nmethods());
180 
181   nmethod* prev = NULL;
182   nmethod* cur = _head;
183   while (cur != NULL) {
<a name="12" id="anc12"></a>

184     ScavengableNMethodsData data = gc_data(cur);
185     debug_only(data.clear_marked());
<a name="13" id="anc13"></a><span class="line-removed">186     assert(data.not_marked(), &quot;&quot;);</span>
187     assert(data.on_list(), &quot;else shouldn&#39;t be on this list&quot;);
188 
<a name="14" id="anc14"></a><span class="line-modified">189     bool is_live = (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded());</span>
<span class="line-modified">190     LogTarget(Trace, gc, nmethod) lt;</span>
<span class="line-removed">191     if (lt.is_enabled()) {</span>
<span class="line-removed">192       LogStream ls(lt);</span>
<span class="line-removed">193       CompileTask::print(&amp;ls, cur,</span>
<span class="line-removed">194         is_live ? &quot;scavengable root &quot; : &quot;dead scavengable root&quot;, /*short_form:*/ true);</span>
<span class="line-removed">195     }</span>
<span class="line-removed">196     if (is_live) {</span>
<span class="line-removed">197       // Perform cur-&gt;oops_do(f), maybe just once per nmethod.</span>
<span class="line-removed">198       f-&gt;do_code_blob(cur);</span>
199     }
<a name="15" id="anc15"></a>
200     nmethod* const next = data.next();
<a name="16" id="anc16"></a><span class="line-modified">201     // The scavengable nmethod list must contain all methods with scavengable</span>
<span class="line-modified">202     // oops. It is safe to include more nmethod on the list, but we do not</span>
<span class="line-modified">203     // expect any live non-scavengable nmethods on the list.</span>
<span class="line-modified">204     if (fix_relocations) {</span>
<span class="line-modified">205       if (!is_live || !has_scavengable_oops(cur)) {</span>
<span class="line-removed">206         unlist_nmethod(cur, prev);</span>
<span class="line-removed">207       } else {</span>
<span class="line-removed">208         prev = cur;</span>
<span class="line-removed">209       }</span>
210     }
<a name="17" id="anc17"></a>
211     cur = next;
212   }
213 
214   // Check for stray marks.
215   debug_only(verify_unlisted_nmethods(NULL));
216 }
217 
<a name="18" id="anc18"></a>








218 #ifndef PRODUCT
<a name="19" id="anc19"></a><span class="line-modified">219 void ScavengableNMethods::asserted_non_scavengable_nmethods_do(CodeBlobClosure* f) {</span>
220   // While we are here, verify the integrity of the list.
221   mark_on_list_nmethods();
222   for (nmethod* cur = _head; cur != NULL; cur = gc_data(cur).next()) {
223     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);
224     gc_data(cur).clear_marked();
225   }
<a name="20" id="anc20"></a><span class="line-modified">226   verify_unlisted_nmethods(f);</span>
227 }
228 #endif // PRODUCT
229 
230 void ScavengableNMethods::unlist_nmethod(nmethod* nm, nmethod* prev) {
231   assert_locked_or_safepoint(CodeCache_lock);
232 
233   assert((prev == NULL &amp;&amp; _head == nm) ||
234          (prev != NULL &amp;&amp; gc_data(prev).next() == nm), &quot;precondition&quot;);
235 
<a name="21" id="anc21"></a><span class="line-removed">236   CodeCache::print_trace(&quot;unlist_nmethod&quot;, nm);</span>
<span class="line-removed">237 </span>
238   ScavengableNMethodsData data = gc_data(nm);
239 
240   if (prev == NULL) {
241     _head = data.next();
242   } else {
243     gc_data(prev).set_next(data.next());
244   }
245   data.set_next(NULL);
246   data.clear_on_list();
247 }
248 
<a name="22" id="anc22"></a><span class="line-removed">249 void ScavengableNMethods::prune_nmethods() {</span>
<span class="line-removed">250   assert_locked_or_safepoint(CodeCache_lock);</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   debug_only(mark_on_list_nmethods());</span>
<span class="line-removed">253 </span>
<span class="line-removed">254   nmethod* last = NULL;</span>
<span class="line-removed">255   nmethod* cur = _head;</span>
<span class="line-removed">256   while (cur != NULL) {</span>
<span class="line-removed">257     nmethod* next = gc_data(cur).next();</span>
<span class="line-removed">258     debug_only(gc_data(cur).clear_marked());</span>
<span class="line-removed">259     assert(gc_data(cur).on_list(), &quot;else shouldn&#39;t be on this list&quot;);</span>
<span class="line-removed">260 </span>
<span class="line-removed">261     if (!cur-&gt;is_zombie() &amp;&amp; !cur-&gt;is_unloaded() &amp;&amp; has_scavengable_oops(cur)) {</span>
<span class="line-removed">262       // Keep it.  Advance &#39;last&#39; to prevent deletion.</span>
<span class="line-removed">263       last = cur;</span>
<span class="line-removed">264     } else {</span>
<span class="line-removed">265       // Prune it from the list, so we don&#39;t have to look at it any more.</span>
<span class="line-removed">266       CodeCache::print_trace(&quot;prune_nmethods&quot;, cur);</span>
<span class="line-removed">267       unlist_nmethod(cur, last);</span>
<span class="line-removed">268     }</span>
<span class="line-removed">269     cur = next;</span>
<span class="line-removed">270   }</span>
<span class="line-removed">271 </span>
<span class="line-removed">272   // Check for stray marks.</span>
<span class="line-removed">273   debug_only(verify_unlisted_nmethods(NULL));</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 #ifndef PRODUCT
277 // Temporarily mark nmethods that are claimed to be on the scavenge list.
278 void ScavengableNMethods::mark_on_list_nmethods() {
279   NMethodIterator iter(NMethodIterator::only_alive);
280   while(iter.next()) {
281     nmethod* nm = iter.method();
282     ScavengableNMethodsData data = gc_data(nm);
283     assert(data.not_marked(), &quot;clean state&quot;);
284     if (data.on_list())
285       data.set_marked();
286   }
287 }
288 
289 // If the closure is given, run it on the unlisted nmethods.
290 // Also make sure that the effects of mark_on_list_nmethods is gone.
<a name="23" id="anc23"></a><span class="line-modified">291 void ScavengableNMethods::verify_unlisted_nmethods(CodeBlobClosure* f_or_null) {</span>
292   NMethodIterator iter(NMethodIterator::only_alive);
293   while(iter.next()) {
294     nmethod* nm = iter.method();
295 
296     verify_nmethod(nm);
297 
<a name="24" id="anc24"></a><span class="line-modified">298     if (f_or_null != NULL &amp;&amp; !gc_data(nm).on_list()) {</span>
<span class="line-modified">299       f_or_null-&gt;do_code_blob(nm);</span>
300     }
301   }
302 }
303 
304 #endif //PRODUCT
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
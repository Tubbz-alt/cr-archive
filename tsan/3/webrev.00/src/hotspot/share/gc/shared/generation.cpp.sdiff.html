<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/generation.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generation.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/generation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/shared/cardTableRS.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcLocker.hpp&quot;
 30 #include &quot;gc/shared/gcTimer.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;gc/shared/genOopClosures.hpp&quot;
 34 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 35 #include &quot;gc/shared/generation.hpp&quot;

 36 #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified"> 37 #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
 38 #include &quot;logging/log.hpp&quot;
 39 #include &quot;memory/allocation.inline.hpp&quot;
 40 #include &quot;oops/oop.inline.hpp&quot;
 41 #include &quot;runtime/java.hpp&quot;
 42 #include &quot;utilities/copy.hpp&quot;
 43 #include &quot;utilities/events.hpp&quot;
 44 
 45 Generation::Generation(ReservedSpace rs, size_t initial_size) :
 46   _gc_manager(NULL),
 47   _ref_processor(NULL) {
 48   if (!_virtual_space.initialize(rs, initial_size)) {
 49     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 50                     &quot;object heap&quot;);
 51   }
 52   // Mangle all of the the initial generation.
 53   if (ZapUnusedHeapArea) {
 54     MemRegion mangle_region((HeapWord*)_virtual_space.low(),
 55       (HeapWord*)_virtual_space.high());
 56     SpaceMangler::mangle_region(mangle_region);
 57   }
</pre>
<hr />
<pre>
 61 
 62 size_t Generation::initial_size() {
 63   GenCollectedHeap* gch = GenCollectedHeap::heap();
 64   if (gch-&gt;is_young_gen(this)) {
 65     return gch-&gt;young_gen_spec()-&gt;init_size();
 66   }
 67   return gch-&gt;old_gen_spec()-&gt;init_size();
 68 }
 69 
 70 size_t Generation::max_capacity() const {
 71   return reserved().byte_size();
 72 }
 73 
 74 // By default we get a single threaded default reference processor;
 75 // generations needing multi-threaded refs processing or discovery override this method.
 76 void Generation::ref_processor_init() {
 77   assert(_ref_processor == NULL, &quot;a reference processor already exists&quot;);
 78   assert(!_reserved.is_empty(), &quot;empty generation?&quot;);
 79   _span_based_discoverer.set_span(_reserved);
 80   _ref_processor = new ReferenceProcessor(&amp;_span_based_discoverer);    // a vanilla reference processor
<span class="line-removed"> 81   if (_ref_processor == NULL) {</span>
<span class="line-removed"> 82     vm_exit_during_initialization(&quot;Could not allocate ReferenceProcessor object&quot;);</span>
<span class="line-removed"> 83   }</span>
 84 }
 85 
 86 void Generation::print() const { print_on(tty); }
 87 
 88 void Generation::print_on(outputStream* st)  const {
 89   st-&gt;print(&quot; %-20s&quot;, name());
 90   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
 91              capacity()/K, used()/K);
 92   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
 93               p2i(_virtual_space.low_boundary()),
 94               p2i(_virtual_space.high()),
 95               p2i(_virtual_space.high_boundary()));
 96 }
 97 
 98 void Generation::print_summary_info_on(outputStream* st) {
 99   StatRecord* sr = stat_record();
100   double time = sr-&gt;accumulated_time.seconds();
101   st-&gt;print_cr(&quot;Accumulated %s generation GC time %3.7f secs, &quot;
102                &quot;%u GC&#39;s, avg GC time %3.7f&quot;,
103                GenCollectedHeap::heap()-&gt;is_young_gen(this) ? &quot;young&quot; : &quot;old&quot; ,
</pre>
<hr />
<pre>
151 bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {
152   size_t available = max_contiguous_available();
153   bool   res = (available &gt;= max_promotion_in_bytes);
154   log_trace(gc)(&quot;Generation: promo attempt is%s safe: available(&quot; SIZE_FORMAT &quot;) %s max_promo(&quot; SIZE_FORMAT &quot;)&quot;,
155                 res? &quot;&quot;:&quot; not&quot;, available, res? &quot;&gt;=&quot;:&quot;&lt;&quot;, max_promotion_in_bytes);
156   return res;
157 }
158 
159 // Ignores &quot;ref&quot; and calls allocate().
160 oop Generation::promote(oop obj, size_t obj_size) {
161   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
162 
163 #ifndef PRODUCT
164   if (GenCollectedHeap::heap()-&gt;promotion_should_fail()) {
165     return NULL;
166   }
167 #endif  // #ifndef PRODUCT
168 
169   HeapWord* result = allocate(obj_size, false);
170   if (result != NULL) {
<span class="line-modified">171     Copy::aligned_disjoint_words((HeapWord*)obj, result, obj_size);</span>
172     return oop(result);
173   } else {
174     GenCollectedHeap* gch = GenCollectedHeap::heap();
175     return gch-&gt;handle_failed_promotion(this, obj, obj_size);
176   }
177 }
178 
179 oop Generation::par_promote(int thread_num,
<span class="line-modified">180                             oop obj, markOop m, size_t word_sz) {</span>
181   // Could do a bad general impl here that gets a lock.  But no.
182   ShouldNotCallThis();
183   return NULL;
184 }
185 
186 Space* Generation::space_containing(const void* p) const {
187   GenerationIsInReservedClosure blk(p);
188   // Cast away const
189   ((Generation*)this)-&gt;space_iterate(&amp;blk);
190   return blk.sp;
191 }
192 
193 // Some of these are mediocre general implementations.  Should be
194 // overridden to get better performance.
195 
196 class GenerationBlockStartClosure : public SpaceClosure {
197  public:
198   const void* _p;
199   HeapWord* _start;
200   virtual void do_space(Space* s) {
</pre>
<hr />
<pre>
271                                                uint n_threads) {
272   CardTableRS* rs = GenCollectedHeap::heap()-&gt;rem_set();
273   rs-&gt;younger_refs_in_space_iterate(sp, cl, n_threads);
274 }
275 
276 class GenerationObjIterateClosure : public SpaceClosure {
277  private:
278   ObjectClosure* _cl;
279  public:
280   virtual void do_space(Space* s) {
281     s-&gt;object_iterate(_cl);
282   }
283   GenerationObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}
284 };
285 
286 void Generation::object_iterate(ObjectClosure* cl) {
287   GenerationObjIterateClosure blk(cl);
288   space_iterate(&amp;blk);
289 }
290 
<span class="line-removed">291 class GenerationSafeObjIterateClosure : public SpaceClosure {</span>
<span class="line-removed">292  private:</span>
<span class="line-removed">293   ObjectClosure* _cl;</span>
<span class="line-removed">294  public:</span>
<span class="line-removed">295   virtual void do_space(Space* s) {</span>
<span class="line-removed">296     s-&gt;safe_object_iterate(_cl);</span>
<span class="line-removed">297   }</span>
<span class="line-removed">298   GenerationSafeObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}</span>
<span class="line-removed">299 };</span>
<span class="line-removed">300 </span>
<span class="line-removed">301 void Generation::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-removed">302   GenerationSafeObjIterateClosure blk(cl);</span>
<span class="line-removed">303   space_iterate(&amp;blk);</span>
<span class="line-removed">304 }</span>
<span class="line-removed">305 </span>
306 #if INCLUDE_SERIALGC
307 
308 void Generation::prepare_for_compaction(CompactPoint* cp) {
309   // Generic implementation, can be specialized
310   CompactibleSpace* space = first_compaction_space();
311   while (space != NULL) {
312     space-&gt;prepare_for_compaction(cp);
313     space = space-&gt;next_compaction_space();
314   }
315 }
316 
317 class AdjustPointersClosure: public SpaceClosure {
318  public:
319   void do_space(Space* sp) {
320     sp-&gt;adjust_pointers();
321   }
322 };
323 
324 void Generation::adjust_pointers() {
325   // Note that this is done over all spaces, not just the compactible
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/blockOffsetTable.inline.hpp&quot;
 27 #include &quot;gc/shared/cardTableRS.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 29 #include &quot;gc/shared/gcLocker.hpp&quot;
 30 #include &quot;gc/shared/gcTimer.hpp&quot;
 31 #include &quot;gc/shared/gcTrace.hpp&quot;
 32 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
 33 #include &quot;gc/shared/genOopClosures.hpp&quot;
 34 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
 35 #include &quot;gc/shared/generation.hpp&quot;
<span class="line-added"> 36 #include &quot;gc/shared/generationSpec.hpp&quot;</span>
 37 #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified"> 38 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
 39 #include &quot;logging/log.hpp&quot;
 40 #include &quot;memory/allocation.inline.hpp&quot;
 41 #include &quot;oops/oop.inline.hpp&quot;
 42 #include &quot;runtime/java.hpp&quot;
 43 #include &quot;utilities/copy.hpp&quot;
 44 #include &quot;utilities/events.hpp&quot;
 45 
 46 Generation::Generation(ReservedSpace rs, size_t initial_size) :
 47   _gc_manager(NULL),
 48   _ref_processor(NULL) {
 49   if (!_virtual_space.initialize(rs, initial_size)) {
 50     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 51                     &quot;object heap&quot;);
 52   }
 53   // Mangle all of the the initial generation.
 54   if (ZapUnusedHeapArea) {
 55     MemRegion mangle_region((HeapWord*)_virtual_space.low(),
 56       (HeapWord*)_virtual_space.high());
 57     SpaceMangler::mangle_region(mangle_region);
 58   }
</pre>
<hr />
<pre>
 62 
 63 size_t Generation::initial_size() {
 64   GenCollectedHeap* gch = GenCollectedHeap::heap();
 65   if (gch-&gt;is_young_gen(this)) {
 66     return gch-&gt;young_gen_spec()-&gt;init_size();
 67   }
 68   return gch-&gt;old_gen_spec()-&gt;init_size();
 69 }
 70 
 71 size_t Generation::max_capacity() const {
 72   return reserved().byte_size();
 73 }
 74 
 75 // By default we get a single threaded default reference processor;
 76 // generations needing multi-threaded refs processing or discovery override this method.
 77 void Generation::ref_processor_init() {
 78   assert(_ref_processor == NULL, &quot;a reference processor already exists&quot;);
 79   assert(!_reserved.is_empty(), &quot;empty generation?&quot;);
 80   _span_based_discoverer.set_span(_reserved);
 81   _ref_processor = new ReferenceProcessor(&amp;_span_based_discoverer);    // a vanilla reference processor



 82 }
 83 
 84 void Generation::print() const { print_on(tty); }
 85 
 86 void Generation::print_on(outputStream* st)  const {
 87   st-&gt;print(&quot; %-20s&quot;, name());
 88   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
 89              capacity()/K, used()/K);
 90   st-&gt;print_cr(&quot; [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;)&quot;,
 91               p2i(_virtual_space.low_boundary()),
 92               p2i(_virtual_space.high()),
 93               p2i(_virtual_space.high_boundary()));
 94 }
 95 
 96 void Generation::print_summary_info_on(outputStream* st) {
 97   StatRecord* sr = stat_record();
 98   double time = sr-&gt;accumulated_time.seconds();
 99   st-&gt;print_cr(&quot;Accumulated %s generation GC time %3.7f secs, &quot;
100                &quot;%u GC&#39;s, avg GC time %3.7f&quot;,
101                GenCollectedHeap::heap()-&gt;is_young_gen(this) ? &quot;young&quot; : &quot;old&quot; ,
</pre>
<hr />
<pre>
149 bool Generation::promotion_attempt_is_safe(size_t max_promotion_in_bytes) const {
150   size_t available = max_contiguous_available();
151   bool   res = (available &gt;= max_promotion_in_bytes);
152   log_trace(gc)(&quot;Generation: promo attempt is%s safe: available(&quot; SIZE_FORMAT &quot;) %s max_promo(&quot; SIZE_FORMAT &quot;)&quot;,
153                 res? &quot;&quot;:&quot; not&quot;, available, res? &quot;&gt;=&quot;:&quot;&lt;&quot;, max_promotion_in_bytes);
154   return res;
155 }
156 
157 // Ignores &quot;ref&quot; and calls allocate().
158 oop Generation::promote(oop obj, size_t obj_size) {
159   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
160 
161 #ifndef PRODUCT
162   if (GenCollectedHeap::heap()-&gt;promotion_should_fail()) {
163     return NULL;
164   }
165 #endif  // #ifndef PRODUCT
166 
167   HeapWord* result = allocate(obj_size, false);
168   if (result != NULL) {
<span class="line-modified">169     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), result, obj_size);</span>
170     return oop(result);
171   } else {
172     GenCollectedHeap* gch = GenCollectedHeap::heap();
173     return gch-&gt;handle_failed_promotion(this, obj, obj_size);
174   }
175 }
176 
177 oop Generation::par_promote(int thread_num,
<span class="line-modified">178                             oop obj, markWord m, size_t word_sz) {</span>
179   // Could do a bad general impl here that gets a lock.  But no.
180   ShouldNotCallThis();
181   return NULL;
182 }
183 
184 Space* Generation::space_containing(const void* p) const {
185   GenerationIsInReservedClosure blk(p);
186   // Cast away const
187   ((Generation*)this)-&gt;space_iterate(&amp;blk);
188   return blk.sp;
189 }
190 
191 // Some of these are mediocre general implementations.  Should be
192 // overridden to get better performance.
193 
194 class GenerationBlockStartClosure : public SpaceClosure {
195  public:
196   const void* _p;
197   HeapWord* _start;
198   virtual void do_space(Space* s) {
</pre>
<hr />
<pre>
269                                                uint n_threads) {
270   CardTableRS* rs = GenCollectedHeap::heap()-&gt;rem_set();
271   rs-&gt;younger_refs_in_space_iterate(sp, cl, n_threads);
272 }
273 
274 class GenerationObjIterateClosure : public SpaceClosure {
275  private:
276   ObjectClosure* _cl;
277  public:
278   virtual void do_space(Space* s) {
279     s-&gt;object_iterate(_cl);
280   }
281   GenerationObjIterateClosure(ObjectClosure* cl) : _cl(cl) {}
282 };
283 
284 void Generation::object_iterate(ObjectClosure* cl) {
285   GenerationObjIterateClosure blk(cl);
286   space_iterate(&amp;blk);
287 }
288 















289 #if INCLUDE_SERIALGC
290 
291 void Generation::prepare_for_compaction(CompactPoint* cp) {
292   // Generic implementation, can be specialized
293   CompactibleSpace* space = first_compaction_space();
294   while (space != NULL) {
295     space-&gt;prepare_for_compaction(cp);
296     space = space-&gt;next_compaction_space();
297   }
298 }
299 
300 class AdjustPointersClosure: public SpaceClosure {
301  public:
302   void do_space(Space* sp) {
303     sp-&gt;adjust_pointers();
304   }
305 };
306 
307 void Generation::adjust_pointers() {
308   // Note that this is done over all spaces, not just the compactible
</pre>
</td>
</tr>
</table>
<center><a href="genOopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generation.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/shared/preservedMarks.cpp b/src/hotspot/share/gc/shared/preservedMarks.cpp
--- a/src/hotspot/share/gc/shared/preservedMarks.cpp
+++ b/src/hotspot/share/gc/shared/preservedMarks.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,24 +26,25 @@
 #include "gc/shared/preservedMarks.inline.hpp"
 #include "gc/shared/workgroup.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "oops/oop.inline.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/macros.hpp"
 
 void PreservedMarks::restore() {
   while (!_stack.is_empty()) {
-    const OopAndMarkOop elem = _stack.pop();
+    const OopAndMarkWord elem = _stack.pop();
     elem.set_mark();
   }
   assert_empty();
 }
 
 void PreservedMarks::adjust_during_full_gc() {
-  StackIterator<OopAndMarkOop, mtGC> iter(_stack);
+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);
   while (!iter.is_empty()) {
-    OopAndMarkOop* elem = iter.next_addr();
+    OopAndMarkWord* elem = iter.next_addr();
 
     oop obj = elem->get_oop();
     if (obj->is_forwarded()) {
       elem->set_oop(obj->forwardee());
     }
@@ -53,11 +54,11 @@
 void PreservedMarks::restore_and_increment(volatile size_t* const total_size_addr) {
   const size_t stack_size = size();
   restore();
   // Only do the atomic add if the size is > 0.
   if (stack_size > 0) {
-    Atomic::add(stack_size, total_size_addr);
+    Atomic::add(total_size_addr, stack_size);
   }
 }
 
 #ifndef PRODUCT
 void PreservedMarks::assert_empty() {
@@ -115,10 +116,40 @@
     _sub_tasks.set_n_threads(worker_num);
     _sub_tasks.set_n_tasks(preserved_marks_set->num());
   }
 };
 
+void PreservedMarksSet::restore(WorkGang* workers) {
+  volatile size_t total_size = 0;
+
+#ifdef ASSERT
+  // This is to make sure the total_size we'll calculate below is correct.
+  size_t total_size_before = 0;
+  for (uint i = 0; i < _num; i += 1) {
+    total_size_before += get(i)->size();
+  }
+#endif // def ASSERT
+
+  if (workers == NULL) {
+    for (uint i = 0; i < num(); i += 1) {
+      total_size += get(i)->size();
+      get(i)->restore();
+    }
+  } else {
+    ParRestoreTask task(workers->active_workers(), this, &total_size);
+    workers->run_task(&task);
+  }
+
+  assert_empty();
+
+  assert(total_size == total_size_before,
+         "total_size = " SIZE_FORMAT " before = " SIZE_FORMAT,
+         total_size, total_size_before);
+
+  log_trace(gc)("Restored " SIZE_FORMAT " marks", total_size);
+}
+
 void PreservedMarksSet::reclaim() {
   assert_empty();
 
   for (uint i = 0; i < _num; i += 1) {
     _stacks[i].~Padded<PreservedMarks>();
@@ -139,18 +170,5 @@
   for (uint i = 0; i < _num; i += 1) {
     get(i)->assert_empty();
   }
 }
 #endif // ndef PRODUCT
-
-void SharedRestorePreservedMarksTaskExecutor::restore(PreservedMarksSet* preserved_marks_set,
-                                                      volatile size_t* total_size_addr) {
-  if (_workers == NULL) {
-    for (uint i = 0; i < preserved_marks_set->num(); i += 1) {
-      *total_size_addr += preserved_marks_set->get(i)->size();
-      preserved_marks_set->get(i)->restore();
-    }
-  } else {
-    ParRestoreTask task(_workers->active_workers(), preserved_marks_set, total_size_addr);
-    _workers->run_task(&task);
-  }
-}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/satbMarkQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="satbMarkQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/satbMarkQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 26 #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 27 
 28 #include &quot;gc/shared/ptrQueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;

 30 
 31 class Thread;
 32 class Monitor;
 33 class SATBMarkQueueSet;
 34 
 35 // Base class for processing the contents of a SATB buffer.
 36 class SATBBufferClosure : public StackObj {
 37 protected:
 38   ~SATBBufferClosure() { }
 39 
 40 public:
 41   // Process the SATB entries in the designated buffer range.
 42   virtual void do_buffer(void** buffer, size_t size) = 0;
 43 };
 44 
 45 // A PtrQueue whose elements are (possibly stale) pointers to object heads.
 46 class SATBMarkQueue: public PtrQueue {
 47   friend class SATBMarkQueueSet;
 48 
 49 private:
 50   // Filter out unwanted entries from the buffer.
 51   inline void filter();
 52 
 53   // Removes entries from the buffer that are no longer needed.
 54   template&lt;typename Filter&gt;
 55   inline void apply_filter(Filter filter_out);
 56 



 57 public:
<span class="line-modified"> 58   SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent = false);</span>
 59 
 60   // Process queue entries and free resources.
 61   void flush();
 62 


 63   // Apply cl to the active part of the buffer.
 64   // Prerequisite: Must be at a safepoint.
 65   void apply_closure_and_empty(SATBBufferClosure* cl);
 66 
<span class="line-removed"> 67   // Overrides PtrQueue::should_enqueue_buffer(). See the method&#39;s</span>
<span class="line-removed"> 68   // definition for more information.</span>
<span class="line-removed"> 69   virtual bool should_enqueue_buffer();</span>
<span class="line-removed"> 70 </span>
 71 #ifndef PRODUCT
 72   // Helpful for debugging
 73   void print(const char* name);
 74 #endif // PRODUCT
 75 
 76   // Compiler support.
 77   static ByteSize byte_offset_of_index() {
 78     return PtrQueue::byte_offset_of_index&lt;SATBMarkQueue&gt;();
 79   }
 80   using PtrQueue::byte_width_of_index;
 81 
 82   static ByteSize byte_offset_of_buf() {
 83     return PtrQueue::byte_offset_of_buf&lt;SATBMarkQueue&gt;();
 84   }
 85   using PtrQueue::byte_width_of_buf;
 86 
 87   static ByteSize byte_offset_of_active() {
 88     return PtrQueue::byte_offset_of_active&lt;SATBMarkQueue&gt;();
 89   }
 90   using PtrQueue::byte_width_of_active;
 91 
 92 };
 93 
 94 class SATBMarkQueueSet: public PtrQueueSet {






 95   size_t _buffer_enqueue_threshold;




 96 
 97 #ifdef ASSERT
 98   void dump_active_states(bool expected_active);
 99   void verify_active_states(bool expected_active);
100 #endif // ASSERT
101 
102 protected:
<span class="line-modified">103   SATBMarkQueueSet();</span>
<span class="line-modified">104   ~SATBMarkQueueSet() {}</span>
105 
106   template&lt;typename Filter&gt;
107   void apply_filter(Filter filter, SATBMarkQueue* queue) {
108     queue-&gt;apply_filter(filter);
109   }
110 
<span class="line-removed">111   void initialize(Monitor* cbl_mon,</span>
<span class="line-removed">112                   BufferNode::Allocator* allocator,</span>
<span class="line-removed">113                   size_t process_completed_buffers_threshold,</span>
<span class="line-removed">114                   uint buffer_enqueue_threshold_percentage);</span>
<span class="line-removed">115 </span>
116 public:
117   virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
118 
119   // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
120   // called only with the world stopped. The method will assert that the
121   // SATB queues of all threads it visits, as well as the SATB queue
122   // set itself, has an active value same as expected_active.
123   void set_active_all_threads(bool active, bool expected_active);
124 


125   size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<span class="line-modified">126   virtual void filter(SATBMarkQueue* queue) = 0;</span>
127 
<span class="line-modified">128   // Filter all the currently-active SATB buffers.</span>
<span class="line-removed">129   void filter_thread_buffers();</span>
130 
131   // If there exists some completed buffer, pop and process it, and
132   // return true.  Otherwise return false.  Processing a buffer
133   // consists of applying the closure to the active range of the
134   // buffer; the leading entries may be excluded due to filtering.
135   bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
136 













137 #ifndef PRODUCT
138   // Helpful for debugging
139   void print_all(const char* msg);
140 #endif // PRODUCT
141 
142   // If a marking is being abandoned, reset any unprocessed log buffers.
143   void abandon_partial_marking();
144 };
145 




146 inline void SATBMarkQueue::filter() {
<span class="line-modified">147   static_cast&lt;SATBMarkQueueSet*&gt;(qset())-&gt;filter(this);</span>
148 }
149 
150 // Removes entries from the buffer that are no longer needed, as
151 // determined by filter. If e is a void* entry in the buffer,
152 // filter_out(e) must be a valid expression whose value is convertible
153 // to bool. Entries are removed (filtered out) if the result is true,
154 // retained if false.
155 template&lt;typename Filter&gt;
156 inline void SATBMarkQueue::apply_filter(Filter filter_out) {
157   void** buf = this-&gt;_buf;
158 
159   if (buf == NULL) {
160     // nothing to do
161     return;
162   }
163 
164   // Two-fingered compaction toward the end.
165   void** src = &amp;buf[this-&gt;index()];
166   void** dst = &amp;buf[this-&gt;capacity()];
167   assert(src &lt;= dst, &quot;invariant&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 26 #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 27 
 28 #include &quot;gc/shared/ptrQueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
<span class="line-added"> 30 #include &quot;memory/padded.hpp&quot;</span>
 31 
 32 class Thread;
 33 class Monitor;
 34 class SATBMarkQueueSet;
 35 
 36 // Base class for processing the contents of a SATB buffer.
 37 class SATBBufferClosure : public StackObj {
 38 protected:
 39   ~SATBBufferClosure() { }
 40 
 41 public:
 42   // Process the SATB entries in the designated buffer range.
 43   virtual void do_buffer(void** buffer, size_t size) = 0;
 44 };
 45 
 46 // A PtrQueue whose elements are (possibly stale) pointers to object heads.
 47 class SATBMarkQueue: public PtrQueue {
 48   friend class SATBMarkQueueSet;
 49 
 50 private:
 51   // Filter out unwanted entries from the buffer.
 52   inline void filter();
 53 
 54   // Removes entries from the buffer that are no longer needed.
 55   template&lt;typename Filter&gt;
 56   inline void apply_filter(Filter filter_out);
 57 
<span class="line-added"> 58 protected:</span>
<span class="line-added"> 59   virtual void handle_completed_buffer();</span>
<span class="line-added"> 60 </span>
 61 public:
<span class="line-modified"> 62   SATBMarkQueue(SATBMarkQueueSet* qset);</span>
 63 
 64   // Process queue entries and free resources.
 65   void flush();
 66 
<span class="line-added"> 67   inline SATBMarkQueueSet* satb_qset() const;</span>
<span class="line-added"> 68 </span>
 69   // Apply cl to the active part of the buffer.
 70   // Prerequisite: Must be at a safepoint.
 71   void apply_closure_and_empty(SATBBufferClosure* cl);
 72 




 73 #ifndef PRODUCT
 74   // Helpful for debugging
 75   void print(const char* name);
 76 #endif // PRODUCT
 77 
 78   // Compiler support.
 79   static ByteSize byte_offset_of_index() {
 80     return PtrQueue::byte_offset_of_index&lt;SATBMarkQueue&gt;();
 81   }
 82   using PtrQueue::byte_width_of_index;
 83 
 84   static ByteSize byte_offset_of_buf() {
 85     return PtrQueue::byte_offset_of_buf&lt;SATBMarkQueue&gt;();
 86   }
 87   using PtrQueue::byte_width_of_buf;
 88 
 89   static ByteSize byte_offset_of_active() {
 90     return PtrQueue::byte_offset_of_active&lt;SATBMarkQueue&gt;();
 91   }
 92   using PtrQueue::byte_width_of_active;
 93 
 94 };
 95 
 96 class SATBMarkQueueSet: public PtrQueueSet {
<span class="line-added"> 97 </span>
<span class="line-added"> 98   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="line-added"> 99   PaddedEnd&lt;BufferNode::Stack&gt; _list;</span>
<span class="line-added">100   volatile size_t _count_and_process_flag;</span>
<span class="line-added">101   // These are rarely (if ever) changed, so same cache line as count.</span>
<span class="line-added">102   size_t _process_completed_buffers_threshold;</span>
103   size_t _buffer_enqueue_threshold;
<span class="line-added">104   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 3 * sizeof(size_t));</span>
<span class="line-added">105 </span>
<span class="line-added">106   BufferNode* get_completed_buffer();</span>
<span class="line-added">107   void abandon_completed_buffers();</span>
108 
109 #ifdef ASSERT
110   void dump_active_states(bool expected_active);
111   void verify_active_states(bool expected_active);
112 #endif // ASSERT
113 
114 protected:
<span class="line-modified">115   SATBMarkQueueSet(BufferNode::Allocator* allocator);</span>
<span class="line-modified">116   ~SATBMarkQueueSet();</span>
117 
118   template&lt;typename Filter&gt;
119   void apply_filter(Filter filter, SATBMarkQueue* queue) {
120     queue-&gt;apply_filter(filter);
121   }
122 





123 public:
124   virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
125 
126   // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
127   // called only with the world stopped. The method will assert that the
128   // SATB queues of all threads it visits, as well as the SATB queue
129   // set itself, has an active value same as expected_active.
130   void set_active_all_threads(bool active, bool expected_active);
131 
<span class="line-added">132   void set_process_completed_buffers_threshold(size_t value);</span>
<span class="line-added">133 </span>
134   size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<span class="line-modified">135   void set_buffer_enqueue_threshold_percentage(uint value);</span>
136 
<span class="line-modified">137   virtual void filter(SATBMarkQueue* queue) = 0;</span>

138 
139   // If there exists some completed buffer, pop and process it, and
140   // return true.  Otherwise return false.  Processing a buffer
141   // consists of applying the closure to the active range of the
142   // buffer; the leading entries may be excluded due to filtering.
143   bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
144 
<span class="line-added">145   virtual void enqueue_completed_buffer(BufferNode* node);</span>
<span class="line-added">146 </span>
<span class="line-added">147   // The number of buffers in the list.  Racy and not updated atomically</span>
<span class="line-added">148   // with the set of completed buffers.</span>
<span class="line-added">149   size_t completed_buffers_num() const {</span>
<span class="line-added">150     return _count_and_process_flag &gt;&gt; 1;</span>
<span class="line-added">151   }</span>
<span class="line-added">152 </span>
<span class="line-added">153   // Return true if completed buffers should be processed.</span>
<span class="line-added">154   bool process_completed_buffers() const {</span>
<span class="line-added">155     return (_count_and_process_flag &amp; 1) != 0;</span>
<span class="line-added">156   }</span>
<span class="line-added">157 </span>
158 #ifndef PRODUCT
159   // Helpful for debugging
160   void print_all(const char* msg);
161 #endif // PRODUCT
162 
163   // If a marking is being abandoned, reset any unprocessed log buffers.
164   void abandon_partial_marking();
165 };
166 
<span class="line-added">167 inline SATBMarkQueueSet* SATBMarkQueue::satb_qset() const {</span>
<span class="line-added">168   return static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="line-added">169 }</span>
<span class="line-added">170 </span>
171 inline void SATBMarkQueue::filter() {
<span class="line-modified">172   satb_qset()-&gt;filter(this);</span>
173 }
174 
175 // Removes entries from the buffer that are no longer needed, as
176 // determined by filter. If e is a void* entry in the buffer,
177 // filter_out(e) must be a valid expression whose value is convertible
178 // to bool. Entries are removed (filtered out) if the result is true,
179 // retained if false.
180 template&lt;typename Filter&gt;
181 inline void SATBMarkQueue::apply_filter(Filter filter_out) {
182   void** buf = this-&gt;_buf;
183 
184   if (buf == NULL) {
185     // nothing to do
186     return;
187   }
188 
189   // Two-fingered compaction toward the end.
190   void** src = &amp;buf[this-&gt;index()];
191   void** dst = &amp;buf[this-&gt;capacity()];
192   assert(src &lt;= dst, &quot;invariant&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="satbMarkQueue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
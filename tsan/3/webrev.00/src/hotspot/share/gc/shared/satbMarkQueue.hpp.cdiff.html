<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/satbMarkQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="satbMarkQueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/satbMarkQueue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,10 ***</span>
<span class="line-new-header">--- 25,11 ---</span>
  #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
  #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
  
  #include &quot;gc/shared/ptrQueue.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
<span class="line-added">+ #include &quot;memory/padded.hpp&quot;</span>
  
  class Thread;
  class Monitor;
  class SATBMarkQueueSet;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,24 ***</span>
  
    // Removes entries from the buffer that are no longer needed.
    template&lt;typename Filter&gt;
    inline void apply_filter(Filter filter_out);
  
  public:
<span class="line-modified">!   SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent = false);</span>
  
    // Process queue entries and free resources.
    void flush();
  
    // Apply cl to the active part of the buffer.
    // Prerequisite: Must be at a safepoint.
    void apply_closure_and_empty(SATBBufferClosure* cl);
  
<span class="line-removed">-   // Overrides PtrQueue::should_enqueue_buffer(). See the method&#39;s</span>
<span class="line-removed">-   // definition for more information.</span>
<span class="line-removed">-   virtual bool should_enqueue_buffer();</span>
<span class="line-removed">- </span>
  #ifndef PRODUCT
    // Helpful for debugging
    void print(const char* name);
  #endif // PRODUCT
  
<span class="line-new-header">--- 53,25 ---</span>
  
    // Removes entries from the buffer that are no longer needed.
    template&lt;typename Filter&gt;
    inline void apply_filter(Filter filter_out);
  
<span class="line-added">+ protected:</span>
<span class="line-added">+   virtual void handle_completed_buffer();</span>
<span class="line-added">+ </span>
  public:
<span class="line-modified">!   SATBMarkQueue(SATBMarkQueueSet* qset);</span>
  
    // Process queue entries and free resources.
    void flush();
  
<span class="line-added">+   inline SATBMarkQueueSet* satb_qset() const;</span>
<span class="line-added">+ </span>
    // Apply cl to the active part of the buffer.
    // Prerequisite: Must be at a safepoint.
    void apply_closure_and_empty(SATBBufferClosure* cl);
  
  #ifndef PRODUCT
    // Helpful for debugging
    void print(const char* name);
  #endif // PRODUCT
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,63 ***</span>
    using PtrQueue::byte_width_of_active;
  
  };
  
  class SATBMarkQueueSet: public PtrQueueSet {
    size_t _buffer_enqueue_threshold;
  
  #ifdef ASSERT
    void dump_active_states(bool expected_active);
    void verify_active_states(bool expected_active);
  #endif // ASSERT
  
  protected:
<span class="line-modified">!   SATBMarkQueueSet();</span>
<span class="line-modified">!   ~SATBMarkQueueSet() {}</span>
  
    template&lt;typename Filter&gt;
    void apply_filter(Filter filter, SATBMarkQueue* queue) {
      queue-&gt;apply_filter(filter);
    }
  
<span class="line-removed">-   void initialize(Monitor* cbl_mon,</span>
<span class="line-removed">-                   BufferNode::Allocator* allocator,</span>
<span class="line-removed">-                   size_t process_completed_buffers_threshold,</span>
<span class="line-removed">-                   uint buffer_enqueue_threshold_percentage);</span>
<span class="line-removed">- </span>
  public:
    virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
  
    // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
    // called only with the world stopped. The method will assert that the
    // SATB queues of all threads it visits, as well as the SATB queue
    // set itself, has an active value same as expected_active.
    void set_active_all_threads(bool active, bool expected_active);
  
    size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<span class="line-modified">!   virtual void filter(SATBMarkQueue* queue) = 0;</span>
  
<span class="line-modified">!   // Filter all the currently-active SATB buffers.</span>
<span class="line-removed">-   void filter_thread_buffers();</span>
  
    // If there exists some completed buffer, pop and process it, and
    // return true.  Otherwise return false.  Processing a buffer
    // consists of applying the closure to the active range of the
    // buffer; the leading entries may be excluded due to filtering.
    bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
  
  #ifndef PRODUCT
    // Helpful for debugging
    void print_all(const char* msg);
  #endif // PRODUCT
  
    // If a marking is being abandoned, reset any unprocessed log buffers.
    void abandon_partial_marking();
  };
  
  inline void SATBMarkQueue::filter() {
<span class="line-modified">!   static_cast&lt;SATBMarkQueueSet*&gt;(qset())-&gt;filter(this);</span>
  }
  
  // Removes entries from the buffer that are no longer needed, as
  // determined by filter. If e is a void* entry in the buffer,
  // filter_out(e) must be a valid expression whose value is convertible
<span class="line-new-header">--- 92,86 ---</span>
    using PtrQueue::byte_width_of_active;
  
  };
  
  class SATBMarkQueueSet: public PtrQueueSet {
<span class="line-added">+ </span>
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="line-added">+   PaddedEnd&lt;BufferNode::Stack&gt; _list;</span>
<span class="line-added">+   volatile size_t _count_and_process_flag;</span>
<span class="line-added">+   // These are rarely (if ever) changed, so same cache line as count.</span>
<span class="line-added">+   size_t _process_completed_buffers_threshold;</span>
    size_t _buffer_enqueue_threshold;
<span class="line-added">+   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 3 * sizeof(size_t));</span>
<span class="line-added">+ </span>
<span class="line-added">+   BufferNode* get_completed_buffer();</span>
<span class="line-added">+   void abandon_completed_buffers();</span>
  
  #ifdef ASSERT
    void dump_active_states(bool expected_active);
    void verify_active_states(bool expected_active);
  #endif // ASSERT
  
  protected:
<span class="line-modified">!   SATBMarkQueueSet(BufferNode::Allocator* allocator);</span>
<span class="line-modified">!   ~SATBMarkQueueSet();</span>
  
    template&lt;typename Filter&gt;
    void apply_filter(Filter filter, SATBMarkQueue* queue) {
      queue-&gt;apply_filter(filter);
    }
  
  public:
    virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
  
    // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
    // called only with the world stopped. The method will assert that the
    // SATB queues of all threads it visits, as well as the SATB queue
    // set itself, has an active value same as expected_active.
    void set_active_all_threads(bool active, bool expected_active);
  
<span class="line-added">+   void set_process_completed_buffers_threshold(size_t value);</span>
<span class="line-added">+ </span>
    size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<span class="line-modified">!   void set_buffer_enqueue_threshold_percentage(uint value);</span>
  
<span class="line-modified">!   virtual void filter(SATBMarkQueue* queue) = 0;</span>
  
    // If there exists some completed buffer, pop and process it, and
    // return true.  Otherwise return false.  Processing a buffer
    // consists of applying the closure to the active range of the
    // buffer; the leading entries may be excluded due to filtering.
    bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
  
<span class="line-added">+   virtual void enqueue_completed_buffer(BufferNode* node);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // The number of buffers in the list.  Racy and not updated atomically</span>
<span class="line-added">+   // with the set of completed buffers.</span>
<span class="line-added">+   size_t completed_buffers_num() const {</span>
<span class="line-added">+     return _count_and_process_flag &gt;&gt; 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Return true if completed buffers should be processed.</span>
<span class="line-added">+   bool process_completed_buffers() const {</span>
<span class="line-added">+     return (_count_and_process_flag &amp; 1) != 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
  #ifndef PRODUCT
    // Helpful for debugging
    void print_all(const char* msg);
  #endif // PRODUCT
  
    // If a marking is being abandoned, reset any unprocessed log buffers.
    void abandon_partial_marking();
  };
  
<span class="line-added">+ inline SATBMarkQueueSet* SATBMarkQueue::satb_qset() const {</span>
<span class="line-added">+   return static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  inline void SATBMarkQueue::filter() {
<span class="line-modified">!   satb_qset()-&gt;filter(this);</span>
  }
  
  // Removes entries from the buffer that are no longer needed, as
  // determined by filter. If e is a void* entry in the buffer,
  // filter_out(e) must be a valid expression whose value is convertible
</pre>
<center><a href="satbMarkQueue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="scavengableNMethods.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
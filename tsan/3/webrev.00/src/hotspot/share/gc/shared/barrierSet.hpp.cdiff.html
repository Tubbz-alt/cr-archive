<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/barrierSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ageTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="barrierSetNMethod.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/barrierSet.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 128,17 ***</span>
    // is redone until it succeeds. This can e.g. prevent allocations from the slow path
    // to be in old.
    virtual void on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {}
    virtual void on_thread_create(Thread* thread) {}
    virtual void on_thread_destroy(Thread* thread) {}
    virtual void on_thread_attach(Thread* thread) {}
    virtual void on_thread_detach(Thread* thread) {}
<span class="line-removed">-   virtual void make_parsable(JavaThread* thread) {}</span>
  
<span class="line-modified">! #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-removed">-   virtual bool oop_equals_operator_allowed() { return true; }</span>
<span class="line-removed">- #endif</span>
  
  public:
    // Print a description of the memory for the barrier set
    virtual void print_on(outputStream* st) const = 0;
  
<span class="line-new-header">--- 128,23 ---</span>
    // is redone until it succeeds. This can e.g. prevent allocations from the slow path
    // to be in old.
    virtual void on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {}
    virtual void on_thread_create(Thread* thread) {}
    virtual void on_thread_destroy(Thread* thread) {}
<span class="line-added">+ </span>
<span class="line-added">+   // These perform BarrierSet-related initialization/cleanup before the thread</span>
<span class="line-added">+   // is added to or removed from the corresponding set of threads. The</span>
<span class="line-added">+   // argument thread is the current thread. These are called either holding</span>
<span class="line-added">+   // the Threads_lock (for a JavaThread) and so not at a safepoint, or holding</span>
<span class="line-added">+   // the NonJavaThreadsList_lock (for a NonJavaThread) locked by the</span>
<span class="line-added">+   // caller. That locking ensures the operation is &quot;atomic&quot; with the list</span>
<span class="line-added">+   // modification wrto operations that hold the NJTList_lock and either also</span>
<span class="line-added">+   // hold the Threads_lock or are at a safepoint.</span>
    virtual void on_thread_attach(Thread* thread) {}
    virtual void on_thread_detach(Thread* thread) {}
  
<span class="line-modified">!   virtual void make_parsable(JavaThread* thread) {}</span>
  
  public:
    // Print a description of the memory for the barrier set
    virtual void print_on(outputStream* st) const = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,27 ***</span>
      static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {
        Raw::store_at(base, offset, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_cmpxchg_in_heap(T new_value, T* addr, T compare_value) {</span>
<span class="line-modified">!       return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_cmpxchg_in_heap_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">!       return Raw::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_xchg_in_heap(T new_value, T* addr) {</span>
<span class="line-modified">!       return Raw::atomic_xchg(new_value, addr);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_xchg_in_heap_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">!       return Raw::atomic_xchg_at(new_value, base, offset);</span>
      }
  
      template &lt;typename T&gt;
      static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
<span class="line-new-header">--- 209,27 ---</span>
      static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {
        Raw::store_at(base, offset, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_cmpxchg_in_heap(T* addr, T compare_value, T new_value) {</span>
<span class="line-modified">!       return Raw::atomic_cmpxchg(addr, compare_value, new_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, T compare_value, T new_value) {</span>
<span class="line-modified">!       return Raw::atomic_cmpxchg_at(base, offset, compare_value, new_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_xchg_in_heap(T* addr, T new_value) {</span>
<span class="line-modified">!       return Raw::atomic_xchg(addr, new_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static T atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, T new_value) {</span>
<span class="line-modified">!       return Raw::atomic_xchg_at(base, offset, new_value);</span>
      }
  
      template &lt;typename T&gt;
      static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                    arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,25 ***</span>
      static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {
        Raw::oop_store_at(base, offset, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
      }
  
<span class="line-modified">!     static oop oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg(new_value, addr);</span>
      }
  
<span class="line-modified">!     static oop oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg_at(new_value, base, offset);</span>
      }
  
      template &lt;typename T&gt;
      static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                        arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
<span class="line-new-header">--- 259,25 ---</span>
      static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {
        Raw::oop_store_at(base, offset, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
      }
  
<span class="line-modified">!     static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg_at(base, offset, compare_value, new_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg(addr, new_value);</span>
      }
  
<span class="line-modified">!     static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg_at(base, offset, new_value);</span>
      }
  
      template &lt;typename T&gt;
      static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
                                        arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,31 ***</span>
      static void oop_store_not_in_heap(T* addr, oop value) {
        Raw::oop_store(addr, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_cmpxchg_not_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_xchg_not_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg(new_value, addr);</span>
      }
  
      // Clone barrier support
      static void clone_in_heap(oop src, oop dst, size_t size) {
        Raw::clone(src, dst, size);
      }
  
      static oop resolve(oop obj) {
        return Raw::resolve(obj);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     static bool equals(oop o1, oop o2) {</span>
<span class="line-removed">-       return Raw::equals(o1, o2);</span>
<span class="line-removed">-     }</span>
    };
  };
  
  template&lt;typename T&gt;
  inline T* barrier_set_cast(BarrierSet* bs) {
<span class="line-new-header">--- 295,27 ---</span>
      static void oop_store_not_in_heap(T* addr, oop value) {
        Raw::oop_store(addr, value);
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);</span>
      }
  
      template &lt;typename T&gt;
<span class="line-modified">!     static oop oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
<span class="line-modified">!       return Raw::oop_atomic_xchg(addr, new_value);</span>
      }
  
      // Clone barrier support
      static void clone_in_heap(oop src, oop dst, size_t size) {
        Raw::clone(src, dst, size);
      }
  
      static oop resolve(oop obj) {
        return Raw::resolve(obj);
      }
    };
  };
  
  template&lt;typename T&gt;
  inline T* barrier_set_cast(BarrierSet* bs) {
</pre>
<center><a href="ageTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="barrierSetNMethod.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/weakProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/stringTable.hpp&quot;
 27 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
 28 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 30 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 31 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 32 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/iterator.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &quot;prims/resolvedMethodTable.hpp&quot;</span>
 36 #include &quot;runtime/globals.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 
<a name="3" id="anc3"></a><span class="line-modified"> 39 template &lt;typename Container&gt;</span>
<span class="line-modified"> 40 class OopsDoAndReportCounts {</span>
<span class="line-modified"> 41 public:</span>
<span class="line-modified"> 42   void operator()(BoolObjectClosure* is_alive, OopClosure* keep_alive, OopStorage* storage) {</span>
<span class="line-modified"> 43     Container::reset_dead_counter();</span>
<span class="line-modified"> 44 </span>
<span class="line-modified"> 45     CountingSkippedIsAliveClosure&lt;BoolObjectClosure, OopClosure&gt; cl(is_alive, keep_alive);</span>
<span class="line-added"> 46     storage-&gt;oops_do(&amp;cl);</span>
<span class="line-added"> 47 </span>
<span class="line-added"> 48     Container::inc_dead_counter(cl.num_dead() + cl.num_skipped());</span>
<span class="line-added"> 49     Container::finish_dead_counter();</span>
<span class="line-added"> 50   }</span>
<span class="line-added"> 51 };</span>
 52 
<a name="4" id="anc4"></a><span class="line-modified"> 53 void WeakProcessor::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive) {</span>
<span class="line-modified"> 54   WeakProcessorPhases::Iterator pit = WeakProcessorPhases::serial_iterator();</span>
<span class="line-added"> 55   for ( ; !pit.is_end(); ++pit) {</span>
<span class="line-added"> 56     WeakProcessorPhases::processor(*pit)(is_alive, keep_alive);</span>
<span class="line-added"> 57   }</span>
 58 
<a name="5" id="anc5"></a><span class="line-modified"> 59   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified"> 60   for ( ; !it.is_end(); ++it) {</span>
<span class="line-modified"> 61     if (OopStorageSet::string_table_weak() == *it) {</span>
<span class="line-modified"> 62       OopsDoAndReportCounts&lt;StringTable&gt;()(is_alive, keep_alive, *it);</span>
<span class="line-modified"> 63     } else if (OopStorageSet::resolved_method_table_weak() == *it) {</span>
<span class="line-added"> 64       OopsDoAndReportCounts&lt;ResolvedMethodTable&gt;()(is_alive, keep_alive, *it);</span>
<span class="line-added"> 65     } else {</span>
<span class="line-added"> 66       it-&gt;weak_oops_do(is_alive, keep_alive);</span>
 67     }
 68   }
 69 }
 70 
 71 void WeakProcessor::oops_do(OopClosure* closure) {
 72   AlwaysTrueClosure always_true;
 73   weak_oops_do(&amp;always_true, closure);
 74 }
 75 
 76 uint WeakProcessor::ergo_workers(uint max_workers) {
 77   // Ignore ParallelRefProcEnabled; that&#39;s for j.l.r.Reference processing.
 78   if (ReferencesPerThread == 0) {
 79     // Configuration says always use all the threads.
 80     return max_workers;
 81   }
 82 
 83   // One thread per ReferencesPerThread references (or fraction thereof)
 84   // in the various OopStorage objects, bounded by max_threads.
 85   //
 86   // Serial phases are ignored in this calculation, because of the
 87   // cost of running unnecessary threads.  These phases are normally
 88   // small or empty (assuming they are configured to exist at all),
 89   // and development oriented, so not allocating any threads
 90   // specifically for them is okay.
 91   size_t ref_count = 0;
<a name="6" id="anc6"></a><span class="line-modified"> 92   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified"> 93   for ( ; !it.is_end(); ++it) {</span>
<span class="line-added"> 94     ref_count += it-&gt;allocation_count();</span>
 95   }
 96 
 97   // +1 to (approx) round up the ref per thread division.
 98   size_t nworkers = 1 + (ref_count / ReferencesPerThread);
 99   nworkers = MIN2(nworkers, static_cast&lt;size_t&gt;(max_workers));
100   return static_cast&lt;uint&gt;(nworkers);
101 }
102 
103 void WeakProcessor::Task::initialize() {
104   assert(_nworkers != 0, &quot;must be&quot;);
105   assert(_phase_times == NULL || _nworkers &lt;= _phase_times-&gt;max_threads(),
106          &quot;nworkers (%u) exceeds max threads (%u)&quot;,
107          _nworkers, _phase_times-&gt;max_threads());
108 
109   if (_phase_times) {
110     _phase_times-&gt;set_active_workers(_nworkers);
111   }
112 
<a name="7" id="anc7"></a><span class="line-modified">113   uint storage_count = WeakProcessorPhases::oopstorage_phase_count;</span>
114   _storage_states = NEW_C_HEAP_ARRAY(StorageState, storage_count, mtGC);
115 
<a name="8" id="anc8"></a><span class="line-modified">116   StorageState* cur_state = _storage_states;</span>
<span class="line-modified">117   OopStorageSet::Iterator it = OopStorageSet::weak_iterator();</span>
<span class="line-modified">118   for ( ; !it.is_end(); ++it, ++cur_state) {</span>
<span class="line-modified">119     assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) &lt; storage_count, &quot;invariant&quot;);</span>
<span class="line-added">120     new (cur_state) StorageState(*it, _nworkers);</span>
121   }
<a name="9" id="anc9"></a><span class="line-added">122   assert(pointer_delta(cur_state, _storage_states, sizeof(StorageState)) == storage_count, &quot;invariant&quot;);</span>
123   StringTable::reset_dead_counter();
<a name="10" id="anc10"></a><span class="line-added">124   ResolvedMethodTable::reset_dead_counter();</span>
125 }
126 
127 WeakProcessor::Task::Task(uint nworkers) :
128   _phase_times(NULL),
129   _nworkers(nworkers),
130   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
131   _storage_states(NULL)
132 {
133   initialize();
134 }
135 
136 WeakProcessor::Task::Task(WeakProcessorPhaseTimes* phase_times, uint nworkers) :
137   _phase_times(phase_times),
138   _nworkers(nworkers),
139   _serial_phases_done(WeakProcessorPhases::serial_phase_count),
140   _storage_states(NULL)
141 {
142   initialize();
143 }
144 
145 WeakProcessor::Task::~Task() {
146   if (_storage_states != NULL) {
147     StorageState* states = _storage_states;
<a name="11" id="anc11"></a><span class="line-modified">148     for (uint i = 0; i &lt; WeakProcessorPhases::oopstorage_phase_count; ++i) {</span>
149       states-&gt;StorageState::~StorageState();
150       ++states;
151     }
152     FREE_C_HEAP_ARRAY(StorageState, _storage_states);
153   }
154   StringTable::finish_dead_counter();
<a name="12" id="anc12"></a><span class="line-added">155   ResolvedMethodTable::finish_dead_counter();</span>
156 }
157 
158 void WeakProcessor::GangTask::work(uint worker_id) {
159   _erased_do_work(this, worker_id);
160 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
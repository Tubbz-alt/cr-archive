<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/oopStorage.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="oopStorage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorageParState.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/oopStorage.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 
 38 // Array of all active blocks.  Refcounted for lock-free reclaim of
 39 // old array when a new array is allocated for expansion.
 40 class OopStorage::ActiveArray {
 41   friend class OopStorage::TestAccess;
 42 
 43   size_t _size;
 44   volatile size_t _block_count;
 45   mutable volatile int _refcount;
 46   // Block* _blocks[1];            // Pseudo flexible array member.
 47 
 48   ActiveArray(size_t size);
 49   ~ActiveArray();
 50 
<span class="line-modified"> 51   // Noncopyable</span>
<span class="line-removed"> 52   ActiveArray(const ActiveArray&amp;);</span>
<span class="line-removed"> 53   ActiveArray&amp; operator=(const ActiveArray&amp;);</span>
 54 
 55   static size_t blocks_offset();
 56   Block* const* base_ptr() const;
 57 
 58   Block* const* block_ptr(size_t index) const;
 59   Block** block_ptr(size_t index);
 60 
 61 public:
 62   static ActiveArray* create(size_t size, AllocFailType alloc_fail = AllocFailStrategy::EXIT_OOM);
 63   static void destroy(ActiveArray* ba);
 64 
 65   inline Block* at(size_t i) const;
 66 
 67   size_t size() const;
 68   size_t block_count() const;
 69   size_t block_count_acquire() const;
 70   void increment_refcount() const;
 71   bool decrement_refcount() const; // Return true if zero, otherwise false
 72 
 73   // Support for OopStorage::allocate.
</pre>
<hr />
<pre>
101 inline OopStorage::Block** OopStorage::ActiveArray::block_ptr(size_t index) {
102   return const_cast&lt;Block**&gt;(base_ptr() + index);
103 }
104 
105 inline OopStorage::Block* OopStorage::ActiveArray::at(size_t index) const {
106   assert(index &lt; _block_count, &quot;precondition&quot;);
107   return *block_ptr(index);
108 }
109 
110 // A Block has an embedded AllocationListEntry to provide the links between
111 // Blocks in an AllocationList.
112 class OopStorage::AllocationListEntry {
113   friend class OopStorage::AllocationList;
114 
115   // Members are mutable, and we deal exclusively with pointers to
116   // const, to make const blocks easier to use; a block being const
117   // doesn&#39;t prevent modifying its list state.
118   mutable const Block* _prev;
119   mutable const Block* _next;
120 
<span class="line-modified">121   // Noncopyable.</span>
<span class="line-removed">122   AllocationListEntry(const AllocationListEntry&amp;);</span>
<span class="line-removed">123   AllocationListEntry&amp; operator=(const AllocationListEntry&amp;);</span>
124 
125 public:
126   AllocationListEntry();
127   ~AllocationListEntry();
128 };
129 
130 // Fixed-sized array of oops, plus bookkeeping data.
131 // All blocks are in the storage&#39;s _active_array, at the block&#39;s _active_index.
132 // Non-full blocks are in the storage&#39;s _allocation_list, linked through the
133 // block&#39;s _allocation_list_entry.  Empty blocks are at the end of that list.
134 class OopStorage::Block /* No base class, to avoid messing up alignment. */ {
135   // _data must be the first non-static data member, for alignment.
136   oop _data[BitsPerWord];
137   static const unsigned _data_pos = 0; // Position of _data.
138 
139   volatile uintx _allocated_bitmask; // One bit per _data element.
<span class="line-modified">140   const OopStorage* _owner;</span>
141   void* _memory;              // Unaligned storage containing block.
142   size_t _active_index;
143   AllocationListEntry _allocation_list_entry;
144   Block* volatile _deferred_updates_next;
145   volatile uintx _release_refcount;
146 
147   Block(const OopStorage* owner, void* memory);
148   ~Block();
149 
150   void check_index(unsigned index) const;
151   unsigned get_index(const oop* ptr) const;
152 
153   template&lt;typename F, typename BlockPtr&gt;
154   static bool iterate_impl(F f, BlockPtr b);
155 
<span class="line-modified">156   // Noncopyable.</span>
<span class="line-removed">157   Block(const Block&amp;);</span>
<span class="line-removed">158   Block&amp; operator=(const Block&amp;);</span>
159 
160 public:
161   const AllocationListEntry&amp; allocation_list_entry() const;
162 
163   static size_t allocation_size();
164   static size_t allocation_alignment_shift();
165 
166   oop* get_pointer(unsigned index);
167   const oop* get_pointer(unsigned index) const;
168 
169   uintx bitmask_for_index(unsigned index) const;
170   uintx bitmask_for_entry(const oop* ptr) const;
171 
172   // Allocation bitmask accessors are racy.
173   bool is_full() const;
174   bool is_empty() const;
175   uintx allocated_bitmask() const;
176 
177   bool is_safe_to_delete() const;
178 
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;oops/oop.hpp&quot;
 32 #include &quot;runtime/safepoint.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/count_trailing_zeros.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 
 38 // Array of all active blocks.  Refcounted for lock-free reclaim of
 39 // old array when a new array is allocated for expansion.
 40 class OopStorage::ActiveArray {
 41   friend class OopStorage::TestAccess;
 42 
 43   size_t _size;
 44   volatile size_t _block_count;
 45   mutable volatile int _refcount;
 46   // Block* _blocks[1];            // Pseudo flexible array member.
 47 
 48   ActiveArray(size_t size);
 49   ~ActiveArray();
 50 
<span class="line-modified"> 51   NONCOPYABLE(ActiveArray);</span>


 52 
 53   static size_t blocks_offset();
 54   Block* const* base_ptr() const;
 55 
 56   Block* const* block_ptr(size_t index) const;
 57   Block** block_ptr(size_t index);
 58 
 59 public:
 60   static ActiveArray* create(size_t size, AllocFailType alloc_fail = AllocFailStrategy::EXIT_OOM);
 61   static void destroy(ActiveArray* ba);
 62 
 63   inline Block* at(size_t i) const;
 64 
 65   size_t size() const;
 66   size_t block_count() const;
 67   size_t block_count_acquire() const;
 68   void increment_refcount() const;
 69   bool decrement_refcount() const; // Return true if zero, otherwise false
 70 
 71   // Support for OopStorage::allocate.
</pre>
<hr />
<pre>
 99 inline OopStorage::Block** OopStorage::ActiveArray::block_ptr(size_t index) {
100   return const_cast&lt;Block**&gt;(base_ptr() + index);
101 }
102 
103 inline OopStorage::Block* OopStorage::ActiveArray::at(size_t index) const {
104   assert(index &lt; _block_count, &quot;precondition&quot;);
105   return *block_ptr(index);
106 }
107 
108 // A Block has an embedded AllocationListEntry to provide the links between
109 // Blocks in an AllocationList.
110 class OopStorage::AllocationListEntry {
111   friend class OopStorage::AllocationList;
112 
113   // Members are mutable, and we deal exclusively with pointers to
114   // const, to make const blocks easier to use; a block being const
115   // doesn&#39;t prevent modifying its list state.
116   mutable const Block* _prev;
117   mutable const Block* _next;
118 
<span class="line-modified">119   NONCOPYABLE(AllocationListEntry);</span>


120 
121 public:
122   AllocationListEntry();
123   ~AllocationListEntry();
124 };
125 
126 // Fixed-sized array of oops, plus bookkeeping data.
127 // All blocks are in the storage&#39;s _active_array, at the block&#39;s _active_index.
128 // Non-full blocks are in the storage&#39;s _allocation_list, linked through the
129 // block&#39;s _allocation_list_entry.  Empty blocks are at the end of that list.
130 class OopStorage::Block /* No base class, to avoid messing up alignment. */ {
131   // _data must be the first non-static data member, for alignment.
132   oop _data[BitsPerWord];
133   static const unsigned _data_pos = 0; // Position of _data.
134 
135   volatile uintx _allocated_bitmask; // One bit per _data element.
<span class="line-modified">136   intptr_t _owner_address;</span>
137   void* _memory;              // Unaligned storage containing block.
138   size_t _active_index;
139   AllocationListEntry _allocation_list_entry;
140   Block* volatile _deferred_updates_next;
141   volatile uintx _release_refcount;
142 
143   Block(const OopStorage* owner, void* memory);
144   ~Block();
145 
146   void check_index(unsigned index) const;
147   unsigned get_index(const oop* ptr) const;
148 
149   template&lt;typename F, typename BlockPtr&gt;
150   static bool iterate_impl(F f, BlockPtr b);
151 
<span class="line-modified">152   NONCOPYABLE(Block);</span>


153 
154 public:
155   const AllocationListEntry&amp; allocation_list_entry() const;
156 
157   static size_t allocation_size();
158   static size_t allocation_alignment_shift();
159 
160   oop* get_pointer(unsigned index);
161   const oop* get_pointer(unsigned index) const;
162 
163   uintx bitmask_for_index(unsigned index) const;
164   uintx bitmask_for_entry(const oop* ptr) const;
165 
166   // Allocation bitmask accessors are racy.
167   bool is_full() const;
168   bool is_empty() const;
169   uintx allocated_bitmask() const;
170 
171   bool is_safe_to_delete() const;
172 
</pre>
</td>
</tr>
</table>
<center><a href="oopStorage.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorageParState.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
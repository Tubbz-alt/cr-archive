<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/genOopClosures.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genCollectedHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genOopClosures.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 // Note: no do_oop defined, this is an abstract class.
 41 
 42 class OopsInGenClosure : public OopIterateClosure {
 43  private:
 44   Generation*  _orig_gen;     // generation originally set in ctor
 45   Generation*  _gen;          // generation being scanned
 46 
 47  protected:
 48   // Some subtypes need access.
 49   HeapWord*    _gen_boundary; // start of generation
 50   CardTableRS* _rs;           // remembered set
 51 
 52   // For assertions
 53   Generation* generation() { return _gen; }
 54   CardTableRS* rs() { return _rs; }
 55 
 56   // Derived classes that modify oops so that they might be old-to-young
 57   // pointers must call the method below.
 58   template &lt;class T&gt; void do_barrier(T* p);
 59 
<span class="line-removed"> 60   // Version for use by closures that may be called in parallel code.</span>
<span class="line-removed"> 61   template &lt;class T&gt; void par_do_barrier(T* p);</span>
<span class="line-removed"> 62 </span>
 63  public:
 64   OopsInGenClosure() : OopIterateClosure(NULL),
 65     _orig_gen(NULL), _gen(NULL), _gen_boundary(NULL), _rs(NULL) {};
 66 
 67   OopsInGenClosure(Generation* gen);
 68   void set_generation(Generation* gen);
 69 
 70   void reset_generation() { _gen = _orig_gen; }
 71 
 72   // Problem with static closures: must have _gen_boundary set at some point,
 73   // but cannot do this until after the heap is initialized.
 74   void set_orig_generation(Generation* gen) {
 75     _orig_gen = gen;
 76     set_generation(gen);
 77   }
 78 
 79   HeapWord* gen_boundary() { return _gen_boundary; }
 80 
 81 };
 82 
</pre>
</td>
<td>
<hr />
<pre>
 40 // Note: no do_oop defined, this is an abstract class.
 41 
 42 class OopsInGenClosure : public OopIterateClosure {
 43  private:
 44   Generation*  _orig_gen;     // generation originally set in ctor
 45   Generation*  _gen;          // generation being scanned
 46 
 47  protected:
 48   // Some subtypes need access.
 49   HeapWord*    _gen_boundary; // start of generation
 50   CardTableRS* _rs;           // remembered set
 51 
 52   // For assertions
 53   Generation* generation() { return _gen; }
 54   CardTableRS* rs() { return _rs; }
 55 
 56   // Derived classes that modify oops so that they might be old-to-young
 57   // pointers must call the method below.
 58   template &lt;class T&gt; void do_barrier(T* p);
 59 



 60  public:
 61   OopsInGenClosure() : OopIterateClosure(NULL),
 62     _orig_gen(NULL), _gen(NULL), _gen_boundary(NULL), _rs(NULL) {};
 63 
 64   OopsInGenClosure(Generation* gen);
 65   void set_generation(Generation* gen);
 66 
 67   void reset_generation() { _gen = _orig_gen; }
 68 
 69   // Problem with static closures: must have _gen_boundary set at some point,
 70   // but cannot do this until after the heap is initialized.
 71   void set_orig_generation(Generation* gen) {
 72     _orig_gen = gen;
 73     set_generation(gen);
 74   }
 75 
 76   HeapWord* gen_boundary() { return _gen_boundary; }
 77 
 78 };
 79 
</pre>
</td>
</tr>
</table>
<center><a href="genCollectedHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genOopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/gcLocker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/gcLocker.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a>
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/atomic.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;runtime/thread.inline.hpp&quot;
 33 #include &quot;runtime/threadSMR.hpp&quot;
 34 
 35 volatile jint GCLocker::_jni_lock_count = 0;
 36 volatile bool GCLocker::_needs_gc       = false;
 37 volatile bool GCLocker::_doing_gc       = false;
<a name="3" id="anc3"></a>
 38 
 39 #ifdef ASSERT
 40 volatile jint GCLocker::_debug_jni_lock_count = 0;
 41 #endif
 42 
 43 
 44 #ifdef ASSERT
 45 void GCLocker::verify_critical_count() {
 46   if (SafepointSynchronize::is_at_safepoint()) {
 47     assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, &quot;must agree&quot;);
 48     int count = 0;
 49     // Count the number of threads with critical operations in progress
 50     JavaThreadIteratorWithHandle jtiwh;
 51     for (; JavaThread *thr = jtiwh.next(); ) {
 52       if (thr-&gt;in_critical()) {
 53         count++;
 54       }
 55     }
 56     if (_jni_lock_count != count) {
 57       log_error(gc, verify)(&quot;critical counts don&#39;t match: %d != %d&quot;, _jni_lock_count, count);
 58       jtiwh.rewind();
 59       for (; JavaThread *thr = jtiwh.next(); ) {
 60         if (thr-&gt;in_critical()) {
 61           log_error(gc, verify)(INTPTR_FORMAT &quot; in_critical %d&quot;, p2i(thr), thr-&gt;in_critical());
 62         }
 63       }
 64     }
 65     assert(_jni_lock_count == count, &quot;must be equal&quot;);
 66   }
 67 }
 68 
 69 // In debug mode track the locking state at all times
 70 void GCLocker::increment_debug_jni_lock_count() {
 71   assert(_debug_jni_lock_count &gt;= 0, &quot;bad value&quot;);
 72   Atomic::inc(&amp;_debug_jni_lock_count);
 73 }
 74 
 75 void GCLocker::decrement_debug_jni_lock_count() {
 76   assert(_debug_jni_lock_count &gt; 0, &quot;bad value&quot;);
 77   Atomic::dec(&amp;_debug_jni_lock_count);
 78 }
 79 #endif
 80 
 81 void GCLocker::log_debug_jni(const char* msg) {
 82   Log(gc, jni) log;
 83   if (log.is_debug()) {
 84     ResourceMark rm; // JavaThread::name() allocates to convert to UTF8
 85     log.debug(&quot;%s Thread \&quot;%s\&quot; %d locked.&quot;, msg, Thread::current()-&gt;name(), _jni_lock_count);
 86   }
 87 }
 88 
 89 bool GCLocker::is_at_safepoint() {
 90   return SafepointSynchronize::is_at_safepoint();
 91 }
 92 
 93 bool GCLocker::check_active_before_gc() {
 94   assert(SafepointSynchronize::is_at_safepoint(), &quot;only read at safepoint&quot;);
 95   if (is_active() &amp;&amp; !_needs_gc) {
 96     verify_critical_count();
 97     _needs_gc = true;
 98     log_debug_jni(&quot;Setting _needs_gc.&quot;);
 99   }
100   return is_active();
101 }
102 
103 void GCLocker::stall_until_clear() {
104   assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
<a name="4" id="anc4"></a><span class="line-modified">105   MutexLocker   ml(JNICritical_lock);</span>
106 
107   if (needs_gc()) {
108     log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
109   }
110 
111   // Wait for _needs_gc  to be cleared
112   while (needs_gc()) {
<a name="5" id="anc5"></a><span class="line-modified">113     JNICritical_lock-&gt;wait();</span>
114   }
115 }
116 
<a name="6" id="anc6"></a>




117 void GCLocker::jni_lock(JavaThread* thread) {
118   assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
<a name="7" id="anc7"></a><span class="line-modified">119   MutexLocker mu(JNICritical_lock);</span>
120   // Block entering threads if we know at least one thread is in a
121   // JNI critical region and we need a GC.
122   // We check that at least one thread is in a critical region before
123   // blocking because blocked threads are woken up by a thread exiting
124   // a JNI critical region.
125   while (is_active_and_needs_gc() || _doing_gc) {
<a name="8" id="anc8"></a><span class="line-modified">126     JNICritical_lock-&gt;wait();</span>
127   }
128   thread-&gt;enter_critical();
129   _jni_lock_count++;
130   increment_debug_jni_lock_count();
131 }
132 
133 void GCLocker::jni_unlock(JavaThread* thread) {
134   assert(thread-&gt;in_last_critical(), &quot;should be exiting critical region&quot;);
135   MutexLocker mu(JNICritical_lock);
136   _jni_lock_count--;
137   decrement_debug_jni_lock_count();
138   thread-&gt;exit_critical();
139   if (needs_gc() &amp;&amp; !is_active_internal()) {
<a name="9" id="anc9"></a><span class="line-modified">140     // We&#39;re the last thread out. Cause a GC to occur.</span>






141     _doing_gc = true;
142     {
143       // Must give up the lock while at a safepoint
144       MutexUnlocker munlock(JNICritical_lock);
145       log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
146       Universe::heap()-&gt;collect(GCCause::_gc_locker);
147     }
148     _doing_gc = false;
149     _needs_gc = false;
150     JNICritical_lock-&gt;notify_all();
151   }
152 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/parallelCleaning.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="oopStorageParState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelCleaning.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/parallelCleaning.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/stringTable.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/parallelCleaning.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;

 33 
 34 StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,
 35                                                  OopClosure* keep_alive,
 36                                                  bool resize_table) :
 37   AbstractGangTask(&quot;String Dedup Cleaning&quot;),
 38   _dedup_closure(is_alive, keep_alive) {
 39 
 40   if (StringDedup::is_enabled()) {
 41     StringDedup::gc_prologue(resize_table);
 42   }
 43 }
 44 
 45 StringDedupCleaningTask::~StringDedupCleaningTask() {
 46   if (StringDedup::is_enabled()) {
 47     StringDedup::gc_epilogue();
 48   }
 49 }
 50 
 51 void StringDedupCleaningTask::work(uint worker_id) {
 52   if (StringDedup::is_enabled()) {
</pre>
<hr />
<pre>
 77   CompiledMethod* first;
 78   CompiledMethodIterator last(CompiledMethodIterator::only_alive);
 79 
 80   do {
 81     *num_claimed_nmethods = 0;
 82 
 83     first = _claimed_nmethod;
 84     last = CompiledMethodIterator(CompiledMethodIterator::only_alive, first);
 85 
 86     if (first != NULL) {
 87 
 88       for (int i = 0; i &lt; MaxClaimNmethods; i++) {
 89         if (!last.next()) {
 90           break;
 91         }
 92         claimed_nmethods[i] = last.method();
 93         (*num_claimed_nmethods)++;
 94       }
 95     }
 96 
<span class="line-modified"> 97   } while (Atomic::cmpxchg(last.method(), &amp;_claimed_nmethod, first) != first);</span>
 98 }
 99 
100 void CodeCacheUnloadingTask::work(uint worker_id) {
101   // The first nmethods is claimed by the first worker.
102   if (worker_id == 0 &amp;&amp; _first_nmethod != NULL) {
103     _first_nmethod-&gt;do_unloading(_unloading_occurred);
104     _first_nmethod = NULL;
105   }
106 
107   int num_claimed_nmethods;
108   CompiledMethod* claimed_nmethods[MaxClaimNmethods];
109 
110   while (true) {
111     claim_nmethods(claimed_nmethods, &amp;num_claimed_nmethods);
112 
113     if (num_claimed_nmethods == 0) {
114       break;
115     }
116 
117     for (int i = 0; i &lt; num_claimed_nmethods; i++) {
118       claimed_nmethods[i]-&gt;do_unloading(_unloading_occurred);
119     }
120   }
121 }
122 
123 KlassCleaningTask::KlassCleaningTask() :
124   _clean_klass_tree_claimed(0),
125   _klass_iterator() {
126 }
127 
128 bool KlassCleaningTask::claim_clean_klass_tree_task() {
129   if (_clean_klass_tree_claimed) {
130     return false;
131   }
132 
<span class="line-modified">133   return Atomic::cmpxchg(1, &amp;_clean_klass_tree_claimed, 0) == 0;</span>
134 }
135 
136 InstanceKlass* KlassCleaningTask::claim_next_klass() {
137   Klass* klass;
138   do {
139     klass =_klass_iterator.next_klass();
140   } while (klass != NULL &amp;&amp; !klass-&gt;is_instance_klass());
141 
142   // this can be null so don&#39;t call InstanceKlass::cast
143   return static_cast&lt;InstanceKlass*&gt;(klass);
144 }
145 
146 void KlassCleaningTask::work() {
147   ResourceMark rm;
148 
149   // One worker will clean the subklass/sibling klass tree.
150   if (claim_clean_klass_tree_task()) {
151     Klass::clean_subklass_tree();
152   }
153 
154   // All workers will help cleaning the classes,
155   InstanceKlass* klass;
156   while ((klass = claim_next_klass()) != NULL) {
157     clean_klass(klass);
158   }
159 }
<span class="line-removed">160 </span>
<span class="line-removed">161 ParallelCleaningTask::ParallelCleaningTask(BoolObjectClosure* is_alive,</span>
<span class="line-removed">162                                            uint num_workers,</span>
<span class="line-removed">163                                            bool unloading_occurred,</span>
<span class="line-removed">164                                            bool resize_dedup_table) :</span>
<span class="line-removed">165   AbstractGangTask(&quot;Parallel Cleaning&quot;),</span>
<span class="line-removed">166   _unloading_occurred(unloading_occurred),</span>
<span class="line-removed">167   _string_dedup_task(is_alive, NULL, resize_dedup_table),</span>
<span class="line-removed">168   _code_cache_task(num_workers, is_alive, unloading_occurred),</span>
<span class="line-removed">169   _klass_cleaning_task() {</span>
<span class="line-removed">170 }</span>
<span class="line-removed">171 </span>
<span class="line-removed">172 // The parallel work done by all worker threads.</span>
<span class="line-removed">173 void ParallelCleaningTask::work(uint worker_id) {</span>
<span class="line-removed">174   // Do first pass of code cache cleaning.</span>
<span class="line-removed">175   _code_cache_task.work(worker_id);</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   // Clean the string dedup data structures.</span>
<span class="line-removed">178   _string_dedup_task.work(worker_id);</span>
<span class="line-removed">179 </span>
<span class="line-removed">180   // Clean all klasses that were not unloaded.</span>
<span class="line-removed">181   // The weak metadata in klass doesn&#39;t need to be</span>
<span class="line-removed">182   // processed if there was no unloading.</span>
<span class="line-removed">183   if (_unloading_occurred) {</span>
<span class="line-removed">184     _klass_cleaning_task.work();</span>
<span class="line-removed">185   }</span>
<span class="line-removed">186 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/stringTable.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/parallelCleaning.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
<span class="line-added"> 33 #include &quot;runtime/atomic.hpp&quot;</span>
 34 
 35 StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,
 36                                                  OopClosure* keep_alive,
 37                                                  bool resize_table) :
 38   AbstractGangTask(&quot;String Dedup Cleaning&quot;),
 39   _dedup_closure(is_alive, keep_alive) {
 40 
 41   if (StringDedup::is_enabled()) {
 42     StringDedup::gc_prologue(resize_table);
 43   }
 44 }
 45 
 46 StringDedupCleaningTask::~StringDedupCleaningTask() {
 47   if (StringDedup::is_enabled()) {
 48     StringDedup::gc_epilogue();
 49   }
 50 }
 51 
 52 void StringDedupCleaningTask::work(uint worker_id) {
 53   if (StringDedup::is_enabled()) {
</pre>
<hr />
<pre>
 78   CompiledMethod* first;
 79   CompiledMethodIterator last(CompiledMethodIterator::only_alive);
 80 
 81   do {
 82     *num_claimed_nmethods = 0;
 83 
 84     first = _claimed_nmethod;
 85     last = CompiledMethodIterator(CompiledMethodIterator::only_alive, first);
 86 
 87     if (first != NULL) {
 88 
 89       for (int i = 0; i &lt; MaxClaimNmethods; i++) {
 90         if (!last.next()) {
 91           break;
 92         }
 93         claimed_nmethods[i] = last.method();
 94         (*num_claimed_nmethods)++;
 95       }
 96     }
 97 
<span class="line-modified"> 98   } while (Atomic::cmpxchg(&amp;_claimed_nmethod, first, last.method()) != first);</span>
 99 }
100 
101 void CodeCacheUnloadingTask::work(uint worker_id) {
102   // The first nmethods is claimed by the first worker.
103   if (worker_id == 0 &amp;&amp; _first_nmethod != NULL) {
104     _first_nmethod-&gt;do_unloading(_unloading_occurred);
105     _first_nmethod = NULL;
106   }
107 
108   int num_claimed_nmethods;
109   CompiledMethod* claimed_nmethods[MaxClaimNmethods];
110 
111   while (true) {
112     claim_nmethods(claimed_nmethods, &amp;num_claimed_nmethods);
113 
114     if (num_claimed_nmethods == 0) {
115       break;
116     }
117 
118     for (int i = 0; i &lt; num_claimed_nmethods; i++) {
119       claimed_nmethods[i]-&gt;do_unloading(_unloading_occurred);
120     }
121   }
122 }
123 
124 KlassCleaningTask::KlassCleaningTask() :
125   _clean_klass_tree_claimed(0),
126   _klass_iterator() {
127 }
128 
129 bool KlassCleaningTask::claim_clean_klass_tree_task() {
130   if (_clean_klass_tree_claimed) {
131     return false;
132   }
133 
<span class="line-modified">134   return Atomic::cmpxchg(&amp;_clean_klass_tree_claimed, 0, 1) == 0;</span>
135 }
136 
137 InstanceKlass* KlassCleaningTask::claim_next_klass() {
138   Klass* klass;
139   do {
140     klass =_klass_iterator.next_klass();
141   } while (klass != NULL &amp;&amp; !klass-&gt;is_instance_klass());
142 
143   // this can be null so don&#39;t call InstanceKlass::cast
144   return static_cast&lt;InstanceKlass*&gt;(klass);
145 }
146 
147 void KlassCleaningTask::work() {
148   ResourceMark rm;
149 
150   // One worker will clean the subklass/sibling klass tree.
151   if (claim_clean_klass_tree_task()) {
152     Klass::clean_subklass_tree();
153   }
154 
155   // All workers will help cleaning the classes,
156   InstanceKlass* klass;
157   while ((klass = claim_next_klass()) != NULL) {
158     clean_klass(klass);
159   }
160 }



























</pre>
</td>
</tr>
</table>
<center><a href="oopStorageParState.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="parallelCleaning.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/workgroup.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKGROUP_HPP
 26 #define SHARE_GC_SHARED_WORKGROUP_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;runtime/thread.hpp&quot;
 31 #include &quot;gc/shared/gcId.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;utilities/debug.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 
 36 // Task class hierarchy:
 37 //   AbstractGangTask
 38 //
 39 // Gang/Group class hierarchy:
 40 //   AbstractWorkGang
 41 //     WorkGang
 42 //     YieldingFlexibleWorkGang (defined in another file)
 43 //
 44 // Worker class hierarchy:
 45 //   AbstractGangWorker (subclass of WorkerThread)
 46 //     GangWorker
 47 //     YieldingFlexibleGangWorker   (defined in another file)
 48 
 49 // Forward declarations of classes defined here
 50 
 51 class AbstractGangWorker;
 52 class Semaphore;
<a name="1" id="anc1"></a><span class="line-added"> 53 class ThreadClosure;</span>
 54 class WorkGang;
 55 
 56 // An abstract task to be worked on by a gang.
 57 // You subclass this to supply your own work() method
 58 class AbstractGangTask {
 59   const char* _name;
 60   const uint _gc_id;
 61 
 62  public:
 63   explicit AbstractGangTask(const char* name) :
 64     _name(name),
 65     _gc_id(GCId::current_or_undefined())
 66   {}
 67 
 68   // The abstract work method.
 69   // The argument tells you which member of the gang you are.
 70   virtual void work(uint worker_id) = 0;
 71 
 72   // Debugging accessor for the name.
 73   const char* name() const { return _name; }
 74   const uint gc_id() const { return _gc_id; }
 75 };
 76 
 77 struct WorkData {
 78   AbstractGangTask* _task;
 79   uint              _worker_id;
 80   WorkData(AbstractGangTask* task, uint worker_id) : _task(task), _worker_id(worker_id) {}
 81 };
 82 
 83 // Interface to handle the synchronization between the coordinator thread and the worker threads,
 84 // when a task is dispatched out to the worker threads.
 85 class GangTaskDispatcher : public CHeapObj&lt;mtGC&gt; {
 86  public:
 87   virtual ~GangTaskDispatcher() {}
 88 
 89   // Coordinator API.
 90 
 91   // Distributes the task out to num_workers workers.
 92   // Returns when the task has been completed by all workers.
 93   virtual void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) = 0;
 94 
 95   // Worker API.
 96 
 97   // Waits for a task to become available to the worker.
 98   // Returns when the worker has been assigned a task.
 99   virtual WorkData worker_wait_for_task() = 0;
100 
101   // Signal to the coordinator that the worker is done with the assigned task.
102   virtual void     worker_done_with_task() = 0;
103 };
104 
105 // The work gang is the collection of workers to execute tasks.
106 // The number of workers run for a task is &quot;_active_workers&quot;
107 // while &quot;_total_workers&quot; is the number of available of workers.
108 class AbstractWorkGang : public CHeapObj&lt;mtInternal&gt; {
109  protected:
110   // The array of worker threads for this gang.
111   AbstractGangWorker** _workers;
112   // The count of the number of workers in the gang.
113   uint _total_workers;
114   // The currently active workers in this gang.
115   uint _active_workers;
116   // The count of created workers in the gang.
117   uint _created_workers;
118   // Printing support.
119   const char* _name;
120 
121   ~AbstractWorkGang() {}
122 
123  private:
124   // Initialize only instance data.
125   const bool _are_GC_task_threads;
126   const bool _are_ConcurrentGC_threads;
127 
128   void set_thread(uint worker_id, AbstractGangWorker* worker) {
129     _workers[worker_id] = worker;
130   }
131 
132  public:
133   AbstractWorkGang(const char* name, uint workers, bool are_GC_task_threads, bool are_ConcurrentGC_threads) :
134       _workers(NULL),
135       _total_workers(workers),
136       _active_workers(UseDynamicNumberOfGCThreads ? 1U : workers),
137       _created_workers(0),
138       _name(name),
139       _are_GC_task_threads(are_GC_task_threads),
140       _are_ConcurrentGC_threads(are_ConcurrentGC_threads)
141   { }
142 
143   // Initialize workers in the gang.  Return true if initialization succeeded.
144   void initialize_workers();
145 
146   bool are_GC_task_threads()      const { return _are_GC_task_threads; }
147   bool are_ConcurrentGC_threads() const { return _are_ConcurrentGC_threads; }
148 
149   uint total_workers() const { return _total_workers; }
150 
151   uint created_workers() const {
152     return _created_workers;
153   }
154 
155   virtual uint active_workers() const {
156     assert(_active_workers &lt;= _total_workers,
157            &quot;_active_workers: %u &gt; _total_workers: %u&quot;, _active_workers, _total_workers);
158     return _active_workers;
159   }
160 
161   uint update_active_workers(uint v) {
162     assert(v &lt;= _total_workers,
163            &quot;Trying to set more workers active than there are&quot;);
164     _active_workers = MIN2(v, _total_workers);
165     add_workers(false /* exit_on_failure */);
166     assert(v != 0, &quot;Trying to set active workers to 0&quot;);
167     log_trace(gc, task)(&quot;%s: using %d out of %d workers&quot;, name(), _active_workers, _total_workers);
168     return _active_workers;
169   }
170 
171   // Add GC workers as needed.
172   void add_workers(bool initializing);
173 
174   // Add GC workers as needed to reach the specified number of workers.
175   void add_workers(uint active_workers, bool initializing);
176 
177   // Return the Ith worker.
178   AbstractGangWorker* worker(uint i) const;
179 
180   // Base name (without worker id #) of threads.
181   const char* group_name() { return name(); }
182 
183   void threads_do(ThreadClosure* tc) const;
184 
185   // Create a GC worker and install it into the work gang.
186   virtual AbstractGangWorker* install_worker(uint which);
187 
188   // Debugging.
189   const char* name() const { return _name; }
190 
191   // Printing
192   void print_worker_threads_on(outputStream *st) const;
193   void print_worker_threads() const {
194     print_worker_threads_on(tty);
195   }
196 
197  protected:
198   virtual AbstractGangWorker* allocate_worker(uint which) = 0;
199 };
200 
201 // An class representing a gang of workers.
202 class WorkGang: public AbstractWorkGang {
203   // To get access to the GangTaskDispatcher instance.
204   friend class GangWorker;
205 
206   GangTaskDispatcher* const _dispatcher;
207   GangTaskDispatcher* dispatcher() const {
208     return _dispatcher;
209   }
210 
211 public:
212   WorkGang(const char* name,
213            uint workers,
214            bool are_GC_task_threads,
215            bool are_ConcurrentGC_threads);
216 
217   ~WorkGang();
218 
219   // Run a task using the current active number of workers, returns when the task is done.
220   virtual void run_task(AbstractGangTask* task);
221   // Run a task with the given number of workers, returns
222   // when the task is done. The number of workers must be at most the number of
223   // active workers.  Additional workers may be created if an insufficient
224   // number currently exists.
225   void run_task(AbstractGangTask* task, uint num_workers);
226 
227 protected:
228   virtual AbstractGangWorker* allocate_worker(uint which);
229 };
230 
231 // Several instances of this class run in parallel as workers for a gang.
232 class AbstractGangWorker: public WorkerThread {
233 public:
234   AbstractGangWorker(AbstractWorkGang* gang, uint id);
235 
236   // The only real method: run a task for the gang.
237   virtual void run();
238   // Predicate for Thread
239   virtual bool is_GC_task_thread() const;
240   virtual bool is_ConcurrentGC_thread() const;
241   // Printing
242   void print_on(outputStream* st) const;
<a name="2" id="anc2"></a><span class="line-modified">243   virtual void print() const;</span>
244 
245 protected:
246   AbstractWorkGang* _gang;
247 
248   virtual void initialize();
249   virtual void loop() = 0;
250 
251   AbstractWorkGang* gang() const { return _gang; }
252 };
253 
254 class GangWorker: public AbstractGangWorker {
255 public:
256   GangWorker(WorkGang* gang, uint id) : AbstractGangWorker(gang, id) {}
257 
258 protected:
259   virtual void loop();
260 
261 private:
262   WorkData wait_for_task();
263   void run_task(WorkData work);
264   void signal_task_done();
265 
266   WorkGang* gang() const { return (WorkGang*)_gang; }
267 };
268 
269 // A class that acts as a synchronisation barrier. Workers enter
270 // the barrier and must wait until all other workers have entered
271 // before any of them may leave.
272 
273 class WorkGangBarrierSync : public StackObj {
274 protected:
275   Monitor _monitor;
276   uint    _n_workers;
277   uint    _n_completed;
278   bool    _should_reset;
279   bool    _aborted;
280 
281   Monitor* monitor()        { return &amp;_monitor; }
282   uint     n_workers()      { return _n_workers; }
283   uint     n_completed()    { return _n_completed; }
284   bool     should_reset()   { return _should_reset; }
285   bool     aborted()        { return _aborted; }
286 
287   void     zero_completed() { _n_completed = 0; }
288   void     inc_completed()  { _n_completed++; }
289   void     set_aborted()    { _aborted = true; }
290   void     set_should_reset(bool v) { _should_reset = v; }
291 
292 public:
293   WorkGangBarrierSync();
294   WorkGangBarrierSync(uint n_workers, const char* name);
295 
296   // Set the number of workers that will use the barrier.
297   // Must be called before any of the workers start running.
298   void set_n_workers(uint n_workers);
299 
300   // Enter the barrier. A worker that enters the barrier will
301   // not be allowed to leave until all other threads have
302   // also entered the barrier or the barrier is aborted.
303   // Returns false if the barrier was aborted.
304   bool enter();
305 
306   // Aborts the barrier and wakes up any threads waiting for
307   // the barrier to complete. The barrier will remain in the
308   // aborted state until the next call to set_n_workers().
309   void abort();
310 };
311 
312 // A class to manage claiming of subtasks within a group of tasks.  The
313 // subtasks will be identified by integer indices, usually elements of an
314 // enumeration type.
315 
316 class SubTasksDone: public CHeapObj&lt;mtInternal&gt; {
317   volatile uint* _tasks;
318   uint _n_tasks;
319   volatile uint _threads_completed;
320 #ifdef ASSERT
321   volatile uint _claimed;
322 #endif
323 
324   // Set all tasks to unclaimed.
325   void clear();
326 
327 public:
328   // Initializes &quot;this&quot; to a state in which there are &quot;n&quot; tasks to be
329   // processed, none of the which are originally claimed.  The number of
330   // threads doing the tasks is initialized 1.
331   SubTasksDone(uint n);
332 
333   // True iff the object is in a valid state.
334   bool valid();
335 
336   // Attempt to claim the task &quot;t&quot;, returning true if successful,
337   // false if it has already been claimed.  The task &quot;t&quot; is required
338   // to be within the range of &quot;this&quot;.
339   bool try_claim_task(uint t);
340 
341   // The calling thread asserts that it has attempted to claim all the
342   // tasks that it will try to claim.  Every thread in the parallel task
343   // must execute this.  (When the last thread does so, the task array is
344   // cleared.)
345   //
346   // n_threads - Number of threads executing the sub-tasks.
347   void all_tasks_completed(uint n_threads);
348 
349   // Destructor.
350   ~SubTasksDone();
351 };
352 
353 // As above, but for sequential tasks, i.e. instead of claiming
354 // sub-tasks from a set (possibly an enumeration), claim sub-tasks
355 // in sequential order. This is ideal for claiming dynamically
356 // partitioned tasks (like striding in the parallel remembered
357 // set scanning). Note that unlike the above class this is
358 // a stack object - is there any reason for it not to be?
359 
360 class SequentialSubTasksDone : public StackObj {
361 protected:
362   uint _n_tasks;     // Total number of tasks available.
363   volatile uint _n_claimed;   // Number of tasks claimed.
364   // _n_threads is used to determine when a sub task is done.
365   // See comments on SubTasksDone::_n_threads
366   uint _n_threads;   // Total number of parallel threads.
367   volatile uint _n_completed; // Number of completed threads.
368 
369   void clear();
370 
371 public:
372   SequentialSubTasksDone() {
373     clear();
374   }
375   ~SequentialSubTasksDone() {}
376 
377   // True iff the object is in a valid state.
378   bool valid();
379 
380   // number of tasks
381   uint n_tasks() const { return _n_tasks; }
382 
383   // Get/set the number of parallel threads doing the tasks to t.
384   // Should be called before the task starts but it is safe
385   // to call this once a task is running provided that all
386   // threads agree on the number of threads.
387   uint n_threads() { return _n_threads; }
388   void set_n_threads(uint t) { _n_threads = t; }
389 
390   // Set the number of tasks to be claimed to t. As above,
391   // should be called before the tasks start but it is safe
392   // to call this once a task is running provided all threads
393   // agree on the number of tasks.
394   void set_n_tasks(uint t) { _n_tasks = t; }
395 
396   // Attempt to claim the next unclaimed task in the sequence,
397   // returning true if successful, with t set to the index of the
398   // claimed task.  Returns false if there are no more unclaimed tasks
399   // in the sequence.
400   bool try_claim_task(uint&amp; t);
401 
402   // The calling thread asserts that it has attempted to claim
403   // all the tasks it possibly can in the sequence. Every thread
404   // claiming tasks must promise call this. Returns true if this
405   // is the last thread to complete so that the thread can perform
406   // cleanup if necessary.
407   bool all_tasks_completed();
408 };
409 
410 #endif // SHARE_GC_SHARED_WORKGROUP_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/gcTrace.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/copyFailedInfo.hpp&quot;
 27 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 28 #include &quot;gc/shared/gcId.hpp&quot;
 29 #include &quot;gc/shared/gcTimer.hpp&quot;
 30 #include &quot;gc/shared/gcTrace.hpp&quot;
 31 #include &quot;gc/shared/objectCountEventSender.hpp&quot;
 32 #include &quot;gc/shared/referenceProcessorStats.hpp&quot;
 33 #include &quot;memory/heapInspection.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;runtime/os.hpp&quot;
 36 #include &quot;utilities/globalDefinitions.hpp&quot;
 37 #include &quot;utilities/macros.hpp&quot;
 38 #include &quot;utilities/ticks.hpp&quot;
 39 
 40 void GCTracer::report_gc_start_impl(GCCause::Cause cause, const Ticks&amp; timestamp) {
 41   _shared_gc_info.set_cause(cause);
 42   _shared_gc_info.set_start_timestamp(timestamp);
 43 }
 44 
 45 void GCTracer::report_gc_start(GCCause::Cause cause, const Ticks&amp; timestamp) {
 46   report_gc_start_impl(cause, timestamp);
 47 }
 48 
 49 void GCTracer::report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions) {
 50   _shared_gc_info.set_sum_of_pauses(time_partitions-&gt;sum_of_pauses());
 51   _shared_gc_info.set_longest_pause(time_partitions-&gt;longest_pause());
 52   _shared_gc_info.set_end_timestamp(timestamp);
 53 
 54   send_phase_events(time_partitions);
 55   send_garbage_collection_event();
 56 }
 57 
 58 void GCTracer::report_gc_end(const Ticks&amp; timestamp, TimePartitions* time_partitions) {
 59   report_gc_end_impl(timestamp, time_partitions);
 60 }
 61 
 62 void GCTracer::report_gc_reference_stats(const ReferenceProcessorStats&amp; rps) const {
 63   send_reference_stats_event(REF_SOFT, rps.soft_count());
 64   send_reference_stats_event(REF_WEAK, rps.weak_count());
 65   send_reference_stats_event(REF_FINAL, rps.final_count());
 66   send_reference_stats_event(REF_PHANTOM, rps.phantom_count());
 67 }
 68 
 69 #if INCLUDE_SERVICES
 70 class ObjectCountEventSenderClosure : public KlassInfoClosure {
 71   const double _size_threshold_percentage;
 72   const size_t _total_size_in_words;
 73   const Ticks _timestamp;
 74 
 75  public:
 76   ObjectCountEventSenderClosure(size_t total_size_in_words, const Ticks&amp; timestamp) :
 77     _size_threshold_percentage(ObjectCountCutOffPercent / 100),
 78     _total_size_in_words(total_size_in_words),
 79     _timestamp(timestamp)
 80   {}
 81 
 82   virtual void do_cinfo(KlassInfoEntry* entry) {
 83     if (should_send_event(entry)) {
 84       ObjectCountEventSender::send(entry, _timestamp);
 85     }
 86   }
 87 
 88  private:
 89   bool should_send_event(const KlassInfoEntry* entry) const {
 90     double percentage_of_heap = ((double) entry-&gt;words()) / _total_size_in_words;
 91     return percentage_of_heap &gt;= _size_threshold_percentage;
 92   }
 93 };
 94 
 95 void GCTracer::report_object_count_after_gc(BoolObjectClosure* is_alive_cl) {
 96   assert(is_alive_cl != NULL, &quot;Must supply function to check liveness&quot;);
 97 
 98   if (ObjectCountEventSender::should_send_event()) {
 99     ResourceMark rm;
100 
101     KlassInfoTable cit(false);
102     if (!cit.allocation_failed()) {
103       HeapInspection hi;
104       hi.populate_table(&amp;cit, is_alive_cl);
105       ObjectCountEventSenderClosure event_sender(cit.size_of_instances_in_words(), Ticks::now());
106       cit.iterate(&amp;event_sender);
107     }
108   }
109 }
110 #endif // INCLUDE_SERVICES
111 
112 void GCTracer::report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary&amp; heap_summary) const {
113   send_gc_heap_summary_event(when, heap_summary);
114 }
115 
116 void GCTracer::report_metaspace_summary(GCWhen::Type when, const MetaspaceSummary&amp; summary) const {
117   send_meta_space_summary_event(when, summary);
118 
119   send_metaspace_chunk_free_list_summary(when, Metaspace::NonClassType, summary.metaspace_chunk_free_list_summary());
120   if (UseCompressedClassPointers) {
121     send_metaspace_chunk_free_list_summary(when, Metaspace::ClassType, summary.class_chunk_free_list_summary());
122   }
123 }
124 
125 void YoungGCTracer::report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions) {
126   assert(_tenuring_threshold != UNSET_TENURING_THRESHOLD, &quot;Tenuring threshold has not been reported&quot;);
127 
128   GCTracer::report_gc_end_impl(timestamp, time_partitions);
129   send_young_gc_event();
130 
131   _tenuring_threshold = UNSET_TENURING_THRESHOLD;
132 }
133 
134 void YoungGCTracer::report_promotion_failed(const PromotionFailedInfo&amp; pf_info) const {
135   send_promotion_failed_event(pf_info);
136 }
137 
138 void YoungGCTracer::report_tenuring_threshold(const uint tenuring_threshold) {
139   _tenuring_threshold = tenuring_threshold;
140 }
141 
142 bool YoungGCTracer::should_report_promotion_events() const {
143   return should_report_promotion_in_new_plab_event() ||
144           should_report_promotion_outside_plab_event();
145 }
146 
147 bool YoungGCTracer::should_report_promotion_in_new_plab_event() const {
148   return should_send_promotion_in_new_plab_event();
149 }
150 
151 bool YoungGCTracer::should_report_promotion_outside_plab_event() const {
152   return should_send_promotion_outside_plab_event();
153 }
154 
155 void YoungGCTracer::report_promotion_in_new_plab_event(Klass* klass, size_t obj_size,
156                                                        uint age, bool tenured,
157                                                        size_t plab_size) const {
158   send_promotion_in_new_plab_event(klass, obj_size, age, tenured, plab_size);
159 }
160 
161 void YoungGCTracer::report_promotion_outside_plab_event(Klass* klass, size_t obj_size,
162                                                         uint age, bool tenured) const {
163   send_promotion_outside_plab_event(klass, obj_size, age, tenured);
164 }
165 
166 void OldGCTracer::report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions) {
167   GCTracer::report_gc_end_impl(timestamp, time_partitions);
168   send_old_gc_event();
169 }
170 
171 void ParallelOldTracer::report_gc_end_impl(const Ticks&amp; timestamp, TimePartitions* time_partitions) {
172   OldGCTracer::report_gc_end_impl(timestamp, time_partitions);
173   send_parallel_old_event();
174 }
175 
176 void ParallelOldTracer::report_dense_prefix(void* dense_prefix) {
177   _parallel_old_gc_info.report_dense_prefix(dense_prefix);
178 }
179 
180 void OldGCTracer::report_concurrent_mode_failure() {
181   send_concurrent_mode_failure_event();
182 }
    </pre>
  </body>
</html>
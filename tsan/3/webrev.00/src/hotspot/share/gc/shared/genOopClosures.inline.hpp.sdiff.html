<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/genOopClosures.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="genOopClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generation.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genOopClosures.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 inline OopsInGenClosure::OopsInGenClosure(Generation* gen) :
 41   OopIterateClosure(gen-&gt;ref_processor()), _orig_gen(gen), _rs(NULL) {
 42   set_generation(gen);
 43 }
 44 
 45 inline void OopsInGenClosure::set_generation(Generation* gen) {
 46   _gen = gen;
 47   _gen_boundary = _gen-&gt;reserved().start();
 48   // Barrier set for the heap, must be set after heap is initialized
 49   if (_rs == NULL) {
 50     _rs = GenCollectedHeap::heap()-&gt;rem_set();
 51   }
 52 }
 53 
 54 template &lt;class T&gt; inline void OopsInGenClosure::do_barrier(T* p) {
 55   assert(generation()-&gt;is_in_reserved(p), &quot;expected ref in generation&quot;);
 56   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 57   assert(!CompressedOops::is_null(heap_oop), &quot;expected non-null oop&quot;);
 58   oop obj = CompressedOops::decode_not_null(heap_oop);
 59   // If p points to a younger generation, mark the card.
<span class="line-modified"> 60   if ((HeapWord*)obj &lt; _gen_boundary) {</span>
 61     _rs-&gt;inline_write_ref_field_gc(p, obj);
 62   }
 63 }
 64 
<span class="line-removed"> 65 template &lt;class T&gt; inline void OopsInGenClosure::par_do_barrier(T* p) {</span>
<span class="line-removed"> 66   assert(generation()-&gt;is_in_reserved(p), &quot;expected ref in generation&quot;);</span>
<span class="line-removed"> 67   T heap_oop = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-removed"> 68   assert(!CompressedOops::is_null(heap_oop), &quot;expected non-null oop&quot;);</span>
<span class="line-removed"> 69   oop obj = CompressedOops::decode_not_null(heap_oop);</span>
<span class="line-removed"> 70   // If p points to a younger generation, mark the card.</span>
<span class="line-removed"> 71   if ((HeapWord*)obj &lt; gen_boundary()) {</span>
<span class="line-removed"> 72     rs()-&gt;write_ref_field_gc_par(p, obj);</span>
<span class="line-removed"> 73   }</span>
<span class="line-removed"> 74 }</span>
<span class="line-removed"> 75 </span>
 76 inline BasicOopsInGenClosure::BasicOopsInGenClosure(Generation* gen) : OopsInGenClosure(gen) {
 77 }
 78 
 79 inline void OopsInClassLoaderDataOrGenClosure::do_cld_barrier() {
 80   assert(_scanned_cld != NULL, &quot;Must be&quot;);
 81   if (!_scanned_cld-&gt;has_modified_oops()) {
 82     _scanned_cld-&gt;record_modified_oops();
 83   }
 84 }
 85 
 86 #if INCLUDE_SERIALGC
 87 
 88 // NOTE! Any changes made here should also be made
 89 // in FastScanClosure::do_oop_work()
 90 template &lt;class T&gt; inline void ScanClosure::do_oop_work(T* p) {
 91   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 92   // Should we copy the obj?
 93   if (!CompressedOops::is_null(heap_oop)) {
 94     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified"> 95     if ((HeapWord*)obj &lt; _boundary) {</span>
 96       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
 97       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
 98                                         : _g-&gt;copy_to_survivor_space(obj);
 99       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
100     }
101 
102     if (is_scanning_a_cld()) {
103       do_cld_barrier();
104     } else if (_gc_barrier) {
105       // Now call parent closure
106       do_barrier(p);
107     }
108   }
109 }
110 
111 inline void ScanClosure::do_oop(oop* p)       { ScanClosure::do_oop_work(p); }
112 inline void ScanClosure::do_oop(narrowOop* p) { ScanClosure::do_oop_work(p); }
113 
114 // NOTE! Any changes made here should also be made
115 // in ScanClosure::do_oop_work()
116 template &lt;class T&gt; inline void FastScanClosure::do_oop_work(T* p) {
117   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
118   // Should we copy the obj?
119   if (!CompressedOops::is_null(heap_oop)) {
120     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">121     if ((HeapWord*)obj &lt; _boundary) {</span>
122       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
123       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
124                                         : _g-&gt;copy_to_survivor_space(obj);
125       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
126       if (is_scanning_a_cld()) {
127         do_cld_barrier();
128       } else if (_gc_barrier) {
129         // Now call parent closure
130         do_barrier(p);
131       }
132     }
133   }
134 }
135 
136 inline void FastScanClosure::do_oop(oop* p)       { FastScanClosure::do_oop_work(p); }
137 inline void FastScanClosure::do_oop(narrowOop* p) { FastScanClosure::do_oop_work(p); }
138 
139 #endif // INCLUDE_SERIALGC
140 
141 template &lt;class T&gt; void FilteringClosure::do_oop_work(T* p) {
142   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
143   if (!CompressedOops::is_null(heap_oop)) {
144     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">145     if ((HeapWord*)obj &lt; _boundary) {</span>
146       _cl-&gt;do_oop(p);
147     }
148   }
149 }
150 
151 inline void FilteringClosure::do_oop(oop* p)       { FilteringClosure::do_oop_work(p); }
152 inline void FilteringClosure::do_oop(narrowOop* p) { FilteringClosure::do_oop_work(p); }
153 
154 #if INCLUDE_SERIALGC
155 
156 // Note similarity to ScanClosure; the difference is that
157 // the barrier set is taken care of outside this closure.
158 template &lt;class T&gt; inline void ScanWeakRefClosure::do_oop_work(T* p) {
159   oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
160   // weak references are sometimes scanned twice; must check
161   // that to-space doesn&#39;t already contain this object
<span class="line-modified">162   if ((HeapWord*)obj &lt; _boundary &amp;&amp; !_g-&gt;to()-&gt;is_in_reserved(obj)) {</span>
163     oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
164                                       : _g-&gt;copy_to_survivor_space(obj);
165     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
166   }
167 }
168 
169 inline void ScanWeakRefClosure::do_oop(oop* p)       { ScanWeakRefClosure::do_oop_work(p); }
170 inline void ScanWeakRefClosure::do_oop(narrowOop* p) { ScanWeakRefClosure::do_oop_work(p); }
171 
172 #endif // INCLUDE_SERIALGC
173 
174 #endif // SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP
</pre>
</td>
<td>
<hr />
<pre>
 40 inline OopsInGenClosure::OopsInGenClosure(Generation* gen) :
 41   OopIterateClosure(gen-&gt;ref_processor()), _orig_gen(gen), _rs(NULL) {
 42   set_generation(gen);
 43 }
 44 
 45 inline void OopsInGenClosure::set_generation(Generation* gen) {
 46   _gen = gen;
 47   _gen_boundary = _gen-&gt;reserved().start();
 48   // Barrier set for the heap, must be set after heap is initialized
 49   if (_rs == NULL) {
 50     _rs = GenCollectedHeap::heap()-&gt;rem_set();
 51   }
 52 }
 53 
 54 template &lt;class T&gt; inline void OopsInGenClosure::do_barrier(T* p) {
 55   assert(generation()-&gt;is_in_reserved(p), &quot;expected ref in generation&quot;);
 56   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 57   assert(!CompressedOops::is_null(heap_oop), &quot;expected non-null oop&quot;);
 58   oop obj = CompressedOops::decode_not_null(heap_oop);
 59   // If p points to a younger generation, mark the card.
<span class="line-modified"> 60   if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; _gen_boundary) {</span>
 61     _rs-&gt;inline_write_ref_field_gc(p, obj);
 62   }
 63 }
 64 











 65 inline BasicOopsInGenClosure::BasicOopsInGenClosure(Generation* gen) : OopsInGenClosure(gen) {
 66 }
 67 
 68 inline void OopsInClassLoaderDataOrGenClosure::do_cld_barrier() {
 69   assert(_scanned_cld != NULL, &quot;Must be&quot;);
 70   if (!_scanned_cld-&gt;has_modified_oops()) {
 71     _scanned_cld-&gt;record_modified_oops();
 72   }
 73 }
 74 
 75 #if INCLUDE_SERIALGC
 76 
 77 // NOTE! Any changes made here should also be made
 78 // in FastScanClosure::do_oop_work()
 79 template &lt;class T&gt; inline void ScanClosure::do_oop_work(T* p) {
 80   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
 81   // Should we copy the obj?
 82   if (!CompressedOops::is_null(heap_oop)) {
 83     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified"> 84     if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; _boundary) {</span>
 85       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
 86       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
 87                                         : _g-&gt;copy_to_survivor_space(obj);
 88       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
 89     }
 90 
 91     if (is_scanning_a_cld()) {
 92       do_cld_barrier();
 93     } else if (_gc_barrier) {
 94       // Now call parent closure
 95       do_barrier(p);
 96     }
 97   }
 98 }
 99 
100 inline void ScanClosure::do_oop(oop* p)       { ScanClosure::do_oop_work(p); }
101 inline void ScanClosure::do_oop(narrowOop* p) { ScanClosure::do_oop_work(p); }
102 
103 // NOTE! Any changes made here should also be made
104 // in ScanClosure::do_oop_work()
105 template &lt;class T&gt; inline void FastScanClosure::do_oop_work(T* p) {
106   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
107   // Should we copy the obj?
108   if (!CompressedOops::is_null(heap_oop)) {
109     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">110     if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; _boundary) {</span>
111       assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);
112       oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
113                                         : _g-&gt;copy_to_survivor_space(obj);
114       RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
115       if (is_scanning_a_cld()) {
116         do_cld_barrier();
117       } else if (_gc_barrier) {
118         // Now call parent closure
119         do_barrier(p);
120       }
121     }
122   }
123 }
124 
125 inline void FastScanClosure::do_oop(oop* p)       { FastScanClosure::do_oop_work(p); }
126 inline void FastScanClosure::do_oop(narrowOop* p) { FastScanClosure::do_oop_work(p); }
127 
128 #endif // INCLUDE_SERIALGC
129 
130 template &lt;class T&gt; void FilteringClosure::do_oop_work(T* p) {
131   T heap_oop = RawAccess&lt;&gt;::oop_load(p);
132   if (!CompressedOops::is_null(heap_oop)) {
133     oop obj = CompressedOops::decode_not_null(heap_oop);
<span class="line-modified">134     if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; _boundary) {</span>
135       _cl-&gt;do_oop(p);
136     }
137   }
138 }
139 
140 inline void FilteringClosure::do_oop(oop* p)       { FilteringClosure::do_oop_work(p); }
141 inline void FilteringClosure::do_oop(narrowOop* p) { FilteringClosure::do_oop_work(p); }
142 
143 #if INCLUDE_SERIALGC
144 
145 // Note similarity to ScanClosure; the difference is that
146 // the barrier set is taken care of outside this closure.
147 template &lt;class T&gt; inline void ScanWeakRefClosure::do_oop_work(T* p) {
148   oop obj = RawAccess&lt;IS_NOT_NULL&gt;::oop_load(p);
149   // weak references are sometimes scanned twice; must check
150   // that to-space doesn&#39;t already contain this object
<span class="line-modified">151   if (cast_from_oop&lt;HeapWord*&gt;(obj) &lt; _boundary &amp;&amp; !_g-&gt;to()-&gt;is_in_reserved(obj)) {</span>
152     oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()
153                                       : _g-&gt;copy_to_survivor_space(obj);
154     RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, new_obj);
155   }
156 }
157 
158 inline void ScanWeakRefClosure::do_oop(oop* p)       { ScanWeakRefClosure::do_oop_work(p); }
159 inline void ScanWeakRefClosure::do_oop(narrowOop* p) { ScanWeakRefClosure::do_oop_work(p); }
160 
161 #endif // INCLUDE_SERIALGC
162 
163 #endif // SHARE_GC_SHARED_GENOOPCLOSURES_INLINE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="genOopClosures.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generation.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
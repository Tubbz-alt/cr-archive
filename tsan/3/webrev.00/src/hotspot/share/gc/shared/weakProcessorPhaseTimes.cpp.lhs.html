<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/weakProcessorPhaseTimes.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
<a name="1" id="anc1"></a>
 26 #include &quot;gc/shared/weakProcessorPhases.hpp&quot;
 27 #include &quot;gc/shared/weakProcessorPhaseTimes.hpp&quot;
 28 #include &quot;gc/shared/workerDataArray.inline.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;logging/logStream.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
 32 #include &quot;utilities/globalDefinitions.hpp&quot;
 33 #include &quot;utilities/ticks.hpp&quot;
 34 
<a name="2" id="anc2"></a><span class="line-modified"> 35 static uint phase_index(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 36   return WeakProcessorPhases::index(phase);</span>
 37 }
 38 
 39 static bool is_serial_phase(WeakProcessorPhase phase) {
 40   return WeakProcessorPhases::is_serial(phase);
 41 }
 42 
<a name="3" id="anc3"></a><span class="line-modified"> 43 static void assert_oop_storage_phase(WeakProcessorPhase phase) {</span>
<span class="line-modified"> 44   assert(WeakProcessorPhases::is_oop_storage(phase),</span>
<span class="line-modified"> 45          &quot;Not an oop_storage phase %u&quot;, phase_index(phase));</span>





 46 }
 47 
 48 const double uninitialized_time = -1.0;
 49 
 50 #ifdef ASSERT
 51 static bool is_initialized_time(double t) { return t &gt;= 0.0; }
 52 static bool is_initialized_items(size_t i) { return i != 0; }
 53 #endif // ASSERT
 54 
 55 static void reset_times(double* times, size_t ntimes) {
 56   for (size_t i = 0; i &lt; ntimes; ++i) {
 57     times[i] = uninitialized_time;
 58   }
 59 }
 60 
 61 static void reset_items(size_t* items, size_t nitems) {
 62   for (size_t i = 0; i &lt; nitems; ++i) {
 63     items[i] = 0;
 64   }
 65 }
 66 
<a name="4" id="anc4"></a>





 67 WeakProcessorPhaseTimes::WeakProcessorPhaseTimes(uint max_threads) :
 68   _max_threads(max_threads),
 69   _active_workers(0),
 70   _total_time_sec(uninitialized_time),
<a name="5" id="anc5"></a><span class="line-modified"> 71   _worker_data(),</span>
<span class="line-removed"> 72   _worker_dead_items(),</span>
<span class="line-removed"> 73   _worker_total_items()</span>
 74 {
 75   assert(_max_threads &gt; 0, &quot;max_threads must not be zero&quot;);
 76 
<a name="6" id="anc6"></a><span class="line-modified"> 77   reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));</span>
<span class="line-modified"> 78   reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));</span>
<span class="line-modified"> 79   reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));</span>
<span class="line-modified"> 80 </span>
<span class="line-modified"> 81   if (_max_threads &gt; 1) {</span>
<span class="line-modified"> 82     WorkerDataArray&lt;double&gt;** wpt = _worker_data;</span>
<span class="line-modified"> 83     FOR_EACH_WEAK_PROCESSOR_OOP_STORAGE_PHASE(phase) {</span>
<span class="line-modified"> 84       const char* description = WeakProcessorPhases::description(phase);</span>
<span class="line-modified"> 85       *wpt = new WorkerDataArray&lt;double&gt;(_max_threads, description);</span>
<span class="line-modified"> 86       (*wpt)-&gt;link_thread_work_items(new WorkerDataArray&lt;size_t&gt;(_max_threads, &quot;Dead&quot;), DeadItems);</span>
<span class="line-modified"> 87       (*wpt)-&gt;link_thread_work_items(new WorkerDataArray&lt;size_t&gt;(_max_threads, &quot;Total&quot;), TotalItems);</span>
<span class="line-removed"> 88       wpt++;</span>
<span class="line-removed"> 89     }</span>
 90   }
<a name="7" id="anc7"></a>
 91 }
 92 
 93 WeakProcessorPhaseTimes::~WeakProcessorPhaseTimes() {
 94   for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {
 95     delete _worker_data[i];
<a name="8" id="anc8"></a><span class="line-removed"> 96     delete _worker_dead_items[i];</span>
<span class="line-removed"> 97     delete _worker_total_items[i];</span>
 98   }
 99 }
100 
101 uint WeakProcessorPhaseTimes::max_threads() const { return _max_threads; }
102 
103 uint WeakProcessorPhaseTimes::active_workers() const {
104   assert(_active_workers != 0, &quot;active workers not set&quot;);
105   return _active_workers;
106 }
107 
108 void WeakProcessorPhaseTimes::set_active_workers(uint n) {
109   assert(_active_workers == 0, &quot;active workers already set&quot;);
110   assert(n &gt; 0, &quot;active workers must be non-zero&quot;);
111   assert(n &lt;= _max_threads, &quot;active workers must not exceed max threads&quot;);
112   _active_workers = n;
113 }
114 
115 void WeakProcessorPhaseTimes::reset() {
116   _active_workers = 0;
117   _total_time_sec = uninitialized_time;
<a name="9" id="anc9"></a><span class="line-modified">118   reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));</span>
<span class="line-modified">119   reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));</span>
<span class="line-modified">120   reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));</span>
<span class="line-removed">121   if (_max_threads &gt; 1) {</span>
<span class="line-removed">122     for (size_t i = 0; i &lt; ARRAY_SIZE(_worker_data); ++i) {</span>
<span class="line-removed">123       _worker_data[i]-&gt;reset();</span>
<span class="line-removed">124     }</span>
125   }
126 }
127 
128 double WeakProcessorPhaseTimes::total_time_sec() const {
129   assert(is_initialized_time(_total_time_sec), &quot;Total time not set&quot;);
130   return _total_time_sec;
131 }
132 
133 void WeakProcessorPhaseTimes::record_total_time_sec(double time_sec) {
134   assert(!is_initialized_time(_total_time_sec), &quot;Already set total time&quot;);
135   _total_time_sec = time_sec;
136 }
137 
138 double WeakProcessorPhaseTimes::phase_time_sec(WeakProcessorPhase phase) const {
<a name="10" id="anc10"></a><span class="line-modified">139   assert(is_initialized_time(_phase_times_sec[phase_index(phase)]),</span>
<span class="line-modified">140          &quot;phase time not set %u&quot;, phase_index(phase));</span>
<span class="line-modified">141   return _phase_times_sec[phase_index(phase)];</span>

142 }
143 
144 void WeakProcessorPhaseTimes::record_phase_time_sec(WeakProcessorPhase phase, double time_sec) {
<a name="11" id="anc11"></a><span class="line-modified">145   assert(!is_initialized_time(_phase_times_sec[phase_index(phase)]),</span>
<span class="line-modified">146          &quot;Already set time for phase %u&quot;, phase_index(phase));</span>
<span class="line-modified">147   _phase_times_sec[phase_index(phase)] = time_sec;</span>

148 }
149 
150 void WeakProcessorPhaseTimes::record_phase_items(WeakProcessorPhase phase, size_t num_dead, size_t num_total) {
<a name="12" id="anc12"></a><span class="line-modified">151   uint p = phase_index(phase);</span>

152   assert(!is_initialized_items(_phase_dead_items[p]),
153          &quot;Already set dead items for phase %u&quot;, p);
154   assert(!is_initialized_items(_phase_total_items[p]),
155          &quot;Already set total items for phase %u&quot;, p);
156   _phase_dead_items[p] = num_dead;
157   _phase_total_items[p] = num_total;
158 }
159 
160 WorkerDataArray&lt;double&gt;* WeakProcessorPhaseTimes::worker_data(WeakProcessorPhase phase) const {
<a name="13" id="anc13"></a><span class="line-modified">161   assert_oop_storage_phase(phase);</span>
<span class="line-modified">162   assert(active_workers() &gt; 1, &quot;No worker data when single-threaded&quot;);</span>
<span class="line-removed">163   return _worker_data[WeakProcessorPhases::oop_storage_index(phase)];</span>
164 }
165 
166 double WeakProcessorPhaseTimes::worker_time_sec(uint worker_id, WeakProcessorPhase phase) const {
167   assert(worker_id &lt; active_workers(),
168          &quot;invalid worker id %u for %u&quot;, worker_id, active_workers());
<a name="14" id="anc14"></a><span class="line-modified">169   if (active_workers() == 1) {</span>
<span class="line-removed">170     return phase_time_sec(phase);</span>
<span class="line-removed">171   } else {</span>
<span class="line-removed">172     return worker_data(phase)-&gt;get(worker_id);</span>
<span class="line-removed">173   }</span>
174 }
175 
176 void WeakProcessorPhaseTimes::record_worker_time_sec(uint worker_id,
177                                                      WeakProcessorPhase phase,
178                                                      double time_sec) {
<a name="15" id="anc15"></a><span class="line-modified">179   if (active_workers() == 1) {</span>
<span class="line-removed">180     record_phase_time_sec(phase, time_sec);</span>
<span class="line-removed">181   } else {</span>
<span class="line-removed">182     worker_data(phase)-&gt;set(worker_id, time_sec);</span>
<span class="line-removed">183   }</span>
184 }
185 
186 void WeakProcessorPhaseTimes::record_worker_items(uint worker_id,
187                                                   WeakProcessorPhase phase,
188                                                   size_t num_dead,
189                                                   size_t num_total) {
<a name="16" id="anc16"></a><span class="line-modified">190   if (active_workers() == 1) {</span>
<span class="line-modified">191     record_phase_items(phase, num_dead, num_total);</span>
<span class="line-modified">192   } else {</span>
<span class="line-removed">193     worker_data(phase)-&gt;set_or_add_thread_work_item(worker_id, num_dead, DeadItems);</span>
<span class="line-removed">194     worker_data(phase)-&gt;set_or_add_thread_work_item(worker_id, num_total, TotalItems);</span>
<span class="line-removed">195   }</span>
196 }
197 
198 static double elapsed_time_sec(Ticks start_time, Ticks end_time) {
199   return (end_time - start_time).seconds();
200 }
201 
202 WeakProcessorTimeTracker::WeakProcessorTimeTracker(WeakProcessorPhaseTimes* times) :
203   _times(times),
204   _start_time(Ticks::now())
205 {}
206 
207 WeakProcessorTimeTracker::~WeakProcessorTimeTracker() {
208   if (_times != NULL) {
209     Ticks end_time = Ticks::now();
210     _times-&gt;record_total_time_sec(elapsed_time_sec(_start_time, end_time));
211   }
212 }
213 
214 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
215                                                              WeakProcessorPhase phase,
216                                                              uint worker_id) :
217   _times(times),
218   _phase(phase),
219   _worker_id(worker_id),
220   _start_time(Ticks::now())
221 {
<a name="17" id="anc17"></a><span class="line-modified">222   assert_oop_storage_phase(_phase);</span>
223   assert(_times == NULL || worker_id &lt; _times-&gt;active_workers(),
224          &quot;Invalid worker_id %u&quot;, worker_id);
225 }
226 
227 WeakProcessorPhaseTimeTracker::WeakProcessorPhaseTimeTracker(WeakProcessorPhaseTimes* times,
228                                                              WeakProcessorPhase phase) :
229   _times(times),
230   _phase(phase),
231   _worker_id(0),
232   _start_time(Ticks::now())
233 {
<a name="18" id="anc18"></a><span class="line-modified">234   assert(is_serial_phase(phase), &quot;Not a serial phase %u&quot;, phase_index(phase));</span>
235 }
236 
237 WeakProcessorPhaseTimeTracker::~WeakProcessorPhaseTimeTracker() {
238   if (_times != NULL) {
239     double time_sec = elapsed_time_sec(_start_time, Ticks::now());
240     if (is_serial_phase(_phase)) {
241       _times-&gt;record_phase_time_sec(_phase, time_sec);
242     } else {
243       _times-&gt;record_worker_time_sec(_worker_id, _phase, time_sec);
244     }
245   }
246 }
247 
248 //////////////////////////////////////////////////////////////////////////////
249 // Printing times
250 
251 const char* const indents[] = {&quot;&quot;, &quot;  &quot;, &quot;    &quot;, &quot;      &quot;, &quot;        &quot;};
252 const size_t max_indents_index = ARRAY_SIZE(indents) - 1;
253 
254 static const char* indent_str(size_t i) {
255   return indents[MIN2(i, max_indents_index)];
256 }
257 
258 #define TIME_FORMAT &quot;%.1lfms&quot;
259 
260 void WeakProcessorPhaseTimes::log_st_phase(WeakProcessorPhase phase,
261                                            uint indent) const {
<a name="19" id="anc19"></a>
262   log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
263                         indent_str(indent),
264                         WeakProcessorPhases::description(phase),
265                         phase_time_sec(phase) * MILLIUNITS);
266 
267   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
268                         indent_str(indent + 1),
269                         &quot;Dead&quot;,
<a name="20" id="anc20"></a><span class="line-modified">270                         _phase_dead_items[phase_index(phase)]);</span>
271 
272   log_debug(gc, phases)(&quot;%s%s: &quot; SIZE_FORMAT,
273                         indent_str(indent + 1),
274                         &quot;Total&quot;,
<a name="21" id="anc21"></a><span class="line-modified">275                         _phase_total_items[phase_index(phase)]);</span>
276 }
277 
278 void WeakProcessorPhaseTimes::log_mt_phase_summary(WeakProcessorPhase phase,
279                                                    uint indent) const {
280   LogTarget(Debug, gc, phases) lt;
281   LogStream ls(lt);
282   ls.print(&quot;%s&quot;, indents[indent]);
283   worker_data(phase)-&gt;print_summary_on(&amp;ls, true);
284   log_mt_phase_details(worker_data(phase), indent + 1);
285 
286   for (uint i = 0; i &lt; worker_data(phase)-&gt;MaxThreadWorkItems; i++) {
287     WorkerDataArray&lt;size_t&gt;* work_items = worker_data(phase)-&gt;thread_work_items(i);
288     if (work_items != NULL) {
289       ls.print(&quot;%s&quot;, indents[indent + 1]);
290       work_items-&gt;print_summary_on(&amp;ls, true);
291       log_mt_phase_details(work_items, indent + 1);
292     }
293   }
294 }
295 
296 template &lt;typename T&gt;
297 void WeakProcessorPhaseTimes::log_mt_phase_details(WorkerDataArray&lt;T&gt;* data,
298                                                    uint indent) const {
299   LogTarget(Trace, gc, phases) lt;
300   if (lt.is_enabled()) {
301     LogStream ls(lt);
302     ls.print(&quot;%s&quot;, indents[indent]);
303     data-&gt;print_details_on(&amp;ls);
304   }
305 }
306 
307 void WeakProcessorPhaseTimes::log_print_phases(uint indent) const {
308   if (log_is_enabled(Debug, gc, phases)) {
<a name="22" id="anc22"></a><span class="line-modified">309     FOR_EACH_WEAK_PROCESSOR_PHASE(phase) {</span>
<span class="line-modified">310       if (is_serial_phase(phase) || (active_workers() == 1)) {</span>
<span class="line-modified">311         log_st_phase(phase, indent);</span>
<span class="line-modified">312       } else {</span>
<span class="line-modified">313         log_mt_phase_summary(phase, indent);</span>
<span class="line-modified">314       }</span>
315     }
316   }
317 }
318 
319 void WeakProcessorPhaseTimes::log_print(uint indent) const {
320   if (log_is_enabled(Debug, gc, phases)) {
321     log_debug(gc, phases)(&quot;%s%s: &quot; TIME_FORMAT,
322                           indent_str(indent),
323                           &quot;Weak Processing&quot;,
324                           total_time_sec() * MILLIUNITS);
325     log_print_phases(indent + 1);
326   }
327 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
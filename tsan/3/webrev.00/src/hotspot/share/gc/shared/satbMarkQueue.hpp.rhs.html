<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/satbMarkQueue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 26 #define SHARE_GC_SHARED_SATBMARKQUEUE_HPP
 27 
 28 #include &quot;gc/shared/ptrQueue.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 30 #include &quot;memory/padded.hpp&quot;</span>
 31 
 32 class Thread;
 33 class Monitor;
 34 class SATBMarkQueueSet;
 35 
 36 // Base class for processing the contents of a SATB buffer.
 37 class SATBBufferClosure : public StackObj {
 38 protected:
 39   ~SATBBufferClosure() { }
 40 
 41 public:
 42   // Process the SATB entries in the designated buffer range.
 43   virtual void do_buffer(void** buffer, size_t size) = 0;
 44 };
 45 
 46 // A PtrQueue whose elements are (possibly stale) pointers to object heads.
 47 class SATBMarkQueue: public PtrQueue {
 48   friend class SATBMarkQueueSet;
 49 
 50 private:
 51   // Filter out unwanted entries from the buffer.
 52   inline void filter();
 53 
 54   // Removes entries from the buffer that are no longer needed.
 55   template&lt;typename Filter&gt;
 56   inline void apply_filter(Filter filter_out);
 57 
<a name="2" id="anc2"></a><span class="line-added"> 58 protected:</span>
<span class="line-added"> 59   virtual void handle_completed_buffer();</span>
<span class="line-added"> 60 </span>
 61 public:
<a name="3" id="anc3"></a><span class="line-modified"> 62   SATBMarkQueue(SATBMarkQueueSet* qset);</span>
 63 
 64   // Process queue entries and free resources.
 65   void flush();
 66 
<a name="4" id="anc4"></a><span class="line-added"> 67   inline SATBMarkQueueSet* satb_qset() const;</span>
<span class="line-added"> 68 </span>
 69   // Apply cl to the active part of the buffer.
 70   // Prerequisite: Must be at a safepoint.
 71   void apply_closure_and_empty(SATBBufferClosure* cl);
 72 
<a name="5" id="anc5"></a>



 73 #ifndef PRODUCT
 74   // Helpful for debugging
 75   void print(const char* name);
 76 #endif // PRODUCT
 77 
 78   // Compiler support.
 79   static ByteSize byte_offset_of_index() {
 80     return PtrQueue::byte_offset_of_index&lt;SATBMarkQueue&gt;();
 81   }
 82   using PtrQueue::byte_width_of_index;
 83 
 84   static ByteSize byte_offset_of_buf() {
 85     return PtrQueue::byte_offset_of_buf&lt;SATBMarkQueue&gt;();
 86   }
 87   using PtrQueue::byte_width_of_buf;
 88 
 89   static ByteSize byte_offset_of_active() {
 90     return PtrQueue::byte_offset_of_active&lt;SATBMarkQueue&gt;();
 91   }
 92   using PtrQueue::byte_width_of_active;
 93 
 94 };
 95 
 96 class SATBMarkQueueSet: public PtrQueueSet {
<a name="6" id="anc6"></a><span class="line-added"> 97 </span>
<span class="line-added"> 98   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);</span>
<span class="line-added"> 99   PaddedEnd&lt;BufferNode::Stack&gt; _list;</span>
<span class="line-added">100   volatile size_t _count_and_process_flag;</span>
<span class="line-added">101   // These are rarely (if ever) changed, so same cache line as count.</span>
<span class="line-added">102   size_t _process_completed_buffers_threshold;</span>
103   size_t _buffer_enqueue_threshold;
<a name="7" id="anc7"></a><span class="line-added">104   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, 3 * sizeof(size_t));</span>
<span class="line-added">105 </span>
<span class="line-added">106   BufferNode* get_completed_buffer();</span>
<span class="line-added">107   void abandon_completed_buffers();</span>
108 
109 #ifdef ASSERT
110   void dump_active_states(bool expected_active);
111   void verify_active_states(bool expected_active);
112 #endif // ASSERT
113 
114 protected:
<a name="8" id="anc8"></a><span class="line-modified">115   SATBMarkQueueSet(BufferNode::Allocator* allocator);</span>
<span class="line-modified">116   ~SATBMarkQueueSet();</span>
117 
118   template&lt;typename Filter&gt;
119   void apply_filter(Filter filter, SATBMarkQueue* queue) {
120     queue-&gt;apply_filter(filter);
121   }
122 
<a name="9" id="anc9"></a>




123 public:
124   virtual SATBMarkQueue&amp; satb_queue_for_thread(Thread* const t) const = 0;
125 
126   // Apply &quot;set_active(active)&quot; to all SATB queues in the set. It should be
127   // called only with the world stopped. The method will assert that the
128   // SATB queues of all threads it visits, as well as the SATB queue
129   // set itself, has an active value same as expected_active.
130   void set_active_all_threads(bool active, bool expected_active);
131 
<a name="10" id="anc10"></a><span class="line-added">132   void set_process_completed_buffers_threshold(size_t value);</span>
<span class="line-added">133 </span>
134   size_t buffer_enqueue_threshold() const { return _buffer_enqueue_threshold; }
<a name="11" id="anc11"></a><span class="line-modified">135   void set_buffer_enqueue_threshold_percentage(uint value);</span>
136 
<a name="12" id="anc12"></a><span class="line-modified">137   virtual void filter(SATBMarkQueue* queue) = 0;</span>

138 
139   // If there exists some completed buffer, pop and process it, and
140   // return true.  Otherwise return false.  Processing a buffer
141   // consists of applying the closure to the active range of the
142   // buffer; the leading entries may be excluded due to filtering.
143   bool apply_closure_to_completed_buffer(SATBBufferClosure* cl);
144 
<a name="13" id="anc13"></a><span class="line-added">145   virtual void enqueue_completed_buffer(BufferNode* node);</span>
<span class="line-added">146 </span>
<span class="line-added">147   // The number of buffers in the list.  Racy and not updated atomically</span>
<span class="line-added">148   // with the set of completed buffers.</span>
<span class="line-added">149   size_t completed_buffers_num() const {</span>
<span class="line-added">150     return _count_and_process_flag &gt;&gt; 1;</span>
<span class="line-added">151   }</span>
<span class="line-added">152 </span>
<span class="line-added">153   // Return true if completed buffers should be processed.</span>
<span class="line-added">154   bool process_completed_buffers() const {</span>
<span class="line-added">155     return (_count_and_process_flag &amp; 1) != 0;</span>
<span class="line-added">156   }</span>
<span class="line-added">157 </span>
158 #ifndef PRODUCT
159   // Helpful for debugging
160   void print_all(const char* msg);
161 #endif // PRODUCT
162 
163   // If a marking is being abandoned, reset any unprocessed log buffers.
164   void abandon_partial_marking();
165 };
166 
<a name="14" id="anc14"></a><span class="line-added">167 inline SATBMarkQueueSet* SATBMarkQueue::satb_qset() const {</span>
<span class="line-added">168   return static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="line-added">169 }</span>
<span class="line-added">170 </span>
171 inline void SATBMarkQueue::filter() {
<a name="15" id="anc15"></a><span class="line-modified">172   satb_qset()-&gt;filter(this);</span>
173 }
174 
175 // Removes entries from the buffer that are no longer needed, as
176 // determined by filter. If e is a void* entry in the buffer,
177 // filter_out(e) must be a valid expression whose value is convertible
178 // to bool. Entries are removed (filtered out) if the result is true,
179 // retained if false.
180 template&lt;typename Filter&gt;
181 inline void SATBMarkQueue::apply_filter(Filter filter_out) {
182   void** buf = this-&gt;_buf;
183 
184   if (buf == NULL) {
185     // nothing to do
186     return;
187   }
188 
189   // Two-fingered compaction toward the end.
190   void** src = &amp;buf[this-&gt;index()];
191   void** dst = &amp;buf[this-&gt;capacity()];
192   assert(src &lt;= dst, &quot;invariant&quot;);
193   for ( ; src &lt; dst; ++src) {
194     // Search low to high for an entry to keep.
195     void* entry = *src;
196     if (!filter_out(entry)) {
197       // Found keeper.  Search high to low for an entry to discard.
198       while (src &lt; --dst) {
199         if (filter_out(*dst)) {
200           *dst = entry;         // Replace discard with keeper.
201           break;
202         }
203       }
204       // If discard search failed (src == dst), the outer loop will also end.
205     }
206   }
207   // dst points to the lowest retained entry, or the end of the buffer
208   // if all the entries were filtered out.
209   this-&gt;set_index(dst - buf);
210 }
211 
212 #endif // SHARE_GC_SHARED_SATBMARKQUEUE_HPP
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
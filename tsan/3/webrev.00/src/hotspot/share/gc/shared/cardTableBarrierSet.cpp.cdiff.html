<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/cardTableBarrierSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="cardTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardTableBarrierSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 94,43 ***</span>
  // Helper for ReduceInitialCardMarks. For performance,
  // compiled code may elide card-marks for initializing stores
  // to a newly allocated object along the fast-path. We
  // compensate for such elided card-marks as follows:
  // (a) Generational, non-concurrent collectors, such as
<span class="line-modified">! //     GenCollectedHeap(ParNew,DefNew,Tenured) and</span>
  //     ParallelScavengeHeap(ParallelGC, ParallelOldGC)
  //     need the card-mark if and only if the region is
  //     in the old gen, and do not care if the card-mark
  //     succeeds or precedes the initializing stores themselves,
  //     so long as the card-mark is completed before the next
  //     scavenge. For all these cases, we can do a card mark
  //     at the point at which we do a slow path allocation
  //     in the old gen, i.e. in this call.
<span class="line-modified">! // (b) GenCollectedHeap(ConcurrentMarkSweepGeneration) requires</span>
<span class="line-removed">- //     in addition that the card-mark for an old gen allocated</span>
<span class="line-removed">- //     object strictly follow any associated initializing stores.</span>
<span class="line-removed">- //     In these cases, the memRegion remembered below is</span>
<span class="line-removed">- //     used to card-mark the entire region either just before the next</span>
<span class="line-removed">- //     slow-path allocation by this thread or just before the next scavenge or</span>
<span class="line-removed">- //     CMS-associated safepoint, whichever of these events happens first.</span>
<span class="line-removed">- //     (The implicit assumption is that the object has been fully</span>
<span class="line-removed">- //     initialized by this point, a fact that we assert when doing the</span>
<span class="line-removed">- //     card-mark.)</span>
<span class="line-removed">- // (c) G1CollectedHeap(G1) uses two kinds of write barriers. When a</span>
  //     G1 concurrent marking is in progress an SATB (pre-write-)barrier
  //     is used to remember the pre-value of any store. Initializing
  //     stores will not need this barrier, so we need not worry about
  //     compensating for the missing pre-barrier here. Turning now
  //     to the post-barrier, we note that G1 needs a RS update barrier
  //     which simply enqueues a (sequence of) dirty cards which may
  //     optionally be refined by the concurrent update threads. Note
  //     that this barrier need only be applied to a non-young write,
<span class="line-modified">! //     but, like in CMS, because of the presence of concurrent refinement</span>
<span class="line-modified">! //     (much like CMS&#39; precleaning), must strictly follow the oop-store.</span>
<span class="line-removed">- //     Thus, using the same protocol for maintaining the intended</span>
<span class="line-removed">- //     invariants turns out, serendepitously, to be the same for both</span>
<span class="line-removed">- //     G1 and CMS.</span>
  //
  // For any future collector, this code should be reexamined with
  // that specific collector in mind, and the documentation above suitably
  // extended and updated.
  void CardTableBarrierSet::on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {
<span class="line-new-header">--- 94,30 ---</span>
  // Helper for ReduceInitialCardMarks. For performance,
  // compiled code may elide card-marks for initializing stores
  // to a newly allocated object along the fast-path. We
  // compensate for such elided card-marks as follows:
  // (a) Generational, non-concurrent collectors, such as
<span class="line-modified">! //     GenCollectedHeap(DefNew,Tenured) and</span>
  //     ParallelScavengeHeap(ParallelGC, ParallelOldGC)
  //     need the card-mark if and only if the region is
  //     in the old gen, and do not care if the card-mark
  //     succeeds or precedes the initializing stores themselves,
  //     so long as the card-mark is completed before the next
  //     scavenge. For all these cases, we can do a card mark
  //     at the point at which we do a slow path allocation
  //     in the old gen, i.e. in this call.
<span class="line-modified">! // (b) G1CollectedHeap(G1) uses two kinds of write barriers. When a</span>
  //     G1 concurrent marking is in progress an SATB (pre-write-)barrier
  //     is used to remember the pre-value of any store. Initializing
  //     stores will not need this barrier, so we need not worry about
  //     compensating for the missing pre-barrier here. Turning now
  //     to the post-barrier, we note that G1 needs a RS update barrier
  //     which simply enqueues a (sequence of) dirty cards which may
  //     optionally be refined by the concurrent update threads. Note
  //     that this barrier need only be applied to a non-young write,
<span class="line-modified">! //     but, because of the presence of concurrent refinement,</span>
<span class="line-modified">! //     must strictly follow the oop-store.</span>
  //
  // For any future collector, this code should be reexamined with
  // that specific collector in mind, and the documentation above suitably
  // extended and updated.
  void CardTableBarrierSet::on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,11 ***</span>
      // Arrays of non-references don&#39;t need a post-barrier.
      // The deferred_card_mark region should be empty
      // following the flush above.
      assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Error&quot;);
    } else {
<span class="line-modified">!     MemRegion mr((HeapWord*)new_obj, new_obj-&gt;size());</span>
      assert(!mr.is_empty(), &quot;Error&quot;);
      if (_defer_initial_card_mark) {
        // Defer the card mark
        thread-&gt;set_deferred_card_mark(mr);
      } else {
<span class="line-new-header">--- 131,11 ---</span>
      // Arrays of non-references don&#39;t need a post-barrier.
      // The deferred_card_mark region should be empty
      // following the flush above.
      assert(thread-&gt;deferred_card_mark().is_empty(), &quot;Error&quot;);
    } else {
<span class="line-modified">!     MemRegion mr(cast_from_oop&lt;HeapWord*&gt;(new_obj), new_obj-&gt;size());</span>
      assert(!mr.is_empty(), &quot;Error&quot;);
      if (_defer_initial_card_mark) {
        // Defer the card mark
        thread-&gt;set_deferred_card_mark(mr);
      } else {
</pre>
<center><a href="cardTable.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTableBarrierSet.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
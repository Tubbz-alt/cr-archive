<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;gc/shared/threadLocalAllocBuffer.inline.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/thread.inline.hpp&quot;
 33 #include &quot;runtime/threadSMR.hpp&quot;
 34 #include &quot;utilities/copy.hpp&quot;
 35 
 36 size_t       ThreadLocalAllocBuffer::_max_size = 0;
 37 int          ThreadLocalAllocBuffer::_reserve_for_allocation_prefetch = 0;
 38 unsigned int ThreadLocalAllocBuffer::_target_refills = 0;
 39 
 40 size_t ThreadLocalAllocBuffer::remaining() {
 41   if (end() == NULL) {
 42     return 0;
 43   }
 44 
 45   return pointer_delta(hard_end(), top());
 46 }
 47 
 48 void ThreadLocalAllocBuffer::accumulate_and_reset_statistics(ThreadLocalAllocStats* stats) {
 49   Thread* thr     = thread();
 50   size_t capacity = Universe::heap()-&gt;tlab_capacity(thr);
 51   size_t used     = Universe::heap()-&gt;tlab_used(thr);
 52 
 53   _gc_waste += (unsigned)remaining();
 54   size_t total_allocated = thr-&gt;allocated_bytes();
 55   size_t allocated_since_last_gc = total_allocated - _allocated_before_last_gc;
 56   _allocated_before_last_gc = total_allocated;
 57 
 58   print_stats(&quot;gc&quot;);
 59 
 60   if (_number_of_refills &gt; 0) {
 61     // Update allocation history if a reasonable amount of eden was allocated.
 62     bool update_allocation_history = used &gt; 0.5 * capacity;
 63 
 64     if (update_allocation_history) {
 65       // Average the fraction of eden allocated in a tlab by this
 66       // thread for use in the next resize operation.
 67       // _gc_waste is not subtracted because it&#39;s included in
 68       // &quot;used&quot;.
 69       // The result can be larger than 1.0 due to direct to old allocations.
 70       // These allocations should ideally not be counted but since it is not possible
 71       // to filter them out here we just cap the fraction to be at most 1.0.
 72       double alloc_frac = MIN2(1.0, (double) allocated_since_last_gc / used);
 73       _allocation_fraction.sample(alloc_frac);
 74     }
 75 
 76     stats-&gt;update_fast_allocations(_number_of_refills,
 77                                    _allocated_size,
 78                                    _gc_waste,
 79                                    _fast_refill_waste,
 80                                    _slow_refill_waste);
 81   } else {
 82     assert(_number_of_refills == 0 &amp;&amp; _fast_refill_waste == 0 &amp;&amp;
 83            _slow_refill_waste == 0 &amp;&amp; _gc_waste          == 0,
 84            &quot;tlab stats == 0&quot;);
 85   }
 86 
 87   stats-&gt;update_slow_allocations(_slow_allocations);
 88 
 89   reset_statistics();
 90 }
 91 
 92 void ThreadLocalAllocBuffer::insert_filler() {
 93   assert(end() != NULL, &quot;Must not be retired&quot;);
 94   if (top() &lt; hard_end()) {
 95     Universe::heap()-&gt;fill_with_dummy_object(top(), hard_end(), true);
 96   }
 97 }
 98 
 99 void ThreadLocalAllocBuffer::make_parsable() {
100   if (end() != NULL) {
101     invariants();
102     if (ZeroTLAB) {
103       retire();
104     } else {
105       insert_filler();
106     }
107   }
108 }
109 
110 void ThreadLocalAllocBuffer::retire(ThreadLocalAllocStats* stats) {
111   if (stats != NULL) {
112     accumulate_and_reset_statistics(stats);
113   }
114 
115   if (end() != NULL) {
116     invariants();
117     thread()-&gt;incr_allocated_bytes(used_bytes());
118     insert_filler();
119     initialize(NULL, NULL, NULL);
120   }
121 }
122 
123 void ThreadLocalAllocBuffer::retire_before_allocation() {
124   _slow_refill_waste += (unsigned int)remaining();
125   retire();
126 }
127 
128 void ThreadLocalAllocBuffer::resize() {
129   // Compute the next tlab size using expected allocation amount
130   assert(ResizeTLAB, &quot;Should not call this otherwise&quot;);
131   size_t alloc = (size_t)(_allocation_fraction.average() *
132                           (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize));
133   size_t new_size = alloc / _target_refills;
134 
<a name="2" id="anc2"></a><span class="line-modified">135   new_size = MIN2(MAX2(new_size, min_size()), max_size());</span>
136 
137   size_t aligned_new_size = align_object_size(new_size);
138 
139   log_trace(gc, tlab)(&quot;TLAB new size: thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
140                       &quot; refills %d  alloc: %8.6f desired_size: &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,
141                       p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),
142                       _target_refills, _allocation_fraction.average(), desired_size(), aligned_new_size);
143 
144   set_desired_size(aligned_new_size);
145   set_refill_waste_limit(initial_refill_waste_limit());
146 }
147 
148 void ThreadLocalAllocBuffer::reset_statistics() {
149   _number_of_refills = 0;
150   _fast_refill_waste = 0;
151   _slow_refill_waste = 0;
152   _gc_waste          = 0;
153   _slow_allocations  = 0;
154   _allocated_size    = 0;
155 }
156 
157 void ThreadLocalAllocBuffer::fill(HeapWord* start,
158                                   HeapWord* top,
159                                   size_t    new_size) {
160   _number_of_refills++;
161   _allocated_size += new_size;
162   print_stats(&quot;fill&quot;);
163   assert(top &lt;= start + new_size - alignment_reserve(), &quot;size too small&quot;);
164 
165   initialize(start, top, start + new_size - alignment_reserve());
166 
167   // Reset amount of internal fragmentation
168   set_refill_waste_limit(initial_refill_waste_limit());
169 }
170 
171 void ThreadLocalAllocBuffer::initialize(HeapWord* start,
172                                         HeapWord* top,
173                                         HeapWord* end) {
174   set_start(start);
175   set_top(top);
176   set_pf_top(top);
177   set_end(end);
178   set_allocation_end(end);
179   invariants();
180 }
181 
182 void ThreadLocalAllocBuffer::initialize() {
183   initialize(NULL,                    // start
184              NULL,                    // top
185              NULL);                   // end
186 
187   set_desired_size(initial_desired_size());
188 
189   size_t capacity = Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize;
190   double alloc_frac = desired_size() * target_refills() / (double) capacity;
191   _allocation_fraction.sample(alloc_frac);
192 
193   set_refill_waste_limit(initial_refill_waste_limit());
194 
195   reset_statistics();
196 }
197 
198 void ThreadLocalAllocBuffer::startup_initialization() {
199   ThreadLocalAllocStats::initialize();
200 
201   // Assuming each thread&#39;s active tlab is, on average,
202   // 1/2 full at a GC
203   _target_refills = 100 / (2 * TLABWasteTargetPercent);
204   // We need to set initial target refills to 2 to avoid a GC which causes VM
205   // abort during VM initialization.
206   _target_refills = MAX2(_target_refills, 2U);
207 
208 #ifdef COMPILER2
209   // If the C2 compiler is present, extra space is needed at the end of
210   // TLABs, otherwise prefetching instructions generated by the C2
211   // compiler will fault (due to accessing memory outside of heap).
212   // The amount of space is the max of the number of lines to
213   // prefetch for array and for instance allocations. (Extra space must be
214   // reserved to accommodate both types of allocations.)
215   //
216   // Only SPARC-specific BIS instructions are known to fault. (Those
217   // instructions are generated if AllocatePrefetchStyle==3 and
218   // AllocatePrefetchInstr==1). To be on the safe side, however,
219   // extra space is reserved for all combinations of
220   // AllocatePrefetchStyle and AllocatePrefetchInstr.
221   //
222   // If the C2 compiler is not present, no space is reserved.
223 
224   // +1 for rounding up to next cache line, +1 to be safe
225   if (is_server_compilation_mode_vm()) {
226     int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;
227     _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /
228                                        (int)HeapWordSize;
229   }
230 #endif
231 
232   // During jvm startup, the main thread is initialized
233   // before the heap is initialized.  So reinitialize it now.
234   guarantee(Thread::current()-&gt;is_Java_thread(), &quot;tlab initialization thread not Java thread&quot;);
235   Thread::current()-&gt;tlab().initialize();
236 
237   log_develop_trace(gc, tlab)(&quot;TLAB min: &quot; SIZE_FORMAT &quot; initial: &quot; SIZE_FORMAT &quot; max: &quot; SIZE_FORMAT,
238                                min_size(), Thread::current()-&gt;tlab().initial_desired_size(), max_size());
239 }
240 
241 size_t ThreadLocalAllocBuffer::initial_desired_size() {
242   size_t init_sz = 0;
243 
244   if (TLABSize &gt; 0) {
245     init_sz = TLABSize / HeapWordSize;
246   } else {
247     // Initial size is a function of the average number of allocating threads.
248     unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();
249 
250     init_sz  = (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize) /
251                       (nof_threads * target_refills());
252     init_sz = align_object_size(init_sz);
253   }
<a name="3" id="anc3"></a>



254   init_sz = MIN2(MAX2(init_sz, min_size()), max_size());
255   return init_sz;
256 }
257 
258 void ThreadLocalAllocBuffer::print_stats(const char* tag) {
259   Log(gc, tlab) log;
260   if (!log.is_trace()) {
261     return;
262   }
263 
264   Thread* thrd = thread();
265   size_t waste = _gc_waste + _slow_refill_waste + _fast_refill_waste;
266   double waste_percent = percent_of(waste, _allocated_size);
267   size_t tlab_used  = Universe::heap()-&gt;tlab_used(thrd);
268   log.trace(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
269             &quot; desired_size: &quot; SIZE_FORMAT &quot;KB&quot;
270             &quot; slow allocs: %d  refill waste: &quot; SIZE_FORMAT &quot;B&quot;
271             &quot; alloc:%8.5f %8.0fKB refills: %d waste %4.1f%% gc: %dB&quot;
272             &quot; slow: %dB fast: %dB&quot;,
273             tag, p2i(thrd), thrd-&gt;osthread()-&gt;thread_id(),
274             _desired_size / (K / HeapWordSize),
275             _slow_allocations, _refill_waste_limit * HeapWordSize,
276             _allocation_fraction.average(),
277             _allocation_fraction.average() * tlab_used / K,
278             _number_of_refills, waste_percent,
279             _gc_waste * HeapWordSize,
280             _slow_refill_waste * HeapWordSize,
281             _fast_refill_waste * HeapWordSize);
282 }
283 
<a name="4" id="anc4"></a><span class="line-modified">284 void ThreadLocalAllocBuffer::set_sample_end() {</span>
285   size_t heap_words_remaining = pointer_delta(_end, _top);
286   size_t bytes_until_sample = thread()-&gt;heap_sampler().bytes_until_sample();
287   size_t words_until_sample = bytes_until_sample / HeapWordSize;
288 
<a name="5" id="anc5"></a>



289   if (heap_words_remaining &gt; words_until_sample) {
290     HeapWord* new_end = _top + words_until_sample;
291     set_end(new_end);
<a name="6" id="anc6"></a><span class="line-modified">292     _bytes_since_last_sample_point = bytes_until_sample;</span>
293   } else {
<a name="7" id="anc7"></a><span class="line-modified">294     _bytes_since_last_sample_point = heap_words_remaining * HeapWordSize;</span>
295   }
296 }
297 
298 Thread* ThreadLocalAllocBuffer::thread() {
299   return (Thread*)(((char*)this) + in_bytes(start_offset()) - in_bytes(Thread::tlab_start_offset()));
300 }
301 
302 void ThreadLocalAllocBuffer::set_back_allocation_end() {
303   _end = _allocation_end;
304 }
305 
306 HeapWord* ThreadLocalAllocBuffer::hard_end() {
307   return _allocation_end + alignment_reserve();
308 }
309 
310 PerfVariable* ThreadLocalAllocStats::_perf_allocating_threads;
311 PerfVariable* ThreadLocalAllocStats::_perf_total_refills;
312 PerfVariable* ThreadLocalAllocStats::_perf_max_refills;
313 PerfVariable* ThreadLocalAllocStats::_perf_total_allocations;
314 PerfVariable* ThreadLocalAllocStats::_perf_total_gc_waste;
315 PerfVariable* ThreadLocalAllocStats::_perf_max_gc_waste;
316 PerfVariable* ThreadLocalAllocStats::_perf_total_slow_refill_waste;
317 PerfVariable* ThreadLocalAllocStats::_perf_max_slow_refill_waste;
318 PerfVariable* ThreadLocalAllocStats::_perf_total_fast_refill_waste;
319 PerfVariable* ThreadLocalAllocStats::_perf_max_fast_refill_waste;
320 PerfVariable* ThreadLocalAllocStats::_perf_total_slow_allocations;
321 PerfVariable* ThreadLocalAllocStats::_perf_max_slow_allocations;
322 AdaptiveWeightedAverage ThreadLocalAllocStats::_allocating_threads_avg(0);
323 
324 static PerfVariable* create_perf_variable(const char* name, PerfData::Units unit, TRAPS) {
325   ResourceMark rm;
326   return PerfDataManager::create_variable(SUN_GC, PerfDataManager::counter_name(&quot;tlab&quot;, name), unit, THREAD);
327 }
328 
329 void ThreadLocalAllocStats::initialize() {
330   _allocating_threads_avg = AdaptiveWeightedAverage(TLABAllocationWeight);
331   _allocating_threads_avg.sample(1); // One allocating thread at startup
332 
333   if (UsePerfData) {
334     EXCEPTION_MARK;
335     _perf_allocating_threads      = create_perf_variable(&quot;allocThreads&quot;, PerfData::U_None,  CHECK);
336     _perf_total_refills           = create_perf_variable(&quot;fills&quot;,        PerfData::U_None,  CHECK);
337     _perf_max_refills             = create_perf_variable(&quot;maxFills&quot;,     PerfData::U_None,  CHECK);
338     _perf_total_allocations       = create_perf_variable(&quot;alloc&quot;,        PerfData::U_Bytes, CHECK);
339     _perf_total_gc_waste          = create_perf_variable(&quot;gcWaste&quot;,      PerfData::U_Bytes, CHECK);
340     _perf_max_gc_waste            = create_perf_variable(&quot;maxGcWaste&quot;,   PerfData::U_Bytes, CHECK);
341     _perf_total_slow_refill_waste = create_perf_variable(&quot;slowWaste&quot;,    PerfData::U_Bytes, CHECK);
342     _perf_max_slow_refill_waste   = create_perf_variable(&quot;maxSlowWaste&quot;, PerfData::U_Bytes, CHECK);
343     _perf_total_fast_refill_waste = create_perf_variable(&quot;fastWaste&quot;,    PerfData::U_Bytes, CHECK);
344     _perf_max_fast_refill_waste   = create_perf_variable(&quot;maxFastWaste&quot;, PerfData::U_Bytes, CHECK);
345     _perf_total_slow_allocations  = create_perf_variable(&quot;slowAlloc&quot;,    PerfData::U_None,  CHECK);
346     _perf_max_slow_allocations    = create_perf_variable(&quot;maxSlowAlloc&quot;, PerfData::U_None,  CHECK);
347   }
348 }
349 
350 ThreadLocalAllocStats::ThreadLocalAllocStats() :
351     _allocating_threads(0),
352     _total_refills(0),
353     _max_refills(0),
354     _total_allocations(0),
355     _total_gc_waste(0),
356     _max_gc_waste(0),
357     _total_fast_refill_waste(0),
358     _max_fast_refill_waste(0),
359     _total_slow_refill_waste(0),
360     _max_slow_refill_waste(0),
361     _total_slow_allocations(0),
362     _max_slow_allocations(0) {}
363 
364 unsigned int ThreadLocalAllocStats::allocating_threads_avg() {
365   return MAX2((unsigned int)(_allocating_threads_avg.average() + 0.5), 1U);
366 }
367 
368 void ThreadLocalAllocStats::update_fast_allocations(unsigned int refills,
369                                        size_t allocations,
370                                        size_t gc_waste,
371                                        size_t fast_refill_waste,
372                                        size_t slow_refill_waste) {
373   _allocating_threads      += 1;
374   _total_refills           += refills;
375   _max_refills              = MAX2(_max_refills, refills);
376   _total_allocations       += allocations;
377   _total_gc_waste          += gc_waste;
378   _max_gc_waste             = MAX2(_max_gc_waste, gc_waste);
379   _total_fast_refill_waste += fast_refill_waste;
380   _max_fast_refill_waste    = MAX2(_max_fast_refill_waste, fast_refill_waste);
381   _total_slow_refill_waste += slow_refill_waste;
382   _max_slow_refill_waste    = MAX2(_max_slow_refill_waste, slow_refill_waste);
383 }
384 
385 void ThreadLocalAllocStats::update_slow_allocations(unsigned int allocations) {
386   _total_slow_allocations += allocations;
387   _max_slow_allocations    = MAX2(_max_slow_allocations, allocations);
388 }
389 
390 void ThreadLocalAllocStats::update(const ThreadLocalAllocStats&amp; other) {
391   _allocating_threads      += other._allocating_threads;
392   _total_refills           += other._total_refills;
393   _max_refills              = MAX2(_max_refills, other._max_refills);
394   _total_allocations       += other._total_allocations;
395   _total_gc_waste          += other._total_gc_waste;
396   _max_gc_waste             = MAX2(_max_gc_waste, other._max_gc_waste);
397   _total_fast_refill_waste += other._total_fast_refill_waste;
398   _max_fast_refill_waste    = MAX2(_max_fast_refill_waste, other._max_fast_refill_waste);
399   _total_slow_refill_waste += other._total_slow_refill_waste;
400   _max_slow_refill_waste    = MAX2(_max_slow_refill_waste, other._max_slow_refill_waste);
401   _total_slow_allocations  += other._total_slow_allocations;
402   _max_slow_allocations     = MAX2(_max_slow_allocations, other._max_slow_allocations);
403 }
404 
405 void ThreadLocalAllocStats::reset() {
406   _allocating_threads      = 0;
407   _total_refills           = 0;
408   _max_refills             = 0;
409   _total_allocations       = 0;
410   _total_gc_waste          = 0;
411   _max_gc_waste            = 0;
412   _total_fast_refill_waste = 0;
413   _max_fast_refill_waste   = 0;
414   _total_slow_refill_waste = 0;
415   _max_slow_refill_waste   = 0;
416   _total_slow_allocations  = 0;
417   _max_slow_allocations    = 0;
418 }
419 
420 void ThreadLocalAllocStats::publish() {
421   if (_total_allocations == 0) {
422     return;
423   }
424 
425   _allocating_threads_avg.sample(_allocating_threads);
426 
427   const size_t waste = _total_gc_waste + _total_slow_refill_waste + _total_fast_refill_waste;
428   const double waste_percent = percent_of(waste, _total_allocations);
429   log_debug(gc, tlab)(&quot;TLAB totals: thrds: %d  refills: %d max: %d&quot;
430                       &quot; slow allocs: %d max %d waste: %4.1f%%&quot;
431                       &quot; gc: &quot; SIZE_FORMAT &quot;B max: &quot; SIZE_FORMAT &quot;B&quot;
432                       &quot; slow: &quot; SIZE_FORMAT &quot;B max: &quot; SIZE_FORMAT &quot;B&quot;
433                       &quot; fast: &quot; SIZE_FORMAT &quot;B max: &quot; SIZE_FORMAT &quot;B&quot;,
434                       _allocating_threads, _total_refills, _max_refills,
435                       _total_slow_allocations, _max_slow_allocations, waste_percent,
436                       _total_gc_waste * HeapWordSize, _max_gc_waste * HeapWordSize,
437                       _total_slow_refill_waste * HeapWordSize, _max_slow_refill_waste * HeapWordSize,
438                       _total_fast_refill_waste * HeapWordSize, _max_fast_refill_waste * HeapWordSize);
439 
440   if (UsePerfData) {
441     _perf_allocating_threads      -&gt;set_value(_allocating_threads);
442     _perf_total_refills           -&gt;set_value(_total_refills);
443     _perf_max_refills             -&gt;set_value(_max_refills);
444     _perf_total_allocations       -&gt;set_value(_total_allocations);
445     _perf_total_gc_waste          -&gt;set_value(_total_gc_waste);
446     _perf_max_gc_waste            -&gt;set_value(_max_gc_waste);
447     _perf_total_slow_refill_waste -&gt;set_value(_total_slow_refill_waste);
448     _perf_max_slow_refill_waste   -&gt;set_value(_max_slow_refill_waste);
449     _perf_total_fast_refill_waste -&gt;set_value(_total_fast_refill_waste);
450     _perf_max_fast_refill_waste   -&gt;set_value(_max_fast_refill_waste);
451     _perf_total_slow_allocations  -&gt;set_value(_total_slow_allocations);
452     _perf_max_slow_allocations    -&gt;set_value(_max_slow_allocations);
453   }
454 }
455 
456 size_t ThreadLocalAllocBuffer::end_reserve() {
457   size_t reserve_size = Universe::heap()-&gt;tlab_alloc_reserve();
458   return MAX2(reserve_size, (size_t)_reserve_for_allocation_prefetch);
459 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
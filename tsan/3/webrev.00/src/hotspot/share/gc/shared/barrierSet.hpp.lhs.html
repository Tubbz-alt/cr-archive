<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/barrierSet.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_BARRIERSET_HPP
 26 #define SHARE_GC_SHARED_BARRIERSET_HPP
 27 
 28 #include &quot;gc/shared/barrierSetConfig.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
 31 #include &quot;oops/accessBackend.hpp&quot;
 32 #include &quot;oops/oopsHierarchy.hpp&quot;
 33 #include &quot;utilities/fakeRttiSupport.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 class BarrierSetAssembler;
 37 class BarrierSetC1;
 38 class BarrierSetC2;
 39 class BarrierSetNMethod;
 40 class JavaThread;
 41 
 42 // This class provides the interface between a barrier implementation and
 43 // the rest of the system.
 44 
 45 class BarrierSet: public CHeapObj&lt;mtGC&gt; {
 46   friend class VMStructs;
 47 
 48   static BarrierSet* _barrier_set;
 49 
 50 public:
 51   enum Name {
 52 #define BARRIER_SET_DECLARE_BS_ENUM(bs_name) bs_name ,
 53     FOR_EACH_BARRIER_SET_DO(BARRIER_SET_DECLARE_BS_ENUM)
 54 #undef BARRIER_SET_DECLARE_BS_ENUM
 55     UnknownBS
 56   };
 57 
 58 protected:
 59   // Fake RTTI support.  For a derived class T to participate
 60   // - T must have a corresponding Name entry.
 61   // - GetName&lt;T&gt; must be specialized to return the corresponding Name
 62   //   entry.
 63   // - If T is a base class, the constructor must have a FakeRtti
 64   //   parameter and pass it up to its base class, with the tag set
 65   //   augmented with the corresponding Name entry.
 66   // - If T is a concrete class, the constructor must create a
 67   //   FakeRtti object whose tag set includes the corresponding Name
 68   //   entry, and pass it up to its base class.
 69   typedef FakeRttiSupport&lt;BarrierSet, Name&gt; FakeRtti;
 70 
 71 private:
 72   FakeRtti _fake_rtti;
 73   BarrierSetAssembler* _barrier_set_assembler;
 74   BarrierSetC1* _barrier_set_c1;
 75   BarrierSetC2* _barrier_set_c2;
 76   BarrierSetNMethod* _barrier_set_nmethod;
 77 
 78 public:
 79   // Metafunction mapping a class derived from BarrierSet to the
 80   // corresponding Name enum tag.
 81   template&lt;typename T&gt; struct GetName;
 82 
 83   // Metafunction mapping a Name enum type to the corresponding
 84   // lass derived from BarrierSet.
 85   template&lt;BarrierSet::Name T&gt; struct GetType;
 86 
 87   // Note: This is not presently the Name corresponding to the
 88   // concrete class of this object.
 89   BarrierSet::Name kind() const { return _fake_rtti.concrete_tag(); }
 90 
 91   // Test whether this object is of the type corresponding to bsn.
 92   bool is_a(BarrierSet::Name bsn) const { return _fake_rtti.has_tag(bsn); }
 93 
 94   // End of fake RTTI support.
 95 
 96 protected:
 97   BarrierSet(BarrierSetAssembler* barrier_set_assembler,
 98              BarrierSetC1* barrier_set_c1,
 99              BarrierSetC2* barrier_set_c2,
100              BarrierSetNMethod* barrier_set_nmethod,
101              const FakeRtti&amp; fake_rtti) :
102     _fake_rtti(fake_rtti),
103     _barrier_set_assembler(barrier_set_assembler),
104     _barrier_set_c1(barrier_set_c1),
105     _barrier_set_c2(barrier_set_c2),
106     _barrier_set_nmethod(barrier_set_nmethod) {}
107   ~BarrierSet() { }
108 
109   template &lt;class BarrierSetAssemblerT&gt;
110   static BarrierSetAssembler* make_barrier_set_assembler() {
111     return NOT_ZERO(new BarrierSetAssemblerT()) ZERO_ONLY(NULL);
112   }
113 
114   template &lt;class BarrierSetC1T&gt;
115   static BarrierSetC1* make_barrier_set_c1() {
116     return COMPILER1_PRESENT(new BarrierSetC1T()) NOT_COMPILER1(NULL);
117   }
118 
119   template &lt;class BarrierSetC2T&gt;
120   static BarrierSetC2* make_barrier_set_c2() {
121     return COMPILER2_PRESENT(new BarrierSetC2T()) NOT_COMPILER2(NULL);
122   }
123 
124 public:
125   // Support for optimizing compilers to call the barrier set on slow path allocations
126   // that did not enter a TLAB. Used for e.g. ReduceInitialCardMarks.
127   // The allocation is safe to use iff it returns true. If not, the slow-path allocation
128   // is redone until it succeeds. This can e.g. prevent allocations from the slow path
129   // to be in old.
130   virtual void on_slowpath_allocation_exit(JavaThread* thread, oop new_obj) {}
131   virtual void on_thread_create(Thread* thread) {}
132   virtual void on_thread_destroy(Thread* thread) {}
<a name="1" id="anc1"></a>








133   virtual void on_thread_attach(Thread* thread) {}
134   virtual void on_thread_detach(Thread* thread) {}
<a name="2" id="anc2"></a><span class="line-removed">135   virtual void make_parsable(JavaThread* thread) {}</span>
136 
<a name="3" id="anc3"></a><span class="line-modified">137 #ifdef CHECK_UNHANDLED_OOPS</span>
<span class="line-removed">138   virtual bool oop_equals_operator_allowed() { return true; }</span>
<span class="line-removed">139 #endif</span>
140 
141 public:
142   // Print a description of the memory for the barrier set
143   virtual void print_on(outputStream* st) const = 0;
144 
145   static BarrierSet* barrier_set() { return _barrier_set; }
146   static void set_barrier_set(BarrierSet* barrier_set);
147 
148   BarrierSetAssembler* barrier_set_assembler() {
149     assert(_barrier_set_assembler != NULL, &quot;should be set&quot;);
150     return _barrier_set_assembler;
151   }
152 
153   BarrierSetC1* barrier_set_c1() {
154     assert(_barrier_set_c1 != NULL, &quot;should be set&quot;);
155     return _barrier_set_c1;
156   }
157 
158   BarrierSetC2* barrier_set_c2() {
159     assert(_barrier_set_c2 != NULL, &quot;should be set&quot;);
160     return _barrier_set_c2;
161   }
162 
163   BarrierSetNMethod* barrier_set_nmethod() {
164     return _barrier_set_nmethod;
165   }
166 
167   // The AccessBarrier of a BarrierSet subclass is called by the Access API
168   // (cf. oops/access.hpp) to perform decorated accesses. GC implementations
169   // may override these default access operations by declaring an
170   // AccessBarrier class in its BarrierSet. Its accessors will then be
171   // automatically resolved at runtime.
172   //
173   // In order to register a new FooBarrierSet::AccessBarrier with the Access API,
174   // the following steps should be taken:
175   // 1) Provide an enum &quot;name&quot; for the BarrierSet in barrierSetConfig.hpp
176   // 2) Make sure the barrier set headers are included from barrierSetConfig.inline.hpp
177   // 3) Provide specializations for BarrierSet::GetName and BarrierSet::GetType.
178   template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
179   class AccessBarrier: protected RawAccessBarrier&lt;decorators&gt; {
180   private:
181     typedef RawAccessBarrier&lt;decorators&gt; Raw;
182 
183   public:
184     // Primitive heap accesses. These accessors get resolved when
185     // IN_HEAP is set (e.g. when using the HeapAccess API), it is
186     // not an oop_* overload, and the barrier strength is AS_NORMAL.
187     template &lt;typename T&gt;
188     static T load_in_heap(T* addr) {
189       return Raw::template load&lt;T&gt;(addr);
190     }
191 
192     template &lt;typename T&gt;
193     static T load_in_heap_at(oop base, ptrdiff_t offset) {
194       return Raw::template load_at&lt;T&gt;(base, offset);
195     }
196 
197     template &lt;typename T&gt;
198     static void store_in_heap(T* addr, T value) {
199       Raw::store(addr, value);
200     }
201 
202     template &lt;typename T&gt;
203     static void store_in_heap_at(oop base, ptrdiff_t offset, T value) {
204       Raw::store_at(base, offset, value);
205     }
206 
207     template &lt;typename T&gt;
<a name="4" id="anc4"></a><span class="line-modified">208     static T atomic_cmpxchg_in_heap(T new_value, T* addr, T compare_value) {</span>
<span class="line-modified">209       return Raw::atomic_cmpxchg(new_value, addr, compare_value);</span>
210     }
211 
212     template &lt;typename T&gt;
<a name="5" id="anc5"></a><span class="line-modified">213     static T atomic_cmpxchg_in_heap_at(T new_value, oop base, ptrdiff_t offset, T compare_value) {</span>
<span class="line-modified">214       return Raw::atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
215     }
216 
217     template &lt;typename T&gt;
<a name="6" id="anc6"></a><span class="line-modified">218     static T atomic_xchg_in_heap(T new_value, T* addr) {</span>
<span class="line-modified">219       return Raw::atomic_xchg(new_value, addr);</span>
220     }
221 
222     template &lt;typename T&gt;
<a name="7" id="anc7"></a><span class="line-modified">223     static T atomic_xchg_in_heap_at(T new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">224       return Raw::atomic_xchg_at(new_value, base, offset);</span>
225     }
226 
227     template &lt;typename T&gt;
228     static void arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
229                                   arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
230                                   size_t length) {
231       Raw::arraycopy(src_obj, src_offset_in_bytes, src_raw,
232                      dst_obj, dst_offset_in_bytes, dst_raw,
233                      length);
234     }
235 
236     // Heap oop accesses. These accessors get resolved when
237     // IN_HEAP is set (e.g. when using the HeapAccess API), it is
238     // an oop_* overload, and the barrier strength is AS_NORMAL.
239     template &lt;typename T&gt;
240     static oop oop_load_in_heap(T* addr) {
241       return Raw::template oop_load&lt;oop&gt;(addr);
242     }
243 
244     static oop oop_load_in_heap_at(oop base, ptrdiff_t offset) {
245       return Raw::template oop_load_at&lt;oop&gt;(base, offset);
246     }
247 
248     template &lt;typename T&gt;
249     static void oop_store_in_heap(T* addr, oop value) {
250       Raw::oop_store(addr, value);
251     }
252 
253     static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {
254       Raw::oop_store_at(base, offset, value);
255     }
256 
257     template &lt;typename T&gt;
<a name="8" id="anc8"></a><span class="line-modified">258     static oop oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified">259       return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
260     }
261 
<a name="9" id="anc9"></a><span class="line-modified">262     static oop oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
<span class="line-modified">263       return Raw::oop_atomic_cmpxchg_at(new_value, base, offset, compare_value);</span>
264     }
265 
266     template &lt;typename T&gt;
<a name="10" id="anc10"></a><span class="line-modified">267     static oop oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified">268       return Raw::oop_atomic_xchg(new_value, addr);</span>
269     }
270 
<a name="11" id="anc11"></a><span class="line-modified">271     static oop oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {</span>
<span class="line-modified">272       return Raw::oop_atomic_xchg_at(new_value, base, offset);</span>
273     }
274 
275     template &lt;typename T&gt;
276     static bool oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,
277                                       arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,
278                                       size_t length);
279 
280     // Off-heap oop accesses. These accessors get resolved when
281     // IN_HEAP is not set (e.g. when using the NativeAccess API), it is
282     // an oop* overload, and the barrier strength is AS_NORMAL.
283     template &lt;typename T&gt;
284     static oop oop_load_not_in_heap(T* addr) {
285       return Raw::template oop_load&lt;oop&gt;(addr);
286     }
287 
288     template &lt;typename T&gt;
289     static void oop_store_not_in_heap(T* addr, oop value) {
290       Raw::oop_store(addr, value);
291     }
292 
293     template &lt;typename T&gt;
<a name="12" id="anc12"></a><span class="line-modified">294     static oop oop_atomic_cmpxchg_not_in_heap(oop new_value, T* addr, oop compare_value) {</span>
<span class="line-modified">295       return Raw::oop_atomic_cmpxchg(new_value, addr, compare_value);</span>
296     }
297 
298     template &lt;typename T&gt;
<a name="13" id="anc13"></a><span class="line-modified">299     static oop oop_atomic_xchg_not_in_heap(oop new_value, T* addr) {</span>
<span class="line-modified">300       return Raw::oop_atomic_xchg(new_value, addr);</span>
301     }
302 
303     // Clone barrier support
304     static void clone_in_heap(oop src, oop dst, size_t size) {
305       Raw::clone(src, dst, size);
306     }
307 
308     static oop resolve(oop obj) {
309       return Raw::resolve(obj);
310     }
<a name="14" id="anc14"></a><span class="line-removed">311 </span>
<span class="line-removed">312     static bool equals(oop o1, oop o2) {</span>
<span class="line-removed">313       return Raw::equals(o1, o2);</span>
<span class="line-removed">314     }</span>
315   };
316 };
317 
318 template&lt;typename T&gt;
319 inline T* barrier_set_cast(BarrierSet* bs) {
320   assert(bs-&gt;is_a(BarrierSet::GetName&lt;T&gt;::value), &quot;wrong type of barrier set&quot;);
321   return static_cast&lt;T*&gt;(bs);
322 }
323 
324 #endif // SHARE_GC_SHARED_BARRIERSET_HPP
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
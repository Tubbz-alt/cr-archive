<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/gcLocker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcConfiguration.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcLocker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,19 ***</span>
<span class="line-new-header">--- 24,21 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  
  volatile jint GCLocker::_jni_lock_count = 0;
  volatile bool GCLocker::_needs_gc       = false;
  volatile bool GCLocker::_doing_gc       = false;
<span class="line-added">+ unsigned int GCLocker::_total_collections = 0;</span>
  
  #ifdef ASSERT
  volatile jint GCLocker::_debug_jni_lock_count = 0;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,32 ***</span>
    return is_active();
  }
  
  void GCLocker::stall_until_clear() {
    assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
<span class="line-modified">!   MutexLocker   ml(JNICritical_lock);</span>
  
    if (needs_gc()) {
      log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
    }
  
    // Wait for _needs_gc  to be cleared
    while (needs_gc()) {
<span class="line-modified">!     JNICritical_lock-&gt;wait();</span>
    }
  }
  
  void GCLocker::jni_lock(JavaThread* thread) {
    assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
<span class="line-modified">!   MutexLocker mu(JNICritical_lock);</span>
    // Block entering threads if we know at least one thread is in a
    // JNI critical region and we need a GC.
    // We check that at least one thread is in a critical region before
    // blocking because blocked threads are woken up by a thread exiting
    // a JNI critical region.
    while (is_active_and_needs_gc() || _doing_gc) {
<span class="line-modified">!     JNICritical_lock-&gt;wait();</span>
    }
    thread-&gt;enter_critical();
    _jni_lock_count++;
    increment_debug_jni_lock_count();
  }
<span class="line-new-header">--- 102,37 ---</span>
    return is_active();
  }
  
  void GCLocker::stall_until_clear() {
    assert(!JavaThread::current()-&gt;in_critical(), &quot;Would deadlock&quot;);
<span class="line-modified">!   MonitorLocker ml(JNICritical_lock);</span>
  
    if (needs_gc()) {
      log_debug_jni(&quot;Allocation failed. Thread stalled by JNI critical section.&quot;);
    }
  
    // Wait for _needs_gc  to be cleared
    while (needs_gc()) {
<span class="line-modified">!     ml.wait();</span>
    }
  }
  
<span class="line-added">+ bool GCLocker::should_discard(GCCause::Cause cause, uint total_collections) {</span>
<span class="line-added">+   return (cause == GCCause::_gc_locker) &amp;&amp;</span>
<span class="line-added">+          (_total_collections != total_collections);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void GCLocker::jni_lock(JavaThread* thread) {
    assert(!thread-&gt;in_critical(), &quot;shouldn&#39;t currently be in a critical region&quot;);
<span class="line-modified">!   MonitorLocker ml(JNICritical_lock);</span>
    // Block entering threads if we know at least one thread is in a
    // JNI critical region and we need a GC.
    // We check that at least one thread is in a critical region before
    // blocking because blocked threads are woken up by a thread exiting
    // a JNI critical region.
    while (is_active_and_needs_gc() || _doing_gc) {
<span class="line-modified">!     ml.wait();</span>
    }
    thread-&gt;enter_critical();
    _jni_lock_count++;
    increment_debug_jni_lock_count();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,11 ***</span>
    MutexLocker mu(JNICritical_lock);
    _jni_lock_count--;
    decrement_debug_jni_lock_count();
    thread-&gt;exit_critical();
    if (needs_gc() &amp;&amp; !is_active_internal()) {
<span class="line-modified">!     // We&#39;re the last thread out. Cause a GC to occur.</span>
      _doing_gc = true;
      {
        // Must give up the lock while at a safepoint
        MutexUnlocker munlock(JNICritical_lock);
        log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
<span class="line-new-header">--- 142,17 ---</span>
    MutexLocker mu(JNICritical_lock);
    _jni_lock_count--;
    decrement_debug_jni_lock_count();
    thread-&gt;exit_critical();
    if (needs_gc() &amp;&amp; !is_active_internal()) {
<span class="line-modified">!     // We&#39;re the last thread out. Request a GC.</span>
<span class="line-added">+     // Capture the current total collections, to allow detection of</span>
<span class="line-added">+     // other collections that make this one unnecessary.  The value of</span>
<span class="line-added">+     // total_collections() is only changed at a safepoint, so there</span>
<span class="line-added">+     // must not be a safepoint between the lock becoming inactive and</span>
<span class="line-added">+     // getting the count, else there may be unnecessary GCLocker GCs.</span>
<span class="line-added">+     _total_collections = Universe::heap()-&gt;total_collections();</span>
      _doing_gc = true;
      {
        // Must give up the lock while at a safepoint
        MutexUnlocker munlock(JNICritical_lock);
        log_debug_jni(&quot;Performing GC after exiting critical section.&quot;);
</pre>
<center><a href="gcConfiguration.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gcLocker.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
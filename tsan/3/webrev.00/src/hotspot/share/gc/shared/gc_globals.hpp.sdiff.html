<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gc_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcVMOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gc_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GC_GLOBALS_HPP
 26 #define SHARE_GC_SHARED_GC_GLOBALS_HPP
 27 

 28 #include &quot;utilities/macros.hpp&quot;
<span class="line-removed"> 29 #if INCLUDE_CMSGC</span>
<span class="line-removed"> 30 #include &quot;gc/cms/cms_globals.hpp&quot;</span>
<span class="line-removed"> 31 #endif</span>
 32 #if INCLUDE_EPSILONGC
 33 #include &quot;gc/epsilon/epsilon_globals.hpp&quot;
 34 #endif
 35 #if INCLUDE_G1GC
 36 #include &quot;gc/g1/g1_globals.hpp&quot;
 37 #endif
 38 #if INCLUDE_PARALLELGC
 39 #include &quot;gc/parallel/parallel_globals.hpp&quot;
 40 #endif
 41 #if INCLUDE_SERIALGC
 42 #include &quot;gc/serial/serial_globals.hpp&quot;
 43 #endif
 44 #if INCLUDE_SHENANDOAHGC
 45 #include &quot;gc/shenandoah/shenandoah_globals.hpp&quot;
 46 #endif
 47 #if INCLUDE_ZGC
 48 #include &quot;gc/z/z_globals.hpp&quot;
 49 #endif
 50 
 51 #define GC_FLAGS(develop,                                                   \
 52                  develop_pd,                                                \
 53                  product,                                                   \
 54                  product_pd,                                                \
 55                  diagnostic,                                                \
 56                  diagnostic_pd,                                             \
 57                  experimental,                                              \
 58                  notproduct,                                                \
 59                  manageable,                                                \
 60                  product_rw,                                                \
 61                  lp64_product,                                              \
 62                  range,                                                     \
<span class="line-modified"> 63                  constraint,                                                \</span>
<span class="line-removed"> 64                  writeable)                                                 \</span>
<span class="line-removed"> 65                                                                             \</span>
<span class="line-removed"> 66   CMSGC_ONLY(GC_CMS_FLAGS(                                                  \</span>
<span class="line-removed"> 67     develop,                                                                \</span>
<span class="line-removed"> 68     develop_pd,                                                             \</span>
<span class="line-removed"> 69     product,                                                                \</span>
<span class="line-removed"> 70     product_pd,                                                             \</span>
<span class="line-removed"> 71     diagnostic,                                                             \</span>
<span class="line-removed"> 72     diagnostic_pd,                                                          \</span>
<span class="line-removed"> 73     experimental,                                                           \</span>
<span class="line-removed"> 74     notproduct,                                                             \</span>
<span class="line-removed"> 75     manageable,                                                             \</span>
<span class="line-removed"> 76     product_rw,                                                             \</span>
<span class="line-removed"> 77     lp64_product,                                                           \</span>
<span class="line-removed"> 78     range,                                                                  \</span>
<span class="line-removed"> 79     constraint,                                                             \</span>
<span class="line-removed"> 80     writeable))                                                             \</span>
 81                                                                             \
 82   EPSILONGC_ONLY(GC_EPSILON_FLAGS(                                          \
 83     develop,                                                                \
 84     develop_pd,                                                             \
 85     product,                                                                \
 86     product_pd,                                                             \
 87     diagnostic,                                                             \
 88     diagnostic_pd,                                                          \
 89     experimental,                                                           \
 90     notproduct,                                                             \
 91     manageable,                                                             \
 92     product_rw,                                                             \
 93     lp64_product,                                                           \
 94     range,                                                                  \
<span class="line-modified"> 95     constraint,                                                             \</span>
<span class="line-removed"> 96     writeable))                                                             \</span>
 97                                                                             \
 98   G1GC_ONLY(GC_G1_FLAGS(                                                    \
 99     develop,                                                                \
100     develop_pd,                                                             \
101     product,                                                                \
102     product_pd,                                                             \
103     diagnostic,                                                             \
104     diagnostic_pd,                                                          \
105     experimental,                                                           \
106     notproduct,                                                             \
107     manageable,                                                             \
108     product_rw,                                                             \
109     lp64_product,                                                           \
110     range,                                                                  \
<span class="line-modified">111     constraint,                                                             \</span>
<span class="line-removed">112     writeable))                                                             \</span>
113                                                                             \
114   PARALLELGC_ONLY(GC_PARALLEL_FLAGS(                                        \
115     develop,                                                                \
116     develop_pd,                                                             \
117     product,                                                                \
118     product_pd,                                                             \
119     diagnostic,                                                             \
120     diagnostic_pd,                                                          \
121     experimental,                                                           \
122     notproduct,                                                             \
123     manageable,                                                             \
124     product_rw,                                                             \
125     lp64_product,                                                           \
126     range,                                                                  \
<span class="line-modified">127     constraint,                                                             \</span>
<span class="line-removed">128     writeable))                                                             \</span>
129                                                                             \
130   SERIALGC_ONLY(GC_SERIAL_FLAGS(                                            \
131     develop,                                                                \
132     develop_pd,                                                             \
133     product,                                                                \
134     product_pd,                                                             \
135     diagnostic,                                                             \
136     diagnostic_pd,                                                          \
137     experimental,                                                           \
138     notproduct,                                                             \
139     manageable,                                                             \
140     product_rw,                                                             \
141     lp64_product,                                                           \
142     range,                                                                  \
<span class="line-modified">143     constraint,                                                             \</span>
<span class="line-removed">144     writeable))                                                             \</span>
145                                                                             \
146   SHENANDOAHGC_ONLY(GC_SHENANDOAH_FLAGS(                                    \
147     develop,                                                                \
148     develop_pd,                                                             \
149     product,                                                                \
150     product_pd,                                                             \
151     diagnostic,                                                             \
152     diagnostic_pd,                                                          \
153     experimental,                                                           \
154     notproduct,                                                             \
155     manageable,                                                             \
156     product_rw,                                                             \
157     lp64_product,                                                           \
158     range,                                                                  \
<span class="line-modified">159     constraint,                                                             \</span>
<span class="line-removed">160     writeable))                                                             \</span>
161                                                                             \
162   ZGC_ONLY(GC_Z_FLAGS(                                                      \
163     develop,                                                                \
164     develop_pd,                                                             \
165     product,                                                                \
166     product_pd,                                                             \
167     diagnostic,                                                             \
168     diagnostic_pd,                                                          \
169     experimental,                                                           \
170     notproduct,                                                             \
171     manageable,                                                             \
172     product_rw,                                                             \
173     lp64_product,                                                           \
174     range,                                                                  \
<span class="line-modified">175     constraint,                                                             \</span>
<span class="line-removed">176     writeable))                                                             \</span>
177                                                                             \
178   /* gc */                                                                  \
179                                                                             \
<span class="line-removed">180   product(bool, UseConcMarkSweepGC, false,                                  \</span>
<span class="line-removed">181           &quot;Use Concurrent Mark-Sweep GC in the old generation&quot;)             \</span>
<span class="line-removed">182                                                                             \</span>
183   product(bool, UseSerialGC, false,                                         \
184           &quot;Use the Serial garbage collector&quot;)                               \
185                                                                             \
186   product(bool, UseG1GC, false,                                             \
187           &quot;Use the Garbage-First garbage collector&quot;)                        \
188                                                                             \
189   product(bool, UseParallelGC, false,                                       \
<span class="line-modified">190           &quot;Use the Parallel Scavenge garbage collector&quot;)                    \</span>
<span class="line-removed">191                                                                             \</span>
<span class="line-removed">192   product(bool, UseParallelOldGC, false,                                    \</span>
<span class="line-removed">193           &quot;Use the Parallel Old garbage collector&quot;)                         \</span>
194                                                                             \
195   experimental(bool, UseEpsilonGC, false,                                   \
196           &quot;Use the Epsilon (no-op) garbage collector&quot;)                      \
197                                                                             \
198   experimental(bool, UseZGC, false,                                         \
199           &quot;Use the Z garbage collector&quot;)                                    \
200                                                                             \
201   experimental(bool, UseShenandoahGC, false,                                \
202           &quot;Use the Shenandoah garbage collector&quot;)                           \
203                                                                             \
204   product(uint, ParallelGCThreads, 0,                                       \
205           &quot;Number of parallel threads parallel gc will use&quot;)                \
206           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
207                                                                             \
208   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
209             &quot;Use semaphore synchronization for the GC Threads, &quot;            \
210             &quot;instead of synchronization based on mutexes&quot;)                  \
211                                                                             \
212   product(bool, UseDynamicNumberOfGCThreads, true,                          \
213           &quot;Dynamically choose the number of threads up to a maximum of &quot;    \
214           &quot;ParallelGCThreads parallel collectors will use for garbage &quot;     \
215           &quot;collection work&quot;)                                                \
216                                                                             \
217   diagnostic(bool, InjectGCWorkerCreationFailure, false,                    \
218              &quot;Inject thread creation failures for &quot;                         \
219              &quot;UseDynamicNumberOfGCThreads&quot;)                                 \
220                                                                             \
221   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
222           &quot;Force dynamic selection of the number of &quot;                       \
223           &quot;parallel threads parallel gc will use to aid debugging&quot;)         \
224                                                                             \
225   product(size_t, HeapSizePerGCThread, ScaleForWordSize(32*M),              \
226           &quot;Size of heap (bytes) per GC thread used in calculating the &quot;     \
227           &quot;number of GC threads&quot;)                                           \
228           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
229                                                                             \
230   product(uint, ConcGCThreads, 0,                                           \
231           &quot;Number of threads concurrent gc will use&quot;)                       \
232           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
233                                                                             \
<span class="line-removed">234   product(uint, GCTaskTimeStampEntries, 200,                                \</span>
<span class="line-removed">235           &quot;Number of time stamp entries per gc worker thread&quot;)              \</span>
<span class="line-removed">236           range(1, max_jint)                                                \</span>
<span class="line-removed">237                                                                             \</span>
238   product(bool, AlwaysTenure, false,                                        \
239           &quot;Always tenure objects in eden (ParallelGC only)&quot;)                \
240                                                                             \
241   product(bool, NeverTenure, false,                                         \
242           &quot;Never tenure objects in eden, may tenure on overflow &quot;           \
243           &quot;(ParallelGC only)&quot;)                                              \
244                                                                             \
245   product(bool, ScavengeBeforeFullGC, true,                                 \
246           &quot;Scavenge youngest generation before each full GC.&quot;)              \
247                                                                             \
248   product(bool, ExplicitGCInvokesConcurrent, false,                         \
249           &quot;A System.gc() request invokes a concurrent collection; &quot;         \
250           &quot;(effective only when using concurrent collectors)&quot;)              \
251                                                                             \
<span class="line-removed">252   product(bool, GCLockerInvokesConcurrent, false,                           \</span>
<span class="line-removed">253           &quot;The exit of a JNI critical section necessitating a scavenge, &quot;   \</span>
<span class="line-removed">254           &quot;also kicks off a background concurrent collection&quot;)              \</span>
<span class="line-removed">255                                                                             \</span>
256   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
257           &quot;How much the GC can expand the eden by while the GC locker &quot;     \
258           &quot;is active (as a percentage)&quot;)                                    \
259           range(0, 100)                                                     \
260                                                                             \
261   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
262           &quot;Number of times to retry allocations when &quot;                      \
263           &quot;blocked by the GC locker&quot;)                                       \
264           range(0, max_uintx)                                               \
265                                                                             \
266   product(uintx, ParallelGCBufferWastePct, 10,                              \
267           &quot;Wasted fraction of parallel allocation buffer&quot;)                  \
268           range(0, 100)                                                     \
269                                                                             \
270   product(uintx, TargetPLABWastePct, 10,                                    \
271           &quot;Target wasted space in last buffer as percent of overall &quot;       \
272           &quot;allocation&quot;)                                                     \
273           range(1, 100)                                                     \
274                                                                             \
275   product(uintx, PLABWeight, 75,                                            \
276           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
277           &quot;computing exponentially decaying average for ResizePLAB&quot;)        \
278           range(0, 100)                                                     \
279                                                                             \
280   product(bool, ResizePLAB, true,                                           \
281           &quot;Dynamically resize (survivor space) promotion LAB&#39;s&quot;)            \
282                                                                             \
283   product(int, ParGCArrayScanChunk, 50,                                     \
284           &quot;Scan a subset of object array and push remainder, if array is &quot;  \
285           &quot;bigger than this&quot;)                                               \
286           range(1, max_jint/3)                                              \
287                                                                             \
<span class="line-removed">288   product(uintx, OldPLABWeight, 50,                                         \</span>
<span class="line-removed">289           &quot;Percentage (0-100) used to weight the current sample when &quot;      \</span>
<span class="line-removed">290           &quot;computing exponentially decaying average for resizing &quot;          \</span>
<span class="line-removed">291           &quot;OldPLABSize&quot;)                                                    \</span>
<span class="line-removed">292           range(0, 100)                                                     \</span>
<span class="line-removed">293                                                                             \</span>
<span class="line-removed">294   product(bool, ResizeOldPLAB, true,                                        \</span>
<span class="line-removed">295           &quot;Dynamically resize (old gen) promotion LAB&#39;s&quot;)                   \</span>
296                                                                             \
297   product(bool, AlwaysPreTouch, false,                                      \
298           &quot;Force all freshly committed pages to be pre-touched&quot;)            \
299                                                                             \
300   product(size_t, PreTouchParallelChunkSize, 1 * G,                         \
301           &quot;Per-thread chunk size for parallel memory pre-touch.&quot;)           \
302           range(1, SIZE_MAX / 2)                                            \
303                                                                             \
304   /* where does the range max value of (max_jint - 1) come from? */         \
305   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
306           &quot;Maximum size of marking stack&quot;)                                  \
307           range(1, (max_jint - 1))                                          \
308                                                                             \
309   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
310           &quot;Size of marking stack&quot;)                                          \
311           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
312                                                                             \
<span class="line-removed">313   develop(bool, VerifyBlockOffsetArray, false,                              \</span>
<span class="line-removed">314           &quot;Do (expensive) block offset array verification&quot;)                 \</span>
<span class="line-removed">315                                                                             \</span>
<span class="line-removed">316   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \</span>
<span class="line-removed">317           &quot;Maintain _unallocated_block in BlockOffsetArray &quot;                \</span>
<span class="line-removed">318           &quot;(currently applicable only to CMS collector)&quot;)                   \</span>
<span class="line-removed">319                                                                             \</span>
320   product(intx, RefDiscoveryPolicy, 0,                                      \
321           &quot;Select type of reference discovery policy: &quot;                     \
322           &quot;reference-based(0) or referent-based(1)&quot;)                        \
323           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
324                 ReferenceProcessor::DiscoveryPolicyMax)                     \
325                                                                             \
326   product(bool, ParallelRefProcEnabled, false,                              \
327           &quot;Enable parallel reference processing whenever possible&quot;)         \
328                                                                             \
329   product(bool, ParallelRefProcBalancingEnabled, true,                      \
330           &quot;Enable balancing of reference processing queues&quot;)                \
331                                                                             \
332   experimental(size_t, ReferencesPerThread, 1000,                           \
333                &quot;Ergonomically start one thread for this amount of &quot;         \
334                &quot;references for reference processing if &quot;                    \
335                &quot;ParallelRefProcEnabled is true. Specify 0 to disable and &quot;  \
336                &quot;use all threads.&quot;)                                          \
337                                                                             \
338   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
339           &quot;The percent occupancy (IHOP) of the current old generation &quot;     \
</pre>
<hr />
<pre>
346           &quot;Fragmentation waste in the old generation is not considered &quot;    \
347           &quot;free space in this calculation. (G1 collector only)&quot;)            \
348           range(0, 100)                                                     \
349                                                                             \
350   notproduct(bool, ScavengeALot, false,                                     \
351           &quot;Force scavenge at every Nth exit from the runtime system &quot;       \
352           &quot;(N=ScavengeALotInterval)&quot;)                                       \
353                                                                             \
354   develop(bool, FullGCALot, false,                                          \
355           &quot;Force full gc at every Nth exit from the runtime system &quot;        \
356           &quot;(N=FullGCALotInterval)&quot;)                                         \
357                                                                             \
358   notproduct(bool, GCALotAtAllSafepoints, false,                            \
359           &quot;Enforce ScavengeALot/GCALot at all potential safepoints&quot;)        \
360                                                                             \
361   notproduct(bool, PromotionFailureALot, false,                             \
362           &quot;Use promotion failure handling on every youngest generation &quot;    \
363           &quot;collection&quot;)                                                     \
364                                                                             \
365   develop(uintx, PromotionFailureALotCount, 1000,                           \
<span class="line-modified">366           &quot;Number of promotion failures occurring at PLAB &quot;                 \</span>
<span class="line-modified">367           &quot;refill attempts (ParNew) or promotion attempts &quot;                 \</span>
<span class="line-removed">368           &quot;(other young collectors)&quot;)                                       \</span>
369                                                                             \
370   develop(uintx, PromotionFailureALotInterval, 5,                           \
371           &quot;Total collections between promotion failures a lot&quot;)             \
372                                                                             \
<span class="line-removed">373   diagnostic(bool, UseOWSTTaskTerminator, true,                             \</span>
<span class="line-removed">374           &quot;Use Optimized Work Stealing Threads task termination &quot;           \</span>
<span class="line-removed">375           &quot;protocol&quot;)                                                       \</span>
<span class="line-removed">376                                                                             \</span>
377   experimental(uintx, WorkStealingSleepMillis, 1,                           \
378           &quot;Sleep time when sleep is used for yields&quot;)                       \
379                                                                             \
380   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
381           &quot;Number of yields before a sleep is done during work stealing&quot;)   \
382                                                                             \
383   experimental(uintx, WorkStealingHardSpins, 4096,                          \
384           &quot;Number of iterations in a spin loop between checks on &quot;          \
385           &quot;time out of hard spin&quot;)                                          \
386                                                                             \
387   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
388           &quot;Ratio of hard spins to calls to yield&quot;)                          \
389                                                                             \
390   develop(uintx, ObjArrayMarkingStride, 2048,                               \
391           &quot;Number of object array elements to push onto the marking stack &quot; \
392           &quot;before pushing a continuation entry&quot;)                            \
393                                                                             \
394   develop(bool, MetadataAllocationFailALot, false,                          \
395           &quot;Fail metadata allocations at intervals controlled by &quot;           \
396           &quot;MetadataAllocationFailALotInterval&quot;)                             \
</pre>
<hr />
<pre>
662                                                                             \
663   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
664           &quot;Enable parallel memory system verification&quot;)                     \
665                                                                             \
666   diagnostic(bool, DeferInitialCardMark, false,                             \
667           &quot;When +ReduceInitialCardMarks, explicitly defer any that &quot;        \
668           &quot;may arise from new_pre_store_barrier&quot;)                           \
669                                                                             \
670   product(bool, UseCondCardMark, false,                                     \
671           &quot;Check for already marked card before updating card table&quot;)       \
672                                                                             \
673   diagnostic(bool, VerifyRememberedSets, false,                             \
674           &quot;Verify GC remembered sets&quot;)                                      \
675                                                                             \
676   diagnostic(bool, VerifyObjectStartArray, true,                            \
677           &quot;Verify GC object start array if verify before/after&quot;)            \
678                                                                             \
679   product(bool, DisableExplicitGC, false,                                   \
680           &quot;Ignore calls to System.gc()&quot;)                                    \
681                                                                             \
<span class="line-removed">682   product(bool, BindGCTaskThreadsToCPUs, false,                             \</span>
<span class="line-removed">683           &quot;Bind GCTaskThreads to CPUs if possible&quot;)                         \</span>
<span class="line-removed">684                                                                             \</span>
<span class="line-removed">685   product(bool, UseGCTaskAffinity, false,                                   \</span>
<span class="line-removed">686           &quot;Use worker affinity when asking for GCTasks&quot;)                    \</span>
<span class="line-removed">687                                                                             \</span>
688   product(bool, PrintGC, false,                                             \
689           &quot;Print message at garbage collection. &quot;                           \
690           &quot;Deprecated, use -Xlog:gc instead.&quot;)                              \
691                                                                             \
692   product(bool, PrintGCDetails, false,                                      \
693           &quot;Print more details at garbage collection. &quot;                      \
694           &quot;Deprecated, use -Xlog:gc* instead.&quot;)                             \
695                                                                             \
696   develop(intx, ConcGCYieldTimeout, 0,                                      \
697           &quot;If non-zero, assert that GC threads yield within this &quot;          \
698           &quot;number of milliseconds&quot;)                                         \
699           range(0, max_intx)                                                \
700                                                                             \
701   notproduct(intx, ScavengeALotInterval,     1,                             \
702           &quot;Interval between which scavenge will occur with +ScavengeALot&quot;)  \
703                                                                             \
704   notproduct(intx, FullGCALotInterval,     1,                               \
705           &quot;Interval between which full gc will occur with +FullGCALot&quot;)     \
706                                                                             \
707   notproduct(intx, FullGCALotStart,     0,                                  \
708           &quot;For which invocation to start FullGCAlot&quot;)                       \
709                                                                             \
710   notproduct(intx, FullGCALotDummies,  32*K,                                \
711           &quot;Dummy object allocated with +FullGCALot, forcing all objects &quot;   \
712           &quot;to move&quot;)                                                        \
713                                                                             \
714   /* gc parameters */                                                       \




715   product(size_t, InitialHeapSize, 0,                                       \
716           &quot;Initial heap size (in bytes); zero means use ergonomics&quot;)        \
717           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
718                                                                             \
719   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
720           &quot;Maximum heap size (in bytes)&quot;)                                   \
721           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
722                                                                             \




723   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
724           &quot;Initial tenured generation size (in bytes)&quot;)                     \
725           range(0, max_uintx)                                               \
726                                                                             \
727   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
728           &quot;Initial new generation size (in bytes)&quot;)                         \
729           constraint(NewSizeConstraintFunc,AfterErgo)                       \
730                                                                             \
731   product(size_t, MaxNewSize, max_uintx,                                    \
732           &quot;Maximum new generation size (in bytes), max_uintx means set &quot;    \
733           &quot;ergonomically&quot;)                                                  \
734           range(0, max_uintx)                                               \
735                                                                             \
736   product_pd(size_t, HeapBaseMinAddress,                                    \
737           &quot;OS specific low limit for heap base address&quot;)                    \
738           constraint(HeapBaseMinAddressConstraintFunc,AfterErgo)            \
739                                                                             \
740   product(size_t, PretenureSizeThreshold, 0,                                \
741           &quot;Maximum size in bytes of objects allocated in DefNew &quot;           \
742           &quot;generation; zero means no maximum&quot;)                              \
743           range(0, max_uintx)                                               \
744                                                                             \
745   product(size_t, MinTLABSize, 2*K,                                         \
746           &quot;Minimum allowed TLAB size (in bytes)&quot;)                           \
747           range(1, max_uintx/2)                                             \
748           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
749                                                                             \
750   product(size_t, TLABSize, 0,                                              \
751           &quot;Starting TLAB size (in bytes); zero means set ergonomically&quot;)    \
752           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
753                                                                             \
754   product(size_t, YoungPLABSize, 4096,                                      \
755           &quot;Size of young gen promotion LAB&#39;s (in HeapWords)&quot;)               \
756           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
757                                                                             \
758   product(size_t, OldPLABSize, 1024,                                        \
<span class="line-modified">759           &quot;Size of old gen promotion LAB&#39;s (in HeapWords), or Number &quot;      \</span>
<span class="line-removed">760           &quot;of blocks to attempt to claim when refilling CMS LAB&#39;s&quot;)         \</span>
761           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
762                                                                             \
763   product(uintx, TLABAllocationWeight, 35,                                  \
764           &quot;Allocation averaging weight&quot;)                                    \
765           range(0, 100)                                                     \
766                                                                             \
767   /* Limit the lower bound of this flag to 1 as it is used  */              \
768   /* in a division expression.                              */              \
769   product(uintx, TLABWasteTargetPercent, 1,                                 \
770           &quot;Percentage of Eden that can be wasted&quot;)                          \
771           range(1, 100)                                                     \
772                                                                             \
773   product(uintx, TLABRefillWasteFraction,    64,                            \
774           &quot;Maximum TLAB waste at a refill (internal fragmentation)&quot;)        \
775           range(1, max_juint)                                               \
776                                                                             \
777   product(uintx, TLABWasteIncrement,    4,                                  \
778           &quot;Increment allowed waste at slow allocation&quot;)                     \
779           range(0, max_jint)                                                \
780           constraint(TLABWasteIncrementConstraintFunc,AfterMemoryInit)      \
</pre>
<hr />
<pre>
791   product_pd(size_t, NewSizeThreadIncrease,                                 \
792           &quot;Additional size added to desired new generation size per &quot;       \
793           &quot;non-daemon thread (in bytes)&quot;)                                   \
794           range(0, max_uintx)                                               \
795                                                                             \
796   product(uintx, QueuedAllocationWarningCount, 0,                           \
797           &quot;Number of times an allocation that queues behind a GC &quot;          \
798           &quot;will retry before printing a warning&quot;)                           \
799           range(0, max_uintx)                                               \
800                                                                             \
801   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
802           &quot;GC invoke count where +VerifyBefore/AfterGC kicks in&quot;)           \
803           range(0, max_uintx)                                               \
804                                                                             \
805   diagnostic(intx, VerifyGCLevel,     0,                                    \
806           &quot;Generation level at which to start +VerifyBefore/AfterGC&quot;)       \
807           range(0, 1)                                                       \
808                                                                             \
809   product(uintx, MaxTenuringThreshold,    15,                               \
810           &quot;Maximum value for tenuring threshold&quot;)                           \
<span class="line-modified">811           range(0, markOopDesc::max_age + 1)                                \</span>
812           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
813                                                                             \
814   product(uintx, InitialTenuringThreshold,    7,                            \
815           &quot;Initial value for tenuring threshold&quot;)                           \
<span class="line-modified">816           range(0, markOopDesc::max_age + 1)                                \</span>
817           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
818                                                                             \
819   product(uintx, TargetSurvivorRatio,    50,                                \
820           &quot;Desired percentage of survivor space used after scavenge&quot;)       \
821           range(0, 100)                                                     \
822                                                                             \
823   product(uintx, MarkSweepDeadRatio,     5,                                 \
824           &quot;Percentage (0-100) of the old gen allowed as dead wood. &quot;        \
825           &quot;Serial mark sweep treats this as both the minimum and maximum &quot;  \
826           &quot;value. &quot;                                                         \
<span class="line-removed">827           &quot;CMS uses this value only if it falls back to mark sweep. &quot;       \</span>
828           &quot;Par compact uses a variable scale based on the density of the &quot;  \
829           &quot;generation and treats this as the maximum value when the heap &quot;  \
830           &quot;is either completely full or completely empty.  Par compact &quot;    \
831           &quot;also has a smaller default value; see arguments.cpp.&quot;)           \
832           range(0, 100)                                                     \
833                                                                             \
834   product(uint, MarkSweepAlwaysCompactCount,     4,                         \
835           &quot;How often should we fully compact the heap (ignoring the dead &quot;  \
836           &quot;space parameters)&quot;)                                              \
837           range(1, max_juint)                                               \
838                                                                             \
839   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
840           &quot;Delay between expansion and allocation (in milliseconds)&quot;)       \
841                                                                             \
842   product(uintx, GCDrainStackTargetSize, 64,                                \
843           &quot;Number of entries we will try to leave on the stack &quot;            \
844           &quot;during parallel gc&quot;)                                             \
845           range(0, max_juint)
846 
847 #endif // SHARE_GC_SHARED_GC_GLOBALS_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GC_GLOBALS_HPP
 26 #define SHARE_GC_SHARED_GC_GLOBALS_HPP
 27 
<span class="line-added"> 28 #include &quot;runtime/globals_shared.hpp&quot;</span>
 29 #include &quot;utilities/macros.hpp&quot;



 30 #if INCLUDE_EPSILONGC
 31 #include &quot;gc/epsilon/epsilon_globals.hpp&quot;
 32 #endif
 33 #if INCLUDE_G1GC
 34 #include &quot;gc/g1/g1_globals.hpp&quot;
 35 #endif
 36 #if INCLUDE_PARALLELGC
 37 #include &quot;gc/parallel/parallel_globals.hpp&quot;
 38 #endif
 39 #if INCLUDE_SERIALGC
 40 #include &quot;gc/serial/serial_globals.hpp&quot;
 41 #endif
 42 #if INCLUDE_SHENANDOAHGC
 43 #include &quot;gc/shenandoah/shenandoah_globals.hpp&quot;
 44 #endif
 45 #if INCLUDE_ZGC
 46 #include &quot;gc/z/z_globals.hpp&quot;
 47 #endif
 48 
 49 #define GC_FLAGS(develop,                                                   \
 50                  develop_pd,                                                \
 51                  product,                                                   \
 52                  product_pd,                                                \
 53                  diagnostic,                                                \
 54                  diagnostic_pd,                                             \
 55                  experimental,                                              \
 56                  notproduct,                                                \
 57                  manageable,                                                \
 58                  product_rw,                                                \
 59                  lp64_product,                                              \
 60                  range,                                                     \
<span class="line-modified"> 61                  constraint)                                                \</span>

















 62                                                                             \
 63   EPSILONGC_ONLY(GC_EPSILON_FLAGS(                                          \
 64     develop,                                                                \
 65     develop_pd,                                                             \
 66     product,                                                                \
 67     product_pd,                                                             \
 68     diagnostic,                                                             \
 69     diagnostic_pd,                                                          \
 70     experimental,                                                           \
 71     notproduct,                                                             \
 72     manageable,                                                             \
 73     product_rw,                                                             \
 74     lp64_product,                                                           \
 75     range,                                                                  \
<span class="line-modified"> 76     constraint))                                                            \</span>

 77                                                                             \
 78   G1GC_ONLY(GC_G1_FLAGS(                                                    \
 79     develop,                                                                \
 80     develop_pd,                                                             \
 81     product,                                                                \
 82     product_pd,                                                             \
 83     diagnostic,                                                             \
 84     diagnostic_pd,                                                          \
 85     experimental,                                                           \
 86     notproduct,                                                             \
 87     manageable,                                                             \
 88     product_rw,                                                             \
 89     lp64_product,                                                           \
 90     range,                                                                  \
<span class="line-modified"> 91     constraint))                                                            \</span>

 92                                                                             \
 93   PARALLELGC_ONLY(GC_PARALLEL_FLAGS(                                        \
 94     develop,                                                                \
 95     develop_pd,                                                             \
 96     product,                                                                \
 97     product_pd,                                                             \
 98     diagnostic,                                                             \
 99     diagnostic_pd,                                                          \
100     experimental,                                                           \
101     notproduct,                                                             \
102     manageable,                                                             \
103     product_rw,                                                             \
104     lp64_product,                                                           \
105     range,                                                                  \
<span class="line-modified">106     constraint))                                                            \</span>

107                                                                             \
108   SERIALGC_ONLY(GC_SERIAL_FLAGS(                                            \
109     develop,                                                                \
110     develop_pd,                                                             \
111     product,                                                                \
112     product_pd,                                                             \
113     diagnostic,                                                             \
114     diagnostic_pd,                                                          \
115     experimental,                                                           \
116     notproduct,                                                             \
117     manageable,                                                             \
118     product_rw,                                                             \
119     lp64_product,                                                           \
120     range,                                                                  \
<span class="line-modified">121     constraint))                                                            \</span>

122                                                                             \
123   SHENANDOAHGC_ONLY(GC_SHENANDOAH_FLAGS(                                    \
124     develop,                                                                \
125     develop_pd,                                                             \
126     product,                                                                \
127     product_pd,                                                             \
128     diagnostic,                                                             \
129     diagnostic_pd,                                                          \
130     experimental,                                                           \
131     notproduct,                                                             \
132     manageable,                                                             \
133     product_rw,                                                             \
134     lp64_product,                                                           \
135     range,                                                                  \
<span class="line-modified">136     constraint))                                                            \</span>

137                                                                             \
138   ZGC_ONLY(GC_Z_FLAGS(                                                      \
139     develop,                                                                \
140     develop_pd,                                                             \
141     product,                                                                \
142     product_pd,                                                             \
143     diagnostic,                                                             \
144     diagnostic_pd,                                                          \
145     experimental,                                                           \
146     notproduct,                                                             \
147     manageable,                                                             \
148     product_rw,                                                             \
149     lp64_product,                                                           \
150     range,                                                                  \
<span class="line-modified">151     constraint))                                                            \</span>

152                                                                             \
153   /* gc */                                                                  \
154                                                                             \



155   product(bool, UseSerialGC, false,                                         \
156           &quot;Use the Serial garbage collector&quot;)                               \
157                                                                             \
158   product(bool, UseG1GC, false,                                             \
159           &quot;Use the Garbage-First garbage collector&quot;)                        \
160                                                                             \
161   product(bool, UseParallelGC, false,                                       \
<span class="line-modified">162           &quot;Use the Parallel garbage collector.&quot;)                            \</span>



163                                                                             \
164   experimental(bool, UseEpsilonGC, false,                                   \
165           &quot;Use the Epsilon (no-op) garbage collector&quot;)                      \
166                                                                             \
167   experimental(bool, UseZGC, false,                                         \
168           &quot;Use the Z garbage collector&quot;)                                    \
169                                                                             \
170   experimental(bool, UseShenandoahGC, false,                                \
171           &quot;Use the Shenandoah garbage collector&quot;)                           \
172                                                                             \
173   product(uint, ParallelGCThreads, 0,                                       \
174           &quot;Number of parallel threads parallel gc will use&quot;)                \
175           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
176                                                                             \
177   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
178             &quot;Use semaphore synchronization for the GC Threads, &quot;            \
179             &quot;instead of synchronization based on mutexes&quot;)                  \
180                                                                             \
181   product(bool, UseDynamicNumberOfGCThreads, true,                          \
182           &quot;Dynamically choose the number of threads up to a maximum of &quot;    \
183           &quot;ParallelGCThreads parallel collectors will use for garbage &quot;     \
184           &quot;collection work&quot;)                                                \
185                                                                             \
186   diagnostic(bool, InjectGCWorkerCreationFailure, false,                    \
187              &quot;Inject thread creation failures for &quot;                         \
188              &quot;UseDynamicNumberOfGCThreads&quot;)                                 \
189                                                                             \
190   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
191           &quot;Force dynamic selection of the number of &quot;                       \
192           &quot;parallel threads parallel gc will use to aid debugging&quot;)         \
193                                                                             \
194   product(size_t, HeapSizePerGCThread, ScaleForWordSize(32*M),              \
195           &quot;Size of heap (bytes) per GC thread used in calculating the &quot;     \
196           &quot;number of GC threads&quot;)                                           \
197           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
198                                                                             \
199   product(uint, ConcGCThreads, 0,                                           \
200           &quot;Number of threads concurrent gc will use&quot;)                       \
201           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
202                                                                             \




203   product(bool, AlwaysTenure, false,                                        \
204           &quot;Always tenure objects in eden (ParallelGC only)&quot;)                \
205                                                                             \
206   product(bool, NeverTenure, false,                                         \
207           &quot;Never tenure objects in eden, may tenure on overflow &quot;           \
208           &quot;(ParallelGC only)&quot;)                                              \
209                                                                             \
210   product(bool, ScavengeBeforeFullGC, true,                                 \
211           &quot;Scavenge youngest generation before each full GC.&quot;)              \
212                                                                             \
213   product(bool, ExplicitGCInvokesConcurrent, false,                         \
214           &quot;A System.gc() request invokes a concurrent collection; &quot;         \
215           &quot;(effective only when using concurrent collectors)&quot;)              \
216                                                                             \




217   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
218           &quot;How much the GC can expand the eden by while the GC locker &quot;     \
219           &quot;is active (as a percentage)&quot;)                                    \
220           range(0, 100)                                                     \
221                                                                             \
222   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
223           &quot;Number of times to retry allocations when &quot;                      \
224           &quot;blocked by the GC locker&quot;)                                       \
225           range(0, max_uintx)                                               \
226                                                                             \
227   product(uintx, ParallelGCBufferWastePct, 10,                              \
228           &quot;Wasted fraction of parallel allocation buffer&quot;)                  \
229           range(0, 100)                                                     \
230                                                                             \
231   product(uintx, TargetPLABWastePct, 10,                                    \
232           &quot;Target wasted space in last buffer as percent of overall &quot;       \
233           &quot;allocation&quot;)                                                     \
234           range(1, 100)                                                     \
235                                                                             \
236   product(uintx, PLABWeight, 75,                                            \
237           &quot;Percentage (0-100) used to weight the current sample when &quot;      \
238           &quot;computing exponentially decaying average for ResizePLAB&quot;)        \
239           range(0, 100)                                                     \
240                                                                             \
241   product(bool, ResizePLAB, true,                                           \
242           &quot;Dynamically resize (survivor space) promotion LAB&#39;s&quot;)            \
243                                                                             \
244   product(int, ParGCArrayScanChunk, 50,                                     \
245           &quot;Scan a subset of object array and push remainder, if array is &quot;  \
246           &quot;bigger than this&quot;)                                               \
247           range(1, max_jint/3)                                              \
248                                                                             \








249                                                                             \
250   product(bool, AlwaysPreTouch, false,                                      \
251           &quot;Force all freshly committed pages to be pre-touched&quot;)            \
252                                                                             \
253   product(size_t, PreTouchParallelChunkSize, 1 * G,                         \
254           &quot;Per-thread chunk size for parallel memory pre-touch.&quot;)           \
255           range(1, SIZE_MAX / 2)                                            \
256                                                                             \
257   /* where does the range max value of (max_jint - 1) come from? */         \
258   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
259           &quot;Maximum size of marking stack&quot;)                                  \
260           range(1, (max_jint - 1))                                          \
261                                                                             \
262   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
263           &quot;Size of marking stack&quot;)                                          \
264           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
265                                                                             \







266   product(intx, RefDiscoveryPolicy, 0,                                      \
267           &quot;Select type of reference discovery policy: &quot;                     \
268           &quot;reference-based(0) or referent-based(1)&quot;)                        \
269           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
270                 ReferenceProcessor::DiscoveryPolicyMax)                     \
271                                                                             \
272   product(bool, ParallelRefProcEnabled, false,                              \
273           &quot;Enable parallel reference processing whenever possible&quot;)         \
274                                                                             \
275   product(bool, ParallelRefProcBalancingEnabled, true,                      \
276           &quot;Enable balancing of reference processing queues&quot;)                \
277                                                                             \
278   experimental(size_t, ReferencesPerThread, 1000,                           \
279                &quot;Ergonomically start one thread for this amount of &quot;         \
280                &quot;references for reference processing if &quot;                    \
281                &quot;ParallelRefProcEnabled is true. Specify 0 to disable and &quot;  \
282                &quot;use all threads.&quot;)                                          \
283                                                                             \
284   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
285           &quot;The percent occupancy (IHOP) of the current old generation &quot;     \
</pre>
<hr />
<pre>
292           &quot;Fragmentation waste in the old generation is not considered &quot;    \
293           &quot;free space in this calculation. (G1 collector only)&quot;)            \
294           range(0, 100)                                                     \
295                                                                             \
296   notproduct(bool, ScavengeALot, false,                                     \
297           &quot;Force scavenge at every Nth exit from the runtime system &quot;       \
298           &quot;(N=ScavengeALotInterval)&quot;)                                       \
299                                                                             \
300   develop(bool, FullGCALot, false,                                          \
301           &quot;Force full gc at every Nth exit from the runtime system &quot;        \
302           &quot;(N=FullGCALotInterval)&quot;)                                         \
303                                                                             \
304   notproduct(bool, GCALotAtAllSafepoints, false,                            \
305           &quot;Enforce ScavengeALot/GCALot at all potential safepoints&quot;)        \
306                                                                             \
307   notproduct(bool, PromotionFailureALot, false,                             \
308           &quot;Use promotion failure handling on every youngest generation &quot;    \
309           &quot;collection&quot;)                                                     \
310                                                                             \
311   develop(uintx, PromotionFailureALotCount, 1000,                           \
<span class="line-modified">312           &quot;Number of promotion failures occurring at PLAB promotion &quot;       \</span>
<span class="line-modified">313           &quot;attempts at young collectors&quot;)                                   \</span>

314                                                                             \
315   develop(uintx, PromotionFailureALotInterval, 5,                           \
316           &quot;Total collections between promotion failures a lot&quot;)             \
317                                                                             \




318   experimental(uintx, WorkStealingSleepMillis, 1,                           \
319           &quot;Sleep time when sleep is used for yields&quot;)                       \
320                                                                             \
321   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
322           &quot;Number of yields before a sleep is done during work stealing&quot;)   \
323                                                                             \
324   experimental(uintx, WorkStealingHardSpins, 4096,                          \
325           &quot;Number of iterations in a spin loop between checks on &quot;          \
326           &quot;time out of hard spin&quot;)                                          \
327                                                                             \
328   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
329           &quot;Ratio of hard spins to calls to yield&quot;)                          \
330                                                                             \
331   develop(uintx, ObjArrayMarkingStride, 2048,                               \
332           &quot;Number of object array elements to push onto the marking stack &quot; \
333           &quot;before pushing a continuation entry&quot;)                            \
334                                                                             \
335   develop(bool, MetadataAllocationFailALot, false,                          \
336           &quot;Fail metadata allocations at intervals controlled by &quot;           \
337           &quot;MetadataAllocationFailALotInterval&quot;)                             \
</pre>
<hr />
<pre>
603                                                                             \
604   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
605           &quot;Enable parallel memory system verification&quot;)                     \
606                                                                             \
607   diagnostic(bool, DeferInitialCardMark, false,                             \
608           &quot;When +ReduceInitialCardMarks, explicitly defer any that &quot;        \
609           &quot;may arise from new_pre_store_barrier&quot;)                           \
610                                                                             \
611   product(bool, UseCondCardMark, false,                                     \
612           &quot;Check for already marked card before updating card table&quot;)       \
613                                                                             \
614   diagnostic(bool, VerifyRememberedSets, false,                             \
615           &quot;Verify GC remembered sets&quot;)                                      \
616                                                                             \
617   diagnostic(bool, VerifyObjectStartArray, true,                            \
618           &quot;Verify GC object start array if verify before/after&quot;)            \
619                                                                             \
620   product(bool, DisableExplicitGC, false,                                   \
621           &quot;Ignore calls to System.gc()&quot;)                                    \
622                                                                             \






623   product(bool, PrintGC, false,                                             \
624           &quot;Print message at garbage collection. &quot;                           \
625           &quot;Deprecated, use -Xlog:gc instead.&quot;)                              \
626                                                                             \
627   product(bool, PrintGCDetails, false,                                      \
628           &quot;Print more details at garbage collection. &quot;                      \
629           &quot;Deprecated, use -Xlog:gc* instead.&quot;)                             \
630                                                                             \
631   develop(intx, ConcGCYieldTimeout, 0,                                      \
632           &quot;If non-zero, assert that GC threads yield within this &quot;          \
633           &quot;number of milliseconds&quot;)                                         \
634           range(0, max_intx)                                                \
635                                                                             \
636   notproduct(intx, ScavengeALotInterval,     1,                             \
637           &quot;Interval between which scavenge will occur with +ScavengeALot&quot;)  \
638                                                                             \
639   notproduct(intx, FullGCALotInterval,     1,                               \
640           &quot;Interval between which full gc will occur with +FullGCALot&quot;)     \
641                                                                             \
642   notproduct(intx, FullGCALotStart,     0,                                  \
643           &quot;For which invocation to start FullGCAlot&quot;)                       \
644                                                                             \
645   notproduct(intx, FullGCALotDummies,  32*K,                                \
646           &quot;Dummy object allocated with +FullGCALot, forcing all objects &quot;   \
647           &quot;to move&quot;)                                                        \
648                                                                             \
649   /* gc parameters */                                                       \
<span class="line-added">650   product(size_t, MinHeapSize, 0,                                           \</span>
<span class="line-added">651           &quot;Minimum heap size (in bytes); zero means use ergonomics&quot;)        \</span>
<span class="line-added">652           constraint(MinHeapSizeConstraintFunc,AfterErgo)                   \</span>
<span class="line-added">653                                                                             \</span>
654   product(size_t, InitialHeapSize, 0,                                       \
655           &quot;Initial heap size (in bytes); zero means use ergonomics&quot;)        \
656           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
657                                                                             \
658   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
659           &quot;Maximum heap size (in bytes)&quot;)                                   \
660           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
661                                                                             \
<span class="line-added">662   manageable(size_t, SoftMaxHeapSize, 0,                                    \</span>
<span class="line-added">663           &quot;Soft limit for maximum heap size (in bytes)&quot;)                    \</span>
<span class="line-added">664           constraint(SoftMaxHeapSizeConstraintFunc,AfterMemoryInit)         \</span>
<span class="line-added">665                                                                             \</span>
666   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
667           &quot;Initial tenured generation size (in bytes)&quot;)                     \
668           range(0, max_uintx)                                               \
669                                                                             \
670   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
671           &quot;Initial new generation size (in bytes)&quot;)                         \
672           constraint(NewSizeConstraintFunc,AfterErgo)                       \
673                                                                             \
674   product(size_t, MaxNewSize, max_uintx,                                    \
675           &quot;Maximum new generation size (in bytes), max_uintx means set &quot;    \
676           &quot;ergonomically&quot;)                                                  \
677           range(0, max_uintx)                                               \
678                                                                             \
679   product_pd(size_t, HeapBaseMinAddress,                                    \
680           &quot;OS specific low limit for heap base address&quot;)                    \
681           constraint(HeapBaseMinAddressConstraintFunc,AfterErgo)            \
682                                                                             \
683   product(size_t, PretenureSizeThreshold, 0,                                \
684           &quot;Maximum size in bytes of objects allocated in DefNew &quot;           \
685           &quot;generation; zero means no maximum&quot;)                              \
686           range(0, max_uintx)                                               \
687                                                                             \
688   product(size_t, MinTLABSize, 2*K,                                         \
689           &quot;Minimum allowed TLAB size (in bytes)&quot;)                           \
690           range(1, max_uintx/2)                                             \
691           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
692                                                                             \
693   product(size_t, TLABSize, 0,                                              \
694           &quot;Starting TLAB size (in bytes); zero means set ergonomically&quot;)    \
695           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
696                                                                             \
697   product(size_t, YoungPLABSize, 4096,                                      \
698           &quot;Size of young gen promotion LAB&#39;s (in HeapWords)&quot;)               \
699           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
700                                                                             \
701   product(size_t, OldPLABSize, 1024,                                        \
<span class="line-modified">702           &quot;Size of old gen promotion LAB&#39;s (in HeapWords)&quot;)                 \</span>

703           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
704                                                                             \
705   product(uintx, TLABAllocationWeight, 35,                                  \
706           &quot;Allocation averaging weight&quot;)                                    \
707           range(0, 100)                                                     \
708                                                                             \
709   /* Limit the lower bound of this flag to 1 as it is used  */              \
710   /* in a division expression.                              */              \
711   product(uintx, TLABWasteTargetPercent, 1,                                 \
712           &quot;Percentage of Eden that can be wasted&quot;)                          \
713           range(1, 100)                                                     \
714                                                                             \
715   product(uintx, TLABRefillWasteFraction,    64,                            \
716           &quot;Maximum TLAB waste at a refill (internal fragmentation)&quot;)        \
717           range(1, max_juint)                                               \
718                                                                             \
719   product(uintx, TLABWasteIncrement,    4,                                  \
720           &quot;Increment allowed waste at slow allocation&quot;)                     \
721           range(0, max_jint)                                                \
722           constraint(TLABWasteIncrementConstraintFunc,AfterMemoryInit)      \
</pre>
<hr />
<pre>
733   product_pd(size_t, NewSizeThreadIncrease,                                 \
734           &quot;Additional size added to desired new generation size per &quot;       \
735           &quot;non-daemon thread (in bytes)&quot;)                                   \
736           range(0, max_uintx)                                               \
737                                                                             \
738   product(uintx, QueuedAllocationWarningCount, 0,                           \
739           &quot;Number of times an allocation that queues behind a GC &quot;          \
740           &quot;will retry before printing a warning&quot;)                           \
741           range(0, max_uintx)                                               \
742                                                                             \
743   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
744           &quot;GC invoke count where +VerifyBefore/AfterGC kicks in&quot;)           \
745           range(0, max_uintx)                                               \
746                                                                             \
747   diagnostic(intx, VerifyGCLevel,     0,                                    \
748           &quot;Generation level at which to start +VerifyBefore/AfterGC&quot;)       \
749           range(0, 1)                                                       \
750                                                                             \
751   product(uintx, MaxTenuringThreshold,    15,                               \
752           &quot;Maximum value for tenuring threshold&quot;)                           \
<span class="line-modified">753           range(0, markWord::max_age + 1)                                   \</span>
754           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
755                                                                             \
756   product(uintx, InitialTenuringThreshold,    7,                            \
757           &quot;Initial value for tenuring threshold&quot;)                           \
<span class="line-modified">758           range(0, markWord::max_age + 1)                                   \</span>
759           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
760                                                                             \
761   product(uintx, TargetSurvivorRatio,    50,                                \
762           &quot;Desired percentage of survivor space used after scavenge&quot;)       \
763           range(0, 100)                                                     \
764                                                                             \
765   product(uintx, MarkSweepDeadRatio,     5,                                 \
766           &quot;Percentage (0-100) of the old gen allowed as dead wood. &quot;        \
767           &quot;Serial mark sweep treats this as both the minimum and maximum &quot;  \
768           &quot;value. &quot;                                                         \

769           &quot;Par compact uses a variable scale based on the density of the &quot;  \
770           &quot;generation and treats this as the maximum value when the heap &quot;  \
771           &quot;is either completely full or completely empty.  Par compact &quot;    \
772           &quot;also has a smaller default value; see arguments.cpp.&quot;)           \
773           range(0, 100)                                                     \
774                                                                             \
775   product(uint, MarkSweepAlwaysCompactCount,     4,                         \
776           &quot;How often should we fully compact the heap (ignoring the dead &quot;  \
777           &quot;space parameters)&quot;)                                              \
778           range(1, max_juint)                                               \
779                                                                             \
780   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
781           &quot;Delay between expansion and allocation (in milliseconds)&quot;)       \
782                                                                             \
783   product(uintx, GCDrainStackTargetSize, 64,                                \
784           &quot;Number of entries we will try to leave on the stack &quot;            \
785           &quot;during parallel gc&quot;)                                             \
786           range(0, max_juint)
787 
788 #endif // SHARE_GC_SHARED_GC_GLOBALS_HPP
</pre>
</td>
</tr>
</table>
<center><a href="gcVMOperations.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genCollectedHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/workgroup.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/gcId.hpp&quot;
 27 #include &quot;gc/shared/workgroup.hpp&quot;
 28 #include &quot;gc/shared/workerManager.hpp&quot;
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;runtime/atomic.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/semaphore.hpp&quot;
 34 #include &quot;runtime/thread.inline.hpp&quot;
 35 
 36 // Definitions of WorkGang methods.
 37 
 38 // The current implementation will exit if the allocation
 39 // of any worker fails.
 40 void  AbstractWorkGang::initialize_workers() {
 41   log_develop_trace(gc, workgang)(&quot;Constructing work gang %s with %u threads&quot;, name(), total_workers());
 42   _workers = NEW_C_HEAP_ARRAY(AbstractGangWorker*, total_workers(), mtInternal);
 43   if (_workers == NULL) {
 44     vm_exit_out_of_memory(0, OOM_MALLOC_ERROR, &quot;Cannot create GangWorker array.&quot;);
 45   }
 46 
 47   add_workers(true);
 48 }
 49 
 50 
 51 AbstractGangWorker* AbstractWorkGang::install_worker(uint worker_id) {
 52   AbstractGangWorker* new_worker = allocate_worker(worker_id);
 53   set_thread(worker_id, new_worker);
 54   return new_worker;
 55 }
 56 
 57 void AbstractWorkGang::add_workers(bool initializing) {
 58   add_workers(_active_workers, initializing);
 59 }
 60 
 61 void AbstractWorkGang::add_workers(uint active_workers, bool initializing) {
 62 
 63   os::ThreadType worker_type;
 64   if (are_ConcurrentGC_threads()) {
 65     worker_type = os::cgc_thread;
 66   } else {
 67     worker_type = os::pgc_thread;
 68   }
 69   uint previous_created_workers = _created_workers;
 70 
 71   _created_workers = WorkerManager::add_workers(this,
 72                                                 active_workers,
 73                                                 _total_workers,
 74                                                 _created_workers,
 75                                                 worker_type,
 76                                                 initializing);
 77   _active_workers = MIN2(_created_workers, _active_workers);
 78 
 79   WorkerManager::log_worker_creation(this, previous_created_workers, _active_workers, _created_workers, initializing);
 80 }
 81 
 82 AbstractGangWorker* AbstractWorkGang::worker(uint i) const {
 83   // Array index bounds checking.
 84   AbstractGangWorker* result = NULL;
 85   assert(_workers != NULL, &quot;No workers for indexing&quot;);
 86   assert(i &lt; total_workers(), &quot;Worker index out of bounds&quot;);
 87   result = _workers[i];
 88   assert(result != NULL, &quot;Indexing to null worker&quot;);
 89   return result;
 90 }
 91 
 92 void AbstractWorkGang::print_worker_threads_on(outputStream* st) const {
 93   uint workers = created_workers();
 94   for (uint i = 0; i &lt; workers; i++) {
 95     worker(i)-&gt;print_on(st);
 96     st-&gt;cr();
 97   }
 98 }
 99 
100 void AbstractWorkGang::threads_do(ThreadClosure* tc) const {
101   assert(tc != NULL, &quot;Null ThreadClosure&quot;);
102   uint workers = created_workers();
103   for (uint i = 0; i &lt; workers; i++) {
104     tc-&gt;do_thread(worker(i));
105   }
106 }
107 
108 // WorkGang dispatcher implemented with semaphores.
109 //
110 // Semaphores don&#39;t require the worker threads to re-claim the lock when they wake up.
111 // This helps lowering the latency when starting and stopping the worker threads.
112 class SemaphoreGangTaskDispatcher : public GangTaskDispatcher {
113   // The task currently being dispatched to the GangWorkers.
114   AbstractGangTask* _task;
115 
116   volatile uint _started;
117   volatile uint _not_finished;
118 
119   // Semaphore used to start the GangWorkers.
120   Semaphore* _start_semaphore;
121   // Semaphore used to notify the coordinator that all workers are done.
122   Semaphore* _end_semaphore;
123 
124 public:
125   SemaphoreGangTaskDispatcher() :
126       _task(NULL),
127       _started(0),
128       _not_finished(0),
129       _start_semaphore(new Semaphore()),
130       _end_semaphore(new Semaphore())
131 { }
132 
133   ~SemaphoreGangTaskDispatcher() {
134     delete _start_semaphore;
135     delete _end_semaphore;
136   }
137 
138   void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {
139     // No workers are allowed to read the state variables until they have been signaled.
140     _task         = task;
141     _not_finished = num_workers;
142 
143     // Dispatch &#39;num_workers&#39; number of tasks.
144     _start_semaphore-&gt;signal(num_workers);
145 
146     // Wait for the last worker to signal the coordinator.
147     _end_semaphore-&gt;wait();
148 
149     // No workers are allowed to read the state variables after the coordinator has been signaled.
150     assert(_not_finished == 0, &quot;%d not finished workers?&quot;, _not_finished);
151     _task    = NULL;
152     _started = 0;
153 
154   }
155 
156   WorkData worker_wait_for_task() {
157     // Wait for the coordinator to dispatch a task.
158     _start_semaphore-&gt;wait();
159 
160     uint num_started = Atomic::add(1u, &amp;_started);
161 
162     // Subtract one to get a zero-indexed worker id.
163     uint worker_id = num_started - 1;
164 
165     return WorkData(_task, worker_id);
166   }
167 
168   void worker_done_with_task() {
169     // Mark that the worker is done with the task.
170     // The worker is not allowed to read the state variables after this line.
171     uint not_finished = Atomic::sub(1u, &amp;_not_finished);
172 
173     // The last worker signals to the coordinator that all work is completed.
174     if (not_finished == 0) {
175       _end_semaphore-&gt;signal();
176     }
177   }
178 };
179 
180 class MutexGangTaskDispatcher : public GangTaskDispatcher {
181   AbstractGangTask* _task;
182 
183   volatile uint _started;
184   volatile uint _finished;
185   volatile uint _num_workers;
186 
187   Monitor* _monitor;
188 
189  public:
190   MutexGangTaskDispatcher() :
191     _task(NULL),
192     _started(0),
193     _finished(0),
194     _num_workers(0),
195     _monitor(new Monitor(Monitor::leaf, &quot;WorkGang dispatcher lock&quot;, false, Monitor::_safepoint_check_never)) {
196   }
197 
198   ~MutexGangTaskDispatcher() {
199     delete _monitor;
200   }
201 
202   void coordinator_execute_on_workers(AbstractGangTask* task, uint num_workers) {
203     MutexLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);
204 
205     _task        = task;
206     _num_workers = num_workers;
207 
208     // Tell the workers to get to work.
209     _monitor-&gt;notify_all();
210 
211     // Wait for them to finish.
212     while (_finished &lt; _num_workers) {
213       _monitor-&gt;wait(/* no_safepoint_check */ true);
214     }
215 
216     _task        = NULL;
217     _num_workers = 0;
218     _started     = 0;
219     _finished    = 0;
220   }
221 
222   WorkData worker_wait_for_task() {
223     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);
224 
225     while (_num_workers == 0 || _started == _num_workers) {
226       _monitor-&gt;wait(/* no_safepoint_check */ true);
227     }
228 
229     _started++;
230 
231     // Subtract one to get a zero-indexed worker id.
232     uint worker_id = _started - 1;
233 
234     return WorkData(_task, worker_id);
235   }
236 
237   void worker_done_with_task() {
238     MonitorLockerEx ml(_monitor, Mutex::_no_safepoint_check_flag);
239 
240     _finished++;
241 
242     if (_finished == _num_workers) {
243       // This will wake up all workers and not only the coordinator.
244       _monitor-&gt;notify_all();
245     }
246   }
247 };
248 
249 static GangTaskDispatcher* create_dispatcher() {
250   if (UseSemaphoreGCThreadsSynchronization) {
251     return new SemaphoreGangTaskDispatcher();
252   }
253 
254   return new MutexGangTaskDispatcher();
255 }
256 
257 WorkGang::WorkGang(const char* name,
258                    uint  workers,
259                    bool  are_GC_task_threads,
260                    bool  are_ConcurrentGC_threads) :
261     AbstractWorkGang(name, workers, are_GC_task_threads, are_ConcurrentGC_threads),
262     _dispatcher(create_dispatcher())
263 { }
264 
265 WorkGang::~WorkGang() {
266   delete _dispatcher;
267 }
268 
269 AbstractGangWorker* WorkGang::allocate_worker(uint worker_id) {
270   return new GangWorker(this, worker_id);
271 }
272 
273 void WorkGang::run_task(AbstractGangTask* task) {
274   run_task(task, active_workers());
275 }
276 
277 void WorkGang::run_task(AbstractGangTask* task, uint num_workers) {
278   guarantee(num_workers &lt;= total_workers(),
279             &quot;Trying to execute task %s with %u workers which is more than the amount of total workers %u.&quot;,
280             task-&gt;name(), num_workers, total_workers());
281   guarantee(num_workers &gt; 0, &quot;Trying to execute task %s with zero workers&quot;, task-&gt;name());
282   uint old_num_workers = _active_workers;
283   update_active_workers(num_workers);
284   _dispatcher-&gt;coordinator_execute_on_workers(task, num_workers);
285   update_active_workers(old_num_workers);
286 }
287 
288 AbstractGangWorker::AbstractGangWorker(AbstractWorkGang* gang, uint id) {
289   _gang = gang;
290   set_id(id);
291   set_name(&quot;%s#%d&quot;, gang-&gt;name(), id);
292 }
293 
294 void AbstractGangWorker::run() {
295   initialize();
296   loop();
297 }
298 
299 void AbstractGangWorker::initialize() {
300   assert(_gang != NULL, &quot;No gang to run in&quot;);
301   os::set_priority(this, NearMaxPriority);
302   log_develop_trace(gc, workgang)(&quot;Running gang worker for gang %s id %u&quot;, gang()-&gt;name(), id());
303   // The VM thread should not execute here because MutexLocker&#39;s are used
304   // as (opposed to MutexLockerEx&#39;s).
305   assert(!Thread::current()-&gt;is_VM_thread(), &quot;VM thread should not be part&quot;
306          &quot; of a work gang&quot;);
307 }
308 
309 bool AbstractGangWorker::is_GC_task_thread() const {
310   return gang()-&gt;are_GC_task_threads();
311 }
312 
313 bool AbstractGangWorker::is_ConcurrentGC_thread() const {
314   return gang()-&gt;are_ConcurrentGC_threads();
315 }
316 
317 void AbstractGangWorker::print_on(outputStream* st) const {
318   st-&gt;print(&quot;\&quot;%s\&quot; &quot;, name());
319   Thread::print_on(st);
320   st-&gt;cr();
321 }
322 
323 WorkData GangWorker::wait_for_task() {
324   return gang()-&gt;dispatcher()-&gt;worker_wait_for_task();
325 }
326 
327 void GangWorker::signal_task_done() {
328   gang()-&gt;dispatcher()-&gt;worker_done_with_task();
329 }
330 
331 void GangWorker::run_task(WorkData data) {
332   GCIdMark gc_id_mark(data._task-&gt;gc_id());
333   log_develop_trace(gc, workgang)(&quot;Running work gang: %s task: %s worker: %u&quot;, name(), data._task-&gt;name(), data._worker_id);
334 
335   data._task-&gt;work(data._worker_id);
336 
337   log_develop_trace(gc, workgang)(&quot;Finished work gang: %s task: %s worker: %u thread: &quot; PTR_FORMAT,
338                                   name(), data._task-&gt;name(), data._worker_id, p2i(Thread::current()));
339 }
340 
341 void GangWorker::loop() {
342   while (true) {
343     WorkData data = wait_for_task();
344 
345     run_task(data);
346 
347     signal_task_done();
348   }
349 }
350 
351 // *** WorkGangBarrierSync
352 
353 WorkGangBarrierSync::WorkGangBarrierSync()
354   : _monitor(Mutex::safepoint, &quot;work gang barrier sync&quot;, true,
355              Monitor::_safepoint_check_never),
356     _n_workers(0), _n_completed(0), _should_reset(false), _aborted(false) {
357 }
358 
359 WorkGangBarrierSync::WorkGangBarrierSync(uint n_workers, const char* name)
360   : _monitor(Mutex::safepoint, name, true, Monitor::_safepoint_check_never),
361     _n_workers(n_workers), _n_completed(0), _should_reset(false), _aborted(false) {
362 }
363 
364 void WorkGangBarrierSync::set_n_workers(uint n_workers) {
365   _n_workers    = n_workers;
366   _n_completed  = 0;
367   _should_reset = false;
368   _aborted      = false;
369 }
370 
371 bool WorkGangBarrierSync::enter() {
372   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);
373   if (should_reset()) {
374     // The should_reset() was set and we are the first worker to enter
375     // the sync barrier. We will zero the n_completed() count which
376     // effectively resets the barrier.
377     zero_completed();
378     set_should_reset(false);
379   }
380   inc_completed();
381   if (n_completed() == n_workers()) {
382     // At this point we would like to reset the barrier to be ready in
383     // case it is used again. However, we cannot set n_completed() to
384     // 0, even after the notify_all(), given that some other workers
385     // might still be waiting for n_completed() to become ==
386     // n_workers(). So, if we set n_completed() to 0, those workers
387     // will get stuck (as they will wake up, see that n_completed() !=
388     // n_workers() and go back to sleep). Instead, we raise the
389     // should_reset() flag and the barrier will be reset the first
390     // time a worker enters it again.
391     set_should_reset(true);
392     monitor()-&gt;notify_all();
393   } else {
394     while (n_completed() != n_workers() &amp;&amp; !aborted()) {
395       monitor()-&gt;wait(/* no_safepoint_check */ true);
396     }
397   }
398   return !aborted();
399 }
400 
401 void WorkGangBarrierSync::abort() {
402   MutexLockerEx x(monitor(), Mutex::_no_safepoint_check_flag);
403   set_aborted();
404   monitor()-&gt;notify_all();
405 }
406 
407 // SubTasksDone functions.
408 
409 SubTasksDone::SubTasksDone(uint n) :
410   _tasks(NULL), _n_tasks(n), _threads_completed(0) {
411   _tasks = NEW_C_HEAP_ARRAY(uint, n, mtInternal);
412   guarantee(_tasks != NULL, &quot;alloc failure&quot;);
413   clear();
414 }
415 
416 bool SubTasksDone::valid() {
417   return _tasks != NULL;
418 }
419 
420 void SubTasksDone::clear() {
421   for (uint i = 0; i &lt; _n_tasks; i++) {
422     _tasks[i] = 0;
423   }
424   _threads_completed = 0;
425 #ifdef ASSERT
426   _claimed = 0;
427 #endif
428 }
429 
430 bool SubTasksDone::try_claim_task(uint t) {
431   assert(t &lt; _n_tasks, &quot;bad task id.&quot;);
432   uint old = _tasks[t];
433   if (old == 0) {
434     old = Atomic::cmpxchg(1u, &amp;_tasks[t], 0u);
435   }
436   assert(_tasks[t] == 1, &quot;What else?&quot;);
437   bool res = old == 0;
438 #ifdef ASSERT
439   if (res) {
440     assert(_claimed &lt; _n_tasks, &quot;Too many tasks claimed; missing clear?&quot;);
441     Atomic::inc(&amp;_claimed);
442   }
443 #endif
444   return res;
445 }
446 
447 void SubTasksDone::all_tasks_completed(uint n_threads) {
448   uint observed = _threads_completed;
449   uint old;
450   do {
451     old = observed;
452     observed = Atomic::cmpxchg(old+1, &amp;_threads_completed, old);
453   } while (observed != old);
454   // If this was the last thread checking in, clear the tasks.
455   uint adjusted_thread_count = (n_threads == 0 ? 1 : n_threads);
456   if (observed + 1 == adjusted_thread_count) {
457     clear();
458   }
459 }
460 
461 
462 SubTasksDone::~SubTasksDone() {
463   if (_tasks != NULL) FREE_C_HEAP_ARRAY(uint, _tasks);
464 }
465 
466 // *** SequentialSubTasksDone
467 
468 void SequentialSubTasksDone::clear() {
469   _n_tasks   = _n_claimed   = 0;
470   _n_threads = _n_completed = 0;
471 }
472 
473 bool SequentialSubTasksDone::valid() {
474   return _n_threads &gt; 0;
475 }
476 
477 bool SequentialSubTasksDone::try_claim_task(uint&amp; t) {
478   t = _n_claimed;
479   while (t &lt; _n_tasks) {
480     uint res = Atomic::cmpxchg(t+1, &amp;_n_claimed, t);
481     if (res == t) {
482       return true;
483     }
484     t = res;
485   }
486   return false;
487 }
488 
489 bool SequentialSubTasksDone::all_tasks_completed() {
490   uint complete = _n_completed;
491   while (true) {
492     uint res = Atomic::cmpxchg(complete+1, &amp;_n_completed, complete);
493     if (res == complete) {
494       break;
495     }
496     complete = res;
497   }
498   if (complete+1 == _n_threads) {
499     clear();
500     return true;
501   }
502   return false;
503 }
    </pre>
  </body>
</html>
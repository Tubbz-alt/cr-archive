<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/gcVMOperations.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gcVMOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gc_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/gcVMOperations.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
108   // Acquire the reference synchronization lock
109   virtual bool doit_prologue();
110   // Do notifyAll (if needed) and release held lock
111   virtual void doit_epilogue();
112 
113   virtual bool allow_nested_vm_operations() const  { return true; }
114   bool prologue_succeeded() const { return _prologue_succeeded; }
115 
116   void set_gc_locked() { _gc_locked = true; }
117   bool gc_locked() const  { return _gc_locked; }
118 
119   static void notify_gc_begin(bool full = false);
120   static void notify_gc_end();
121 };
122 
123 
124 class VM_GC_HeapInspection: public VM_GC_Operation {
125  private:
126   outputStream* _out;
127   bool _full_gc;
<span class="line-removed">128   bool _csv_format; // &quot;comma separated values&quot; format for spreadsheet.</span>
<span class="line-removed">129   bool _print_help;</span>
<span class="line-removed">130   bool _print_class_stats;</span>
<span class="line-removed">131   const char* _columns;</span>
132  public:
133   VM_GC_HeapInspection(outputStream* out, bool request_full_gc) :
134     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
135                     GCCause::_heap_inspection /* GC Cause */,
136                     0 /* total full collections, dummy, ignored */,
<span class="line-modified">137                     request_full_gc) {</span>
<span class="line-removed">138     _out = out;</span>
<span class="line-removed">139     _full_gc = request_full_gc;</span>
<span class="line-removed">140     _csv_format = false;</span>
<span class="line-removed">141     _print_help = false;</span>
<span class="line-removed">142     _print_class_stats = false;</span>
<span class="line-removed">143     _columns = NULL;</span>
<span class="line-removed">144   }</span>
145 
146   ~VM_GC_HeapInspection() {}
147   virtual VMOp_Type type() const { return VMOp_GC_HeapInspection; }
148   virtual bool skip_operation() const;
149   virtual void doit();
<span class="line-removed">150   void set_csv_format(bool value) {_csv_format = value;}</span>
<span class="line-removed">151   void set_print_help(bool value) {_print_help = value;}</span>
<span class="line-removed">152   void set_print_class_stats(bool value) {_print_class_stats = value;}</span>
<span class="line-removed">153   void set_columns(const char* value) {_columns = value;}</span>
154  protected:
155   bool collect();
156 };
157 
158 class VM_CollectForAllocation : public VM_GC_Operation {
159  protected:
160   size_t    _word_size; // Size of object to be allocated (in number of words)
161   HeapWord* _result;    // Allocation result (NULL if allocation failed)
162 
163  public:
164   VM_CollectForAllocation(size_t word_size, uint gc_count_before, GCCause::Cause cause);
165 
166   HeapWord* result() const {
167     return _result;
168   }
169 };
170 
171 class VM_GenCollectForAllocation : public VM_CollectForAllocation {
172  private:
173   bool        _tlab;                       // alloc is of a tlab.
</pre>
<hr />
<pre>
177                              uint gc_count_before)
178     : VM_CollectForAllocation(word_size, gc_count_before, GCCause::_allocation_failure),
179       _tlab(tlab) {
180     assert(word_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
181   }
182   ~VM_GenCollectForAllocation()  {}
183   virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }
184   virtual void doit();
185 };
186 
187 // VM operation to invoke a collection of the heap as a
188 // GenCollectedHeap heap.
189 class VM_GenCollectFull: public VM_GC_Operation {
190  private:
191   GenCollectedHeap::GenerationType _max_generation;
192  public:
193   VM_GenCollectFull(uint gc_count_before,
194                     uint full_gc_count_before,
195                     GCCause::Cause gc_cause,
196                     GenCollectedHeap::GenerationType max_generation)
<span class="line-modified">197     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true /* full */),</span>

198       _max_generation(max_generation) { }
199   ~VM_GenCollectFull() {}
200   virtual VMOp_Type type() const { return VMOp_GenCollectFull; }
201   virtual void doit();
202 };
203 
204 class VM_CollectForMetadataAllocation: public VM_GC_Operation {
205  private:
206   MetaWord*                _result;
207   size_t                   _size;     // size of object to be allocated
208   Metaspace::MetadataType  _mdtype;
209   ClassLoaderData*         _loader_data;
210 
211  public:
212   VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
213                                   size_t size,
214                                   Metaspace::MetadataType mdtype,
215                                   uint gc_count_before,
216                                   uint full_gc_count_before,
217                                   GCCause::Cause gc_cause);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
108   // Acquire the reference synchronization lock
109   virtual bool doit_prologue();
110   // Do notifyAll (if needed) and release held lock
111   virtual void doit_epilogue();
112 
113   virtual bool allow_nested_vm_operations() const  { return true; }
114   bool prologue_succeeded() const { return _prologue_succeeded; }
115 
116   void set_gc_locked() { _gc_locked = true; }
117   bool gc_locked() const  { return _gc_locked; }
118 
119   static void notify_gc_begin(bool full = false);
120   static void notify_gc_end();
121 };
122 
123 
124 class VM_GC_HeapInspection: public VM_GC_Operation {
125  private:
126   outputStream* _out;
127   bool _full_gc;




128  public:
129   VM_GC_HeapInspection(outputStream* out, bool request_full_gc) :
130     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
131                     GCCause::_heap_inspection /* GC Cause */,
132                     0 /* total full collections, dummy, ignored */,
<span class="line-modified">133                     request_full_gc), _out(out), _full_gc(request_full_gc) {}</span>







134 
135   ~VM_GC_HeapInspection() {}
136   virtual VMOp_Type type() const { return VMOp_GC_HeapInspection; }
137   virtual bool skip_operation() const;
138   virtual void doit();




139  protected:
140   bool collect();
141 };
142 
143 class VM_CollectForAllocation : public VM_GC_Operation {
144  protected:
145   size_t    _word_size; // Size of object to be allocated (in number of words)
146   HeapWord* _result;    // Allocation result (NULL if allocation failed)
147 
148  public:
149   VM_CollectForAllocation(size_t word_size, uint gc_count_before, GCCause::Cause cause);
150 
151   HeapWord* result() const {
152     return _result;
153   }
154 };
155 
156 class VM_GenCollectForAllocation : public VM_CollectForAllocation {
157  private:
158   bool        _tlab;                       // alloc is of a tlab.
</pre>
<hr />
<pre>
162                              uint gc_count_before)
163     : VM_CollectForAllocation(word_size, gc_count_before, GCCause::_allocation_failure),
164       _tlab(tlab) {
165     assert(word_size != 0, &quot;An allocation should always be requested with this operation.&quot;);
166   }
167   ~VM_GenCollectForAllocation()  {}
168   virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }
169   virtual void doit();
170 };
171 
172 // VM operation to invoke a collection of the heap as a
173 // GenCollectedHeap heap.
174 class VM_GenCollectFull: public VM_GC_Operation {
175  private:
176   GenCollectedHeap::GenerationType _max_generation;
177  public:
178   VM_GenCollectFull(uint gc_count_before,
179                     uint full_gc_count_before,
180                     GCCause::Cause gc_cause,
181                     GenCollectedHeap::GenerationType max_generation)
<span class="line-modified">182     : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,</span>
<span class="line-added">183                       max_generation != GenCollectedHeap::YoungGen /* full */),</span>
184       _max_generation(max_generation) { }
185   ~VM_GenCollectFull() {}
186   virtual VMOp_Type type() const { return VMOp_GenCollectFull; }
187   virtual void doit();
188 };
189 
190 class VM_CollectForMetadataAllocation: public VM_GC_Operation {
191  private:
192   MetaWord*                _result;
193   size_t                   _size;     // size of object to be allocated
194   Metaspace::MetadataType  _mdtype;
195   ClassLoaderData*         _loader_data;
196 
197  public:
198   VM_CollectForMetadataAllocation(ClassLoaderData* loader_data,
199                                   size_t size,
200                                   Metaspace::MetadataType mdtype,
201                                   uint gc_count_before,
202                                   uint full_gc_count_before,
203                                   GCCause::Cause gc_cause);
</pre>
</td>
</tr>
</table>
<center><a href="gcVMOperations.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="gc_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
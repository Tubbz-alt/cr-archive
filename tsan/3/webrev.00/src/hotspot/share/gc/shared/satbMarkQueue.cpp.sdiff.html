<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/satbMarkQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="referenceProcessorPhaseTimes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/satbMarkQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;

 31 #include &quot;runtime/mutexLocker.hpp&quot;
 32 #include &quot;runtime/os.hpp&quot;
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 #include &quot;runtime/thread.hpp&quot;
 35 #include &quot;runtime/threadSMR.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;

 37 
<span class="line-modified"> 38 SATBMarkQueue::SATBMarkQueue(SATBMarkQueueSet* qset, bool permanent) :</span>
 39   // SATB queues are only active during marking cycles. We create
 40   // them with their active field set to false. If a thread is
 41   // created during a cycle and its SATB queue needs to be activated
 42   // before the thread starts running, we&#39;ll need to set its active
 43   // field to true. This must be done in the collector-specific
 44   // BarrierSet thread attachment protocol.
<span class="line-modified"> 45   PtrQueue(qset, permanent, false /* active */)</span>
 46 { }
 47 
 48 void SATBMarkQueue::flush() {
 49   // Filter now to possibly save work later.  If filtering empties the
 50   // buffer then flush_impl can deallocate the buffer.
 51   filter();
 52   flush_impl();
 53 }
 54 
 55 // This method will first apply filtering to the buffer. If filtering
 56 // retains a small enough collection in the buffer, we can continue to
 57 // use the buffer as-is, instead of enqueueing and replacing it.
 58 
<span class="line-modified"> 59 bool SATBMarkQueue::should_enqueue_buffer() {</span>
 60   // This method should only be called if there is a non-NULL buffer
 61   // that is full.
 62   assert(index() == 0, &quot;pre-condition&quot;);
 63   assert(_buf != NULL, &quot;pre-condition&quot;);
 64 
 65   filter();
 66 
<span class="line-modified"> 67   SATBMarkQueueSet* satb_qset = static_cast&lt;SATBMarkQueueSet*&gt;(qset());</span>
<span class="line-removed"> 68   size_t threshold = satb_qset-&gt;buffer_enqueue_threshold();</span>
 69   // Ensure we&#39;ll enqueue completely full buffers.
 70   assert(threshold &gt; 0, &quot;enqueue threshold = 0&quot;);
 71   // Ensure we won&#39;t enqueue empty buffers.
 72   assert(threshold &lt;= capacity(),
 73          &quot;enqueue threshold &quot; SIZE_FORMAT &quot; exceeds capacity &quot; SIZE_FORMAT,
 74          threshold, capacity());
<span class="line-modified"> 75   return index() &lt; threshold;</span>




 76 }
 77 
 78 void SATBMarkQueue::apply_closure_and_empty(SATBBufferClosure* cl) {
 79   assert(SafepointSynchronize::is_at_safepoint(),
 80          &quot;SATB queues must only be processed at safepoints&quot;);
 81   if (_buf != NULL) {
 82     cl-&gt;do_buffer(&amp;_buf[index()], size());
 83     reset();
 84   }
 85 }
 86 
 87 #ifndef PRODUCT
 88 // Helpful for debugging
 89 
 90 static void print_satb_buffer(const char* name,
 91                               void** buf,
 92                               size_t index,
 93                               size_t capacity) {
 94   tty-&gt;print_cr(&quot;  SATB BUFFER [%s] buf: &quot; PTR_FORMAT &quot; index: &quot; SIZE_FORMAT
 95                 &quot; capacity: &quot; SIZE_FORMAT,
 96                 name, p2i(buf), index, capacity);
 97 }
 98 
 99 void SATBMarkQueue::print(const char* name) {
100   print_satb_buffer(name, _buf, index(), capacity());
101 }
102 
103 #endif // PRODUCT
104 
<span class="line-modified">105 SATBMarkQueueSet::SATBMarkQueueSet() :</span>
<span class="line-modified">106   PtrQueueSet(),</span>



107   _buffer_enqueue_threshold(0)
108 {}
109 
<span class="line-modified">110 void SATBMarkQueueSet::initialize(Monitor* cbl_mon,</span>
<span class="line-modified">111                                   BufferNode::Allocator* allocator,</span>
<span class="line-modified">112                                   size_t process_completed_buffers_threshold,</span>
<span class="line-modified">113                                   uint buffer_enqueue_threshold_percentage) {</span>
<span class="line-modified">114   PtrQueueSet::initialize(cbl_mon, allocator);</span>
<span class="line-modified">115   set_process_completed_buffers_threshold(process_completed_buffers_threshold);</span>
<span class="line-modified">116   assert(buffer_size() != 0, &quot;buffer size not initialized&quot;);</span>










































117   // Minimum threshold of 1 ensures enqueuing of completely full buffers.
118   size_t size = buffer_size();
<span class="line-modified">119   size_t enqueue_qty = (size * buffer_enqueue_threshold_percentage) / 100;</span>
120   _buffer_enqueue_threshold = MAX2(size - enqueue_qty, (size_t)1);
121 }
122 
123 #ifdef ASSERT
124 void SATBMarkQueueSet::dump_active_states(bool expected_active) {
125   log_error(gc, verify)(&quot;Expected SATB active state: %s&quot;, expected_active ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
126   log_error(gc, verify)(&quot;Actual SATB active states:&quot;);
127   log_error(gc, verify)(&quot;  Queue set: %s&quot;, is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
128 
129   class DumpThreadStateClosure : public ThreadClosure {
130     SATBMarkQueueSet* _qset;
131   public:
132     DumpThreadStateClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
133     virtual void do_thread(Thread* t) {
134       SATBMarkQueue&amp; queue = _qset-&gt;satb_queue_for_thread(t);
135       log_error(gc, verify)(&quot;  Thread \&quot;%s\&quot; queue: %s&quot;,
136                             t-&gt;name(),
137                             queue.is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
138     }
139   } closure(this);
</pre>
<hr />
<pre>
153     bool _expected_active;
154   public:
155     VerifyThreadStatesClosure(SATBMarkQueueSet* qset, bool expected_active) :
156       _qset(qset), _expected_active(expected_active) {}
157     virtual void do_thread(Thread* t) {
158       if (_qset-&gt;satb_queue_for_thread(t).is_active() != _expected_active) {
159         _qset-&gt;dump_active_states(_expected_active);
160         fatal(&quot;Thread SATB queue has an unexpected active state&quot;);
161       }
162     }
163   } closure(this, expected_active);
164   Threads::threads_do(&amp;closure);
165 }
166 #endif // ASSERT
167 
168 void SATBMarkQueueSet::set_active_all_threads(bool active, bool expected_active) {
169   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
170 #ifdef ASSERT
171   verify_active_states(expected_active);
172 #endif // ASSERT
<span class="line-modified">173   _all_active = active;</span>




174 
175   class SetThreadActiveClosure : public ThreadClosure {
176     SATBMarkQueueSet* _qset;
177     bool _active;
178   public:
179     SetThreadActiveClosure(SATBMarkQueueSet* qset, bool active) :
180       _qset(qset), _active(active) {}
181     virtual void do_thread(Thread* t) {
182       _qset-&gt;satb_queue_for_thread(t).set_active(_active);
183     }
184   } closure(this, active);
185   Threads::threads_do(&amp;closure);
186 }
187 
<span class="line-removed">188 void SATBMarkQueueSet::filter_thread_buffers() {</span>
<span class="line-removed">189   class FilterThreadBufferClosure : public ThreadClosure {</span>
<span class="line-removed">190     SATBMarkQueueSet* _qset;</span>
<span class="line-removed">191   public:</span>
<span class="line-removed">192     FilterThreadBufferClosure(SATBMarkQueueSet* qset) : _qset(qset) {}</span>
<span class="line-removed">193     virtual void do_thread(Thread* t) {</span>
<span class="line-removed">194       _qset-&gt;satb_queue_for_thread(t).filter();</span>
<span class="line-removed">195     }</span>
<span class="line-removed">196   } closure(this);</span>
<span class="line-removed">197   Threads::threads_do(&amp;closure);</span>
<span class="line-removed">198 }</span>
<span class="line-removed">199 </span>
200 bool SATBMarkQueueSet::apply_closure_to_completed_buffer(SATBBufferClosure* cl) {
201   BufferNode* nd = get_completed_buffer();
202   if (nd != NULL) {
203     void **buf = BufferNode::make_buffer_from_node(nd);
204     size_t index = nd-&gt;index();
205     size_t size = buffer_size();
206     assert(index &lt;= size, &quot;invariant&quot;);
207     cl-&gt;do_buffer(buf + index, size - index);
208     deallocate_buffer(nd);
209     return true;
210   } else {
211     return false;
212   }
213 }
214 
































215 #ifndef PRODUCT
216 // Helpful for debugging
217 
218 #define SATB_PRINTER_BUFFER_SIZE 256
219 
220 void SATBMarkQueueSet::print_all(const char* msg) {
221   char buffer[SATB_PRINTER_BUFFER_SIZE];
222   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
223 
224   tty-&gt;cr();
225   tty-&gt;print_cr(&quot;SATB BUFFERS [%s]&quot;, msg);
226 
<span class="line-modified">227   BufferNode* nd = completed_buffers_head();</span>
228   int i = 0;
229   while (nd != NULL) {
230     void** buf = BufferNode::make_buffer_from_node(nd);
231     os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Enqueued: %d&quot;, i);
232     print_satb_buffer(buffer, buf, nd-&gt;index(), buffer_size());
233     nd = nd-&gt;next();
234     i += 1;
235   }
236 
237   class PrintThreadClosure : public ThreadClosure {
238     SATBMarkQueueSet* _qset;
239     char* _buffer;
240 
241   public:
242     PrintThreadClosure(SATBMarkQueueSet* qset, char* buffer) :
243       _qset(qset), _buffer(buffer) {}
244 
245     virtual void do_thread(Thread* t) {
246       os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Thread: %s&quot;, t-&gt;name());
247       _qset-&gt;satb_queue_for_thread(t).print(_buffer);
248     }
249   } closure(this, buffer);
250   Threads::threads_do(&amp;closure);
251 
252   tty-&gt;cr();
253 }
254 #endif // PRODUCT
255 











256 void SATBMarkQueueSet::abandon_partial_marking() {
257   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
258   abandon_completed_buffers();
259 
260   class AbandonThreadQueueClosure : public ThreadClosure {
261     SATBMarkQueueSet* _qset;
262   public:
263     AbandonThreadQueueClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
264     virtual void do_thread(Thread* t) {
265       _qset-&gt;satb_queue_for_thread(t).reset();
266     }
267   } closure(this);
268   Threads::threads_do(&amp;closure);
269 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/satbMarkQueue.hpp&quot;
 27 #include &quot;gc/shared/collectedHeap.hpp&quot;
 28 #include &quot;logging/log.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added"> 31 #include &quot;runtime/atomic.hpp&quot;</span>
 32 #include &quot;runtime/mutexLocker.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/safepoint.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/threadSMR.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
<span class="line-added"> 38 #include &quot;utilities/globalCounter.inline.hpp&quot;</span>
 39 
<span class="line-modified"> 40 SATBMarkQueue::SATBMarkQueue(SATBMarkQueueSet* qset) :</span>
 41   // SATB queues are only active during marking cycles. We create
 42   // them with their active field set to false. If a thread is
 43   // created during a cycle and its SATB queue needs to be activated
 44   // before the thread starts running, we&#39;ll need to set its active
 45   // field to true. This must be done in the collector-specific
 46   // BarrierSet thread attachment protocol.
<span class="line-modified"> 47   PtrQueue(qset, false /* active */)</span>
 48 { }
 49 
 50 void SATBMarkQueue::flush() {
 51   // Filter now to possibly save work later.  If filtering empties the
 52   // buffer then flush_impl can deallocate the buffer.
 53   filter();
 54   flush_impl();
 55 }
 56 
 57 // This method will first apply filtering to the buffer. If filtering
 58 // retains a small enough collection in the buffer, we can continue to
 59 // use the buffer as-is, instead of enqueueing and replacing it.
 60 
<span class="line-modified"> 61 void SATBMarkQueue::handle_completed_buffer() {</span>
 62   // This method should only be called if there is a non-NULL buffer
 63   // that is full.
 64   assert(index() == 0, &quot;pre-condition&quot;);
 65   assert(_buf != NULL, &quot;pre-condition&quot;);
 66 
 67   filter();
 68 
<span class="line-modified"> 69   size_t threshold = satb_qset()-&gt;buffer_enqueue_threshold();</span>

 70   // Ensure we&#39;ll enqueue completely full buffers.
 71   assert(threshold &gt; 0, &quot;enqueue threshold = 0&quot;);
 72   // Ensure we won&#39;t enqueue empty buffers.
 73   assert(threshold &lt;= capacity(),
 74          &quot;enqueue threshold &quot; SIZE_FORMAT &quot; exceeds capacity &quot; SIZE_FORMAT,
 75          threshold, capacity());
<span class="line-modified"> 76 </span>
<span class="line-added"> 77   if (index() &lt; threshold) {</span>
<span class="line-added"> 78     // Buffer is sufficiently full; enqueue and allocate a new one.</span>
<span class="line-added"> 79     enqueue_completed_buffer();</span>
<span class="line-added"> 80   } // Else continue to accumulate in buffer.</span>
 81 }
 82 
 83 void SATBMarkQueue::apply_closure_and_empty(SATBBufferClosure* cl) {
 84   assert(SafepointSynchronize::is_at_safepoint(),
 85          &quot;SATB queues must only be processed at safepoints&quot;);
 86   if (_buf != NULL) {
 87     cl-&gt;do_buffer(&amp;_buf[index()], size());
 88     reset();
 89   }
 90 }
 91 
 92 #ifndef PRODUCT
 93 // Helpful for debugging
 94 
 95 static void print_satb_buffer(const char* name,
 96                               void** buf,
 97                               size_t index,
 98                               size_t capacity) {
 99   tty-&gt;print_cr(&quot;  SATB BUFFER [%s] buf: &quot; PTR_FORMAT &quot; index: &quot; SIZE_FORMAT
100                 &quot; capacity: &quot; SIZE_FORMAT,
101                 name, p2i(buf), index, capacity);
102 }
103 
104 void SATBMarkQueue::print(const char* name) {
105   print_satb_buffer(name, _buf, index(), capacity());
106 }
107 
108 #endif // PRODUCT
109 
<span class="line-modified">110 SATBMarkQueueSet::SATBMarkQueueSet(BufferNode::Allocator* allocator) :</span>
<span class="line-modified">111   PtrQueueSet(allocator),</span>
<span class="line-added">112   _list(),</span>
<span class="line-added">113   _count_and_process_flag(0),</span>
<span class="line-added">114   _process_completed_buffers_threshold(SIZE_MAX),</span>
115   _buffer_enqueue_threshold(0)
116 {}
117 
<span class="line-modified">118 SATBMarkQueueSet::~SATBMarkQueueSet() {</span>
<span class="line-modified">119   abandon_completed_buffers();</span>
<span class="line-modified">120 }</span>
<span class="line-modified">121 </span>
<span class="line-modified">122 // _count_and_process_flag has flag in least significant bit, count in</span>
<span class="line-modified">123 // remaining bits.  _process_completed_buffers_threshold is scaled</span>
<span class="line-modified">124 // accordingly, with the lsbit set, so a _count_and_process_flag value</span>
<span class="line-added">125 // is directly comparable with the recorded threshold value.  The</span>
<span class="line-added">126 // process flag is set whenever the count exceeds the threshold, and</span>
<span class="line-added">127 // remains set until the count is reduced to zero.</span>
<span class="line-added">128 </span>
<span class="line-added">129 // Increment count.  If count &gt; threshold, set flag, else maintain flag.</span>
<span class="line-added">130 static void increment_count(volatile size_t* cfptr, size_t threshold) {</span>
<span class="line-added">131   size_t old;</span>
<span class="line-added">132   size_t value = Atomic::load(cfptr);</span>
<span class="line-added">133   do {</span>
<span class="line-added">134     old = value;</span>
<span class="line-added">135     value += 2;</span>
<span class="line-added">136     assert(value &gt; old, &quot;overflow&quot;);</span>
<span class="line-added">137     if (value &gt; threshold) value |= 1;</span>
<span class="line-added">138     value = Atomic::cmpxchg(cfptr, old, value);</span>
<span class="line-added">139   } while (value != old);</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
<span class="line-added">142 // Decrement count.  If count == 0, clear flag, else maintain flag.</span>
<span class="line-added">143 static void decrement_count(volatile size_t* cfptr) {</span>
<span class="line-added">144   size_t old;</span>
<span class="line-added">145   size_t value = Atomic::load(cfptr);</span>
<span class="line-added">146   do {</span>
<span class="line-added">147     assert((value &gt;&gt; 1) != 0, &quot;underflow&quot;);</span>
<span class="line-added">148     old = value;</span>
<span class="line-added">149     value -= 2;</span>
<span class="line-added">150     if (value &lt;= 1) value = 0;</span>
<span class="line-added">151     value = Atomic::cmpxchg(cfptr, old, value);</span>
<span class="line-added">152   } while (value != old);</span>
<span class="line-added">153 }</span>
<span class="line-added">154 </span>
<span class="line-added">155 void SATBMarkQueueSet::set_process_completed_buffers_threshold(size_t value) {</span>
<span class="line-added">156   // Scale requested threshold to align with count field.  If scaling</span>
<span class="line-added">157   // overflows, just use max value.  Set process flag field to make</span>
<span class="line-added">158   // comparison in increment_count exact.</span>
<span class="line-added">159   size_t scaled_value = value &lt;&lt; 1;</span>
<span class="line-added">160   if ((scaled_value &gt;&gt; 1) != value) {</span>
<span class="line-added">161     scaled_value = SIZE_MAX;</span>
<span class="line-added">162   }</span>
<span class="line-added">163   _process_completed_buffers_threshold = scaled_value | 1;</span>
<span class="line-added">164 }</span>
<span class="line-added">165 </span>
<span class="line-added">166 void SATBMarkQueueSet::set_buffer_enqueue_threshold_percentage(uint value) {</span>
167   // Minimum threshold of 1 ensures enqueuing of completely full buffers.
168   size_t size = buffer_size();
<span class="line-modified">169   size_t enqueue_qty = (size * value) / 100;</span>
170   _buffer_enqueue_threshold = MAX2(size - enqueue_qty, (size_t)1);
171 }
172 
173 #ifdef ASSERT
174 void SATBMarkQueueSet::dump_active_states(bool expected_active) {
175   log_error(gc, verify)(&quot;Expected SATB active state: %s&quot;, expected_active ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
176   log_error(gc, verify)(&quot;Actual SATB active states:&quot;);
177   log_error(gc, verify)(&quot;  Queue set: %s&quot;, is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
178 
179   class DumpThreadStateClosure : public ThreadClosure {
180     SATBMarkQueueSet* _qset;
181   public:
182     DumpThreadStateClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
183     virtual void do_thread(Thread* t) {
184       SATBMarkQueue&amp; queue = _qset-&gt;satb_queue_for_thread(t);
185       log_error(gc, verify)(&quot;  Thread \&quot;%s\&quot; queue: %s&quot;,
186                             t-&gt;name(),
187                             queue.is_active() ? &quot;ACTIVE&quot; : &quot;INACTIVE&quot;);
188     }
189   } closure(this);
</pre>
<hr />
<pre>
203     bool _expected_active;
204   public:
205     VerifyThreadStatesClosure(SATBMarkQueueSet* qset, bool expected_active) :
206       _qset(qset), _expected_active(expected_active) {}
207     virtual void do_thread(Thread* t) {
208       if (_qset-&gt;satb_queue_for_thread(t).is_active() != _expected_active) {
209         _qset-&gt;dump_active_states(_expected_active);
210         fatal(&quot;Thread SATB queue has an unexpected active state&quot;);
211       }
212     }
213   } closure(this, expected_active);
214   Threads::threads_do(&amp;closure);
215 }
216 #endif // ASSERT
217 
218 void SATBMarkQueueSet::set_active_all_threads(bool active, bool expected_active) {
219   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
220 #ifdef ASSERT
221   verify_active_states(expected_active);
222 #endif // ASSERT
<span class="line-modified">223   // Update the global state, synchronized with threads list management.</span>
<span class="line-added">224   {</span>
<span class="line-added">225     MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="line-added">226     _all_active = active;</span>
<span class="line-added">227   }</span>
228 
229   class SetThreadActiveClosure : public ThreadClosure {
230     SATBMarkQueueSet* _qset;
231     bool _active;
232   public:
233     SetThreadActiveClosure(SATBMarkQueueSet* qset, bool active) :
234       _qset(qset), _active(active) {}
235     virtual void do_thread(Thread* t) {
236       _qset-&gt;satb_queue_for_thread(t).set_active(_active);
237     }
238   } closure(this, active);
239   Threads::threads_do(&amp;closure);
240 }
241 












242 bool SATBMarkQueueSet::apply_closure_to_completed_buffer(SATBBufferClosure* cl) {
243   BufferNode* nd = get_completed_buffer();
244   if (nd != NULL) {
245     void **buf = BufferNode::make_buffer_from_node(nd);
246     size_t index = nd-&gt;index();
247     size_t size = buffer_size();
248     assert(index &lt;= size, &quot;invariant&quot;);
249     cl-&gt;do_buffer(buf + index, size - index);
250     deallocate_buffer(nd);
251     return true;
252   } else {
253     return false;
254   }
255 }
256 
<span class="line-added">257 // SATB buffer life-cycle - Per-thread queues obtain buffers from the</span>
<span class="line-added">258 // qset&#39;s buffer allocator, fill them, and push them onto the qset&#39;s</span>
<span class="line-added">259 // list.  The GC concurrently pops buffers from the qset, processes</span>
<span class="line-added">260 // them, and returns them to the buffer allocator for re-use.  Both</span>
<span class="line-added">261 // the allocator and the qset use lock-free stacks.  The ABA problem</span>
<span class="line-added">262 // is solved by having both allocation pops and GC pops performed</span>
<span class="line-added">263 // within GlobalCounter critical sections, while the return of buffers</span>
<span class="line-added">264 // to the allocator performs a GlobalCounter synchronize before</span>
<span class="line-added">265 // pushing onto the allocator&#39;s list.</span>
<span class="line-added">266 </span>
<span class="line-added">267 void SATBMarkQueueSet::enqueue_completed_buffer(BufferNode* node) {</span>
<span class="line-added">268   assert(node != NULL, &quot;precondition&quot;);</span>
<span class="line-added">269   // Increment count and update flag appropriately.  Done before</span>
<span class="line-added">270   // pushing buffer so count is always at least the actual number in</span>
<span class="line-added">271   // the list, and decrement never underflows.</span>
<span class="line-added">272   increment_count(&amp;_count_and_process_flag, _process_completed_buffers_threshold);</span>
<span class="line-added">273   _list.push(*node);</span>
<span class="line-added">274 }</span>
<span class="line-added">275 </span>
<span class="line-added">276 BufferNode* SATBMarkQueueSet::get_completed_buffer() {</span>
<span class="line-added">277   BufferNode* node;</span>
<span class="line-added">278   {</span>
<span class="line-added">279     GlobalCounter::CriticalSection cs(Thread::current());</span>
<span class="line-added">280     node = _list.pop();</span>
<span class="line-added">281   }</span>
<span class="line-added">282   if (node != NULL) {</span>
<span class="line-added">283     // Got a buffer so decrement count and update flag appropriately.</span>
<span class="line-added">284     decrement_count(&amp;_count_and_process_flag);</span>
<span class="line-added">285   }</span>
<span class="line-added">286   return node;</span>
<span class="line-added">287 }</span>
<span class="line-added">288 </span>
289 #ifndef PRODUCT
290 // Helpful for debugging
291 
292 #define SATB_PRINTER_BUFFER_SIZE 256
293 
294 void SATBMarkQueueSet::print_all(const char* msg) {
295   char buffer[SATB_PRINTER_BUFFER_SIZE];
296   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
297 
298   tty-&gt;cr();
299   tty-&gt;print_cr(&quot;SATB BUFFERS [%s]&quot;, msg);
300 
<span class="line-modified">301   BufferNode* nd = _list.top();</span>
302   int i = 0;
303   while (nd != NULL) {
304     void** buf = BufferNode::make_buffer_from_node(nd);
305     os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Enqueued: %d&quot;, i);
306     print_satb_buffer(buffer, buf, nd-&gt;index(), buffer_size());
307     nd = nd-&gt;next();
308     i += 1;
309   }
310 
311   class PrintThreadClosure : public ThreadClosure {
312     SATBMarkQueueSet* _qset;
313     char* _buffer;
314 
315   public:
316     PrintThreadClosure(SATBMarkQueueSet* qset, char* buffer) :
317       _qset(qset), _buffer(buffer) {}
318 
319     virtual void do_thread(Thread* t) {
320       os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, &quot;Thread: %s&quot;, t-&gt;name());
321       _qset-&gt;satb_queue_for_thread(t).print(_buffer);
322     }
323   } closure(this, buffer);
324   Threads::threads_do(&amp;closure);
325 
326   tty-&gt;cr();
327 }
328 #endif // PRODUCT
329 
<span class="line-added">330 void SATBMarkQueueSet::abandon_completed_buffers() {</span>
<span class="line-added">331   Atomic::store(&amp;_count_and_process_flag, size_t(0));</span>
<span class="line-added">332   BufferNode* buffers_to_delete = _list.pop_all();</span>
<span class="line-added">333   while (buffers_to_delete != NULL) {</span>
<span class="line-added">334     BufferNode* bn = buffers_to_delete;</span>
<span class="line-added">335     buffers_to_delete = bn-&gt;next();</span>
<span class="line-added">336     bn-&gt;set_next(NULL);</span>
<span class="line-added">337     deallocate_buffer(bn);</span>
<span class="line-added">338   }</span>
<span class="line-added">339 }</span>
<span class="line-added">340 </span>
341 void SATBMarkQueueSet::abandon_partial_marking() {
342   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);
343   abandon_completed_buffers();
344 
345   class AbandonThreadQueueClosure : public ThreadClosure {
346     SATBMarkQueueSet* _qset;
347   public:
348     AbandonThreadQueueClosure(SATBMarkQueueSet* qset) : _qset(qset) {}
349     virtual void do_thread(Thread* t) {
350       _qset-&gt;satb_queue_for_thread(t).reset();
351     }
352   } closure(this);
353   Threads::threads_do(&amp;closure);
354 }
</pre>
</td>
</tr>
</table>
<center><a href="referenceProcessorPhaseTimes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="satbMarkQueue.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/referenceProcessor.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_REFERENCEPROCESSOR_HPP
 26 #define SHARE_GC_SHARED_REFERENCEPROCESSOR_HPP
 27 
 28 #include &quot;gc/shared/referenceDiscoverer.hpp&quot;
 29 #include &quot;gc/shared/referencePolicy.hpp&quot;
 30 #include &quot;gc/shared/referenceProcessorStats.hpp&quot;
 31 #include &quot;memory/referenceType.hpp&quot;
 32 #include &quot;oops/instanceRefKlass.hpp&quot;
 33 
 34 class AbstractRefProcTaskExecutor;
 35 class GCTimer;
 36 class ReferencePolicy;
 37 class ReferenceProcessorPhaseTimes;
 38 
 39 // List of discovered references.
 40 class DiscoveredList {
 41 public:
 42   DiscoveredList() : _oop_head(NULL), _compressed_head(0), _len(0) { }
 43   inline oop head() const;
 44   HeapWord* adr_head() {
 45     return UseCompressedOops ? (HeapWord*)&amp;_compressed_head :
 46                                (HeapWord*)&amp;_oop_head;
 47   }
 48   inline void set_head(oop o);
 49   inline bool is_empty() const;
 50   size_t length()               { return _len; }
 51   void   set_length(size_t len) { _len = len;  }
 52   void   inc_length(size_t inc) { _len += inc; assert(_len &gt; 0, &quot;Error&quot;); }
 53   void   dec_length(size_t dec) { _len -= dec; }
 54 
 55   inline void clear();
 56 private:
 57   // Set value depending on UseCompressedOops. This could be a template class
 58   // but then we have to fix all the instantiations and declarations that use this class.
 59   oop       _oop_head;
 60   narrowOop _compressed_head;
 61   size_t _len;
 62 };
 63 
 64 // Iterator for the list of discovered references.
 65 class DiscoveredListIterator {
 66 private:
 67   DiscoveredList&amp;    _refs_list;
 68   HeapWord*          _prev_discovered_addr;
 69   oop                _prev_discovered;
 70   oop                _current_discovered;
 71   HeapWord*          _current_discovered_addr;
 72   oop                _next_discovered;
 73 
 74   HeapWord*          _referent_addr;
 75   oop                _referent;
 76 
 77   OopClosure*        _keep_alive;
 78   BoolObjectClosure* _is_alive;
 79 
 80   DEBUG_ONLY(
 81   oop                _first_seen; // cyclic linked list check
 82   )
 83 
 84   size_t             _processed;
 85   size_t             _removed;
 86 
 87 public:
 88   inline DiscoveredListIterator(DiscoveredList&amp;    refs_list,
 89                                 OopClosure*        keep_alive,
 90                                 BoolObjectClosure* is_alive);
 91 
 92   // End Of List.
 93   inline bool has_next() const { return _current_discovered != NULL; }
 94 
 95   // Get oop to the Reference object.
 96   inline oop obj() const { return _current_discovered; }
 97 
 98   // Get oop to the referent object.
 99   inline oop referent() const { return _referent; }
100 
101   // Returns true if referent is alive.
102   inline bool is_referent_alive() const {
103     return _is_alive-&gt;do_object_b(_referent);
104   }
105 
106   // Loads data for the current reference.
107   // The &quot;allow_null_referent&quot; argument tells us to allow for the possibility
108   // of a NULL referent in the discovered Reference object. This typically
109   // happens in the case of concurrent collectors that may have done the
110   // discovery concurrently, or interleaved, with mutator execution.
111   void load_ptrs(DEBUG_ONLY(bool allow_null_referent));
112 
113   // Move to the next discovered reference.
114   inline void next() {
115     _prev_discovered_addr = _current_discovered_addr;
116     _prev_discovered = _current_discovered;
117     move_to_next();
118   }
119 
120   // Remove the current reference from the list
121   void remove();
122 
123   // Make the referent alive.
124   inline void make_referent_alive() {
125     if (UseCompressedOops) {
126       _keep_alive-&gt;do_oop((narrowOop*)_referent_addr);
127     } else {
128       _keep_alive-&gt;do_oop((oop*)_referent_addr);
129     }
130   }
131 
132   // Do enqueuing work, i.e. notifying the GC about the changed discovered pointers.
133   void enqueue();
134 
135   // Move enqueued references to the reference pending list.
136   void complete_enqueue();
137 
138   // NULL out referent pointer.
139   void clear_referent();
140 
141   // Statistics
142   inline size_t processed() const { return _processed; }
143   inline size_t removed() const { return _removed; }
144 
145   inline void move_to_next() {
<a name="1" id="anc1"></a><span class="line-modified">146     if (_current_discovered == _next_discovered) {</span>
147       // End of the list.
148       _current_discovered = NULL;
149     } else {
150       _current_discovered = _next_discovered;
151     }
<a name="2" id="anc2"></a><span class="line-modified">152     assert(_current_discovered != _first_seen, &quot;cyclic ref_list found&quot;);</span>
153     _processed++;
154   }
155 };
156 
157 // The ReferenceProcessor class encapsulates the per-&quot;collector&quot; processing
158 // of java.lang.Reference objects for GC. The interface is useful for supporting
159 // a generational abstraction, in particular when there are multiple
160 // generations that are being independently collected -- possibly
161 // concurrently and/or incrementally.
162 // ReferenceProcessor class abstracts away from a generational setting
163 // by using a closure that determines whether a given reference or referent are
164 // subject to this ReferenceProcessor&#39;s discovery, thus allowing its use in a
165 // straightforward manner in a general, non-generational, non-contiguous generation
166 // (or heap) setting.
167 class ReferenceProcessor : public ReferenceDiscoverer {
168   friend class RefProcPhase1Task;
169   friend class RefProcPhase2Task;
170   friend class RefProcPhase3Task;
171   friend class RefProcPhase4Task;
172 public:
173   // Names of sub-phases of reference processing. Indicates the type of the reference
174   // processed and the associated phase number at the end.
175   enum RefProcSubPhases {
176     SoftRefSubPhase1,
177     SoftRefSubPhase2,
178     WeakRefSubPhase2,
179     FinalRefSubPhase2,
180     FinalRefSubPhase3,
181     PhantomRefSubPhase4,
182     RefSubPhaseMax
183   };
184 
185   // Main phases of reference processing.
186   enum RefProcPhases {
187     RefPhase1,
188     RefPhase2,
189     RefPhase3,
190     RefPhase4,
191     RefPhaseMax
192   };
193 
194 private:
195   size_t total_count(DiscoveredList lists[]) const;
196   void verify_total_count_zero(DiscoveredList lists[], const char* type) NOT_DEBUG_RETURN;
197 
198   // The SoftReference master timestamp clock
199   static jlong _soft_ref_timestamp_clock;
200 
201   BoolObjectClosure* _is_subject_to_discovery; // determines whether a given oop is subject
202                                                // to this ReferenceProcessor&#39;s discovery
203                                                // (and further processing).
204 
205   bool        _discovering_refs;        // true when discovery enabled
206   bool        _discovery_is_atomic;     // if discovery is atomic wrt
207                                         // other collectors in configuration
208   bool        _discovery_is_mt;         // true if reference discovery is MT.
209 
210   bool        _enqueuing_is_done;       // true if all weak references enqueued
211   bool        _processing_is_mt;        // true during phases when
212                                         // reference processing is MT.
213   uint        _next_id;                 // round-robin mod _num_queues counter in
214                                         // support of work distribution
215 
216   bool        _adjust_no_of_processing_threads; // allow dynamic adjustment of processing threads
217   // For collectors that do not keep GC liveness information
218   // in the object header, this field holds a closure that
219   // helps the reference processor determine the reachability
<a name="3" id="anc3"></a><span class="line-modified">220   // of an oop.</span>

221   BoolObjectClosure* _is_alive_non_header;
222 
223   // Soft ref clearing policies
224   // . the default policy
225   static ReferencePolicy*   _default_soft_ref_policy;
226   // . the &quot;clear all&quot; policy
227   static ReferencePolicy*   _always_clear_soft_ref_policy;
228   // . the current policy below is either one of the above
229   ReferencePolicy*          _current_soft_ref_policy;
230 
231   // The discovered ref lists themselves
232 
233   // The active MT&#39;ness degree of the queues below
234   uint            _num_queues;
235   // The maximum MT&#39;ness degree of the queues below
236   uint            _max_num_queues;
237 
238   // Master array of discovered oops
239   DiscoveredList* _discovered_refs;
240 
241   // Arrays of lists of oops, one per thread (pointers into master array above)
242   DiscoveredList* _discoveredSoftRefs;
243   DiscoveredList* _discoveredWeakRefs;
244   DiscoveredList* _discoveredFinalRefs;
245   DiscoveredList* _discoveredPhantomRefs;
246 
247   // Phase 1: Re-evaluate soft ref policy.
248   void process_soft_ref_reconsider(BoolObjectClosure* is_alive,
249                                    OopClosure* keep_alive,
250                                    VoidClosure* complete_gc,
251                                    AbstractRefProcTaskExecutor*  task_executor,
252                                    ReferenceProcessorPhaseTimes* phase_times);
253 
254   // Phase 2: Drop Soft/Weak/Final references with a NULL or live referent, and clear
255   // and enqueue non-Final references.
256   void process_soft_weak_final_refs(BoolObjectClosure* is_alive,
257                                     OopClosure* keep_alive,
258                                     VoidClosure* complete_gc,
259                                     AbstractRefProcTaskExecutor*  task_executor,
260                                     ReferenceProcessorPhaseTimes* phase_times);
261 
262   // Phase 3: Keep alive followers of Final references, and enqueue.
263   void process_final_keep_alive(OopClosure* keep_alive,
264                                 VoidClosure* complete_gc,
265                                 AbstractRefProcTaskExecutor*  task_executor,
266                                 ReferenceProcessorPhaseTimes* phase_times);
267 
268   // Phase 4: Drop and keep alive live Phantom references, or clear and enqueue if dead.
269   void process_phantom_refs(BoolObjectClosure* is_alive,
270                             OopClosure* keep_alive,
271                             VoidClosure* complete_gc,
272                             AbstractRefProcTaskExecutor*  task_executor,
273                             ReferenceProcessorPhaseTimes* phase_times);
274 
275   // Work methods used by the process_* methods. All methods return the number of
276   // removed elements.
277 
278   // (SoftReferences only) Traverse the list and remove any SoftReferences whose
279   // referents are not alive, but that should be kept alive for policy reasons.
280   // Keep alive the transitive closure of all such referents.
281   size_t process_soft_ref_reconsider_work(DiscoveredList&amp;     refs_list,
282                                           ReferencePolicy*    policy,
283                                           BoolObjectClosure*  is_alive,
284                                           OopClosure*         keep_alive,
285                                           VoidClosure*        complete_gc);
286 
287   // Traverse the list and remove any Refs whose referents are alive,
288   // or NULL if discovery is not atomic. Enqueue and clear the reference for
289   // others if do_enqueue_and_clear is set.
290   size_t process_soft_weak_final_refs_work(DiscoveredList&amp;    refs_list,
291                                            BoolObjectClosure* is_alive,
292                                            OopClosure*        keep_alive,
293                                            bool               do_enqueue_and_clear);
294 
295   // Keep alive followers of referents for FinalReferences. Must only be called for
296   // those.
297   size_t process_final_keep_alive_work(DiscoveredList&amp;    refs_list,
298                                        OopClosure*        keep_alive,
299                                        VoidClosure*       complete_gc);
300 
301   size_t process_phantom_refs_work(DiscoveredList&amp;    refs_list,
302                                    BoolObjectClosure* is_alive,
303                                    OopClosure*        keep_alive,
304                                    VoidClosure*       complete_gc);
305 
306 public:
307   static int number_of_subclasses_of_ref() { return (REF_PHANTOM - REF_OTHER); }
308 
309   uint num_queues() const                  { return _num_queues; }
310   uint max_num_queues() const              { return _max_num_queues; }
311   void set_active_mt_degree(uint v);
312 
313   ReferencePolicy* setup_policy(bool always_clear) {
314     _current_soft_ref_policy = always_clear ?
315       _always_clear_soft_ref_policy : _default_soft_ref_policy;
316     _current_soft_ref_policy-&gt;setup();   // snapshot the policy threshold
317     return _current_soft_ref_policy;
318   }
319 
320   // &quot;Preclean&quot; all the discovered reference lists by removing references that
321   // are active (e.g. due to the mutator calling enqueue()) or with NULL or
322   // strongly reachable referents.
323   // The first argument is a predicate on an oop that indicates
324   // its (strong) reachability and the fourth is a closure that
325   // may be used to incrementalize or abort the precleaning process.
326   // The caller is responsible for taking care of potential
327   // interference with concurrent operations on these lists
328   // (or predicates involved) by other threads.
329   void preclean_discovered_references(BoolObjectClosure* is_alive,
330                                       OopClosure*        keep_alive,
331                                       VoidClosure*       complete_gc,
332                                       YieldClosure*      yield,
333                                       GCTimer*           gc_timer);
334 
335 private:
336   // Returns the name of the discovered reference list
337   // occupying the i / _num_queues slot.
338   const char* list_name(uint i);
339 
340   // &quot;Preclean&quot; the given discovered reference list by removing references with
341   // the attributes mentioned in preclean_discovered_references().
342   // Supports both normal and fine grain yielding.
343   // Returns whether the operation should be aborted.
344   bool preclean_discovered_reflist(DiscoveredList&amp;    refs_list,
345                                    BoolObjectClosure* is_alive,
346                                    OopClosure*        keep_alive,
347                                    VoidClosure*       complete_gc,
348                                    YieldClosure*      yield);
349 
350   // round-robin mod _num_queues (not: _not_ mod _max_num_queues)
351   uint next_id() {
352     uint id = _next_id;
353     assert(!_discovery_is_mt, &quot;Round robin should only be used in serial discovery&quot;);
354     if (++_next_id == _num_queues) {
355       _next_id = 0;
356     }
357     assert(_next_id &lt; _num_queues, &quot;_next_id %u _num_queues %u _max_num_queues %u&quot;, _next_id, _num_queues, _max_num_queues);
358     return id;
359   }
360   DiscoveredList* get_discovered_list(ReferenceType rt);
361   inline void add_to_discovered_list_mt(DiscoveredList&amp; refs_list, oop obj,
362                                         HeapWord* discovered_addr);
363 
364   void clear_discovered_references(DiscoveredList&amp; refs_list);
365 
366   void log_reflist(const char* prefix, DiscoveredList list[], uint num_active_queues);
367   void log_reflist_counts(DiscoveredList ref_lists[], uint num_active_queues) PRODUCT_RETURN;
368 
369   // Balances reference queues.
370   void balance_queues(DiscoveredList refs_lists[]);
371   bool need_balance_queues(DiscoveredList refs_lists[]);
372 
373   // If there is need to balance the given queue, do it.
374   void maybe_balance_queues(DiscoveredList refs_lists[]);
375 
376   // Update (advance) the soft ref master clock field.
377   void update_soft_ref_master_clock();
378 
379   bool is_subject_to_discovery(oop const obj) const;
380 
381   bool is_mt_processing_set_up(AbstractRefProcTaskExecutor* task_executor) const;
382 
383 public:
384   // Default parameters give you a vanilla reference processor.
385   ReferenceProcessor(BoolObjectClosure* is_subject_to_discovery,
386                      bool mt_processing = false, uint mt_processing_degree = 1,
387                      bool mt_discovery  = false, uint mt_discovery_degree  = 1,
388                      bool atomic_discovery = true,
389                      BoolObjectClosure* is_alive_non_header = NULL,
390                      bool adjust_no_of_processing_threads = false);
391 
392   // RefDiscoveryPolicy values
393   enum DiscoveryPolicy {
394     ReferenceBasedDiscovery = 0,
395     ReferentBasedDiscovery  = 1,
396     DiscoveryPolicyMin      = ReferenceBasedDiscovery,
397     DiscoveryPolicyMax      = ReferentBasedDiscovery
398   };
399 
400   static void init_statics();
401 
402   // get and set &quot;is_alive_non_header&quot; field
403   BoolObjectClosure* is_alive_non_header() {
404     return _is_alive_non_header;
405   }
406   void set_is_alive_non_header(BoolObjectClosure* is_alive_non_header) {
407     _is_alive_non_header = is_alive_non_header;
408   }
409 
410   BoolObjectClosure* is_subject_to_discovery_closure() const { return _is_subject_to_discovery; }
411   void set_is_subject_to_discovery_closure(BoolObjectClosure* cl) { _is_subject_to_discovery = cl; }
412 
413   // start and stop weak ref discovery
414   void enable_discovery(bool check_no_refs = true);
415   void disable_discovery()  { _discovering_refs = false; }
416   bool discovery_enabled()  { return _discovering_refs;  }
417 
418   // whether discovery is atomic wrt other collectors
419   bool discovery_is_atomic() const { return _discovery_is_atomic; }
420   void set_atomic_discovery(bool atomic) { _discovery_is_atomic = atomic; }
421 
422   // whether discovery is done by multiple threads same-old-timeously
423   bool discovery_is_mt() const { return _discovery_is_mt; }
424   void set_mt_discovery(bool mt) { _discovery_is_mt = mt; }
425 
426   // Whether we are in a phase when _processing_ is MT.
427   bool processing_is_mt() const { return _processing_is_mt; }
428   void set_mt_processing(bool mt) { _processing_is_mt = mt; }
429 
430   // whether all enqueueing of weak references is complete
431   bool enqueuing_is_done()  { return _enqueuing_is_done; }
432   void set_enqueuing_is_done(bool v) { _enqueuing_is_done = v; }
433 
434   // iterate over oops
435   void weak_oops_do(OopClosure* f);       // weak roots
436 
437   void verify_list(DiscoveredList&amp; ref_list);
438 
439   // Discover a Reference object, using appropriate discovery criteria
440   virtual bool discover_reference(oop obj, ReferenceType rt);
441 
442   // Has discovered references that need handling
443   bool has_discovered_references();
444 
445   // Process references found during GC (called by the garbage collector)
446   ReferenceProcessorStats
447   process_discovered_references(BoolObjectClosure*            is_alive,
448                                 OopClosure*                   keep_alive,
449                                 VoidClosure*                  complete_gc,
450                                 AbstractRefProcTaskExecutor*  task_executor,
451                                 ReferenceProcessorPhaseTimes* phase_times);
452 
453   // If a discovery is in process that is being superceded, abandon it: all
454   // the discovered lists will be empty, and all the objects on them will
455   // have NULL discovered fields.  Must be called only at a safepoint.
456   void abandon_partial_discovery();
457 
458   size_t total_reference_count(ReferenceType rt) const;
459 
460   // debugging
461   void verify_no_references_recorded() PRODUCT_RETURN;
462   void verify_referent(oop obj)        PRODUCT_RETURN;
463 
464   bool adjust_no_of_processing_threads() const { return _adjust_no_of_processing_threads; }
465 };
466 
467 // A subject-to-discovery closure that uses a single memory span to determine the area that
468 // is subject to discovery. Useful for collectors which have contiguous generations.
469 class SpanSubjectToDiscoveryClosure : public BoolObjectClosure {
470   MemRegion _span;
471 
472 public:
473   SpanSubjectToDiscoveryClosure() : BoolObjectClosure(), _span() { }
474   SpanSubjectToDiscoveryClosure(MemRegion span) : BoolObjectClosure(), _span(span) { }
475 
476   MemRegion span() const { return _span; }
477 
478   void set_span(MemRegion mr) {
479     _span = mr;
480   }
481 
482   virtual bool do_object_b(oop obj) {
483     return _span.contains(obj);
484   }
485 };
486 
487 // A utility class to disable reference discovery in
488 // the scope which contains it, for given ReferenceProcessor.
489 class NoRefDiscovery: StackObj {
490  private:
491   ReferenceProcessor* _rp;
492   bool _was_discovering_refs;
493  public:
494   NoRefDiscovery(ReferenceProcessor* rp) : _rp(rp) {
495     _was_discovering_refs = _rp-&gt;discovery_enabled();
496     if (_was_discovering_refs) {
497       _rp-&gt;disable_discovery();
498     }
499   }
500 
501   ~NoRefDiscovery() {
502     if (_was_discovering_refs) {
503       _rp-&gt;enable_discovery(false /*check_no_refs*/);
504     }
505   }
506 };
507 
508 // A utility class to temporarily mutate the subject discovery closure of the
509 // given ReferenceProcessor in the scope that contains it.
510 class ReferenceProcessorSubjectToDiscoveryMutator : StackObj {
511   ReferenceProcessor* _rp;
512   BoolObjectClosure* _saved_cl;
513 
514 public:
515   ReferenceProcessorSubjectToDiscoveryMutator(ReferenceProcessor* rp, BoolObjectClosure* cl):
516     _rp(rp) {
517     _saved_cl = _rp-&gt;is_subject_to_discovery_closure();
518     _rp-&gt;set_is_subject_to_discovery_closure(cl);
519   }
520 
521   ~ReferenceProcessorSubjectToDiscoveryMutator() {
522     _rp-&gt;set_is_subject_to_discovery_closure(_saved_cl);
523   }
524 };
525 
526 // A utility class to temporarily mutate the span of the
527 // given ReferenceProcessor in the scope that contains it.
528 class ReferenceProcessorSpanMutator : StackObj {
529   ReferenceProcessor* _rp;
530   SpanSubjectToDiscoveryClosure _discoverer;
531   BoolObjectClosure* _old_discoverer;
532 
533 public:
534   ReferenceProcessorSpanMutator(ReferenceProcessor* rp,
535                                 MemRegion span):
536     _rp(rp),
537     _discoverer(span),
538     _old_discoverer(rp-&gt;is_subject_to_discovery_closure()) {
539 
540     rp-&gt;set_is_subject_to_discovery_closure(&amp;_discoverer);
541   }
542 
543   ~ReferenceProcessorSpanMutator() {
544     _rp-&gt;set_is_subject_to_discovery_closure(_old_discoverer);
545   }
546 };
547 
548 // A utility class to temporarily change the MT&#39;ness of
549 // reference discovery for the given ReferenceProcessor
550 // in the scope that contains it.
551 class ReferenceProcessorMTDiscoveryMutator: StackObj {
552  private:
553   ReferenceProcessor* _rp;
554   bool                _saved_mt;
555 
556  public:
557   ReferenceProcessorMTDiscoveryMutator(ReferenceProcessor* rp,
558                                        bool mt):
559     _rp(rp) {
560     _saved_mt = _rp-&gt;discovery_is_mt();
561     _rp-&gt;set_mt_discovery(mt);
562   }
563 
564   ~ReferenceProcessorMTDiscoveryMutator() {
565     _rp-&gt;set_mt_discovery(_saved_mt);
566   }
567 };
568 
569 // A utility class to temporarily change the disposition
570 // of the &quot;is_alive_non_header&quot; closure field of the
571 // given ReferenceProcessor in the scope that contains it.
572 class ReferenceProcessorIsAliveMutator: StackObj {
573  private:
574   ReferenceProcessor* _rp;
575   BoolObjectClosure*  _saved_cl;
576 
577  public:
578   ReferenceProcessorIsAliveMutator(ReferenceProcessor* rp,
579                                    BoolObjectClosure*  cl):
580     _rp(rp) {
581     _saved_cl = _rp-&gt;is_alive_non_header();
582     _rp-&gt;set_is_alive_non_header(cl);
583   }
584 
585   ~ReferenceProcessorIsAliveMutator() {
586     _rp-&gt;set_is_alive_non_header(_saved_cl);
587   }
588 };
589 
590 // A utility class to temporarily change the disposition
591 // of the &quot;discovery_is_atomic&quot; field of the
592 // given ReferenceProcessor in the scope that contains it.
593 class ReferenceProcessorAtomicMutator: StackObj {
594  private:
595   ReferenceProcessor* _rp;
596   bool                _saved_atomic_discovery;
597 
598  public:
599   ReferenceProcessorAtomicMutator(ReferenceProcessor* rp,
600                                   bool atomic):
601     _rp(rp) {
602     _saved_atomic_discovery = _rp-&gt;discovery_is_atomic();
603     _rp-&gt;set_atomic_discovery(atomic);
604   }
605 
606   ~ReferenceProcessorAtomicMutator() {
607     _rp-&gt;set_atomic_discovery(_saved_atomic_discovery);
608   }
609 };
610 
611 
612 // A utility class to temporarily change the MT processing
613 // disposition of the given ReferenceProcessor instance
614 // in the scope that contains it.
615 class ReferenceProcessorMTProcMutator: StackObj {
616  private:
617   ReferenceProcessor* _rp;
618   bool  _saved_mt;
619 
620  public:
621   ReferenceProcessorMTProcMutator(ReferenceProcessor* rp,
622                                   bool mt):
623     _rp(rp) {
624     _saved_mt = _rp-&gt;processing_is_mt();
625     _rp-&gt;set_mt_processing(mt);
626   }
627 
628   ~ReferenceProcessorMTProcMutator() {
629     _rp-&gt;set_mt_processing(_saved_mt);
630   }
631 };
632 
633 // This class is an interface used to implement task execution for the
634 // reference processing.
635 class AbstractRefProcTaskExecutor {
636 public:
637 
638   // Abstract tasks to execute.
639   class ProcessTask;
640 
641   // Executes a task using worker threads.
642   virtual void execute(ProcessTask&amp; task, uint ergo_workers) = 0;
643 
644   // Switch to single threaded mode.
645   virtual void set_single_threaded_mode() { };
646 };
647 
648 // Abstract reference processing task to execute.
649 class AbstractRefProcTaskExecutor::ProcessTask {
650 protected:
651   ReferenceProcessor&amp;           _ref_processor;
652   // Indicates whether the phase could generate work that should be balanced across
653   // threads after execution.
654   bool                          _marks_oops_alive;
655   ReferenceProcessorPhaseTimes* _phase_times;
656 
657   ProcessTask(ReferenceProcessor&amp; ref_processor,
658               bool marks_oops_alive,
659               ReferenceProcessorPhaseTimes* phase_times)
660     : _ref_processor(ref_processor),
661       _marks_oops_alive(marks_oops_alive),
662       _phase_times(phase_times)
663   { }
664 
665 public:
666   virtual void work(uint worker_id,
667                     BoolObjectClosure&amp; is_alive,
668                     OopClosure&amp; keep_alive,
669                     VoidClosure&amp; complete_gc) = 0;
670 
671   bool marks_oops_alive() const { return _marks_oops_alive; }
672 };
673 
674 // Temporarily change the number of workers based on given reference count.
675 // This ergonomically decided worker count will be used to activate worker threads.
676 class RefProcMTDegreeAdjuster : public StackObj {
677   typedef ReferenceProcessor::RefProcPhases RefProcPhases;
678 
679   ReferenceProcessor* _rp;
680   bool                _saved_mt_processing;
681   uint                _saved_num_queues;
682 
683   // Calculate based on total of references.
684   uint ergo_proc_thread_count(size_t ref_count,
685                               uint max_threads,
686                               RefProcPhases phase) const;
687 
688   bool use_max_threads(RefProcPhases phase) const;
689 
690 public:
691   RefProcMTDegreeAdjuster(ReferenceProcessor* rp,
692                           RefProcPhases phase,
693                           size_t ref_count);
694   ~RefProcMTDegreeAdjuster();
695 };
696 
697 #endif // SHARE_GC_SHARED_REFERENCEPROCESSOR_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre> 1 /*
 2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #ifndef SHARE_GC_SHARED_THREADLOCALALLOCBUFFER_INLINE_HPP
26 #define SHARE_GC_SHARED_THREADLOCALALLOCBUFFER_INLINE_HPP
27 
28 #include &quot;gc/shared/collectedHeap.hpp&quot;
29 #include &quot;gc/shared/threadLocalAllocBuffer.hpp&quot;
<a name="1" id="anc1"></a>
30 #include &quot;logging/log.hpp&quot;
31 #include &quot;runtime/thread.hpp&quot;
32 #include &quot;utilities/copy.hpp&quot;
33 
34 inline HeapWord* ThreadLocalAllocBuffer::allocate(size_t size) {
35   invariants();
36   HeapWord* obj = top();
37   if (pointer_delta(end(), obj) &gt;= size) {
38     // successful thread-local allocation
39 #ifdef ASSERT
40     // Skip mangling the space corresponding to the object header to
41     // ensure that the returned space is not considered parsable by
42     // any concurrent GC thread.
43     size_t hdr_size = oopDesc::header_size();
44     Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);
45 #endif // ASSERT
46     // This addition is safe because we know that top is
47     // at least size below end, so the add can&#39;t wrap.
48     set_top(obj + size);
49 
50     invariants();
51     return obj;
52   }
53   return NULL;
54 }
55 
56 inline size_t ThreadLocalAllocBuffer::compute_size(size_t obj_size) {
57   // Compute the size for the new TLAB.
58   // The &quot;last&quot; tlab may be smaller to reduce fragmentation.
59   // unsafe_max_tlab_alloc is just a hint.
60   const size_t available_size = Universe::heap()-&gt;unsafe_max_tlab_alloc(thread()) / HeapWordSize;
61   size_t new_tlab_size = MIN3(available_size, desired_size() + align_object_size(obj_size), max_size());
62 
63   // Make sure there&#39;s enough room for object and filler int[].
64   if (new_tlab_size &lt; compute_min_size(obj_size)) {
65     // If there isn&#39;t enough room for the allocation, return failure.
66     log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns failure&quot;,
67                         obj_size);
68     return 0;
69   }
70   log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns &quot; SIZE_FORMAT,
71                       obj_size, new_tlab_size);
72   return new_tlab_size;
73 }
74 
75 inline size_t ThreadLocalAllocBuffer::compute_min_size(size_t obj_size) {
76   const size_t aligned_obj_size = align_object_size(obj_size);
77   const size_t size_with_reserve = aligned_obj_size + alignment_reserve();
78   return MAX2(size_with_reserve, heap_word_size(MinTLABSize));
79 }
80 
81 void ThreadLocalAllocBuffer::record_slow_allocation(size_t obj_size) {
82   // Raise size required to bypass TLAB next time. Why? Else there&#39;s
83   // a risk that a thread that repeatedly allocates objects of one
84   // size will get stuck on this slow path.
85 
86   set_refill_waste_limit(refill_waste_limit() + refill_waste_limit_increment());
87 
88   _slow_allocations++;
89 
90   log_develop_trace(gc, tlab)(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;
91                               &quot; obj: &quot; SIZE_FORMAT
92                               &quot; free: &quot; SIZE_FORMAT
93                               &quot; waste: &quot; SIZE_FORMAT,
94                               &quot;slow&quot;, p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),
95                               obj_size, free(), refill_waste_limit());
96 }
97 
98 #endif // SHARE_GC_SHARED_THREADLOCALALLOCBUFFER_INLINE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
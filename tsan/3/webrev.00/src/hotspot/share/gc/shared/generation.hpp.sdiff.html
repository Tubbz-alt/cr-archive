<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/generation.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="generation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generationCounters.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/generation.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENERATION_HPP
 26 #define SHARE_GC_SHARED_GENERATION_HPP
 27 
 28 #include &quot;gc/shared/collectorCounters.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/memRegion.hpp&quot;
<span class="line-removed"> 33 #include &quot;memory/universe.hpp&quot;</span>
 34 #include &quot;memory/virtualspace.hpp&quot;
 35 #include &quot;runtime/mutex.hpp&quot;
 36 #include &quot;runtime/perfData.hpp&quot;
 37 
 38 // A Generation models a heap area for similarly-aged objects.
 39 // It will contain one ore more spaces holding the actual objects.
 40 //
 41 // The Generation class hierarchy:
 42 //
 43 // Generation                      - abstract base class
 44 // - DefNewGeneration              - allocation area (copy collected)
<span class="line-removed"> 45 //   - ParNewGeneration            - a DefNewGeneration that is collected by</span>
<span class="line-removed"> 46 //                                   several threads</span>
 47 // - CardGeneration                 - abstract class adding offset array behavior
 48 //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)
<span class="line-removed"> 49 //   - ConcurrentMarkSweepGeneration - Mostly Concurrent Mark Sweep Generation</span>
<span class="line-removed"> 50 //                                       (Detlefs-Printezis refinement of</span>
<span class="line-removed"> 51 //                                       Boehm-Demers-Schenker)</span>
 52 //
<span class="line-modified"> 53 // The system configurations currently allowed are:</span>
 54 //
 55 //   DefNewGeneration + TenuredGeneration
 56 //
<span class="line-removed"> 57 //   ParNewGeneration + ConcurrentMarkSweepGeneration</span>
<span class="line-removed"> 58 //</span>
 59 
 60 class DefNewGeneration;
 61 class GCMemoryManager;
 62 class GenerationSpec;
 63 class CompactibleSpace;
 64 class ContiguousSpace;
 65 class CompactPoint;
 66 class OopsInGenClosure;
 67 class OopClosure;
 68 class ScanClosure;
 69 class FastScanClosure;
 70 class GenCollectedHeap;
 71 class GCStats;
 72 
 73 // A &quot;ScratchBlock&quot; represents a block of memory in one generation usable by
 74 // another.  It represents &quot;num_words&quot; free words, starting at and including
 75 // the address of &quot;this&quot;.
 76 struct ScratchBlock {
 77   ScratchBlock* next;
 78   size_t num_words;
</pre>
<hr />
<pre>
106   // Performance Counters
107   CollectorCounters* _gc_counters;
108 
109   // Statistics for garbage collection
110   GCStats* _gc_stats;
111 
112   // Initialize the generation.
113   Generation(ReservedSpace rs, size_t initial_byte_size);
114 
115   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) (exactly) all the ref fields in
116   // &quot;sp&quot; that point into younger generations.
117   // The iteration is only over objects allocated at the start of the
118   // iterations; objects allocated as a result of applying the closure are
119   // not included.
120   void younger_refs_in_space_iterate(Space* sp, OopsInGenClosure* cl, uint n_threads);
121 
122  public:
123   // The set of possible generation kinds.
124   enum Name {
125     DefNew,
<span class="line-removed">126     ParNew,</span>
127     MarkSweepCompact,
<span class="line-removed">128     ConcurrentMarkSweep,</span>
129     Other
130   };
131 
132   enum SomePublicConstants {
133     // Generations are GenGrain-aligned and have size that are multiples of
134     // GenGrain.
135     // Note: on ARM we add 1 bit for card_table_base to be properly aligned
136     // (we expect its low byte to be zero - see implementation of post_barrier)
137     LogOfGenGrain = 16 ARM32_ONLY(+1),
138     GenGrain = 1 &lt;&lt; LogOfGenGrain
139   };
140 
141   // allocate and initialize (&quot;weak&quot;) refs processing support
142   virtual void ref_processor_init();
143   void set_ref_processor(ReferenceProcessor* rp) {
144     assert(_ref_processor == NULL, &quot;clobbering existing _ref_processor&quot;);
145     _ref_processor = rp;
146   }
147 
148   virtual Generation::Name kind() { return Generation::Other; }
</pre>
<hr />
<pre>
284     guarantee(false, &quot;Generation doesn&#39;t support thread local allocation buffers&quot;);
285     return 0;
286   }
287 
288   // &quot;obj&quot; is the address of an object in a younger generation.  Allocate space
289   // for &quot;obj&quot; in the current (or some higher) generation, and copy &quot;obj&quot; into
290   // the newly allocated space, if possible, returning the result (or NULL if
291   // the allocation failed).
292   //
293   // The &quot;obj_size&quot; argument is just obj-&gt;size(), passed along so the caller can
294   // avoid repeating the virtual call to retrieve it.
295   virtual oop promote(oop obj, size_t obj_size);
296 
297   // Thread &quot;thread_num&quot; (0 &lt;= i &lt; ParalleGCThreads) wants to promote
298   // object &quot;obj&quot;, whose original mark word was &quot;m&quot;, and whose size is
299   // &quot;word_sz&quot;.  If possible, allocate space for &quot;obj&quot;, copy obj into it
300   // (taking care to copy &quot;m&quot; into the mark word when done, since the mark
301   // word of &quot;obj&quot; may have been overwritten with a forwarding pointer, and
302   // also taking care to copy the klass pointer *last*.  Returns the new
303   // object if successful, or else NULL.
<span class="line-modified">304   virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);</span>
305 
306   // Informs the current generation that all par_promote_alloc&#39;s in the
307   // collection have been completed; any supporting data structures can be
308   // reset.  Default is to do nothing.
309   virtual void par_promote_alloc_done(int thread_num) {}
310 
311   // Informs the current generation that all oop_since_save_marks_iterates
312   // performed by &quot;thread_num&quot; in the current collection, if any, have been
313   // completed; any supporting data structures can be reset.  Default is to
314   // do nothing.
315   virtual void par_oop_since_save_marks_iterate_done(int thread_num) {}
316 
317   // Returns &quot;true&quot; iff collect() should subsequently be called on this
318   // this generation. See comment below.
319   // This is a generic implementation which can be overridden.
320   //
321   // Note: in the current (1.4) implementation, when genCollectedHeap&#39;s
322   // incremental_collection_will_fail flag is set, all allocations are
323   // slow path (the only fast-path place to allocate is DefNew, which
324   // will be full if the flag is set).
</pre>
<hr />
<pre>
463   // younger), allowing them to resize themselves as appropriate.
464   virtual void compute_new_size() = 0;
465 
466   // Printing
467   virtual const char* name() const = 0;
468   virtual const char* short_name() const = 0;
469 
470   // Reference Processing accessor
471   ReferenceProcessor* const ref_processor() { return _ref_processor; }
472 
473   // Iteration.
474 
475   // Iterate over all the ref-containing fields of all objects in the
476   // generation, calling &quot;cl.do_oop&quot; on each.
477   virtual void oop_iterate(OopIterateClosure* cl);
478 
479   // Iterate over all objects in the generation, calling &quot;cl.do_object&quot; on
480   // each.
481   virtual void object_iterate(ObjectClosure* cl);
482 
<span class="line-removed">483   // Iterate over all safe objects in the generation, calling &quot;cl.do_object&quot; on</span>
<span class="line-removed">484   // each.  An object is safe if its references point to other objects in</span>
<span class="line-removed">485   // the heap.  This defaults to object_iterate() unless overridden.</span>
<span class="line-removed">486   virtual void safe_object_iterate(ObjectClosure* cl);</span>
<span class="line-removed">487 </span>
488   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) all and only all the ref fields
489   // in the current generation that contain pointers to objects in younger
490   // generations. Objects allocated since the last &quot;save_marks&quot; call are
491   // excluded.
492   virtual void younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) = 0;
493 
494   // Inform a generation that it longer contains references to objects
495   // in any younger generation.    [e.g. Because younger gens are empty,
496   // clear the card table.]
497   virtual void clear_remembered_set() { }
498 
499   // Inform a generation that some of its objects have moved.  [e.g. The
500   // generation&#39;s spaces were compacted, invalidating the card table.]
501   virtual void invalidate_remembered_set() { }
502 
503   // Block abstraction.
504 
505   // Returns the address of the start of the &quot;block&quot; that contains the
506   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
507   // may not pack objects densely; a chunk may either be an object or a
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_GENERATION_HPP
 26 #define SHARE_GC_SHARED_GENERATION_HPP
 27 
 28 #include &quot;gc/shared/collectorCounters.hpp&quot;
 29 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/memRegion.hpp&quot;

 33 #include &quot;memory/virtualspace.hpp&quot;
 34 #include &quot;runtime/mutex.hpp&quot;
 35 #include &quot;runtime/perfData.hpp&quot;
 36 
 37 // A Generation models a heap area for similarly-aged objects.
 38 // It will contain one ore more spaces holding the actual objects.
 39 //
 40 // The Generation class hierarchy:
 41 //
 42 // Generation                      - abstract base class
 43 // - DefNewGeneration              - allocation area (copy collected)


 44 // - CardGeneration                 - abstract class adding offset array behavior
 45 //   - TenuredGeneration             - tenured (old object) space (markSweepCompact)



 46 //
<span class="line-modified"> 47 // The system configuration currently allowed is:</span>
 48 //
 49 //   DefNewGeneration + TenuredGeneration
 50 //


 51 
 52 class DefNewGeneration;
 53 class GCMemoryManager;
 54 class GenerationSpec;
 55 class CompactibleSpace;
 56 class ContiguousSpace;
 57 class CompactPoint;
 58 class OopsInGenClosure;
 59 class OopClosure;
 60 class ScanClosure;
 61 class FastScanClosure;
 62 class GenCollectedHeap;
 63 class GCStats;
 64 
 65 // A &quot;ScratchBlock&quot; represents a block of memory in one generation usable by
 66 // another.  It represents &quot;num_words&quot; free words, starting at and including
 67 // the address of &quot;this&quot;.
 68 struct ScratchBlock {
 69   ScratchBlock* next;
 70   size_t num_words;
</pre>
<hr />
<pre>
 98   // Performance Counters
 99   CollectorCounters* _gc_counters;
100 
101   // Statistics for garbage collection
102   GCStats* _gc_stats;
103 
104   // Initialize the generation.
105   Generation(ReservedSpace rs, size_t initial_byte_size);
106 
107   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) (exactly) all the ref fields in
108   // &quot;sp&quot; that point into younger generations.
109   // The iteration is only over objects allocated at the start of the
110   // iterations; objects allocated as a result of applying the closure are
111   // not included.
112   void younger_refs_in_space_iterate(Space* sp, OopsInGenClosure* cl, uint n_threads);
113 
114  public:
115   // The set of possible generation kinds.
116   enum Name {
117     DefNew,

118     MarkSweepCompact,

119     Other
120   };
121 
122   enum SomePublicConstants {
123     // Generations are GenGrain-aligned and have size that are multiples of
124     // GenGrain.
125     // Note: on ARM we add 1 bit for card_table_base to be properly aligned
126     // (we expect its low byte to be zero - see implementation of post_barrier)
127     LogOfGenGrain = 16 ARM32_ONLY(+1),
128     GenGrain = 1 &lt;&lt; LogOfGenGrain
129   };
130 
131   // allocate and initialize (&quot;weak&quot;) refs processing support
132   virtual void ref_processor_init();
133   void set_ref_processor(ReferenceProcessor* rp) {
134     assert(_ref_processor == NULL, &quot;clobbering existing _ref_processor&quot;);
135     _ref_processor = rp;
136   }
137 
138   virtual Generation::Name kind() { return Generation::Other; }
</pre>
<hr />
<pre>
274     guarantee(false, &quot;Generation doesn&#39;t support thread local allocation buffers&quot;);
275     return 0;
276   }
277 
278   // &quot;obj&quot; is the address of an object in a younger generation.  Allocate space
279   // for &quot;obj&quot; in the current (or some higher) generation, and copy &quot;obj&quot; into
280   // the newly allocated space, if possible, returning the result (or NULL if
281   // the allocation failed).
282   //
283   // The &quot;obj_size&quot; argument is just obj-&gt;size(), passed along so the caller can
284   // avoid repeating the virtual call to retrieve it.
285   virtual oop promote(oop obj, size_t obj_size);
286 
287   // Thread &quot;thread_num&quot; (0 &lt;= i &lt; ParalleGCThreads) wants to promote
288   // object &quot;obj&quot;, whose original mark word was &quot;m&quot;, and whose size is
289   // &quot;word_sz&quot;.  If possible, allocate space for &quot;obj&quot;, copy obj into it
290   // (taking care to copy &quot;m&quot; into the mark word when done, since the mark
291   // word of &quot;obj&quot; may have been overwritten with a forwarding pointer, and
292   // also taking care to copy the klass pointer *last*.  Returns the new
293   // object if successful, or else NULL.
<span class="line-modified">294   virtual oop par_promote(int thread_num, oop obj, markWord m, size_t word_sz);</span>
295 
296   // Informs the current generation that all par_promote_alloc&#39;s in the
297   // collection have been completed; any supporting data structures can be
298   // reset.  Default is to do nothing.
299   virtual void par_promote_alloc_done(int thread_num) {}
300 
301   // Informs the current generation that all oop_since_save_marks_iterates
302   // performed by &quot;thread_num&quot; in the current collection, if any, have been
303   // completed; any supporting data structures can be reset.  Default is to
304   // do nothing.
305   virtual void par_oop_since_save_marks_iterate_done(int thread_num) {}
306 
307   // Returns &quot;true&quot; iff collect() should subsequently be called on this
308   // this generation. See comment below.
309   // This is a generic implementation which can be overridden.
310   //
311   // Note: in the current (1.4) implementation, when genCollectedHeap&#39;s
312   // incremental_collection_will_fail flag is set, all allocations are
313   // slow path (the only fast-path place to allocate is DefNew, which
314   // will be full if the flag is set).
</pre>
<hr />
<pre>
453   // younger), allowing them to resize themselves as appropriate.
454   virtual void compute_new_size() = 0;
455 
456   // Printing
457   virtual const char* name() const = 0;
458   virtual const char* short_name() const = 0;
459 
460   // Reference Processing accessor
461   ReferenceProcessor* const ref_processor() { return _ref_processor; }
462 
463   // Iteration.
464 
465   // Iterate over all the ref-containing fields of all objects in the
466   // generation, calling &quot;cl.do_oop&quot; on each.
467   virtual void oop_iterate(OopIterateClosure* cl);
468 
469   // Iterate over all objects in the generation, calling &quot;cl.do_object&quot; on
470   // each.
471   virtual void object_iterate(ObjectClosure* cl);
472 





473   // Apply &quot;cl-&gt;do_oop&quot; to (the address of) all and only all the ref fields
474   // in the current generation that contain pointers to objects in younger
475   // generations. Objects allocated since the last &quot;save_marks&quot; call are
476   // excluded.
477   virtual void younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) = 0;
478 
479   // Inform a generation that it longer contains references to objects
480   // in any younger generation.    [e.g. Because younger gens are empty,
481   // clear the card table.]
482   virtual void clear_remembered_set() { }
483 
484   // Inform a generation that some of its objects have moved.  [e.g. The
485   // generation&#39;s spaces were compacted, invalidating the card table.]
486   virtual void invalidate_remembered_set() { }
487 
488   // Block abstraction.
489 
490   // Returns the address of the start of the &quot;block&quot; that contains the
491   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps
492   // may not pack objects densely; a chunk may either be an object or a
</pre>
</td>
</tr>
</table>
<center><a href="generation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="generationCounters.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../c1/barrierSetC1.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetC2.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/c2/barrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;opto/convertnode.hpp&quot;
  #include &quot;opto/graphKit.hpp&quot;
  #include &quot;opto/idealKit.hpp&quot;
  #include &quot;opto/macro.hpp&quot;
  #include &quot;opto/narrowptrnode.hpp&quot;
<span class="line-added">+ #include &quot;opto/runtime.hpp&quot;</span>
  #include &quot;utilities/macros.hpp&quot;
  
  // By default this is a no-op.
  void BarrierSetC2::resolve_address(C2Access&amp; access) const { }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,17 ***</span>
  }
  
  PhaseGVN&amp; C2ParseAccess::gvn() const { return _kit-&gt;gvn(); }
  
  bool C2Access::needs_cpu_membar() const {
<span class="line-modified">!   bool mismatched = (_decorators &amp; C2_MISMATCHED) != 0;</span>
    bool is_unordered = (_decorators &amp; MO_UNORDERED) != 0;
    bool anonymous = (_decorators &amp; C2_UNSAFE_ACCESS) != 0;
<span class="line-modified">!   bool in_heap = (_decorators &amp; IN_HEAP) != 0;</span>
  
<span class="line-modified">!   bool is_write = (_decorators &amp; C2_WRITE_ACCESS) != 0;</span>
<span class="line-modified">!   bool is_read = (_decorators &amp; C2_READ_ACCESS) != 0;</span>
    bool is_atomic = is_read &amp;&amp; is_write;
  
    if (is_atomic) {
      // Atomics always need to be wrapped in CPU membars
      return true;
<span class="line-new-header">--- 41,20 ---</span>
  }
  
  PhaseGVN&amp; C2ParseAccess::gvn() const { return _kit-&gt;gvn(); }
  
  bool C2Access::needs_cpu_membar() const {
<span class="line-modified">!   bool mismatched   = (_decorators &amp; C2_MISMATCHED) != 0;</span>
    bool is_unordered = (_decorators &amp; MO_UNORDERED) != 0;
<span class="line-added">+ </span>
    bool anonymous = (_decorators &amp; C2_UNSAFE_ACCESS) != 0;
<span class="line-modified">!   bool in_heap   = (_decorators &amp; IN_HEAP) != 0;</span>
<span class="line-added">+   bool in_native = (_decorators &amp; IN_NATIVE) != 0;</span>
<span class="line-added">+   bool is_mixed  = !in_heap &amp;&amp; !in_native;</span>
  
<span class="line-modified">!   bool is_write  = (_decorators &amp; C2_WRITE_ACCESS) != 0;</span>
<span class="line-modified">!   bool is_read   = (_decorators &amp; C2_READ_ACCESS) != 0;</span>
    bool is_atomic = is_read &amp;&amp; is_write;
  
    if (is_atomic) {
      // Atomics always need to be wrapped in CPU membars
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,13 ***</span>
      // We will need memory barriers unless we can determine a unique
      // alias category for this reference.  (Note:  If for some reason
      // the barriers get omitted and the unsafe reference begins to &quot;pollute&quot;
      // the alias analysis of the rest of the graph, either Compile::can_alias
      // or Compile::must_alias will throw a diagnostic assert.)
<span class="line-modified">!     if (!in_heap || !is_unordered || (mismatched &amp;&amp; !_addr.type()-&gt;isa_aryptr())) {</span>
        return true;
      }
    }
  
    return false;
  }
  
<span class="line-new-header">--- 64,15 ---</span>
      // We will need memory barriers unless we can determine a unique
      // alias category for this reference.  (Note:  If for some reason
      // the barriers get omitted and the unsafe reference begins to &quot;pollute&quot;
      // the alias analysis of the rest of the graph, either Compile::can_alias
      // or Compile::must_alias will throw a diagnostic assert.)
<span class="line-modified">!     if (is_mixed || !is_unordered || (mismatched &amp;&amp; !_addr.type()-&gt;isa_aryptr())) {</span>
        return true;
      }
<span class="line-added">+   } else {</span>
<span class="line-added">+     assert(!is_mixed, &quot;not unsafe&quot;);</span>
    }
  
    return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
    bool unaligned = (decorators &amp; C2_UNALIGNED) != 0;
    bool unsafe = (decorators &amp; C2_UNSAFE_ACCESS) != 0;
    bool requires_atomic_access = (decorators &amp; MO_UNORDERED) == 0;
  
    bool in_native = (decorators &amp; IN_NATIVE) != 0;
<span class="line-modified">!   assert(!in_native, &quot;not supported yet&quot;);</span>
  
    MemNode::MemOrd mo = access.mem_node_mo();
  
    Node* store;
    if (access.is_parse_access()) {
<span class="line-new-header">--- 83,11 ---</span>
    bool unaligned = (decorators &amp; C2_UNALIGNED) != 0;
    bool unsafe = (decorators &amp; C2_UNSAFE_ACCESS) != 0;
    bool requires_atomic_access = (decorators &amp; MO_UNORDERED) == 0;
  
    bool in_native = (decorators &amp; IN_NATIVE) != 0;
<span class="line-modified">!   assert(!in_native || (unsafe &amp;&amp; !access.is_oop()), &quot;not supported yet&quot;);</span>
  
    MemNode::MemOrd mo = access.mem_node_mo();
  
    Node* store;
    if (access.is_parse_access()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
        val.set_node(new_val);
      }
  
      store = kit-&gt;store_to_memory(kit-&gt;control(), access.addr().node(), val.node(), access.type(),
                                       access.addr().type(), mo, requires_atomic_access, unaligned, mismatched, unsafe);
<span class="line-removed">-     access.set_raw_access(store);</span>
    } else {
      assert(!requires_atomic_access, &quot;not yet supported&quot;);
      assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
      C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
      Node* ctl = opt_access.ctl();
<span class="line-new-header">--- 99,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,10 ***</span>
<span class="line-new-header">--- 122,12 ---</span>
      store = gvn.transform(st);
      if (store == st) {
        mm-&gt;set_memory_at(alias, st);
      }
    }
<span class="line-added">+   access.set_raw_access(store);</span>
<span class="line-added">+ </span>
    return store;
  }
  
  Node* BarrierSetC2::load_at_resolved(C2Access&amp; access, const Type* val_type) const {
    DecoratorSet decorators = access.decorators();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,42 ***</span>
  
    bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
    bool requires_atomic_access = (decorators &amp; MO_UNORDERED) == 0;
    bool unaligned = (decorators &amp; C2_UNALIGNED) != 0;
    bool control_dependent = (decorators &amp; C2_CONTROL_DEPENDENT_LOAD) != 0;
<span class="line-modified">!   bool pinned = (decorators &amp; C2_PINNED_LOAD) != 0;</span>
    bool unsafe = (decorators &amp; C2_UNSAFE_ACCESS) != 0;
  
    bool in_native = (decorators &amp; IN_NATIVE) != 0;
  
    MemNode::MemOrd mo = access.mem_node_mo();
<span class="line-modified">!   LoadNode::ControlDependency dep = pinned ? LoadNode::Pinned : LoadNode::DependsOnlyOnTest;</span>
  
    Node* load;
    if (access.is_parse_access()) {
      C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
      GraphKit* kit = parse_access.kit();
      Node* control = control_dependent ? kit-&gt;control() : NULL;
  
      if (in_native) {
<span class="line-modified">!       load = kit-&gt;make_load(control, adr, val_type, access.type(), mo);</span>
      } else {
        load = kit-&gt;make_load(control, adr, val_type, access.type(), adr_type, mo,
<span class="line-modified">!                             dep, requires_atomic_access, unaligned, mismatched, unsafe);</span>
      }
<span class="line-removed">-     access.set_raw_access(load);</span>
    } else {
      assert(!requires_atomic_access, &quot;not yet supported&quot;);
      assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
      C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
      Node* control = control_dependent ? opt_access.ctl() : NULL;
      MergeMemNode* mm = opt_access.mem();
      PhaseGVN&amp; gvn = opt_access.gvn();
      Node* mem = mm-&gt;memory_at(gvn.C-&gt;get_alias_index(adr_type));
<span class="line-modified">!     load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo, dep, unaligned, mismatched);</span>
      load = gvn.transform(load);
    }
  
    return load;
  }
  
  class C2AccessFence: public StackObj {
<span class="line-new-header">--- 137,46 ---</span>
  
    bool mismatched = (decorators &amp; C2_MISMATCHED) != 0;
    bool requires_atomic_access = (decorators &amp; MO_UNORDERED) == 0;
    bool unaligned = (decorators &amp; C2_UNALIGNED) != 0;
    bool control_dependent = (decorators &amp; C2_CONTROL_DEPENDENT_LOAD) != 0;
<span class="line-modified">!   bool unknown_control = (decorators &amp; C2_UNKNOWN_CONTROL_LOAD) != 0;</span>
    bool unsafe = (decorators &amp; C2_UNSAFE_ACCESS) != 0;
  
    bool in_native = (decorators &amp; IN_NATIVE) != 0;
  
    MemNode::MemOrd mo = access.mem_node_mo();
<span class="line-modified">!   LoadNode::ControlDependency dep = unknown_control ? LoadNode::UnknownControl : LoadNode::DependsOnlyOnTest;</span>
  
    Node* load;
    if (access.is_parse_access()) {
      C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
      GraphKit* kit = parse_access.kit();
      Node* control = control_dependent ? kit-&gt;control() : NULL;
  
      if (in_native) {
<span class="line-modified">!       load = kit-&gt;make_load(control, adr, val_type, access.type(), mo, dep,</span>
<span class="line-added">+                             requires_atomic_access, unaligned,</span>
<span class="line-added">+                             mismatched, unsafe, access.barrier_data());</span>
      } else {
        load = kit-&gt;make_load(control, adr, val_type, access.type(), adr_type, mo,
<span class="line-modified">!                             dep, requires_atomic_access, unaligned, mismatched, unsafe,</span>
<span class="line-added">+                             access.barrier_data());</span>
      }
    } else {
      assert(!requires_atomic_access, &quot;not yet supported&quot;);
      assert(access.is_opt_access(), &quot;either parse or opt access&quot;);
      C2OptAccess&amp; opt_access = static_cast&lt;C2OptAccess&amp;&gt;(access);
      Node* control = control_dependent ? opt_access.ctl() : NULL;
      MergeMemNode* mm = opt_access.mem();
      PhaseGVN&amp; gvn = opt_access.gvn();
      Node* mem = mm-&gt;memory_at(gvn.C-&gt;get_alias_index(adr_type));
<span class="line-modified">!     load = LoadNode::make(gvn, control, mem, adr, adr_type, val_type, access.type(), mo,</span>
<span class="line-added">+                           dep, unaligned, mismatched, unsafe, access.barrier_data());</span>
      load = gvn.transform(load);
    }
<span class="line-added">+   access.set_raw_access(load);</span>
  
    return load;
  }
  
  class C2AccessFence: public StackObj {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,11 ***</span>
  
    if (is_read &amp;&amp; !is_write &amp;&amp; anonymous) {
      // To be valid, unsafe loads may depend on other conditions than
      // the one that guards them: pin the Load node
      _decorators |= C2_CONTROL_DEPENDENT_LOAD;
<span class="line-modified">!     _decorators |= C2_PINNED_LOAD;</span>
      const TypePtr* adr_type = _addr.type();
      Node* adr = _addr.node();
      if (!needs_cpu_membar() &amp;&amp; adr_type-&gt;isa_instptr()) {
        assert(adr_type-&gt;meet(TypePtr::NULL_PTR) != adr_type-&gt;remove_speculative(), &quot;should be not null&quot;);
        intptr_t offset = Type::OffsetBot;
<span class="line-new-header">--- 358,11 ---</span>
  
    if (is_read &amp;&amp; !is_write &amp;&amp; anonymous) {
      // To be valid, unsafe loads may depend on other conditions than
      // the one that guards them: pin the Load node
      _decorators |= C2_CONTROL_DEPENDENT_LOAD;
<span class="line-modified">!     _decorators |= C2_UNKNOWN_CONTROL_LOAD;</span>
      const TypePtr* adr_type = _addr.type();
      Node* adr = _addr.node();
      if (!needs_cpu_membar() &amp;&amp; adr_type-&gt;isa_instptr()) {
        assert(adr_type-&gt;meet(TypePtr::NULL_PTR) != adr_type-&gt;remove_speculative(), &quot;should be not null&quot;);
        intptr_t offset = Type::OffsetBot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,11 ***</span>
        if (offset &gt;= 0) {
          int s = Klass::layout_helper_size_in_bytes(adr_type-&gt;isa_instptr()-&gt;klass()-&gt;layout_helper());
          if (offset &lt; s) {
            // Guaranteed to be a valid access, no need to pin it
            _decorators ^= C2_CONTROL_DEPENDENT_LOAD;
<span class="line-modified">!           _decorators ^= C2_PINNED_LOAD;</span>
          }
        }
      }
    }
  }
<span class="line-new-header">--- 370,11 ---</span>
        if (offset &gt;= 0) {
          int s = Klass::layout_helper_size_in_bytes(adr_type-&gt;isa_instptr()-&gt;klass()-&gt;layout_helper());
          if (offset &lt; s) {
            // Guaranteed to be a valid access, no need to pin it
            _decorators ^= C2_CONTROL_DEPENDENT_LOAD;
<span class="line-modified">!           _decorators ^= C2_UNKNOWN_CONTROL_LOAD;</span>
          }
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,39 ***</span>
    if (access.is_oop()) {
  #ifdef _LP64
      if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo));</span>
      } else
  #endif
      {
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo));</span>
      }
    } else {
      switch (access.type()) {
        case T_BYTE: {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndExchangeBNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo));</span>
          break;
        }
        case T_SHORT: {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndExchangeSNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo));</span>
          break;
        }
        case T_INT: {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndExchangeINode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo));</span>
          break;
        }
        case T_LONG: {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndExchangeLNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo));</span>
          break;
        }
        default:
          ShouldNotReachHere();
      }
    }
  
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
  #ifdef _LP64
    if (access.is_oop() &amp;&amp; adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
<span class="line-new-header">--- 416,42 ---</span>
    if (access.is_oop()) {
  #ifdef _LP64
      if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
<span class="line-modified">!       load_store = new CompareAndExchangeNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, adr_type, value_type-&gt;make_narrowoop(), mo);</span>
      } else
  #endif
      {
<span class="line-modified">!       load_store = new CompareAndExchangePNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, value_type-&gt;is_oopptr(), mo);</span>
      }
    } else {
      switch (access.type()) {
        case T_BYTE: {
<span class="line-modified">!         load_store = new CompareAndExchangeBNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo);</span>
          break;
        }
        case T_SHORT: {
<span class="line-modified">!         load_store = new CompareAndExchangeSNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo);</span>
          break;
        }
        case T_INT: {
<span class="line-modified">!         load_store = new CompareAndExchangeINode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo);</span>
          break;
        }
        case T_LONG: {
<span class="line-modified">!         load_store = new CompareAndExchangeLNode(kit-&gt;control(), mem, adr, new_val, expected_val, adr_type, mo);</span>
          break;
        }
        default:
          ShouldNotReachHere();
      }
    }
  
<span class="line-added">+   load_store-&gt;as_LoadStore()-&gt;set_barrier_data(access.barrier_data());</span>
<span class="line-added">+   load_store = kit-&gt;gvn().transform(load_store);</span>
<span class="line-added">+ </span>
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
  #ifdef _LP64
    if (access.is_oop() &amp;&amp; adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,62 ***</span>
  #ifdef _LP64
      if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
        if (is_weak_cas) {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));</span>
        } else {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo));</span>
        }
      } else
  #endif
      {
        if (is_weak_cas) {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
        } else {
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
        }
      }
    } else {
      switch(access.type()) {
        case T_BYTE: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapBNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          } else {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new CompareAndSwapBNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          }
          break;
        }
        case T_SHORT: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapSNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          } else {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new CompareAndSwapSNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          }
          break;
        }
        case T_INT: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapINode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          } else {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new CompareAndSwapINode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          }
          break;
        }
        case T_LONG: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new WeakCompareAndSwapLNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          } else {
<span class="line-modified">!           load_store = kit-&gt;gvn().transform(new CompareAndSwapLNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo));</span>
          }
          break;
        }
        default:
          ShouldNotReachHere();
      }
    }
  
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
    return load_store;
  }
<span class="line-new-header">--- 476,65 ---</span>
  #ifdef _LP64
      if (adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        Node *oldval_enc = kit-&gt;gvn().transform(new EncodePNode(expected_val, expected_val-&gt;bottom_type()-&gt;make_narrowoop()));
        if (is_weak_cas) {
<span class="line-modified">!         load_store = new WeakCompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo);</span>
        } else {
<span class="line-modified">!         load_store = new CompareAndSwapNNode(kit-&gt;control(), mem, adr, newval_enc, oldval_enc, mo);</span>
        }
      } else
  #endif
      {
        if (is_weak_cas) {
<span class="line-modified">!         load_store = new WeakCompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
        } else {
<span class="line-modified">!         load_store = new CompareAndSwapPNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
        }
      }
    } else {
      switch(access.type()) {
        case T_BYTE: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = new WeakCompareAndSwapBNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          } else {
<span class="line-modified">!           load_store = new CompareAndSwapBNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          }
          break;
        }
        case T_SHORT: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = new WeakCompareAndSwapSNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          } else {
<span class="line-modified">!           load_store = new CompareAndSwapSNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          }
          break;
        }
        case T_INT: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = new WeakCompareAndSwapINode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          } else {
<span class="line-modified">!           load_store = new CompareAndSwapINode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          }
          break;
        }
        case T_LONG: {
          if (is_weak_cas) {
<span class="line-modified">!           load_store = new WeakCompareAndSwapLNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          } else {
<span class="line-modified">!           load_store = new CompareAndSwapLNode(kit-&gt;control(), mem, adr, new_val, expected_val, mo);</span>
          }
          break;
        }
        default:
          ShouldNotReachHere();
      }
    }
  
<span class="line-added">+   load_store-&gt;as_LoadStore()-&gt;set_barrier_data(access.barrier_data());</span>
<span class="line-added">+   load_store = kit-&gt;gvn().transform(load_store);</span>
<span class="line-added">+ </span>
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
    return load_store;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,31 ***</span>
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        load_store = kit-&gt;gvn().transform(new GetAndSetNNode(kit-&gt;control(), mem, adr, newval_enc, adr_type, value_type-&gt;make_narrowoop()));
      } else
  #endif
      {
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new GetAndSetPNode(kit-&gt;control(), mem, adr, new_val, adr_type, value_type-&gt;is_oopptr()));</span>
      }
    } else  {
      switch (access.type()) {
        case T_BYTE:
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new GetAndSetBNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
          break;
        case T_SHORT:
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new GetAndSetSNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
          break;
        case T_INT:
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new GetAndSetINode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
          break;
        case T_LONG:
<span class="line-modified">!         load_store = kit-&gt;gvn().transform(new GetAndSetLNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
          break;
        default:
          ShouldNotReachHere();
      }
    }
  
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
  #ifdef _LP64
    if (access.is_oop() &amp;&amp; adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
<span class="line-new-header">--- 552,34 ---</span>
        Node *newval_enc = kit-&gt;gvn().transform(new EncodePNode(new_val, new_val-&gt;bottom_type()-&gt;make_narrowoop()));
        load_store = kit-&gt;gvn().transform(new GetAndSetNNode(kit-&gt;control(), mem, adr, newval_enc, adr_type, value_type-&gt;make_narrowoop()));
      } else
  #endif
      {
<span class="line-modified">!       load_store = new GetAndSetPNode(kit-&gt;control(), mem, adr, new_val, adr_type, value_type-&gt;is_oopptr());</span>
      }
    } else  {
      switch (access.type()) {
        case T_BYTE:
<span class="line-modified">!         load_store = new GetAndSetBNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
          break;
        case T_SHORT:
<span class="line-modified">!         load_store = new GetAndSetSNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
          break;
        case T_INT:
<span class="line-modified">!         load_store = new GetAndSetINode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
          break;
        case T_LONG:
<span class="line-modified">!         load_store = new GetAndSetLNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
          break;
        default:
          ShouldNotReachHere();
      }
    }
  
<span class="line-added">+   load_store-&gt;as_LoadStore()-&gt;set_barrier_data(access.barrier_data());</span>
<span class="line-added">+   load_store = kit-&gt;gvn().transform(load_store);</span>
<span class="line-added">+ </span>
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
  #ifdef _LP64
    if (access.is_oop() &amp;&amp; adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,25 ***</span>
    const TypePtr* adr_type = access.addr().type();
    Node* mem = access.memory();
  
    switch(access.type()) {
      case T_BYTE:
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new GetAndAddBNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
        break;
      case T_SHORT:
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new GetAndAddSNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
        break;
      case T_INT:
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new GetAndAddINode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
        break;
      case T_LONG:
<span class="line-modified">!       load_store = kit-&gt;gvn().transform(new GetAndAddLNode(kit-&gt;control(), mem, adr, new_val, adr_type));</span>
        break;
      default:
        ShouldNotReachHere();
    }
  
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
    return load_store;
  }
<span class="line-new-header">--- 597,28 ---</span>
    const TypePtr* adr_type = access.addr().type();
    Node* mem = access.memory();
  
    switch(access.type()) {
      case T_BYTE:
<span class="line-modified">!       load_store = new GetAndAddBNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
        break;
      case T_SHORT:
<span class="line-modified">!       load_store = new GetAndAddSNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
        break;
      case T_INT:
<span class="line-modified">!       load_store = new GetAndAddINode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
        break;
      case T_LONG:
<span class="line-modified">!       load_store = new GetAndAddLNode(kit-&gt;control(), mem, adr, new_val, adr_type);</span>
        break;
      default:
        ShouldNotReachHere();
    }
  
<span class="line-added">+   load_store-&gt;as_LoadStore()-&gt;set_barrier_data(access.barrier_data());</span>
<span class="line-added">+   load_store = kit-&gt;gvn().transform(load_store);</span>
<span class="line-added">+ </span>
    access.set_raw_access(load_store);
    pin_atomic_op(access);
  
    return load_store;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 624,15 ***</span>
    C2AccessFence fence(access);
    resolve_address(access);
    return atomic_add_at_resolved(access, new_val, value_type);
  }
  
<span class="line-modified">! void BarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {</span>
    // Exclude the header but include array length to copy by 8 bytes words.
    // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
    int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">!                             instanceOopDesc::base_offset_in_bytes();</span>
    // base_off:
    // 8  - 32-bit VM
    // 12 - 64-bit VM, compressed klass
    // 16 - 64-bit VM, normal klass
    if (base_off % BytesPerLong != 0) {
<span class="line-new-header">--- 647,15 ---</span>
    C2AccessFence fence(access);
    resolve_address(access);
    return atomic_add_at_resolved(access, new_val, value_type);
  }
  
<span class="line-modified">! int BarrierSetC2::arraycopy_payload_base_offset(bool is_array) {</span>
    // Exclude the header but include array length to copy by 8 bytes words.
    // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
    int base_off = is_array ? arrayOopDesc::length_offset_in_bytes() :
<span class="line-modified">!                  instanceOopDesc::base_offset_in_bytes();</span>
    // base_off:
    // 8  - 32-bit VM
    // 12 - 64-bit VM, compressed klass
    // 16 - 64-bit VM, normal klass
    if (base_off % BytesPerLong != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,22 ***</span>
        // Include klass to copy by 8 bytes words.
        base_off = instanceOopDesc::klass_offset_in_bytes();
      }
      assert(base_off % BytesPerLong == 0, &quot;expect 8 bytes alignment&quot;);
    }
<span class="line-modified">!   Node* src_base  = kit-&gt;basic_plus_adr(src,  base_off);</span>
<span class="line-modified">!   Node* dst_base = kit-&gt;basic_plus_adr(dst, base_off);</span>
  
    // Compute the length also, if needed:
<span class="line-modified">!   Node* countx = size;</span>
<span class="line-modified">!   countx = kit-&gt;gvn().transform(new SubXNode(countx, kit-&gt;MakeConX(base_off)));</span>
<span class="line-modified">!   countx = kit-&gt;gvn().transform(new URShiftXNode(countx, kit-&gt;intcon(LogBytesPerLong) ));</span>
  
    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
  
<span class="line-modified">!   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, NULL, dst_base, NULL, countx, true, false);</span>
<span class="line-modified">!   ac-&gt;set_clonebasic();</span>
    Node* n = kit-&gt;gvn().transform(ac);
    if (n == ac) {
      ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
      kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
    } else {
<span class="line-new-header">--- 667,31 ---</span>
        // Include klass to copy by 8 bytes words.
        base_off = instanceOopDesc::klass_offset_in_bytes();
      }
      assert(base_off % BytesPerLong == 0, &quot;expect 8 bytes alignment&quot;);
    }
<span class="line-modified">!   return base_off;</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BarrierSetC2::clone(GraphKit* kit, Node* src_base, Node* dst_base, Node* size, bool is_array) const {</span>
<span class="line-added">+   int base_off = arraycopy_payload_base_offset(is_array);</span>
<span class="line-added">+   Node* payload_src = kit-&gt;basic_plus_adr(src_base,  base_off);</span>
<span class="line-added">+   Node* payload_dst = kit-&gt;basic_plus_adr(dst_base, base_off);</span>
  
    // Compute the length also, if needed:
<span class="line-modified">!   Node* payload_size = size;</span>
<span class="line-modified">!   payload_size = kit-&gt;gvn().transform(new SubXNode(payload_size, kit-&gt;MakeConX(base_off)));</span>
<span class="line-modified">!   payload_size = kit-&gt;gvn().transform(new URShiftXNode(payload_size, kit-&gt;intcon(LogBytesPerLong) ));</span>
  
    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;
  
<span class="line-modified">!   ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, payload_src, NULL, payload_dst, NULL, payload_size, true, false);</span>
<span class="line-modified">!   if (is_array) {</span>
<span class="line-added">+     ac-&gt;set_clone_array();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ac-&gt;set_clone_inst();</span>
<span class="line-added">+   }</span>
    Node* n = kit-&gt;gvn().transform(ac);
    if (n == ac) {
      ac-&gt;_adr_type = TypeRawPtr::BOTTOM;
      kit-&gt;set_predefined_output_for_runtime_call(ac, ac-&gt;in(TypeFunc::Memory), raw_adr_type);
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 792,9 ***</span>
                                          0, new_alloc_bytes, T_LONG);
    }
    return fast_oop;
  }
  
<span class="line-modified">! void BarrierSetC2::clone_barrier_at_expansion(ArrayCopyNode* ac, Node* call, PhaseIterGVN&amp; igvn) const {</span>
<span class="line-modified">!   // no barrier</span>
<span class="line-modified">!   igvn.replace_node(ac, call);</span>
  }
<span class="line-new-header">--- 824,32 ---</span>
                                          0, new_alloc_bytes, T_LONG);
    }
    return fast_oop;
  }
  
<span class="line-modified">! #define XTOP LP64_ONLY(COMMA phase-&gt;top())</span>
<span class="line-modified">! </span>
<span class="line-modified">! void BarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {</span>
<span class="line-added">+   Node* ctrl = ac-&gt;in(TypeFunc::Control);</span>
<span class="line-added">+   Node* mem = ac-&gt;in(TypeFunc::Memory);</span>
<span class="line-added">+   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
<span class="line-added">+   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);</span>
<span class="line-added">+   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);</span>
<span class="line-added">+   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);</span>
<span class="line-added">+   Node* length = ac-&gt;in(ArrayCopyNode::Length);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert (src_offset == NULL,  &quot;for clone offsets should be null&quot;);</span>
<span class="line-added">+   assert (dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const char* copyfunc_name = &quot;arraycopy&quot;;</span>
<span class="line-added">+   address     copyfunc_addr =</span>
<span class="line-added">+           phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL,</span>
<span class="line-added">+                               true, copyfunc_name, true);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;</span>
<span class="line-added">+   const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();</span>
<span class="line-added">+ </span>
<span class="line-added">+   Node* call = phase-&gt;make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, src, dest, length XTOP);</span>
<span class="line-added">+   phase-&gt;transform_later(call);</span>
<span class="line-added">+ </span>
<span class="line-added">+   phase-&gt;igvn().replace_node(ac, call);</span>
  }
</pre>
<center><a href="../c1/barrierSetC1.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetC2.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
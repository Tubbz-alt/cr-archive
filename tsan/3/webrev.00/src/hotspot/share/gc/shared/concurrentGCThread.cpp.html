<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/concurrentGCThread.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #include &quot;precompiled.hpp&quot;
26 #include &quot;gc/shared/concurrentGCThread.hpp&quot;
27 #include &quot;runtime/atomic.hpp&quot;
28 #include &quot;runtime/init.hpp&quot;
29 #include &quot;runtime/mutexLocker.hpp&quot;
30 #include &quot;runtime/os.hpp&quot;
31 
32 ConcurrentGCThread::ConcurrentGCThread() :
33     _should_terminate(false),
34     _has_terminated(false) {}
35 
36 void ConcurrentGCThread::create_and_start(ThreadPriority prio) {
37   if (os::create_thread(this, os::cgc_thread)) {
38     os::set_priority(this, prio);
39     os::start_thread(this);
40   }
41 }
42 
43 void ConcurrentGCThread::run() {
44   // Setup handle area
45   set_active_handles(JNIHandleBlock::allocate_block());
46 
47   // Wait for initialization to complete
48   wait_init_completed();
49 
50   run_service();
51 
52   // Signal thread has terminated
53   MonitorLocker ml(Terminator_lock);
54   Atomic::release_store(&amp;_has_terminated, true);
55   ml.notify_all();
56 }
57 
58 void ConcurrentGCThread::stop() {
59   assert(!should_terminate(), &quot;Invalid state&quot;);
60   assert(!has_terminated(), &quot;Invalid state&quot;);
61 
62   // Signal thread to terminate
63   Atomic::release_store_fence(&amp;_should_terminate, true);
64 
65   stop_service();
66 
67   // Wait for thread to terminate
68   MonitorLocker ml(Terminator_lock);
69   while (!_has_terminated) {
70     ml.wait();
71   }
72 }
73 
74 bool ConcurrentGCThread::should_terminate() const {
75   return Atomic::load_acquire(&amp;_should_terminate);
76 }
77 
78 bool ConcurrentGCThread::has_terminated() const {
79   return Atomic::load_acquire(&amp;_has_terminated);
80 }
    </pre>
  </body>
</html>
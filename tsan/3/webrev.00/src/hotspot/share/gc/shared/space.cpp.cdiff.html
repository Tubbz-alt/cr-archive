<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/space.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="scavengableNMethods.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="space.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/space.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,17 ***</span>
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  #include &quot;gc/shared/space.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/spaceDecorator.hpp&quot;</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
<span class="line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
<span class="line-new-header">--- 29,16 ---</span>
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  #include &quot;gc/shared/space.hpp&quot;
  #include &quot;gc/shared/space.inline.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;</span>
  #include &quot;memory/iterator.inline.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/java.hpp&quot;
  #include &quot;runtime/prefetch.inline.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/copy.hpp&quot;
  #include &quot;utilities/globalDefinitions.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,22 ***</span>
  // scanned some of that extended region, we may need to
  // trim its right-end back some so we do not scan what
  // we (or another worker thread) may already have scanned
  // or planning to scan.
  void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {
<span class="line-removed">- </span>
<span class="line-removed">-   // Some collectors need to do special things whenever their dirty</span>
<span class="line-removed">-   // cards are processed. For instance, CMS must remember mutator updates</span>
<span class="line-removed">-   // (i.e. dirty cards) so as to re-scan mutated objects.</span>
<span class="line-removed">-   // Such work can be piggy-backed here on dirty card scanning, so as to make</span>
<span class="line-removed">-   // it slightly more efficient than doing a complete non-destructive pre-scan</span>
<span class="line-removed">-   // of the card table.</span>
<span class="line-removed">-   MemRegionClosure* pCl = _sp-&gt;preconsumptionDirtyCardClosure();</span>
<span class="line-removed">-   if (pCl != NULL) {</span>
<span class="line-removed">-     pCl-&gt;do_MemRegion(mr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    HeapWord* bottom = mr.start();
    HeapWord* last = mr.last();
    HeapWord* top = mr.end();
    HeapWord* bottom_obj;
    HeapWord* top_obj;
<span class="line-new-header">--- 107,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,11 ***</span>
      cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
      compaction_max_size = pointer_delta(cp-&gt;space-&gt;end(), compact_top);
    }
  
    // store the forwarding pointer into the mark word
<span class="line-modified">!   if ((HeapWord*)q != compact_top) {</span>
      q-&gt;forward_to(oop(compact_top));
      assert(q-&gt;is_gc_marked(), &quot;encoding the pointer should preserve the mark&quot;);
    } else {
      // if the object isn&#39;t moving we can just set the mark to the default
      // mark and handle it specially later on.
<span class="line-new-header">--- 371,11 ---</span>
      cp-&gt;threshold = cp-&gt;space-&gt;initialize_threshold();
      compaction_max_size = pointer_delta(cp-&gt;space-&gt;end(), compact_top);
    }
  
    // store the forwarding pointer into the mark word
<span class="line-modified">!   if (cast_from_oop&lt;HeapWord*&gt;(q) != compact_top) {</span>
      q-&gt;forward_to(oop(compact_top));
      assert(q-&gt;is_gc_marked(), &quot;encoding the pointer should preserve the mark&quot;);
    } else {
      // if the object isn&#39;t moving we can just set the mark to the default
      // mark and handle it specially later on.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,38 ***</span>
  void ContiguousSpace::object_iterate(ObjectClosure* blk) {
    if (is_empty()) return;
    object_iterate_from(bottom(), blk);
  }
  
<span class="line-removed">- // For a ContiguousSpace object_iterate() and safe_object_iterate()</span>
<span class="line-removed">- // are the same.</span>
<span class="line-removed">- void ContiguousSpace::safe_object_iterate(ObjectClosure* blk) {</span>
<span class="line-removed">-   object_iterate(blk);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ContiguousSpace::object_iterate_from(HeapWord* mark, ObjectClosure* blk) {
    while (mark &lt; top()) {
      blk-&gt;do_object(oop(mark));
      mark += oop(mark)-&gt;size();
    }
  }
  
<span class="line-removed">- HeapWord*</span>
<span class="line-removed">- ContiguousSpace::object_iterate_careful(ObjectClosureCareful* blk) {</span>
<span class="line-removed">-   HeapWord * limit = concurrent_iteration_safe_limit();</span>
<span class="line-removed">-   assert(limit &lt;= top(), &quot;sanity check&quot;);</span>
<span class="line-removed">-   for (HeapWord* p = bottom(); p &lt; limit;) {</span>
<span class="line-removed">-     size_t size = blk-&gt;do_object_careful(oop(p));</span>
<span class="line-removed">-     if (size == 0) {</span>
<span class="line-removed">-       return p;  // failed at p</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       p += size;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return NULL; // all done</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Very general, slow implementation.
  HeapWord* ContiguousSpace::block_start_const(const void* p) const {
    assert(MemRegion(bottom(), end()).contains(p),
           &quot;p (&quot; PTR_FORMAT &quot;) not in space [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
           p2i(p), p2i(bottom()), p2i(end()));
<span class="line-new-header">--- 483,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
  inline HeapWord* ContiguousSpace::par_allocate_impl(size_t size) {
    do {
      HeapWord* obj = top();
      if (pointer_delta(end(), obj) &gt;= size) {
        HeapWord* new_top = obj + size;
<span class="line-modified">!       HeapWord* result = Atomic::cmpxchg(new_top, top_addr(), obj);</span>
        // result can be one of two:
        //  the old top value: the exchange succeeded
        //  otherwise: the new value of the top is returned.
        if (result == obj) {
          assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);
<span class="line-new-header">--- 551,11 ---</span>
  inline HeapWord* ContiguousSpace::par_allocate_impl(size_t size) {
    do {
      HeapWord* obj = top();
      if (pointer_delta(end(), obj) &gt;= size) {
        HeapWord* new_top = obj + size;
<span class="line-modified">!       HeapWord* result = Atomic::cmpxchg(top_addr(), obj, new_top);</span>
        // result can be one of two:
        //  the old top value: the exchange succeeded
        //  otherwise: the new value of the top is returned.
        if (result == obj) {
          assert(is_aligned(obj) &amp;&amp; is_aligned(new_top), &quot;checking alignment&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,18 ***</span>
    if (size &gt;= align_object_size(array_header_size)) {
      size_t length = (size - array_header_size) * (HeapWordSize / sizeof(jint));
      // allocate uninitialized int array
      typeArrayOop t = (typeArrayOop) allocate(size);
      assert(t != NULL, &quot;allocation should succeed&quot;);
<span class="line-modified">!     t-&gt;set_mark_raw(markOopDesc::prototype());</span>
      t-&gt;set_klass(Universe::intArrayKlassObj());
      t-&gt;set_length((int)length);
    } else {
      assert(size == CollectedHeap::min_fill_size(),
             &quot;size for smallest fake object doesn&#39;t match&quot;);
      instanceOop obj = (instanceOop) allocate(size);
<span class="line-modified">!     obj-&gt;set_mark_raw(markOopDesc::prototype());</span>
      obj-&gt;set_klass_gap(0);
      obj-&gt;set_klass(SystemDictionary::Object_klass());
    }
  }
  
<span class="line-new-header">--- 615,18 ---</span>
    if (size &gt;= align_object_size(array_header_size)) {
      size_t length = (size - array_header_size) * (HeapWordSize / sizeof(jint));
      // allocate uninitialized int array
      typeArrayOop t = (typeArrayOop) allocate(size);
      assert(t != NULL, &quot;allocation should succeed&quot;);
<span class="line-modified">!     t-&gt;set_mark_raw(markWord::prototype());</span>
      t-&gt;set_klass(Universe::intArrayKlassObj());
      t-&gt;set_length((int)length);
    } else {
      assert(size == CollectedHeap::min_fill_size(),
             &quot;size for smallest fake object doesn&#39;t match&quot;);
      instanceOop obj = (instanceOop) allocate(size);
<span class="line-modified">!     obj-&gt;set_mark_raw(markWord::prototype());</span>
      obj-&gt;set_klass_gap(0);
      obj-&gt;set_klass(SystemDictionary::Object_klass());
    }
  }
  
</pre>
<center><a href="scavengableNMethods.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="space.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
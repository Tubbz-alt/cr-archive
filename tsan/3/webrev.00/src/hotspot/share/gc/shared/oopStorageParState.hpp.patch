diff a/src/hotspot/share/gc/shared/oopStorageParState.hpp b/src/hotspot/share/gc/shared/oopStorageParState.hpp
--- a/src/hotspot/share/gc/shared/oopStorageParState.hpp
+++ b/src/hotspot/share/gc/shared/oopStorageParState.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,11 +24,11 @@
 
 #ifndef SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 #define SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 
 #include "gc/shared/oopStorage.hpp"
-#include "utilities/macros.hpp"
+#include "utilities/globalDefinitions.hpp"
 
 //////////////////////////////////////////////////////////////////////////////
 // Support for parallel and optionally concurrent state iteration.
 //
 // Concurrent Iteration
@@ -132,13 +132,11 @@
   size_t _block_count;
   volatile size_t _next_block;
   uint _estimated_thread_count;
   bool _concurrent;
 
-  // Noncopyable.
-  BasicParState(const BasicParState&);
-  BasicParState& operator=(const BasicParState&);
+  NONCOPYABLE(BasicParState);
 
   struct IterationData;
 
   void update_concurrent_iteration_count(int value);
   bool claim_next_segment(IterationData* data);
@@ -151,10 +149,12 @@
   BasicParState(const OopStorage* storage,
                 uint estimated_thread_count,
                 bool concurrent);
   ~BasicParState();
 
+  const OopStorage* storage() const { return _storage; }
+
   template<bool is_const, typename F> void iterate(F f);
 
   static uint default_estimated_thread_count(bool concurrent);
 };
 
@@ -170,10 +170,11 @@
   ParState(StoragePtr storage,
            uint estimated_thread_count = BasicParState::default_estimated_thread_count(concurrent)) :
     _basic_state(storage, estimated_thread_count, concurrent)
   {}
 
+  const OopStorage* storage() const { return _basic_state.storage(); }
   template<typename F> void iterate(F f);
   template<typename Closure> void oops_do(Closure* cl);
 };
 
 template<>
@@ -184,10 +185,11 @@
   ParState(OopStorage* storage,
            uint estimated_thread_count = BasicParState::default_estimated_thread_count(false)) :
     _basic_state(storage, estimated_thread_count, false)
   {}
 
+  const OopStorage* storage() const { return _basic_state.storage(); }
   template<typename F> void iterate(F f);
   template<typename Closure> void oops_do(Closure* cl);
   template<typename Closure> void weak_oops_do(Closure* cl);
   template<typename IsAliveClosure, typename Closure>
   void weak_oops_do(IsAliveClosure* is_alive, Closure* cl);

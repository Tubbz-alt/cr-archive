<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/workerDataArray.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 26 #define SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 27 
 28 #include &quot;gc/shared/workerDataArray.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 template &lt;typename T&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 33 WorkerDataArray&lt;T&gt;::WorkerDataArray(const char* title, uint length, bool is_serial) :</span>
 34  _data(NULL),
 35  _length(length),
<a name="2" id="anc2"></a><span class="line-modified"> 36  _title(title),</span>
<span class="line-added"> 37  _is_serial(is_serial) {</span>
 38   assert(length &gt; 0, &quot;Must have some workers to store data for&quot;);
<a name="3" id="anc3"></a><span class="line-added"> 39   assert(!is_serial || length == 1, &quot;Serial phase must only have a single entry.&quot;);</span>
 40   _data = NEW_C_HEAP_ARRAY(T, _length, mtGC);
 41   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 42     _thread_work_items[i] = NULL;
 43   }
 44   reset();
 45 }
 46 
 47 template &lt;typename T&gt;
 48 void WorkerDataArray&lt;T&gt;::set(uint worker_i, T value) {
 49   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 50   assert(_data[worker_i] == uninitialized(), &quot;Overwriting data for worker %d in %s&quot;, worker_i, _title);
 51   _data[worker_i] = value;
 52 }
 53 
 54 template &lt;typename T&gt;
 55 T WorkerDataArray&lt;T&gt;::get(uint worker_i) const {
 56   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 57   return _data[worker_i];
 58 }
 59 
 60 template &lt;typename T&gt;
 61 WorkerDataArray&lt;T&gt;::~WorkerDataArray() {
<a name="4" id="anc4"></a><span class="line-added"> 62   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {</span>
<span class="line-added"> 63     delete _thread_work_items[i];</span>
<span class="line-added"> 64   }</span>
 65   FREE_C_HEAP_ARRAY(T, _data);
 66 }
 67 
 68 template &lt;typename T&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 69 void WorkerDataArray&lt;T&gt;::create_thread_work_items(const char* title, uint index, uint length_override) {</span>
 70   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
<a name="6" id="anc6"></a><span class="line-modified"> 71   assert(_thread_work_items[index] == NULL, &quot;Tried to overwrite existing thread work item&quot;);</span>
<span class="line-added"> 72   uint length = length_override != 0 ? length_override : _length;</span>
<span class="line-added"> 73   _thread_work_items[index] = new WorkerDataArray&lt;size_t&gt;(title, length);</span>
 74 }
 75 
 76 template &lt;typename T&gt;
 77 void WorkerDataArray&lt;T&gt;::set_thread_work_item(uint worker_i, size_t value, uint index) {
 78   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 79   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 80   _thread_work_items[index]-&gt;set(worker_i, value);
 81 }
 82 
 83 template &lt;typename T&gt;
 84 void WorkerDataArray&lt;T&gt;::add_thread_work_item(uint worker_i, size_t value, uint index) {
 85   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 86   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 87   _thread_work_items[index]-&gt;add(worker_i, value);
 88 }
 89 
 90 template &lt;typename T&gt;
 91 void WorkerDataArray&lt;T&gt;::set_or_add_thread_work_item(uint worker_i, size_t value, uint index) {
 92   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 93   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 94   if (_thread_work_items[index]-&gt;get(worker_i) == _thread_work_items[index]-&gt;uninitialized()) {
 95     _thread_work_items[index]-&gt;set(worker_i, value);
 96   } else {
 97     _thread_work_items[index]-&gt;add(worker_i, value);
 98   }
 99 }
100 
<a name="7" id="anc7"></a><span class="line-added">101 template &lt;typename T&gt;</span>
<span class="line-added">102 size_t WorkerDataArray&lt;T&gt;::get_thread_work_item(uint worker_i, uint index) {</span>
<span class="line-added">103   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);</span>
<span class="line-added">104   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);</span>
<span class="line-added">105   return _thread_work_items[index]-&gt;get(worker_i);</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
108 template &lt;typename T&gt;
109 void WorkerDataArray&lt;T&gt;::add(uint worker_i, T value) {
110   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
<a name="8" id="anc8"></a><span class="line-modified">111   assert(_data[worker_i] != uninitialized(), &quot;No data to add to %s for worker %d&quot;, _title, worker_i);</span>
112   _data[worker_i] += value;
113 }
114 
115 template &lt;typename T&gt;
116 double WorkerDataArray&lt;T&gt;::average() const {
117   uint contributing_threads = 0;
118   for (uint i = 0; i &lt; _length; ++i) {
119     if (get(i) != uninitialized()) {
120       contributing_threads++;
121     }
122   }
123   if (contributing_threads == 0) {
124     return 0.0;
125   }
126   return sum() / (double) contributing_threads;
127 }
128 
129 template &lt;typename T&gt;
130 T WorkerDataArray&lt;T&gt;::sum() const {
131   T s = 0;
132   for (uint i = 0; i &lt; _length; ++i) {
133     if (get(i) != uninitialized()) {
134       s += get(i);
135     }
136   }
137   return s;
138 }
139 
140 template &lt;typename T&gt;
141 void WorkerDataArray&lt;T&gt;::set_all(T value) {
142   for (uint i = 0; i &lt; _length; i++) {
143     _data[i] = value;
144   }
145 }
146 
147 template &lt;class T&gt;
148 void WorkerDataArray&lt;T&gt;::print_summary_on(outputStream* out, bool print_sum) const {
<a name="9" id="anc9"></a><span class="line-modified">149   if (_is_serial) {</span>
<span class="line-added">150     out-&gt;print(&quot;%s:&quot;, title());</span>
<span class="line-added">151   } else {</span>
<span class="line-added">152     out-&gt;print(&quot;%-25s&quot;, title());</span>
<span class="line-added">153   }</span>
<span class="line-added">154 </span>
155   uint start = 0;
156   while (start &lt; _length &amp;&amp; get(start) == uninitialized()) {
157     start++;
158   }
159   if (start &lt; _length) {
<a name="10" id="anc10"></a><span class="line-modified">160     if (_is_serial) {</span>
<span class="line-modified">161       WDAPrinter::summary(out, get(0));</span>
<span class="line-modified">162     } else {</span>
<span class="line-modified">163       T min = get(start);</span>
<span class="line-modified">164       T max = min;</span>
<span class="line-modified">165       T sum = 0;</span>
<span class="line-modified">166       uint contributing_threads = 0;</span>
<span class="line-modified">167       for (uint i = start; i &lt; _length; ++i) {</span>
<span class="line-modified">168         T value = get(i);</span>
<span class="line-modified">169         if (value != uninitialized()) {</span>
<span class="line-modified">170           max = MAX2(max, value);</span>
<span class="line-added">171           min = MIN2(min, value);</span>
<span class="line-added">172           sum += value;</span>
<span class="line-added">173           contributing_threads++;</span>
<span class="line-added">174         }</span>
175       }
<a name="11" id="anc11"></a><span class="line-added">176       T diff = max - min;</span>
<span class="line-added">177       assert(contributing_threads != 0, &quot;Must be since we found a used value for the start index&quot;);</span>
<span class="line-added">178       double avg = sum / (double) contributing_threads;</span>
<span class="line-added">179       WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);</span>
<span class="line-added">180       out-&gt;print_cr(&quot;, Workers: %d&quot;, contributing_threads);</span>
181     }
<a name="12" id="anc12"></a>




182   } else {
183     // No data for this phase.
184     out-&gt;print_cr(&quot; skipped&quot;);
185   }
186 }
187 
188 template &lt;class T&gt;
189 void WorkerDataArray&lt;T&gt;::print_details_on(outputStream* out) const {
190   WDAPrinter::details(this, out);
191 }
192 
193 template &lt;typename T&gt;
194 void WorkerDataArray&lt;T&gt;::reset() {
195   set_all(uninitialized());
196   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
197     if (_thread_work_items[i] != NULL) {
198       _thread_work_items[i]-&gt;reset();
199     }
200   }
201 }
202 
203 #endif // SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/gc/shared/suspendibleThreadSet.cpp b/src/hotspot/share/gc/shared/suspendibleThreadSet.cpp
--- a/src/hotspot/share/gc/shared/suspendibleThreadSet.cpp
+++ b/src/hotspot/share/gc/shared/suspendibleThreadSet.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,21 +46,21 @@
   return _nthreads_stopped == _nthreads;
 }
 
 void SuspendibleThreadSet::join() {
   assert(!Thread::current()->is_suspendible_thread(), "Thread already joined");
-  MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
   while (_suspend_all) {
-    ml.wait(Mutex::_no_safepoint_check_flag);
+    ml.wait();
   }
   _nthreads++;
   DEBUG_ONLY(Thread::current()->set_suspendible_thread();)
 }
 
 void SuspendibleThreadSet::leave() {
   assert(Thread::current()->is_suspendible_thread(), "Thread not joined");
-  MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
   assert(_nthreads > 0, "Invalid");
   DEBUG_ONLY(Thread::current()->clear_suspendible_thread();)
   _nthreads--;
   if (_suspend_all && is_synchronized()) {
     // This leave completes a request, so inform the requestor.
@@ -68,11 +68,11 @@
   }
 }
 
 void SuspendibleThreadSet::yield() {
   assert(Thread::current()->is_suspendible_thread(), "Must have joined");
-  MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
   if (_suspend_all) {
     _nthreads_stopped++;
     if (is_synchronized()) {
       if (ConcGCYieldTimeout > 0) {
         double now = os::elapsedTime();
@@ -80,11 +80,11 @@
       }
       // This yield completes the request, so inform the requestor.
       _synchronize_wakeup->signal();
     }
     while (_suspend_all) {
-      ml.wait(Mutex::_no_safepoint_check_flag);
+      ml.wait();
     }
     assert(_nthreads_stopped > 0, "Invalid");
     _nthreads_stopped--;
   }
 }
@@ -93,11 +93,11 @@
   assert(Thread::current()->is_VM_thread(), "Must be the VM thread");
   if (ConcGCYieldTimeout > 0) {
     _suspend_all_start = os::elapsedTime();
   }
   {
-    MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+    MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
     assert(!_suspend_all, "Only one at a time");
     _suspend_all = true;
     if (is_synchronized()) {
       return;
     }
@@ -116,19 +116,19 @@
   // synchronize call.  Hence, there is no need to re-check for
   // is_synchronized after the wait; it will always be true there.
   _synchronize_wakeup->wait();
 
 #ifdef ASSERT
-  MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
   assert(_suspend_all, "STS not synchronizing");
   assert(is_synchronized(), "STS not synchronized");
 #endif
 }
 
 void SuspendibleThreadSet::desynchronize() {
   assert(Thread::current()->is_VM_thread(), "Must be the VM thread");
-  MonitorLockerEx ml(STS_lock, Mutex::_no_safepoint_check_flag);
+  MonitorLocker ml(STS_lock, Mutex::_no_safepoint_check_flag);
   assert(_suspend_all, "STS not synchronizing");
   assert(is_synchronized(), "STS not synchronized");
   _suspend_all = false;
   ml.notify_all();
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/jvmFlagConstraintsGC.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="isGCActiveMark.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsGC.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/jvmFlagConstraintsGC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21,37 +21,30 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/cardTableRS.hpp&quot;</span>
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;gc/shared/collectorPolicy.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;gc/shared/gcArguments.hpp&quot;</span>
  #include &quot;gc/shared/gcConfig.hpp&quot;
  #include &quot;gc/shared/jvmFlagConstraintsGC.hpp&quot;
  #include &quot;gc/shared/plab.hpp&quot;
  #include &quot;gc/shared/threadLocalAllocBuffer.hpp&quot;
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/globals.hpp&quot;
  #include &quot;runtime/globals_extension.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="udiff-line-modified-removed">- #if INCLUDE_CMSGC</span>
<span class="udiff-line-removed">- #include &quot;gc/cms/jvmFlagConstraintsCMS.hpp&quot;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #if INCLUDE_G1GC
  #include &quot;gc/g1/jvmFlagConstraintsG1.hpp&quot;
  #endif
  #if INCLUDE_PARALLELGC
  #include &quot;gc/parallel/jvmFlagConstraintsParallel.hpp&quot;
  #endif
<span class="udiff-line-removed">- #ifdef COMPILER1</span>
<span class="udiff-line-removed">- #include &quot;c1/c1_globals.hpp&quot;</span>
<span class="udiff-line-removed">- #endif // COMPILER1</span>
<span class="udiff-line-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-removed">- #include &quot;opto/c2_globals.hpp&quot;</span>
<span class="udiff-line-removed">- #endif // COMPILER2</span>
  
  // Some flags that have default values that indicate that the
  // JVM should automatically determine an appropriate value
  // for that flag.  In those cases it is only appropriate for the
  // constraint checking to be done if the user has specified the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,26 +61,18 @@</span>
    if (status != JVMFlag::SUCCESS) {
      return status;
    }
  #endif
  
<span class="udiff-line-removed">- #if INCLUDE_CMSGC</span>
<span class="udiff-line-removed">-   status = ParallelGCThreadsConstraintFuncCMS(value, verbose);</span>
<span class="udiff-line-removed">-   if (status != JVMFlag::SUCCESS) {</span>
<span class="udiff-line-removed">-     return status;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    return status;
  }
  
  // As ConcGCThreads should be smaller than ParallelGCThreads,
  // we need constraint function.
  JVMFlag::Error ConcGCThreadsConstraintFunc(uint value, bool verbose) {
<span class="udiff-line-modified-removed">-   // CMS and G1 GCs use ConcGCThreads.</span>
<span class="udiff-line-modified-removed">-   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="udiff-line-removed">-        GCConfig::is_gc_selected(CollectedHeap::G1)) &amp;&amp; (value &gt; ParallelGCThreads)) {</span>
<span class="udiff-line-modified-added">+   // G1 GC use ConcGCThreads.</span>
<span class="udiff-line-modified-added">+   if (GCConfig::is_gc_selected(CollectedHeap::G1) &amp;&amp; (value &gt; ParallelGCThreads)) {</span>
      JVMFlag::printError(verbose,
                          &quot;ConcGCThreads (&quot; UINT32_FORMAT &quot;) must be &quot;
                          &quot;less than or equal to ParallelGCThreads (&quot; UINT32_FORMAT &quot;)\n&quot;,
                          value, ParallelGCThreads);
      return JVMFlag::VIOLATES_CONSTRAINT;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,13 +80,12 @@</span>
  
    return JVMFlag::SUCCESS;
  }
  
  static JVMFlag::Error MinPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="udiff-line-modified-removed">-   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="udiff-line-modified-removed">-        GCConfig::is_gc_selected(CollectedHeap::G1)  ||</span>
<span class="udiff-line-removed">-        GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp; (value &lt; PLAB::min_size())) {</span>
<span class="udiff-line-modified-added">+   if ((GCConfig::is_gc_selected(CollectedHeap::G1) || GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       (value &lt; PLAB::min_size())) {</span>
      JVMFlag::printError(verbose,
                          &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
                          &quot;greater than or equal to ergonomic PLAB minimum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
                          name, value, PLAB::min_size());
      return JVMFlag::VIOLATES_CONSTRAINT;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109,12 +93,11 @@</span>
  
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error MaxPLABSizeBounds(const char* name, size_t value, bool verbose) {
<span class="udiff-line-modified-removed">-   if ((GCConfig::is_gc_selected(CollectedHeap::CMS) ||</span>
<span class="udiff-line-removed">-        GCConfig::is_gc_selected(CollectedHeap::G1)  ||</span>
<span class="udiff-line-modified-added">+   if ((GCConfig::is_gc_selected(CollectedHeap::G1) ||</span>
         GCConfig::is_gc_selected(CollectedHeap::Parallel)) &amp;&amp; (value &gt; PLAB::max_size())) {
      JVMFlag::printError(verbose,
                          &quot;%s (&quot; SIZE_FORMAT &quot;) must be &quot;
                          &quot;less than or equal to ergonomic PLAB maximum size (&quot; SIZE_FORMAT &quot;)\n&quot;,
                          name, value, PLAB::max_size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,15 +121,10 @@</span>
  }
  
  JVMFlag::Error OldPLABSizeConstraintFunc(size_t value, bool verbose) {
    JVMFlag::Error status = JVMFlag::SUCCESS;
  
<span class="udiff-line-removed">- #if INCLUDE_CMSGC</span>
<span class="udiff-line-removed">-   if (UseConcMarkSweepGC) {</span>
<span class="udiff-line-removed">-     return OldPLABSizeConstraintFuncCMS(value, verbose);</span>
<span class="udiff-line-removed">-   } else</span>
<span class="udiff-line-removed">- #endif</span>
    {
      status = MinMaxPLABSizeBounds(&quot;OldPLABSize&quot;, value, verbose);
    }
  
    return status;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -311,21 +289,25 @@</span>
  static JVMFlag::Error MaxSizeForHeapAlignment(const char* name, size_t value, bool verbose) {
    size_t heap_alignment;
  
  #if INCLUDE_G1GC
    if (UseG1GC) {
<span class="udiff-line-modified-removed">-     // For G1 GC, we don&#39;t know until G1CollectorPolicy is created.</span>
<span class="udiff-line-modified-added">+     // For G1 GC, we don&#39;t know until G1CollectedHeap is created.</span>
      heap_alignment = MaxSizeForHeapAlignmentG1();
    } else
  #endif
    {
<span class="udiff-line-modified-removed">-     heap_alignment = CollectorPolicy::compute_heap_alignment();</span>
<span class="udiff-line-modified-added">+     heap_alignment = GCArguments::compute_heap_alignment();</span>
    }
  
    return MaxSizeForAlignment(name, value, heap_alignment, verbose);
  }
  
<span class="udiff-line-added">+ JVMFlag::Error MinHeapSizeConstraintFunc(size_t value, bool verbose) {</span>
<span class="udiff-line-added">+   return MaxSizeForHeapAlignment(&quot;MinHeapSize&quot;, value, verbose);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  JVMFlag::Error InitialHeapSizeConstraintFunc(size_t value, bool verbose) {
    return MaxSizeForHeapAlignment(&quot;InitialHeapSize&quot;, value, verbose);
  }
  
  JVMFlag::Error MaxHeapSizeConstraintFunc(size_t value, bool verbose) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -335,10 +317,19 @@</span>
      status = CheckMaxHeapSizeAndSoftRefLRUPolicyMSPerMB(value, SoftRefLRUPolicyMSPerMB, verbose);
    }
    return status;
  }
  
<span class="udiff-line-added">+ JVMFlag::Error SoftMaxHeapSizeConstraintFunc(size_t value, bool verbose) {</span>
<span class="udiff-line-added">+   if (value &gt; MaxHeapSize) {</span>
<span class="udiff-line-added">+     JVMFlag::printError(verbose, &quot;SoftMaxHeapSize must be less than or equal to the maximum heap size\n&quot;);</span>
<span class="udiff-line-added">+     return JVMFlag::VIOLATES_CONSTRAINT;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return JVMFlag::SUCCESS;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  JVMFlag::Error HeapBaseMinAddressConstraintFunc(size_t value, bool verbose) {
    // If an overflow happened in Arguments::set_heap_size(), MaxHeapSize will have too large a value.
    // Check for this by ensuring that MaxHeapSize plus the requested min base address still fit within max_uintx.
    if (UseCompressedOops &amp;&amp; FLAG_IS_ERGO(MaxHeapSize) &amp;&amp; (value &gt; (max_uintx - MaxHeapSize))) {
      JVMFlag::printError(verbose,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,16 +411,16 @@</span>
    return JVMFlag::SUCCESS;
  }
  
  JVMFlag::Error SurvivorRatioConstraintFunc(uintx value, bool verbose) {
    if (FLAG_IS_CMDLINE(SurvivorRatio) &amp;&amp;
<span class="udiff-line-modified-removed">-       (value &gt; (MaxHeapSize / Universe::heap()-&gt;collector_policy()-&gt;space_alignment()))) {</span>
<span class="udiff-line-modified-added">+       (value &gt; (MaxHeapSize / SpaceAlignment))) {</span>
      JVMFlag::printError(verbose,
                          &quot;SurvivorRatio (&quot; UINTX_FORMAT &quot;) must be &quot;
                          &quot;less than or equal to ergonomic SurvivorRatio maximum (&quot; SIZE_FORMAT &quot;)\n&quot;,
                          value,
<span class="udiff-line-modified-removed">-                         (MaxHeapSize / Universe::heap()-&gt;collector_policy()-&gt;space_alignment()));</span>
<span class="udiff-line-modified-added">+                         (MaxHeapSize / SpaceAlignment));</span>
      return JVMFlag::VIOLATES_CONSTRAINT;
    } else {
      return JVMFlag::SUCCESS;
    }
  }
</pre>
<center><a href="isGCActiveMark.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlagConstraintsGC.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
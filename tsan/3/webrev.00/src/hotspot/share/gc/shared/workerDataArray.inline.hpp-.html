<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/workerDataArray.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 26 #define SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
 27 
 28 #include &quot;gc/shared/workerDataArray.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;utilities/ostream.hpp&quot;
 31 
 32 template &lt;typename T&gt;
 33 WorkerDataArray&lt;T&gt;::WorkerDataArray(uint length, const char* title) :
 34  _data(NULL),
 35  _length(length),
 36  _title(title) {
 37   assert(length &gt; 0, &quot;Must have some workers to store data for&quot;);
 38   _data = NEW_C_HEAP_ARRAY(T, _length, mtGC);
 39   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
 40     _thread_work_items[i] = NULL;
 41   }
 42   reset();
 43 }
 44 
 45 template &lt;typename T&gt;
 46 void WorkerDataArray&lt;T&gt;::set(uint worker_i, T value) {
 47   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 48   assert(_data[worker_i] == uninitialized(), &quot;Overwriting data for worker %d in %s&quot;, worker_i, _title);
 49   _data[worker_i] = value;
 50 }
 51 
 52 template &lt;typename T&gt;
 53 T WorkerDataArray&lt;T&gt;::get(uint worker_i) const {
 54   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 55   return _data[worker_i];
 56 }
 57 
 58 template &lt;typename T&gt;
 59 WorkerDataArray&lt;T&gt;::~WorkerDataArray() {
 60   FREE_C_HEAP_ARRAY(T, _data);
 61 }
 62 
 63 template &lt;typename T&gt;
 64 void WorkerDataArray&lt;T&gt;::link_thread_work_items(WorkerDataArray&lt;size_t&gt;* thread_work_items, uint index) {
 65   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 66   _thread_work_items[index] = thread_work_items;
 67 }
 68 
 69 template &lt;typename T&gt;
 70 void WorkerDataArray&lt;T&gt;::set_thread_work_item(uint worker_i, size_t value, uint index) {
 71   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 72   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 73   _thread_work_items[index]-&gt;set(worker_i, value);
 74 }
 75 
 76 template &lt;typename T&gt;
 77 void WorkerDataArray&lt;T&gt;::add_thread_work_item(uint worker_i, size_t value, uint index) {
 78   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 79   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 80   _thread_work_items[index]-&gt;add(worker_i, value);
 81 }
 82 
 83 template &lt;typename T&gt;
 84 void WorkerDataArray&lt;T&gt;::set_or_add_thread_work_item(uint worker_i, size_t value, uint index) {
 85   assert(index &lt; MaxThreadWorkItems, &quot;Tried to access thread work item %u (max %u)&quot;, index, MaxThreadWorkItems);
 86   assert(_thread_work_items[index] != NULL, &quot;No sub count&quot;);
 87   if (_thread_work_items[index]-&gt;get(worker_i) == _thread_work_items[index]-&gt;uninitialized()) {
 88     _thread_work_items[index]-&gt;set(worker_i, value);
 89   } else {
 90     _thread_work_items[index]-&gt;add(worker_i, value);
 91   }
 92 }
 93 
 94 template &lt;typename T&gt;
 95 void WorkerDataArray&lt;T&gt;::add(uint worker_i, T value) {
 96   assert(worker_i &lt; _length, &quot;Worker %d is greater than max: %d&quot;, worker_i, _length);
 97   assert(_data[worker_i] != uninitialized(), &quot;No data to add to for worker %d&quot;, worker_i);
 98   _data[worker_i] += value;
 99 }
100 
101 template &lt;typename T&gt;
102 double WorkerDataArray&lt;T&gt;::average() const {
103   uint contributing_threads = 0;
104   for (uint i = 0; i &lt; _length; ++i) {
105     if (get(i) != uninitialized()) {
106       contributing_threads++;
107     }
108   }
109   if (contributing_threads == 0) {
110     return 0.0;
111   }
112   return sum() / (double) contributing_threads;
113 }
114 
115 template &lt;typename T&gt;
116 T WorkerDataArray&lt;T&gt;::sum() const {
117   T s = 0;
118   for (uint i = 0; i &lt; _length; ++i) {
119     if (get(i) != uninitialized()) {
120       s += get(i);
121     }
122   }
123   return s;
124 }
125 
126 template &lt;typename T&gt;
127 void WorkerDataArray&lt;T&gt;::set_all(T value) {
128   for (uint i = 0; i &lt; _length; i++) {
129     _data[i] = value;
130   }
131 }
132 
133 template &lt;class T&gt;
134 void WorkerDataArray&lt;T&gt;::print_summary_on(outputStream* out, bool print_sum) const {
135   out-&gt;print(&quot;%-25s&quot;, title());
136   uint start = 0;
137   while (start &lt; _length &amp;&amp; get(start) == uninitialized()) {
138     start++;
139   }
140   if (start &lt; _length) {
141     T min = get(start);
142     T max = min;
143     T sum = 0;
144     uint contributing_threads = 0;
145     for (uint i = start; i &lt; _length; ++i) {
146       T value = get(i);
147       if (value != uninitialized()) {
148         max = MAX2(max, value);
149         min = MIN2(min, value);
150         sum += value;
151         contributing_threads++;
152       }
153     }
154     T diff = max - min;
155     assert(contributing_threads != 0, &quot;Must be since we found a used value for the start index&quot;);
156     double avg = sum / (double) contributing_threads;
157     WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);
158     out-&gt;print_cr(&quot;, Workers: %d&quot;, contributing_threads);
159   } else {
160     // No data for this phase.
161     out-&gt;print_cr(&quot; skipped&quot;);
162   }
163 }
164 
165 template &lt;class T&gt;
166 void WorkerDataArray&lt;T&gt;::print_details_on(outputStream* out) const {
167   WDAPrinter::details(this, out);
168 }
169 
170 template &lt;typename T&gt;
171 void WorkerDataArray&lt;T&gt;::reset() {
172   set_all(uninitialized());
173   for (uint i = 0; i &lt; MaxThreadWorkItems; i++) {
174     if (_thread_work_items[i] != NULL) {
175       _thread_work_items[i]-&gt;reset();
176     }
177   }
178 }
179 
180 #endif // SHARE_GC_SHARED_WORKERDATAARRAY_INLINE_HPP
    </pre>
  </body>
</html>
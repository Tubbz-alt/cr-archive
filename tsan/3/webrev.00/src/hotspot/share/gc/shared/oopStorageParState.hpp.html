<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/oopStorageParState.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 26 #define SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
 27 
 28 #include &quot;gc/shared/oopStorage.hpp&quot;
 29 #include &quot;utilities/globalDefinitions.hpp&quot;
 30 
 31 //////////////////////////////////////////////////////////////////////////////
 32 // Support for parallel and optionally concurrent state iteration.
 33 //
 34 // Concurrent Iteration
 35 //
 36 // Iteration involves the _active_array (an ActiveArray), which contains all
 37 // of the blocks owned by a storage object.
 38 //
 39 // A concurrent ParState increments the associated storage&#39;s
 40 // _concurrent_iteration_count when the state is constructed, and
 41 // decrements it when the state is destroyed.  These assignments are made with
 42 // _active_mutex locked.  Meanwhile, empty block deletion is not done while
 43 // _concurrent_iteration_count is non-zero.  The counter check and the dependent
 44 // removal of a block from the _active_array is performed with _active_mutex
 45 // locked.  This prevents concurrent iteration and empty block deletion from
 46 // interfering with with each other.
 47 //
 48 // Both allocate() and delete_empty_blocks() lock the
 49 // _allocation_mutex while performing their respective list and array
 50 // manipulations, preventing them from interfering with each other.
 51 //
 52 // When allocate() creates a new block, it is added to the end of the
 53 // _active_array.  Then _active_array&#39;s _block_count is incremented to account
 54 // for the new block.  When concurrent iteration is started (by a parallel
 55 // worker thread calling the state&#39;s iterate() function), the current
 56 // _active_array and its _block_count are captured for use by the iteration,
 57 // with iteration processing all blocks in that array up to that block count.
 58 //
 59 // As a result, the sequence over which concurrent iteration operates is
 60 // stable.  However, once the iteration is started, later allocations may add
 61 // blocks to the end of the array that won&#39;t be examined by the iteration.
 62 // An allocation may even require expansion of the array, so the iteration is
 63 // no longer processing the current array, but rather the previous one.
 64 // And while the sequence is stable, concurrent allocate() and release()
 65 // operations may change the set of allocated entries in a block at any time
 66 // during the iteration.
 67 //
 68 // As a result, a concurrent iteration handler must accept that some
 69 // allocations and releases that occur after the iteration started will not be
 70 // seen by the iteration.  Further, some may overlap examination by the
 71 // iteration.  To help with this, allocate() and release() have an invariant
 72 // that an entry&#39;s value must be NULL when it is not in use.
 73 //
 74 // ParState&lt;concurrent, is_const&gt;
 75 //   concurrent must be true if iteration may be concurrent with the
 76 //   mutators.
 77 //
 78 //   is_const must be true if the iteration is over a constant storage
 79 //   object, false if the iteration may modify the storage object.
 80 //
 81 // ParState([const] OopStorage* storage)
 82 //   Construct an object for managing an iteration over storage.  For a
 83 //   concurrent ParState, empty block deletion for the associated storage
 84 //   is inhibited for the life of the ParState.
 85 //
 86 // template&lt;typename F&gt; void iterate(F f)
 87 //   Repeatedly claims a block from the associated storage that has
 88 //   not been processed by this iteration (possibly by other threads),
 89 //   and applies f to each entry in the claimed block. Assume p is of
 90 //   type const oop* or oop*, according to is_const. Then f(p) must be
 91 //   a valid expression whose value is ignored.  Concurrent uses must
 92 //   be prepared for an entry&#39;s value to change at any time, due to
 93 //   mutator activity.
 94 //
 95 // template&lt;typename Closure&gt; void oops_do(Closure* cl)
 96 //   Wrapper around iterate, providing an adaptation layer allowing
 97 //   the use of OopClosures and similar objects for iteration.  Assume
 98 //   p is of type const oop* or oop*, according to is_const.  Then
 99 //   cl-&gt;do_oop(p) must be a valid expression whose value is ignored.
100 //   Concurrent uses must be prepared for the entry&#39;s value to change
101 //   at any time, due to mutator activity.
102 //
103 // Optional operations, provided only if !concurrent &amp;&amp; !is_const.
104 // These are not provided when is_const, because the storage object
105 // may be modified by the iteration infrastructure, even if the
106 // provided closure doesn&#39;t modify the storage object.  These are not
107 // provided when concurrent because any pre-filtering behavior by the
108 // iteration infrastructure is inappropriate for concurrent iteration;
109 // modifications of the storage by the mutator could result in the
110 // pre-filtering being applied (successfully or not) to objects that
111 // are unrelated to what the closure finds in the entry.
112 //
113 // template&lt;typename Closure&gt; void weak_oops_do(Closure* cl)
114 // template&lt;typename IsAliveClosure, typename Closure&gt;
115 // void weak_oops_do(IsAliveClosure* is_alive, Closure* cl)
116 //   Wrappers around iterate, providing an adaptation layer allowing
117 //   the use of is-alive closures and OopClosures for iteration.
118 //   Assume p is of type oop*.  Then
119 //
120 //   - cl-&gt;do_oop(p) must be a valid expression whose value is ignored.
121 //
122 //   - is_alive-&gt;do_object_b(*p) must be a valid expression whose value
123 //   is convertible to bool.
124 //
125 //   If *p == NULL then neither is_alive nor cl will be invoked for p.
126 //   If is_alive-&gt;do_object_b(*p) is false, then cl will not be
127 //   invoked on p.
128 
129 class OopStorage::BasicParState {
130   const OopStorage* _storage;
131   ActiveArray* _active_array;
132   size_t _block_count;
133   volatile size_t _next_block;
134   uint _estimated_thread_count;
135   bool _concurrent;
136 
137   NONCOPYABLE(BasicParState);
138 
139   struct IterationData;
140 
141   void update_concurrent_iteration_count(int value);
142   bool claim_next_segment(IterationData* data);
143   bool finish_iteration(const IterationData* data) const;
144 
145   // Wrapper for iteration handler; ignore handler result and return true.
146   template&lt;typename F&gt; class AlwaysTrueFn;
147 
148 public:
149   BasicParState(const OopStorage* storage,
150                 uint estimated_thread_count,
151                 bool concurrent);
152   ~BasicParState();
153 
154   const OopStorage* storage() const { return _storage; }
155 
156   template&lt;bool is_const, typename F&gt; void iterate(F f);
157 
158   static uint default_estimated_thread_count(bool concurrent);
159 };
160 
161 template&lt;bool concurrent, bool is_const&gt;
162 class OopStorage::ParState {
163   BasicParState _basic_state;
164 
165   typedef typename Conditional&lt;is_const,
166                                const OopStorage*,
167                                OopStorage*&gt;::type StoragePtr;
168 
169 public:
170   ParState(StoragePtr storage,
171            uint estimated_thread_count = BasicParState::default_estimated_thread_count(concurrent)) :
172     _basic_state(storage, estimated_thread_count, concurrent)
173   {}
174 
175   const OopStorage* storage() const { return _basic_state.storage(); }
176   template&lt;typename F&gt; void iterate(F f);
177   template&lt;typename Closure&gt; void oops_do(Closure* cl);
178 };
179 
180 template&lt;&gt;
181 class OopStorage::ParState&lt;false, false&gt; {
182   BasicParState _basic_state;
183 
184 public:
185   ParState(OopStorage* storage,
186            uint estimated_thread_count = BasicParState::default_estimated_thread_count(false)) :
187     _basic_state(storage, estimated_thread_count, false)
188   {}
189 
190   const OopStorage* storage() const { return _basic_state.storage(); }
191   template&lt;typename F&gt; void iterate(F f);
192   template&lt;typename Closure&gt; void oops_do(Closure* cl);
193   template&lt;typename Closure&gt; void weak_oops_do(Closure* cl);
194   template&lt;typename IsAliveClosure, typename Closure&gt;
195   void weak_oops_do(IsAliveClosure* is_alive, Closure* cl);
196 };
197 
198 #endif // SHARE_GC_SHARED_OOPSTORAGEPARSTATE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/shared/parallelCleaning.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/stringTable.hpp&quot;
 28 #include &quot;code/codeCache.hpp&quot;
 29 #include &quot;gc/shared/parallelCleaning.hpp&quot;
 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 
 34 StringDedupCleaningTask::StringDedupCleaningTask(BoolObjectClosure* is_alive,
 35                                                  OopClosure* keep_alive,
 36                                                  bool resize_table) :
 37   AbstractGangTask(&quot;String Dedup Cleaning&quot;),
 38   _dedup_closure(is_alive, keep_alive) {
 39 
 40   if (StringDedup::is_enabled()) {
 41     StringDedup::gc_prologue(resize_table);
 42   }
 43 }
 44 
 45 StringDedupCleaningTask::~StringDedupCleaningTask() {
 46   if (StringDedup::is_enabled()) {
 47     StringDedup::gc_epilogue();
 48   }
 49 }
 50 
 51 void StringDedupCleaningTask::work(uint worker_id) {
 52   if (StringDedup::is_enabled()) {
 53     StringDedup::parallel_unlink(&amp;_dedup_closure, worker_id);
 54   }
 55 }
 56 
 57 CodeCacheUnloadingTask::CodeCacheUnloadingTask(uint num_workers, BoolObjectClosure* is_alive, bool unloading_occurred) :
 58   _unloading_scope(is_alive),
 59   _unloading_occurred(unloading_occurred),
 60   _num_workers(num_workers),
 61   _first_nmethod(NULL),
 62   _claimed_nmethod(NULL) {
 63   // Get first alive nmethod
 64   CompiledMethodIterator iter(CompiledMethodIterator::only_alive);
 65   if(iter.next()) {
 66     _first_nmethod = iter.method();
 67   }
 68   _claimed_nmethod = _first_nmethod;
 69 }
 70 
 71 CodeCacheUnloadingTask::~CodeCacheUnloadingTask() {
 72   CodeCache::verify_clean_inline_caches();
 73   CodeCache::verify_icholder_relocations();
 74 }
 75 
 76 void CodeCacheUnloadingTask::claim_nmethods(CompiledMethod** claimed_nmethods, int *num_claimed_nmethods) {
 77   CompiledMethod* first;
 78   CompiledMethodIterator last(CompiledMethodIterator::only_alive);
 79 
 80   do {
 81     *num_claimed_nmethods = 0;
 82 
 83     first = _claimed_nmethod;
 84     last = CompiledMethodIterator(CompiledMethodIterator::only_alive, first);
 85 
 86     if (first != NULL) {
 87 
 88       for (int i = 0; i &lt; MaxClaimNmethods; i++) {
 89         if (!last.next()) {
 90           break;
 91         }
 92         claimed_nmethods[i] = last.method();
 93         (*num_claimed_nmethods)++;
 94       }
 95     }
 96 
 97   } while (Atomic::cmpxchg(last.method(), &amp;_claimed_nmethod, first) != first);
 98 }
 99 
100 void CodeCacheUnloadingTask::work(uint worker_id) {
101   // The first nmethods is claimed by the first worker.
102   if (worker_id == 0 &amp;&amp; _first_nmethod != NULL) {
103     _first_nmethod-&gt;do_unloading(_unloading_occurred);
104     _first_nmethod = NULL;
105   }
106 
107   int num_claimed_nmethods;
108   CompiledMethod* claimed_nmethods[MaxClaimNmethods];
109 
110   while (true) {
111     claim_nmethods(claimed_nmethods, &amp;num_claimed_nmethods);
112 
113     if (num_claimed_nmethods == 0) {
114       break;
115     }
116 
117     for (int i = 0; i &lt; num_claimed_nmethods; i++) {
118       claimed_nmethods[i]-&gt;do_unloading(_unloading_occurred);
119     }
120   }
121 }
122 
123 KlassCleaningTask::KlassCleaningTask() :
124   _clean_klass_tree_claimed(0),
125   _klass_iterator() {
126 }
127 
128 bool KlassCleaningTask::claim_clean_klass_tree_task() {
129   if (_clean_klass_tree_claimed) {
130     return false;
131   }
132 
133   return Atomic::cmpxchg(1, &amp;_clean_klass_tree_claimed, 0) == 0;
134 }
135 
136 InstanceKlass* KlassCleaningTask::claim_next_klass() {
137   Klass* klass;
138   do {
139     klass =_klass_iterator.next_klass();
140   } while (klass != NULL &amp;&amp; !klass-&gt;is_instance_klass());
141 
142   // this can be null so don&#39;t call InstanceKlass::cast
143   return static_cast&lt;InstanceKlass*&gt;(klass);
144 }
145 
146 void KlassCleaningTask::work() {
147   ResourceMark rm;
148 
149   // One worker will clean the subklass/sibling klass tree.
150   if (claim_clean_klass_tree_task()) {
151     Klass::clean_subklass_tree();
152   }
153 
154   // All workers will help cleaning the classes,
155   InstanceKlass* klass;
156   while ((klass = claim_next_klass()) != NULL) {
157     clean_klass(klass);
158   }
159 }
160 
161 ParallelCleaningTask::ParallelCleaningTask(BoolObjectClosure* is_alive,
162                                            uint num_workers,
163                                            bool unloading_occurred,
164                                            bool resize_dedup_table) :
165   AbstractGangTask(&quot;Parallel Cleaning&quot;),
166   _unloading_occurred(unloading_occurred),
167   _string_dedup_task(is_alive, NULL, resize_dedup_table),
168   _code_cache_task(num_workers, is_alive, unloading_occurred),
169   _klass_cleaning_task() {
170 }
171 
172 // The parallel work done by all worker threads.
173 void ParallelCleaningTask::work(uint worker_id) {
174   // Do first pass of code cache cleaning.
175   _code_cache_task.work(worker_id);
176 
177   // Clean the string dedup data structures.
178   _string_dedup_task.work(worker_id);
179 
180   // Clean all klasses that were not unloaded.
181   // The weak metadata in klass doesn&#39;t need to be
182   // processed if there was no unloading.
183   if (_unloading_occurred) {
184     _klass_cleaning_task.work();
185   }
186 }
    </pre>
  </body>
</html>
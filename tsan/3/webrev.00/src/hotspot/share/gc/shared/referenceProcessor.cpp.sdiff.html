<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/referenceProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ptrQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/referenceProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/referencePolicy.hpp&quot;
  33 #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
  34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;

  38 #include &quot;oops/access.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;runtime/java.hpp&quot;
  41 
  42 ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = NULL;
  43 ReferencePolicy* ReferenceProcessor::_default_soft_ref_policy      = NULL;
  44 jlong            ReferenceProcessor::_soft_ref_timestamp_clock = 0;
  45 
  46 void referenceProcessor_init() {
  47   ReferenceProcessor::init_statics();
  48 }
  49 
  50 void ReferenceProcessor::init_statics() {
  51   // We need a monotonically non-decreasing time in ms but
  52   // os::javaTimeMillis() does not guarantee monotonicity.
  53   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  54 
  55   // Initialize the soft ref timestamp clock.
  56   _soft_ref_timestamp_clock = now;
  57   // Also update the soft ref clock in j.l.r.SoftReference
  58   java_lang_ref_SoftReference::set_clock(_soft_ref_timestamp_clock);
  59 
  60   _always_clear_soft_ref_policy = new AlwaysClearPolicy();
  61   if (is_server_compilation_mode_vm()) {
  62     _default_soft_ref_policy = new LRUMaxHeapPolicy();
  63   } else {
  64     _default_soft_ref_policy = new LRUCurrentHeapPolicy();
  65   }
<span class="line-removed">  66   if (_always_clear_soft_ref_policy == NULL || _default_soft_ref_policy == NULL) {</span>
<span class="line-removed">  67     vm_exit_during_initialization(&quot;Could not allocate reference policy object&quot;);</span>
<span class="line-removed">  68   }</span>
  69   guarantee(RefDiscoveryPolicy == ReferenceBasedDiscovery ||
  70             RefDiscoveryPolicy == ReferentBasedDiscovery,
  71             &quot;Unrecognized RefDiscoveryPolicy&quot;);
  72 }
  73 
  74 void ReferenceProcessor::enable_discovery(bool check_no_refs) {
  75 #ifdef ASSERT
  76   // Verify that we&#39;re not currently discovering refs
  77   assert(!_discovering_refs, &quot;nested call?&quot;);
  78 
  79   if (check_no_refs) {
  80     // Verify that the discovered lists are empty
  81     verify_no_references_recorded();
  82   }
  83 #endif // ASSERT
  84 
  85   // Someone could have modified the value of the static
  86   // field in the j.l.r.SoftReference class that holds the
  87   // soft reference timestamp clock using reflection or
  88   // Unsafe between GCs. Unconditionally update the static
</pre>
<hr />
<pre>
 101                                        bool      atomic_discovery,
 102                                        BoolObjectClosure* is_alive_non_header,
 103                                        bool      adjust_no_of_processing_threads)  :
 104   _is_subject_to_discovery(is_subject_to_discovery),
 105   _discovering_refs(false),
 106   _enqueuing_is_done(false),
 107   _processing_is_mt(mt_processing),
 108   _next_id(0),
 109   _adjust_no_of_processing_threads(adjust_no_of_processing_threads),
 110   _is_alive_non_header(is_alive_non_header)
 111 {
 112   assert(is_subject_to_discovery != NULL, &quot;must be set&quot;);
 113 
 114   _discovery_is_atomic = atomic_discovery;
 115   _discovery_is_mt     = mt_discovery;
 116   _num_queues          = MAX2(1U, mt_processing_degree);
 117   _max_num_queues      = MAX2(_num_queues, mt_discovery_degree);
 118   _discovered_refs     = NEW_C_HEAP_ARRAY(DiscoveredList,
 119             _max_num_queues * number_of_subclasses_of_ref(), mtGC);
 120 
<span class="line-removed"> 121   if (_discovered_refs == NULL) {</span>
<span class="line-removed"> 122     vm_exit_during_initialization(&quot;Could not allocated RefProc Array&quot;);</span>
<span class="line-removed"> 123   }</span>
 124   _discoveredSoftRefs    = &amp;_discovered_refs[0];
 125   _discoveredWeakRefs    = &amp;_discoveredSoftRefs[_max_num_queues];
 126   _discoveredFinalRefs   = &amp;_discoveredWeakRefs[_max_num_queues];
 127   _discoveredPhantomRefs = &amp;_discoveredFinalRefs[_max_num_queues];
 128 
 129   // Initialize all entries to NULL
 130   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 131     _discovered_refs[i].clear();
 132   }
 133 
 134   setup_policy(false /* default soft ref policy */);
 135 }
 136 
 137 #ifndef PRODUCT
 138 void ReferenceProcessor::verify_no_references_recorded() {
 139   guarantee(!_discovering_refs, &quot;Discovering refs?&quot;);
 140   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 141     guarantee(_discovered_refs[i].is_empty(),
 142               &quot;Found non-empty discovered list at %u&quot;, i);
 143   }
</pre>
<hr />
<pre>
 251 
 252   if (task_executor != NULL) {
 253     // Record the work done by the parallel workers.
 254     task_executor-&gt;set_single_threaded_mode();
 255   }
 256 
 257   phase_times-&gt;set_total_time_ms((os::elapsedTime() - start_time) * 1000);
 258 
 259   return stats;
 260 }
 261 
 262 void DiscoveredListIterator::load_ptrs(DEBUG_ONLY(bool allow_null_referent)) {
 263   _current_discovered_addr = java_lang_ref_Reference::discovered_addr_raw(_current_discovered);
 264   oop discovered = java_lang_ref_Reference::discovered(_current_discovered);
 265   assert(_current_discovered_addr &amp;&amp; oopDesc::is_oop_or_null(discovered),
 266          &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
 267   _next_discovered = discovered;
 268 
 269   _referent_addr = java_lang_ref_Reference::referent_addr_raw(_current_discovered);
 270   _referent = java_lang_ref_Reference::referent(_current_discovered);
<span class="line-modified"> 271   assert(Universe::heap()-&gt;is_in_reserved_or_null(_referent),</span>
 272          &quot;Wrong oop found in java.lang.Reference object&quot;);
 273   assert(allow_null_referent ?
 274              oopDesc::is_oop_or_null(_referent)
 275            : oopDesc::is_oop(_referent),
 276          &quot;Expected an oop%s for referent field at &quot; PTR_FORMAT,
 277          (allow_null_referent ? &quot; or NULL&quot; : &quot;&quot;),
 278          p2i(_referent));
 279 }
 280 
 281 void DiscoveredListIterator::remove() {
 282   assert(oopDesc::is_oop(_current_discovered), &quot;Dropping a bad reference&quot;);
 283   RawAccess&lt;&gt;::oop_store(_current_discovered_addr, oop(NULL));
 284 
 285   // First _prev_next ref actually points into DiscoveredList (gross).
 286   oop new_next;
<span class="line-modified"> 287   if (oopDesc::equals_raw(_next_discovered, _current_discovered)) {</span>
 288     // At the end of the list, we should make _prev point to itself.
 289     // If _ref is the first ref, then _prev_next will be in the DiscoveredList,
 290     // and _prev will be NULL.
 291     new_next = _prev_discovered;
 292   } else {
 293     new_next = _next_discovered;
 294   }
 295   // Remove Reference object from discovered list. Note that G1 does not need a
 296   // pre-barrier here because we know the Reference has already been found/marked,
 297   // that&#39;s how it ended up in the discovered list in the first place.
 298   RawAccess&lt;&gt;::oop_store(_prev_discovered_addr, new_next);
 299   _removed++;
 300   _refs_list.dec_length(1);
 301 }
 302 
 303 void DiscoveredListIterator::clear_referent() {
 304   RawAccess&lt;&gt;::oop_store(_referent_addr, oop(NULL));
 305 }
 306 
 307 void DiscoveredListIterator::enqueue() {
</pre>
<hr />
<pre>
 318     oop old = Universe::swap_reference_pending_list(_refs_list.head());
 319     HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_store_at(_prev_discovered, java_lang_ref_Reference::discovered_offset, old);
 320   }
 321 }
 322 
 323 inline void log_dropped_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 324   if (log_develop_is_enabled(Trace, gc, ref)) {
 325     ResourceMark rm;
 326     log_develop_trace(gc, ref)(&quot;Dropping %s reference &quot; PTR_FORMAT &quot;: %s&quot;,
 327                                reason, p2i(iter.obj()),
 328                                iter.obj()-&gt;klass()-&gt;internal_name());
 329   }
 330 }
 331 
 332 inline void log_enqueued_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 333   if (log_develop_is_enabled(Trace, gc, ref)) {
 334     ResourceMark rm;
 335     log_develop_trace(gc, ref)(&quot;Enqueue %s reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
 336                                reason, p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
 337   }
<span class="line-modified"> 338   assert(oopDesc::is_oop(iter.obj(), UseConcMarkSweepGC), &quot;Adding a bad reference&quot;);</span>
 339 }
 340 
 341 size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&amp;    refs_list,
 342                                                             ReferencePolicy*   policy,
 343                                                             BoolObjectClosure* is_alive,
 344                                                             OopClosure*        keep_alive,
 345                                                             VoidClosure*       complete_gc) {
 346   assert(policy != NULL, &quot;Must have a non-NULL policy&quot;);
 347   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
 348   // Decide which softly reachable refs should be kept alive.
 349   while (iter.has_next()) {
 350     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));
 351     bool referent_is_dead = (iter.referent() != NULL) &amp;&amp; !iter.is_referent_alive();
 352     if (referent_is_dead &amp;&amp;
 353         !policy-&gt;should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) {
 354       log_dropped_ref(iter, &quot;by policy&quot;);
 355       // Remove Reference object from list
 356       iter.remove();
 357       // keep the referent around
 358       iter.make_referent_alive();
</pre>
<hr />
<pre>
 457     } else {
 458       iter.clear_referent();
 459       iter.enqueue();
 460       log_enqueued_ref(iter, &quot;cleared Phantom&quot;);
 461       iter.next();
 462     }
 463   }
 464   iter.complete_enqueue();
 465   // Close the reachable set; needed for collectors which keep_alive_closure do
 466   // not immediately complete their work.
 467   complete_gc-&gt;do_void();
 468   refs_list.clear();
 469 
 470   return iter.removed();
 471 }
 472 
 473 void
 474 ReferenceProcessor::clear_discovered_references(DiscoveredList&amp; refs_list) {
 475   oop obj = NULL;
 476   oop next = refs_list.head();
<span class="line-modified"> 477   while (!oopDesc::equals_raw(next, obj)) {</span>
 478     obj = next;
 479     next = java_lang_ref_Reference::discovered(obj);
 480     java_lang_ref_Reference::set_discovered_raw(obj, NULL);
 481   }
 482   refs_list.clear();
 483 }
 484 
 485 void ReferenceProcessor::abandon_partial_discovery() {
 486   // loop over the lists
 487   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 488     if ((i % _max_num_queues) == 0) {
 489       log_develop_trace(gc, ref)(&quot;Abandoning %s discovered list&quot;, list_name(i));
 490     }
 491     clear_discovered_references(_discovered_refs[i]);
 492   }
 493 }
 494 
 495 size_t ReferenceProcessor::total_reference_count(ReferenceType type) const {
 496   DiscoveredList* list = NULL;
 497 
</pre>
<hr />
<pre>
 729         oop move_head = ref_lists[from_idx].head();
 730         oop move_tail = move_head;
 731         oop new_head  = move_head;
 732         // find an element to split the list on
 733         for (size_t j = 0; j &lt; refs_to_move; ++j) {
 734           move_tail = new_head;
 735           new_head = java_lang_ref_Reference::discovered(new_head);
 736         }
 737 
 738         // Add the chain to the to list.
 739         if (ref_lists[to_idx].head() == NULL) {
 740           // to list is empty. Make a loop at the end.
 741           java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);
 742         } else {
 743           java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());
 744         }
 745         ref_lists[to_idx].set_head(move_head);
 746         ref_lists[to_idx].inc_length(refs_to_move);
 747 
 748         // Remove the chain from the from list.
<span class="line-modified"> 749         if (oopDesc::equals_raw(move_tail, new_head)) {</span>
 750           // We found the end of the from list.
 751           ref_lists[from_idx].set_head(NULL);
 752         } else {
 753           ref_lists[from_idx].set_head(new_head);
 754         }
 755         ref_lists[from_idx].dec_length(refs_to_move);
 756         if (ref_lists[from_idx].length() == 0) {
 757           break;
 758         }
 759       } else {
 760         to_idx = (to_idx + 1) % _num_queues;
 761       }
 762     }
 763   }
 764 #ifdef ASSERT
 765   log_reflist_counts(ref_lists, _num_queues);
 766   size_t balanced_total_refs = 0;
 767   for (uint i = 0; i &lt; _num_queues; ++i) {
 768     balanced_total_refs += ref_lists[i].length();
 769   }
</pre>
<hr />
<pre>
1016     case REF_NONE:
1017       // we should not reach here if we are an InstanceRefKlass
1018     default:
1019       ShouldNotReachHere();
1020   }
1021   log_develop_trace(gc, ref)(&quot;Thread %d gets list &quot; INTPTR_FORMAT, id, p2i(list));
1022   return list;
1023 }
1024 
1025 inline void
1026 ReferenceProcessor::add_to_discovered_list_mt(DiscoveredList&amp; refs_list,
1027                                               oop             obj,
1028                                               HeapWord*       discovered_addr) {
1029   assert(_discovery_is_mt, &quot;!_discovery_is_mt should have been handled by caller&quot;);
1030   // First we must make sure this object is only enqueued once. CAS in a non null
1031   // discovered_addr.
1032   oop current_head = refs_list.head();
1033   // The last ref must have its discovered field pointing to itself.
1034   oop next_discovered = (current_head != NULL) ? current_head : obj;
1035 
<span class="line-modified">1036   oop retest = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_atomic_cmpxchg(next_discovered, discovered_addr, oop(NULL));</span>
1037 
1038   if (retest == NULL) {
1039     // This thread just won the right to enqueue the object.
1040     // We have separate lists for enqueueing, so no synchronization
1041     // is necessary.
1042     refs_list.set_head(obj);
1043     refs_list.inc_length(1);
1044 
1045     log_develop_trace(gc, ref)(&quot;Discovered reference (mt) (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1046                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1047   } else {
1048     // If retest was non NULL, another thread beat us to it:
1049     // The reference has already been discovered...
1050     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1051                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1052   }
1053 }
1054 
1055 #ifndef PRODUCT
1056 // Non-atomic (i.e. concurrent) discovery might allow us
</pre>
<hr />
<pre>
1139   ResourceMark rm;      // Needed for tracing.
1140 
1141   HeapWord* const discovered_addr = java_lang_ref_Reference::discovered_addr_raw(obj);
1142   const oop  discovered = java_lang_ref_Reference::discovered(obj);
1143   assert(oopDesc::is_oop_or_null(discovered), &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
1144   if (discovered != NULL) {
1145     // The reference has already been discovered...
1146     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1147                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1148     if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1149       // assumes that an object is not processed twice;
1150       // if it&#39;s been already discovered it must be on another
1151       // generation&#39;s discovered list; so we won&#39;t discover it.
1152       return false;
1153     } else {
1154       assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,
1155              &quot;Unrecognized policy&quot;);
1156       // Check assumption that an object is not potentially
1157       // discovered twice except by concurrent collectors that potentially
1158       // trace the same Reference object twice.
<span class="line-modified">1159       assert(UseConcMarkSweepGC || UseG1GC || UseShenandoahGC,</span>
1160              &quot;Only possible with a concurrent marking collector&quot;);
1161       return true;
1162     }
1163   }
1164 
1165   if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1166     verify_referent(obj);
1167     // Discover if and only if EITHER:
1168     // .. reference is in our span, OR
1169     // .. we are an atomic collector and referent is in our span
1170     if (is_subject_to_discovery(obj) ||
1171         (discovery_is_atomic() &amp;&amp;
1172          is_subject_to_discovery(java_lang_ref_Reference::referent(obj)))) {
1173     } else {
1174       return false;
1175     }
1176   } else {
1177     assert(RefDiscoveryPolicy == ReferenceBasedDiscovery &amp;&amp;
1178            is_subject_to_discovery(obj), &quot;code inconsistency&quot;);
1179   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;gc/shared/collectedHeap.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/gcTimer.hpp&quot;
  31 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  32 #include &quot;gc/shared/referencePolicy.hpp&quot;
  33 #include &quot;gc/shared/referenceProcessor.inline.hpp&quot;
  34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  38 #include &quot;memory/universe.hpp&quot;</span>
  39 #include &quot;oops/access.inline.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;runtime/java.hpp&quot;
  42 
  43 ReferencePolicy* ReferenceProcessor::_always_clear_soft_ref_policy = NULL;
  44 ReferencePolicy* ReferenceProcessor::_default_soft_ref_policy      = NULL;
  45 jlong            ReferenceProcessor::_soft_ref_timestamp_clock = 0;
  46 
  47 void referenceProcessor_init() {
  48   ReferenceProcessor::init_statics();
  49 }
  50 
  51 void ReferenceProcessor::init_statics() {
  52   // We need a monotonically non-decreasing time in ms but
  53   // os::javaTimeMillis() does not guarantee monotonicity.
  54   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
  55 
  56   // Initialize the soft ref timestamp clock.
  57   _soft_ref_timestamp_clock = now;
  58   // Also update the soft ref clock in j.l.r.SoftReference
  59   java_lang_ref_SoftReference::set_clock(_soft_ref_timestamp_clock);
  60 
  61   _always_clear_soft_ref_policy = new AlwaysClearPolicy();
  62   if (is_server_compilation_mode_vm()) {
  63     _default_soft_ref_policy = new LRUMaxHeapPolicy();
  64   } else {
  65     _default_soft_ref_policy = new LRUCurrentHeapPolicy();
  66   }



  67   guarantee(RefDiscoveryPolicy == ReferenceBasedDiscovery ||
  68             RefDiscoveryPolicy == ReferentBasedDiscovery,
  69             &quot;Unrecognized RefDiscoveryPolicy&quot;);
  70 }
  71 
  72 void ReferenceProcessor::enable_discovery(bool check_no_refs) {
  73 #ifdef ASSERT
  74   // Verify that we&#39;re not currently discovering refs
  75   assert(!_discovering_refs, &quot;nested call?&quot;);
  76 
  77   if (check_no_refs) {
  78     // Verify that the discovered lists are empty
  79     verify_no_references_recorded();
  80   }
  81 #endif // ASSERT
  82 
  83   // Someone could have modified the value of the static
  84   // field in the j.l.r.SoftReference class that holds the
  85   // soft reference timestamp clock using reflection or
  86   // Unsafe between GCs. Unconditionally update the static
</pre>
<hr />
<pre>
  99                                        bool      atomic_discovery,
 100                                        BoolObjectClosure* is_alive_non_header,
 101                                        bool      adjust_no_of_processing_threads)  :
 102   _is_subject_to_discovery(is_subject_to_discovery),
 103   _discovering_refs(false),
 104   _enqueuing_is_done(false),
 105   _processing_is_mt(mt_processing),
 106   _next_id(0),
 107   _adjust_no_of_processing_threads(adjust_no_of_processing_threads),
 108   _is_alive_non_header(is_alive_non_header)
 109 {
 110   assert(is_subject_to_discovery != NULL, &quot;must be set&quot;);
 111 
 112   _discovery_is_atomic = atomic_discovery;
 113   _discovery_is_mt     = mt_discovery;
 114   _num_queues          = MAX2(1U, mt_processing_degree);
 115   _max_num_queues      = MAX2(_num_queues, mt_discovery_degree);
 116   _discovered_refs     = NEW_C_HEAP_ARRAY(DiscoveredList,
 117             _max_num_queues * number_of_subclasses_of_ref(), mtGC);
 118 



 119   _discoveredSoftRefs    = &amp;_discovered_refs[0];
 120   _discoveredWeakRefs    = &amp;_discoveredSoftRefs[_max_num_queues];
 121   _discoveredFinalRefs   = &amp;_discoveredWeakRefs[_max_num_queues];
 122   _discoveredPhantomRefs = &amp;_discoveredFinalRefs[_max_num_queues];
 123 
 124   // Initialize all entries to NULL
 125   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 126     _discovered_refs[i].clear();
 127   }
 128 
 129   setup_policy(false /* default soft ref policy */);
 130 }
 131 
 132 #ifndef PRODUCT
 133 void ReferenceProcessor::verify_no_references_recorded() {
 134   guarantee(!_discovering_refs, &quot;Discovering refs?&quot;);
 135   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 136     guarantee(_discovered_refs[i].is_empty(),
 137               &quot;Found non-empty discovered list at %u&quot;, i);
 138   }
</pre>
<hr />
<pre>
 246 
 247   if (task_executor != NULL) {
 248     // Record the work done by the parallel workers.
 249     task_executor-&gt;set_single_threaded_mode();
 250   }
 251 
 252   phase_times-&gt;set_total_time_ms((os::elapsedTime() - start_time) * 1000);
 253 
 254   return stats;
 255 }
 256 
 257 void DiscoveredListIterator::load_ptrs(DEBUG_ONLY(bool allow_null_referent)) {
 258   _current_discovered_addr = java_lang_ref_Reference::discovered_addr_raw(_current_discovered);
 259   oop discovered = java_lang_ref_Reference::discovered(_current_discovered);
 260   assert(_current_discovered_addr &amp;&amp; oopDesc::is_oop_or_null(discovered),
 261          &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
 262   _next_discovered = discovered;
 263 
 264   _referent_addr = java_lang_ref_Reference::referent_addr_raw(_current_discovered);
 265   _referent = java_lang_ref_Reference::referent(_current_discovered);
<span class="line-modified"> 266   assert(Universe::heap()-&gt;is_in_or_null(_referent),</span>
 267          &quot;Wrong oop found in java.lang.Reference object&quot;);
 268   assert(allow_null_referent ?
 269              oopDesc::is_oop_or_null(_referent)
 270            : oopDesc::is_oop(_referent),
 271          &quot;Expected an oop%s for referent field at &quot; PTR_FORMAT,
 272          (allow_null_referent ? &quot; or NULL&quot; : &quot;&quot;),
 273          p2i(_referent));
 274 }
 275 
 276 void DiscoveredListIterator::remove() {
 277   assert(oopDesc::is_oop(_current_discovered), &quot;Dropping a bad reference&quot;);
 278   RawAccess&lt;&gt;::oop_store(_current_discovered_addr, oop(NULL));
 279 
 280   // First _prev_next ref actually points into DiscoveredList (gross).
 281   oop new_next;
<span class="line-modified"> 282   if (_next_discovered == _current_discovered) {</span>
 283     // At the end of the list, we should make _prev point to itself.
 284     // If _ref is the first ref, then _prev_next will be in the DiscoveredList,
 285     // and _prev will be NULL.
 286     new_next = _prev_discovered;
 287   } else {
 288     new_next = _next_discovered;
 289   }
 290   // Remove Reference object from discovered list. Note that G1 does not need a
 291   // pre-barrier here because we know the Reference has already been found/marked,
 292   // that&#39;s how it ended up in the discovered list in the first place.
 293   RawAccess&lt;&gt;::oop_store(_prev_discovered_addr, new_next);
 294   _removed++;
 295   _refs_list.dec_length(1);
 296 }
 297 
 298 void DiscoveredListIterator::clear_referent() {
 299   RawAccess&lt;&gt;::oop_store(_referent_addr, oop(NULL));
 300 }
 301 
 302 void DiscoveredListIterator::enqueue() {
</pre>
<hr />
<pre>
 313     oop old = Universe::swap_reference_pending_list(_refs_list.head());
 314     HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_store_at(_prev_discovered, java_lang_ref_Reference::discovered_offset, old);
 315   }
 316 }
 317 
 318 inline void log_dropped_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 319   if (log_develop_is_enabled(Trace, gc, ref)) {
 320     ResourceMark rm;
 321     log_develop_trace(gc, ref)(&quot;Dropping %s reference &quot; PTR_FORMAT &quot;: %s&quot;,
 322                                reason, p2i(iter.obj()),
 323                                iter.obj()-&gt;klass()-&gt;internal_name());
 324   }
 325 }
 326 
 327 inline void log_enqueued_ref(const DiscoveredListIterator&amp; iter, const char* reason) {
 328   if (log_develop_is_enabled(Trace, gc, ref)) {
 329     ResourceMark rm;
 330     log_develop_trace(gc, ref)(&quot;Enqueue %s reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
 331                                reason, p2i(iter.obj()), iter.obj()-&gt;klass()-&gt;internal_name());
 332   }
<span class="line-modified"> 333   assert(oopDesc::is_oop(iter.obj()), &quot;Adding a bad reference&quot;);</span>
 334 }
 335 
 336 size_t ReferenceProcessor::process_soft_ref_reconsider_work(DiscoveredList&amp;    refs_list,
 337                                                             ReferencePolicy*   policy,
 338                                                             BoolObjectClosure* is_alive,
 339                                                             OopClosure*        keep_alive,
 340                                                             VoidClosure*       complete_gc) {
 341   assert(policy != NULL, &quot;Must have a non-NULL policy&quot;);
 342   DiscoveredListIterator iter(refs_list, keep_alive, is_alive);
 343   // Decide which softly reachable refs should be kept alive.
 344   while (iter.has_next()) {
 345     iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() /* allow_null_referent */));
 346     bool referent_is_dead = (iter.referent() != NULL) &amp;&amp; !iter.is_referent_alive();
 347     if (referent_is_dead &amp;&amp;
 348         !policy-&gt;should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) {
 349       log_dropped_ref(iter, &quot;by policy&quot;);
 350       // Remove Reference object from list
 351       iter.remove();
 352       // keep the referent around
 353       iter.make_referent_alive();
</pre>
<hr />
<pre>
 452     } else {
 453       iter.clear_referent();
 454       iter.enqueue();
 455       log_enqueued_ref(iter, &quot;cleared Phantom&quot;);
 456       iter.next();
 457     }
 458   }
 459   iter.complete_enqueue();
 460   // Close the reachable set; needed for collectors which keep_alive_closure do
 461   // not immediately complete their work.
 462   complete_gc-&gt;do_void();
 463   refs_list.clear();
 464 
 465   return iter.removed();
 466 }
 467 
 468 void
 469 ReferenceProcessor::clear_discovered_references(DiscoveredList&amp; refs_list) {
 470   oop obj = NULL;
 471   oop next = refs_list.head();
<span class="line-modified"> 472   while (next != obj) {</span>
 473     obj = next;
 474     next = java_lang_ref_Reference::discovered(obj);
 475     java_lang_ref_Reference::set_discovered_raw(obj, NULL);
 476   }
 477   refs_list.clear();
 478 }
 479 
 480 void ReferenceProcessor::abandon_partial_discovery() {
 481   // loop over the lists
 482   for (uint i = 0; i &lt; _max_num_queues * number_of_subclasses_of_ref(); i++) {
 483     if ((i % _max_num_queues) == 0) {
 484       log_develop_trace(gc, ref)(&quot;Abandoning %s discovered list&quot;, list_name(i));
 485     }
 486     clear_discovered_references(_discovered_refs[i]);
 487   }
 488 }
 489 
 490 size_t ReferenceProcessor::total_reference_count(ReferenceType type) const {
 491   DiscoveredList* list = NULL;
 492 
</pre>
<hr />
<pre>
 724         oop move_head = ref_lists[from_idx].head();
 725         oop move_tail = move_head;
 726         oop new_head  = move_head;
 727         // find an element to split the list on
 728         for (size_t j = 0; j &lt; refs_to_move; ++j) {
 729           move_tail = new_head;
 730           new_head = java_lang_ref_Reference::discovered(new_head);
 731         }
 732 
 733         // Add the chain to the to list.
 734         if (ref_lists[to_idx].head() == NULL) {
 735           // to list is empty. Make a loop at the end.
 736           java_lang_ref_Reference::set_discovered_raw(move_tail, move_tail);
 737         } else {
 738           java_lang_ref_Reference::set_discovered_raw(move_tail, ref_lists[to_idx].head());
 739         }
 740         ref_lists[to_idx].set_head(move_head);
 741         ref_lists[to_idx].inc_length(refs_to_move);
 742 
 743         // Remove the chain from the from list.
<span class="line-modified"> 744         if (move_tail == new_head) {</span>
 745           // We found the end of the from list.
 746           ref_lists[from_idx].set_head(NULL);
 747         } else {
 748           ref_lists[from_idx].set_head(new_head);
 749         }
 750         ref_lists[from_idx].dec_length(refs_to_move);
 751         if (ref_lists[from_idx].length() == 0) {
 752           break;
 753         }
 754       } else {
 755         to_idx = (to_idx + 1) % _num_queues;
 756       }
 757     }
 758   }
 759 #ifdef ASSERT
 760   log_reflist_counts(ref_lists, _num_queues);
 761   size_t balanced_total_refs = 0;
 762   for (uint i = 0; i &lt; _num_queues; ++i) {
 763     balanced_total_refs += ref_lists[i].length();
 764   }
</pre>
<hr />
<pre>
1011     case REF_NONE:
1012       // we should not reach here if we are an InstanceRefKlass
1013     default:
1014       ShouldNotReachHere();
1015   }
1016   log_develop_trace(gc, ref)(&quot;Thread %d gets list &quot; INTPTR_FORMAT, id, p2i(list));
1017   return list;
1018 }
1019 
1020 inline void
1021 ReferenceProcessor::add_to_discovered_list_mt(DiscoveredList&amp; refs_list,
1022                                               oop             obj,
1023                                               HeapWord*       discovered_addr) {
1024   assert(_discovery_is_mt, &quot;!_discovery_is_mt should have been handled by caller&quot;);
1025   // First we must make sure this object is only enqueued once. CAS in a non null
1026   // discovered_addr.
1027   oop current_head = refs_list.head();
1028   // The last ref must have its discovered field pointing to itself.
1029   oop next_discovered = (current_head != NULL) ? current_head : obj;
1030 
<span class="line-modified">1031   oop retest = HeapAccess&lt;AS_NO_KEEPALIVE&gt;::oop_atomic_cmpxchg(discovered_addr, oop(NULL), next_discovered);</span>
1032 
1033   if (retest == NULL) {
1034     // This thread just won the right to enqueue the object.
1035     // We have separate lists for enqueueing, so no synchronization
1036     // is necessary.
1037     refs_list.set_head(obj);
1038     refs_list.inc_length(1);
1039 
1040     log_develop_trace(gc, ref)(&quot;Discovered reference (mt) (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1041                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1042   } else {
1043     // If retest was non NULL, another thread beat us to it:
1044     // The reference has already been discovered...
1045     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1046                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1047   }
1048 }
1049 
1050 #ifndef PRODUCT
1051 // Non-atomic (i.e. concurrent) discovery might allow us
</pre>
<hr />
<pre>
1134   ResourceMark rm;      // Needed for tracing.
1135 
1136   HeapWord* const discovered_addr = java_lang_ref_Reference::discovered_addr_raw(obj);
1137   const oop  discovered = java_lang_ref_Reference::discovered(obj);
1138   assert(oopDesc::is_oop_or_null(discovered), &quot;Expected an oop or NULL for discovered field at &quot; PTR_FORMAT, p2i(discovered));
1139   if (discovered != NULL) {
1140     // The reference has already been discovered...
1141     log_develop_trace(gc, ref)(&quot;Already discovered reference (&quot; INTPTR_FORMAT &quot;: %s)&quot;,
1142                                p2i(obj), obj-&gt;klass()-&gt;internal_name());
1143     if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1144       // assumes that an object is not processed twice;
1145       // if it&#39;s been already discovered it must be on another
1146       // generation&#39;s discovered list; so we won&#39;t discover it.
1147       return false;
1148     } else {
1149       assert(RefDiscoveryPolicy == ReferenceBasedDiscovery,
1150              &quot;Unrecognized policy&quot;);
1151       // Check assumption that an object is not potentially
1152       // discovered twice except by concurrent collectors that potentially
1153       // trace the same Reference object twice.
<span class="line-modified">1154       assert(UseG1GC || UseShenandoahGC,</span>
1155              &quot;Only possible with a concurrent marking collector&quot;);
1156       return true;
1157     }
1158   }
1159 
1160   if (RefDiscoveryPolicy == ReferentBasedDiscovery) {
1161     verify_referent(obj);
1162     // Discover if and only if EITHER:
1163     // .. reference is in our span, OR
1164     // .. we are an atomic collector and referent is in our span
1165     if (is_subject_to_discovery(obj) ||
1166         (discovery_is_atomic() &amp;&amp;
1167          is_subject_to_discovery(java_lang_ref_Reference::referent(obj)))) {
1168     } else {
1169       return false;
1170     }
1171   } else {
1172     assert(RefDiscoveryPolicy == ReferenceBasedDiscovery &amp;&amp;
1173            is_subject_to_discovery(obj), &quot;code inconsistency&quot;);
1174   }
</pre>
</td>
</tr>
</table>
<center><a href="ptrQueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="referenceProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="gc_globals.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genCollectedHeap.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/genCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,23 +40,27 @@</span>
  #include &quot;gc/shared/gcId.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  #include &quot;gc/shared/gcTrace.hpp&quot;
  #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/genArguments.hpp&quot;</span>
  #include &quot;gc/shared/gcVMOperations.hpp&quot;
  #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  #include &quot;gc/shared/generationSpec.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/locationPrinter.inline.hpp&quot;</span>
  #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  #include &quot;gc/shared/space.hpp&quot;
  #include &quot;gc/shared/strongRootsScope.hpp&quot;
  #include &quot;gc/shared/weakProcessor.hpp&quot;
  #include &quot;gc/shared/workgroup.hpp&quot;
  #include &quot;memory/filemap.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/metaspaceCounters.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/flags/flagSetting.hpp&quot;
  #include &quot;runtime/handles.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67,26 +71,27 @@</span>
  #include &quot;utilities/debug.hpp&quot;
  #include &quot;utilities/formatBuffer.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/stack.inline.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
<span class="udiff-line-added">+ #if INCLUDE_JVMCI</span>
<span class="udiff-line-added">+ #include &quot;jvmci/jvmci.hpp&quot;</span>
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- GenCollectedHeap::GenCollectedHeap(GenCollectorPolicy *policy,</span>
<span class="udiff-line-removed">-                                    Generation::Name young,</span>
<span class="udiff-line-modified-added">+ GenCollectedHeap::GenCollectedHeap(Generation::Name young,</span>
                                     Generation::Name old,
                                     const char* policy_counters_name) :
    CollectedHeap(),
    _young_gen_spec(new GenerationSpec(young,
<span class="udiff-line-modified-removed">-                                      policy-&gt;initial_young_size(),</span>
<span class="udiff-line-modified-removed">-                                      policy-&gt;max_young_size(),</span>
<span class="udiff-line-modified-removed">-                                      policy-&gt;gen_alignment())),</span>
<span class="udiff-line-modified-added">+                                      NewSize,</span>
<span class="udiff-line-modified-added">+                                      MaxNewSize,</span>
<span class="udiff-line-modified-added">+                                      GenAlignment)),</span>
    _old_gen_spec(new GenerationSpec(old,
<span class="udiff-line-modified-removed">-                                    policy-&gt;initial_old_size(),</span>
<span class="udiff-line-modified-removed">-                                    policy-&gt;max_old_size(),</span>
<span class="udiff-line-modified-removed">-                                    policy-&gt;gen_alignment())),</span>
<span class="udiff-line-modified-added">+                                    OldSize,</span>
<span class="udiff-line-modified-added">+                                    MaxOldSize,</span>
<span class="udiff-line-modified-added">+                                    GenAlignment)),</span>
    _rem_set(NULL),
<span class="udiff-line-removed">-   _gen_policy(policy),</span>
    _soft_ref_gen_policy(),
    _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),
    _full_collections_completed(0),
    _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)) {
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99,36 +104,31 @@</span>
    // HeapWordSize).
    guarantee(HeapWordSize == wordSize, &quot;HeapWordSize must equal wordSize&quot;);
  
    // Allocate space for the heap.
  
<span class="udiff-line-modified-removed">-   char* heap_address;</span>
<span class="udiff-line-removed">-   ReservedSpace heap_rs;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   size_t heap_alignment = collector_policy()-&gt;heap_alignment();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   heap_address = allocate(heap_alignment, &amp;heap_rs);</span>
<span class="udiff-line-modified-added">+   ReservedHeapSpace heap_rs = allocate(HeapAlignment);</span>
  
    if (!heap_rs.is_reserved()) {
      vm_shutdown_during_initialization(
        &quot;Could not reserve enough space for object heap&quot;);
      return JNI_ENOMEM;
    }
  
<span class="udiff-line-modified-removed">-   initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size()));</span>
<span class="udiff-line-modified-added">+   initialize_reserved_region(heap_rs);</span>
  
<span class="udiff-line-modified-removed">-   _rem_set = create_rem_set(reserved_region());</span>
<span class="udiff-line-modified-added">+   _rem_set = create_rem_set(heap_rs.region());</span>
    _rem_set-&gt;initialize();
    CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
    bs-&gt;initialize();
    BarrierSet::set_barrier_set(bs);
  
    ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec-&gt;max_size(), false, false);
    _young_gen = _young_gen_spec-&gt;init(young_rs, rem_set());
<span class="udiff-line-modified-removed">-   heap_rs = heap_rs.last_part(_young_gen_spec-&gt;max_size());</span>
<span class="udiff-line-modified-added">+   ReservedSpace old_rs = heap_rs.last_part(_young_gen_spec-&gt;max_size());</span>
  
<span class="udiff-line-modified-removed">-   ReservedSpace old_rs = heap_rs.first_part(_old_gen_spec-&gt;max_size(), false, false);</span>
<span class="udiff-line-modified-added">+   old_rs = old_rs.first_part(_old_gen_spec-&gt;max_size(), false, false);</span>
    _old_gen = _old_gen_spec-&gt;init(old_rs, rem_set());
    clear_incremental_collection_failed();
  
    return JNI_OK;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146,12 +146,11 @@</span>
                                          init_survivor_size,
                                          max_gc_pause_sec,
                                          GCTimeRatio);
  }
  
<span class="udiff-line-modified-removed">- char* GenCollectedHeap::allocate(size_t alignment,</span>
<span class="udiff-line-removed">-                                  ReservedSpace* heap_rs){</span>
<span class="udiff-line-modified-added">+ ReservedHeapSpace GenCollectedHeap::allocate(size_t alignment) {</span>
    // Now figure out the total size.
    const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();
    assert(alignment % pageSize == 0, &quot;Must be&quot;);
  
    // Check for overflow.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,20 +161,20 @@</span>
    }
    assert(total_reserved % alignment == 0,
           &quot;Gen size; total_reserved=&quot; SIZE_FORMAT &quot;, alignment=&quot;
           SIZE_FORMAT, total_reserved, alignment);
  
<span class="udiff-line-modified-removed">-   *heap_rs = Universe::reserve_heap(total_reserved, alignment);</span>
<span class="udiff-line-modified-added">+   ReservedHeapSpace heap_rs = Universe::reserve_heap(total_reserved, alignment);</span>
  
    os::trace_page_sizes(&quot;Heap&quot;,
<span class="udiff-line-modified-removed">-                        collector_policy()-&gt;min_heap_byte_size(),</span>
<span class="udiff-line-modified-added">+                        MinHeapSize,</span>
                         total_reserved,
                         alignment,
<span class="udiff-line-modified-removed">-                        heap_rs-&gt;base(),</span>
<span class="udiff-line-modified-removed">-                        heap_rs-&gt;size());</span>
<span class="udiff-line-modified-added">+                        heap_rs.base(),</span>
<span class="udiff-line-modified-added">+                        heap_rs.size());</span>
  
<span class="udiff-line-modified-removed">-   return heap_rs-&gt;base();</span>
<span class="udiff-line-modified-added">+   return heap_rs;</span>
  }
  
  class GenIsScavengable : public BoolObjectClosure {
  public:
    bool do_object_b(oop obj) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,10 +202,23 @@</span>
  void GenCollectedHeap::ref_processing_init() {
    _young_gen-&gt;ref_processor_init();
    _old_gen-&gt;ref_processor_init();
  }
  
<span class="udiff-line-added">+ PreGenGCValues GenCollectedHeap::get_pre_gc_values() const {</span>
<span class="udiff-line-added">+   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return PreGenGCValues(def_new_gen-&gt;used(),</span>
<span class="udiff-line-added">+                         def_new_gen-&gt;capacity(),</span>
<span class="udiff-line-added">+                         def_new_gen-&gt;eden()-&gt;used(),</span>
<span class="udiff-line-added">+                         def_new_gen-&gt;eden()-&gt;capacity(),</span>
<span class="udiff-line-added">+                         def_new_gen-&gt;from()-&gt;used(),</span>
<span class="udiff-line-added">+                         def_new_gen-&gt;from()-&gt;capacity(),</span>
<span class="udiff-line-added">+                         old_gen()-&gt;used(),</span>
<span class="udiff-line-added">+                         old_gen()-&gt;capacity());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  GenerationSpec* GenCollectedHeap::young_gen_spec() const {
    return _young_gen_spec;
  }
  
  GenerationSpec* GenCollectedHeap::old_gen_spec() const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -231,11 +243,11 @@</span>
  }
  
  // Update the _full_collections_completed counter
  // at the end of a stop-world full GC.
  unsigned int GenCollectedHeap::update_full_collections_completed() {
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
    assert(_full_collections_completed &lt;= _total_full_collections,
           &quot;Can&#39;t complete more collections than were started&quot;);
    _full_collections_completed = _total_full_collections;
    ml.notify_all();
    return _full_collections_completed;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -245,11 +257,11 @@</span>
  // at the end of a concurrent GC cycle. Note the conditional update
  // below to allow this method to be called by a concurrent collector
  // without synchronizing in any manner with the VM thread (which
  // may already have initiated a STW full collection &quot;concurrently&quot;).
  unsigned int GenCollectedHeap::update_full_collections_completed(unsigned int count) {
<span class="udiff-line-modified-removed">-   MonitorLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);</span>
    assert((_full_collections_completed &lt;= _total_full_collections) &amp;&amp;
           (count &lt;= _total_full_collections),
           &quot;Can&#39;t complete more collections than were started&quot;);
    if (count &gt; _full_collections_completed) {
      _full_collections_completed = count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,39 +417,10 @@</span>
                                  &quot; size=&quot; SIZE_FORMAT &quot; %s&quot;, try_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);
      }
    }
  }
  
<span class="udiff-line-removed">- #ifndef PRODUCT</span>
<span class="udiff-line-removed">- // Override of memory state checking method in CollectedHeap:</span>
<span class="udiff-line-removed">- // Some collectors (CMS for example) can&#39;t have badHeapWordVal written</span>
<span class="udiff-line-removed">- // in the first two words of an object. (For instance , in the case of</span>
<span class="udiff-line-removed">- // CMS these words hold state used to synchronize between certain</span>
<span class="udiff-line-removed">- // (concurrent) GC steps and direct allocating mutators.)</span>
<span class="udiff-line-removed">- // The skip_header_HeapWords() method below, allows us to skip</span>
<span class="udiff-line-removed">- // over the requisite number of HeapWord&#39;s. Note that (for</span>
<span class="udiff-line-removed">- // generational collectors) this means that those many words are</span>
<span class="udiff-line-removed">- // skipped in each object, irrespective of the generation in which</span>
<span class="udiff-line-removed">- // that object lives. The resultant loss of precision seems to be</span>
<span class="udiff-line-removed">- // harmless and the pain of avoiding that imprecision appears somewhat</span>
<span class="udiff-line-removed">- // higher than we are prepared to pay for such rudimentary debugging</span>
<span class="udiff-line-removed">- // support.</span>
<span class="udiff-line-removed">- void GenCollectedHeap::check_for_non_bad_heap_word_value(HeapWord* addr,</span>
<span class="udiff-line-removed">-                                                          size_t size) {</span>
<span class="udiff-line-removed">-   if (CheckMemoryInitialization &amp;&amp; ZapUnusedHeapArea) {</span>
<span class="udiff-line-removed">-     // We are asked to check a size in HeapWords,</span>
<span class="udiff-line-removed">-     // but the memory is mangled in juint words.</span>
<span class="udiff-line-removed">-     juint* start = (juint*) (addr + skip_header_HeapWords());</span>
<span class="udiff-line-removed">-     juint* end   = (juint*) (addr + size);</span>
<span class="udiff-line-removed">-     for (juint* slot = start; slot &lt; end; slot += 1) {</span>
<span class="udiff-line-removed">-       assert(*slot == badHeapWordVal,</span>
<span class="udiff-line-removed">-              &quot;Found non badHeapWordValue in pre-allocation check&quot;);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  HeapWord* GenCollectedHeap::attempt_allocation(size_t size,
                                                 bool is_tlab,
                                                 bool first_only) {
    HeapWord* res = NULL;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -487,11 +470,11 @@</span>
  
    if (run_verification &amp;&amp; VerifyBeforeGC) {
      HandleMark hm;  // Discard invalid handles created during verification
      Universe::verify(&quot;Before GC&quot;);
    }
<span class="udiff-line-modified-removed">-   COMPILER2_PRESENT(DerivedPointerTable::clear());</span>
<span class="udiff-line-modified-added">+   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());</span>
  
    if (restore_marks_for_biased_locking) {
      // We perform this mark word preservation work lazily
      // because it&#39;s only at this point that we know whether we
      // absolutely have to do it; we want to avoid doing it for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -535,11 +518,11 @@</span>
        rp-&gt;set_enqueuing_is_done(false);
      }
      rp-&gt;verify_no_references_recorded();
    }
  
<span class="udiff-line-modified-removed">-   COMPILER2_PRESENT(DerivedPointerTable::update_pointers());</span>
<span class="udiff-line-modified-added">+   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());</span>
  
    gen-&gt;stat_record()-&gt;accumulated_time.stop();
  
    update_gc_stats(gen, full);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,21 +555,17 @@</span>
    const bool do_clear_all_soft_refs = clear_all_soft_refs ||
                            soft_ref_policy()-&gt;should_clear_all_soft_refs();
  
    ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());
  
<span class="udiff-line-removed">-   const size_t metadata_prev_used = MetaspaceUtils::used_bytes();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
    FlagSetting fl(_is_gc_active, true);
  
    bool complete = full &amp;&amp; (max_generation == OldGen);
    bool old_collects_young = complete &amp;&amp; !ScavengeBeforeFullGC;
    bool do_young_collection = !old_collects_young &amp;&amp; _young_gen-&gt;should_collect(full, size, is_tlab);
  
<span class="udiff-line-modified-removed">-   size_t young_prev_used = _young_gen-&gt;used();</span>
<span class="udiff-line-removed">-   size_t old_prev_used = _old_gen-&gt;used();</span>
<span class="udiff-line-modified-added">+   const PreGenGCValues pre_gc_values = get_pre_gc_values();</span>
  
    bool run_verification = total_collections() &gt;= VerifyGCStartAt;
    bool prepared_for_verification = false;
    bool do_full_collection = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -624,12 +603,11 @@</span>
      do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
      if (!do_full_collection) {
        // Adjust generation sizes.
        _young_gen-&gt;compute_new_size();
  
<span class="udiff-line-modified-removed">-       print_heap_change(young_prev_used, old_prev_used);</span>
<span class="udiff-line-removed">-       MetaspaceUtils::print_metaspace_change(metadata_prev_used);</span>
<span class="udiff-line-modified-added">+       print_heap_change(pre_gc_values);</span>
  
        // Track memory usage and detect low memory after GC finishes
        MemoryService::track_memory_usage();
  
        gc_epilogue(complete);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -683,12 +661,11 @@</span>
      MetaspaceUtils::verify_metrics();
      // Resize the metaspace capacity after full collections
      MetaspaceGC::compute_new_size();
      update_full_collections_completed();
  
<span class="udiff-line-modified-removed">-     print_heap_change(young_prev_used, old_prev_used);</span>
<span class="udiff-line-removed">-     MetaspaceUtils::print_metaspace_change(metadata_prev_used);</span>
<span class="udiff-line-modified-added">+     print_heap_change(pre_gc_values);</span>
  
      // Track memory usage and detect low memory after GC finishes
      MemoryService::track_memory_usage();
  
      // Need to tell the epilogue code we are done with Full GC, regardless what was
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -697,14 +674,10 @@</span>
  
      BiasedLocking::restore_marks();
  
      print_heap_after_gc();
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef TRACESPINNING</span>
<span class="udiff-line-removed">-   ParallelTaskTerminator::print_termination_counts();</span>
<span class="udiff-line-removed">- #endif</span>
  }
  
  bool GenCollectedHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,
                                                   GenCollectedHeap::GenerationType max_gen) const {
    return max_gen == OldGen &amp;&amp; _old_gen-&gt;should_collect(full, size, is_tlab);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -721,14 +694,14 @@</span>
  void GenCollectedHeap::verify_nmethod(nmethod* nm) {
    ScavengableNMethods::verify_nmethod(nm);
  }
  
  void GenCollectedHeap::flush_nmethod(nmethod* nm) {
<span class="udiff-line-modified-removed">-   ScavengableNMethods::flush_nmethod(nm);</span>
<span class="udiff-line-modified-added">+   // Do nothing.</span>
  }
  
<span class="udiff-line-modified-removed">- void GenCollectedHeap::prune_nmethods() {</span>
<span class="udiff-line-modified-added">+ void GenCollectedHeap::prune_scavengable_nmethods() {</span>
    ScavengableNMethods::prune_nmethods();
  }
  
  HeapWord* GenCollectedHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {
    GCCauseSetter x(this, GCCause::_allocation_failure);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -822,11 +795,10 @@</span>
                                       OopClosure* strong_roots,
                                       CLDClosure* strong_cld_closure,
                                       CLDClosure* weak_cld_closure,
                                       CodeBlobToOopClosure* code_roots) {
    // General roots.
<span class="udiff-line-removed">-   assert(Threads::thread_claim_parity() != 0, &quot;must have called prologue code&quot;);</span>
    assert(code_roots != NULL, &quot;code root closure should always be set&quot;);
    // _n_termination for _process_strong_tasks should be set up stream
    // in a method not running in a GC worker.  Otherwise the GC worker
    // could be trying to change the termination condition while the task
    // is executing in another GC worker.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -856,24 +828,25 @@</span>
      Management::oops_do(strong_roots);
    }
    if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_jvmti_oops_do)) {
      JvmtiExport::oops_do(strong_roots);
    }
<span class="udiff-line-added">+ #if INCLUDE_AOT</span>
    if (UseAOT &amp;&amp; _process_strong_tasks-&gt;try_claim_task(GCH_PS_aot_oops_do)) {
      AOTLoader::oops_do(strong_roots);
    }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ #endif</span>
    if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_SystemDictionary_oops_do)) {
      SystemDictionary::oops_do(strong_roots);
    }
  
    if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_CodeCache_oops_do)) {
      if (so &amp; SO_ScavengeCodeCache) {
        assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
  
        // We only visit parts of the CodeCache when scavenging.
<span class="udiff-line-modified-removed">-       ScavengableNMethods::scavengable_nmethods_do(code_roots);</span>
<span class="udiff-line-modified-added">+       ScavengableNMethods::nmethods_do(code_roots);</span>
      }
      if (so &amp; SO_AllCodeCache) {
        assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
  
        // CMSCollector uses this to do intermediate-strength collections.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,12 +919,13 @@</span>
  }
  
  // public collection interfaces
  
  void GenCollectedHeap::collect(GCCause::Cause cause) {
<span class="udiff-line-modified-removed">-   if (cause == GCCause::_wb_young_gc) {</span>
<span class="udiff-line-modified-removed">-     // Young collection for the WhiteBox API.</span>
<span class="udiff-line-modified-added">+   if ((cause == GCCause::_wb_young_gc) ||</span>
<span class="udiff-line-modified-added">+       (cause == GCCause::_gc_locker)) {</span>
<span class="udiff-line-added">+     // Young collection for WhiteBox or GCLocker.</span>
      collect(cause, YoungGen);
    } else {
  #ifdef ASSERT
    if (cause == GCCause::_scavenge_alot) {
      // Young collection only.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -985,10 +959,15 @@</span>
  
  void GenCollectedHeap::collect_locked(GCCause::Cause cause, GenerationType max_generation) {
    // Read the GC count while holding the Heap_lock
    unsigned int gc_count_before      = total_collections();
    unsigned int full_gc_count_before = total_full_collections();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (GCLocker::should_discard(cause, gc_count_before)) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    {
      MutexUnlocker mu(Heap_lock);  // give up heap lock, execute gets it back
      VM_GenCollectFull op(gc_count_before, full_gc_count_before,
                           cause, max_generation);
      VMThread::execute(&amp;op);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -999,28 +978,19 @@</span>
     do_full_collection(clear_all_soft_refs, OldGen);
  }
  
  void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs,
                                            GenerationType last_generation) {
<span class="udiff-line-removed">-   GenerationType local_last_generation;</span>
<span class="udiff-line-removed">-   if (!incremental_collection_will_fail(false /* don&#39;t consult_young */) &amp;&amp;</span>
<span class="udiff-line-removed">-       gc_cause() == GCCause::_gc_locker) {</span>
<span class="udiff-line-removed">-     local_last_generation = YoungGen;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     local_last_generation = last_generation;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
    do_collection(true,                   // full
                  clear_all_soft_refs,    // clear_all_soft_refs
                  0,                      // size
                  false,                  // is_tlab
<span class="udiff-line-modified-removed">-                 local_last_generation); // last_generation</span>
<span class="udiff-line-modified-added">+                 last_generation);       // last_generation</span>
    // Hack XXX FIX ME !!!
    // A scavenge may not have been attempted, or may have
    // been attempted and failed, because the old gen was too full
<span class="udiff-line-modified-removed">-   if (local_last_generation == YoungGen &amp;&amp; gc_cause() == GCCause::_gc_locker &amp;&amp;</span>
<span class="udiff-line-removed">-       incremental_collection_will_fail(false /* don&#39;t consult_young */)) {</span>
<span class="udiff-line-modified-added">+   if (gc_cause() == GCCause::_gc_locker &amp;&amp; incremental_collection_failed()) {</span>
      log_debug(gc, jni)(&quot;GC locker: Trying a full collection because scavenge failed&quot;);
      // This time allow the old gen to be collected as well
      do_collection(true,                // full
                    clear_all_soft_refs, // clear_all_soft_refs
                    0,                   // size
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1028,11 +998,11 @@</span>
                    OldGen);             // last_generation
    }
  }
  
  bool GenCollectedHeap::is_in_young(oop p) {
<span class="udiff-line-modified-removed">-   bool result = ((HeapWord*)p) &lt; _old_gen-&gt;reserved().start();</span>
<span class="udiff-line-modified-added">+   bool result = cast_from_oop&lt;HeapWord*&gt;(p) &lt; _old_gen-&gt;reserved().start();</span>
    assert(result == _young_gen-&gt;is_in_reserved(p),
           &quot;incorrect test - result=%d, p=&quot; INTPTR_FORMAT, result, p2i((void*)p));
    return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1059,15 +1029,10 @@</span>
  void GenCollectedHeap::object_iterate(ObjectClosure* cl) {
    _young_gen-&gt;object_iterate(cl);
    _old_gen-&gt;object_iterate(cl);
  }
  
<span class="udiff-line-removed">- void GenCollectedHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="udiff-line-removed">-   _young_gen-&gt;safe_object_iterate(cl);</span>
<span class="udiff-line-removed">-   _old_gen-&gt;safe_object_iterate(cl);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  Space* GenCollectedHeap::space_containing(const void* addr) const {
    Space* res = _young_gen-&gt;space_containing(addr);
    if (res != NULL) {
      return res;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1225,12 +1190,11 @@</span>
  }
  
  GenCollectedHeap* GenCollectedHeap::heap() {
    CollectedHeap* heap = Universe::heap();
    assert(heap != NULL, &quot;Uninitialized access to GenCollectedHeap::heap()&quot;);
<span class="udiff-line-modified-removed">-   assert(heap-&gt;kind() == CollectedHeap::Serial ||</span>
<span class="udiff-line-removed">-          heap-&gt;kind() == CollectedHeap::CMS, &quot;Invalid name&quot;);</span>
<span class="udiff-line-modified-added">+   assert(heap-&gt;kind() == CollectedHeap::Serial, &quot;Invalid name&quot;);</span>
    return (GenCollectedHeap*) heap;
  }
  
  #if INCLUDE_SERIALGC
  void GenCollectedHeap::prepare_for_compaction() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1262,23 +1226,50 @@</span>
  }
  
  void GenCollectedHeap::print_gc_threads_on(outputStream* st) const {
  }
  
<span class="udiff-line-added">+ bool GenCollectedHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="udiff-line-added">+   return BlockLocationPrinter&lt;GenCollectedHeap&gt;::print_location(st, addr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void GenCollectedHeap::print_tracing_info() const {
    if (log_is_enabled(Debug, gc, heap, exit)) {
      LogStreamHandle(Debug, gc, heap, exit) lsh;
      _young_gen-&gt;print_summary_info_on(&amp;lsh);
      _old_gen-&gt;print_summary_info_on(&amp;lsh);
    }
  }
  
<span class="udiff-line-modified-removed">- void GenCollectedHeap::print_heap_change(size_t young_prev_used, size_t old_prev_used) const {</span>
<span class="udiff-line-modified-removed">-   log_info(gc, heap)(&quot;%s: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="udiff-line-modified-removed">-                      _young_gen-&gt;short_name(), young_prev_used / K, _young_gen-&gt;used() /K, _young_gen-&gt;capacity() /K);</span>
<span class="udiff-line-modified-removed">-   log_info(gc, heap)(&quot;%s: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K(&quot;  SIZE_FORMAT &quot;K)&quot;,</span>
<span class="udiff-line-modified-removed">-                      _old_gen-&gt;short_name(), old_prev_used / K, _old_gen-&gt;used() /K, _old_gen-&gt;capacity() /K);</span>
<span class="udiff-line-modified-added">+ void GenCollectedHeap::print_heap_change(const PreGenGCValues&amp; pre_gc_values) const {</span>
<span class="udiff-line-modified-added">+   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   log_info(gc, heap)(HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="udiff-line-modified-added">+                      HEAP_CHANGE_FORMAT&quot; &quot;</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT,</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(def_new_gen-&gt;short_name(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.young_gen_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.young_gen_capacity(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;used(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;capacity()),</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(&quot;Eden&quot;,</span>
<span class="udiff-line-added">+                                              pre_gc_values.eden_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.eden_capacity(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;eden()-&gt;used(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;eden()-&gt;capacity()),</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(&quot;From&quot;,</span>
<span class="udiff-line-added">+                                              pre_gc_values.from_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.from_capacity(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;from()-&gt;used(),</span>
<span class="udiff-line-added">+                                              def_new_gen-&gt;from()-&gt;capacity()));</span>
<span class="udiff-line-added">+   log_info(gc, heap)(HEAP_CHANGE_FORMAT,</span>
<span class="udiff-line-added">+                      HEAP_CHANGE_FORMAT_ARGS(old_gen()-&gt;short_name(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.old_gen_used(),</span>
<span class="udiff-line-added">+                                              pre_gc_values.old_gen_capacity(),</span>
<span class="udiff-line-added">+                                              old_gen()-&gt;used(),</span>
<span class="udiff-line-added">+                                              old_gen()-&gt;capacity()));</span>
<span class="udiff-line-added">+   MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());</span>
  }
  
  class GenGCPrologueClosure: public GenCollectedHeap::GenClosure {
   private:
    bool _full;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1368,11 +1359,11 @@</span>
    HeapWord* result = NULL;
  
    result = old_gen-&gt;expand_and_allocate(obj_size, false);
  
    if (result != NULL) {
<span class="udiff-line-modified-removed">-     Copy::aligned_disjoint_words((HeapWord*)obj, result, obj_size);</span>
<span class="udiff-line-modified-added">+     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), result, obj_size);</span>
    }
    return oop(result);
  }
  
  class GenTimeOfLastGCClosure: public GenCollectedHeap::GenClosure {
</pre>
<center><a href="gc_globals.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="genCollectedHeap.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
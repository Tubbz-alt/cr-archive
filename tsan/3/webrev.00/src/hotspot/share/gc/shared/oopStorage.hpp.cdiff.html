<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shared/oopStorage.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="oopStorage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/oopStorage.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 150,22 ***</span>
    // Parallel iteration is for the exclusive use of the GC.
    // Other clients must use serial iteration.
    template&lt;bool concurrent, bool is_const&gt; class ParState;
  
    // Service thread cleanup support.
<span class="line-modified">!   // Stops deleting if there is an in-progress concurrent iteration.</span>
<span class="line-modified">!   // Locks both the _allocation_mutex and the _active_mutex, and may</span>
<span class="line-modified">!   // safepoint.  Deletion may be throttled, with only some available</span>
<span class="line-modified">!   // work performed, in order to allow other Service thread subtasks</span>
<span class="line-modified">!   // to run.  Returns true if there may be more work to do, false if</span>
<span class="line-modified">!   // nothing to do.</span>
    bool delete_empty_blocks();
  
<span class="line-modified">!   // Service thread cleanup support.</span>
<span class="line-modified">!   // Called by the service thread (while holding Service_lock) to test</span>
<span class="line-modified">!   // whether a call to delete_empty_blocks should be made.</span>
<span class="line-modified">!   bool needs_delete_empty_blocks() const;</span>
  
    // Debugging and logging support.
    const char* name() const;
    void print_on(outputStream* st) const PRODUCT_RETURN;
  
<span class="line-new-header">--- 150,30 ---</span>
    // Parallel iteration is for the exclusive use of the GC.
    // Other clients must use serial iteration.
    template&lt;bool concurrent, bool is_const&gt; class ParState;
  
    // Service thread cleanup support.
<span class="line-modified">! </span>
<span class="line-modified">!   // Called by the service thread to process any pending cleanups for this</span>
<span class="line-modified">!   // storage object.  Drains the _deferred_updates list, and deletes empty</span>
<span class="line-modified">!   // blocks.  Stops deleting if there is an in-progress concurrent</span>
<span class="line-modified">!   // iteration.  Locks both the _allocation_mutex and the _active_mutex, and</span>
<span class="line-modified">!   // may safepoint.  Deletion may be throttled, with only some available</span>
<span class="line-added">+   // work performed, in order to allow other Service thread subtasks to run.</span>
<span class="line-added">+   // Returns true if there may be more work to do, false if nothing to do.</span>
    bool delete_empty_blocks();
  
<span class="line-modified">!   // Called by safepoint cleanup to notify the service thread (via</span>
<span class="line-modified">!   // Service_lock) that there may be some OopStorage objects with pending</span>
<span class="line-modified">!   // cleanups to process.</span>
<span class="line-modified">!   static void trigger_cleanup_if_needed();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Called by the service thread (while holding Service_lock) to to test</span>
<span class="line-added">+   // for pending cleanup requests, and resets the request state to allow</span>
<span class="line-added">+   // recognition of new requests.  Returns true if there was a pending</span>
<span class="line-added">+   // request.</span>
<span class="line-added">+   static bool has_cleanup_work_and_reset();</span>
  
    // Debugging and logging support.
    const char* name() const;
    void print_on(outputStream* st) const PRODUCT_RETURN;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,26 ***</span>
    // Declare, but not define, the public class OopStorage::TestAccess.
    // That class is defined as part of the unit-test. It &quot;exports&quot; the needed
    // private types by providing public typedefs for them.
    class TestAccess;
  
<span class="line-modified">!   // xlC on AIX can&#39;t compile test_oopStorage.cpp with following private</span>
<span class="line-removed">-   // classes. C++03 introduced access for nested classes with DR45, but xlC</span>
<span class="line-removed">-   // version 12 rejects it.</span>
<span class="line-removed">- NOT_AIX( private: )</span>
    class Block;                  // Fixed-size array of oops, plus bookkeeping.
    class ActiveArray;            // Array of Blocks, plus bookkeeping.
    class AllocationListEntry;    // Provides AllocationList links in a Block.
  
    // Doubly-linked list of Blocks.
    class AllocationList {
      const Block* _head;
      const Block* _tail;
  
<span class="line-modified">!     // Noncopyable.</span>
<span class="line-removed">-     AllocationList(const AllocationList&amp;);</span>
<span class="line-removed">-     AllocationList&amp; operator=(const AllocationList&amp;);</span>
  
    public:
      AllocationList();
      ~AllocationList();
  
<span class="line-new-header">--- 181,21 ---</span>
    // Declare, but not define, the public class OopStorage::TestAccess.
    // That class is defined as part of the unit-test. It &quot;exports&quot; the needed
    // private types by providing public typedefs for them.
    class TestAccess;
  
<span class="line-modified">! private:</span>
    class Block;                  // Fixed-size array of oops, plus bookkeeping.
    class ActiveArray;            // Array of Blocks, plus bookkeeping.
    class AllocationListEntry;    // Provides AllocationList links in a Block.
  
    // Doubly-linked list of Blocks.
    class AllocationList {
      const Block* _head;
      const Block* _tail;
  
<span class="line-modified">!     NONCOPYABLE(AllocationList);</span>
  
    public:
      AllocationList();
      ~AllocationList();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,14 ***</span>
  
  private:
    const char* _name;
    ActiveArray* _active_array;
    AllocationList _allocation_list;
<span class="line-removed">- AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
    Block* volatile _deferred_updates;
<span class="line-removed">- AIX_ONLY(private:)</span>
<span class="line-removed">- </span>
    Mutex* _allocation_mutex;
    Mutex* _active_mutex;
  
    // Volatile for racy unlocked accesses.
    volatile size_t _allocation_count;
<span class="line-new-header">--- 217,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,22 ***</span>
    mutable SingleWriterSynchronizer _protect_active;
  
    // mutable because this gets set even for const iteration.
    mutable int _concurrent_iteration_count;
  
<span class="line-modified">!   volatile uint _needs_cleanup;</span>
  
    bool try_add_block();
    Block* block_for_allocation();
  
    Block* find_block_or_null(const oop* ptr) const;
    void delete_empty_block(const Block&amp; block);
    bool reduce_deferred_updates();
<span class="line-removed">-   void notify_needs_cleanup();</span>
<span class="line-removed">- AIX_ONLY(public:)               // xlC 12 on AIX doesn&#39;t implement C++ DR45.</span>
    void record_needs_cleanup();
<span class="line-removed">- AIX_ONLY(private:)</span>
  
    // Managing _active_array.
    bool expand_active_array();
    void replace_active_array(ActiveArray* new_array);
    ActiveArray* obtain_active_array() const;
<span class="line-new-header">--- 230,19 ---</span>
    mutable SingleWriterSynchronizer _protect_active;
  
    // mutable because this gets set even for const iteration.
    mutable int _concurrent_iteration_count;
  
<span class="line-modified">!   volatile bool _needs_cleanup;</span>
  
    bool try_add_block();
    Block* block_for_allocation();
  
    Block* find_block_or_null(const oop* ptr) const;
    void delete_empty_block(const Block&amp; block);
    bool reduce_deferred_updates();
    void record_needs_cleanup();
  
    // Managing _active_array.
    bool expand_active_array();
    void replace_active_array(ActiveArray* new_array);
    ActiveArray* obtain_active_array() const;
</pre>
<center><a href="oopStorage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="oopStorage.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
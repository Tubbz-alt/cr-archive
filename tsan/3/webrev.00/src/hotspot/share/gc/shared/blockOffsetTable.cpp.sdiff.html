<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/blockOffsetTable.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="barrierSetNMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="blockOffsetTable.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/blockOffsetTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
227     last_entry = entry;  // remember for monotonicity test
228   }
229 }
230 
231 
232 void
233 BlockOffsetArray::alloc_block(HeapWord* blk_start, HeapWord* blk_end) {
234   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
235          &quot;phantom block&quot;);
236   single_block(blk_start, blk_end);
237 }
238 
239 // Action_mark - update the BOT for the block [blk_start, blk_end).
240 //               Current typical use is for splitting a block.
241 // Action_single - udpate the BOT for an allocation.
242 // Action_verify - BOT verification.
243 void
244 BlockOffsetArray::do_block_internal(HeapWord* blk_start,
245                                     HeapWord* blk_end,
246                                     Action action, bool reducing) {
<span class="line-modified">247   assert(Universe::heap()-&gt;is_in_reserved(blk_start),</span>
<span class="line-modified">248          &quot;reference must be into the heap&quot;);</span>
<span class="line-modified">249   assert(Universe::heap()-&gt;is_in_reserved(blk_end-1),</span>
<span class="line-modified">250          &quot;limit must be within the heap&quot;);</span>
251   // This is optimized to make the test fast, assuming we only rarely
252   // cross boundaries.
253   uintptr_t end_ui = (uintptr_t)(blk_end - 1);
254   uintptr_t start_ui = (uintptr_t)blk_start;
255   // Calculate the last card boundary preceding end of blk
256   intptr_t boundary_before_end = (intptr_t)end_ui;
257   clear_bits(boundary_before_end, right_n_bits((int)BOTConstants::LogN));
258   if (start_ui &lt;= (uintptr_t)boundary_before_end) {
259     // blk starts at or crosses a boundary
260     // Calculate index of card on which blk begins
261     size_t    start_index = _array-&gt;index_for(blk_start);
262     // Index of card on which blk ends
263     size_t    end_index   = _array-&gt;index_for(blk_end - 1);
264     // Start address of card on which blk begins
265     HeapWord* boundary    = _array-&gt;address_for_index(start_index);
266     assert(boundary &lt;= blk_start, &quot;blk should start at or after boundary&quot;);
267     if (blk_start != boundary) {
268       // blk starts strictly after boundary
269       // adjust card boundary and start_index forward to next card
270       boundary += BOTConstants::N_words;
</pre>
<hr />
<pre>
334     HeapWord* p = _array-&gt;address_for_index(next_index) + 1;
335     if (p &gt;= _end) {
336       // That&#39;s all of the allocated block table.
337       return;
338     }
339     // block_start() asserts that start &lt;= p.
340     HeapWord* start = block_start(p);
341     // First check if the start is an allocated block and only
342     // then if it is a valid object.
343     oop o = oop(start);
344     assert(!Universe::is_fully_initialized() ||
345            _sp-&gt;is_free_block(start) ||
346            oopDesc::is_oop_or_null(o), &quot;Bad object was found&quot;);
347     next_index++;
348     last_p = p;
349     last_start = start;
350     last_o = o;
351   }
352 }
353 
<span class="line-removed">354 //////////////////////////////////////////////////////////////////////</span>
<span class="line-removed">355 // BlockOffsetArrayNonContigSpace</span>
<span class="line-removed">356 //////////////////////////////////////////////////////////////////////</span>
<span class="line-removed">357 </span>
<span class="line-removed">358 // The block [blk_start, blk_end) has been allocated;</span>
<span class="line-removed">359 // adjust the block offset table to represent this information;</span>
<span class="line-removed">360 // NOTE: Clients of BlockOffsetArrayNonContigSpace: consider using</span>
<span class="line-removed">361 // the somewhat more lightweight split_block() or</span>
<span class="line-removed">362 // (when init_to_zero()) mark_block() wherever possible.</span>
<span class="line-removed">363 // right-open interval: [blk_start, blk_end)</span>
<span class="line-removed">364 void</span>
<span class="line-removed">365 BlockOffsetArrayNonContigSpace::alloc_block(HeapWord* blk_start,</span>
<span class="line-removed">366                                             HeapWord* blk_end) {</span>
<span class="line-removed">367   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,</span>
<span class="line-removed">368          &quot;phantom block&quot;);</span>
<span class="line-removed">369   single_block(blk_start, blk_end);</span>
<span class="line-removed">370   allocated(blk_start, blk_end);</span>
<span class="line-removed">371 }</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 // Adjust BOT to show that a previously whole block has been split</span>
<span class="line-removed">374 // into two.  We verify the BOT for the first part (prefix) and</span>
<span class="line-removed">375 // update the  BOT for the second part (suffix).</span>
<span class="line-removed">376 //      blk is the start of the block</span>
<span class="line-removed">377 //      blk_size is the size of the original block</span>
<span class="line-removed">378 //      left_blk_size is the size of the first part of the split</span>
<span class="line-removed">379 void BlockOffsetArrayNonContigSpace::split_block(HeapWord* blk,</span>
<span class="line-removed">380                                                  size_t blk_size,</span>
<span class="line-removed">381                                                  size_t left_blk_size) {</span>
<span class="line-removed">382   // Verify that the BOT shows [blk, blk + blk_size) to be one block.</span>
<span class="line-removed">383   verify_single_block(blk, blk_size);</span>
<span class="line-removed">384   // Update the BOT to indicate that [blk + left_blk_size, blk + blk_size)</span>
<span class="line-removed">385   // is one single block.</span>
<span class="line-removed">386   assert(blk_size &gt; 0, &quot;Should be positive&quot;);</span>
<span class="line-removed">387   assert(left_blk_size &gt; 0, &quot;Should be positive&quot;);</span>
<span class="line-removed">388   assert(left_blk_size &lt; blk_size, &quot;Not a split&quot;);</span>
<span class="line-removed">389 </span>
<span class="line-removed">390   // Start addresses of prefix block and suffix block.</span>
<span class="line-removed">391   HeapWord* pref_addr = blk;</span>
<span class="line-removed">392   HeapWord* suff_addr = blk + left_blk_size;</span>
<span class="line-removed">393   HeapWord* end_addr  = blk + blk_size;</span>
<span class="line-removed">394 </span>
<span class="line-removed">395   // Indices for starts of prefix block and suffix block.</span>
<span class="line-removed">396   size_t pref_index = _array-&gt;index_for(pref_addr);</span>
<span class="line-removed">397   if (_array-&gt;address_for_index(pref_index) != pref_addr) {</span>
<span class="line-removed">398     // pref_addr does not begin pref_index</span>
<span class="line-removed">399     pref_index++;</span>
<span class="line-removed">400   }</span>
<span class="line-removed">401 </span>
<span class="line-removed">402   size_t suff_index = _array-&gt;index_for(suff_addr);</span>
<span class="line-removed">403   if (_array-&gt;address_for_index(suff_index) != suff_addr) {</span>
<span class="line-removed">404     // suff_addr does not begin suff_index</span>
<span class="line-removed">405     suff_index++;</span>
<span class="line-removed">406   }</span>
<span class="line-removed">407 </span>
<span class="line-removed">408   // Definition: A block B, denoted [B_start, B_end) __starts__</span>
<span class="line-removed">409   //     a card C, denoted [C_start, C_end), where C_start and C_end</span>
<span class="line-removed">410   //     are the heap addresses that card C covers, iff</span>
<span class="line-removed">411   //     B_start &lt;= C_start &lt; B_end.</span>
<span class="line-removed">412   //</span>
<span class="line-removed">413   //     We say that a card C &quot;is started by&quot; a block B, iff</span>
<span class="line-removed">414   //     B &quot;starts&quot; C.</span>
<span class="line-removed">415   //</span>
<span class="line-removed">416   //     Note that the cardinality of the set of cards {C}</span>
<span class="line-removed">417   //     started by a block B can be 0, 1, or more.</span>
<span class="line-removed">418   //</span>
<span class="line-removed">419   // Below, pref_index and suff_index are, respectively, the</span>
<span class="line-removed">420   // first (least) card indices that the prefix and suffix of</span>
<span class="line-removed">421   // the split start; end_index is one more than the index of</span>
<span class="line-removed">422   // the last (greatest) card that blk starts.</span>
<span class="line-removed">423   size_t end_index  = _array-&gt;index_for(end_addr - 1) + 1;</span>
<span class="line-removed">424 </span>
<span class="line-removed">425   // Calculate the # cards that the prefix and suffix affect.</span>
<span class="line-removed">426   size_t num_pref_cards = suff_index - pref_index;</span>
<span class="line-removed">427 </span>
<span class="line-removed">428   size_t num_suff_cards = end_index  - suff_index;</span>
<span class="line-removed">429   // Change the cards that need changing</span>
<span class="line-removed">430   if (num_suff_cards &gt; 0) {</span>
<span class="line-removed">431     HeapWord* boundary = _array-&gt;address_for_index(suff_index);</span>
<span class="line-removed">432     // Set the offset card for suffix block</span>
<span class="line-removed">433     _array-&gt;set_offset_array(suff_index, boundary, suff_addr, true /* reducing */);</span>
<span class="line-removed">434     // Change any further cards that need changing in the suffix</span>
<span class="line-removed">435     if (num_pref_cards &gt; 0) {</span>
<span class="line-removed">436       if (num_pref_cards &gt;= num_suff_cards) {</span>
<span class="line-removed">437         // Unilaterally fix all of the suffix cards: closed card</span>
<span class="line-removed">438         // index interval in args below.</span>
<span class="line-removed">439         set_remainder_to_point_to_start_incl(suff_index + 1, end_index - 1, true /* reducing */);</span>
<span class="line-removed">440       } else {</span>
<span class="line-removed">441         // Unilaterally fix the first (num_pref_cards - 1) following</span>
<span class="line-removed">442         // the &quot;offset card&quot; in the suffix block.</span>
<span class="line-removed">443         const size_t right_most_fixed_index = suff_index + num_pref_cards - 1;</span>
<span class="line-removed">444         set_remainder_to_point_to_start_incl(suff_index + 1,</span>
<span class="line-removed">445           right_most_fixed_index, true /* reducing */);</span>
<span class="line-removed">446         // Fix the appropriate cards in the remainder of the</span>
<span class="line-removed">447         // suffix block -- these are the last num_pref_cards</span>
<span class="line-removed">448         // cards in each power block of the &quot;new&quot; range plumbed</span>
<span class="line-removed">449         // from suff_addr.</span>
<span class="line-removed">450         bool more = true;</span>
<span class="line-removed">451         uint i = 1;</span>
<span class="line-removed">452         // Fix the first power block with  back_by &gt; num_pref_cards.</span>
<span class="line-removed">453         while (more &amp;&amp; (i &lt; BOTConstants::N_powers)) {</span>
<span class="line-removed">454           size_t back_by = BOTConstants::power_to_cards_back(i);</span>
<span class="line-removed">455           size_t right_index = suff_index + back_by - 1;</span>
<span class="line-removed">456           size_t left_index  = right_index - num_pref_cards + 1;</span>
<span class="line-removed">457           if (right_index &gt;= end_index - 1) { // last iteration</span>
<span class="line-removed">458             right_index = end_index - 1;</span>
<span class="line-removed">459             more = false;</span>
<span class="line-removed">460           }</span>
<span class="line-removed">461           if (left_index &lt;= right_most_fixed_index) {</span>
<span class="line-removed">462                 left_index = right_most_fixed_index + 1;</span>
<span class="line-removed">463           }</span>
<span class="line-removed">464           if (back_by &gt; num_pref_cards) {</span>
<span class="line-removed">465             // Fill in the remainder of this &quot;power block&quot;, if it</span>
<span class="line-removed">466             // is non-null.</span>
<span class="line-removed">467             if (left_index &lt;= right_index) {</span>
<span class="line-removed">468               _array-&gt;set_offset_array(left_index, right_index,</span>
<span class="line-removed">469                                        BOTConstants::N_words + i - 1, true /* reducing */);</span>
<span class="line-removed">470             } else {</span>
<span class="line-removed">471               more = false; // we are done</span>
<span class="line-removed">472               assert((end_index - 1) == right_index, &quot;Must be at the end.&quot;);</span>
<span class="line-removed">473             }</span>
<span class="line-removed">474             i++;</span>
<span class="line-removed">475             break;</span>
<span class="line-removed">476           }</span>
<span class="line-removed">477           i++;</span>
<span class="line-removed">478         }</span>
<span class="line-removed">479         // Fix the rest of the power blocks.</span>
<span class="line-removed">480         while (more &amp;&amp; (i &lt; BOTConstants::N_powers)) {</span>
<span class="line-removed">481           size_t back_by = BOTConstants::power_to_cards_back(i);</span>
<span class="line-removed">482           size_t right_index = suff_index + back_by - 1;</span>
<span class="line-removed">483           size_t left_index  = right_index - num_pref_cards + 1;</span>
<span class="line-removed">484           if (right_index &gt;= end_index - 1) { // last iteration</span>
<span class="line-removed">485             right_index = end_index - 1;</span>
<span class="line-removed">486             if (left_index &gt; right_index) {</span>
<span class="line-removed">487               break;</span>
<span class="line-removed">488             }</span>
<span class="line-removed">489             more  = false;</span>
<span class="line-removed">490           }</span>
<span class="line-removed">491           assert(left_index &lt;= right_index, &quot;Error&quot;);</span>
<span class="line-removed">492           _array-&gt;set_offset_array(left_index, right_index, BOTConstants::N_words + i - 1, true /* reducing */);</span>
<span class="line-removed">493           i++;</span>
<span class="line-removed">494         }</span>
<span class="line-removed">495       }</span>
<span class="line-removed">496     } // else no more cards to fix in suffix</span>
<span class="line-removed">497   } // else nothing needs to be done</span>
<span class="line-removed">498   // Verify that we did the right thing</span>
<span class="line-removed">499   verify_single_block(pref_addr, left_blk_size);</span>
<span class="line-removed">500   verify_single_block(suff_addr, blk_size - left_blk_size);</span>
<span class="line-removed">501 }</span>
<span class="line-removed">502 </span>
<span class="line-removed">503 </span>
<span class="line-removed">504 // Mark the BOT such that if [blk_start, blk_end) straddles a card</span>
<span class="line-removed">505 // boundary, the card following the first such boundary is marked</span>
<span class="line-removed">506 // with the appropriate offset.</span>
<span class="line-removed">507 // NOTE: this method does _not_ adjust _unallocated_block or</span>
<span class="line-removed">508 // any cards subsequent to the first one.</span>
<span class="line-removed">509 void</span>
<span class="line-removed">510 BlockOffsetArrayNonContigSpace::mark_block(HeapWord* blk_start,</span>
<span class="line-removed">511                                            HeapWord* blk_end, bool reducing) {</span>
<span class="line-removed">512   do_block_internal(blk_start, blk_end, Action_mark, reducing);</span>
<span class="line-removed">513 }</span>
<span class="line-removed">514 </span>
<span class="line-removed">515 HeapWord* BlockOffsetArrayNonContigSpace::block_start_unsafe(</span>
<span class="line-removed">516   const void* addr) const {</span>
<span class="line-removed">517   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);</span>
<span class="line-removed">518   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,</span>
<span class="line-removed">519          &quot;addr must be covered by this Array&quot;);</span>
<span class="line-removed">520   // Must read this exactly once because it can be modified by parallel</span>
<span class="line-removed">521   // allocation.</span>
<span class="line-removed">522   HeapWord* ub = _unallocated_block;</span>
<span class="line-removed">523   if (BlockOffsetArrayUseUnallocatedBlock &amp;&amp; addr &gt;= ub) {</span>
<span class="line-removed">524     assert(ub &lt; _end, &quot;tautology (see above)&quot;);</span>
<span class="line-removed">525     return ub;</span>
<span class="line-removed">526   }</span>
<span class="line-removed">527 </span>
<span class="line-removed">528   // Otherwise, find the block start using the table.</span>
<span class="line-removed">529   size_t index = _array-&gt;index_for(addr);</span>
<span class="line-removed">530   HeapWord* q = _array-&gt;address_for_index(index);</span>
<span class="line-removed">531 </span>
<span class="line-removed">532   uint offset = _array-&gt;offset_array(index);    // Extend u_char to uint.</span>
<span class="line-removed">533   while (offset &gt;= BOTConstants::N_words) {</span>
<span class="line-removed">534     // The excess of the offset from N_words indicates a power of Base</span>
<span class="line-removed">535     // to go back by.</span>
<span class="line-removed">536     size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);</span>
<span class="line-removed">537     q -= (BOTConstants::N_words * n_cards_back);</span>
<span class="line-removed">538     assert(q &gt;= _sp-&gt;bottom(),</span>
<span class="line-removed">539            &quot;q = &quot; PTR_FORMAT &quot; crossed below bottom = &quot; PTR_FORMAT,</span>
<span class="line-removed">540            p2i(q), p2i(_sp-&gt;bottom()));</span>
<span class="line-removed">541     assert(q &lt; _sp-&gt;end(),</span>
<span class="line-removed">542            &quot;q = &quot; PTR_FORMAT &quot; crossed above end = &quot; PTR_FORMAT,</span>
<span class="line-removed">543            p2i(q), p2i(_sp-&gt;end()));</span>
<span class="line-removed">544     index -= n_cards_back;</span>
<span class="line-removed">545     offset = _array-&gt;offset_array(index);</span>
<span class="line-removed">546   }</span>
<span class="line-removed">547   assert(offset &lt; BOTConstants::N_words, &quot;offset too large&quot;);</span>
<span class="line-removed">548   index--;</span>
<span class="line-removed">549   q -= offset;</span>
<span class="line-removed">550   assert(q &gt;= _sp-&gt;bottom(),</span>
<span class="line-removed">551          &quot;q = &quot; PTR_FORMAT &quot; crossed below bottom = &quot; PTR_FORMAT,</span>
<span class="line-removed">552          p2i(q), p2i(_sp-&gt;bottom()));</span>
<span class="line-removed">553   assert(q &lt; _sp-&gt;end(),</span>
<span class="line-removed">554          &quot;q = &quot; PTR_FORMAT &quot; crossed above end = &quot; PTR_FORMAT,</span>
<span class="line-removed">555          p2i(q), p2i(_sp-&gt;end()));</span>
<span class="line-removed">556   HeapWord* n = q;</span>
<span class="line-removed">557 </span>
<span class="line-removed">558   while (n &lt;= addr) {</span>
<span class="line-removed">559     debug_only(HeapWord* last = q);   // for debugging</span>
<span class="line-removed">560     q = n;</span>
<span class="line-removed">561     n += _sp-&gt;block_size(n);</span>
<span class="line-removed">562     assert(n &gt; q,</span>
<span class="line-removed">563            &quot;Looping at n = &quot; PTR_FORMAT &quot; with last = &quot; PTR_FORMAT &quot;,&quot;</span>
<span class="line-removed">564            &quot; while querying blk_start(&quot; PTR_FORMAT &quot;)&quot;</span>
<span class="line-removed">565            &quot; on _sp = [&quot; PTR_FORMAT &quot;,&quot; PTR_FORMAT &quot;)&quot;,</span>
<span class="line-removed">566            p2i(n), p2i(last), p2i(addr), p2i(_sp-&gt;bottom()), p2i(_sp-&gt;end()));</span>
<span class="line-removed">567   }</span>
<span class="line-removed">568   assert(q &lt;= addr,</span>
<span class="line-removed">569          &quot;wrong order for current (&quot; INTPTR_FORMAT &quot;)&quot; &quot; &lt;= arg (&quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="line-removed">570          p2i(q), p2i(addr));</span>
<span class="line-removed">571   assert(addr &lt;= n,</span>
<span class="line-removed">572          &quot;wrong order for arg (&quot; INTPTR_FORMAT &quot;) &lt;= next (&quot; INTPTR_FORMAT &quot;)&quot;,</span>
<span class="line-removed">573          p2i(addr), p2i(n));</span>
<span class="line-removed">574   return q;</span>
<span class="line-removed">575 }</span>
<span class="line-removed">576 </span>
<span class="line-removed">577 HeapWord* BlockOffsetArrayNonContigSpace::block_start_careful(</span>
<span class="line-removed">578   const void* addr) const {</span>
<span class="line-removed">579   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);</span>
<span class="line-removed">580 </span>
<span class="line-removed">581   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,</span>
<span class="line-removed">582          &quot;addr must be covered by this Array&quot;);</span>
<span class="line-removed">583   // Must read this exactly once because it can be modified by parallel</span>
<span class="line-removed">584   // allocation.</span>
<span class="line-removed">585   HeapWord* ub = _unallocated_block;</span>
<span class="line-removed">586   if (BlockOffsetArrayUseUnallocatedBlock &amp;&amp; addr &gt;= ub) {</span>
<span class="line-removed">587     assert(ub &lt; _end, &quot;tautology (see above)&quot;);</span>
<span class="line-removed">588     return ub;</span>
<span class="line-removed">589   }</span>
<span class="line-removed">590 </span>
<span class="line-removed">591   // Otherwise, find the block start using the table, but taking</span>
<span class="line-removed">592   // care (cf block_start_unsafe() above) not to parse any objects/blocks</span>
<span class="line-removed">593   // on the cards themselves.</span>
<span class="line-removed">594   size_t index = _array-&gt;index_for(addr);</span>
<span class="line-removed">595   assert(_array-&gt;address_for_index(index) == addr,</span>
<span class="line-removed">596          &quot;arg should be start of card&quot;);</span>
<span class="line-removed">597 </span>
<span class="line-removed">598   HeapWord* q = (HeapWord*)addr;</span>
<span class="line-removed">599   uint offset;</span>
<span class="line-removed">600   do {</span>
<span class="line-removed">601     offset = _array-&gt;offset_array(index);</span>
<span class="line-removed">602     if (offset &lt; BOTConstants::N_words) {</span>
<span class="line-removed">603       q -= offset;</span>
<span class="line-removed">604     } else {</span>
<span class="line-removed">605       size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);</span>
<span class="line-removed">606       q -= (n_cards_back * BOTConstants::N_words);</span>
<span class="line-removed">607       index -= n_cards_back;</span>
<span class="line-removed">608     }</span>
<span class="line-removed">609   } while (offset &gt;= BOTConstants::N_words);</span>
<span class="line-removed">610   assert(q &lt;= addr, &quot;block start should be to left of arg&quot;);</span>
<span class="line-removed">611   return q;</span>
<span class="line-removed">612 }</span>
<span class="line-removed">613 </span>
<span class="line-removed">614 #ifndef PRODUCT</span>
<span class="line-removed">615 // Verification &amp; debugging - ensure that the offset table reflects the fact</span>
<span class="line-removed">616 // that the block [blk_start, blk_end) or [blk, blk + size) is a</span>
<span class="line-removed">617 // single block of storage. NOTE: can&#39;t const this because of</span>
<span class="line-removed">618 // call to non-const do_block_internal() below.</span>
<span class="line-removed">619 void BlockOffsetArrayNonContigSpace::verify_single_block(</span>
<span class="line-removed">620   HeapWord* blk_start, HeapWord* blk_end) {</span>
<span class="line-removed">621   if (VerifyBlockOffsetArray) {</span>
<span class="line-removed">622     do_block_internal(blk_start, blk_end, Action_check);</span>
<span class="line-removed">623   }</span>
<span class="line-removed">624 }</span>
<span class="line-removed">625 </span>
<span class="line-removed">626 void BlockOffsetArrayNonContigSpace::verify_single_block(</span>
<span class="line-removed">627   HeapWord* blk, size_t size) {</span>
<span class="line-removed">628   verify_single_block(blk, blk + size);</span>
<span class="line-removed">629 }</span>
<span class="line-removed">630 </span>
<span class="line-removed">631 // Verify that the given block is before _unallocated_block</span>
<span class="line-removed">632 void BlockOffsetArrayNonContigSpace::verify_not_unallocated(</span>
<span class="line-removed">633   HeapWord* blk_start, HeapWord* blk_end) const {</span>
<span class="line-removed">634   if (BlockOffsetArrayUseUnallocatedBlock) {</span>
<span class="line-removed">635     assert(blk_start &lt; blk_end, &quot;Block inconsistency?&quot;);</span>
<span class="line-removed">636     assert(blk_end &lt;= _unallocated_block, &quot;_unallocated_block problem&quot;);</span>
<span class="line-removed">637   }</span>
<span class="line-removed">638 }</span>
<span class="line-removed">639 </span>
<span class="line-removed">640 void BlockOffsetArrayNonContigSpace::verify_not_unallocated(</span>
<span class="line-removed">641   HeapWord* blk, size_t size) const {</span>
<span class="line-removed">642   verify_not_unallocated(blk, blk + size);</span>
<span class="line-removed">643 }</span>
<span class="line-removed">644 #endif // PRODUCT</span>
<span class="line-removed">645 </span>
<span class="line-removed">646 size_t BlockOffsetArrayNonContigSpace::last_active_index() const {</span>
<span class="line-removed">647   if (_unallocated_block == _bottom) {</span>
<span class="line-removed">648     return 0;</span>
<span class="line-removed">649   } else {</span>
<span class="line-removed">650     return _array-&gt;index_for(_unallocated_block - 1);</span>
<span class="line-removed">651   }</span>
<span class="line-removed">652 }</span>
<span class="line-removed">653 </span>
654 //////////////////////////////////////////////////////////////////////
655 // BlockOffsetArrayContigSpace
656 //////////////////////////////////////////////////////////////////////
657 
658 HeapWord* BlockOffsetArrayContigSpace::block_start_unsafe(const void* addr) const {
659   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);
660 
661   // Otherwise, find the block start using the table.
662   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,
663          &quot;addr must be covered by this Array&quot;);
664   size_t index = _array-&gt;index_for(addr);
665   // We must make sure that the offset table entry we use is valid.  If
666   // &quot;addr&quot; is past the end, start at the last known one and go forward.
667   index = MIN2(index, _next_offset_index-1);
668   HeapWord* q = _array-&gt;address_for_index(index);
669 
670   uint offset = _array-&gt;offset_array(index);    // Extend u_char to uint.
671   while (offset &gt; BOTConstants::N_words) {
672     // The excess of the offset from N_words indicates a power of Base
673     // to go back by.
</pre>
<hr />
<pre>
701 //              _next_offset_threshold
702 //              |   _next_offset_index
703 //              v   v
704 //      +-------+-------+-------+-------+-------+
705 //      | i-1   |   i   | i+1   | i+2   | i+3   |
706 //      +-------+-------+-------+-------+-------+
707 //       ( ^    ]
708 //         block-start
709 //
710 
711 void BlockOffsetArrayContigSpace::alloc_block_work(HeapWord* blk_start,
712                                         HeapWord* blk_end) {
713   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
714          &quot;phantom block&quot;);
715   assert(blk_end &gt; _next_offset_threshold,
716          &quot;should be past threshold&quot;);
717   assert(blk_start &lt;= _next_offset_threshold,
718          &quot;blk_start should be at or before threshold&quot;);
719   assert(pointer_delta(_next_offset_threshold, blk_start) &lt;= BOTConstants::N_words,
720          &quot;offset should be &lt;= BlockOffsetSharedArray::N&quot;);
<span class="line-modified">721   assert(Universe::heap()-&gt;is_in_reserved(blk_start),</span>
<span class="line-modified">722          &quot;reference must be into the heap&quot;);</span>
<span class="line-modified">723   assert(Universe::heap()-&gt;is_in_reserved(blk_end-1),</span>
<span class="line-modified">724          &quot;limit must be within the heap&quot;);</span>
725   assert(_next_offset_threshold ==
726          _array-&gt;_reserved.start() + _next_offset_index*BOTConstants::N_words,
727          &quot;index must agree with threshold&quot;);
728 
729   debug_only(size_t orig_next_offset_index = _next_offset_index;)
730 
731   // Mark the card that holds the offset into the block.  Note
732   // that _next_offset_index and _next_offset_threshold are not
733   // updated until the end of this method.
734   _array-&gt;set_offset_array(_next_offset_index,
735                            _next_offset_threshold,
736                            blk_start);
737 
738   // We need to now mark the subsequent cards that this blk spans.
739 
740   // Index of card on which blk ends.
741   size_t end_index   = _array-&gt;index_for(blk_end - 1);
742 
743   // Are there more cards left to be updated?
744   if (_next_offset_index + 1 &lt;= end_index) {
</pre>
<hr />
<pre>
758 
759 #ifdef ASSERT
760   // The offset can be 0 if the block starts on a boundary.  That
761   // is checked by an assertion above.
762   size_t start_index = _array-&gt;index_for(blk_start);
763   HeapWord* boundary    = _array-&gt;address_for_index(start_index);
764   assert((_array-&gt;offset_array(orig_next_offset_index) == 0 &amp;&amp;
765           blk_start == boundary) ||
766           (_array-&gt;offset_array(orig_next_offset_index) &gt; 0 &amp;&amp;
767          _array-&gt;offset_array(orig_next_offset_index) &lt;= BOTConstants::N_words),
768          &quot;offset array should have been set&quot;);
769   for (size_t j = orig_next_offset_index + 1; j &lt;= end_index; j++) {
770     assert(_array-&gt;offset_array(j) &gt; 0 &amp;&amp;
771            _array-&gt;offset_array(j) &lt;= (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
772            &quot;offset array should have been set&quot;);
773   }
774 #endif
775 }
776 
777 HeapWord* BlockOffsetArrayContigSpace::initialize_threshold() {
<span class="line-removed">778   assert(!Universe::heap()-&gt;is_in_reserved(_array-&gt;_offset_array),</span>
<span class="line-removed">779          &quot;just checking&quot;);</span>
780   _next_offset_index = _array-&gt;index_for(_bottom);
781   _next_offset_index++;
782   _next_offset_threshold =
783     _array-&gt;address_for_index(_next_offset_index);
784   return _next_offset_threshold;
785 }
786 
787 void BlockOffsetArrayContigSpace::zero_bottom_entry() {
<span class="line-removed">788   assert(!Universe::heap()-&gt;is_in_reserved(_array-&gt;_offset_array),</span>
<span class="line-removed">789          &quot;just checking&quot;);</span>
790   size_t bottom_index = _array-&gt;index_for(_bottom);
791   _array-&gt;set_offset_array(bottom_index, 0);
792 }
793 
794 size_t BlockOffsetArrayContigSpace::last_active_index() const {
795   return _next_offset_index == 0 ? 0 : _next_offset_index - 1;
796 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
227     last_entry = entry;  // remember for monotonicity test
228   }
229 }
230 
231 
232 void
233 BlockOffsetArray::alloc_block(HeapWord* blk_start, HeapWord* blk_end) {
234   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
235          &quot;phantom block&quot;);
236   single_block(blk_start, blk_end);
237 }
238 
239 // Action_mark - update the BOT for the block [blk_start, blk_end).
240 //               Current typical use is for splitting a block.
241 // Action_single - udpate the BOT for an allocation.
242 // Action_verify - BOT verification.
243 void
244 BlockOffsetArray::do_block_internal(HeapWord* blk_start,
245                                     HeapWord* blk_end,
246                                     Action action, bool reducing) {
<span class="line-modified">247   assert(_sp-&gt;is_in_reserved(blk_start),</span>
<span class="line-modified">248          &quot;reference must be into the space&quot;);</span>
<span class="line-modified">249   assert(_sp-&gt;is_in_reserved(blk_end-1),</span>
<span class="line-modified">250          &quot;limit must be within the space&quot;);</span>
251   // This is optimized to make the test fast, assuming we only rarely
252   // cross boundaries.
253   uintptr_t end_ui = (uintptr_t)(blk_end - 1);
254   uintptr_t start_ui = (uintptr_t)blk_start;
255   // Calculate the last card boundary preceding end of blk
256   intptr_t boundary_before_end = (intptr_t)end_ui;
257   clear_bits(boundary_before_end, right_n_bits((int)BOTConstants::LogN));
258   if (start_ui &lt;= (uintptr_t)boundary_before_end) {
259     // blk starts at or crosses a boundary
260     // Calculate index of card on which blk begins
261     size_t    start_index = _array-&gt;index_for(blk_start);
262     // Index of card on which blk ends
263     size_t    end_index   = _array-&gt;index_for(blk_end - 1);
264     // Start address of card on which blk begins
265     HeapWord* boundary    = _array-&gt;address_for_index(start_index);
266     assert(boundary &lt;= blk_start, &quot;blk should start at or after boundary&quot;);
267     if (blk_start != boundary) {
268       // blk starts strictly after boundary
269       // adjust card boundary and start_index forward to next card
270       boundary += BOTConstants::N_words;
</pre>
<hr />
<pre>
334     HeapWord* p = _array-&gt;address_for_index(next_index) + 1;
335     if (p &gt;= _end) {
336       // That&#39;s all of the allocated block table.
337       return;
338     }
339     // block_start() asserts that start &lt;= p.
340     HeapWord* start = block_start(p);
341     // First check if the start is an allocated block and only
342     // then if it is a valid object.
343     oop o = oop(start);
344     assert(!Universe::is_fully_initialized() ||
345            _sp-&gt;is_free_block(start) ||
346            oopDesc::is_oop_or_null(o), &quot;Bad object was found&quot;);
347     next_index++;
348     last_p = p;
349     last_start = start;
350     last_o = o;
351   }
352 }
353 












































































































































































































































































































354 //////////////////////////////////////////////////////////////////////
355 // BlockOffsetArrayContigSpace
356 //////////////////////////////////////////////////////////////////////
357 
358 HeapWord* BlockOffsetArrayContigSpace::block_start_unsafe(const void* addr) const {
359   assert(_array-&gt;offset_array(0) == 0, &quot;objects can&#39;t cross covered areas&quot;);
360 
361   // Otherwise, find the block start using the table.
362   assert(_bottom &lt;= addr &amp;&amp; addr &lt; _end,
363          &quot;addr must be covered by this Array&quot;);
364   size_t index = _array-&gt;index_for(addr);
365   // We must make sure that the offset table entry we use is valid.  If
366   // &quot;addr&quot; is past the end, start at the last known one and go forward.
367   index = MIN2(index, _next_offset_index-1);
368   HeapWord* q = _array-&gt;address_for_index(index);
369 
370   uint offset = _array-&gt;offset_array(index);    // Extend u_char to uint.
371   while (offset &gt; BOTConstants::N_words) {
372     // The excess of the offset from N_words indicates a power of Base
373     // to go back by.
</pre>
<hr />
<pre>
401 //              _next_offset_threshold
402 //              |   _next_offset_index
403 //              v   v
404 //      +-------+-------+-------+-------+-------+
405 //      | i-1   |   i   | i+1   | i+2   | i+3   |
406 //      +-------+-------+-------+-------+-------+
407 //       ( ^    ]
408 //         block-start
409 //
410 
411 void BlockOffsetArrayContigSpace::alloc_block_work(HeapWord* blk_start,
412                                         HeapWord* blk_end) {
413   assert(blk_start != NULL &amp;&amp; blk_end &gt; blk_start,
414          &quot;phantom block&quot;);
415   assert(blk_end &gt; _next_offset_threshold,
416          &quot;should be past threshold&quot;);
417   assert(blk_start &lt;= _next_offset_threshold,
418          &quot;blk_start should be at or before threshold&quot;);
419   assert(pointer_delta(_next_offset_threshold, blk_start) &lt;= BOTConstants::N_words,
420          &quot;offset should be &lt;= BlockOffsetSharedArray::N&quot;);
<span class="line-modified">421   assert(_sp-&gt;is_in_reserved(blk_start),</span>
<span class="line-modified">422          &quot;reference must be into the space&quot;);</span>
<span class="line-modified">423   assert(_sp-&gt;is_in_reserved(blk_end-1),</span>
<span class="line-modified">424          &quot;limit must be within the space&quot;);</span>
425   assert(_next_offset_threshold ==
426          _array-&gt;_reserved.start() + _next_offset_index*BOTConstants::N_words,
427          &quot;index must agree with threshold&quot;);
428 
429   debug_only(size_t orig_next_offset_index = _next_offset_index;)
430 
431   // Mark the card that holds the offset into the block.  Note
432   // that _next_offset_index and _next_offset_threshold are not
433   // updated until the end of this method.
434   _array-&gt;set_offset_array(_next_offset_index,
435                            _next_offset_threshold,
436                            blk_start);
437 
438   // We need to now mark the subsequent cards that this blk spans.
439 
440   // Index of card on which blk ends.
441   size_t end_index   = _array-&gt;index_for(blk_end - 1);
442 
443   // Are there more cards left to be updated?
444   if (_next_offset_index + 1 &lt;= end_index) {
</pre>
<hr />
<pre>
458 
459 #ifdef ASSERT
460   // The offset can be 0 if the block starts on a boundary.  That
461   // is checked by an assertion above.
462   size_t start_index = _array-&gt;index_for(blk_start);
463   HeapWord* boundary    = _array-&gt;address_for_index(start_index);
464   assert((_array-&gt;offset_array(orig_next_offset_index) == 0 &amp;&amp;
465           blk_start == boundary) ||
466           (_array-&gt;offset_array(orig_next_offset_index) &gt; 0 &amp;&amp;
467          _array-&gt;offset_array(orig_next_offset_index) &lt;= BOTConstants::N_words),
468          &quot;offset array should have been set&quot;);
469   for (size_t j = orig_next_offset_index + 1; j &lt;= end_index; j++) {
470     assert(_array-&gt;offset_array(j) &gt; 0 &amp;&amp;
471            _array-&gt;offset_array(j) &lt;= (u_char) (BOTConstants::N_words+BOTConstants::N_powers-1),
472            &quot;offset array should have been set&quot;);
473   }
474 #endif
475 }
476 
477 HeapWord* BlockOffsetArrayContigSpace::initialize_threshold() {


478   _next_offset_index = _array-&gt;index_for(_bottom);
479   _next_offset_index++;
480   _next_offset_threshold =
481     _array-&gt;address_for_index(_next_offset_index);
482   return _next_offset_threshold;
483 }
484 
485 void BlockOffsetArrayContigSpace::zero_bottom_entry() {


486   size_t bottom_index = _array-&gt;index_for(_bottom);
487   _array-&gt;set_offset_array(bottom_index, 0);
488 }
489 
490 size_t BlockOffsetArrayContigSpace::last_active_index() const {
491   return _next_offset_index == 0 ? 0 : _next_offset_index - 1;
492 }
</pre>
</td>
</tr>
</table>
<center><a href="barrierSetNMethod.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="blockOffsetTable.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
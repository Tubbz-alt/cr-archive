<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMark.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMark.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMark.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 #define SHARE_GC_Z_ZMARK_HPP
 26 
 27 #include &quot;gc/z/zMarkStack.hpp&quot;
 28 #include &quot;gc/z/zMarkStackAllocator.hpp&quot;
 29 #include &quot;gc/z/zMarkTerminate.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 class Thread;
 34 class ZMarkCache;
 35 class ZPageTable;
 36 class ZWorkers;
 37 
 38 class ZMark {
 39   friend class ZMarkRootsTask;
 40   friend class ZMarkTask;
 41   friend class ZMarkTryCompleteTask;
 42 
 43 private:
 44   ZWorkers* const     _workers;
<span class="line-modified"> 45   ZPageTable* const   _pagetable;</span>
 46   ZMarkStackAllocator _allocator;
 47   ZMarkStripeSet      _stripes;
 48   ZMarkTerminate      _terminate;
 49   volatile bool       _work_terminateflush;
 50   volatile size_t     _work_nproactiveflush;
 51   volatile size_t     _work_nterminateflush;
 52   size_t              _nproactiveflush;
 53   size_t              _nterminateflush;
 54   size_t              _ntrycomplete;
 55   size_t              _ncontinue;
 56   uint                _nworkers;
 57 
 58   size_t calculate_nstripes(uint nworkers) const;
 59   void prepare_mark();
 60 
 61   bool is_array(uintptr_t addr) const;
 62   void push_partial_array(uintptr_t addr, size_t size, bool finalizable);
 63   void follow_small_array(uintptr_t addr, size_t size, bool finalizable);
 64   void follow_large_array(uintptr_t addr, size_t size, bool finalizable);
 65   void follow_array(uintptr_t addr, size_t size, bool finalizable);
</pre>
<hr />
<pre>
 84   bool try_flush(volatile size_t* nflush);
 85   bool try_terminate();
 86   bool try_complete();
 87   bool try_end();
 88 
 89   void prepare_work();
 90   void finish_work();
 91 
 92   void work_without_timeout(ZMarkCache* cache,
 93                             ZMarkStripe* stripe,
 94                             ZMarkThreadLocalStacks* stacks);
 95   void work_with_timeout(ZMarkCache* cache,
 96                          ZMarkStripe* stripe,
 97                          ZMarkThreadLocalStacks* stacks,
 98                          uint64_t timeout_in_millis);
 99   void work(uint64_t timeout_in_millis);
100 
101   void verify_all_stacks_empty() const;
102 
103 public:
<span class="line-modified">104   ZMark(ZWorkers* workers, ZPageTable* pagetable);</span>
105 
106   bool is_initialized() const;
107 
<span class="line-modified">108   template &lt;bool finalizable, bool publish&gt; void mark_object(uintptr_t addr);</span>
109 
110   void start();
111   void mark(bool initial);
112   bool end();
113 
114   void flush_and_free();
115   bool flush_and_free(Thread* thread);
116 };
117 
118 #endif // SHARE_GC_Z_ZMARK_HPP
</pre>
</td>
<td>
<hr />
<pre>
 25 #define SHARE_GC_Z_ZMARK_HPP
 26 
 27 #include &quot;gc/z/zMarkStack.hpp&quot;
 28 #include &quot;gc/z/zMarkStackAllocator.hpp&quot;
 29 #include &quot;gc/z/zMarkTerminate.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 class Thread;
 34 class ZMarkCache;
 35 class ZPageTable;
 36 class ZWorkers;
 37 
 38 class ZMark {
 39   friend class ZMarkRootsTask;
 40   friend class ZMarkTask;
 41   friend class ZMarkTryCompleteTask;
 42 
 43 private:
 44   ZWorkers* const     _workers;
<span class="line-modified"> 45   ZPageTable* const   _page_table;</span>
 46   ZMarkStackAllocator _allocator;
 47   ZMarkStripeSet      _stripes;
 48   ZMarkTerminate      _terminate;
 49   volatile bool       _work_terminateflush;
 50   volatile size_t     _work_nproactiveflush;
 51   volatile size_t     _work_nterminateflush;
 52   size_t              _nproactiveflush;
 53   size_t              _nterminateflush;
 54   size_t              _ntrycomplete;
 55   size_t              _ncontinue;
 56   uint                _nworkers;
 57 
 58   size_t calculate_nstripes(uint nworkers) const;
 59   void prepare_mark();
 60 
 61   bool is_array(uintptr_t addr) const;
 62   void push_partial_array(uintptr_t addr, size_t size, bool finalizable);
 63   void follow_small_array(uintptr_t addr, size_t size, bool finalizable);
 64   void follow_large_array(uintptr_t addr, size_t size, bool finalizable);
 65   void follow_array(uintptr_t addr, size_t size, bool finalizable);
</pre>
<hr />
<pre>
 84   bool try_flush(volatile size_t* nflush);
 85   bool try_terminate();
 86   bool try_complete();
 87   bool try_end();
 88 
 89   void prepare_work();
 90   void finish_work();
 91 
 92   void work_without_timeout(ZMarkCache* cache,
 93                             ZMarkStripe* stripe,
 94                             ZMarkThreadLocalStacks* stacks);
 95   void work_with_timeout(ZMarkCache* cache,
 96                          ZMarkStripe* stripe,
 97                          ZMarkThreadLocalStacks* stacks,
 98                          uint64_t timeout_in_millis);
 99   void work(uint64_t timeout_in_millis);
100 
101   void verify_all_stacks_empty() const;
102 
103 public:
<span class="line-modified">104   ZMark(ZWorkers* workers, ZPageTable* page_table);</span>
105 
106   bool is_initialized() const;
107 
<span class="line-modified">108   template &lt;bool follow, bool finalizable, bool publish&gt; void mark_object(uintptr_t addr);</span>
109 
110   void start();
111   void mark(bool initial);
112   bool end();
113 
114   void flush_and_free();
115   bool flush_and_free(Thread* thread);
116 };
117 
118 #endif // SHARE_GC_Z_ZMARK_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zMark.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMark.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
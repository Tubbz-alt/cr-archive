<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zValue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZVALUE_HPP
 25 #define SHARE_GC_Z_ZVALUE_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 28 #include &quot;gc/z/zCPU.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;gc/z/zGlobals.hpp&quot;</span>
<span class="line-modified"> 30 #include &quot;gc/z/zNUMA.hpp&quot;</span>
<span class="line-modified"> 31 #include &quot;gc/z/zThread.hpp&quot;</span>
<span class="line-modified"> 32 #include &quot;gc/z/zUtils.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;utilities/align.hpp&quot;</span>
 34 
 35 template &lt;typename S&gt;
 36 class ZValueStorage : public AllStatic {
 37 private:
 38   static uintptr_t _top;
 39   static uintptr_t _end;
 40 
 41 public:
 42   static const size_t offset = 4 * K;
 43 
<a name="3" id="anc3"></a><span class="line-modified"> 44   static uintptr_t alloc(size_t size) {</span>
<span class="line-removed"> 45     guarantee(size &lt;= offset, &quot;Allocation too large&quot;);</span>
<span class="line-removed"> 46 </span>
<span class="line-removed"> 47     // Allocate entry in existing memory block</span>
<span class="line-removed"> 48     const uintptr_t addr = align_up(_top, S::alignment());</span>
<span class="line-removed"> 49     _top = addr + size;</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51     if (_top &lt; _end) {</span>
<span class="line-removed"> 52       // Success</span>
<span class="line-removed"> 53       return addr;</span>
<span class="line-removed"> 54     }</span>
<span class="line-removed"> 55 </span>
<span class="line-removed"> 56     // Allocate new block of memory</span>
<span class="line-removed"> 57     const size_t block_alignment = offset;</span>
<span class="line-removed"> 58     const size_t block_size = offset * S::count();</span>
<span class="line-removed"> 59     _top = ZUtils::alloc_aligned(block_alignment, block_size);</span>
<span class="line-removed"> 60     _end = _top + offset;</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62     // Retry allocation</span>
<span class="line-removed"> 63     return alloc(size);</span>
<span class="line-removed"> 64   }</span>
 65 };
 66 
<a name="4" id="anc4"></a><span class="line-removed"> 67 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_end = 0;</span>
<span class="line-removed"> 68 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_top = 0;</span>
<span class="line-removed"> 69 </span>
 70 class ZContendedStorage : public ZValueStorage&lt;ZContendedStorage&gt; {
 71 public:
<a name="5" id="anc5"></a><span class="line-modified"> 72   static size_t alignment() {</span>
<span class="line-modified"> 73     return ZCacheLineSize;</span>
<span class="line-modified"> 74   }</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76   static uint32_t count() {</span>
<span class="line-removed"> 77     return 1;</span>
<span class="line-removed"> 78   }</span>
<span class="line-removed"> 79 </span>
<span class="line-removed"> 80   static uint32_t id() {</span>
<span class="line-removed"> 81     return 0;</span>
<span class="line-removed"> 82   }</span>
 83 };
 84 
 85 class ZPerCPUStorage : public ZValueStorage&lt;ZPerCPUStorage&gt; {
 86 public:
<a name="6" id="anc6"></a><span class="line-modified"> 87   static size_t alignment() {</span>
<span class="line-modified"> 88     return sizeof(uintptr_t);</span>
<span class="line-modified"> 89   }</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91   static uint32_t count() {</span>
<span class="line-removed"> 92     return ZCPU::count();</span>
<span class="line-removed"> 93   }</span>
<span class="line-removed"> 94 </span>
<span class="line-removed"> 95   static uint32_t id() {</span>
<span class="line-removed"> 96     return ZCPU::id();</span>
<span class="line-removed"> 97   }</span>
 98 };
 99 
100 class ZPerNUMAStorage : public ZValueStorage&lt;ZPerNUMAStorage&gt; {
101 public:
<a name="7" id="anc7"></a><span class="line-modified">102   static size_t alignment() {</span>
<span class="line-modified">103     return sizeof(uintptr_t);</span>
<span class="line-modified">104   }</span>
<span class="line-removed">105 </span>
<span class="line-removed">106   static uint32_t count() {</span>
<span class="line-removed">107     return ZNUMA::count();</span>
<span class="line-removed">108   }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110   static uint32_t id() {</span>
<span class="line-removed">111     return ZNUMA::id();</span>
<span class="line-removed">112   }</span>
113 };
114 
115 class ZPerWorkerStorage : public ZValueStorage&lt;ZPerWorkerStorage&gt; {
116 public:
<a name="8" id="anc8"></a><span class="line-modified">117   static size_t alignment() {</span>
<span class="line-modified">118     return sizeof(uintptr_t);</span>
<span class="line-modified">119   }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121   static uint32_t count() {</span>
<span class="line-removed">122     return MAX2(ParallelGCThreads, ConcGCThreads);</span>
<span class="line-removed">123   }</span>
<span class="line-removed">124 </span>
<span class="line-removed">125   static uint32_t id() {</span>
<span class="line-removed">126     return ZThread::worker_id();</span>
<span class="line-removed">127   }</span>
128 };
129 
<a name="9" id="anc9"></a><span class="line-modified">130 template &lt;typename S, typename T&gt;</span>
<span class="line-modified">131 class ZValueIterator;</span>

132 
133 template &lt;typename S, typename T&gt;
134 class ZValue : public CHeapObj&lt;mtGC&gt; {
135 private:
136   const uintptr_t _addr;
137 
<a name="10" id="anc10"></a><span class="line-modified">138   uintptr_t value_addr(uint32_t value_id) const {</span>
<span class="line-removed">139     return _addr + (value_id * S::offset);</span>
<span class="line-removed">140   }</span>
141 
142 public:
<a name="11" id="anc11"></a><span class="line-modified">143   ZValue() :</span>
<span class="line-modified">144       _addr(S::alloc(sizeof(T))) {</span>
<span class="line-modified">145     // Initialize all instances</span>
<span class="line-modified">146     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-modified">147     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-modified">148       ::new (addr) T;</span>
<span class="line-modified">149     }</span>
<span class="line-modified">150   }</span>
<span class="line-modified">151 </span>
<span class="line-modified">152   ZValue(const T&amp; value) :</span>
<span class="line-modified">153       _addr(S::alloc(sizeof(T))) {</span>
<span class="line-removed">154     // Initialize all instances</span>
<span class="line-removed">155     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-removed">156     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-removed">157       ::new (addr) T(value);</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159   }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161   // Not implemented</span>
<span class="line-removed">162   ZValue(const ZValue&lt;S, T&gt;&amp; value);</span>
<span class="line-removed">163   ZValue&lt;S, T&gt;&amp; operator=(const ZValue&lt;S, T&gt;&amp; value);</span>
<span class="line-removed">164 </span>
<span class="line-removed">165   const T* addr(uint32_t value_id = S::id()) const {</span>
<span class="line-removed">166     return reinterpret_cast&lt;const T*&gt;(value_addr(value_id));</span>
<span class="line-removed">167   }</span>
<span class="line-removed">168 </span>
<span class="line-removed">169   T* addr(uint32_t value_id = S::id()) {</span>
<span class="line-removed">170     return reinterpret_cast&lt;T*&gt;(value_addr(value_id));</span>
<span class="line-removed">171   }</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   const T&amp; get(uint32_t value_id = S::id()) const {</span>
<span class="line-removed">174     return *addr(value_id);</span>
<span class="line-removed">175   }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   T&amp; get(uint32_t value_id = S::id()) {</span>
<span class="line-removed">178     return *addr(value_id);</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   void set(const T&amp; value, uint32_t value_id = S::id()) {</span>
<span class="line-removed">182     get(value_id) = value;</span>
<span class="line-removed">183   }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   void set_all(const T&amp; value) {</span>
<span class="line-removed">186     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-removed">187     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-removed">188       *addr = value;</span>
<span class="line-removed">189     }</span>
<span class="line-removed">190   }</span>
191 };
192 
193 template &lt;typename T&gt;
194 class ZContended : public ZValue&lt;ZContendedStorage, T&gt; {
195 public:
<a name="12" id="anc12"></a><span class="line-modified">196   ZContended() :</span>
<span class="line-modified">197       ZValue&lt;ZContendedStorage, T&gt;() {}</span>
<span class="line-removed">198 </span>
<span class="line-removed">199   ZContended(const T&amp; value) :</span>
<span class="line-removed">200       ZValue&lt;ZContendedStorage, T&gt;(value) {}</span>
<span class="line-removed">201 </span>
<span class="line-removed">202   using ZValue&lt;ZContendedStorage, T&gt;::operator=;</span>
203 };
204 
205 template &lt;typename T&gt;
206 class ZPerCPU : public ZValue&lt;ZPerCPUStorage, T&gt; {
207 public:
<a name="13" id="anc13"></a><span class="line-modified">208   ZPerCPU() :</span>
<span class="line-modified">209       ZValue&lt;ZPerCPUStorage, T&gt;() {}</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   ZPerCPU(const T&amp; value) :</span>
<span class="line-removed">212       ZValue&lt;ZPerCPUStorage, T&gt;(value) {}</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   using ZValue&lt;ZPerCPUStorage, T&gt;::operator=;</span>
215 };
216 
217 template &lt;typename T&gt;
218 class ZPerNUMA : public ZValue&lt;ZPerNUMAStorage, T&gt; {
219 public:
<a name="14" id="anc14"></a><span class="line-modified">220   ZPerNUMA() :</span>
<span class="line-modified">221       ZValue&lt;ZPerNUMAStorage, T&gt;() {}</span>
<span class="line-removed">222 </span>
<span class="line-removed">223   ZPerNUMA(const T&amp; value) :</span>
<span class="line-removed">224       ZValue&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
<span class="line-removed">225 </span>
<span class="line-removed">226   using ZValue&lt;ZPerNUMAStorage, T&gt;::operator=;</span>
227 };
228 
229 template &lt;typename T&gt;
230 class ZPerWorker : public ZValue&lt;ZPerWorkerStorage, T&gt; {
231 public:
<a name="15" id="anc15"></a><span class="line-modified">232   ZPerWorker() :</span>
<span class="line-modified">233       ZValue&lt;ZPerWorkerStorage, T&gt;() {}</span>
<span class="line-removed">234 </span>
<span class="line-removed">235   ZPerWorker(const T&amp; value) :</span>
<span class="line-removed">236       ZValue&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
<span class="line-removed">237 </span>
<span class="line-removed">238   using ZValue&lt;ZPerWorkerStorage, T&gt;::operator=;</span>
239 };
240 
<a name="16" id="anc16"></a>



241 template &lt;typename S, typename T&gt;
242 class ZValueIterator {
243 private:
244   ZValue&lt;S, T&gt;* const _value;
245   uint32_t            _value_id;
246 
247 public:
<a name="17" id="anc17"></a><span class="line-modified">248   ZValueIterator(ZValue&lt;S, T&gt;* value) :</span>
<span class="line-modified">249       _value(value),</span>
<span class="line-modified">250       _value_id(0) {}</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   bool next(T** value) {</span>
<span class="line-removed">253     if (_value_id &lt; S::count()) {</span>
<span class="line-removed">254       *value = _value-&gt;addr(_value_id++);</span>
<span class="line-removed">255       return true;</span>
<span class="line-removed">256     }</span>
<span class="line-removed">257     return false;</span>
<span class="line-removed">258   }</span>
259 };
260 
261 template &lt;typename T&gt;
262 class ZPerCPUIterator : public ZValueIterator&lt;ZPerCPUStorage, T&gt; {
263 public:
<a name="18" id="anc18"></a><span class="line-modified">264   ZPerCPUIterator(ZPerCPU&lt;T&gt;* value) :</span>
<span class="line-removed">265       ZValueIterator&lt;ZPerCPUStorage, T&gt;(value) {}</span>
266 };
267 
268 template &lt;typename T&gt;
269 class ZPerNUMAIterator : public ZValueIterator&lt;ZPerNUMAStorage, T&gt; {
270 public:
<a name="19" id="anc19"></a><span class="line-modified">271   ZPerNUMAIterator(ZPerNUMA&lt;T&gt;* value) :</span>
<span class="line-removed">272       ZValueIterator&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
273 };
274 
275 template &lt;typename T&gt;
276 class ZPerWorkerIterator : public ZValueIterator&lt;ZPerWorkerStorage, T&gt; {
277 public:
<a name="20" id="anc20"></a><span class="line-modified">278   ZPerWorkerIterator(ZPerWorker&lt;T&gt;* value) :</span>
<span class="line-removed">279       ZValueIterator&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
280 };
281 
282 template &lt;typename S, typename T&gt;
283 class ZValueConstIterator {
284 private:
285   const ZValue&lt;S, T&gt;* const _value;
286   uint32_t                  _value_id;
287 
288 public:
<a name="21" id="anc21"></a><span class="line-modified">289   ZValueConstIterator(const ZValue&lt;S, T&gt;* value) :</span>
<span class="line-modified">290       _value(value),</span>
<span class="line-modified">291       _value_id(0) {}</span>
<span class="line-removed">292 </span>
<span class="line-removed">293   bool next(const T** value) {</span>
<span class="line-removed">294     if (_value_id &lt; S::count()) {</span>
<span class="line-removed">295       *value = _value-&gt;addr(_value_id++);</span>
<span class="line-removed">296       return true;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298     return false;</span>
<span class="line-removed">299   }</span>
300 };
301 
302 template &lt;typename T&gt;
303 class ZPerCPUConstIterator : public ZValueConstIterator&lt;ZPerCPUStorage, T&gt; {
304 public:
<a name="22" id="anc22"></a><span class="line-modified">305   ZPerCPUConstIterator(const ZPerCPU&lt;T&gt;* value) :</span>
<span class="line-removed">306       ZValueConstIterator&lt;ZPerCPUStorage, T&gt;(value) {}</span>
307 };
308 
309 template &lt;typename T&gt;
310 class ZPerNUMAConstIterator : public ZValueConstIterator&lt;ZPerNUMAStorage, T&gt; {
311 public:
<a name="23" id="anc23"></a><span class="line-modified">312   ZPerNUMAConstIterator(const ZPerNUMA&lt;T&gt;* value) :</span>
<span class="line-removed">313       ZValueConstIterator&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
314 };
315 
316 template &lt;typename T&gt;
317 class ZPerWorkerConstIterator : public ZValueConstIterator&lt;ZPerWorkerStorage, T&gt; {
318 public:
<a name="24" id="anc24"></a><span class="line-modified">319   ZPerWorkerConstIterator(const ZPerWorker&lt;T&gt;* value) :</span>
<span class="line-removed">320       ZValueConstIterator&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
321 };
322 
323 #endif // SHARE_GC_Z_ZVALUE_HPP
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
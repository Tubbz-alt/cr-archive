<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zCPU.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zCollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 26 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 27 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zHeap.inline.hpp&quot;
 30 #include &quot;gc/z/zNMethod.hpp&quot;


 31 #include &quot;gc/z/zServiceability.hpp&quot;
 32 #include &quot;gc/z/zStat.hpp&quot;
 33 #include &quot;gc/z/zUtils.inline.hpp&quot;


 34 #include &quot;runtime/mutexLocker.hpp&quot;

 35 
 36 ZCollectedHeap* ZCollectedHeap::heap() {
 37   CollectedHeap* heap = Universe::heap();
 38   assert(heap != NULL, &quot;Uninitialized access to ZCollectedHeap::heap()&quot;);
 39   assert(heap-&gt;kind() == CollectedHeap::Z, &quot;Invalid name&quot;);
 40   return (ZCollectedHeap*)heap;
 41 }
 42 
<span class="line-modified"> 43 ZCollectedHeap::ZCollectedHeap(ZCollectorPolicy* policy) :</span>
<span class="line-removed"> 44     _collector_policy(policy),</span>
 45     _soft_ref_policy(),
 46     _barrier_set(),
 47     _initialize(&amp;_barrier_set),
 48     _heap(),
 49     _director(new ZDirector()),
 50     _driver(new ZDriver()),

 51     _stat(new ZStat()),
 52     _runtime_workers() {}
 53 
 54 CollectedHeap::Name ZCollectedHeap::kind() const {
 55   return CollectedHeap::Z;
 56 }
 57 
 58 const char* ZCollectedHeap::name() const {
<span class="line-modified"> 59   return ZGCName;</span>
 60 }
 61 
 62 jint ZCollectedHeap::initialize() {
 63   if (!_heap.is_initialized()) {
 64     return JNI_ENOMEM;
 65   }
 66 
<span class="line-modified"> 67   initialize_reserved_region((HeapWord*)ZAddressReservedStart(),</span>
<span class="line-removed"> 68                              (HeapWord*)ZAddressReservedEnd());</span>
 69 
 70   return JNI_OK;
 71 }
 72 
 73 void ZCollectedHeap::initialize_serviceability() {
 74   _heap.serviceability_initialize();
 75 }
 76 
 77 void ZCollectedHeap::stop() {
 78   _director-&gt;stop();
 79   _driver-&gt;stop();

 80   _stat-&gt;stop();
 81 }
 82 
<span class="line-removed"> 83 CollectorPolicy* ZCollectedHeap::collector_policy() const {</span>
<span class="line-removed"> 84   return _collector_policy;</span>
<span class="line-removed"> 85 }</span>
<span class="line-removed"> 86 </span>
 87 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
 88   return &amp;_soft_ref_policy;
 89 }
 90 
 91 size_t ZCollectedHeap::max_capacity() const {
 92   return _heap.max_capacity();
 93 }
 94 
 95 size_t ZCollectedHeap::capacity() const {
 96   return _heap.capacity();
 97 }
 98 
 99 size_t ZCollectedHeap::used() const {
100   return _heap.used();
101 }
102 




103 bool ZCollectedHeap::is_maximal_no_gc() const {
104   // Not supported
105   ShouldNotReachHere();
106   return false;
107 }
108 
109 bool ZCollectedHeap::is_in(const void* p) const {
<span class="line-modified">110   return is_in_reserved(p) &amp;&amp; _heap.is_in((uintptr_t)p);</span>
111 }
112 
<span class="line-modified">113 bool ZCollectedHeap::is_in_closed_subset(const void* p) const {</span>
<span class="line-modified">114   return is_in(p);</span>
115 }
116 
117 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
118   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
119   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
120 
121   if (addr != 0) {
122     *actual_size = requested_size;
123   }
124 
125   return (HeapWord*)addr;
126 }
127 









128 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
129   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
130   return (HeapWord*)_heap.alloc_object(size_in_bytes);
131 }
132 
133 MetaWord* ZCollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
134                                                              size_t size,
135                                                              Metaspace::MetadataType mdtype) {
136   MetaWord* result;
137 
138   // Start asynchronous GC
139   collect(GCCause::_metadata_GC_threshold);
140 
141   // Expand and retry allocation
142   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
143   if (result != NULL) {
144     return result;
145   }
146 
147   // Start synchronous GC
</pre>
<hr />
<pre>
213   // Not supported
214   ShouldNotReachHere();
215   return true;
216 }
217 
218 bool ZCollectedHeap::card_mark_must_follow_store() const {
219   // Not supported
220   ShouldNotReachHere();
221   return false;
222 }
223 
224 GrowableArray&lt;GCMemoryManager*&gt; ZCollectedHeap::memory_managers() {
225   return GrowableArray&lt;GCMemoryManager*&gt;(1, 1, _heap.serviceability_memory_manager());
226 }
227 
228 GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
229   return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
230 }
231 
232 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
<span class="line-modified">233   _heap.object_iterate(cl, true /* visit_referents */);</span>
234 }
235 
<span class="line-modified">236 void ZCollectedHeap::safe_object_iterate(ObjectClosure* cl) {</span>
<span class="line-modified">237   _heap.object_iterate(cl, true /* visit_referents */);</span>
<span class="line-removed">238 }</span>
<span class="line-removed">239 </span>
<span class="line-removed">240 HeapWord* ZCollectedHeap::block_start(const void* addr) const {</span>
<span class="line-removed">241   return (HeapWord*)_heap.block_start((uintptr_t)addr);</span>
<span class="line-removed">242 }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244 bool ZCollectedHeap::block_is_obj(const HeapWord* addr) const {</span>
<span class="line-removed">245   return _heap.block_is_obj((uintptr_t)addr);</span>
246 }
247 
248 void ZCollectedHeap::register_nmethod(nmethod* nm) {
249   ZNMethod::register_nmethod(nm);
250 }
251 
252 void ZCollectedHeap::unregister_nmethod(nmethod* nm) {
253   ZNMethod::unregister_nmethod(nm);
254 }
255 
256 void ZCollectedHeap::flush_nmethod(nmethod* nm) {
257   ZNMethod::flush_nmethod(nm);
258 }
259 
260 void ZCollectedHeap::verify_nmethod(nmethod* nm) {
261   // Does nothing
262 }
263 
264 WorkGang* ZCollectedHeap::get_safepoint_workers() {
265   return _runtime_workers.workers();
266 }
267 
268 jlong ZCollectedHeap::millis_since_last_gc() {
269   return ZStatCycle::time_since_last() / MILLIUNITS;
270 }
271 
272 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
273   tc-&gt;do_thread(_director);
274   tc-&gt;do_thread(_driver);

275   tc-&gt;do_thread(_stat);
276   _heap.worker_threads_do(tc);
277   _runtime_workers.threads_do(tc);
278 }
279 
280 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
<span class="line-modified">281   const size_t capacity_in_words = capacity() / HeapWordSize;</span>
<span class="line-removed">282   const size_t max_capacity_in_words = max_capacity() / HeapWordSize;</span>
<span class="line-removed">283   return VirtualSpaceSummary(reserved_region().start(),</span>
<span class="line-removed">284                              reserved_region().start() + capacity_in_words,</span>
<span class="line-removed">285                              reserved_region().start() + max_capacity_in_words);</span>
286 }
287 
288 void ZCollectedHeap::safepoint_synchronize_begin() {
289   SuspendibleThreadSet::synchronize();
290 }
291 
292 void ZCollectedHeap::safepoint_synchronize_end() {
293   SuspendibleThreadSet::desynchronize();
294 }
295 
296 void ZCollectedHeap::prepare_for_verify() {
297   // Does nothing
298 }
299 
300 void ZCollectedHeap::print_on(outputStream* st) const {
301   _heap.print_on(st);
302 }
303 
304 void ZCollectedHeap::print_on_error(outputStream* st) const {
305   CollectedHeap::print_on_error(st);
306 
<span class="line-removed">307   st-&gt;print_cr(&quot;Address Space&quot;);</span>
<span class="line-removed">308   st-&gt;print_cr( &quot;     Start:             &quot; PTR_FORMAT, ZAddressSpaceStart);</span>
<span class="line-removed">309   st-&gt;print_cr( &quot;     End:               &quot; PTR_FORMAT, ZAddressSpaceEnd);</span>
<span class="line-removed">310   st-&gt;print_cr( &quot;     Size:              &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZAddressSpaceSize, ZAddressSpaceSize);</span>
311   st-&gt;print_cr( &quot;Heap&quot;);
312   st-&gt;print_cr( &quot;     GlobalPhase:       %u&quot;, ZGlobalPhase);
313   st-&gt;print_cr( &quot;     GlobalSeqNum:      %u&quot;, ZGlobalSeqNum);
314   st-&gt;print_cr( &quot;     Offset Max:        &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZAddressOffsetMax, ZAddressOffsetMax);
315   st-&gt;print_cr( &quot;     Page Size Small:   &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZPageSizeSmall, ZPageSizeSmall);
316   st-&gt;print_cr( &quot;     Page Size Medium:  &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZPageSizeMedium, ZPageSizeMedium);
317   st-&gt;print_cr( &quot;Metadata Bits&quot;);
318   st-&gt;print_cr( &quot;     Good:              &quot; PTR_FORMAT, ZAddressGoodMask);
319   st-&gt;print_cr( &quot;     Bad:               &quot; PTR_FORMAT, ZAddressBadMask);
320   st-&gt;print_cr( &quot;     WeakBad:           &quot; PTR_FORMAT, ZAddressWeakBadMask);
321   st-&gt;print_cr( &quot;     Marked:            &quot; PTR_FORMAT, ZAddressMetadataMarked);
322   st-&gt;print_cr( &quot;     Remapped:          &quot; PTR_FORMAT, ZAddressMetadataRemapped);
323 }
324 
325 void ZCollectedHeap::print_extended_on(outputStream* st) const {
326   _heap.print_extended_on(st);
327 }
328 
329 void ZCollectedHeap::print_gc_threads_on(outputStream* st) const {
330   _director-&gt;print_on(st);
331   st-&gt;cr();
332   _driver-&gt;print_on(st);
333   st-&gt;cr();


334   _stat-&gt;print_on(st);
335   st-&gt;cr();
336   _heap.print_worker_threads_on(st);
337   _runtime_workers.print_threads_on(st);
338 }
339 
340 void ZCollectedHeap::print_tracing_info() const {
341   // Does nothing
342 }
343 




344 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
345   _heap.verify();
346 }
347 
348 bool ZCollectedHeap::is_oop(oop object) const {
<span class="line-modified">349   return CollectedHeap::is_oop(object) &amp;&amp; _heap.is_oop(object);</span>
350 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
 26 #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
 27 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zHeap.inline.hpp&quot;
 30 #include &quot;gc/z/zNMethod.hpp&quot;
<span class="line-added"> 31 #include &quot;gc/z/zObjArrayAllocator.hpp&quot;</span>
<span class="line-added"> 32 #include &quot;gc/z/zOop.inline.hpp&quot;</span>
 33 #include &quot;gc/z/zServiceability.hpp&quot;
 34 #include &quot;gc/z/zStat.hpp&quot;
 35 #include &quot;gc/z/zUtils.inline.hpp&quot;
<span class="line-added"> 36 #include &quot;memory/iterator.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;memory/universe.hpp&quot;</span>
 38 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added"> 39 #include &quot;utilities/align.hpp&quot;</span>
 40 
 41 ZCollectedHeap* ZCollectedHeap::heap() {
 42   CollectedHeap* heap = Universe::heap();
 43   assert(heap != NULL, &quot;Uninitialized access to ZCollectedHeap::heap()&quot;);
 44   assert(heap-&gt;kind() == CollectedHeap::Z, &quot;Invalid name&quot;);
 45   return (ZCollectedHeap*)heap;
 46 }
 47 
<span class="line-modified"> 48 ZCollectedHeap::ZCollectedHeap() :</span>

 49     _soft_ref_policy(),
 50     _barrier_set(),
 51     _initialize(&amp;_barrier_set),
 52     _heap(),
 53     _director(new ZDirector()),
 54     _driver(new ZDriver()),
<span class="line-added"> 55     _uncommitter(new ZUncommitter()),</span>
 56     _stat(new ZStat()),
 57     _runtime_workers() {}
 58 
 59 CollectedHeap::Name ZCollectedHeap::kind() const {
 60   return CollectedHeap::Z;
 61 }
 62 
 63 const char* ZCollectedHeap::name() const {
<span class="line-modified"> 64   return ZName;</span>
 65 }
 66 
 67 jint ZCollectedHeap::initialize() {
 68   if (!_heap.is_initialized()) {
 69     return JNI_ENOMEM;
 70   }
 71 
<span class="line-modified"> 72   Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);</span>

 73 
 74   return JNI_OK;
 75 }
 76 
 77 void ZCollectedHeap::initialize_serviceability() {
 78   _heap.serviceability_initialize();
 79 }
 80 
 81 void ZCollectedHeap::stop() {
 82   _director-&gt;stop();
 83   _driver-&gt;stop();
<span class="line-added"> 84   _uncommitter-&gt;stop();</span>
 85   _stat-&gt;stop();
 86 }
 87 




 88 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
 89   return &amp;_soft_ref_policy;
 90 }
 91 
 92 size_t ZCollectedHeap::max_capacity() const {
 93   return _heap.max_capacity();
 94 }
 95 
 96 size_t ZCollectedHeap::capacity() const {
 97   return _heap.capacity();
 98 }
 99 
100 size_t ZCollectedHeap::used() const {
101   return _heap.used();
102 }
103 
<span class="line-added">104 size_t ZCollectedHeap::unused() const {</span>
<span class="line-added">105   return _heap.unused();</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
108 bool ZCollectedHeap::is_maximal_no_gc() const {
109   // Not supported
110   ShouldNotReachHere();
111   return false;
112 }
113 
114 bool ZCollectedHeap::is_in(const void* p) const {
<span class="line-modified">115   return _heap.is_in((uintptr_t)p);</span>
116 }
117 
<span class="line-modified">118 uint32_t ZCollectedHeap::hash_oop(oop obj) const {</span>
<span class="line-modified">119   return _heap.hash_oop(ZOop::to_address(obj));</span>
120 }
121 
122 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
123   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
124   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
125 
126   if (addr != 0) {
127     *actual_size = requested_size;
128   }
129 
130   return (HeapWord*)addr;
131 }
132 
<span class="line-added">133 oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {</span>
<span class="line-added">134   if (!do_zero) {</span>
<span class="line-added">135     return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);</span>
<span class="line-added">136   }</span>
<span class="line-added">137 </span>
<span class="line-added">138   ZObjArrayAllocator allocator(klass, size, length, THREAD);</span>
<span class="line-added">139   return allocator.allocate();</span>
<span class="line-added">140 }</span>
<span class="line-added">141 </span>
142 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
143   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
144   return (HeapWord*)_heap.alloc_object(size_in_bytes);
145 }
146 
147 MetaWord* ZCollectedHeap::satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
148                                                              size_t size,
149                                                              Metaspace::MetadataType mdtype) {
150   MetaWord* result;
151 
152   // Start asynchronous GC
153   collect(GCCause::_metadata_GC_threshold);
154 
155   // Expand and retry allocation
156   result = loader_data-&gt;metaspace_non_null()-&gt;expand_and_allocate(size, mdtype);
157   if (result != NULL) {
158     return result;
159   }
160 
161   // Start synchronous GC
</pre>
<hr />
<pre>
227   // Not supported
228   ShouldNotReachHere();
229   return true;
230 }
231 
232 bool ZCollectedHeap::card_mark_must_follow_store() const {
233   // Not supported
234   ShouldNotReachHere();
235   return false;
236 }
237 
238 GrowableArray&lt;GCMemoryManager*&gt; ZCollectedHeap::memory_managers() {
239   return GrowableArray&lt;GCMemoryManager*&gt;(1, 1, _heap.serviceability_memory_manager());
240 }
241 
242 GrowableArray&lt;MemoryPool*&gt; ZCollectedHeap::memory_pools() {
243   return GrowableArray&lt;MemoryPool*&gt;(1, 1, _heap.serviceability_memory_pool());
244 }
245 
246 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
<span class="line-modified">247   _heap.object_iterate(cl, true /* visit_weaks */);</span>
248 }
249 
<span class="line-modified">250 void ZCollectedHeap::keep_alive(oop obj) {</span>
<span class="line-modified">251   _heap.keep_alive(obj);</span>








252 }
253 
254 void ZCollectedHeap::register_nmethod(nmethod* nm) {
255   ZNMethod::register_nmethod(nm);
256 }
257 
258 void ZCollectedHeap::unregister_nmethod(nmethod* nm) {
259   ZNMethod::unregister_nmethod(nm);
260 }
261 
262 void ZCollectedHeap::flush_nmethod(nmethod* nm) {
263   ZNMethod::flush_nmethod(nm);
264 }
265 
266 void ZCollectedHeap::verify_nmethod(nmethod* nm) {
267   // Does nothing
268 }
269 
270 WorkGang* ZCollectedHeap::get_safepoint_workers() {
271   return _runtime_workers.workers();
272 }
273 
274 jlong ZCollectedHeap::millis_since_last_gc() {
275   return ZStatCycle::time_since_last() / MILLIUNITS;
276 }
277 
278 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
279   tc-&gt;do_thread(_director);
280   tc-&gt;do_thread(_driver);
<span class="line-added">281   tc-&gt;do_thread(_uncommitter);</span>
282   tc-&gt;do_thread(_stat);
283   _heap.worker_threads_do(tc);
284   _runtime_workers.threads_do(tc);
285 }
286 
287 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
<span class="line-modified">288   return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());</span>




289 }
290 
291 void ZCollectedHeap::safepoint_synchronize_begin() {
292   SuspendibleThreadSet::synchronize();
293 }
294 
295 void ZCollectedHeap::safepoint_synchronize_end() {
296   SuspendibleThreadSet::desynchronize();
297 }
298 
299 void ZCollectedHeap::prepare_for_verify() {
300   // Does nothing
301 }
302 
303 void ZCollectedHeap::print_on(outputStream* st) const {
304   _heap.print_on(st);
305 }
306 
307 void ZCollectedHeap::print_on_error(outputStream* st) const {
308   CollectedHeap::print_on_error(st);
309 




310   st-&gt;print_cr( &quot;Heap&quot;);
311   st-&gt;print_cr( &quot;     GlobalPhase:       %u&quot;, ZGlobalPhase);
312   st-&gt;print_cr( &quot;     GlobalSeqNum:      %u&quot;, ZGlobalSeqNum);
313   st-&gt;print_cr( &quot;     Offset Max:        &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZAddressOffsetMax, ZAddressOffsetMax);
314   st-&gt;print_cr( &quot;     Page Size Small:   &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZPageSizeSmall, ZPageSizeSmall);
315   st-&gt;print_cr( &quot;     Page Size Medium:  &quot; SIZE_FORMAT_W(-15) &quot; (&quot; PTR_FORMAT &quot;)&quot;, ZPageSizeMedium, ZPageSizeMedium);
316   st-&gt;print_cr( &quot;Metadata Bits&quot;);
317   st-&gt;print_cr( &quot;     Good:              &quot; PTR_FORMAT, ZAddressGoodMask);
318   st-&gt;print_cr( &quot;     Bad:               &quot; PTR_FORMAT, ZAddressBadMask);
319   st-&gt;print_cr( &quot;     WeakBad:           &quot; PTR_FORMAT, ZAddressWeakBadMask);
320   st-&gt;print_cr( &quot;     Marked:            &quot; PTR_FORMAT, ZAddressMetadataMarked);
321   st-&gt;print_cr( &quot;     Remapped:          &quot; PTR_FORMAT, ZAddressMetadataRemapped);
322 }
323 
324 void ZCollectedHeap::print_extended_on(outputStream* st) const {
325   _heap.print_extended_on(st);
326 }
327 
328 void ZCollectedHeap::print_gc_threads_on(outputStream* st) const {
329   _director-&gt;print_on(st);
330   st-&gt;cr();
331   _driver-&gt;print_on(st);
332   st-&gt;cr();
<span class="line-added">333   _uncommitter-&gt;print_on(st);</span>
<span class="line-added">334   st-&gt;cr();</span>
335   _stat-&gt;print_on(st);
336   st-&gt;cr();
337   _heap.print_worker_threads_on(st);
338   _runtime_workers.print_threads_on(st);
339 }
340 
341 void ZCollectedHeap::print_tracing_info() const {
342   // Does nothing
343 }
344 
<span class="line-added">345 bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {</span>
<span class="line-added">346   return _heap.print_location(st, (uintptr_t)addr);</span>
<span class="line-added">347 }</span>
<span class="line-added">348 </span>
349 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
350   _heap.verify();
351 }
352 
353 bool ZCollectedHeap::is_oop(oop object) const {
<span class="line-modified">354   return _heap.is_oop(ZOop::to_address(object));</span>
355 }
</pre>
</td>
</tr>
</table>
<center><a href="zCPU.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zCollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zList.inline.hpp&quot;
 26 #include &quot;gc/z/zMemory.inline.hpp&quot;
 27 #include &quot;memory/allocation.inline.hpp&quot;
 28 
<a name="2" id="anc2"></a>


























































 29 uintptr_t ZMemoryManager::alloc_from_front(size_t size) {
 30   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 31   for (ZMemory* area; iter.next(&amp;area);) {
 32     if (area-&gt;size() &gt;= size) {
 33       if (area-&gt;size() == size) {
 34         // Exact match, remove area
 35         const uintptr_t start = area-&gt;start();
 36         _freelist.remove(area);
<a name="3" id="anc3"></a><span class="line-modified"> 37         delete area;</span>
 38         return start;
 39       } else {
 40         // Larger than requested, shrink area
 41         const uintptr_t start = area-&gt;start();
<a name="4" id="anc4"></a><span class="line-modified"> 42         area-&gt;shrink_from_front(size);</span>
 43         return start;
 44       }
 45     }
 46   }
 47 
 48   // Out of memory
 49   return UINTPTR_MAX;
 50 }
 51 
<a name="5" id="anc5"></a>























 52 uintptr_t ZMemoryManager::alloc_from_back(size_t size) {
 53   ZListReverseIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 54   for (ZMemory* area; iter.next(&amp;area);) {
 55     if (area-&gt;size() &gt;= size) {
 56       if (area-&gt;size() == size) {
 57         // Exact match, remove area
 58         const uintptr_t start = area-&gt;start();
 59         _freelist.remove(area);
<a name="6" id="anc6"></a><span class="line-modified"> 60         delete area;</span>
 61         return start;
 62       } else {
 63         // Larger than requested, shrink area
<a name="7" id="anc7"></a><span class="line-modified"> 64         area-&gt;shrink_from_back(size);</span>
 65         return area-&gt;end();
 66       }
 67     }
 68   }
 69 
 70   // Out of memory
 71   return UINTPTR_MAX;
 72 }
 73 
<a name="8" id="anc8"></a>






















 74 void ZMemoryManager::free(uintptr_t start, size_t size) {
 75   assert(start != UINTPTR_MAX, &quot;Invalid address&quot;);
 76   const uintptr_t end = start + size;
 77 
 78   ZListIterator&lt;ZMemory&gt; iter(&amp;_freelist);
 79   for (ZMemory* area; iter.next(&amp;area);) {
 80     if (start &lt; area-&gt;start()) {
 81       ZMemory* const prev = _freelist.prev(area);
 82       if (prev != NULL &amp;&amp; start == prev-&gt;end()) {
 83         if (end == area-&gt;start()) {
 84           // Merge with prev and current area
<a name="9" id="anc9"></a><span class="line-modified"> 85           prev-&gt;grow_from_back(size + area-&gt;size());</span>
 86           _freelist.remove(area);
 87           delete area;
 88         } else {
 89           // Merge with prev area
<a name="10" id="anc10"></a><span class="line-modified"> 90           prev-&gt;grow_from_back(size);</span>
 91         }
 92       } else if (end == area-&gt;start()) {
 93         // Merge with current area
<a name="11" id="anc11"></a><span class="line-modified"> 94         area-&gt;grow_from_front(size);</span>
 95       } else {
 96         // Insert new area before current area
 97         assert(end &lt; area-&gt;start(), &quot;Areas must not overlap&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 98         ZMemory* new_area = new ZMemory(start, size);</span>
 99         _freelist.insert_before(area, new_area);
100       }
101 
102       // Done
103       return;
104     }
105   }
106 
107   // Insert last
108   ZMemory* const last = _freelist.last();
109   if (last != NULL &amp;&amp; start == last-&gt;end()) {
110     // Merge with last area
<a name="13" id="anc13"></a><span class="line-modified">111     last-&gt;grow_from_back(size);</span>
112   } else {
113     // Insert new area last
<a name="14" id="anc14"></a><span class="line-modified">114     ZMemory* new_area = new ZMemory(start, size);</span>
115     _freelist.insert_last(new_area);
116   }
117 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
diff a/src/hotspot/share/gc/z/zHeap.inline.hpp b/src/hotspot/share/gc/z/zHeap.inline.hpp
--- a/src/hotspot/share/gc/z/zHeap.inline.hpp
+++ b/src/hotspot/share/gc/z/zHeap.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,16 +23,18 @@
 
 #ifndef SHARE_GC_Z_ZHEAP_INLINE_HPP
 #define SHARE_GC_Z_ZHEAP_INLINE_HPP
 
 #include "gc/z/zAddress.inline.hpp"
+#include "gc/z/zForwarding.inline.hpp"
+#include "gc/z/zForwardingTable.inline.hpp"
+#include "gc/z/zHash.inline.hpp"
 #include "gc/z/zHeap.hpp"
 #include "gc/z/zMark.inline.hpp"
 #include "gc/z/zOop.inline.hpp"
 #include "gc/z/zPage.inline.hpp"
 #include "gc/z/zPageTable.inline.hpp"
-#include "gc/z/zUtils.inline.hpp"
 #include "utilities/debug.hpp"
 
 inline ZHeap* ZHeap::heap() {
   assert(_heap != NULL, "Not initialized");
   return _heap;
@@ -40,28 +42,29 @@
 
 inline ReferenceDiscoverer* ZHeap::reference_discoverer() {
   return &_reference_processor;
 }
 
-inline bool ZHeap::is_relocating(uintptr_t addr) const {
-  return _pagetable.is_relocating(addr);
+inline uint32_t ZHeap::hash_oop(uintptr_t addr) const {
+  const uintptr_t offset = ZAddress::offset(addr);
+  return ZHash::address_to_uint32(offset);
 }
 
 inline bool ZHeap::is_object_live(uintptr_t addr) const {
-  ZPage* page = _pagetable.get(addr);
+  ZPage* page = _page_table.get(addr);
   return page->is_object_live(addr);
 }
 
 inline bool ZHeap::is_object_strongly_live(uintptr_t addr) const {
-  ZPage* page = _pagetable.get(addr);
+  ZPage* page = _page_table.get(addr);
   return page->is_object_strongly_live(addr);
 }
 
-template <bool finalizable, bool publish>
+template <bool follow, bool finalizable, bool publish>
 inline void ZHeap::mark_object(uintptr_t addr) {
   assert(ZGlobalPhase == ZPhaseMark, "Mark not allowed");
-  _mark.mark_object<finalizable, publish>(addr);
+  _mark.mark_object<follow, finalizable, publish>(addr);
 }
 
 inline uintptr_t ZHeap::alloc_tlab(size_t size) {
   guarantee(size <= max_tlab_size(), "TLAB too large");
   return _object_allocator.alloc_object(size);
@@ -83,22 +86,55 @@
   assert(ZAddress::is_good_or_null(addr), "Bad address");
   return addr;
 }
 
 inline void ZHeap::undo_alloc_object_for_relocation(uintptr_t addr, size_t size) {
-  ZPage* const page = _pagetable.get(addr);
+  ZPage* const page = _page_table.get(addr);
   _object_allocator.undo_alloc_object_for_relocation(page, addr, size);
 }
 
+inline uintptr_t ZHeap::relocate_object(uintptr_t addr) {
+  assert(ZGlobalPhase == ZPhaseRelocate, "Relocate not allowed");
+
+  ZForwarding* const forwarding = _forwarding_table.get(addr);
+  if (forwarding == NULL) {
+    // Not forwarding
+    return ZAddress::good(addr);
+  }
+
+  // Relocate object
+  const bool retained = forwarding->retain_page();
+  const uintptr_t new_addr = _relocate.relocate_object(forwarding, addr);
+  if (retained) {
+    forwarding->release_page();
+  }
+
+  return new_addr;
+}
+
+inline uintptr_t ZHeap::remap_object(uintptr_t addr) {
+  assert(ZGlobalPhase == ZPhaseMark ||
+         ZGlobalPhase == ZPhaseMarkCompleted, "Forward not allowed");
+
+  ZForwarding* const forwarding = _forwarding_table.get(addr);
+  if (forwarding == NULL) {
+    // Not forwarding
+    return ZAddress::good(addr);
+  }
+
+  // Forward object
+  return _relocate.forward_object(forwarding, addr);
+}
+
 inline bool ZHeap::is_alloc_stalled() const {
   return _page_allocator.is_alloc_stalled();
 }
 
 inline void ZHeap::check_out_of_memory() {
   _page_allocator.check_out_of_memory();
 }
 
-inline bool ZHeap::is_oop(oop object) const {
-  return ZOop::is_good(object);
+inline bool ZHeap::is_oop(uintptr_t addr) const {
+  return ZAddress::is_good(addr) && is_object_aligned(addr) && is_in(addr);
 }
 
 #endif // SHARE_GC_Z_ZHEAP_INLINE_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,55 ***</span>
   */
  
  #ifndef SHARE_GC_Z_ZHEAP_HPP
  #define SHARE_GC_Z_ZHEAP_HPP
  
<span class="line-removed">- #include &quot;gc/shared/gcTimer.hpp&quot;</span>
  #include &quot;gc/z/zAllocationFlags.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zArray.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zList.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zLock.hpp&quot;</span>
  #include &quot;gc/z/zMark.hpp&quot;
  #include &quot;gc/z/zObjectAllocator.hpp&quot;
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zPageAllocator.hpp&quot;
  #include &quot;gc/z/zPageTable.hpp&quot;
  #include &quot;gc/z/zReferenceProcessor.hpp&quot;
  #include &quot;gc/z/zRelocate.hpp&quot;
  #include &quot;gc/z/zRelocationSet.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zRelocationSetSelector.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zRootsIterator.hpp&quot;</span>
  #include &quot;gc/z/zWeakRootsProcessor.hpp&quot;
  #include &quot;gc/z/zServiceability.hpp&quot;
  #include &quot;gc/z/zUnload.hpp&quot;
  #include &quot;gc/z/zWorkers.hpp&quot;
<span class="line-modified">! #include &quot;memory/allocation.hpp&quot;</span>
  
  class ZHeap {
    friend class VMStructs;
  
  private:
    static ZHeap*       _heap;
  
    ZWorkers            _workers;
    ZObjectAllocator    _object_allocator;
    ZPageAllocator      _page_allocator;
<span class="line-modified">!   ZPageTable          _pagetable;</span>
    ZMark               _mark;
    ZReferenceProcessor _reference_processor;
    ZWeakRootsProcessor _weak_roots_processor;
    ZRelocate           _relocate;
    ZRelocationSet      _relocation_set;
    ZUnload             _unload;
    ZServiceability     _serviceability;
  
    size_t heap_min_size() const;
    size_t heap_max_size() const;
    size_t heap_max_reserve_size() const;
  
    void out_of_memory();
<span class="line-removed">-   void flip_views();</span>
    void fixup_partial_loads();
  
  public:
    static ZHeap* heap();
  
<span class="line-new-header">--- 22,55 ---</span>
   */
  
  #ifndef SHARE_GC_Z_ZHEAP_HPP
  #define SHARE_GC_Z_ZHEAP_HPP
  
  #include &quot;gc/z/zAllocationFlags.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zForwardingTable.hpp&quot;</span>
  #include &quot;gc/z/zMark.hpp&quot;
  #include &quot;gc/z/zObjectAllocator.hpp&quot;
  #include &quot;gc/z/zPage.hpp&quot;
  #include &quot;gc/z/zPageAllocator.hpp&quot;
  #include &quot;gc/z/zPageTable.hpp&quot;
  #include &quot;gc/z/zReferenceProcessor.hpp&quot;
  #include &quot;gc/z/zRelocate.hpp&quot;
  #include &quot;gc/z/zRelocationSet.hpp&quot;
  #include &quot;gc/z/zWeakRootsProcessor.hpp&quot;
  #include &quot;gc/z/zServiceability.hpp&quot;
  #include &quot;gc/z/zUnload.hpp&quot;
  #include &quot;gc/z/zWorkers.hpp&quot;
<span class="line-modified">! </span>
<span class="line-added">+ class ThreadClosure;</span>
  
  class ZHeap {
    friend class VMStructs;
  
  private:
    static ZHeap*       _heap;
  
    ZWorkers            _workers;
    ZObjectAllocator    _object_allocator;
    ZPageAllocator      _page_allocator;
<span class="line-modified">!   ZPageTable          _page_table;</span>
<span class="line-added">+   ZForwardingTable    _forwarding_table;</span>
    ZMark               _mark;
    ZReferenceProcessor _reference_processor;
    ZWeakRootsProcessor _weak_roots_processor;
    ZRelocate           _relocate;
    ZRelocationSet      _relocation_set;
    ZUnload             _unload;
    ZServiceability     _serviceability;
  
    size_t heap_min_size() const;
<span class="line-added">+   size_t heap_initial_size() const;</span>
    size_t heap_max_size() const;
    size_t heap_max_reserve_size() const;
  
<span class="line-added">+   void flip_to_marked();</span>
<span class="line-added">+   void flip_to_remapped();</span>
<span class="line-added">+ </span>
    void out_of_memory();
    void fixup_partial_loads();
  
  public:
    static ZHeap* heap();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,29 ***</span>
    bool is_initialized() const;
  
    // Heap metrics
    size_t min_capacity() const;
    size_t max_capacity() const;
<span class="line-modified">!   size_t current_max_capacity() const;</span>
    size_t capacity() const;
    size_t max_reserve() const;
    size_t used_high() const;
    size_t used_low() const;
    size_t used() const;
    size_t allocated() const;
    size_t reclaimed() const;
  
    size_t tlab_capacity() const;
    size_t tlab_used() const;
    size_t max_tlab_size() const;
    size_t unsafe_max_tlab_alloc() const;
  
    bool is_in(uintptr_t addr) const;
<span class="line-modified">! </span>
<span class="line-removed">-   // Block</span>
<span class="line-removed">-   uintptr_t block_start(uintptr_t addr) const;</span>
<span class="line-removed">-   bool block_is_obj(uintptr_t addr) const;</span>
  
    // Workers
    uint nconcurrent_worker_threads() const;
    uint nconcurrent_no_boost_worker_threads() const;
    void set_boost_worker_threads(bool boost);
<span class="line-new-header">--- 79,27 ---</span>
    bool is_initialized() const;
  
    // Heap metrics
    size_t min_capacity() const;
    size_t max_capacity() const;
<span class="line-modified">!   size_t soft_max_capacity() const;</span>
    size_t capacity() const;
    size_t max_reserve() const;
    size_t used_high() const;
    size_t used_low() const;
    size_t used() const;
<span class="line-added">+   size_t unused() const;</span>
    size_t allocated() const;
    size_t reclaimed() const;
  
    size_t tlab_capacity() const;
    size_t tlab_used() const;
    size_t max_tlab_size() const;
    size_t unsafe_max_tlab_alloc() const;
  
    bool is_in(uintptr_t addr) const;
<span class="line-modified">!   uint32_t hash_oop(uintptr_t addr) const;</span>
  
    // Workers
    uint nconcurrent_worker_threads() const;
    uint nconcurrent_no_boost_worker_threads() const;
    void set_boost_worker_threads(bool boost);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,12 ***</span>
    void process_non_strong_references();
  
    // Page allocation
    ZPage* alloc_page(uint8_t type, size_t size, ZAllocationFlags flags);
    void undo_alloc_page(ZPage* page);
<span class="line-modified">!   bool retain_page(ZPage* page);</span>
<span class="line-modified">!   void release_page(ZPage* page, bool reclaimed);</span>
  
    // Object allocation
    uintptr_t alloc_tlab(size_t size);
    uintptr_t alloc_object(size_t size);
    uintptr_t alloc_object_for_relocation(size_t size);
<span class="line-new-header">--- 114,14 ---</span>
    void process_non_strong_references();
  
    // Page allocation
    ZPage* alloc_page(uint8_t type, size_t size, ZAllocationFlags flags);
    void undo_alloc_page(ZPage* page);
<span class="line-modified">!   void free_page(ZPage* page, bool reclaimed);</span>
<span class="line-modified">! </span>
<span class="line-added">+   // Uncommit memory</span>
<span class="line-added">+   uint64_t uncommit(uint64_t delay);</span>
  
    // Object allocation
    uintptr_t alloc_tlab(size_t size);
    uintptr_t alloc_object(size_t size);
    uintptr_t alloc_object_for_relocation(size_t size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,45 ***</span>
    void check_out_of_memory();
  
    // Marking
    bool is_object_live(uintptr_t addr) const;
    bool is_object_strongly_live(uintptr_t addr) const;
<span class="line-modified">!   template &lt;bool finalizable, bool publish&gt; void mark_object(uintptr_t addr);</span>
    void mark_start();
    void mark(bool initial);
    void mark_flush_and_free(Thread* thread);
    bool mark_end();
<span class="line-modified">! </span>
<span class="line-removed">-   // Post-marking &amp; Pre-relocation</span>
<span class="line-removed">-   void destroy_detached_pages();</span>
  
    // Relocation set
    void select_relocation_set();
<span class="line-removed">-   void prepare_relocation_set();</span>
    void reset_relocation_set();
  
    // Relocation
<span class="line-removed">-   bool is_relocating(uintptr_t addr) const;</span>
    void relocate_start();
    uintptr_t relocate_object(uintptr_t addr);
<span class="line-modified">!   uintptr_t forward_object(uintptr_t addr);</span>
    void relocate();
  
    // Iteration
<span class="line-modified">!   void object_iterate(ObjectClosure* cl, bool visit_referents);</span>
  
    // Serviceability
    void serviceability_initialize();
    GCMemoryManager* serviceability_memory_manager();
    MemoryPool* serviceability_memory_pool();
    ZServiceabilityCounters* serviceability_counters();
  
    // Printing
    void print_on(outputStream* st) const;
    void print_extended_on(outputStream* st) const;
  
    // Verification
<span class="line-modified">!   bool is_oop(oop object) const;</span>
    void verify();
  };
  
  #endif // SHARE_GC_Z_ZHEAP_HPP
<span class="line-new-header">--- 130,43 ---</span>
    void check_out_of_memory();
  
    // Marking
    bool is_object_live(uintptr_t addr) const;
    bool is_object_strongly_live(uintptr_t addr) const;
<span class="line-modified">!   template &lt;bool follow, bool finalizable, bool publish&gt; void mark_object(uintptr_t addr);</span>
    void mark_start();
    void mark(bool initial);
    void mark_flush_and_free(Thread* thread);
    bool mark_end();
<span class="line-modified">!   void keep_alive(oop obj);</span>
  
    // Relocation set
    void select_relocation_set();
    void reset_relocation_set();
  
    // Relocation
    void relocate_start();
    uintptr_t relocate_object(uintptr_t addr);
<span class="line-modified">!   uintptr_t remap_object(uintptr_t addr);</span>
    void relocate();
  
    // Iteration
<span class="line-modified">!   void object_iterate(ObjectClosure* cl, bool visit_weaks);</span>
<span class="line-added">+   void pages_do(ZPageClosure* cl);</span>
  
    // Serviceability
    void serviceability_initialize();
    GCMemoryManager* serviceability_memory_manager();
    MemoryPool* serviceability_memory_pool();
    ZServiceabilityCounters* serviceability_counters();
  
    // Printing
    void print_on(outputStream* st) const;
    void print_extended_on(outputStream* st) const;
<span class="line-added">+   bool print_location(outputStream* st, uintptr_t addr) const;</span>
  
    // Verification
<span class="line-modified">!   bool is_oop(uintptr_t addr) const;</span>
    void verify();
  };
  
  #endif // SHARE_GC_Z_ZHEAP_HPP
</pre>
<center><a href="zHeap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeap.inline.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
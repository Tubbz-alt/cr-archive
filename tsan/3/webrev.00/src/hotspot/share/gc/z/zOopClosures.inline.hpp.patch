diff a/src/hotspot/share/gc/z/zOopClosures.inline.hpp b/src/hotspot/share/gc/z/zOopClosures.inline.hpp
--- a/src/hotspot/share/gc/z/zOopClosures.inline.hpp
+++ b/src/hotspot/share/gc/z/zOopClosures.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -53,11 +53,16 @@
   ShouldNotReachHere();
 }
 
 template <bool finalizable>
 inline ZMarkBarrierOopClosure<finalizable>::ZMarkBarrierOopClosure() :
-    MetadataVisitingOopIterateClosure(finalizable ? NULL : ZHeap::heap()->reference_discoverer()) {}
+    ClaimMetadataVisitingOopIterateClosure(finalizable
+                                               ? ClassLoaderData::_claim_finalizable
+                                               : ClassLoaderData::_claim_strong,
+                                           finalizable
+                                               ? NULL
+                                               : ZHeap::heap()->reference_discoverer()) {}
 
 template <bool finalizable>
 inline void ZMarkBarrierOopClosure<finalizable>::do_oop(oop* p) {
   ZBarrier::mark_barrier_on_oop_field(p, finalizable);
 }
@@ -65,22 +70,10 @@
 template <bool finalizable>
 inline void ZMarkBarrierOopClosure<finalizable>::do_oop(narrowOop* p) {
   ShouldNotReachHere();
 }
 
-template <bool finalizable>
-inline void ZMarkBarrierOopClosure<finalizable>::do_klass(Klass* k) {
-  ClassLoaderData* const cld = k->class_loader_data();
-  ZMarkBarrierOopClosure<finalizable>::do_cld(cld);
-}
-
-template <bool finalizable>
-inline void ZMarkBarrierOopClosure<finalizable>::do_cld(ClassLoaderData* cld) {
-  const int claim = finalizable ? ClassLoaderData::_claim_finalizable : ClassLoaderData::_claim_strong;
-  cld->oops_do(this, claim);
-}
-
 inline bool ZPhantomIsAliveObjectClosure::do_object_b(oop o) {
   return ZBarrier::is_alive_barrier_on_phantom_oop(o);
 }
 
 inline void ZPhantomKeepAliveOopClosure::do_oop(oop* p) {
@@ -101,11 +94,11 @@
     // The destination could have been modified/reused, in which case
     // we don't want to clear it. However, no one could write the same
     // oop here again (the object would be strongly live and we would
     // not consider clearing such oops), so therefore we don't have an
     // ABA problem here.
-    Atomic::cmpxchg(oop(NULL), p, obj);
+    Atomic::cmpxchg(p, obj, oop(NULL));
   }
 }
 
 inline void ZPhantomCleanOopClosure::do_oop(narrowOop* p) {
   ShouldNotReachHere();

diff a/src/hotspot/share/gc/z/zBarrier.cpp b/src/hotspot/share/gc/z/zBarrier.cpp
--- a/src/hotspot/share/gc/z/zBarrier.cpp
+++ b/src/hotspot/share/gc/z/zBarrier.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,18 +29,10 @@
 #include "memory/iterator.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/safepoint.hpp"
 #include "utilities/debug.hpp"
 
-bool ZBarrier::during_mark() {
-  return ZGlobalPhase == ZPhaseMark;
-}
-
-bool ZBarrier::during_relocate() {
-  return ZGlobalPhase == ZPhaseRelocate;
-}
-
 template <bool finalizable>
 bool ZBarrier::should_mark_through(uintptr_t addr) {
   // Finalizable marked oops can still exists on the heap after marking
   // has completed, in which case we just want to convert this into a
   // good oop and not push it on the mark stack.
@@ -70,11 +62,11 @@
 
   // Mark through
   return true;
 }
 
-template <bool finalizable, bool publish>
+template <bool follow, bool finalizable, bool publish>
 uintptr_t ZBarrier::mark(uintptr_t addr) {
   uintptr_t good_addr;
 
   if (ZAddress::is_marked(addr)) {
     // Already marked, but try to mark though anyway
@@ -87,44 +79,41 @@
     good_addr = remap(addr);
   }
 
   // Mark
   if (should_mark_through<finalizable>(addr)) {
-    ZHeap::heap()->mark_object<finalizable, publish>(good_addr);
+    ZHeap::heap()->mark_object<follow, finalizable, publish>(good_addr);
+  }
+
+  if (finalizable) {
+    // Make the oop finalizable marked/good, instead of normal marked/good.
+    // This is needed because an object might first becomes finalizable
+    // marked by the GC, and then loaded by a mutator thread. In this case,
+    // the mutator thread must be able to tell that the object needs to be
+    // strongly marked. The finalizable bit in the oop exists to make sure
+    // that a load of a finalizable marked oop will fall into the barrier
+    // slow path so that we can mark the object as strongly reachable.
+    return ZAddress::finalizable_good(good_addr);
   }
 
   return good_addr;
 }
 
 uintptr_t ZBarrier::remap(uintptr_t addr) {
   assert(!ZAddress::is_good(addr), "Should not be good");
   assert(!ZAddress::is_weak_good(addr), "Should not be weak good");
-
-  if (ZHeap::heap()->is_relocating(addr)) {
-    // Forward
-    return ZHeap::heap()->forward_object(addr);
-  }
-
-  // Remap
-  return ZAddress::good(addr);
+  return ZHeap::heap()->remap_object(addr);
 }
 
 uintptr_t ZBarrier::relocate(uintptr_t addr) {
   assert(!ZAddress::is_good(addr), "Should not be good");
   assert(!ZAddress::is_weak_good(addr), "Should not be weak good");
-
-  if (ZHeap::heap()->is_relocating(addr)) {
-    // Relocate
-    return ZHeap::heap()->relocate_object(addr);
-  }
-
-  // Remap
-  return ZAddress::good(addr);
+  return ZHeap::heap()->relocate_object(addr);
 }
 
 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
-  return during_relocate() ? relocate(addr) : mark<Strong, Publish>(addr);
+  return during_relocate() ? relocate(addr) : mark<Follow, Strong, Publish>(addr);
 }
 
 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
   return during_relocate() ? relocate(addr) : remap(addr);
 }
@@ -135,11 +124,11 @@
 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
   return relocate_or_mark(addr);
 }
 
 void ZBarrier::load_barrier_on_oop_fields(oop o) {
-  assert(ZOop::is_good(o), "Should be good");
+  assert(ZAddress::is_good(ZOop::to_address(o)), "Should be good");
   ZLoadBarrierOopClosure cl;
   o->oop_iterate(&cl);
 }
 
 //
@@ -186,37 +175,37 @@
 
 //
 // Mark barrier
 //
 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
-  return mark<Strong, Overflow>(addr);
+  assert(during_mark(), "Invalid phase");
+
+  // Mark
+  return mark<Follow, Strong, Overflow>(addr);
 }
 
 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
-  const uintptr_t good_addr = mark<Finalizable, Overflow>(addr);
-  if (ZAddress::is_good(addr)) {
-    // If the oop was already strongly marked/good, then we do
-    // not want to downgrade it to finalizable marked/good.
-    return good_addr;
-  }
+  assert(during_mark(), "Invalid phase");
 
-  // Make the oop finalizable marked/good, instead of normal marked/good.
-  // This is needed because an object might first becomes finalizable
-  // marked by the GC, and then loaded by a mutator thread. In this case,
-  // the mutator thread must be able to tell that the object needs to be
-  // strongly marked. The finalizable bit in the oop exists to make sure
-  // that a load of a finalizable marked oop will fall into the barrier
-  // slow path so that we can mark the object as strongly reachable.
-  return ZAddress::finalizable_good(good_addr);
+  // Mark
+  return mark<Follow, Finalizable, Overflow>(addr);
 }
 
 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
   assert(SafepointSynchronize::is_at_safepoint(), "Should be at safepoint");
   assert(during_mark(), "Invalid phase");
 
   // Mark
-  return mark<Strong, Publish>(addr);
+  return mark<Follow, Strong, Publish>(addr);
+}
+
+uintptr_t ZBarrier::mark_barrier_on_invisible_root_oop_slow_path(uintptr_t addr) {
+  assert(SafepointSynchronize::is_at_safepoint(), "Should be at safepoint");
+  assert(during_mark(), "Invalid phase");
+
+  // Mark
+  return mark<DontFollow, Strong, Publish>(addr);
 }
 
 //
 // Relocate barrier
 //

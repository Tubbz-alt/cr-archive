<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zGranuleMap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,36 ***</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/oopStorage.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/z/zAddress.hpp&quot;</span>
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
  #include &quot;gc/z/zHeapIterator.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zList.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zLock.inline.hpp&quot;</span>
  #include &quot;gc/z/zMark.inline.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zOopClosures.inline.hpp&quot;</span>
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageTable.inline.hpp&quot;
  #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
  #include &quot;gc/z/zResurrection.hpp&quot;
<span class="line-removed">- #include &quot;gc/z/zRootsIterator.hpp&quot;</span>
  #include &quot;gc/z/zStat.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zTask.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/z/zThread.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zTracer.inline.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/z/zVirtualMemory.inline.hpp&quot;</span>
  #include &quot;gc/z/zWorkers.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;oops/oop.inline.hpp&quot;</span>
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
<span class="line-removed">- #include &quot;utilities/align.hpp&quot;</span>
  #include &quot;utilities/debug.hpp&quot;
  
  static const ZStatSampler ZSamplerHeapUsedBeforeMark(&quot;Memory&quot;, &quot;Heap Used Before Mark&quot;, ZStatUnitBytes);
  static const ZStatSampler ZSamplerHeapUsedAfterMark(&quot;Memory&quot;, &quot;Heap Used After Mark&quot;, ZStatUnitBytes);
  static const ZStatSampler ZSamplerHeapUsedBeforeRelocation(&quot;Memory&quot;, &quot;Heap Used Before Relocation&quot;, ZStatUnitBytes);
<span class="line-new-header">--- 20,31 ---</span>
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/locationPrinter.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/z/zAddress.inline.hpp&quot;</span>
  #include &quot;gc/z/zGlobals.hpp&quot;
  #include &quot;gc/z/zHeap.inline.hpp&quot;
  #include &quot;gc/z/zHeapIterator.hpp&quot;
  #include &quot;gc/z/zMark.inline.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageTable.inline.hpp&quot;
  #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
<span class="line-added">+ #include &quot;gc/z/zRelocationSetSelector.inline.hpp&quot;</span>
  #include &quot;gc/z/zResurrection.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
<span class="line-modified">! #include &quot;gc/z/zThread.inline.hpp&quot;</span>
<span class="line-modified">! #include &quot;gc/z/zVerify.hpp&quot;</span>
  #include &quot;gc/z/zWorkers.inline.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="line-added">+ #include &quot;memory/iterator.hpp&quot;</span>
  #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified">! #include &quot;runtime/handshake.hpp&quot;</span>
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.hpp&quot;
  #include &quot;utilities/debug.hpp&quot;
  
  static const ZStatSampler ZSamplerHeapUsedBeforeMark(&quot;Memory&quot;, &quot;Heap Used Before Mark&quot;, ZStatUnitBytes);
  static const ZStatSampler ZSamplerHeapUsedAfterMark(&quot;Memory&quot;, &quot;Heap Used After Mark&quot;, ZStatUnitBytes);
  static const ZStatSampler ZSamplerHeapUsedBeforeRelocation(&quot;Memory&quot;, &quot;Heap Used Before Relocation&quot;, ZStatUnitBytes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,14 ***</span>
  
  ZHeap* ZHeap::_heap = NULL;
  
  ZHeap::ZHeap() :
      _workers(),
<span class="line-modified">!     _object_allocator(_workers.nworkers()),</span>
<span class="line-modified">!     _page_allocator(heap_min_size(), heap_max_size(), heap_max_reserve_size()),</span>
<span class="line-modified">!     _pagetable(),</span>
<span class="line-modified">!     _mark(&amp;_workers, &amp;_pagetable),</span>
      _reference_processor(&amp;_workers),
      _weak_roots_processor(&amp;_workers),
      _relocate(&amp;_workers),
      _relocation_set(),
      _unload(&amp;_workers),
<span class="line-new-header">--- 54,15 ---</span>
  
  ZHeap* ZHeap::_heap = NULL;
  
  ZHeap::ZHeap() :
      _workers(),
<span class="line-modified">!     _object_allocator(),</span>
<span class="line-modified">!     _page_allocator(&amp;_workers, heap_min_size(), heap_initial_size(), heap_max_size(), heap_max_reserve_size()),</span>
<span class="line-modified">!     _page_table(),</span>
<span class="line-modified">!     _forwarding_table(),</span>
<span class="line-added">+     _mark(&amp;_workers, &amp;_page_table),</span>
      _reference_processor(&amp;_workers),
      _weak_roots_processor(&amp;_workers),
      _relocate(&amp;_workers),
      _relocation_set(),
      _unload(&amp;_workers),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,21 ***</span>
    // Install global heap instance
    assert(_heap == NULL, &quot;Already initialized&quot;);
    _heap = this;
  
    // Update statistics
<span class="line-modified">!   ZStatHeap::set_at_initialize(heap_max_size(), heap_max_reserve_size());</span>
  }
  
  size_t ZHeap::heap_min_size() const {
<span class="line-modified">!   const size_t aligned_min_size = align_up(InitialHeapSize, ZGranuleSize);</span>
<span class="line-modified">!   return MIN2(aligned_min_size, heap_max_size());</span>
  }
  
  size_t ZHeap::heap_max_size() const {
<span class="line-modified">!   const size_t aligned_max_size = align_up(MaxHeapSize, ZGranuleSize);</span>
<span class="line-removed">-   return MIN2(aligned_max_size, ZAddressOffsetMax);</span>
  }
  
  size_t ZHeap::heap_max_reserve_size() const {
    // Reserve one small page per worker plus one shared medium page. This is still just
    // an estimate and doesn&#39;t guarantee that we can&#39;t run out of memory during relocation.
<span class="line-new-header">--- 70,23 ---</span>
    // Install global heap instance
    assert(_heap == NULL, &quot;Already initialized&quot;);
    _heap = this;
  
    // Update statistics
<span class="line-modified">!   ZStatHeap::set_at_initialize(heap_min_size(), heap_max_size(), heap_max_reserve_size());</span>
  }
  
  size_t ZHeap::heap_min_size() const {
<span class="line-modified">!   return MinHeapSize;</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t ZHeap::heap_initial_size() const {</span>
<span class="line-added">+   return InitialHeapSize;</span>
  }
  
  size_t ZHeap::heap_max_size() const {
<span class="line-modified">!   return MaxHeapSize;</span>
  }
  
  size_t ZHeap::heap_max_reserve_size() const {
    // Reserve one small page per worker plus one shared medium page. This is still just
    // an estimate and doesn&#39;t guarantee that we can&#39;t run out of memory during relocation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,19 ***</span>
  bool ZHeap::is_initialized() const {
    return _page_allocator.is_initialized() &amp;&amp; _mark.is_initialized();
  }
  
  size_t ZHeap::min_capacity() const {
<span class="line-modified">!   return heap_min_size();</span>
  }
  
  size_t ZHeap::max_capacity() const {
    return _page_allocator.max_capacity();
  }
  
<span class="line-modified">! size_t ZHeap::current_max_capacity() const {</span>
<span class="line-modified">!   return _page_allocator.current_max_capacity();</span>
  }
  
  size_t ZHeap::capacity() const {
    return _page_allocator.capacity();
  }
<span class="line-new-header">--- 97,19 ---</span>
  bool ZHeap::is_initialized() const {
    return _page_allocator.is_initialized() &amp;&amp; _mark.is_initialized();
  }
  
  size_t ZHeap::min_capacity() const {
<span class="line-modified">!   return _page_allocator.min_capacity();</span>
  }
  
  size_t ZHeap::max_capacity() const {
    return _page_allocator.max_capacity();
  }
  
<span class="line-modified">! size_t ZHeap::soft_max_capacity() const {</span>
<span class="line-modified">!   return _page_allocator.soft_max_capacity();</span>
  }
  
  size_t ZHeap::capacity() const {
    return _page_allocator.capacity();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,10 ***</span>
<span class="line-new-header">--- 128,14 ---</span>
  
  size_t ZHeap::used() const {
    return _page_allocator.used();
  }
  
<span class="line-added">+ size_t ZHeap::unused() const {</span>
<span class="line-added">+   return _page_allocator.unused();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  size_t ZHeap::allocated() const {
    return _page_allocator.allocated();
  }
  
  size_t ZHeap::reclaimed() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,32 ***</span>
  
    return MIN2(size, max_tlab_size());
  }
  
  bool ZHeap::is_in(uintptr_t addr) const {
<span class="line-modified">!   if (addr &lt; ZAddressReservedStart() || addr &gt;= ZAddressReservedEnd()) {</span>
<span class="line-modified">!     return false;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const ZPage* const page = _pagetable.get(addr);</span>
<span class="line-modified">!   if (page != NULL) {</span>
<span class="line-modified">!     return page-&gt;is_in(addr);</span>
    }
  
    return false;
  }
  
<span class="line-removed">- uintptr_t ZHeap::block_start(uintptr_t addr) const {</span>
<span class="line-removed">-   const ZPage* const page = _pagetable.get(addr);</span>
<span class="line-removed">-   return page-&gt;block_start(addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ZHeap::block_is_obj(uintptr_t addr) const {</span>
<span class="line-removed">-   const ZPage* const page = _pagetable.get(addr);</span>
<span class="line-removed">-   return page-&gt;block_is_obj(addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  uint ZHeap::nconcurrent_worker_threads() const {
    return _workers.nconcurrent();
  }
  
  uint ZHeap::nconcurrent_no_boost_worker_threads() const {
<span class="line-new-header">--- 168,26 ---</span>
  
    return MIN2(size, max_tlab_size());
  }
  
  bool ZHeap::is_in(uintptr_t addr) const {
<span class="line-modified">!   // An address is considered to be &quot;in the heap&quot; if it points into</span>
<span class="line-modified">!   // the allocated part of a page, regardless of which heap view is</span>
<span class="line-modified">!   // used. Note that an address with the finalizable metadata bit set</span>
<span class="line-modified">!   // is not pointing into a heap view, and therefore not considered</span>
<span class="line-modified">!   // to be &quot;in the heap&quot;.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (ZAddress::is_in(addr)) {</span>
<span class="line-added">+     const ZPage* const page = _page_table.get(addr);</span>
<span class="line-added">+     if (page != NULL) {</span>
<span class="line-added">+       return page-&gt;is_in(addr);</span>
<span class="line-added">+     }</span>
    }
  
    return false;
  }
  
  uint ZHeap::nconcurrent_worker_threads() const {
    return _workers.nconcurrent();
  }
  
  uint ZHeap::nconcurrent_no_boost_worker_threads() const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,12 ***</span>
  }
  
  ZPage* ZHeap::alloc_page(uint8_t type, size_t size, ZAllocationFlags flags) {
    ZPage* const page = _page_allocator.alloc_page(type, size, flags);
    if (page != NULL) {
<span class="line-modified">!     // Update pagetable</span>
<span class="line-modified">!     _pagetable.insert(page);</span>
    }
  
    return page;
  }
  
<span class="line-new-header">--- 214,12 ---</span>
  }
  
  ZPage* ZHeap::alloc_page(uint8_t type, size_t size, ZAllocationFlags flags) {
    ZPage* const page = _page_allocator.alloc_page(type, size, flags);
    if (page != NULL) {
<span class="line-modified">!     // Insert page table entry</span>
<span class="line-modified">!     _page_table.insert(page);</span>
    }
  
    return page;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,48 ***</span>
  
    ZStatInc(ZCounterUndoPageAllocation);
    log_trace(gc)(&quot;Undo page allocation, thread: &quot; PTR_FORMAT &quot; (%s), page: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT,
                  ZThread::id(), ZThread::name(), p2i(page), page-&gt;size());
  
<span class="line-modified">!   release_page(page, false /* reclaimed */);</span>
  }
  
<span class="line-modified">! bool ZHeap::retain_page(ZPage* page) {</span>
<span class="line-modified">!   return page-&gt;inc_refcount();</span>
  }
  
<span class="line-modified">! void ZHeap::release_page(ZPage* page, bool reclaimed) {</span>
<span class="line-modified">!   if (page-&gt;dec_refcount()) {</span>
<span class="line-removed">-     _page_allocator.free_page(page, reclaimed);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-modified">! void ZHeap::flip_views() {</span>
<span class="line-modified">!   // For debugging only</span>
<span class="line-modified">!   if (ZUnmapBadViews) {</span>
<span class="line-modified">!     // Flip pages</span>
<span class="line-removed">-     ZPageTableIterator iter(&amp;_pagetable);</span>
<span class="line-removed">-     for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="line-removed">-       if (!page-&gt;is_detached()) {</span>
<span class="line-removed">-         _page_allocator.flip_page(page);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Flip pre-mapped memory</span>
<span class="line-modified">!     _page_allocator.flip_pre_mapped();</span>
<span class="line-modified">!   }</span>
  }
  
  void ZHeap::mark_start() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
    // Update statistics
    ZStatSample(ZSamplerHeapUsedBeforeMark, used());
  
    // Flip address view
<span class="line-modified">!   ZAddressMasks::flip_to_marked();</span>
<span class="line-removed">-   flip_views();</span>
  
    // Retire allocating pages
    _object_allocator.retire_pages();
  
    // Reset allocated/reclaimed/used statistics
<span class="line-new-header">--- 228,43 ---</span>
  
    ZStatInc(ZCounterUndoPageAllocation);
    log_trace(gc)(&quot;Undo page allocation, thread: &quot; PTR_FORMAT &quot; (%s), page: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT,
                  ZThread::id(), ZThread::name(), p2i(page), page-&gt;size());
  
<span class="line-modified">!   free_page(page, false /* reclaimed */);</span>
  }
  
<span class="line-modified">! void ZHeap::free_page(ZPage* page, bool reclaimed) {</span>
<span class="line-modified">!   // Remove page table entry</span>
<span class="line-added">+   _page_table.remove(page);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Free page</span>
<span class="line-added">+   _page_allocator.free_page(page, reclaimed);</span>
  }
  
<span class="line-modified">! uint64_t ZHeap::uncommit(uint64_t delay) {</span>
<span class="line-modified">!   return _page_allocator.uncommit(delay);</span>
  }
  
<span class="line-modified">! void ZHeap::flip_to_marked() {</span>
<span class="line-modified">!   ZVerifyViewsFlip flip(&amp;_page_allocator);</span>
<span class="line-modified">!   ZAddress::flip_to_marked();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void ZHeap::flip_to_remapped() {</span>
<span class="line-modified">!   ZVerifyViewsFlip flip(&amp;_page_allocator);</span>
<span class="line-modified">!   ZAddress::flip_to_remapped();</span>
  }
  
  void ZHeap::mark_start() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
    // Update statistics
    ZStatSample(ZSamplerHeapUsedBeforeMark, used());
  
    // Flip address view
<span class="line-modified">!   flip_to_marked();</span>
  
    // Retire allocating pages
    _object_allocator.retire_pages();
  
    // Reset allocated/reclaimed/used statistics
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,131 ***</span>
  
    // Reset marking information and mark roots
    _mark.start();
  
    // Update statistics
<span class="line-modified">!   ZStatHeap::set_at_mark_start(capacity(), used());</span>
  }
  
  void ZHeap::mark(bool initial) {
    _mark.mark(initial);
  }
  
  void ZHeap::mark_flush_and_free(Thread* thread) {
    _mark.flush_and_free(thread);
  }
  
<span class="line-removed">- class ZFixupPartialLoadsClosure : public ZRootsIteratorClosure {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   virtual void do_oop(oop* p) {</span>
<span class="line-removed">-     ZBarrier::mark_barrier_on_root_oop_field(p);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual void do_oop(narrowOop* p) {</span>
<span class="line-removed">-     ShouldNotReachHere();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ZFixupPartialLoadsTask : public ZTask {</span>
<span class="line-removed">- private:</span>
<span class="line-removed">-   ZThreadRootsIterator _thread_roots;</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ZFixupPartialLoadsTask() :</span>
<span class="line-removed">-       ZTask(&quot;ZFixupPartialLoadsTask&quot;),</span>
<span class="line-removed">-       _thread_roots() {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual void work() {</span>
<span class="line-removed">-     ZFixupPartialLoadsClosure cl;</span>
<span class="line-removed">-     _thread_roots.oops_do(&amp;cl);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZHeap::fixup_partial_loads() {</span>
<span class="line-removed">-   ZFixupPartialLoadsTask task;</span>
<span class="line-removed">-   _workers.run_parallel(&amp;task);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool ZHeap::mark_end() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="line-removed">-   // C2 can generate code where a safepoint poll is inserted</span>
<span class="line-removed">-   // between a load and the associated load barrier. To handle</span>
<span class="line-removed">-   // this case we need to rescan the thread stack here to make</span>
<span class="line-removed">-   // sure such oops are marked.</span>
<span class="line-removed">-   fixup_partial_loads();</span>
<span class="line-removed">- </span>
    // Try end marking
    if (!_mark.end()) {
      // Marking not completed, continue concurrent mark
      return false;
    }
  
    // Enter mark completed phase
    ZGlobalPhase = ZPhaseMarkCompleted;
  
    // Update statistics
    ZStatSample(ZSamplerHeapUsedAfterMark, used());
    ZStatHeap::set_at_mark_end(capacity(), allocated(), used());
  
    // Block resurrection of weak/phantom references
    ZResurrection::block();
  
    // Process weak roots
    _weak_roots_processor.process_weak_roots();
  
<span class="line-modified">!   // Prepare to unload unused classes and code</span>
    _unload.prepare();
  
    return true;
  }
  
  void ZHeap::set_soft_reference_policy(bool clear) {
    _reference_processor.set_soft_reference_policy(clear);
  }
  
  void ZHeap::process_non_strong_references() {
    // Process Soft/Weak/Final/PhantomReferences
    _reference_processor.process_references();
  
    // Process concurrent weak roots
    _weak_roots_processor.process_concurrent_weak_roots();
  
<span class="line-modified">!   // Unload unused classes and code</span>
<span class="line-modified">!   _unload.unload();</span>
  
    // Unblock resurrection of weak/phantom references
    ZResurrection::unblock();
  
    // Enqueue Soft/Weak/Final/PhantomReferences. Note that this
    // must be done after unblocking resurrection. Otherwise the
    // Finalizer thread could call Reference.get() on the Finalizers
    // that were just enqueued, which would incorrectly return null
    // during the resurrection block window, since such referents
    // are only Finalizable marked.
    _reference_processor.enqueue_references();
  }
  
<span class="line-removed">- void ZHeap::destroy_detached_pages() {</span>
<span class="line-removed">-   ZList&lt;ZPage&gt; list;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   _page_allocator.flush_detached_pages(&amp;list);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (ZPage* page = list.remove_first(); page != NULL; page = list.remove_first()) {</span>
<span class="line-removed">-     // Remove pagetable entry</span>
<span class="line-removed">-     _pagetable.remove(page);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Delete the page</span>
<span class="line-removed">-     _page_allocator.destroy_page(page);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ZHeap::select_relocation_set() {
    // Register relocatable pages with selector
    ZRelocationSetSelector selector;
<span class="line-modified">!   ZPageTableIterator iter(&amp;_pagetable);</span>
<span class="line-modified">!   for (ZPage* page; iter.next(&amp;page);) {</span>
      if (!page-&gt;is_relocatable()) {
        // Not relocatable, don&#39;t register
        continue;
      }
  
<span class="line-new-header">--- 278,112 ---</span>
  
    // Reset marking information and mark roots
    _mark.start();
  
    // Update statistics
<span class="line-modified">!   ZStatHeap::set_at_mark_start(soft_max_capacity(), capacity(), used());</span>
  }
  
  void ZHeap::mark(bool initial) {
    _mark.mark(initial);
  }
  
  void ZHeap::mark_flush_and_free(Thread* thread) {
    _mark.flush_and_free(thread);
  }
  
  bool ZHeap::mark_end() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
    // Try end marking
    if (!_mark.end()) {
      // Marking not completed, continue concurrent mark
      return false;
    }
  
    // Enter mark completed phase
    ZGlobalPhase = ZPhaseMarkCompleted;
  
<span class="line-added">+   // Verify after mark</span>
<span class="line-added">+   ZVerify::after_mark();</span>
<span class="line-added">+ </span>
    // Update statistics
    ZStatSample(ZSamplerHeapUsedAfterMark, used());
    ZStatHeap::set_at_mark_end(capacity(), allocated(), used());
  
    // Block resurrection of weak/phantom references
    ZResurrection::block();
  
    // Process weak roots
    _weak_roots_processor.process_weak_roots();
  
<span class="line-modified">!   // Prepare to unload stale metadata and nmethods</span>
    _unload.prepare();
  
    return true;
  }
  
<span class="line-added">+ void ZHeap::keep_alive(oop obj) {</span>
<span class="line-added">+   ZBarrier::keep_alive_barrier_on_oop(obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ZHeap::set_soft_reference_policy(bool clear) {
    _reference_processor.set_soft_reference_policy(clear);
  }
  
<span class="line-added">+ class ZRendezvousClosure : public HandshakeClosure {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ZRendezvousClosure() :</span>
<span class="line-added">+       HandshakeClosure(&quot;ZRendezvous&quot;) {}</span>
<span class="line-added">+ </span>
<span class="line-added">+   void do_thread(Thread* thread) {}</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  void ZHeap::process_non_strong_references() {
    // Process Soft/Weak/Final/PhantomReferences
    _reference_processor.process_references();
  
    // Process concurrent weak roots
    _weak_roots_processor.process_concurrent_weak_roots();
  
<span class="line-modified">!   // Unlink stale metadata and nmethods</span>
<span class="line-modified">!   _unload.unlink();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Perform a handshake. This is needed 1) to make sure that stale</span>
<span class="line-added">+   // metadata and nmethods are no longer observable. And 2), to</span>
<span class="line-added">+   // prevent the race where a mutator first loads an oop, which is</span>
<span class="line-added">+   // logically null but not yet cleared. Then this oop gets cleared</span>
<span class="line-added">+   // by the reference processor and resurrection is unblocked. At</span>
<span class="line-added">+   // this point the mutator could see the unblocked state and pass</span>
<span class="line-added">+   // this invalid oop through the normal barrier path, which would</span>
<span class="line-added">+   // incorrectly try to mark the oop.</span>
<span class="line-added">+   ZRendezvousClosure cl;</span>
<span class="line-added">+   Handshake::execute(&amp;cl);</span>
  
    // Unblock resurrection of weak/phantom references
    ZResurrection::unblock();
  
<span class="line-added">+   // Purge stale metadata and nmethods that were unlinked</span>
<span class="line-added">+   _unload.purge();</span>
<span class="line-added">+ </span>
    // Enqueue Soft/Weak/Final/PhantomReferences. Note that this
    // must be done after unblocking resurrection. Otherwise the
    // Finalizer thread could call Reference.get() on the Finalizers
    // that were just enqueued, which would incorrectly return null
    // during the resurrection block window, since such referents
    // are only Finalizable marked.
    _reference_processor.enqueue_references();
  }
  
  void ZHeap::select_relocation_set() {
<span class="line-added">+   // Do not allow pages to be deleted</span>
<span class="line-added">+   _page_allocator.enable_deferred_delete();</span>
<span class="line-added">+ </span>
    // Register relocatable pages with selector
    ZRelocationSetSelector selector;
<span class="line-modified">!   ZPageTableIterator pt_iter(&amp;_page_table);</span>
<span class="line-modified">!   for (ZPage* page; pt_iter.next(&amp;page);) {</span>
      if (!page-&gt;is_relocatable()) {
        // Not relocatable, don&#39;t register
        continue;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,55 ***</span>
      } else {
        // Register garbage page
        selector.register_garbage_page(page);
  
        // Reclaim page immediately
<span class="line-modified">!       release_page(page, true /* reclaimed */);</span>
      }
    }
  
    // Select pages to relocate
    selector.select(&amp;_relocation_set);
  
<span class="line-modified">!   // Update statistics</span>
<span class="line-modified">!   ZStatRelocation::set_at_select_relocation_set(selector.relocating());</span>
<span class="line-modified">!   ZStatHeap::set_at_select_relocation_set(selector.live(),</span>
<span class="line-modified">!                                           selector.garbage(),</span>
<span class="line-removed">-                                           reclaimed());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZHeap::prepare_relocation_set() {</span>
<span class="line-removed">-   ZRelocationSetIterator iter(&amp;_relocation_set);</span>
<span class="line-removed">-   for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="line-removed">-     // Prepare for relocation</span>
<span class="line-removed">-     page-&gt;set_forwarding();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Update pagetable</span>
<span class="line-removed">-     _pagetable.set_relocating(page);</span>
    }
  }
  
  void ZHeap::reset_relocation_set() {
    ZRelocationSetIterator iter(&amp;_relocation_set);
<span class="line-modified">!   for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="line-modified">!     // Reset relocation information</span>
<span class="line-removed">-     page-&gt;reset_forwarding();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Update pagetable</span>
<span class="line-removed">-     _pagetable.clear_relocating(page);</span>
    }
  }
  
  void ZHeap::relocate_start() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="line-modified">!   // Finish unloading of classes and code</span>
    _unload.finish();
  
    // Flip address view
<span class="line-modified">!   ZAddressMasks::flip_to_remapped();</span>
<span class="line-removed">-   flip_views();</span>
  
    // Enter relocate phase
    ZGlobalPhase = ZPhaseRelocate;
  
    // Update statistics
<span class="line-new-header">--- 393,50 ---</span>
      } else {
        // Register garbage page
        selector.register_garbage_page(page);
  
        // Reclaim page immediately
<span class="line-modified">!       free_page(page, true /* reclaimed */);</span>
      }
    }
  
<span class="line-added">+   // Allow pages to be deleted</span>
<span class="line-added">+   _page_allocator.disable_deferred_delete();</span>
<span class="line-added">+ </span>
    // Select pages to relocate
    selector.select(&amp;_relocation_set);
  
<span class="line-modified">!   // Setup forwarding table</span>
<span class="line-modified">!   ZRelocationSetIterator rs_iter(&amp;_relocation_set);</span>
<span class="line-modified">!   for (ZForwarding* forwarding; rs_iter.next(&amp;forwarding);) {</span>
<span class="line-modified">!     _forwarding_table.insert(forwarding);</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Update statistics</span>
<span class="line-added">+   ZStatRelocation::set_at_select_relocation_set(selector.stats());</span>
<span class="line-added">+   ZStatHeap::set_at_select_relocation_set(selector.stats(), reclaimed());</span>
  }
  
  void ZHeap::reset_relocation_set() {
<span class="line-added">+   // Reset forwarding table</span>
    ZRelocationSetIterator iter(&amp;_relocation_set);
<span class="line-modified">!   for (ZForwarding* forwarding; iter.next(&amp;forwarding);) {</span>
<span class="line-modified">!     _forwarding_table.remove(forwarding);</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   // Reset relocation set</span>
<span class="line-added">+   _relocation_set.reset();</span>
  }
  
  void ZHeap::relocate_start() {
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="line-modified">!   // Finish unloading stale metadata and nmethods</span>
    _unload.finish();
  
    // Flip address view
<span class="line-modified">!   flip_to_remapped();</span>
  
    // Enter relocate phase
    ZGlobalPhase = ZPhaseRelocate;
  
    // Update statistics
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,29 ***</span>
  
    // Remap/Relocate roots
    _relocate.start();
  }
  
<span class="line-removed">- uintptr_t ZHeap::relocate_object(uintptr_t addr) {</span>
<span class="line-removed">-   assert(ZGlobalPhase == ZPhaseRelocate, &quot;Relocate not allowed&quot;);</span>
<span class="line-removed">-   ZPage* const page = _pagetable.get(addr);</span>
<span class="line-removed">-   const bool retained = retain_page(page);</span>
<span class="line-removed">-   const uintptr_t new_addr = page-&gt;relocate_object(addr);</span>
<span class="line-removed">-   if (retained) {</span>
<span class="line-removed">-     release_page(page, true /* reclaimed */);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return new_addr;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uintptr_t ZHeap::forward_object(uintptr_t addr) {</span>
<span class="line-removed">-   assert(ZGlobalPhase == ZPhaseMark ||</span>
<span class="line-removed">-          ZGlobalPhase == ZPhaseMarkCompleted, &quot;Forward not allowed&quot;);</span>
<span class="line-removed">-   ZPage* const page = _pagetable.get(addr);</span>
<span class="line-removed">-   return page-&gt;forward_object(addr);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ZHeap::relocate() {
    // Relocate relocation set
    const bool success = _relocate.relocate(&amp;_relocation_set);
  
    // Update statistics
<span class="line-new-header">--- 445,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,15 ***</span>
    ZStatRelocation::set_at_relocate_end(success);
    ZStatHeap::set_at_relocate_end(capacity(), allocated(), reclaimed(),
                                   used(), used_high(), used_low());
  }
  
<span class="line-modified">! void ZHeap::object_iterate(ObjectClosure* cl, bool visit_referents) {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="line-modified">!   ZHeapIterator iter(visit_referents);</span>
<span class="line-modified">!   iter.objects_do(cl);</span>
  }
  
  void ZHeap::serviceability_initialize() {
    _serviceability.initialize();
  }
<span class="line-new-header">--- 456,23 ---</span>
    ZStatRelocation::set_at_relocate_end(success);
    ZStatHeap::set_at_relocate_end(capacity(), allocated(), reclaimed(),
                                   used(), used_high(), used_low());
  }
  
<span class="line-modified">! void ZHeap::object_iterate(ObjectClosure* cl, bool visit_weaks) {</span>
    assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
  
<span class="line-modified">!   ZHeapIterator iter;</span>
<span class="line-modified">!   iter.objects_do(cl, visit_weaks);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ZHeap::pages_do(ZPageClosure* cl) {</span>
<span class="line-added">+   ZPageTableIterator iter(&amp;_page_table);</span>
<span class="line-added">+   for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="line-added">+     cl-&gt;do_page(page);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _page_allocator.pages_do(cl);</span>
  }
  
  void ZHeap::serviceability_initialize() {
    _serviceability.initialize();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,47 ***</span>
  
  void ZHeap::print_extended_on(outputStream* st) const {
    print_on(st);
    st-&gt;cr();
  
<span class="line-modified">!   ZPageTableIterator iter(&amp;_pagetable);</span>
    for (ZPage* page; iter.next(&amp;page);) {
      page-&gt;print_on(st);
    }
  
    st-&gt;cr();
  }
  
<span class="line-modified">! class ZVerifyRootsTask : public ZTask {</span>
<span class="line-modified">! private:</span>
<span class="line-modified">!   ZRootsIterator     _strong_roots;</span>
<span class="line-modified">!   ZWeakRootsIterator _weak_roots;</span>
<span class="line-modified">! </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   ZVerifyRootsTask() :</span>
<span class="line-removed">-       ZTask(&quot;ZVerifyRootsTask&quot;),</span>
<span class="line-removed">-       _strong_roots(),</span>
<span class="line-removed">-       _weak_roots() {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual void work() {</span>
<span class="line-removed">-     ZVerifyOopClosure cl;</span>
<span class="line-removed">-     _strong_roots.oops_do(&amp;cl);</span>
<span class="line-removed">-     _weak_roots.oops_do(&amp;cl);</span>
    }
<span class="line-modified">! };</span>
  
  void ZHeap::verify() {
    // Heap verification can only be done between mark end and
    // relocate start. This is the only window where all oop are
    // good and the whole heap is in a consistent state.
    guarantee(ZGlobalPhase == ZPhaseMarkCompleted, &quot;Invalid phase&quot;);
  
<span class="line-modified">!   {</span>
<span class="line-removed">-     ZVerifyRootsTask task;</span>
<span class="line-removed">-     _workers.run_parallel(&amp;task);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     ZVerifyObjectClosure cl;</span>
<span class="line-removed">-     object_iterate(&amp;cl, false /* visit_referents */);</span>
<span class="line-removed">-   }</span>
  }
<span class="line-new-header">--- 499,38 ---</span>
  
  void ZHeap::print_extended_on(outputStream* st) const {
    print_on(st);
    st-&gt;cr();
  
<span class="line-modified">!   // Do not allow pages to be deleted</span>
<span class="line-added">+   _page_allocator.enable_deferred_delete();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Print all pages</span>
<span class="line-added">+   ZPageTableIterator iter(&amp;_page_table);</span>
    for (ZPage* page; iter.next(&amp;page);) {
      page-&gt;print_on(st);
    }
  
<span class="line-added">+   // Allow pages to be deleted</span>
<span class="line-added">+   _page_allocator.enable_deferred_delete();</span>
<span class="line-added">+ </span>
    st-&gt;cr();
  }
  
<span class="line-modified">! bool ZHeap::print_location(outputStream* st, uintptr_t addr) const {</span>
<span class="line-modified">!   if (LocationPrinter::is_valid_obj((void*)addr)) {</span>
<span class="line-modified">!     st-&gt;print(PTR_FORMAT &quot; is a %s oop: &quot;, addr, ZAddress::is_good(addr) ? &quot;good&quot; : &quot;bad&quot;);</span>
<span class="line-modified">!     ZOop::from_address(addr)-&gt;print_on(st);</span>
<span class="line-modified">!     return true;</span>
    }
<span class="line-modified">! </span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
  
  void ZHeap::verify() {
    // Heap verification can only be done between mark end and
    // relocate start. This is the only window where all oop are
    // good and the whole heap is in a consistent state.
    guarantee(ZGlobalPhase == ZPhaseMarkCompleted, &quot;Invalid phase&quot;);
  
<span class="line-modified">!   ZVerify::after_weak_processing();</span>
  }
</pre>
<center><a href="zGranuleMap.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zHeap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zMarkStack.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zMarkStack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMarkStack.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zMarkStack.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45   bool push(T value);
 46   bool pop(T&amp; value);
 47 
 48   ZStack&lt;T, S&gt;* next() const;
 49   ZStack&lt;T, S&gt;** next_addr();
 50 };
 51 
 52 template &lt;typename T&gt;
 53 class ZStackList {
 54 private:
 55   T* volatile _head;
 56 
 57   T* encode_versioned_pointer(const T* stack, uint32_t version) const;
 58   void decode_versioned_pointer(const T* vstack, T** stack, uint32_t* version) const;
 59 
 60 public:
 61   ZStackList();
 62 
 63   bool is_empty() const;
 64 
<span class="line-modified"> 65   void push_atomic(T* stack);</span>
<span class="line-modified"> 66   T* pop_atomic();</span>
 67 };
 68 
 69 typedef ZStack&lt;ZMarkStackEntry, ZMarkStackSlots&gt;     ZMarkStack;
 70 typedef ZStackList&lt;ZMarkStack&gt;                       ZMarkStackList;
 71 typedef ZStack&lt;ZMarkStack*, ZMarkStackMagazineSlots&gt; ZMarkStackMagazine;
 72 typedef ZStackList&lt;ZMarkStackMagazine&gt;               ZMarkStackMagazineList;
 73 
 74 class ZMarkStripe {
 75 private:
<span class="line-modified"> 76   ZMarkStackList _published  ATTRIBUTE_ALIGNED(ZCacheLineSize);</span>
<span class="line-modified"> 77   ZMarkStackList _overflowed ATTRIBUTE_ALIGNED(ZCacheLineSize);</span>
 78 
 79 public:
 80   ZMarkStripe();
 81 
 82   bool is_empty() const;
 83 
 84   void publish_stack(ZMarkStack* stack, bool publish = true);
 85   ZMarkStack* steal_stack();
 86 };
 87 
 88 class ZMarkStripeSet {
 89 private:
 90   size_t      _nstripes;
 91   size_t      _nstripes_mask;
 92   ZMarkStripe _stripes[ZMarkStripesMax];
 93 
 94 public:
 95   ZMarkStripeSet();
 96 
 97   size_t nstripes() const;
</pre>
</td>
<td>
<hr />
<pre>
 45   bool push(T value);
 46   bool pop(T&amp; value);
 47 
 48   ZStack&lt;T, S&gt;* next() const;
 49   ZStack&lt;T, S&gt;** next_addr();
 50 };
 51 
 52 template &lt;typename T&gt;
 53 class ZStackList {
 54 private:
 55   T* volatile _head;
 56 
 57   T* encode_versioned_pointer(const T* stack, uint32_t version) const;
 58   void decode_versioned_pointer(const T* vstack, T** stack, uint32_t* version) const;
 59 
 60 public:
 61   ZStackList();
 62 
 63   bool is_empty() const;
 64 
<span class="line-modified"> 65   void push(T* stack);</span>
<span class="line-modified"> 66   T* pop();</span>
 67 };
 68 
 69 typedef ZStack&lt;ZMarkStackEntry, ZMarkStackSlots&gt;     ZMarkStack;
 70 typedef ZStackList&lt;ZMarkStack&gt;                       ZMarkStackList;
 71 typedef ZStack&lt;ZMarkStack*, ZMarkStackMagazineSlots&gt; ZMarkStackMagazine;
 72 typedef ZStackList&lt;ZMarkStackMagazine&gt;               ZMarkStackMagazineList;
 73 
 74 class ZMarkStripe {
 75 private:
<span class="line-modified"> 76   ZCACHE_ALIGNED ZMarkStackList _published;</span>
<span class="line-modified"> 77   ZCACHE_ALIGNED ZMarkStackList _overflowed;</span>
 78 
 79 public:
 80   ZMarkStripe();
 81 
 82   bool is_empty() const;
 83 
 84   void publish_stack(ZMarkStack* stack, bool publish = true);
 85   ZMarkStack* steal_stack();
 86 };
 87 
 88 class ZMarkStripeSet {
 89 private:
 90   size_t      _nstripes;
 91   size_t      _nstripes_mask;
 92   ZMarkStripe _stripes[ZMarkStripesMax];
 93 
 94 public:
 95   ZMarkStripeSet();
 96 
 97   size_t nstripes() const;
</pre>
</td>
</tr>
</table>
<center><a href="zMarkStack.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zMarkStack.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/z/zPage.hpp b/src/hotspot/share/gc/z/zPage.hpp
--- a/src/hotspot/share/gc/z/zPage.hpp
+++ b/src/hotspot/share/gc/z/zPage.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,11 +22,10 @@
  */
 
 #ifndef SHARE_GC_Z_ZPAGE_HPP
 #define SHARE_GC_Z_ZPAGE_HPP
 
-#include "gc/z/zForwardingTable.hpp"
 #include "gc/z/zList.hpp"
 #include "gc/z/zLiveMap.hpp"
 #include "gc/z/zPhysicalMemory.hpp"
 #include "gc/z/zVirtualMemory.hpp"
 #include "memory/allocation.hpp"
@@ -34,96 +33,88 @@
 class ZPage : public CHeapObj<mtGC> {
   friend class VMStructs;
   friend class ZList<ZPage>;
 
 private:
-  // Always hot
-  const uint8_t        _type;             // Page type
-  volatile uint8_t     _pinned;           // Pinned flag
-  uint8_t              _numa_id;          // NUMA node affinity
-  uint32_t             _seqnum;           // Allocation sequence number
-  const ZVirtualMemory _virtual;          // Virtual start/end address
-  volatile uintptr_t   _top;              // Virtual top address
-  ZLiveMap             _livemap;          // Live map
-
-  // Hot when relocated and cached
-  volatile uint32_t    _refcount;         // Page reference count
-  ZForwardingTable     _forwarding;       // Forwarding table
-  ZPhysicalMemory      _physical;         // Physical memory for page
-  ZListNode<ZPage>     _node;             // Page list node
-
+  uint8_t            _type;
+  uint8_t            _numa_id;
+  uint32_t           _seqnum;
+  ZVirtualMemory     _virtual;
+  volatile uintptr_t _top;
+  ZLiveMap           _livemap;
+  uint64_t           _last_used;
+  ZPhysicalMemory    _physical;
+  ZListNode<ZPage>   _node;
+
+  void assert_initialized() const;
+
+  uint8_t type_from_size(size_t size) const;
   const char* type_to_string() const;
-  uint32_t object_max_count() const;
-  uintptr_t relocate_object_inner(uintptr_t from_index, uintptr_t from_offset);
 
   bool is_object_marked(uintptr_t addr) const;
   bool is_object_strongly_marked(uintptr_t addr) const;
 
 public:
-  ZPage(uint8_t type, ZVirtualMemory vmem, ZPhysicalMemory pmem);
+  ZPage(const ZVirtualMemory& vmem, const ZPhysicalMemory& pmem);
+  ZPage(uint8_t type, const ZVirtualMemory& vmem, const ZPhysicalMemory& pmem);
   ~ZPage();
 
+  uint32_t object_max_count() const;
   size_t object_alignment_shift() const;
   size_t object_alignment() const;
 
   uint8_t type() const;
   uintptr_t start() const;
   uintptr_t end() const;
   size_t size() const;
   uintptr_t top() const;
   size_t remaining() const;
 
-  uint8_t numa_id();
-
-  ZPhysicalMemory& physical_memory();
+  const ZPhysicalMemory& physical_memory() const;
   const ZVirtualMemory& virtual_memory() const;
 
-  void reset();
-
-  bool inc_refcount();
-  bool dec_refcount();
-
-  bool is_in(uintptr_t addr) const;
-
-  uintptr_t block_start(uintptr_t addr) const;
-  bool block_is_obj(uintptr_t addr) const;
+  uint8_t numa_id();
 
-  bool is_active() const;
   bool is_allocating() const;
   bool is_relocatable() const;
-  bool is_detached() const;
 
   bool is_mapped() const;
   void set_pre_mapped();
 
-  bool is_pinned() const;
-  void set_pinned();
+  uint64_t last_used() const;
+  void set_last_used();
+
+  void reset();
 
-  bool is_forwarding() const;
-  void set_forwarding();
-  void reset_forwarding();
-  void verify_forwarding() const;
+  ZPage* retype(uint8_t type);
+  ZPage* split(size_t size);
+  ZPage* split(uint8_t type, size_t size);
+
+  bool is_in(uintptr_t addr) const;
 
   bool is_marked() const;
   bool is_object_live(uintptr_t addr) const;
   bool is_object_strongly_live(uintptr_t addr) const;
   bool mark_object(uintptr_t addr, bool finalizable, bool& inc_live);
 
-  void inc_live_atomic(uint32_t objects, size_t bytes);
+  void inc_live(uint32_t objects, size_t bytes);
+  uint32_t live_objects() const;
   size_t live_bytes() const;
 
   void object_iterate(ObjectClosure* cl);
 
   uintptr_t alloc_object(size_t size);
   uintptr_t alloc_object_atomic(size_t size);
 
   bool undo_alloc_object(uintptr_t addr, size_t size);
   bool undo_alloc_object_atomic(uintptr_t addr, size_t size);
 
-  uintptr_t relocate_object(uintptr_t from);
-  uintptr_t forward_object(uintptr_t from);
-
   void print_on(outputStream* out) const;
   void print() const;
 };
 
+class ZPageClosure {
+public:
+  virtual void do_page(const ZPage* page) = 0;
+};
+
 #endif // SHARE_GC_Z_ZPAGE_HPP

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/c2/zBarrierSetC2.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
 25 #define SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
 26 
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;utilities/growableArray.hpp&quot;
 31 
<a name="1" id="anc1"></a><span class="line-modified"> 32 class LoadBarrierNode : public MultiNode {</span>
<span class="line-modified"> 33 private:</span>
<span class="line-modified"> 34   bool _weak;               // On strong or weak oop reference</span>
<span class="line-removed"> 35   bool _writeback;          // Controls if the barrier writes the healed oop back to memory</span>
<span class="line-removed"> 36                             // A swap on a memory location must never write back the healed oop</span>
<span class="line-removed"> 37   bool _oop_reload_allowed; // Controls if the barrier are allowed to reload the oop from memory</span>
<span class="line-removed"> 38                             // before healing, otherwise both the oop and the address must be</span>
<span class="line-removed"> 39                             // passed to the barrier from the oop</span>
<span class="line-removed"> 40 </span>
<span class="line-removed"> 41   static bool is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n);</span>
<span class="line-removed"> 42   void push_dominated_barriers(PhaseIterGVN* igvn) const;</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44 public:</span>
<span class="line-removed"> 45   enum {</span>
<span class="line-removed"> 46     Control,</span>
<span class="line-removed"> 47     Memory,</span>
<span class="line-removed"> 48     Oop,</span>
<span class="line-removed"> 49     Address,</span>
<span class="line-removed"> 50     Number_of_Outputs = Address,</span>
<span class="line-removed"> 51     Similar,</span>
<span class="line-removed"> 52     Number_of_Inputs</span>
<span class="line-removed"> 53   };</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55   LoadBarrierNode(Compile* C,</span>
<span class="line-removed"> 56                   Node* c,</span>
<span class="line-removed"> 57                   Node* mem,</span>
<span class="line-removed"> 58                   Node* val,</span>
<span class="line-removed"> 59                   Node* adr,</span>
<span class="line-removed"> 60                   bool weak,</span>
<span class="line-removed"> 61                   bool writeback,</span>
<span class="line-removed"> 62                   bool oop_reload_allowed);</span>
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64   virtual int Opcode() const;</span>
<span class="line-removed"> 65   virtual uint size_of() const;</span>
<span class="line-removed"> 66   virtual uint cmp(const Node&amp; n) const;</span>
<span class="line-removed"> 67   virtual const Type *bottom_type() const;</span>
<span class="line-removed"> 68   virtual const TypePtr* adr_type() const;</span>
<span class="line-removed"> 69   virtual const Type *Value(PhaseGVN *phase) const;</span>
<span class="line-removed"> 70   virtual Node *Identity(PhaseGVN *phase);</span>
<span class="line-removed"> 71   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);</span>
<span class="line-removed"> 72   virtual uint match_edge(uint idx) const;</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   LoadBarrierNode* has_dominating_barrier(PhaseIdealLoop* phase,</span>
<span class="line-removed"> 75                                           bool linear_only,</span>
<span class="line-removed"> 76                                           bool look_for_similar);</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78   void fix_similar_in_uses(PhaseIterGVN* igvn);</span>
<span class="line-removed"> 79 </span>
<span class="line-removed"> 80   bool has_true_uses() const;</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82   bool can_be_eliminated() const {</span>
<span class="line-removed"> 83     return !in(Similar)-&gt;is_top();</span>
<span class="line-removed"> 84   }</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86   bool is_weak() const {</span>
<span class="line-removed"> 87     return _weak;</span>
<span class="line-removed"> 88   }</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90   bool is_writeback() const {</span>
<span class="line-removed"> 91     return _writeback;</span>
<span class="line-removed"> 92   }</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94   bool oop_reload_allowed() const {</span>
<span class="line-removed"> 95     return _oop_reload_allowed;</span>
<span class="line-removed"> 96   }</span>
<span class="line-removed"> 97 };</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99 class LoadBarrierSlowRegNode : public LoadPNode {</span>
<span class="line-removed">100 public:</span>
<span class="line-removed">101   LoadBarrierSlowRegNode(Node *c,</span>
<span class="line-removed">102                          Node *mem,</span>
<span class="line-removed">103                          Node *adr,</span>
<span class="line-removed">104                          const TypePtr *at,</span>
<span class="line-removed">105                          const TypePtr* t,</span>
<span class="line-removed">106                          MemOrd mo,</span>
<span class="line-removed">107                          ControlDependency control_dependency = DependsOnlyOnTest) :</span>
<span class="line-removed">108       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {</span>
<span class="line-removed">109     init_class_id(Class_LoadBarrierSlowReg);</span>
<span class="line-removed">110   }</span>
<span class="line-removed">111 </span>
<span class="line-removed">112   virtual const char * name() {</span>
<span class="line-removed">113     return &quot;LoadBarrierSlowRegNode&quot;;</span>
<span class="line-removed">114   }</span>
115 
<a name="2" id="anc2"></a><span class="line-modified">116   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed">117     return NULL;</span>
<span class="line-removed">118   }</span>
<span class="line-removed">119 </span>
<span class="line-removed">120   virtual int Opcode() const;</span>
<span class="line-removed">121 };</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 class LoadBarrierWeakSlowRegNode : public LoadPNode {</span>
<span class="line-removed">124 public:</span>
<span class="line-removed">125   LoadBarrierWeakSlowRegNode(Node *c,</span>
<span class="line-removed">126                              Node *mem,</span>
<span class="line-removed">127                              Node *adr,</span>
<span class="line-removed">128                              const TypePtr *at,</span>
<span class="line-removed">129                              const TypePtr* t,</span>
<span class="line-removed">130                              MemOrd mo,</span>
<span class="line-removed">131                              ControlDependency control_dependency = DependsOnlyOnTest) :</span>
<span class="line-removed">132       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {</span>
<span class="line-removed">133     init_class_id(Class_LoadBarrierWeakSlowReg);</span>
<span class="line-removed">134   }</span>
<span class="line-removed">135 </span>
<span class="line-removed">136   virtual const char * name() {</span>
<span class="line-removed">137     return &quot;LoadBarrierWeakSlowRegNode&quot;;</span>
<span class="line-removed">138   }</span>
<span class="line-removed">139 </span>
<span class="line-removed">140   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed">141     return NULL;</span>
<span class="line-removed">142   }</span>
<span class="line-removed">143 </span>
<span class="line-removed">144   virtual int Opcode() const;</span>
<span class="line-removed">145 };</span>
<span class="line-removed">146 </span>
<span class="line-removed">147 class ZBarrierSetC2State : public ResourceObj {</span>
148 private:
<a name="3" id="anc3"></a><span class="line-modified">149   // List of load barrier nodes which need to be expanded before matching</span>
<span class="line-modified">150   GrowableArray&lt;LoadBarrierNode*&gt;* _load_barrier_nodes;</span>







151 
152 public:
<a name="4" id="anc4"></a><span class="line-modified">153   ZBarrierSetC2State(Arena* comp_arena);</span>
<span class="line-modified">154   int load_barrier_count() const;</span>
<span class="line-modified">155   void add_load_barrier_node(LoadBarrierNode* n);</span>
<span class="line-modified">156   void remove_load_barrier_node(LoadBarrierNode* n);</span>
<span class="line-modified">157   LoadBarrierNode* load_barrier_node(int idx) const;</span>




158 };
159 
160 class ZBarrierSetC2 : public BarrierSetC2 {
161 private:
<a name="5" id="anc5"></a><span class="line-modified">162   ZBarrierSetC2State* state() const;</span>
<span class="line-modified">163   Node* make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const;</span>
<span class="line-removed">164   Node* make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const;</span>
<span class="line-removed">165   void expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;</span>
<span class="line-removed">166   void expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const;</span>
<span class="line-removed">167   void expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;</span>
<span class="line-removed">168   const TypeFunc* load_barrier_Type() const;</span>
<span class="line-removed">169 </span>
<span class="line-removed">170 #ifdef ASSERT</span>
<span class="line-removed">171   void verify_gc_barriers(bool post_parse) const;</span>
<span class="line-removed">172 #endif</span>
173 
174 protected:
175   virtual Node* load_at_resolved(C2Access&amp; access, const Type* val_type) const;
176   virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access,
177                                                Node* expected_val,
178                                                Node* new_val,
179                                                const Type* val_type) const;
180   virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess&amp; access,
181                                                 Node* expected_val,
182                                                 Node* new_val,
183                                                 const Type* value_type) const;
184   virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access,
185                                         Node* new_val,
186                                         const Type* val_type) const;
187 
188 public:
<a name="6" id="anc6"></a><span class="line-removed">189   Node* load_barrier(GraphKit* kit,</span>
<span class="line-removed">190                      Node* val,</span>
<span class="line-removed">191                      Node* adr,</span>
<span class="line-removed">192                      bool weak = false,</span>
<span class="line-removed">193                      bool writeback = true,</span>
<span class="line-removed">194                      bool oop_reload_allowed = true) const;</span>
<span class="line-removed">195 </span>
196   virtual void* create_barrier_state(Arena* comp_arena) const;
<a name="7" id="anc7"></a><span class="line-modified">197   virtual bool has_load_barriers() const { return true; }</span>
<span class="line-modified">198   virtual bool is_gc_barrier_node(Node* node) const;</span>
<span class="line-modified">199   virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const { }</span>
<span class="line-modified">200   virtual void eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const;</span>
<span class="line-modified">201   virtual void add_users_to_worklist(Unique_Node_List* worklist) const;</span>
<span class="line-modified">202   virtual void enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const;</span>
<span class="line-modified">203   virtual void register_potential_barrier_node(Node* node) const;</span>
<span class="line-modified">204   virtual void unregister_potential_barrier_node(Node* node) const;</span>
<span class="line-modified">205   virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const;</span>
<span class="line-modified">206   virtual Node* step_over_gc_barrier(Node* c) const;</span>
<span class="line-removed">207   // If the BarrierSetC2 state has kept barrier nodes in its compilation unit state to be</span>
<span class="line-removed">208   // expanded later, then now is the time to do so.</span>
<span class="line-removed">209   virtual bool expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const;</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   static void find_dominating_barriers(PhaseIterGVN&amp; igvn);</span>
<span class="line-removed">212   static void loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round);</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const;</span>
<span class="line-removed">215 </span>
<span class="line-removed">216   virtual bool matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const;</span>
<span class="line-removed">217 </span>
<span class="line-removed">218 #ifdef ASSERT</span>
<span class="line-removed">219   virtual void verify_gc_barriers(Compile* compile, CompilePhase phase) const;</span>
<span class="line-removed">220 #endif</span>
<span class="line-removed">221 </span>
<span class="line-removed">222   virtual bool escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const;</span>
<span class="line-removed">223   virtual bool escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const;</span>
224 };
225 
226 #endif // SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
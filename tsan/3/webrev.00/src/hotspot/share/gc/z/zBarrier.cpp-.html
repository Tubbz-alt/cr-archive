<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/z/zBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zHeap.inline.hpp&quot;
 27 #include &quot;gc/z/zOop.inline.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;memory/iterator.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 
 34 bool ZBarrier::during_mark() {
 35   return ZGlobalPhase == ZPhaseMark;
 36 }
 37 
 38 bool ZBarrier::during_relocate() {
 39   return ZGlobalPhase == ZPhaseRelocate;
 40 }
 41 
 42 template &lt;bool finalizable&gt;
 43 bool ZBarrier::should_mark_through(uintptr_t addr) {
 44   // Finalizable marked oops can still exists on the heap after marking
 45   // has completed, in which case we just want to convert this into a
 46   // good oop and not push it on the mark stack.
 47   if (!during_mark()) {
 48     assert(ZAddress::is_marked(addr), &quot;Should be marked&quot;);
 49     assert(ZAddress::is_finalizable(addr), &quot;Should be finalizable&quot;);
 50     return false;
 51   }
 52 
 53   // During marking, we mark through already marked oops to avoid having
 54   // some large part of the object graph hidden behind a pushed, but not
 55   // yet flushed, entry on a mutator mark stack. Always marking through
 56   // allows the GC workers to proceed through the object graph even if a
 57   // mutator touched an oop first, which in turn will reduce the risk of
 58   // having to flush mark stacks multiple times to terminate marking.
 59   //
 60   // However, when doing finalizable marking we don&#39;t always want to mark
 61   // through. First, marking through an already strongly marked oop would
 62   // be wasteful, since we will then proceed to do finalizable marking on
 63   // an object which is, or will be, marked strongly. Second, marking
 64   // through an already finalizable marked oop would also be wasteful,
 65   // since such oops can never end up on a mutator mark stack and can
 66   // therefore not hide some part of the object graph from GC workers.
 67   if (finalizable) {
 68     return !ZAddress::is_marked(addr);
 69   }
 70 
 71   // Mark through
 72   return true;
 73 }
 74 
 75 template &lt;bool finalizable, bool publish&gt;
 76 uintptr_t ZBarrier::mark(uintptr_t addr) {
 77   uintptr_t good_addr;
 78 
 79   if (ZAddress::is_marked(addr)) {
 80     // Already marked, but try to mark though anyway
 81     good_addr = ZAddress::good(addr);
 82   } else if (ZAddress::is_remapped(addr)) {
 83     // Already remapped, but also needs to be marked
 84     good_addr = ZAddress::good(addr);
 85   } else {
 86     // Needs to be both remapped and marked
 87     good_addr = remap(addr);
 88   }
 89 
 90   // Mark
 91   if (should_mark_through&lt;finalizable&gt;(addr)) {
 92     ZHeap::heap()-&gt;mark_object&lt;finalizable, publish&gt;(good_addr);
 93   }
 94 
 95   return good_addr;
 96 }
 97 
 98 uintptr_t ZBarrier::remap(uintptr_t addr) {
 99   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
100   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
101 
102   if (ZHeap::heap()-&gt;is_relocating(addr)) {
103     // Forward
104     return ZHeap::heap()-&gt;forward_object(addr);
105   }
106 
107   // Remap
108   return ZAddress::good(addr);
109 }
110 
111 uintptr_t ZBarrier::relocate(uintptr_t addr) {
112   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
113   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
114 
115   if (ZHeap::heap()-&gt;is_relocating(addr)) {
116     // Relocate
117     return ZHeap::heap()-&gt;relocate_object(addr);
118   }
119 
120   // Remap
121   return ZAddress::good(addr);
122 }
123 
124 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
125   return during_relocate() ? relocate(addr) : mark&lt;Strong, Publish&gt;(addr);
126 }
127 
128 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
129   return during_relocate() ? relocate(addr) : remap(addr);
130 }
131 
132 //
133 // Load barrier
134 //
135 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
136   return relocate_or_mark(addr);
137 }
138 
139 void ZBarrier::load_barrier_on_oop_fields(oop o) {
140   assert(ZOop::is_good(o), &quot;Should be good&quot;);
141   ZLoadBarrierOopClosure cl;
142   o-&gt;oop_iterate(&amp;cl);
143 }
144 
145 //
146 // Weak load barrier
147 //
148 uintptr_t ZBarrier::weak_load_barrier_on_oop_slow_path(uintptr_t addr) {
149   return ZAddress::is_weak_good(addr) ? ZAddress::good(addr) : relocate_or_remap(addr);
150 }
151 
152 uintptr_t ZBarrier::weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr) {
153   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
154   if (ZHeap::heap()-&gt;is_object_strongly_live(good_addr)) {
155     return good_addr;
156   }
157 
158   // Not strongly live
159   return 0;
160 }
161 
162 uintptr_t ZBarrier::weak_load_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
163   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
164   if (ZHeap::heap()-&gt;is_object_live(good_addr)) {
165     return good_addr;
166   }
167 
168   // Not live
169   return 0;
170 }
171 
172 //
173 // Keep alive barrier
174 //
175 uintptr_t ZBarrier::keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr) {
176   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
177   assert(ZHeap::heap()-&gt;is_object_strongly_live(good_addr), &quot;Should be live&quot;);
178   return good_addr;
179 }
180 
181 uintptr_t ZBarrier::keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
182   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
183   assert(ZHeap::heap()-&gt;is_object_live(good_addr), &quot;Should be live&quot;);
184   return good_addr;
185 }
186 
187 //
188 // Mark barrier
189 //
190 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
191   return mark&lt;Strong, Overflow&gt;(addr);
192 }
193 
194 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
195   const uintptr_t good_addr = mark&lt;Finalizable, Overflow&gt;(addr);
196   if (ZAddress::is_good(addr)) {
197     // If the oop was already strongly marked/good, then we do
198     // not want to downgrade it to finalizable marked/good.
199     return good_addr;
200   }
201 
202   // Make the oop finalizable marked/good, instead of normal marked/good.
203   // This is needed because an object might first becomes finalizable
204   // marked by the GC, and then loaded by a mutator thread. In this case,
205   // the mutator thread must be able to tell that the object needs to be
206   // strongly marked. The finalizable bit in the oop exists to make sure
207   // that a load of a finalizable marked oop will fall into the barrier
208   // slow path so that we can mark the object as strongly reachable.
209   return ZAddress::finalizable_good(good_addr);
210 }
211 
212 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
213   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
214   assert(during_mark(), &quot;Invalid phase&quot;);
215 
216   // Mark
217   return mark&lt;Strong, Publish&gt;(addr);
218 }
219 
220 //
221 // Relocate barrier
222 //
223 uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {
224   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
225   assert(during_relocate(), &quot;Invalid phase&quot;);
226 
227   // Relocate
228   return relocate(addr);
229 }
230 
231 //
232 // Narrow oop variants, never used.
233 //
234 oop ZBarrier::load_barrier_on_oop_field(volatile narrowOop* p) {
235   ShouldNotReachHere();
236   return NULL;
237 }
238 
239 oop ZBarrier::load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
240   ShouldNotReachHere();
241   return NULL;
242 }
243 
244 void ZBarrier::load_barrier_on_oop_array(volatile narrowOop* p, size_t length) {
245   ShouldNotReachHere();
246 }
247 
248 oop ZBarrier::load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
249   ShouldNotReachHere();
250   return NULL;
251 }
252 
253 oop ZBarrier::load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
254   ShouldNotReachHere();
255   return NULL;
256 }
257 
258 oop ZBarrier::weak_load_barrier_on_oop_field_preloaded(volatile narrowOop* p, oop o) {
259   ShouldNotReachHere();
260   return NULL;
261 }
262 
263 oop ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(volatile narrowOop* p, oop o) {
264   ShouldNotReachHere();
265   return NULL;
266 }
267 
268 oop ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(volatile narrowOop* p, oop o) {
269   ShouldNotReachHere();
270   return NULL;
271 }
    </pre>
  </body>
</html>
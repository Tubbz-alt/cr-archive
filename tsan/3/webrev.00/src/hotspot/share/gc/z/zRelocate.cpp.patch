diff a/src/hotspot/share/gc/z/zRelocate.cpp b/src/hotspot/share/gc/z/zRelocate.cpp
--- a/src/hotspot/share/gc/z/zRelocate.cpp
+++ b/src/hotspot/share/gc/z/zRelocate.cpp
@@ -22,33 +22,46 @@
  */
 
 #include "precompiled.hpp"
 #include "gc/z/zAddress.inline.hpp"
 #include "gc/z/zBarrier.inline.hpp"
+#include "gc/z/zForwarding.inline.hpp"
 #include "gc/z/zHeap.hpp"
 #include "gc/z/zOopClosures.inline.hpp"
 #include "gc/z/zPage.hpp"
 #include "gc/z/zRelocate.hpp"
 #include "gc/z/zRelocationSet.inline.hpp"
 #include "gc/z/zRootsIterator.hpp"
+#include "gc/z/zStat.hpp"
 #include "gc/z/zTask.hpp"
+#include "gc/z/zThread.inline.hpp"
 #include "gc/z/zThreadLocalAllocBuffer.hpp"
 #include "gc/z/zWorkers.hpp"
+#include "logging/log.hpp"
+
+static const ZStatCounter ZCounterRelocationContention("Contention", "Relocation Contention", ZStatUnitOpsPerSecond);
 
 ZRelocate::ZRelocate(ZWorkers* workers) :
     _workers(workers) {}
 
 class ZRelocateRootsIteratorClosure : public ZRootsIteratorClosure {
 public:
   virtual void do_thread(Thread* thread) {
     // Update thread local address bad mask
     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
 
+    // Relocate invisible root
+    ZThreadLocalData::do_invisible_root(thread, ZBarrier::relocate_barrier_on_root_oop_field);
+
     // Remap TLAB
     ZThreadLocalAllocBuffer::remap(thread);
   }
 
+  virtual bool should_disarm_nmethods() const {
+    return true;
+  }
+
   virtual void do_oop(oop* p) {
     ZBarrier::relocate_barrier_on_root_oop_field(p);
   }
 
   virtual void do_oop(narrowOop* p) {
@@ -62,56 +75,131 @@
   ZRelocateRootsIteratorClosure _cl;
 
 public:
   ZRelocateRootsTask() :
       ZTask("ZRelocateRootsTask"),
-      _roots() {}
+      _roots(true /* visit_jvmti_weak_export */) {}
 
   virtual void work() {
     // During relocation we need to visit the JVMTI
     // export weak roots to rehash the JVMTI tag map
-    _roots.oops_do(&_cl, true /* visit_jvmti_weak_export */);
+    _roots.oops_do(&_cl);
   }
 };
 
 void ZRelocate::start() {
   ZRelocateRootsTask task;
   _workers->run_parallel(&task);
 }
 
+uintptr_t ZRelocate::relocate_object_inner(ZForwarding* forwarding, uintptr_t from_index, uintptr_t from_offset) const {
+  ZForwardingCursor cursor;
+
+  // Lookup forwarding entry
+  const ZForwardingEntry entry = forwarding->find(from_index, &cursor);
+  if (entry.populated() && entry.from_index() == from_index) {
+    // Already relocated, return new address
+    return entry.to_offset();
+  }
+
+  assert(ZHeap::heap()->is_object_live(ZAddress::good(from_offset)), "Should be live");
+
+  if (forwarding->is_pinned()) {
+    // In-place forward
+    return forwarding->insert(from_index, from_offset, &cursor);
+  }
+
+  // Allocate object
+  const uintptr_t from_good = ZAddress::good(from_offset);
+  const size_t size = ZUtils::object_size(from_good);
+  const uintptr_t to_good = ZHeap::heap()->alloc_object_for_relocation(size);
+  if (to_good == 0) {
+    // Failed, in-place forward
+    return forwarding->insert(from_index, from_offset, &cursor);
+  }
+
+  // Copy object
+  ZUtils::object_copy(from_good, to_good, size);
+
+  // Insert forwarding entry
+  const uintptr_t to_offset = ZAddress::offset(to_good);
+  const uintptr_t to_offset_final = forwarding->insert(from_index, to_offset, &cursor);
+  if (to_offset_final == to_offset) {
+    // Relocation succeeded
+    return to_offset;
+  }
+
+  // Relocation contention
+  ZStatInc(ZCounterRelocationContention);
+  log_trace(gc)("Relocation contention, thread: " PTR_FORMAT " (%s), forwarding: " PTR_FORMAT
+                ", entry: " SIZE_FORMAT ", oop: " PTR_FORMAT ", size: " SIZE_FORMAT,
+                ZThread::id(), ZThread::name(), p2i(forwarding), cursor, from_good, size);
+
+  // Try undo allocation
+  ZHeap::heap()->undo_alloc_object_for_relocation(to_good, size);
+
+  return to_offset_final;
+}
+
+uintptr_t ZRelocate::relocate_object(ZForwarding* forwarding, uintptr_t from_addr) const {
+  const uintptr_t from_offset = ZAddress::offset(from_addr);
+  const uintptr_t from_index = (from_offset - forwarding->start()) >> forwarding->object_alignment_shift();
+  const uintptr_t to_offset = relocate_object_inner(forwarding, from_index, from_offset);
+
+  if (from_offset == to_offset) {
+    // In-place forwarding, pin page
+    forwarding->set_pinned();
+  }
+
+  return ZAddress::good(to_offset);
+}
+
+uintptr_t ZRelocate::forward_object(ZForwarding* forwarding, uintptr_t from_addr) const {
+  const uintptr_t from_offset = ZAddress::offset(from_addr);
+  const uintptr_t from_index = (from_offset - forwarding->start()) >> forwarding->object_alignment_shift();
+  const ZForwardingEntry entry = forwarding->find(from_index);
+
+  assert(entry.populated(), "Should be forwarded");
+  assert(entry.from_index() == from_index, "Should be forwarded");
+
+  return ZAddress::good(entry.to_offset());
+}
+
 class ZRelocateObjectClosure : public ObjectClosure {
 private:
-  ZPage* const _page;
+  ZRelocate* const   _relocate;
+  ZForwarding* const _forwarding;
 
 public:
-  ZRelocateObjectClosure(ZPage* page) :
-      _page(page) {}
+  ZRelocateObjectClosure(ZRelocate* relocate, ZForwarding* forwarding) :
+      _relocate(relocate),
+      _forwarding(forwarding) {}
 
   virtual void do_object(oop o) {
-    _page->relocate_object(ZOop::to_address(o));
+    _relocate->relocate_object(_forwarding, ZOop::to_address(o));
   }
 };
 
 bool ZRelocate::work(ZRelocationSetParallelIterator* iter) {
   bool success = true;
 
   // Relocate pages in the relocation set
-  for (ZPage* page; iter->next(&page);) {
+  for (ZForwarding* forwarding; iter->next(&forwarding);) {
     // Relocate objects in page
-    ZRelocateObjectClosure cl(page);
-    page->object_iterate(&cl);
+    ZRelocateObjectClosure cl(this, forwarding);
+    forwarding->page()->object_iterate(&cl);
 
     if (ZVerifyForwarding) {
-      page->verify_forwarding();
+      forwarding->verify();
     }
 
-    if (page->is_pinned()) {
+    if (forwarding->is_pinned()) {
       // Relocation failed, page is now pinned
       success = false;
     } else {
       // Relocation succeeded, release page
-      ZHeap::heap()->release_page(page, true /* reclaimed */);
+      forwarding->release_page();
     }
   }
 
   return success;
 }

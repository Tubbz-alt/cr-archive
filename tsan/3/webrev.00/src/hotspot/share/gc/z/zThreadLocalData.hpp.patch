diff a/src/hotspot/share/gc/z/zThreadLocalData.hpp b/src/hotspot/share/gc/z/zThreadLocalData.hpp
--- a/src/hotspot/share/gc/z/zThreadLocalData.hpp
+++ b/src/hotspot/share/gc/z/zThreadLocalData.hpp
@@ -32,14 +32,16 @@
 
 class ZThreadLocalData {
 private:
   uintptr_t              _address_bad_mask;
   ZMarkThreadLocalStacks _stacks;
+  oop*                   _invisible_root;
 
   ZThreadLocalData() :
       _address_bad_mask(0),
-      _stacks() {}
+      _stacks(),
+      _invisible_root(NULL) {}
 
   static ZThreadLocalData* data(Thread* thread) {
     return thread->gc_data<ZThreadLocalData>();
   }
 
@@ -58,10 +60,27 @@
 
   static ZMarkThreadLocalStacks* stacks(Thread* thread) {
     return &data(thread)->_stacks;
   }
 
+  static void set_invisible_root(Thread* thread, oop* root) {
+    assert(data(thread)->_invisible_root == NULL, "Already set");
+    data(thread)->_invisible_root = root;
+  }
+
+  static void clear_invisible_root(Thread* thread) {
+    assert(data(thread)->_invisible_root != NULL, "Should be set");
+    data(thread)->_invisible_root = NULL;
+  }
+
+  template <typename T>
+  static void do_invisible_root(Thread* thread, T f) {
+    if (data(thread)->_invisible_root != NULL) {
+      f(data(thread)->_invisible_root);
+    }
+  }
+
   static ByteSize address_bad_mask_offset() {
     return Thread::gc_data_offset() + byte_offset_of(ZThreadLocalData, _address_bad_mask);
   }
 
   static ByteSize nmethod_disarmed_offset() {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zBarrierSet.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zBarrierSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zBarrierSet.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 60,18 ***</span>
<span class="line-new-header">--- 60,20 ---</span>
      if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
        return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
      } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
        return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
      } else {
<span class="line-added">+       assert((HasDecorator&lt;decorators, ON_PHANTOM_OOP_REF&gt;::value), &quot;Must be&quot;);</span>
        return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
      }
    } else {
      if (HasDecorator&lt;decorators, ON_STRONG_OOP_REF&gt;::value) {
        return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
      } else if (HasDecorator&lt;decorators, ON_WEAK_OOP_REF&gt;::value) {
        return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
      } else {
<span class="line-added">+       assert((HasDecorator&lt;decorators, ON_PHANTOM_OOP_REF&gt;::value), &quot;Must be&quot;);</span>
        return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,18 ***</span>
<span class="line-new-header">--- 89,20 ---</span>
      if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
        return ZBarrier::weak_load_barrier_on_oop_field_preloaded(addr, o);
      } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
        return ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(addr, o);
      } else {
<span class="line-added">+       assert(decorators_known_strength &amp; ON_PHANTOM_OOP_REF, &quot;Must be&quot;);</span>
        return ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(addr, o);
      }
    } else {
      if (decorators_known_strength &amp; ON_STRONG_OOP_REF) {
        return ZBarrier::load_barrier_on_oop_field_preloaded(addr, o);
      } else if (decorators_known_strength &amp; ON_WEAK_OOP_REF) {
        return ZBarrier::load_barrier_on_weak_oop_field_preloaded(addr, o);
      } else {
<span class="line-added">+       assert(decorators_known_strength &amp; ON_PHANTOM_OOP_REF, &quot;Must be&quot;);</span>
        return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(addr, o);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,47 ***</span>
    return load_barrier_on_oop_field_preloaded(addr, o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(oop new_value, T* addr, oop compare_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
    ZBarrier::load_barrier_on_oop_field(addr);
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_in_heap(new_value, addr, compare_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset, oop compare_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF | ON_UNKNOWN_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
    // Through Unsafe.CompareAndExchangeObject()/CompareAndSetObject() we can receive
    // calls with ON_UNKNOWN_OOP_REF set. However, we treat these as ON_STRONG_OOP_REF,
    // with the motivation that if you&#39;re doing Unsafe operations on a Reference.referent
    // field, then you&#39;re on your own anyway.
    ZBarrier::load_barrier_on_oop_field(field_addr(base, offset));
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_in_heap_at(new_value, base, offset, compare_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(oop new_value, T* addr) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   const oop o = Raw::oop_atomic_xchg_in_heap(new_value, addr);</span>
    return ZBarrier::load_barrier_on_oop(o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop new_value, oop base, ptrdiff_t offset) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   const oop o = Raw::oop_atomic_xchg_in_heap_at(new_value, base, offset);</span>
    return ZBarrier::load_barrier_on_oop(o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-new-header">--- 130,47 ---</span>
    return load_barrier_on_oop_field_preloaded(addr, o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
    ZBarrier::load_barrier_on_oop_field(addr);
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_in_heap(addr, compare_value, new_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF | ON_UNKNOWN_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
    // Through Unsafe.CompareAndExchangeObject()/CompareAndSetObject() we can receive
    // calls with ON_UNKNOWN_OOP_REF set. However, we treat these as ON_STRONG_OOP_REF,
    // with the motivation that if you&#39;re doing Unsafe operations on a Reference.referent
    // field, then you&#39;re on your own anyway.
    ZBarrier::load_barrier_on_oop_field(field_addr(base, offset));
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_in_heap_at(base, offset, compare_value, new_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap(T* addr, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   const oop o = Raw::oop_atomic_xchg_in_heap(addr, new_value);</span>
    return ZBarrier::load_barrier_on_oop(o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   const oop o = Raw::oop_atomic_xchg_in_heap_at(base, offset, new_value);</span>
    return ZBarrier::load_barrier_on_oop(o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,22 ***</span>
    return load_barrier_on_oop_field_preloaded(addr, o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(oop new_value, T* addr, oop compare_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_not_in_heap(new_value, addr, compare_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(oop new_value, T* addr) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   return Raw::oop_atomic_xchg_not_in_heap(new_value, addr);</span>
  }
  
  #endif // SHARE_GC_Z_ZBARRIERSET_INLINE_HPP
<span class="line-new-header">--- 220,22 ---</span>
    return load_barrier_on_oop_field_preloaded(addr, o);
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_cmpxchg_not_in_heap(T* addr, oop compare_value, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   return Raw::oop_atomic_cmpxchg_not_in_heap(addr, compare_value, new_value);</span>
  }
  
  template &lt;DecoratorSet decorators, typename BarrierSetT&gt;
  template &lt;typename T&gt;
<span class="line-modified">! inline oop ZBarrierSet::AccessBarrier&lt;decorators, BarrierSetT&gt;::oop_atomic_xchg_not_in_heap(T* addr, oop new_value) {</span>
    verify_decorators_present&lt;ON_STRONG_OOP_REF&gt;();
    verify_decorators_absent&lt;AS_NO_KEEPALIVE&gt;();
  
<span class="line-modified">!   return Raw::oop_atomic_xchg_not_in_heap(addr, new_value);</span>
  }
  
  #endif // SHARE_GC_Z_ZBARRIERSET_INLINE_HPP
</pre>
<center><a href="zBarrierSet.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrierSetAssembler.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
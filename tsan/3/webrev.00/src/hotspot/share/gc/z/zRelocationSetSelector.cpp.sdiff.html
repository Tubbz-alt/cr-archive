<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zRelocationSetSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zRelocationSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocationSetSelector.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zRelocationSetSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zArray.inline.hpp&quot;
 26 #include &quot;gc/z/zPage.inline.hpp&quot;
 27 #include &quot;gc/z/zRelocationSet.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/z/zRelocationSetSelector.hpp&quot;</span>
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/globals.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;










 32 
 33 ZRelocationSetSelectorGroup::ZRelocationSetSelectorGroup(const char* name,
 34                                                          size_t page_size,
 35                                                          size_t object_size_limit) :
 36     _name(name),
 37     _page_size(page_size),
 38     _object_size_limit(object_size_limit),
 39     _fragmentation_limit(page_size * (ZFragmentationLimit / 100)),
 40     _registered_pages(),
 41     _sorted_pages(NULL),
 42     _nselected(0),
<span class="line-modified"> 43     _relocating(0),</span>
<span class="line-removed"> 44     _fragmentation(0) {}</span>
 45 
 46 ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {
<span class="line-modified"> 47   FREE_C_HEAP_ARRAY(const ZPage*, _sorted_pages);</span>
 48 }
 49 
<span class="line-modified"> 50 void ZRelocationSetSelectorGroup::register_live_page(const ZPage* page, size_t garbage) {</span>





 51   if (garbage &gt; _fragmentation_limit) {
 52     _registered_pages.add(page);
<span class="line-removed"> 53   } else {</span>
<span class="line-removed"> 54     _fragmentation += garbage;</span>
 55   }














 56 }
 57 
 58 void ZRelocationSetSelectorGroup::semi_sort() {
 59   // Semi-sort registered pages by live bytes in ascending order
 60   const size_t npartitions_shift = 11;
 61   const size_t npartitions = (size_t)1 &lt;&lt; npartitions_shift;
 62   const size_t partition_size = _page_size &gt;&gt; npartitions_shift;
 63   const size_t partition_size_shift = exact_log2(partition_size);
 64   const size_t npages = _registered_pages.size();
 65 
 66   // Partition slots/fingers
 67   size_t partitions[npartitions];
 68 
 69   // Allocate destination array
<span class="line-modified"> 70   _sorted_pages = REALLOC_C_HEAP_ARRAY(const ZPage*, _sorted_pages, npages, mtGC);</span>

 71   debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));
 72 
 73   // Calculate partition slots
 74   memset(partitions, 0, sizeof(partitions));
<span class="line-modified"> 75   ZArrayIterator&lt;const ZPage*&gt; iter1(&amp;_registered_pages);</span>
<span class="line-modified"> 76   for (const ZPage* page; iter1.next(&amp;page);) {</span>
 77     const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
 78     partitions[index]++;
 79   }
 80 
 81   // Calculate partition fingers
 82   size_t finger = 0;
 83   for (size_t i = 0; i &lt; npartitions; i++) {
 84     const size_t slots = partitions[i];
 85     partitions[i] = finger;
 86     finger += slots;
 87   }
 88 
 89   // Sort pages into partitions
<span class="line-modified"> 90   ZArrayIterator&lt;const ZPage*&gt; iter2(&amp;_registered_pages);</span>
<span class="line-modified"> 91   for (const ZPage* page; iter2.next(&amp;page);) {</span>
 92     const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
 93     const size_t finger = partitions[index]++;
 94     assert(_sorted_pages[finger] == NULL, &quot;Invalid finger&quot;);
 95     _sorted_pages[finger] = page;
 96   }
 97 }
 98 
 99 void ZRelocationSetSelectorGroup::select() {





100   // Calculate the number of pages to relocate by successively including pages in
101   // a candidate relocation set and calculate the maximum space requirement for
102   // their live objects.
103   const size_t npages = _registered_pages.size();
104   size_t selected_from = 0;
105   size_t selected_to = 0;
106   size_t from_size = 0;
107 
108   semi_sort();
109 
110   for (size_t from = 1; from &lt;= npages; from++) {
111     // Add page to the candidate relocation set
112     from_size += _sorted_pages[from - 1]-&gt;live_bytes();
113 
114     // Calculate the maximum number of pages needed by the candidate relocation set.
115     // By subtracting the object size limit from the pages size we get the maximum
116     // number of pages that the relocation set is guaranteed to fit in, regardless
117     // of in which order the objects are relocated.
118     const size_t to = ceil((double)(from_size) / (double)(_page_size - _object_size_limit));
119 
</pre>
<hr />
<pre>
121     // currently selected final relocation set. If this number is larger than the
122     // acceptable fragmentation limit, then the current candidate relocation set
123     // becomes our new final relocation set.
124     const size_t diff_from = from - selected_from;
125     const size_t diff_to = to - selected_to;
126     const double diff_reclaimable = 100 - percent_of(diff_to, diff_from);
127     if (diff_reclaimable &gt; ZFragmentationLimit) {
128       selected_from = from;
129       selected_to = to;
130     }
131 
132     log_trace(gc, reloc)(&quot;Candidate Relocation Set (%s Pages): &quot;
133                          SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, %.1f%% relative defragmentation, %s&quot;,
134                          _name, from, to, diff_reclaimable, (selected_from == from) ? &quot;Selected&quot; : &quot;Rejected&quot;);
135   }
136 
137   // Finalize selection
138   _nselected = selected_from;
139 
140   // Update statistics
<span class="line-modified">141   _relocating = from_size;</span>
<span class="line-modified">142   for (size_t i = _nselected; i &lt; npages; i++) {</span>
<span class="line-removed">143     const ZPage* const page = _sorted_pages[i];</span>
<span class="line-removed">144     _fragmentation += page-&gt;size() - page-&gt;live_bytes();</span>
<span class="line-removed">145   }</span>
146 
<span class="line-modified">147   log_debug(gc, reloc)(&quot;Relocation Set (%s Pages): &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot; skipped&quot;,</span>
148                        _name, selected_from, selected_to, npages - _nselected);
149 }
150 
<span class="line-removed">151 const ZPage* const* ZRelocationSetSelectorGroup::selected() const {</span>
<span class="line-removed">152   return _sorted_pages;</span>
<span class="line-removed">153 }</span>
<span class="line-removed">154 </span>
<span class="line-removed">155 size_t ZRelocationSetSelectorGroup::nselected() const {</span>
<span class="line-removed">156   return _nselected;</span>
<span class="line-removed">157 }</span>
<span class="line-removed">158 </span>
<span class="line-removed">159 size_t ZRelocationSetSelectorGroup::relocating() const {</span>
<span class="line-removed">160   return _relocating;</span>
<span class="line-removed">161 }</span>
<span class="line-removed">162 </span>
<span class="line-removed">163 size_t ZRelocationSetSelectorGroup::fragmentation() const {</span>
<span class="line-removed">164   return _fragmentation;</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
167 ZRelocationSetSelector::ZRelocationSetSelector() :
168     _small(&quot;Small&quot;, ZPageSizeSmall, ZObjectSizeLimitSmall),
169     _medium(&quot;Medium&quot;, ZPageSizeMedium, ZObjectSizeLimitMedium),
<span class="line-modified">170     _live(0),</span>
<span class="line-removed">171     _garbage(0),</span>
<span class="line-removed">172     _fragmentation(0) {}</span>
173 
<span class="line-modified">174 void ZRelocationSetSelector::register_live_page(const ZPage* page) {</span>
175   const uint8_t type = page-&gt;type();
<span class="line-removed">176   const size_t live = page-&gt;live_bytes();</span>
<span class="line-removed">177   const size_t garbage = page-&gt;size() - live;</span>
178 
179   if (type == ZPageTypeSmall) {
<span class="line-modified">180     _small.register_live_page(page, garbage);</span>
181   } else if (type == ZPageTypeMedium) {
<span class="line-modified">182     _medium.register_live_page(page, garbage);</span>
183   } else {
<span class="line-modified">184     _fragmentation += garbage;</span>
185   }
<span class="line-removed">186 </span>
<span class="line-removed">187   _live += live;</span>
<span class="line-removed">188   _garbage += garbage;</span>
189 }
190 
<span class="line-modified">191 void ZRelocationSetSelector::register_garbage_page(const ZPage* page) {</span>
<span class="line-modified">192   _garbage += page-&gt;size();</span>








193 }
194 
195 void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {
196   // Select pages to relocate. The resulting relocation set will be
197   // sorted such that medium pages comes first, followed by small
198   // pages. Pages within each page group will be semi-sorted by live
199   // bytes in ascending order. Relocating pages in this order allows
200   // us to start reclaiming memory more quickly.
201 
<span class="line-modified">202   // Select pages from each group</span>
203   _medium.select();
204   _small.select();
205 
206   // Populate relocation set
207   relocation_set-&gt;populate(_medium.selected(), _medium.nselected(),
208                            _small.selected(), _small.nselected());
209 }
210 
<span class="line-modified">211 size_t ZRelocationSetSelector::live() const {</span>
<span class="line-modified">212   return _live;</span>
<span class="line-modified">213 }</span>
<span class="line-modified">214 </span>
<span class="line-modified">215 size_t ZRelocationSetSelector::garbage() const {</span>
<span class="line-modified">216   return _garbage;</span>
<span class="line-removed">217 }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219 size_t ZRelocationSetSelector::relocating() const {</span>
<span class="line-removed">220   return _small.relocating() + _medium.relocating();</span>
<span class="line-removed">221 }</span>
<span class="line-removed">222 </span>
<span class="line-removed">223 size_t ZRelocationSetSelector::fragmentation() const {</span>
<span class="line-removed">224   return _fragmentation + _small.fragmentation() + _medium.fragmentation();</span>
225 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zArray.inline.hpp&quot;
 26 #include &quot;gc/z/zPage.inline.hpp&quot;
 27 #include &quot;gc/z/zRelocationSet.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/z/zRelocationSetSelector.inline.hpp&quot;</span>
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;runtime/globals.hpp&quot;
 31 #include &quot;utilities/debug.hpp&quot;
<span class="line-added"> 32 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
<span class="line-added"> 33 </span>
<span class="line-added"> 34 ZRelocationSetSelectorGroupStats::ZRelocationSetSelectorGroupStats() :</span>
<span class="line-added"> 35     _npages(0),</span>
<span class="line-added"> 36     _total(0),</span>
<span class="line-added"> 37     _live(0),</span>
<span class="line-added"> 38     _garbage(0),</span>
<span class="line-added"> 39     _empty(0),</span>
<span class="line-added"> 40     _compacting_from(0),</span>
<span class="line-added"> 41     _compacting_to(0) {}</span>
 42 
 43 ZRelocationSetSelectorGroup::ZRelocationSetSelectorGroup(const char* name,
 44                                                          size_t page_size,
 45                                                          size_t object_size_limit) :
 46     _name(name),
 47     _page_size(page_size),
 48     _object_size_limit(object_size_limit),
 49     _fragmentation_limit(page_size * (ZFragmentationLimit / 100)),
 50     _registered_pages(),
 51     _sorted_pages(NULL),
 52     _nselected(0),
<span class="line-modified"> 53     _stats() {}</span>

 54 
 55 ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {
<span class="line-modified"> 56   FREE_C_HEAP_ARRAY(ZPage*, _sorted_pages);</span>
 57 }
 58 
<span class="line-modified"> 59 void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {</span>
<span class="line-added"> 60   const uint8_t type = page-&gt;type();</span>
<span class="line-added"> 61   const size_t size = page-&gt;size();</span>
<span class="line-added"> 62   const size_t live = page-&gt;live_bytes();</span>
<span class="line-added"> 63   const size_t garbage = size - live;</span>
<span class="line-added"> 64 </span>
 65   if (garbage &gt; _fragmentation_limit) {
 66     _registered_pages.add(page);


 67   }
<span class="line-added"> 68 </span>
<span class="line-added"> 69   _stats._npages++;</span>
<span class="line-added"> 70   _stats._total += size;</span>
<span class="line-added"> 71   _stats._live += live;</span>
<span class="line-added"> 72   _stats._garbage += garbage;</span>
<span class="line-added"> 73 }</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75 void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {</span>
<span class="line-added"> 76   const size_t size = page-&gt;size();</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78   _stats._npages++;</span>
<span class="line-added"> 79   _stats._total += size;</span>
<span class="line-added"> 80   _stats._garbage += size;</span>
<span class="line-added"> 81   _stats._empty += size;</span>
 82 }
 83 
 84 void ZRelocationSetSelectorGroup::semi_sort() {
 85   // Semi-sort registered pages by live bytes in ascending order
 86   const size_t npartitions_shift = 11;
 87   const size_t npartitions = (size_t)1 &lt;&lt; npartitions_shift;
 88   const size_t partition_size = _page_size &gt;&gt; npartitions_shift;
 89   const size_t partition_size_shift = exact_log2(partition_size);
 90   const size_t npages = _registered_pages.size();
 91 
 92   // Partition slots/fingers
 93   size_t partitions[npartitions];
 94 
 95   // Allocate destination array
<span class="line-modified"> 96   assert(_sorted_pages == NULL, &quot;Already initialized&quot;);</span>
<span class="line-added"> 97   _sorted_pages = NEW_C_HEAP_ARRAY(ZPage*, npages, mtGC);</span>
 98   debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));
 99 
100   // Calculate partition slots
101   memset(partitions, 0, sizeof(partitions));
<span class="line-modified">102   ZArrayIterator&lt;ZPage*&gt; iter1(&amp;_registered_pages);</span>
<span class="line-modified">103   for (ZPage* page; iter1.next(&amp;page);) {</span>
104     const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
105     partitions[index]++;
106   }
107 
108   // Calculate partition fingers
109   size_t finger = 0;
110   for (size_t i = 0; i &lt; npartitions; i++) {
111     const size_t slots = partitions[i];
112     partitions[i] = finger;
113     finger += slots;
114   }
115 
116   // Sort pages into partitions
<span class="line-modified">117   ZArrayIterator&lt;ZPage*&gt; iter2(&amp;_registered_pages);</span>
<span class="line-modified">118   for (ZPage* page; iter2.next(&amp;page);) {</span>
119     const size_t index = page-&gt;live_bytes() &gt;&gt; partition_size_shift;
120     const size_t finger = partitions[index]++;
121     assert(_sorted_pages[finger] == NULL, &quot;Invalid finger&quot;);
122     _sorted_pages[finger] = page;
123   }
124 }
125 
126 void ZRelocationSetSelectorGroup::select() {
<span class="line-added">127   if (_page_size == 0) {</span>
<span class="line-added">128     // Page type disabled</span>
<span class="line-added">129     return;</span>
<span class="line-added">130   }</span>
<span class="line-added">131 </span>
132   // Calculate the number of pages to relocate by successively including pages in
133   // a candidate relocation set and calculate the maximum space requirement for
134   // their live objects.
135   const size_t npages = _registered_pages.size();
136   size_t selected_from = 0;
137   size_t selected_to = 0;
138   size_t from_size = 0;
139 
140   semi_sort();
141 
142   for (size_t from = 1; from &lt;= npages; from++) {
143     // Add page to the candidate relocation set
144     from_size += _sorted_pages[from - 1]-&gt;live_bytes();
145 
146     // Calculate the maximum number of pages needed by the candidate relocation set.
147     // By subtracting the object size limit from the pages size we get the maximum
148     // number of pages that the relocation set is guaranteed to fit in, regardless
149     // of in which order the objects are relocated.
150     const size_t to = ceil((double)(from_size) / (double)(_page_size - _object_size_limit));
151 
</pre>
<hr />
<pre>
153     // currently selected final relocation set. If this number is larger than the
154     // acceptable fragmentation limit, then the current candidate relocation set
155     // becomes our new final relocation set.
156     const size_t diff_from = from - selected_from;
157     const size_t diff_to = to - selected_to;
158     const double diff_reclaimable = 100 - percent_of(diff_to, diff_from);
159     if (diff_reclaimable &gt; ZFragmentationLimit) {
160       selected_from = from;
161       selected_to = to;
162     }
163 
164     log_trace(gc, reloc)(&quot;Candidate Relocation Set (%s Pages): &quot;
165                          SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, %.1f%% relative defragmentation, %s&quot;,
166                          _name, from, to, diff_reclaimable, (selected_from == from) ? &quot;Selected&quot; : &quot;Rejected&quot;);
167   }
168 
169   // Finalize selection
170   _nselected = selected_from;
171 
172   // Update statistics
<span class="line-modified">173   _stats._compacting_from = selected_from * _page_size;</span>
<span class="line-modified">174   _stats._compacting_to = selected_to * _page_size;</span>



175 
<span class="line-modified">176   log_trace(gc, reloc)(&quot;Relocation Set (%s Pages): &quot; SIZE_FORMAT &quot;-&gt;&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot; skipped&quot;,</span>
177                        _name, selected_from, selected_to, npages - _nselected);
178 }
179 
















180 ZRelocationSetSelector::ZRelocationSetSelector() :
181     _small(&quot;Small&quot;, ZPageSizeSmall, ZObjectSizeLimitSmall),
182     _medium(&quot;Medium&quot;, ZPageSizeMedium, ZObjectSizeLimitMedium),
<span class="line-modified">183     _large(&quot;Large&quot;, 0 /* page_size */, 0 /* object_size_limit */) {}</span>


184 
<span class="line-modified">185 void ZRelocationSetSelector::register_live_page(ZPage* page) {</span>
186   const uint8_t type = page-&gt;type();


187 
188   if (type == ZPageTypeSmall) {
<span class="line-modified">189     _small.register_live_page(page);</span>
190   } else if (type == ZPageTypeMedium) {
<span class="line-modified">191     _medium.register_live_page(page);</span>
192   } else {
<span class="line-modified">193     _large.register_live_page(page);</span>
194   }



195 }
196 
<span class="line-modified">197 void ZRelocationSetSelector::register_garbage_page(ZPage* page) {</span>
<span class="line-modified">198   const uint8_t type = page-&gt;type();</span>
<span class="line-added">199 </span>
<span class="line-added">200   if (type == ZPageTypeSmall) {</span>
<span class="line-added">201     _small.register_garbage_page(page);</span>
<span class="line-added">202   } else if (type == ZPageTypeMedium) {</span>
<span class="line-added">203     _medium.register_garbage_page(page);</span>
<span class="line-added">204   } else {</span>
<span class="line-added">205     _large.register_garbage_page(page);</span>
<span class="line-added">206   }</span>
207 }
208 
209 void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {
210   // Select pages to relocate. The resulting relocation set will be
211   // sorted such that medium pages comes first, followed by small
212   // pages. Pages within each page group will be semi-sorted by live
213   // bytes in ascending order. Relocating pages in this order allows
214   // us to start reclaiming memory more quickly.
215 
<span class="line-modified">216   // Select pages from each group, except large</span>
217   _medium.select();
218   _small.select();
219 
220   // Populate relocation set
221   relocation_set-&gt;populate(_medium.selected(), _medium.nselected(),
222                            _small.selected(), _small.nselected());
223 }
224 
<span class="line-modified">225 ZRelocationSetSelectorStats ZRelocationSetSelector::stats() const {</span>
<span class="line-modified">226   ZRelocationSetSelectorStats stats;</span>
<span class="line-modified">227   stats._small = _small.stats();</span>
<span class="line-modified">228   stats._medium = _medium.stats();</span>
<span class="line-modified">229   stats._large = _large.stats();</span>
<span class="line-modified">230   return stats;</span>








231 }
</pre>
</td>
</tr>
</table>
<center><a href="zRelocationSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocationSetSelector.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
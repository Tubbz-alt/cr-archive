<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/z/zPageCache.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zPageAllocator.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageCache.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zPageCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,16 +25,25 @@</span>
  #include &quot;gc/z/zList.inline.hpp&quot;
  #include &quot;gc/z/zNUMA.hpp&quot;
  #include &quot;gc/z/zPage.inline.hpp&quot;
  #include &quot;gc/z/zPageCache.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/z/zValue.inline.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  
  static const ZStatCounter ZCounterPageCacheHitL1(&quot;Memory&quot;, &quot;Page Cache Hit L1&quot;, ZStatUnitOpsPerSecond);
  static const ZStatCounter ZCounterPageCacheHitL2(&quot;Memory&quot;, &quot;Page Cache Hit L2&quot;, ZStatUnitOpsPerSecond);
<span class="udiff-line-added">+ static const ZStatCounter ZCounterPageCacheHitL3(&quot;Memory&quot;, &quot;Page Cache Hit L3&quot;, ZStatUnitOpsPerSecond);</span>
  static const ZStatCounter ZCounterPageCacheMiss(&quot;Memory&quot;, &quot;Page Cache Miss&quot;, ZStatUnitOpsPerSecond);
<span class="udiff-line-modified-removed">- static const ZStatCounter ZCounterPageCacheFlush(&quot;Memory&quot;, &quot;Page Cache Flush&quot;, ZStatUnitBytesPerSecond);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ ZPageCacheFlushClosure::ZPageCacheFlushClosure(size_t requested) :</span>
<span class="udiff-line-added">+     _requested(requested),</span>
<span class="udiff-line-added">+     _flushed(0) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ size_t ZPageCacheFlushClosure::overflushed() const {</span>
<span class="udiff-line-added">+   return _flushed &gt; _requested ? _flushed - _requested : 0;</span>
<span class="udiff-line-added">+ }</span>
  
  ZPageCache::ZPageCache() :
      _available(0),
      _small(),
      _medium(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,132 +75,191 @@</span>
      }
  
      remote_numa_id++;
    }
  
<span class="udiff-line-removed">-   ZStatInc(ZCounterPageCacheMiss);</span>
    return NULL;
  }
  
  ZPage* ZPageCache::alloc_medium_page() {
<span class="udiff-line-modified-removed">-   ZPage* const l1_page = _medium.remove_first();</span>
<span class="udiff-line-modified-removed">-   if (l1_page != NULL) {</span>
<span class="udiff-line-modified-added">+   ZPage* const page = _medium.remove_first();</span>
<span class="udiff-line-modified-added">+   if (page != NULL) {</span>
      ZStatInc(ZCounterPageCacheHitL1);
<span class="udiff-line-modified-removed">-     return l1_page;</span>
<span class="udiff-line-modified-added">+     return page;</span>
    }
  
<span class="udiff-line-removed">-   ZStatInc(ZCounterPageCacheMiss);</span>
    return NULL;
  }
  
  ZPage* ZPageCache::alloc_large_page(size_t size) {
    // Find a page with the right size
    ZListIterator&lt;ZPage&gt; iter(&amp;_large);
<span class="udiff-line-modified-removed">-   for (ZPage* l1_page; iter.next(&amp;l1_page);) {</span>
<span class="udiff-line-modified-removed">-     if (l1_page-&gt;size() == size) {</span>
<span class="udiff-line-modified-added">+   for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="udiff-line-modified-added">+     if (size == page-&gt;size()) {</span>
        // Page found
<span class="udiff-line-modified-removed">-       _large.remove(l1_page);</span>
<span class="udiff-line-modified-added">+       _large.remove(page);</span>
        ZStatInc(ZCounterPageCacheHitL1);
<span class="udiff-line-modified-removed">-       return l1_page;</span>
<span class="udiff-line-modified-added">+       return page;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ZPage* ZPageCache::alloc_oversized_medium_page(size_t size) {</span>
<span class="udiff-line-added">+   if (size &lt;= ZPageSizeMedium) {</span>
<span class="udiff-line-added">+     return _medium.remove_first();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ZPage* ZPageCache::alloc_oversized_large_page(size_t size) {</span>
<span class="udiff-line-added">+   // Find a page that is large enough</span>
<span class="udiff-line-added">+   ZListIterator&lt;ZPage&gt; iter(&amp;_large);</span>
<span class="udiff-line-added">+   for (ZPage* page; iter.next(&amp;page);) {</span>
<span class="udiff-line-added">+     if (size &lt;= page-&gt;size()) {</span>
<span class="udiff-line-added">+       // Page found</span>
<span class="udiff-line-added">+       _large.remove(page);</span>
<span class="udiff-line-added">+       return page;</span>
      }
    }
  
<span class="udiff-line-removed">-   ZStatInc(ZCounterPageCacheMiss);</span>
    return NULL;
  }
  
<span class="udiff-line-added">+ ZPage* ZPageCache::alloc_oversized_page(size_t size) {</span>
<span class="udiff-line-added">+   ZPage* page = alloc_oversized_large_page(size);</span>
<span class="udiff-line-added">+   if (page == NULL) {</span>
<span class="udiff-line-added">+     page = alloc_oversized_medium_page(size);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (page != NULL) {</span>
<span class="udiff-line-added">+     ZStatInc(ZCounterPageCacheHitL3);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return page;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  ZPage* ZPageCache::alloc_page(uint8_t type, size_t size) {
    ZPage* page;
  
<span class="udiff-line-added">+   // Try allocate exact page</span>
    if (type == ZPageTypeSmall) {
      page = alloc_small_page();
    } else if (type == ZPageTypeMedium) {
      page = alloc_medium_page();
    } else {
      page = alloc_large_page(size);
    }
  
<span class="udiff-line-added">+   if (page == NULL) {</span>
<span class="udiff-line-added">+     // Try allocate potentially oversized page</span>
<span class="udiff-line-added">+     ZPage* const oversized = alloc_oversized_page(size);</span>
<span class="udiff-line-added">+     if (oversized != NULL) {</span>
<span class="udiff-line-added">+       if (size &lt; oversized-&gt;size()) {</span>
<span class="udiff-line-added">+         // Split oversized page</span>
<span class="udiff-line-added">+         page = oversized-&gt;split(type, size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Cache remainder</span>
<span class="udiff-line-added">+         free_page_inner(oversized);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         // Re-type correctly sized page</span>
<span class="udiff-line-added">+         page = oversized-&gt;retype(type);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    if (page != NULL) {
      _available -= page-&gt;size();
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ZStatInc(ZCounterPageCacheMiss);</span>
    }
  
    return page;
  }
  
<span class="udiff-line-modified-removed">- void ZPageCache::free_page(ZPage* page) {</span>
<span class="udiff-line-removed">-   assert(!page-&gt;is_active(), &quot;Invalid page state&quot;);</span>
<span class="udiff-line-removed">-   assert(!page-&gt;is_pinned(), &quot;Invalid page state&quot;);</span>
<span class="udiff-line-removed">-   assert(!page-&gt;is_detached(), &quot;Invalid page state&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ void ZPageCache::free_page_inner(ZPage* page) {</span>
    const uint8_t type = page-&gt;type();
    if (type == ZPageTypeSmall) {
      _small.get(page-&gt;numa_id()).insert_first(page);
    } else if (type == ZPageTypeMedium) {
      _medium.insert_first(page);
    } else {
      _large.insert_first(page);
    }
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-added">+ void ZPageCache::free_page(ZPage* page) {</span>
<span class="udiff-line-added">+   free_page_inner(page);</span>
    _available += page-&gt;size();
  }
  
<span class="udiff-line-modified-removed">- void ZPageCache::flush_list(ZList&lt;ZPage&gt;* from, size_t requested, ZList&lt;ZPage&gt;* to, size_t* flushed) {</span>
<span class="udiff-line-modified-removed">-   while (*flushed &lt; requested) {</span>
<span class="udiff-line-modified-removed">-     // Flush least recently used</span>
<span class="udiff-line-modified-removed">-     ZPage* const page = from-&gt;remove_last();</span>
<span class="udiff-line-modified-removed">-     if (page == NULL) {</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     *flushed += page-&gt;size();</span>
<span class="udiff-line-removed">-     to-&gt;insert_last(page);</span>
<span class="udiff-line-modified-added">+ bool ZPageCache::flush_list_inner(ZPageCacheFlushClosure* cl, ZList&lt;ZPage&gt;* from, ZList&lt;ZPage&gt;* to) {</span>
<span class="udiff-line-modified-added">+   ZPage* const page = from-&gt;last();</span>
<span class="udiff-line-modified-added">+   if (page == NULL || !cl-&gt;do_page(page)) {</span>
<span class="udiff-line-modified-added">+     // Don&#39;t flush page</span>
<span class="udiff-line-modified-added">+     return false;</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Flush page</span>
<span class="udiff-line-added">+   _available -= page-&gt;size();</span>
<span class="udiff-line-added">+   from-&gt;remove(page);</span>
<span class="udiff-line-added">+   to-&gt;insert_last(page);</span>
<span class="udiff-line-added">+   return true;</span>
  }
  
<span class="udiff-line-modified-removed">- void ZPageCache::flush_per_numa_lists(ZPerNUMA&lt;ZList&lt;ZPage&gt; &gt;* from, size_t requested, ZList&lt;ZPage&gt;* to, size_t* flushed) {</span>
<span class="udiff-line-modified-added">+ void ZPageCache::flush_list(ZPageCacheFlushClosure* cl, ZList&lt;ZPage&gt;* from, ZList&lt;ZPage&gt;* to) {</span>
<span class="udiff-line-added">+   while (flush_list_inner(cl, from, to));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ZPageCache::flush_per_numa_lists(ZPageCacheFlushClosure* cl, ZPerNUMA&lt;ZList&lt;ZPage&gt; &gt;* from, ZList&lt;ZPage&gt;* to) {</span>
    const uint32_t numa_count = ZNUMA::count();
<span class="udiff-line-modified-removed">-   uint32_t numa_empty = 0;</span>
<span class="udiff-line-modified-added">+   uint32_t numa_done = 0;</span>
    uint32_t numa_next = 0;
  
    // Flush lists round-robin
<span class="udiff-line-modified-removed">-   while (*flushed &lt; requested) {</span>
<span class="udiff-line-modified-removed">-     ZPage* const page = from-&gt;get(numa_next).remove_last();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   while (numa_done &lt; numa_count) {</span>
<span class="udiff-line-modified-added">+     ZList&lt;ZPage&gt;* numa_list = from-&gt;addr(numa_next);</span>
      if (++numa_next == numa_count) {
        numa_next = 0;
      }
  
<span class="udiff-line-modified-removed">-     if (page == NULL) {</span>
<span class="udiff-line-modified-removed">-       // List is empty</span>
<span class="udiff-line-modified-removed">-       if (++numa_empty == numa_count) {</span>
<span class="udiff-line-modified-removed">-         // All lists are empty</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       // Try next list</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-modified-added">+     if (flush_list_inner(cl, numa_list, to)) {</span>
<span class="udiff-line-modified-added">+       // Not done</span>
<span class="udiff-line-modified-added">+       numa_done = 0;</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       // Done</span>
<span class="udiff-line-modified-added">+       numa_done++;</span>
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Flush page</span>
<span class="udiff-line-removed">-     numa_empty = 0;</span>
<span class="udiff-line-removed">-     *flushed += page-&gt;size();</span>
<span class="udiff-line-removed">-     to-&gt;insert_last(page);</span>
    }
  }
  
<span class="udiff-line-modified-removed">- void ZPageCache::flush(ZList&lt;ZPage&gt;* to, size_t requested) {</span>
<span class="udiff-line-removed">-   size_t flushed = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ void ZPageCache::flush(ZPageCacheFlushClosure* cl, ZList&lt;ZPage&gt;* to) {</span>
    // Prefer flushing large, then medium and last small pages
<span class="udiff-line-modified-removed">-   flush_list(&amp;_large, requested, to, &amp;flushed);</span>
<span class="udiff-line-modified-removed">-   flush_list(&amp;_medium, requested, to, &amp;flushed);</span>
<span class="udiff-line-modified-removed">-   flush_per_numa_lists(&amp;_small, requested, to, &amp;flushed);</span>
<span class="udiff-line-modified-added">+   flush_list(cl, &amp;_large, to);</span>
<span class="udiff-line-modified-added">+   flush_list(cl, &amp;_medium, to);</span>
<span class="udiff-line-modified-added">+   flush_per_numa_lists(cl, &amp;_small, to);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   ZStatInc(ZCounterPageCacheFlush, flushed);</span>
<span class="udiff-line-modified-added">+ void ZPageCache::pages_do(ZPageClosure* cl) const {</span>
<span class="udiff-line-added">+   // Small</span>
<span class="udiff-line-added">+   ZPerNUMAConstIterator&lt;ZList&lt;ZPage&gt; &gt; iter_numa(&amp;_small);</span>
<span class="udiff-line-added">+   for (const ZList&lt;ZPage&gt;* list; iter_numa.next(&amp;list);) {</span>
<span class="udiff-line-added">+     ZListIterator&lt;ZPage&gt; iter_small(list);</span>
<span class="udiff-line-added">+     for (ZPage* page; iter_small.next(&amp;page);) {</span>
<span class="udiff-line-added">+       cl-&gt;do_page(page);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   log_info(gc, heap)(&quot;Page Cache Flushed: &quot;</span>
<span class="udiff-line-modified-removed">-                      SIZE_FORMAT &quot;M requested, &quot;</span>
<span class="udiff-line-modified-removed">-                      SIZE_FORMAT &quot;M(&quot; SIZE_FORMAT &quot;M-&gt;&quot; SIZE_FORMAT &quot;M) flushed&quot;,</span>
<span class="udiff-line-modified-removed">-                      requested / M, flushed / M , _available / M, (_available - flushed) / M);</span>
<span class="udiff-line-modified-added">+   // Medium</span>
<span class="udiff-line-modified-added">+   ZListIterator&lt;ZPage&gt; iter_medium(&amp;_medium);</span>
<span class="udiff-line-modified-added">+   for (ZPage* page; iter_medium.next(&amp;page);) {</span>
<span class="udiff-line-modified-added">+     cl-&gt;do_page(page);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   _available -= flushed;</span>
<span class="udiff-line-modified-added">+   // Large</span>
<span class="udiff-line-added">+   ZListIterator&lt;ZPage&gt; iter_large(&amp;_large);</span>
<span class="udiff-line-added">+   for (ZPage* page; iter_large.next(&amp;page);) {</span>
<span class="udiff-line-added">+     cl-&gt;do_page(page);</span>
<span class="udiff-line-added">+   }</span>
  }
</pre>
<center><a href="zPageAllocator.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zPageCache.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
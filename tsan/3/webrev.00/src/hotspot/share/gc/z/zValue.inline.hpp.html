<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/z/zValue.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZVALUE_INLINE_HPP
 25 #define SHARE_GC_Z_ZVALUE_INLINE_HPP
 26 
 27 #include &quot;gc/z/zCPU.inline.hpp&quot;
 28 #include &quot;gc/z/zGlobals.hpp&quot;
 29 #include &quot;gc/z/zNUMA.hpp&quot;
 30 #include &quot;gc/z/zThread.inline.hpp&quot;
 31 #include &quot;gc/z/zUtils.hpp&quot;
 32 #include &quot;gc/z/zValue.hpp&quot;
 33 #include &quot;runtime/globals.hpp&quot;
 34 #include &quot;utilities/align.hpp&quot;
 35 
 36 //
 37 // Storage
 38 //
 39 
 40 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_end = 0;
 41 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_top = 0;
 42 
 43 template &lt;typename S&gt;
 44 uintptr_t ZValueStorage&lt;S&gt;::alloc(size_t size) {
 45   assert(size &lt;= offset, &quot;Allocation too large&quot;);
 46 
 47   // Allocate entry in existing memory block
 48   const uintptr_t addr = align_up(_top, S::alignment());
 49   _top = addr + size;
 50 
 51   if (_top &lt; _end) {
 52     // Success
 53     return addr;
 54   }
 55 
 56   // Allocate new block of memory
 57   const size_t block_alignment = offset;
 58   const size_t block_size = offset * S::count();
 59   _top = ZUtils::alloc_aligned(block_alignment, block_size);
 60   _end = _top + offset;
 61 
 62   // Retry allocation
 63   return alloc(size);
 64 }
 65 
 66 inline size_t ZContendedStorage::alignment() {
 67   return ZCacheLineSize;
 68 }
 69 
 70 inline uint32_t ZContendedStorage::count() {
 71   return 1;
 72 }
 73 
 74 inline uint32_t ZContendedStorage::id() {
 75   return 0;
 76 }
 77 
 78 inline size_t ZPerCPUStorage::alignment() {
 79   return sizeof(uintptr_t);
 80 }
 81 
 82 inline uint32_t ZPerCPUStorage::count() {
 83   return ZCPU::count();
 84 }
 85 
 86 inline uint32_t ZPerCPUStorage::id() {
 87   return ZCPU::id();
 88 }
 89 
 90 inline size_t ZPerNUMAStorage::alignment() {
 91   return sizeof(uintptr_t);
 92 }
 93 
 94 inline uint32_t ZPerNUMAStorage::count() {
 95   return ZNUMA::count();
 96 }
 97 
 98 inline uint32_t ZPerNUMAStorage::id() {
 99   return ZNUMA::id();
100 }
101 
102 inline size_t ZPerWorkerStorage::alignment() {
103   return sizeof(uintptr_t);
104 }
105 
106 inline uint32_t ZPerWorkerStorage::count() {
107   return MAX2(ParallelGCThreads, ConcGCThreads);
108 }
109 
110 inline uint32_t ZPerWorkerStorage::id() {
111   return ZThread::worker_id();
112 }
113 
114 //
115 // Value
116 //
117 
118 template &lt;typename S, typename T&gt;
119 inline uintptr_t ZValue&lt;S, T&gt;::value_addr(uint32_t value_id) const {
120   return _addr + (value_id * S::offset);
121 }
122 
123 template &lt;typename S, typename T&gt;
124 inline ZValue&lt;S, T&gt;::ZValue() :
125     _addr(S::alloc(sizeof(T))) {
126   // Initialize all instances
127   ZValueIterator&lt;S, T&gt; iter(this);
128   for (T* addr; iter.next(&amp;addr);) {
129     ::new (addr) T;
130   }
131 }
132 
133 template &lt;typename S, typename T&gt;
134 inline ZValue&lt;S, T&gt;::ZValue(const T&amp; value) :
135     _addr(S::alloc(sizeof(T))) {
136   // Initialize all instances
137   ZValueIterator&lt;S, T&gt; iter(this);
138   for (T* addr; iter.next(&amp;addr);) {
139     ::new (addr) T(value);
140   }
141 }
142 
143 template &lt;typename S, typename T&gt;
144 inline const T* ZValue&lt;S, T&gt;::addr(uint32_t value_id) const {
145   return reinterpret_cast&lt;const T*&gt;(value_addr(value_id));
146 }
147 
148 template &lt;typename S, typename T&gt;
149 inline T* ZValue&lt;S, T&gt;::addr(uint32_t value_id) {
150   return reinterpret_cast&lt;T*&gt;(value_addr(value_id));
151 }
152 
153 template &lt;typename S, typename T&gt;
154 inline const T&amp; ZValue&lt;S, T&gt;::get(uint32_t value_id) const {
155   return *addr(value_id);
156 }
157 
158 template &lt;typename S, typename T&gt;
159 inline T&amp; ZValue&lt;S, T&gt;::get(uint32_t value_id) {
160   return *addr(value_id);
161 }
162 
163 template &lt;typename S, typename T&gt;
164 inline void ZValue&lt;S, T&gt;::set(const T&amp; value, uint32_t value_id) {
165   get(value_id) = value;
166 }
167 
168 template &lt;typename S, typename T&gt;
169 inline void ZValue&lt;S, T&gt;::set_all(const T&amp; value) {
170   ZValueIterator&lt;S, T&gt; iter(this);
171   for (T* addr; iter.next(&amp;addr);) {
172     *addr = value;
173   }
174 }
175 
176 template &lt;typename T&gt;
177 inline ZContended&lt;T&gt;::ZContended() :
178     ZValue&lt;ZContendedStorage, T&gt;() {}
179 
180 template &lt;typename T&gt;
181 inline ZContended&lt;T&gt;::ZContended(const T&amp; value) :
182     ZValue&lt;ZContendedStorage, T&gt;(value) {}
183 
184 template &lt;typename T&gt;
185 inline ZPerCPU&lt;T&gt;::ZPerCPU() :
186     ZValue&lt;ZPerCPUStorage, T&gt;() {}
187 
188 template &lt;typename T&gt;
189 inline ZPerCPU&lt;T&gt;::ZPerCPU(const T&amp; value) :
190     ZValue&lt;ZPerCPUStorage, T&gt;(value) {}
191 
192 template &lt;typename T&gt;
193 inline ZPerNUMA&lt;T&gt;::ZPerNUMA() :
194     ZValue&lt;ZPerNUMAStorage, T&gt;() {}
195 
196 template &lt;typename T&gt;
197 inline ZPerNUMA&lt;T&gt;::ZPerNUMA(const T&amp; value) :
198     ZValue&lt;ZPerNUMAStorage, T&gt;(value) {}
199 
200 template &lt;typename T&gt;
201 inline ZPerWorker&lt;T&gt;::ZPerWorker() :
202     ZValue&lt;ZPerWorkerStorage, T&gt;() {}
203 
204 template &lt;typename T&gt;
205 inline ZPerWorker&lt;T&gt;::ZPerWorker(const T&amp; value) :
206     ZValue&lt;ZPerWorkerStorage, T&gt;(value) {}
207 
208 //
209 // Iterator
210 //
211 
212 template &lt;typename S, typename T&gt;
213 inline ZValueIterator&lt;S, T&gt;::ZValueIterator(ZValue&lt;S, T&gt;* value) :
214     _value(value),
215     _value_id(0) {}
216 
217 template &lt;typename S, typename T&gt;
218 inline bool ZValueIterator&lt;S, T&gt;::next(T** value) {
219   if (_value_id &lt; S::count()) {
220     *value = _value-&gt;addr(_value_id++);
221     return true;
222   }
223   return false;
224 }
225 
226 template &lt;typename T&gt;
227 inline ZPerCPUIterator&lt;T&gt;::ZPerCPUIterator(ZPerCPU&lt;T&gt;* value) :
228     ZValueIterator&lt;ZPerCPUStorage, T&gt;(value) {}
229 
230 template &lt;typename T&gt;
231 inline ZPerNUMAIterator&lt;T&gt;::ZPerNUMAIterator(ZPerNUMA&lt;T&gt;* value) :
232     ZValueIterator&lt;ZPerNUMAStorage, T&gt;(value) {}
233 
234 template &lt;typename T&gt;
235 inline ZPerWorkerIterator&lt;T&gt;::ZPerWorkerIterator(ZPerWorker&lt;T&gt;* value) :
236     ZValueIterator&lt;ZPerWorkerStorage, T&gt;(value) {}
237 
238 template &lt;typename S, typename T&gt;
239 inline ZValueConstIterator&lt;S, T&gt;::ZValueConstIterator(const ZValue&lt;S, T&gt;* value) :
240     _value(value),
241     _value_id(0) {}
242 
243 template &lt;typename S, typename T&gt;
244 inline bool ZValueConstIterator&lt;S, T&gt;::next(const T** value) {
245   if (_value_id &lt; S::count()) {
246     *value = _value-&gt;addr(_value_id++);
247     return true;
248   }
249   return false;
250 }
251 
252 template &lt;typename T&gt;
253 inline ZPerCPUConstIterator&lt;T&gt;::ZPerCPUConstIterator(const ZPerCPU&lt;T&gt;* value) :
254     ZValueConstIterator&lt;ZPerCPUStorage, T&gt;(value) {}
255 
256 template &lt;typename T&gt;
257 inline ZPerNUMAConstIterator&lt;T&gt;::ZPerNUMAConstIterator(const ZPerNUMA&lt;T&gt;* value) :
258     ZValueConstIterator&lt;ZPerNUMAStorage, T&gt;(value) {}
259 
260 template &lt;typename T&gt;
261 inline ZPerWorkerConstIterator&lt;T&gt;::ZPerWorkerConstIterator(const ZPerWorker&lt;T&gt;* value) :
262     ZValueConstIterator&lt;ZPerWorkerStorage, T&gt;(value) {}
263 
264 #endif // SHARE_GC_Z_ZVALUE_INLINE_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zValue.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zUtils.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zVirtualMemory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zValue.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZVALUE_HPP
 25 #define SHARE_GC_Z_ZVALUE_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
<span class="line-modified"> 28 #include &quot;gc/z/zCPU.hpp&quot;</span>
<span class="line-modified"> 29 #include &quot;gc/z/zGlobals.hpp&quot;</span>
<span class="line-modified"> 30 #include &quot;gc/z/zNUMA.hpp&quot;</span>
<span class="line-modified"> 31 #include &quot;gc/z/zThread.hpp&quot;</span>
<span class="line-modified"> 32 #include &quot;gc/z/zUtils.hpp&quot;</span>
<span class="line-removed"> 33 #include &quot;utilities/align.hpp&quot;</span>
 34 
 35 template &lt;typename S&gt;
 36 class ZValueStorage : public AllStatic {
 37 private:
 38   static uintptr_t _top;
 39   static uintptr_t _end;
 40 
 41 public:
 42   static const size_t offset = 4 * K;
 43 
<span class="line-modified"> 44   static uintptr_t alloc(size_t size) {</span>
<span class="line-removed"> 45     guarantee(size &lt;= offset, &quot;Allocation too large&quot;);</span>
<span class="line-removed"> 46 </span>
<span class="line-removed"> 47     // Allocate entry in existing memory block</span>
<span class="line-removed"> 48     const uintptr_t addr = align_up(_top, S::alignment());</span>
<span class="line-removed"> 49     _top = addr + size;</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51     if (_top &lt; _end) {</span>
<span class="line-removed"> 52       // Success</span>
<span class="line-removed"> 53       return addr;</span>
<span class="line-removed"> 54     }</span>
<span class="line-removed"> 55 </span>
<span class="line-removed"> 56     // Allocate new block of memory</span>
<span class="line-removed"> 57     const size_t block_alignment = offset;</span>
<span class="line-removed"> 58     const size_t block_size = offset * S::count();</span>
<span class="line-removed"> 59     _top = ZUtils::alloc_aligned(block_alignment, block_size);</span>
<span class="line-removed"> 60     _end = _top + offset;</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62     // Retry allocation</span>
<span class="line-removed"> 63     return alloc(size);</span>
<span class="line-removed"> 64   }</span>
 65 };
 66 
<span class="line-removed"> 67 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_end = 0;</span>
<span class="line-removed"> 68 template &lt;typename T&gt; uintptr_t ZValueStorage&lt;T&gt;::_top = 0;</span>
<span class="line-removed"> 69 </span>
 70 class ZContendedStorage : public ZValueStorage&lt;ZContendedStorage&gt; {
 71 public:
<span class="line-modified"> 72   static size_t alignment() {</span>
<span class="line-modified"> 73     return ZCacheLineSize;</span>
<span class="line-modified"> 74   }</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76   static uint32_t count() {</span>
<span class="line-removed"> 77     return 1;</span>
<span class="line-removed"> 78   }</span>
<span class="line-removed"> 79 </span>
<span class="line-removed"> 80   static uint32_t id() {</span>
<span class="line-removed"> 81     return 0;</span>
<span class="line-removed"> 82   }</span>
 83 };
 84 
 85 class ZPerCPUStorage : public ZValueStorage&lt;ZPerCPUStorage&gt; {
 86 public:
<span class="line-modified"> 87   static size_t alignment() {</span>
<span class="line-modified"> 88     return sizeof(uintptr_t);</span>
<span class="line-modified"> 89   }</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91   static uint32_t count() {</span>
<span class="line-removed"> 92     return ZCPU::count();</span>
<span class="line-removed"> 93   }</span>
<span class="line-removed"> 94 </span>
<span class="line-removed"> 95   static uint32_t id() {</span>
<span class="line-removed"> 96     return ZCPU::id();</span>
<span class="line-removed"> 97   }</span>
 98 };
 99 
100 class ZPerNUMAStorage : public ZValueStorage&lt;ZPerNUMAStorage&gt; {
101 public:
<span class="line-modified">102   static size_t alignment() {</span>
<span class="line-modified">103     return sizeof(uintptr_t);</span>
<span class="line-modified">104   }</span>
<span class="line-removed">105 </span>
<span class="line-removed">106   static uint32_t count() {</span>
<span class="line-removed">107     return ZNUMA::count();</span>
<span class="line-removed">108   }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110   static uint32_t id() {</span>
<span class="line-removed">111     return ZNUMA::id();</span>
<span class="line-removed">112   }</span>
113 };
114 
115 class ZPerWorkerStorage : public ZValueStorage&lt;ZPerWorkerStorage&gt; {
116 public:
<span class="line-modified">117   static size_t alignment() {</span>
<span class="line-modified">118     return sizeof(uintptr_t);</span>
<span class="line-modified">119   }</span>
<span class="line-removed">120 </span>
<span class="line-removed">121   static uint32_t count() {</span>
<span class="line-removed">122     return MAX2(ParallelGCThreads, ConcGCThreads);</span>
<span class="line-removed">123   }</span>
<span class="line-removed">124 </span>
<span class="line-removed">125   static uint32_t id() {</span>
<span class="line-removed">126     return ZThread::worker_id();</span>
<span class="line-removed">127   }</span>
128 };
129 
<span class="line-modified">130 template &lt;typename S, typename T&gt;</span>
<span class="line-modified">131 class ZValueIterator;</span>

132 
133 template &lt;typename S, typename T&gt;
134 class ZValue : public CHeapObj&lt;mtGC&gt; {
135 private:
136   const uintptr_t _addr;
137 
<span class="line-modified">138   uintptr_t value_addr(uint32_t value_id) const {</span>
<span class="line-removed">139     return _addr + (value_id * S::offset);</span>
<span class="line-removed">140   }</span>
141 
142 public:
<span class="line-modified">143   ZValue() :</span>
<span class="line-modified">144       _addr(S::alloc(sizeof(T))) {</span>
<span class="line-modified">145     // Initialize all instances</span>
<span class="line-modified">146     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-modified">147     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-modified">148       ::new (addr) T;</span>
<span class="line-modified">149     }</span>
<span class="line-modified">150   }</span>
<span class="line-modified">151 </span>
<span class="line-modified">152   ZValue(const T&amp; value) :</span>
<span class="line-modified">153       _addr(S::alloc(sizeof(T))) {</span>
<span class="line-removed">154     // Initialize all instances</span>
<span class="line-removed">155     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-removed">156     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-removed">157       ::new (addr) T(value);</span>
<span class="line-removed">158     }</span>
<span class="line-removed">159   }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161   // Not implemented</span>
<span class="line-removed">162   ZValue(const ZValue&lt;S, T&gt;&amp; value);</span>
<span class="line-removed">163   ZValue&lt;S, T&gt;&amp; operator=(const ZValue&lt;S, T&gt;&amp; value);</span>
<span class="line-removed">164 </span>
<span class="line-removed">165   const T* addr(uint32_t value_id = S::id()) const {</span>
<span class="line-removed">166     return reinterpret_cast&lt;const T*&gt;(value_addr(value_id));</span>
<span class="line-removed">167   }</span>
<span class="line-removed">168 </span>
<span class="line-removed">169   T* addr(uint32_t value_id = S::id()) {</span>
<span class="line-removed">170     return reinterpret_cast&lt;T*&gt;(value_addr(value_id));</span>
<span class="line-removed">171   }</span>
<span class="line-removed">172 </span>
<span class="line-removed">173   const T&amp; get(uint32_t value_id = S::id()) const {</span>
<span class="line-removed">174     return *addr(value_id);</span>
<span class="line-removed">175   }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   T&amp; get(uint32_t value_id = S::id()) {</span>
<span class="line-removed">178     return *addr(value_id);</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   void set(const T&amp; value, uint32_t value_id = S::id()) {</span>
<span class="line-removed">182     get(value_id) = value;</span>
<span class="line-removed">183   }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   void set_all(const T&amp; value) {</span>
<span class="line-removed">186     ZValueIterator&lt;S, T&gt; iter(this);</span>
<span class="line-removed">187     for (T* addr; iter.next(&amp;addr);) {</span>
<span class="line-removed">188       *addr = value;</span>
<span class="line-removed">189     }</span>
<span class="line-removed">190   }</span>
191 };
192 
193 template &lt;typename T&gt;
194 class ZContended : public ZValue&lt;ZContendedStorage, T&gt; {
195 public:
<span class="line-modified">196   ZContended() :</span>
<span class="line-modified">197       ZValue&lt;ZContendedStorage, T&gt;() {}</span>
<span class="line-removed">198 </span>
<span class="line-removed">199   ZContended(const T&amp; value) :</span>
<span class="line-removed">200       ZValue&lt;ZContendedStorage, T&gt;(value) {}</span>
<span class="line-removed">201 </span>
<span class="line-removed">202   using ZValue&lt;ZContendedStorage, T&gt;::operator=;</span>
203 };
204 
205 template &lt;typename T&gt;
206 class ZPerCPU : public ZValue&lt;ZPerCPUStorage, T&gt; {
207 public:
<span class="line-modified">208   ZPerCPU() :</span>
<span class="line-modified">209       ZValue&lt;ZPerCPUStorage, T&gt;() {}</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   ZPerCPU(const T&amp; value) :</span>
<span class="line-removed">212       ZValue&lt;ZPerCPUStorage, T&gt;(value) {}</span>
<span class="line-removed">213 </span>
<span class="line-removed">214   using ZValue&lt;ZPerCPUStorage, T&gt;::operator=;</span>
215 };
216 
217 template &lt;typename T&gt;
218 class ZPerNUMA : public ZValue&lt;ZPerNUMAStorage, T&gt; {
219 public:
<span class="line-modified">220   ZPerNUMA() :</span>
<span class="line-modified">221       ZValue&lt;ZPerNUMAStorage, T&gt;() {}</span>
<span class="line-removed">222 </span>
<span class="line-removed">223   ZPerNUMA(const T&amp; value) :</span>
<span class="line-removed">224       ZValue&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
<span class="line-removed">225 </span>
<span class="line-removed">226   using ZValue&lt;ZPerNUMAStorage, T&gt;::operator=;</span>
227 };
228 
229 template &lt;typename T&gt;
230 class ZPerWorker : public ZValue&lt;ZPerWorkerStorage, T&gt; {
231 public:
<span class="line-modified">232   ZPerWorker() :</span>
<span class="line-modified">233       ZValue&lt;ZPerWorkerStorage, T&gt;() {}</span>
<span class="line-removed">234 </span>
<span class="line-removed">235   ZPerWorker(const T&amp; value) :</span>
<span class="line-removed">236       ZValue&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
<span class="line-removed">237 </span>
<span class="line-removed">238   using ZValue&lt;ZPerWorkerStorage, T&gt;::operator=;</span>
239 };
240 




241 template &lt;typename S, typename T&gt;
242 class ZValueIterator {
243 private:
244   ZValue&lt;S, T&gt;* const _value;
245   uint32_t            _value_id;
246 
247 public:
<span class="line-modified">248   ZValueIterator(ZValue&lt;S, T&gt;* value) :</span>
<span class="line-modified">249       _value(value),</span>
<span class="line-modified">250       _value_id(0) {}</span>
<span class="line-removed">251 </span>
<span class="line-removed">252   bool next(T** value) {</span>
<span class="line-removed">253     if (_value_id &lt; S::count()) {</span>
<span class="line-removed">254       *value = _value-&gt;addr(_value_id++);</span>
<span class="line-removed">255       return true;</span>
<span class="line-removed">256     }</span>
<span class="line-removed">257     return false;</span>
<span class="line-removed">258   }</span>
259 };
260 
261 template &lt;typename T&gt;
262 class ZPerCPUIterator : public ZValueIterator&lt;ZPerCPUStorage, T&gt; {
263 public:
<span class="line-modified">264   ZPerCPUIterator(ZPerCPU&lt;T&gt;* value) :</span>
<span class="line-removed">265       ZValueIterator&lt;ZPerCPUStorage, T&gt;(value) {}</span>
266 };
267 
268 template &lt;typename T&gt;
269 class ZPerNUMAIterator : public ZValueIterator&lt;ZPerNUMAStorage, T&gt; {
270 public:
<span class="line-modified">271   ZPerNUMAIterator(ZPerNUMA&lt;T&gt;* value) :</span>
<span class="line-removed">272       ZValueIterator&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
273 };
274 
275 template &lt;typename T&gt;
276 class ZPerWorkerIterator : public ZValueIterator&lt;ZPerWorkerStorage, T&gt; {
277 public:
<span class="line-modified">278   ZPerWorkerIterator(ZPerWorker&lt;T&gt;* value) :</span>
<span class="line-removed">279       ZValueIterator&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
280 };
281 
282 template &lt;typename S, typename T&gt;
283 class ZValueConstIterator {
284 private:
285   const ZValue&lt;S, T&gt;* const _value;
286   uint32_t                  _value_id;
287 
288 public:
<span class="line-modified">289   ZValueConstIterator(const ZValue&lt;S, T&gt;* value) :</span>
<span class="line-modified">290       _value(value),</span>
<span class="line-modified">291       _value_id(0) {}</span>
<span class="line-removed">292 </span>
<span class="line-removed">293   bool next(const T** value) {</span>
<span class="line-removed">294     if (_value_id &lt; S::count()) {</span>
<span class="line-removed">295       *value = _value-&gt;addr(_value_id++);</span>
<span class="line-removed">296       return true;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298     return false;</span>
<span class="line-removed">299   }</span>
300 };
301 
302 template &lt;typename T&gt;
303 class ZPerCPUConstIterator : public ZValueConstIterator&lt;ZPerCPUStorage, T&gt; {
304 public:
<span class="line-modified">305   ZPerCPUConstIterator(const ZPerCPU&lt;T&gt;* value) :</span>
<span class="line-removed">306       ZValueConstIterator&lt;ZPerCPUStorage, T&gt;(value) {}</span>
307 };
308 
309 template &lt;typename T&gt;
310 class ZPerNUMAConstIterator : public ZValueConstIterator&lt;ZPerNUMAStorage, T&gt; {
311 public:
<span class="line-modified">312   ZPerNUMAConstIterator(const ZPerNUMA&lt;T&gt;* value) :</span>
<span class="line-removed">313       ZValueConstIterator&lt;ZPerNUMAStorage, T&gt;(value) {}</span>
314 };
315 
316 template &lt;typename T&gt;
317 class ZPerWorkerConstIterator : public ZValueConstIterator&lt;ZPerWorkerStorage, T&gt; {
318 public:
<span class="line-modified">319   ZPerWorkerConstIterator(const ZPerWorker&lt;T&gt;* value) :</span>
<span class="line-removed">320       ZValueConstIterator&lt;ZPerWorkerStorage, T&gt;(value) {}</span>
321 };
322 
323 #endif // SHARE_GC_Z_ZVALUE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZVALUE_HPP
 25 #define SHARE_GC_Z_ZVALUE_HPP
 26 
 27 #include &quot;memory/allocation.hpp&quot;
<span class="line-modified"> 28 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
<span class="line-modified"> 29 </span>
<span class="line-modified"> 30 //</span>
<span class="line-modified"> 31 // Storage</span>
<span class="line-modified"> 32 //</span>

 33 
 34 template &lt;typename S&gt;
 35 class ZValueStorage : public AllStatic {
 36 private:
 37   static uintptr_t _top;
 38   static uintptr_t _end;
 39 
 40 public:
 41   static const size_t offset = 4 * K;
 42 
<span class="line-modified"> 43   static uintptr_t alloc(size_t size);</span>




















 44 };
 45 



 46 class ZContendedStorage : public ZValueStorage&lt;ZContendedStorage&gt; {
 47 public:
<span class="line-modified"> 48   static size_t alignment();</span>
<span class="line-modified"> 49   static uint32_t count();</span>
<span class="line-modified"> 50   static uint32_t id();</span>








 51 };
 52 
 53 class ZPerCPUStorage : public ZValueStorage&lt;ZPerCPUStorage&gt; {
 54 public:
<span class="line-modified"> 55   static size_t alignment();</span>
<span class="line-modified"> 56   static uint32_t count();</span>
<span class="line-modified"> 57   static uint32_t id();</span>








 58 };
 59 
 60 class ZPerNUMAStorage : public ZValueStorage&lt;ZPerNUMAStorage&gt; {
 61 public:
<span class="line-modified"> 62   static size_t alignment();</span>
<span class="line-modified"> 63   static uint32_t count();</span>
<span class="line-modified"> 64   static uint32_t id();</span>








 65 };
 66 
 67 class ZPerWorkerStorage : public ZValueStorage&lt;ZPerWorkerStorage&gt; {
 68 public:
<span class="line-modified"> 69   static size_t alignment();</span>
<span class="line-modified"> 70   static uint32_t count();</span>
<span class="line-modified"> 71   static uint32_t id();</span>








 72 };
 73 
<span class="line-modified"> 74 //</span>
<span class="line-modified"> 75 // Value</span>
<span class="line-added"> 76 //</span>
 77 
 78 template &lt;typename S, typename T&gt;
 79 class ZValue : public CHeapObj&lt;mtGC&gt; {
 80 private:
 81   const uintptr_t _addr;
 82 
<span class="line-modified"> 83   uintptr_t value_addr(uint32_t value_id) const;</span>


 84 
 85 public:
<span class="line-modified"> 86   ZValue();</span>
<span class="line-modified"> 87   ZValue(const T&amp; value);</span>
<span class="line-modified"> 88 </span>
<span class="line-modified"> 89   const T* addr(uint32_t value_id = S::id()) const;</span>
<span class="line-modified"> 90   T* addr(uint32_t value_id = S::id());</span>
<span class="line-modified"> 91 </span>
<span class="line-modified"> 92   const T&amp; get(uint32_t value_id = S::id()) const;</span>
<span class="line-modified"> 93   T&amp; get(uint32_t value_id = S::id());</span>
<span class="line-modified"> 94 </span>
<span class="line-modified"> 95   void set(const T&amp; value, uint32_t value_id = S::id());</span>
<span class="line-modified"> 96   void set_all(const T&amp; value);</span>





































 97 };
 98 
 99 template &lt;typename T&gt;
100 class ZContended : public ZValue&lt;ZContendedStorage, T&gt; {
101 public:
<span class="line-modified">102   ZContended();</span>
<span class="line-modified">103   ZContended(const T&amp; value);</span>





104 };
105 
106 template &lt;typename T&gt;
107 class ZPerCPU : public ZValue&lt;ZPerCPUStorage, T&gt; {
108 public:
<span class="line-modified">109   ZPerCPU();</span>
<span class="line-modified">110   ZPerCPU(const T&amp; value);</span>





111 };
112 
113 template &lt;typename T&gt;
114 class ZPerNUMA : public ZValue&lt;ZPerNUMAStorage, T&gt; {
115 public:
<span class="line-modified">116   ZPerNUMA();</span>
<span class="line-modified">117   ZPerNUMA(const T&amp; value);</span>





118 };
119 
120 template &lt;typename T&gt;
121 class ZPerWorker : public ZValue&lt;ZPerWorkerStorage, T&gt; {
122 public:
<span class="line-modified">123   ZPerWorker();</span>
<span class="line-modified">124   ZPerWorker(const T&amp; value);</span>





125 };
126 
<span class="line-added">127 //</span>
<span class="line-added">128 // Iterator</span>
<span class="line-added">129 //</span>
<span class="line-added">130 </span>
131 template &lt;typename S, typename T&gt;
132 class ZValueIterator {
133 private:
134   ZValue&lt;S, T&gt;* const _value;
135   uint32_t            _value_id;
136 
137 public:
<span class="line-modified">138   ZValueIterator(ZValue&lt;S, T&gt;* value);</span>
<span class="line-modified">139 </span>
<span class="line-modified">140   bool next(T** value);</span>








141 };
142 
143 template &lt;typename T&gt;
144 class ZPerCPUIterator : public ZValueIterator&lt;ZPerCPUStorage, T&gt; {
145 public:
<span class="line-modified">146   ZPerCPUIterator(ZPerCPU&lt;T&gt;* value);</span>

147 };
148 
149 template &lt;typename T&gt;
150 class ZPerNUMAIterator : public ZValueIterator&lt;ZPerNUMAStorage, T&gt; {
151 public:
<span class="line-modified">152   ZPerNUMAIterator(ZPerNUMA&lt;T&gt;* value);</span>

153 };
154 
155 template &lt;typename T&gt;
156 class ZPerWorkerIterator : public ZValueIterator&lt;ZPerWorkerStorage, T&gt; {
157 public:
<span class="line-modified">158   ZPerWorkerIterator(ZPerWorker&lt;T&gt;* value);</span>

159 };
160 
161 template &lt;typename S, typename T&gt;
162 class ZValueConstIterator {
163 private:
164   const ZValue&lt;S, T&gt;* const _value;
165   uint32_t                  _value_id;
166 
167 public:
<span class="line-modified">168   ZValueConstIterator(const ZValue&lt;S, T&gt;* value);</span>
<span class="line-modified">169 </span>
<span class="line-modified">170   bool next(const T** value);</span>








171 };
172 
173 template &lt;typename T&gt;
174 class ZPerCPUConstIterator : public ZValueConstIterator&lt;ZPerCPUStorage, T&gt; {
175 public:
<span class="line-modified">176   ZPerCPUConstIterator(const ZPerCPU&lt;T&gt;* value);</span>

177 };
178 
179 template &lt;typename T&gt;
180 class ZPerNUMAConstIterator : public ZValueConstIterator&lt;ZPerNUMAStorage, T&gt; {
181 public:
<span class="line-modified">182   ZPerNUMAConstIterator(const ZPerNUMA&lt;T&gt;* value);</span>

183 };
184 
185 template &lt;typename T&gt;
186 class ZPerWorkerConstIterator : public ZValueConstIterator&lt;ZPerWorkerStorage, T&gt; {
187 public:
<span class="line-modified">188   ZPerWorkerConstIterator(const ZPerWorker&lt;T&gt;* value);</span>

189 };
190 
191 #endif // SHARE_GC_Z_ZVALUE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="zUtils.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zVirtualMemory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zDriver.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zDirector.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zDriver.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zDriver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcId.hpp&quot;
 26 #include &quot;gc/shared/gcLocker.hpp&quot;
 27 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 28 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 29 #include &quot;gc/z/zDriver.hpp&quot;
 30 #include &quot;gc/z/zHeap.inline.hpp&quot;
 31 #include &quot;gc/z/zMessagePort.inline.hpp&quot;
 32 #include &quot;gc/z/zServiceability.hpp&quot;
 33 #include &quot;gc/z/zStat.hpp&quot;

 34 #include &quot;logging/log.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;runtime/vmOperations.hpp&quot;
 37 #include &quot;runtime/vmThread.hpp&quot;
 38 
 39 static const ZStatPhaseCycle      ZPhaseCycle(&quot;Garbage Collection Cycle&quot;);
 40 static const ZStatPhasePause      ZPhasePauseMarkStart(&quot;Pause Mark Start&quot;);
 41 static const ZStatPhaseConcurrent ZPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
 42 static const ZStatPhaseConcurrent ZPhaseConcurrentMarkContinue(&quot;Concurrent Mark Continue&quot;);
 43 static const ZStatPhasePause      ZPhasePauseMarkEnd(&quot;Pause Mark End&quot;);
 44 static const ZStatPhaseConcurrent ZPhaseConcurrentProcessNonStrongReferences(&quot;Concurrent Process Non-Strong References&quot;);
 45 static const ZStatPhaseConcurrent ZPhaseConcurrentResetRelocationSet(&quot;Concurrent Reset Relocation Set&quot;);
<span class="line-removed"> 46 static const ZStatPhaseConcurrent ZPhaseConcurrentDestroyDetachedPages(&quot;Concurrent Destroy Detached Pages&quot;);</span>
 47 static const ZStatPhaseConcurrent ZPhaseConcurrentSelectRelocationSet(&quot;Concurrent Select Relocation Set&quot;);
<span class="line-removed"> 48 static const ZStatPhaseConcurrent ZPhaseConcurrentPrepareRelocationSet(&quot;Concurrent Prepare Relocation Set&quot;);</span>
 49 static const ZStatPhasePause      ZPhasePauseRelocateStart(&quot;Pause Relocate Start&quot;);
 50 static const ZStatPhaseConcurrent ZPhaseConcurrentRelocated(&quot;Concurrent Relocate&quot;);
 51 static const ZStatCriticalPhase   ZCriticalPhaseGCLockerStall(&quot;GC Locker Stall&quot;, false /* verbose */);
 52 static const ZStatSampler         ZSamplerJavaThreads(&quot;System&quot;, &quot;Java Threads&quot;, ZStatUnitThreads);
 53 
 54 class VM_ZOperation : public VM_Operation {
 55 private:
 56   const uint _gc_id;
 57   bool       _gc_locked;
 58   bool       _success;
 59 
 60 public:
 61   VM_ZOperation() :
 62       _gc_id(GCId::current()),
 63       _gc_locked(false),
 64       _success(false) {}
 65 
 66   virtual bool needs_inactive_gc_locker() const {
 67     // An inactive GC locker is needed in operations where we change the bad
 68     // mask or move objects. Changing the bad mask will invalidate all oops,
</pre>
<hr />
<pre>
 71   }
 72 
 73   virtual bool do_operation() = 0;
 74 
 75   virtual bool doit_prologue() {
 76     Heap_lock-&gt;lock();
 77     return true;
 78   }
 79 
 80   virtual void doit() {
 81     // Abort if GC locker state is incompatible
 82     if (needs_inactive_gc_locker() &amp;&amp; GCLocker::check_active_before_gc()) {
 83       _gc_locked = true;
 84       return;
 85     }
 86 
 87     // Setup GC id and active marker
 88     GCIdMark gc_id_mark(_gc_id);
 89     IsGCActiveMark gc_active_mark;
 90 



 91     // Execute operation
 92     _success = do_operation();
 93 
 94     // Update statistics
 95     ZStatSample(ZSamplerJavaThreads, Threads::number_of_threads());
 96   }
 97 
 98   virtual void doit_epilogue() {
 99     Heap_lock-&gt;unlock();
100   }
101 
102   bool gc_locked() const {
103     return _gc_locked;
104   }
105 
106   bool success() const {
107     return _success;
108   }
109 };
110 
</pre>
<hr />
<pre>
192 };
193 
194 class VM_ZRelocateStart : public VM_ZOperation {
195 public:
196   virtual VMOp_Type type() const {
197     return VMOp_ZRelocateStart;
198   }
199 
200   virtual bool needs_inactive_gc_locker() const {
201     return true;
202   }
203 
204   virtual bool do_operation() {
205     ZStatTimer timer(ZPhasePauseRelocateStart);
206     ZServiceabilityRelocateStartTracer tracer;
207     ZHeap::heap()-&gt;relocate_start();
208     return true;
209   }
210 };
211 











212 ZDriver::ZDriver() :
213     _gc_cycle_port(),
214     _gc_locker_port() {
215   set_name(&quot;ZDriver&quot;);
216   create_and_start();
217 }
218 
219 void ZDriver::collect(GCCause::Cause cause) {
220   switch (cause) {
221   case GCCause::_wb_young_gc:
222   case GCCause::_wb_conc_mark:
223   case GCCause::_wb_full_gc:
224   case GCCause::_dcmd_gc_run:
225   case GCCause::_java_lang_system_gc:
226   case GCCause::_full_gc_alot:
227   case GCCause::_scavenge_alot:
228   case GCCause::_jvmti_force_gc:
229   case GCCause::_metadata_GC_clear_soft_refs:
230     // Start synchronous GC
231     _gc_cycle_port.send_sync(cause);
232     break;
233 
234   case GCCause::_z_timer:
235   case GCCause::_z_warmup:
236   case GCCause::_z_allocation_rate:
237   case GCCause::_z_allocation_stall:
238   case GCCause::_z_proactive:

239   case GCCause::_metadata_GC_threshold:
240     // Start asynchronous GC
241     _gc_cycle_port.send_async(cause);
242     break;
243 
244   case GCCause::_gc_locker:
245     // Restart VM operation previously blocked by the GC locker
246     _gc_locker_port.signal();
247     break;
248 
249   default:
250     // Other causes not supported
251     fatal(&quot;Unsupported GC cause (%s)&quot;, GCCause::to_string(cause));
252     break;
253   }
254 }
255 
256 template &lt;typename T&gt;
257 bool ZDriver::pause() {
258   for (;;) {
</pre>
<hr />
<pre>
283 
284 bool ZDriver::pause_mark_end() {
285   return pause&lt;VM_ZMarkEnd&gt;();
286 }
287 
288 void ZDriver::concurrent_mark_continue() {
289   ZStatTimer timer(ZPhaseConcurrentMarkContinue);
290   ZHeap::heap()-&gt;mark(false /* initial */);
291 }
292 
293 void ZDriver::concurrent_process_non_strong_references() {
294   ZStatTimer timer(ZPhaseConcurrentProcessNonStrongReferences);
295   ZHeap::heap()-&gt;process_non_strong_references();
296 }
297 
298 void ZDriver::concurrent_reset_relocation_set() {
299   ZStatTimer timer(ZPhaseConcurrentResetRelocationSet);
300   ZHeap::heap()-&gt;reset_relocation_set();
301 }
302 
<span class="line-removed">303 void ZDriver::concurrent_destroy_detached_pages() {</span>
<span class="line-removed">304   ZStatTimer timer(ZPhaseConcurrentDestroyDetachedPages);</span>
<span class="line-removed">305   ZHeap::heap()-&gt;destroy_detached_pages();</span>
<span class="line-removed">306 }</span>
<span class="line-removed">307 </span>
308 void ZDriver::pause_verify() {
309   if (VerifyBeforeGC || VerifyDuringGC || VerifyAfterGC) {

310     VM_Verify op;
311     VMThread::execute(&amp;op);




312   }
313 }
314 
315 void ZDriver::concurrent_select_relocation_set() {
316   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
317   ZHeap::heap()-&gt;select_relocation_set();
318 }
319 
<span class="line-removed">320 void ZDriver::concurrent_prepare_relocation_set() {</span>
<span class="line-removed">321   ZStatTimer timer(ZPhaseConcurrentPrepareRelocationSet);</span>
<span class="line-removed">322   ZHeap::heap()-&gt;prepare_relocation_set();</span>
<span class="line-removed">323 }</span>
<span class="line-removed">324 </span>
325 void ZDriver::pause_relocate_start() {
326   pause&lt;VM_ZRelocateStart&gt;();
327 }
328 
329 void ZDriver::concurrent_relocate() {
330   ZStatTimer timer(ZPhaseConcurrentRelocated);
331   ZHeap::heap()-&gt;relocate();
332 }
333 
334 void ZDriver::check_out_of_memory() {
335   ZHeap::heap()-&gt;check_out_of_memory();
336 }
337 
338 class ZDriverGCScope : public StackObj {
339 private:
<span class="line-modified">340   GCIdMark      _gc_id;</span>
<span class="line-modified">341   GCCauseSetter _gc_cause_setter;</span>
<span class="line-modified">342   ZStatTimer    _timer;</span>

343 
344 public:
345   ZDriverGCScope(GCCause::Cause cause) :
346       _gc_id(),

347       _gc_cause_setter(ZCollectedHeap::heap(), cause),
348       _timer(ZPhaseCycle) {
349     // Update statistics
350     ZStatCycle::at_start();
351   }
352 
353   ~ZDriverGCScope() {
354     // Calculate boost factor
355     const double boost_factor = (double)ZHeap::heap()-&gt;nconcurrent_worker_threads() /
356                                 (double)ZHeap::heap()-&gt;nconcurrent_no_boost_worker_threads();
357 
358     // Update statistics
<span class="line-modified">359     ZStatCycle::at_end(boost_factor);</span>
360 
361     // Update data used by soft reference policy
362     Universe::update_heap_info_at_gc();
363   }
364 };
365 
366 void ZDriver::gc(GCCause::Cause cause) {
367   ZDriverGCScope scope(cause);
368 
369   // Phase 1: Pause Mark Start
370   pause_mark_start();
371 
372   // Phase 2: Concurrent Mark
373   concurrent_mark();
374 
375   // Phase 3: Pause Mark End
376   while (!pause_mark_end()) {
377     // Phase 3.5: Concurrent Mark Continue
378     concurrent_mark_continue();
379   }
380 
381   // Phase 4: Concurrent Process Non-Strong References
382   concurrent_process_non_strong_references();
383 
384   // Phase 5: Concurrent Reset Relocation Set
385   concurrent_reset_relocation_set();
386 
<span class="line-modified">387   // Phase 6: Concurrent Destroy Detached Pages</span>
<span class="line-removed">388   concurrent_destroy_detached_pages();</span>
<span class="line-removed">389 </span>
<span class="line-removed">390   // Phase 7: Pause Verify</span>
391   pause_verify();
392 
<span class="line-modified">393   // Phase 8: Concurrent Select Relocation Set</span>
394   concurrent_select_relocation_set();
395 
<span class="line-modified">396   // Phase 9: Concurrent Prepare Relocation Set</span>
<span class="line-removed">397   concurrent_prepare_relocation_set();</span>
<span class="line-removed">398 </span>
<span class="line-removed">399   // Phase 10: Pause Relocate Start</span>
400   pause_relocate_start();
401 
<span class="line-modified">402   // Phase 11: Concurrent Relocate</span>
403   concurrent_relocate();
404 }
405 
406 void ZDriver::run_service() {
407   // Main loop
408   while (!should_terminate()) {
409     // Wait for GC request
410     const GCCause::Cause cause = _gc_cycle_port.receive();
411     if (cause == GCCause::_no_gc) {
412       continue;
413     }
414 
415     // Run GC
416     gc(cause);
417 
418     // Notify GC completed
419     _gc_cycle_port.ack();
420 
421     // Check for out of memory condition
422     check_out_of_memory();
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/shared/gcId.hpp&quot;
 26 #include &quot;gc/shared/gcLocker.hpp&quot;
 27 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
 28 #include &quot;gc/z/zCollectedHeap.hpp&quot;
 29 #include &quot;gc/z/zDriver.hpp&quot;
 30 #include &quot;gc/z/zHeap.inline.hpp&quot;
 31 #include &quot;gc/z/zMessagePort.inline.hpp&quot;
 32 #include &quot;gc/z/zServiceability.hpp&quot;
 33 #include &quot;gc/z/zStat.hpp&quot;
<span class="line-added"> 34 #include &quot;gc/z/zVerify.hpp&quot;</span>
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;runtime/vmOperations.hpp&quot;
 38 #include &quot;runtime/vmThread.hpp&quot;
 39 
 40 static const ZStatPhaseCycle      ZPhaseCycle(&quot;Garbage Collection Cycle&quot;);
 41 static const ZStatPhasePause      ZPhasePauseMarkStart(&quot;Pause Mark Start&quot;);
 42 static const ZStatPhaseConcurrent ZPhaseConcurrentMark(&quot;Concurrent Mark&quot;);
 43 static const ZStatPhaseConcurrent ZPhaseConcurrentMarkContinue(&quot;Concurrent Mark Continue&quot;);
 44 static const ZStatPhasePause      ZPhasePauseMarkEnd(&quot;Pause Mark End&quot;);
 45 static const ZStatPhaseConcurrent ZPhaseConcurrentProcessNonStrongReferences(&quot;Concurrent Process Non-Strong References&quot;);
 46 static const ZStatPhaseConcurrent ZPhaseConcurrentResetRelocationSet(&quot;Concurrent Reset Relocation Set&quot;);

 47 static const ZStatPhaseConcurrent ZPhaseConcurrentSelectRelocationSet(&quot;Concurrent Select Relocation Set&quot;);

 48 static const ZStatPhasePause      ZPhasePauseRelocateStart(&quot;Pause Relocate Start&quot;);
 49 static const ZStatPhaseConcurrent ZPhaseConcurrentRelocated(&quot;Concurrent Relocate&quot;);
 50 static const ZStatCriticalPhase   ZCriticalPhaseGCLockerStall(&quot;GC Locker Stall&quot;, false /* verbose */);
 51 static const ZStatSampler         ZSamplerJavaThreads(&quot;System&quot;, &quot;Java Threads&quot;, ZStatUnitThreads);
 52 
 53 class VM_ZOperation : public VM_Operation {
 54 private:
 55   const uint _gc_id;
 56   bool       _gc_locked;
 57   bool       _success;
 58 
 59 public:
 60   VM_ZOperation() :
 61       _gc_id(GCId::current()),
 62       _gc_locked(false),
 63       _success(false) {}
 64 
 65   virtual bool needs_inactive_gc_locker() const {
 66     // An inactive GC locker is needed in operations where we change the bad
 67     // mask or move objects. Changing the bad mask will invalidate all oops,
</pre>
<hr />
<pre>
 70   }
 71 
 72   virtual bool do_operation() = 0;
 73 
 74   virtual bool doit_prologue() {
 75     Heap_lock-&gt;lock();
 76     return true;
 77   }
 78 
 79   virtual void doit() {
 80     // Abort if GC locker state is incompatible
 81     if (needs_inactive_gc_locker() &amp;&amp; GCLocker::check_active_before_gc()) {
 82       _gc_locked = true;
 83       return;
 84     }
 85 
 86     // Setup GC id and active marker
 87     GCIdMark gc_id_mark(_gc_id);
 88     IsGCActiveMark gc_active_mark;
 89 
<span class="line-added"> 90     // Verify before operation</span>
<span class="line-added"> 91     ZVerify::before_zoperation();</span>
<span class="line-added"> 92 </span>
 93     // Execute operation
 94     _success = do_operation();
 95 
 96     // Update statistics
 97     ZStatSample(ZSamplerJavaThreads, Threads::number_of_threads());
 98   }
 99 
100   virtual void doit_epilogue() {
101     Heap_lock-&gt;unlock();
102   }
103 
104   bool gc_locked() const {
105     return _gc_locked;
106   }
107 
108   bool success() const {
109     return _success;
110   }
111 };
112 
</pre>
<hr />
<pre>
194 };
195 
196 class VM_ZRelocateStart : public VM_ZOperation {
197 public:
198   virtual VMOp_Type type() const {
199     return VMOp_ZRelocateStart;
200   }
201 
202   virtual bool needs_inactive_gc_locker() const {
203     return true;
204   }
205 
206   virtual bool do_operation() {
207     ZStatTimer timer(ZPhasePauseRelocateStart);
208     ZServiceabilityRelocateStartTracer tracer;
209     ZHeap::heap()-&gt;relocate_start();
210     return true;
211   }
212 };
213 
<span class="line-added">214 class VM_ZVerify : public VM_Operation {</span>
<span class="line-added">215 public:</span>
<span class="line-added">216   virtual VMOp_Type type() const {</span>
<span class="line-added">217     return VMOp_ZVerify;</span>
<span class="line-added">218   }</span>
<span class="line-added">219 </span>
<span class="line-added">220   virtual void doit() {</span>
<span class="line-added">221     ZVerify::after_weak_processing();</span>
<span class="line-added">222   }</span>
<span class="line-added">223 };</span>
<span class="line-added">224 </span>
225 ZDriver::ZDriver() :
226     _gc_cycle_port(),
227     _gc_locker_port() {
228   set_name(&quot;ZDriver&quot;);
229   create_and_start();
230 }
231 
232 void ZDriver::collect(GCCause::Cause cause) {
233   switch (cause) {
234   case GCCause::_wb_young_gc:
235   case GCCause::_wb_conc_mark:
236   case GCCause::_wb_full_gc:
237   case GCCause::_dcmd_gc_run:
238   case GCCause::_java_lang_system_gc:
239   case GCCause::_full_gc_alot:
240   case GCCause::_scavenge_alot:
241   case GCCause::_jvmti_force_gc:
242   case GCCause::_metadata_GC_clear_soft_refs:
243     // Start synchronous GC
244     _gc_cycle_port.send_sync(cause);
245     break;
246 
247   case GCCause::_z_timer:
248   case GCCause::_z_warmup:
249   case GCCause::_z_allocation_rate:
250   case GCCause::_z_allocation_stall:
251   case GCCause::_z_proactive:
<span class="line-added">252   case GCCause::_z_high_usage:</span>
253   case GCCause::_metadata_GC_threshold:
254     // Start asynchronous GC
255     _gc_cycle_port.send_async(cause);
256     break;
257 
258   case GCCause::_gc_locker:
259     // Restart VM operation previously blocked by the GC locker
260     _gc_locker_port.signal();
261     break;
262 
263   default:
264     // Other causes not supported
265     fatal(&quot;Unsupported GC cause (%s)&quot;, GCCause::to_string(cause));
266     break;
267   }
268 }
269 
270 template &lt;typename T&gt;
271 bool ZDriver::pause() {
272   for (;;) {
</pre>
<hr />
<pre>
297 
298 bool ZDriver::pause_mark_end() {
299   return pause&lt;VM_ZMarkEnd&gt;();
300 }
301 
302 void ZDriver::concurrent_mark_continue() {
303   ZStatTimer timer(ZPhaseConcurrentMarkContinue);
304   ZHeap::heap()-&gt;mark(false /* initial */);
305 }
306 
307 void ZDriver::concurrent_process_non_strong_references() {
308   ZStatTimer timer(ZPhaseConcurrentProcessNonStrongReferences);
309   ZHeap::heap()-&gt;process_non_strong_references();
310 }
311 
312 void ZDriver::concurrent_reset_relocation_set() {
313   ZStatTimer timer(ZPhaseConcurrentResetRelocationSet);
314   ZHeap::heap()-&gt;reset_relocation_set();
315 }
316 





317 void ZDriver::pause_verify() {
318   if (VerifyBeforeGC || VerifyDuringGC || VerifyAfterGC) {
<span class="line-added">319     // Full verification</span>
320     VM_Verify op;
321     VMThread::execute(&amp;op);
<span class="line-added">322   } else if (ZVerifyRoots || ZVerifyObjects) {</span>
<span class="line-added">323     // Limited verification</span>
<span class="line-added">324     VM_ZVerify op;</span>
<span class="line-added">325     VMThread::execute(&amp;op);</span>
326   }
327 }
328 
329 void ZDriver::concurrent_select_relocation_set() {
330   ZStatTimer timer(ZPhaseConcurrentSelectRelocationSet);
331   ZHeap::heap()-&gt;select_relocation_set();
332 }
333 





334 void ZDriver::pause_relocate_start() {
335   pause&lt;VM_ZRelocateStart&gt;();
336 }
337 
338 void ZDriver::concurrent_relocate() {
339   ZStatTimer timer(ZPhaseConcurrentRelocated);
340   ZHeap::heap()-&gt;relocate();
341 }
342 
343 void ZDriver::check_out_of_memory() {
344   ZHeap::heap()-&gt;check_out_of_memory();
345 }
346 
347 class ZDriverGCScope : public StackObj {
348 private:
<span class="line-modified">349   GCIdMark       _gc_id;</span>
<span class="line-modified">350   GCCause::Cause _gc_cause;</span>
<span class="line-modified">351   GCCauseSetter  _gc_cause_setter;</span>
<span class="line-added">352   ZStatTimer     _timer;</span>
353 
354 public:
355   ZDriverGCScope(GCCause::Cause cause) :
356       _gc_id(),
<span class="line-added">357       _gc_cause(cause),</span>
358       _gc_cause_setter(ZCollectedHeap::heap(), cause),
359       _timer(ZPhaseCycle) {
360     // Update statistics
361     ZStatCycle::at_start();
362   }
363 
364   ~ZDriverGCScope() {
365     // Calculate boost factor
366     const double boost_factor = (double)ZHeap::heap()-&gt;nconcurrent_worker_threads() /
367                                 (double)ZHeap::heap()-&gt;nconcurrent_no_boost_worker_threads();
368 
369     // Update statistics
<span class="line-modified">370     ZStatCycle::at_end(_gc_cause, boost_factor);</span>
371 
372     // Update data used by soft reference policy
373     Universe::update_heap_info_at_gc();
374   }
375 };
376 
377 void ZDriver::gc(GCCause::Cause cause) {
378   ZDriverGCScope scope(cause);
379 
380   // Phase 1: Pause Mark Start
381   pause_mark_start();
382 
383   // Phase 2: Concurrent Mark
384   concurrent_mark();
385 
386   // Phase 3: Pause Mark End
387   while (!pause_mark_end()) {
388     // Phase 3.5: Concurrent Mark Continue
389     concurrent_mark_continue();
390   }
391 
392   // Phase 4: Concurrent Process Non-Strong References
393   concurrent_process_non_strong_references();
394 
395   // Phase 5: Concurrent Reset Relocation Set
396   concurrent_reset_relocation_set();
397 
<span class="line-modified">398   // Phase 6: Pause Verify</span>



399   pause_verify();
400 
<span class="line-modified">401   // Phase 7: Concurrent Select Relocation Set</span>
402   concurrent_select_relocation_set();
403 
<span class="line-modified">404   // Phase 8: Pause Relocate Start</span>



405   pause_relocate_start();
406 
<span class="line-modified">407   // Phase 9: Concurrent Relocate</span>
408   concurrent_relocate();
409 }
410 
411 void ZDriver::run_service() {
412   // Main loop
413   while (!should_terminate()) {
414     // Wait for GC request
415     const GCCause::Cause cause = _gc_cycle_port.receive();
416     if (cause == GCCause::_no_gc) {
417       continue;
418     }
419 
420     // Run GC
421     gc(cause);
422 
423     // Notify GC completed
424     _gc_cycle_port.ack();
425 
426     // Check for out of memory condition
427     check_out_of_memory();
</pre>
</td>
</tr>
</table>
<center><a href="zDirector.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zDriver.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/c2/zBarrierSetC2.hpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="zBarrierSetC2.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../vmStructs_z.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/c2/zBarrierSetC2.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,151 ***</span>
  #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;opto/node.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
<span class="line-modified">! class LoadBarrierNode : public MultiNode {</span>
<span class="line-modified">! private:</span>
<span class="line-modified">!   bool _weak;               // On strong or weak oop reference</span>
<span class="line-removed">-   bool _writeback;          // Controls if the barrier writes the healed oop back to memory</span>
<span class="line-removed">-                             // A swap on a memory location must never write back the healed oop</span>
<span class="line-removed">-   bool _oop_reload_allowed; // Controls if the barrier are allowed to reload the oop from memory</span>
<span class="line-removed">-                             // before healing, otherwise both the oop and the address must be</span>
<span class="line-removed">-                             // passed to the barrier from the oop</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static bool is_dominator(PhaseIdealLoop* phase, bool linear_only, Node *d, Node *n);</span>
<span class="line-removed">-   void push_dominated_barriers(PhaseIterGVN* igvn) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   enum {</span>
<span class="line-removed">-     Control,</span>
<span class="line-removed">-     Memory,</span>
<span class="line-removed">-     Oop,</span>
<span class="line-removed">-     Address,</span>
<span class="line-removed">-     Number_of_Outputs = Address,</span>
<span class="line-removed">-     Similar,</span>
<span class="line-removed">-     Number_of_Inputs</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   LoadBarrierNode(Compile* C,</span>
<span class="line-removed">-                   Node* c,</span>
<span class="line-removed">-                   Node* mem,</span>
<span class="line-removed">-                   Node* val,</span>
<span class="line-removed">-                   Node* adr,</span>
<span class="line-removed">-                   bool weak,</span>
<span class="line-removed">-                   bool writeback,</span>
<span class="line-removed">-                   bool oop_reload_allowed);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual int Opcode() const;</span>
<span class="line-removed">-   virtual uint size_of() const;</span>
<span class="line-removed">-   virtual uint cmp(const Node&amp; n) const;</span>
<span class="line-removed">-   virtual const Type *bottom_type() const;</span>
<span class="line-removed">-   virtual const TypePtr* adr_type() const;</span>
<span class="line-removed">-   virtual const Type *Value(PhaseGVN *phase) const;</span>
<span class="line-removed">-   virtual Node *Identity(PhaseGVN *phase);</span>
<span class="line-removed">-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);</span>
<span class="line-removed">-   virtual uint match_edge(uint idx) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   LoadBarrierNode* has_dominating_barrier(PhaseIdealLoop* phase,</span>
<span class="line-removed">-                                           bool linear_only,</span>
<span class="line-removed">-                                           bool look_for_similar);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void fix_similar_in_uses(PhaseIterGVN* igvn);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool has_true_uses() const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool can_be_eliminated() const {</span>
<span class="line-removed">-     return !in(Similar)-&gt;is_top();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool is_weak() const {</span>
<span class="line-removed">-     return _weak;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool is_writeback() const {</span>
<span class="line-removed">-     return _writeback;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool oop_reload_allowed() const {</span>
<span class="line-removed">-     return _oop_reload_allowed;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class LoadBarrierSlowRegNode : public LoadPNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   LoadBarrierSlowRegNode(Node *c,</span>
<span class="line-removed">-                          Node *mem,</span>
<span class="line-removed">-                          Node *adr,</span>
<span class="line-removed">-                          const TypePtr *at,</span>
<span class="line-removed">-                          const TypePtr* t,</span>
<span class="line-removed">-                          MemOrd mo,</span>
<span class="line-removed">-                          ControlDependency control_dependency = DependsOnlyOnTest) :</span>
<span class="line-removed">-       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {</span>
<span class="line-removed">-     init_class_id(Class_LoadBarrierSlowReg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual const char * name() {</span>
<span class="line-removed">-     return &quot;LoadBarrierSlowRegNode&quot;;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual int Opcode() const;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class LoadBarrierWeakSlowRegNode : public LoadPNode {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   LoadBarrierWeakSlowRegNode(Node *c,</span>
<span class="line-removed">-                              Node *mem,</span>
<span class="line-removed">-                              Node *adr,</span>
<span class="line-removed">-                              const TypePtr *at,</span>
<span class="line-removed">-                              const TypePtr* t,</span>
<span class="line-removed">-                              MemOrd mo,</span>
<span class="line-removed">-                              ControlDependency control_dependency = DependsOnlyOnTest) :</span>
<span class="line-removed">-       LoadPNode(c, mem, adr, at, t, mo, control_dependency) {</span>
<span class="line-removed">-     init_class_id(Class_LoadBarrierWeakSlowReg);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual const char * name() {</span>
<span class="line-removed">-     return &quot;LoadBarrierWeakSlowRegNode&quot;;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual int Opcode() const;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ZBarrierSetC2State : public ResourceObj {</span>
  private:
<span class="line-modified">!   // List of load barrier nodes which need to be expanded before matching</span>
<span class="line-modified">!   GrowableArray&lt;LoadBarrierNode*&gt;* _load_barrier_nodes;</span>
  
  public:
<span class="line-modified">!   ZBarrierSetC2State(Arena* comp_arena);</span>
<span class="line-modified">!   int load_barrier_count() const;</span>
<span class="line-modified">!   void add_load_barrier_node(LoadBarrierNode* n);</span>
<span class="line-modified">!   void remove_load_barrier_node(LoadBarrierNode* n);</span>
<span class="line-modified">!   LoadBarrierNode* load_barrier_node(int idx) const;</span>
  };
  
  class ZBarrierSetC2 : public BarrierSetC2 {
  private:
<span class="line-modified">!   ZBarrierSetC2State* state() const;</span>
<span class="line-modified">!   Node* make_cas_loadbarrier(C2AtomicParseAccess&amp; access) const;</span>
<span class="line-removed">-   Node* make_cmpx_loadbarrier(C2AtomicParseAccess&amp; access) const;</span>
<span class="line-removed">-   void expand_loadbarrier_basic(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;</span>
<span class="line-removed">-   void expand_loadbarrier_node(PhaseMacroExpand* phase, LoadBarrierNode* barrier) const;</span>
<span class="line-removed">-   void expand_loadbarrier_optimized(PhaseMacroExpand* phase, LoadBarrierNode *barrier) const;</span>
<span class="line-removed">-   const TypeFunc* load_barrier_Type() const;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   void verify_gc_barriers(bool post_parse) const;</span>
<span class="line-removed">- #endif</span>
  
  protected:
    virtual Node* load_at_resolved(C2Access&amp; access, const Type* val_type) const;
    virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access,
                                                 Node* expected_val,
<span class="line-new-header">--- 27,42 ---</span>
  #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;opto/node.hpp&quot;
  #include &quot;utilities/growableArray.hpp&quot;
  
<span class="line-modified">! const uint8_t ZLoadBarrierStrong = 1;</span>
<span class="line-modified">! const uint8_t ZLoadBarrierWeak   = 2;</span>
<span class="line-modified">! const uint8_t ZLoadBarrierElided = 3;</span>
  
<span class="line-modified">! class ZLoadBarrierStubC2 : public ResourceObj {</span>
  private:
<span class="line-modified">!   const MachNode* _node;</span>
<span class="line-modified">!   const Address   _ref_addr;</span>
<span class="line-added">+   const Register  _ref;</span>
<span class="line-added">+   const Register  _tmp;</span>
<span class="line-added">+   const bool      _weak;</span>
<span class="line-added">+   Label           _entry;</span>
<span class="line-added">+   Label           _continuation;</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak);</span>
  
  public:
<span class="line-modified">!   static ZLoadBarrierStubC2* create(const MachNode* node, Address ref_addr, Register ref, Register tmp, bool weak);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Address ref_addr() const;</span>
<span class="line-modified">!   Register ref() const;</span>
<span class="line-modified">!   Register tmp() const;</span>
<span class="line-added">+   address slow_path() const;</span>
<span class="line-added">+   RegMask&amp; live() const;</span>
<span class="line-added">+   Label* entry();</span>
<span class="line-added">+   Label* continuation();</span>
  };
  
  class ZBarrierSetC2 : public BarrierSetC2 {
  private:
<span class="line-modified">!   void compute_liveness_at_stubs() const;</span>
<span class="line-modified">!   void analyze_dominating_barriers() const;</span>
  
  protected:
    virtual Node* load_at_resolved(C2Access&amp; access, const Type* val_type) const;
    virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess&amp; access,
                                                 Node* expected_val,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,43 ***</span>
    virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access,
                                          Node* new_val,
                                          const Type* val_type) const;
  
  public:
<span class="line-removed">-   Node* load_barrier(GraphKit* kit,</span>
<span class="line-removed">-                      Node* val,</span>
<span class="line-removed">-                      Node* adr,</span>
<span class="line-removed">-                      bool weak = false,</span>
<span class="line-removed">-                      bool writeback = true,</span>
<span class="line-removed">-                      bool oop_reload_allowed = true) const;</span>
<span class="line-removed">- </span>
    virtual void* create_barrier_state(Arena* comp_arena) const;
<span class="line-modified">!   virtual bool has_load_barriers() const { return true; }</span>
<span class="line-modified">!   virtual bool is_gc_barrier_node(Node* node) const;</span>
<span class="line-modified">!   virtual void eliminate_gc_barrier(PhaseMacroExpand* macro, Node* node) const { }</span>
<span class="line-modified">!   virtual void eliminate_useless_gc_barriers(Unique_Node_List &amp;useful, Compile* C) const;</span>
<span class="line-modified">!   virtual void add_users_to_worklist(Unique_Node_List* worklist) const;</span>
<span class="line-modified">!   virtual void enqueue_useful_gc_barrier(PhaseIterGVN* igvn, Node* node) const;</span>
<span class="line-modified">!   virtual void register_potential_barrier_node(Node* node) const;</span>
<span class="line-modified">!   virtual void unregister_potential_barrier_node(Node* node) const;</span>
<span class="line-modified">!   virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const;</span>
<span class="line-modified">!   virtual Node* step_over_gc_barrier(Node* c) const;</span>
<span class="line-removed">-   // If the BarrierSetC2 state has kept barrier nodes in its compilation unit state to be</span>
<span class="line-removed">-   // expanded later, then now is the time to do so.</span>
<span class="line-removed">-   virtual bool expand_barriers(Compile* C, PhaseIterGVN&amp; igvn) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static void find_dominating_barriers(PhaseIterGVN&amp; igvn);</span>
<span class="line-removed">-   static void loop_optimize_gc_barrier(PhaseIdealLoop* phase, Node* node, bool last_round);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual bool matcher_find_shared_visit(Matcher* matcher, Matcher::MStack&amp; mstack, Node* n, uint opcode, bool&amp; mem_op, int&amp; mem_addr_idx) const;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   virtual void verify_gc_barriers(Compile* compile, CompilePhase phase) const;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual bool escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const;</span>
<span class="line-removed">-   virtual bool escape_add_final_edges(ConnectionGraph* conn_graph, PhaseGVN* gvn, Node* n, uint opcode) const;</span>
  };
  
  #endif // SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
<span class="line-new-header">--- 75,19 ---</span>
    virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess&amp; access,
                                          Node* new_val,
                                          const Type* val_type) const;
  
  public:
    virtual void* create_barrier_state(Arena* comp_arena) const;
<span class="line-modified">!   virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc,</span>
<span class="line-modified">!                                                BasicType type,</span>
<span class="line-modified">!                                                bool is_clone,</span>
<span class="line-modified">!                                                ArrayCopyPhase phase) const;</span>
<span class="line-modified">!   virtual void clone_at_expansion(PhaseMacroExpand* phase,</span>
<span class="line-modified">!                                   ArrayCopyNode* ac) const;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   virtual void late_barrier_analysis() const;</span>
<span class="line-modified">!   virtual int estimate_stub_size() const;</span>
<span class="line-modified">!   virtual void emit_stubs(CodeBuffer&amp; cb) const;</span>
  };
  
  #endif // SHARE_GC_Z_C2_ZBARRIERSETC2_HPP
</pre>
<center><a href="zBarrierSetC2.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../vmStructs_z.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
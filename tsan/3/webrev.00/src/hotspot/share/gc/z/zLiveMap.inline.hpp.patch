diff a/src/hotspot/share/gc/z/zLiveMap.inline.hpp b/src/hotspot/share/gc/z/zLiveMap.inline.hpp
--- a/src/hotspot/share/gc/z/zLiveMap.inline.hpp
+++ b/src/hotspot/share/gc/z/zLiveMap.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -36,11 +36,11 @@
 inline void ZLiveMap::reset() {
   _seqnum = 0;
 }
 
 inline bool ZLiveMap::is_marked() const {
-  return _seqnum == ZGlobalSeqNum;
+  return Atomic::load_acquire(&_seqnum) == ZGlobalSeqNum;
 }
 
 inline uint32_t ZLiveMap::live_objects() const {
   assert(ZGlobalPhase != ZPhaseMark, "Invalid phase");
   return _live_objects;
@@ -66,19 +66,19 @@
 inline BitMapView ZLiveMap::segment_claim_bits() {
   return BitMapView(&_segment_claim_bits, nsegments);
 }
 
 inline bool ZLiveMap::is_segment_live(BitMap::idx_t segment) const {
-  return segment_live_bits().at(segment);
+  return segment_live_bits().par_at(segment);
 }
 
-inline bool ZLiveMap::set_segment_live_atomic(BitMap::idx_t segment) {
-  return segment_live_bits().par_set_bit(segment);
+inline bool ZLiveMap::set_segment_live(BitMap::idx_t segment) {
+  return segment_live_bits().par_set_bit(segment, memory_order_release);
 }
 
 inline bool ZLiveMap::claim_segment(BitMap::idx_t segment) {
-  return segment_claim_bits().par_set_bit(segment);
+  return segment_claim_bits().par_set_bit(segment, memory_order_acq_rel);
 }
 
 inline BitMap::idx_t ZLiveMap::first_live_segment() const {
   return segment_live_bits().get_next_one_offset(0, nsegments);
 }
@@ -90,21 +90,21 @@
 inline BitMap::idx_t ZLiveMap::segment_size() const {
   return _bitmap.size() / nsegments;
 }
 
 inline BitMap::idx_t ZLiveMap::index_to_segment(BitMap::idx_t index) const {
-  return index >> _shift;
+  return index >> _segment_shift;
 }
 
 inline bool ZLiveMap::get(size_t index) const {
   BitMap::idx_t segment = index_to_segment(index);
   return is_marked() &&              // Page is marked
          is_segment_live(segment) && // Segment is marked
          _bitmap.at(index);          // Object is marked
 }
 
-inline bool ZLiveMap::set_atomic(size_t index, bool finalizable, bool& inc_live) {
+inline bool ZLiveMap::set(size_t index, bool finalizable, bool& inc_live) {
   if (!is_marked()) {
     // First object to be marked during this
     // cycle, reset marking information.
     reset(index);
   }
@@ -117,13 +117,13 @@
   }
 
   return _bitmap.par_set_bit_pair(index, finalizable, inc_live);
 }
 
-inline void ZLiveMap::inc_live_atomic(uint32_t objects, size_t bytes) {
-  Atomic::add(objects, &_live_objects);
-  Atomic::add(bytes, &_live_bytes);
+inline void ZLiveMap::inc_live(uint32_t objects, size_t bytes) {
+  Atomic::add(&_live_objects, objects);
+  Atomic::add(&_live_bytes, bytes);
 }
 
 inline BitMap::idx_t ZLiveMap::segment_start(BitMap::idx_t segment) const {
   return segment_size() * segment;
 }
@@ -142,11 +142,11 @@
   while (index < end_index) {
     // Calculate object address
     const uintptr_t addr = page_start + ((index / 2) << page_object_alignment_shift);
 
     // Apply closure
-    cl->do_object(ZOop::to_oop(addr));
+    cl->do_object(ZOop::from_address(addr));
 
     // Find next bit after this object
     const size_t size = ZUtils::object_size(addr);
     const uintptr_t next_addr = align_up(addr + size, 1 << page_object_alignment_shift);
     const BitMap::idx_t next_index = ((next_addr - page_start) >> page_object_alignment_shift) * 2;

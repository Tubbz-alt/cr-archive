diff a/src/hotspot/share/gc/z/zNMethod.cpp b/src/hotspot/share/gc/z/zNMethod.cpp
--- a/src/hotspot/share/gc/z/zNMethod.cpp
+++ b/src/hotspot/share/gc/z/zNMethod.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -37,12 +37,12 @@
 #include "gc/z/zWorkers.hpp"
 #include "logging/log.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/iterator.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "runtime/atomic.hpp"
-#include "runtime/orderAccess.hpp"
 #include "utilities/debug.hpp"
 
 static ZNMethodData* gc_data(const nmethod* nm) {
   return nm->gc_data<ZNMethodData>();
 }
@@ -161,11 +161,11 @@
   log_register(nm);
 
   ZNMethodTable::register_nmethod(nm);
 
   // Disarm nmethod entry barrier
-  disarm_nmethod(nm);
+  disarm(nm);
 }
 
 void ZNMethod::unregister_nmethod(nmethod* nm) {
   assert(CodeCache_lock->owned_by_self(), "Lock must be held");
 
@@ -185,11 +185,29 @@
 void ZNMethod::flush_nmethod(nmethod* nm) {
   // Destroy GC data
   delete gc_data(nm);
 }
 
-void ZNMethod::disarm_nmethod(nmethod* nm) {
+bool ZNMethod::supports_entry_barrier(nmethod* nm) {
+  BarrierSetNMethod* const bs = BarrierSet::barrier_set()->barrier_set_nmethod();
+  if (bs != NULL) {
+    return bs->supports_entry_barrier(nm);
+  }
+
+  return false;
+}
+
+bool ZNMethod::is_armed(nmethod* nm) {
+  BarrierSetNMethod* const bs = BarrierSet::barrier_set()->barrier_set_nmethod();
+  if (bs != NULL) {
+    return bs->is_armed(nm);
+  }
+
+  return false;
+}
+
+void ZNMethod::disarm(nmethod* nm) {
   BarrierSetNMethod* const bs = BarrierSet::barrier_set()->barrier_set_nmethod();
   if (bs != NULL) {
     bs->disarm(nm);
   }
 }
@@ -255,11 +273,30 @@
 private:
   bool          _unloading_occurred;
   volatile bool _failed;
 
   void set_failed() {
-    Atomic::store(true, &_failed);
+    Atomic::store(&_failed, true);
+  }
+
+  void unlink(nmethod* nm) {
+    // Unlinking of the dependencies must happen before the
+    // handshake separating unlink and purge.
+    nm->flush_dependencies(false /* delete_immediately */);
+
+    // unlink_from_method will take the CompiledMethod_lock.
+    // In this case we don't strictly need it when unlinking nmethods from
+    // the Method, because it is only concurrently unlinked by
+    // the entry barrier, which acquires the per nmethod lock.
+    nm->unlink_from_method();
+
+    if (nm->is_osr_method()) {
+      // Invalidate the osr nmethod before the handshake. The nmethod
+      // will be made unloaded after the handshake. Then invalidate_osr_method()
+      // will be called again, which will be a no-op.
+      nm->invalidate_osr_method();
+    }
   }
 
 public:
   ZNMethodUnlinkClosure(bool unloading_occurred) :
       _unloading_occurred(unloading_occurred),
@@ -272,28 +309,24 @@
 
     if (!nm->is_alive()) {
       return;
     }
 
-    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));
-
     if (nm->is_unloading()) {
-      // Unlinking of the dependencies must happen before the
-      // handshake separating unlink and purge.
-      nm->flush_dependencies(false /* delete_immediately */);
-
-      // We don't need to take the lock when unlinking nmethods from
-      // the Method, because it is only concurrently unlinked by
-      // the entry barrier, which acquires the per nmethod lock.
-      nm->unlink_from_method(false /* acquire_lock */);
+      ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));
+      unlink(nm);
       return;
     }
 
-    // Heal oops and disarm
-    ZNMethodOopClosure cl;
-    ZNMethod::nmethod_oops_do(nm, &cl);
-    ZNMethod::disarm_nmethod(nm);
+    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));
+
+    if (ZNMethod::is_armed(nm)) {
+      // Heal oops and disarm
+      ZNMethodOopClosure cl;
+      ZNMethod::nmethod_oops_do(nm, &cl);
+      ZNMethod::disarm(nm);
+    }
 
     // Clear compiled ICs and exception caches
     if (!nm->unload_nmethod_caches(_unloading_occurred)) {
       set_failed();
     }

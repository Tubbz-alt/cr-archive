<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zBarrier.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zArray.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zBarrier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zHeap.inline.hpp&quot;
 27 #include &quot;gc/z/zOop.inline.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;memory/iterator.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 
<span class="line-removed"> 34 bool ZBarrier::during_mark() {</span>
<span class="line-removed"> 35   return ZGlobalPhase == ZPhaseMark;</span>
<span class="line-removed"> 36 }</span>
<span class="line-removed"> 37 </span>
<span class="line-removed"> 38 bool ZBarrier::during_relocate() {</span>
<span class="line-removed"> 39   return ZGlobalPhase == ZPhaseRelocate;</span>
<span class="line-removed"> 40 }</span>
<span class="line-removed"> 41 </span>
 42 template &lt;bool finalizable&gt;
 43 bool ZBarrier::should_mark_through(uintptr_t addr) {
 44   // Finalizable marked oops can still exists on the heap after marking
 45   // has completed, in which case we just want to convert this into a
 46   // good oop and not push it on the mark stack.
 47   if (!during_mark()) {
 48     assert(ZAddress::is_marked(addr), &quot;Should be marked&quot;);
 49     assert(ZAddress::is_finalizable(addr), &quot;Should be finalizable&quot;);
 50     return false;
 51   }
 52 
 53   // During marking, we mark through already marked oops to avoid having
 54   // some large part of the object graph hidden behind a pushed, but not
 55   // yet flushed, entry on a mutator mark stack. Always marking through
 56   // allows the GC workers to proceed through the object graph even if a
 57   // mutator touched an oop first, which in turn will reduce the risk of
 58   // having to flush mark stacks multiple times to terminate marking.
 59   //
 60   // However, when doing finalizable marking we don&#39;t always want to mark
 61   // through. First, marking through an already strongly marked oop would
 62   // be wasteful, since we will then proceed to do finalizable marking on
 63   // an object which is, or will be, marked strongly. Second, marking
 64   // through an already finalizable marked oop would also be wasteful,
 65   // since such oops can never end up on a mutator mark stack and can
 66   // therefore not hide some part of the object graph from GC workers.
 67   if (finalizable) {
 68     return !ZAddress::is_marked(addr);
 69   }
 70 
 71   // Mark through
 72   return true;
 73 }
 74 
<span class="line-modified"> 75 template &lt;bool finalizable, bool publish&gt;</span>
 76 uintptr_t ZBarrier::mark(uintptr_t addr) {
 77   uintptr_t good_addr;
 78 
 79   if (ZAddress::is_marked(addr)) {
 80     // Already marked, but try to mark though anyway
 81     good_addr = ZAddress::good(addr);
 82   } else if (ZAddress::is_remapped(addr)) {
 83     // Already remapped, but also needs to be marked
 84     good_addr = ZAddress::good(addr);
 85   } else {
 86     // Needs to be both remapped and marked
 87     good_addr = remap(addr);
 88   }
 89 
 90   // Mark
 91   if (should_mark_through&lt;finalizable&gt;(addr)) {
<span class="line-modified"> 92     ZHeap::heap()-&gt;mark_object&lt;finalizable, publish&gt;(good_addr);</span>











 93   }
 94 
 95   return good_addr;
 96 }
 97 
 98 uintptr_t ZBarrier::remap(uintptr_t addr) {
 99   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
100   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">101 </span>
<span class="line-removed">102   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">103     // Forward</span>
<span class="line-removed">104     return ZHeap::heap()-&gt;forward_object(addr);</span>
<span class="line-removed">105   }</span>
<span class="line-removed">106 </span>
<span class="line-removed">107   // Remap</span>
<span class="line-removed">108   return ZAddress::good(addr);</span>
109 }
110 
111 uintptr_t ZBarrier::relocate(uintptr_t addr) {
112   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
113   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">114 </span>
<span class="line-removed">115   if (ZHeap::heap()-&gt;is_relocating(addr)) {</span>
<span class="line-removed">116     // Relocate</span>
<span class="line-removed">117     return ZHeap::heap()-&gt;relocate_object(addr);</span>
<span class="line-removed">118   }</span>
<span class="line-removed">119 </span>
<span class="line-removed">120   // Remap</span>
<span class="line-removed">121   return ZAddress::good(addr);</span>
122 }
123 
124 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
<span class="line-modified">125   return during_relocate() ? relocate(addr) : mark&lt;Strong, Publish&gt;(addr);</span>
126 }
127 
128 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
129   return during_relocate() ? relocate(addr) : remap(addr);
130 }
131 
132 //
133 // Load barrier
134 //
135 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
136   return relocate_or_mark(addr);
137 }
138 
139 void ZBarrier::load_barrier_on_oop_fields(oop o) {
<span class="line-modified">140   assert(ZOop::is_good(o), &quot;Should be good&quot;);</span>
141   ZLoadBarrierOopClosure cl;
142   o-&gt;oop_iterate(&amp;cl);
143 }
144 
145 //
146 // Weak load barrier
147 //
148 uintptr_t ZBarrier::weak_load_barrier_on_oop_slow_path(uintptr_t addr) {
149   return ZAddress::is_weak_good(addr) ? ZAddress::good(addr) : relocate_or_remap(addr);
150 }
151 
152 uintptr_t ZBarrier::weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr) {
153   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
154   if (ZHeap::heap()-&gt;is_object_strongly_live(good_addr)) {
155     return good_addr;
156   }
157 
158   // Not strongly live
159   return 0;
160 }
</pre>
<hr />
<pre>
171 
172 //
173 // Keep alive barrier
174 //
175 uintptr_t ZBarrier::keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr) {
176   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
177   assert(ZHeap::heap()-&gt;is_object_strongly_live(good_addr), &quot;Should be live&quot;);
178   return good_addr;
179 }
180 
181 uintptr_t ZBarrier::keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
182   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
183   assert(ZHeap::heap()-&gt;is_object_live(good_addr), &quot;Should be live&quot;);
184   return good_addr;
185 }
186 
187 //
188 // Mark barrier
189 //
190 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
<span class="line-modified">191   return mark&lt;Strong, Overflow&gt;(addr);</span>



192 }
193 
194 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
<span class="line-modified">195   const uintptr_t good_addr = mark&lt;Finalizable, Overflow&gt;(addr);</span>
<span class="line-removed">196   if (ZAddress::is_good(addr)) {</span>
<span class="line-removed">197     // If the oop was already strongly marked/good, then we do</span>
<span class="line-removed">198     // not want to downgrade it to finalizable marked/good.</span>
<span class="line-removed">199     return good_addr;</span>
<span class="line-removed">200   }</span>
201 
<span class="line-modified">202   // Make the oop finalizable marked/good, instead of normal marked/good.</span>
<span class="line-modified">203   // This is needed because an object might first becomes finalizable</span>
<span class="line-removed">204   // marked by the GC, and then loaded by a mutator thread. In this case,</span>
<span class="line-removed">205   // the mutator thread must be able to tell that the object needs to be</span>
<span class="line-removed">206   // strongly marked. The finalizable bit in the oop exists to make sure</span>
<span class="line-removed">207   // that a load of a finalizable marked oop will fall into the barrier</span>
<span class="line-removed">208   // slow path so that we can mark the object as strongly reachable.</span>
<span class="line-removed">209   return ZAddress::finalizable_good(good_addr);</span>
210 }
211 
212 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
213   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
214   assert(during_mark(), &quot;Invalid phase&quot;);
215 
216   // Mark
<span class="line-modified">217   return mark&lt;Strong, Publish&gt;(addr);</span>








218 }
219 
220 //
221 // Relocate barrier
222 //
223 uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {
224   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
225   assert(during_relocate(), &quot;Invalid phase&quot;);
226 
227   // Relocate
228   return relocate(addr);
229 }
230 
231 //
232 // Narrow oop variants, never used.
233 //
234 oop ZBarrier::load_barrier_on_oop_field(volatile narrowOop* p) {
235   ShouldNotReachHere();
236   return NULL;
237 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zBarrier.inline.hpp&quot;
 26 #include &quot;gc/z/zHeap.inline.hpp&quot;
 27 #include &quot;gc/z/zOop.inline.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;memory/iterator.inline.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 








 34 template &lt;bool finalizable&gt;
 35 bool ZBarrier::should_mark_through(uintptr_t addr) {
 36   // Finalizable marked oops can still exists on the heap after marking
 37   // has completed, in which case we just want to convert this into a
 38   // good oop and not push it on the mark stack.
 39   if (!during_mark()) {
 40     assert(ZAddress::is_marked(addr), &quot;Should be marked&quot;);
 41     assert(ZAddress::is_finalizable(addr), &quot;Should be finalizable&quot;);
 42     return false;
 43   }
 44 
 45   // During marking, we mark through already marked oops to avoid having
 46   // some large part of the object graph hidden behind a pushed, but not
 47   // yet flushed, entry on a mutator mark stack. Always marking through
 48   // allows the GC workers to proceed through the object graph even if a
 49   // mutator touched an oop first, which in turn will reduce the risk of
 50   // having to flush mark stacks multiple times to terminate marking.
 51   //
 52   // However, when doing finalizable marking we don&#39;t always want to mark
 53   // through. First, marking through an already strongly marked oop would
 54   // be wasteful, since we will then proceed to do finalizable marking on
 55   // an object which is, or will be, marked strongly. Second, marking
 56   // through an already finalizable marked oop would also be wasteful,
 57   // since such oops can never end up on a mutator mark stack and can
 58   // therefore not hide some part of the object graph from GC workers.
 59   if (finalizable) {
 60     return !ZAddress::is_marked(addr);
 61   }
 62 
 63   // Mark through
 64   return true;
 65 }
 66 
<span class="line-modified"> 67 template &lt;bool follow, bool finalizable, bool publish&gt;</span>
 68 uintptr_t ZBarrier::mark(uintptr_t addr) {
 69   uintptr_t good_addr;
 70 
 71   if (ZAddress::is_marked(addr)) {
 72     // Already marked, but try to mark though anyway
 73     good_addr = ZAddress::good(addr);
 74   } else if (ZAddress::is_remapped(addr)) {
 75     // Already remapped, but also needs to be marked
 76     good_addr = ZAddress::good(addr);
 77   } else {
 78     // Needs to be both remapped and marked
 79     good_addr = remap(addr);
 80   }
 81 
 82   // Mark
 83   if (should_mark_through&lt;finalizable&gt;(addr)) {
<span class="line-modified"> 84     ZHeap::heap()-&gt;mark_object&lt;follow, finalizable, publish&gt;(good_addr);</span>
<span class="line-added"> 85   }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87   if (finalizable) {</span>
<span class="line-added"> 88     // Make the oop finalizable marked/good, instead of normal marked/good.</span>
<span class="line-added"> 89     // This is needed because an object might first becomes finalizable</span>
<span class="line-added"> 90     // marked by the GC, and then loaded by a mutator thread. In this case,</span>
<span class="line-added"> 91     // the mutator thread must be able to tell that the object needs to be</span>
<span class="line-added"> 92     // strongly marked. The finalizable bit in the oop exists to make sure</span>
<span class="line-added"> 93     // that a load of a finalizable marked oop will fall into the barrier</span>
<span class="line-added"> 94     // slow path so that we can mark the object as strongly reachable.</span>
<span class="line-added"> 95     return ZAddress::finalizable_good(good_addr);</span>
 96   }
 97 
 98   return good_addr;
 99 }
100 
101 uintptr_t ZBarrier::remap(uintptr_t addr) {
102   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
103   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">104   return ZHeap::heap()-&gt;remap_object(addr);</span>







105 }
106 
107 uintptr_t ZBarrier::relocate(uintptr_t addr) {
108   assert(!ZAddress::is_good(addr), &quot;Should not be good&quot;);
109   assert(!ZAddress::is_weak_good(addr), &quot;Should not be weak good&quot;);
<span class="line-modified">110   return ZHeap::heap()-&gt;relocate_object(addr);</span>







111 }
112 
113 uintptr_t ZBarrier::relocate_or_mark(uintptr_t addr) {
<span class="line-modified">114   return during_relocate() ? relocate(addr) : mark&lt;Follow, Strong, Publish&gt;(addr);</span>
115 }
116 
117 uintptr_t ZBarrier::relocate_or_remap(uintptr_t addr) {
118   return during_relocate() ? relocate(addr) : remap(addr);
119 }
120 
121 //
122 // Load barrier
123 //
124 uintptr_t ZBarrier::load_barrier_on_oop_slow_path(uintptr_t addr) {
125   return relocate_or_mark(addr);
126 }
127 
128 void ZBarrier::load_barrier_on_oop_fields(oop o) {
<span class="line-modified">129   assert(ZAddress::is_good(ZOop::to_address(o)), &quot;Should be good&quot;);</span>
130   ZLoadBarrierOopClosure cl;
131   o-&gt;oop_iterate(&amp;cl);
132 }
133 
134 //
135 // Weak load barrier
136 //
137 uintptr_t ZBarrier::weak_load_barrier_on_oop_slow_path(uintptr_t addr) {
138   return ZAddress::is_weak_good(addr) ? ZAddress::good(addr) : relocate_or_remap(addr);
139 }
140 
141 uintptr_t ZBarrier::weak_load_barrier_on_weak_oop_slow_path(uintptr_t addr) {
142   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
143   if (ZHeap::heap()-&gt;is_object_strongly_live(good_addr)) {
144     return good_addr;
145   }
146 
147   // Not strongly live
148   return 0;
149 }
</pre>
<hr />
<pre>
160 
161 //
162 // Keep alive barrier
163 //
164 uintptr_t ZBarrier::keep_alive_barrier_on_weak_oop_slow_path(uintptr_t addr) {
165   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
166   assert(ZHeap::heap()-&gt;is_object_strongly_live(good_addr), &quot;Should be live&quot;);
167   return good_addr;
168 }
169 
170 uintptr_t ZBarrier::keep_alive_barrier_on_phantom_oop_slow_path(uintptr_t addr) {
171   const uintptr_t good_addr = weak_load_barrier_on_oop_slow_path(addr);
172   assert(ZHeap::heap()-&gt;is_object_live(good_addr), &quot;Should be live&quot;);
173   return good_addr;
174 }
175 
176 //
177 // Mark barrier
178 //
179 uintptr_t ZBarrier::mark_barrier_on_oop_slow_path(uintptr_t addr) {
<span class="line-modified">180   assert(during_mark(), &quot;Invalid phase&quot;);</span>
<span class="line-added">181 </span>
<span class="line-added">182   // Mark</span>
<span class="line-added">183   return mark&lt;Follow, Strong, Overflow&gt;(addr);</span>
184 }
185 
186 uintptr_t ZBarrier::mark_barrier_on_finalizable_oop_slow_path(uintptr_t addr) {
<span class="line-modified">187   assert(during_mark(), &quot;Invalid phase&quot;);</span>





188 
<span class="line-modified">189   // Mark</span>
<span class="line-modified">190   return mark&lt;Follow, Finalizable, Overflow&gt;(addr);</span>






191 }
192 
193 uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {
194   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
195   assert(during_mark(), &quot;Invalid phase&quot;);
196 
197   // Mark
<span class="line-modified">198   return mark&lt;Follow, Strong, Publish&gt;(addr);</span>
<span class="line-added">199 }</span>
<span class="line-added">200 </span>
<span class="line-added">201 uintptr_t ZBarrier::mark_barrier_on_invisible_root_oop_slow_path(uintptr_t addr) {</span>
<span class="line-added">202   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);</span>
<span class="line-added">203   assert(during_mark(), &quot;Invalid phase&quot;);</span>
<span class="line-added">204 </span>
<span class="line-added">205   // Mark</span>
<span class="line-added">206   return mark&lt;DontFollow, Strong, Publish&gt;(addr);</span>
207 }
208 
209 //
210 // Relocate barrier
211 //
212 uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {
213   assert(SafepointSynchronize::is_at_safepoint(), &quot;Should be at safepoint&quot;);
214   assert(during_relocate(), &quot;Invalid phase&quot;);
215 
216   // Relocate
217   return relocate(addr);
218 }
219 
220 //
221 // Narrow oop variants, never used.
222 //
223 oop ZBarrier::load_barrier_on_oop_field(volatile narrowOop* p) {
224   ShouldNotReachHere();
225   return NULL;
226 }
</pre>
</td>
</tr>
</table>
<center><a href="zArray.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zBarrier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
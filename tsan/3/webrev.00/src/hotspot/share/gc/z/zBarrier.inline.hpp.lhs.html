<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zBarrier.inline.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZBARRIER_INLINE_HPP
 25 #define SHARE_GC_Z_ZBARRIER_INLINE_HPP
 26 
<a name="2" id="anc2"></a>
 27 #include &quot;gc/z/zAddress.inline.hpp&quot;
 28 #include &quot;gc/z/zBarrier.hpp&quot;
 29 #include &quot;gc/z/zOop.inline.hpp&quot;
 30 #include &quot;gc/z/zResurrection.inline.hpp&quot;
<a name="3" id="anc3"></a>
 31 #include &quot;runtime/atomic.hpp&quot;
 32 
<a name="4" id="anc4"></a>







































































































 33 template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt;
 34 inline oop ZBarrier::barrier(volatile oop* p, oop o) {
<a name="5" id="anc5"></a><span class="line-modified"> 35   uintptr_t addr = ZOop::to_address(o);</span>
 36 
<a name="6" id="anc6"></a><span class="line-removed"> 37 retry:</span>
 38   // Fast path
 39   if (fast_path(addr)) {
<a name="7" id="anc7"></a><span class="line-modified"> 40     return ZOop::to_oop(addr);</span>
 41   }
 42 
 43   // Slow path
 44   const uintptr_t good_addr = slow_path(addr);
 45 
<a name="8" id="anc8"></a><span class="line-modified"> 46   // Self heal, but only if the address was actually updated by the slow path,</span>
<span class="line-modified"> 47   // which might not be the case, e.g. when marking through an already good oop.</span>
<span class="line-removed"> 48   if (p != NULL &amp;&amp; good_addr != addr) {</span>
<span class="line-removed"> 49     const uintptr_t prev_addr = Atomic::cmpxchg(good_addr, (volatile uintptr_t*)p, addr);</span>
<span class="line-removed"> 50     if (prev_addr != addr) {</span>
<span class="line-removed"> 51       // Some other thread overwrote the oop. If this oop was updated by a</span>
<span class="line-removed"> 52       // weak barrier the new oop might not be good, in which case we need</span>
<span class="line-removed"> 53       // to re-apply this barrier.</span>
<span class="line-removed"> 54       addr = prev_addr;</span>
<span class="line-removed"> 55       goto retry;</span>
<span class="line-removed"> 56     }</span>
 57   }
 58 
<a name="9" id="anc9"></a><span class="line-modified"> 59   return ZOop::to_oop(good_addr);</span>
 60 }
 61 
 62 template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt;
 63 inline oop ZBarrier::weak_barrier(volatile oop* p, oop o) {
 64   const uintptr_t addr = ZOop::to_address(o);
 65 
 66   // Fast path
 67   if (fast_path(addr)) {
 68     // Return the good address instead of the weak good address
 69     // to ensure that the currently active heap view is used.
<a name="10" id="anc10"></a><span class="line-modified"> 70     return ZOop::to_oop(ZAddress::good_or_null(addr));</span>
 71   }
 72 
 73   // Slow path
<a name="11" id="anc11"></a><span class="line-modified"> 74   uintptr_t good_addr = slow_path(addr);</span>
<span class="line-modified"> 75 </span>
<span class="line-modified"> 76   // Self heal unless the address returned from the slow path is null,</span>
<span class="line-modified"> 77   // in which case resurrection was blocked and we must let the reference</span>
<span class="line-modified"> 78   // processor clear the oop. Mutators are not allowed to clear oops in</span>
<span class="line-modified"> 79   // these cases, since that would be similar to calling Reference.clear(),</span>
<span class="line-removed"> 80   // which would make the reference non-discoverable or silently dropped</span>
<span class="line-removed"> 81   // by the reference processor.</span>
<span class="line-removed"> 82   if (p != NULL &amp;&amp; good_addr != 0) {</span>
<span class="line-removed"> 83     // The slow path returns a good/marked address, but we never mark oops</span>
<span class="line-removed"> 84     // in a weak load barrier so we always self heal with the remapped address.</span>
<span class="line-removed"> 85     const uintptr_t weak_good_addr = ZAddress::remapped(good_addr);</span>
<span class="line-removed"> 86     const uintptr_t prev_addr = Atomic::cmpxchg(weak_good_addr, (volatile uintptr_t*)p, addr);</span>
<span class="line-removed"> 87     if (prev_addr != addr) {</span>
<span class="line-removed"> 88       // Some other thread overwrote the oop. The new</span>
<span class="line-removed"> 89       // oop is guaranteed to be weak good or null.</span>
<span class="line-removed"> 90       assert(ZAddress::is_weak_good_or_null(prev_addr), &quot;Bad weak overwrite&quot;);</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92       // Return the good address instead of the weak good address</span>
<span class="line-removed"> 93       // to ensure that the currently active heap view is used.</span>
<span class="line-removed"> 94       good_addr = ZAddress::good_or_null(prev_addr);</span>
<span class="line-removed"> 95     }</span>
 96   }
 97 
<a name="12" id="anc12"></a><span class="line-modified"> 98   return ZOop::to_oop(good_addr);</span>
 99 }
100 
101 template &lt;ZBarrierFastPath fast_path, ZBarrierSlowPath slow_path&gt;
102 inline void ZBarrier::root_barrier(oop* p, oop o) {
103   const uintptr_t addr = ZOop::to_address(o);
104 
105   // Fast path
106   if (fast_path(addr)) {
107     return;
108   }
109 
110   // Slow path
111   const uintptr_t good_addr = slow_path(addr);
112 
113   // Non-atomic healing helps speed up root scanning. This is safe to do
114   // since we are always healing roots in a safepoint, or under a lock,
115   // which ensures we are never racing with mutators modifying roots while
116   // we are healing them. It&#39;s also safe in case multiple GC threads try
117   // to heal the same root if it is aligned, since they would always heal
118   // the root in the same way and it does not matter in which order it
119   // happens. For misaligned oops, there needs to be mutual exclusion.
<a name="13" id="anc13"></a><span class="line-modified">120   *p = ZOop::to_oop(good_addr);</span>
<span class="line-removed">121 }</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 inline bool ZBarrier::is_null_fast_path(uintptr_t addr) {</span>
<span class="line-removed">124   return ZAddress::is_null(addr);</span>
125 }
126 
127 inline bool ZBarrier::is_good_or_null_fast_path(uintptr_t addr) {
128   return ZAddress::is_good_or_null(addr);
129 }
130 
131 inline bool ZBarrier::is_weak_good_or_null_fast_path(uintptr_t addr) {
132   return ZAddress::is_weak_good_or_null(addr);
133 }
134 
<a name="14" id="anc14"></a><span class="line-modified">135 inline bool ZBarrier::is_resurrection_blocked(volatile oop* p, oop* o) {</span>
<span class="line-modified">136   const bool is_blocked = ZResurrection::is_blocked();</span>

137 
<a name="15" id="anc15"></a><span class="line-modified">138   // Reload oop after checking the resurrection blocked state. This is</span>
<span class="line-modified">139   // done to prevent a race where we first load an oop, which is logically</span>
<span class="line-modified">140   // null but not yet cleared, then this oop is cleared by the reference</span>
<span class="line-removed">141   // processor and resurrection is unblocked. At this point the mutator</span>
<span class="line-removed">142   // would see the unblocked state and pass this invalid oop through the</span>
<span class="line-removed">143   // normal barrier path, which would incorrectly try to mark this oop.</span>
<span class="line-removed">144   if (p != NULL) {</span>
<span class="line-removed">145     // First assign to reloaded_o to avoid compiler warning about</span>
<span class="line-removed">146     // implicit dereference of volatile oop.</span>
<span class="line-removed">147     const oop reloaded_o = *p;</span>
<span class="line-removed">148     *o = reloaded_o;</span>
<span class="line-removed">149   }</span>
150 
<a name="16" id="anc16"></a><span class="line-modified">151   return is_blocked;</span>

152 }
153 
154 //
155 // Load barrier
156 //
157 inline oop ZBarrier::load_barrier_on_oop(oop o) {
158   return load_barrier_on_oop_field_preloaded((oop*)NULL, o);
159 }
160 
161 inline oop ZBarrier::load_barrier_on_oop_field(volatile oop* p) {
162   const oop o = *p;
163   return load_barrier_on_oop_field_preloaded(p, o);
164 }
165 
166 inline oop ZBarrier::load_barrier_on_oop_field_preloaded(volatile oop* p, oop o) {
167   return barrier&lt;is_good_or_null_fast_path, load_barrier_on_oop_slow_path&gt;(p, o);
168 }
169 
170 inline void ZBarrier::load_barrier_on_oop_array(volatile oop* p, size_t length) {
171   for (volatile const oop* const end = p + length; p &lt; end; p++) {
172     load_barrier_on_oop_field(p);
173   }
174 }
175 
<a name="17" id="anc17"></a>











176 inline oop ZBarrier::load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o) {
<a name="18" id="anc18"></a><span class="line-modified">177   if (is_resurrection_blocked(p, &amp;o)) {</span>
<span class="line-modified">178     return weak_barrier&lt;is_good_or_null_fast_path, weak_load_barrier_on_weak_oop_slow_path&gt;(p, o);</span>


179   }
180 
181   return load_barrier_on_oop_field_preloaded(p, o);
182 }
183 
184 inline oop ZBarrier::load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o) {
<a name="19" id="anc19"></a><span class="line-modified">185   if (is_resurrection_blocked(p, &amp;o)) {</span>
<span class="line-modified">186     return weak_barrier&lt;is_good_or_null_fast_path, weak_load_barrier_on_phantom_oop_slow_path&gt;(p, o);</span>
187   }
188 
189   return load_barrier_on_oop_field_preloaded(p, o);
190 }
191 
192 inline void ZBarrier::load_barrier_on_root_oop_field(oop* p) {
193   const oop o = *p;
194   root_barrier&lt;is_good_or_null_fast_path, load_barrier_on_oop_slow_path&gt;(p, o);
195 }
196 
197 //
198 // Weak load barrier
199 //
200 inline oop ZBarrier::weak_load_barrier_on_oop_field(volatile oop* p) {
201   assert(!ZResurrection::is_blocked(), &quot;Should not be called during resurrection blocked phase&quot;);
202   const oop o = *p;
203   return weak_load_barrier_on_oop_field_preloaded(p, o);
204 }
205 
206 inline oop ZBarrier::weak_load_barrier_on_oop_field_preloaded(volatile oop* p, oop o) {
207   return weak_barrier&lt;is_weak_good_or_null_fast_path, weak_load_barrier_on_oop_slow_path&gt;(p, o);
208 }
209 
210 inline oop ZBarrier::weak_load_barrier_on_weak_oop(oop o) {
211   return weak_load_barrier_on_weak_oop_field_preloaded((oop*)NULL, o);
212 }
213 
214 inline oop ZBarrier::weak_load_barrier_on_weak_oop_field(volatile oop* p) {
215   const oop o = *p;
216   return weak_load_barrier_on_weak_oop_field_preloaded(p, o);
217 }
218 
219 inline oop ZBarrier::weak_load_barrier_on_weak_oop_field_preloaded(volatile oop* p, oop o) {
<a name="20" id="anc20"></a><span class="line-modified">220   if (is_resurrection_blocked(p, &amp;o)) {</span>
<span class="line-modified">221     return weak_barrier&lt;is_good_or_null_fast_path, weak_load_barrier_on_weak_oop_slow_path&gt;(p, o);</span>


222   }
223 
224   return weak_load_barrier_on_oop_field_preloaded(p, o);
225 }
226 
227 inline oop ZBarrier::weak_load_barrier_on_phantom_oop(oop o) {
228   return weak_load_barrier_on_phantom_oop_field_preloaded((oop*)NULL, o);
229 }
230 
231 inline oop ZBarrier::weak_load_barrier_on_phantom_oop_field(volatile oop* p) {
232   const oop o = *p;
233   return weak_load_barrier_on_phantom_oop_field_preloaded(p, o);
234 }
235 
236 inline oop ZBarrier::weak_load_barrier_on_phantom_oop_field_preloaded(volatile oop* p, oop o) {
<a name="21" id="anc21"></a><span class="line-modified">237   if (is_resurrection_blocked(p, &amp;o)) {</span>
<span class="line-modified">238     return weak_barrier&lt;is_good_or_null_fast_path, weak_load_barrier_on_phantom_oop_slow_path&gt;(p, o);</span>
239   }
240 
241   return weak_load_barrier_on_oop_field_preloaded(p, o);
242 }
243 
244 //
245 // Is alive barrier
246 //
247 inline bool ZBarrier::is_alive_barrier_on_weak_oop(oop o) {
248   // Check if oop is logically non-null. This operation
249   // is only valid when resurrection is blocked.
250   assert(ZResurrection::is_blocked(), &quot;Invalid phase&quot;);
251   return weak_load_barrier_on_weak_oop(o) != NULL;
252 }
253 
254 inline bool ZBarrier::is_alive_barrier_on_phantom_oop(oop o) {
255   // Check if oop is logically non-null. This operation
256   // is only valid when resurrection is blocked.
257   assert(ZResurrection::is_blocked(), &quot;Invalid phase&quot;);
258   return weak_load_barrier_on_phantom_oop(o) != NULL;
259 }
260 
261 //
262 // Keep alive barrier
263 //
264 inline void ZBarrier::keep_alive_barrier_on_weak_oop_field(volatile oop* p) {
265   // This operation is only valid when resurrection is blocked.
266   assert(ZResurrection::is_blocked(), &quot;Invalid phase&quot;);
267   const oop o = *p;
268   barrier&lt;is_good_or_null_fast_path, keep_alive_barrier_on_weak_oop_slow_path&gt;(p, o);
269 }
270 
271 inline void ZBarrier::keep_alive_barrier_on_phantom_oop_field(volatile oop* p) {
272   // This operation is only valid when resurrection is blocked.
273   assert(ZResurrection::is_blocked(), &quot;Invalid phase&quot;);
274   const oop o = *p;
275   barrier&lt;is_good_or_null_fast_path, keep_alive_barrier_on_phantom_oop_slow_path&gt;(p, o);
276 }
277 
278 inline void ZBarrier::keep_alive_barrier_on_phantom_root_oop_field(oop* p) {
279   // This operation is only valid when resurrection is blocked.
280   assert(ZResurrection::is_blocked(), &quot;Invalid phase&quot;);
281   const oop o = *p;
282   root_barrier&lt;is_good_or_null_fast_path, keep_alive_barrier_on_phantom_oop_slow_path&gt;(p, o);
283 }
284 
<a name="22" id="anc22"></a>








285 //
286 // Mark barrier
287 //
288 inline void ZBarrier::mark_barrier_on_oop_field(volatile oop* p, bool finalizable) {
<a name="23" id="anc23"></a><span class="line-removed">289   // The fast path only checks for null since the GC worker</span>
<span class="line-removed">290   // threads doing marking wants to mark through good oops.</span>
291   const oop o = *p;
292 
293   if (finalizable) {
<a name="24" id="anc24"></a><span class="line-modified">294     barrier&lt;is_null_fast_path, mark_barrier_on_finalizable_oop_slow_path&gt;(p, o);</span>
295   } else {
<a name="25" id="anc25"></a><span class="line-modified">296     barrier&lt;is_null_fast_path, mark_barrier_on_oop_slow_path&gt;(p, o);</span>







297   }
298 }
299 
300 inline void ZBarrier::mark_barrier_on_oop_array(volatile oop* p, size_t length, bool finalizable) {
301   for (volatile const oop* const end = p + length; p &lt; end; p++) {
302     mark_barrier_on_oop_field(p, finalizable);
303   }
304 }
305 
306 inline void ZBarrier::mark_barrier_on_root_oop_field(oop* p) {
307   const oop o = *p;
308   root_barrier&lt;is_good_or_null_fast_path, mark_barrier_on_root_oop_slow_path&gt;(p, o);
309 }
310 
<a name="26" id="anc26"></a>




311 //
312 // Relocate barrier
313 //
314 inline void ZBarrier::relocate_barrier_on_root_oop_field(oop* p) {
315   const oop o = *p;
316   root_barrier&lt;is_good_or_null_fast_path, relocate_barrier_on_root_oop_slow_path&gt;(p, o);
317 }
318 
319 #endif // SHARE_GC_Z_ZBARRIER_INLINE_HPP
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
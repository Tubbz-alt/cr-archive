<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/z/zMark.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_GC_Z_ZMARK_HPP
 25 #define SHARE_GC_Z_ZMARK_HPP
 26 
 27 #include &quot;gc/z/zMarkStack.hpp&quot;
 28 #include &quot;gc/z/zMarkStackAllocator.hpp&quot;
 29 #include &quot;gc/z/zMarkTerminate.hpp&quot;
 30 #include &quot;oops/oopsHierarchy.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 
 33 class Thread;
 34 class ZMarkCache;
 35 class ZPageTable;
 36 class ZWorkers;
 37 
 38 class ZMark {
 39   friend class ZMarkRootsTask;
 40   friend class ZMarkTask;
 41   friend class ZMarkTryCompleteTask;
 42 
 43 private:
 44   ZWorkers* const     _workers;
<a name="1" id="anc1"></a><span class="line-modified"> 45   ZPageTable* const   _pagetable;</span>
 46   ZMarkStackAllocator _allocator;
 47   ZMarkStripeSet      _stripes;
 48   ZMarkTerminate      _terminate;
 49   volatile bool       _work_terminateflush;
 50   volatile size_t     _work_nproactiveflush;
 51   volatile size_t     _work_nterminateflush;
 52   size_t              _nproactiveflush;
 53   size_t              _nterminateflush;
 54   size_t              _ntrycomplete;
 55   size_t              _ncontinue;
 56   uint                _nworkers;
 57 
 58   size_t calculate_nstripes(uint nworkers) const;
 59   void prepare_mark();
 60 
 61   bool is_array(uintptr_t addr) const;
 62   void push_partial_array(uintptr_t addr, size_t size, bool finalizable);
 63   void follow_small_array(uintptr_t addr, size_t size, bool finalizable);
 64   void follow_large_array(uintptr_t addr, size_t size, bool finalizable);
 65   void follow_array(uintptr_t addr, size_t size, bool finalizable);
 66   void follow_partial_array(ZMarkStackEntry entry, bool finalizable);
 67   void follow_array_object(objArrayOop obj, bool finalizable);
 68   void follow_object(oop obj, bool finalizable);
 69   bool try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable);
 70   void mark_and_follow(ZMarkCache* cache, ZMarkStackEntry entry);
 71 
 72   template &lt;typename T&gt; bool drain(ZMarkStripe* stripe,
 73                                    ZMarkThreadLocalStacks* stacks,
 74                                    ZMarkCache* cache,
 75                                    T* timeout);
 76   template &lt;typename T&gt; bool drain_and_flush(ZMarkStripe* stripe,
 77                                              ZMarkThreadLocalStacks* stacks,
 78                                              ZMarkCache* cache,
 79                                              T* timeout);
 80   bool try_steal(ZMarkStripe* stripe, ZMarkThreadLocalStacks* stacks);
 81   void idle() const;
 82   bool flush(bool at_safepoint);
 83   bool try_proactive_flush();
 84   bool try_flush(volatile size_t* nflush);
 85   bool try_terminate();
 86   bool try_complete();
 87   bool try_end();
 88 
 89   void prepare_work();
 90   void finish_work();
 91 
 92   void work_without_timeout(ZMarkCache* cache,
 93                             ZMarkStripe* stripe,
 94                             ZMarkThreadLocalStacks* stacks);
 95   void work_with_timeout(ZMarkCache* cache,
 96                          ZMarkStripe* stripe,
 97                          ZMarkThreadLocalStacks* stacks,
 98                          uint64_t timeout_in_millis);
 99   void work(uint64_t timeout_in_millis);
100 
101   void verify_all_stacks_empty() const;
102 
103 public:
<a name="2" id="anc2"></a><span class="line-modified">104   ZMark(ZWorkers* workers, ZPageTable* pagetable);</span>
105 
106   bool is_initialized() const;
107 
<a name="3" id="anc3"></a><span class="line-modified">108   template &lt;bool finalizable, bool publish&gt; void mark_object(uintptr_t addr);</span>
109 
110   void start();
111   void mark(bool initial);
112   bool end();
113 
114   void flush_and_free();
115   bool flush_and_free(Thread* thread);
116 };
117 
118 #endif // SHARE_GC_Z_ZMARK_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
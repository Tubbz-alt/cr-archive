<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/z/zUnload.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zTracer.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zUnload.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
  #include &quot;gc/z/zOopClosures.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zUnload.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  
<span class="line-modified">! static const ZStatSubPhase ZSubPhaseConcurrentClassesUnload(&quot;Concurrent Classes Unload&quot;);</span>
  
  class ZIsUnloadingOopClosure : public OopClosure {
  private:
    ZPhantomIsAliveObjectClosure _is_alive;
    bool                         _is_unloading;
<span class="line-new-header">--- 34,12 ---</span>
  #include &quot;gc/z/zOopClosures.hpp&quot;
  #include &quot;gc/z/zStat.hpp&quot;
  #include &quot;gc/z/zUnload.hpp&quot;
  #include &quot;oops/access.inline.hpp&quot;
  
<span class="line-modified">! static const ZStatSubPhase ZSubPhaseConcurrentClassesUnlink(&quot;Concurrent Classes Unlink&quot;);</span>
<span class="line-added">+ static const ZStatSubPhase ZSubPhaseConcurrentClassesPurge(&quot;Concurrent Classes Purge&quot;);</span>
  
  class ZIsUnloadingOopClosure : public OopClosure {
  private:
    ZPhantomIsAliveObjectClosure _is_alive;
    bool                         _is_unloading;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
    virtual bool is_unloading(CompiledMethod* method) const {
      nmethod* const nm = method-&gt;as_nmethod();
      ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
      ZLocker&lt;ZReentrantLock&gt; locker(lock);
      ZIsUnloadingOopClosure cl;
<span class="line-modified">!     nm-&gt;oops_do(&amp;cl, true /* allow_zombie */);</span>
      return cl.is_unloading();
    }
  };
  
  class ZCompiledICProtectionBehaviour : public CompiledICProtectionBehaviour {
<span class="line-new-header">--- 70,11 ---</span>
    virtual bool is_unloading(CompiledMethod* method) const {
      nmethod* const nm = method-&gt;as_nmethod();
      ZReentrantLock* const lock = ZNMethod::lock_for_nmethod(nm);
      ZLocker&lt;ZReentrantLock&gt; locker(lock);
      ZIsUnloadingOopClosure cl;
<span class="line-modified">!     ZNMethod::nmethod_oops_do(nm, &amp;cl);</span>
      return cl.is_unloading();
    }
  };
  
  class ZCompiledICProtectionBehaviour : public CompiledICProtectionBehaviour {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,58 ***</span>
    CodeCache::increment_unloading_cycle();
    DependencyContext::cleaning_start();
  }
  
  void ZUnload::unlink() {
    SuspendibleThreadSetJoiner sts;
    bool unloading_occurred;
  
    {
<span class="line-modified">!     MutexLockerEx ml(ClassLoaderDataGraph_lock);</span>
      unloading_occurred = SystemDictionary::do_unloading(ZStatPhase::timer());
    }
  
    Klass::clean_weak_klass_links(unloading_occurred);
<span class="line-removed">- </span>
    ZNMethod::unlink(_workers, unloading_occurred);
<span class="line-removed">- </span>
    DependencyContext::cleaning_end();
  }
  
  void ZUnload::purge() {
    {
      SuspendibleThreadSetJoiner sts;
      ZNMethod::purge(_workers);
    }
  
    ClassLoaderDataGraph::purge();
    CodeCache::purge_exception_caches();
  }
  
<span class="line-removed">- class ZUnloadRendezvousClosure : public ThreadClosure {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-   void do_thread(Thread* thread) {}</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ZUnload::unload() {</span>
<span class="line-removed">-   if (!ClassUnloading) {</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ZStatTimer timer(ZSubPhaseConcurrentClassesUnload);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Unlink stale metadata and nmethods</span>
<span class="line-removed">-   unlink();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Make sure stale metadata and nmethods are no longer observable</span>
<span class="line-removed">-   ZUnloadRendezvousClosure cl;</span>
<span class="line-removed">-   Handshake::execute(&amp;cl);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Purge stale metadata and nmethods that were unlinked</span>
<span class="line-removed">-   purge();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ZUnload::finish() {
    // Resize and verify metaspace
    MetaspaceGC::compute_new_size();
    MetaspaceUtils::verify_metrics();
  }
<span class="line-new-header">--- 125,44 ---</span>
    CodeCache::increment_unloading_cycle();
    DependencyContext::cleaning_start();
  }
  
  void ZUnload::unlink() {
<span class="line-added">+   if (!ClassUnloading) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZStatTimer timer(ZSubPhaseConcurrentClassesUnlink);</span>
    SuspendibleThreadSetJoiner sts;
    bool unloading_occurred;
  
    {
<span class="line-modified">!     MutexLocker ml(ClassLoaderDataGraph_lock);</span>
      unloading_occurred = SystemDictionary::do_unloading(ZStatPhase::timer());
    }
  
    Klass::clean_weak_klass_links(unloading_occurred);
    ZNMethod::unlink(_workers, unloading_occurred);
    DependencyContext::cleaning_end();
  }
  
  void ZUnload::purge() {
<span class="line-added">+   if (!ClassUnloading) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ZStatTimer timer(ZSubPhaseConcurrentClassesPurge);</span>
<span class="line-added">+ </span>
    {
      SuspendibleThreadSetJoiner sts;
      ZNMethod::purge(_workers);
    }
  
    ClassLoaderDataGraph::purge();
    CodeCache::purge_exception_caches();
  }
  
  void ZUnload::finish() {
    // Resize and verify metaspace
    MetaspaceGC::compute_new_size();
    MetaspaceUtils::verify_metrics();
  }
</pre>
<center><a href="zTracer.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zUnload.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
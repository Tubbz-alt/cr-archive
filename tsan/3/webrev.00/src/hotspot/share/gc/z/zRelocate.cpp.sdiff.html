<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zRelocate.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zReferenceProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zRelocate.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zAddress.inline.hpp&quot;
 26 #include &quot;gc/z/zBarrier.inline.hpp&quot;

 27 #include &quot;gc/z/zHeap.hpp&quot;
 28 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 29 #include &quot;gc/z/zPage.hpp&quot;
 30 #include &quot;gc/z/zRelocate.hpp&quot;
 31 #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
 32 #include &quot;gc/z/zRootsIterator.hpp&quot;

 33 #include &quot;gc/z/zTask.hpp&quot;

 34 #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
 35 #include &quot;gc/z/zWorkers.hpp&quot;



 36 
 37 ZRelocate::ZRelocate(ZWorkers* workers) :
 38     _workers(workers) {}
 39 
 40 class ZRelocateRootsIteratorClosure : public ZRootsIteratorClosure {
 41 public:
 42   virtual void do_thread(Thread* thread) {
 43     // Update thread local address bad mask
 44     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
 45 



 46     // Remap TLAB
 47     ZThreadLocalAllocBuffer::remap(thread);
 48   }
 49 




 50   virtual void do_oop(oop* p) {
 51     ZBarrier::relocate_barrier_on_root_oop_field(p);
 52   }
 53 
 54   virtual void do_oop(narrowOop* p) {
 55     ShouldNotReachHere();
 56   }
 57 };
 58 
 59 class ZRelocateRootsTask : public ZTask {
 60 private:
 61   ZRootsIterator                _roots;
 62   ZRelocateRootsIteratorClosure _cl;
 63 
 64 public:
 65   ZRelocateRootsTask() :
 66       ZTask(&quot;ZRelocateRootsTask&quot;),
<span class="line-modified"> 67       _roots() {}</span>
 68 
 69   virtual void work() {
 70     // During relocation we need to visit the JVMTI
 71     // export weak roots to rehash the JVMTI tag map
<span class="line-modified"> 72     _roots.oops_do(&amp;_cl, true /* visit_jvmti_weak_export */);</span>
 73   }
 74 };
 75 
 76 void ZRelocate::start() {
 77   ZRelocateRootsTask task;
 78   _workers-&gt;run_parallel(&amp;task);
 79 }
 80 









































































 81 class ZRelocateObjectClosure : public ObjectClosure {
 82 private:
<span class="line-modified"> 83   ZPage* const _page;</span>

 84 
 85 public:
<span class="line-modified"> 86   ZRelocateObjectClosure(ZPage* page) :</span>
<span class="line-modified"> 87       _page(page) {}</span>

 88 
 89   virtual void do_object(oop o) {
<span class="line-modified"> 90     _page-&gt;relocate_object(ZOop::to_address(o));</span>
 91   }
 92 };
 93 
 94 bool ZRelocate::work(ZRelocationSetParallelIterator* iter) {
 95   bool success = true;
 96 
 97   // Relocate pages in the relocation set
<span class="line-modified"> 98   for (ZPage* page; iter-&gt;next(&amp;page);) {</span>
 99     // Relocate objects in page
<span class="line-modified">100     ZRelocateObjectClosure cl(page);</span>
<span class="line-modified">101     page-&gt;object_iterate(&amp;cl);</span>
102 
103     if (ZVerifyForwarding) {
<span class="line-modified">104       page-&gt;verify_forwarding();</span>
105     }
106 
<span class="line-modified">107     if (page-&gt;is_pinned()) {</span>
108       // Relocation failed, page is now pinned
109       success = false;
110     } else {
111       // Relocation succeeded, release page
<span class="line-modified">112       ZHeap::heap()-&gt;release_page(page, true /* reclaimed */);</span>
113     }
114   }
115 
116   return success;
117 }
118 
119 class ZRelocateTask : public ZTask {
120 private:
121   ZRelocate* const               _relocate;
122   ZRelocationSetParallelIterator _iter;
123   bool                           _failed;
124 
125 public:
126   ZRelocateTask(ZRelocate* relocate, ZRelocationSet* relocation_set) :
127       ZTask(&quot;ZRelocateTask&quot;),
128       _relocate(relocate),
129       _iter(relocation_set),
130       _failed(false) {}
131 
132   virtual void work() {
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;gc/z/zAddress.inline.hpp&quot;
 26 #include &quot;gc/z/zBarrier.inline.hpp&quot;
<span class="line-added"> 27 #include &quot;gc/z/zForwarding.inline.hpp&quot;</span>
 28 #include &quot;gc/z/zHeap.hpp&quot;
 29 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 30 #include &quot;gc/z/zPage.hpp&quot;
 31 #include &quot;gc/z/zRelocate.hpp&quot;
 32 #include &quot;gc/z/zRelocationSet.inline.hpp&quot;
 33 #include &quot;gc/z/zRootsIterator.hpp&quot;
<span class="line-added"> 34 #include &quot;gc/z/zStat.hpp&quot;</span>
 35 #include &quot;gc/z/zTask.hpp&quot;
<span class="line-added"> 36 #include &quot;gc/z/zThread.inline.hpp&quot;</span>
 37 #include &quot;gc/z/zThreadLocalAllocBuffer.hpp&quot;
 38 #include &quot;gc/z/zWorkers.hpp&quot;
<span class="line-added"> 39 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 static const ZStatCounter ZCounterRelocationContention(&quot;Contention&quot;, &quot;Relocation Contention&quot;, ZStatUnitOpsPerSecond);</span>
 42 
 43 ZRelocate::ZRelocate(ZWorkers* workers) :
 44     _workers(workers) {}
 45 
 46 class ZRelocateRootsIteratorClosure : public ZRootsIteratorClosure {
 47 public:
 48   virtual void do_thread(Thread* thread) {
 49     // Update thread local address bad mask
 50     ZThreadLocalData::set_address_bad_mask(thread, ZAddressBadMask);
 51 
<span class="line-added"> 52     // Relocate invisible root</span>
<span class="line-added"> 53     ZThreadLocalData::do_invisible_root(thread, ZBarrier::relocate_barrier_on_root_oop_field);</span>
<span class="line-added"> 54 </span>
 55     // Remap TLAB
 56     ZThreadLocalAllocBuffer::remap(thread);
 57   }
 58 
<span class="line-added"> 59   virtual bool should_disarm_nmethods() const {</span>
<span class="line-added"> 60     return true;</span>
<span class="line-added"> 61   }</span>
<span class="line-added"> 62 </span>
 63   virtual void do_oop(oop* p) {
 64     ZBarrier::relocate_barrier_on_root_oop_field(p);
 65   }
 66 
 67   virtual void do_oop(narrowOop* p) {
 68     ShouldNotReachHere();
 69   }
 70 };
 71 
 72 class ZRelocateRootsTask : public ZTask {
 73 private:
 74   ZRootsIterator                _roots;
 75   ZRelocateRootsIteratorClosure _cl;
 76 
 77 public:
 78   ZRelocateRootsTask() :
 79       ZTask(&quot;ZRelocateRootsTask&quot;),
<span class="line-modified"> 80       _roots(true /* visit_jvmti_weak_export */) {}</span>
 81 
 82   virtual void work() {
 83     // During relocation we need to visit the JVMTI
 84     // export weak roots to rehash the JVMTI tag map
<span class="line-modified"> 85     _roots.oops_do(&amp;_cl);</span>
 86   }
 87 };
 88 
 89 void ZRelocate::start() {
 90   ZRelocateRootsTask task;
 91   _workers-&gt;run_parallel(&amp;task);
 92 }
 93 
<span class="line-added"> 94 uintptr_t ZRelocate::relocate_object_inner(ZForwarding* forwarding, uintptr_t from_index, uintptr_t from_offset) const {</span>
<span class="line-added"> 95   ZForwardingCursor cursor;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97   // Lookup forwarding entry</span>
<span class="line-added"> 98   const ZForwardingEntry entry = forwarding-&gt;find(from_index, &amp;cursor);</span>
<span class="line-added"> 99   if (entry.populated() &amp;&amp; entry.from_index() == from_index) {</span>
<span class="line-added">100     // Already relocated, return new address</span>
<span class="line-added">101     return entry.to_offset();</span>
<span class="line-added">102   }</span>
<span class="line-added">103 </span>
<span class="line-added">104   assert(ZHeap::heap()-&gt;is_object_live(ZAddress::good(from_offset)), &quot;Should be live&quot;);</span>
<span class="line-added">105 </span>
<span class="line-added">106   if (forwarding-&gt;is_pinned()) {</span>
<span class="line-added">107     // In-place forward</span>
<span class="line-added">108     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);</span>
<span class="line-added">109   }</span>
<span class="line-added">110 </span>
<span class="line-added">111   // Allocate object</span>
<span class="line-added">112   const uintptr_t from_good = ZAddress::good(from_offset);</span>
<span class="line-added">113   const size_t size = ZUtils::object_size(from_good);</span>
<span class="line-added">114   const uintptr_t to_good = ZHeap::heap()-&gt;alloc_object_for_relocation(size);</span>
<span class="line-added">115   if (to_good == 0) {</span>
<span class="line-added">116     // Failed, in-place forward</span>
<span class="line-added">117     return forwarding-&gt;insert(from_index, from_offset, &amp;cursor);</span>
<span class="line-added">118   }</span>
<span class="line-added">119 </span>
<span class="line-added">120   // Copy object</span>
<span class="line-added">121   ZUtils::object_copy(from_good, to_good, size);</span>
<span class="line-added">122 </span>
<span class="line-added">123   // Insert forwarding entry</span>
<span class="line-added">124   const uintptr_t to_offset = ZAddress::offset(to_good);</span>
<span class="line-added">125   const uintptr_t to_offset_final = forwarding-&gt;insert(from_index, to_offset, &amp;cursor);</span>
<span class="line-added">126   if (to_offset_final == to_offset) {</span>
<span class="line-added">127     // Relocation succeeded</span>
<span class="line-added">128     return to_offset;</span>
<span class="line-added">129   }</span>
<span class="line-added">130 </span>
<span class="line-added">131   // Relocation contention</span>
<span class="line-added">132   ZStatInc(ZCounterRelocationContention);</span>
<span class="line-added">133   log_trace(gc)(&quot;Relocation contention, thread: &quot; PTR_FORMAT &quot; (%s), forwarding: &quot; PTR_FORMAT</span>
<span class="line-added">134                 &quot;, entry: &quot; SIZE_FORMAT &quot;, oop: &quot; PTR_FORMAT &quot;, size: &quot; SIZE_FORMAT,</span>
<span class="line-added">135                 ZThread::id(), ZThread::name(), p2i(forwarding), cursor, from_good, size);</span>
<span class="line-added">136 </span>
<span class="line-added">137   // Try undo allocation</span>
<span class="line-added">138   ZHeap::heap()-&gt;undo_alloc_object_for_relocation(to_good, size);</span>
<span class="line-added">139 </span>
<span class="line-added">140   return to_offset_final;</span>
<span class="line-added">141 }</span>
<span class="line-added">142 </span>
<span class="line-added">143 uintptr_t ZRelocate::relocate_object(ZForwarding* forwarding, uintptr_t from_addr) const {</span>
<span class="line-added">144   const uintptr_t from_offset = ZAddress::offset(from_addr);</span>
<span class="line-added">145   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();</span>
<span class="line-added">146   const uintptr_t to_offset = relocate_object_inner(forwarding, from_index, from_offset);</span>
<span class="line-added">147 </span>
<span class="line-added">148   if (from_offset == to_offset) {</span>
<span class="line-added">149     // In-place forwarding, pin page</span>
<span class="line-added">150     forwarding-&gt;set_pinned();</span>
<span class="line-added">151   }</span>
<span class="line-added">152 </span>
<span class="line-added">153   return ZAddress::good(to_offset);</span>
<span class="line-added">154 }</span>
<span class="line-added">155 </span>
<span class="line-added">156 uintptr_t ZRelocate::forward_object(ZForwarding* forwarding, uintptr_t from_addr) const {</span>
<span class="line-added">157   const uintptr_t from_offset = ZAddress::offset(from_addr);</span>
<span class="line-added">158   const uintptr_t from_index = (from_offset - forwarding-&gt;start()) &gt;&gt; forwarding-&gt;object_alignment_shift();</span>
<span class="line-added">159   const ZForwardingEntry entry = forwarding-&gt;find(from_index);</span>
<span class="line-added">160 </span>
<span class="line-added">161   assert(entry.populated(), &quot;Should be forwarded&quot;);</span>
<span class="line-added">162   assert(entry.from_index() == from_index, &quot;Should be forwarded&quot;);</span>
<span class="line-added">163 </span>
<span class="line-added">164   return ZAddress::good(entry.to_offset());</span>
<span class="line-added">165 }</span>
<span class="line-added">166 </span>
167 class ZRelocateObjectClosure : public ObjectClosure {
168 private:
<span class="line-modified">169   ZRelocate* const   _relocate;</span>
<span class="line-added">170   ZForwarding* const _forwarding;</span>
171 
172 public:
<span class="line-modified">173   ZRelocateObjectClosure(ZRelocate* relocate, ZForwarding* forwarding) :</span>
<span class="line-modified">174       _relocate(relocate),</span>
<span class="line-added">175       _forwarding(forwarding) {}</span>
176 
177   virtual void do_object(oop o) {
<span class="line-modified">178     _relocate-&gt;relocate_object(_forwarding, ZOop::to_address(o));</span>
179   }
180 };
181 
182 bool ZRelocate::work(ZRelocationSetParallelIterator* iter) {
183   bool success = true;
184 
185   // Relocate pages in the relocation set
<span class="line-modified">186   for (ZForwarding* forwarding; iter-&gt;next(&amp;forwarding);) {</span>
187     // Relocate objects in page
<span class="line-modified">188     ZRelocateObjectClosure cl(this, forwarding);</span>
<span class="line-modified">189     forwarding-&gt;page()-&gt;object_iterate(&amp;cl);</span>
190 
191     if (ZVerifyForwarding) {
<span class="line-modified">192       forwarding-&gt;verify();</span>
193     }
194 
<span class="line-modified">195     if (forwarding-&gt;is_pinned()) {</span>
196       // Relocation failed, page is now pinned
197       success = false;
198     } else {
199       // Relocation succeeded, release page
<span class="line-modified">200       forwarding-&gt;release_page();</span>
201     }
202   }
203 
204   return success;
205 }
206 
207 class ZRelocateTask : public ZTask {
208 private:
209   ZRelocate* const               _relocate;
210   ZRelocationSetParallelIterator _iter;
211   bool                           _failed;
212 
213 public:
214   ZRelocateTask(ZRelocate* relocate, ZRelocationSet* relocation_set) :
215       ZTask(&quot;ZRelocateTask&quot;),
216       _relocate(relocate),
217       _iter(relocation_set),
218       _failed(false) {}
219 
220   virtual void work() {
</pre>
</td>
</tr>
</table>
<center><a href="zReferenceProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
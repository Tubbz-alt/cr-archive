diff a/src/hotspot/share/gc/z/zLock.inline.hpp b/src/hotspot/share/gc/z/zLock.inline.hpp
--- a/src/hotspot/share/gc/z/zLock.inline.hpp
+++ b/src/hotspot/share/gc/z/zLock.inline.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,31 +24,24 @@
 #ifndef SHARE_GC_Z_ZLOCK_INLINE_HPP
 #define SHARE_GC_Z_ZLOCK_INLINE_HPP
 
 #include "gc/z/zLock.hpp"
 #include "runtime/atomic.hpp"
+#include "runtime/os.inline.hpp"
 #include "runtime/thread.hpp"
 #include "utilities/debug.hpp"
 
-inline ZLock::ZLock() {
-  pthread_mutex_init(&_lock, NULL);
-}
-
-inline ZLock::~ZLock() {
-  pthread_mutex_destroy(&_lock);
-}
-
 inline void ZLock::lock() {
-  pthread_mutex_lock(&_lock);
+  _lock.lock();
 }
 
 inline bool ZLock::try_lock() {
-  return pthread_mutex_trylock(&_lock) == 0;
+  return _lock.try_lock();
 }
 
 inline void ZLock::unlock() {
-  pthread_mutex_unlock(&_lock);
+  _lock.unlock();
 }
 
 inline ZReentrantLock::ZReentrantLock() :
     _lock(),
     _owner(NULL),
@@ -58,11 +51,11 @@
   Thread* const thread = Thread::current();
   Thread* const owner = Atomic::load(&_owner);
 
   if (owner != thread) {
     _lock.lock();
-    Atomic::store(thread, &_owner);
+    Atomic::store(&_owner, thread);
   }
 
   _count++;
 }
 
@@ -71,11 +64,11 @@
   assert(_count > 0, "Invalid count");
 
   _count--;
 
   if (_count == 0) {
-    Atomic::store((Thread*)NULL, &_owner);
+    Atomic::store(&_owner, (Thread*)NULL);
     _lock.unlock();
   }
 }
 
 inline bool ZReentrantLock::is_owned() const {
@@ -85,14 +78,18 @@
 }
 
 template <typename T>
 inline ZLocker<T>::ZLocker(T* lock) :
     _lock(lock) {
-  _lock->lock();
+  if (_lock != NULL) {
+    _lock->lock();
+  }
 }
 
 template <typename T>
 inline ZLocker<T>::~ZLocker() {
-  _lock->unlock();
+  if (_lock != NULL) {
+    _lock->unlock();
+  }
 }
 
 #endif // SHARE_GC_Z_ZLOCK_INLINE_HPP

diff a/src/hotspot/share/gc/z/zCollectedHeap.cpp b/src/hotspot/share/gc/z/zCollectedHeap.cpp
--- a/src/hotspot/share/gc/z/zCollectedHeap.cpp
+++ b/src/hotspot/share/gc/z/zCollectedHeap.cpp
@@ -26,48 +26,52 @@
 #include "gc/shared/suspendibleThreadSet.hpp"
 #include "gc/z/zCollectedHeap.hpp"
 #include "gc/z/zGlobals.hpp"
 #include "gc/z/zHeap.inline.hpp"
 #include "gc/z/zNMethod.hpp"
+#include "gc/z/zObjArrayAllocator.hpp"
+#include "gc/z/zOop.inline.hpp"
 #include "gc/z/zServiceability.hpp"
 #include "gc/z/zStat.hpp"
 #include "gc/z/zUtils.inline.hpp"
+#include "memory/iterator.hpp"
+#include "memory/universe.hpp"
 #include "runtime/mutexLocker.hpp"
+#include "utilities/align.hpp"
 
 ZCollectedHeap* ZCollectedHeap::heap() {
   CollectedHeap* heap = Universe::heap();
   assert(heap != NULL, "Uninitialized access to ZCollectedHeap::heap()");
   assert(heap->kind() == CollectedHeap::Z, "Invalid name");
   return (ZCollectedHeap*)heap;
 }
 
-ZCollectedHeap::ZCollectedHeap(ZCollectorPolicy* policy) :
-    _collector_policy(policy),
+ZCollectedHeap::ZCollectedHeap() :
     _soft_ref_policy(),
     _barrier_set(),
     _initialize(&_barrier_set),
     _heap(),
     _director(new ZDirector()),
     _driver(new ZDriver()),
+    _uncommitter(new ZUncommitter()),
     _stat(new ZStat()),
     _runtime_workers() {}
 
 CollectedHeap::Name ZCollectedHeap::kind() const {
   return CollectedHeap::Z;
 }
 
 const char* ZCollectedHeap::name() const {
-  return ZGCName;
+  return ZName;
 }
 
 jint ZCollectedHeap::initialize() {
   if (!_heap.is_initialized()) {
     return JNI_ENOMEM;
   }
 
-  initialize_reserved_region((HeapWord*)ZAddressReservedStart(),
-                             (HeapWord*)ZAddressReservedEnd());
+  Universe::calculate_verify_data((HeapWord*)0, (HeapWord*)UINTPTR_MAX);
 
   return JNI_OK;
 }
 
 void ZCollectedHeap::initialize_serviceability() {
@@ -75,17 +79,14 @@
 }
 
 void ZCollectedHeap::stop() {
   _director->stop();
   _driver->stop();
+  _uncommitter->stop();
   _stat->stop();
 }
 
-CollectorPolicy* ZCollectedHeap::collector_policy() const {
-  return _collector_policy;
-}
-
 SoftRefPolicy* ZCollectedHeap::soft_ref_policy() {
   return &_soft_ref_policy;
 }
 
 size_t ZCollectedHeap::max_capacity() const {
@@ -98,22 +99,26 @@
 
 size_t ZCollectedHeap::used() const {
   return _heap.used();
 }
 
+size_t ZCollectedHeap::unused() const {
+  return _heap.unused();
+}
+
 bool ZCollectedHeap::is_maximal_no_gc() const {
   // Not supported
   ShouldNotReachHere();
   return false;
 }
 
 bool ZCollectedHeap::is_in(const void* p) const {
-  return is_in_reserved(p) && _heap.is_in((uintptr_t)p);
+  return _heap.is_in((uintptr_t)p);
 }
 
-bool ZCollectedHeap::is_in_closed_subset(const void* p) const {
-  return is_in(p);
+uint32_t ZCollectedHeap::hash_oop(oop obj) const {
+  return _heap.hash_oop(ZOop::to_address(obj));
 }
 
 HeapWord* ZCollectedHeap::allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) {
   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(requested_size));
   const uintptr_t addr = _heap.alloc_tlab(size_in_bytes);
@@ -123,10 +128,19 @@
   }
 
   return (HeapWord*)addr;
 }
 
+oop ZCollectedHeap::array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS) {
+  if (!do_zero) {
+    return CollectedHeap::array_allocate(klass, size, length, false /* do_zero */, THREAD);
+  }
+
+  ZObjArrayAllocator allocator(klass, size, length, THREAD);
+  return allocator.allocate();
+}
+
 HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {
   const size_t size_in_bytes = ZUtils::words_to_bytes(align_object_size(size));
   return (HeapWord*)_heap.alloc_object(size_in_bytes);
 }
 
@@ -228,23 +242,15 @@
 GrowableArray<MemoryPool*> ZCollectedHeap::memory_pools() {
   return GrowableArray<MemoryPool*>(1, 1, _heap.serviceability_memory_pool());
 }
 
 void ZCollectedHeap::object_iterate(ObjectClosure* cl) {
-  _heap.object_iterate(cl, true /* visit_referents */);
+  _heap.object_iterate(cl, true /* visit_weaks */);
 }
 
-void ZCollectedHeap::safe_object_iterate(ObjectClosure* cl) {
-  _heap.object_iterate(cl, true /* visit_referents */);
-}
-
-HeapWord* ZCollectedHeap::block_start(const void* addr) const {
-  return (HeapWord*)_heap.block_start((uintptr_t)addr);
-}
-
-bool ZCollectedHeap::block_is_obj(const HeapWord* addr) const {
-  return _heap.block_is_obj((uintptr_t)addr);
+void ZCollectedHeap::keep_alive(oop obj) {
+  _heap.keep_alive(obj);
 }
 
 void ZCollectedHeap::register_nmethod(nmethod* nm) {
   ZNMethod::register_nmethod(nm);
 }
@@ -270,21 +276,18 @@
 }
 
 void ZCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
   tc->do_thread(_director);
   tc->do_thread(_driver);
+  tc->do_thread(_uncommitter);
   tc->do_thread(_stat);
   _heap.worker_threads_do(tc);
   _runtime_workers.threads_do(tc);
 }
 
 VirtualSpaceSummary ZCollectedHeap::create_heap_space_summary() {
-  const size_t capacity_in_words = capacity() / HeapWordSize;
-  const size_t max_capacity_in_words = max_capacity() / HeapWordSize;
-  return VirtualSpaceSummary(reserved_region().start(),
-                             reserved_region().start() + capacity_in_words,
-                             reserved_region().start() + max_capacity_in_words);
+  return VirtualSpaceSummary((HeapWord*)0, (HeapWord*)capacity(), (HeapWord*)max_capacity());
 }
 
 void ZCollectedHeap::safepoint_synchronize_begin() {
   SuspendibleThreadSet::synchronize();
 }
@@ -302,14 +305,10 @@
 }
 
 void ZCollectedHeap::print_on_error(outputStream* st) const {
   CollectedHeap::print_on_error(st);
 
-  st->print_cr("Address Space");
-  st->print_cr( "     Start:             " PTR_FORMAT, ZAddressSpaceStart);
-  st->print_cr( "     End:               " PTR_FORMAT, ZAddressSpaceEnd);
-  st->print_cr( "     Size:              " SIZE_FORMAT_W(-15) " (" PTR_FORMAT ")", ZAddressSpaceSize, ZAddressSpaceSize);
   st->print_cr( "Heap");
   st->print_cr( "     GlobalPhase:       %u", ZGlobalPhase);
   st->print_cr( "     GlobalSeqNum:      %u", ZGlobalSeqNum);
   st->print_cr( "     Offset Max:        " SIZE_FORMAT_W(-15) " (" PTR_FORMAT ")", ZAddressOffsetMax, ZAddressOffsetMax);
   st->print_cr( "     Page Size Small:   " SIZE_FORMAT_W(-15) " (" PTR_FORMAT ")", ZPageSizeSmall, ZPageSizeSmall);
@@ -329,22 +328,28 @@
 void ZCollectedHeap::print_gc_threads_on(outputStream* st) const {
   _director->print_on(st);
   st->cr();
   _driver->print_on(st);
   st->cr();
+  _uncommitter->print_on(st);
+  st->cr();
   _stat->print_on(st);
   st->cr();
   _heap.print_worker_threads_on(st);
   _runtime_workers.print_threads_on(st);
 }
 
 void ZCollectedHeap::print_tracing_info() const {
   // Does nothing
 }
 
+bool ZCollectedHeap::print_location(outputStream* st, void* addr) const {
+  return _heap.print_location(st, (uintptr_t)addr);
+}
+
 void ZCollectedHeap::verify(VerifyOption option /* ignored */) {
   _heap.verify();
 }
 
 bool ZCollectedHeap::is_oop(oop object) const {
-  return CollectedHeap::is_oop(object) && _heap.is_oop(object);
+  return _heap.is_oop(ZOop::to_address(object));
 }

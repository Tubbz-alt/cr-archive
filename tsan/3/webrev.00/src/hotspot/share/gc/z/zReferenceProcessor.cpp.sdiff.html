<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zReferenceProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zPhysicalMemory.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zReferenceProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/javaClasses.inline.hpp&quot;
 26 #include &quot;gc/shared/referencePolicy.hpp&quot;
 27 #include &quot;gc/shared/referenceProcessorStats.hpp&quot;
 28 #include &quot;gc/z/zHeap.inline.hpp&quot;
 29 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 30 #include &quot;gc/z/zReferenceProcessor.hpp&quot;
 31 #include &quot;gc/z/zStat.hpp&quot;
 32 #include &quot;gc/z/zTask.hpp&quot;
 33 #include &quot;gc/z/zTracer.inline.hpp&quot;
 34 #include &quot;gc/z/zUtils.inline.hpp&quot;

 35 #include &quot;memory/universe.hpp&quot;

 36 #include &quot;runtime/mutexLocker.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 
 39 static const ZStatSubPhase ZSubPhaseConcurrentReferencesProcess(&quot;Concurrent References Process&quot;);
 40 static const ZStatSubPhase ZSubPhaseConcurrentReferencesEnqueue(&quot;Concurrent References Enqueue&quot;);
 41 
 42 static ReferenceType reference_type(oop reference) {
 43   return InstanceKlass::cast(reference-&gt;klass())-&gt;reference_type();
 44 }
 45 
 46 static const char* reference_type_name(ReferenceType type) {
 47   switch (type) {
 48   case REF_SOFT:
 49     return &quot;Soft&quot;;
 50 
 51   case REF_WEAK:
 52     return &quot;Weak&quot;;
 53 
 54   case REF_FINAL:
 55     return &quot;Final&quot;;
</pre>
<hr />
<pre>
298 }
299 
300 void ZReferenceProcessor::work() {
301   // Process discovered references
302   oop* const list = _discovered_list.addr();
303   oop* p = list;
304 
305   while (*p != NULL) {
306     const oop reference = *p;
307     const ReferenceType type = reference_type(reference);
308 
309     if (should_drop(reference, type)) {
310       *p = drop(reference, type);
311     } else {
312       p = keep(reference, type);
313     }
314   }
315 
316   // Prepend discovered references to internal pending list
317   if (*list != NULL) {
<span class="line-modified">318     *p = Atomic::xchg(*list, _pending_list.addr());</span>
319     if (*p == NULL) {
320       // First to prepend to list, record tail
321       _pending_list_tail = p;
322     }
323 
324     // Clear discovered list
325     *list = NULL;
326   }
327 }
328 
329 bool ZReferenceProcessor::is_empty() const {
330   ZPerWorkerConstIterator&lt;oop&gt; iter(&amp;_discovered_list);
331   for (const oop* list; iter.next(&amp;list);) {
332     if (*list != NULL) {
333       return false;
334     }
335   }
336 
337   if (_pending_list.get() != NULL) {
338     return false;
</pre>
<hr />
<pre>
433   ZReferenceProcessorTask task(this);
434   _workers-&gt;run_concurrent(&amp;task);
435 
436   // Update SoftReference clock
437   soft_reference_update_clock();
438 
439   // Collect, log and trace statistics
440   collect_statistics();
441 }
442 
443 void ZReferenceProcessor::enqueue_references() {
444   ZStatTimer timer(ZSubPhaseConcurrentReferencesEnqueue);
445 
446   if (_pending_list.get() == NULL) {
447     // Nothing to enqueue
448     return;
449   }
450 
451   {
452     // Heap_lock protects external pending list
<span class="line-modified">453     MonitorLockerEx ml(Heap_lock);</span>
454 
455     // Prepend internal pending list to external pending list
456     *_pending_list_tail = Universe::swap_reference_pending_list(_pending_list.get());
457 
458     // Notify ReferenceHandler thread
459     ml.notify_all();
460   }
461 
462   // Reset internal pending list
463   _pending_list.set(NULL);
464   _pending_list_tail = _pending_list.addr();
465 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;classfile/javaClasses.inline.hpp&quot;
 26 #include &quot;gc/shared/referencePolicy.hpp&quot;
 27 #include &quot;gc/shared/referenceProcessorStats.hpp&quot;
 28 #include &quot;gc/z/zHeap.inline.hpp&quot;
 29 #include &quot;gc/z/zOopClosures.inline.hpp&quot;
 30 #include &quot;gc/z/zReferenceProcessor.hpp&quot;
 31 #include &quot;gc/z/zStat.hpp&quot;
 32 #include &quot;gc/z/zTask.hpp&quot;
 33 #include &quot;gc/z/zTracer.inline.hpp&quot;
 34 #include &quot;gc/z/zUtils.inline.hpp&quot;
<span class="line-added"> 35 #include &quot;gc/z/zValue.inline.hpp&quot;</span>
 36 #include &quot;memory/universe.hpp&quot;
<span class="line-added"> 37 #include &quot;runtime/atomic.hpp&quot;</span>
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 
 41 static const ZStatSubPhase ZSubPhaseConcurrentReferencesProcess(&quot;Concurrent References Process&quot;);
 42 static const ZStatSubPhase ZSubPhaseConcurrentReferencesEnqueue(&quot;Concurrent References Enqueue&quot;);
 43 
 44 static ReferenceType reference_type(oop reference) {
 45   return InstanceKlass::cast(reference-&gt;klass())-&gt;reference_type();
 46 }
 47 
 48 static const char* reference_type_name(ReferenceType type) {
 49   switch (type) {
 50   case REF_SOFT:
 51     return &quot;Soft&quot;;
 52 
 53   case REF_WEAK:
 54     return &quot;Weak&quot;;
 55 
 56   case REF_FINAL:
 57     return &quot;Final&quot;;
</pre>
<hr />
<pre>
300 }
301 
302 void ZReferenceProcessor::work() {
303   // Process discovered references
304   oop* const list = _discovered_list.addr();
305   oop* p = list;
306 
307   while (*p != NULL) {
308     const oop reference = *p;
309     const ReferenceType type = reference_type(reference);
310 
311     if (should_drop(reference, type)) {
312       *p = drop(reference, type);
313     } else {
314       p = keep(reference, type);
315     }
316   }
317 
318   // Prepend discovered references to internal pending list
319   if (*list != NULL) {
<span class="line-modified">320     *p = Atomic::xchg(_pending_list.addr(), *list);</span>
321     if (*p == NULL) {
322       // First to prepend to list, record tail
323       _pending_list_tail = p;
324     }
325 
326     // Clear discovered list
327     *list = NULL;
328   }
329 }
330 
331 bool ZReferenceProcessor::is_empty() const {
332   ZPerWorkerConstIterator&lt;oop&gt; iter(&amp;_discovered_list);
333   for (const oop* list; iter.next(&amp;list);) {
334     if (*list != NULL) {
335       return false;
336     }
337   }
338 
339   if (_pending_list.get() != NULL) {
340     return false;
</pre>
<hr />
<pre>
435   ZReferenceProcessorTask task(this);
436   _workers-&gt;run_concurrent(&amp;task);
437 
438   // Update SoftReference clock
439   soft_reference_update_clock();
440 
441   // Collect, log and trace statistics
442   collect_statistics();
443 }
444 
445 void ZReferenceProcessor::enqueue_references() {
446   ZStatTimer timer(ZSubPhaseConcurrentReferencesEnqueue);
447 
448   if (_pending_list.get() == NULL) {
449     // Nothing to enqueue
450     return;
451   }
452 
453   {
454     // Heap_lock protects external pending list
<span class="line-modified">455     MonitorLocker ml(Heap_lock);</span>
456 
457     // Prepend internal pending list to external pending list
458     *_pending_list_tail = Universe::swap_reference_pending_list(_pending_list.get());
459 
460     // Notify ReferenceHandler thread
461     ml.notify_all();
462   }
463 
464   // Reset internal pending list
465   _pending_list.set(NULL);
466   _pending_list_tail = _pending_list.addr();
467 }
</pre>
</td>
</tr>
</table>
<center><a href="zPhysicalMemory.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zRelocate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/z/zStat.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="zRuntimeWorkers.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zStat.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/z/zStat.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;gc/z/zCollectedHeap.hpp&quot;
<span class="line-modified">  26 #include &quot;gc/z/zCPU.hpp&quot;</span>
  27 #include &quot;gc/z/zGlobals.hpp&quot;
  28 #include &quot;gc/z/zHeap.inline.hpp&quot;
  29 #include &quot;gc/z/zLargePages.inline.hpp&quot;
  30 #include &quot;gc/z/zNMethodTable.hpp&quot;
  31 #include &quot;gc/z/zNUMA.hpp&quot;

  32 #include &quot;gc/z/zStat.hpp&quot;
  33 #include &quot;gc/z/zTracer.inline.hpp&quot;
  34 #include &quot;gc/z/zUtils.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;runtime/atomic.hpp&quot;
  37 #include &quot;runtime/os.hpp&quot;
  38 #include &quot;runtime/timer.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/compilerWarnings.hpp&quot;
  41 #include &quot;utilities/debug.hpp&quot;
  42 #include &quot;utilities/ticks.hpp&quot;
  43 








  44 //
  45 // Stat sampler/counter data
  46 //
  47 struct ZStatSamplerData {
  48   uint64_t _nsamples;
  49   uint64_t _sum;
  50   uint64_t _max;
  51 
  52   ZStatSamplerData() :
  53     _nsamples(0),
  54     _sum(0),
  55     _max(0) {}
  56 
  57   void add(const ZStatSamplerData&amp; new_sample) {
  58     _nsamples += new_sample._nsamples;
<span class="line-modified">  59     _sum += new_sample._nsamples;</span>
  60     _max = MAX2(_max, new_sample._max);
  61   }
  62 };
  63 
  64 struct ZStatCounterData {
  65   uint64_t _counter;
  66 
  67   ZStatCounterData() :
  68     _counter(0) {}
  69 };
  70 
  71 //
  72 // Stat sampler history
  73 //
  74 template &lt;size_t size&gt;
  75 class ZStatSamplerHistoryInterval {
  76 private:
  77   size_t           _next;
  78   ZStatSamplerData _samples[size];
  79   ZStatSamplerData _accumulated;
</pre>
<hr />
<pre>
 213   }
 214 
 215   uint64_t max_10_hours() const {
 216     return MAX3(_10seconds.accumulated()._max,
 217                 _10minutes.accumulated()._max,
 218                 _10hours.total()._max);
 219   }
 220 
 221   uint64_t max_total() const {
 222     return MAX4(_10seconds.accumulated()._max,
 223                 _10minutes.accumulated()._max,
 224                 _10hours.accumulated()._max,
 225                 _total._max);
 226   }
 227 };
 228 
 229 //
 230 // Stat unit printers
 231 //
 232 void ZStatUnitTime(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 233   log.print(&quot; %10s: %-40s  &quot;</span>
 234             &quot;%9.3f / %-9.3f &quot;
 235             &quot;%9.3f / %-9.3f &quot;
 236             &quot;%9.3f / %-9.3f &quot;
 237             &quot;%9.3f / %-9.3f   ms&quot;,
 238             sampler.group(),
 239             sampler.name(),
 240             TimeHelper::counter_to_millis(history.avg_10_seconds()),
 241             TimeHelper::counter_to_millis(history.max_10_seconds()),
 242             TimeHelper::counter_to_millis(history.avg_10_minutes()),
 243             TimeHelper::counter_to_millis(history.max_10_minutes()),
 244             TimeHelper::counter_to_millis(history.avg_10_hours()),
 245             TimeHelper::counter_to_millis(history.max_10_hours()),
 246             TimeHelper::counter_to_millis(history.avg_total()),
 247             TimeHelper::counter_to_millis(history.max_total()));
 248 }
 249 
 250 void ZStatUnitBytes(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 251   log.print(&quot; %10s: %-40s  &quot;</span>
 252             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 253             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 254             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 255             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   MB&quot;,
 256             sampler.group(),
 257             sampler.name(),
 258             history.avg_10_seconds() / M,
 259             history.max_10_seconds() / M,
 260             history.avg_10_minutes() / M,
 261             history.max_10_minutes() / M,
 262             history.avg_10_hours() / M,
 263             history.max_10_hours() / M,
 264             history.avg_total() / M,
 265             history.max_total() / M);
 266 }
 267 
 268 void ZStatUnitThreads(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 269   log.print(&quot; %10s: %-40s  &quot;</span>
 270             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 271             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 272             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 273             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   threads&quot;,
 274             sampler.group(),
 275             sampler.name(),
 276             history.avg_10_seconds(),
 277             history.max_10_seconds(),
 278             history.avg_10_minutes(),
 279             history.max_10_minutes(),
 280             history.avg_10_hours(),
 281             history.max_10_hours(),
 282             history.avg_total(),
 283             history.max_total());
 284 }
 285 
 286 void ZStatUnitBytesPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 287   log.print(&quot; %10s: %-40s  &quot;</span>
 288             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 289             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 290             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 291             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   MB/s&quot;,
 292             sampler.group(),
 293             sampler.name(),
 294             history.avg_10_seconds() / M,
 295             history.max_10_seconds() / M,
 296             history.avg_10_minutes() / M,
 297             history.max_10_minutes() / M,
 298             history.avg_10_hours() / M,
 299             history.max_10_hours() / M,
 300             history.avg_total() / M,
 301             history.max_total() / M);
 302 }
 303 
 304 void ZStatUnitOpsPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 305   log.print(&quot; %10s: %-40s  &quot;</span>
 306             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 307             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 308             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 309             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   ops/s&quot;,
 310             sampler.group(),
 311             sampler.name(),
 312             history.avg_10_seconds(),
 313             history.max_10_seconds(),
 314             history.avg_10_minutes(),
 315             history.max_10_minutes(),
 316             history.avg_10_hours(),
 317             history.max_10_hours(),
 318             history.avg_total(),
 319             history.max_total());
 320 }
 321 
 322 //
 323 // Stat value
 324 //
 325 uintptr_t ZStatValue::_base = 0;
</pre>
<hr />
<pre>
 330                           uint32_t id,
 331                           uint32_t size) :
 332     _group(group),
 333     _name(name),
 334     _id(id),
 335     _offset(_cpu_offset) {
 336   assert(_base == 0, &quot;Already initialized&quot;);
 337   _cpu_offset += size;
 338 }
 339 
 340 template &lt;typename T&gt;
 341 T* ZStatValue::get_cpu_local(uint32_t cpu) const {
 342   assert(_base != 0, &quot;Not initialized&quot;);
 343   const uintptr_t cpu_base = _base + (_cpu_offset * cpu);
 344   const uintptr_t value_addr = cpu_base + _offset;
 345   return (T*)value_addr;
 346 }
 347 
 348 void ZStatValue::initialize() {
 349   // Finalize and align CPU offset
<span class="line-modified"> 350   _cpu_offset = align_up(_cpu_offset, ZCacheLineSize);</span>
 351 
 352   // Allocation aligned memory
 353   const size_t size = _cpu_offset * ZCPU::count();
 354   _base = ZUtils::alloc_aligned(ZCacheLineSize, size);
<span class="line-removed"> 355   memset((void*)_base, 0, size);</span>
 356 }
 357 
 358 const char* ZStatValue::group() const {
 359   return _group;
 360 }
 361 
 362 const char* ZStatValue::name() const {
 363   return _name;
 364 }
 365 
 366 uint32_t ZStatValue::id() const {
 367   return _id;
 368 }
 369 
 370 //
 371 // Stat iterable value
 372 //
 373 template &lt;typename T&gt; uint32_t ZStatIterableValue&lt;T&gt;::_count = 0;
 374 template &lt;typename T&gt; T*       ZStatIterableValue&lt;T&gt;::_first = NULL;
 375 
</pre>
<hr />
<pre>
 401 }
 402 
 403 //
 404 // Stat sampler
 405 //
 406 ZStatSampler::ZStatSampler(const char* group, const char* name, ZStatUnitPrinter printer) :
 407     ZStatIterableValue&lt;ZStatSampler&gt;(group, name, sizeof(ZStatSamplerData)),
 408     _printer(printer) {}
 409 
 410 ZStatSamplerData* ZStatSampler::get() const {
 411   return get_cpu_local&lt;ZStatSamplerData&gt;(ZCPU::id());
 412 }
 413 
 414 ZStatSamplerData ZStatSampler::collect_and_reset() const {
 415   ZStatSamplerData all;
 416 
 417   const uint32_t ncpus = ZCPU::count();
 418   for (uint32_t i = 0; i &lt; ncpus; i++) {
 419     ZStatSamplerData* const cpu_data = get_cpu_local&lt;ZStatSamplerData&gt;(i);
 420     if (cpu_data-&gt;_nsamples &gt; 0) {
<span class="line-modified"> 421       const uint64_t nsamples = Atomic::xchg((uint64_t)0, &amp;cpu_data-&gt;_nsamples);</span>
<span class="line-modified"> 422       const uint64_t sum = Atomic::xchg((uint64_t)0, &amp;cpu_data-&gt;_sum);</span>
<span class="line-modified"> 423       const uint64_t max = Atomic::xchg((uint64_t)0, &amp;cpu_data-&gt;_max);</span>
 424       all._nsamples += nsamples;
 425       all._sum += sum;
 426       if (all._max &lt; max) {
 427         all._max = max;
 428       }
 429     }
 430   }
 431 
 432   return all;
 433 }
 434 
 435 ZStatUnitPrinter ZStatSampler::printer() const {
 436   return _printer;
 437 }
 438 
 439 //
 440 // Stat counter
 441 //
 442 ZStatCounter::ZStatCounter(const char* group, const char* name, ZStatUnitPrinter printer) :
 443     ZStatIterableValue&lt;ZStatCounter&gt;(group, name, sizeof(ZStatCounterData)),
 444     _sampler(group, name, printer) {}
 445 
 446 ZStatCounterData* ZStatCounter::get() const {
 447   return get_cpu_local&lt;ZStatCounterData&gt;(ZCPU::id());
 448 }
 449 
 450 void ZStatCounter::sample_and_reset() const {
 451   uint64_t counter = 0;
 452 
 453   const uint32_t ncpus = ZCPU::count();
 454   for (uint32_t i = 0; i &lt; ncpus; i++) {
 455     ZStatCounterData* const cpu_data = get_cpu_local&lt;ZStatCounterData&gt;(i);
<span class="line-modified"> 456     counter += Atomic::xchg((uint64_t)0, &amp;cpu_data-&gt;_counter);</span>
 457   }
 458 
 459   ZStatSample(_sampler, counter);
 460 }
 461 
 462 //
 463 // Stat unsampled counter
 464 //
 465 ZStatUnsampledCounter::ZStatUnsampledCounter(const char* name) :
 466     ZStatIterableValue&lt;ZStatUnsampledCounter&gt;(&quot;Unsampled&quot;, name, sizeof(ZStatCounterData)) {}
 467 
 468 ZStatCounterData* ZStatUnsampledCounter::get() const {
 469   return get_cpu_local&lt;ZStatCounterData&gt;(ZCPU::id());
 470 }
 471 
 472 ZStatCounterData ZStatUnsampledCounter::collect_and_reset() const {
 473   ZStatCounterData all;
 474 
 475   const uint32_t ncpus = ZCPU::count();
 476   for (uint32_t i = 0; i &lt; ncpus; i++) {
 477     ZStatCounterData* const cpu_data = get_cpu_local&lt;ZStatCounterData&gt;(i);
<span class="line-modified"> 478     all._counter += Atomic::xchg((uint64_t)0, &amp;cpu_data-&gt;_counter);</span>
 479   }
 480 
 481   return all;
 482 }
 483 
 484 //
 485 // Stat MMU (Minimum Mutator Utilization)
 486 //
 487 ZStatMMUPause::ZStatMMUPause() :
 488     _start(0.0),
 489     _end(0.0) {}
 490 
 491 ZStatMMUPause::ZStatMMUPause(const Ticks&amp; start, const Ticks&amp; end) :
 492     _start(TimeHelper::counter_to_millis(start.value())),
 493     _end(TimeHelper::counter_to_millis(end.value())) {}
 494 
 495 double ZStatMMUPause::end() const {
 496   return _end;
 497 }
 498 
</pre>
<hr />
<pre>
 604 
 605 const char* ZStatPhase::name() const {
 606   return _sampler.name();
 607 }
 608 
 609 ZStatPhaseCycle::ZStatPhaseCycle(const char* name) :
 610     ZStatPhase(&quot;Collector&quot;, name) {}
 611 
 612 void ZStatPhaseCycle::register_start(const Ticks&amp; start) const {
 613   timer()-&gt;register_gc_start(start);
 614 
 615   ZTracer::tracer()-&gt;report_gc_start(ZCollectedHeap::heap()-&gt;gc_cause(), start);
 616 
 617   ZCollectedHeap::heap()-&gt;print_heap_before_gc();
 618   ZCollectedHeap::heap()-&gt;trace_heap_before_gc(ZTracer::tracer());
 619 
 620   log_info(gc, start)(&quot;Garbage Collection (%s)&quot;,
 621                        GCCause::to_string(ZCollectedHeap::heap()-&gt;gc_cause()));
 622 }
 623 
<span class="line-removed"> 624 #define ZUSED_FMT                       SIZE_FORMAT &quot;M(%.0lf%%)&quot;</span>
<span class="line-removed"> 625 #define ZUSED_ARGS(size, max_capacity)  ((size) / M), (percent_of(size, max_capacity))</span>
<span class="line-removed"> 626 </span>
 627 void ZStatPhaseCycle::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 628   timer()-&gt;register_gc_end(end);
 629 
 630   ZCollectedHeap::heap()-&gt;print_heap_after_gc();
 631   ZCollectedHeap::heap()-&gt;trace_heap_after_gc(ZTracer::tracer());
 632 
 633   ZTracer::tracer()-&gt;report_gc_end(end, timer()-&gt;time_partitions());
 634 
 635   const Tickspan duration = end - start;
 636   ZStatSample(_sampler, duration.value());
 637 
 638   ZStatLoad::print();
 639   ZStatMMU::print();
 640   ZStatMark::print();
<span class="line-removed"> 641   ZStatRelocation::print();</span>
 642   ZStatNMethods::print();
 643   ZStatMetaspace::print();
 644   ZStatReferences::print();

 645   ZStatHeap::print();
 646 
<span class="line-modified"> 647   log_info(gc)(&quot;Garbage Collection (%s) &quot; ZUSED_FMT &quot;-&gt;&quot; ZUSED_FMT,</span>
 648                GCCause::to_string(ZCollectedHeap::heap()-&gt;gc_cause()),
<span class="line-modified"> 649                ZUSED_ARGS(ZStatHeap::used_at_mark_start(), ZStatHeap::max_capacity()),</span>
<span class="line-modified"> 650                ZUSED_ARGS(ZStatHeap::used_at_relocate_end(), ZStatHeap::max_capacity()));</span>
 651 }
 652 
 653 Tickspan ZStatPhasePause::_max;
 654 
 655 ZStatPhasePause::ZStatPhasePause(const char* name) :
 656     ZStatPhase(&quot;Phase&quot;, name) {}
 657 
 658 const Tickspan&amp; ZStatPhasePause::max() {
 659   return _max;
 660 }
 661 
 662 void ZStatPhasePause::register_start(const Ticks&amp; start) const {
 663   timer()-&gt;register_gc_pause_start(name(), start);
 664 
 665   LogTarget(Debug, gc, phases, start) log;
 666   log_start(log);
 667 }
 668 
 669 void ZStatPhasePause::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 670   timer()-&gt;register_gc_pause_end(end);
</pre>
<hr />
<pre>
 696 
 697 void ZStatPhaseConcurrent::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 698   timer()-&gt;register_gc_concurrent_end(end);
 699 
 700   const Tickspan duration = end - start;
 701   ZStatSample(_sampler, duration.value());
 702 
 703   LogTarget(Info, gc, phases) log;
 704   log_end(log, duration);
 705 }
 706 
 707 ZStatSubPhase::ZStatSubPhase(const char* name) :
 708     ZStatPhase(&quot;Subphase&quot;, name) {}
 709 
 710 void ZStatSubPhase::register_start(const Ticks&amp; start) const {
 711   LogTarget(Debug, gc, phases, start) log;
 712   log_start(log, true /* thread */);
 713 }
 714 
 715 void ZStatSubPhase::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
<span class="line-modified"> 716   ZTracer::tracer()-&gt;report_thread_phase(*this, start, end);</span>
 717 
 718   const Tickspan duration = end - start;
 719   ZStatSample(_sampler, duration.value());
 720 
 721   LogTarget(Debug, gc, phases) log;
 722   log_end(log, duration, true /* thread */);
 723 }
 724 
 725 ZStatCriticalPhase::ZStatCriticalPhase(const char* name, bool verbose) :
 726     ZStatPhase(&quot;Critical&quot;, name),
 727     _counter(&quot;Critical&quot;, name, ZStatUnitOpsPerSecond),
 728     _verbose(verbose) {}
 729 
 730 void ZStatCriticalPhase::register_start(const Ticks&amp; start) const {
 731   LogTarget(Debug, gc, start) log;
 732   log_start(log, true /* thread */);
 733 }
 734 
 735 void ZStatCriticalPhase::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
<span class="line-modified"> 736   ZTracer::tracer()-&gt;report_thread_phase(*this, start, end);</span>
 737 
 738   const Tickspan duration = end - start;
 739   ZStatSample(_sampler, duration.value());
 740   ZStatInc(_counter);
 741 
 742   if (_verbose) {
 743     LogTarget(Info, gc) log;
 744     log_end(log, duration, true /* thread */);
 745   } else {
 746     LogTarget(Debug, gc) log;
 747     log_end(log, duration, true /* thread */);
 748   }
 749 }
 750 





 751 //
 752 // Stat sample/inc
 753 //
<span class="line-modified"> 754 void ZStatSample(const ZStatSampler&amp; sampler, uint64_t value, bool trace) {</span>
 755   ZStatSamplerData* const cpu_data = sampler.get();
<span class="line-modified"> 756   Atomic::add(1u, &amp;cpu_data-&gt;_nsamples);</span>
<span class="line-modified"> 757   Atomic::add(value, &amp;cpu_data-&gt;_sum);</span>
 758 
 759   uint64_t max = cpu_data-&gt;_max;
 760   for (;;) {
 761     if (max &gt;= value) {
 762       // Not max
 763       break;
 764     }
 765 
 766     const uint64_t new_max = value;
<span class="line-modified"> 767     const uint64_t prev_max = Atomic::cmpxchg(new_max, &amp;cpu_data-&gt;_max, max);</span>
 768     if (prev_max == max) {
 769       // Success
 770       break;
 771     }
 772 
 773     // Retry
 774     max = prev_max;
 775   }
 776 
<span class="line-modified"> 777   if (trace) {</span>
<span class="line-removed"> 778     ZTracer::tracer()-&gt;report_stat_sampler(sampler, value);</span>
<span class="line-removed"> 779   }</span>
 780 }
 781 
<span class="line-modified"> 782 void ZStatInc(const ZStatCounter&amp; counter, uint64_t increment, bool trace) {</span>
 783   ZStatCounterData* const cpu_data = counter.get();
<span class="line-modified"> 784   const uint64_t value = Atomic::add(increment, &amp;cpu_data-&gt;_counter);</span>
 785 
<span class="line-modified"> 786   if (trace) {</span>
<span class="line-removed"> 787     ZTracer::tracer()-&gt;report_stat_counter(counter, increment, value);</span>
<span class="line-removed"> 788   }</span>
 789 }
 790 
 791 void ZStatInc(const ZStatUnsampledCounter&amp; counter, uint64_t increment) {
 792   ZStatCounterData* const cpu_data = counter.get();
<span class="line-modified"> 793   Atomic::add(increment, &amp;cpu_data-&gt;_counter);</span>
 794 }
 795 
 796 //
 797 // Stat allocation rate
 798 //
 799 const ZStatUnsampledCounter ZStatAllocRate::_counter(&quot;Allocation Rate&quot;);
 800 TruncatedSeq                ZStatAllocRate::_rate(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);
 801 TruncatedSeq                ZStatAllocRate::_rate_avg(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);
 802 
 803 const ZStatUnsampledCounter&amp; ZStatAllocRate::counter() {
 804   return _counter;
 805 }
 806 
 807 uint64_t ZStatAllocRate::sample_and_reset() {
 808   const ZStatCounterData bytes_per_sample = _counter.collect_and_reset();
 809   const uint64_t bytes_per_second = bytes_per_sample._counter * sample_hz;
 810 
 811   _rate.add(bytes_per_second);
 812   _rate_avg.add(_rate.avg());
 813 
</pre>
<hr />
<pre>
 828 ZStat::ZStat() :
 829     _metronome(sample_hz) {
 830   set_name(&quot;ZStat&quot;);
 831   create_and_start();
 832 }
 833 
 834 void ZStat::sample_and_collect(ZStatSamplerHistory* history) const {
 835   // Sample counters
 836   for (const ZStatCounter* counter = ZStatCounter::first(); counter != NULL; counter = counter-&gt;next()) {
 837     counter-&gt;sample_and_reset();
 838   }
 839 
 840   // Collect samples
 841   for (const ZStatSampler* sampler = ZStatSampler::first(); sampler != NULL; sampler = sampler-&gt;next()) {
 842     ZStatSamplerHistory&amp; sampler_history = history[sampler-&gt;id()];
 843     sampler_history.add(sampler-&gt;collect_and_reset());
 844   }
 845 }
 846 
 847 bool ZStat::should_print(LogTargetHandle log) const {
<span class="line-modified"> 848   return log.is_enabled() &amp;&amp; (_metronome.nticks() % ZStatisticsInterval == 0);</span>









 849 }
 850 
 851 void ZStat::print(LogTargetHandle log, const ZStatSamplerHistory* history) const {
 852   // Print
 853   log.print(&quot;=== Garbage Collection Statistics =======================================================================================================================&quot;);
 854   log.print(&quot;                                                             Last 10s              Last 10m              Last 10h                Total&quot;);
 855   log.print(&quot;                                                             Avg / Max             Avg / Max             Avg / Max             Avg / Max&quot;);
 856 
 857   for (const ZStatSampler* sampler = ZStatSampler::first(); sampler != NULL; sampler = sampler-&gt;next()) {
 858     const ZStatSamplerHistory&amp; sampler_history = history[sampler-&gt;id()];
 859     const ZStatUnitPrinter printer = sampler-&gt;printer();
 860     printer(log, *sampler, sampler_history);
 861   }
 862 
 863   log.print(&quot;=========================================================================================================================================================&quot;);
 864 }
 865 
 866 void ZStat::run_service() {
 867   ZStatSamplerHistory* const history = new ZStatSamplerHistory[ZStatSampler::count()];
 868   LogTarget(Info, gc, stats) log;
</pre>
<hr />
<pre>
 994 
 995     const char* end() {
 996       _buffer[_position] = &#39;\0&#39;;
 997       return _buffer;
 998     }
 999   };
1000 
1001 public:
1002   ZStatTablePrinter(size_t column0_width, size_t columnN_width) :
1003       _column0_width(column0_width),
1004       _columnN_width(columnN_width) {}
1005 
1006   ZColumn operator()() {
1007     return ZColumn(_buffer, 0, _column0_width, _columnN_width);
1008   }
1009 };
1010 
1011 //
1012 // Stat cycle
1013 //
<span class="line-modified">1014 uint64_t  ZStatCycle::_ncycles = 0;</span>
1015 Ticks     ZStatCycle::_start_of_last;
1016 Ticks     ZStatCycle::_end_of_last;
1017 NumberSeq ZStatCycle::_normalized_duration(0.3 /* alpha */);
1018 
1019 void ZStatCycle::at_start() {
1020   _start_of_last = Ticks::now();
1021 }
1022 
<span class="line-modified">1023 void ZStatCycle::at_end(double boost_factor) {</span>
1024   _end_of_last = Ticks::now();
<span class="line-modified">1025   _ncycles++;</span>



1026 
1027   // Calculate normalized cycle duration. The measured duration is
1028   // normalized using the boost factor to avoid artificial deflation
1029   // of the duration when boost mode is enabled.
1030   const double duration = (_end_of_last - _start_of_last).seconds();
1031   const double normalized_duration = duration * boost_factor;
1032   _normalized_duration.add(normalized_duration);
1033 }
1034 
<span class="line-modified">1035 uint64_t ZStatCycle::ncycles() {</span>
<span class="line-modified">1036   return _ncycles;</span>










1037 }
1038 
1039 const AbsSeq&amp; ZStatCycle::normalized_duration() {
1040   return _normalized_duration;
1041 }
1042 
1043 double ZStatCycle::time_since_last() {
<span class="line-modified">1044   if (_ncycles == 0) {</span>
<span class="line-modified">1045     // Return time since VM start-up</span>
1046     return os::elapsedTime();
1047   }
1048 
1049   const Ticks now = Ticks::now();
1050   const Tickspan time_since_last = now - _end_of_last;
1051   return time_since_last.seconds();
1052 }
1053 
1054 //
1055 // Stat load
1056 //
1057 void ZStatLoad::print() {
1058   double loadavg[3] = {};
1059   os::loadavg(loadavg, ARRAY_SIZE(loadavg));
1060   log_info(gc, load)(&quot;Load: %.2f/%.2f/%.2f&quot;, loadavg[0], loadavg[1], loadavg[2]);
1061 }
1062 
1063 //
1064 // Stat mark
1065 //
</pre>
<hr />
<pre>
1083   _ncontinue = ncontinue;
1084 }
1085 
1086 void ZStatMark::print() {
1087   log_info(gc, marking)(&quot;Mark: &quot;
1088                         SIZE_FORMAT &quot; stripe(s), &quot;
1089                         SIZE_FORMAT &quot; proactive flush(es), &quot;
1090                         SIZE_FORMAT &quot; terminate flush(es), &quot;
1091                         SIZE_FORMAT &quot; completion(s), &quot;
1092                         SIZE_FORMAT &quot; continuation(s) &quot;,
1093                         _nstripes,
1094                         _nproactiveflush,
1095                         _nterminateflush,
1096                         _ntrycomplete,
1097                         _ncontinue);
1098 }
1099 
1100 //
1101 // Stat relocation
1102 //
<span class="line-modified">1103 size_t ZStatRelocation::_relocating;</span>
<span class="line-modified">1104 bool ZStatRelocation::_success;</span>
1105 
<span class="line-modified">1106 void ZStatRelocation::set_at_select_relocation_set(size_t relocating) {</span>
<span class="line-modified">1107   _relocating = relocating;</span>
1108 }
1109 
1110 void ZStatRelocation::set_at_relocate_end(bool success) {
1111   _success = success;
1112 }
1113 












1114 void ZStatRelocation::print() {
<span class="line-modified">1115   if (_success) {</span>
<span class="line-modified">1116     log_info(gc, reloc)(&quot;Relocation: Successful, &quot; SIZE_FORMAT &quot;M relocated&quot;, _relocating / M);</span>
<span class="line-modified">1117   } else {</span>
<span class="line-modified">1118     log_info(gc, reloc)(&quot;Relocation: Incomplete&quot;);</span>
<span class="line-modified">1119   }</span>
1120 }
1121 
1122 //
1123 // Stat nmethods
1124 //
1125 void ZStatNMethods::print() {
1126   log_info(gc, nmethod)(&quot;NMethods: &quot; SIZE_FORMAT &quot; registered, &quot; SIZE_FORMAT &quot; unregistered&quot;,
1127                         ZNMethodTable::registered_nmethods(),
1128                         ZNMethodTable::unregistered_nmethods());
1129 }
1130 
1131 //
1132 // Stat metaspace
1133 //
1134 void ZStatMetaspace::print() {
1135   log_info(gc, metaspace)(&quot;Metaspace: &quot;
1136                           SIZE_FORMAT &quot;M used, &quot; SIZE_FORMAT &quot;M capacity, &quot;
1137                           SIZE_FORMAT &quot;M committed, &quot; SIZE_FORMAT &quot;M reserved&quot;,
1138                           MetaspaceUtils::used_bytes() / M,
1139                           MetaspaceUtils::capacity_bytes() / M,
</pre>
<hr />
<pre>
1181                     ref.discovered,
1182                     ref.enqueued);
1183 }
1184 
1185 void ZStatReferences::print() {
1186   print(&quot;Soft&quot;, _soft);
1187   print(&quot;Weak&quot;, _weak);
1188   print(&quot;Final&quot;, _final);
1189   print(&quot;Phantom&quot;, _phantom);
1190 }
1191 
1192 //
1193 // Stat heap
1194 //
1195 ZStatHeap::ZAtInitialize ZStatHeap::_at_initialize;
1196 ZStatHeap::ZAtMarkStart ZStatHeap::_at_mark_start;
1197 ZStatHeap::ZAtMarkEnd ZStatHeap::_at_mark_end;
1198 ZStatHeap::ZAtRelocateStart ZStatHeap::_at_relocate_start;
1199 ZStatHeap::ZAtRelocateEnd ZStatHeap::_at_relocate_end;
1200 
<span class="line-modified">1201 #define ZSIZE_NA               &quot;%9s&quot;, &quot;-&quot;</span>
<span class="line-modified">1202 #define ZSIZE_ARGS(size)       SIZE_FORMAT_W(8) &quot;M (%.0lf%%)&quot;, \</span>
<span class="line-modified">1203                                ((size) / M), (percent_of(size, _at_initialize.max_capacity))</span>










1204 
1205 size_t ZStatHeap::available(size_t used) {
1206   return _at_initialize.max_capacity - used;
1207 }
1208 
1209 size_t ZStatHeap::reserve(size_t used) {
1210   return MIN2(_at_initialize.max_reserve, available(used));
1211 }
1212 
1213 size_t ZStatHeap::free(size_t used) {
1214   return available(used) - reserve(used);
1215 }
1216 
<span class="line-modified">1217 void ZStatHeap::set_at_initialize(size_t max_capacity,</span>

1218                                   size_t max_reserve) {

1219   _at_initialize.max_capacity = max_capacity;
1220   _at_initialize.max_reserve = max_reserve;
1221 }
1222 
<span class="line-modified">1223 void ZStatHeap::set_at_mark_start(size_t capacity,</span>

1224                                   size_t used) {

1225   _at_mark_start.capacity = capacity;
1226   _at_mark_start.reserve = reserve(used);
1227   _at_mark_start.used = used;
1228   _at_mark_start.free = free(used);
1229 }
1230 
1231 void ZStatHeap::set_at_mark_end(size_t capacity,
1232                                 size_t allocated,
1233                                 size_t used) {
1234   _at_mark_end.capacity = capacity;
1235   _at_mark_end.reserve = reserve(used);
1236   _at_mark_end.allocated = allocated;
1237   _at_mark_end.used = used;
1238   _at_mark_end.free = free(used);
1239 }
1240 
<span class="line-modified">1241 void ZStatHeap::set_at_select_relocation_set(size_t live,</span>
<span class="line-modified">1242                                              size_t garbage,</span>
<span class="line-modified">1243                                              size_t reclaimed) {</span>

1244   _at_mark_end.live = live;
1245   _at_mark_end.garbage = garbage;
1246 
1247   _at_relocate_start.garbage = garbage - reclaimed;
1248   _at_relocate_start.reclaimed = reclaimed;
1249 }
1250 
1251 void ZStatHeap::set_at_relocate_start(size_t capacity,
1252                                       size_t allocated,
1253                                       size_t used) {
1254   _at_relocate_start.capacity = capacity;
1255   _at_relocate_start.reserve = reserve(used);
1256   _at_relocate_start.allocated = allocated;
1257   _at_relocate_start.used = used;
1258   _at_relocate_start.free = free(used);
1259 }
1260 
1261 void ZStatHeap::set_at_relocate_end(size_t capacity,
1262                                     size_t allocated,
1263                                     size_t reclaimed,
1264                                     size_t used,
1265                                     size_t used_high,
1266                                     size_t used_low) {
1267   _at_relocate_end.capacity = capacity;
<span class="line-modified">1268   _at_relocate_end.capacity_high = capacity;</span>
<span class="line-modified">1269   _at_relocate_end.capacity_low = _at_mark_start.capacity;</span>
1270   _at_relocate_end.reserve = reserve(used);
1271   _at_relocate_end.reserve_high = reserve(used_low);
1272   _at_relocate_end.reserve_low = reserve(used_high);
1273   _at_relocate_end.garbage = _at_mark_end.garbage - reclaimed;
1274   _at_relocate_end.allocated = allocated;
1275   _at_relocate_end.reclaimed = reclaimed;
1276   _at_relocate_end.used = used;
1277   _at_relocate_end.used_high = used_high;
1278   _at_relocate_end.used_low = used_low;
1279   _at_relocate_end.free = free(used);
1280   _at_relocate_end.free_high = free(used_low);
1281   _at_relocate_end.free_low = free(used_high);
1282 }
1283 
1284 size_t ZStatHeap::max_capacity() {
1285   return _at_initialize.max_capacity;
1286 }
1287 
1288 size_t ZStatHeap::used_at_mark_start() {
1289   return _at_mark_start.used;
1290 }
1291 
1292 size_t ZStatHeap::used_at_relocate_end() {
1293   return _at_relocate_end.used;
1294 }
1295 
1296 void ZStatHeap::print() {







1297   ZStatTablePrinter table(10, 18);
1298   log_info(gc, heap)(&quot;%s&quot;, table()
1299                      .fill()
1300                      .center(&quot;Mark Start&quot;)
1301                      .center(&quot;Mark End&quot;)
1302                      .center(&quot;Relocate Start&quot;)
1303                      .center(&quot;Relocate End&quot;)
1304                      .center(&quot;High&quot;)
1305                      .center(&quot;Low&quot;)
1306                      .end());
1307   log_info(gc, heap)(&quot;%s&quot;, table()
1308                      .right(&quot;Capacity:&quot;)
<span class="line-modified">1309                      .left(ZSIZE_ARGS(_at_mark_start.capacity))</span>
<span class="line-modified">1310                      .left(ZSIZE_ARGS(_at_mark_end.capacity))</span>
<span class="line-modified">1311                      .left(ZSIZE_ARGS(_at_relocate_start.capacity))</span>
<span class="line-modified">1312                      .left(ZSIZE_ARGS(_at_relocate_end.capacity))</span>
<span class="line-modified">1313                      .left(ZSIZE_ARGS(_at_relocate_end.capacity_high))</span>
<span class="line-modified">1314                      .left(ZSIZE_ARGS(_at_relocate_end.capacity_low))</span>
1315                      .end());
1316   log_info(gc, heap)(&quot;%s&quot;, table()
1317                      .right(&quot;Reserve:&quot;)
<span class="line-modified">1318                      .left(ZSIZE_ARGS(_at_mark_start.reserve))</span>
<span class="line-modified">1319                      .left(ZSIZE_ARGS(_at_mark_end.reserve))</span>
<span class="line-modified">1320                      .left(ZSIZE_ARGS(_at_relocate_start.reserve))</span>
<span class="line-modified">1321                      .left(ZSIZE_ARGS(_at_relocate_end.reserve))</span>
<span class="line-modified">1322                      .left(ZSIZE_ARGS(_at_relocate_end.reserve_high))</span>
<span class="line-modified">1323                      .left(ZSIZE_ARGS(_at_relocate_end.reserve_low))</span>
1324                      .end());
1325   log_info(gc, heap)(&quot;%s&quot;, table()
1326                      .right(&quot;Free:&quot;)
<span class="line-modified">1327                      .left(ZSIZE_ARGS(_at_mark_start.free))</span>
<span class="line-modified">1328                      .left(ZSIZE_ARGS(_at_mark_end.free))</span>
<span class="line-modified">1329                      .left(ZSIZE_ARGS(_at_relocate_start.free))</span>
<span class="line-modified">1330                      .left(ZSIZE_ARGS(_at_relocate_end.free))</span>
<span class="line-modified">1331                      .left(ZSIZE_ARGS(_at_relocate_end.free_high))</span>
<span class="line-modified">1332                      .left(ZSIZE_ARGS(_at_relocate_end.free_low))</span>
1333                      .end());
1334   log_info(gc, heap)(&quot;%s&quot;, table()
1335                      .right(&quot;Used:&quot;)
<span class="line-modified">1336                      .left(ZSIZE_ARGS(_at_mark_start.used))</span>
<span class="line-modified">1337                      .left(ZSIZE_ARGS(_at_mark_end.used))</span>
<span class="line-modified">1338                      .left(ZSIZE_ARGS(_at_relocate_start.used))</span>
<span class="line-modified">1339                      .left(ZSIZE_ARGS(_at_relocate_end.used))</span>
<span class="line-modified">1340                      .left(ZSIZE_ARGS(_at_relocate_end.used_high))</span>
<span class="line-modified">1341                      .left(ZSIZE_ARGS(_at_relocate_end.used_low))</span>
1342                      .end());
1343   log_info(gc, heap)(&quot;%s&quot;, table()
1344                      .right(&quot;Live:&quot;)
<span class="line-modified">1345                      .left(ZSIZE_NA)</span>
<span class="line-modified">1346                      .left(ZSIZE_ARGS(_at_mark_end.live))</span>
<span class="line-modified">1347                      .left(ZSIZE_ARGS(_at_mark_end.live /* Same as at mark end */))</span>
<span class="line-modified">1348                      .left(ZSIZE_ARGS(_at_mark_end.live /* Same as at mark end */))</span>
<span class="line-modified">1349                      .left(ZSIZE_NA)</span>
<span class="line-modified">1350                      .left(ZSIZE_NA)</span>
1351                      .end());
1352   log_info(gc, heap)(&quot;%s&quot;, table()
1353                      .right(&quot;Allocated:&quot;)
<span class="line-modified">1354                      .left(ZSIZE_NA)</span>
<span class="line-modified">1355                      .left(ZSIZE_ARGS(_at_mark_end.allocated))</span>
<span class="line-modified">1356                      .left(ZSIZE_ARGS(_at_relocate_start.allocated))</span>
<span class="line-modified">1357                      .left(ZSIZE_ARGS(_at_relocate_end.allocated))</span>
<span class="line-modified">1358                      .left(ZSIZE_NA)</span>
<span class="line-modified">1359                      .left(ZSIZE_NA)</span>
1360                      .end());
1361   log_info(gc, heap)(&quot;%s&quot;, table()
1362                      .right(&quot;Garbage:&quot;)
<span class="line-modified">1363                      .left(ZSIZE_NA)</span>
<span class="line-modified">1364                      .left(ZSIZE_ARGS(_at_mark_end.garbage))</span>
<span class="line-modified">1365                      .left(ZSIZE_ARGS(_at_relocate_start.garbage))</span>
<span class="line-modified">1366                      .left(ZSIZE_ARGS(_at_relocate_end.garbage))</span>
<span class="line-modified">1367                      .left(ZSIZE_NA)</span>
<span class="line-modified">1368                      .left(ZSIZE_NA)</span>
1369                      .end());
1370   log_info(gc, heap)(&quot;%s&quot;, table()
1371                      .right(&quot;Reclaimed:&quot;)
<span class="line-modified">1372                      .left(ZSIZE_NA)</span>
<span class="line-modified">1373                      .left(ZSIZE_NA)</span>
<span class="line-modified">1374                      .left(ZSIZE_ARGS(_at_relocate_start.reclaimed))</span>
<span class="line-modified">1375                      .left(ZSIZE_ARGS(_at_relocate_end.reclaimed))</span>
<span class="line-modified">1376                      .left(ZSIZE_NA)</span>
<span class="line-modified">1377                      .left(ZSIZE_NA)</span>
1378                      .end());
1379 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;gc/z/zCollectedHeap.hpp&quot;
<span class="line-modified">  26 #include &quot;gc/z/zCPU.inline.hpp&quot;</span>
  27 #include &quot;gc/z/zGlobals.hpp&quot;
  28 #include &quot;gc/z/zHeap.inline.hpp&quot;
  29 #include &quot;gc/z/zLargePages.inline.hpp&quot;
  30 #include &quot;gc/z/zNMethodTable.hpp&quot;
  31 #include &quot;gc/z/zNUMA.hpp&quot;
<span class="line-added">  32 #include &quot;gc/z/zRelocationSetSelector.inline.hpp&quot;</span>
  33 #include &quot;gc/z/zStat.hpp&quot;
  34 #include &quot;gc/z/zTracer.inline.hpp&quot;
  35 #include &quot;gc/z/zUtils.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/os.hpp&quot;
  39 #include &quot;runtime/timer.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;utilities/compilerWarnings.hpp&quot;
  42 #include &quot;utilities/debug.hpp&quot;
  43 #include &quot;utilities/ticks.hpp&quot;
  44 
<span class="line-added">  45 #define ZSIZE_FMT                       SIZE_FORMAT &quot;M(%.0f%%)&quot;</span>
<span class="line-added">  46 #define ZSIZE_ARGS_WITH_MAX(size, max)  ((size) / M), (percent_of(size, max))</span>
<span class="line-added">  47 #define ZSIZE_ARGS(size)                ZSIZE_ARGS_WITH_MAX(size, ZStatHeap::max_capacity())</span>
<span class="line-added">  48 </span>
<span class="line-added">  49 #define ZTABLE_ARGS_NA                  &quot;%9s&quot;, &quot;-&quot;</span>
<span class="line-added">  50 #define ZTABLE_ARGS(size)               SIZE_FORMAT_W(8) &quot;M (%.0f%%)&quot;, \</span>
<span class="line-added">  51                                         ((size) / M), (percent_of(size, ZStatHeap::max_capacity()))</span>
<span class="line-added">  52 </span>
  53 //
  54 // Stat sampler/counter data
  55 //
  56 struct ZStatSamplerData {
  57   uint64_t _nsamples;
  58   uint64_t _sum;
  59   uint64_t _max;
  60 
  61   ZStatSamplerData() :
  62     _nsamples(0),
  63     _sum(0),
  64     _max(0) {}
  65 
  66   void add(const ZStatSamplerData&amp; new_sample) {
  67     _nsamples += new_sample._nsamples;
<span class="line-modified">  68     _sum += new_sample._sum;</span>
  69     _max = MAX2(_max, new_sample._max);
  70   }
  71 };
  72 
  73 struct ZStatCounterData {
  74   uint64_t _counter;
  75 
  76   ZStatCounterData() :
  77     _counter(0) {}
  78 };
  79 
  80 //
  81 // Stat sampler history
  82 //
  83 template &lt;size_t size&gt;
  84 class ZStatSamplerHistoryInterval {
  85 private:
  86   size_t           _next;
  87   ZStatSamplerData _samples[size];
  88   ZStatSamplerData _accumulated;
</pre>
<hr />
<pre>
 222   }
 223 
 224   uint64_t max_10_hours() const {
 225     return MAX3(_10seconds.accumulated()._max,
 226                 _10minutes.accumulated()._max,
 227                 _10hours.total()._max);
 228   }
 229 
 230   uint64_t max_total() const {
 231     return MAX4(_10seconds.accumulated()._max,
 232                 _10minutes.accumulated()._max,
 233                 _10hours.accumulated()._max,
 234                 _total._max);
 235   }
 236 };
 237 
 238 //
 239 // Stat unit printers
 240 //
 241 void ZStatUnitTime(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 242   log.print(&quot; %10s: %-41s &quot;</span>
 243             &quot;%9.3f / %-9.3f &quot;
 244             &quot;%9.3f / %-9.3f &quot;
 245             &quot;%9.3f / %-9.3f &quot;
 246             &quot;%9.3f / %-9.3f   ms&quot;,
 247             sampler.group(),
 248             sampler.name(),
 249             TimeHelper::counter_to_millis(history.avg_10_seconds()),
 250             TimeHelper::counter_to_millis(history.max_10_seconds()),
 251             TimeHelper::counter_to_millis(history.avg_10_minutes()),
 252             TimeHelper::counter_to_millis(history.max_10_minutes()),
 253             TimeHelper::counter_to_millis(history.avg_10_hours()),
 254             TimeHelper::counter_to_millis(history.max_10_hours()),
 255             TimeHelper::counter_to_millis(history.avg_total()),
 256             TimeHelper::counter_to_millis(history.max_total()));
 257 }
 258 
 259 void ZStatUnitBytes(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 260   log.print(&quot; %10s: %-41s &quot;</span>
 261             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 262             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 263             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 264             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   MB&quot;,
 265             sampler.group(),
 266             sampler.name(),
 267             history.avg_10_seconds() / M,
 268             history.max_10_seconds() / M,
 269             history.avg_10_minutes() / M,
 270             history.max_10_minutes() / M,
 271             history.avg_10_hours() / M,
 272             history.max_10_hours() / M,
 273             history.avg_total() / M,
 274             history.max_total() / M);
 275 }
 276 
 277 void ZStatUnitThreads(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 278   log.print(&quot; %10s: %-41s &quot;</span>
 279             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 280             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 281             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 282             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   threads&quot;,
 283             sampler.group(),
 284             sampler.name(),
 285             history.avg_10_seconds(),
 286             history.max_10_seconds(),
 287             history.avg_10_minutes(),
 288             history.max_10_minutes(),
 289             history.avg_10_hours(),
 290             history.max_10_hours(),
 291             history.avg_total(),
 292             history.max_total());
 293 }
 294 
 295 void ZStatUnitBytesPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 296   log.print(&quot; %10s: %-41s &quot;</span>
 297             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 298             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 299             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 300             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   MB/s&quot;,
 301             sampler.group(),
 302             sampler.name(),
 303             history.avg_10_seconds() / M,
 304             history.max_10_seconds() / M,
 305             history.avg_10_minutes() / M,
 306             history.max_10_minutes() / M,
 307             history.avg_10_hours() / M,
 308             history.max_10_hours() / M,
 309             history.avg_total() / M,
 310             history.max_total() / M);
 311 }
 312 
 313 void ZStatUnitOpsPerSecond(LogTargetHandle log, const ZStatSampler&amp; sampler, const ZStatSamplerHistory&amp; history) {
<span class="line-modified"> 314   log.print(&quot; %10s: %-41s &quot;</span>
 315             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 316             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 317             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot; &quot;
 318             UINT64_FORMAT_W(9) &quot; / &quot; UINT64_FORMAT_W(-9) &quot;   ops/s&quot;,
 319             sampler.group(),
 320             sampler.name(),
 321             history.avg_10_seconds(),
 322             history.max_10_seconds(),
 323             history.avg_10_minutes(),
 324             history.max_10_minutes(),
 325             history.avg_10_hours(),
 326             history.max_10_hours(),
 327             history.avg_total(),
 328             history.max_total());
 329 }
 330 
 331 //
 332 // Stat value
 333 //
 334 uintptr_t ZStatValue::_base = 0;
</pre>
<hr />
<pre>
 339                           uint32_t id,
 340                           uint32_t size) :
 341     _group(group),
 342     _name(name),
 343     _id(id),
 344     _offset(_cpu_offset) {
 345   assert(_base == 0, &quot;Already initialized&quot;);
 346   _cpu_offset += size;
 347 }
 348 
 349 template &lt;typename T&gt;
 350 T* ZStatValue::get_cpu_local(uint32_t cpu) const {
 351   assert(_base != 0, &quot;Not initialized&quot;);
 352   const uintptr_t cpu_base = _base + (_cpu_offset * cpu);
 353   const uintptr_t value_addr = cpu_base + _offset;
 354   return (T*)value_addr;
 355 }
 356 
 357 void ZStatValue::initialize() {
 358   // Finalize and align CPU offset
<span class="line-modified"> 359   _cpu_offset = align_up(_cpu_offset, (uint32_t)ZCacheLineSize);</span>
 360 
 361   // Allocation aligned memory
 362   const size_t size = _cpu_offset * ZCPU::count();
 363   _base = ZUtils::alloc_aligned(ZCacheLineSize, size);

 364 }
 365 
 366 const char* ZStatValue::group() const {
 367   return _group;
 368 }
 369 
 370 const char* ZStatValue::name() const {
 371   return _name;
 372 }
 373 
 374 uint32_t ZStatValue::id() const {
 375   return _id;
 376 }
 377 
 378 //
 379 // Stat iterable value
 380 //
 381 template &lt;typename T&gt; uint32_t ZStatIterableValue&lt;T&gt;::_count = 0;
 382 template &lt;typename T&gt; T*       ZStatIterableValue&lt;T&gt;::_first = NULL;
 383 
</pre>
<hr />
<pre>
 409 }
 410 
 411 //
 412 // Stat sampler
 413 //
 414 ZStatSampler::ZStatSampler(const char* group, const char* name, ZStatUnitPrinter printer) :
 415     ZStatIterableValue&lt;ZStatSampler&gt;(group, name, sizeof(ZStatSamplerData)),
 416     _printer(printer) {}
 417 
 418 ZStatSamplerData* ZStatSampler::get() const {
 419   return get_cpu_local&lt;ZStatSamplerData&gt;(ZCPU::id());
 420 }
 421 
 422 ZStatSamplerData ZStatSampler::collect_and_reset() const {
 423   ZStatSamplerData all;
 424 
 425   const uint32_t ncpus = ZCPU::count();
 426   for (uint32_t i = 0; i &lt; ncpus; i++) {
 427     ZStatSamplerData* const cpu_data = get_cpu_local&lt;ZStatSamplerData&gt;(i);
 428     if (cpu_data-&gt;_nsamples &gt; 0) {
<span class="line-modified"> 429       const uint64_t nsamples = Atomic::xchg(&amp;cpu_data-&gt;_nsamples, (uint64_t)0);</span>
<span class="line-modified"> 430       const uint64_t sum = Atomic::xchg(&amp;cpu_data-&gt;_sum, (uint64_t)0);</span>
<span class="line-modified"> 431       const uint64_t max = Atomic::xchg(&amp;cpu_data-&gt;_max, (uint64_t)0);</span>
 432       all._nsamples += nsamples;
 433       all._sum += sum;
 434       if (all._max &lt; max) {
 435         all._max = max;
 436       }
 437     }
 438   }
 439 
 440   return all;
 441 }
 442 
 443 ZStatUnitPrinter ZStatSampler::printer() const {
 444   return _printer;
 445 }
 446 
 447 //
 448 // Stat counter
 449 //
 450 ZStatCounter::ZStatCounter(const char* group, const char* name, ZStatUnitPrinter printer) :
 451     ZStatIterableValue&lt;ZStatCounter&gt;(group, name, sizeof(ZStatCounterData)),
 452     _sampler(group, name, printer) {}
 453 
 454 ZStatCounterData* ZStatCounter::get() const {
 455   return get_cpu_local&lt;ZStatCounterData&gt;(ZCPU::id());
 456 }
 457 
 458 void ZStatCounter::sample_and_reset() const {
 459   uint64_t counter = 0;
 460 
 461   const uint32_t ncpus = ZCPU::count();
 462   for (uint32_t i = 0; i &lt; ncpus; i++) {
 463     ZStatCounterData* const cpu_data = get_cpu_local&lt;ZStatCounterData&gt;(i);
<span class="line-modified"> 464     counter += Atomic::xchg(&amp;cpu_data-&gt;_counter, (uint64_t)0);</span>
 465   }
 466 
 467   ZStatSample(_sampler, counter);
 468 }
 469 
 470 //
 471 // Stat unsampled counter
 472 //
 473 ZStatUnsampledCounter::ZStatUnsampledCounter(const char* name) :
 474     ZStatIterableValue&lt;ZStatUnsampledCounter&gt;(&quot;Unsampled&quot;, name, sizeof(ZStatCounterData)) {}
 475 
 476 ZStatCounterData* ZStatUnsampledCounter::get() const {
 477   return get_cpu_local&lt;ZStatCounterData&gt;(ZCPU::id());
 478 }
 479 
 480 ZStatCounterData ZStatUnsampledCounter::collect_and_reset() const {
 481   ZStatCounterData all;
 482 
 483   const uint32_t ncpus = ZCPU::count();
 484   for (uint32_t i = 0; i &lt; ncpus; i++) {
 485     ZStatCounterData* const cpu_data = get_cpu_local&lt;ZStatCounterData&gt;(i);
<span class="line-modified"> 486     all._counter += Atomic::xchg(&amp;cpu_data-&gt;_counter, (uint64_t)0);</span>
 487   }
 488 
 489   return all;
 490 }
 491 
 492 //
 493 // Stat MMU (Minimum Mutator Utilization)
 494 //
 495 ZStatMMUPause::ZStatMMUPause() :
 496     _start(0.0),
 497     _end(0.0) {}
 498 
 499 ZStatMMUPause::ZStatMMUPause(const Ticks&amp; start, const Ticks&amp; end) :
 500     _start(TimeHelper::counter_to_millis(start.value())),
 501     _end(TimeHelper::counter_to_millis(end.value())) {}
 502 
 503 double ZStatMMUPause::end() const {
 504   return _end;
 505 }
 506 
</pre>
<hr />
<pre>
 612 
 613 const char* ZStatPhase::name() const {
 614   return _sampler.name();
 615 }
 616 
 617 ZStatPhaseCycle::ZStatPhaseCycle(const char* name) :
 618     ZStatPhase(&quot;Collector&quot;, name) {}
 619 
 620 void ZStatPhaseCycle::register_start(const Ticks&amp; start) const {
 621   timer()-&gt;register_gc_start(start);
 622 
 623   ZTracer::tracer()-&gt;report_gc_start(ZCollectedHeap::heap()-&gt;gc_cause(), start);
 624 
 625   ZCollectedHeap::heap()-&gt;print_heap_before_gc();
 626   ZCollectedHeap::heap()-&gt;trace_heap_before_gc(ZTracer::tracer());
 627 
 628   log_info(gc, start)(&quot;Garbage Collection (%s)&quot;,
 629                        GCCause::to_string(ZCollectedHeap::heap()-&gt;gc_cause()));
 630 }
 631 



 632 void ZStatPhaseCycle::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 633   timer()-&gt;register_gc_end(end);
 634 
 635   ZCollectedHeap::heap()-&gt;print_heap_after_gc();
 636   ZCollectedHeap::heap()-&gt;trace_heap_after_gc(ZTracer::tracer());
 637 
 638   ZTracer::tracer()-&gt;report_gc_end(end, timer()-&gt;time_partitions());
 639 
 640   const Tickspan duration = end - start;
 641   ZStatSample(_sampler, duration.value());
 642 
 643   ZStatLoad::print();
 644   ZStatMMU::print();
 645   ZStatMark::print();

 646   ZStatNMethods::print();
 647   ZStatMetaspace::print();
 648   ZStatReferences::print();
<span class="line-added"> 649   ZStatRelocation::print();</span>
 650   ZStatHeap::print();
 651 
<span class="line-modified"> 652   log_info(gc)(&quot;Garbage Collection (%s) &quot; ZSIZE_FMT &quot;-&gt;&quot; ZSIZE_FMT,</span>
 653                GCCause::to_string(ZCollectedHeap::heap()-&gt;gc_cause()),
<span class="line-modified"> 654                ZSIZE_ARGS(ZStatHeap::used_at_mark_start()),</span>
<span class="line-modified"> 655                ZSIZE_ARGS(ZStatHeap::used_at_relocate_end()));</span>
 656 }
 657 
 658 Tickspan ZStatPhasePause::_max;
 659 
 660 ZStatPhasePause::ZStatPhasePause(const char* name) :
 661     ZStatPhase(&quot;Phase&quot;, name) {}
 662 
 663 const Tickspan&amp; ZStatPhasePause::max() {
 664   return _max;
 665 }
 666 
 667 void ZStatPhasePause::register_start(const Ticks&amp; start) const {
 668   timer()-&gt;register_gc_pause_start(name(), start);
 669 
 670   LogTarget(Debug, gc, phases, start) log;
 671   log_start(log);
 672 }
 673 
 674 void ZStatPhasePause::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 675   timer()-&gt;register_gc_pause_end(end);
</pre>
<hr />
<pre>
 701 
 702 void ZStatPhaseConcurrent::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
 703   timer()-&gt;register_gc_concurrent_end(end);
 704 
 705   const Tickspan duration = end - start;
 706   ZStatSample(_sampler, duration.value());
 707 
 708   LogTarget(Info, gc, phases) log;
 709   log_end(log, duration);
 710 }
 711 
 712 ZStatSubPhase::ZStatSubPhase(const char* name) :
 713     ZStatPhase(&quot;Subphase&quot;, name) {}
 714 
 715 void ZStatSubPhase::register_start(const Ticks&amp; start) const {
 716   LogTarget(Debug, gc, phases, start) log;
 717   log_start(log, true /* thread */);
 718 }
 719 
 720 void ZStatSubPhase::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
<span class="line-modified"> 721   ZTracer::tracer()-&gt;report_thread_phase(name(), start, end);</span>
 722 
 723   const Tickspan duration = end - start;
 724   ZStatSample(_sampler, duration.value());
 725 
 726   LogTarget(Debug, gc, phases) log;
 727   log_end(log, duration, true /* thread */);
 728 }
 729 
 730 ZStatCriticalPhase::ZStatCriticalPhase(const char* name, bool verbose) :
 731     ZStatPhase(&quot;Critical&quot;, name),
 732     _counter(&quot;Critical&quot;, name, ZStatUnitOpsPerSecond),
 733     _verbose(verbose) {}
 734 
 735 void ZStatCriticalPhase::register_start(const Ticks&amp; start) const {
 736   LogTarget(Debug, gc, start) log;
 737   log_start(log, true /* thread */);
 738 }
 739 
 740 void ZStatCriticalPhase::register_end(const Ticks&amp; start, const Ticks&amp; end) const {
<span class="line-modified"> 741   ZTracer::tracer()-&gt;report_thread_phase(name(), start, end);</span>
 742 
 743   const Tickspan duration = end - start;
 744   ZStatSample(_sampler, duration.value());
 745   ZStatInc(_counter);
 746 
 747   if (_verbose) {
 748     LogTarget(Info, gc) log;
 749     log_end(log, duration, true /* thread */);
 750   } else {
 751     LogTarget(Debug, gc) log;
 752     log_end(log, duration, true /* thread */);
 753   }
 754 }
 755 
<span class="line-added"> 756 //</span>
<span class="line-added"> 757 // Stat timer</span>
<span class="line-added"> 758 //</span>
<span class="line-added"> 759 THREAD_LOCAL uint32_t ZStatTimerDisable::_active = 0;</span>
<span class="line-added"> 760 </span>
 761 //
 762 // Stat sample/inc
 763 //
<span class="line-modified"> 764 void ZStatSample(const ZStatSampler&amp; sampler, uint64_t value) {</span>
 765   ZStatSamplerData* const cpu_data = sampler.get();
<span class="line-modified"> 766   Atomic::add(&amp;cpu_data-&gt;_nsamples, 1u);</span>
<span class="line-modified"> 767   Atomic::add(&amp;cpu_data-&gt;_sum, value);</span>
 768 
 769   uint64_t max = cpu_data-&gt;_max;
 770   for (;;) {
 771     if (max &gt;= value) {
 772       // Not max
 773       break;
 774     }
 775 
 776     const uint64_t new_max = value;
<span class="line-modified"> 777     const uint64_t prev_max = Atomic::cmpxchg(&amp;cpu_data-&gt;_max, max, new_max);</span>
 778     if (prev_max == max) {
 779       // Success
 780       break;
 781     }
 782 
 783     // Retry
 784     max = prev_max;
 785   }
 786 
<span class="line-modified"> 787   ZTracer::tracer()-&gt;report_stat_sampler(sampler, value);</span>


 788 }
 789 
<span class="line-modified"> 790 void ZStatInc(const ZStatCounter&amp; counter, uint64_t increment) {</span>
 791   ZStatCounterData* const cpu_data = counter.get();
<span class="line-modified"> 792   const uint64_t value = Atomic::add(&amp;cpu_data-&gt;_counter, increment);</span>
 793 
<span class="line-modified"> 794   ZTracer::tracer()-&gt;report_stat_counter(counter, increment, value);</span>


 795 }
 796 
 797 void ZStatInc(const ZStatUnsampledCounter&amp; counter, uint64_t increment) {
 798   ZStatCounterData* const cpu_data = counter.get();
<span class="line-modified"> 799   Atomic::add(&amp;cpu_data-&gt;_counter, increment);</span>
 800 }
 801 
 802 //
 803 // Stat allocation rate
 804 //
 805 const ZStatUnsampledCounter ZStatAllocRate::_counter(&quot;Allocation Rate&quot;);
 806 TruncatedSeq                ZStatAllocRate::_rate(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);
 807 TruncatedSeq                ZStatAllocRate::_rate_avg(ZStatAllocRate::sample_window_sec * ZStatAllocRate::sample_hz);
 808 
 809 const ZStatUnsampledCounter&amp; ZStatAllocRate::counter() {
 810   return _counter;
 811 }
 812 
 813 uint64_t ZStatAllocRate::sample_and_reset() {
 814   const ZStatCounterData bytes_per_sample = _counter.collect_and_reset();
 815   const uint64_t bytes_per_second = bytes_per_sample._counter * sample_hz;
 816 
 817   _rate.add(bytes_per_second);
 818   _rate_avg.add(_rate.avg());
 819 
</pre>
<hr />
<pre>
 834 ZStat::ZStat() :
 835     _metronome(sample_hz) {
 836   set_name(&quot;ZStat&quot;);
 837   create_and_start();
 838 }
 839 
 840 void ZStat::sample_and_collect(ZStatSamplerHistory* history) const {
 841   // Sample counters
 842   for (const ZStatCounter* counter = ZStatCounter::first(); counter != NULL; counter = counter-&gt;next()) {
 843     counter-&gt;sample_and_reset();
 844   }
 845 
 846   // Collect samples
 847   for (const ZStatSampler* sampler = ZStatSampler::first(); sampler != NULL; sampler = sampler-&gt;next()) {
 848     ZStatSamplerHistory&amp; sampler_history = history[sampler-&gt;id()];
 849     sampler_history.add(sampler-&gt;collect_and_reset());
 850   }
 851 }
 852 
 853 bool ZStat::should_print(LogTargetHandle log) const {
<span class="line-modified"> 854   static uint64_t print_at = ZStatisticsInterval;</span>
<span class="line-added"> 855   const uint64_t now = os::elapsedTime();</span>
<span class="line-added"> 856 </span>
<span class="line-added"> 857   if (now &lt; print_at) {</span>
<span class="line-added"> 858     return false;</span>
<span class="line-added"> 859   }</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861   print_at = ((now / ZStatisticsInterval) * ZStatisticsInterval) + ZStatisticsInterval;</span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863   return log.is_enabled();</span>
 864 }
 865 
 866 void ZStat::print(LogTargetHandle log, const ZStatSamplerHistory* history) const {
 867   // Print
 868   log.print(&quot;=== Garbage Collection Statistics =======================================================================================================================&quot;);
 869   log.print(&quot;                                                             Last 10s              Last 10m              Last 10h                Total&quot;);
 870   log.print(&quot;                                                             Avg / Max             Avg / Max             Avg / Max             Avg / Max&quot;);
 871 
 872   for (const ZStatSampler* sampler = ZStatSampler::first(); sampler != NULL; sampler = sampler-&gt;next()) {
 873     const ZStatSamplerHistory&amp; sampler_history = history[sampler-&gt;id()];
 874     const ZStatUnitPrinter printer = sampler-&gt;printer();
 875     printer(log, *sampler, sampler_history);
 876   }
 877 
 878   log.print(&quot;=========================================================================================================================================================&quot;);
 879 }
 880 
 881 void ZStat::run_service() {
 882   ZStatSamplerHistory* const history = new ZStatSamplerHistory[ZStatSampler::count()];
 883   LogTarget(Info, gc, stats) log;
</pre>
<hr />
<pre>
1009 
1010     const char* end() {
1011       _buffer[_position] = &#39;\0&#39;;
1012       return _buffer;
1013     }
1014   };
1015 
1016 public:
1017   ZStatTablePrinter(size_t column0_width, size_t columnN_width) :
1018       _column0_width(column0_width),
1019       _columnN_width(columnN_width) {}
1020 
1021   ZColumn operator()() {
1022     return ZColumn(_buffer, 0, _column0_width, _columnN_width);
1023   }
1024 };
1025 
1026 //
1027 // Stat cycle
1028 //
<span class="line-modified">1029 uint64_t  ZStatCycle::_nwarmup_cycles = 0;</span>
1030 Ticks     ZStatCycle::_start_of_last;
1031 Ticks     ZStatCycle::_end_of_last;
1032 NumberSeq ZStatCycle::_normalized_duration(0.3 /* alpha */);
1033 
1034 void ZStatCycle::at_start() {
1035   _start_of_last = Ticks::now();
1036 }
1037 
<span class="line-modified">1038 void ZStatCycle::at_end(GCCause::Cause cause, double boost_factor) {</span>
1039   _end_of_last = Ticks::now();
<span class="line-modified">1040 </span>
<span class="line-added">1041   if (cause == GCCause::_z_warmup) {</span>
<span class="line-added">1042     _nwarmup_cycles++;</span>
<span class="line-added">1043   }</span>
1044 
1045   // Calculate normalized cycle duration. The measured duration is
1046   // normalized using the boost factor to avoid artificial deflation
1047   // of the duration when boost mode is enabled.
1048   const double duration = (_end_of_last - _start_of_last).seconds();
1049   const double normalized_duration = duration * boost_factor;
1050   _normalized_duration.add(normalized_duration);
1051 }
1052 
<span class="line-modified">1053 bool ZStatCycle::is_warm() {</span>
<span class="line-modified">1054   return _nwarmup_cycles &gt;= 3;</span>
<span class="line-added">1055 }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057 uint64_t ZStatCycle::nwarmup_cycles() {</span>
<span class="line-added">1058   return _nwarmup_cycles;</span>
<span class="line-added">1059 }</span>
<span class="line-added">1060 </span>
<span class="line-added">1061 bool ZStatCycle::is_normalized_duration_trustable() {</span>
<span class="line-added">1062   // The normalized duration is considered trustable if we have</span>
<span class="line-added">1063   // completed at least one warmup cycle</span>
<span class="line-added">1064   return _nwarmup_cycles &gt; 0;</span>
1065 }
1066 
1067 const AbsSeq&amp; ZStatCycle::normalized_duration() {
1068   return _normalized_duration;
1069 }
1070 
1071 double ZStatCycle::time_since_last() {
<span class="line-modified">1072   if (_end_of_last.value() == 0) {</span>
<span class="line-modified">1073     // No end recorded yet, return time since VM start</span>
1074     return os::elapsedTime();
1075   }
1076 
1077   const Ticks now = Ticks::now();
1078   const Tickspan time_since_last = now - _end_of_last;
1079   return time_since_last.seconds();
1080 }
1081 
1082 //
1083 // Stat load
1084 //
1085 void ZStatLoad::print() {
1086   double loadavg[3] = {};
1087   os::loadavg(loadavg, ARRAY_SIZE(loadavg));
1088   log_info(gc, load)(&quot;Load: %.2f/%.2f/%.2f&quot;, loadavg[0], loadavg[1], loadavg[2]);
1089 }
1090 
1091 //
1092 // Stat mark
1093 //
</pre>
<hr />
<pre>
1111   _ncontinue = ncontinue;
1112 }
1113 
1114 void ZStatMark::print() {
1115   log_info(gc, marking)(&quot;Mark: &quot;
1116                         SIZE_FORMAT &quot; stripe(s), &quot;
1117                         SIZE_FORMAT &quot; proactive flush(es), &quot;
1118                         SIZE_FORMAT &quot; terminate flush(es), &quot;
1119                         SIZE_FORMAT &quot; completion(s), &quot;
1120                         SIZE_FORMAT &quot; continuation(s) &quot;,
1121                         _nstripes,
1122                         _nproactiveflush,
1123                         _nterminateflush,
1124                         _ntrycomplete,
1125                         _ncontinue);
1126 }
1127 
1128 //
1129 // Stat relocation
1130 //
<span class="line-modified">1131 ZRelocationSetSelectorStats ZStatRelocation::_stats;</span>
<span class="line-modified">1132 bool                        ZStatRelocation::_success;</span>
1133 
<span class="line-modified">1134 void ZStatRelocation::set_at_select_relocation_set(const ZRelocationSetSelectorStats&amp; stats) {</span>
<span class="line-modified">1135   _stats = stats;</span>
1136 }
1137 
1138 void ZStatRelocation::set_at_relocate_end(bool success) {
1139   _success = success;
1140 }
1141 
<span class="line-added">1142 void ZStatRelocation::print(const char* name, const ZRelocationSetSelectorGroupStats&amp; group) {</span>
<span class="line-added">1143   const size_t total = _stats.small().total() + _stats.medium().total() + _stats.large().total();</span>
<span class="line-added">1144 </span>
<span class="line-added">1145   log_info(gc, reloc)(&quot;%s Pages: &quot; SIZE_FORMAT &quot; / &quot; ZSIZE_FMT &quot;, Empty: &quot; ZSIZE_FMT &quot;, Compacting: &quot; ZSIZE_FMT &quot;-&gt;&quot; ZSIZE_FMT,</span>
<span class="line-added">1146                       name,</span>
<span class="line-added">1147                       group.npages(),</span>
<span class="line-added">1148                       ZSIZE_ARGS_WITH_MAX(group.total(), total),</span>
<span class="line-added">1149                       ZSIZE_ARGS_WITH_MAX(group.empty(), total),</span>
<span class="line-added">1150                       ZSIZE_ARGS_WITH_MAX(group.compacting_from(), total),</span>
<span class="line-added">1151                       ZSIZE_ARGS_WITH_MAX(group.compacting_to(), total));</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
1154 void ZStatRelocation::print() {
<span class="line-modified">1155   print(&quot;Small&quot;, _stats.small());</span>
<span class="line-modified">1156   print(&quot;Medium&quot;, _stats.medium());</span>
<span class="line-modified">1157   print(&quot;Large&quot;, _stats.large());</span>
<span class="line-modified">1158 </span>
<span class="line-modified">1159   log_info(gc, reloc)(&quot;Relocation: %s&quot;, _success ? &quot;Successful&quot; : &quot;Incomplete&quot;);</span>
1160 }
1161 
1162 //
1163 // Stat nmethods
1164 //
1165 void ZStatNMethods::print() {
1166   log_info(gc, nmethod)(&quot;NMethods: &quot; SIZE_FORMAT &quot; registered, &quot; SIZE_FORMAT &quot; unregistered&quot;,
1167                         ZNMethodTable::registered_nmethods(),
1168                         ZNMethodTable::unregistered_nmethods());
1169 }
1170 
1171 //
1172 // Stat metaspace
1173 //
1174 void ZStatMetaspace::print() {
1175   log_info(gc, metaspace)(&quot;Metaspace: &quot;
1176                           SIZE_FORMAT &quot;M used, &quot; SIZE_FORMAT &quot;M capacity, &quot;
1177                           SIZE_FORMAT &quot;M committed, &quot; SIZE_FORMAT &quot;M reserved&quot;,
1178                           MetaspaceUtils::used_bytes() / M,
1179                           MetaspaceUtils::capacity_bytes() / M,
</pre>
<hr />
<pre>
1221                     ref.discovered,
1222                     ref.enqueued);
1223 }
1224 
1225 void ZStatReferences::print() {
1226   print(&quot;Soft&quot;, _soft);
1227   print(&quot;Weak&quot;, _weak);
1228   print(&quot;Final&quot;, _final);
1229   print(&quot;Phantom&quot;, _phantom);
1230 }
1231 
1232 //
1233 // Stat heap
1234 //
1235 ZStatHeap::ZAtInitialize ZStatHeap::_at_initialize;
1236 ZStatHeap::ZAtMarkStart ZStatHeap::_at_mark_start;
1237 ZStatHeap::ZAtMarkEnd ZStatHeap::_at_mark_end;
1238 ZStatHeap::ZAtRelocateStart ZStatHeap::_at_relocate_start;
1239 ZStatHeap::ZAtRelocateEnd ZStatHeap::_at_relocate_end;
1240 
<span class="line-modified">1241 size_t ZStatHeap::capacity_high() {</span>
<span class="line-modified">1242   return MAX4(_at_mark_start.capacity,</span>
<span class="line-modified">1243               _at_mark_end.capacity,</span>
<span class="line-added">1244               _at_relocate_start.capacity,</span>
<span class="line-added">1245               _at_relocate_end.capacity);</span>
<span class="line-added">1246 }</span>
<span class="line-added">1247 </span>
<span class="line-added">1248 size_t ZStatHeap::capacity_low() {</span>
<span class="line-added">1249   return MIN4(_at_mark_start.capacity,</span>
<span class="line-added">1250               _at_mark_end.capacity,</span>
<span class="line-added">1251               _at_relocate_start.capacity,</span>
<span class="line-added">1252               _at_relocate_end.capacity);</span>
<span class="line-added">1253 }</span>
1254 
1255 size_t ZStatHeap::available(size_t used) {
1256   return _at_initialize.max_capacity - used;
1257 }
1258 
1259 size_t ZStatHeap::reserve(size_t used) {
1260   return MIN2(_at_initialize.max_reserve, available(used));
1261 }
1262 
1263 size_t ZStatHeap::free(size_t used) {
1264   return available(used) - reserve(used);
1265 }
1266 
<span class="line-modified">1267 void ZStatHeap::set_at_initialize(size_t min_capacity,</span>
<span class="line-added">1268                                   size_t max_capacity,</span>
1269                                   size_t max_reserve) {
<span class="line-added">1270   _at_initialize.min_capacity = min_capacity;</span>
1271   _at_initialize.max_capacity = max_capacity;
1272   _at_initialize.max_reserve = max_reserve;
1273 }
1274 
<span class="line-modified">1275 void ZStatHeap::set_at_mark_start(size_t soft_max_capacity,</span>
<span class="line-added">1276                                   size_t capacity,</span>
1277                                   size_t used) {
<span class="line-added">1278   _at_mark_start.soft_max_capacity = soft_max_capacity;</span>
1279   _at_mark_start.capacity = capacity;
1280   _at_mark_start.reserve = reserve(used);
1281   _at_mark_start.used = used;
1282   _at_mark_start.free = free(used);
1283 }
1284 
1285 void ZStatHeap::set_at_mark_end(size_t capacity,
1286                                 size_t allocated,
1287                                 size_t used) {
1288   _at_mark_end.capacity = capacity;
1289   _at_mark_end.reserve = reserve(used);
1290   _at_mark_end.allocated = allocated;
1291   _at_mark_end.used = used;
1292   _at_mark_end.free = free(used);
1293 }
1294 
<span class="line-modified">1295 void ZStatHeap::set_at_select_relocation_set(const ZRelocationSetSelectorStats&amp; stats, size_t reclaimed) {</span>
<span class="line-modified">1296   const size_t live = stats.small().live() + stats.medium().live() + stats.large().live();</span>
<span class="line-modified">1297   const size_t garbage = stats.small().garbage() + stats.medium().garbage() + stats.large().garbage();</span>
<span class="line-added">1298 </span>
1299   _at_mark_end.live = live;
1300   _at_mark_end.garbage = garbage;
1301 
1302   _at_relocate_start.garbage = garbage - reclaimed;
1303   _at_relocate_start.reclaimed = reclaimed;
1304 }
1305 
1306 void ZStatHeap::set_at_relocate_start(size_t capacity,
1307                                       size_t allocated,
1308                                       size_t used) {
1309   _at_relocate_start.capacity = capacity;
1310   _at_relocate_start.reserve = reserve(used);
1311   _at_relocate_start.allocated = allocated;
1312   _at_relocate_start.used = used;
1313   _at_relocate_start.free = free(used);
1314 }
1315 
1316 void ZStatHeap::set_at_relocate_end(size_t capacity,
1317                                     size_t allocated,
1318                                     size_t reclaimed,
1319                                     size_t used,
1320                                     size_t used_high,
1321                                     size_t used_low) {
1322   _at_relocate_end.capacity = capacity;
<span class="line-modified">1323   _at_relocate_end.capacity_high = capacity_high();</span>
<span class="line-modified">1324   _at_relocate_end.capacity_low = capacity_low();</span>
1325   _at_relocate_end.reserve = reserve(used);
1326   _at_relocate_end.reserve_high = reserve(used_low);
1327   _at_relocate_end.reserve_low = reserve(used_high);
1328   _at_relocate_end.garbage = _at_mark_end.garbage - reclaimed;
1329   _at_relocate_end.allocated = allocated;
1330   _at_relocate_end.reclaimed = reclaimed;
1331   _at_relocate_end.used = used;
1332   _at_relocate_end.used_high = used_high;
1333   _at_relocate_end.used_low = used_low;
1334   _at_relocate_end.free = free(used);
1335   _at_relocate_end.free_high = free(used_low);
1336   _at_relocate_end.free_low = free(used_high);
1337 }
1338 
1339 size_t ZStatHeap::max_capacity() {
1340   return _at_initialize.max_capacity;
1341 }
1342 
1343 size_t ZStatHeap::used_at_mark_start() {
1344   return _at_mark_start.used;
1345 }
1346 
1347 size_t ZStatHeap::used_at_relocate_end() {
1348   return _at_relocate_end.used;
1349 }
1350 
1351 void ZStatHeap::print() {
<span class="line-added">1352   log_info(gc, heap)(&quot;Min Capacity: &quot;</span>
<span class="line-added">1353                      ZSIZE_FMT, ZSIZE_ARGS(_at_initialize.min_capacity));</span>
<span class="line-added">1354   log_info(gc, heap)(&quot;Max Capacity: &quot;</span>
<span class="line-added">1355                      ZSIZE_FMT, ZSIZE_ARGS(_at_initialize.max_capacity));</span>
<span class="line-added">1356   log_info(gc, heap)(&quot;Soft Max Capacity: &quot;</span>
<span class="line-added">1357                      ZSIZE_FMT, ZSIZE_ARGS(_at_mark_start.soft_max_capacity));</span>
<span class="line-added">1358 </span>
1359   ZStatTablePrinter table(10, 18);
1360   log_info(gc, heap)(&quot;%s&quot;, table()
1361                      .fill()
1362                      .center(&quot;Mark Start&quot;)
1363                      .center(&quot;Mark End&quot;)
1364                      .center(&quot;Relocate Start&quot;)
1365                      .center(&quot;Relocate End&quot;)
1366                      .center(&quot;High&quot;)
1367                      .center(&quot;Low&quot;)
1368                      .end());
1369   log_info(gc, heap)(&quot;%s&quot;, table()
1370                      .right(&quot;Capacity:&quot;)
<span class="line-modified">1371                      .left(ZTABLE_ARGS(_at_mark_start.capacity))</span>
<span class="line-modified">1372                      .left(ZTABLE_ARGS(_at_mark_end.capacity))</span>
<span class="line-modified">1373                      .left(ZTABLE_ARGS(_at_relocate_start.capacity))</span>
<span class="line-modified">1374                      .left(ZTABLE_ARGS(_at_relocate_end.capacity))</span>
<span class="line-modified">1375                      .left(ZTABLE_ARGS(_at_relocate_end.capacity_high))</span>
<span class="line-modified">1376                      .left(ZTABLE_ARGS(_at_relocate_end.capacity_low))</span>
1377                      .end());
1378   log_info(gc, heap)(&quot;%s&quot;, table()
1379                      .right(&quot;Reserve:&quot;)
<span class="line-modified">1380                      .left(ZTABLE_ARGS(_at_mark_start.reserve))</span>
<span class="line-modified">1381                      .left(ZTABLE_ARGS(_at_mark_end.reserve))</span>
<span class="line-modified">1382                      .left(ZTABLE_ARGS(_at_relocate_start.reserve))</span>
<span class="line-modified">1383                      .left(ZTABLE_ARGS(_at_relocate_end.reserve))</span>
<span class="line-modified">1384                      .left(ZTABLE_ARGS(_at_relocate_end.reserve_high))</span>
<span class="line-modified">1385                      .left(ZTABLE_ARGS(_at_relocate_end.reserve_low))</span>
1386                      .end());
1387   log_info(gc, heap)(&quot;%s&quot;, table()
1388                      .right(&quot;Free:&quot;)
<span class="line-modified">1389                      .left(ZTABLE_ARGS(_at_mark_start.free))</span>
<span class="line-modified">1390                      .left(ZTABLE_ARGS(_at_mark_end.free))</span>
<span class="line-modified">1391                      .left(ZTABLE_ARGS(_at_relocate_start.free))</span>
<span class="line-modified">1392                      .left(ZTABLE_ARGS(_at_relocate_end.free))</span>
<span class="line-modified">1393                      .left(ZTABLE_ARGS(_at_relocate_end.free_high))</span>
<span class="line-modified">1394                      .left(ZTABLE_ARGS(_at_relocate_end.free_low))</span>
1395                      .end());
1396   log_info(gc, heap)(&quot;%s&quot;, table()
1397                      .right(&quot;Used:&quot;)
<span class="line-modified">1398                      .left(ZTABLE_ARGS(_at_mark_start.used))</span>
<span class="line-modified">1399                      .left(ZTABLE_ARGS(_at_mark_end.used))</span>
<span class="line-modified">1400                      .left(ZTABLE_ARGS(_at_relocate_start.used))</span>
<span class="line-modified">1401                      .left(ZTABLE_ARGS(_at_relocate_end.used))</span>
<span class="line-modified">1402                      .left(ZTABLE_ARGS(_at_relocate_end.used_high))</span>
<span class="line-modified">1403                      .left(ZTABLE_ARGS(_at_relocate_end.used_low))</span>
1404                      .end());
1405   log_info(gc, heap)(&quot;%s&quot;, table()
1406                      .right(&quot;Live:&quot;)
<span class="line-modified">1407                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1408                      .left(ZTABLE_ARGS(_at_mark_end.live))</span>
<span class="line-modified">1409                      .left(ZTABLE_ARGS(_at_mark_end.live /* Same as at mark end */))</span>
<span class="line-modified">1410                      .left(ZTABLE_ARGS(_at_mark_end.live /* Same as at mark end */))</span>
<span class="line-modified">1411                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1412                      .left(ZTABLE_ARGS_NA)</span>
1413                      .end());
1414   log_info(gc, heap)(&quot;%s&quot;, table()
1415                      .right(&quot;Allocated:&quot;)
<span class="line-modified">1416                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1417                      .left(ZTABLE_ARGS(_at_mark_end.allocated))</span>
<span class="line-modified">1418                      .left(ZTABLE_ARGS(_at_relocate_start.allocated))</span>
<span class="line-modified">1419                      .left(ZTABLE_ARGS(_at_relocate_end.allocated))</span>
<span class="line-modified">1420                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1421                      .left(ZTABLE_ARGS_NA)</span>
1422                      .end());
1423   log_info(gc, heap)(&quot;%s&quot;, table()
1424                      .right(&quot;Garbage:&quot;)
<span class="line-modified">1425                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1426                      .left(ZTABLE_ARGS(_at_mark_end.garbage))</span>
<span class="line-modified">1427                      .left(ZTABLE_ARGS(_at_relocate_start.garbage))</span>
<span class="line-modified">1428                      .left(ZTABLE_ARGS(_at_relocate_end.garbage))</span>
<span class="line-modified">1429                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1430                      .left(ZTABLE_ARGS_NA)</span>
1431                      .end());
1432   log_info(gc, heap)(&quot;%s&quot;, table()
1433                      .right(&quot;Reclaimed:&quot;)
<span class="line-modified">1434                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1435                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1436                      .left(ZTABLE_ARGS(_at_relocate_start.reclaimed))</span>
<span class="line-modified">1437                      .left(ZTABLE_ARGS(_at_relocate_end.reclaimed))</span>
<span class="line-modified">1438                      .left(ZTABLE_ARGS_NA)</span>
<span class="line-modified">1439                      .left(ZTABLE_ARGS_NA)</span>
1440                      .end());
1441 }
</pre>
</td>
</tr>
</table>
<center><a href="zRuntimeWorkers.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="zStat.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>